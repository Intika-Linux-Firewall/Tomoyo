Index: include/linux/ccs_common.h
===================================================================
--- include/linux/ccs_common.h	(revision 1866)
+++ include/linux/ccs_common.h	(working copy)
@@ -213,6 +213,8 @@
 	uid_t uid;
 	gid_t gid;
 	ino_t ino;
+	mode_t mode;
+	dev_t rdev;
 };
 
 /* Structure for attribute checks in addition to pathname checks. */
Index: fs/tomoyo_cond.c
===================================================================
--- fs/tomoyo_cond.c	(revision 1866)
+++ fs/tomoyo_cond.c	(working copy)
@@ -460,60 +460,110 @@
 /* The list for "struct condition_list". */
 static LIST1_HEAD(condition_list);
 
-#define TASK_UID          0
-#define TASK_EUID         1
-#define TASK_SUID         2
-#define TASK_FSUID        3
-#define TASK_GID          4
-#define TASK_EGID         5
-#define TASK_SGID         6
-#define TASK_FSGID        7
-#define TASK_PID          8
-#define TASK_PPID         9
-#define PATH1_UID        10
-#define PATH1_GID        11
-#define PATH1_INO        12
-#define PATH1_PARENT_UID 13
-#define PATH1_PARENT_GID 14
-#define PATH1_PARENT_INO 15
-#define PATH2_PARENT_UID 16
-#define PATH2_PARENT_GID 17
-#define PATH2_PARENT_INO 18
-#define EXEC_ARGC        19
-#define EXEC_ENVC        20
-#define TASK_STATE_0     21
-#define TASK_STATE_1     22
-#define TASK_STATE_2     23
-#define MAX_KEYWORD      24
+#define TASK_UID             0
+#define TASK_EUID            1
+#define TASK_SUID            2
+#define TASK_FSUID           3
+#define TASK_GID             4
+#define TASK_EGID            5
+#define TASK_SGID            6
+#define TASK_FSGID           7
+#define TASK_PID             8
+#define TASK_PPID            9
+#define PATH1_UID           10
+#define PATH1_GID           11
+#define PATH1_INO           12
+#define PATH1_PARENT_UID    13
+#define PATH1_PARENT_GID    14
+#define PATH1_PARENT_INO    15
+#define PATH2_PARENT_UID    16
+#define PATH2_PARENT_GID    17
+#define PATH2_PARENT_INO    18
+#define PATH1_TYPE          19
+#define PATH1_DEV_MAJOR     20
+#define PATH1_DEV_MINOR     21
+#define PATH1_MODE          22
+#define PATH1_PARENT_MODE   23
+#define PATH2_PARENT_MODE   24
+#define EXEC_ARGC           25
+#define EXEC_ENVC           26
+#define TASK_STATE_0        27
+#define TASK_STATE_1        28
+#define TASK_STATE_2        29
+#define TYPE_SOCKET         30
+#define TYPE_SYMLINK        31
+#define TYPE_FILE           32
+#define TYPE_BLOCK_DEV      33
+#define TYPE_DIRECTORY      34
+#define TYPE_CHAR_DEV       35
+#define TYPE_FIFO           36
+#define MODE_SETUID         37
+#define MODE_SETGID         38
+#define MODE_STICKY         39
+#define MODE_OWNER_READ     40
+#define MODE_OWNER_WRITE    41
+#define MODE_OWNER_EXECUTE  42
+#define MODE_GROUP_READ     43
+#define MODE_GROUP_WRITE    44
+#define MODE_GROUP_EXECUTE  45
+#define MODE_OTHERS_READ    46
+#define MODE_OTHERS_WRITE   47
+#define MODE_OTHERS_EXECUTE 48
+#define MAX_KEYWORD         49
 
 static struct {
 	const char *keyword;
 	const int keyword_len; /* strlen(keyword) */
 } condition_control_keyword[MAX_KEYWORD] = {
-	[TASK_UID]         = { "task.uid",           8 },
-	[TASK_EUID]        = { "task.euid",          9 },
-	[TASK_SUID]        = { "task.suid",          9 },
-	[TASK_FSUID]       = { "task.fsuid",        10 },
-	[TASK_GID]         = { "task.gid",           8 },
-	[TASK_EGID]        = { "task.egid",          9 },
-	[TASK_SGID]        = { "task.sgid",          9 },
-	[TASK_FSGID]       = { "task.fsgid",        10 },
-	[TASK_PID]         = { "task.pid",           8 },
-	[TASK_PPID]        = { "task.ppid",          9 },
-	[PATH1_UID]        = { "path1.uid",          9 },
-	[PATH1_GID]        = { "path1.gid",          9 },
-	[PATH1_INO]        = { "path1.ino",          9 },
-	[PATH1_PARENT_UID] = { "path1.parent.uid",  16 },
-	[PATH1_PARENT_GID] = { "path1.parent.gid",  16 },
-	[PATH1_PARENT_INO] = { "path1.parent.ino",  16 },
-	[PATH2_PARENT_UID] = { "path2.parent.uid",  16 },
-	[PATH2_PARENT_GID] = { "path2.parent.gid",  16 },
-	[PATH2_PARENT_INO] = { "path2.parent.ino",  16 },
-	[EXEC_ARGC]        = { "exec.argc",          9 },
-	[EXEC_ENVC]        = { "exec.envc",          9 },
-	[TASK_STATE_0]     = { "task.state[0]",     13 },
-	[TASK_STATE_1]     = { "task.state[1]",     13 },
-	[TASK_STATE_2]     = { "task.state[2]",     13 },
+	[TASK_UID]            = { "task.uid",           8 },
+	[TASK_EUID]           = { "task.euid",          9 },
+	[TASK_SUID]           = { "task.suid",          9 },
+	[TASK_FSUID]          = { "task.fsuid",        10 },
+	[TASK_GID]            = { "task.gid",           8 },
+	[TASK_EGID]           = { "task.egid",          9 },
+	[TASK_SGID]           = { "task.sgid",          9 },
+	[TASK_FSGID]          = { "task.fsgid",        10 },
+	[TASK_PID]            = { "task.pid",           8 },
+	[TASK_PPID]           = { "task.ppid",          9 },
+	[PATH1_UID]           = { "path1.uid",          9 },
+	[PATH1_GID]           = { "path1.gid",          9 },
+	[PATH1_INO]           = { "path1.ino",          9 },
+	[PATH1_PARENT_UID]    = { "path1.parent.uid",  16 },
+	[PATH1_PARENT_GID]    = { "path1.parent.gid",  16 },
+	[PATH1_PARENT_INO]    = { "path1.parent.ino",  16 },
+	[PATH2_PARENT_UID]    = { "path2.parent.uid",  16 },
+	[PATH2_PARENT_GID]    = { "path2.parent.gid",  16 },
+	[PATH2_PARENT_INO]    = { "path2.parent.ino",  16 },
+	[PATH1_TYPE]          = { "path1.type",        10 }, /* S_IFMT   */
+	[PATH1_DEV_MAJOR]     = { "path1.major",       11 },
+	[PATH1_DEV_MINOR]     = { "path1.minor",       11 },
+	[PATH1_MODE]          = { "path1.mode",        10 },
+	[PATH1_PARENT_MODE]   = { "path1.parent.mode", 17 },
+	[PATH2_PARENT_MODE]   = { "path2.parent.mode", 17 },
+	[EXEC_ARGC]           = { "exec.argc",          9 },
+	[EXEC_ENVC]           = { "exec.envc",          9 },
+	[TASK_STATE_0]        = { "task.state[0]",     13 },
+	[TASK_STATE_1]        = { "task.state[1]",     13 },
+	[TASK_STATE_2]        = { "task.state[2]",     13 },
+	[TYPE_SOCKET]         = { "socket",             6 }, /* S_IFSOCK */
+	[TYPE_SYMLINK]        = { "symlink",            7 }, /* S_IFLNK  */
+	[TYPE_FILE]           = { "file",               4 }, /* S_IFREG  */
+	[TYPE_BLOCK_DEV]      = { "block",              5 }, /* S_IFBLK  */
+	[TYPE_DIRECTORY]      = { "directory",          9 }, /* S_IFDIR  */
+	[TYPE_CHAR_DEV]       = { "char",               4 }, /* S_IFCHR  */
+	[TYPE_FIFO]           = { "fifo",               4 }, /* S_IFIFO  */
+	[MODE_SETUID]         = { "setuid",             6 }, /* S_ISUID  */
+	[MODE_SETGID]         = { "setgid",             6 }, /* S_ISGID  */
+	[MODE_STICKY]         = { "sticky",             6 }, /* S_ISVTX  */
+	[MODE_OWNER_READ]     = { "user_read",          9 }, /* S_IRUSR  */
+	[MODE_OWNER_WRITE]    = { "user_write",        10 }, /* S_IWUSR  */
+	[MODE_OWNER_EXECUTE]  = { "user_execute",      12 }, /* S_IXUSR  */
+	[MODE_GROUP_READ]     = { "group_read",        10 }, /* S_IRGRP  */
+	[MODE_GROUP_WRITE]    = { "group_write",       11 }, /* S_IWGRP  */
+	[MODE_GROUP_EXECUTE]  = { "group_execute",     13 }, /* S_IXGRP  */
+	[MODE_OTHERS_READ]    = { "others_read",       11 }, /* S_IROTH  */
+	[MODE_OTHERS_WRITE]   = { "others_write",      12 }, /* S_IWOTH  */
+	[MODE_OTHERS_EXECUTE] = { "others_execute",    14 }, /* S_IXOTH  */
 };
 
 /**
@@ -942,6 +992,7 @@
 			obj->path1_stat.uid = stat.uid;
 			obj->path1_stat.gid = stat.gid;
 			obj->path1_stat.ino = stat.ino;
+			obj->path1_stat.rdev = stat.rdev;
 			obj->path1_valid = true;
 		}
 	}
@@ -955,6 +1006,7 @@
 			obj->path1_parent_stat.uid = stat.uid;
 			obj->path1_parent_stat.gid = stat.gid;
 			obj->path1_parent_stat.ino = stat.ino;
+			obj->path1_parent_stat.rdev = stat.rdev;
 			obj->path1_parent_valid = true;
 		}
 	}
@@ -971,6 +1023,7 @@
 				obj->path2_parent_stat.uid = stat.uid;
 				obj->path2_parent_stat.gid = stat.gid;
 				obj->path2_parent_stat.ino = stat.ino;
+				obj->path2_parent_stat.rdev = stat.rdev;
 				obj->path2_parent_valid = true;
 			}
 		}
@@ -1022,6 +1075,9 @@
 		const bool match = (header >> 16) & 1;
 		const u8 left = header >> 8;
 		const u8 right = header;
+		bool left_is_bitop = false;
+		bool right_is_bitop = false;
+		u8 j;
 		ptr++;
 		if ((left >= PATH1_UID && left < EXEC_ARGC) ||
 		    (right >= PATH1_UID && right < EXEC_ARGC)) {
@@ -1032,230 +1088,265 @@
 				obj->validate_done = true;
 			}
 		}
-		switch (left) {
-		case TASK_UID:
-			left_max = task->uid;
-			break;
-		case TASK_EUID:
-			left_max = task->euid;
-			break;
-		case TASK_SUID:
-			left_max = task->suid;
-			break;
-		case TASK_FSUID:
-			left_max = task->fsuid;
-			break;
-		case TASK_GID:
-			left_max = task->gid;
-			break;
-		case TASK_EGID:
-			left_max = task->egid;
-			break;
-		case TASK_SGID:
-			left_max = task->sgid;
-			break;
-		case TASK_FSGID:
-			left_max = task->fsgid;
-			break;
-		case TASK_PID:
-			left_max = sys_getpid();
-			break;
-		case TASK_PPID:
-			left_max = sys_getppid();
-			break;
-		case PATH1_UID:
-			if (!obj->path1_valid)
-				goto out;
-			left_max = obj->path1_stat.uid;
-			break;
-		case PATH1_GID:
-			if (!obj->path1_valid)
-				goto out;
-			left_max = obj->path1_stat.gid;
-			break;
-		case PATH1_INO:
-			if (!obj->path1_valid)
-				goto out;
-			left_max = obj->path1_stat.ino;
-			break;
-		case PATH1_PARENT_UID:
-			if (!obj->path1_parent_valid)
-				goto out;
-			left_max = obj->path1_parent_stat.uid;
-			break;
-		case PATH1_PARENT_GID:
-			if (!obj->path1_parent_valid)
-				goto out;
-			left_max = obj->path1_parent_stat.gid;
-			break;
-		case PATH1_PARENT_INO:
-			if (!obj->path1_parent_valid)
-				goto out;
-			left_max = obj->path1_parent_stat.ino;
-			break;
-		case PATH2_PARENT_UID:
-			if (!obj->path2_parent_valid)
-				goto out;
-			left_max = obj->path2_parent_stat.uid;
-			break;
-		case PATH2_PARENT_GID:
-			if (!obj->path2_parent_valid)
-				goto out;
-			left_max = obj->path2_parent_stat.gid;
-			break;
-		case PATH2_PARENT_INO:
-			if (!obj->path2_parent_valid)
-				goto out;
-			left_max = obj->path2_parent_stat.ino;
-			break;
-		case EXEC_ARGC:
-			if (!bprm)
-				goto out;
-			left_max = bprm->argc;
-			i++;
-			break;
-		case EXEC_ENVC:
-			if (!bprm)
-				goto out;
-			left_max = bprm->envc;
-			i++;
-			break;
-		case TASK_STATE_0:
-			left_max = (u8) (task->tomoyo_flags >> 24);
-			break;
-		case TASK_STATE_1:
-			left_max = (u8) (task->tomoyo_flags >> 16);
-			break;
-		case TASK_STATE_2:
-			left_max = (u8) (task->tomoyo_flags >> 8);
-			break;
-		case MAX_KEYWORD:
-			left_max = *ptr;
-			ptr++;
-			i++;
-			break;
-		case MAX_KEYWORD + 1:
-			left_min = *ptr;
-			ptr++;
-			left_max = *ptr;
-			ptr++;
-			i += 2;
-			break;
+		for (j = 0; j < 2; j++) {
+			const u8 index = j ? right : left;
+			unsigned long min_v = 0;
+			unsigned long max_v = 0;
+			bool is_bitop = false;
+			switch (index) {
+			case TASK_UID:
+				max_v = task->uid;
+				break;
+			case TASK_EUID:
+				max_v = task->euid;
+				break;
+			case TASK_SUID:
+				max_v = task->suid;
+				break;
+			case TASK_FSUID:
+				max_v = task->fsuid;
+				break;
+			case TASK_GID:
+				max_v = task->gid;
+				break;
+			case TASK_EGID:
+				max_v = task->egid;
+				break;
+			case TASK_SGID:
+				max_v = task->sgid;
+				break;
+			case TASK_FSGID:
+				max_v = task->fsgid;
+				break;
+			case TASK_PID:
+				max_v = sys_getpid();
+				break;
+			case TASK_PPID:
+				max_v = sys_getppid();
+				break;
+			case PATH1_UID:
+				if (!obj->path1_valid)
+					goto out;
+				max_v = obj->path1_stat.uid;
+				break;
+			case PATH1_GID:
+				if (!obj->path1_valid)
+					goto out;
+				max_v = obj->path1_stat.gid;
+				break;
+			case PATH1_INO:
+				if (!obj->path1_valid)
+					goto out;
+				max_v = obj->path1_stat.ino;
+				break;
+			case PATH1_PARENT_UID:
+				if (!obj->path1_parent_valid)
+					goto out;
+				max_v = obj->path1_parent_stat.uid;
+				break;
+			case PATH1_PARENT_GID:
+				if (!obj->path1_parent_valid)
+					goto out;
+				max_v = obj->path1_parent_stat.gid;
+				break;
+			case PATH1_PARENT_INO:
+				if (!obj->path1_parent_valid)
+					goto out;
+				max_v = obj->path1_parent_stat.ino;
+				break;
+			case PATH2_PARENT_UID:
+				if (!obj->path2_parent_valid)
+					goto out;
+				max_v = obj->path2_parent_stat.uid;
+				break;
+			case PATH2_PARENT_GID:
+				if (!obj->path2_parent_valid)
+					goto out;
+				max_v = obj->path2_parent_stat.gid;
+				break;
+			case PATH2_PARENT_INO:
+				if (!obj->path2_parent_valid)
+					goto out;
+				max_v = obj->path2_parent_stat.ino;
+				break;
+			case PATH1_TYPE:
+				if (!obj->path1_valid)
+					goto out;
+				max_v = obj->path1_stat.mode & S_IFMT;
+				break;
+			case PATH1_DEV_MAJOR:
+				if (!obj->path1_valid)
+					goto out;
+				max_v = MAJOR(obj->path1_stat.rdev);
+				break;
+			case PATH1_DEV_MINOR:
+				if (!obj->path1_valid)
+					goto out;
+				max_v = MINOR(obj->path1_stat.rdev);
+				break;
+			case PATH1_MODE:
+				if (!obj->path1_valid)
+					goto out;
+				max_v = obj->path1_stat.mode & S_IALLUGO;
+				break;
+			case PATH1_PARENT_MODE:
+				if (!obj->path1_parent_valid)
+					goto out;
+				max_v = obj->path1_parent_stat.mode & S_IALLUGO;
+				break;
+			case PATH2_PARENT_MODE:
+				if (!obj->path2_parent_valid)
+					goto out;
+				max_v = obj->path2_parent_stat.mode & S_IALLUGO;
+				break;
+			case TYPE_SOCKET:
+				max_v = S_IFSOCK;
+				break;
+			case TYPE_SYMLINK:
+				max_v = S_IFLNK;
+				break;
+			case TYPE_FILE:
+				max_v = S_IFREG;
+				break;
+			case TYPE_BLOCK_DEV:
+				max_v = S_IFBLK;
+				break;
+			case TYPE_DIRECTORY:
+				max_v = S_IFDIR;
+				break;
+			case TYPE_CHAR_DEV:
+				max_v = S_IFCHR;
+				break;
+			case TYPE_FIFO:
+				max_v = S_IFIFO;
+				break;
+			case MODE_SETUID:
+				max_v = S_ISUID;
+				is_bitop = true;
+				break;
+			case MODE_SETGID:
+				max_v = S_ISGID;
+				is_bitop = true;
+				break;
+			case MODE_STICKY:
+				max_v = S_ISVTX;
+				is_bitop = true;
+				break;
+			case MODE_OWNER_READ:
+				max_v = S_IRUSR;
+				is_bitop = true;
+				break;
+			case MODE_OWNER_WRITE:
+				max_v = S_IWUSR;
+				is_bitop = true;
+				break;
+			case MODE_OWNER_EXECUTE:
+				max_v = S_IXUSR;
+				is_bitop = true;
+				break;
+			case MODE_GROUP_READ:
+				max_v = S_IRGRP;
+				is_bitop = true;
+				break;
+			case MODE_GROUP_WRITE:
+				max_v = S_IWGRP;
+				is_bitop = true;
+				break;
+			case MODE_GROUP_EXECUTE:
+				max_v = S_IXGRP;
+				is_bitop = true;
+				break;
+			case MODE_OTHERS_READ:
+				max_v = S_IROTH;
+				is_bitop = true;
+				break;
+			case MODE_OTHERS_WRITE:
+				max_v = S_IWOTH;
+				is_bitop = true;
+				break;
+			case MODE_OTHERS_EXECUTE:
+				max_v = S_IXOTH;
+				is_bitop = true;
+				break;
+			case EXEC_ARGC:
+				if (!bprm)
+					goto out;
+				max_v = bprm->argc;
+				i++;
+				break;
+			case EXEC_ENVC:
+				if (!bprm)
+					goto out;
+				max_v = bprm->envc;
+				i++;
+				break;
+			case TASK_STATE_0:
+				max_v = (u8) (task->tomoyo_flags >> 24);
+				break;
+			case TASK_STATE_1:
+				max_v = (u8) (task->tomoyo_flags >> 16);
+				break;
+			case TASK_STATE_2:
+				max_v = (u8) (task->tomoyo_flags >> 8);
+				break;
+			case MAX_KEYWORD:
+				max_v = *ptr;
+				ptr++;
+				i++;
+				break;
+			case MAX_KEYWORD + 1:
+				min_v = *ptr;
+				ptr++;
+				max_v = *ptr;
+				ptr++;
+				i += 2;
+				break;
+			}
+			if (index != MAX_KEYWORD + 1)
+				min_v = max_v;
+			if (j) {
+				right_max = max_v;
+				right_min = min_v;
+				right_is_bitop = is_bitop;
+			} else {
+				left_max = max_v;
+				left_min = min_v;
+				left_is_bitop = is_bitop;
+			}
 		}
-		if (left != MAX_KEYWORD + 1)
-			left_min = left_max;
-		switch (right) {
-		case TASK_UID:
-			right_max = task->uid;
-			break;
-		case TASK_EUID:
-			right_max = task->euid;
-			break;
-		case TASK_SUID:
-			right_max = task->suid;
-			break;
-		case TASK_FSUID:
-			right_max = task->fsuid;
-			break;
-		case TASK_GID:
-			right_max = task->gid;
-			break;
-		case TASK_EGID:
-			right_max = task->egid;
-			break;
-		case TASK_SGID:
-			right_max = task->sgid;
-			break;
-		case TASK_FSGID:
-			right_max = task->fsgid;
-			break;
-		case TASK_PID:
-			right_max = sys_getpid();
-			break;
-		case TASK_PPID:
-			right_max = sys_getppid();
-			break;
-		case PATH1_UID:
-			if (!obj->path1_valid)
-				goto out;
-			right_max = obj->path1_stat.uid;
-			break;
-		case PATH1_GID:
-			if (!obj->path1_valid)
-				goto out;
-			right_max = obj->path1_stat.gid;
-			break;
-		case PATH1_INO:
-			if (!obj->path1_valid)
-				goto out;
-			right_max = obj->path1_stat.ino;
-			break;
-		case PATH1_PARENT_UID:
-			if (!obj->path1_parent_valid)
-				goto out;
-			right_max = obj->path1_parent_stat.uid;
-			break;
-		case PATH1_PARENT_GID:
-			if (!obj->path1_parent_valid)
-				goto out;
-			right_max = obj->path1_parent_stat.gid;
-			break;
-		case PATH1_PARENT_INO:
-			if (!obj->path1_parent_valid)
-				goto out;
-			right_max = obj->path1_parent_stat.ino;
-			break;
-		case PATH2_PARENT_UID:
-			if (!obj->path2_parent_valid)
-				goto out;
-			right_max = obj->path2_parent_stat.uid;
-			break;
-		case PATH2_PARENT_GID:
-			if (!obj->path2_parent_valid)
-				goto out;
-			right_max = obj->path2_parent_stat.gid;
-			break;
-		case PATH2_PARENT_INO:
-			if (!obj->path2_parent_valid)
-				goto out;
-			right_max = obj->path2_parent_stat.ino;
-			break;
-		case EXEC_ARGC:
-			if (!bprm)
-				goto out;
-			right_max = bprm->argc;
-			i++;
-			break;
-		case EXEC_ENVC:
-			if (!bprm)
-				goto out;
-			right_max = bprm->envc;
-			i++;
-			break;
-		case TASK_STATE_0:
-			right_max = (u8) (task->tomoyo_flags >> 24);
-			break;
-		case TASK_STATE_1:
-			right_max = (u8) (task->tomoyo_flags >> 16);
-			break;
-		case TASK_STATE_2:
-			right_max = (u8) (task->tomoyo_flags >> 8);
-			break;
-		case MAX_KEYWORD:
-			right_max = *ptr;
-			ptr++;
-			i++;
-			break;
-		case MAX_KEYWORD + 1:
-			right_min = *ptr;
-			ptr++;
-			right_max = *ptr;
-			ptr++;
-			i += 2;
-			break;
+		/*
+		 * Bit operation is valid only when counterpart value
+		 * represents permission.
+		 */
+		if (left_is_bitop && right_is_bitop)
+			goto out;
+		if (left_is_bitop) {
+			if (right == PATH1_MODE || right == PATH1_PARENT_MODE
+			    || right == PATH2_PARENT_MODE) {
+				if (match) {
+					if ((right_max & left_max))
+						continue;
+				} else {
+					if (!(right_max & left_max))
+						continue;
+				}
+			}
+			goto out;
 		}
-		if (right != MAX_KEYWORD + 1)
-			right_min = right_max;
+		if (right_is_bitop) {
+			if (left == PATH1_MODE || left == PATH1_PARENT_MODE
+			    || left == PATH2_PARENT_MODE) {
+				if (match) {
+					if ((left_max & right_max))
+						continue;
+				} else {
+					if (!(left_max & right_max))
+						continue;
+				}
+			}
+			goto out;
+		}
+		/* Normal value range comparison. */
 		if (match) {
 			if (left_min <= right_max && left_max >= right_min)
 				continue;
