Index: trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c	(working copy)
@@ -37,45 +37,50 @@
 {
 	const struct ccs_reserved *p1 = container_of(a, typeof(*p1), head);
 	const struct ccs_reserved *p2 = container_of(b, typeof(*p2), head);
-	return p1->min_port == p2->min_port && p1->max_port == p2->max_port;
+	return ccs_same_number_union(&p1->port, &p2->port);
 }
 
 /**
- * ccs_update_reserved_entry - Update "struct ccs_reserved" list.
+ * ccs_write_reserved_port - Write "struct ccs_reserved" list.
  *
- * @min_port:  Start of port number range.
- * @max_port:  End of port number range.
- * @is_delete: True if it is a delete request.
+ * @param: Pointer to "struct ccs_acl_param".
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_update_reserved_entry(const u16 min_port, const u16 max_port,
-				     const bool is_delete)
+int ccs_write_reserved_port(struct ccs_acl_param *param)
 {
-	struct ccs_reserved *ptr;
-	struct ccs_reserved e = {
-		.min_port = min_port,
-		.max_port = max_port
-	};
-	const int error =
-		ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_RESERVEDPORT],
-				  ccs_same_reserved);
+	struct ccs_reserved e = { };
+	struct ccs_policy_namespace *ns = param->ns;
+	int error;
 	u8 *tmp;
+	if (param->data[0] == '@' || !ccs_parse_number_union(param, &e.port) ||
+	    e.port.values[1] > 65535 || param->data[0])
+		return -EINVAL;
+	param->list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+	error = ccs_update_policy(&e.head, sizeof(e), param,
+				  ccs_same_reserved);
+	/*
+	 * ccs_put_number_union() is not needed because param->data[0] != '@'.
+	 */
 	if (error)
 		return error;
 	tmp = kzalloc(sizeof(ccs_reserved_port_map), CCS_GFP_FLAGS);
 	if (!tmp)
 		return -ENOMEM;
-	list_for_each_entry_srcu(ptr, &ccs_policy_list[CCS_ID_RESERVEDPORT],
-				 head.list, &ccs_ss) {
-		unsigned int port;
-		if (ptr->head.is_deleted)
-			continue;
-		for (port = ptr->min_port; port <= ptr->max_port; port++)
-			tmp[port >> 3] |= 1 << (port & 7);
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		struct ccs_reserved *ptr;
+		struct list_head *list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
+			unsigned int port;
+			if (ptr->head.is_deleted)
+				continue;
+			for (port = ptr->port.values[0];
+			     port <= ptr->port.values[1]; port++)
+				tmp[port >> 3] |= 1 << (port & 7);
+		}
 	}
 	memmove(ccs_reserved_port_map, tmp, sizeof(ccs_reserved_port_map));
 	kfree(tmp);
@@ -86,33 +91,3 @@
 	ccsecurity_ops.lport_reserved = __ccs_lport_reserved;
 	return 0;
 }
-
-/**
- * ccs_write_reserved_port - Write "struct ccs_reserved" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-int ccs_write_reserved_port(char *data, const bool is_delete)
-{
-	unsigned int from;
-	unsigned int to;
-	if (strchr(data, ' '))
-		goto out;
-	switch (sscanf(data, "%u-%u", &from, &to)) {
-	case 1:
-		to = from;
-		/* fall through */
-	case 2:
-		if (from <= to && to < 65536)
-			return ccs_update_reserved_entry(from, to,
-							 is_delete);
-		break;
-	}
-out:
-	return -EINVAL;
-}
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/audit.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/audit.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/audit.c	(working copy)
@@ -336,6 +336,7 @@
 {
 	const struct ccs_domain_info *domain;
 	char *buf;
+	const char *cp;
 	const struct ccs_acl_info *acl = r->matched_acl;
 	r->matched_acl = NULL;
 	if (!acl || !acl->cond || !acl->cond->transit)
@@ -349,8 +350,12 @@
 			return;
 	}
 	domain = ccs_current_domain();
-	snprintf(buf, CCS_EXEC_TMPSIZE - 1, "%s %s", domain->domainname->name,
-		 acl->cond->transit->name);
+	cp = acl->cond->transit->name;
+	if (*cp == '/')
+		snprintf(buf, CCS_EXEC_TMPSIZE - 1, "%s %s",
+			 domain->domainname->name, cp);
+	else
+		strncpy(buf, cp, CCS_EXEC_TMPSIZE - 1);
 	if (!ccs_assign_domain(buf, r->profile, domain->group, true))
 		ccs_transition_failed(buf);
 	kfree(buf);
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c	(working copy)
@@ -8,25 +8,12 @@
 
 #include "internal.h"
 
-/*
- * The global domains referred by "use_group" keyword.
- *
- * Although "use_group" needs only "struct list_head acl_info_list[2]",
- * we define structure for "use_group" as "struct ccs_domain_info" in order to
- * use common code.
- */
-struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
-
 /* The initial domain. */
 struct ccs_domain_info ccs_kernel_domain;
 
 /* The list for "struct ccs_domain_info". */
 LIST_HEAD(ccs_domain_list);
 
-/* List of policy. */
-struct list_head ccs_policy_list[CCS_MAX_POLICY];
-/* List of "struct ccs_group". */
-struct list_head ccs_group_list[CCS_MAX_GROUP];
 /* List of "struct ccs_condition" and "struct ccs_ipv6addr". */
 struct list_head ccs_shared_list[CCS_MAX_LIST];
 
@@ -35,8 +22,7 @@
  *
  * @new_entry:       Pointer to "struct ccs_acl_info".
  * @size:            Size of @new_entry in bytes.
- * @is_delete:       True if it is a delete request.
- * @list:            Pointer to "struct list_head".
+ * @param:           Pointer to "struct ccs_acl_param".
  * @check_duplicate: Callback function to find duplicated entry.
  *
  * Returns 0 on success, negative value otherwise.
@@ -44,22 +30,23 @@
  * Caller holds ccs_read_lock().
  */
 int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      bool is_delete, struct list_head *list,
+		      struct ccs_acl_param *param,
 		      bool (*check_duplicate) (const struct ccs_acl_head *,
 					       const struct ccs_acl_head *))
 {
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	struct ccs_acl_head *entry;
+	struct list_head *list = param->list;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return -ENOMEM;
 	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
 		if (!check_duplicate(entry, new_entry))
 			continue;
-		entry->is_deleted = is_delete;
+		entry->is_deleted = param->is_delete;
 		error = 0;
 		break;
 	}
-	if (error && !is_delete) {
+	if (error && !param->is_delete) {
 		entry = ccs_commit_ok(new_entry, size);
 		if (entry) {
 			list_add_tail_rcu(&entry->list, list);
@@ -105,23 +92,22 @@
 					       struct ccs_acl_info *,
 					       const bool))
 {
-	struct ccs_domain_info * const domain = param->domain;
 	const bool is_delete = param->is_delete;
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	struct ccs_acl_info *entry;
 	const u8 type = new_entry->type;
-	const u8 i = type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
-		type == CCS_TYPE_DENIED_EXECUTE_HANDLER ||
-		type == CCS_TYPE_AUTO_TASK_ACL;
+	struct list_head * const list = &param->list
+		[type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
+		 type == CCS_TYPE_DENIED_EXECUTE_HANDLER ||
+		 type == CCS_TYPE_AUTO_TASK_ACL];
 	if (param->data[0]) {
-		new_entry->cond = ccs_get_condition(param->data);
+		new_entry->cond = ccs_get_condition(param);
 		if (!new_entry->cond)
 			return -EINVAL;
 	}
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list_for_each_entry_srcu(entry, &domain->acl_info_list[i], list,
-				 &ccs_ss) {
+	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
 		if (!ccs_same_acl_head(entry, new_entry) ||
 		    !check_duplicate(entry, new_entry))
 			continue;
@@ -136,8 +122,7 @@
 	if (error && !is_delete) {
 		entry = ccs_commit_ok(new_entry, size);
 		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &domain->acl_info_list[i]);
+			list_add_tail_rcu(&entry->list, list);
 			error = 0;
 		}
 	}
@@ -166,9 +151,9 @@
 	struct ccs_acl_info *ptr;
 	bool retried = false;
 	const u8 i = !check_entry;
+	const struct list_head *list = &domain->acl_info_list[i];
 retry:
-	list_for_each_entry_srcu(ptr, &domain->acl_info_list[i], list,
-				 &ccs_ss) {
+	list_for_each_entry_srcu(ptr, list, list, &ccs_ss) {
 		if (ptr->is_deleted)
 			continue;
 		if (ptr->type != r->param_type)
@@ -183,7 +168,7 @@
 	}
 	if (!retried) {
 		retried = true;
-		domain = &ccs_acl_group[domain->group];
+		list = &r->ns->acl_group[domain->group][i];
 		goto retry;
 	}
 	r->granted = false;
@@ -210,22 +195,27 @@
 }
 
 /**
- * ccs_update_transition_control_entry - Update "struct ccs_transition_control" list.
+ * ccs_write_transition_control - Write "struct ccs_transition_control" list.
  *
- * @domainname: The name of domain. Maybe NULL.
- * @program:    The name of program. Maybe NULL.
- * @type:       Type of transition.
- * @is_delete:  True if it is a delete request.
+ * @param: Pointer to "struct ccs_acl_param".
+ * @type:  Type of this entry.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_transition_control_entry(const char *domainname,
-					       const char *program,
-					       const u8 type,
-					       const bool is_delete)
+int ccs_write_transition_control(struct ccs_acl_param *param, const u8 type)
 {
 	struct ccs_transition_control e = { .type = type };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
+	char *program = param->data;
+	char *domainname = strstr(program, " from ");
+	if (domainname) {
+		*domainname = '\0';
+		domainname += 6;
+	} else if (type == CCS_TRANSITION_CONTROL_NO_KEEP ||
+		   type == CCS_TRANSITION_CONTROL_KEEP) {
+		domainname = program;
+		program = NULL;
+	}
 	if (program && strcmp(program, "any")) {
 		if (!ccs_correct_path(program))
 			return -EINVAL;
@@ -243,8 +233,8 @@
 		if (!e.domainname)
 			goto out;
 	}
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_TRANSITION_CONTROL],
+	param->list = &param->ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+	error = ccs_update_policy(&e.head, sizeof(e), param,
 				  ccs_same_transition_control);
 out:
 	ccs_put_name(e.domainname);
@@ -253,31 +243,6 @@
 }
 
 /**
- * ccs_write_transition_control - Write "struct ccs_transition_control" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- * @type:      Type of this entry.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_transition_control(char *data, const bool is_delete,
-				 const u8 type)
-{
-	char *domainname = strstr(data, " from ");
-	if (domainname) {
-		*domainname = '\0';
-		domainname += 6;
-	} else if (type == CCS_TRANSITION_CONTROL_NO_KEEP ||
-		   type == CCS_TRANSITION_CONTROL_KEEP) {
-		domainname = data;
-		data = NULL;
-	}
-	return ccs_update_transition_control_entry(domainname, data, type,
-						   is_delete);
-}
-
-/**
  * ccs_last_word - Get last component of a domainname.
  *
  * @name: Domainname to check.
@@ -295,6 +260,7 @@
 /**
  * ccs_transition_type - Get domain transition type.
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @domainname: The name of domain.
  * @program:    The name of program.
  *
@@ -304,17 +270,18 @@
  *
  * Caller holds ccs_read_lock().
  */
-static u8 ccs_transition_type(const struct ccs_path_info *domainname,
+static u8 ccs_transition_type(const struct ccs_policy_namespace *ns,
+			      const struct ccs_path_info *domainname,
 			      const struct ccs_path_info *program)
 {
 	const struct ccs_transition_control *ptr;
 	const char *last_name = ccs_last_word(domainname->name);
 	u8 type;
 	for (type = 0; type < CCS_MAX_TRANSITION_TYPE; type++) {
+		const struct list_head *list;
 next:
-		list_for_each_entry_srcu(ptr, &ccs_policy_list
-					 [CCS_ID_TRANSITION_CONTROL],
-					 head.list, &ccs_ss) {
+		list = &ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 			if (ptr->head.is_deleted || ptr->type != type)
 				continue;
 			if (ptr->domainname) {
@@ -333,6 +300,14 @@
 			}
 			if (ptr->program && ccs_pathcmp(ptr->program, program))
 				continue;
+			if (type == CCS_TRANSITION_CONTROL_NO_NAMESPACE) {
+				/*
+				 * Do not check for move_namespace if
+				 * no_move_namespace matched.
+				 */
+				type = CCS_TRANSITION_CONTROL_NO_INITIALIZE;
+				goto next;
+			}
 			if (type == CCS_TRANSITION_CONTROL_NO_INITIALIZE) {
 				/*
 				 * Do not check for initialize_domain if
@@ -366,20 +341,18 @@
 }
 
 /**
- * ccs_update_aggregator_entry - Update "struct ccs_aggregator" list.
+ * ccs_write_aggregator - Write "struct ccs_aggregator" list.
  *
- * @original_name:   The original program's name.
- * @aggregated_name: The aggregated program's name.
- * @is_delete:       True if it is a delete request.
+ * @param: Pointer to "struct ccs_acl_param".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_aggregator_entry(const char *original_name,
-				       const char *aggregated_name,
-				       const bool is_delete)
+int ccs_write_aggregator(struct ccs_acl_param *param)
 {
 	struct ccs_aggregator e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
+	const char *original_name = ccs_read_token(param);
+	const char *aggregated_name = ccs_read_token(param);
 	if (!ccs_correct_word(original_name) ||
 	    !ccs_correct_path(aggregated_name))
 		return -EINVAL;
@@ -388,8 +361,8 @@
 	if (!e.original_name || !e.aggregated_name ||
 	    e.aggregated_name->is_patterned) /* No patterns allowed. */
 		goto out;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_AGGREGATOR],
+	param->list = &param->ns->policy_list[CCS_ID_AGGREGATOR];
+	error = ccs_update_policy(&e.head, sizeof(e), param,
 				  ccs_same_aggregator);
 out:
 	ccs_put_name(e.original_name);
@@ -397,27 +370,94 @@
 	return error;
 }
 
+/* Domain create handler. */
+
 /**
- * ccs_write_aggregator - Write "struct ccs_aggregator" list.
+ * ccs_find_namespace - Find specified namespace.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
+ * @name: Name of namespace to find.
+ * @len:  Length of @name.
  *
- * Returns 0 on success, negative value otherwise.
+ * Returns pointer to "struct ccs_policy_namespace" if found, NULL otherwise.
+ *
+ * Caller holds ccs_read_lock().
  */
-int ccs_write_aggregator(char *data, const bool is_delete)
+static struct ccs_policy_namespace *ccs_find_namespace(const char *name,
+						       const unsigned int len)
 {
-	char *w[2];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	return ccs_update_aggregator_entry(w[0], w[1], is_delete);
+	struct ccs_policy_namespace *ns;
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		if (strncmp(name, ns->name, len) ||
+		    (name[len] && name[len] != ' '))
+			continue;
+		return ns;
+	}
+	return NULL;
 }
 
-/* Domain create handler. */
 
 /**
- * ccs_assign_domain - Create a domain.
+ * ccs_assign_namespace - Create a new namespace.
  *
+ * @domainname: Name of namespace to create.
+ *
+ * Returns pointer to "struct ccs_policy_namespace" on success, NULL otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+struct ccs_policy_namespace *ccs_assign_namespace(const char *domainname)
+{
+	struct ccs_policy_namespace *ptr;
+	struct ccs_policy_namespace *entry;
+	const char *cp = domainname;
+	unsigned int len = 0;
+	while (*cp && *cp++ != ' ')
+		len++;
+	ptr = ccs_find_namespace(domainname, len);
+	if (ptr)
+		return ptr;
+	if (len >= CCS_EXEC_TMPSIZE - 10 || !ccs_domain_def(domainname))
+		return NULL;
+	entry = kzalloc(sizeof(*entry) + len + 1, CCS_GFP_FLAGS);
+	if (!entry)
+		return NULL;
+	if (mutex_lock_interruptible(&ccs_policy_lock))
+		goto out;
+	ptr = ccs_find_namespace(domainname, len);
+	if (!ptr && ccs_memory_ok(entry, sizeof(*entry) + len + 1)) {
+		char *name = (char *) (entry + 1);
+		ptr = entry;
+		memmove(name, domainname, len);
+		name[len] = '\0';
+		entry->name = name;
+		ccs_init_policy_namespace(entry);
+		entry = NULL;
+	}
+	mutex_unlock(&ccs_policy_lock);
+out:
+	kfree(entry);
+	return entry;
+}
+
+/**
+ * ccs_namespace_jump - Check for namespace jump.
+ *
+ * @domainname: Name of domain.
+ *
+ * Returns true if namespace differs, false otherwise.
+ */
+static bool ccs_namespace_jump(const char *domainname)
+{
+	const char *namespace = ccs_current_namespace()->name;
+	const int len = strlen(namespace);
+	return strncmp(domainname, namespace, len) ||
+		(domainname[len] && domainname[len] != ' ');
+}
+
+/**
+ * ccs_assign_domain - Create a domain or a namespace.
+ *
  * @domainname: The name of domain.
  * @profile:    Profile number to assign if the domain was newly created.
  * @group:      Group number to assign if the domain was newly created.
@@ -432,13 +472,26 @@
 					  const bool transit)
 {
 	struct ccs_domain_info e = { };
-	struct ccs_domain_info *entry = ccs_find_domain(domainname);
+	struct ccs_domain_info *entry;
 	bool created = false;
-	if (entry)
-		goto out;
 	if (strlen(domainname) >= CCS_EXEC_TMPSIZE - 10 ||
 	    !ccs_correct_domain(domainname))
 		return NULL;
+	entry = ccs_find_domain(domainname);
+	if (entry)
+		goto out;
+	if (transit && ccs_namespace_jump(domainname))
+		/*
+		 * Namespace jump is requested but target domain was not found.
+		 * Don't create target domains upon namespace jump in order to
+		 * avoid inheriting "use_profile" and "use_group" information,
+		 * for definition of profiles and acl_groups may differ across
+		 * namespaces.
+		 */
+		return NULL;
+	e.ns = ccs_assign_namespace(domainname);
+	if (!e.ns)
+		return NULL;
 	e.profile = profile;
 	e.group = group;
 	e.domainname = ccs_get_name(domainname);
@@ -519,10 +572,10 @@
 		}
 	} else {
 		struct ccs_aggregator *ptr;
+		struct list_head *list =
+			&r->ns->policy_list[CCS_ID_AGGREGATOR];
 		/* Check 'aggregator' directive. */
-		list_for_each_entry_srcu(ptr,
-					 &ccs_policy_list[CCS_ID_AGGREGATOR],
-					 head.list, &ccs_ss) {
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 			if (ptr->head.is_deleted ||
 			    !ccs_path_matches_pattern(&rn, ptr->original_name))
 				continue;
@@ -555,10 +608,14 @@
 	}
 
 	/* Calculate domain to transit to. */
-	switch (ccs_transition_type(old_domain->domainname, &rn)) {
+	switch (ccs_transition_type(r->ns, old_domain->domainname, &rn)) {
+	case CCS_TRANSITION_CONTROL_NAMESPACE:
+		/* Transit to the root of specified namespace. */
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "<%s>", rn.name);
+		break;
 	case CCS_TRANSITION_CONTROL_INITIALIZE:
-		/* Transit to the child of ccs_kernel_domain domain. */
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, CCS_ROOT_NAME " " "%s",
+		/* Transit to the child of current namespace's root. */
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%s %s", r->ns->name,
 			 rn.name);
 		break;
 	case CCS_TRANSITION_CONTROL_KEEP:
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/memory.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/memory.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/memory.c	(working copy)
@@ -109,15 +109,17 @@
 /**
  * ccs_get_group - Allocate memory for "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group".
  *
- * @group_name: The name of address group.
- * @idx:        Index number.
+ * @param: Pointer to "struct ccs_acl_param".
+ * @idx:   Index number.
  *
  * Returns pointer to "struct ccs_group" on success, NULL otherwise.
  */
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx)
+struct ccs_group *ccs_get_group(struct ccs_acl_param *param, const u8 idx)
 {
 	struct ccs_group e = { };
 	struct ccs_group *group = NULL;
+	struct list_head *list;
+	const char *group_name = ccs_read_token(param);
 	bool found = false;
 	if (!ccs_correct_word(group_name) || idx >= CCS_MAX_GROUP)
 		return NULL;
@@ -126,7 +128,8 @@
 		return NULL;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list_for_each_entry(group, &ccs_group_list[idx], head.list) {
+	list = &param->ns->group_list[idx];
+	list_for_each_entry(group, list, head.list) {
 		if (e.group_name != group->group_name)
 			continue;
 		atomic_inc(&group->head.users);
@@ -138,8 +141,7 @@
 		if (entry) {
 			INIT_LIST_HEAD(&entry->member_list);
 			atomic_set(&entry->head.users, 1);
-			list_add_tail_rcu(&entry->head.list,
-					  &ccs_group_list[idx]);
+			list_add_tail_rcu(&entry->head.list, list);
 			group = entry;
 			found = true;
 		}
@@ -400,6 +402,9 @@
 
 #endif
 
+/* Initial namespace.*/
+struct ccs_policy_namespace ccs_kernel_namespace;
+
 /**
  * ccs_mm_init - Initialize mm related code.
  *
@@ -410,10 +415,9 @@
 	int idx;
 	for (idx = 0; idx < CCS_MAX_HASH; idx++)
 		INIT_LIST_HEAD(&ccs_name_list[idx]);
-	for (idx = 0; idx < CCS_MAX_ACL_GROUPS; idx++) {
-		INIT_LIST_HEAD(&ccs_acl_group[idx].acl_info_list[0]);
-		INIT_LIST_HEAD(&ccs_acl_group[idx].acl_info_list[1]);
-	}
+	ccs_kernel_namespace.name = "<kernel>";
+	ccs_init_policy_namespace(&ccs_kernel_namespace);
+	ccs_kernel_domain.ns = &ccs_kernel_namespace;
 	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list[0]);
 	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list[1]);
 #ifdef CONFIG_CCSECURITY_USE_EXTERNAL_TASK_SECURITY
@@ -425,27 +429,28 @@
 	ccsecurity_ops.alloc_task_security = __ccs_alloc_task_security;
 	ccsecurity_ops.free_task_security = __ccs_free_task_security;
 #endif
-	ccs_kernel_domain.domainname = ccs_get_name(CCS_ROOT_NAME);
+	ccs_kernel_domain.domainname = ccs_get_name("<kernel>");
 	list_add_tail_rcu(&ccs_kernel_domain.list, &ccs_domain_list);
+#ifdef CONFIG_CCSECURITY_BUILTIN_INITIALIZERS
 	idx = ccs_read_lock();
-	if (ccs_find_domain(CCS_ROOT_NAME) != &ccs_kernel_domain)
-		panic("Can't register ccs_kernel_domain");
-#ifdef CONFIG_CCSECURITY_BUILTIN_INITIALIZERS
 	{
 		/* Load built-in policy. */
+		struct ccs_acl_param param = { };
 		static char ccs_builtin_initializers[] __initdata
 			= CONFIG_CCSECURITY_BUILTIN_INITIALIZERS;
 		char *cp = ccs_builtin_initializers;
 		ccs_normalize_line(cp);
+		param.ns = &ccs_kernel_namespace;
 		while (cp && *cp) {
 			char *cp2 = strchr(cp, ' ');
 			if (cp2)
 				*cp2++ = '\0';
-			ccs_write_transition_control(cp, false,
+			param.data = cp;
+			ccs_write_transition_control(&param,
 				     CCS_TRANSITION_CONTROL_INITIALIZE);
 			cp = cp2;
 		}
 	}
+	ccs_read_unlock(idx);
 #endif
-	ccs_read_unlock(idx);
 }
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/util.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/util.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/util.c	(working copy)
@@ -247,20 +247,24 @@
 /**
  * ccs_parse_name_union - Parse a ccs_name_union.
  *
- * @filename: Name or name group.
- * @ptr:      Pointer to "struct ccs_name_union".
+ * @param: Pointer to "struct ccs_acl_param".
+ * @ptr:   Pointer to "struct ccs_name_union".
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr)
+bool ccs_parse_name_union(struct ccs_acl_param *param,
+			  struct ccs_name_union *ptr)
 {
-	if (!ccs_correct_word(filename))
-		return false;
-	if (filename[0] == '@') {
-		ptr->group = ccs_get_group(filename + 1, CCS_PATH_GROUP);
+	char *filename;
+	if (param->data[0] == '@') {
+		param->data++;
+		ptr->group = ccs_get_group(param, CCS_PATH_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
+	filename = ccs_read_token(param);
+	if (!ccs_correct_word(filename))
+		return false;
 	ptr->filename = ccs_get_name(filename);
 	ptr->is_group = false;
 	return ptr->filename != NULL;
@@ -269,25 +273,25 @@
 /**
  * ccs_parse_number_union - Parse a ccs_number_union.
  *
- * @data: Number or number range or number group.
- * @ptr:  Pointer to "struct ccs_number_union".
+ * @param: Pointer to "struct ccs_acl_param".
+ * @ptr:   Pointer to "struct ccs_number_union".
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_parse_number_union(char *data, struct ccs_number_union *ptr)
+bool ccs_parse_number_union(struct ccs_acl_param *param,
+			    struct ccs_number_union *ptr)
 {
+	char *data;
 	u8 type;
 	unsigned long v;
 	memset(ptr, 0, sizeof(*ptr));
-	if (!data[0])
-		return false;
-	if (data[0] == '@') {
-		if (!ccs_correct_word(data))
-			return false;
-		ptr->group = ccs_get_group(data + 1, CCS_NUMBER_GROUP);
+	if (param->data[0] == '@') {
+		param->data++;
+		ptr->group = ccs_get_group(param, CCS_NUMBER_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
+	data = ccs_read_token(param);
 	type = ccs_parse_ulong(&v, &data);
 	if (type == CCS_VALUE_TYPE_INVALID)
 		return false;
@@ -301,7 +305,7 @@
 	if (*data++ != '-')
 		return false;
 	type = ccs_parse_ulong(&v, &data);
-	if (type == CCS_VALUE_TYPE_INVALID || *data)
+	if (type == CCS_VALUE_TYPE_INVALID || *data || ptr->values[0] > v)
 		return false;
 	ptr->values[1] = v;
 	ptr->value_type[1] = type;
@@ -426,33 +430,6 @@
 }
 
 /**
- * ccs_tokenize - Tokenize string.
- *
- * @buffer: The line to tokenize.
- * @w:      Pointer to "char *".
- * @size:   Sizeof @w.
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_tokenize(char *buffer, char *w[], size_t size)
-{
-	int count = size / sizeof(char *);
-	int i;
-	for (i = 0; i < count; i++)
-		w[i] = "";
-	for (i = 0; i < count; i++) {
-		char *cp = strchr(buffer, ' ');
-		if (cp)
-			*cp = '\0';
-		w[i] = buffer;
-		if (!cp)
-			break;
-		buffer = cp + 1;
-	}
-	return i < count || !*buffer;
-}
-
-/**
  * ccs_correct_word2 - Check whether the given string follows the naming rules.
  *
  * @string: The byte sequence to check. Not '\0'-terminated.
@@ -562,26 +539,21 @@
  */
 bool ccs_correct_domain(const unsigned char *domainname)
 {
-	if (!domainname || strncmp(domainname, CCS_ROOT_NAME,
-				   CCS_ROOT_NAME_LEN))
-		goto out;
-	domainname += CCS_ROOT_NAME_LEN;
-	if (!*domainname)
+	if (!domainname || !ccs_domain_def(domainname))
+		return false;
+	domainname = strchr(domainname, ' ');
+	if (!domainname++)
 		return true;
-	if (*domainname++ != ' ')
-		goto out;
 	while (1) {
 		const unsigned char *cp = strchr(domainname, ' ');
 		if (!cp)
 			break;
 		if (*domainname != '/' ||
 		    !ccs_correct_word2(domainname, cp - domainname))
-			goto out;
+			return false;
 		domainname = cp + 1;
 	}
 	return ccs_correct_path(domainname);
-out:
-	return false;
 }
 
 /**
@@ -593,7 +565,18 @@
  */
 bool ccs_domain_def(const unsigned char *buffer)
 {
-	return !strncmp(buffer, CCS_ROOT_NAME, CCS_ROOT_NAME_LEN);
+	const unsigned char *cp;
+	int len;
+	if (*buffer != '<')
+		return false;
+	cp = strchr(buffer, ' ');
+	if (!cp)
+		len = strlen(buffer);
+	else
+		len = cp - buffer;
+	if (buffer[len - 1] != '>' || !ccs_correct_word2(buffer + 1, len - 2))
+		return false;
+	return true;
 }
 
 /**
@@ -1028,6 +1011,7 @@
 		struct ccs_domain_info *domain = ccs_current_domain();
 		const u8 profile = domain->profile;
 		memset(r, 0, sizeof(*r));
+		r->ns = ccs_current_namespace();
 		r->profile = profile;
 		r->type = index;
 		r->mode = ccs_get_mode(profile, index);
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/file.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/file.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/file.c	(working copy)
@@ -393,7 +393,7 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name))
+	if (!ccs_parse_name_union(param, &e.name))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -462,10 +462,10 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.mode) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.major) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.minor))
+	if (!ccs_parse_name_union(param, &e.name) ||
+	    !ccs_parse_number_union(param, &e.mode) ||
+	    !ccs_parse_number_union(param, &e.major) ||
+	    !ccs_parse_number_union(param, &e.minor))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -535,8 +535,8 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name1) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.name2))
+	if (!ccs_parse_name_union(param, &e.name1) ||
+	    !ccs_parse_name_union(param, &e.name2))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -579,10 +579,10 @@
 {
 	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL };
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.dev_name) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.dir_name) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.fs_type) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.flags))
+	if (!ccs_parse_name_union(param, &e.dev_name) ||
+	    !ccs_parse_name_union(param, &e.dir_name) ||
+	    !ccs_parse_name_union(param, &e.fs_type) ||
+	    !ccs_parse_number_union(param, &e.flags))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -1001,8 +1001,8 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.number))
+	if (!ccs_parse_name_union(param, &e.name) ||
+	    !ccs_parse_number_union(param, &e.number))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/proc_if.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/proc_if.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/proc_if.c	(working copy)
@@ -338,10 +338,6 @@
 static int __init ccs_init_module(void)
 {
 	int i;
-	for (i = 0; i < CCS_MAX_POLICY; i++)
-		INIT_LIST_HEAD(&ccs_policy_list[i]);
-	for (i = 0; i < CCS_MAX_GROUP; i++)
-		INIT_LIST_HEAD(&ccs_group_list[i]);
 	for (i = 0; i < CCS_MAX_LIST; i++)
 		INIT_LIST_HEAD(&ccs_shared_list[i]);
 	if (ccsecurity_ops.disabled)
@@ -353,7 +349,6 @@
 	if (init_srcu_struct(&ccs_ss))
 		panic("Out of memory.");
 #endif
-	ccs_proc_init();
 	ccs_mm_init();
 	ccs_capability_init();
 	ccs_file_init();
@@ -362,6 +357,7 @@
 	ccs_mount_init();
 	ccs_policy_io_init();
 	ccs_domain_init();
+	ccs_proc_init();
 #ifdef CONFIG_CCSECURITY_USE_BUILTIN_POLICY
 	ccs_load_builtin_policy();
 #endif
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -461,13 +461,6 @@
 	CCS_MAX_GROUP
 };
 
-/* Index numbers for type of IP address. */
-enum ccs_ip_address_type {
-	CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP,
-	CCS_IP_ADDRESS_TYPE_IPv4,
-	CCS_IP_ADDRESS_TYPE_IPv6,
-};
-
 /* Index numbers for category of functionality. */
 enum ccs_mac_category_index {
 	CCS_MAC_CATEGORY_FILE,
@@ -697,6 +690,8 @@
 /* Index numbers for domain transition control keywords. */
 enum ccs_transition_type {
 	/* Do not change this order, */
+	CCS_TRANSITION_CONTROL_NO_NAMESPACE,
+	CCS_TRANSITION_CONTROL_NAMESPACE,
 	CCS_TRANSITION_CONTROL_NO_INITIALIZE,
 	CCS_TRANSITION_CONTROL_INITIALIZE,
 	CCS_TRANSITION_CONTROL_NO_KEEP,
@@ -728,10 +723,6 @@
  */
 #define CCS_SOCK_MAX 6
 
-/* A domain definition starts with <kernel>. */
-#define CCS_ROOT_NAME                         "<kernel>"
-#define CCS_ROOT_NAME_LEN                     (sizeof(CCS_ROOT_NAME) - 1)
-
 /* Size of temporary buffer for execve() operation. */
 #define CCS_EXEC_TMPSIZE     4096
 
@@ -823,6 +814,24 @@
 	u8 is_group;
 };
 
+/* Structure for holding an IP address. */
+struct ccs_ipaddr_union {
+	struct {
+		/* Start of IPv4 address range. Host endian. */
+		u32 min;
+		/* End of IPv4 address range. Host endian.   */
+		u32 max;
+	} ipv4;
+	struct {
+		/* Start of IPv6 address range. Big endian.  */
+		const struct in6_addr *min;
+		/* End of IPv6 address range. Big endian.    */
+		const struct in6_addr *max;
+	} ipv6;
+	/* Pointer to address group. */
+	struct ccs_group *group;
+};
+
 /* Structure for "path_group"/"number_group"/"address_group" directive. */
 struct ccs_group {
 	struct ccs_shared_acl_head head;
@@ -850,11 +859,8 @@
 /* Structure for "address_group" directive. */
 struct ccs_address_group {
 	struct ccs_acl_head head;
-	bool is_ipv6; /* True if IPv6 address, false if IPv4 address. */
-	union {
-		u32 ipv4;                    /* Host byte order    */
-		const struct in6_addr *ipv6; /* Network byte order */
-	} min, max;
+	/* Structure for holding an IP address. */
+	struct ccs_ipaddr_union address;
 };
 
 /* Subset of "struct stat". Used by conditional ACL and audit logs. */
@@ -934,6 +940,7 @@
 };
 
 struct ccs_execve;
+struct ccs_policy_namespace;
 
 /* Structure for request info. */
 struct ccs_request_info {
@@ -1027,6 +1034,7 @@
 			const struct ccs_path_info *domainname;
 		} task;
 	} param;
+	struct ccs_policy_namespace *ns;
 	u8 param_type; /* One of values in "enum ccs_acl_entry_type_index". */
 	bool granted; /* True if granted, false otherwise. */
 	/* True if current thread should not be carried sleep penalty. */
@@ -1095,6 +1103,8 @@
 	struct list_head acl_info_list[2];
 	/* Name of this domain. Never NULL.          */
 	const struct ccs_path_info *domainname;
+	/* Namespace for this domain. Never NULL. */
+	struct ccs_policy_namespace *ns;
 	u8 profile;        /* Profile number to use. */
 	u8 group;          /* Group number to use.   */
 	bool is_deleted;   /* Delete flag.           */
@@ -1102,7 +1112,8 @@
 };
 
 /*
- * Structure for "initialize_domain"/"no_initialize_domain" and
+ * Structure for "move_namespace"/"no_move_namespace" and
+ * "initialize_domain"/"no_initialize_domain" and
  * "keep_domain"/"no_keep_domain" keyword.
  */
 struct ccs_transition_control {
@@ -1123,8 +1134,7 @@
 /* Structure for "deny_autobind" keyword. */
 struct ccs_reserved {
 	struct ccs_acl_head head;
-	u16 min_port;                /* Start of port number range.          */
-	u16 max_port;                /* End of port number range.            */
+	struct ccs_number_union port;
 };
 
 /* Structure for policy manager. */
@@ -1137,7 +1147,7 @@
 
 /* Structure for argv[]. */
 struct ccs_argv {
-	unsigned int index;
+	unsigned long index;
 	const struct ccs_path_info *value;
 	bool is_not;
 };
@@ -1264,32 +1274,7 @@
 	struct ccs_acl_info head; /* type = CCS_TYPE_INET_ACL */
 	u8 protocol;
 	u8 perm; /* Bitmask of values in "enum ccs_network_acl_index" */
-	/*
-	 * address_type takes one of the following constants.
-	 *   CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP
-	 *                if @address points to "address_group" directive.
-	 *   CCS_IP_ADDRESS_TYPE_IPv4
-	 *                if @address points to an IPv4 address.
-	 *   CCS_IP_ADDRESS_TYPE_IPv6
-	 *                if @address points to an IPv6 address.
-	 */
-	u8 address_type;
-	union {
-		struct {
-			/* Start of IPv4 address range. Host endian. */
-			u32 min;
-			/* End of IPv4 address range. Host endian.   */
-			u32 max;
-		} ipv4;
-		struct {
-			/* Start of IPv6 address range. Big endian.  */
-			const struct in6_addr *min;
-			/* End of IPv6 address range. Big endian.    */
-			const struct in6_addr *max;
-		} ipv6;
-		/* Pointer to address group. */
-		struct ccs_group *group;
-	} address;
+	struct ccs_ipaddr_union address;
 	struct ccs_number_union port;
 };
 
@@ -1310,8 +1295,13 @@
 
 /* Structure for holding a line from /proc/ccs/ interface. */
 struct ccs_acl_param {
+	/* Unprocessed data. */
 	char *data;
-	struct ccs_domain_info *domain;
+	/* Pointer to "struct list_head" or "struct list_head[2]" */
+	struct list_head *list;
+	/* Namespace to use. */
+	struct ccs_policy_namespace *ns;
+	/* True if it is a delete request. */
 	bool is_delete;
 };
 
@@ -1325,6 +1315,7 @@
 	char __user *read_user_buf;
 	size_t read_user_buf_avail;
 	struct {
+		struct list_head *ns;
 		struct list_head *domain;
 		struct list_head *group;
 		struct list_head *acl;
@@ -1344,8 +1335,10 @@
 		const char *w[CCS_MAX_IO_READ_QUEUE];
 	} r;
 	struct {
+		struct ccs_policy_namespace *ns;
 		struct ccs_domain_info *domain;
 		size_t avail;
+		bool is_delete;
 	} w;
 	/* Buffer for reading.                  */
 	char *read_buf;
@@ -1355,6 +1348,8 @@
 	char *write_buf;
 	/* Size of write buffer.                */
 	size_t writebuf_size;
+	/* Namespace as of open(). */
+	struct ccs_policy_namespace *original_ns;
 	/* Type of interface. */
 	enum ccs_proc_interface_index type;
 	/* Users counter protected by ccs_io_buffer_list_lock. */
@@ -1381,6 +1376,22 @@
 	u8 sec;
 };
 
+/* Structure for policy namespace. */
+struct ccs_policy_namespace {
+	/* Profile table. Memory is allocated as needed. */
+	struct ccs_profile *profile_ptr[CCS_MAX_PROFILES];
+	/* List of "struct ccs_group". */
+	struct list_head group_list[CCS_MAX_GROUP];
+	/* List of policy. */
+	struct list_head policy_list[CCS_MAX_POLICY];
+	/* The global ACL referred by "use_group" keyword. */
+	struct list_head acl_group[CCS_MAX_ACL_GROUPS][2];
+	/* List for connecting to ccs_namespace_list list. */
+	struct list_head namespace_list;
+	/* Name of this namespace (e.g. "<kernel>", "</usr/sbin/httpd>" ). */
+	const char *name;
+};
+
 /* Prototype definition for "struct ccsecurity_operations". */
 
 void __init ccs_capability_init(void);
@@ -1410,13 +1421,16 @@
 bool ccs_memory_ok(const void *ptr, const unsigned int size);
 bool ccs_number_matches_group(const unsigned long min, const unsigned long max,
 			      const struct ccs_group *group);
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr);
-bool ccs_parse_number_union(char *data, struct ccs_number_union *num);
+bool ccs_parse_ipaddr_union(struct ccs_acl_param *param,
+			    struct ccs_ipaddr_union *ptr);
+bool ccs_parse_name_union(struct ccs_acl_param *param,
+			  struct ccs_name_union *ptr);
+bool ccs_parse_number_union(struct ccs_acl_param *param,
+			    struct ccs_number_union *ptr);
 bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 			      const struct ccs_path_info *pattern);
 bool ccs_permstr(const char *string, const char *keyword);
 bool ccs_str_starts(char **src, const char *find);
-bool ccs_tokenize(char *buffer, char *w[], size_t size);
 char *ccs_encode(const char *str);
 char *ccs_encode2(const char *str, int str_len);
 char *ccs_init_log(struct ccs_request_info *r, int len, const char *fmt,
@@ -1437,7 +1451,7 @@
 int ccs_get_path(const char *pathname, struct path *path);
 int ccs_init_request_info(struct ccs_request_info *r, const u8 index);
 int ccs_open_control(const u8 type, struct file *file);
-int ccs_parse_ip_address(char *address, u16 *min, u16 *max);
+int ccs_parse_ip_address(struct ccs_acl_param *param, u16 *min, u16 *max);
 int ccs_path_permission(struct ccs_request_info *r, u8 operation,
 			const struct ccs_path_info *filename);
 int ccs_poll_control(struct file *file, poll_table *wait);
@@ -1453,30 +1467,30 @@
 					       struct ccs_acl_info *,
 					       const bool));
 int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      bool is_delete, struct list_head *list,
+		      struct ccs_acl_param *param,
 		      bool (*check_duplicate) (const struct ccs_acl_head *,
 					       const struct ccs_acl_head *));
-int ccs_write_aggregator(char *data, const bool is_delete);
+int ccs_write_aggregator(struct ccs_acl_param *param);
 int ccs_write_capability(struct ccs_acl_param *param);
 int ccs_write_file(struct ccs_acl_param *param);
-int ccs_write_group(char *data, const bool is_delete, const u8 type);
+int ccs_write_group(struct ccs_acl_param *param, const u8 type);
 int ccs_write_inet_network(struct ccs_acl_param *param);
 int ccs_write_ipc(struct ccs_acl_param *param);
 int ccs_write_misc(struct ccs_acl_param *param);
-int ccs_write_reserved_port(char *data, const bool is_delete);
-int ccs_write_transition_control(char *data, const bool is_delete,
-				 const u8 type);
+int ccs_write_reserved_port(struct ccs_acl_param *param);
+int ccs_write_transition_control(struct ccs_acl_param *param, const u8 type);
 int ccs_write_unix_network(struct ccs_acl_param *param);
 ssize_t ccs_read_control(struct file *file, char __user *buffer,
 			 const size_t buffer_len);
 ssize_t ccs_write_control(struct file *file, const char __user *buffer,
 			  const size_t buffer_len);
-struct ccs_condition *ccs_get_condition(char *condition);
+struct ccs_condition *ccs_get_condition(struct ccs_acl_param *param);
 struct ccs_domain_info *ccs_assign_domain(const char *domainname,
 					  const u8 profile, const u8 group,
 					  const bool transit);
 struct ccs_domain_info *ccs_find_domain(const char *domainname);
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx);
+struct ccs_group *ccs_get_group(struct ccs_acl_param *param, const u8 idx);
+struct ccs_policy_namespace *ccs_assign_namespace(const char *domainname);
 struct ccs_profile *ccs_profile(const u8 profile);
 u8 ccs_get_config(const u8 profile, const u8 index);
 u8 ccs_parse_ulong(unsigned long *result, char **str);
@@ -1488,14 +1502,12 @@
 void ccs_del_condition(struct list_head *element);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
 void ccs_get_attributes(struct ccs_obj_info *obj);
+void ccs_init_policy_namespace(struct ccs_policy_namespace *ns);
 void ccs_memory_free(const void *ptr, size_t size);
 void ccs_normalize_line(unsigned char *buffer);
 void ccs_notify_gc(struct ccs_io_buffer *head, const bool is_register);
-void ccs_print_ipv4(char *buffer, const int buffer_len, const u32 min_ip,
-		    const u32 max_ip);
-void ccs_print_ipv6(char *buffer, const int buffer_len,
-		    const struct in6_addr *min_ip,
-		    const struct in6_addr *max_ip);
+void ccs_print_ip(char *buf, const unsigned int size,
+		  const struct ccs_ipaddr_union *ptr);
 void ccs_print_ulong(char *buffer, const int buffer_len,
 		     const unsigned long value, const u8 type);
 void ccs_put_name_union(struct ccs_name_union *ptr);
@@ -1528,12 +1540,12 @@
 extern const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION];
 extern const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION];
 extern const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION];
-extern struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
+extern struct ccs_policy_namespace ccs_kernel_namespace;
 extern struct ccs_domain_info ccs_kernel_domain;
 extern struct list_head ccs_domain_list;
-extern struct list_head ccs_group_list[CCS_MAX_GROUP];
+extern struct list_head ccs_manager_list;
 extern struct list_head ccs_name_list[CCS_MAX_HASH];
-extern struct list_head ccs_policy_list[CCS_MAX_POLICY];
+extern struct list_head ccs_namespace_list;
 extern struct list_head ccs_shared_list[CCS_MAX_LIST];
 extern struct mutex ccs_policy_lock;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
@@ -1591,6 +1603,22 @@
 		a->is_group == b->is_group;
 }
 
+/**
+ * ccs_same_ipaddr_union - Check for duplicated "struct ccs_ipaddr_union" entry.
+ *
+ * @a: Pointer to "struct ccs_ipaddr_union".
+ * @b: Pointer to "struct ccs_ipaddr_union".
+ *
+ * Returns true if @a == @b, false otherwise.
+ */
+static inline bool ccs_same_ipaddr_union(const struct ccs_ipaddr_union *a,
+					 const struct ccs_ipaddr_union *b)
+{
+	return a->ipv4.min == b->ipv4.min && a->ipv4.max == b->ipv4.max &&
+		a->ipv6.min == b->ipv6.min && a->ipv6.max == b->ipv6.max &&
+		a->group == b->group;
+}
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
 
 /**
@@ -2045,8 +2073,8 @@
  * Returns pointer to "struct ccs_domain_info" for current thread.
  *
  * If current thread does not belong to a domain (which is true for initial
- * init_task in order to hide ccs_kernel_domain from this module), current
- * thread enters into ccs_kernel_domain.
+ * init_task in order to hide ccs_kernel_domain from this module),
+ * current thread enters into ccs_kernel_domain.
  */
 static inline struct ccs_domain_info *ccs_current_domain(void)
 {
@@ -2080,4 +2108,9 @@
 
 #endif
 
+static inline struct ccs_policy_namespace *ccs_current_namespace(void)
+{
+	return ccs_current_domain()->ns;
+}
+
 #endif
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/condition.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/condition.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/condition.c	(working copy)
@@ -277,16 +277,17 @@
 /**
  * ccs_parse_name_union_quoted - Parse a quoted word.
  *
- * @filename: A line containing a quoted word.
- * @ptr:      Pointer to "struct ccs_name_union".
+ * @param: Pointer to "struct ccs_acl_param".
+ * @ptr:   Pointer to "struct ccs_name_union".
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_parse_name_union_quoted(char *filename,
+static bool ccs_parse_name_union_quoted(struct ccs_acl_param *param,
 					struct ccs_name_union *ptr)
 {
+	char *filename = param->data;
 	if (*filename == '@')
-		return ccs_parse_name_union(filename, ptr);
+		return ccs_parse_name_union(param, ptr);
 	ptr->is_group = false;
 	ptr->filename = ccs_get_dqword(filename);
 	return ptr->filename != NULL;
@@ -295,35 +296,28 @@
 /**
  * ccs_parse_argv - Parse an argv[] condition part.
  *
- * @start: String to parse.
+ * @left:  Lefthand value.
+ * @right: Righthand value.
  * @argv:  Pointer to "struct ccs_argv".
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_parse_argv(char *start, struct ccs_argv *argv)
+static bool ccs_parse_argv(char *left, char *right, struct ccs_argv *argv)
 {
-	unsigned long index;
-	const struct ccs_path_info *value;
-	bool is_not;
-	char c;
-	if (ccs_parse_ulong(&index, &start) != CCS_VALUE_TYPE_DECIMAL)
+	if (ccs_parse_ulong(&argv->index, &left) != CCS_VALUE_TYPE_DECIMAL)
 		goto out;
-	if (*start++ != ']')
+	if (*left++ != ']')
 		goto out;
-	c = *start++;
-	if (c == '=')
-		is_not = false;
-	else if (c == '!' && *start++ == '=')
-		is_not = true;
-	else
+	if (*left == '!') {
+		left++;
+		argv->is_not = true;
+	} else {
+		argv->is_not = false;
+	}
+	if (*left)
 		goto out;
-	value = ccs_get_dqword(start);
-	if (!value)
-		goto out;
-	argv->index = index;
-	argv->is_not = is_not;
-	argv->value = value;
-	return true;
+	argv->value = ccs_get_dqword(right);
+	return argv->value != NULL;
 out:
 	return false;
 }
@@ -331,53 +325,41 @@
 /**
  * ccs_parse_envp - Parse an envp[] condition part.
  *
- * @start: String to parse.
+ * @left:  Lefthand value.
+ * @right: Righthand value.
  * @envp:  Pointer to "struct ccs_envp".
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_parse_envp(char *start, struct ccs_envp *envp)
+static bool ccs_parse_envp(char *left, char *right, struct ccs_envp *envp)
 {
 	const struct ccs_path_info *name;
 	const struct ccs_path_info *value;
-	bool is_not;
-	char *cp = start;
-	/*
-	 * Since environment variable names don't
-	 * contain '=', I can treat '"]=' and '"]!='
-	 * sequences as delimiters.
-	 */
-	while (1) {
-		if (!strncmp(start, "\"]=", 3)) {
-			is_not = false;
-			*start = '\0';
-			start += 3;
-			break;
-		} else if (!strncmp(start, "\"]!=", 4)) {
-			is_not = true;
-			*start = '\0';
-			start += 4;
-			break;
-		} else if (!*start++) {
-			goto out;
-		}
+	char *cp = left + strlen(left) - 1;
+	if (*cp == '!') {
+		cp--;
+		envp->is_not = true;
+	} else {
+		envp->is_not = false;
 	}
-	if (!ccs_correct_word(cp))
+	if (*cp-- != ']' || *cp != '"')
 		goto out;
-	name = ccs_get_name(cp);
+	*cp = '\0';
+	if (!ccs_correct_word(left))
+		goto out;
+	name = ccs_get_name(left);
 	if (!name)
 		goto out;
-	if (!strcmp(start, "NULL")) {
+	if (!strcmp(right, "NULL")) {
 		value = NULL;
 	} else {
-		value = ccs_get_dqword(start);
+		value = ccs_get_dqword(right);
 		if (!value) {
 			ccs_put_name(name);
 			goto out;
 		}
 	}
 	envp->name = name;
-	envp->is_not = is_not;
 	envp->value = value;
 	return true;
 out:
@@ -482,11 +464,11 @@
 /**
  * ccs_get_condition - Parse condition part.
  *
- * @condition: Pointer to string to parse.
+ * @param: Pointer to "struct ccs_acl_param".
  *
  * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
  */
-struct ccs_condition *ccs_get_condition(char *condition)
+struct ccs_condition *ccs_get_condition(struct ccs_acl_param *param)
 {
 	char *start;
 	struct ccs_condition *entry = NULL;
@@ -497,17 +479,18 @@
 	struct ccs_envp *envp = NULL;
 	struct ccs_condition e = { };
 	bool dry_run = true;
-	char *end_of_string = condition + strlen(condition);
+	char * const start_of_string = param->data;
+	char * const end_of_string = start_of_string + strlen(start_of_string);
 rerun:
-	start = condition;
+	start = start_of_string;
 	while (1) {
 		u8 left = -1;
 		u8 right = -1;
-		char *word = start;
+		char *left_word = start;
 		char *cp;
-		char *eq;
-		bool is_not = false;
-		if (!*word)
+		char *right_word;
+		bool is_not;
+		if (!*left_word)
 			break;
 		cp = strchr(start, ' ');
 		if (cp) {
@@ -516,33 +499,45 @@
 		} else {
 			start = "";
 		}
-		dprintk(KERN_WARNING "%u: <%s>\n", __LINE__, word);
-		if (!strncmp(word, "grant_log=", 10)) {
+		dprintk(KERN_WARNING "%u: <%s>\n", __LINE__, left_word);
+		right_word = strchr(left_word, '=');
+		if (!right_word || right_word == left_word)
+			goto out;
+		is_not = (*(right_word - 1) == '!');
+		*right_word++ = '\0';
+		if (!strcmp(left_word, "grant_log")) {
 			if (!dry_run) {
-				word += 10;
 				if (entry->grant_log != CCS_GRANTLOG_AUTO)
 					goto out;
-				else if (!strcmp(word, "yes"))
+				else if (!strcmp(right_word, "yes"))
 					entry->grant_log = CCS_GRANTLOG_YES;
-				else if (!strcmp(word, "no"))
+				else if (!strcmp(right_word, "no"))
 					entry->grant_log = CCS_GRANTLOG_NO;
 				else
 					goto out;
 			}
 			continue;
-		} else if (!strncmp(word, "auto_domain_transition=", 23)) {
+		} else if (!strcmp(left_word, "auto_domain_transition")) {
 			if (!dry_run) {
-				word += 23;
-				if (entry->transit)
+				if (entry->transit || *right_word != '/')
 					goto out;
-				entry->transit = ccs_get_dqword(word);
-				if (!entry->transit ||
-				    entry->transit->name[0] != '/')
+				entry->transit = ccs_get_dqword(right_word);
+				if (!entry->transit)
 					goto out;
 			}
 			continue;
+		} else if (!strcmp(left_word, "auto_namespace_transition")) {
+			if (!dry_run) {
+				if (entry->transit ||
+				    !ccs_domain_def(right_word))
+					goto out;
+				entry->transit = ccs_get_dqword(right_word);
+				if (!entry->transit)
+					goto out;
+			}
+			continue;
 		}
-		if (!strncmp(word, "exec.argv[", 10)) {
+		if (!strncmp(left_word, "exec.argv[", 10)) {
 			if (dry_run) {
 				e.argc++;
 				e.condc++;
@@ -550,11 +545,12 @@
 				e.argc--;
 				e.condc--;
 				left = CCS_ARGV_ENTRY;
-				if (!ccs_parse_argv(word + 10, argv++))
+				if (!ccs_parse_argv(left_word + 10,
+						    right_word, argv++))
 					goto out;
 			}
 			goto store_value;
-		} else if (!strncmp(word, "exec.envp[\"", 11)) {
+		} else if (!strncmp(left_word, "exec.envp[\"", 11)) {
 			if (dry_run) {
 				e.envc++;
 				e.condc++;
@@ -562,21 +558,14 @@
 				e.envc--;
 				e.condc--;
 				left = CCS_ENVP_ENTRY;
-				if (!ccs_parse_envp(word + 11, envp++))
+				if (!ccs_parse_envp(left_word + 11,
+						    right_word, envp++))
 					goto out;
 			}
 			goto store_value;
 		}
-		eq = strchr(word, '=');
-		if (!eq)
-			goto out;
-		if (eq > word && *(eq - 1) == '!') {
-			is_not = true;
-			eq--;
-		}
-		*eq = '\0';
-		left = ccs_condition_type(word);
-		dprintk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__, word,
+		left = ccs_condition_type(left_word);
+		dprintk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__, left_word,
 			left);
 		if (left == CCS_MAX_CONDITION_KEYWORD) {
 			if (dry_run) {
@@ -584,17 +573,13 @@
 			} else {
 				e.numbers_count--;
 				left = CCS_NUMBER_UNION;
-				if (!ccs_parse_number_union(word, numbers_p))
+				param->data = left_word;
+				if (*left_word == '@' ||
+				    !ccs_parse_number_union(param,
+							    numbers_p++))
 					goto out;
-				if (numbers_p->is_group)
-					goto out;
-				numbers_p++;
 			}
 		}
-		*eq = is_not ? '!' : '=';
-		word = eq + 1;
-		if (is_not)
-			word++;
 		if (dry_run)
 			e.condc++;
 		else
@@ -605,20 +590,24 @@
 			} else {
 				e.names_count--;
 				right = CCS_NAME_UNION;
-				if (!ccs_parse_name_union_quoted(word,
+				param->data = right_word;
+				if (!ccs_parse_name_union_quoted(param,
 								 names_p++))
 					goto out;
 			}
 			goto store_value;
 		}
-		right = ccs_condition_type(word);
+		right = ccs_condition_type(right_word);
 		if (right == CCS_MAX_CONDITION_KEYWORD) {
 			if (dry_run) {
 				e.numbers_count++;
 			} else {
 				e.numbers_count--;
 				right = CCS_NUMBER_UNION;
-				if (!ccs_parse_number_union(word, numbers_p++))
+				param->data = right_word;
+				if (*right_word == '@' ||
+				    !ccs_parse_number_union(param,
+							    numbers_p++))
 					goto out;
 			}
 		}
@@ -656,7 +645,7 @@
 	names_p = (struct ccs_name_union *) (numbers_p + e.numbers_count);
 	argv = (struct ccs_argv *) (names_p + e.names_count);
 	envp = (struct ccs_envp *) (argv + e.argc);
-	for (start = condition; start < end_of_string; start++)
+	for (start = start_of_string; start < end_of_string; start++)
 		if (!*start)
 			*start = ' ';
 	dry_run = false;
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -83,9 +83,6 @@
 /* Profile version. Currently only 20100903 is defined. */
 static unsigned int ccs_profile_version;
 
-/* Profile table. Memory is allocated as needed. */
-static struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
-
 /* String table for operation mode. */
 const char * const ccs_mode[CCS_CONFIG_MAX_MODE] = {
 	[CCS_CONFIG_DISABLED]   = "disabled",
@@ -430,26 +427,72 @@
 	ccs_set_string(head, "/");
 }
 
+/* List of namespaces. */
+LIST_HEAD(ccs_namespace_list);
+/* True if namespace other than ccs_kernel_namespace is defined. */
+static bool ccs_namespace_enabled;
+
 /**
+ * ccs_init_policy_namespace - Initialize namespace.
+ *
+ * @ns: Pointer to "struct ccs_policy_namespace".
+ *
+ * Returns nothing.
+ */
+void ccs_init_policy_namespace(struct ccs_policy_namespace *ns)
+{
+	unsigned int idx;
+	for (idx = 0; idx < CCS_MAX_ACL_GROUPS; idx++) {
+		INIT_LIST_HEAD(&ns->acl_group[idx][0]);
+		INIT_LIST_HEAD(&ns->acl_group[idx][1]);
+	}
+	for (idx = 0; idx < CCS_MAX_GROUP; idx++)
+		INIT_LIST_HEAD(&ns->group_list[idx]);
+	for (idx = 0; idx < CCS_MAX_POLICY; idx++)
+		INIT_LIST_HEAD(&ns->policy_list[idx]);
+	ccs_namespace_enabled = !list_empty(&ccs_namespace_list);
+	list_add_tail_rcu(&ns->namespace_list, &ccs_namespace_list);
+}
+
+/**
+ * ccs_print_namespace - Print namespace header.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ */
+static void ccs_print_namespace(struct ccs_io_buffer *head)
+{
+	if (!ccs_namespace_enabled)
+		return;
+	ccs_set_string(head,
+		       container_of(head->r.ns, struct ccs_policy_namespace,
+				    namespace_list)->name);
+	ccs_set_space(head);
+}
+
+/**
  * ccs_assign_profile - Create a new profile.
  *
+ * @ns:      Pointer to "struct ccs_policy_namespace".
  * @profile: Profile number to create.
  *
  * Returns pointer to "struct ccs_profile" on success, NULL otherwise.
  */
-static struct ccs_profile *ccs_assign_profile(const unsigned int profile)
+static struct ccs_profile *ccs_assign_profile(struct ccs_policy_namespace *ns,
+					      const unsigned int profile)
 {
 	struct ccs_profile *ptr;
 	struct ccs_profile *entry;
 	if (profile >= CCS_MAX_PROFILES)
 		return NULL;
-	ptr = ccs_profile_ptr[profile];
+	ptr = ns->profile_ptr[profile];
 	if (ptr)
 		return ptr;
 	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	ptr = ccs_profile_ptr[profile];
+	ptr = ns->profile_ptr[profile];
 	if (!ptr && ccs_memory_ok(entry, sizeof(*entry))) {
 		ptr = entry;
 		ptr->default_config = CCS_CONFIG_DISABLED |
@@ -461,7 +504,7 @@
 		ptr->pref[CCS_PREF_MAX_LEARNING_ENTRY] =
 			CONFIG_CCSECURITY_MAX_ACCEPT_ENTRY;
 		mb(); /* Avoid out-of-order execution. */
-		ccs_profile_ptr[profile] = ptr;
+		ns->profile_ptr[profile] = ptr;
 		entry = NULL;
 	}
 	mutex_unlock(&ccs_policy_lock);
@@ -482,16 +525,15 @@
 	ccs_policy_loaded = true;
 	list_for_each_entry_srcu(domain, &ccs_domain_list, list, &ccs_ss) {
 		const u8 profile = domain->profile;
-		if (ccs_profile_ptr[profile])
+		if (domain->ns->profile_ptr[profile])
 			continue;
-		printk(KERN_ERR "Profile %u must be defined before using it.\n",
-		       profile);
+		printk(KERN_ERR "Profile %u must be defined before "
+		       "using it.\n", profile);
 		printk(KERN_ERR "Please see http://tomoyo.sourceforge.jp/1.8/ "
 		       "for more information.\n");
 		panic("Profile %u (used by '%s') not defined.\n",
 		      profile, domain->domainname->name);
 	}
-	ccs_read_unlock(idx);
 	if (ccs_profile_version != 20100903) {
 		printk(KERN_ERR "Userland tools must be installed for "
 		       "TOMOYO 1.8, and policy must be initialized.\n");
@@ -500,6 +542,7 @@
 		panic("Profile version %u is not supported.\n",
 		      ccs_profile_version);
 	}
+	ccs_read_unlock(idx);
 	printk(KERN_INFO "CCSecurity: 1.8.1+   2011/05/11\n");
 	printk(KERN_INFO "Mandatory Access Control activated.\n");
 }
@@ -514,7 +557,8 @@
 struct ccs_profile *ccs_profile(const u8 profile)
 {
 	static struct ccs_profile ccs_null_profile;
-	struct ccs_profile *ptr = ccs_profile_ptr[profile];
+	struct ccs_profile *ptr = ccs_current_namespace()->
+		profile_ptr[profile];
 	if (!ptr)
 		ptr = &ccs_null_profile;
 	return ptr;
@@ -654,7 +698,7 @@
 	if (*cp != '-')
 		return -EINVAL;
 	data = cp + 1;
-	profile = ccs_assign_profile(i);
+	profile = ccs_assign_profile(head->w.ns, i);
 	if (!profile)
 		return -EINVAL;
 	cp = strchr(data, '=');
@@ -711,31 +755,39 @@
 static void ccs_read_profile(struct ccs_io_buffer *head)
 {
 	u8 index;
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
 	const struct ccs_profile *profile;
+	if (head->r.eof)
+		return;
 next:
 	index = head->r.index;
-	profile = ccs_profile_ptr[index];
+	profile = ns->profile_ptr[index];
 	switch (head->r.step) {
 	case 0:
+		ccs_print_namespace(head);
 		ccs_io_printf(head, "PROFILE_VERSION=%u\n", 20100903);
 		head->r.step++;
 		break;
 	case 1:
-		for ( ; head->r.index < CCS_MAX_PROFILES;
-		      head->r.index++)
-			if (ccs_profile_ptr[head->r.index])
+		for ( ; head->r.index < CCS_MAX_PROFILES; head->r.index++)
+			if (ns->profile_ptr[head->r.index])
 				break;
-		if (head->r.index == CCS_MAX_PROFILES)
+		if (head->r.index == CCS_MAX_PROFILES) {
+			head->r.eof = true;
 			return;
+		}
 		head->r.step++;
 		break;
 	case 2:
 		{
 			u8 i;
 			const struct ccs_path_info *comment = profile->comment;
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-COMMENT=", index);
 			ccs_set_string(head, comment ? comment->name : "");
 			ccs_set_lf(head);
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-PREFERENCE={ ", index);
 			for (i = 0; i < CCS_MAX_PREF; i++)
 				ccs_io_printf(head, "%s=%u ",
@@ -747,6 +799,7 @@
 		break;
 	case 3:
 		{
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-%s", index, "CONFIG");
 			ccs_print_config(head, profile->default_config);
 			head->r.bit = 0;
@@ -760,6 +813,7 @@
 			const u8 config = profile->config[i];
 			if (config == CCS_CONFIG_USE_DEFAULT)
 				continue;
+			ccs_print_namespace(head);
 			if (i < CCS_MAX_MAC_INDEX)
 				ccs_io_printf(head, "%u-CONFIG::%s::%s", index,
 					      ccs_category_keywords
@@ -806,9 +860,15 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_manager_entry(const char *manager, const bool is_delete)
+static inline int ccs_update_manager_entry(const char *manager,
+					   const bool is_delete)
 {
 	struct ccs_manager e = { };
+	struct ccs_acl_param param = {
+		/* .ns = &ccs_kernel_namespace, */
+		.is_delete = is_delete,
+		.list = &ccs_kernel_namespace.policy_list[CCS_ID_MANAGER],
+	};
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (ccs_domain_def(manager)) {
 		if (!ccs_correct_domain(manager))
@@ -819,12 +879,11 @@
 			return -EINVAL;
 	}
 	e.manager = ccs_get_name(manager);
-	if (!e.manager)
-		return error;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_MANAGER],
-				  ccs_same_manager);
-	ccs_put_name(e.manager);
+	if (e.manager) {
+		error = ccs_update_policy(&e.head, sizeof(e), &param,
+					  ccs_same_manager);
+		ccs_put_name(e.manager);
+	}
 	return error;
 }
 
@@ -837,13 +896,12 @@
  */
 static int ccs_write_manager(struct ccs_io_buffer *head)
 {
-	char *data = head->write_buf;
-	bool is_delete = ccs_str_starts(&data, "delete ");
+	const char *data = head->write_buf;
 	if (!strcmp(data, "manage_by_non_root")) {
-		ccs_manage_by_non_root = !is_delete;
+		ccs_manage_by_non_root = !head->w.is_delete;
 		return 0;
 	}
-	return ccs_update_manager_entry(data, is_delete);
+	return ccs_update_manager_entry(data, head->w.is_delete);
 }
 
 /**
@@ -859,7 +917,8 @@
 {
 	if (head->r.eof)
 		return;
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[CCS_ID_MANAGER]) {
+	list_for_each_cookie(head->r.acl, &ccs_kernel_namespace.
+			     policy_list[CCS_ID_MANAGER]) {
 		struct ccs_manager *ptr =
 			list_entry(head->r.acl, typeof(*ptr), head.list);
 		if (ptr->head.is_deleted)
@@ -895,8 +954,9 @@
 	if (!ccs_manage_by_non_root && (current_uid() || current_euid()))
 		return false;
 	exe = ccs_get_exe();
-	list_for_each_entry_srcu(ptr, &ccs_policy_list[CCS_ID_MANAGER],
-				 head.list, &ccs_ss) {
+	list_for_each_entry_srcu(ptr, &ccs_kernel_namespace.
+				 policy_list[CCS_ID_MANAGER], head.list,
+				 &ccs_ss) {
 		if (ptr->head.is_deleted)
 			continue;
 		if (ptr->is_domain) {
@@ -925,7 +985,7 @@
 }
 
 /**
- * ccs_select_one - Parse select command.
+ * ccs_select_domain - Parse select command.
  *
  * @head: Pointer to "struct ccs_io_buffer".
  * @data: String to parse.
@@ -934,15 +994,14 @@
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_select_one(struct ccs_io_buffer *head, const char *data)
+static bool ccs_select_domain(struct ccs_io_buffer *head, const char *data)
 {
 	unsigned int pid;
 	struct ccs_domain_info *domain = NULL;
 	bool global_pid = false;
-	if (!strcmp(data, "transition_only")) {
-		head->r.print_transition_related_only = true;
-		return true;
-	}
+	if (strncmp(data, "select ", 7))
+		return false;
+	data += 7;
 	if (sscanf(data, "pid=%u", &pid) == 1 ||
 	    (global_pid = true, sscanf(data, "global-pid=%u", &pid) == 1)) {
 		struct task_struct *p;
@@ -960,7 +1019,7 @@
 			domain = ccs_task_domain(p);
 		ccs_tasklist_unlock();
 	} else if (!strncmp(data, "domain=", 7)) {
-		if (ccs_domain_def(data + 7))
+		if (*(data + 7) == '<')
 			domain = ccs_find_domain(data + 7);
 	} else
 		return false;
@@ -1068,20 +1127,23 @@
 /**
  * ccs_write_domain2 - Write domain policy.
  *
+ * @ns:        Pointer to "struct ccs_policy_namespace".
+ * @list:      Pointer to "struct list_head [2]".
  * @data:      Policy to be interpreted.
- * @domain:    Pointer to "struct ccs_domain_info".
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_write_domain2(char *data, struct ccs_domain_info *domain,
+static int ccs_write_domain2(struct ccs_policy_namespace *ns,
+			     struct list_head list[2], char *data,
 			     const bool is_delete)
 {
 	struct ccs_acl_param param = {
+		.ns = ns,
+		.list = list,
 		.data = data,
-		.domain = domain,
 		.is_delete = is_delete,
 	};
 	static const struct {
@@ -1153,20 +1215,12 @@
 static int ccs_write_domain(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
+	struct ccs_policy_namespace *ns;
 	struct ccs_domain_info *domain = head->w.domain;
-	bool is_delete = false;
-	bool is_select = false;
+	const bool is_delete = head->w.is_delete;
+	const bool is_select = !is_delete && ccs_str_starts(&data, "select ");
 	unsigned int profile;
-	if (ccs_str_starts(&data, "delete "))
-		is_delete = true;
-	else if (ccs_str_starts(&data, "select "))
-		is_select = true;
-	if (is_select && ccs_select_one(head, data))
-		return -EAGAIN;
-	/* Don't allow updating policies by non manager programs. */
-	if (!ccs_manager())
-		return -EPERM;
-	if (ccs_domain_def(data)) {
+	if (*data == '<') {
 		domain = NULL;
 		if (is_delete)
 			ccs_delete_domain(data);
@@ -1179,10 +1233,10 @@
 	}
 	if (!domain)
 		return -EINVAL;
-
+	ns = domain->ns;
 	if (sscanf(data, "use_profile %u\n", &profile) == 1
 	    && profile < CCS_MAX_PROFILES) {
-		if (!ccs_policy_loaded || ccs_profile_ptr[(u8) profile])
+		if (!ccs_policy_loaded || ns->profile_ptr[(u8) profile])
 			if (!is_delete)
 				domain->profile = (u8) profile;
 		return 0;
@@ -1200,7 +1254,7 @@
 		domain->flags[profile] = !is_delete;
 		return 0;
 	}
-	return ccs_write_domain2(data, domain, is_delete);
+	return ccs_write_domain2(ns, domain->acl_info_list, data, is_delete);
 }
 
 /**
@@ -1214,34 +1268,47 @@
 static void ccs_print_name_union(struct ccs_io_buffer *head,
 				 const struct ccs_name_union *ptr)
 {
-	const bool cond = head->r.print_cond_part;
-	if (!cond)
-		ccs_set_space(head);
+	ccs_set_space(head);
 	if (ptr->is_group) {
 		ccs_set_string(head, "@");
 		ccs_set_string(head, ptr->group->group_name->name);
 	} else {
-		if (cond)
-			ccs_set_string(head, "\"");
 		ccs_set_string(head, ptr->filename->name);
-		if (cond)
-			ccs_set_string(head, "\"");
 	}
 }
 
 /**
- * ccs_print_number_union - Print a ccs_number_union.
+ * ccs_print_name_union_quoted - Print a ccs_name_union with a quote.
  *
  * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ccs_name_union".
+ *
+ * Returns nothing.
+ */
+static void ccs_print_name_union_quoted(struct ccs_io_buffer *head,
+					const struct ccs_name_union *ptr)
+{
+	if (ptr->is_group) {
+		ccs_set_string(head, "@");
+		ccs_set_string(head, ptr->group->group_name->name);
+	} else {
+		ccs_set_string(head, "\"");
+		ccs_set_string(head, ptr->filename->name);
+		ccs_set_string(head, "\"");
+	}
+}
+
+/**
+ * ccs_print_number_union_nospace - Print a ccs_number_union without a space.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
  * @ptr:  Pointer to "struct ccs_number_union".
  *
  * Returns nothing.
  */
-static void ccs_print_number_union(struct ccs_io_buffer *head,
-				   const struct ccs_number_union *ptr)
+static void ccs_print_number_union_nospace(struct ccs_io_buffer *head,
+					   const struct ccs_number_union *ptr)
 {
-	if (!head->r.print_cond_part)
-		ccs_set_space(head);
 	if (ptr->is_group) {
 		ccs_set_string(head, "@");
 		ccs_set_string(head, ptr->group->group_name->name);
@@ -1279,6 +1346,21 @@
 }
 
 /**
+ * ccs_print_number_union - Print a ccs_number_union.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ccs_number_union".
+ *
+ * Returns nothing.
+ */
+static void ccs_print_number_union(struct ccs_io_buffer *head,
+				   const struct ccs_number_union *ptr)
+{
+	ccs_set_space(head);
+	ccs_print_number_union_nospace(head, ptr);
+}
+
+/**
  * ccs_print_condition - Print condition part.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -1345,19 +1427,19 @@
 				switch (left) {
 				case CCS_ARGV_ENTRY:
 					ccs_io_printf(head,
-						      "exec.argv[%u]%s\"%s\"",
+						      "exec.argv[%lu]%s=\"",
 						      argv->index,
-						      argv->is_not ?
-						      "!=" : "=",
-						      argv->value->name);
+						      argv->is_not ? "!" : "");
+					ccs_set_string(head,
+						       argv->value->name);
+					ccs_set_string(head, "\"");
 					argv++;
 					continue;
 				case CCS_ENVP_ENTRY:
-					ccs_io_printf(head,
-						      "exec.envp[\"%s\"]%s",
-						      envp->name->name,
-						      envp->is_not ?
-						      "!=" : "=");
+					ccs_set_string(head, "exec.envp[\"");
+					ccs_set_string(head, envp->name->name);
+					ccs_io_printf(head, "\"]%s=",
+						      envp->is_not ? "!" : "");
 					if (envp->value) {
 						ccs_set_string(head, "\"");
 						ccs_set_string(head, envp->
@@ -1369,8 +1451,8 @@
 					envp++;
 					continue;
 				case CCS_NUMBER_UNION:
-					ccs_print_number_union(head,
-							       numbers_p++);
+					ccs_print_number_union_nospace
+						(head, numbers_p++);
 					break;
 				default:
 					ccs_set_string(head,
@@ -1380,11 +1462,12 @@
 				ccs_set_string(head, match ? "=" : "!=");
 				switch (right) {
 				case CCS_NAME_UNION:
-					ccs_print_name_union(head, names_p++);
+					ccs_print_name_union_quoted
+						(head, names_p++);
 					break;
 				case CCS_NUMBER_UNION:
-					ccs_print_number_union(head,
-							       numbers_p++);
+					ccs_print_number_union_nospace
+						(head, numbers_p++);
 					break;
 				default:
 					ccs_set_string(head,
@@ -1406,8 +1489,11 @@
 				      ccs_yesno(cond->grant_log ==
 						CCS_GRANTLOG_YES));
 		if (cond->transit) {
-			ccs_set_string(head, " auto_domain_transition=\"");
-			ccs_set_string(head, cond->transit->name);
+			const char *name = cond->transit->name;
+			ccs_set_string(head, *name == '<' ?
+				       " auto_namespace_transition=\"" :
+				       " auto_domain_transition=\"");
+			ccs_set_string(head, name);
 			ccs_set_string(head, "\"");
 		}
 		ccs_set_lf(head);
@@ -1426,8 +1512,10 @@
  */
 static void ccs_set_group(struct ccs_io_buffer *head, const char *category)
 {
-	if (head->type == CCS_EXCEPTIONPOLICY)
+	if (head->type == CCS_EXCEPTIONPOLICY) {
+		ccs_print_namespace(head);
 		ccs_io_printf(head, "acl_group %u ", head->r.acl_group_index);
+	}
 	ccs_set_string(head, category);
 }
 
@@ -1588,23 +1676,14 @@
 		if (first)
 			return true;
 		ccs_set_space(head);
-		switch (ptr->address_type) {
-			char buf[128];
-		case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
+		if (ptr->address.group) {
 			ccs_set_string(head, "@");
 			ccs_set_string(head,
 				       ptr->address.group->group_name->name);
-			break;
-		case CCS_IP_ADDRESS_TYPE_IPv4:
-			ccs_print_ipv4(buf, sizeof(buf), ptr->address.ipv4.min,
-				       ptr->address.ipv4.max);
+		} else {
+			char buf[128];
+			ccs_print_ip(buf, sizeof(buf), &ptr->address);
 			ccs_io_printf(head, "%s", buf);
-			break;
-		case CCS_IP_ADDRESS_TYPE_IPv6:
-			ccs_print_ipv6(buf, sizeof(buf), ptr->address.ipv6.min,
-				       ptr->address.ipv6.max);
-			ccs_io_printf(head, "%s", buf);
-			break;
 		}
 		ccs_print_number_union(head, &ptr->port);
 	} else if (acl_type == CCS_TYPE_UNIX_ACL) {
@@ -1661,19 +1740,17 @@
 /**
  * ccs_read_domain2 - Read domain policy.
  *
- * @head:   Pointer to "struct ccs_io_buffer".
- * @domain: Pointer to "struct ccs_domain_info".
- * @index:  Index number.
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @list: Pointer to "struct list_head".
  *
  * Returns true on success, false otherwise.
  *
  * Caller holds ccs_read_lock().
  */
 static bool ccs_read_domain2(struct ccs_io_buffer *head,
-			     struct ccs_domain_info *domain,
-			     const u8 index)
+			     struct list_head *list)
 {
-	list_for_each_cookie(head->r.acl, &domain->acl_info_list[index]) {
+	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_acl_info *ptr =
 			list_entry(head->r.acl, typeof(*ptr), list);
 		if (!ccs_print_entry(head, ptr))
@@ -1718,12 +1795,12 @@
 			ccs_set_lf(head);
 			/* fall through */
 		case 1:
-			if (!ccs_read_domain2(head, domain, 0))
+			if (!ccs_read_domain2(head, &domain->acl_info_list[0]))
 				return;
 			head->r.step++;
 			/* fall through */
 		case 2:
-			if (!ccs_read_domain2(head, domain, 1))
+			if (!ccs_read_domain2(head, &domain->acl_info_list[1]))
 				return;
 			head->r.step++;
 			if (!ccs_set_lf(head))
@@ -1766,7 +1843,8 @@
 	if (profile >= CCS_MAX_PROFILES)
 		return -EINVAL;
 	domain = ccs_find_domain(cp + 1);
-	if (domain && (!ccs_policy_loaded || ccs_profile_ptr[(u8) profile]))
+	if (domain && (!ccs_policy_loaded ||
+		       head->w.ns->profile_ptr[(u8) profile]))
 		domain->profile = (u8) profile;
 	return 0;
 }
@@ -1881,6 +1959,9 @@
 
 /* String table for domain transition control keywords. */
 static const char * const ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
+	[CCS_TRANSITION_CONTROL_NAMESPACE]     = "move_namespace ",
+	[CCS_TRANSITION_CONTROL_NO_NAMESPACE]  = "no_move_namespace ",
+	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
 	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
 	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
 	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
@@ -1903,43 +1984,34 @@
  */
 static int ccs_write_exception(struct ccs_io_buffer *head)
 {
-	char *data = head->write_buf;
-	const bool is_delete = ccs_str_starts(&data, "delete ");
+	const bool is_delete = head->w.is_delete;
+	struct ccs_acl_param param = {
+		.ns = head->w.ns,
+		.is_delete = is_delete,
+		.data = head->write_buf,
+	};
 	u8 i;
-	static const struct {
-		const char *keyword;
-		int (*write) (char *, const bool);
-	} ccs_callback[2] = {
-		{ "aggregator ",    ccs_write_aggregator },
-		{ "deny_autobind ", ccs_write_reserved_port },
-	};
-	if (!is_delete && ccs_str_starts(&data, "select ") &&
-	    !strcmp(data, "transition_only")) {
-		head->r.print_transition_related_only = true;
-		return -EAGAIN;
-	}
-	/* Don't allow updating policies by non manager programs. */
-	if (!ccs_manager())
-		return -EPERM;
-	for (i = 0; i < 2; i++)
-		if (ccs_str_starts(&data, ccs_callback[i].keyword))
-			return ccs_callback[i].write(data, is_delete);
+	if (ccs_str_starts(&param.data, "aggregator "))
+		return ccs_write_aggregator(&param);
+	if (ccs_str_starts(&param.data, "deny_autobind "))
+		return ccs_write_reserved_port(&param);
 	for (i = 0; i < CCS_MAX_TRANSITION_TYPE; i++)
-		if (ccs_str_starts(&data, ccs_transition_type[i]))
-			return ccs_write_transition_control(data, is_delete,
-							    i);
+		if (ccs_str_starts(&param.data, ccs_transition_type[i]))
+			return ccs_write_transition_control(&param, i);
 	for (i = 0; i < CCS_MAX_GROUP; i++)
-		if (ccs_str_starts(&data, ccs_group_name[i]))
-			return ccs_write_group(data, is_delete, i);
-	if (ccs_str_starts(&data, "acl_group ")) {
+		if (ccs_str_starts(&param.data, ccs_group_name[i]))
+			return ccs_write_group(&param, i);
+	if (ccs_str_starts(&param.data, "acl_group ")) {
 		unsigned int group;
+		char *data = param.data;
 		if (sscanf(data, "%u", &group) == 1 &&
 		    group < CCS_MAX_ACL_GROUPS) {
 			data = strchr(data, ' ');
-			if (data)
-				return ccs_write_domain2(data + 1,
-							 &ccs_acl_group[group],
-							 is_delete);
+			if (data++)
+				return ccs_write_domain2(head->w.ns,
+							 head->w.ns->
+							 acl_group[group],
+							 data, is_delete);
 		}
 	}
 	return -EINVAL;
@@ -1957,7 +2029,10 @@
  */
 static bool ccs_read_group(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.group, &ccs_group_list[idx]) {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
+	struct list_head *list = &ns->group_list[idx];
+	list_for_each_cookie(head->r.group, list) {
 		struct ccs_group *group =
 			list_entry(head->r.group, typeof(*group), head.list);
 		list_for_each_cookie(head->r.acl, &group->member_list) {
@@ -1967,6 +2042,7 @@
 				continue;
 			if (!ccs_flush(head))
 				return false;
+			ccs_print_namespace(head);
 			ccs_set_string(head, ccs_group_name[idx]);
 			ccs_set_string(head, group->group_name->name);
 			if (idx == CCS_PATH_GROUP) {
@@ -1983,14 +2059,8 @@
 				struct ccs_address_group *member =
 					container_of(ptr, typeof(*member),
 						     head);
-				if (member->is_ipv6)
-					ccs_print_ipv6(buffer, sizeof(buffer),
-						       member->min.ipv6,
-						       member->max.ipv6);
-				else
-					ccs_print_ipv4(buffer, sizeof(buffer),
-						       member->min.ipv4,
-						       member->max.ipv4);
+				ccs_print_ip(buffer, sizeof(buffer),
+					     &member->address);
 				ccs_io_printf(head, " %s", buffer);
 			}
 			ccs_set_lf(head);
@@ -2013,7 +2083,10 @@
  */
 static bool ccs_read_policy(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[idx]) {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
+	struct list_head *list = &ns->policy_list[idx];
+	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_acl_head *acl =
 			container_of(head->r.acl, typeof(*acl), list);
 		if (acl->is_deleted)
@@ -2028,6 +2101,7 @@
 			{
 				struct ccs_transition_control *ptr =
 					container_of(acl, typeof(*ptr), head);
+				ccs_print_namespace(head);
 				ccs_set_string(head,
 					       ccs_transition_type[ptr->type]);
 				ccs_set_string(head, ptr->program ?
@@ -2041,6 +2115,7 @@
 			{
 				struct ccs_aggregator *ptr =
 					container_of(acl, typeof(*ptr), head);
+				ccs_print_namespace(head);
 				ccs_set_string(head, "aggregator ");
 				ccs_set_string(head, ptr->original_name->name);
 				ccs_set_space(head);
@@ -2052,12 +2127,10 @@
 			{
 				struct ccs_reserved *ptr =
 					container_of(acl, typeof(*ptr), head);
-				const u16 min_port = ptr->min_port;
-				const u16 max_port = ptr->max_port;
+				ccs_print_namespace(head);
 				ccs_set_string(head, "deny_autobind ");
-				ccs_io_printf(head, "%u", min_port);
-				if (min_port != max_port)
-					ccs_io_printf(head, "-%u", max_port);
+				ccs_print_number_union_nospace(head,
+							       &ptr->port);
 			}
 			break;
 		default:
@@ -2080,6 +2153,8 @@
  */
 static void ccs_read_exception(struct ccs_io_buffer *head)
 {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
 	if (head->r.eof)
 		return;
 	while (head->r.step < CCS_MAX_POLICY &&
@@ -2096,9 +2171,9 @@
 	       + CCS_MAX_ACL_GROUPS * 2) {
 		head->r.acl_group_index = (head->r.step - CCS_MAX_POLICY
 					   - CCS_MAX_GROUP) / 2;
-		if (!ccs_read_domain2(head,
-				      &ccs_acl_group[head->r.acl_group_index],
-				      head->r.step & 1))
+		if (!ccs_read_domain2(head, &ns->acl_group
+				      [head->r.acl_group_index]
+				      [head->r.step & 1]))
 			return;
 		head->r.step++;
 	}
@@ -2201,7 +2276,8 @@
 	if (symlink)
 		ccs_addprintf(buffer, len, "%s", symlink);
 	ccs_normalize_line(buffer);
-	if (!ccs_write_domain2(buffer, ccs_current_domain(), false))
+	if (!ccs_write_domain2(ccs_current_namespace(), ccs_current_domain()->
+			       acl_info_list, buffer, false))
 		ccs_update_stat(CCS_STAT_POLICY_UPDATES);
 	kfree(buffer);
 }
@@ -2477,9 +2553,9 @@
 
 /* String table for /proc/ccs/stat interface. */
 static const char * const ccs_memory_headers[CCS_MAX_MEMORY_STAT] = {
-	[CCS_MEMORY_POLICY] = "policy:",
-	[CCS_MEMORY_AUDIT]  = "audit log:",
-	[CCS_MEMORY_QUERY]  = "query message:",
+	[CCS_MEMORY_POLICY]     = "policy:",
+	[CCS_MEMORY_AUDIT]      = "audit log:",
+	[CCS_MEMORY_QUERY]      = "query message:",
 };
 
 /* Timestamp counter for last updated. */
@@ -2577,6 +2653,7 @@
 	struct ccs_io_buffer *head = kzalloc(sizeof(*head), CCS_GFP_FLAGS);
 	if (!head)
 		return -ENOMEM;
+	head->original_ns = ccs_current_namespace();
 	mutex_init(&head->io_sem);
 	head->type = type;
 	switch (type) {
@@ -2695,6 +2772,44 @@
 }
 
 /**
+ * ccs_move_namespace_cursor - Print namespace delimiter if needed.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ */
+static inline void ccs_move_namespace_cursor(struct ccs_io_buffer *head)
+{
+	struct list_head *ns;
+	if (head->type != CCS_EXCEPTIONPOLICY && head->type != CCS_PROFILE)
+		return;
+	/*
+	 * If this is the first read, or reading previous namespace finished
+	 * and has more namespaces to read, update the namespace cursor.
+	 */
+	ns = head->r.ns;
+	if (!ns || (head->r.eof && ns->next != &ccs_namespace_list)) {
+		/* Clearing is OK because ccs_flush() returned true. */
+		memset(&head->r, 0, sizeof(head->r));
+		head->r.ns = ns ? ns->next : ccs_namespace_list.next;
+	}
+}
+
+/**
+ * ccs_has_more_namespace - Check for unread namespaces.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true if we have more entries to print, false otherwise.
+ */
+static inline bool ccs_has_more_namespace(struct ccs_io_buffer *head)
+{
+	return (head->type == CCS_EXCEPTIONPOLICY ||
+		head->type == CCS_PROFILE) && head->r.eof &&
+		head->r.ns->next != &ccs_namespace_list;
+}
+
+/**
  * ccs_read_control - read() for /proc/ccs/ interface.
  *
  * @file:       Pointer to "struct file".
@@ -2720,8 +2835,10 @@
 	idx = ccs_read_lock();
 	if (ccs_flush(head))
 		/* Call the policy handler. */
-		head->read(head);
-	ccs_flush(head);
+		do {
+			ccs_move_namespace_cursor(head);
+			head->read(head);
+		} while (ccs_flush(head) && ccs_has_more_namespace(head));
 	ccs_read_unlock(idx);
 	len = head->read_user_buf - buffer;
 	mutex_unlock(&head->io_sem);
@@ -2752,13 +2869,6 @@
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
 	idx = ccs_read_lock();
-	/* Don't allow updating policies by non manager programs. */
-	if (head->write != ccs_write_pid && head->write != ccs_write_domain &&
-	    head->write != ccs_write_exception && !ccs_manager()) {
-		ccs_read_unlock(idx);
-		mutex_unlock(&head->io_sem);
-		return -EPERM;
-	}
 	/* Read a line and dispatch it to the policy handler. */
 	while (avail_len > 0) {
 		char c;
@@ -2787,15 +2897,68 @@
 		cp0[head->w.avail - 1] = '\0';
 		head->w.avail = 0;
 		ccs_normalize_line(cp0);
+		if (!strcmp(cp0, "reset")) {
+			head->w.ns = head->original_ns;
+			head->w.domain = NULL;
+			memset(&head->r, 0, sizeof(head->r));
+			continue;
+		}
+		/* Don't allow updating policies by non manager programs. */
+		switch (head->type) {
+		case CCS_PROCESS_STATUS:
+			/* This does not write anything. */
+			break;
+		case CCS_DOMAINPOLICY:
+			if (ccs_select_domain(head, cp0))
+				continue;
+			/* fall through */
+		case CCS_EXCEPTIONPOLICY:
+			if (!strcmp(cp0, "select transition_only")) {
+				head->r.print_transition_related_only = true;
+				continue;
+			}
+			/* fall through */
+		default:
+			if (!ccs_manager()) {
+				error = -EPERM;
+				goto out;
+			}
+		}
+		/* Delete request? */
+		head->w.is_delete = !strncmp(cp0, "delete ", 7);
+		if (head->w.is_delete)
+			memmove(cp0, cp0 + 7, strlen(cp0 + 7) + 1);
+		/* Selecting namespace to update. */
+		if (head->type == CCS_EXCEPTIONPOLICY ||
+		    head->type == CCS_PROFILE) {
+			if (*cp0 == '<') {
+				char *cp = strchr(cp0, ' ');
+				if (cp) {
+					*cp++ = '\0';
+					head->w.ns = ccs_assign_namespace(cp0);
+					memmove(cp0, cp, strlen(cp) + 1);
+				} else
+					head->w.ns = NULL;
+			} else
+				head->w.ns = head->original_ns;
+			/* Don't allow updating if namespace is invalid. */
+			if (!head->w.ns) {
+				error = -ENOENT;
+				goto out;
+			}
+		}
 		{
+			/* Do the update. */
 			const int ret = head->write(head);
 			if (ret == -EPERM) {
 				error = -EPERM;
 				break;
 			}
+			/* Do not update statistics if not updated. */
 			if (ret)
 				continue;
 		}
+		/* Update statistics. */
 		switch (head->type) {
 		case CCS_DOMAINPOLICY:
 		case CCS_EXCEPTIONPOLICY:
@@ -2809,6 +2972,7 @@
 			break;
 		}
 	}
+out:
 	ccs_read_unlock(idx);
 	mutex_unlock(&head->io_sem);
 	return error;
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c	(working copy)
@@ -417,15 +417,9 @@
 		{
 			struct ccs_inet_acl *entry =
 				container_of(acl, typeof(*entry), head);
-			switch (entry->address_type) {
-			case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
-				ccs_put_group(entry->address.group);
-				break;
-			case CCS_IP_ADDRESS_TYPE_IPv6:
-				ccs_put_ipv6_address(entry->address.ipv6.min);
-				ccs_put_ipv6_address(entry->address.ipv6.max);
-				break;
-			}
+			ccs_put_group(entry->address.group);
+			ccs_put_ipv6_address(entry->address.ipv6.min);
+			ccs_put_ipv6_address(entry->address.ipv6.max);
 			ccs_put_number_union(&entry->port);
 		}
 		break;
@@ -542,10 +536,8 @@
 {
 	struct ccs_address_group *member =
 		container_of(element, typeof(*member), head.list);
-	if (member->is_ipv6) {
-		ccs_put_ipv6_address(member->min.ipv6);
-		ccs_put_ipv6_address(member->max.ipv6);
-	}
+	ccs_put_ipv6_address(member->address.ipv6.min);
+	ccs_put_ipv6_address(member->address.ipv6.max);
 }
 
 /**
@@ -745,16 +737,16 @@
 /**
  * ccs_collect_acl - Delete elements in "struct ccs_domain_info".
  *
- * @domain: Pointer to "struct ccs_domain_info".
+ * @list: Pointer to "struct list_head[2]".
  *
  * Returns true if some elements are deleted, false otherwise.
  */
-static bool ccs_collect_acl(struct ccs_domain_info *domain)
+static bool ccs_collect_acl(struct list_head *list)
 {
 	struct ccs_acl_info *acl;
 	u8 i;
 	for (i = 0; i < 2; i++) {
-		list_for_each_entry(acl, &domain->acl_info_list[i], list) {
+		list_for_each_entry(acl, &list[i], list) {
 			if (!acl->is_deleted)
 				continue;
 			if (!ccs_add_to_gc(CCS_ID_ACL, &acl->list))
@@ -773,20 +765,15 @@
 {
 	int i;
 	enum ccs_policy_id id;
+	struct ccs_policy_namespace *ns;
 	int idx;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return;
 	idx = ccs_read_lock();
-	for (id = 0; id < CCS_MAX_POLICY; id++)
-		if (!ccs_collect_member(id, &ccs_policy_list[id]))
-			goto unlock;
-	for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
-		if (!ccs_collect_acl(&ccs_acl_group[i]))
-			goto unlock;
 	{
 		struct ccs_domain_info *domain;
 		list_for_each_entry(domain, &ccs_domain_list, list) {
-			if (!ccs_collect_acl(domain))
+			if (!ccs_collect_acl(domain->acl_info_list))
 				goto unlock;
 			if (!domain->is_deleted ||
 			    ccs_domain_used_by_task(domain))
@@ -795,28 +782,39 @@
 				goto unlock;
 		}
 	}
-	for (i = 0; i < CCS_MAX_GROUP; i++) {
-		struct list_head *list = &ccs_group_list[i];
-		struct ccs_group *group;
-		switch (i) {
-		case 0:
-			id = CCS_ID_PATH_GROUP;
-			break;
-		case 1:
-			id = CCS_ID_NUMBER_GROUP;
-			break;
-		default:
-			id = CCS_ID_ADDRESS_GROUP;
-			break;
-		}
-		list_for_each_entry(group, list, head.list) {
-			if (!ccs_collect_member(id, &group->member_list))
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		for (id = 0; id < CCS_MAX_POLICY; id++)
+			if (!ccs_collect_member(id, &ns->policy_list[id]))
 				goto unlock;
-			if (!list_empty(&group->member_list) ||
-			    atomic_read(&group->head.users))
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_GROUP, &group->head.list))
+		for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
+			if (!ccs_collect_acl(ns->acl_group[i]))
 				goto unlock;
+		for (i = 0; i < CCS_MAX_GROUP; i++) {
+			struct list_head *list = &ns->group_list[i];
+			struct ccs_group *group;
+			switch (i) {
+			case 0:
+				id = CCS_ID_PATH_GROUP;
+				break;
+			case 1:
+				id = CCS_ID_NUMBER_GROUP;
+				break;
+			default:
+				id = CCS_ID_ADDRESS_GROUP;
+				break;
+			}
+			list_for_each_entry(group, list, head.list) {
+				if (!ccs_collect_member(id,
+							&group->member_list))
+					goto unlock;
+				if (!list_empty(&group->member_list) ||
+				    atomic_read(&group->head.users))
+					continue;
+				if (!ccs_add_to_gc(CCS_ID_GROUP,
+						   &group->head.list))
+					goto unlock;
+			}
 		}
 	}
 	for (i = 0; i < CCS_MAX_LIST + CCS_MAX_HASH; i++) {
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/network.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/network.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/network.c	(working copy)
@@ -50,18 +50,19 @@
 };
 
 /**
- * ccs_parse_ip_address - Parse an IP address.
+ * ccs_parse_ipaddr_union - Parse an IP address.
  *
- * @address: String to parse.
- * @min:     Pointer to store min address.
- * @max:     Pointer to store max address.
+ * @param: Pointer to "struct ccs_acl_param".
+ * @ptr:   Pointer to "struct ccs_ipaddr_union".
  *
- * Returns CCS_IP_ADDRESS_TYPE_IPv6 if @address is an IPv6,
- * CCS_IP_ADDRESS_TYPE_IPv4 if @address is an IPv4,
- * CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP otherwise.
+ * Returns true on success, false otherwise.
  */
-int ccs_parse_ip_address(char *address, u16 *min, u16 *max)
+bool ccs_parse_ipaddr_union(struct ccs_acl_param *param,
+			    struct ccs_ipaddr_union *ptr)
 {
+	u16 min[8];
+	u16 max[8];
+	char *address = ccs_read_token(param);
 	int count = sscanf(address, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx"
 			   "-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
 			   &min[0], &min[1], &min[2], &min[3],
@@ -70,29 +71,40 @@
 			   &max[4], &max[5], &max[6], &max[7]);
 	if (count == 8 || count == 16) {
 		u8 i;
+		const struct in6_addr *ip[2];
 		if (count == 8)
 			memmove(max, min, sizeof(u16) * 8);
 		for (i = 0; i < 8; i++) {
 			min[i] = htons(min[i]);
 			max[i] = htons(max[i]);
 		}
-		return CCS_IP_ADDRESS_TYPE_IPv6;
+		ip[0] = ccs_get_ipv6_address((struct in6_addr *) min);
+		ip[1] = ccs_get_ipv6_address((struct in6_addr *) max);
+		if (!ip[0] || !ip[1]) {
+			ccs_put_ipv6_address(ip[0]);
+			ccs_put_ipv6_address(ip[1]);
+			return false;
+		}
+		ptr->ipv6.min = ip[0];
+		ptr->ipv6.max = ip[1];
+		return true;
 	}
 	count = sscanf(address, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
 		       &min[0], &min[1], &min[2], &min[3],
 		       &max[0], &max[1], &max[2], &max[3]);
 	if (count == 4 || count == 8) {
-		u32 ip = htonl((((u8) min[0]) << 24) + (((u8) min[1]) << 16)
-			       + (((u8) min[2]) << 8) + (u8) min[3]);
-		memmove(min, &ip, sizeof(ip));
-		if (count == 8)
-			ip = htonl((((u8) max[0]) << 24)
-				   + (((u8) max[1]) << 16)
-				   + (((u8) max[2]) << 8) + (u8) max[3]);
-		memmove(max, &ip, sizeof(ip));
-		return CCS_IP_ADDRESS_TYPE_IPv4;
+		/* use host byte order to allow u32 comparison.*/
+		ptr->ipv4.min = (((u8) min[0]) << 24) + (((u8) min[1]) << 16)
+			+ (((u8) min[2]) << 8) + (u8) min[3];
+		if (count == 4)
+			ptr->ipv4.max = ptr->ipv4.min;
+		else
+			ptr->ipv4.max =
+				(((u8) max[0]) << 24) + (((u8) max[1]) << 16)
+				+ (((u8) max[2]) << 8) + (u8) max[3];
+		return true;
 	}
-	return CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
+	return false;
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
@@ -123,8 +135,8 @@
  *
  * Returns nothing.
  */
-void ccs_print_ipv4(char *buffer, const int buffer_len,
-		    const u32 min_ip, const u32 max_ip)
+static void ccs_print_ipv4(char *buffer, const unsigned int buffer_len,
+			   const u32 min_ip, const u32 max_ip)
 {
 	memset(buffer, 0, buffer_len);
 	snprintf(buffer, buffer_len - 1, "%u.%u.%u.%u%c%u.%u.%u.%u",
@@ -152,9 +164,9 @@
  *
  * Returns nothing.
  */
-void ccs_print_ipv6(char *buffer, const int buffer_len,
-		    const struct in6_addr *min_ip,
-		    const struct in6_addr *max_ip)
+static void ccs_print_ipv6(char *buffer, const unsigned int buffer_len,
+			   const struct in6_addr *min_ip,
+			   const struct in6_addr *max_ip)
 {
 	memset(buffer, 0, buffer_len);
 	snprintf(buffer, buffer_len - 1,
@@ -163,6 +175,24 @@
 		 NIP6(*max_ip));
 }
 
+/**
+ * ccs_print_ip - Print an IP address.
+ *
+ * @buf:  Buffer to write to.
+ * @size: Size of @buf.
+ * @ptr:  Pointer to "struct ipaddr_union".
+ *
+ * Returns nothing.
+ */
+void ccs_print_ip(char *buf, const unsigned int size,
+		  const struct ccs_ipaddr_union *ptr)
+{
+	if (ptr->ipv6.min)
+		ccs_print_ipv6(buf, size, ptr->ipv6.min, ptr->ipv6.max);
+	else
+		ccs_print_ipv4(buf, size, ptr->ipv4.min, ptr->ipv4.max);
+}
+
 /*
  * Mapping table from "enum ccs_network_acl_index" to "enum ccs_mac_index" for
  * inet domain socket.
@@ -224,12 +254,7 @@
 	const struct ccs_inet_acl *p1 = container_of(a, typeof(*p1), head);
 	const struct ccs_inet_acl *p2 = container_of(b, typeof(*p2), head);
 	return p1->protocol == p2->protocol &&
-		p1->address_type == p2->address_type &&
-		p1->address.ipv4.min == p2->address.ipv4.min &&
-		p1->address.ipv6.min == p2->address.ipv6.min &&
-		p1->address.ipv4.max == p2->address.ipv4.max &&
-		p1->address.ipv6.max == p2->address.ipv6.max &&
-		p1->address.group == p2->address.group &&
+		ccs_same_ipaddr_union(&p1->address, &p2->address) &&
 		ccs_same_number_union(&p1->port, &p2->port);
 }
 
@@ -308,13 +333,10 @@
 int ccs_write_inet_network(struct ccs_acl_param *param)
 {
 	struct ccs_inet_acl e = { .head.type = CCS_TYPE_INET_ACL };
-	u16 min_address[8];
-	u16 max_address[8];
 	int error = -EINVAL;
 	u8 type;
 	const char *protocol = ccs_read_token(param);
 	const char *operation = ccs_read_token(param);
-	char *address = ccs_read_token(param);
 	for (e.protocol = 0; e.protocol < CCS_SOCK_MAX; e.protocol++)
 		if (!strcmp(protocol, ccs_proto_keyword[e.protocol]))
 			break;
@@ -323,43 +345,24 @@
 			e.perm |= 1 << type;
 	if (e.protocol == CCS_SOCK_MAX || !e.perm)
 		return -EINVAL;
-	switch (ccs_parse_ip_address(address, min_address, max_address)) {
-	case CCS_IP_ADDRESS_TYPE_IPv6:
-		e.address_type = CCS_IP_ADDRESS_TYPE_IPv6;
-		e.address.ipv6.min = ccs_get_ipv6_address((struct in6_addr *)
-							    min_address);
-		e.address.ipv6.max = ccs_get_ipv6_address((struct in6_addr *)
-							    max_address);
-		if (!e.address.ipv6.min || !e.address.ipv6.max)
-			goto out;
-		break;
-	case CCS_IP_ADDRESS_TYPE_IPv4:
-		e.address_type = CCS_IP_ADDRESS_TYPE_IPv4;
-		/* use host byte order to allow u32 comparison.*/
-		e.address.ipv4.min = ntohl(*(u32 *) min_address);
-		e.address.ipv4.max = ntohl(*(u32 *) max_address);
-		break;
-	default:
-		if (address[0] != '@')
-			return -EINVAL;
-		e.address_type = CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
-		e.address.group = ccs_get_group(address + 1,
-						CCS_ADDRESS_GROUP);
+	if (param->data[0] == '@') {
+		param->data++;
+		e.address.group = ccs_get_group(param, CCS_ADDRESS_GROUP);
 		if (!e.address.group)
 			return -ENOMEM;
-		break;
+	} else {
+		if (!ccs_parse_ipaddr_union(param, &e.address))
+			goto out;
 	}
-	if (!ccs_parse_number_union(ccs_read_token(param), &e.port))
+	if (!ccs_parse_number_union(param, &e.port) ||
+	    e.port.values[1] > 65535)
 		goto out;
 	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_inet_acl,
 				  ccs_merge_inet_acl);
 out:
-	if (e.address_type == CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP)
-		ccs_put_group(e.address.group);
-	else if (e.address_type == CCS_IP_ADDRESS_TYPE_IPv6) {
-		ccs_put_ipv6_address(e.address.ipv6.min);
-		ccs_put_ipv6_address(e.address.ipv6.max);
-	}
+	ccs_put_group(e.address.group);
+	ccs_put_ipv6_address(e.address.ipv6.min);
+	ccs_put_ipv6_address(e.address.ipv6.max);
 	ccs_put_number_union(&e.port);
 	return error;
 }
@@ -386,7 +389,7 @@
 			e.perm |= 1 << type;
 	if (e.protocol == CCS_SOCK_MAX || !e.perm)
 		return -EINVAL;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name))
+	if (!ccs_parse_name_union(param, &e.name))
 		return -EINVAL;
 	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_unix_acl,
 				  ccs_merge_unix_acl);
@@ -478,30 +481,23 @@
 			       const struct ccs_acl_info *ptr)
 {
 	const struct ccs_inet_acl *acl = container_of(ptr, typeof(*acl), head);
-	bool ret;
 	if (!(acl->perm & (1 << r->param.inet_network.operation)) ||
 	    !ccs_compare_number_union(r->param.inet_network.port, &acl->port))
 		return false;
-	switch (acl->address_type) {
-	case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
-		ret = ccs_address_matches_group(r->param.inet_network.is_ipv6,
-						r->param.inet_network.address,
-						acl->address.group);
-		break;
-	case CCS_IP_ADDRESS_TYPE_IPv4:
-		ret = !r->param.inet_network.is_ipv6 &&
-			acl->address.ipv4.min <= r->param.inet_network.ip &&
-			r->param.inet_network.ip <= acl->address.ipv4.max;
-		break;
-	default:
-		ret = r->param.inet_network.is_ipv6 &&
+	if (acl->address.group)
+		return ccs_address_matches_group(r->param.inet_network.is_ipv6,
+						 r->param.inet_network.address,
+						 acl->address.group);
+	else if (acl->address.ipv6.min)
+		return r->param.inet_network.is_ipv6 &&
 			memcmp(acl->address.ipv6.min,
 			       r->param.inet_network.address, 16) <= 0 &&
 			memcmp(r->param.inet_network.address,
 			       acl->address.ipv6.max, 16) <= 0;
-		break;
-	}
-	return ret;
+	else
+		return !r->param.inet_network.is_ipv6 &&
+			acl->address.ipv4.min <= r->param.inet_network.ip &&
+			r->param.inet_network.ip <= acl->address.ipv4.max;
 }
 
 /**
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/group.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/group.c	(revision 5044)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/group.c	(working copy)
@@ -55,80 +55,54 @@
 							  head);
 	const struct ccs_address_group *p2 = container_of(b, typeof(*p2),
 							  head);
-	return p1->is_ipv6 == p2->is_ipv6 &&
-		p1->min.ipv4 == p2->min.ipv4 && p1->min.ipv6 == p2->min.ipv6 &&
-		p1->max.ipv4 == p2->max.ipv4 && p1->max.ipv6 == p2->max.ipv6;
+	return ccs_same_ipaddr_union(&p1->address, &p2->address);
 }
 
 /**
  * ccs_write_group - Write "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- * @type:      Type of this group.
+ * @param: Pointer to "struct ccs_acl_param".
+ * @type:  Type of this group.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_group(char *data, const bool is_delete, const u8 type)
+int ccs_write_group(struct ccs_acl_param *param, const u8 type)
 {
-	struct ccs_group *group;
-	struct list_head *member;
-	char *w[2];
+	struct ccs_group *group = ccs_get_group(param, type);
 	int error = -EINVAL;
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	group = ccs_get_group(w[0], type);
 	if (!group)
 		return -ENOMEM;
-	member = &group->member_list;
+	param->list = &group->member_list;
 	if (type == CCS_PATH_GROUP) {
 		struct ccs_path_group e = { };
-		e.member_name = ccs_get_name(w[1]);
+		e.member_name = ccs_get_name(ccs_read_token(param));
 		if (!e.member_name) {
 			error = -ENOMEM;
 			goto out;
 		}
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_path_group);
+		error = ccs_update_policy(&e.head, sizeof(e), param,
+					  ccs_same_path_group);
 		ccs_put_name(e.member_name);
 	} else if (type == CCS_NUMBER_GROUP) {
 		struct ccs_number_group e = { };
-		if (w[1][0] == '@' || !ccs_parse_number_union(w[1], &e.number)
-		    || e.number.values[0] > e.number.values[1])
+		if (param->data[0] == '@' ||
+		    !ccs_parse_number_union(param, &e.number))
 			goto out;
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_number_group);
+		error = ccs_update_policy(&e.head, sizeof(e), param,
+					  ccs_same_number_group);
 		/*
-		 * ccs_put_number_union() is not needed because w[1][0] != '@'.
+		 * ccs_put_number_union() is not needed because
+		 * param->data[0] != '@'.
 		 */
 	} else {
 		struct ccs_address_group e = { };
-		u16 min_address[8];
-		u16 max_address[8];
-		switch (ccs_parse_ip_address(w[1], min_address, max_address)) {
-		case CCS_IP_ADDRESS_TYPE_IPv6:
-			e.is_ipv6 = true;
-			e.min.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
-							  min_address);
-			e.max.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
-							  max_address);
-			if (!e.min.ipv6 || !e.max.ipv6)
-				goto out_address;
-			break;
-		case CCS_IP_ADDRESS_TYPE_IPv4:
-			e.min.ipv4 = ntohl(*(u32 *) min_address);
-			e.max.ipv4 = ntohl(*(u32 *) max_address);
-			break;
-		default:
-			goto out_address;
-		}
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_address_group);
-out_address:
-		if (e.is_ipv6) {
-			ccs_put_ipv6_address(e.min.ipv6);
-			ccs_put_ipv6_address(e.max.ipv6);
-		}
+		if (param->data[0] == '@' ||
+		    !ccs_parse_ipaddr_union(param, &e.address))
+			goto out;
+		error = ccs_update_policy(&e.head, sizeof(e), param,
+					  ccs_same_address_group);
+		ccs_put_ipv6_address(e.address.ipv6.min);
+		ccs_put_ipv6_address(e.address.ipv6.max);
 	}
 out:
 	ccs_put_group(group);
@@ -211,16 +185,19 @@
 				 &ccs_ss) {
 		if (member->head.is_deleted)
 			continue;
-		if (member->is_ipv6) {
+		if (member->address.ipv6.min) {
 			if (is_ipv6 &&
-			    memcmp(member->min.ipv6, address, 16) <= 0 &&
-			    memcmp(address, member->max.ipv6, 16) <= 0) {
+			    memcmp(member->address.ipv6.min, address, 16)
+			    <= 0 &&
+			    memcmp(address, member->address.ipv6.max, 16)
+			    <= 0) {
 				matched = true;
 				break;
 			}
 		} else {
 			if (!is_ipv6 &&
-			    member->min.ipv4 <= ip && ip <= member->max.ipv4) {
+			    member->address.ipv4.min <= ip &&
+			    ip <= member->address.ipv4.max) {
 				matched = true;
 				break;
 			}
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.h
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.h	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.h	(working copy)
@@ -51,9 +51,6 @@
 
 /***** CONSTANTS DEFINITION START *****/
 
-#define CCS_ROOT_NAME                    "<kernel>"
-#define CCS_ROOT_NAME_LEN                (sizeof(CCS_ROOT_NAME) - 1)
-
 #define CCS_PROC_POLICY_DIR              "/proc/ccs/"
 #define CCS_PROC_POLICY_DOMAIN_POLICY    "/proc/ccs/domain_policy"
 #define CCS_PROC_POLICY_DOMAIN_STATUS    "/proc/ccs/.domain_status"
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-checkpolicy.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-checkpolicy.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-checkpolicy.c	(working copy)
@@ -238,17 +238,27 @@
 			pos = eq + 1;
 			if (!strcmp(pos, "NULL"))
 				goto next;
-			if (r_len < 2)
+			if (r_len < 2 || pos[0] != '"' ||
+			    pos[r_len - 1] != '"')
 				goto out;
-			if (pos[0] == '"' && pos[r_len - 1] == '"')
-				goto next;
-			goto out;
+			goto next;
 		} else if (!strcmp(pos, "auto_domain_transition")) {
 			pos = eq + 1;
-			if (r_len < 2)
+			if (r_len < 2 || pos[0] != '"' ||
+			    pos[r_len - 1] != '"')
 				goto out;
-			if (pos[0] == '"' && pos[r_len - 1] == '"')
-				goto next;
+			if (pos[1] != '/')
+				goto out;
+			goto next;
+		} else if (!strcmp(pos, "auto_namespace_transition")) {
+			pos = eq + 1;
+			if (r_len < 2 || pos[0] != '"' ||
+			    pos[r_len - 1] != '"')
+				goto out;
+			pos[r_len - 1] = '\0';
+			if (!ccs_domain_def(pos + 1))
+				goto out;
+			goto next;
 		} else if (!strcmp(pos, "grant_log")) {
 			pos = eq + 1;
 			if (!strcmp(pos, "yes") || !strcmp(pos, "no"))
@@ -662,7 +672,7 @@
 
 static void ccs_check_domain_policy(char *policy)
 {
-	if (!strncmp(policy, "<kernel>", 8)) {
+	if (ccs_domain_def(policy)) {
 		if (!ccs_correct_domain(policy) ||
 		    strlen(policy) >= CCS_MAX_DOMAINNAME_LEN) {
 			printf("%u: ERROR: '%s' is a bad domainname.\n",
@@ -700,8 +710,10 @@
 		{ "address_group ", ccs_check_path, ccs_check_ip_address },
 		{ "aggregator ", ccs_check_path, ccs_check_path },
 		{ "deny_autobind ", ccs_check_port },
+		{ "move_namespace ", ccs_check_path_domain },
 		{ "initialize_domain ", ccs_check_path_domain },
 		{ "keep_domain ", ccs_check_path_domain },
+		{ "no_move_namespace ", ccs_check_path_domain },
 		{ "no_initialize_domain ", ccs_check_path_domain },
 		{ "no_keep_domain ", ccs_check_path_domain },
 		{ "number_group ", ccs_check_path, ccs_check_number },
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.c	(working copy)
@@ -40,7 +40,7 @@
 /* Array of string ACL entries. */
 struct ccs_generic_acl *ccs_gacl_list = NULL;
 /* Length of ccs_generic_list array. */
-int ccs_gacl_list_count = 0;
+static int ccs_gacl_list_count = 0;
 
 /* Policy directory. */
 static const char *ccs_policy_dir = NULL;
@@ -62,6 +62,8 @@
 static unsigned int ccs_current_pid = 0;
 /* Currently active screen's index. */
 enum ccs_screen_type ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
+/* Previously active screen's index. */
+static enum ccs_screen_type ccs_previous_screen = CCS_SCREEN_DOMAIN_LIST;
 /*
  * Array of "initialize_domain"/"no_initialize_domain"/"keep_domain"/
  * "no_keep_domain" entries.
@@ -96,12 +98,18 @@
 /* Start from the first line when showing ACL screen? */
 static _Bool ccs_no_restore_cursor = false;
 
+/* Namespace to use. */
+static char *ccs_current_namespace = NULL;
+static int ccs_current_namespace_len = 0;
+
 /* Domain transition coltrol keywords. */
 static const char *ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
-	[CCS_TRANSITION_CONTROL_INITIALIZE] = "initialize_domain ",
+	[CCS_TRANSITION_CONTROL_NAMESPACE]     = "move_namespace ",
+	[CCS_TRANSITION_CONTROL_NO_NAMESPACE]  = "no_move_namespace ",
+	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
 	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
-	[CCS_TRANSITION_CONTROL_KEEP] = "keep_domain ",
-	[CCS_TRANSITION_CONTROL_NO_KEEP] = "no_keep_domain ",
+	[CCS_TRANSITION_CONTROL_KEEP]          = "keep_domain ",
+	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
 };
 
 static FILE *ccs_editpolicy_open_write(const char *filename);
@@ -152,6 +160,7 @@
 static void ccs_page_down_key(void);
 static void ccs_page_up_key(void);
 static void ccs_read_domain_and_exception_policy(void);
+static void ccs_read_namespace_list(void);
 static void ccs_read_generic_policy(void);
 static void ccs_resize_window(void);
 static void ccs_set_cursor_pos(const int index);
@@ -375,7 +384,7 @@
 }
 
 /**
- * ccs_add_transition_control_policy - Add "initialize_domain"/"no_initialize_domain"/"keep_domain"/ "no_keep_domain" entries.
+ * ccs_add_transition_control_policy - Add "move_namespace"/"no_move_namespace"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/ "no_keep_domain" entries.
  *
  * @data: Line to parse.
  * @type: One of values in "enum ccs_transition_type".
@@ -425,16 +434,26 @@
 {
 	const struct ccs_transition_control_entry *d_t =
 		ccs_transition_control(domainname, program);
-	if (d_t && d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE) {
+	if (d_t && (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE ||
+		    d_t->type == CCS_TRANSITION_CONTROL_NAMESPACE)) {
 		char *line;
 		int source;
 		ccs_get();
-		line = ccs_shprintf("%s %s", domainname->name, program);
+		if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE)
+			line = ccs_shprintf("%s %s", domainname->name,
+					    program);
+		else
+			line = ccs_shprintf("%s <%s>", domainname->name,
+					    program);
 		ccs_normalize_line(line);
 		source = ccs_assign_domain(&ccs_dp, line, true, false);
 		if (source == EOF)
 			ccs_out_of_memory();
-		line = ccs_shprintf(CCS_ROOT_NAME " %s", program);
+		if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE)
+			line = ccs_shprintf("%s %s", ccs_current_namespace,
+					    program);
+		else
+			line = ccs_shprintf("<%s>", program);
 		ccs_dp.list[source].target_domainname = strdup(line);
 		if (!ccs_dp.list[source].target_domainname)
 			ccs_out_of_memory();
@@ -465,12 +484,16 @@
  *
  * @index: Index in the domain policy.
  *
- * Returns index in the domain policy if found, EOF otherwise.
+ * Returns index in the domain policy if found, -2 if namespace jump,
+ * EOF otherwise.
  */
 static int ccs_find_target_domain(const int index)
 {
-	return ccs_find_domain(&ccs_dp, ccs_dp.list[index].target_domainname,
-			       false, false);
+	const char *cp = ccs_dp.list[index].target_domainname;
+	const char *sp = ccs_get_last_word(cp);
+	if (*sp == '<' && strcmp(ccs_current_namespace, sp))
+		return -2;
+	return ccs_find_domain(&ccs_dp, cp, false, false);
 }
 
 /**
@@ -544,8 +567,10 @@
 	if (redirect_index >= 0)
 		line = ccs_shprintf(" ( -> %d )",
 				    ccs_dp.list[redirect_index].number);
+	else if (redirect_index == EOF)
+                line = ccs_shprintf(" ( -> Not Found )");
 	else
-		line = ccs_shprintf(" ( -> Not Found )");
+		line = ccs_shprintf(" ( -> Namespace jump )");
 	printw("%s", ccs_eat(line));
 	tmp_col += strlen(line);
 	ccs_put();
@@ -972,6 +997,14 @@
 			if (ptr->program &&
 			    strcmp(ptr->program->name, program))
 				continue;
+			if (type == CCS_TRANSITION_CONTROL_NO_NAMESPACE) {
+				/*
+				 * Do not check for move_namespace if
+				 * no_move_namespace matched.
+				 */
+				type = CCS_TRANSITION_CONTROL_NO_INITIALIZE;
+				goto next;
+			}
 			if (type == CCS_TRANSITION_CONTROL_NO_INITIALIZE) {
 				/*
 				 * Do not check for initialize_domain if
@@ -980,7 +1013,8 @@
 				type = CCS_TRANSITION_CONTROL_NO_KEEP;
 				goto next;
 			}
-			if (type == CCS_TRANSITION_CONTROL_INITIALIZE ||
+			if (type == CCS_TRANSITION_CONTROL_NAMESPACE ||
+			    type == CCS_TRANSITION_CONTROL_INITIALIZE ||
 			    type == CCS_TRANSITION_CONTROL_KEEP)
 				return ptr;
 			else
@@ -1031,6 +1065,81 @@
 }
 
 /**
+ * ccs_is_current_namespace - Check namespace.
+ *
+ * @line: Line to check namespace.
+ *
+ * Returns true if this line deals current namespace, false otherwise.
+ */
+static _Bool ccs_is_current_namespace(const char *line)
+{
+	return !strncmp(line, ccs_current_namespace, ccs_current_namespace_len)
+		&& (line[ccs_current_namespace_len] == ' ' ||
+		    !line[ccs_current_namespace_len]);
+}
+
+static void ccs_add_generic_entry(const char *line, const enum
+				  ccs_editpolicy_directives directive)
+{
+	int i;
+	char *cp;
+	for (i = 0; i < ccs_gacl_list_count; i++)
+		if (!strcmp(line, ccs_gacl_list[i].operand))
+			return;
+	ccs_gacl_list = realloc(ccs_gacl_list,
+				(ccs_gacl_list_count + 1) *
+				sizeof(struct ccs_generic_acl));
+	if (!ccs_gacl_list)
+		ccs_out_of_memory();
+	cp = strdup(line);
+	if (!cp)
+		ccs_out_of_memory();
+	ccs_gacl_list[ccs_gacl_list_count].directive = directive;
+	ccs_gacl_list[ccs_gacl_list_count].selected = 0;
+	ccs_gacl_list[ccs_gacl_list_count++].operand = cp;
+}
+
+/**
+ * ccs_read_namespace_list - Read namespace list.
+ *
+ * Returns nothing.
+ */
+static void ccs_read_namespace_list(void)
+{
+	u8 i;
+	static const char *files[3] = { CCS_PROC_POLICY_PROFILE,
+					CCS_PROC_POLICY_EXCEPTION_POLICY,
+					CCS_PROC_POLICY_DOMAIN_POLICY };
+	while (ccs_gacl_list_count)
+		free((void *) ccs_gacl_list[--ccs_gacl_list_count].operand);
+	ccs_add_generic_entry("<kernel>", CCS_DIRECTIVE_NONE);
+	for (i = 0; i < 3; i++) {
+		FILE *fp = ccs_editpolicy_open_read(files[i]);
+		if (!fp)
+			continue;
+		ccs_get();
+		while (true) {
+			char *line = ccs_freadline_unpack(fp);
+			char *cp;
+			if (!line)
+				break;
+			cp = strchr(line, ' ');
+			if (cp)
+				*cp = '\0';
+			else if (i != 2)
+				continue;
+			if (!ccs_domain_def(line))
+				continue;
+			ccs_add_generic_entry(line, CCS_DIRECTIVE_NONE);
+		}
+		ccs_put();
+		fclose(fp);
+	}
+	qsort(ccs_gacl_list, ccs_gacl_list_count,
+	      sizeof(struct ccs_generic_acl), ccs_string_acl_compare);
+}
+
+/**
  * ccs_read_generic_policy - Read policy data other than domain policy.
  *
  * Returns nothing.
@@ -1040,9 +1149,7 @@
 	FILE *fp = NULL;
 	_Bool flag = false;
 	while (ccs_gacl_list_count)
-		free((void *)
-		     ccs_gacl_list[--ccs_gacl_list_count].
-		     operand);
+		free((void *) ccs_gacl_list[--ccs_gacl_list_count].operand);
 	if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
 		if (ccs_network_mode)
 			/* We can read after write. */
@@ -1088,6 +1195,14 @@
 			if (!line[0])
 				continue;
 		}
+		if ((ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST ||
+		    ccs_current_screen == CCS_SCREEN_PROFILE_LIST) &&
+		    *line == '<') {
+			char *cp = strchr(line, ' ');
+			if (!cp++ || !ccs_is_current_namespace(line))
+				continue;
+			memmove(line, cp, strlen(cp) + 1);
+		}
 		switch (ccs_current_screen) {
 		case CCS_SCREEN_EXCEPTION_LIST:
 		case CCS_SCREEN_ACL_LIST:
@@ -1108,20 +1223,7 @@
 			directive = CCS_DIRECTIVE_NONE;
 			break;
 		}
-		ccs_gacl_list =
-			realloc(ccs_gacl_list,
-				(ccs_gacl_list_count + 1) *
-				sizeof(struct ccs_generic_acl));
-		if (!ccs_gacl_list)
-			ccs_out_of_memory();
-		cp = strdup(line);
-		if (!cp)
-			ccs_out_of_memory();
-		ccs_gacl_list[ccs_gacl_list_count].directive =
-			directive;
-		ccs_gacl_list[ccs_gacl_list_count].selected = 0;
-		ccs_gacl_list[ccs_gacl_list_count++].operand =
-			cp;
+		ccs_add_generic_entry(line, directive);
 	}
 	ccs_put();
 	ccs_freadline_raw = false;
@@ -1281,10 +1383,16 @@
 	static char domainname[4096];
 	int source;
 	char *cp = strrchr(line, ' ');
-	if (!cp || strncmp(cp, " auto_domain_transition=\"", 25))
+	if (!cp)
 		return;
-	*cp = '\0';
-	cp += 25;
+	if (!strncmp(cp, " auto_domain_transition=\"", 25)) {
+		*cp = '\0';
+		cp += 25;
+	} else if (!strncmp(cp, " auto_namespace_transition=\"", 28)) {
+		*cp = '\0';
+		cp += 28;
+	} else
+		return;
 	source = strlen(cp);
 	if (!source)
 		return;
@@ -1395,19 +1503,13 @@
 static void ccs_parse_exception_line(char *line, const int max_index)
 {
 	unsigned int group;
-	if (ccs_str_starts(line, "initialize_domain "))
-		ccs_add_transition_control_policy
-			(line, CCS_TRANSITION_CONTROL_INITIALIZE);
-	else if (ccs_str_starts(line, "no_initialize_domain "))
-		ccs_add_transition_control_policy
-			(line, CCS_TRANSITION_CONTROL_NO_INITIALIZE);
-	else if (ccs_str_starts(line, "keep_domain "))
-		ccs_add_transition_control_policy
-			(line, CCS_TRANSITION_CONTROL_KEEP);
-	else if (ccs_str_starts(line, "no_keep_domain "))
-		ccs_add_transition_control_policy
-			(line, CCS_TRANSITION_CONTROL_NO_KEEP);
-	else if (ccs_str_starts(line, "path_group "))
+	for (group = 0; group < CCS_MAX_TRANSITION_TYPE; group++) {
+		if (!ccs_str_starts(line, ccs_transition_type[group]))
+			continue;
+		ccs_add_transition_control_policy(line, group);
+		return;
+	}
+	if (ccs_str_starts(line, "path_group "))
 		ccs_add_path_group_policy(line, false);
 	else if (ccs_str_starts(line, "address_group "))
 		ccs_add_address_group_policy(line, false);
@@ -1451,7 +1553,6 @@
 	ccs_clear_domain_policy(&ccs_dp);
 	ccs_transition_control_list_len = 0;
 	ccs_editpolicy_clear_groups();
-	ccs_assign_domain(&ccs_dp, CCS_ROOT_NAME, false, false);
 
 	/* Load all domain transition related entries. */
 	fp = NULL;
@@ -1476,7 +1577,11 @@
 			char *line = ccs_freadline_unpack(fp);
 			if (!line)
 				break;
-			if (ccs_domain_def(line)) {
+			if (*line == '<') {
+				if (!ccs_is_current_namespace(line)) {
+					index = EOF;
+					continue;
+				}
 				index = ccs_assign_domain(&ccs_dp, line, false,
 							  false);
 				continue;
@@ -1517,6 +1622,12 @@
 			char *line = ccs_freadline_unpack(fp);
 			if (!line)
 				break;
+			if (*line == '<') {
+				char *cp = strchr(line, ' ');
+				if (!cp++ || !ccs_is_current_namespace(line))
+					continue;
+				memmove(line, cp, strlen(cp) + 1);
+			}
 			ccs_parse_exception_line(line, max_index);
 		}
 		ccs_put();
@@ -1550,9 +1661,9 @@
 			d_t = ccs_transition_control(&parent, cp);
 			if (!d_t)
 				continue;
-			/* Initializer under <kernel> is reachable. */
+			/* Initializer under root of namespace is reachable. */
 			if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE &&
-			    parent.total_len == CCS_ROOT_NAME_LEN)
+			    !strchr(parent.name, ' '))
 				break;
 			ccs_dp.list[index].d_t = d_t;
 			continue;
@@ -1611,10 +1722,10 @@
 			= ccs_dp.list[index].string_ptr;
 		const int max_count = ccs_dp.list[index].string_count;
 		/*
-		 * Don't create source domain under <kernel> because
-		 * they will become target domains.
+		 * Don't create source domains under root of namespace
+		 * because they will become target domains.
 		 */
-		if (domainname->total_len == CCS_ROOT_NAME_LEN)
+		if (!strchr(domainname->name, ' '))
 			continue;
 		for (i = 0; i < max_count; i++) {
 			const struct ccs_path_info *cp = string_ptr[i];
@@ -1986,8 +2097,12 @@
 		const int index = ccs_editpolicy_get_current();
 		ccs_get();
 		ccs_eat_col = ptr->x;
-		line = ccs_shprintf("%s",
-				    ccs_eat(ccs_domain_name(&ccs_dp, index)));
+		if (index >= 0)
+			line = ccs_shprintf("%s",
+					    ccs_eat(ccs_domain_name(&ccs_dp,
+								    index)));
+		else
+			line = ccs_shprintf("%s", ccs_current_namespace);
 		if (ccs_window_width < strlen(line))
 			line[ccs_window_width] = '\0';
 		move(2, 0);
@@ -1997,6 +2112,21 @@
 		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
 		ccs_put();
 	}
+	if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST ||
+	    ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
+		char *line;
+		ccs_get();
+		ccs_eat_col = ptr->x;
+		line = ccs_shprintf("%s", ccs_current_namespace);
+		if (ccs_window_width < strlen(line))
+			line[ccs_window_width] = '\0';
+		move(2, 0);
+		clrtoeol();
+		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		printw("%s", line);
+		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		ccs_put();
+	}
 	move(CCS_HEADER_LINES + ptr->y, 0);
 	ccs_editpolicy_line_draw();     /* add color */
 	refresh();
@@ -2203,7 +2333,9 @@
 			if (!ccs_gacl_list[i].selected)
 				continue;
 			directive = ccs_gacl_list[i].directive;
-			fprintf(fp, "delete %s %s\n",
+			fprintf(fp, "delete %s %s %s\n",
+				ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST
+				? ccs_current_namespace : "",
 				ccs_directives[directive].original,
 				ccs_gacl_list[i].operand);
 		}
@@ -2252,14 +2384,17 @@
 			fprintf(fp, "select domain=%s\n", ccs_current_domain);
 		/* Fall through. */
 	case CCS_SCREEN_EXCEPTION_LIST:
+		if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST)
+			fprintf(fp, "%s ", ccs_current_namespace);
 		directive = ccs_find_directive(false, line);
 		if (directive != CCS_DIRECTIVE_NONE)
-			fprintf(fp, "%s ",
-				ccs_directives[directive].original);
+			fprintf(fp, "%s ", ccs_directives[directive].original);
 		break;
 	case CCS_SCREEN_PROFILE_LIST:
 		if (!strchr(line, '='))
-			fprintf(fp, "%s-COMMENT=\n", line);
+			fprintf(fp, "%s %s-COMMENT=\n", ccs_current_namespace,
+				line);
+		fprintf(fp, "%s ", ccs_current_namespace);
 		break;
 	default:
 		break;
@@ -2445,6 +2580,7 @@
 		if (cp)
 			*cp = '\0';
 		directive = ccs_gacl_list[index].directive;
+		fprintf(fp, "%s ", ccs_current_namespace);
 		if (directive < 256)
 			fprintf(fp, "%u-", directive);
 		fprintf(fp, "%s=%s\n", buf, line);
@@ -2501,27 +2637,50 @@
  *
  * @current: Index in the domain policy.
  *
- * Returns true if next window is ACL list, false otherwise.
+ * Returns true if next window is ACL list or namespace list, false otherwise.
  */
 static _Bool ccs_select_acl_window(const int current)
 {
 	char *old_domain;
-	if (ccs_current_screen != CCS_SCREEN_DOMAIN_LIST || current == EOF)
+	if (current == EOF)
 		return false;
+	if (ccs_current_screen == CCS_SCREEN_NAMESPACE_LIST) {
+		free(ccs_current_namespace);
+		ccs_current_namespace = strdup(ccs_gacl_list[current].operand);
+		if (!ccs_current_namespace)
+			ccs_out_of_memory();
+		ccs_current_namespace_len = strlen(ccs_current_namespace);
+		ccs_current_screen = ccs_previous_screen;
+		return true;
+	}
+	if (ccs_current_screen != CCS_SCREEN_DOMAIN_LIST)
+		return false;
 	ccs_current_pid = 0;
 	if (ccs_domain_sort_type) {
 		ccs_current_pid = ccs_task_list[current].pid;
 	} else if (ccs_initializer_source(current)) {
 		struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
 		const int redirect_index = ccs_find_target_domain(current);
-		if (redirect_index == EOF)
-			return false;
-		ptr->current = redirect_index - ptr->y;
-		while (ptr->current < 0) {
-			ptr->current++;
-			ptr->y--;
+		if (redirect_index >= 0) {
+			ptr->current = redirect_index - ptr->y;
+			while (ptr->current < 0) {
+				ptr->current++;
+				ptr->y--;
+			}
+			ccs_show_list();
 		}
-		ccs_show_list();
+		if (redirect_index == -2) {
+			free(ccs_current_namespace);
+			ccs_current_namespace =
+				strdup(ccs_get_last_word(ccs_dp.list[current].
+							 target_domainname));
+			if (!ccs_current_namespace)
+				ccs_out_of_memory();
+			ccs_current_namespace_len =
+				strlen(ccs_current_namespace);
+			ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
+			return true;
+		}
 		return false;
 	} else if (ccs_deleted_domain(current)) {
 		return false;
@@ -2536,6 +2695,7 @@
 	ccs_no_restore_cursor = old_domain &&
 		strcmp(old_domain, ccs_current_domain);
 	free(old_domain);
+	ccs_current_screen = CCS_SCREEN_ACL_LIST;
 	return true;
 }
 
@@ -2557,6 +2717,7 @@
 		printw("a     <<< Domain Policy Editor >>>\n");
 	printw("p     <<< Profile Editor >>>\n");
 	printw("m     <<< Manager Policy Editor >>>\n");
+	printw("n     <<< Namespace Selector >>>\n");
 	if (!ccs_offline_mode) {
 		/* printw("i     <<< Interactive Enforcing Mode >>>\n"); */
 		printw("s     <<< Statistics >>>\n");
@@ -2572,11 +2733,15 @@
 			return CCS_SCREEN_DOMAIN_LIST;
 		if (c == 'A' || c == 'a')
 			if (ccs_select_acl_window(current))
-				return CCS_SCREEN_ACL_LIST;
+				return ccs_current_screen;
 		if (c == 'P' || c == 'p')
 			return CCS_SCREEN_PROFILE_LIST;
 		if (c == 'M' || c == 'm')
 			return CCS_SCREEN_MANAGER_LIST;
+		if (c == 'N' || c == 'n') {
+			ccs_previous_screen = ccs_current_screen;
+			return CCS_SCREEN_NAMESPACE_LIST;
+		}
 		if (!ccs_offline_mode) {
 			/*
 			if (c == 'I' || c == 'i')
@@ -2684,9 +2849,14 @@
 	} else if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
 		ccs_policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
 		ccs_list_caption = "Domain Policy Editor";
+		/*
 	} else if (ccs_current_screen == CCS_SCREEN_QUERY_LIST) {
 		ccs_policy_file = CCS_PROC_POLICY_QUERY;
 		ccs_list_caption = "Interactive Enforcing Mode";
+		*/
+	} else if (ccs_current_screen == CCS_SCREEN_NAMESPACE_LIST) {
+		ccs_policy_file = CCS_PROC_POLICY_DOMAIN_STATUS;
+		ccs_list_caption = "Namespace Selector";
 	} else if (ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
 		ccs_policy_file = CCS_PROC_POLICY_PROFILE;
 		ccs_list_caption = "Profile Editor";
@@ -2718,6 +2888,9 @@
 			ccs_read_process_list(true);
 			ccs_adjust_cursor_pos(ccs_task_list_len);
 		}
+	} else if (ccs_current_screen == CCS_SCREEN_NAMESPACE_LIST) {
+		ccs_read_namespace_list();
+		ccs_adjust_cursor_pos(ccs_gacl_list_count);
 	} else {
 		ccs_read_generic_policy();
 		ccs_adjust_cursor_pos(ccs_gacl_list_count);
@@ -2833,6 +3006,7 @@
 			case CCS_SCREEN_ACL_LIST:
 			case CCS_SCREEN_PROFILE_LIST:
 			case CCS_SCREEN_MANAGER_LIST:
+			case CCS_SCREEN_NAMESPACE_LIST:
 				ccs_add_entry();
 				goto start;
 			default:
@@ -2842,7 +3016,7 @@
 		case '\r':
 		case '\n':
 			if (ccs_select_acl_window(current))
-				return CCS_SCREEN_ACL_LIST;
+				return ccs_current_screen;
 			break;
 		case 's':
 		case 'S':
@@ -2965,6 +3139,11 @@
 				goto usage;
 			ccs_policy_dir = ptr;
 			ccs_offline_mode = true;
+		} else if (*ptr == '<') {
+			if (ccs_current_namespace || strchr(ptr, ' ') ||
+			    !ccs_domain_def(ptr))
+				goto usage;
+			ccs_current_namespace = strdup(ptr);
 		} else if (cp) {
 			*cp++ = '\0';
 			if (ccs_network_mode || ccs_offline_mode)
@@ -2990,12 +3169,17 @@
 			 != 1) {
 usage:
 			printf("Usage: %s [e|d|p|m|s] [readonly] "
-			       "[refresh=interval] "
+			       "[refresh=interval] [<namespace>]"
 			       "[{policy_dir|remote_ip:remote_port}]\n",
 			       argv[0]);
 			exit(1);
 		}
 	}
+	if (!ccs_current_namespace)
+		ccs_current_namespace = strdup("<kernel>");
+	if (!ccs_current_namespace)
+		goto usage;
+	ccs_current_namespace_len = strlen(ccs_current_namespace);
 }
 
 /**
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_offline.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_offline.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_offline.c	(working copy)
@@ -94,7 +94,7 @@
 	memset(&ccs_dp, 0, sizeof(ccs_dp));
 	memset(&mp, 0, sizeof(mp));
 	ccs_get();
-	ccs_assign_domain(&ccs_dp, CCS_ROOT_NAME, false, false);
+	ccs_assign_domain(&ccs_dp, "<kernel>", false, false);
 	while (true) {
 		FILE *fp;
 		struct msghdr msg;
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_optimizer.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_optimizer.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_optimizer.c	(working copy)
@@ -237,8 +237,10 @@
 		if (!cp)
 			return;
 		if (index == CCS_DIRECTIVE_IPC_SIGNAL && i == 1 &&
-		    !strncmp(buffer, "<kernel>", 8)) {
-			cp = buffer + 8;
+		    ccs_domain_def(buffer)) {
+			cp = strchr(buffer, ' ');
+			if (!cp)
+				return;
 			while (*cp) {
 				if (*cp++ != ' ' || *cp++ == '/')
 					continue;
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_keyword.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_keyword.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_keyword.c	(working copy)
@@ -314,11 +314,14 @@
 	[CCS_DIRECTIVE_IPC_SIGNAL]    = { "ipc signal", NULL, 0, 0 },
 	[CCS_DIRECTIVE_KEEP_DOMAIN]   = { "keep_domain", NULL, 0, 0 },
 	[CCS_DIRECTIVE_MISC_ENV]      = { "misc env", NULL, 0, 0 },
+	[CCS_DIRECTIVE_MOVE_NAMESPACE] = { "move_namespace", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NETWORK_INET]  = { "network inet", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NETWORK_UNIX]  = { "network unix", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NONE]          = { "", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN]
 	= { "no_initialize_domain", NULL, 0, 0 },
+	[CCS_DIRECTIVE_NO_MOVE_NAMESPACE]
+	= { "no_move_namespace", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NO_KEEP_DOMAIN] = { "no_keep_domain", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NUMBER_GROUP]  = { "number_group", NULL, 0, 0 },
 	[CCS_DIRECTIVE_PATH_GROUP]    = { "path_group", NULL, 0, 0 },
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.h
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.h	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.h	(working copy)
@@ -29,13 +29,16 @@
 	CCS_SCREEN_ACL_LIST,
 	CCS_SCREEN_PROFILE_LIST,
 	CCS_SCREEN_MANAGER_LIST,
-	CCS_SCREEN_QUERY_LIST,
+	/* CCS_SCREEN_QUERY_LIST, */
+	CCS_SCREEN_NAMESPACE_LIST,
 	CCS_SCREEN_STAT_LIST,
 	CCS_MAXSCREEN
 };
 
 enum ccs_transition_type {
 	/* Do not change this order, */
+	CCS_TRANSITION_CONTROL_NO_NAMESPACE,
+	CCS_TRANSITION_CONTROL_NAMESPACE,
 	CCS_TRANSITION_CONTROL_NO_INITIALIZE,
 	CCS_TRANSITION_CONTROL_INITIALIZE,
 	CCS_TRANSITION_CONTROL_NO_KEEP,
@@ -334,9 +337,11 @@
 	CCS_DIRECTIVE_IPC_SIGNAL,
 	CCS_DIRECTIVE_KEEP_DOMAIN,
 	CCS_DIRECTIVE_MISC_ENV,
+	CCS_DIRECTIVE_MOVE_NAMESPACE,
 	CCS_DIRECTIVE_NETWORK_INET,
 	CCS_DIRECTIVE_NETWORK_UNIX,
 	CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN,
+	CCS_DIRECTIVE_NO_MOVE_NAMESPACE,
 	CCS_DIRECTIVE_NO_KEEP_DOMAIN,
 	CCS_DIRECTIVE_NUMBER_GROUP,
 	CCS_DIRECTIVE_PATH_GROUP,
@@ -441,7 +446,6 @@
 void ccs_editpolicy_sttr_save(void);
 
 extern enum ccs_screen_type ccs_current_screen;
-extern int ccs_gacl_list_count;
 extern int ccs_list_item_count;
 extern int ccs_path_group_list_len;
 extern int ccs_persistent_fd;
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-findtemp.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-findtemp.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-findtemp.c	(working copy)
@@ -38,8 +38,7 @@
 				char *cp = strchr(buffer, '\n');
 				if (cp)
 					*cp = '\0';
-				if (!strncmp(buffer, "<kernel>", 8) &&
-				    (buffer[8] == ' ' || !buffer[8])) {
+				if (ccs_domain_def(buffer)) {
 					free(domain);
 					domain = strdup(buffer);
 					if (!domain)
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c	(working copy)
@@ -286,22 +286,6 @@
 }
 
 /**
- * ccs_domain_def - Check whether the given token can be a domainname.
- *
- * @domainname: The token to check.
- *
- * Returns true if @domainname possibly be a domainname, false otherwise.
- *
- * Note that this function in kernel source checks only !strncmp() part.
- */
-_Bool ccs_domain_def(const char *domainname)
-{
-	return !strncmp(domainname, CCS_ROOT_NAME, CCS_ROOT_NAME_LEN) &&
-		(domainname[CCS_ROOT_NAME_LEN] == '\0'
-		 || domainname[CCS_ROOT_NAME_LEN] == ' ');
-}
-
-/**
  * ccs_fprintf_encoded - fprintf() using TOMOYO's escape rules.
  *
  * @fp:       Pointer to "FILE".
@@ -481,6 +465,30 @@
 }
 
 /**
+ * ccs_domain_def - Check whether the given token can be a domainname.
+ *
+ * @buffer: The token to check.
+ *
+ * Returns true if @buffer possibly be a domainname, false otherwise.
+ */
+_Bool ccs_domain_def(const char *buffer)
+{
+	const char *cp;
+	int len;
+	       if (*buffer != '<')
+		       return false;
+	       cp = strchr(buffer, ' ');
+	       if (!cp)
+		       len = strlen(buffer);
+	       else
+		       len = cp - buffer;
+	       if (buffer[len - 1] != '>' ||
+		   !ccs_correct_word2(buffer + 1, len - 2))
+		       return false;
+	       return true;
+}
+
+/**
  * ccs_correct_domain - Check whether the given domainname follows the naming rules.
  *
  * @domainname: The domainname to check.
@@ -489,14 +497,11 @@
  */
 _Bool ccs_correct_domain(const char *domainname)
 {
-	if (!domainname || strncmp(domainname, CCS_ROOT_NAME,
-				   CCS_ROOT_NAME_LEN))
-		goto out;
-	domainname += CCS_ROOT_NAME_LEN;
-	if (!*domainname)
+	if (!domainname || !ccs_domain_def(domainname))
+		return false;
+	domainname = strchr(domainname, ' ');
+	if (!domainname++)
 		return true;
-	if (*domainname++ != ' ')
-		goto out;
 	while (1) {
 		const char *cp = strchr(domainname, ' ');
 		if (!cp)
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-domainmatch.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-domainmatch.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-domainmatch.c	(working copy)
@@ -43,8 +43,7 @@
 		char *cp = strchr(buffer, '\n');
 		if (cp)
 			*cp = '\0';
-		if (!strncmp(buffer, "<kernel>", 8) &&
-		    (buffer[8] == ' ' || !buffer[8])) {
+		if (ccs_domain_def(buffer)) {
 			free(domain);
 			domain = strdup(buffer);
 			if (!domain)
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-patternize.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-patternize.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-patternize.c	(working copy)
@@ -514,7 +514,7 @@
 		char *sp = ccs_freadline_unpack(stdin);
 		if (!sp)
 			break;
-		if (!strncmp(sp, "<kernel>", 8) && (!sp[8] || sp[8] == ' ')) {
+		if (ccs_domain_def(sp)) {
 			free(ccs_current_domainname);
 			ccs_current_domainname = strdup(sp);
 			printf("%s\n", sp);
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/Makefile
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/Makefile	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/Makefile	(working copy)
@@ -15,8 +15,8 @@
 	sleep 10
 
 libccstools.so: ccstools.c ccstools.h
-	$(CC) $(CFLAGS) -fPIC ccstools.c -shared -Wl,-soname,libccstools.so.1 -o libccstools.so.1.0.4
-	ln -sf libccstools.so.1.0.4 libccstools.so
+	$(CC) $(CFLAGS) -fPIC ccstools.c -shared -Wl,-soname,libccstools.so.1 -o libccstools.so.1.0.5
+	ln -sf libccstools.so.1.0.5 libccstools.so
 
 .c:
 	$(CC) $(CFLAGS) -o $@ -lccstools -L. $<
@@ -29,8 +29,8 @@
 
 install: all
 	mkdir -p -m 0755 $(INSTALLDIR)$(USRLIBDIR)
-	$(INSTALL) -m 0755 libccstools.so.1.0.4 $(INSTALLDIR)$(USRLIBDIR)
-	ln -sf libccstools.so.1.0.4 $(INSTALLDIR)$(USRLIBDIR)/libccstools.so.1
+	$(INSTALL) -m 0755 libccstools.so.1.0.5 $(INSTALLDIR)$(USRLIBDIR)
+	ln -sf libccstools.so.1.0.5 $(INSTALLDIR)$(USRLIBDIR)/libccstools.so.1
 ifeq ($(INSTALLDIR),)
 	ldconfig || true
 endif
Index: trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/init_policy.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/init_policy.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/init_policy.c	(working copy)
@@ -1277,9 +1277,11 @@
 "keyword_alias ipc signal                    = ipc signal\n"
 "keyword_alias keep_domain                   = keep_domain\n"
 "keyword_alias misc env                      = misc env\n"
+"keyword_alias move_namespace                = move_namespace\n"
 "keyword_alias network inet                  = network inet\n"
 "keyword_alias network unix                  = network unix\n"
 "keyword_alias no_initialize_domain          = no_initialize_domain\n"
+"keyword_alias no_move_namespace             = no_move_namespace\n"
 "keyword_alias no_keep_domain                = no_keep_domain\n"
 "keyword_alias number_group                  = number_group\n"
 "keyword_alias path_group                    = path_group\n"
@@ -1417,7 +1419,7 @@
 "# This file contains rewriting rules used by ccs-patternize command.\n"
 "\n"
 "# Domain policy consists with domain declaration lines (which start with\n"
-"# <kernel> ) and acl declaration lines (which do not start with <kernel> ).\n"
+"# '<' ,) and acl declaration lines (which do not start with '<' ).\n"
 "# You can refer the former using 'domain' keyword and the latter using 'acl'"
 "\n"
 "# keyword.\n"
Index: trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/convert-audit-log.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/convert-audit-log.c	(revision 5044)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/convert-audit-log.c	(working copy)
@@ -100,6 +100,7 @@
 
 int main(int argc, char *argv[])
 {
+	char *namespace = NULL;
 	char *domainname = NULL;
 	memset(buffer, 0, sizeof(buffer));
 	if (argc > 1) {
@@ -125,8 +126,12 @@
 		else if (!strncmp(buffer, "symlink.target=", 15)) {
 			realloc_buffer(strlen(buffer) + 2);
 			cond_len += sprintf(cond + cond_len, " %s", buffer);
-		} else if (!strcmp(buffer, "<kernel>")) {
+		} else if (buffer[0] == '<' /* ccs_domain_def(buffer) */) {
 			char *cp;
+			free(namespace);
+			namespace = strdup(buffer);
+			if (!namespace)
+				break;
 			if (!fgets(buffer, sizeof(buffer) - 1, stdin) ||
 			    !strchr(buffer, '\n'))
 				break;
@@ -145,7 +150,7 @@
 				cond_len = 0;
 				continue;
 			}
-			printf("<kernel>%s", domainname);
+			printf("%s%s", namespace, domainname);
 			printf("%s", buffer);
 			if (cond_len) {
 				printf("%s", cond);
@@ -155,6 +160,7 @@
 		}
 	}
 	free(domainname);
+	free(namespace);
 	free(cond);
 	return 0;
 }
