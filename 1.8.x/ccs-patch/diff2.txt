Index: security/ccsecurity/audit.c
===================================================================
--- security/ccsecurity/audit.c	(revision 4649)
+++ security/ccsecurity/audit.c	(working copy)
@@ -494,10 +494,6 @@
 void ccs_read_log(struct ccs_io_buffer *head)
 {
 	struct ccs_log *ptr = NULL;
-	if (head->r.w_pos)
-		return;
-	kfree(head->read_buf);
-	head->read_buf = NULL;
 	spin_lock(&ccs_log_lock);
 	if (!list_empty(&ccs_log)) {
 		ptr = list_entry(ccs_log.next, typeof(*ptr), list);
@@ -507,8 +503,9 @@
 	}
 	spin_unlock(&ccs_log_lock);
 	if (ptr) {
-		head->read_buf = ptr->log;
-		head->r.w[head->r.w_pos++] = head->read_buf;
+		kfree(head->reader->buffer);
+		head->reader->buffer = ptr->log;
+		ccs_set_string(head, ptr->log);
 		kfree(ptr);
 	}
 }
Index: security/ccsecurity/internal.h
===================================================================
--- security/ccsecurity/internal.h	(revision 4649)
+++ security/ccsecurity/internal.h	(working copy)
@@ -1314,50 +1314,49 @@
 	bool is_delete;
 };
 
-/* Structure for reading/writing policy via /proc interfaces. */
+struct ccs_io_buffer;
+struct ccs_reader_struct {
+	wait_queue_head_t request_wait;
+	wait_queue_head_t response_wait;
+	/* Updated by userspace thread. */
+	unsigned int request_size;
+	struct list_head *seek_to_domain;
+	/* Updated by kernel thread. */
+	struct list_head *domain;
+	struct list_head *group;
+	struct list_head *acl;
+	unsigned int response_size;
+	unsigned int buffer_size;
+	char *buffer;
+	int reader_idx;
+	int query_index;
+	u8 group_index;
+	bool eof;
+	bool print_this_domain_only;
+	bool print_cond_part;
+};
+
+/* Structure for reading/writing policy via /proc/ccs/ interfaces. */
 struct ccs_io_buffer {
+	atomic_t users;
 	void (*read) (struct ccs_io_buffer *);
 	int (*write) (struct ccs_io_buffer *);
 	int (*poll) (struct file *file, poll_table *wait);
 	/* Exclusive lock for this structure.   */
 	struct mutex io_sem;
-	/* Index returned by ccs_lock().        */
-	int reader_idx;
-	char __user *read_user_buf;
-	int read_user_buf_avail;
+	struct ccs_reader_struct *reader;
 	struct {
-		struct list_head *domain;
-		struct list_head *group;
-		struct list_head *acl;
-		int avail;
-		int step;
-		int query_index;
-		u16 index;
-		u16 cond_index;
-		u8 group_index;
-		u8 cond_step;
-		u8 bit;
-		u8 w_pos;
-		bool eof;
-		bool print_this_domain_only;
-		bool print_execute_only;
-		bool print_cond_part;
-		const char *w[CCS_MAX_IO_READ_QUEUE];
-	} r;
-	struct {
 		struct ccs_domain_info *domain;
 		int avail;
 	} w;
-	/* Buffer for reading.                  */
-	char *read_buf;
-	/* Size of read buffer.                 */
-	int readbuf_size;
 	/* Buffer for writing.                  */
 	char *write_buf;
 	/* Size of write buffer.                */
 	int writebuf_size;
 	/* One of values in "enum ccs_proc_interface_index". */
 	u8 type;
+	/* List for telling GC not to kfree() elements. */
+	struct list_head list;
 };
 
 /* Structure for /proc/ccs/profile interface. */
@@ -1434,7 +1433,6 @@
 int ccs_env_perm(struct ccs_request_info *r, const char *env);
 int ccs_get_path(const char *pathname, struct path *path);
 int ccs_init_request_info(struct ccs_request_info *r, const u8 index);
-int ccs_lock(void);
 int ccs_open_control(const u8 type, struct file *file);
 int ccs_parse_ip_address(char *address, u16 *min, u16 *max);
 int ccs_path_permission(struct ccs_request_info *r, u8 operation,
@@ -1485,10 +1483,12 @@
 		   bool (*check_entry) (struct ccs_request_info *,
 					const struct ccs_acl_info *));
 void ccs_convert_time(time_t time, struct ccs_time *p);
+void ccs_daemonize(const char *name);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
 void ccs_get_attributes(struct ccs_obj_info *obj);
 void ccs_memory_free(const void *ptr, size_t size);
 void ccs_normalize_line(unsigned char *buffer);
+void ccs_notify_gc(struct ccs_io_buffer *head, const bool is_register);
 void ccs_print_ipv4(char *buffer, const int buffer_len, const u32 min_ip,
 		    const u32 max_ip);
 void ccs_print_ipv6(char *buffer, const int buffer_len,
@@ -1500,8 +1500,8 @@
 void ccs_put_number_union(struct ccs_number_union *ptr);
 void ccs_read_log(struct ccs_io_buffer *head);
 void ccs_run_gc(void);
+void ccs_set_string(struct ccs_io_buffer *head, const char *string);
 void ccs_transition_failed(const char *domainname);
-void ccs_unlock(const int idx);
 void ccs_update_stat(const u8 index);
 void ccs_warn_oom(const char *function);
 void ccs_write_log(struct ccs_request_info *r, const char *fmt, ...)
@@ -1613,6 +1613,9 @@
 
 #else
 
+int ccs_lock(void);
+void ccs_unlock(const int idx);
+
 /**
  * ccs_read_lock - Take lock for protecting policy.
  *
Index: security/ccsecurity/policy_io.c
===================================================================
--- security/ccsecurity/policy_io.c	(revision 4649)
+++ security/ccsecurity/policy_io.c	(working copy)
@@ -300,48 +300,6 @@
 }
 
 /**
- * ccs_flush - Flush queued string to userspace's buffer.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true if all data was flushed, false otherwise.
- */
-static bool ccs_flush(struct ccs_io_buffer *head)
-{
-	while (head->r.w_pos) {
-		const char *w = head->r.w[0];
-		int len = strlen(w);
-		if (len) {
-			if (len > head->read_user_buf_avail)
-				len = head->read_user_buf_avail;
-			if (!len)
-				return false;
-			if (copy_to_user(head->read_user_buf, w, len))
-				return false;
-			head->read_user_buf_avail -= len;
-			head->read_user_buf += len;
-			w += len;
-		}
-		head->r.w[0] = w;
-		if (*w)
-			return false;
-		/* Add '\0' for audit logs and query. */
-		if (head->poll) {
-			if (!head->read_user_buf_avail ||
-			    copy_to_user(head->read_user_buf, "", 1))
-				return false;
-			head->read_user_buf_avail--;
-			head->read_user_buf++;
-		}
-		head->r.w_pos--;
-		for (len = 0; len < head->r.w_pos; len++)
-			head->r.w[len] = head->r.w[len + 1];
-	}
-	head->r.avail = 0;
-	return true;
-}
-
-/**
  * ccs_set_string - Queue string to "struct ccs_io_buffer" structure.
  *
  * @head:   Pointer to "struct ccs_io_buffer".
@@ -353,13 +311,50 @@
  * This means that char[] allocated on stack memory cannot be passed to
  * this function. Use ccs_io_printf() for char[] allocated on stack memory.
  */
-static void ccs_set_string(struct ccs_io_buffer *head, const char *string)
+void ccs_set_string(struct ccs_io_buffer *head, const char *string)
 {
-	if (head->r.w_pos < CCS_MAX_IO_READ_QUEUE) {
-		head->r.w[head->r.w_pos++] = string;
-		ccs_flush(head);
-	} else
-		printk(KERN_WARNING "Too many words in a line.\n");
+	struct ccs_reader_struct *reader = head->reader;
+	int slen = strlen(string);
+	/* Add '\0' for audit logs and query. */
+	if (head->poll)
+		slen++;
+	while (slen) {
+		int rlen;
+		/* If we have read up to requested bytes, notify the caller. */
+		if (reader->response_size == reader->request_size)
+			wake_up(&reader->response_wait);
+		/*
+		 * Leave the SRCU read section, for the caller might leave
+		 * read() and we can't know when the caller reenters read().
+		 *
+		 * Since "struct ccs_io_buffer *" was registered by
+		 * ccs_notify_gc(), it is safe to leave the SRCU read section
+		 * without clearing cursors because ccs_used_by_io_buffer()
+		 * will find it.
+		 */
+		ccs_read_unlock(reader->reader_idx);
+		/*
+		 * Wait for the next read request, indicated by positive
+		 * request_size. The caller might call close(), indicated by
+		 * users counter.
+		 */
+		wait_event_interruptible(reader->request_wait,
+					 reader->request_size ||
+					 atomic_read(&head->users) == 1);
+		/* Reenter the SRCU read section. */
+		reader->reader_idx = ccs_read_lock();
+		rlen = reader->request_size;
+		if (rlen <= 0)
+			return;
+		if (rlen >= sizeof(reader->buffer))
+			rlen = sizeof(reader->buffer);
+		if (rlen >= slen)
+			rlen = slen;
+		memmove(reader->buffer, string, rlen);
+		string += rlen;
+		reader->response_size += rlen;
+		slen -= rlen;
+	}
 }
 
 /* Prototype for ccs_io_printf(). */
@@ -376,21 +371,16 @@
  */
 static void ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
 {
+	struct ccs_reader_struct *reader = head->reader;
 	va_list args;
-	int len;
-	int pos = head->r.avail;
-	int size = head->readbuf_size - pos;
-	if (size <= 0)
+	int len = reader->buffer_size;
+	if (len <= 1)
 		return;
 	va_start(args, fmt);
-	len = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;
+	vsnprintf(reader->buffer, len, fmt, args);
 	va_end(args);
-	if (pos + len >= head->readbuf_size) {
-		printk(KERN_WARNING "Too many words in a line.\n");
-		return;
-	}
-	head->r.avail += len;
-	ccs_set_string(head, head->read_buf + pos);
+	reader->buffer[len - 1] = '\0';
+	ccs_set_string(head, reader->buffer);
 }
 
 /**
@@ -412,10 +402,9 @@
  *
  * Returns nothing.
  */
-static bool ccs_set_lf(struct ccs_io_buffer *head)
+static void ccs_set_lf(struct ccs_io_buffer *head)
 {
 	ccs_set_string(head, "\n");
-	return !head->r.w_pos;
 }
 
 /**
@@ -691,77 +680,44 @@
  */
 static void ccs_read_profile(struct ccs_io_buffer *head)
 {
-	u8 index;
-	const struct ccs_profile *profile;
-next:
-	index = head->r.index;
-	profile = ccs_profile_ptr[index];
-	switch (head->r.step) {
-	case 0:
-		ccs_io_printf(head, "PROFILE_VERSION=%s\n", "20100903");
-		head->r.step++;
-		break;
-	case 1:
-		for ( ; head->r.index < CCS_MAX_PROFILES;
-		      head->r.index++)
-			if (ccs_profile_ptr[head->r.index])
-				break;
-		if (head->r.index == CCS_MAX_PROFILES)
-			return;
-		head->r.step++;
-		break;
-	case 2:
-		{
-			u8 i;
-			const struct ccs_path_info *comment = profile->comment;
-			ccs_io_printf(head, "%u-COMMENT=", index);
-			ccs_set_string(head, comment ? comment->name : "");
-			ccs_set_lf(head);
-			ccs_io_printf(head, "%u-PREFERENCE={ ", index);
-			for (i = 0; i < CCS_MAX_PREF; i++)
-				ccs_io_printf(head, "%s=%u ",
-					      ccs_pref_keywords[i],
-					      profile->pref[i]);
-			ccs_set_string(head, " }\n");
-			head->r.step++;
-		}
-		break;
-	case 3:
-		{
-			ccs_io_printf(head, "%u-%s", index, "CONFIG");
-			ccs_print_config(head, profile->default_config);
-			head->r.bit = 0;
-			head->r.step++;
-		}
-		break;
-	case 4:
-		for ( ; head->r.bit < CCS_MAX_MAC_INDEX
-			      + CCS_MAX_MAC_CATEGORY_INDEX; head->r.bit++) {
-			const u8 i = head->r.bit;
+	u16 index;
+	if (head->reader->eof)
+		return;
+	ccs_io_printf(head, "PROFILE_VERSION=%s\n", "20100903");
+	for (index = 0; index < CCS_MAX_PROFILES; index++) {
+		const struct ccs_profile *profile = ccs_profile_ptr[index];
+		u8 i;
+		const struct ccs_path_info *comment;
+		if (!profile)
+			continue;
+		ccs_io_printf(head, "%u-COMMENT=", index);
+		comment = profile->comment;
+		ccs_set_string(head, comment ? comment->name : "");
+		ccs_set_lf(head);
+		ccs_io_printf(head, "%u-PREFERENCE={ ", index);
+		for (i = 0; i < CCS_MAX_PREF; i++)
+			ccs_io_printf(head, "%s=%u ", ccs_pref_keywords[i],
+				      profile->pref[i]);
+		ccs_set_string(head, " }\n");
+		ccs_io_printf(head, "%u-%s", index, "CONFIG");
+		ccs_print_config(head, profile->default_config);
+		for (i = 0; i < CCS_MAX_MAC_INDEX + CCS_MAX_MAC_CATEGORY_INDEX;
+		     i++) {
 			const u8 config = profile->config[i];
 			if (config == CCS_CONFIG_USE_DEFAULT)
 				continue;
 			if (i < CCS_MAX_MAC_INDEX)
-				ccs_io_printf(head, "%u-CONFIG::%s::%s", index,
-					      ccs_category_keywords
+				ccs_io_printf(head, "%u-CONFIG::%s::%s",
+					      index, ccs_category_keywords
 					      [ccs_index2category[i]],
 					      ccs_mac_keywords[i]);
 			else
 				ccs_io_printf(head, "%u-CONFIG::%s", index,
 					      ccs_mac_keywords[i]);
 			ccs_print_config(head, config);
-			head->r.bit++;
-			break;
 		}
-		if (head->r.bit == CCS_MAX_MAC_INDEX
-		    + CCS_MAX_MAC_CATEGORY_INDEX) {
-			head->r.index++;
-			head->r.step = 1;
-		}
-		break;
 	}
-	if (ccs_flush(head))
-		goto next;
+	head->reader->eof = true;
 }
 
 /**
@@ -838,19 +794,18 @@
  */
 static void ccs_read_manager(struct ccs_io_buffer *head)
 {
-	if (head->r.eof)
+	struct ccs_reader_struct *reader = head->reader;
+	if (reader->eof)
 		return;
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[CCS_ID_MANAGER]) {
+	list_for_each_cookie(reader->acl, &ccs_policy_list[CCS_ID_MANAGER]) {
 		struct ccs_manager *ptr =
-			list_entry(head->r.acl, typeof(*ptr), head.list);
+			list_entry(reader->acl, typeof(*ptr), head.list);
 		if (ptr->head.is_deleted)
 			continue;
-		if (!ccs_flush(head))
-			return;
 		ccs_set_string(head, ptr->manager->name);
 		ccs_set_lf(head);
 	}
-	head->r.eof = true;
+	reader->eof = true;
 }
 
 /**
@@ -920,10 +875,6 @@
 	unsigned int pid;
 	struct ccs_domain_info *domain = NULL;
 	bool global_pid = false;
-	if (!strcmp(data, "execute")) {
-		head->r.print_execute_only = true;
-		return true;
-	}
 	if (sscanf(data, "pid=%u", &pid) == 1 ||
 	    (global_pid = true, sscanf(data, "global-pid=%u", &pid) == 1)) {
 		struct task_struct *p;
@@ -947,17 +898,17 @@
 		return false;
 	head->w.domain = domain;
 	/* Accessing read_buf is safe because head->io_sem is held. */
-	if (!head->read_buf)
+	if (!head->reader)
 		return true; /* Do nothing if open(O_WRONLY). */
-	memset(&head->r, 0, sizeof(head->r));
-	head->r.print_this_domain_only = true;
+	//memset(&head->reader, 0, sizeof(head->reader));
+	head->reader->print_this_domain_only = true;
 	if (domain)
-		head->r.domain = &domain->list;
+		head->reader->seek_to_domain = &domain->list;
 	else
-		head->r.eof = true;
-	ccs_io_printf(head, "# select %s\n", data);
-	if (domain && domain->is_deleted)
-		ccs_set_string(head, "# This is a deleted domain.\n");
+		head->reader->eof = true;
+	//ccs_io_printf(head, "# select %s\n", data);
+	//if (domain && domain->is_deleted)
+	//ccs_set_string(head, "# This is a deleted domain.\n");
 	return true;
 }
 
@@ -1159,7 +1110,7 @@
 static void ccs_print_name_union(struct ccs_io_buffer *head,
 				 const struct ccs_name_union *ptr)
 {
-	const bool cond = head->r.print_cond_part;
+	const bool cond = head->reader->print_cond_part;
 	if (!cond)
 		ccs_set_space(head);
 	if (ptr->is_group) {
@@ -1185,7 +1136,7 @@
 static void ccs_print_number_union(struct ccs_io_buffer *head,
 				   const struct ccs_number_union *ptr)
 {
-	if (!head->r.print_cond_part)
+	if (!head->reader->print_cond_part)
 		ccs_set_space(head);
 	if (ptr->is_group) {
 		ccs_set_string(head, "@");
@@ -1229,136 +1180,80 @@
  * @head: Pointer to "struct ccs_io_buffer".
  * @cond: Pointer to "struct ccs_condition".
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
  */
-static bool ccs_print_condition(struct ccs_io_buffer *head,
+static void ccs_print_condition(struct ccs_io_buffer *head,
 				const struct ccs_condition *cond)
 {
-	switch (head->r.cond_step) {
-	case 0:
-		head->r.cond_index = 0;
-		head->r.cond_step++;
-		/* fall through */
-	case 1:
-		{
-			const u16 condc = cond->condc;
-			const struct ccs_condition_element *condp =
-				(typeof(condp)) (cond + 1);
-			const struct ccs_number_union *numbers_p =
-				(typeof(numbers_p)) (condp + condc);
-			const struct ccs_name_union *names_p =
-				(typeof(names_p))
-				(numbers_p + cond->numbers_count);
-			const struct ccs_argv *argv =
-				(typeof(argv)) (names_p + cond->names_count);
-			const struct ccs_envp *envp =
-				(typeof(envp)) (argv + cond->argc);
-			u16 skip;
-			for (skip = 0; skip < head->r.cond_index; skip++) {
-				const u8 left = condp->left;
-				const u8 right = condp->right;
-				condp++;
-				switch (left) {
-				case CCS_ARGV_ENTRY:
-					argv++;
-					continue;
-				case CCS_ENVP_ENTRY:
-					envp++;
-					continue;
-				case CCS_NUMBER_UNION:
-					numbers_p++;
-					break;
-				}
-				switch (right) {
-				case CCS_NAME_UNION:
-					names_p++;
-					break;
-				case CCS_NUMBER_UNION:
-					numbers_p++;
-					break;
-				}
+	u16 i;
+	const u16 condc = cond->condc;
+	const struct ccs_condition_element *condp =
+		(typeof(condp)) (cond + 1);
+	const struct ccs_number_union *numbers_p =
+		(typeof(numbers_p)) (condp + condc);
+	const struct ccs_name_union *names_p =
+		(typeof(names_p))
+		(numbers_p + cond->numbers_count);
+	const struct ccs_argv *argv =
+		(typeof(argv)) (names_p + cond->names_count);
+	const struct ccs_envp *envp = (typeof(envp)) (argv + cond->argc);
+	head->reader->print_cond_part = true;
+	for (i = 0; i < condc; i++) {
+		const u8 match = condp->equals;
+		const u8 left = condp->left;
+		const u8 right = condp->right;
+		condp++;
+		ccs_set_space(head);
+		switch (left) {
+		case CCS_ARGV_ENTRY:
+			ccs_io_printf(head, "exec.argv[%u]%s\"%s\"",
+				      argv->index, argv->is_not ? "!=" : "=",
+				      argv->value->name);
+			argv++;
+			continue;
+		case CCS_ENVP_ENTRY:
+			ccs_io_printf(head, "exec.envp[\"%s\"]%s",
+				      envp->name->name,
+				      envp->is_not ? "!=" : "=");
+			if (envp->value) {
+				ccs_set_string(head, "\"");
+				ccs_set_string(head, envp->value->name);
+				ccs_set_string(head, "\"");
+			} else {
+				ccs_set_string(head, "NULL");
 			}
-			while (head->r.cond_index < condc) {
-				const u8 match = condp->equals;
-				const u8 left = condp->left;
-				const u8 right = condp->right;
-				if (!ccs_flush(head))
-					return false;
-				condp++;
-				head->r.cond_index++;
-				ccs_set_space(head);
-				switch (left) {
-				case CCS_ARGV_ENTRY:
-					ccs_io_printf(head,
-						      "exec.argv[%u]%s\"%s\"",
-						      argv->index,
-						      argv->is_not ?
-						      "!=" : "=",
-						      argv->value->name);
-					argv++;
-					continue;
-				case CCS_ENVP_ENTRY:
-					ccs_io_printf(head,
-						      "exec.envp[\"%s\"]%s",
-						      envp->name->name,
-						      envp->is_not ?
-						      "!=" : "=");
-					if (envp->value) {
-						ccs_set_string(head, "\"");
-						ccs_set_string(head, envp->
-							       value->name);
-						ccs_set_string(head, "\"");
-					} else {
-						ccs_set_string(head, "NULL");
-					}
-					envp++;
-					continue;
-				case CCS_NUMBER_UNION:
-					ccs_print_number_union(head,
-							       numbers_p++);
-					break;
-				default:
-					ccs_set_string(head,
-					       ccs_condition_keyword[left]);
-					break;
-				}
-				ccs_set_string(head, match ? "=" : "!=");
-				switch (right) {
-				case CCS_NAME_UNION:
-					ccs_print_name_union(head, names_p++);
-					break;
-				case CCS_NUMBER_UNION:
-					ccs_print_number_union(head,
-							       numbers_p++);
-					break;
-				default:
-					ccs_set_string(head,
-					       ccs_condition_keyword[right]);
-					break;
-				}
-			}
+			envp++;
+			continue;
+		case CCS_NUMBER_UNION:
+			ccs_print_number_union(head, numbers_p++);
+			break;
+		default:
+			ccs_set_string(head, ccs_condition_keyword[left]);
+			break;
 		}
-		head->r.cond_step++;
-		/* fall through */
-	case 2:
-		if (!ccs_flush(head))
+		ccs_set_string(head, match ? "=" : "!=");
+		switch (right) {
+		case CCS_NAME_UNION:
+			ccs_print_name_union(head, names_p++);
 			break;
-		head->r.cond_step++;
-		/* fall through */
-	case 3:
-		if (cond->grant_log != CCS_GRANTLOG_AUTO)
-			ccs_io_printf(head, " grant_log=%s",
-				      ccs_yesno(cond->grant_log ==
-						CCS_GRANTLOG_YES));
-		if (cond->transit) {
-			ccs_set_string(head, " auto_domain_transition=\"");
-			ccs_set_string(head, cond->transit->name);
-			ccs_set_string(head, "\"");
+		case CCS_NUMBER_UNION:
+			ccs_print_number_union(head, numbers_p++);
+			break;
+		default:
+			ccs_set_string(head, ccs_condition_keyword[right]);
+			break;
 		}
-		ccs_set_lf(head);
-		return true;
 	}
-	return false;
+	if (cond->grant_log != CCS_GRANTLOG_AUTO)
+		ccs_io_printf(head, " grant_log=%s",
+			      ccs_yesno(cond->grant_log == CCS_GRANTLOG_YES));
+	if (cond->transit) {
+		ccs_set_string(head, " auto_domain_transition=\"");
+		ccs_set_string(head, cond->transit->name);
+		ccs_set_string(head, "\"");
+	}
+	head->reader->print_cond_part = false;
+	ccs_set_lf(head);
 }
 
 /**
@@ -1387,7 +1282,8 @@
 static void ccs_set_group(struct ccs_io_buffer *head)
 {
 	if (head->type == CCS_EXCEPTIONPOLICY)
-		ccs_io_printf(head, "acl_group %u ", head->r.group_index);
+		ccs_io_printf(head, "acl_group %u ",
+			      head->reader->group_index);
 }
 
 /**
@@ -1396,36 +1292,27 @@
  * @head: Pointer to "struct ccs_io_buffer".
  * @acl:  Pointer to an ACL entry.
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
  */
-static bool ccs_print_entry(struct ccs_io_buffer *head,
+static void ccs_print_entry(struct ccs_io_buffer *head,
 			    const struct ccs_acl_info *acl)
 {
 	const u8 acl_type = acl->type;
-	u8 bit;
-	if (head->r.print_cond_part)
-		goto print_cond_part;
+	u8 bit = 0;
 	if (acl->is_deleted)
-		return true;
+		return;
 next:
-	bit = head->r.bit;
-	if (!ccs_flush(head))
-		return false;
-	else if (acl_type == CCS_TYPE_PATH_ACL) {
+	if (acl_type == CCS_TYPE_PATH_ACL) {
 		struct ccs_path_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
 		const u16 perm = ptr->perm;
 		for ( ; bit < CCS_MAX_PATH_OPERATION; bit++) {
 			if (!(perm & (1 << bit)))
 				continue;
-			if (head->r.print_execute_only &&
-			    bit != CCS_TYPE_EXECUTE
-			    /* && bit != CCS_TYPE_TRANSIT */)
-				continue;
 			break;
 		}
 		if (bit >= CCS_MAX_PATH_OPERATION)
-			goto done;
+			return;
 		ccs_set_group(head);
 		ccs_set_string(head, "file ");
 		ccs_set_string(head, ccs_path_keyword[bit]);
@@ -1450,14 +1337,12 @@
 			       "auto_domain_transition " :
 			       "manual_domain_transition ");
 		ccs_set_string(head, ptr->domainname->name);
-	} else if (head->r.print_execute_only) {
-		return true;
 	} else if (acl_type == CCS_TYPE_MKDEV_ACL) {
 		struct ccs_mkdev_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
 		bit = ccs_fns(ptr->perm, bit);
 		if (bit >= CCS_MAX_MKDEV_OPERATION)
-			goto done;
+			return;
 		ccs_set_group(head);
 		ccs_set_string(head, "file ");
 		ccs_set_string(head, ccs_mac_keywords[ccs_pnnn2mac[bit]]);
@@ -1470,7 +1355,7 @@
 			container_of(acl, typeof(*ptr), head);
 		bit = ccs_fns(ptr->perm, bit);
 		if (bit >= CCS_MAX_PATH2_OPERATION)
-			goto done;
+			return;
 		ccs_set_group(head);
 		ccs_set_string(head, "file ");
 		ccs_set_string(head, ccs_mac_keywords[ccs_pp2mac[bit]]);
@@ -1481,7 +1366,7 @@
 			container_of(acl, typeof(*ptr), head);
 		bit = ccs_fns(ptr->perm, bit);
 		if (bit >= CCS_MAX_PATH_NUMBER_OPERATION)
-			goto done;
+			return;
 		ccs_set_group(head);
 		ccs_set_string(head, "file ");
 		ccs_set_string(head, ccs_mac_keywords[ccs_pn2mac[bit]]);
@@ -1505,7 +1390,7 @@
 			container_of(acl, typeof(*ptr), head);
 		bit = ccs_fns(ptr->perm, bit);
 		if (bit >= CCS_MAX_NETWORK_OPERATION)
-			goto done;
+			return;
 		ccs_set_group(head);
 		ccs_set_string(head, "network inet ");
 		ccs_set_string(head, ccs_proto_keyword[ptr->protocol]);
@@ -1536,7 +1421,7 @@
 			container_of(acl, typeof(*ptr), head);
 		bit = ccs_fns(ptr->perm, bit);
 		if (bit >= CCS_MAX_NETWORK_OPERATION)
-			goto done;
+			return;
 		ccs_set_group(head);
 		ccs_set_string(head, "network unix ");
 		ccs_set_string(head, ccs_proto_keyword[ptr->protocol]);
@@ -1560,16 +1445,8 @@
 		ccs_print_name_union(head, &ptr->fs_type);
 		ccs_print_number_union(head, &ptr->flags);
 	}
-	head->r.bit = bit + 1;
 	if (acl->cond) {
-		head->r.print_cond_part = true;
-		head->r.cond_step = 0;
-		if (!ccs_flush(head))
-			return false;
-print_cond_part:
-		if (!ccs_print_condition(head, acl->cond))
-			return false;
-		head->r.print_cond_part = false;
+		ccs_print_condition(head, acl->cond);
 	} else {
 		ccs_set_lf(head);
 	}
@@ -1580,11 +1457,9 @@
 	case CCS_TYPE_PATH_NUMBER_ACL:
 	case CCS_TYPE_INET_ACL:
 	case CCS_TYPE_UNIX_ACL:
+		bit++;
 		goto next;
 	}
-done:
-	head->r.bit = 0;
-	return true;
 }
 
 /**
@@ -1592,24 +1467,24 @@
  *
  * @head:   Pointer to "struct ccs_io_buffer".
  * @domain: Pointer to "struct ccs_domain_info".
- * @index:  Index number.
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_read_domain2(struct ccs_io_buffer *head,
-			     struct ccs_domain_info *domain,
-			     const u8 index)
+static void ccs_read_domain2(struct ccs_io_buffer *head,
+			     struct ccs_domain_info *domain)
 {
-	list_for_each_cookie(head->r.acl, &domain->acl_info_list[index]) {
-		struct ccs_acl_info *ptr =
-			list_entry(head->r.acl, typeof(*ptr), list);
-		if (!ccs_print_entry(head, ptr))
-			return false;
+	u8 i;
+	struct ccs_reader_struct *reader = head->reader;
+	for (i = 0; i < 2; i++) {
+		list_for_each_cookie(reader->acl, &domain->acl_info_list[i]) {
+			struct ccs_acl_info *ptr =
+				list_entry(reader->acl, typeof(*ptr), list);
+			ccs_print_entry(head, ptr);
+		}
+		reader->acl = NULL;
 	}
-	head->r.acl = NULL;
-	return true;
 }
 
 /**
@@ -1623,49 +1498,30 @@
  */
 static void ccs_read_domain(struct ccs_io_buffer *head)
 {
-	if (head->r.eof)
+	struct ccs_reader_struct *reader = head->reader;
+	if (reader->eof)
 		return;
-	list_for_each_cookie(head->r.domain, &ccs_domain_list) {
+	list_for_each_cookie(reader->domain, &ccs_domain_list) {
 		struct ccs_domain_info *domain =
-			list_entry(head->r.domain, typeof(*domain), list);
-		switch (head->r.step) {
-			u8 i;
-		case 0:
-			if (domain->is_deleted &&
-			    !head->r.print_this_domain_only)
-				continue;
-			/* Print domainname and flags. */
-			ccs_set_string(head, domain->domainname->name);
-			ccs_set_lf(head);
-			ccs_io_printf(head, "use_profile %u\n",
-				      domain->profile);
-			ccs_io_printf(head, "use_group %u\n", domain->group);
-			for (i = 0; i < CCS_MAX_DOMAIN_INFO_FLAGS; i++)
-				if (domain->flags[i])
-					ccs_set_string(head, ccs_dif[i]);
-			head->r.step++;
-			ccs_set_lf(head);
-			/* fall through */
-		case 1:
-			if (!ccs_read_domain2(head, domain, 0))
-				return;
-			head->r.step++;
-			/* fall through */
-		case 2:
-			if (!ccs_read_domain2(head, domain, 1))
-				return;
-			head->r.step++;
-			if (!ccs_set_lf(head))
-				return;
-			/* fall through */
-		case 3:
-			head->r.step = 0;
-			if (head->r.print_this_domain_only)
-				goto done;
-		}
+			list_entry(reader->domain, typeof(*domain), list);
+		u8 i;
+		if (domain->is_deleted && !reader->print_this_domain_only)
+			continue;
+		/* Print domainname and flags. */
+		ccs_set_string(head, domain->domainname->name);
+		ccs_set_lf(head);
+		ccs_io_printf(head, "use_profile %u\n", domain->profile);
+		ccs_io_printf(head, "use_group %u\n", domain->group);
+		for (i = 0; i < CCS_MAX_DOMAIN_INFO_FLAGS; i++)
+			if (domain->flags[i])
+				ccs_set_string(head, ccs_dif[i]);
+		ccs_set_lf(head);
+		ccs_read_domain2(head, domain);
+		ccs_set_lf(head);
+		if (reader->print_this_domain_only)
+			break;
 	}
-done:
-	head->r.eof = true;
+	reader->eof = true;
 }
 
 /**
@@ -1718,20 +1574,19 @@
  */
 static void ccs_read_domain_profile(struct ccs_io_buffer *head)
 {
-	if (head->r.eof)
+	struct ccs_reader_struct *reader = head->reader;
+	if (reader->eof)
 		return;
-	list_for_each_cookie(head->r.domain, &ccs_domain_list) {
+	list_for_each_cookie(reader->domain, &ccs_domain_list) {
 		struct ccs_domain_info *domain =
-			list_entry(head->r.domain, typeof(*domain), list);
+			list_entry(reader->domain, typeof(*domain), list);
 		if (domain->is_deleted)
 			continue;
-		if (!ccs_flush(head))
-			return;
 		ccs_io_printf(head, "%u ", domain->profile);
 		ccs_set_string(head, domain->domainname->name);
 		ccs_set_lf(head);
 	}
-	head->r.eof = true;
+	reader->eof = true;
 }
 
 /**
@@ -1743,7 +1598,8 @@
  */
 static int ccs_write_pid(struct ccs_io_buffer *head)
 {
-	head->r.eof = false;
+	if (head->reader)
+		head->reader->eof = false;
 	return 0;
 }
 
@@ -1769,12 +1625,12 @@
 	u32 ccs_flags = 0;
 	/* Accessing write_buf is safe because head->io_sem is held. */
 	if (!buf) {
-		head->r.eof = true;
+		head->reader->eof = true;
 		return; /* Do nothing if open(O_RDONLY). */
 	}
-	if (head->r.w_pos || head->r.eof)
+	if (head->reader->eof)
 		return;
-	head->r.eof = true;
+	head->reader->eof = true;
 	if (ccs_str_starts(&buf, "info "))
 		task_info = true;
 	if (ccs_str_starts(&buf, "global-pid "))
@@ -1872,22 +1728,21 @@
  * @head: Pointer to "struct ccs_io_buffer".
  * @idx:  Index number.
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_read_group(struct ccs_io_buffer *head, const int idx)
+static void ccs_read_group(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.group, &ccs_group_list[idx]) {
+	struct ccs_reader_struct *reader = head->reader;
+	list_for_each_cookie(reader->group, &ccs_group_list[idx]) {
 		struct ccs_group *group =
-			list_entry(head->r.group, typeof(*group), head.list);
-		list_for_each_cookie(head->r.acl, &group->member_list) {
+			list_entry(reader->group, typeof(*group), head.list);
+		list_for_each_cookie(reader->acl, &group->member_list) {
 			struct ccs_acl_head *ptr =
-				list_entry(head->r.acl, typeof(*ptr), list);
+				list_entry(reader->acl, typeof(*ptr), list);
 			if (ptr->is_deleted)
 				continue;
-			if (!ccs_flush(head))
-				return false;
 			ccs_set_string(head, ccs_group_name[idx]);
 			ccs_set_string(head, group->group_name->name);
 			if (idx == CCS_PATH_GROUP) {
@@ -1916,10 +1771,9 @@
 			}
 			ccs_set_lf(head);
 		}
-		head->r.acl = NULL;
+		reader->acl = NULL;
 	}
-	head->r.group = NULL;
-	return true;
+	reader->group = NULL;
 }
 
 /**
@@ -1928,19 +1782,18 @@
  * @head: Pointer to "struct ccs_io_buffer".
  * @idx:  Index number.
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_read_policy(struct ccs_io_buffer *head, const int idx)
+static void ccs_read_policy(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[idx]) {
+	struct ccs_reader_struct *reader = head->reader;
+	list_for_each_cookie(reader->acl, &ccs_policy_list[idx]) {
 		struct ccs_acl_head *acl =
-			container_of(head->r.acl, typeof(*acl), list);
+			container_of(reader->acl, typeof(*acl), list);
 		if (acl->is_deleted)
 			continue;
-		if (!ccs_flush(head))
-			return false;
 		switch (idx) {
 		case CCS_ID_TRANSITION_CONTROL:
 			{
@@ -1983,8 +1836,7 @@
 		}
 		ccs_set_lf(head);
 	}
-	head->r.acl = NULL;
-	return true;
+	reader->acl = NULL;
 }
 
 /**
@@ -1998,29 +1850,18 @@
  */
 static void ccs_read_exception(struct ccs_io_buffer *head)
 {
-	if (head->r.eof)
+	u16 i;
+	if (head->reader->eof)
 		return;
-	while (head->r.step < CCS_MAX_POLICY &&
-	       ccs_read_policy(head, head->r.step))
-		head->r.step++;
-	if (head->r.step < CCS_MAX_POLICY)
-		return;
-	while (head->r.step < CCS_MAX_POLICY + CCS_MAX_GROUP &&
-	       ccs_read_group(head, head->r.step - CCS_MAX_POLICY))
-		head->r.step++;
-	if (head->r.step < CCS_MAX_POLICY + CCS_MAX_GROUP)
-		return;
-	while (head->r.step < CCS_MAX_POLICY + CCS_MAX_GROUP
-	       + CCS_MAX_ACL_GROUPS * 2) {
-		head->r.group_index = (head->r.step - CCS_MAX_POLICY
-				       - CCS_MAX_GROUP) / 2;
-		if (!ccs_read_domain2(head,
-				      &ccs_acl_group[head->r.group_index],
-				      head->r.step & 1))
-			return;
-		head->r.step++;
+	for (i = 0; i < CCS_MAX_POLICY; i++)
+		ccs_read_policy(head, i);
+	for (i = 0; i < CCS_MAX_GROUP; i++)
+		ccs_read_group(head, i);
+	for (i = 0; i < CCS_MAX_ACL_GROUPS; i++) {
+		head->reader->group_index = i;
+		ccs_read_domain2(head, &ccs_acl_group[i]);
 	}
-	head->r.eof = true;
+	head->reader->eof = true;
 }
 
 /* Wait queue for kernel -> userspace notification. */
@@ -2282,27 +2123,24 @@
  */
 static void ccs_read_query(struct ccs_io_buffer *head)
 {
+	struct ccs_reader_struct *reader = head->reader;
 	struct list_head *tmp;
 	int pos = 0;
 	int len = 0;
 	char *buf;
-	if (head->r.w_pos)
-		return;
-	kfree(head->read_buf);
-	head->read_buf = NULL;
 	spin_lock(&ccs_query_list_lock);
 	list_for_each(tmp, &ccs_query_list) {
 		struct ccs_query *ptr = list_entry(tmp, typeof(*ptr), list);
 		if (ptr->answer)
 			continue;
-		if (pos++ != head->r.query_index)
+		if (pos++ != reader->query_index)
 			continue;
 		len = ptr->query_len;
 		break;
 	}
 	spin_unlock(&ccs_query_list_lock);
 	if (!len) {
-		head->r.query_index = 0;
+		reader->query_index = 0;
 		return;
 	}
 	buf = kzalloc(len + 32, CCS_GFP_FLAGS);
@@ -2314,7 +2152,7 @@
 		struct ccs_query *ptr = list_entry(tmp, typeof(*ptr), list);
 		if (ptr->answer)
 			continue;
-		if (pos++ != head->r.query_index)
+		if (pos++ != reader->query_index)
 			continue;
 		/*
 		 * Some query can be skipped because ccs_query_list
@@ -2327,9 +2165,10 @@
 	}
 	spin_unlock(&ccs_query_list_lock);
 	if (buf[0]) {
-		head->read_buf = buf;
-		head->r.w[head->r.w_pos++] = buf;
-		head->r.query_index++;
+		kfree(reader->buffer);
+		reader->buffer = buf;
+		ccs_set_string(head, buf);
+		reader->query_index++;
 	} else {
 		kfree(buf);
 	}
@@ -2379,10 +2218,10 @@
  */
 static void ccs_read_version(struct ccs_io_buffer *head)
 {
-	if (head->r.eof)
+	if (head->reader->eof)
 		return;
 	ccs_set_string(head, "1.8.0");
-	head->r.eof = true;
+	head->reader->eof = true;
 }
 
 /* String table for /proc/ccs/meminfo interface. */
@@ -2434,7 +2273,7 @@
 {
 	u8 i;
 	unsigned int total = 0;
-	if (head->r.eof)
+	if (head->reader->eof)
 		return;
 	for (i = 0; i < CCS_MAX_POLICY_STAT; i++) {
 		ccs_io_printf(head, "Policy %-30s %10u", ccs_policy_headers[i],
@@ -2461,7 +2300,7 @@
 	}
 	ccs_io_printf(head, "Total memory used:                    %10u\n",
 		      total);
-	head->r.eof = true;
+	head->reader->eof = true;
 }
 
 /**
@@ -2500,7 +2339,7 @@
 {
 	unsigned int total = 0;
 	int i;
-	if (head->r.eof)
+	if (head->reader->eof)
 		return;
 	for (i = 0; i < CCS_MAX_MEMORY_STAT; i++) {
 		unsigned int used = ccs_memory_used[i];
@@ -2513,7 +2352,7 @@
 		ccs_io_printf(head, "\n");
 	}
 	ccs_io_printf(head, "%-12s %10u\n", "Total:", total);
-	head->r.eof = true;
+	head->reader->eof = true;
 }
 
 /**
@@ -2533,7 +2372,81 @@
 	return 0;
 }
 
+/*
+ * ccs_cleanup_io_buffer - Release memory used for policy I/O.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing. 
+ */
+static void ccs_cleanup_io_buffer(struct ccs_io_buffer *head)
+{
+	struct ccs_reader_struct *reader = head->reader;
+	/* Initialized to 2 upon open() if reader exists, 1 otherwise. */
+	if (!atomic_dec_and_test(&head->users))
+		return;
+	if (reader) {
+		kfree(reader->buffer);
+		kfree(reader);
+	}
+	kfree(head->write_buf);
+	kfree(head);
+}
+
 /**
+ * ccs_reader_thread - Kernel thread for reading /proc/ccs/ interface.
+ *
+ * @arg: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0.
+ */
+static int ccs_reader_thread(void *arg)
+{
+	struct ccs_io_buffer *head = arg;
+	struct ccs_reader_struct *reader = head->reader;
+	ccs_daemonize("CCS reader");
+	/* Enter the SRCU read section. */
+	reader->reader_idx = ccs_read_lock();
+	while (1) {
+		/* Leave the SRCU read section. */
+		ccs_read_unlock(reader->reader_idx);
+		/*
+		 * Wait for the first read() request, indicated by positive
+		 * buffer size. The caller may issue seek request, indicated by
+		 * non NULL seek_to_domain pointer. Also, the caller may
+		 * close(), indicated by user counter.
+		 */
+		wait_event_interruptible(reader->request_wait,
+					 reader->request_size ||
+					 reader->seek_to_domain ||
+					 atomic_read(&head->users) == 1);
+		/* Reenter the SRCU read section. */
+		reader->reader_idx = ccs_read_lock();
+		/* If the caller called close(), exit the loop. */
+		if (atomic_read(&head->users) == 1)
+			break;
+		/* If the caller called seek, move the cursor. */
+		if (reader->seek_to_domain) {
+			reader->domain = reader->seek_to_domain;
+			reader->acl = NULL;
+			/* reader->group = NULL; */
+			reader->seek_to_domain = NULL;
+		/* If the caller called read, read the policy. */
+		} else if (reader->request_size) {
+			head->read(head);
+		} else {
+			break;
+		}
+		wake_up_all(&reader->response_wait);
+	}
+	/* Leave the SRCU read section. */
+	ccs_read_unlock(reader->reader_idx);
+	ccs_cleanup_io_buffer(head);
+	/* This acts as do_exit(0). */
+	return 0;
+}
+
+/**
  * ccs_open_control - open() for /proc/ccs/ interface.
  *
  * @type: Type of interface.
@@ -2543,10 +2456,12 @@
  */
 int ccs_open_control(const u8 type, struct file *file)
 {
+	struct ccs_reader_struct *reader = NULL;
 	struct ccs_io_buffer *head = kzalloc(sizeof(*head), CCS_GFP_FLAGS);
 	if (!head)
 		return -ENOMEM;
 	mutex_init(&head->io_sem);
+	atomic_set(&head->users, 2);
 	head->type = type;
 	switch (type) {
 	case CCS_DOMAINPOLICY: /* /proc/ccs/domain_policy */
@@ -2578,17 +2493,14 @@
 		break;
 	case CCS_VERSION: /* /proc/ccs/version */
 		head->read = ccs_read_version;
-		head->readbuf_size = 128;
 		break;
 	case CCS_STAT: /* /proc/ccs/stat */
 		head->write = ccs_write_stat;
 		head->read = ccs_read_stat;
-		head->readbuf_size = 1024;
 		break;
 	case CCS_MEMINFO: /* /proc/ccs/meminfo */
 		head->write = ccs_write_memory_quota;
 		head->read = ccs_read_memory_counter;
-		head->readbuf_size = 512;
 		break;
 	case CCS_PROFILE: /* /proc/ccs/profile */
 		head->write = ccs_write_profile;
@@ -2611,15 +2523,15 @@
 		 */
 		head->read = NULL;
 		head->poll = NULL;
-	} else if (!head->poll) {
-		/* Don't allocate read_buf for poll() access. */
-		if (!head->readbuf_size)
-			head->readbuf_size = 4096;
-		head->read_buf = kzalloc(head->readbuf_size, CCS_GFP_FLAGS);
-		if (!head->read_buf) {
+	} else if (head->read) {
+		reader = kzalloc(sizeof(*reader), CCS_GFP_FLAGS);
+		if (!reader) {
 			kfree(head);
 			return -ENOMEM;
 		}
+		init_waitqueue_head(&reader->request_wait);
+		init_waitqueue_head(&reader->response_wait);
+		head->reader = reader;
 	}
 	if (!(file->f_mode & FMODE_WRITE)) {
 		/*
@@ -2631,7 +2543,10 @@
 		head->writebuf_size = 4096;
 		head->write_buf = kzalloc(head->writebuf_size, CCS_GFP_FLAGS);
 		if (!head->write_buf) {
-			kfree(head->read_buf);
+			if (reader) {
+				kfree(reader->buffer);
+				kfree(reader);
+			}
 			kfree(head);
 			return -ENOMEM;
 		}
@@ -2643,10 +2558,23 @@
 	 */
 	if (type == CCS_QUERY)
 		atomic_inc(&ccs_query_observers);
-	else if (type != CCS_AUDIT && type != CCS_VERSION &&
-		 type != CCS_MEMINFO && type != CCS_STAT)
-		head->reader_idx = ccs_lock();
 	file->private_data = head;
+	//ccs_notify_gc(head, true);
+	if (reader) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 6)
+		struct task_struct *task;
+		task = kthread_create(ccs_reader_thread, head, "CCS reader");
+		if (!IS_ERR(task))
+			wake_up_process(task);
+		else
+			atomic_dec(&head->users);
+#else
+		if (kernel_thread(ccs_reader_thread, head, 0) < 0)
+			atomic_dec(&head->users);
+#endif
+	} else {
+		atomic_dec(&head->users);
+	}
 	return 0;
 }
 
@@ -2684,22 +2612,24 @@
 {
 	int len;
 	struct ccs_io_buffer *head = file->private_data;
-	int idx;
+	struct ccs_reader_struct *reader = head->reader;
 	if (!head->read)
 		return -ENOSYS;
 	if (!access_ok(VERIFY_WRITE, buffer, buffer_len))
 		return -EFAULT;
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
-	head->read_user_buf = buffer;
-	head->read_user_buf_avail = buffer_len;
-	idx = ccs_read_lock();
-	if (ccs_flush(head))
-		/* Call the policy handler. */
-		head->read(head);
-	ccs_flush(head);
-	ccs_read_unlock(idx);
-	len = head->read_user_buf - buffer;
+	reader->request_size = buffer_len;
+	wake_up(&reader->request_wait);
+	wait_event_interruptible(reader->response_wait,
+				 reader->response_size ||
+				 atomic_read(&head->users) == 1);
+	len = reader->response_size;
+	BUG_ON(len > buffer_len || len < 0);
+	if (copy_to_user(buffer, reader->buffer, len))
+		len = -EFAULT;
+	else
+		reader->response_size = 0;
 	mutex_unlock(&head->io_sem);
 	return len;
 }
@@ -2790,27 +2720,21 @@
 int ccs_close_control(struct file *file)
 {
 	struct ccs_io_buffer *head = file->private_data;
-	const bool is_write = head->write_buf != NULL;
+	struct ccs_reader_struct *reader = head->reader;
+	//const bool is_write = head->write_buf != NULL;
 	const u8 type = head->type;
-	/*
-	 * If the file is /proc/ccs/query, decrement the observer counter.
-	 */
-	if (type == CCS_QUERY) {
-		if (atomic_dec_and_test(&ccs_query_observers))
-			wake_up_all(&ccs_answer_wait);
-	} else if (type != CCS_AUDIT && type != CCS_VERSION &&
-		   type != CCS_MEMINFO && type != CCS_STAT)
-		ccs_unlock(head->reader_idx);
-	/* Release memory used for policy I/O. */
-	kfree(head->read_buf);
-	head->read_buf = NULL;
-	kfree(head->write_buf);
-	head->write_buf = NULL;
-	kfree(head);
-	head = NULL;
-	file->private_data = NULL;
-	if (is_write)
-		ccs_run_gc();
+	/* If the file is /proc/ccs/query, decrement the observer counter. */
+	if (type == CCS_QUERY &&
+	    atomic_dec_and_test(&ccs_query_observers))
+		wake_up_all(&ccs_answer_wait);
+	if (reader) {
+		reader->request_size = 0;
+		reader->seek_to_domain = NULL;
+		wake_up(&reader->request_wait);
+	}
+	ccs_cleanup_io_buffer(head);
+	//if (is_write)
+	//	ccs_run_gc();
 	return 0;
 }
 
Index: security/ccsecurity/gc.c
===================================================================
--- security/ccsecurity/gc.c	(revision 4649)
+++ security/ccsecurity/gc.c	(working copy)
@@ -51,46 +51,64 @@
 
 #endif
 
-
-/* Structure for garbage collection. */
-struct ccs_gc {
-	struct list_head list;
-	int type; /* One of values in "enum ccs_policy_id". */
-	struct list_head *element;
-};
-/* List of entries to be deleted. */
+/* The list for "struct ccs_io_buffer". */
 static LIST_HEAD(ccs_gc_list);
-/* Length of ccs_gc_list. */
-static int ccs_gc_list_len;
+/* Lock for protecting ccs_gc_list. */
+static DEFINE_SPINLOCK(ccs_gc_lock);
 
 /**
- * ccs_add_to_gc - Add an entry to to be deleted list.
+ * ccs_notify_gc - Register/unregister /proc/ccs/ users.
  *
- * @type:    Type of this entry.
- * @element: Pointer to "struct list_head".
+ * @head:        Pointer to "struct ccs_io_buffer".
+ * @is_register: True if register, false if unregister.
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
+ */
+void ccs_notify_gc(struct ccs_io_buffer *head, const bool is_register)
+{
+	spin_lock(&ccs_gc_lock);
+	if (is_register)
+		list_add(&head->list, &ccs_gc_list);
+	else
+		list_del(&head->list);
+	spin_unlock(&ccs_gc_lock);
+}
+
+/**
+ * ccs_used_by_io_buffer - Check whether the list element is used by /proc/ccs/ users or not.
  *
- * Caller holds ccs_policy_lock mutex.
+ * @element: Pointer to "struct list_head".
  *
- * Adding an entry needs kmalloc(). Thus, if we try to add thousands of
- * entries at once, it will take too long time. Thus, do not add more than 128
- * entries per a scan. But to be able to handle worst case where all entries
- * are in-use, we accept one more entry per a scan.
- *
- * If we use singly linked list using "struct list_head"->prev (which is
- * LIST_POISON2), we can avoid kmalloc().
+ * Returns true if @element is used by /proc/ccs/ users, false otherwise.
  */
-static bool ccs_add_to_gc(const int type, struct list_head *element)
+static bool ccs_used_by_io_buffer(const struct list_head *element)
 {
-	struct ccs_gc *entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
-	if (!entry)
-		return false;
-	entry->type = type;
-	entry->element = element;
-	list_add(&entry->list, &ccs_gc_list);
-	list_del_rcu(element);
-	return ccs_gc_list_len++ < 128;
+	struct ccs_io_buffer *head;
+	bool in_use = false;
+	spin_lock(&ccs_gc_lock);
+	list_for_each_entry(head, &ccs_gc_list, list) {
+		struct ccs_reader_struct *reader = head->reader;
+		if (reader && reader->domain == element)
+			printk(KERN_INFO
+			       "***** %p is used by r.domain *****\n",
+			       element);
+		else if (reader && reader->group == element)
+			printk(KERN_INFO
+			       "***** %p is used by r.group *****\n", element);
+		else if (reader && reader->acl == element)
+			printk(KERN_INFO
+			       "***** %p is used by r.acl *****\n", element);
+		else if (&head->w.domain->list == element)
+			printk(KERN_INFO
+			       "***** %p is used by w.domain->list *****\n",
+			       element);
+		else
+			continue;
+		in_use = true;
+		break;
+	}
+	spin_unlock(&ccs_gc_lock);
+	return in_use;
 }
 
 /**
@@ -540,24 +558,16 @@
 /*
  * Lock for syscall users.
  *
- * This lock is held for only protecting single SRCU section. Accessing
- * /proc/ccs/ interface cannot be finished within single SRCU section.
- * Therefore, we use ccs_lock()/ccs_unlock() for protecting /proc/ccs/ users.
- * Garbage collector waits for both this SRCU grace period and ccs_counter.
+ * This lock is held for only protecting single SRCU section.
  */
 struct srcu_struct ccs_ss;
 
-#endif
+#else
 
 /*
- * Lock for /proc/ccs/ users.
+ * Lock for syscall users.
  *
- * Holding SRCU lock upon open() and release upon close() causes lockdep to
- * complain about returning to userspace with SRCU lock held.
- * Therefore, non-SRCU lock is used in order to suppress the lockdep warning.
- * Modifying to hold/release SRCU lock upon each read()/write() is to-do list.
- *
- * This lock is also used for protecting single SRCU section for 2.6.18 and
+ * This lock is used for protecting single SRCU section for 2.6.18 and
  * earlier kernels because they don't have SRCU support.
  */
 static struct {
@@ -568,7 +578,7 @@
 static DEFINE_SPINLOCK(ccs_counter_lock);
 
 /**
- * ccs_lock - Hold non-SRCU lock.
+ * ccs_lock - Alternative for srcu_read_lock().
  *
  * Returns index number which has to be passed to ccs_unlock().
  */
@@ -583,7 +593,7 @@
 }
 
 /**
- * ccs_unlock - Release non-SRCU lock.
+ * ccs_unlock - Alternative for srcu_read_unlock().
  *
  * @idx: Index number returned by ccs_lock().
  *
@@ -597,7 +607,7 @@
 }
 
 /**
- * ccs_synchronize_counter - Wait for SRCU grace period.
+ * ccs_synchronize_counter - Alternative for synchronize_srcu().
  *
  * Returns nothing.
  */
@@ -617,10 +627,7 @@
 	ccs_counter.counter_idx ^= 1;
 	v = ccs_counter.counter[idx];
 	spin_unlock(&ccs_counter_lock);
-	/*
-	 * Waiting for /proc/ccs/ interface users to close() may take more than
-	 * a few seconds. Therefore, we should use ssleep() here.
-	 */
+	/* Wait for previously active counter to become 0. */
 	while (v) {
 		ssleep(1);
 		spin_lock(&ccs_counter_lock);
@@ -629,24 +636,103 @@
 	}
 }
 
+#endif
+
 /**
+ * ccs_delete_entry - Delete an entry.
+ *
+ * @id:      One of values in "enum ccs_policy_id".
+ * @element: Pointer to "struct list_head".
+ *
+ * Returns nnothing.
+ *
+ * Caller holds ccs_policy_lock mutex.
+ */
+static void ccs_delete_entry(const enum ccs_policy_id id,
+			     struct list_head *element)
+{
+	struct list_head *prev = element->prev;
+	size_t size;
+	if (ccs_used_by_io_buffer(element))
+		return;
+	list_del_rcu(element);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+	synchronize_srcu(&ccs_ss);
+#else
+	ccs_synchronize_counter();
+#endif
+	if (ccs_used_by_io_buffer(element))
+		goto add_again;
+	switch (id) {
+	case CCS_ID_TRANSITION_CONTROL:
+		size = ccs_del_transition_control(element);
+		break;
+	case CCS_ID_MANAGER:
+		size = ccs_del_manager(element);
+		break;
+	case CCS_ID_AGGREGATOR:
+		size = ccs_del_aggregator(element);
+		break;
+	case CCS_ID_GROUP:
+		size = ccs_del_group(element);
+		break;
+	case CCS_ID_PATH_GROUP:
+		size = ccs_del_path_group(element);
+		break;
+	case CCS_ID_ADDRESS_GROUP:
+		size = ccs_del_address_group(element);
+		break;
+	case CCS_ID_NUMBER_GROUP:
+		size = ccs_del_number_group(element);
+		break;
+	case CCS_ID_RESERVEDPORT:
+		size = ccs_del_reservedport(element);
+		break;
+	case CCS_ID_IPV6_ADDRESS:
+		size = ccs_del_ipv6_address(element);
+		break;
+	case CCS_ID_CONDITION:
+		size = ccs_del_condition(element);
+		break;
+	case CCS_ID_NAME:
+		size = ccs_del_name(element);
+		break;
+	case CCS_ID_ACL:
+		size = ccs_del_acl(element);
+		break;
+	case CCS_ID_DOMAIN:
+		size = ccs_del_domain(element);
+		if (!size)
+			goto add_again;
+		break;
+	default:
+		size = 0;
+		break;
+	}
+	ccs_memory_free(element, size);
+	return;
+add_again:
+	element->prev = prev;
+	prev->next = element;
+}
+
+/**
  * ccs_collect_member - Delete elements with "struct ccs_acl_head".
  *
  * @member_list: Pointer to "struct list_head".
  * @id:          One of values in "enum ccs_policy_id".
  *
- * Returns true if some elements are deleted, false otherwise.
+ * Returns nothing.
  */
-static bool ccs_collect_member(struct list_head *member_list, int id)
+static void ccs_collect_member(const enum ccs_policy_id id,
+			       struct list_head *member_list)
 {
 	struct ccs_acl_head *member;
-	list_for_each_entry(member, member_list, list) {
-		if (!member->is_deleted)
-			continue;
-		if (!ccs_add_to_gc(id, &member->list))
-			return false;
+	struct ccs_acl_head *tmp;
+	list_for_each_entry_safe(member, tmp, member_list, list) {
+		if (member->is_deleted)
+			ccs_delete_entry(id, &member->list);
 	}
-	return true;
 }
 
 /**
@@ -654,57 +740,90 @@
  *
  * @domain: Pointer to "struct ccs_domain_info".
  *
- * Returns true if some elements are deleted, false otherwise.
+ * Returns nothing.
  */
-static bool ccs_collect_acl(struct ccs_domain_info *domain)
+static void ccs_collect_acl(struct ccs_domain_info *domain)
 {
 	struct ccs_acl_info *acl;
+	struct ccs_acl_info *tmp;
 	u8 i;
 	for (i = 0; i < 2; i++) {
-		list_for_each_entry(acl, &domain->acl_info_list[i], list) {
-			if (!acl->is_deleted)
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_ACL, &acl->list))
-				return false;
+		list_for_each_entry_safe(acl, tmp, &domain->acl_info_list[i],
+					 list) {
+			if (acl->is_deleted)
+				ccs_delete_entry(CCS_ID_ACL, &acl->list);
 		}
 	}
-	return true;
 }
 
+void ccs_daemonize(const char *name)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+	daemonize(name);
+#else
+	daemonize();
+	reparent_to_init();
+#if defined(TASK_DEAD)
+	{
+		struct task_struct *task = current;
+		spin_lock_irq(&task->sighand->siglock);
+		siginitsetinv(&task->blocked, 0);
+		recalc_sigpending();
+		spin_unlock_irq(&task->sighand->siglock);
+	}
+#else
+	{
+		struct task_struct *task = current;
+		spin_lock_irq(&task->sigmask_lock);
+		siginitsetinv(&task->blocked, 0);
+		recalc_sigpending(task);
+		spin_unlock_irq(&task->sigmask_lock);
+	}
+#endif
+	snprintf(current->comm, sizeof(current->comm) - 1, "%s", name);
+#endif
+}
+
 /**
- * ccs_collect_entry - Scan lists for deleted elements.
+ * ccs_gc_thread - Garbage collector thread function.
  *
- * Returns nothing.
+ * @unused: Unused.
+ *
+ * In case OOM-killer choose this thread for termination, we create this thread
+ * as a short live thread whenever /proc/ccs/ interface was close()d.
+ *
+ * Returns 0.
  */
-static void ccs_collect_entry(void)
+static int ccs_gc_thread(void *unused)
 {
 	int i;
-	int idx;
+	enum ccs_policy_id id;
+	/* Garbage collector thread is exclusive. */
+	static DEFINE_MUTEX(ccs_gc_mutex);
+	if (!mutex_trylock(&ccs_gc_mutex))
+		goto out;
+	ccs_daemonize("GC for CCS");
 	if (mutex_lock_interruptible(&ccs_policy_lock))
-		return;
-	idx = ccs_read_lock();
-	for (i = 0; i < CCS_MAX_POLICY; i++)
-		if (!ccs_collect_member(&ccs_policy_list[i], i))
-			goto unlock;
+		goto out_unlock;
+	for (id = 0; id < CCS_MAX_POLICY; id++)
+		ccs_collect_member(id, &ccs_policy_list[id]);
 	for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
-		if (!ccs_collect_acl(&ccs_acl_group[i]))
-			goto unlock;
+		ccs_collect_acl(&ccs_acl_group[i]);
 	{
 		struct ccs_domain_info *domain;
-		list_for_each_entry(domain, &ccs_domain_list, list) {
-			if (!ccs_collect_acl(domain))
-				goto unlock;
+		struct ccs_domain_info *tmp;
+		list_for_each_entry_safe(domain, tmp, &ccs_domain_list, list) {
+			ccs_collect_acl(domain);
 			if (!domain->is_deleted ||
 			    ccs_used_by_task(domain))
 				continue;
-			if (!ccs_add_to_gc(CCS_ID_DOMAIN, &domain->list))
-				goto unlock;
+			ccs_delete_entry(CCS_ID_DOMAIN, &domain->list);
 		}
 	}
 	for (i = 0; i < CCS_MAX_GROUP; i++) {
 		struct list_head *list = &ccs_group_list[i];
-		int id;
 		struct ccs_group *group;
+		struct ccs_group *tmp;
 		switch (i) {
 		case 0:
 			id = CCS_ID_PATH_GROUP;
@@ -716,21 +835,20 @@
 			id = CCS_ID_ADDRESS_GROUP;
 			break;
 		}
-		list_for_each_entry(group, list, head.list) {
-			if (!ccs_collect_member(&group->member_list, id))
-				goto unlock;
+		list_for_each_entry_safe(group, tmp, list, head.list) {
+			ccs_collect_member(id, &group->member_list);
 			if (!list_empty(&group->member_list) ||
 			    atomic_read(&group->head.users))
 				continue;
-			if (!ccs_add_to_gc(CCS_ID_GROUP, &group->head.list))
-				goto unlock;
+			ccs_delete_entry(CCS_ID_GROUP, &group->head.list);
 		}
 	}
 	for (i = 0; i < CCS_MAX_LIST + CCS_MAX_HASH; i++) {
 		struct list_head *list = i < CCS_MAX_LIST ?
 			&ccs_shared_list[i] : &ccs_name_list[i - CCS_MAX_LIST];
-		int id;
+		enum ccs_policy_id id;
 		struct ccs_shared_acl_head *ptr;
+		struct ccs_shared_acl_head *tmp;
 		switch (i) {
 		case 0:
 			id = CCS_ID_CONDITION;
@@ -742,132 +860,13 @@
 			id = CCS_ID_NAME;
 			break;
 		}
-		list_for_each_entry(ptr, list, list) {
-			if (atomic_read(&ptr->users))
-				continue;
-			if (!ccs_add_to_gc(id, &ptr->list))
-				goto unlock;
+		list_for_each_entry_safe(ptr, tmp, list, list) {
+			if (!atomic_read(&ptr->users))
+				ccs_delete_entry(id, &ptr->list);
 		}
 	}
-unlock:
-	ccs_read_unlock(idx);
 	mutex_unlock(&ccs_policy_lock);
-}
-
-/**
- * ccs_kfree_entry - Delete entries in ccs_gc_list.
- *
- * Returns true if some entries were kfree()d, false otherwise.
- */
-static bool ccs_kfree_entry(void)
-{
-	struct ccs_gc *p;
-	struct ccs_gc *tmp;
-	bool result = false;
-	list_for_each_entry_safe(p, tmp, &ccs_gc_list, list) {
-		size_t size = 0;
-		struct list_head * const element = p->element;
-		switch (p->type) {
-		case CCS_ID_TRANSITION_CONTROL:
-			size = ccs_del_transition_control(element);
-			break;
-		case CCS_ID_MANAGER:
-			size = ccs_del_manager(element);
-			break;
-		case CCS_ID_AGGREGATOR:
-			size = ccs_del_aggregator(element);
-			break;
-		case CCS_ID_GROUP:
-			size = ccs_del_group(element);
-			break;
-		case CCS_ID_PATH_GROUP:
-			size = ccs_del_path_group(element);
-			break;
-		case CCS_ID_ADDRESS_GROUP:
-			size = ccs_del_address_group(element);
-			break;
-		case CCS_ID_NUMBER_GROUP:
-			size = ccs_del_number_group(element);
-			break;
-		case CCS_ID_RESERVEDPORT:
-			size = ccs_del_reservedport(element);
-			break;
-		case CCS_ID_IPV6_ADDRESS:
-			size = ccs_del_ipv6_address(element);
-			break;
-		case CCS_ID_CONDITION:
-			size = ccs_del_condition(element);
-			break;
-		case CCS_ID_NAME:
-			size = ccs_del_name(element);
-			break;
-		case CCS_ID_ACL:
-			size = ccs_del_acl(element);
-			break;
-		case CCS_ID_DOMAIN:
-			size = ccs_del_domain(element);
-			if (!size)
-				continue;
-			break;
-		}
-		ccs_memory_free(element, size);
-		list_del(&p->list);
-		kfree(p);
-		ccs_gc_list_len--;
-		result = true;
-	}
-	return result;
-}
-
-/**
- * ccs_gc_thread - Garbage collector thread function.
- *
- * @unused: Unused.
- *
- * In case OOM-killer choose this thread for termination, we create this thread
- * as a short live thread whenever /proc/ccs/ interface was close()d.
- *
- * Returns 0.
- */
-static int ccs_gc_thread(void *unused)
-{
-	/* Garbage collector thread is exclusive. */
-	static DEFINE_MUTEX(ccs_gc_mutex);
-	if (!mutex_trylock(&ccs_gc_mutex))
-		goto out;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
-	daemonize("GC for CCS");
-#else
-	daemonize();
-	reparent_to_init();
-#if defined(TASK_DEAD)
-	{
-		struct task_struct *task = current;
-		spin_lock_irq(&task->sighand->siglock);
-		siginitsetinv(&task->blocked, 0);
-		recalc_sigpending();
-		spin_unlock_irq(&task->sighand->siglock);
-	}
-#else
-	{
-		struct task_struct *task = current;
-		spin_lock_irq(&task->sigmask_lock);
-		siginitsetinv(&task->blocked, 0);
-		recalc_sigpending(task);
-		spin_unlock_irq(&task->sigmask_lock);
-	}
-#endif
-	snprintf(current->comm, sizeof(current->comm) - 1, "GC for CCS");
-#endif
-	do {
-		ccs_collect_entry();
-		if (list_empty(&ccs_gc_list))
-			break;
-		ccs_synchronize_counter();
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
-		synchronize_srcu(&ccs_ss);
-#endif
-	} while (ccs_kfree_entry());
+out_unlock:
 	mutex_unlock(&ccs_gc_mutex);
 out:
 	/* This acts as do_exit(0). */
