config CCSECURITY
	bool "CCSecurity support"
	default m
	help
	  Say Y here to support non-LSM version of TOMOYO Linux.
	  http://tomoyo.sourceforge.jp/

config CCSECURITY_LKM
	bool "Compile as loadable kernel module"
	default n
	depends on CCSECURITY && MODULES
	help
	  Say Y here if you want to keep vmlinux's size as small as possible.

config CCSECURITY_DISABLE_BY_DEFAULT
	bool "Disable by default"
	default n
	depends on CCSECURITY
	help
	  Say Y here if you want TOMOYO disabled by default.
	  To enable TOMOYO, pass ccsecurity=on to kernel command line.
	  To disable TOMOYO, pass ccsecurity=off to kernel command line.

config CCSECURITY_USE_EXTERNAL_TASK_SECURITY
	bool "Do not modify 'struct task_struct' in order to keep KABI"
	default n
	depends on CCSECURITY
	help
	  Say Y here if you want to keep KABI for prebuilt kernel modules
	  unchanged. TOMOYO needs "struct ccs_domain_info *" and "u32" for each
	  "struct task_struct". But embedding these variables into
	  "struct task_struct" breaks KABI for prebuilt kernel modules (which
	  means that you will need to rebuild prebuilt kernel modules).
	  If you say Y here, these variables are managed outside
	  "struct task_struct" rather than embedding into "struct task_struct",
	  but accessing these variables becomes slower because lookup operation
	  is performed everytime the current thread needs to access them.

config CCSECURITY_MAX_ACCEPT_ENTRY
	int "Default maximal count for learning mode"
	default 2048
	range 0 2147483647
	depends on CCSECURITY
	help
	  This is the default value for maximal ACL entries
	  that are automatically appended into policy at "learning mode".
	  Some programs access thousands of objects, so running
	  such programs in "learning mode" dulls the system response
	  and consumes much memory.
	  This is the safeguard for such programs.

config CCSECURITY_MAX_AUDIT_LOG
	int "Default maximal count for audit log"
	default 1024
	range 0 2147483647
	depends on CCSECURITY
	help
	  This is the default value for maximal entries for
	  audit logs that the kernel can hold on memory.
	  You can read the log via /proc/ccs/audit.
	  If you don't need audit logs, you may set this value to 0.

config CCSECURITY_USE_BUILTIN_POLICY
	bool "Use built-in policy"
	default n
	depends on CCSECURITY
	---help---
	  Choose this option if you want to embed initial policy files into the
	  kernel. This is a superset of "Built-in domain initializer programs".

	  To use this option, you need to create a file named
	  security/ccsecurity/builtin-policy.h that contains /proc/ccs/profile
	  /proc/ccs/exception_policy /proc/ccs/domain_policy /proc/ccs/manager
	  and /proc/ccs/stat in this order which are quoted and escaped in
	  accordance with C syntax. An example content of the file looks like:

	    /* Profile configuration. */
	    "PROFILE_VERSION=20100903\n"
	    "0-CONFIG={ mode=enforcing }\n",
	    /* Exception policy configuration. */
	    "initialize_domain /sbin/modprobe from any\n"
	    "initialize_domain /sbin/hotplug from any\n",
	    /* Domain policy configuration. */
	    "<kernel>\n"
	    "use_profile 0\n"
	    "use_group 0\n"
	    "file execute /sbin/init\n"
	    "file execute /sbin/modprobe\n"
	    "file execute /sbin/hotplug\n"
	    "<kernel> /sbin/init\n"
	    "use_profile 0\n"
	    "use_group 0\n",
	    /* Manager configuration. */
	    "/usr/sbin/ccs-editpolicy\n",
	    /* Stat configuration. */
	    "Memory used by policy: 0\n"
	    "Memory used by audit log: 16777216\n"
	    "Memory used by query message: 1048576\n"

	  Note that you need to escape as needed (e.g. use \\ to represent \ ,
	  use \n to represent a new line) because the file is interpreted as
	  a C source file.

config CCSECURITY_BUILTIN_INITIALIZERS
	string "Built-in domain initializer programs"
	default "/sbin/modprobe /sbin/hotplug"
	depends on CCSECURITY
	depends on !CCSECURITY_USE_BUILTIN_POLICY
	---help---
	  Some programs are executed from initrd/initramfs before /sbin/init
	  starts.

	  Since policy is loaded when /sbin/init starts, it is impossible to
	  run such programs outside the <kernel> domain. Usually it is fine.

	  But if such programs continue running when /sbin/init starts, such
	  programs will reside in the <kernel> domain.
	  If such programs executes /bin/sh , you will give the <kernel> domain
	  permission to execute /bin/sh ; I think you don't want to do so.

	  This option allows you to chase such programs away from the <kernel>
	  domain so that you won't give the <kernel> domain permission to
	  execute /bin/sh .

config CCSECURITY_ACTIVATE_FROM_THE_BEGINNING
	bool "Activate immediately after loading built-in policy."
	default n
	depends on CCSECURITY_USE_BUILTIN_POLICY
	---help---
	  Choose this option if you want to activate access control as soon as
	  built-in policy was loaded. This option will be useful for systems
	  where operations which can lead to the hijacking of the boot sequence
	  are needed before loading the policy. For example, you can activate
	  immediately after loading the fixed part of policy which will allow
	  only operations needed for mounting a partition which contains the
	  variant part of policy and verifying (e.g. running GPG check) and
	  loading the variant part of policy. Since you can start using
	  enforcing mode from the beginning, you can reduce the possibility of
	  hijacking the boot sequence.

config CCSECURITY_OMIT_USERSPACE_LOADER
	bool "Omit calling policy loader when /sbin/init starts."
	default y
	depends on CCSECURITY_ACTIVATE_FROM_THE_BEGINNING
	---help---
	  Choose this option if you want to skip calling policy loader when
	  /sbin/init starts. If you embedded policy using "Use built-in policy"
	  and chose "Activate immediately after loading built-in policy.",
	  I think you don't need to call policy loader because policy was
	  already loaded and already activated.

config CCSECURITY_DEFAULT_LOADER
	string "Default policy loader"
	default "/sbin/ccs-init"
	depends on CCSECURITY
	depends on !CCSECURITY_OMIT_USERSPACE_LOADER
	---help---
	  This is the default pathname of policy loader which is called before
	  activation. You can override using CCS_loader= kernel command line
	  option.

config CCSECURITY_ALTERNATIVE_TRIGGER
	string "Alternative activation trigger"
	default "/sbin/ccs-start"
	depends on CCSECURITY
	depends on !CCSECURITY_OMIT_USERSPACE_LOADER
	---help---
	  Some environments do not have /sbin/init . In such environments,
	  we need to use different program's pathname (e.g. /init or /linuxrc )
	  as activation trigger.
