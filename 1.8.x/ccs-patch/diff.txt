Index: include/linux/ccsecurity.h
===================================================================
--- include/linux/ccsecurity.h	(revision 4923)
+++ include/linux/ccsecurity.h	(working copy)
@@ -32,6 +32,31 @@
 struct pid_namespace;
 int search_binary_handler(struct linux_binprm *bprm, struct pt_regs *regs);
 
+/* Index numbers for Capability Controls. */
+enum ccs_capability_acl_index {
+	/* socket(PF_ROUTE, *, *)                                      */
+	CCS_USE_ROUTE_SOCKET,
+	/* socket(PF_PACKET, *, *)                                     */
+	CCS_USE_PACKET_SOCKET,
+	/* sys_reboot()                                                */
+	CCS_SYS_REBOOT,
+	/* sys_vhangup()                                               */
+	CCS_SYS_VHANGUP,
+	/* do_settimeofday(), sys_adjtimex()                           */
+	CCS_SYS_SETTIME,
+	/* sys_nice(), sys_setpriority()                               */
+	CCS_SYS_NICE,
+	/* sys_sethostname(), sys_setdomainname()                      */
+	CCS_SYS_SETHOSTNAME,
+	/* sys_create_module(), sys_init_module(), sys_delete_module() */
+	CCS_USE_KERNEL_MODULE,
+	/* sys_kexec_load()                                            */
+	CCS_SYS_KEXEC_LOAD,
+	/* sys_ptrace()                                                */
+	CCS_SYS_PTRACE,
+	CCS_MAX_CAPABILITY_INDEX
+} __attribute__((packed));
+
 #ifdef CONFIG_CCSECURITY
 
 /* For exporting variables and functions. */
@@ -83,7 +108,7 @@
 				 unsigned long arg);
 	int (*parse_table) (int __user *name, int nlen, void __user *oldval,
 			    void __user *newval, struct ctl_table *table);
-	_Bool (*capable) (const u8 operation);
+	_Bool (*capable) (const enum ccs_capability_acl_index operation);
 	int (*mknod_permission) (struct inode *dir, struct dentry *dentry,
 				 struct vfsmount *mnt, unsigned int mode,
 				 unsigned int dev);
@@ -279,9 +304,10 @@
 	return func ? func(name, nlen, oldval, newval, table) : 0;
 }
 
-static inline _Bool ccs_capable(const u8 operation)
+static inline _Bool ccs_capable(const enum ccs_capability_acl_index operation)
 {
-	_Bool (*func) (const u8) = ccsecurity_ops.capable;
+	_Bool (*func) (const enum ccs_capability_acl_index)
+		= ccsecurity_ops.capable;
 	return func ? func(operation) : 1;
 }
 
@@ -629,7 +655,7 @@
 	return 0;
 }
 
-static inline _Bool ccs_capable(const u8 operation)
+static inline _Bool ccs_capable(const enum ccs_capability_acl_index operation)
 {
 	return 1;
 }
@@ -817,29 +843,4 @@
 
 #endif
 
-/* Index numbers for Capability Controls. */
-enum ccs_capability_acl_index {
-	/* socket(PF_ROUTE, *, *)                                      */
-	CCS_USE_ROUTE_SOCKET,
-	/* socket(PF_PACKET, *, *)                                     */
-	CCS_USE_PACKET_SOCKET,
-	/* sys_reboot()                                                */
-	CCS_SYS_REBOOT,
-	/* sys_vhangup()                                               */
-	CCS_SYS_VHANGUP,
-	/* do_settimeofday(), sys_adjtimex()                           */
-	CCS_SYS_SETTIME,
-	/* sys_nice(), sys_setpriority()                               */
-	CCS_SYS_NICE,
-	/* sys_sethostname(), sys_setdomainname()                      */
-	CCS_SYS_SETHOSTNAME,
-	/* sys_create_module(), sys_init_module(), sys_delete_module() */
-	CCS_USE_KERNEL_MODULE,
-	/* sys_kexec_load()                                            */
-	CCS_SYS_KEXEC_LOAD,
-	/* sys_ptrace()                                                */
-	CCS_SYS_PTRACE,
-	CCS_MAX_CAPABILITY_INDEX
-};
-
 #endif
Index: security/ccsecurity/domain.c
===================================================================
--- security/ccsecurity/domain.c	(revision 4923)
+++ security/ccsecurity/domain.c	(working copy)
@@ -109,7 +109,7 @@
 	const bool is_delete = param->is_delete;
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	struct ccs_acl_info *entry;
-	const u8 type = new_entry->type;
+	const enum ccs_acl_entry_type_index type = new_entry->type;
 	const u8 i = type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
 		type == CCS_TYPE_DENIED_EXECUTE_HANDLER ||
 		type == CCS_TYPE_AUTO_TASK_ACL;
@@ -221,8 +221,8 @@
  */
 static int ccs_update_transition_control_entry(const char *domainname,
 					       const char *program,
-					       const u8 type,
-					       const bool is_delete)
+					       const enum ccs_transition_type
+					       type, const bool is_delete)
 {
 	struct ccs_transition_control e = { .type = type };
 	int error = is_delete ? -ENOENT : -ENOMEM;
@@ -262,7 +262,7 @@
  * Returns 0 on success, negative value otherwise.
  */
 int ccs_write_transition_control(char *data, const bool is_delete,
-				 const u8 type)
+				 const enum ccs_transition_type type)
 {
 	char *domainname = strstr(data, " from ");
 	if (domainname) {
Index: security/ccsecurity/memory.c
===================================================================
--- security/ccsecurity/memory.c	(revision 4923)
+++ security/ccsecurity/memory.c	(working copy)
@@ -114,7 +114,8 @@
  *
  * Returns pointer to "struct ccs_group" on success, NULL otherwise.
  */
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx)
+struct ccs_group *ccs_get_group(const char *group_name,
+				const enum ccs_group_id idx)
 {
 	struct ccs_group e = { };
 	struct ccs_group *group = NULL;
Index: security/ccsecurity/util.c
===================================================================
--- security/ccsecurity/util.c	(revision 4923)
+++ security/ccsecurity/util.c	(working copy)
@@ -14,8 +14,8 @@
 /* Has /sbin/init started? */
 bool ccs_policy_loaded;
 
-/* Mapping table from "enum ccs_mac_index" to "enum ccs_mac_category_index". */
-const u8 ccs_index2category[CCS_MAX_MAC_INDEX] = {
+/* Mapping table from "enum ccs_mac_index" to "". */
+const enum ccs_mac_category_index ccs_index2category[CCS_MAX_MAC_INDEX] = {
 	/* CONFIG::file group */
 	[CCS_MAC_FILE_EXECUTE]    = CCS_MAC_CATEGORY_FILE,
 	[CCS_MAC_FILE_OPEN]       = CCS_MAC_CATEGORY_FILE,
@@ -194,7 +194,7 @@
  * The @src is updated to point the first character after the value
  * on success.
  */
-u8 ccs_parse_ulong(unsigned long *result, char **str)
+enum ccs_value_type ccs_parse_ulong(unsigned long *result, char **str)
 {
 	const char *cp = *str;
 	char *ep;
@@ -991,9 +991,10 @@
  * CONFIG::category. If CONFIG::category is set to use default, then use
  * CONFIG. CONFIG cannot be set to use default.
  */
-u8 ccs_get_config(const u8 profile, const u8 index)
+enum ccs_mode_value ccs_get_config(const u8 profile,
+				   const enum ccs_mac_index index)
 {
-	u8 config;
+	enum ccs_mode_value config;
 	const struct ccs_profile *p;
 	if (!ccs_policy_loaded)
 		return CCS_CONFIG_DISABLED;
@@ -1020,7 +1021,8 @@
  * transition to that domain failed, the current thread will be killed by
  * SIGKILL. Note that if current->pid == 1, sending SIGKILL won't work.
  */
-int ccs_init_request_info(struct ccs_request_info *r, const u8 index)
+enum ccs_mode_value ccs_init_request_info(struct ccs_request_info *r,
+					  const enum ccs_mac_index index)
 {
 	u8 i;
 	const char *buf;
Index: security/ccsecurity/file.c
===================================================================
--- security/ccsecurity/file.c	(revision 4923)
+++ security/ccsecurity/file.c	(working copy)
@@ -28,8 +28,8 @@
 
 #endif
 
-/* Mapping table from "enum ccs_path_acl_index" to "enum ccs_mac_index". */
-static const u8 ccs_p2mac[CCS_MAX_PATH_OPERATION] = {
+/* Mapping table from "enum ccs_path_acl_index". */
+static const enum ccs_mac_index ccs_p2mac[CCS_MAX_PATH_OPERATION] = {
 	[CCS_TYPE_EXECUTE]    = CCS_MAC_FILE_EXECUTE,
 	[CCS_TYPE_READ]       = CCS_MAC_FILE_OPEN,
 	[CCS_TYPE_WRITE]      = CCS_MAC_FILE_OPEN,
@@ -43,23 +43,21 @@
 	[CCS_TYPE_UMOUNT]     = CCS_MAC_FILE_UMOUNT,
 };
 
-/* Mapping table from "enum ccs_mkdev_acl_index" to "enum ccs_mac_index". */
-const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION] = {
+/* Mapping table from "enum ccs_mkdev_acl_index". */
+const enum ccs_mac_index ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION] = {
 	[CCS_TYPE_MKBLOCK] = CCS_MAC_FILE_MKBLOCK,
 	[CCS_TYPE_MKCHAR]  = CCS_MAC_FILE_MKCHAR,
 };
 
-/* Mapping table from "enum ccs_path2_acl_index" to "enum ccs_mac_index". */
-const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION] = {
+/* Mapping table from "enum ccs_path2_acl_index". */
+const enum ccs_mac_index ccs_pp2mac[CCS_MAX_PATH2_OPERATION] = {
 	[CCS_TYPE_LINK]       = CCS_MAC_FILE_LINK,
 	[CCS_TYPE_RENAME]     = CCS_MAC_FILE_RENAME,
 	[CCS_TYPE_PIVOT_ROOT] = CCS_MAC_FILE_PIVOT_ROOT,
 };
 
-/*
- * Mapping table from "enum ccs_path_number_acl_index" to "enum ccs_mac_index".
- */
-const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION] = {
+/* Mapping table from "enum ccs_path_number_acl_index". */
+const enum ccs_mac_index ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION] = {
 	[CCS_TYPE_CREATE] = CCS_MAC_FILE_CREATE,
 	[CCS_TYPE_MKDIR]  = CCS_MAC_FILE_MKDIR,
 	[CCS_TYPE_MKFIFO] = CCS_MAC_FILE_MKFIFO,
@@ -228,8 +226,9 @@
  */
 static int ccs_audit_path_number_log(struct ccs_request_info *r)
 {
-	const u8 type = r->param.path_number.operation;
-	u8 radix;
+	const enum ccs_path_number_acl_index type
+		= r->param.path_number.operation;
+	enum ccs_value_type radix;
 	char buffer[64];
 	switch (type) {
 	case CCS_TYPE_CREATE:
@@ -605,7 +604,8 @@
  *
  * Caller holds ccs_read_lock().
  */
-int ccs_path_permission(struct ccs_request_info *r, u8 operation,
+int ccs_path_permission(struct ccs_request_info *r,
+			const enum ccs_path_acl_index operation,
 			const struct ccs_path_info *filename)
 {
 	int error;
@@ -768,8 +768,9 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_path_perm(const u8 operation, struct dentry *dentry,
-			 struct vfsmount *mnt, const char *target)
+static int ccs_path_perm(const enum ccs_path_acl_index operation,
+			 struct dentry *dentry, struct vfsmount *mnt,
+			 const char *target)
 {
 	struct ccs_request_info r;
 	struct ccs_obj_info obj = {
@@ -804,6 +805,8 @@
 		ccs_fill_path_info(&symlink_target);
 		obj.symlink_target = &symlink_target;
 		break;
+	default:
+		break;
 	}
 	error = ccs_path_permission(&r, operation, &buf);
 	if (operation == CCS_TYPE_SYMLINK)
@@ -820,7 +823,6 @@
  * ccs_mkdev_perm - Check permission for "mkblock" and "mkchar".
  *
  * @operation: Type of operation. (CCS_TYPE_MKCHAR or CCS_TYPE_MKBLOCK)
- * @dir:       Pointer to "struct inode".
  * @dentry:    Pointer to "struct dentry".
  * @mnt:       Pointer to "struct vfsmount". Maybe NULL.
  * @mode:      Create mode.
@@ -828,7 +830,7 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_mkdev_perm(const u8 operation, struct inode *dir,
+static int ccs_mkdev_perm(const enum ccs_mkdev_acl_index operation,
 			  struct dentry *dentry, struct vfsmount *mnt,
 			  const unsigned int mode, unsigned int dev)
 {
@@ -878,19 +880,16 @@
  * ccs_path2_perm - Check permission for "rename", "link" and "pivot_root".
  *
  * @operation: Type of operation.
- * @dir1:      Pointer to "struct inode". Maybe NULL.
  * @dentry1:   Pointer to "struct dentry".
  * @mnt1:      Pointer to "struct vfsmount". Maybe NULL.
- * @dir2:      Pointer to "struct inode". Maybe NULL.
  * @dentry2:   Pointer to "struct dentry".
  * @mnt2:      Pointer to "struct vfsmount". Maybe NULL.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_path2_perm(const u8 operation, struct inode *dir1,
+static int ccs_path2_perm(const enum ccs_path2_acl_index operation,
 			  struct dentry *dentry1, struct vfsmount *mnt1,
-			  struct inode *dir2, struct dentry *dentry2,
-			  struct vfsmount *mnt2)
+			  struct dentry *dentry2, struct vfsmount *mnt2)
 {
 	struct ccs_request_info r;
 	int error = 0;
@@ -925,6 +924,8 @@
 		ccs_add_slash(&buf1);
 		ccs_add_slash(&buf2);
 		break;
+	case CCS_MAX_PATH2_OPERATION:
+		break;
 	}
 	r.obj = &obj;
 	r.param_type = CCS_TYPE_PATH2_ACL;
@@ -1028,7 +1029,7 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_path_number_perm(const u8 type, struct inode *dir,
+static int ccs_path_number_perm(const enum ccs_path_number_acl_index type,
 				struct dentry *dentry, struct vfsmount *vfsmnt,
 				unsigned long number)
 {
@@ -1079,7 +1080,7 @@
 static int __ccs_ioctl_permission(struct file *filp, unsigned int cmd,
 				  unsigned long arg)
 {
-	return ccs_path_number_perm(CCS_TYPE_IOCTL, NULL, filp->f_dentry,
+	return ccs_path_number_perm(CCS_TYPE_IOCTL, filp->f_dentry,
 				    filp->f_vfsmnt, cmd);
 }
 
@@ -1097,7 +1098,7 @@
 {
 	if (mode == (mode_t) -1)
 		return 0;
-	return ccs_path_number_perm(CCS_TYPE_CHMOD, NULL, dentry, vfsmnt,
+	return ccs_path_number_perm(CCS_TYPE_CHMOD, dentry, vfsmnt,
 				    mode & S_IALLUGO);
 }
 
@@ -1119,11 +1120,11 @@
 	if (user == (uid_t) -1 && group == (gid_t) -1)
 		return 0;
 	if (user != (uid_t) -1)
-		error = ccs_path_number_perm(CCS_TYPE_CHOWN, NULL, dentry,
-					     vfsmnt, user);
+		error = ccs_path_number_perm(CCS_TYPE_CHOWN, dentry, vfsmnt,
+					     user);
 	if (!error && group != (gid_t) -1)
-		error = ccs_path_number_perm(CCS_TYPE_CHGRP, NULL, dentry,
-					     vfsmnt, group);
+		error = ccs_path_number_perm(CCS_TYPE_CHGRP, dentry, vfsmnt,
+					     group);
 	return error;
 }
 
@@ -1164,9 +1165,8 @@
 static int __ccs_pivot_root_permission(struct path *old_path,
 				       struct path *new_path)
 {
-	return ccs_path2_perm(CCS_TYPE_PIVOT_ROOT, NULL, new_path->dentry,
-			      new_path->mnt, NULL, old_path->dentry,
-			      old_path->mnt);
+	return ccs_path2_perm(CCS_TYPE_PIVOT_ROOT, new_path->dentry,
+			      new_path->mnt, old_path->dentry, old_path->mnt);
 }
 
 /**
@@ -1253,24 +1253,24 @@
 	const unsigned int perm = mode & S_IALLUGO;
 	switch (mode & S_IFMT) {
 	case S_IFCHR:
-		error = ccs_mkdev_perm(CCS_TYPE_MKCHAR, dir, dentry, mnt, perm,
+		error = ccs_mkdev_perm(CCS_TYPE_MKCHAR, dentry, mnt, perm,
 				       dev);
 		break;
 	case S_IFBLK:
-		error = ccs_mkdev_perm(CCS_TYPE_MKBLOCK, dir, dentry, mnt,
-				       perm, dev);
+		error = ccs_mkdev_perm(CCS_TYPE_MKBLOCK, dentry, mnt, perm,
+				       dev);
 		break;
 	case S_IFIFO:
-		error = ccs_path_number_perm(CCS_TYPE_MKFIFO, dir, dentry, mnt,
+		error = ccs_path_number_perm(CCS_TYPE_MKFIFO, dentry, mnt,
 					     perm);
 		break;
 	case S_IFSOCK:
-		error = ccs_path_number_perm(CCS_TYPE_MKSOCK, dir, dentry, mnt,
+		error = ccs_path_number_perm(CCS_TYPE_MKSOCK, dentry, mnt,
 					     perm);
 		break;
 	case 0:
 	case S_IFREG:
-		error = ccs_path_number_perm(CCS_TYPE_CREATE, dir, dentry, mnt,
+		error = ccs_path_number_perm(CCS_TYPE_CREATE, dentry, mnt,
 					     perm);
 		break;
 	}
@@ -1290,7 +1290,7 @@
 static int __ccs_mkdir_permission(struct inode *dir, struct dentry *dentry,
 				  struct vfsmount *mnt, unsigned int mode)
 {
-	return ccs_path_number_perm(CCS_TYPE_MKDIR, dir, dentry, mnt, mode);
+	return ccs_path_number_perm(CCS_TYPE_MKDIR, dentry, mnt, mode);
 }
 
 /**
@@ -1384,8 +1384,8 @@
 				   struct dentry *new_dentry,
 				   struct vfsmount *mnt)
 {
-	return ccs_path2_perm(CCS_TYPE_RENAME, old_dir, old_dentry, mnt,
-			      new_dir, new_dentry, mnt);
+	return ccs_path2_perm(CCS_TYPE_RENAME, old_dentry, mnt, new_dentry,
+			      mnt);
 }
 
 /**
@@ -1403,8 +1403,7 @@
 				 struct dentry *new_dentry,
 				 struct vfsmount *mnt)
 {
-	return ccs_path2_perm(CCS_TYPE_LINK, NULL, old_dentry, mnt,
-			      new_dir, new_dentry, mnt);
+	return ccs_path2_perm(CCS_TYPE_LINK, old_dentry, mnt, new_dentry, mnt);
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
Index: security/ccsecurity/capability.c
===================================================================
--- security/ccsecurity/capability.c	(revision 4923)
+++ security/ccsecurity/capability.c	(working copy)
@@ -8,10 +8,8 @@
 
 #include "internal.h"
 
-/*
- * Mapping table from "enum ccs_capability_acl_index" to "enum ccs_mac_index".
- */
-const u8 ccs_c2mac[CCS_MAX_CAPABILITY_INDEX] = {
+/* Mapping table from "enum ccs_capability_acl_index". */
+const enum ccs_mac_index ccs_c2mac[CCS_MAX_CAPABILITY_INDEX] = {
 	[CCS_USE_ROUTE_SOCKET]  = CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET,
 	[CCS_USE_PACKET_SOCKET] = CCS_MAC_CAPABILITY_USE_PACKET_SOCKET,
 	[CCS_SYS_REBOOT]        = CCS_MAC_CAPABILITY_SYS_REBOOT,
@@ -60,7 +58,7 @@
  *
  * Returns true on success, false otherwise.
  */
-static bool __ccs_capable(const u8 operation)
+static bool __ccs_capable(const enum ccs_capability_acl_index operation)
 {
 	struct ccs_request_info r;
 	int error = 0;
Index: security/ccsecurity/internal.h
===================================================================
--- security/ccsecurity/internal.h	(revision 4923)
+++ security/ccsecurity/internal.h	(working copy)
@@ -332,6 +332,10 @@
 
 #endif
 
+#ifndef __packed
+#define __packed __attribute__((packed))
+#endif
+
 /*
  * TOMOYO specific part start.
  */
@@ -356,7 +360,7 @@
 	CCS_TYPE_DENIED_EXECUTE_HANDLER,
 	CCS_TYPE_AUTO_TASK_ACL,
 	CCS_TYPE_MANUAL_TASK_ACL,
-};
+} __packed;
 
 /* Index numbers for "struct ccs_condition". */
 enum ccs_conditions_index {
@@ -427,7 +431,7 @@
 	CCS_NAME_UNION,
 	CCS_ARGV_ENTRY,
 	CCS_ENVP_ENTRY,
-};
+} __packed;
 
 /* Index numbers for domain's attributes. */
 enum ccs_domain_info_flags_index {
@@ -441,7 +445,7 @@
 	 */
 	CCS_DIF_TRANSITION_FAILED,
 	CCS_MAX_DOMAIN_INFO_FLAGS
-};
+} __packed;
 
 /* Index numbers for audit type. */
 enum ccs_grant_log {
@@ -451,7 +455,7 @@
 	CCS_GRANTLOG_NO,
 	/* Generate grant_log. */
 	CCS_GRANTLOG_YES,
-};
+} __packed;
 
 /* Index numbers for group entries. */
 enum ccs_group_id {
@@ -459,14 +463,14 @@
 	CCS_NUMBER_GROUP,
 	CCS_ADDRESS_GROUP,
 	CCS_MAX_GROUP
-};
+} __packed;
 
 /* Index numbers for type of IP address. */
 enum ccs_ip_address_type {
 	CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP,
 	CCS_IP_ADDRESS_TYPE_IPv4,
 	CCS_IP_ADDRESS_TYPE_IPv6,
-};
+} __packed;
 
 /* Index numbers for category of functionality. */
 enum ccs_mac_category_index {
@@ -476,7 +480,7 @@
 	CCS_MAC_CATEGORY_IPC,
 	CCS_MAC_CATEGORY_CAPABILITY,
 	CCS_MAX_MAC_CATEGORY_INDEX
-};
+} __packed;
 
 /* Index numbers for functionality. */
 enum ccs_mac_index {
@@ -537,7 +541,7 @@
 	CCS_MAC_CAPABILITY_SYS_KEXEC_LOAD,
 	CCS_MAC_CAPABILITY_SYS_PTRACE,
 	CCS_MAX_MAC_INDEX
-};
+} __packed;
 
 /* Index numbers for /proc/ccs/stat interface. */
 enum ccs_memory_stat_type {
@@ -545,14 +549,14 @@
 	CCS_MEMORY_AUDIT,
 	CCS_MEMORY_QUERY,
 	CCS_MAX_MEMORY_STAT
-};
+} __packed;
 
 /* Index numbers for access controls with one pathname and three numbers. */
 enum ccs_mkdev_acl_index {
 	CCS_TYPE_MKBLOCK,
 	CCS_TYPE_MKCHAR,
 	CCS_MAX_MKDEV_OPERATION
-};
+} __packed;
 
 /* Index numbers for operation mode. */
 enum ccs_mode_value {
@@ -564,7 +568,7 @@
 	CCS_CONFIG_WANT_REJECT_LOG =  64,
 	CCS_CONFIG_WANT_GRANT_LOG  = 128,
 	CCS_CONFIG_USE_DEFAULT     = 255,
-};
+} __packed;
 
 /* Index numbers for socket operations. */
 enum ccs_network_acl_index {
@@ -575,7 +579,7 @@
 	CCS_NETWORK_SEND,    /* send() operation. */
 	CCS_NETWORK_RECV,    /* recv() operation. */
 	CCS_MAX_NETWORK_OPERATION
-};
+} __packed;
 
 /* Index numbers for access controls with two pathnames. */
 enum ccs_path2_acl_index {
@@ -583,7 +587,7 @@
 	CCS_TYPE_RENAME,
 	CCS_TYPE_PIVOT_ROOT,
 	CCS_MAX_PATH2_OPERATION
-};
+} __packed;
 
 /* Index numbers for access controls with one pathname. */
 enum ccs_path_acl_index {
@@ -599,7 +603,7 @@
 	CCS_TYPE_CHROOT,
 	CCS_TYPE_UMOUNT,
 	CCS_MAX_PATH_OPERATION
-};
+} __packed;
 
 /* Index numbers for access controls with one pathname and one number. */
 enum ccs_path_number_acl_index {
@@ -612,7 +616,7 @@
 	CCS_TYPE_CHOWN,
 	CCS_TYPE_CHGRP,
 	CCS_MAX_PATH_NUMBER_OPERATION
-};
+} __packed;
 
 /* Index numbers for stat(). */
 enum ccs_path_stat_index {
@@ -622,7 +626,7 @@
 	CCS_PATH2,
 	CCS_PATH2_PARENT,
 	CCS_MAX_PATH_STAT
-};
+} __packed;
 
 /* Index numbers for entry type. */
 enum ccs_policy_id {
@@ -640,7 +644,7 @@
 	CCS_ID_ACL,
 	CCS_ID_DOMAIN,
 	CCS_MAX_POLICY
-};
+} __packed;
 
 /* Index numbers for /proc/ccs/stat interface. */
 enum ccs_policy_stat_type {
@@ -650,7 +654,7 @@
 	CCS_STAT_POLICY_PERMISSIVE, /* == CCS_CONFIG_PERMISSIVE */
 	CCS_STAT_POLICY_ENFORCING,  /* == CCS_CONFIG_ENFORCING */
 	CCS_MAX_POLICY_STAT
-};
+} __packed;
 
 /* Index numbers for profile's PREFERENCE values. */
 enum ccs_pref_index {
@@ -658,7 +662,7 @@
 	CCS_PREF_MAX_LEARNING_ENTRY,
 	CCS_PREF_ENFORCING_PENALTY,
 	CCS_MAX_PREF
-};
+} __packed;
 
 /* Index numbers for /proc/ccs/ interfaces. */
 enum ccs_proc_interface_index {
@@ -673,14 +677,14 @@
 	CCS_QUERY,
 	CCS_MANAGER,
 	CCS_EXECUTE_HANDLER,
-};
+} __packed;
 
 /* Index numbers for shared entries. */
 enum ccs_shared_acl_id {
 	CCS_CONDITION_LIST,
 	CCS_IPV6ADDRESS_LIST,
 	CCS_MAX_LIST
-};
+} __packed;
 
 /* Index numbers for special mount operations. */
 enum ccs_special_mount {
@@ -692,7 +696,7 @@
 	CCS_MOUNT_MAKE_SLAVE,      /* mount --make-slave /dir      */
 	CCS_MOUNT_MAKE_SHARED,     /* mount --make-shared /dir     */
 	CCS_MAX_SPECIAL_MOUNT
-};
+} __packed;
 
 /* Index numbers for domain transition control keywords. */
 enum ccs_transition_type {
@@ -702,7 +706,7 @@
 	CCS_TRANSITION_CONTROL_NO_KEEP,
 	CCS_TRANSITION_CONTROL_KEEP,
 	CCS_MAX_TRANSITION_TYPE
-};
+} __packed;
 
 /* Index numbers for type of numeric values. */
 enum ccs_value_type {
@@ -710,7 +714,7 @@
 	CCS_VALUE_TYPE_DECIMAL,
 	CCS_VALUE_TYPE_OCTAL,
 	CCS_VALUE_TYPE_HEXADECIMAL,
-};
+} __packed;
 
 /* Constants definition for internal use. */
 
@@ -788,21 +792,21 @@
 struct ccs_acl_head {
 	struct list_head list;
 	bool is_deleted;
-} __attribute__((__packed__));
+} __packed;
 
 /* Common header for shared entries. */
 struct ccs_shared_acl_head {
 	struct list_head list;
 	atomic_t users;
-} __attribute__((__packed__));
+} __packed;
 
 /* Common header for individual entries. */
 struct ccs_acl_info {
 	struct list_head list;
 	struct ccs_condition *cond; /* Maybe NULL. */
 	bool is_deleted;
-	u8 type; /* One of values in "enum ccs_acl_entry_type_index". */
-} __attribute__((__packed__));
+	enum ccs_acl_entry_type_index type;
+} __packed;
 
 /* Structure for holding a word. */
 struct ccs_name_union {
@@ -810,17 +814,16 @@
 	const struct ccs_path_info *filename;
 	struct ccs_group *group;
 	/* True if @group != NULL, false if @filename != NULL. */
-	u8 is_group;
+	bool is_group;
 };
 
 /* Structure for holding a number. */
 struct ccs_number_union {
 	unsigned long values[2];
 	struct ccs_group *group; /* Maybe NULL. */
-	/* One of values in "enum ccs_value_type". */
-	u8 value_type[2];
+	enum ccs_value_type value_type[2];
 	/* True if @group != NULL, false otherwise. */
-	u8 is_group;
+	bool is_group;
 };
 
 /* Structure for "path_group"/"number_group"/"address_group" directive. */
@@ -902,13 +905,13 @@
 	 * "struct ccs_envp" for CCS_ENVP_ENTRY is attached to the tail
 	 * of the array of this struct.
 	 */
-	u8 left;
+	enum ccs_conditions_index left;
 	/*
 	 * Right hand operand. A "struct ccs_number_union" for
 	 * CCS_NUMBER_UNION, a "struct ccs_name_union" for CCS_NAME_UNION is
 	 * attached to the tail of the array of this struct.
 	 */
-	u8 right;
+	enum ccs_conditions_index right;
 	/* Equation operator. True if equals or overlaps, false otherwise. */
 	bool equals;
 };
@@ -922,7 +925,7 @@
 	u16 names_count; /* Number of "struct ccs_name_union names". */
 	u16 argc; /* Number of "struct ccs_argv". */
 	u16 envc; /* Number of "struct ccs_envp". */
-	u8 grant_log; /* One of values in "enum ccs_grant_log". */
+	enum ccs_grant_log grant_log;
 	const struct ccs_path_info *transit; /* Maybe NULL. */
 	/*
 	 * struct ccs_condition_element condition[condc];
@@ -963,30 +966,24 @@
 			 * than "struct ccs_path_acl".
 			 */
 			const struct ccs_path_info *matched_path;
-			/* One of values in "enum ccs_path_acl_index". */
-			u8 operation;
+			enum ccs_path_acl_index operation;
 		} path;
 		struct {
 			const struct ccs_path_info *filename1;
 			const struct ccs_path_info *filename2;
-			/* One of values in "enum ccs_path2_acl_index". */
-			u8 operation;
+			enum ccs_path2_acl_index operation;
 		} path2;
 		struct {
 			const struct ccs_path_info *filename;
 			unsigned int mode;
 			unsigned int major;
 			unsigned int minor;
-			/* One of values in "enum ccs_mkdev_acl_index". */
-			u8 operation;
+			enum ccs_mkdev_acl_index operation;
 		} mkdev;
 		struct {
 			const struct ccs_path_info *filename;
 			unsigned long number;
-			/*
-			 * One of values in "enum ccs_path_number_acl_index".
-			 */
-			u8 operation;
+			enum ccs_path_number_acl_index operation;
 		} path_number;
 		struct {
 			const u32 *address;
@@ -994,23 +991,20 @@
 			u16 port;
 			/* One of values smaller than CCS_SOCK_MAX. */
 			u8 protocol;
-			/* One of values in "enum ccs_network_acl_index". */
-			u8 operation;
+			enum ccs_network_acl_index operation;
 			bool is_ipv6;
 		} inet_network;
 		struct {
 			const struct ccs_path_info *address;
 			/* One of values smaller than CCS_SOCK_MAX. */
 			u8 protocol;
-			/* One of values in "enum ccs_network_acl_index". */
-			u8 operation;
+			enum ccs_network_acl_index operation;
 		} unix_network;
 		struct {
 			const struct ccs_path_info *name;
 		} environ;
 		struct {
-			/* One of values in "enum ccs_capability_acl_index". */
-			u8 operation;
+			enum ccs_capability_acl_index operation;
 		} capability;
 		struct {
 			const char *dest_pattern;
@@ -1027,7 +1021,7 @@
 			const struct ccs_path_info *domainname;
 		} task;
 	} param;
-	u8 param_type; /* One of values in "enum ccs_acl_entry_type_index". */
+	enum ccs_acl_entry_type_index param_type;
 	bool granted; /* True if granted, false otherwise. */
 	/* True if current thread should not be carried sleep penalty. */
 	bool dont_sleep_on_enforce_error;
@@ -1107,7 +1101,7 @@
  */
 struct ccs_transition_control {
 	struct ccs_acl_head head;
-	u8 type; /* = one of values in "enum ccs_transition_type" */
+	enum ccs_transition_type type;
 	bool is_last_name; /* True if the domainname is ccs_last_word(). */
 	const struct ccs_path_info *domainname;
 	const struct ccs_path_info *program;
@@ -1242,7 +1236,7 @@
 /* Structure for "capability" directive. */
 struct ccs_capability_acl {
 	struct ccs_acl_info head; /* type = CCS_TYPE_CAPABILITY_ACL */
-	u8 operation; /* one of values in "enum ccs_capability_acl_index". */
+	enum ccs_capability_acl_index operation;
 };
 
 /* Structure for "ipc signal" directive. */
@@ -1366,8 +1360,9 @@
 /* Structure for /proc/ccs/profile interface. */
 struct ccs_profile {
 	const struct ccs_path_info *comment;
-	u8 default_config;
-	u8 config[CCS_MAX_MAC_INDEX + CCS_MAX_MAC_CATEGORY_INDEX];
+	enum ccs_mode_value default_config;
+	enum ccs_mode_value config[CCS_MAX_MAC_INDEX
+				   + CCS_MAX_MAC_CATEGORY_INDEX];
 	unsigned int pref[CCS_MAX_PREF];
 };
 
@@ -1436,10 +1431,13 @@
 int ccs_delete_domain(char *data);
 int ccs_env_perm(struct ccs_request_info *r, const char *env);
 int ccs_get_path(const char *pathname, struct path *path);
-int ccs_init_request_info(struct ccs_request_info *r, const u8 index);
-int ccs_open_control(const u8 type, struct file *file);
+enum ccs_mode_value ccs_init_request_info(struct ccs_request_info *r,
+					  const enum ccs_mac_index index);
+int ccs_open_control(const enum ccs_proc_interface_index type,
+		     struct file *file);
 int ccs_parse_ip_address(char *address, u16 *min, u16 *max);
-int ccs_path_permission(struct ccs_request_info *r, u8 operation,
+int ccs_path_permission(struct ccs_request_info *r,
+			const enum ccs_path_acl_index operation,
 			const struct ccs_path_info *filename);
 int ccs_poll_control(struct file *file, poll_table *wait);
 int ccs_poll_log(struct file *file, poll_table *wait);
@@ -1460,13 +1458,14 @@
 int ccs_write_aggregator(char *data, const bool is_delete);
 int ccs_write_capability(struct ccs_acl_param *param);
 int ccs_write_file(struct ccs_acl_param *param);
-int ccs_write_group(char *data, const bool is_delete, const u8 type);
+int ccs_write_group(char *data, const bool is_delete,
+		    const enum ccs_group_id type);
 int ccs_write_inet_network(struct ccs_acl_param *param);
 int ccs_write_ipc(struct ccs_acl_param *param);
 int ccs_write_misc(struct ccs_acl_param *param);
 int ccs_write_reserved_port(char *data, const bool is_delete);
 int ccs_write_transition_control(char *data, const bool is_delete,
-				 const u8 type);
+				 const enum ccs_transition_type type);
 int ccs_write_unix_network(struct ccs_acl_param *param);
 ssize_t ccs_read_control(struct file *file, char __user *buffer,
 			 const size_t buffer_len);
@@ -1477,10 +1476,12 @@
 					  const u8 profile, const u8 group,
 					  const bool transit);
 struct ccs_domain_info *ccs_find_domain(const char *domainname);
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx);
+struct ccs_group *ccs_get_group(const char *group_name,
+				const enum ccs_group_id idx);
 struct ccs_profile *ccs_profile(const u8 profile);
-u8 ccs_get_config(const u8 profile, const u8 index);
-u8 ccs_parse_ulong(unsigned long *result, char **str);
+enum ccs_mode_value ccs_get_config(const u8 profile,
+				   const enum ccs_mac_index index);
+enum ccs_value_type ccs_parse_ulong(unsigned long *result, char **str);
 void *ccs_commit_ok(void *data, const unsigned int size);
 void ccs_check_acl(struct ccs_request_info *r,
 		   bool (*check_entry) (struct ccs_request_info *,
@@ -1503,7 +1504,7 @@
 void ccs_put_number_union(struct ccs_number_union *ptr);
 void ccs_read_log(struct ccs_io_buffer *head);
 void ccs_transition_failed(const char *domainname);
-void ccs_update_stat(const u8 index);
+void ccs_update_stat(const enum ccs_policy_stat_type index);
 void ccs_warn_oom(const char *function);
 void ccs_write_log(struct ccs_request_info *r, const char *fmt, ...)
 	__attribute__ ((format(printf, 2, 3)));
@@ -1524,11 +1525,11 @@
 extern const char * const ccs_path_keyword[CCS_MAX_PATH_OPERATION];
 extern const char * const ccs_proto_keyword[CCS_SOCK_MAX];
 extern const char * const ccs_socket_keyword[CCS_MAX_NETWORK_OPERATION];
-extern const u8 ccs_c2mac[CCS_MAX_CAPABILITY_INDEX];
-extern const u8 ccs_index2category[CCS_MAX_MAC_INDEX];
-extern const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION];
-extern const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION];
-extern const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION];
+extern const enum ccs_mac_index ccs_c2mac[CCS_MAX_CAPABILITY_INDEX];
+extern const enum ccs_mac_category_index ccs_index2category[CCS_MAX_MAC_INDEX];
+extern const enum ccs_mac_index ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION];
+extern const enum ccs_mac_category_index ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION];
+extern const enum ccs_mac_index ccs_pp2mac[CCS_MAX_PATH2_OPERATION];
 extern struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
 extern struct ccs_domain_info ccs_kernel_domain;
 extern struct list_head ccs_domain_list;
@@ -1797,7 +1798,8 @@
  *
  * Returns mode.
  */
-static inline u8 ccs_get_mode(const u8 profile, const u8 index)
+static inline enum ccs_mode_value ccs_get_mode(const u8 profile,
+					       const enum ccs_mac_index index)
 {
 	return ccs_get_config(profile, index) & (CCS_CONFIG_MAX_MODE - 1);
 }
Index: security/ccsecurity/condition.c
===================================================================
--- security/ccsecurity/condition.c	(revision 4923)
+++ security/ccsecurity/condition.c	(working copy)
@@ -411,9 +411,9 @@
  * Returns one of values in "enum ccs_conditions_index" on success,
  * CCS_MAX_CONDITION_KEYWORD otherwise.
  */
-static u8 ccs_condition_type(const char *word)
+static enum ccs_conditions_index ccs_condition_type(const char *word)
 {
-	u8 i;
+	enum ccs_conditions_index i;
 	for (i = 0; i < CCS_MAX_CONDITION_KEYWORD; i++) {
 		if (!strcmp(word, ccs_condition_keyword[i]))
 			break;
@@ -679,7 +679,7 @@
  */
 void ccs_get_attributes(struct ccs_obj_info *obj)
 {
-	u8 i;
+	enum ccs_path_stat_index i;
 	struct dentry *dentry = NULL;
 
 	for (i = 0; i < CCS_MAX_PATH_STAT; i++) {
@@ -772,8 +772,8 @@
 	envp = (const struct ccs_envp *) (argv + argc);
 	for (i = 0; i < condc; i++) {
 		const bool match = condp->equals;
-		const u8 left = condp->left;
-		const u8 right = condp->right;
+		const enum ccs_conditions_index left = condp->left;
+		const enum ccs_conditions_index right = condp->right;
 		bool is_bitop[2] = { false, false };
 		u8 j;
 		condp++;
@@ -800,12 +800,15 @@
 				if (!ccs_scan_exec_realpath(file, ptr, match))
 					goto out;
 				break;
+			default:
+				break;
 			}
 			continue;
 		}
 		/* Check numeric or bit-op expressions. */
 		for (j = 0; j < 2; j++) {
-			const u8 index = j ? right : left;
+			const enum ccs_conditions_index index =
+				j ? right : left;
 			unsigned long value = 0;
 			switch (index) {
 			case CCS_TASK_UID:
@@ -923,7 +926,7 @@
 					obj->validate_done = true;
 				}
 				{
-					u8 stat_index;
+					enum ccs_path_stat_index stat_index;
 					struct ccs_mini_stat *stat;
 					switch (index) {
 					case CCS_PATH1_UID:
@@ -1011,6 +1014,8 @@
 					case CCS_PATH2_PARENT_PERM:
 						value = stat->mode & S_IALLUGO;
 						break;
+					default:
+						break;
 					}
 				}
 				break;
@@ -1031,6 +1036,9 @@
 			case CCS_MODE_OTHERS_WRITE:
 			case CCS_MODE_OTHERS_EXECUTE:
 				is_bitop[j] = true;
+				break;
+			default:
+				break;
 			}
 		}
 		if (left == CCS_NUMBER_UNION) {
@@ -1069,6 +1077,9 @@
 			case CCS_PATH2_PARENT_PERM:
 				if (!(max_v[0] & max_v[1]) == !match)
 					continue;
+				break;
+			default:
+				break;
 			}
 			goto out;
 		} else if (is_bitop[1]) {
@@ -1079,6 +1090,9 @@
 			case CCS_PATH2_PARENT_PERM:
 				if (!(max_v[0] & max_v[1]) == !match)
 					continue;
+				break;
+			default:
+				break;
 			}
 			goto out;
 		}
Index: security/ccsecurity/policy_io.c
===================================================================
--- security/ccsecurity/policy_io.c	(revision 4923)
+++ security/ccsecurity/policy_io.c	(working copy)
@@ -570,7 +570,7 @@
 			struct ccs_profile *profile)
 {
 	u8 i;
-	u8 config;
+	enum ccs_mode_value config;
 	if (!strcmp(name, "CONFIG")) {
 		i = CCS_MAX_MAC_INDEX + CCS_MAX_MAC_CATEGORY_INDEX;
 		config = profile->default_config;
@@ -580,7 +580,8 @@
 		     i++) {
 			int len = 0;
 			if (i < CCS_MAX_MAC_INDEX) {
-				const u8 c = ccs_index2category[i];
+				const enum ccs_mac_category_index c =
+					ccs_index2category[i];
 				const char *category =
 					ccs_category_keywords[c];
 				len = strlen(category);
@@ -693,7 +694,8 @@
  *
  * Caller prints functionality's name.
  */
-static void ccs_print_config(struct ccs_io_buffer *head, const u8 config)
+static void ccs_print_config(struct ccs_io_buffer *head,
+			     const enum ccs_mode_value config)
 {
 	ccs_io_printf(head, "={ mode=%s grant_log=%s reject_log=%s }\n",
 		      ccs_mode[config & 3],
@@ -757,7 +759,7 @@
 		for ( ; head->r.bit < CCS_MAX_MAC_INDEX
 			      + CCS_MAX_MAC_CATEGORY_INDEX; head->r.bit++) {
 			const u8 i = head->r.bit;
-			const u8 config = profile->config[i];
+			const enum ccs_mode_value config = profile->config[i];
 			if (config == CCS_CONFIG_USE_DEFAULT)
 				continue;
 			if (i < CCS_MAX_MAC_INDEX)
@@ -1280,8 +1282,10 @@
 				(typeof(envp)) (argv + cond->argc);
 			u16 skip;
 			for (skip = 0; skip < head->r.cond_index; skip++) {
-				const u8 left = condp->left;
-				const u8 right = condp->right;
+				const enum ccs_conditions_index left
+					= condp->left;
+				const enum ccs_conditions_index right
+					= condp->right;
 				condp++;
 				switch (left) {
 				case CCS_ARGV_ENTRY:
@@ -1293,6 +1297,8 @@
 				case CCS_NUMBER_UNION:
 					numbers_p++;
 					break;
+				default:
+					break;
 				}
 				switch (right) {
 				case CCS_NAME_UNION:
@@ -1301,6 +1307,8 @@
 				case CCS_NUMBER_UNION:
 					numbers_p++;
 					break;
+				default:
+					break;
 				}
 			}
 			while (head->r.cond_index < condc) {
@@ -2464,7 +2472,7 @@
  *
  * Returns nothing.
  */
-void ccs_update_stat(const u8 index)
+void ccs_update_stat(const enum ccs_policy_stat_type index)
 {
 	struct timeval tv;
 	do_gettimeofday(&tv);
@@ -2542,7 +2550,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_open_control(const u8 type, struct file *file)
+int ccs_open_control(const enum ccs_proc_interface_index type,
+		     struct file *file)
 {
 	struct ccs_io_buffer *head = kzalloc(sizeof(*head), CCS_GFP_FLAGS);
 	if (!head)
Index: security/ccsecurity/network.c
===================================================================
--- security/ccsecurity/network.c	(revision 4923)
+++ security/ccsecurity/network.c	(working copy)
@@ -24,7 +24,7 @@
 /* Structure for holding socket address. */
 struct ccs_addr_info {
 	u8 protocol;
-	u8 operation;
+	enum ccs_network_acl_index operation;
 	struct ccs_inet_addr_info inet;
 	struct ccs_unix_addr_info unix0;
 };
@@ -163,11 +163,9 @@
 		 NIP6(*max_ip));
 }
 
-/*
- * Mapping table from "enum ccs_network_acl_index" to "enum ccs_mac_index" for
- * inet domain socket.
- */
-static const u8 ccs_inet2mac[CCS_SOCK_MAX][CCS_MAX_NETWORK_OPERATION] = {
+/* Mapping table from "enum ccs_network_acl_index" for inet domain socket. */
+static const enum ccs_mac_index ccs_inet2mac[CCS_SOCK_MAX]
+[CCS_MAX_NETWORK_OPERATION] = {
 	[SOCK_STREAM] = {
 		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_INET_STREAM_BIND,
 		[CCS_NETWORK_LISTEN]  = CCS_MAC_NETWORK_INET_STREAM_LISTEN,
@@ -186,11 +184,9 @@
 	},
 };
 
-/*
- * Mapping table from "enum ccs_network_acl_index" to "enum ccs_mac_index" for
- * unix domain socket.
- */
-static const u8 ccs_unix2mac[CCS_SOCK_MAX][CCS_MAX_NETWORK_OPERATION] = {
+/* Mapping table from "enum ccs_network_acl_index" for unix domain socket. */
+static const enum ccs_mac_index ccs_unix2mac[CCS_SOCK_MAX]
+[CCS_MAX_NETWORK_OPERATION] = {
 	[SOCK_STREAM] = {
 		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_UNIX_STREAM_BIND,
 		[CCS_NETWORK_LISTEN]  = CCS_MAC_NETWORK_UNIX_STREAM_LISTEN,
@@ -311,7 +307,7 @@
 	u16 min_address[8];
 	u16 max_address[8];
 	int error = -EINVAL;
-	u8 type;
+	enum ccs_network_acl_index type;
 	const char *protocol = ccs_read_token(param);
 	const char *operation = ccs_read_token(param);
 	char *address = ccs_read_token(param);
@@ -375,7 +371,7 @@
 {
 	struct ccs_unix_acl e = { .head.type = CCS_TYPE_UNIX_ACL };
 	int error;
-	u8 type;
+	enum ccs_network_acl_index type;
 	const char *protocol = ccs_read_token(param);
 	const char *operation = ccs_read_token(param);
 	for (e.protocol = 0; e.protocol < CCS_SOCK_MAX; e.protocol++)
@@ -419,7 +415,8 @@
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_audit_net_log(struct ccs_request_info *r, const char *family,
-			     const u8 protocol, const u8 operation,
+			     const u8 protocol,
+			     const enum ccs_network_acl_index operation,
 			     const char *address)
 {
 	return ccs_supervisor(r, "network %s %s %s %s\n", family,
@@ -533,7 +530,8 @@
 	const int idx = ccs_read_lock();
 	struct ccs_request_info r;
 	int error = 0;
-	const u8 type = ccs_inet2mac[address->protocol][address->operation];
+	const enum ccs_mac_index type
+		= ccs_inet2mac[address->protocol][address->operation];
 	if (type && ccs_init_request_info(&r, type) != CCS_CONFIG_DISABLED) {
 		r.param_type = CCS_TYPE_INET_ACL;
 		r.param.inet_network.protocol = address->protocol;
Index: security/ccsecurity/group.c
===================================================================
--- security/ccsecurity/group.c	(revision 4923)
+++ security/ccsecurity/group.c	(working copy)
@@ -69,7 +69,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_group(char *data, const bool is_delete, const u8 type)
+int ccs_write_group(char *data, const bool is_delete,
+		    const enum ccs_group_id type)
 {
 	struct ccs_group *group;
 	struct list_head *member;
