<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<link rel="stylesheet" href="../media/tomoyolinux.css" media="all" type="text/css">
<title>TOMOYO Linux 1.8.x : 導入ガイド : Chapter 12</title>
</head>

<body>

<div id="titlebar">
<a href="../index.html.ja"><img src="../media/tomoyotitle.png" alt="tomoyotitle.png" width="320" height="40" border="0" align="left"></a>
</div>

<div id="navbar" class="tomoyo-documentation">
<ul id="navbarlist">
<li id="tomoyo-home"><a href="../index.html.ja" title="TOMOYO Linux ホーム">ホーム</a></li>
<li id="tomoyo-about"><a href="../about.html.ja" title="TOMOYO Linux の詳細">詳細</a></li>
<li id="tomoyo-download"><a href="../download.html.ja" title="TOMOYO Linux を入手">ダウンロード</a></li>
<li id="tomoyo-changelogs"><a href="../changelogs.html.ja" title="TOMOYO Linux 変更履歴">変更履歴</a></li>
<li id="tomoyo-documentation"><a href="../documentation.html.ja" title="公式ドキュメント">ドキュメント</a></li>
<li id="tomoyo-support"><a href="../support.html.ja" title="サポート情報">サポート</a></li>
<li id="tomoyo-links"><a href="../links.html.ja" title="Links">リンク</a></li>
</ul>
<ul id="switch-language">
<li id="tomoyo-switch-language"><a href="chapter-12.html.en" title="Go to English page">English page</a></li>
</ul>
</div>

<div id="content">

<div id="documentation">

<div class="navheader">
<p><a href="chapter-11.html.ja">&lt;前&gt;</a> <a href="index.html.ja">&lt;目次&gt;</a> <a href="chapter-13.html.ja">&lt;次&gt;</a></p>
</div>

<h2>Chapter 12: ユーザ認証の強化</h2>

<h3><a name="12.1">12.1. 不正なＳＳＨログイン</a></h3>

<p>例えばＳＳＨのブルートフォース攻撃やインターネットに接続されている他のサーバの脆弱性を攻撃することで不正にログインされる場合があります。 TOMOYO Linux を用いてドメインを階層化することにより、追加のユーザ認証を行う防御層を配備することが可能になります。 TOMOYO Linux であれば、好きな回数だけログイン認証を強制することができます。以下のようなスクリプトを考えてみましょう：</p>

<pre>
#! /bin/sh -p
read -r -s -e -p "Password: " password
sleep 2
if [ "$password" = "123456" ]; then
  exec $SHELL
else
  echo "Authentication failed."
fi
</pre>

<p>Call this script "auth1", make it executable and place it in "/usr/bin" or any directory specified in $PATH. This is only an example script, but it does not matter that the password is in plaintext as the attacker can be denied from reading the script. See <a href="#12.3">12.3. Example authentication programs</a> for more examples. Suppose we have the following in exception policy:</p>

<pre>
initialize_domain /usr/sbin/sshd from any
</pre>

<p>Now we can manage the domain "&lt;kernel&gt; /usr/sbin/sshd /bin/bash", but make sure that the <a href="policy-specification/exception-policy-syntax.html.ja#keep_domain">keep_domain</a> directive is not specified for this domain. Use domain policy to restrict this domain and only allow the execution of the "auth1" script, but no other programs:</p>

<pre>
file execute /usr/bin/auth1 exec.realpath="/usr/bin/auth1"
</pre>

<p>Following login through SSH, the user must go through another authentication mechanism. If this is an illegal login from an attacker, then they will not be able to know what the authentication mechanism is. Ths script above can employ as foreign an authentication mechanism as you desire.</p>

<p>The domain created following successful authentication can be given normal privileges, and for example may be given the "keep_domain /bin/bash from /usr/bin/auth1" directive in exception policy:</p>

<img src="media/fig-6-2.png" alt="fig-6-2.png" width="600" height="450"></a>

<h3><a name="12.2">12.2. 管理者権限の分割</a></h3>

<p>Using this tiered approach, it is also possible to split root permissions. The script can be repeated with a different password and saved as "/usr/bin/auth2". The domain created by execution of "auth1" can be given maximum privileges using domain policy, but the domain create by execution of "auth2" can be given limited privileges, such as to administrate only the web server:</p>

<img src="media/fig-6-14-en.png" alt="fig-6-14-en.png" width="600" height="450">

<h3><a name="12.3">12.3. 認証プログラムの例</a></h3>

<p>This example script is the same as above, but stores the password as a hash:</p>

<pre class="command">
echo "password" | sha1sum
</pre>

<pre class="output">
c8fed00eb2e87f1cee8e90ebbe870c190ac3848c  -
</pre>

<pre>
#!/bin/sh -p

hash="c8fed00eb2e87f1cee8e90ebbe870c190ac3848c  -"

read -r -s -e -p "Password: " password
hash_attempt="$(echo "$password" | sha1sum)"
sleep 2
if [ "$hash_attempt" = "$hash" ]; then
  exec $SHELL
else
  echo "Authentication failed"
fi
</pre>

<p>Other example authentication programs are listed below. But these programs exist only as examples of how you might design unique authentication methods. Some of the algorithms are poor and should not be used in a production environment.</p>

<div class="simple-table-wrap">
<table border="1">
<tr><td><code><a name="candy">candy</a></code></td><td><p>This authentication program succeeds if the correct password is typed, but only if the program is launched within 10 seconds of the parent process (e.g. "/bin/bash") being launched. If the program is not launched within this time period, then all password attempts will fail. This is useful in preventing brute force attacks, and the attacker will not know that no attempt can succeed.</p></td></tr>
<tr><td><code><a name="chaplet">chaplet</a></code></td><td><p>This authentication program displays a string of challenge data, and authentication will succeed only if the numerical characters from the challenge data are typed. This is only an example and the algorithm is poor. It should be customized before use in a production environment.</p></td></tr>
<tr><td><code><a name="checktoken_gettoken">checktoken/gettoken</a></code></td><td><p>These authentication programs use tokens based on system time. The <code>gettoken</code> program generates a token to be checked by <code>checktoken</code>. Authentication will succeed if the correct token is generated. This is only an example and the algorithm is poor. It should be customized before use in a production environment.</p></td></tr>
<tr><td><code><a name="groovy">groovy</a></code></td><td><p>This authentication program prompts for a password, but does not check the password. Instead, it checks for the existence of the file "/tmp/.lockme", succeeding only when this file does not exist. This can prevent brute force attacks. This is only an example and uses a file location that is apparent to attackers. It should be customized before use in a production environment.</p></td></tr>
<tr><td><code><a name="honey">honey</a></code></td><td><p>This authentication program fails unless the correct password is typed within the correct time interval. This can prevent brute force attacks.</p></td></tr>
<tr><td><code><a name="mailauth">mailauth</a></code></td><td><p>This authentication program generates a one-time password and sends it to the user using <code>mail</code>. The authentication succeeds if the user inputs this password. To use this program, a mail server is required.</p></td></tr>
<tr><td><code><a name="timeauth">timeauth</a></code></td><td><p>This authentication program is a reimplementation of <code><a href="#honey">honey</a></code> that makes use of an external script.</p></td></tr>
</table>
</div>

<p>Also, below examples can be useful when you use reinforced authentication.</p>

<div class="simple-table-wrap">
<table>
<tr><td><code><a name="falsh">falsh</a></code></td><td><p>This is a very restricted shell with no built-in commands. Since login shell such as /bin/bash provides many built-in commands such as <code>kill</code>, an attacker can do bad things (e.g. killing processes) without executing external programs even if execution of executing external programs are restricted by TOMOYO Linux. To prevent the attacker from using shell's built-in commands, you may want to use this shell as a login shell when using reinforced authentication.</p></td></tr>
<tr><td><code><a name="proxy">proxy</a></code></td><td><p> - This is a simple port forwarder program. This program can be used by the client to bind to a specific local port on the server so that the server-side firewall, such as <code>iptables</code> can use packet filtering based on the port number of the client.</p></td></tr>
</table>
</div>

</div><!-- documentation -->

</div><!-- content -->

<div id="navfooter">
<hr>
<table>
<tr>
<td class="docs-previous">
<a href="chapter-11.html.ja">前</a>
</td>
<td class="docs-index">
<a href="index.html.ja">目次</a>
</td>
<td class="docs-next">
<a href="chapter-13.html.ja">次</a>
</td>
</tr>
<tr>
<td class="docs-previous-description">
<p>Chapter 11: アクセス許可のグループ化</p>
</td>
<td class="docs-home">
</td>
<td class="docs-next-description">
<p>Chapter 13: カーネルの外部でプログラムの実行可否を判断する</p>
</td>
</tr>
</table>
</div>

<div id="footer">
<p class="language">Go to <a href="chapter-12.html.en">English page</a>.</p>
<p class="timestamp">Last modified: $Date$</p>
<p class="trademark">Linux&reg; は世界各国における Linus Torvalds の登録商標です。 TOMOYO&reg; は<a href="http://www.nttdata.co.jp/">株式会社ＮＴＴデータ</a>の登録商標です。</p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</div>

</body>
</html>
