<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linux 導入手順書</title>
<link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<p style="text-align:right;"><a href="enforcing.html.en">English Page</a></p>
<p style="text-align:right;">Last modified: $Date$</p>
<h1>第５章：システムの振る舞いを制限</h1>

<p>このページでは、 TOMOYO Linux の強制モードの使い方と、強制モードで動作中に発生したポリシー違反を処理する方法について説明します。</p>

<hr>

<h2><a name="using_enforcing_mode">ステップ１：強制モードを有効にする</a></h2>

<p>ドメインポリシーと例外ポリシーの調整が完了したら、ドメインに対して強制モードを割り当てることができます。</p>

<p>ポリシーエディタを実行してください。対象となるドメインを選択し、 s キーを押して 3 と入力してから Enter キーを押します。</p>

<p><img src="editpolicy-httpd-set-profile3.png" width="720" height="400"></p>

<p>選択されたドメインのプロファイル番号が 3 に変化しました。</p>

<p><img src="editpolicy-httpd-profile3.png" width="720" height="400"></p>

<p>@ キーを押してプロセス一覧表示に切り替えてください。そして、 /usr/sbin/httpd プロセスとその子孫に対してプロファイル 3 が割り当てられていることを確認してください。</p>

<p><img src="editpolicy-httpd-process3.png" width="720" height="400"></p>

<p>プロファイル 3 は強制モードを行うよう指定されているため、これにより /usr/sbin/httpd プロセスおよびその子孫は強制アクセス制御により保護された状態になりました。</p>

<p><img src="editpolicy-profile-list-enforcing.png" width="720" height="400"></p>

<p>q キーを押してポリシーエディタを終了してください。</p>

<p>ポリシーで許可されている操作をしてみましょう。</p>

<p><img src="operation-permitted.png" width="684" height="912"></p>

<p>メールの送信はポリシーで許可されているので、操作は正常に終了しました。</p>

<p>ポリシーで許可されていない操作をしてみましょう。</p>

<p><img src="unix-penguin.png" width="684" height="912"></p>

<p>操作は拒否されました。（一見すると正常に終了したように見えますが、実際には /bin/mail が「入力が空っぽです」と警告しているとおり、 /bin/cat の実行が拒否されています。）</p>

<p><img src="unix-penguin-rejected.png" width="684" height="597"></p>

<p>/proc/ccs/stat からポリシー違反の発生回数と最後に発生した時刻について知ることができます。</p>

<pre>
[root@tomoyo ~]# cat /proc/ccs/stat
Policy update:                              1571 (Last: 2010/12/25 16:10:48)
Policy violation in learning mode:           453 (Last: 2010/12/25 15:33:21)
Policy violation in permissive mode:          22 (Last: 2010/12/25 15:47:10)
Policy violation in enforcing mode:            2 (Last: 2010/12/25 16:08:35)
Memory used by policy:                    165728
Memory used by audit log:                      0 (Quota:   16777216)
Memory used by query message:                  0 (Quota:    1048576)
Total memory used:                        165728
</pre>

<p>もしアクセスログの設定を<a href="initialize.html.ja#configure_audit_daemon">第２章：設定の初期化</a>で行っていた場合は、拒否されたアクセス要求を /var/log/tomoyo/reject_003.log から抽出することができます。</p>

<table border="1">
<tr><td>
[root@tomoyo ~]# cat /var/log/tomoyo/reject_003.log<br>
#2010/12/25 16:08:35# profile=3 mode=enforcing granted=no (global-pid=3628) task={ pid=3628 ppid=3627 uid=48 gid=48 euid=48 egid=48 suid=48 sgid=48 fsuid=48 fsgid=48 type!=execute_handler } path1={ uid=0 gid=0 ino=688153 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=688129 perm=0755 } exec={ realpath="/bin/cat" argc=2 envc=7 argv[]={ "cat" "/etc/passwd" } envp[]={ "TERM=vt100" "PATH=/sbin:/usr/sbin:/bin:/usr/bin" "_=/bin/cat" "PWD=/usr/share/horde/admin" "LANG=en_US.UTF-8" "SHLVL=3" "LANGUAGE=en_US.UTF-8" } }<br>
&lt;kernel&gt; /usr/sbin/httpd /bin/sh<br>
file execute /bin/cat<br>
<br>
#2010/12/25 16:08:35# profile=3 mode=enforcing granted=no (global-pid=3628) task={ pid=3628 ppid=3627 uid=48 gid=48 euid=48 egid=48 suid=48 sgid=48 fsuid=48 fsgid=48 type!=execute_handler } path1={ uid=0 gid=0 ino=688153 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=688129 perm=0755 }<br>
&lt;kernel&gt; /usr/sbin/httpd /bin/sh<br>
file read /bin/cat
</td></tr>
</table>

<p>最初のログは、 /usr/sbin/httpd から起動された /bin/sh から /bin/cat の実行が要求され、そのときの引数は cat /etc/passwd であったことを示しています。このログの１行目に mode=enforcing および granted=no という内容が含まれているため、この要求は拒否されたことが判ります。</p>

<p>２番目のログは、 /usr/sbin/httpd から起動された /bin/sh が /bin/cat を読み込みモードでオープンしようとして拒否されたことを示しています。これは、要求されたプログラムを実行できなかった場合そのプログラムの内容を確認するために読み込みモードでオープンしようとするという習性が /bin/sh にあるためです。</p>

<p>ポリシー違反の発生を通知するために /usr/sbin/ccs-notifyd というデーモンプログラムが提供されています。 /etc/rc.local 等から起動するようにしてください。</p>

<p>通知方法は /etc/ccs/tools/notifyd.conf に記録されています。以下に初期設定を示します。</p>

<pre>
# This file contains configuration used by ccs-notifyd command.

# ccs-notifyd is a daemon that notifies the occurrence of policy violation
# in enforcing mode.
#
# time_to_wait is grace time in second before rejecting the request that
# caused policy violation in enforcing mode. For example, if you specify
# 30, you will be given 30 seconds for starting ccs-queryd command and
# responding to the policy violation event.
# If you specify non 0 value, you need to register ccs-notifyd command to
# /proc/ccs/manager as well as ccs-queryd command, for ccs-notifyd needs to
# behave as if ccs-queryd command is running.
# Also, you should avoid specifying too large value (e.g. 3600) because
# the request will remain pending for that period if you can't respond.
#
# action_to_take is a command line you want to use for notification.
# The command specified by this parameter must read the policy violation
# notifycation from standard input. For example, mail, curl and xmessage
# commands can read from standard input.
# This parameter is passed to execve(). Thus, please use a wrapper program
# if you need shell processing (e.g. wildcard expansion, environment
# variables).
#
# minimal_interval is grace time in second before re-notifying the next
# occurrence of policy violation. You can specify 60 to limit notifycation
# to once per a minute, 3600 to limit notifycation to once per an hour.
# You can specify 0 to unlimit, but notifying of every policy violation
# events (e.g. sending a mail) might annoy you because policy violation
# can occur in clusters if once occurred.

# Please use TOMOYO Linux's escape rule (e.g. '\040' rather than '\ ' for
# representing a ' ' in a word).

# Examples:
#
# time_to_wait 180
# action_to_take mail admin@example.com
#
#    Wait for 180 seconds before rejecting the request.
#    The occurrence is notified by sending mail to admin@example.com
#    (if SMTP service is available).
#
# time_to_wait 0
# action_to_take curl --data-binary @- https://your.server/path_to_cgi
#
#    Reject the request immediately.
#    The occurrence is notified by executing curl command.
#
time_to_wait 0
action_to_take mail -s Notification\040from\040ccs-notifyd root@localhost
minimal_interval 60
</pre>

<p>action_to_take 行を変更して /usr/sbin/ccs-notifyd を実行してください。</p>

<p>ポリシー違反が発生すると以下のようなメールが届くはずです。このメールの内容は、ヘッダにシリアルナンバーが付与されている点を除いてアクセスログと同一内容です。</p>

<table border="1">
<tr><td>
[root@tomoyo ~]# mail<br>
Mail version 8.1 6/6/93.  Type ? for help.<br>
"/var/spool/mail/root": 1 messages 1 new<br>
&gt;N  1 root@localhost.local  Sun Dec 26 01:08  18/1211 "Notification from ccs-notifyd"<br>
&amp;<br>
Message 1:<br>
From root@localhost.localdomain  Sun Dec 26 01:08:35 2010<br>
Date: Sun, 26 Dec 2010 01:08:35 +0900<br>
From: root &lt;root@localhost.localdomain&gt;<br>
To: root@localhost.localdomain<br>
Subject: Notification from ccs-notifyd<br>
<br>
Q0-0<br>
#2010/12/25 16:08:35# profile=3 mode=enforcing granted=no (global-pid=3628) task={ pid=3628 ppid=3627 uid=48 gid=48 euid=48 egid=48 suid=48 sgid=48 fsuid=48 fsgid=48 type!=execute_handler } path1={ uid=0 gid=0 ino=688153 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=688129 perm=0755 } exec={ realpath="/bin/cat" argc=2 envc=7 argv[]={ "cat" "/etc/passwd" } envp[]={ "TERM=vt100" "PATH=/sbin:/usr/sbin:/bin:/usr/bin" "_=/bin/cat" "PWD=/usr/share/horde/admin" "LANG=en_US.UTF-8" "SHLVL=3" "LANGUAGE=en_US.UTF-8" } }<br>
&lt;kernel&gt; /usr/sbin/httpd /bin/sh<br>
file execute /bin/cat
</td></tr>
</table>

<p>プロファイルで PREFERENCE={ enforcing_penalty=1 } と設定することで、強制モードでポリシー違反が発生した場合に、ポリシー違反の原因となったプロセスを 0.1 秒間スリープ状態にさせることができます。無限ループの中でポリシー違反が発生した場合に、ＣＰＵ使用率が 100% になってしまうのを回避するのに役にたちます。ハイジャックされた Samba サーバプロセスがポリシーで許可されていない要求を繰り返すことによりＣＰＵを浪費している状況について以下のムービーで紹介しています。</p>

<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/I8fF5mueWTw&amp;hl=en_US&amp;fs=1"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/I8fF5mueWTw&amp;hl=en_US&amp;fs=1" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="425" height="344"></embed></object></p>

<hr>

<h2><a name="using_interactive_mode">ステップ２：ソフトウェアのアップデート時に発生するポリシー違反を処理する</a></h2>

<p>パッケージのアップデートに伴いポリシーの更新が必要になる場合があります。</p>

<ul>
<li>ファイルのパス名が変化した場合
<li>ファイルの依存関係が変化した場合 
<li>必要なアクセス許可が増えた場合 
</ul>

<p>学習モードを使ってポリシーを最初から再取得するのが理想です。しかし、現実には、一度強制モードでの運用を開始したシステムを強制モード以外に変更することは困難です。ドメイン単位で強制モードにするかどうかを指定できますが、強制モードではないドメインに属しているアプリケーションの制御を奪われたら意味がありません。例えば、 http サーバのアクセス許可を再取得するために http サーバだけを学習モードにするだけでも、システム全体が無防備になってしまうわけです。そのため、 TOMOYO Linux では、強制モードのまま、パッケージのアップデートとポリシーの修正を行います。</p>

<p>TOMOYO Linux には、強制モードのままポリシーの修正を行うためのツールが付属しています。これらのツールを使うことで、軽微な変更ならば、ポリシーを最初から再取得することなくシステムの運用を継続できます。ただし、これらのツールは、全てのケースに対応できるとは限らず、最適なポリシーであることを保証するものではありません。</p>

<h3>操作例</h3>

<p>実際の操作手順について以下のムービーで紹介しています。</p>

<p><object width="425" height="344"><param name="movie" value="http://www.youtube.com/v/b9q1Jo25LPA&amp;hl=en_US&amp;fs=1"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://www.youtube.com/v/b9q1Jo25LPA&amp;hl=en_US&amp;fs=1" type="application/x-shockwave-flash" allowscriptaccess="always" allowfullscreen="true" width="425" height="344"></embed></object></p>

<p>ポリシーに違反したアクセス要求を処理するために /usr/sbin/ccs-queryd コマンドを利用します。</p>

<table border="1">
<tr><td>
[root@tomoyo ~]# /usr/sbin/ccs-queryd<br>
Monitoring /proc/ccs/query . Press Ctrl-C to terminate.<br>
</td></tr>
</table>

<p>デーモンの再起動などのように普段行われない動作によりポリシー違反が発生するかもしれません。ポリシー違反が発生した場合、 ccs-queryd にプロンプトが表示されます。</p>

<table border="1">
<tr><td>
#2010-01-10 12:29:35# profile=3 mode=enforcing (global-pid=4561) task={ pid=4561 ppid=4557 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 type!=execute_handler } path1={ uid=0 gid=0 ino=1507379 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=1507329 perm=0755 } exec={ realpath="/bin/sleep" argc=2 envc=6 argv[]={ "sleep" "1" } envp[]={ "TERM=xterm" "PATH=/sbin:/usr/sbin:/bin:/usr/bin" "PWD=/" "LANG=en_US.UTF-8" "SHLVL=1" "_=/bin/sleep" } }<br>
&lt;kernel&gt; /etc/rc.d/init.d/cups<br>
file execute /bin/sleep<br>
Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):
</td></tr>
</table>

<p>上記の例は、 &lt;kernel&gt; /etc/rc.d/init.d/cups というドメインに属しているプロセスが sleep 1 というコマンドラインを処理するために /bin/sleep の実行を要求したが、ポリシーによって拒否されたことを示しています。通常であればポリシーに違反したアクセス要求は直ちに拒否されますが、 ccs-queryd が動作しているため、カーネルはあなたの判断を仰いでいることを示しています。</p>

<p>Y を押すと許可します。<br>
N を押すと拒否します。<br>
R を押すと再試行します。（手作業でドメインポリシーを変更した後などに利用します。）
S を押すとそのプロセスのドメインポリシーが表示します。<br>
A を押すと編集した上でドメイン用ポリシーに追加後、再試行します。（先にドメインポリシーを編集することができます。）</p>

<p>無条件にアクセス要求を許可しないようにしてください。ポリシー違反の原因がパッケージのアップデートによるものとは限らず、侵入者の攻撃によるものである可能性があるからです。もし、侵入者の攻撃によって発生したアクセス要求に対してアクセスを許可してしまった場合、侵入されてしまいます。</p>

<p>ccs-queryd が動作している場合、ポリシーによって拒否されたアクセス要求は、あなたが応答するまで保留状態となります。そのため、 ccs-queryd を動作させたままログアウトしないでください。</p>

<p>プログラムが必要とするアクセス許可が与えられるようにするために、 ccs-queryd の監視を忘れないようにしてください。もし、アクセス許可の不足が検出された場合には ccs-queryd に表示されます。</p>

<p>なお、 ccs-queryd はメモリ上のポリシーを直接編集します。シャットダウンすると失われてしまいますので、忘れずに ccs-savepolicy を実行してポリシーを保存してください。</p>

<table border="1">
<tr><td>
[root@tomoyo ~]# /usr/sbin/ccs-savepolicy
</td></tr>
</table>

<p>Once policy has been updated, "ccs-queryd" can be stopped with 'Ctrl-C'.</p>

<h3>ccs-queryd の操作例</h3>

<table border="1">
<tr><td>
#2010-01-10 12:27:10# profile=3 mode=enforcing (global-pid=4210) task={ pid=4210 ppid=4205 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 type!=execute_handler } path1={ uid=0 gid=0 ino=1766 major=0 minor=17 perm=0666 type=char dev_major=1 dev_minor=3 } path1.parent={ uid=0 gid=0 ino=962 perm=0755 }<br>
&lt;kernel&gt; /etc/rc.d/init.d/sshd<br>
file ioctl /dev/null 0x5401<br>
Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):s<br>
# select global-pid=4210<br>
&lt;kernel&gt; /etc/rc.d/init.d/sshd<br>
use_profile 3<br>
<br>
file read /bin/bash<br>
file read /dev/tty<br>
file write /dev/tty<br>
file read /dev/pts/\$<br>
file write /dev/pts/\$<br>
file read /usr/lib/locale/locale-archive<br>
file read /etc/nsswitch.conf<br>
file read /etc/passwd<br>
file read /etc/rc.d/init.d/sshd<br>
file read /etc/rc.d/init.d/functions<br>
file execute /sbin/consoletype exec.realpath="/sbin/consoletype" exec.argv[0]="/sbin/consoletype"<br>
file read /etc/profile.d/lang.sh<br>
file read /etc/sysconfig/i18n<br>
file read /etc/sysconfig/init<br>
file execute /sbin/runlevel exec.realpath="/sbin/runlevel" exec.argv[0]="runlevel"<br>
file execute /bin/cp exec.realpath="/bin/cp" exec.argv[0]="cp"<br>
file execute /usr/sbin/sshd exec.realpath="/usr/sbin/sshd" exec.argv[0]="/usr/sbin/sshd"<br>
file execute /bin/touch exec.realpath="/bin/touch" exec.argv[0]="touch"<br>
file read /dev/console<br>
file write /dev/console<br>
file execute /bin/unicode_start exec.realpath="/bin/unicode_start" exec.argv[0]="/bin/unicode_start"<br>
file read /var/run/sshd.pid<br>
file write /dev/null<br>
ipc signal 15 &lt;kernel&gt; /usr/sbin/sshd<br>
file execute /bin/usleep exec.realpath="/bin/usleep" exec.argv[0]="usleep"<br>
file execute /bin/rm exec.realpath="/bin/rm" exec.argv[0]="rm"<br>
file execute /usr/bin/killall exec.realpath="/usr/bin/killall" exec.argv[0]="killall"<br>
file execute /usr/bin/rhgb-client exec.realpath="/usr/bin/rhgb-client" exec.argv[0]="/usr/bin/rhgb-client"<br>
file execute /bin/sleep exec.realpath="/bin/sleep" exec.argv[0]="sleep"<br>
ipc signal 1 &lt;kernel&gt; /usr/sbin/sshd<br>
file ioctl /dev/console 0x5401<br>
file ioctl /etc/rc.d/init.d/sshd 0x5401<br>
file ioctl /var/run/sshd.pid 0x5401<br>
file ioctl /dev/pts/\$ 0x5401<br>
<br>
<br>
#2010-01-10 12:27:20# profile=3 mode=enforcing (global-pid=4210) task={ pid=4210 ppid=4205 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 type!=execute_handler } path1={ uid=0 gid=0 ino=1766 major=0 minor=17 perm=0666 type=char dev_major=1 dev_minor=3 } path1.parent={ uid=0 gid=0 ino=962 perm=0755 }<br>
&lt;kernel&gt; /etc/rc.d/init.d/sshd<br>
file ioctl /dev/null 0x5401<br>
Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):a<br>
Enter new entry&gt; file ioctl /dev/null 0x5401<br>
Added 'file ioctl /dev/null 0x5401'.<br>
<br>
----------------------------------------<br>
#2010-01-10 12:29:35# profile=3 mode=enforcing (global-pid=4561) task={ pid=4561 ppid=4557 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 type!=execute_handler } path1={ uid=0 gid=0 ino=1507379 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=1507329 perm=0755 } exec={ realpath="/bin/sleep" argc=2 envc=6 argv[]={ "sleep" "1" } envp[]={ "TERM=xterm" "PATH=/sbin:/usr/sbin:/bin:/usr/bin" "PWD=/" "LANG=en_US.UTF-8" "SHLVL=1" "_=/bin/sleep" } }<br>
&lt;kernel&gt; /etc/rc.d/init.d/cups<br>
file execute /bin/sleep<br>
Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):a<br>
Enter new entry&gt; file execute /bin/sleep exec.argc=2 exec.argv[1]="1"<br>
Added 'file execute /bin/sleep exec.argc=2 exec.argv[1]="1"'.<br>
<br>
#2010-01-10 12:29:58# profile=3 mode=enforcing (global-pid=4561) task={ pid=4561 ppid=4557 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 type!=execute_handler } path1={ uid=0 gid=0 ino=707247 major=8 minor=1 perm=0644 type=file } path1.parent={ uid=0 gid=0 ino=688142 perm=0755 }<br>
&lt;kernel&gt; /etc/rc.d/init.d/cups /bin/sleep<br>
file read /usr/lib/locale/locale-archive<br>
Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):a<br>
Enter new entry&gt; file read /usr/lib/locale/locale-archive<br>
Added 'file read /usr/lib/locale/locale-archive'.<br>
<br>
----------------------------------------<br>
#2010-01-10 12:30:10# profile=3 mode=enforcing (global-pid=4630) task={ pid=4630 ppid=4629 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 type!=execute_handler } path1={ uid=0 gid=0 ino=955698 major=8 minor=1 perm=0666 type=socket } path1.parent={ uid=0 gid=0 ino=950312 perm=0755 }<br>
&lt;kernel&gt; /usr/sbin/acpid<br>
file unlink /var/run/acpid.socket<br>
Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):a<br>
Enter new entry&gt; file unlink /var/run/acpid.socket path1.type=socket<br>
Added 'file unlink /var/run/acpid.socket path1.type=socket'.
</td></tr>
</table>

<hr>

<p><a href="index.html.ja">目次へ戻る</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</body>
</html>
