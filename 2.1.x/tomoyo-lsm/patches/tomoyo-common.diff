Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>

---
 security/tomoyo/common.c | 1881 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 1881 insertions(+)

Index: linux-2.6/security/tomoyo/common.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6/security/tomoyo/common.c	2007-08-11 12:19:38.000000000 +0900
@@ -0,0 +1,1966 @@
+/*
+ * security/tomoyo/common.c
+ *
+ * Common functions for TOMOYO Linux.
+ */
+
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/utime.h>
+#include <linux/file.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <stdarg.h>
+#include <linux/namei.h>
+#include <linux/mount.h>
+#include <linux/proc_fs.h>
+#include "realpath.h"
+#include "tomoyo.h"
+
+#ifdef CONFIG_TOMOYO_MAX_ACCEPT_ENTRY
+#define MAX_ACCEPT_ENTRY CONFIG_TOMOYO_MAX_ACCEPT_ENTRY
+#else
+#define MAX_ACCEPT_ENTRY 2048
+#endif
+
+static int tmy_read_control(struct file *file,
+			    char __user *buffer,
+			    const int buffer_len);
+
+/*************************  VARIABLES  *************************/
+
+/* /sbin/init started? */
+int sbin_init_started;
+
+static struct {
+	const char *keyword;
+	unsigned int current_value;
+	const unsigned int max_value;
+} tmy_control[TMY_MAX_CONTROL_INDEX] = {
+	[TMY_COMMENT]             = { "COMMENT",             0, 0 },
+	[TMY_MAC_FOR_FILE]        = { "MAC_FOR_FILE",        0, 3 },
+	[TMY_MAC_FOR_ARGV0]       = { "MAC_FOR_ARGV0",       0, 3 },
+	[TMY_MAC_FOR_NETWORK]     = { "MAC_FOR_NETWORK",     0, 3 },
+	[TMY_MAC_FOR_SIGNAL]      = { "MAC_FOR_SIGNAL",      0, 3 },
+	[TMY_RESTRICT_MOUNT]      = { "RESTRICT_MOUNT",      0, 3 },
+	[TMY_RESTRICT_UMOUNT]     = { "RESTRICT_UNMOUNT",    0, 3 },
+	[TMY_DENY_CONCEAL_MOUNT]  = { "DENY_CONCEAL_MOUNT",  0, 3 },
+	[TMY_RESTRICT_PIVOT_ROOT] = { "RESTRICT_PIVOT_ROOT", 0, 3 },
+	[TMY_MAX_ACCEPT_ENTRY]    =
+	{ "MAX_ACCEPT_ENTRY", MAX_ACCEPT_ENTRY, INT_MAX },
+	[TMY_AUDIT_GRANT]         = { "TOMOYO_AUDIT_GRANT",  0, 1 },
+	[TMY_AUDIT_REJECT]        = { "TOMOYO_AUDIT_REJECT", 1, 1 },
+	[TMY_ALLOW_ENFORCE_GRACE] = { "ALLOW_ENFORCE_GRACE", 0, 1 },
+};
+
+struct profile {
+	unsigned int value[TMY_MAX_CONTROL_INDEX];
+	const struct path_info *comment;
+};
+
+static struct profile *profile_ptr[TMY_MAX_PROFILES];
+
+/*************************  UTILITY FUNCTIONS  *************************/
+
+/* Am I root? */
+static int tmy_is_root(void)
+{
+	return !current->uid && !current->euid;
+}
+
+/*
+ * Format string.
+ * Leading and trailing whitespaces are removed.
+ * Multiple whitespaces are packed into single space.
+ */
+static void tmy_normalize_line(unsigned char *buffer)
+{
+	unsigned char *sp = buffer;
+	unsigned char *dp = buffer;
+	int first = 1;
+	while (*sp && (*sp <= ' ' || *sp >= 127))
+		sp++;
+	while (*sp) {
+		if (!first)
+			*dp++ = ' ';
+		first = 0;
+		while (*sp > ' ' && *sp < 127)
+			*dp++ = *sp++;
+		while (*sp && (*sp <= ' ' || *sp >= 127))
+			sp++;
+	}
+	*dp = '\0';
+}
+
+static unsigned char tmy_str2chr(const unsigned char c,
+				 const unsigned char d,
+				 const unsigned char e) {
+	return (((unsigned char) (c - '0')) << 6) +
+		(((unsigned char) (d - '0')) << 3) +
+		(((unsigned char) (e - '0')));
+}
+
+/*
+ *  Check whether the given filename follows the naming rules.
+ *  Returns nonzero if follows, zero otherwise.
+ */
+int tmy_correct_path(const char *filename,
+		     const int start_type,
+		     const int pattern_type,
+		     const int end_type,
+		     const char *function)
+{
+	int contains_pattern = 0;
+	char c;
+	char d;
+	char e;
+	const char *original_filename = filename;
+	if (!filename)
+		goto out;
+	c = *filename;
+	if (start_type == 1) { /* Must start with '/' */
+		if (c != '/')
+			goto out;
+	} else if (start_type == -1) { /* Must not start with '/' */
+		if (c == '/')
+			goto out;
+	}
+	if (c)
+		c = * (strchr(filename, '\0') - 1);
+	if (end_type == 1) { /* Must end with '/' */
+		if (c != '/')
+			goto out;
+	} else if (end_type == -1) { /* Must not end with '/' */
+		if (c == '/')
+			goto out;
+	}
+	while ((c = *filename++) != '\0') {
+		if (c == '\\') {
+			switch ((c = *filename++)) {
+			case '\\':  /* "\\" */
+				continue;
+			case '$':   /* "\$" */
+			case '+':   /* "\+" */
+			case '?':   /* "\?" */
+			case '*':   /* "\*" */
+			case '@':   /* "\@" */
+			case 'x':   /* "\x" */
+			case 'X':   /* "\X" */
+			case 'a':   /* "\a" */
+			case 'A':   /* "\A" */
+			case '-':   /* "\-" */
+				if (pattern_type == -1)
+					break; /* Must not contain pattern */
+				contains_pattern = 1;
+				continue;
+			case '0':   /* "\ooo" */
+			case '1':
+			case '2':
+			case '3':
+				d = *filename++;
+				e = *filename++;
+				if (d >= '0' &&
+				    d <= '7' &&
+				    e >= '0' &&
+				    e <= '7') {
+					const unsigned char f =
+						tmy_str2chr(c, d, e);
+					if (f && (f <= ' ' || f >= 127))
+						/* pattern is not \000 */
+						continue;
+				}
+			}
+			goto out;
+		} else if (c <= ' ' || c >= 127)
+			goto out;
+	}
+	if (pattern_type == 1) { /* Must contain pattern */
+		if (!contains_pattern)
+			goto out;
+	}
+	return 1;
+out:
+	printk(KERN_DEBUG "%s: Invalid pathname '%s'\n",
+	       function, original_filename);
+	return 0;
+}
+
+/*
+ *  Check whether the given domainname follows the naming rules.
+ *  Returns nonzero if follows, zero otherwise.
+ */
+int tmy_is_correct_domain(const unsigned char *domainname,
+			  const char *function)
+{
+	unsigned char c;
+	unsigned char d;
+	unsigned char e;
+	const char *org_domainname = domainname;
+	if (!domainname ||
+	    strncmp(domainname, TMY_ROOT_NAME, TMY_ROOT_NAME_LEN))
+		goto out;
+	domainname += TMY_ROOT_NAME_LEN;
+	if (!*domainname)
+		return 1;
+	do {
+		if (*domainname++ != ' ')
+			goto out;
+		if (*domainname++ != '/')
+			goto out;
+		while ((c = *domainname) != '\0' && c != ' ') {
+			domainname++;
+			if (c == '\\') {
+				switch ((c = *domainname++)) {
+				case '\\':  /* "\\" */
+					continue;
+				case '0':   /* "\ooo" */
+				case '1':
+				case '2':
+				case '3':
+					d = *domainname++;
+					e = *domainname++;
+					if (d >= '0' &&
+					    d <= '7' &&
+					    e >= '0' &&
+					    e <= '7') {
+						const unsigned char f =
+							tmy_str2chr(c, d, e);
+						if (f && (f <= ' ' || f >= 127))
+							continue;
+					}
+				}
+				goto out;
+			} else if (c < ' ' || c >= 127)
+				goto out;
+		}
+	} while (*domainname);
+	return 1;
+out:
+	printk(KERN_DEBUG "%s: Invalid domainname '%s'\n",
+	       function, org_domainname);
+	return 0;
+}
+
+static int tmy_path_depth(const char *pathname)
+{
+	int i = 0;
+	if (pathname) {
+		char *ep = strchr(pathname, '\0');
+		if (pathname < ep--) {
+			if (*ep != '/')
+				i++;
+			while (pathname <= ep)
+				if (*ep-- == '/')
+					i += 2;
+		}
+	}
+	return i;
+}
+
+static int tmy_const_part_length(const char *filename)
+{
+	int len = 0;
+	if (filename) {
+		char c;
+		char d;
+		while ((c = *filename++) != '\0') {
+			if (c != '\\') {
+				len++;
+				continue;
+			}
+			switch (c = *filename++) {
+			case '\\':  /* "\\" */
+				len += 2;
+				continue;
+			case '0':   /* "\ooo" */
+			case '1':
+			case '2':
+			case '3':
+				c = *filename++;
+				d = *filename++;
+				if (c >= '0' &&
+				    c <= '7' &&
+				    d >= '0' &&
+				    d <= '7') {
+					len += 4;
+					continue;
+				}
+			}
+			break;
+		}
+	}
+	return len;
+}
+
+void tmy_fill_path_info(struct path_info *ptr)
+{
+	const char *name = ptr->name;
+	const int len = strlen(name);
+	ptr->total_len = len;
+	ptr->const_len = tmy_const_part_length(name);
+	ptr->is_dir = len && (name[len - 1] == '/');
+	ptr->is_patterned = (ptr->const_len < len);
+	ptr->hash = full_name_hash(name, len);
+	ptr->depth = tmy_path_depth(name);
+}
+
+static int tmy_file_match2(const char *filename,
+			   const char *filename_end,
+			   const char *pattern,
+			   const char *pattern_end)
+{
+	while (filename < filename_end && pattern < pattern_end) {
+		char c;
+		int i;
+		int j;
+		if (*pattern != '\\') {
+			if (*filename++ != *pattern++)
+				return 0;
+			continue;
+		}
+		c = *filename;
+		pattern++;
+		switch (*pattern) {
+		case '?':
+			if (c == '/')
+				return 0;
+			if (c == '\\') {
+				char c2 = filename[2];
+				char c3 = filename[3];
+				c = filename[1];
+				if (c == '\\')
+					/* safe because filename is \\ */
+					filename++;
+				else if (c >= '0' &&
+					   c <= '3' &&
+					   c2 >= '0' &&
+					   c <= '7' &&
+					 c3 >= '0' &&
+					 c <= '7')
+					/* safe because filename is \ooo */
+					filename += 3;
+				else
+					return 0;
+			}
+			break;
+		case '\\':
+			if (c != '\\')
+				return 0;
+			if (*++filename != '\\')
+				return 0; /* safe because *filename != '\0' */
+			break;
+		case '+':
+			if (c < '0' || c > '9')
+				return 0;
+			break;
+		case 'x':
+			if (!((c >= '0' && c <= '9') ||
+			      (c >= 'A' && c <= 'F') ||
+			      (c >= 'a' && c <= 'f')))
+				return 0;
+			break;
+		case 'a':
+			if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')))
+				return 0;
+			break;
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+			if (c == '\\' &&
+			    (c = filename[1]) >= '0' &&
+			    c <= '3' &&
+			    c == *pattern &&
+			    (c = filename[2]) >= '0' &&
+			    c <= '7' &&
+			    c == pattern[1] &&
+			    (c = filename[3]) >= '0' &&
+			    c <= '7' &&
+			    c == pattern[2]) {
+				filename += 3;
+				pattern += 2;
+				break;
+			}
+			return 0; /* Not matched. */
+		case '*':
+		case '@':
+			for (i = 0; i <= filename_end - filename; i++) {
+				if (tmy_file_match2(filename + i,
+						    filename_end,
+						    pattern + 1,
+						    pattern_end))
+					return 1;
+				c = filename[i];
+				if (c == '.' && *pattern == '@')
+					break;
+				if (c == '\\') {
+					c = filename[i + 1];
+					if (c == '\\')
+						i++;
+					else if (c >= '0' &&
+						 c <= '3' &&
+						 (c = filename[i + 2]) >= '0' &&
+						 c <= '7' &&
+						 (c = filename[i + 3]) >= '0' &&
+						 c <= '7')
+						i += 3;
+					else
+						break; /* Bad pattern. */
+				}
+			}
+			return 0; /* Not matched. */
+		default:
+			j = 0;
+			c = *pattern;
+			if (c == '$')
+				while ((c = filename[j]) >= '0' && c <= '9')
+					j++;
+			else if (c == 'X')
+				while (((c = filename[j]) >= '0' && c <= '9')
+				       || (c >= 'A' && c <= 'F')
+				       || (c >= 'a' && c <= 'f'))
+					j++;
+			else if (c == 'A')
+				while (((c = filename[j]) >= 'A' && c <= 'Z')
+				       || (c >= 'a' && c <= 'z'))
+					j++;
+			for (i = 1; i <= j; i++)
+				if (tmy_file_match2(filename + i,
+						    filename_end,
+						    pattern + 1,
+						    pattern_end))
+					return 1;
+			return 0; /* Not matched or bad pattern. */
+		}
+		filename++; /* safe because *filename != '\0' */
+		pattern++; /* safe because *pattern != '\0' */
+	}
+	while (*pattern == '\\' &&
+	       (*(pattern + 1) == '*' ||
+		*(pattern + 1) == '@'))
+		pattern += 2;
+	return (filename == filename_end && pattern == pattern_end);
+}
+
+static int tmy_file_match(const char *filename,
+			  const char *filename_end,
+			  const char *pattern,
+			  const char *pattern_end)
+{
+	const char *pattern_start = pattern;
+	int first = 1;
+	int result;
+	while (pattern < pattern_end - 1) {
+		if (*pattern++ != '\\' || *pattern++ != '-')
+			continue;
+		result = tmy_file_match2(filename,
+					 filename_end,
+					 pattern_start,
+					 pattern - 2);
+		if (first)
+			result = !result;
+		if (result)
+			return 0;
+		first = 0;
+		pattern_start = pattern;
+	}
+	result = tmy_file_match2(filename,
+				 filename_end, pattern_start, pattern_end);
+	return first ? result : !result;
+}
+
+/*
+ *  Check whether the given pathname matches to the given pattern.
+ *  Returns nonzero if matches, zero otherwise.
+ *
+ *  The following patterns are available.
+ *    \\     \ itself.
+ *    \ooo   Octal representation of a byte.
+ *    \*     More than or equals to 0 character other than '/'.
+ *    \@     More than or equals to 0 character other than '/' or '.'.
+ *    \?     1 byte character other than '/'.
+ *    \$     More than or equals to 1 decimal digit.
+ *    \+     1 decimal digit.
+ *    \X     More than or equals to 1 hexadecimal digit.
+ *    \x     1 hexadecimal digit.
+ *    \A     More than or equals to 1 alphabet character.
+ *    \a     1 alphabet character.
+ *    \-     Subtraction operator.
+ */
+
+int tmy_path_match(const struct path_info *pathname0,
+		   const struct path_info *pattern0)
+{
+	const char *pathname = pathname0->name, *pattern = pattern0->name;
+	const int len = pattern0->const_len;
+	if (!pattern0->is_patterned)
+		return !tmy_pathcmp(pathname0, pattern0);
+	if (pathname0->depth != pattern0->depth)
+		return 0;
+	if (strncmp(pathname, pattern, len))
+		return 0;
+	pathname += len;
+	pattern += len;
+	while (*pathname && *pattern) {
+		const char *pathname_delimiter = strchr(pathname, '/');
+		const char *pattern_delimiter = strchr(pattern, '/');
+		if (!pathname_delimiter)
+			pathname_delimiter = strchr(pathname, '\0');
+		if (!pattern_delimiter)
+			pattern_delimiter = strchr(pattern, '\0');
+		if (!tmy_file_match(pathname,
+				    pathname_delimiter,
+				    pattern,
+				    pattern_delimiter))
+			return 0;
+		pathname = *pathname_delimiter ?
+			pathname_delimiter + 1 :
+			pathname_delimiter;
+		pattern = *pattern_delimiter ?
+			pattern_delimiter + 1 :
+			pattern_delimiter;
+	}
+	while (*pattern == '\\' &&
+	       (*(pattern + 1) == '*' ||
+		*(pattern + 1) == '@'))
+		pattern += 2;
+	return (!*pathname && !*pattern);
+}
+
+/*
+ *  Transactional printf() to struct io_buffer structure.
+ *  snprintf() will truncate, but tmy_io_printf() won't.
+ *  Returns zero on success, nonzero otherwise.
+ */
+int tmy_io_printf(struct io_buffer *head, const char *fmt, ...)
+{
+	va_list args;
+	int len;
+	int pos = head->read_avail;
+	int size = head->readbuf_size - pos;
+	if (size <= 0)
+		return -ENOMEM;
+	va_start(args, fmt);
+	len = vsnprintf(head->read_buf + pos, size, fmt, args);
+	va_end(args);
+	if (pos + len >= head->readbuf_size)
+		return -ENOMEM;
+	head->read_avail += len;
+	return 0;
+}
+
+/*
+ * Get tmy_realpath() of current process.
+ * This function uses tmy_alloc(), so caller must tmy_free()
+ * if this function didn't return NULL.
+ */
+const char *tmy_get_exe(void)
+{
+	struct vm_area_struct *vma;
+	if (!current->mm)
+		return NULL;
+	for (vma = current->mm->mmap; vma; vma = vma->vm_next)
+		if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file)
+			return tmy_realpath_dentry(vma->vm_file->f_dentry,
+						   vma->vm_file->f_vfsmnt);
+	return NULL;
+}
+
+const char *tmy_get_msg(const int is_enforce)
+{
+	if (is_enforce)
+		return "ERROR";
+	else
+		return "WARNING";
+}
+
+static inline int strstr2(char **src, const char *find)
+{
+	const int len = strlen(find);
+	char *tmp = *src;
+	if (strncmp(tmp, find, len) == 0) {
+		tmp += len;
+		*src = tmp;
+		return 1;
+	}
+	return 0;
+}
+
+/*************************  DOMAIN POLICY HANDLER  *************************/
+
+/* Check whether the given access control is enabled. */
+unsigned int tmy_flags(const unsigned int index)
+{
+	const u8 profile =
+		TMY_SECURITY->domain->profile;
+	might_sleep();
+	return sbin_init_started && index < TMY_MAX_CONTROL_INDEX
+#if TMY_MAX_PROFILES != 256
+		&& profile < TMY_MAX_PROFILES
+#endif
+		&& profile_ptr[profile] ?
+		profile_ptr[profile]->value[index] :
+		0;
+}
+
+unsigned int tmy_audit_grant(void)
+{
+	return tmy_flags(TMY_AUDIT_GRANT);
+}
+
+unsigned int tmy_audit_reject(void)
+{
+	return tmy_flags(TMY_AUDIT_REJECT);
+}
+
+/* Check whether the given access control is enforce mode. */
+unsigned int tmy_enforce(const unsigned int index)
+{
+	return tmy_flags(index) == 3;
+}
+
+/* Check whether the given access control is accept mode. */
+unsigned int tmy_accept(const unsigned int index)
+{
+	return tmy_flags(index) == 1;
+}
+
+static struct profile *tmy_find_new_profile(const unsigned int profile)
+{
+	static DECLARE_MUTEX(profile_lock);
+	struct profile *ptr = NULL;
+	down(&profile_lock);
+	ptr = profile_ptr[profile];
+	if (profile < TMY_MAX_PROFILES && ptr == NULL) {
+		ptr = tmy_alloc_element(sizeof(*ptr));
+		if (ptr != NULL) {
+			int i;
+			for (i = 0; i < TMY_MAX_CONTROL_INDEX; i++)
+				ptr->value[i] = tmy_control[i].current_value;
+			mb(); /* Instead of using spinlock. */
+			profile_ptr[profile] = ptr;
+		}
+	}
+	up(&profile_lock);
+	return ptr;
+}
+
+static int profile_loaded;
+
+static int tmy_set_status(struct io_buffer *head)
+{
+	char *data = head->write_buf;
+	unsigned int i;
+	unsigned int value;
+	char *cp;
+	struct profile *profile;
+	if (!tmy_is_root())
+		return -EPERM;
+	i = simple_strtoul(data, &cp, 10);
+	if (data != cp) {
+		if (*cp != '-')
+			return -EINVAL;
+		data = cp + 1;
+	}
+	profile = tmy_find_new_profile(i);
+	if (!profile)
+		return -EINVAL;
+	cp = strchr(data, '=');
+	if (!cp)
+		return -EINVAL;
+	*cp = '\0';
+	profile_loaded = 1;
+	tmy_update_counter(TMY_UPDATE_STATUS);
+	if (strcmp(data, tmy_control[TMY_COMMENT].keyword) == 0) {
+		profile->comment = tmy_save_name(cp + 1);
+		return 0;
+	}
+	if (sscanf(cp + 1, "%u", &value) != 1)
+		return -EINVAL;
+	for (i = 0; i < TMY_MAX_CONTROL_INDEX; i++) {
+		if (strcmp(data, tmy_control[i].keyword))
+			continue;
+		if (value > tmy_control[i].max_value)
+			value = tmy_control[i].max_value;
+		profile->value[i] = value;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static int tmy_read_status(struct io_buffer *head)
+{
+	int step;
+	if (head->read_eof)
+		return 0;
+	if (!tmy_is_root())
+		return -EPERM;
+	for (step = head->read_step;
+	     step < TMY_MAX_PROFILES * TMY_MAX_CONTROL_INDEX;
+	     step++) {
+		const int i = step / TMY_MAX_CONTROL_INDEX;
+		const int j = step % TMY_MAX_CONTROL_INDEX;
+		const struct profile *profile = profile_ptr[i];
+		head->read_step = step;
+		if (!profile)
+			continue;
+		if (j != TMY_COMMENT)
+			goto non_comment;
+		if (tmy_io_printf(head, "%u-%s=%s\n",
+				  i, tmy_control[TMY_COMMENT].keyword,
+				  profile->comment ?
+				  profile->comment->name : ""))
+			break;
+		goto comment_ok;
+non_comment:
+		if (tmy_io_printf(head, "%u-%s=%u\n",
+				  i, tmy_control[j].keyword,
+				  profile->value[j]))
+			break;
+comment_ok: ;
+	}
+	if (step == TMY_MAX_PROFILES * TMY_MAX_CONTROL_INDEX)
+		head->read_eof = 1;
+	return 0;
+}
+
+/*************************  POLICY MANAGER HANDLER  *************************/
+
+struct policy_manager_entry {
+	struct policy_manager_entry *next;
+	const struct path_info *manager;
+	u8 is_domain;
+	u8 is_deleted;
+};
+
+static struct policy_manager_entry *policy_manager_list;
+
+static int tmy_add_manager_entry(const char *manager, u8 is_delete)
+{
+	struct policy_manager_entry *new_entry, *ptr;
+	static DECLARE_MUTEX(lock);
+	const struct path_info *saved_manager;
+	int error = -ENOMEM;
+	u8 is_domain = 0;
+	if (!tmy_is_root())
+		return -EPERM;
+	if (tmy_is_domain_def(manager)) {
+		if (!tmy_is_correct_domain(manager, __FUNCTION__))
+			return -EINVAL;
+		is_domain = 1;
+	} else {
+		if (!tmy_correct_path(manager, 1, -1, -1, __FUNCTION__))
+			return -EINVAL;
+	}
+	saved_manager = tmy_save_name(manager);
+	if (saved_manager == NULL)
+		return -ENOMEM;
+	down(&lock);
+	for (ptr = policy_manager_list; ptr; ptr = ptr->next) {
+		if (ptr->manager == saved_manager) {
+			ptr->is_deleted = is_delete;
+			error = 0;
+			goto out;
+		}
+	}
+	if (is_delete) {
+		error = -ENOENT;
+		goto out;
+	}
+	new_entry = tmy_alloc_element(sizeof(*new_entry));
+	if (new_entry == NULL)
+		goto out;
+	new_entry->manager = saved_manager;
+	new_entry->is_domain = is_domain;
+	mb(); /* Instead of using spinlock. */
+	ptr = policy_manager_list;
+	if (ptr) {
+		while (ptr->next)
+			ptr = ptr->next;
+		ptr->next = new_entry;
+	} else
+		policy_manager_list = new_entry;
+	error = 0;
+out:
+	up(&lock);
+	if (!error)
+		tmy_update_counter(TMY_UPDATE_MANAGER);
+	return error;
+}
+
+static int tmy_add_manager_policy(struct io_buffer *head)
+{
+	char *data = head->write_buf;
+	int is_delete = 0;
+	if (!tmy_is_root())
+		return -EPERM;
+	if (strstr2(&data, TMY_DELETE))
+		is_delete = 1;
+	return tmy_add_manager_entry(data, is_delete);
+}
+
+static int tmy_read_manager_policy(struct io_buffer *head)
+{
+	if (!head->read_eof) {
+		struct policy_manager_entry *ptr = head->read_var2;
+		if (!tmy_is_root())
+			return -EPERM;
+		if (!ptr)
+			ptr = policy_manager_list;
+		while (ptr) {
+			head->read_var2 = ptr;
+			if (!ptr->is_deleted &&
+			    tmy_io_printf(head,
+					  "%s\n",
+					  ptr->manager->name))
+				break;
+			ptr = ptr->next;
+		}
+		if (!ptr)
+			head->read_eof = 1;
+	}
+	return 0;
+}
+
+/* Check whether the current process is a policy manager. */
+static int tmy_is_policy_manager(void)
+{
+	struct policy_manager_entry *ptr;
+	const char *exe;
+	const struct path_info *domainname =
+		TMY_SECURITY->domain->domainname;
+	if (!sbin_init_started)
+		return 1;
+	for (ptr = policy_manager_list; ptr; ptr = ptr->next) {
+		if (!ptr->is_deleted &&
+		    ptr->is_domain &&
+		    !tmy_pathcmp(domainname, ptr->manager))
+			return 1;
+	}
+	exe = tmy_get_exe();
+	if (!exe)
+		return 0;
+	for (ptr = policy_manager_list; ptr; ptr = ptr->next) {
+		if (!ptr->is_deleted &&
+		    !ptr->is_domain &&
+		    !strcmp(exe, ptr->manager->name))
+			break;
+	}
+	if (!ptr) { /* Reduce error messages. */
+		static pid_t last_pid;
+		const pid_t pid = current->pid;
+		if (last_pid != pid) {
+			printk(KERN_INFO
+			       "%s is not permitted to update policies.\n",
+			       exe);
+			last_pid = pid;
+		}
+	}
+	tmy_free(exe);
+	return ptr ? 1 : 0;
+}
+
+/*************************  DOMAIN POLICY HANDLER  *************************/
+
+static int tmy_add_domain_policy(struct io_buffer *head)
+{
+	char *data = head->write_buf;
+	struct domain_info *domain = head->write_var1;
+	int is_delete = 0;
+	int is_select = 0;
+	int is_undelete = 0;
+	unsigned int profile;
+	if (!tmy_is_root())
+		return -EPERM;
+	if (strstr2(&data, TMY_DELETE))
+		is_delete = 1;
+	else if (strstr2(&data, TMY_SELECT))
+		is_select = 1;
+	else if (strstr2(&data, TMY_UNDELETE))
+		is_undelete = 1;
+	tmy_update_counter(TMY_UPDATE_DOMAINPOLICY);
+	if (tmy_is_domain_def(data)) {
+		if (is_delete) {
+			tmy_delete_domain(data);
+			domain = NULL;
+		} else if (is_select)
+			domain = tmy_find_domain(data);
+		else if (is_undelete)
+			domain = tmy_undelete_domain(data);
+		else
+			domain = tmy_new_domain(data, 0);
+		head->write_var1 = domain;
+		return 0;
+	}
+	if (!domain)
+		return -EINVAL;
+	if (sscanf(data, TMY_USE_PROFILE "%u", &profile) == 1 &&
+	    profile < TMY_MAX_PROFILES) {
+		if (profile_ptr[profile] || !sbin_init_started)
+			domain->profile = (u8) profile;
+	} else if (strstr2(&data, TMY_ALLOW_NETWORK))
+		return tmy_add_network_policy(data, domain, is_delete);
+	else if (strstr2(&data, TMY_ALLOW_ARGV0))
+		return tmy_add_argv0_policy(data, domain, is_delete);
+	else if (strstr2(&data, TMY_ALLOW_SIGNAL))
+		return AddSignalPolicy(data, domain, is_delete);
+	else
+		return tmy_add_file_policy(data, domain, is_delete);
+	return -EINVAL;
+}
+
+static inline int print_file_rwx_acl(struct io_buffer *head, int pos,
+				     struct acl_info *ptr)
+{
+	struct file_acl *ptr2 = (struct file_acl *) ptr;
+	const unsigned char b = ptr2->u_is_group;
+	if (tmy_io_printf(head, "%d %s%s\n",
+			  ptr2->perm, b ? "@" : "",
+			  b ? ptr2->u.group->group_name->name :
+			  ptr2->u.filename->name)) {
+		head->read_avail = pos;
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static inline int print_argv0_acl(struct io_buffer *head, int pos,
+				  struct acl_info *ptr)
+{
+	struct argv0_acl *ptr2 = (struct argv0_acl *) ptr;
+	if (tmy_io_printf(head, TMY_ALLOW_ARGV0 "%s %s\n",
+			  ptr2->filename->name, ptr2->argv0->name)) {
+		head->read_avail = pos;
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static inline int print_network_acl(struct io_buffer *head, int pos,
+				    struct acl_info *ptr)
+{
+	struct net_acl *ptr2 = (struct net_acl *) ptr;
+	u8 record_type = ptr2->record_type;
+	u32 min_address;
+	u32 max_address;
+	char buf[64];
+	const u16 *min_address_ptr;
+	const u16 *max_address_ptr;
+	u16 min_port;
+	u16 max_port;
+
+	if (tmy_io_printf(head, TMY_ALLOW_NETWORK "%s ",
+			  tmy_network2keyword(ptr2->operation_type)))
+		goto out;
+	if (record_type != TMY_TYPE_ADDRESS_GROUP)
+		goto non_address_group;
+
+	if (tmy_io_printf(head, "@%s", ptr2->u.group->group_name->name))
+		goto out;
+	goto print_port;
+
+non_address_group:
+	if (record_type != TMY_TYPE_IPv4)
+		goto ipv6_address;
+
+	min_address = ptr2->u.ipv4.min;
+	max_address = ptr2->u.ipv4.max;
+	if (tmy_io_printf(head, "%u.%u.%u.%u", HIPQUAD(min_address)))
+		goto out;
+	if (min_address != max_address &&
+	    tmy_io_printf(head, "-%u.%u.%u.%u", HIPQUAD(max_address)))
+		goto out;
+	goto print_port;
+
+ipv6_address:
+	min_address_ptr = ptr2->u.ipv6.min;
+	max_address_ptr = ptr2->u.ipv6.max;
+	tmy_print_ipv6(buf, sizeof(buf), min_address_ptr);
+	if (tmy_io_printf(head, "%s", buf))
+		goto out;
+	if (memcmp(min_address_ptr, max_address_ptr, 16)) {
+		tmy_print_ipv6(buf, sizeof(buf), max_address_ptr);
+		if (tmy_io_printf(head, "-%s", buf))
+			goto out;
+	}
+
+print_port:
+	min_port = ptr2->min_port;
+	max_port = ptr2->max_port;
+	if (tmy_io_printf(head, " %u", min_port))
+		goto out;
+	if (min_port != max_port && tmy_io_printf(head, "-%u", max_port))
+		goto out;
+	if (tmy_io_printf(head, "\n")) {
+out:
+		head->read_avail = pos;
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static inline int print_signal_acl(struct io_buffer *head, int pos,
+				   struct acl_info *ptr)
+{
+	struct signal_acl *ptr2 = (struct signal_acl *) ptr;
+	if (tmy_io_printf(head, TMY_ALLOW_SIGNAL "%u %s\n",
+			  ptr2->sig, ptr2->domainname->name)) {
+		head->read_avail = pos;
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static inline int print_file_other_acl(struct io_buffer *head, int pos,
+				       struct acl_info *ptr)
+{
+	const u8 acl_type = ptr->type;
+	const char *keyword = tmy_acltype2keyword(acl_type);
+	if (!keyword)
+		return 0; /* This must not happen. */
+	if (tmy_acltype2paths(acl_type) == 2) {
+		struct double_acl *ptr2 = (struct double_acl *) ptr;
+		const u8 b1 = ptr2->u1_is_group;
+		const u8 b2 = ptr2->u2_is_group;
+		if (tmy_io_printf(head,
+				  "allow_%s %s%s %s%s\n",
+				  keyword,
+				  b1 ? "@" : "",
+				  b1 ? ptr2->u1.group1->group_name->name :
+				  ptr2->u1.filename1->name,
+				  b2 ? "@" : "",
+				  b2 ? ptr2->u2.group2->group_name->name :
+				  ptr2->u2.filename2->name)) {
+			head->read_avail = pos;
+			return -ENOMEM;
+		}
+	} else {
+		struct single_acl *ptr2 = (struct single_acl *) ptr;
+		const u8 b = ptr2->u_is_group;
+		if (tmy_io_printf(head,
+				  "allow_%s %s%s\n",
+				  keyword,
+				  b ? "@" : "",
+				  b ? ptr2->u.group->group_name->name :
+				  ptr2->u.filename->name)) {
+			head->read_avail = pos;
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+
+static int tmy_read_domain_policy(struct io_buffer *head)
+{
+	struct domain_info *domain = head->read_var1;
+	if (head->read_eof)
+		return 0;
+	switch (head->read_step) {
+	case 0: break;
+	case 1: goto step1;
+	case 2: goto step2;
+	case 3: goto step3;
+	default: return -EINVAL;
+	}
+	if (!tmy_is_root())
+		return -EPERM;
+	for (domain = &KERNEL_DOMAIN; domain; domain = domain->next) {
+		struct acl_info *ptr;
+		if (domain->is_deleted)
+			continue;
+		head->read_var1 = domain;
+		head->read_var2 = NULL;
+		head->read_step = 1;
+step1:
+		if (tmy_io_printf(head,
+				  "%s\n" TMY_USE_PROFILE "%u\n%s\n",
+				  domain->domainname->name,
+				  domain->profile,
+				  domain->quota_warned ?
+				  "quota_exceeded\n" : ""))
+			break;
+		head->read_var2 = domain->first_acl_ptr;
+		head->read_step = 2;
+step2:
+		for (ptr = head->read_var2; ptr; ptr = ptr->next) {
+			const u8 acl_type = ptr->type;
+			const int pos = head->read_avail;
+			head->read_var2 = ptr;
+			if (ptr->is_deleted)
+				continue;
+			if (acl_type == TMY_TYPE_FILE_ACL) {
+				if (print_file_rwx_acl(head, pos, ptr))
+					break;
+			} else if (acl_type == TMY_TYPE_ARGV0_ACL) {
+				if (print_argv0_acl(head, pos, ptr))
+					break;
+			} else if (acl_type == TMY_TYPE_IP_NETWORK_ACL) {
+				if (print_network_acl(head, pos, ptr))
+					break;
+			} else if (acl_type == TMY_TYPE_SIGNAL_ACL) {
+				if (print_signal_acl(head, pos, ptr))
+					break;
+			} else
+				if (print_file_other_acl(head, pos, ptr))
+					break;
+		}
+		if (ptr)
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 3;
+step3:
+		if (tmy_io_printf(head, "\n"))
+			break;
+	}
+	if (!domain)
+		head->read_eof = 1;
+	return 0;
+}
+
+static int tmy_read_domain_profile(struct io_buffer *head)
+{
+	if (!head->read_eof) {
+		struct domain_info *domain;
+		if (head->read_step == 0) {
+			head->read_var1 = &KERNEL_DOMAIN;
+			head->read_step = 1;
+		}
+		if (!tmy_is_root())
+			return -EPERM;
+		for (domain = head->read_var1; domain; domain = domain->next) {
+			if (domain->is_deleted)
+				continue;
+			head->read_var1 = domain;
+			if (tmy_io_printf(head,
+					  "%u %s\n",
+					  domain->profile,
+					  domain->domainname->name))
+				break;
+		}
+		if (!domain)
+			head->read_eof = 1;
+	}
+	return 0;
+}
+
+static int tmy_write_pid(struct io_buffer *head)
+{
+	head->read_step = (int) simple_strtoul(head->write_buf, NULL, 10);
+	head->read_eof = 0;
+	return 0;
+}
+
+static int tmy_read_pid(struct io_buffer *head)
+{
+	if (head->read_avail == 0 && !head->read_eof) {
+		const int pid = head->read_step;
+		struct task_struct *p;
+		struct domain_info *domain = NULL;
+		/***** CRITICAL SECTION START *****/
+		read_lock(&tasklist_lock);
+		p = find_task_by_pid(pid);
+		if (p) {
+			struct tmy_security *tmp =
+				(struct tmy_security *) p->security;
+			if (tmp) {
+				domain = tmp->domain;
+				if (!domain)
+					domain = &KERNEL_DOMAIN;
+			}
+		}
+		read_unlock(&tasklist_lock);
+		/***** CRITICAL SECTION END *****/
+		if (domain)
+			tmy_io_printf(head,
+				      "%d %u %s",
+				      pid,
+				      domain->profile,
+				      domain->domainname->name);
+		head->read_eof = 1;
+	}
+	return 0;
+}
+
+static int tmy_update_domain_profile(struct io_buffer *head)
+{
+	char *data = head->write_buf;
+	char *cp = strchr(data, ' ');
+	struct domain_info *domain;
+	unsigned int profile;
+	if (!tmy_is_root())
+		return -EPERM;
+	if (!cp)
+		return -EINVAL;
+	*cp = '\0';
+	domain = tmy_find_domain(cp + 1);
+	profile = simple_strtoul(data, NULL, 10);
+	if (domain && profile < TMY_MAX_PROFILES &&
+	    (profile_ptr[profile] || !sbin_init_started))
+		domain->profile = (u8) profile;
+	tmy_update_counter(TMY_UPDATE_DOMAINPOLICY);
+	return 0;
+}
+
+/*************************  SYSTEM POLICY HANDLER  *************************/
+
+static int tmy_add_system_policy(struct io_buffer *head)
+{
+	char *data = head->write_buf;
+	int is_delete = 0;
+	if (!tmy_is_root())
+		return -EPERM;
+	tmy_update_counter(TMY_UPDATE_SYSTEMPOLICY);
+	if (strstr2(&data, TMY_DELETE))
+		is_delete = 1;
+	if (strstr2(&data, TMY_ALLOW_MOUNT))
+		return AddMountPolicy(data, is_delete);
+	if (strstr2(&data, TMY_DENY_UNMOUNT))
+		return AddNoUmountPolicy(data, is_delete);
+	if (strstr2(&data, TMY_ALLOW_PIVOT_ROOT))
+		return AddPivotRootPolicy(data, is_delete);
+	return -EINVAL;
+}
+
+static int tmy_read_system_policy(struct io_buffer *head)
+{
+	if (head->read_eof)
+		return 0;
+
+	switch (head->read_step) {
+	case 0:
+		if (!tmy_is_root()) return -EPERM;
+		head->read_var2 = NULL; head->read_step = 1;
+	case 1:
+		if (ReadMountPolicy(head)) break;
+		head->read_var2 = NULL; head->read_step = 2;
+	case 2:
+		if (ReadNoUmountPolicy(head)) break;
+		head->read_var2 = NULL; head->read_step = 3;
+	case 3:
+		if (ReadPivotRootPolicy(head)) break;
+		head->read_eof = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*************************  EXCEPTION POLICY HANDLER  *************************/
+
+static int tmy_add_exception_policy(struct io_buffer *head)
+{
+	char *data = head->write_buf;
+	int is_delete = 0;
+	if (!tmy_is_root())
+		return -EPERM;
+	tmy_update_counter(TMY_UPDATE_EXCEPTIONPOLICY);
+	if (strstr2(&data, TMY_DELETE))
+		is_delete = 1;
+	if (strstr2(&data, TMY_KEEP_DOMAIN))
+		return tmy_add_domain_keeper_policy(data, 0, is_delete);
+	if (strstr2(&data, TMY_NO_KEEP_DOMAIN))
+		return tmy_add_domain_keeper_policy(data, 1, is_delete);
+	if (strstr2(&data, TMY_INITIALIZE_DOMAIN))
+		return tmy_add_domain_initializer_policy(data, 0,
+							 is_delete, 0);
+	if (strstr2(&data, TMY_NO_INITIALIZE_DOMAIN))
+		return tmy_add_domain_initializer_policy(data, 1,
+							 is_delete, 0);
+	if (strstr2(&data, TMY_INITIALIZER))
+		return tmy_add_domain_initializer_policy(data, 0,
+							 is_delete, 1);
+	if (strstr2(&data, TMY_NO_INITIALIZER))
+		return tmy_add_domain_initializer_policy(data, 1,
+							 is_delete, 1);
+	if (strstr2(&data, TMY_ALIAS))
+		return tmy_add_alias_policy(data, is_delete);
+	if (strstr2(&data, TMY_AGGREGATOR))
+		return tmy_add_aggregator_policy(data, is_delete);
+	if (strstr2(&data, TMY_ALLOW_READ))
+		return tmy_add_globally_readable_policy(data, is_delete);
+	if (strstr2(&data, TMY_FILE_PATTERN))
+		return tmy_add_pattern_policy(data, is_delete);
+	if (strstr2(&data, TMY_PATH_GROUP))
+		return tmy_add_group_policy(data, is_delete);
+	if (strstr2(&data, TMY_DENY_REWRITE))
+		return tmy_add_no_rewrite_policy(data, is_delete);
+	if (strstr2(&data, TMY_ADDRESS_GROUP))
+		return tmy_add_addr_group_policy(data, is_delete);
+	return -EINVAL;
+}
+
+static int tmy_read_exception_policy(struct io_buffer *head)
+{
+	if (head->read_eof)
+		return 0;
+
+	switch (head->read_step) {
+	case 0:
+		if (!tmy_is_root())
+			return -EPERM;
+		head->read_var2 = NULL;
+		head->read_step = 1;
+	case 1:
+		if (tmy_read_domain_keeper_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 2;
+	case 2:
+		if (tmy_read_globally_readable_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 3;
+	case 3:
+		if (tmy_read_domain_initializer_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 4;
+	case 4:
+		if (tmy_read_alias_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 5;
+	case 5:
+		if (tmy_read_aggregator_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 6;
+	case 6:
+		if (tmy_read_pattern_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 7;
+	case 7:
+		if (tmy_read_no_rewrite_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 8;
+	case 8:
+		if (tmy_read_group_policy(head))
+			break;
+		head->read_var1 = NULL;
+		head->read_var2 = NULL;
+		head->read_step = 9;
+	case 9:
+		if (tmy_read_addr_group_policy(head))
+			break;
+		head->read_eof = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*************************  POLICY LOADER  *************************/
+
+static const char *tmy_loader;
+
+static int tmy_loader_setup(char *str)
+{
+	tmy_loader = str;
+	return 0;
+}
+
+__setup("TOMOYO_loader=", tmy_loader_setup);
+
+void tmy_load_policy(const char *filename)
+{
+	if (sbin_init_started)
+		return;
+	/*
+	 * Check filename is /sbin/init or /sbin/tomoyo-start .
+	 * /sbin/tomoyo-start is a dummy filename in case
+	 * where /sbin/init can't be passed.
+	 * You can create /sbin/tomoyo-start
+	 * by "ln -s /bin/true /sbin/tomoyo-start", for
+	 * only the pathname is needed to activate Mandatory Access Control.
+	 */
+	if (strcmp(filename, "/sbin/init") != 0
+	    && strcmp(filename, "/sbin/tomoyo-start") != 0)
+		return;
+	/*
+	 * Don't activate MAC if the path given by 'TOMOYO_loader=' option
+	 * doesn't exist.
+	 * If initrd.img includes /sbin/init but real-root-dev has not
+	 * mounted on / yet, activating MAC will block the system
+	 * since policies are not loaded yet.
+	 * So let do_execve() call this function everytime.
+	 */
+	if (!profile_loaded) {
+		struct nameidata nd;
+		char *argv[2], *envp[3];
+		if (!tmy_loader)
+			tmy_loader = "/sbin/tomoyo-init";
+		if (path_lookup(tmy_loader, LOOKUP_FOLLOW, &nd)) {
+			printk("Not activating Mandatory Access Control "
+			       "now since %s doesn't exist.\n", tmy_loader);
+			return;
+		}
+		path_release(&nd);
+		argv[0] = (char *) tmy_loader;
+		argv[1] = NULL;
+		envp[0] = "HOME=/";
+		envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+		envp[2] = NULL;
+		call_usermodehelper(argv[0], argv, envp, 1);
+	}
+
+	printk(KERN_INFO "TOMOYO: 2.1rc1   2007/08/07\n");
+	if (!profile_loaded)
+		panic("No profiles loaded. "
+		      "Run policy loader using 'init=' option.\n");
+	printk(KERN_INFO "Mandatory Access Control activated.\n");
+	sbin_init_started = 1;
+	{ /* Check all profiles currently assigned to domains are defined. */
+		struct domain_info *domain;
+		for (domain = &KERNEL_DOMAIN; domain; domain = domain->next) {
+			const u8 profile = domain->profile;
+			if (profile_ptr[profile]) continue;
+			panic("Profile %u (used by '%s') not defined.\n",
+			      profile,
+			      domain->domainname->name);
+		}
+	}
+}
+
+
+/*************************  MAC Decision Delayer  *************************/
+
+static DECLARE_WAIT_QUEUE_HEAD(query_wait);
+
+static spinlock_t query_lock = SPIN_LOCK_UNLOCKED;
+
+struct query_entry {
+	struct list_head list;
+	char *query;
+	int query_len;
+	unsigned int serial;
+	int timer;
+	int answer;
+};
+
+static LIST_HEAD(query_list);
+static atomic_t queryd_watcher = ATOMIC_INIT(0);
+
+int tmy_supervisor(const char *fmt, ...)
+{
+	va_list args;
+	int error = -EPERM;
+	int pos;
+	int len;
+	static unsigned int serial;
+	struct query_entry *query_entry;
+	if (!tmy_flags(TMY_ALLOW_ENFORCE_GRACE))
+		return -EPERM;
+	if (!atomic_read(&queryd_watcher))
+		return -EPERM;
+	va_start(args, fmt);
+	len = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 32;
+	va_end(args);
+	query_entry = tmy_alloc(sizeof(*query_entry));
+	if (!query_entry)
+		goto out;
+	query_entry->query = tmy_alloc(len);
+	if (!query_entry->query)
+		goto out;
+	INIT_LIST_HEAD(&query_entry->list);
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&query_lock);
+	query_entry->serial = serial++;
+	spin_unlock(&query_lock);
+	/***** CRITICAL SECTION END *****/
+	pos = snprintf(query_entry->query, len - 1,
+		       "Q%u\n", query_entry->serial);
+	va_start(args, fmt);
+	vsnprintf(query_entry->query + pos, len - 1 - pos, fmt, args);
+	query_entry->query_len = strlen(query_entry->query) + 1;
+	va_end(args);
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&query_lock);
+	list_add_tail(&query_entry->list, &query_list);
+	spin_unlock(&query_lock);
+	/***** CRITICAL SECTION END *****/
+	tmy_update_counter(TMY_UPDATE_QUERY);
+	/* Give 10 seconds for supervisor's opinion. */
+	for (query_entry->timer = 0;
+	     atomic_read(&queryd_watcher) &&
+		     tmy_flags(TMY_ALLOW_ENFORCE_GRACE) &&
+		     query_entry->timer < 100;
+	     query_entry->timer++) {
+		wake_up(&query_wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ / 10);
+		if (query_entry->answer)
+			break;
+	}
+	tmy_update_counter(TMY_UPDATE_QUERY);
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&query_lock);
+	list_del(&query_entry->list);
+	spin_unlock(&query_lock);
+	/***** CRITICAL SECTION END *****/
+	switch (query_entry->answer) {
+	case 1:
+		/* Granted by administrator. */
+		error = 0;
+		break;
+	case 0:
+		/* Timed out. */
+		break;
+	default:
+		/* Rejected by administrator. */
+		break;
+	}
+out:
+	if (query_entry)
+		tmy_free(query_entry->query);
+	tmy_free(query_entry);
+	return error;
+}
+
+static int tmy_poll_query(struct file *file, poll_table *wait)
+{
+	int found;
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&query_lock);
+	found = !list_empty(&query_list);
+	spin_unlock(&query_lock);
+	/***** CRITICAL SECTION END *****/
+	if (found)
+		return POLLIN | POLLRDNORM;
+	poll_wait(file, &query_wait, wait);
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&query_lock);
+	found = !list_empty(&query_list);
+	spin_unlock(&query_lock);
+	/***** CRITICAL SECTION END *****/
+	if (found)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static int tmy_read_query(struct io_buffer *head)
+{
+	struct list_head *tmp;
+	int pos = 0;
+	int len = 0;
+	char *buf;
+	if (head->read_avail)
+		return 0;
+	if (head->read_buf) {
+		tmy_free(head->read_buf);
+		head->read_buf = NULL;
+		head->readbuf_size = 0;
+	}
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&query_lock);
+	list_for_each(tmp, &query_list) {
+		struct query_entry *ptr
+			= list_entry(tmp, struct query_entry, list);
+		if (pos++ == head->read_step) {
+			len = ptr->query_len;
+			break;
+		}
+	}
+	spin_unlock(&query_lock);
+	/***** CRITICAL SECTION END *****/
+	if (!len) {
+		head->read_step = 0;
+		return 0;
+	}
+	buf = tmy_alloc(len);
+	if (buf) {
+		pos = 0;
+		/***** CRITICAL SECTION START *****/
+		spin_lock(&query_lock);
+		list_for_each(tmp, &query_list) {
+			struct query_entry *ptr
+				= list_entry(tmp, struct query_entry, list);
+			if (pos++ == head->read_step) {
+				/* Some query can be skiipped because
+				 * query_list can change, but I don't care.
+				 */
+				if (len == ptr->query_len)
+					memmove(buf, ptr->query, len);
+				break;
+			}
+		}
+		spin_unlock(&query_lock);
+		/***** CRITICAL SECTION END *****/
+		if (buf[0]) {
+			head->readbuf_size = len;
+			head->read_avail = len;
+			head->read_buf = buf;
+			head->read_step++;
+		} else
+			tmy_free(buf);
+	}
+	return 0;
+}
+
+static int tmy_write_answer(struct io_buffer *head)
+{
+	char *data = head->write_buf;
+	struct list_head *tmp;
+	unsigned int serial;
+	unsigned int answer;
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&query_lock);
+	list_for_each(tmp, &query_list) {
+		struct query_entry *ptr
+			= list_entry(tmp, struct query_entry, list);
+		ptr->timer = 0;
+	}
+	spin_unlock(&query_lock);
+	/***** CRITICAL SECTION END *****/
+	if (sscanf(data, "A%u=%u", &serial, &answer) != 2)
+		return -EINVAL;
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&query_lock);
+	list_for_each(tmp, &query_list) {
+		struct query_entry *ptr
+			= list_entry(tmp, struct query_entry, list);
+		if (ptr->serial != serial)
+			continue;
+		if (!ptr->answer)
+			ptr->answer = answer;
+		break;
+	}
+	spin_unlock(&query_lock);
+	/***** CRITICAL SECTION END *****/
+	return 0;
+}
+
+/*************************  /proc INTERFACE HANDLER  *************************/
+
+/* Policy updates counter. */
+static unsigned int updates_counter[TMY_MAX_UPDATES_COUNTER];
+static spinlock_t updates_counter_lock = SPIN_LOCK_UNLOCKED;
+
+void tmy_update_counter(const unsigned char index)
+{
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&updates_counter_lock);
+	if (index < TMY_MAX_UPDATES_COUNTER)
+		updates_counter[index]++;
+	spin_unlock(&updates_counter_lock);
+	/***** CRITICAL SECTION END *****/
+}
+
+static int tmy_read_updates_counter(struct io_buffer *head)
+{
+	unsigned int counter[TMY_MAX_UPDATES_COUNTER];
+	if (head->read_eof)
+		return 0;
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&updates_counter_lock);
+	memmove(counter, updates_counter, sizeof(updates_counter));
+	memset(updates_counter, 0, sizeof(updates_counter));
+	spin_unlock(&updates_counter_lock);
+	/***** CRITICAL SECTION END *****/
+	tmy_io_printf(head,
+		      "/proc/tomoyo/domain_policy:    %10u\n"
+		      "/proc/tomoyo/system_policy:    %10u\n"
+		      "/proc/tomoyo/exception_policy: %10u\n"
+		      "/proc/tomoyo/status:           %10u\n"
+		      "/proc/tomoyo/query:            %10u\n"
+		      "/proc/tomoyo/manager:          %10u\n",
+		      counter[TMY_UPDATE_DOMAINPOLICY],
+		      counter[TMY_UPDATE_SYSTEMPOLICY],
+		      counter[TMY_UPDATE_EXCEPTIONPOLICY],
+		      counter[TMY_UPDATE_STATUS],
+		      counter[TMY_UPDATE_QUERY],
+		      counter[TMY_UPDATE_MANAGER]);
+	head->read_eof = 1;
+	return 0;
+}
+
+static int tmy_read_memory_counter(struct io_buffer *head)
+{
+	int shared;
+	int private;
+	int dynamic;
+	if (head->read_eof)
+		return 0;
+	shared = tmy_get_memory_used_for_save_name();
+	private = tmy_get_memory_used_for_elements();
+	dynamic = tmy_get_memory_used_for_dynamic();
+	if (tmy_io_printf(head,
+			  "Shared:  %10u\n"
+			  "Private: %10u\n"
+			  "Dynamic: %10u\n"
+			  "Total:   %10u\n",
+			  shared,
+			  private,
+			  dynamic,
+			  shared + private + dynamic) == 0)
+		head->read_eof = 1;
+	return 0;
+}
+
+static int tmy_open_control(const int type, struct file *file)
+{
+	struct io_buffer *head = tmy_alloc(sizeof(*head));
+	if (!head)
+		return -ENOMEM;
+	init_MUTEX(&head->read_sem);
+	init_MUTEX(&head->write_sem);
+	switch (type) {
+	case TMY_POLICY_DOMAINPOLICY:
+		head->write = tmy_add_domain_policy;
+		head->read = tmy_read_domain_policy;
+		break;
+	case TMY_POLICY_SYSTEMPOLICY:
+		head->write = tmy_add_system_policy;
+		head->read = tmy_read_system_policy;
+		break;
+	case TMY_POLICY_EXCEPTIONPOLICY:
+		head->write = tmy_add_exception_policy;
+		head->read = tmy_read_exception_policy;
+		break;
+	case TMY_POLICY_DOMAIN_STATUS:
+		head->write = tmy_update_domain_profile;
+		head->read = tmy_read_domain_profile;
+		break;
+	case TMY_INFO_PROCESS_STATUS:
+		head->write = tmy_write_pid;
+		head->read = tmy_read_pid;
+		break;
+	case TMY_INFO_SELFDOMAIN:
+		head->read = tmy_read_self_domain;
+		break;
+	case TMY_INFO_MEMINFO:
+		head->read = tmy_read_memory_counter;
+		head->readbuf_size = 128;
+		break;
+	case TMY_STATUS:
+		head->write = tmy_set_status;
+		head->read = tmy_read_status;
+		break;
+	case TMY_POLICY_QUERY:
+		head->poll = tmy_poll_query;
+		head->write = tmy_write_answer;
+		head->read = tmy_read_query;
+		break;
+	case TMY_POLICY_MANAGER:
+		head->write = tmy_add_manager_policy;
+		head->read = tmy_read_manager_policy;
+		break;
+	case TMY_INFO_UPDATESCOUNTER:
+		head->read = tmy_read_updates_counter;
+		break;
+	}
+	if (type != TMY_POLICY_QUERY) {
+		if (!head->readbuf_size)
+			head->readbuf_size = PAGE_SIZE * 2;
+		head->read_buf = tmy_alloc(head->readbuf_size);
+		if (!head->read_buf) {
+			tmy_free(head);
+			return -ENOMEM;
+		}
+	}
+	if (head->write) {
+		head->writebuf_size = PAGE_SIZE * 2;
+		head->write_buf = tmy_alloc(head->writebuf_size);
+		if (!head->write_buf) {
+			tmy_free(head->read_buf);
+			tmy_free(head);
+			return -ENOMEM;
+		}
+	}
+	file->private_data = head;
+	if (type == TMY_INFO_SELFDOMAIN)
+		tmy_read_control(file, NULL, 0);
+	else if (head->write == tmy_write_answer)
+		atomic_inc(&queryd_watcher);
+	return 0;
+}
+
+static int tmy_copy_to_user(struct io_buffer *head, char __user *buffer,
+			    int buffer_len)
+{
+	int len = head->read_avail;
+	char *cp = head->read_buf;
+	if (len > buffer_len)
+		len = buffer_len;
+	if (len) {
+		if (copy_to_user(buffer, cp, len))
+			return -EFAULT;
+		head->read_avail -= len;
+		memmove(cp, cp + len, head->read_avail);
+	}
+	return len;
+}
+
+static int tmy_poll_control(struct file *file, poll_table *wait)
+{
+	struct io_buffer *head = (struct io_buffer *) file->private_data;
+	if (!head->poll)
+		return -ENOSYS;
+	return head->poll(file, wait);
+}
+
+static int tmy_read_control(struct file *file, char __user *buffer,
+			    const int buffer_len)
+{
+	int len = 0;
+	struct io_buffer *head = (struct io_buffer *) file->private_data;
+	if (!head->read)
+		return -ENOSYS;
+	if (!access_ok(VERIFY_WRITE, buffer, buffer_len))
+		return -EFAULT;
+	if (down_interruptible(&head->read_sem))
+		return -EINTR;
+	len = head->read(head);
+	if (len >= 0)
+		len = tmy_copy_to_user(head, buffer, buffer_len);
+	up(&head->read_sem);
+	return len;
+}
+
+static int tmy_write_control(struct file *file, const char __user *buffer,
+			     const int buffer_len)
+{
+	struct io_buffer *head = (struct io_buffer *) file->private_data;
+	int error = buffer_len;
+	int avail_len = buffer_len;
+	char *cp0 = head->write_buf;
+	if (!head->write)
+		return -ENOSYS;
+	if (!access_ok(VERIFY_READ, buffer, buffer_len))
+		return -EFAULT;
+	if (!tmy_is_root())
+		return -EPERM;
+	if (head->write != tmy_write_pid && !tmy_is_policy_manager())
+		/* Forbid updating policies for non manager programs. */
+		return -EPERM;
+
+	if (down_interruptible(&head->write_sem))
+		return -EINTR;
+	while (avail_len > 0) {
+		char c;
+		if (head->write_avail >= head->writebuf_size - 1) {
+			error = -ENOMEM;
+			break;
+		} else if (get_user(c, buffer)) {
+			error = -EFAULT;
+			break;
+		}
+		buffer++;
+		avail_len--;
+		cp0[head->write_avail++] = c;
+		if (c != '\n')
+			continue;
+		cp0[head->write_avail - 1] = '\0';
+		head->write_avail = 0;
+		tmy_normalize_line(cp0);
+		head->write(head);
+	}
+	up(&head->write_sem);
+	return error;
+}
+
+
+static int tmy_close_control(struct file *file)
+{
+	struct io_buffer *head = file->private_data;
+
+	if (head->write == tmy_write_answer)
+		atomic_dec(&queryd_watcher);
+
+	tmy_free(head->read_buf);
+	head->read_buf = NULL;
+	tmy_free(head->write_buf);
+	head->write_buf = NULL;
+	tmy_free(head);
+	head = NULL;
+	file->private_data = NULL;
+	return 0;
+}
+
+static int tmy_open(struct inode *inode, struct file *file)
+{
+	return tmy_open_control(((u8 *) PDE(inode)->data) - ((u8 *) NULL),
+				file);
+}
+
+static int tmy_release(struct inode *inode, struct file *file)
+{
+	return tmy_close_control(file);
+}
+
+static unsigned int tmy_poll(struct file *file, poll_table *wait)
+{
+	return tmy_poll_control(file, wait);
+}
+
+static ssize_t tmy_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	return tmy_read_control(file, buf, count);
+}
+
+static ssize_t tmy_write(struct file *file, const char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	return tmy_write_control(file, buf, count);
+}
+
+static struct file_operations tmy_operations = {
+	.open 	 = tmy_open,
+	.release = tmy_release,
+	.poll 	 = tmy_poll,
+	.read 	 = tmy_read,
+	.write 	 = tmy_write
+};
+
+static void tmy_create_entry(const char *name,
+			     const mode_t mode,
+			     struct proc_dir_entry *parent,
+			     const int key)
+{
+	struct proc_dir_entry *entry = create_proc_entry(name, mode, parent);
+	if (entry) {
+		entry->proc_fops = &tmy_operations;
+		entry->data = ((u8 *) NULL) + key;
+	}
+}
+
+void tmy_proc_init(void)
+{
+	static int initialized;
+	struct proc_dir_entry *tmy_dir;
+	if (initialized)
+		return;
+	initialized = 1;
+	tmy_dir = proc_mkdir("tomoyo", NULL);
+	tmy_realpath_init();
+	tmy_find_domain(""); /* Set domainname of KERNEL domain. */
+	tmy_create_entry("query",            0600, tmy_dir,
+			 TMY_POLICY_QUERY);
+	tmy_create_entry("domain_policy",    0600, tmy_dir,
+			 TMY_POLICY_DOMAINPOLICY);
+	tmy_create_entry("system_policy",    0600, tmy_dir,
+			 TMY_POLICY_SYSTEMPOLICY);
+	tmy_create_entry("exception_policy", 0600, tmy_dir,
+			 TMY_POLICY_EXCEPTIONPOLICY);
+	tmy_create_entry(".domain_status",   0600, tmy_dir,
+			 TMY_POLICY_DOMAIN_STATUS);
+	tmy_create_entry(".process_status",  0400, tmy_dir,
+			 TMY_INFO_PROCESS_STATUS);
+	tmy_create_entry("self_domain",      0400, tmy_dir,
+			 TMY_INFO_SELFDOMAIN);
+	tmy_create_entry("meminfo",          0400, tmy_dir,
+			 TMY_INFO_MEMINFO);
+	tmy_create_entry("status",           0600, tmy_dir,
+			 TMY_STATUS);
+	tmy_create_entry("manager",          0600, tmy_dir,
+			 TMY_POLICY_MANAGER);
+	tmy_create_entry(".updates_counter", 0400, tmy_dir,
+			 TMY_INFO_UPDATESCOUNTER);
+}
