[TOMOYO] Add pivot_root handler.

This patch handles "allow_pivot_root" directive.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/pivot_root.c |  177 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 177 insertions(+)

--- /dev/null
+++ linux-2.6.32-rc1/security/tomoyo/pivot_root.c
@@ -0,0 +1,177 @@
+/*
+ * security/tomoyo/pivot_root.c
+ *
+ * Copyright (C) 2005-2009  NTT DATA CORPORATION
+ */
+#include "internal.h"
+
+/**
+ * tomoyo_audit_pivot_root_log - Audit pivot_root log.
+ *
+ * @r:          Pointer to "struct tomoyo_request_info".
+ * @new_root:   New root directory.
+ * @old_root:   Old root directory.
+ * @is_granted: True if this is a granted log.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_audit_pivot_root_log(struct tomoyo_request_info *r,
+				       const char *new_root,
+				       const char *old_root,
+				       const bool is_granted)
+{
+	if (!is_granted)
+		tomoyo_warn_log(r, "pivot_root %s %s", new_root, old_root);
+	return tomoyo_write_audit_log(is_granted, r,
+				      TOMOYO_KEYWORD_ALLOW_PIVOT_ROOT
+				      "%s %s\n", new_root, old_root);
+}
+
+/**
+ * tomoyo_pivot_root_acl - Check permission for pivot_root().
+ *
+ * @old: Pointer to "struct path".
+ * @new: Pointer to "struct path".
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+static int tomoyo_pivot_root_acl(struct path *old, struct path *new)
+{
+	struct tomoyo_request_info r;
+	struct tomoyo_obj_info obj = {
+		.path1 = *new,
+		.path2 = *old
+	};
+	int error;
+	char *old_root;
+	char *new_root;
+	struct tomoyo_path_info old_root_dir;
+	struct tomoyo_path_info new_root_dir;
+	if (!tomoyo_capable(TOMOYO_SYS_PIVOT_ROOT))
+		return -EPERM;
+	if (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_PIVOT_ROOT)
+	    == TOMOYO_CONFIG_DISABLED)
+		return 0;
+	r.obj = &obj;
+	error = -ENOENT;
+	old_root = tomoyo_realpath_from_path(old);
+	new_root = tomoyo_realpath_from_path(new);
+	if (!old_root || !new_root)
+		goto out;
+	old_root_dir.name = old_root;
+	tomoyo_fill_path_info(&old_root_dir);
+	new_root_dir.name = new_root;
+	tomoyo_fill_path_info(&new_root_dir);
+	if (!old_root_dir.is_dir || !new_root_dir.is_dir)
+		goto out;
+	do {
+		struct tomoyo_acl_info *ptr;
+		error = -EPERM;
+		list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
+			struct tomoyo_pivot_root_acl *acl;
+			if (ptr->is_deleted ||
+			    ptr->type != TOMOYO_TYPE_PIVOT_ROOT_ACL)
+				continue;
+			acl = container_of(ptr, struct tomoyo_pivot_root_acl,
+					   head);
+			if (!tomoyo_compare_name_union(&old_root_dir,
+						       &acl->old_root) ||
+			    !tomoyo_compare_name_union(&new_root_dir,
+						       &acl->new_root) ||
+			    !tomoyo_condition(&r, ptr))
+				continue;
+			r.cond = ptr->cond;
+			error = 0;
+			break;
+		}
+		tomoyo_audit_pivot_root_log(&r, new_root, old_root, !error);
+		if (!error)
+			break;
+		error = tomoyo_supervisor(&r, TOMOYO_KEYWORD_ALLOW_PIVOT_ROOT
+					  "%s %s\n",
+					  tomoyo_file_pattern(&new_root_dir),
+					  tomoyo_file_pattern(&old_root_dir));
+	} while (error == 1);
+ out:
+	kfree(old_root);
+	kfree(new_root);
+	if (r.mode != TOMOYO_CONFIG_ENFORCING)
+		error = 0;
+	return error;
+}
+
+/**
+ * tomoyo_pivot_root_permission - Check permission for pivot_root().
+ *
+ * @old_path: Pointer to "struct path".
+ * @new_path: Pointer to "struct path".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int tomoyo_pivot_root_permission(struct path *old_path, struct path *new_path)
+{
+	const int idx = tomoyo_read_lock();
+	const int error = tomoyo_pivot_root_acl(old_path, new_path);
+	tomoyo_read_unlock(idx);
+	return error;
+}
+
+/**
+ * tomoyo_write_pivot_root_policy - Write "struct tomoyo_pivot_root_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct tomoyo_domain_info".
+ * @condition: Pointer to "struct tomoyo_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int tomoyo_write_pivot_root_policy(char *data,
+				   struct tomoyo_domain_info *domain,
+				   struct tomoyo_condition *condition,
+				   const bool is_delete)
+{
+	struct tomoyo_pivot_root_acl *entry = NULL;
+	struct tomoyo_acl_info *ptr;
+	struct tomoyo_pivot_root_acl e = {
+		.head.type = TOMOYO_TYPE_PIVOT_ROOT_ACL,
+		.head.cond = condition
+	};
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	char *w[2];
+	if (!tomoyo_tokenize(data, w, sizeof(w)) || !w[1][0] ||
+	    (w[0][0] != '@' && !tomoyo_is_correct_path(w[0], 1, 0, 1)) ||
+	    (w[1][0] != '@' && !tomoyo_is_correct_path(w[1], 1, 0, 1)))
+		return -EINVAL;
+	if (!tomoyo_parse_name_union(w[1], &e.old_root) ||
+	    !tomoyo_parse_name_union(w[0], &e.new_root))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&tomoyo_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct tomoyo_pivot_root_acl *acl =
+			container_of(ptr, struct tomoyo_pivot_root_acl, head);
+		if (ptr->type != TOMOYO_TYPE_PIVOT_ROOT_ACL ||
+		    ptr->cond != condition ||
+		    tomoyo_memcmp(acl, &e, offsetof(typeof(e), old_root),
+				  sizeof(e)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && tomoyo_commit_ok(entry, &e, sizeof(e))) {
+		tomoyo_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&tomoyo_policy_lock);
+ out:
+	tomoyo_put_name_union(&e.old_root);
+	tomoyo_put_name_union(&e.new_root);
+	kfree(entry);
+	return error;
+}
