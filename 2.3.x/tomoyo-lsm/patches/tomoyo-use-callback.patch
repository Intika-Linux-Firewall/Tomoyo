[PATCH] TOMOYO: Use callback.

Use common structure and unify similar code.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/Makefile       |    2 
 security/tomoyo/common.c       |  480 +++++++++++++++++------------
 security/tomoyo/common.h       |  373 ++++++++--------------
 security/tomoyo/domain.c       |  443 ++++++++++++--------------
 security/tomoyo/file.c         |  673 ++++++++++++++++-------------------------
 security/tomoyo/group.c        |  122 +++++++
 security/tomoyo/mount.c        |   55 +--
 security/tomoyo/number_group.c |  175 ----------
 security/tomoyo/path_group.c   |  163 ---------
 9 files changed, 1049 insertions(+), 1437 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/Makefile
+++ security-testing-2.6/security/tomoyo/Makefile
@@ -1 +1 @@
-obj-y = condition.o common.o domain.o file.o gc.o load_policy.o memory.o mount.o number_group.o path_group.o realpath.o securityfs_if.o tomoyo.o util.o
+obj-y = condition.o common.o domain.o file.o gc.o group.o load_policy.o memory.o mount.o realpath.o securityfs_if.o tomoyo.o util.o
--- security-testing-2.6.orig/security/tomoyo/common.c
+++ security-testing-2.6/security/tomoyo/common.c
@@ -85,7 +85,7 @@ static const char *tomoyo_yesno(const un
  * Returns true on success, false otherwise.
  */
 static bool tomoyo_print_name_union(struct tomoyo_io_buffer *head,
-				 const struct tomoyo_name_union *ptr)
+				    const struct tomoyo_name_union *ptr)
 {
 	int pos = head->read_avail;
 	if (pos && head->read_buf[pos - 1] == ' ')
@@ -113,6 +113,40 @@ static bool tomoyo_print_name_union_quot
 	return tomoyo_io_printf(head, "\"%s\"", ptr->filename->name);
 }
 
+static void tomoyo_print_number(char *buffer, int buffer_len,
+			     const struct tomoyo_number_union *ptr)
+{
+	int i;
+	unsigned long min = ptr->values[0];
+	const unsigned long max = ptr->values[1];
+	u8 min_type = ptr->min_type;
+	const u8 max_type = ptr->min_type;
+	memset(buffer, 0, buffer_len);
+	buffer_len -= 2;
+	for (i = 0; i < 2; i++) {
+		int len;
+		switch (min_type) {
+		case TOMOYO_VALUE_TYPE_HEXADECIMAL:
+			snprintf(buffer, buffer_len, "0x%lX", min);
+			break;
+		case TOMOYO_VALUE_TYPE_OCTAL:
+			snprintf(buffer, buffer_len, "0%lo", min);
+			break;
+		default:
+			snprintf(buffer, buffer_len, "%lu", min);
+			break;
+		}
+		if (min == max && min_type == max_type)
+			break;
+		len = strlen(buffer);
+		buffer[len++] = '-';
+		buffer += len;
+		buffer_len -= len;
+		min_type = max_type;
+		min = max;
+	}
+}
+
 /**
  * tomoyo_print_number_union_common - Print a tomoyo_number_union.
  *
@@ -514,10 +548,16 @@ static int tomoyo_read_profile(struct to
  *
  * # cat /sys/kernel/security/tomoyo/manager
  */
-LIST_HEAD(tomoyo_policy_manager_list);
+
+static bool tomoyo_same_manager(const struct tomoyo_acl_head *a,
+				const struct tomoyo_acl_head *b)
+{
+	return container_of(a, struct tomoyo_manager, head)->manager
+		== container_of(b, struct tomoyo_manager, head)->manager;
+}
 
 /**
- * tomoyo_update_manager_entry - Add a manager entry.
+ * tomoyo_update_manager - Add a manager entry.
  *
  * @manager:   The path to manager or the domainnamme.
  * @is_delete: True if it is a delete request.
@@ -526,50 +566,29 @@ LIST_HEAD(tomoyo_policy_manager_list);
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_update_manager_entry(const char *manager,
-				       const bool is_delete)
+static int tomoyo_update_manager(const char *manager, const bool is_delete)
 {
-	struct tomoyo_policy_manager_entry *ptr;
-	struct tomoyo_policy_manager_entry e = { };
+	struct tomoyo_manager e = { };
 	int error = is_delete ? -ENOENT : -ENOMEM;
-
-	if (tomoyo_is_domain_def(manager)) {
-		if (!tomoyo_is_correct_domain(manager))
+	if (tomoyo_domain_def(manager)) {
+		if (!tomoyo_correct_domain(manager))
 			return -EINVAL;
 		e.is_domain = true;
 	} else {
-		if (!tomoyo_is_correct_path(manager))
+		if (!tomoyo_correct_path(manager))
 			return -EINVAL;
 	}
 	e.manager = tomoyo_get_name(manager);
 	if (!e.manager)
-		return -ENOMEM;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &tomoyo_policy_manager_list, list) {
-		if (ptr->manager != e.manager)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_policy_manager_entry *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &tomoyo_policy_manager_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
- out:
+		return error;
+	error = tomoyo_update_policy(&e.head, sizeof(e), is_delete,
+				     TOMOYO_ID_MANAGER, tomoyo_same_manager);
 	tomoyo_put_name(e.manager);
 	return error;
 }
 
 /**
- * tomoyo_write_manager_policy - Write manager policy.
+ * tomoyo_write_manager - Write manager policy.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
  *
@@ -577,7 +596,7 @@ static int tomoyo_update_manager_entry(c
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_write_manager_policy(struct tomoyo_io_buffer *head)
+static int tomoyo_write_manager(struct tomoyo_io_buffer *head)
 {
 	char *data = head->write_buf;
 	bool is_delete = tomoyo_str_starts(&data, TOMOYO_KEYWORD_DELETE);
@@ -586,51 +605,47 @@ static int tomoyo_write_manager_policy(s
 		tomoyo_manage_by_non_root = !is_delete;
 		return 0;
 	}
-	return tomoyo_update_manager_entry(data, is_delete);
+	return tomoyo_update_manager(data, is_delete);
 }
 
 /**
- * tomoyo_read_manager_policy - Read manager policy.
+ * tomoyo_read_manager - Read manager policy.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
  *
- * Returns 0.
- *
  * Caller holds tomoyo_read_lock().
+ *
+ * Returns 0.
  */
-static int tomoyo_read_manager_policy(struct tomoyo_io_buffer *head)
+static int tomoyo_read_manager(struct tomoyo_io_buffer *head)
 {
 	struct list_head *pos;
-	bool done = true;
-
 	if (head->read_eof)
 		return 0;
 	list_for_each_cookie(pos, head->read_var2,
-			     &tomoyo_policy_manager_list) {
-		struct tomoyo_policy_manager_entry *ptr;
-		ptr = list_entry(pos, struct tomoyo_policy_manager_entry,
-				 list);
-		if (ptr->is_deleted)
+			     &tomoyo_policy_list[TOMOYO_ID_MANAGER]) {
+		struct tomoyo_manager *ptr
+			= list_entry(pos, typeof(*ptr), head.list);
+		if (ptr->head.is_deleted)
 			continue;
-		done = tomoyo_io_printf(head, "%s\n", ptr->manager->name);
-		if (!done)
-			break;
+		if (!tomoyo_io_printf(head, "%s\n", ptr->manager->name))
+			return 0;
 	}
-	head->read_eof = done;
+	head->read_eof = true;
 	return 0;
 }
 
 /**
- * tomoyo_is_policy_manager - Check whether the current process is a policy manager.
+ * tomoyo_manager - Check whether the current process is a policy manager.
  *
  * Returns true if the current process is permitted to modify policy
  * via /sys/kernel/security/tomoyo/ interface.
  *
  * Caller holds tomoyo_read_lock().
  */
-static bool tomoyo_is_policy_manager(void)
+static bool tomoyo_manager(void)
 {
-	struct tomoyo_policy_manager_entry *ptr;
+	struct tomoyo_manager *ptr;
 	const char *exe;
 	const struct task_struct *task = current;
 	const struct tomoyo_path_info *domainname = tomoyo_domain()->domainname;
@@ -640,32 +655,28 @@ static bool tomoyo_is_policy_manager(voi
 		return true;
 	if (!tomoyo_manage_by_non_root && (task->cred->uid || task->cred->euid))
 		return false;
-	list_for_each_entry_rcu(ptr, &tomoyo_policy_manager_list, list) {
-		if (!ptr->is_deleted && ptr->is_domain
-		    && !tomoyo_pathcmp(domainname, ptr->manager)) {
-			found = true;
-			break;
-		}
-	}
-	if (found)
-		return true;
 	exe = tomoyo_get_exe();
-	if (!exe)
-		return false;
-	list_for_each_entry_rcu(ptr, &tomoyo_policy_manager_list, list) {
-		if (!ptr->is_deleted && !ptr->is_domain
-		    && !strcmp(exe, ptr->manager->name)) {
-			found = true;
-			break;
+	list_for_each_entry_rcu(ptr, &tomoyo_policy_list[TOMOYO_ID_MANAGER],
+				head.list) {
+		if (ptr->head.is_deleted)
+			continue;
+		if (ptr->is_domain) {
+			if (tomoyo_pathcmp(domainname, ptr->manager))
+				continue;
+		} else {
+			if (!exe || strcmp(exe, ptr->manager->name))
+				continue;
 		}
+		found = true;
+		break;
 	}
 	if (!found) { /* Reduce error messages. */
-		static pid_t last_pid;
+		static pid_t tomoyo_last_pid;
 		const pid_t pid = current->pid;
-		if (last_pid != pid) {
+		if (tomoyo_last_pid != pid) {
 			printk(KERN_WARNING "%s ( %s ) is not permitted to "
 			       "update policies.\n", domainname->name, exe);
-			last_pid = pid;
+			tomoyo_last_pid = pid;
 		}
 	}
 	kfree(exe);
@@ -673,7 +684,7 @@ static bool tomoyo_is_policy_manager(voi
 }
 
 /**
- * tomoyo_is_select_one - Parse select command.
+ * tomoyo_select_one - Parse select command.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
  * @data: String to parse.
@@ -682,7 +693,7 @@ static bool tomoyo_is_policy_manager(voi
  *
  * Caller holds tomoyo_read_lock().
  */
-static bool tomoyo_is_select_one(struct tomoyo_io_buffer *head,
+static bool tomoyo_select_one(struct tomoyo_io_buffer *head,
 				 const char *data)
 {
 	unsigned int pid;
@@ -703,7 +714,7 @@ static bool tomoyo_is_select_one(struct 
 		read_unlock(&tasklist_lock);
 		rcu_read_unlock();
 	} else if (!strncmp(data, "domain=", 7)) {
-		if (tomoyo_is_domain_def(data + 7))
+		if (tomoyo_domain_def(data + 7))
 			domain = tomoyo_find_domain(data + 7);
 	} else
 		return false;
@@ -766,7 +777,7 @@ static int tomoyo_delete_domain(char *do
 }
 
 /**
- * tomoyo_write_domain_policy2 - Write domain policy.
+ * tomoyo_write_domain2 - Write domain policy.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
  *
@@ -774,14 +785,13 @@ static int tomoyo_delete_domain(char *do
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_write_domain_policy2(char *data,
-				       struct tomoyo_domain_info *domain,
-				       struct tomoyo_condition *cond,
-				       const bool is_delete)
+static int tomoyo_write_domain2(char *data, struct tomoyo_domain_info *domain,
+				struct tomoyo_condition *cond,
+				const bool is_delete)
 {
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_ALLOW_MOUNT))
-                return tomoyo_write_mount_policy(data, domain, cond, is_delete);
-	return tomoyo_write_file_policy(data, domain, cond, is_delete);
+                return tomoyo_write_mount(data, domain, cond, is_delete);
+	return tomoyo_write_file(data, domain, cond, is_delete);
 }
 
 /**
@@ -812,7 +822,7 @@ static char *tomoyo_find_condition_part(
 }
 
 /**
- * tomoyo_write_domain_policy - Write domain policy.
+ * tomoyo_write_domain - Write domain policy.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
  *
@@ -820,7 +830,7 @@ static char *tomoyo_find_condition_part(
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_write_domain_policy(struct tomoyo_io_buffer *head)
+static int tomoyo_write_domain(struct tomoyo_io_buffer *head)
 {
 	char *data = head->write_buf;
 	struct tomoyo_domain_info *domain = head->write_var1;
@@ -835,12 +845,12 @@ static int tomoyo_write_domain_policy(st
 		is_delete = true;
 	else if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_SELECT))
 		is_select = true;
-	if (is_select && tomoyo_is_select_one(head, data))
+	if (is_select && tomoyo_select_one(head, data))
 		return 0;
 	/* Don't allow updating policies by non manager programs. */
-	if (!tomoyo_is_policy_manager())
+	if (!tomoyo_manager())
 		return -EPERM;
-	if (tomoyo_is_domain_def(data)) {
+	if (tomoyo_domain_def(data)) {
 		domain = NULL;
 		if (is_delete)
 			tomoyo_delete_domain(data);
@@ -878,7 +888,7 @@ static int tomoyo_write_domain_policy(st
 		if (!cond)
 			return -EINVAL;
 	}
-	error = tomoyo_write_domain_policy2(data, domain, cond, is_delete);
+	error = tomoyo_write_domain2(data, domain, cond, is_delete);
 	if (cond)
 		tomoyo_put_condition(cond);
 	return error;
@@ -898,8 +908,8 @@ static bool tomoyo_print_condition(struc
 	const struct tomoyo_condition_element *condp;
 	const struct tomoyo_number_union *numbers_p;
 	const struct tomoyo_name_union *names_p;
-	const struct tomoyo_argv_entry *argv;
-	const struct tomoyo_envp_entry *envp;
+	const struct tomoyo_argv *argv;
+	const struct tomoyo_envp *envp;
 	u16 condc;
 	u16 i;
 	char buffer[32];
@@ -910,8 +920,8 @@ static bool tomoyo_print_condition(struc
 	numbers_p = (const struct tomoyo_number_union *) (condp + condc);
 	names_p = (const struct tomoyo_name_union *)
 		(numbers_p + cond->numbers_count);
-	argv = (const struct tomoyo_argv_entry *) (names_p + cond->names_count);
-	envp = (const struct tomoyo_envp_entry *) (argv + cond->argc);
+	argv = (const struct tomoyo_argv *) (names_p + cond->names_count);
+	envp = (const struct tomoyo_envp *) (argv + cond->argc);
 	memset(buffer, 0, sizeof(buffer));
 	if (condc && !tomoyo_io_printf(head, "%s", " if"))
 		goto out;
@@ -1145,8 +1155,6 @@ static bool tomoyo_print_mount_acl(struc
 				   const struct tomoyo_condition *cond)
 {
 	const int pos = head->read_avail;
-	if (ptr->is_deleted)
-		return true;
 	if (!tomoyo_io_printf(head, TOMOYO_KEYWORD_ALLOW_MOUNT) ||
 	    !tomoyo_print_name_union(head, &ptr->dev_name) ||
 	    !tomoyo_print_name_union(head, &ptr->dir_name) ||
@@ -1173,6 +1181,8 @@ static bool tomoyo_print_entry(struct to
 	const struct tomoyo_condition *cond = ptr->cond;
 	const u8 acl_type = ptr->type;
 
+	if (ptr->is_deleted)
+		return true;
 	if (acl_type == TOMOYO_TYPE_PATH_ACL) {
 		struct tomoyo_path_acl *acl
 			= container_of(ptr, struct tomoyo_path_acl, head);
@@ -1205,7 +1215,7 @@ static bool tomoyo_print_entry(struct to
 }
 
 /**
- * tomoyo_read_domain_policy - Read domain policy.
+ * tomoyo_read_domain - Read domain policy.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
  *
@@ -1213,7 +1223,7 @@ static bool tomoyo_print_entry(struct to
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_read_domain_policy(struct tomoyo_io_buffer *head)
+static int tomoyo_read_domain(struct tomoyo_io_buffer *head)
 {
 	struct list_head *dpos;
 	struct list_head *apos;
@@ -1397,7 +1407,7 @@ static int tomoyo_read_pid(struct tomoyo
 }
 
 /**
- * tomoyo_write_exception_policy - Write exception policy.
+ * tomoyo_write_exception - Write exception policy.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
  *
@@ -1405,108 +1415,200 @@ static int tomoyo_read_pid(struct tomoyo
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_write_exception_policy(struct tomoyo_io_buffer *head)
+static int tomoyo_write_exception(struct tomoyo_io_buffer *head)
 {
 	char *data = head->write_buf;
 	bool is_delete = tomoyo_str_starts(&data, TOMOYO_KEYWORD_DELETE);
 
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_KEEP_DOMAIN))
-		return tomoyo_write_domain_keeper_policy(data, false,
-							 is_delete);
+		return tomoyo_write_domain_keeper(data, false, is_delete);
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_NO_KEEP_DOMAIN))
-		return tomoyo_write_domain_keeper_policy(data, true, is_delete);
+		return tomoyo_write_domain_keeper(data, true, is_delete);
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_INITIALIZE_DOMAIN))
-		return tomoyo_write_domain_initializer_policy(data, false,
+		return tomoyo_write_domain_initializer(data, false,
 							      is_delete);
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_NO_INITIALIZE_DOMAIN))
-		return tomoyo_write_domain_initializer_policy(data, true,
+		return tomoyo_write_domain_initializer(data, true,
 							      is_delete);
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_AGGREGATOR))
-		return tomoyo_write_aggregator_policy(data, is_delete);
+		return tomoyo_write_aggregator(data, is_delete);
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_ALLOW_READ))
-		return tomoyo_write_globally_readable_policy(data, is_delete);
+		return tomoyo_write_globally_readable(data, is_delete);
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_FILE_PATTERN))
-		return tomoyo_write_pattern_policy(data, is_delete);
+		return tomoyo_write_pattern(data, is_delete);
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_DENY_REWRITE))
-		return tomoyo_write_no_rewrite_policy(data, is_delete);
+		return tomoyo_write_no_rewrite(data, is_delete);
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_PATH_GROUP))
-		return tomoyo_write_path_group_policy(data, is_delete);
+		return tomoyo_write_group(data, is_delete, TOMOYO_PATH_GROUP);
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_NUMBER_GROUP))
-		return tomoyo_write_number_group_policy(data, is_delete);
+		return tomoyo_write_group(data, is_delete, TOMOYO_NUMBER_GROUP);
 	return -EINVAL;
 }
 
+
 /**
- * tomoyo_read_exception_policy - Read exception policy.
+ * tomoyo_read_group - Read "struct tomoyo_path_group"/"struct tomoyo_number_group" list.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
+ * @idx:  Index number.
  *
- * Returns 0 on success, -EINVAL otherwise.
+ * Returns true on success, false otherwise.
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_read_exception_policy(struct tomoyo_io_buffer *head)
+static bool tomoyo_read_group(struct tomoyo_io_buffer *head, const int idx)
 {
-	if (!head->read_eof) {
-		switch (head->read_step) {
-		case 0:
-			head->read_var2 = NULL;
-			head->read_step = 1;
-		case 1:
-			if (!tomoyo_read_domain_keeper_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 2;
-		case 2:
-			if (!tomoyo_read_globally_readable_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 3;
-		case 3:
-			head->read_var2 = NULL;
-			head->read_step = 4;
-		case 4:
-			if (!tomoyo_read_domain_initializer_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 5;
-		case 5:
-			head->read_var2 = NULL;
-			head->read_step = 6;
-		case 6:
-			if (!tomoyo_read_aggregator_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 7;
-		case 7:
-			if (!tomoyo_read_file_pattern(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 8;
-		case 8:
-			if (!tomoyo_read_no_rewrite_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 9;
-		case 9:
-			if (!tomoyo_read_path_group_policy(head))
-				break;
-			head->read_var1 = NULL;
-			head->read_var2 = NULL;
-			head->read_step = 10;
-		case 10:
-			if (!tomoyo_read_number_group_policy(head))
-				break;
-			head->read_var1 = NULL;
-			head->read_var2 = NULL;
-			head->read_step = 11;
-		case 11:
-			head->read_eof = true;
+	struct list_head *gpos;
+	struct list_head *mpos;
+	const char *w[3] = { "", "", "" };
+	if (idx == TOMOYO_PATH_GROUP)
+		w[0] = TOMOYO_KEYWORD_PATH_GROUP;
+	else if (idx == TOMOYO_NUMBER_GROUP)
+		w[0] = TOMOYO_KEYWORD_NUMBER_GROUP;
+	list_for_each_cookie(gpos, head->read_var1, &tomoyo_group_list[idx]) {
+		struct tomoyo_group *group =
+			list_entry(gpos, struct tomoyo_group, head.list);
+		w[1] = group->group_name->name;
+		list_for_each_cookie(mpos, head->read_var2,
+				     &group->member_list) {
+			char buffer[128];
+			struct tomoyo_acl_head *ptr =
+				list_entry(mpos, struct tomoyo_acl_head, list);
+			if (ptr->is_deleted)
+				continue;
+			if (idx == TOMOYO_PATH_GROUP) {
+				w[2] = container_of(ptr, struct tomoyo_path_group,
+						    head)->member_name->name;
+			} else if (idx == TOMOYO_NUMBER_GROUP) {
+				w[2] = buffer;
+				tomoyo_print_number(buffer, sizeof(buffer),
+						    &container_of
+						    (ptr, struct tomoyo_number_group,
+						     head)->number);
+			}
+			if (!tomoyo_io_printf(head, "%s%s %s\n", w[0], w[1],
+					      w[2]))
+				return false;
+		}
+	}
+	return true;
+}
+
+/**
+ * tomoyo_read_policy - Read "struct tomoyo_..." list.
+ *
+ * @head: Pointer to "struct tomoyo_io_buffer".
+ * @idx:  Index number.
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+static bool tomoyo_read_policy(struct tomoyo_io_buffer *head, const int idx)
+{
+	struct list_head *pos;
+	list_for_each_cookie(pos, head->read_var2, &tomoyo_policy_list[idx]) {
+		const char *w[4] = { "", "", "", "" };
+		struct tomoyo_acl_head *acl = container_of(pos, typeof(*acl),
+							   list);
+		if (acl->is_deleted)
+			continue;
+		switch (idx) {
+		case TOMOYO_ID_DOMAIN_KEEPER:
+			{
+				struct tomoyo_domain_keeper *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = ptr->is_not ?
+					TOMOYO_KEYWORD_NO_KEEP_DOMAIN :
+					TOMOYO_KEYWORD_KEEP_DOMAIN;
+				if (ptr->program) {
+					w[1] = ptr->program->name;
+					w[2] = " from ";
+				}
+				w[3] = ptr->domainname->name;
+			}
+			break;
+		case TOMOYO_ID_DOMAIN_INITIALIZER:
+			{
+				struct tomoyo_domain_initializer *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = ptr->is_not ?
+					TOMOYO_KEYWORD_NO_INITIALIZE_DOMAIN :
+					TOMOYO_KEYWORD_INITIALIZE_DOMAIN;
+				w[1] = ptr->program->name;
+				if (ptr->domainname) {
+					w[2] = " from ";
+					w[3] = ptr->domainname->name;
+				}
+			}
+			break;
+		case TOMOYO_ID_AGGREGATOR:
+			{
+				struct tomoyo_aggregator *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = TOMOYO_KEYWORD_AGGREGATOR;
+				w[1] = ptr->original_name->name;
+				w[2] = " ";
+				w[3] = ptr->aggregated_name->name;
+			}
+			break;
+		case TOMOYO_ID_PATTERN:
+			{
+				struct tomoyo_pattern *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = TOMOYO_KEYWORD_FILE_PATTERN;
+				w[1] = ptr->pattern->name;
+			}
+			break;
+		case TOMOYO_ID_NO_REWRITE:
+			{
+				struct tomoyo_no_rewrite *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = TOMOYO_KEYWORD_DENY_REWRITE;
+				w[1] = ptr->pattern->name;
+			}
+			break;
+		case TOMOYO_ID_GLOBALLY_READABLE:
+			{
+				struct tomoyo_globally_readable_file *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = TOMOYO_KEYWORD_ALLOW_READ;
+				w[1] = ptr->filename->name;
+			}
 			break;
 		default:
-			return -EINVAL;
+			continue;
 		}
+		if (!tomoyo_io_printf(head, "%s%s%s%s\n", w[0], w[1], w[2], w[3]))
+			return false;
 	}
+	return true;
+}
+
+/**
+ * tomoyo_read_exception - Read exception policy.
+ *
+ * @head: Pointer to "struct tomoyo_io_buffer".
+ *
+ * Caller holds tomoyo_read_lock().
+ *
+ * Returns 0.
+ */
+static int tomoyo_read_exception(struct tomoyo_io_buffer *head)
+{
+	if (head->read_eof)
+		return 0;
+	while (head->read_step < TOMOYO_MAX_POLICY &&
+	       tomoyo_read_policy(head, head->read_step))
+		head->read_step++;
+	if (head->read_step < TOMOYO_MAX_POLICY)
+		return 0;
+	while (head->read_step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP &&
+	       tomoyo_read_group(head, head->read_step - TOMOYO_MAX_POLICY))
+		head->read_step++;
+	if (head->read_step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP)
+		return 0;
+	head->read_eof = true;
 	return 0;
 }
 
@@ -1583,7 +1685,7 @@ static char *tomoyo_init_audit_log(int *
  *
  * Returns true on success, false otherwise.
  */
-static bool tomoyo_get_argv0(struct tomoyo_execve_entry *ee)
+static bool tomoyo_get_argv0(struct tomoyo_execve *ee)
 {
 	struct linux_binprm *bprm = ee->bprm;
 	char *arg_ptr = ee->tmp;
@@ -1637,7 +1739,7 @@ static bool tomoyo_get_argv0(struct tomo
  * Returns pointer to "struct tomoyo_condition" on success, NULL otherwise.
  */
 static struct tomoyo_condition *tomoyo_get_execute_condition
-(struct tomoyo_execve_entry *ee)
+(struct tomoyo_execve *ee)
 {
 	struct tomoyo_condition *cond;
 	char *buf;
@@ -1685,7 +1787,7 @@ static DECLARE_WAIT_QUEUE_HEAD(tomoyo_qu
 static DEFINE_SPINLOCK(tomoyo_query_list_lock);
 
 /* Structure for query. */
-struct tomoyo_query_entry {
+struct tomoyo_query {
 	struct list_head list;
 	char *query;
 	int query_len;
@@ -1721,7 +1823,7 @@ int tomoyo_supervisor(struct tomoyo_requ
 	int pos;
 	int len;
 	static unsigned int tomoyo_serial;
-	struct tomoyo_query_entry *tomoyo_query_entry = NULL;
+	struct tomoyo_query *tomoyo_query_entry = NULL;
 	bool quota_exceeded = false;
 	char *header;
 	switch (r->mode) {
@@ -1744,7 +1846,7 @@ int tomoyo_supervisor(struct tomoyo_requ
 			cond = tomoyo_get_execute_condition(r->ee);
 		else
 			cond = NULL;
-		tomoyo_write_domain_policy2(buffer, r->domain, cond, false);
+		tomoyo_write_domain2(buffer, r->domain, cond, false);
 		tomoyo_put_condition(cond);
 		kfree(buffer);
 		/* fall through */
@@ -1847,9 +1949,8 @@ static int tomoyo_poll_query(struct file
 	for (i = 0; i < 2; i++) {
 		spin_lock(&tomoyo_query_list_lock);
 		list_for_each(tmp, &tomoyo_query_list) {
-			struct tomoyo_query_entry *ptr
-				= list_entry(tmp, struct tomoyo_query_entry,
-					     list);
+			struct tomoyo_query *ptr
+				= list_entry(tmp, typeof(*ptr), list);
 			if (ptr->answer)
 				continue;
 			found = true;
@@ -1887,8 +1988,7 @@ static int tomoyo_read_query(struct tomo
 	}
 	spin_lock(&tomoyo_query_list_lock);
 	list_for_each(tmp, &tomoyo_query_list) {
-		struct tomoyo_query_entry *ptr
-			= list_entry(tmp, struct tomoyo_query_entry, list);
+		struct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);
 		if (ptr->answer)
 			continue;
 		if (pos++ != head->read_step)
@@ -1907,8 +2007,7 @@ static int tomoyo_read_query(struct tomo
 	pos = 0;
 	spin_lock(&tomoyo_query_list_lock);
 	list_for_each(tmp, &tomoyo_query_list) {
-		struct tomoyo_query_entry *ptr
-			= list_entry(tmp, struct tomoyo_query_entry, list);
+		struct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);
 		if (ptr->answer)
 			continue;
 		if (pos++ != head->read_step)
@@ -1948,8 +2047,7 @@ static int tomoyo_write_answer(struct to
 	unsigned int answer;
 	spin_lock(&tomoyo_query_list_lock);
 	list_for_each(tmp, &tomoyo_query_list) {
-		struct tomoyo_query_entry *ptr
-			= list_entry(tmp, struct tomoyo_query_entry, list);
+		struct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);
 		ptr->timer = 0;
 	}
 	spin_unlock(&tomoyo_query_list_lock);
@@ -1957,8 +2055,7 @@ static int tomoyo_write_answer(struct to
 		return -EINVAL;
 	spin_lock(&tomoyo_query_list_lock);
 	list_for_each(tmp, &tomoyo_query_list) {
-		struct tomoyo_query_entry *ptr
-			= list_entry(tmp, struct tomoyo_query_entry, list);
+		struct tomoyo_query *ptr = list_entry(tmp, typeof(*ptr), list);
 		if (ptr->serial != serial)
 			continue;
 		if (!ptr->answer)
@@ -2027,13 +2124,13 @@ int tomoyo_open_control(const u8 type, s
 	switch (type) {
 	case TOMOYO_DOMAINPOLICY:
 		/* /sys/kernel/security/tomoyo/domain_policy */
-		head->write = tomoyo_write_domain_policy;
-		head->read = tomoyo_read_domain_policy;
+		head->write = tomoyo_write_domain;
+		head->read = tomoyo_read_domain;
 		break;
 	case TOMOYO_EXCEPTIONPOLICY:
 		/* /sys/kernel/security/tomoyo/exception_policy */
-		head->write = tomoyo_write_exception_policy;
-		head->read = tomoyo_read_exception_policy;
+		head->write = tomoyo_write_exception;
+		head->read = tomoyo_read_exception;
 		break;
 	case TOMOYO_SELFDOMAIN:
 		/* /sys/kernel/security/tomoyo/self_domain */
@@ -2072,8 +2169,8 @@ int tomoyo_open_control(const u8 type, s
 		break;
 	case TOMOYO_MANAGER:
 		/* /sys/kernel/security/tomoyo/manager */
-		head->write = tomoyo_write_manager_policy;
-		head->read = tomoyo_read_manager_policy;
+		head->write = tomoyo_write_manager;
+		head->read = tomoyo_read_manager;
 		break;
 	}
 	if (!(file->f_mode & FMODE_READ)) {
@@ -2218,8 +2315,7 @@ int tomoyo_write_control(struct file *fi
 		return -EFAULT;
 	/* Don't allow updating policies by non manager programs. */
 	if (head->write != tomoyo_write_pid &&
-	    head->write != tomoyo_write_domain_policy &&
-	    !tomoyo_is_policy_manager())
+	    head->write != tomoyo_write_domain && !tomoyo_manager())
 		return -EPERM;
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -111,6 +111,8 @@ enum tomoyo_path_acl_index {
 	TOMOYO_MAX_PATH_OPERATION
 };
 
+#define TOMOYO_RW_MASK ((1 << TOMOYO_TYPE_READ) | (1 << TOMOYO_TYPE_WRITE))
+
 enum tomoyo_path_number3_acl_index {
 	TOMOYO_TYPE_MKBLOCK,
 	TOMOYO_TYPE_MKCHAR,
@@ -230,10 +232,20 @@ struct tomoyo_condition_element {
 	bool equals;
 };
 
-/* Structure for " if " part. */
-struct tomoyo_condition {
+/* Common header for holding ACL entries. */
+struct tomoyo_acl_head {
+	struct list_head list;
+	bool is_deleted;
+} __attribute__((__packed__));
+
+struct tomoyo_shared_acl_head {
 	struct list_head list;
 	atomic_t users;
+} __attribute__((__packed__));
+
+/* Structure for " if " part. */
+struct tomoyo_condition {
+	struct tomoyo_shared_acl_head head;
 	u32 size;
 	u16 condc;
 	u16 numbers_count;
@@ -262,7 +274,7 @@ struct tomoyo_execve_entry;
  */
 struct tomoyo_request_info {
 	struct tomoyo_domain_info *domain;
-	struct tomoyo_execve_entry *ee;
+	struct tomoyo_execve *ee;
 	u8 retry;
 	u8 profile;
 	u8 mode; /* One of tomoyo_mode_index . */
@@ -298,61 +310,60 @@ struct tomoyo_path_info {
 };
 
 /*
- * tomoyo_name_entry is a structure which is used for linking
+ * tomoyo_name is a structure which is used for linking
  * "struct tomoyo_path_info" into tomoyo_name_list .
  */
-struct tomoyo_name_entry {
-	struct list_head list;
-	atomic_t users;
+struct tomoyo_name {
+	struct tomoyo_shared_acl_head head;
 	struct tomoyo_path_info entry;
 };
 
 struct tomoyo_name_union {
 	const struct tomoyo_path_info *filename;
-	struct tomoyo_path_group *group;
+	struct tomoyo_group *group;
 	u8 is_group;
 };
 
 struct tomoyo_number_union {
 	unsigned long values[2];
-	struct tomoyo_number_group *group;
+	struct tomoyo_group *group;
 	u8 min_type;
 	u8 max_type;
 	u8 is_group;
 };
 
-/* Structure for "path_group" directive. */
-struct tomoyo_path_group {
-	struct list_head list;
-	const struct tomoyo_path_info *group_name;
-	struct list_head member_list;
-	atomic_t users;
+enum tomoyo_shared_acl_id {
+	TOMOYO_CONDITION_LIST,
+	TOMOYO_MAX_LIST
 };
 
-/* Structure for "number_group" directive. */
-struct tomoyo_number_group {
-	struct list_head list;
+enum tomoyo_group_id {
+	TOMOYO_PATH_GROUP,
+	TOMOYO_NUMBER_GROUP,
+	TOMOYO_MAX_GROUP
+};
+
+/* Structure for "path_group"/"number_group" directive. */
+struct tomoyo_group {
+	struct tomoyo_shared_acl_head head;
 	const struct tomoyo_path_info *group_name;
 	struct list_head member_list;
-	atomic_t users;
 };
 
 /* Structure for "path_group" directive. */
-struct tomoyo_path_group_member {
-	struct list_head list;
-	bool is_deleted;
+struct tomoyo_path_group {
+	struct tomoyo_acl_head head;
 	const struct tomoyo_path_info *member_name;
 };
 
 /* Structure for "number_group" directive. */
-struct tomoyo_number_group_member {
-	struct list_head list;
-	bool is_deleted;
+struct tomoyo_number_group {
+	struct tomoyo_acl_head head;
 	struct tomoyo_number_union number;
 };
 
 /* Structure for execve() operation. */
-struct tomoyo_execve_entry {
+struct tomoyo_execve {
 	struct tomoyo_request_info r;
 	struct linux_binprm *bprm;
 	int reader_idx;
@@ -370,9 +381,10 @@ struct tomoyo_execve_entry {
  *  (2) "cond" which tells optional conditions for this entry. Maybe NULL.
  *  (3) "type" which tells type of the entry (either
  *      "struct tomoyo_path_acl" or "struct tomoyo_path2_acl").
+ *  (4) "is_deleted" is boolean.
  *
  * Packing "struct tomoyo_acl_info" allows
- * "struct tomoyo_path_acl" to embed "u8" + "u16" and
+ * "struct tomoyo_path_acl" to embed "u16" and
  * "struct tomoyo_path2_acl" to embed "u8"
  * without enlarging their structure size.
  */
@@ -380,6 +392,7 @@ struct tomoyo_acl_info {
 	struct list_head list;
 	struct tomoyo_condition *cond;
 	u8 type;
+	bool is_deleted;
 } __packed;
 
 /*
@@ -428,14 +441,14 @@ struct tomoyo_domain_info {
 };
 
 /* Structure for argv[]. */
-struct tomoyo_argv_entry {
+struct tomoyo_argv {
 	unsigned int index;
 	const struct tomoyo_path_info *value;
 	bool is_not;
 };
 
 /* Structure for envp[]. */
-struct tomoyo_envp_entry {
+struct tomoyo_envp {
 	const struct tomoyo_path_info *name;
 	const struct tomoyo_path_info *value;
 	bool is_not;
@@ -532,17 +545,15 @@ struct tomoyo_path2_acl {
  * It has following fields.
  *
  *  (1) "head" which is a "struct tomoyo_acl_info".
- *  (2) "is_deleted" is boolean.
- *  (3) "dev_name" is the device name.
- *  (4) "dir_name" is the mount point.
- *  (5) "flags" is the mount flags.
+ *  (2) "dev_name" is the device name.
+ *  (3) "dir_name" is the mount point.
+ *  (4) "flags" is the mount flags.
  *
  * Directives held by this structure are "allow_rename", "allow_link" and
  * "allow_pivot_root".
  */
 struct tomoyo_mount_acl {
 	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_MOUNT_ACL */
-	bool is_deleted;
 	struct tomoyo_name_union dev_name;
 	struct tomoyo_name_union dir_name;
 	struct tomoyo_name_union fs_type;
@@ -611,7 +622,7 @@ struct tomoyo_io_buffer {
 };
 
 /*
- * tomoyo_globally_readable_file_entry is a structure which is used for holding
+ * tomoyo_globally_readable_file is a structure which is used for holding
  * "allow_read" entries.
  * It has following fields.
  *
@@ -620,14 +631,14 @@ struct tomoyo_io_buffer {
  *  (3) "is_deleted" is a bool which is true if marked as deleted, false
  *      otherwise.
  */
-struct tomoyo_globally_readable_file_entry {
-	struct list_head list;
-	const struct tomoyo_path_info *filename;
+struct tomoyo_globally_readable_file {
+	struct tomoyo_acl_head head;
 	bool is_deleted;
+	const struct tomoyo_path_info *filename;
 };
 
 /*
- * tomoyo_pattern_entry is a structure which is used for holding
+ * tomoyo_pattern is a structure which is used for holding
  * "tomoyo_pattern_list" entries.
  * It has following fields.
  *
@@ -637,14 +648,13 @@ struct tomoyo_globally_readable_file_ent
  *  (3) "is_deleted" is a bool which is true if marked as deleted, false
  *      otherwise.
  */
-struct tomoyo_pattern_entry {
-	struct list_head list;
+struct tomoyo_pattern {
+	struct tomoyo_acl_head head;
 	const struct tomoyo_path_info *pattern;
-	bool is_deleted;
 };
 
 /*
- * tomoyo_no_rewrite_entry is a structure which is used for holding
+ * tomoyo_no_rewrite is a structure which is used for holding
  * "deny_rewrite" entries.
  * It has following fields.
  *
@@ -654,14 +664,13 @@ struct tomoyo_pattern_entry {
  *  (3) "is_deleted" is a bool which is true if marked as deleted, false
  *      otherwise.
  */
-struct tomoyo_no_rewrite_entry {
-	struct list_head list;
+struct tomoyo_no_rewrite {
+	struct tomoyo_acl_head head;
 	const struct tomoyo_path_info *pattern;
-	bool is_deleted;
 };
 
 /*
- * tomoyo_domain_initializer_entry is a structure which is used for holding
+ * tomoyo_domain_initializer is a structure which is used for holding
  * "initialize_domain" and "no_initialize_domain" entries.
  * It has following fields.
  *
@@ -676,18 +685,17 @@ struct tomoyo_no_rewrite_entry {
  *  (6) "is_last_name" is a bool which is true if "domainname" is "the last
  *      component of a domainname", false otherwise.
  */
-struct tomoyo_domain_initializer_entry {
-	struct list_head list;
-	const struct tomoyo_path_info *domainname;    /* This may be NULL */
-	const struct tomoyo_path_info *program;
-	bool is_deleted;
+struct tomoyo_domain_initializer {
+	struct tomoyo_acl_head head;
 	bool is_not;       /* True if this entry is "no_initialize_domain".  */
 	/* True if the domainname is tomoyo_get_last_name(). */
 	bool is_last_name;
+	const struct tomoyo_path_info *domainname;    /* This may be NULL */
+	const struct tomoyo_path_info *program;
 };
 
 /*
- * tomoyo_domain_keeper_entry is a structure which is used for holding
+ * tomoyo_domain_keeper is a structure which is used for holding
  * "keep_domain" and "no_keep_domain" entries.
  * It has following fields.
  *
@@ -703,18 +711,17 @@ struct tomoyo_domain_initializer_entry {
  *  (6) "is_last_name" is a bool which is true if "domainname" is "the last
  *      component of a domainname", false otherwise.
  */
-struct tomoyo_domain_keeper_entry {
-	struct list_head list;
-	const struct tomoyo_path_info *domainname;
-	const struct tomoyo_path_info *program;       /* This may be NULL */
-	bool is_deleted;
+struct tomoyo_domain_keeper {
+	struct tomoyo_acl_head head;
 	bool is_not;       /* True if this entry is "no_keep_domain".        */
 	/* True if the domainname is tomoyo_get_last_name(). */
 	bool is_last_name;
+	const struct tomoyo_path_info *domainname;
+	const struct tomoyo_path_info *program;       /* This may be NULL */
 };
 
 /*
- * tomoyo_aggregator_entry is a structure which is used for holding
+ * tomoyo_aggregator is a structure which is used for holding
  * "aggregator" entries.
  * It has following fields.
  *
@@ -724,15 +731,14 @@ struct tomoyo_domain_keeper_entry {
  *  (4) "is_deleted" is a bool which is true if marked as deleted, false
  *      otherwise.
  */
-struct tomoyo_aggregator_entry {
-	struct list_head list;
+struct tomoyo_aggregator {
+	struct tomoyo_acl_head head;
 	const struct tomoyo_path_info *original_name;
 	const struct tomoyo_path_info *aggregated_name;
-	bool is_deleted;
 };
 
 /*
- * tomoyo_policy_manager_entry is a structure which is used for holding list of
+ * tomoyo_manager is a structure which is used for holding list of
  * domainnames or programs which are permitted to modify configuration via
  * /sys/kernel/security/tomoyo/ interface.
  * It has following fields.
@@ -744,12 +750,11 @@ struct tomoyo_aggregator_entry {
  *  (4) "is_deleted" is a bool which is true if marked as deleted, false
  *      otherwise.
  */
-struct tomoyo_policy_manager_entry {
-	struct list_head list;
+struct tomoyo_manager {
+	struct tomoyo_acl_head head;
+	bool is_domain;  /* True if manager is a domainname. */
 	/* A path to program or a domainname. */
 	const struct tomoyo_path_info *manager;
-	bool is_domain;  /* True if manager is a domainname. */
-	bool is_deleted; /* True if this entry is deleted. */
 };
 
 struct tomoyo_preference {
@@ -774,6 +779,22 @@ struct tomoyo_profile {
 extern asmlinkage long sys_getpid(void);
 extern asmlinkage long sys_getppid(void);
 
+int tomoyo_write_group(char *data, const bool is_delete, const u8 type);
+int tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,
+			 bool is_delete, const int idx, bool (*check_duplicate)
+			 (const struct tomoyo_acl_head *,
+			  const struct tomoyo_acl_head *));
+int tomoyo_update_group(struct tomoyo_acl_head *new_entry, const int size,
+			bool is_delete, struct tomoyo_group *group,
+			bool (*check_duplicate) (const struct tomoyo_acl_head *,
+						 const struct tomoyo_acl_head *));
+int tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,
+			 bool is_delete, struct tomoyo_domain_info *domain,
+			 bool (*check_duplicate) (const struct tomoyo_acl_info *,
+						  const struct tomoyo_acl_info *),
+			 bool (*merge_duplicate) (struct tomoyo_acl_info *,
+						  struct tomoyo_acl_info *,
+						  const bool));
 bool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,
 		      struct tomoyo_page_dump *dump);
 u8 tomoyo_parse_ulong(unsigned long *result, char **str);
@@ -815,21 +836,21 @@ int tomoyo_get_mode(const u8 profile, co
 bool tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt, ...)
 	__attribute__ ((format(printf, 2, 3)));
 /* Check whether the domainname is correct. */
-bool tomoyo_is_correct_domain(const unsigned char *domainname);
+bool tomoyo_correct_domain(const unsigned char *domainname);
 /* Check whether the token is correct. */
-bool tomoyo_is_correct_path(const char *filename);
-bool tomoyo_is_correct_word(const char *string);
+bool tomoyo_correct_path(const char *filename);
+bool tomoyo_correct_word(const char *string);
 /* Check whether the token can be a domainname. */
-bool tomoyo_is_domain_def(const unsigned char *buffer);
+bool tomoyo_domain_def(const unsigned char *buffer);
 bool tomoyo_parse_name_union(const char *filename,
 			     struct tomoyo_name_union *ptr);
-/* Check whether the given filename matches the given path_group. */
+/* Check whether the given filename matches the given group. */
 bool tomoyo_path_matches_group(const struct tomoyo_path_info *pathname,
-			       const struct tomoyo_path_group *group);
+			       const struct tomoyo_group *group);
 /* Check whether the given value matches the given number_group. */
 bool tomoyo_number_matches_group(const unsigned long min,
 				 const unsigned long max,
-				 const struct tomoyo_number_group *group);
+				 const struct tomoyo_group *group);
 /* Check whether the given filename matches the given pattern. */
 bool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,
 				 const struct tomoyo_path_info *pattern);
@@ -838,25 +859,6 @@ bool tomoyo_print_number_union(struct to
 			       const struct tomoyo_number_union *ptr);
 bool tomoyo_parse_number_union(char *data, struct tomoyo_number_union *num);
 
-/* Read "aggregator" entry in exception policy. */
-bool tomoyo_read_aggregator_policy(struct tomoyo_io_buffer *head);
-/*
- * Read "initialize_domain" and "no_initialize_domain" entry
- * in exception policy.
- */
-bool tomoyo_read_domain_initializer_policy(struct tomoyo_io_buffer *head);
-/* Read "keep_domain" and "no_keep_domain" entry in exception policy. */
-bool tomoyo_read_domain_keeper_policy(struct tomoyo_io_buffer *head);
-/* Read "file_pattern" entry in exception policy. */
-bool tomoyo_read_file_pattern(struct tomoyo_io_buffer *head);
-/* Read "path_group" entry in exception policy. */
-bool tomoyo_read_path_group_policy(struct tomoyo_io_buffer *head);
-/* Read "number_group" entry in exception policy. */
-bool tomoyo_read_number_group_policy(struct tomoyo_io_buffer *head);
-/* Read "allow_read" entry in exception policy. */
-bool tomoyo_read_globally_readable_policy(struct tomoyo_io_buffer *head);
-/* Read "deny_rewrite" entry in exception policy. */
-bool tomoyo_read_no_rewrite_policy(struct tomoyo_io_buffer *head);
 /* Tokenize a line. */
 bool tomoyo_tokenize(char *buffer, char *w[], size_t size);
 /* Write domain policy violation warning message to console? */
@@ -877,16 +879,16 @@ int tomoyo_init_request_info(struct tomo
 int tomoyo_mount_permission(char *dev_name, struct path *path, char *type,
 			    unsigned long flags, void *data_page);
 /* Create "aggregator" entry in exception policy. */
-int tomoyo_write_aggregator_policy(char *data, const bool is_delete);
+int tomoyo_write_aggregator(char *data, const bool is_delete);
 /*
  * Create "initialize_domain" and "no_initialize_domain" entry
  * in exception policy.
  */
-int tomoyo_write_domain_initializer_policy(char *data, const bool is_not,
-					   const bool is_delete);
+int tomoyo_write_domain_initializer(char *data, const bool is_not,
+				    const bool is_delete);
 /* Create "keep_domain" and "no_keep_domain" entry in exception policy. */
-int tomoyo_write_domain_keeper_policy(char *data, const bool is_not,
-				      const bool is_delete);
+int tomoyo_write_domain_keeper(char *data, const bool is_not,
+			       const bool is_delete);
 /*
  * Create "allow_read/write", "allow_execute", "allow_read", "allow_write",
  * "allow_create", "allow_unlink", "allow_mkdir", "allow_rmdir",
@@ -894,25 +896,19 @@ int tomoyo_write_domain_keeper_policy(ch
  * "allow_truncate", "allow_symlink", "allow_rewrite", "allow_rename" and
  * "allow_link" entry in domain policy.
  */
-int tomoyo_write_file_policy(char *data, struct tomoyo_domain_info *domain,
-			     struct tomoyo_condition *cond,
-			     const bool is_delete);
+int tomoyo_write_file(char *data, struct tomoyo_domain_info *domain,
+		      struct tomoyo_condition *cond, const bool is_delete);
 /* Create "allow_read" entry in exception policy. */
-int tomoyo_write_globally_readable_policy(char *data, const bool is_delete);
+int tomoyo_write_globally_readable(char *data, const bool is_delete);
 /* Create "allow_mount" entry in domain policy. */
-int tomoyo_write_mount_policy(char *data, struct tomoyo_domain_info *domain,
-			      struct tomoyo_condition *cond,
-			      const bool is_delete);
+int tomoyo_write_mount(char *data, struct tomoyo_domain_info *domain,
+		       struct tomoyo_condition *cond, const bool is_delete);
 /* Create "deny_rewrite" entry in exception policy. */
-int tomoyo_write_no_rewrite_policy(char *data, const bool is_delete);
+int tomoyo_write_no_rewrite(char *data, const bool is_delete);
 /* Create "file_pattern" entry in exception policy. */
-int tomoyo_write_pattern_policy(char *data, const bool is_delete);
-/* Create "path_group" entry in exception policy. */
-int tomoyo_write_path_group_policy(char *data, const bool is_delete);
+int tomoyo_write_pattern(char *data, const bool is_delete);
 int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
-/* Create "number_group" entry in exception policy. */
-int tomoyo_write_number_group_policy(char *data, const bool is_delete);
 /* Find a domain by the given name. */
 struct tomoyo_domain_info *tomoyo_find_domain(const char *domainname);
 /* Find or create a domain by the given name. */
@@ -920,9 +916,10 @@ struct tomoyo_domain_info *tomoyo_find_o
 							    domainname,
 							    const u8 profile);
 struct tomoyo_profile *tomoyo_profile(const u8 profile);
-/* Allocate memory for "struct tomoyo_path_group". */
-struct tomoyo_path_group *tomoyo_get_path_group(const char *group_name);
-struct tomoyo_number_group *tomoyo_get_number_group(const char *group_name);
+/*
+ * Allocate memory for "struct tomoyo_path_group"/"struct tomoyo_number_group".
+ */
+struct tomoyo_group *tomoyo_get_group(const char *group_name, const u8 type);
 
 /* Check mode for specified functionality. */
 unsigned int tomoyo_check_flags(const struct tomoyo_domain_info *domain,
@@ -999,19 +996,31 @@ void tomoyo_memory_free(void *ptr);
 /* Lock for GC. */
 extern struct srcu_struct tomoyo_ss;
 
+/* Index numbers for garbage collection. */
+enum tomoyo_gc_id {
+	TOMOYO_ID_GROUP,
+	TOMOYO_ID_PATH_GROUP,
+	TOMOYO_ID_NUMBER_GROUP,
+	TOMOYO_ID_AGGREGATOR,
+	TOMOYO_ID_DOMAIN_INITIALIZER,
+	TOMOYO_ID_DOMAIN_KEEPER,
+	TOMOYO_ID_PATTERN,
+	TOMOYO_ID_GLOBALLY_READABLE,
+	TOMOYO_ID_NO_REWRITE,
+	TOMOYO_ID_MANAGER,
+	TOMOYO_ID_CONDITION,
+	TOMOYO_ID_NAME,
+	TOMOYO_ID_ACL,
+	TOMOYO_ID_DOMAIN,
+	TOMOYO_MAX_POLICY
+};
+
 /* The list for "struct tomoyo_domain_info". */
 extern struct list_head tomoyo_domain_list;
 
-extern struct list_head tomoyo_path_group_list;
-extern struct list_head tomoyo_number_group_list;
-extern struct list_head tomoyo_domain_initializer_list;
-extern struct list_head tomoyo_domain_keeper_list;
-extern struct list_head tomoyo_aggregator_list;
-extern struct list_head tomoyo_globally_readable_list;
-extern struct list_head tomoyo_pattern_list;
-extern struct list_head tomoyo_no_rewrite_list;
-extern struct list_head tomoyo_policy_manager_list;
-extern struct list_head tomoyo_condition_list;
+extern struct list_head tomoyo_policy_list[TOMOYO_MAX_POLICY];
+extern struct list_head tomoyo_group_list[TOMOYO_MAX_GROUP];
+extern struct list_head tomoyo_shared_list[TOMOYO_MAX_LIST];
 extern struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];
 
 /* Lock for protecting policy. */
@@ -1047,25 +1056,25 @@ static inline bool tomoyo_pathcmp(const 
 }
 
 /**
- * tomoyo_is_valid - Check whether the character is a valid char.
+ * tomoyo_valid - Check whether the character is a valid char.
  *
  * @c: The character to check.
  *
  * Returns true if @c is a valid character, false otherwise.
  */
-static inline bool tomoyo_is_valid(const unsigned char c)
+static inline bool tomoyo_valid(const unsigned char c)
 {
 	return c > ' ' && c < 127;
 }
 
 /**
- * tomoyo_is_invalid - Check whether the character is an invalid char.
+ * tomoyo_invalid - Check whether the character is an invalid char.
  *
  * @c: The character to check.
  *
  * Returns true if @c is an invalid character, false otherwise.
  */
-static inline bool tomoyo_is_invalid(const unsigned char c)
+static inline bool tomoyo_invalid(const unsigned char c)
 {
 	return c && (c <= ' ' || c >= 127);
 }
@@ -1073,35 +1082,29 @@ static inline bool tomoyo_is_invalid(con
 static inline void tomoyo_put_condition(struct tomoyo_condition *cond)
 {
 	if (cond)
-		atomic_dec(&cond->users);
+		atomic_dec(&cond->head.users);
 }
 
 static inline void tomoyo_put_name(const struct tomoyo_path_info *name)
 {
 	if (name) {
-		struct tomoyo_name_entry *ptr =
-			container_of(name, struct tomoyo_name_entry, entry);
-		atomic_dec(&ptr->users);
+		struct tomoyo_name *ptr =
+			container_of(name, typeof (*ptr), entry);
+		atomic_dec(&ptr->head.users);
 	}
 }
 
-static inline void tomoyo_put_path_group(struct tomoyo_path_group *group)
-{
-	if (group)
-		atomic_dec(&group->users);
-}
-
-static inline void tomoyo_put_number_group(struct tomoyo_number_group *group)
+static inline void tomoyo_put_group(struct tomoyo_group *group)
 {
 	if (group)
-		atomic_dec(&group->users);
+		atomic_dec(&group->head.users);
 }
 
 static inline void tomoyo_add_domain_acl(struct tomoyo_domain_info *domain,
 					 struct tomoyo_acl_info *acl)
 {
 	if (acl->cond)
-		atomic_inc(&acl->cond->users);
+		atomic_inc(&acl->cond->head.users);
 	list_add_tail_rcu(&acl->list, &domain->acl_info_list);
 }
 
@@ -1116,20 +1119,20 @@ static inline struct tomoyo_domain_info 
 	return task_cred_xxx(task, security);
 }
 
-static inline bool tomoyo_is_same_acl_head(const struct tomoyo_acl_info *p1,
+static inline bool tomoyo_same_acl_head(const struct tomoyo_acl_info *p1,
 					   const struct tomoyo_acl_info *p2)
 {
 	return p1->type == p2->type && p1->cond == p2->cond;
 }
 
-static inline bool tomoyo_is_same_name_union
+static inline bool tomoyo_same_name_union
 (const struct tomoyo_name_union *p1, const struct tomoyo_name_union *p2)
 {
 	return p1->filename == p2->filename && p1->group == p2->group &&
 		p1->is_group == p2->is_group;
 }
 
-static inline bool tomoyo_is_same_number_union
+static inline bool tomoyo_same_number_union
 (const struct tomoyo_number_union *p1, const struct tomoyo_number_union *p2)
 {
 	return p1->values[0] == p2->values[0] && p1->values[1] == p2->values[1]
@@ -1137,88 +1140,6 @@ static inline bool tomoyo_is_same_number
 		p1->max_type == p2->max_type && p1->is_group == p2->is_group;
 }
 
-static inline bool tomoyo_is_same_path_acl(const struct tomoyo_path_acl *p1,
-					   const struct tomoyo_path_acl *p2)
-{
-	return tomoyo_is_same_acl_head(&p1->head, &p2->head) &&
-		tomoyo_is_same_name_union(&p1->name, &p2->name);
-}
-
-static inline bool tomoyo_is_same_path_number3_acl
-(const struct tomoyo_path_number3_acl *p1,
- const struct tomoyo_path_number3_acl *p2)
-{
-	return tomoyo_is_same_acl_head(&p1->head, &p2->head)
-		&& tomoyo_is_same_name_union(&p1->name, &p2->name)
-		&& tomoyo_is_same_number_union(&p1->mode, &p2->mode)
-		&& tomoyo_is_same_number_union(&p1->major, &p2->major)
-		&& tomoyo_is_same_number_union(&p1->minor, &p2->minor);
-}
-
-
-static inline bool tomoyo_is_same_path2_acl(const struct tomoyo_path2_acl *p1,
-					    const struct tomoyo_path2_acl *p2)
-{
-	return tomoyo_is_same_acl_head(&p1->head, &p2->head) &&
-		tomoyo_is_same_name_union(&p1->name1, &p2->name1) &&
-		tomoyo_is_same_name_union(&p1->name2, &p2->name2);
-}
-
-static inline bool tomoyo_is_same_path_number_acl
-(const struct tomoyo_path_number_acl *p1,
- const struct tomoyo_path_number_acl *p2)
-{
-	return tomoyo_is_same_acl_head(&p1->head, &p2->head)
-		&& tomoyo_is_same_name_union(&p1->name, &p2->name)
-		&& tomoyo_is_same_number_union(&p1->number, &p2->number);
-}
-
-static inline bool tomoyo_is_same_mount_acl(const struct tomoyo_mount_acl *p1,
-					    const struct tomoyo_mount_acl *p2)
-{
-	return tomoyo_is_same_acl_head(&p1->head, &p2->head) &&
-		tomoyo_is_same_name_union(&p1->dev_name, &p2->dev_name) &&
-		tomoyo_is_same_name_union(&p1->dir_name, &p2->dir_name) &&
-		tomoyo_is_same_name_union(&p1->fs_type, &p2->fs_type) &&
-		tomoyo_is_same_number_union(&p1->flags, &p2->flags);
-}
-
-static inline bool tomoyo_is_same_domain_initializer_entry
-(const struct tomoyo_domain_initializer_entry *p1,
- const struct tomoyo_domain_initializer_entry *p2)
-{
-	return p1->is_not == p2->is_not && p1->is_last_name == p2->is_last_name
-		&& p1->domainname == p2->domainname
-		&& p1->program == p2->program;
-}
-
-static inline bool tomoyo_is_same_domain_keeper_entry
-(const struct tomoyo_domain_keeper_entry *p1,
- const struct tomoyo_domain_keeper_entry *p2)
-{
-	return p1->is_not == p2->is_not && p1->is_last_name == p2->is_last_name
-		&& p1->domainname == p2->domainname
-		&& p1->program == p2->program;
-}
-
-static inline bool tomoyo_is_same_aggregator_entry
-(const struct tomoyo_aggregator_entry *p1,
- const struct tomoyo_aggregator_entry *p2)
-{
-	return p1->original_name == p2->original_name &&
-		p1->aggregated_name == p2->aggregated_name;
-}
-
-static inline bool tomoyo_is_same_condition(const struct tomoyo_condition *p1,
-					    const struct tomoyo_condition *p2)
-{
-	return p1->size == p2->size && p1->condc == p2->condc &&
-		p1->numbers_count == p2->numbers_count &&
-		p1->names_count == p2->names_count &&
-		p1->argc == p2->argc && p1->envc == p2->envc &&
-		!memcmp(p1 + 1, p2 + 1, p1->size - sizeof(*p1));
-}
-
 /**
  * list_for_each_cookie - iterate over a list with cookie.
  * @pos:        the &struct list_head to use as a loop cursor.
--- security-testing-2.6.orig/security/tomoyo/domain.c
+++ security-testing-2.6/security/tomoyo/domain.c
@@ -16,6 +16,10 @@
 /* The initial domain. */
 struct tomoyo_domain_info tomoyo_kernel_domain;
 
+struct list_head tomoyo_policy_list[TOMOYO_MAX_POLICY];
+struct list_head tomoyo_group_list[TOMOYO_MAX_GROUP];
+struct list_head tomoyo_shared_list[TOMOYO_MAX_LIST];
+
 /*
  * tomoyo_domain_list is used for holding list of domains.
  * The ->acl_info_list of "struct tomoyo_domain_info" is used for holding
@@ -73,8 +77,97 @@ const char *tomoyo_get_last_name(const s
 	return cp0;
 }
 
+int tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,
+		      bool is_delete, const int idx, bool (*check_duplicate)
+		      (const struct tomoyo_acl_head *,
+		       const struct tomoyo_acl_head *))
+{
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct tomoyo_acl_head *entry;
+	if (mutex_lock_interruptible(&tomoyo_policy_lock))
+		return -ENOMEM;
+	list_for_each_entry_rcu(entry, &tomoyo_policy_list[idx], list) {
+		if (!check_duplicate(entry, new_entry))
+			continue;
+		entry->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (error && !is_delete) {
+		entry = tomoyo_commit_ok(new_entry, size);
+		if (entry) {
+			list_add_tail_rcu(&entry->list, &tomoyo_policy_list[idx]);
+			error = 0;
+		}
+	}
+	mutex_unlock(&tomoyo_policy_lock);
+	return error;
+}
+
+int tomoyo_update_group(struct tomoyo_acl_head *new_entry, const int size,
+		     bool is_delete, struct tomoyo_group *group,
+		     bool (*check_duplicate) (const struct tomoyo_acl_head *,
+					      const struct tomoyo_acl_head *))
+{
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct tomoyo_acl_head *entry;
+	if (mutex_lock_interruptible(&tomoyo_policy_lock))
+		return -ENOMEM;
+	list_for_each_entry_rcu(entry, &group->member_list, list) {
+		if (!check_duplicate(entry, new_entry))
+			continue;
+		entry->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error) {
+		entry = tomoyo_commit_ok(new_entry, size);
+		if (entry) {
+			list_add_tail_rcu(&entry->list, &group->member_list);
+			error = 0;
+		}
+	}
+	mutex_unlock(&tomoyo_policy_lock);
+	return error;
+}
+
+int tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,
+		      bool is_delete, struct tomoyo_domain_info *domain,
+		      bool (*check_duplicate) (const struct tomoyo_acl_info *,
+					       const struct tomoyo_acl_info *),
+		      bool (*merge_duplicate) (struct tomoyo_acl_info *,
+					       struct tomoyo_acl_info *,
+					       const bool))
+{
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct tomoyo_acl_info *entry;
+
+	if (mutex_lock_interruptible(&tomoyo_policy_lock))
+		return error;
+	list_for_each_entry_rcu(entry, &domain->acl_info_list, list) {
+		if (!check_duplicate(entry, new_entry))
+			continue;
+		if (merge_duplicate)
+			entry->is_deleted = merge_duplicate(entry, new_entry,
+							    is_delete);
+		else
+			entry->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (error && !is_delete) {
+		entry = tomoyo_commit_ok(new_entry, size);
+		if (entry) {
+			tomoyo_add_domain_acl(domain, entry);
+			error = 0;
+		}
+	}
+	mutex_unlock(&tomoyo_policy_lock);
+	return error;
+}
+
 /*
- * tomoyo_domain_initializer_list is used for holding list of programs which
+ * domain_initializer_list is used for holding list of programs which
  * triggers reinitialization of domainname. Normally, a domainname is
  * monotonically getting longer. But sometimes, we restart daemon programs.
  * It would be convenient for us that "a daemon started upon system boot" and
@@ -109,10 +202,21 @@ const char *tomoyo_get_last_name(const s
  * will cause "/usr/sbin/httpd" to belong to "<kernel> /usr/sbin/httpd" domain
  * unless executed from "<kernel> /etc/rc.d/init.d/httpd" domain.
  */
-LIST_HEAD(tomoyo_domain_initializer_list);
+
+static bool tomoyo_same_domain_initializer(const struct tomoyo_acl_head *a,
+					const struct tomoyo_acl_head *b)
+{
+	const struct tomoyo_domain_initializer *p1 = container_of(a, typeof(*p1),
+							       head);
+	const struct tomoyo_domain_initializer *p2 = container_of(b, typeof(*p2),
+							       head);
+	return p1->is_not == p2->is_not && p1->is_last_name == p2->is_last_name
+		&& p1->domainname == p2->domainname
+		&& p1->program == p2->program;
+}
 
 /**
- * tomoyo_update_domain_initializer_entry - Update "struct tomoyo_domain_initializer_entry" list.
+ * tomoyo_update_domain_initializer - Update "struct tomoyo_domain_initializer" list.
  *
  * @domainname: The name of domain. May be NULL.
  * @program:    The name of program.
@@ -123,22 +227,20 @@ LIST_HEAD(tomoyo_domain_initializer_list
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_update_domain_initializer_entry(const char *domainname,
-						  const char *program,
-						  const bool is_not,
-						  const bool is_delete)
+static int tomoyo_update_domain_initializer(const char *domainname,
+					 const char *program,
+					 const bool is_not,
+					 const bool is_delete)
 {
-	struct tomoyo_domain_initializer_entry *ptr;
-	struct tomoyo_domain_initializer_entry e = { .is_not = is_not };
+	struct tomoyo_domain_initializer e = { .is_not = is_not };
 	int error = is_delete ? -ENOENT : -ENOMEM;
-
-	if (!tomoyo_is_correct_path(program))
+	if (!tomoyo_correct_path(program))
 		return -EINVAL;
 	if (domainname) {
-		if (!tomoyo_is_domain_def(domainname) &&
-		    tomoyo_is_correct_path(domainname))
+		if (!tomoyo_domain_def(domainname) &&
+		    tomoyo_correct_path(domainname))
 			e.is_last_name = true;
-		else if (!tomoyo_is_correct_domain(domainname))
+		else if (!tomoyo_correct_domain(domainname))
 			return -EINVAL;
 		e.domainname = tomoyo_get_name(domainname);
 		if (!e.domainname)
@@ -147,25 +249,9 @@ static int tomoyo_update_domain_initiali
 	e.program = tomoyo_get_name(program);
 	if (!e.program)
 		goto out;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &tomoyo_domain_initializer_list, list) {
-		if (!tomoyo_is_same_domain_initializer_entry(ptr, &e))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_domain_initializer_entry *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &tomoyo_domain_initializer_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
+	error = tomoyo_update_policy(&e.head, sizeof(e), is_delete,
+				  TOMOYO_ID_DOMAIN_INITIALIZER,
+				  tomoyo_same_domain_initializer);
  out:
 	tomoyo_put_name(e.domainname);
 	tomoyo_put_name(e.program);
@@ -173,46 +259,7 @@ static int tomoyo_update_domain_initiali
 }
 
 /**
- * tomoyo_read_domain_initializer_policy - Read "struct tomoyo_domain_initializer_entry" list.
- *
- * @head: Pointer to "struct tomoyo_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-bool tomoyo_read_domain_initializer_policy(struct tomoyo_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-
-	list_for_each_cookie(pos, head->read_var2,
-			     &tomoyo_domain_initializer_list) {
-		const char *no;
-		const char *from = "";
-		const char *domain = "";
-		struct tomoyo_domain_initializer_entry *ptr;
-		ptr = list_entry(pos, struct tomoyo_domain_initializer_entry,
-				  list);
-		if (ptr->is_deleted)
-			continue;
-		no = ptr->is_not ? "no_" : "";
-		if (ptr->domainname) {
-			from = " from ";
-			domain = ptr->domainname->name;
-		}
-		done = tomoyo_io_printf(head,
-					"%s" TOMOYO_KEYWORD_INITIALIZE_DOMAIN
-					"%s%s%s\n", no, ptr->program->name,
-					from, domain);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
- * tomoyo_write_domain_initializer_policy - Write "struct tomoyo_domain_initializer_entry" list.
+ * tomoyo_write_domain_initializer - Write "struct tomoyo_domain_initializer" list.
  *
  * @data:      String to parse.
  * @is_not:    True if it is "no_initialize_domain" entry.
@@ -222,23 +269,23 @@ bool tomoyo_read_domain_initializer_poli
  *
  * Caller holds tomoyo_read_lock().
  */
-int tomoyo_write_domain_initializer_policy(char *data, const bool is_not,
-					   const bool is_delete)
+int tomoyo_write_domain_initializer(char *data, const bool is_not,
+				    const bool is_delete)
 {
 	char *cp = strstr(data, " from ");
 
 	if (cp) {
 		*cp = '\0';
-		return tomoyo_update_domain_initializer_entry(cp + 6, data,
-							      is_not,
-							      is_delete);
+		return tomoyo_update_domain_initializer(cp + 6, data,
+							is_not,
+							is_delete);
 	}
-	return tomoyo_update_domain_initializer_entry(NULL, data, is_not,
-						      is_delete);
+	return tomoyo_update_domain_initializer(NULL, data, is_not,
+						is_delete);
 }
 
 /**
- * tomoyo_is_domain_initializer - Check whether the given program causes domainname reinitialization.
+ * tomoyo_domain_initializer - Check whether the given program causes domainname reinitialization.
  *
  * @domainname: The name of domain.
  * @program:    The name of program.
@@ -249,17 +296,18 @@ int tomoyo_write_domain_initializer_poli
  *
  * Caller holds tomoyo_read_lock().
  */
-static bool tomoyo_is_domain_initializer(const struct tomoyo_path_info *
-					 domainname,
-					 const struct tomoyo_path_info *program,
-					 const struct tomoyo_path_info *
-					 last_name)
+static bool tomoyo_domain_initializer(const struct tomoyo_path_info *
+				      domainname,
+				      const struct tomoyo_path_info *program,
+				      const struct tomoyo_path_info *
+				      last_name)
 {
-	struct tomoyo_domain_initializer_entry *ptr;
+	struct tomoyo_domain_initializer *ptr;
 	bool flag = false;
 
-	list_for_each_entry_rcu(ptr, &tomoyo_domain_initializer_list, list) {
-		if (ptr->is_deleted)
+	list_for_each_entry_rcu(ptr, &tomoyo_policy_list
+				[TOMOYO_ID_DOMAIN_INITIALIZER], head.list) {
+		if (ptr->head.is_deleted)
 			continue;
 		if (ptr->domainname) {
 			if (!ptr->is_last_name) {
@@ -319,10 +367,20 @@ static bool tomoyo_is_domain_initializer
  * "<kernel> /usr/sbin/sshd /bin/bash /usr/bin/passwd" domain, unless
  * explicitly specified by "initialize_domain".
  */
-LIST_HEAD(tomoyo_domain_keeper_list);
+static bool tomoyo_same_domain_keeper(const struct tomoyo_acl_head *a,
+				   const struct tomoyo_acl_head *b)
+{
+	const struct tomoyo_domain_keeper *p1 = container_of(a, typeof(*p1),
+							  head);
+	const struct tomoyo_domain_keeper *p2 = container_of(b, typeof(*p2),
+							  head);
+	return p1->is_not == p2->is_not && p1->is_last_name == p2->is_last_name
+		&& p1->domainname == p2->domainname
+		&& p1->program == p2->program;
+}
 
 /**
- * tomoyo_update_domain_keeper_entry - Update "struct tomoyo_domain_keeper_entry" list.
+ * tomoyo_update_domain_keeper - Update "struct tomoyo_domain_keeper" list.
  *
  * @domainname: The name of domain.
  * @program:    The name of program. May be NULL.
@@ -333,22 +391,19 @@ LIST_HEAD(tomoyo_domain_keeper_list);
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_update_domain_keeper_entry(const char *domainname,
-					     const char *program,
-					     const bool is_not,
-					     const bool is_delete)
+static int tomoyo_update_domain_keeper(const char *domainname,
+				       const char *program,
+				       const bool is_not,
+				       const bool is_delete)
 {
-	struct tomoyo_domain_keeper_entry *ptr;
-	struct tomoyo_domain_keeper_entry e = { .is_not = is_not };
+	struct tomoyo_domain_keeper e = { .is_not = is_not };
 	int error = is_delete ? -ENOENT : -ENOMEM;
-
-	if (!tomoyo_is_domain_def(domainname) &&
-	    tomoyo_is_correct_path(domainname))
+	if (!tomoyo_domain_def(domainname) && tomoyo_correct_path(domainname))
 		e.is_last_name = true;
-	else if (!tomoyo_is_correct_domain(domainname))
+	else if (!tomoyo_correct_domain(domainname))
 		return -EINVAL;
 	if (program) {
-		if (!tomoyo_is_correct_path(program))
+		if (!tomoyo_correct_path(program))
 			return -EINVAL;
 		e.program = tomoyo_get_name(program);
 		if (!e.program)
@@ -357,25 +412,9 @@ static int tomoyo_update_domain_keeper_e
 	e.domainname = tomoyo_get_name(domainname);
 	if (!e.domainname)
 		goto out;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &tomoyo_domain_keeper_list, list) {
-		if (!tomoyo_is_same_domain_keeper_entry(ptr, &e))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_domain_keeper_entry *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &tomoyo_domain_keeper_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
+	error = tomoyo_update_policy(&e.head, sizeof(e), is_delete,
+				  TOMOYO_ID_DOMAIN_KEEPER,
+				  tomoyo_same_domain_keeper);
  out:
 	tomoyo_put_name(e.domainname);
 	tomoyo_put_name(e.program);
@@ -383,7 +422,7 @@ static int tomoyo_update_domain_keeper_e
 }
 
 /**
- * tomoyo_write_domain_keeper_policy - Write "struct tomoyo_domain_keeper_entry" list.
+ * tomoyo_write_domain_keeper - Write "struct tomoyo_domain_keeper_entry" list.
  *
  * @data:      String to parse.
  * @is_not:    True if it is "no_keep_domain" entry.
@@ -391,60 +430,21 @@ static int tomoyo_update_domain_keeper_e
  *
  * Caller holds tomoyo_read_lock().
  */
-int tomoyo_write_domain_keeper_policy(char *data, const bool is_not,
-				      const bool is_delete)
+int tomoyo_write_domain_keeper(char *data, const bool is_not,
+			       const bool is_delete)
 {
 	char *cp = strstr(data, " from ");
 
 	if (cp) {
 		*cp = '\0';
-		return tomoyo_update_domain_keeper_entry(cp + 6, data, is_not,
-							 is_delete);
+		return tomoyo_update_domain_keeper(cp + 6, data, is_not,
+						   is_delete);
 	}
-	return tomoyo_update_domain_keeper_entry(data, NULL, is_not, is_delete);
+	return tomoyo_update_domain_keeper(data, NULL, is_not, is_delete);
 }
 
 /**
- * tomoyo_read_domain_keeper_policy - Read "struct tomoyo_domain_keeper_entry" list.
- *
- * @head: Pointer to "struct tomoyo_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-bool tomoyo_read_domain_keeper_policy(struct tomoyo_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-
-	list_for_each_cookie(pos, head->read_var2,
-			     &tomoyo_domain_keeper_list) {
-		struct tomoyo_domain_keeper_entry *ptr;
-		const char *no;
-		const char *from = "";
-		const char *program = "";
-
-		ptr = list_entry(pos, struct tomoyo_domain_keeper_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		no = ptr->is_not ? "no_" : "";
-		if (ptr->program) {
-			from = " from ";
-			program = ptr->program->name;
-		}
-		done = tomoyo_io_printf(head,
-					"%s" TOMOYO_KEYWORD_KEEP_DOMAIN
-					"%s%s%s\n", no, program, from,
-					ptr->domainname->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
- * tomoyo_is_domain_keeper - Check whether the given program causes domain transition suppression.
+ * tomoyo_domain_keeper - Check whether the given program causes domain transition suppression.
  *
  * @domainname: The name of domain.
  * @program:    The name of program.
@@ -455,15 +455,16 @@ bool tomoyo_read_domain_keeper_policy(st
  *
  * Caller holds tomoyo_read_lock().
  */
-static bool tomoyo_is_domain_keeper(const struct tomoyo_path_info *domainname,
+static bool tomoyo_domain_keeper(const struct tomoyo_path_info *domainname,
 				    const struct tomoyo_path_info *program,
 				    const struct tomoyo_path_info *last_name)
 {
-	struct tomoyo_domain_keeper_entry *ptr;
+	struct tomoyo_domain_keeper *ptr;
 	bool flag = false;
 
-	list_for_each_entry_rcu(ptr, &tomoyo_domain_keeper_list, list) {
-		if (ptr->is_deleted)
+	list_for_each_entry_rcu(ptr, &tomoyo_policy_list
+				[TOMOYO_ID_DOMAIN_KEEPER], head.list) {
+		if (ptr->head.is_deleted)
 			continue;
 		if (!ptr->is_last_name) {
 			if (ptr->domainname != domainname)
@@ -510,10 +511,18 @@ static bool tomoyo_is_domain_keeper(cons
  * permission is checked for /./editor and domainname which the current process
  * will belong to after execve() succeeds is calculated using /./editor .
  */
-LIST_HEAD(tomoyo_aggregator_list);
+static bool tomoyo_same_aggregator(const struct tomoyo_acl_head *a,
+				const struct tomoyo_acl_head *b)
+{
+	const struct tomoyo_aggregator *p1 = container_of(a, typeof(*p1), head);
+	const struct tomoyo_aggregator *p2 = container_of(b, typeof(*p2), head);
+	return p1->original_name == p2->original_name &&
+		p1->aggregated_name == p2->aggregated_name;
+}
+
 
 /**
- * tomoyo_update_aggregator_entry - Update "struct tomoyo_aggregator_entry" list.
+ * tomoyo_update_aggregator - Update "struct tomoyo_aggregator" list.
  *
  * @original_name:   The original program's name.
  * @aggregated_name: The program name to use.
@@ -523,41 +532,23 @@ LIST_HEAD(tomoyo_aggregator_list);
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_update_aggregator_entry(const char *original_name,
-					  const char *aggregated_name,
-					  const bool is_delete)
+static int tomoyo_update_aggregator(const char *original_name,
+				 const char *aggregated_name,
+				 const bool is_delete)
 {
-	struct tomoyo_aggregator_entry *ptr;
-	struct tomoyo_aggregator_entry e = { };
+	struct tomoyo_aggregator e = { };
 	int error = is_delete ? -ENOENT : -ENOMEM;
-
-	if (!tomoyo_is_correct_path(original_name) ||
-	    !tomoyo_is_correct_path(aggregated_name))
+	if (!tomoyo_correct_path(original_name) ||
+	    !tomoyo_correct_path(aggregated_name))
 		return -EINVAL;
 	e.original_name = tomoyo_get_name(original_name);
 	e.aggregated_name = tomoyo_get_name(aggregated_name);
 	if (!e.original_name || !e.aggregated_name ||
 	    e.aggregated_name->is_patterned) /* No patterns allowed. */
 		goto out;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &tomoyo_aggregator_list, list) {
-		if (!tomoyo_is_same_aggregator_entry(ptr, &e))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_aggregator_entry *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &tomoyo_aggregator_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
+	error = tomoyo_update_policy(&e.head, sizeof(e), is_delete,
+				     TOMOYO_ID_AGGREGATOR,
+				     tomoyo_same_aggregator);
  out:
 	tomoyo_put_name(e.original_name);
 	tomoyo_put_name(e.aggregated_name);
@@ -565,36 +556,7 @@ static int tomoyo_update_aggregator_entr
 }
 
 /**
- * tomoyo_read_aggregator_policy - Read "struct tomoyo_aggregator_entry" list.
- *
- * @head: Pointer to "struct tomoyo_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-bool tomoyo_read_aggregator_policy(struct tomoyo_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-
-	list_for_each_cookie(pos, head->read_var2, &tomoyo_aggregator_list) {
-		struct tomoyo_aggregator_entry *ptr;
-
-		ptr = list_entry(pos, struct tomoyo_aggregator_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = tomoyo_io_printf(head, TOMOYO_KEYWORD_AGGREGATOR
-					"%s %s\n", ptr->original_name->name,
-					ptr->aggregated_name->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
- * tomoyo_write_aggregator_policy - Write "struct tomoyo_aggregator_entry" list.
+ * tomoyo_write_aggregator - Write "struct tomoyo_aggregator" list.
  *
  * @data:      String to parse.
  * @is_delete: True if it is a delete request.
@@ -603,14 +565,14 @@ bool tomoyo_read_aggregator_policy(struc
  *
  * Caller holds tomoyo_read_lock().
  */
-int tomoyo_write_aggregator_policy(char *data, const bool is_delete)
+int tomoyo_write_aggregator(char *data, const bool is_delete)
 {
 	char *cp = strchr(data, ' ');
 
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return tomoyo_update_aggregator_entry(data, cp, is_delete);
+	return tomoyo_update_aggregator(data, cp, is_delete);
 }
 
 /**
@@ -632,7 +594,7 @@ struct tomoyo_domain_info *tomoyo_find_o
 	const struct tomoyo_path_info *saved_domainname;
 	bool found = false;
 
-	if (!tomoyo_is_correct_domain(domainname))
+	if (!tomoyo_correct_domain(domainname))
 		return NULL;
 	saved_domainname = tomoyo_get_name(domainname);
 	if (!saved_domainname)
@@ -719,7 +681,7 @@ bool tomoyo_dump_page(struct linux_binpr
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_find_next_domain2(struct tomoyo_execve_entry *ee)
+static int tomoyo_find_next_domain2(struct tomoyo_execve *ee)
 {
 	struct tomoyo_request_info *r = &ee->r;
 	struct tomoyo_domain_info *old_domain = tomoyo_domain();
@@ -749,9 +711,10 @@ static int tomoyo_find_next_domain2(stru
 
 	/* Check 'aggregator' directive. */
 	{
-		struct tomoyo_aggregator_entry *ptr;
-		list_for_each_entry_rcu(ptr, &tomoyo_aggregator_list, list) {
-			if (ptr->is_deleted ||
+		struct tomoyo_aggregator *ptr;
+		list_for_each_entry_rcu(ptr, &tomoyo_policy_list
+					[TOMOYO_ID_AGGREGATOR], head.list) {
+			if (ptr->head.is_deleted ||
 			    !tomoyo_path_matches_pattern(&rn,
 							 ptr->original_name))
 				continue;
@@ -770,7 +733,7 @@ static int tomoyo_find_next_domain2(stru
 	if (retval < 0)
 		goto out;
 
-	if (tomoyo_is_domain_initializer(old_domain->domainname, &rn, &ln)) {
+	if (tomoyo_domain_initializer(old_domain->domainname, &rn, &ln)) {
 		/* Transit to the child of tomoyo_kernel_domain domain. */
 		snprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1,
 			 TOMOYO_ROOT_NAME " " "%s", rn.name);
@@ -782,7 +745,7 @@ static int tomoyo_find_next_domain2(stru
 		 * initializers because they might start before /sbin/init.
 		 */
 		domain = old_domain;
-	} else if (tomoyo_is_domain_keeper(old_domain->domainname, &rn, &ln)) {
+	} else if (tomoyo_domain_keeper(old_domain->domainname, &rn, &ln)) {
 		/* Keep current domain. */
 		domain = old_domain;
 	} else {
@@ -836,7 +799,7 @@ static int tomoyo_find_next_domain2(stru
 int tomoyo_find_next_domain(struct linux_binprm *bprm)
 {
 	int retval = -ENOMEM;
-	struct tomoyo_execve_entry *ee = kzalloc(sizeof(*ee), GFP_NOFS);
+	struct tomoyo_execve *ee = kzalloc(sizeof(*ee), GFP_NOFS);
 
 	if (!ee)
 		return -ENOMEM;
--- security-testing-2.6.orig/security/tomoyo/file.c
+++ security-testing-2.6/security/tomoyo/file.c
@@ -92,7 +92,7 @@ void tomoyo_put_name_union(struct tomoyo
 	if (!ptr)
 		return;
 	if (ptr->is_group)
-		tomoyo_put_path_group(ptr->group);
+		tomoyo_put_group(ptr->group);
 	else
 		tomoyo_put_name(ptr->filename);
 }
@@ -108,7 +108,7 @@ bool tomoyo_compare_name_union(const str
 void tomoyo_put_number_union(struct tomoyo_number_union *ptr)
 {
 	if (ptr && ptr->is_group)
-		tomoyo_put_number_group(ptr->group);
+		tomoyo_put_group(ptr->group);
 }
 
 bool tomoyo_compare_number_union(const unsigned long value,
@@ -253,10 +253,17 @@ static int tomoyo_update_path_acl(const 
  * given "allow_read /lib/libc-2.5.so" to the domain which current process
  * belongs to.
  */
-LIST_HEAD(tomoyo_globally_readable_list);
+static bool tomoyo_same_globally_readable(const struct tomoyo_acl_head *a,
+					  const struct tomoyo_acl_head *b)
+{
+	return container_of(a, struct tomoyo_globally_readable_file, head)
+		->filename ==
+		container_of(b, struct tomoyo_globally_readable_file, head)
+		->filename;
+}
 
 /**
- * tomoyo_update_globally_readable_entry - Update "struct tomoyo_globally_readable_file_entry" list.
+ * tomoyo_update_globally_readable - Update "struct tomoyo_globally_readable_file" list.
  *
  * @filename:  Filename unconditionally permitted to open() for reading.
  * @is_delete: True if it is a delete request.
@@ -265,44 +272,26 @@ LIST_HEAD(tomoyo_globally_readable_list)
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_update_globally_readable_entry(const char *filename,
-						 const bool is_delete)
-{
-	struct tomoyo_globally_readable_file_entry *ptr;
-	struct tomoyo_globally_readable_file_entry e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
 
-	if (!tomoyo_is_correct_word(filename))
+static int tomoyo_update_globally_readable(const char *filename,
+					   const bool is_delete)
+{
+	struct tomoyo_globally_readable_file e = { };
+	int error;
+	if (!tomoyo_correct_word(filename))
 		return -EINVAL;
 	e.filename = tomoyo_get_name(filename);
 	if (!e.filename)
 		return -ENOMEM;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &tomoyo_globally_readable_list, list) {
-		if (ptr->filename != e.filename)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_globally_readable_file_entry *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &tomoyo_globally_readable_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
- out:
+	error = tomoyo_update_policy(&e.head, sizeof(e), is_delete,
+				     TOMOYO_ID_GLOBALLY_READABLE,
+				     tomoyo_same_globally_readable);
 	tomoyo_put_name(e.filename);
 	return error;
 }
 
 /**
- * tomoyo_is_globally_readable_file - Check if the file is unconditionnaly permitted to be open()ed for reading.
+ * tomoyo_globally_readable_file - Check if the file is unconditionnaly permitted to be open()ed for reading.
  *
  * @filename: The filename to check.
  *
@@ -310,15 +299,17 @@ static int tomoyo_update_globally_readab
  *
  * Caller holds tomoyo_read_lock().
  */
-static bool tomoyo_is_globally_readable_file(const struct tomoyo_path_info *
+static bool tomoyo_globally_readable_file(const struct tomoyo_path_info *
 					     filename)
 {
-	struct tomoyo_globally_readable_file_entry *ptr;
+	struct tomoyo_globally_readable_file *ptr;
 	bool found = false;
 
-	list_for_each_entry_rcu(ptr, &tomoyo_globally_readable_list, list) {
-		if (!ptr->is_deleted &&
-		    tomoyo_path_matches_pattern(filename, ptr->filename)) {
+	list_for_each_entry_rcu(ptr, &tomoyo_policy_list
+				[TOMOYO_ID_GLOBALLY_READABLE], head.list) {
+		if (ptr->head.is_deleted)
+			continue;
+		if (tomoyo_path_matches_pattern(filename, ptr->filename)) {
 			found = true;
 			break;
 		}
@@ -327,7 +318,7 @@ static bool tomoyo_is_globally_readable_
 }
 
 /**
- * tomoyo_write_globally_readable_policy - Write "struct tomoyo_globally_readable_file_entry" list.
+ * tomoyo_write_globally_readable - Write "struct tomoyo_globally_readable_file_entry" list.
  *
  * @data:      String to parse.
  * @is_delete: True if it is a delete request.
@@ -336,39 +327,9 @@ static bool tomoyo_is_globally_readable_
  *
  * Caller holds tomoyo_read_lock().
  */
-int tomoyo_write_globally_readable_policy(char *data, const bool is_delete)
+int tomoyo_write_globally_readable(char *data, const bool is_delete)
 {
-	return tomoyo_update_globally_readable_entry(data, is_delete);
-}
-
-/**
- * tomoyo_read_globally_readable_policy - Read "struct tomoyo_globally_readable_file_entry" list.
- *
- * @head: Pointer to "struct tomoyo_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-bool tomoyo_read_globally_readable_policy(struct tomoyo_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-
-	list_for_each_cookie(pos, head->read_var2,
-			     &tomoyo_globally_readable_list) {
-		struct tomoyo_globally_readable_file_entry *ptr;
-		ptr = list_entry(pos,
-				 struct tomoyo_globally_readable_file_entry,
-				 list);
-		if (ptr->is_deleted)
-			continue;
-		done = tomoyo_io_printf(head, TOMOYO_KEYWORD_ALLOW_READ "%s\n",
-					ptr->filename->name);
-		if (!done)
-			break;
-	}
-	return done;
+	return tomoyo_update_globally_readable(data, is_delete);
 }
 
 /* tomoyo_pattern_list is used for holding list of pathnames which are used for
@@ -400,10 +361,15 @@ bool tomoyo_read_globally_readable_polic
  * which pretends as if /proc/self/ is not a symlink; so that we can forbid
  * current process from accessing other process's information.
  */
-LIST_HEAD(tomoyo_pattern_list);
+static bool tomoyo_same_pattern(const struct tomoyo_acl_head *a,
+			     const struct tomoyo_acl_head *b)
+{
+	return container_of(a, struct tomoyo_pattern, head)->pattern ==
+		container_of(b, struct tomoyo_pattern, head)->pattern;
+}
 
 /**
- * tomoyo_update_file_pattern_entry - Update "struct tomoyo_pattern_entry" list.
+ * tomoyo_update_file_pattern - Update "struct tomoyo_pattern" list.
  *
  * @pattern:   Pathname pattern.
  * @is_delete: True if it is a delete request.
@@ -412,37 +378,18 @@ LIST_HEAD(tomoyo_pattern_list);
  *
  * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_update_file_pattern_entry(const char *pattern,
-					    const bool is_delete)
+static int tomoyo_update_file_pattern(const char *pattern,
+				      const bool is_delete)
 {
-	struct tomoyo_pattern_entry *ptr;
-	struct tomoyo_pattern_entry e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-
-	if (!tomoyo_is_correct_word(pattern))
+	struct tomoyo_pattern e = { };
+	int error;
+	if (!tomoyo_correct_word(pattern))
 		return -EINVAL;
 	e.pattern = tomoyo_get_name(pattern);
 	if (!e.pattern)
-		return error;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &tomoyo_pattern_list, list) {
-		if (e.pattern != ptr->pattern)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_pattern_entry *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list, &tomoyo_pattern_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
- out:
+		return -ENOMEM;
+	error = tomoyo_update_policy(&e.head, sizeof(e), is_delete,
+				     TOMOYO_ID_PATTERN, tomoyo_same_pattern);
 	tomoyo_put_name(e.pattern);
 	return error;
 }
@@ -458,11 +405,12 @@ static int tomoyo_update_file_pattern_en
  */
 const char *tomoyo_file_pattern(const struct tomoyo_path_info *filename)
 {
-	struct tomoyo_pattern_entry *ptr;
+	struct tomoyo_pattern *ptr;
 	const struct tomoyo_path_info *pattern = NULL;
 
-	list_for_each_entry_rcu(ptr, &tomoyo_pattern_list, list) {
-		if (ptr->is_deleted)
+	list_for_each_entry_rcu(ptr, &tomoyo_policy_list[TOMOYO_ID_PATTERN],
+				head.list) {
+		if (ptr->head.is_deleted)
 			continue;
 		if (!tomoyo_path_matches_pattern(filename, ptr->pattern))
 			continue;
@@ -489,36 +437,9 @@ const char *tomoyo_file_pattern(const st
  *
  * Caller holds tomoyo_read_lock().
  */
-int tomoyo_write_pattern_policy(char *data, const bool is_delete)
-{
-	return tomoyo_update_file_pattern_entry(data, is_delete);
-}
-
-/**
- * tomoyo_read_file_pattern - Read "struct tomoyo_pattern_entry" list.
- *
- * @head: Pointer to "struct tomoyo_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-bool tomoyo_read_file_pattern(struct tomoyo_io_buffer *head)
+int tomoyo_write_pattern(char *data, const bool is_delete)
 {
-	struct list_head *pos;
-	bool done = true;
-
-	list_for_each_cookie(pos, head->read_var2, &tomoyo_pattern_list) {
-		struct tomoyo_pattern_entry *ptr;
-		ptr = list_entry(pos, struct tomoyo_pattern_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = tomoyo_io_printf(head, TOMOYO_KEYWORD_FILE_PATTERN
-					"%s\n", ptr->pattern->name);
-		if (!done)
-			break;
-	}
-	return done;
+	return tomoyo_update_file_pattern(data, is_delete);
 }
 
 /*
@@ -550,56 +471,39 @@ bool tomoyo_read_file_pattern(struct tom
  * " (deleted)" suffix if the file is already unlink()ed; so that we don't
  * need to worry whether the file is already unlink()ed or not.
  */
-LIST_HEAD(tomoyo_no_rewrite_list);
+
+static bool tomoyo_same_no_rewrite(const struct tomoyo_acl_head *a,
+				   const struct tomoyo_acl_head *b)
+{
+	return container_of(a, struct tomoyo_no_rewrite, head)->pattern ==
+		container_of(b, struct tomoyo_no_rewrite, head)->pattern;
+}
 
 /**
- * tomoyo_update_no_rewrite_entry - Update "struct tomoyo_no_rewrite_entry" list.
+ * tomoyo_write_no_rewrite - Write "struct tomoyo_no_rewrite" list.
  *
- * @pattern:   Pathname pattern that are not rewritable by default.
+ * @data:      String to parse.
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
- *
- * Caller holds tomoyo_read_lock().
  */
-static int tomoyo_update_no_rewrite_entry(const char *pattern,
-					  const bool is_delete)
+int tomoyo_write_no_rewrite(char *data, const bool is_delete)
 {
-	struct tomoyo_no_rewrite_entry *ptr;
-	struct tomoyo_no_rewrite_entry e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-
-	if (!tomoyo_is_correct_word(pattern))
+	struct tomoyo_no_rewrite e = { };
+	int error;
+	if (!tomoyo_correct_word(data))
 		return -EINVAL;
-	e.pattern = tomoyo_get_name(pattern);
+	e.pattern = tomoyo_get_name(data);
 	if (!e.pattern)
-		return error;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &tomoyo_no_rewrite_list, list) {
-		if (ptr->pattern != e.pattern)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_no_rewrite_entry *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &tomoyo_no_rewrite_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
- out:
+		return -ENOMEM;
+	error = tomoyo_update_policy(&e.head, sizeof(e), is_delete,
+				  TOMOYO_ID_NO_REWRITE, tomoyo_same_no_rewrite);
 	tomoyo_put_name(e.pattern);
 	return error;
 }
 
 /**
- * tomoyo_is_no_rewrite_file - Check if the given pathname is not permitted to be rewrited.
+ * tomoyo_no_rewrite_file - Check if the given pathname is not permitted to be rewrited.
  *
  * @filename: Filename to check.
  *
@@ -608,13 +512,14 @@ static int tomoyo_update_no_rewrite_entr
  *
  * Caller holds tomoyo_read_lock().
  */
-static bool tomoyo_is_no_rewrite_file(const struct tomoyo_path_info *filename)
+static bool tomoyo_no_rewrite_file(const struct tomoyo_path_info *filename)
 {
-	struct tomoyo_no_rewrite_entry *ptr;
+	struct tomoyo_no_rewrite *ptr;
 	bool found = false;
 
-	list_for_each_entry_rcu(ptr, &tomoyo_no_rewrite_list, list) {
-		if (ptr->is_deleted)
+	list_for_each_entry_rcu(ptr, &tomoyo_policy_list[TOMOYO_ID_NO_REWRITE],
+				head.list) {
+		if (ptr->head.is_deleted)
 			continue;
 		if (!tomoyo_path_matches_pattern(filename, ptr->pattern))
 			continue;
@@ -625,48 +530,6 @@ static bool tomoyo_is_no_rewrite_file(co
 }
 
 /**
- * tomoyo_write_no_rewrite_policy - Write "struct tomoyo_no_rewrite_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-int tomoyo_write_no_rewrite_policy(char *data, const bool is_delete)
-{
-	return tomoyo_update_no_rewrite_entry(data, is_delete);
-}
-
-/**
- * tomoyo_read_no_rewrite_policy - Read "struct tomoyo_no_rewrite_entry" list.
- *
- * @head: Pointer to "struct tomoyo_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-bool tomoyo_read_no_rewrite_policy(struct tomoyo_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-
-	list_for_each_cookie(pos, head->read_var2, &tomoyo_no_rewrite_list) {
-		struct tomoyo_no_rewrite_entry *ptr;
-		ptr = list_entry(pos, struct tomoyo_no_rewrite_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = tomoyo_io_printf(head, TOMOYO_KEYWORD_DENY_REWRITE
-					"%s\n", ptr->pattern->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
  * tomoyo_update_file_acl - Update file's read/write/execute ACL.
  *
  * @perm:      Permission (between 1 to 7).
@@ -784,7 +647,7 @@ static int tomoyo_file_perm(struct tomoy
 	do {
 		error = tomoyo_path_acl(r, filename, perm);
 		if (error && mode == 4 && !r->domain->ignore_global_allow_read
-		    && tomoyo_is_globally_readable_file(filename))
+		    && tomoyo_globally_readable_file(filename))
 			error = 0;
 		if (!error)
 			break;
@@ -801,78 +664,101 @@ static int tomoyo_file_perm(struct tomoy
 	return error;
 }
 
+static bool tomoyo_same_path_acl(const struct tomoyo_acl_info *a,
+			      const struct tomoyo_acl_info *b)
+{
+	const struct tomoyo_path_acl *p1 = container_of(a, typeof(*p1), head);
+	const struct tomoyo_path_acl *p2 = container_of(b, typeof(*p2), head);
+	return tomoyo_same_acl_head(&p1->head, &p2->head) &&
+		tomoyo_same_name_union(&p1->name, &p2->name);
+}
+
+static bool tomoyo_merge_path_acl(struct tomoyo_acl_info *a, struct tomoyo_acl_info *b,
+			       const bool is_delete)
+{
+	u16 * const a_perm = &container_of(a, struct tomoyo_path_acl, head)->perm;
+	u16 perm = *a_perm;
+	const u16 b_perm = container_of(b, struct tomoyo_path_acl, head)->perm;
+	if (is_delete) {
+		perm &= ~b_perm;
+		if ((perm & TOMOYO_RW_MASK) != TOMOYO_RW_MASK)
+			perm &= ~(1 << TOMOYO_TYPE_READ_WRITE);
+		else if (!(perm & (1 << TOMOYO_TYPE_READ_WRITE)))
+			perm &= ~TOMOYO_RW_MASK;
+	} else {
+		perm |= b_perm;
+		if ((perm & TOMOYO_RW_MASK) == TOMOYO_RW_MASK)
+			perm |= (1 << TOMOYO_TYPE_READ_WRITE);
+		else if (perm & (1 << TOMOYO_TYPE_READ_WRITE))
+			perm |= TOMOYO_RW_MASK;
+	}
+	*a_perm = perm;
+	return !perm;
+}
+
 /**
  * tomoyo_update_path_acl - Update "struct tomoyo_path_acl" list.
  *
  * @type:      Type of operation.
  * @filename:  Filename.
  * @domain:    Pointer to "struct tomoyo_domain_info".
- * @cond:      Pointer to "struct tomoyo_condition". Maybe NULL.
+ * @condition: Pointer to "struct tomoyo_condition". May be NULL.
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
- *
- * Caller holds tomoyo_read_lock().
  */
 static int tomoyo_update_path_acl(const u8 type, const char *filename,
-				  struct tomoyo_domain_info *const domain,
-				  struct tomoyo_condition *cond,
-				  const bool is_delete)
+			       struct tomoyo_domain_info * const domain,
+			       struct tomoyo_condition *condition,
+			       const bool is_delete)
 {
-	static const u16 tomoyo_rw_mask =
-		(1 << TOMOYO_TYPE_READ) | (1 << TOMOYO_TYPE_WRITE);
-	const u16 perm = 1 << type;
-	struct tomoyo_acl_info *ptr;
 	struct tomoyo_path_acl e = {
 		.head.type = TOMOYO_TYPE_PATH_ACL,
-		.head.cond = cond,
-		.perm = perm
+		.head.cond = condition,
+		.perm = 1 << type
 	};
-	int error = is_delete ? -ENOENT : -ENOMEM;
-
-	if (type == TOMOYO_TYPE_READ_WRITE)
-		e.perm |= tomoyo_rw_mask;
-	if (!domain)
-		return -EINVAL;
+	int error;
+	if (e.perm == (1 << TOMOYO_TYPE_READ_WRITE))
+		e.perm |= TOMOYO_RW_MASK;
 	if (!tomoyo_parse_name_union(filename, &e.name))
 		return -EINVAL;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct tomoyo_path_acl *acl =
-			container_of(ptr, struct tomoyo_path_acl, head);
-		if (!tomoyo_is_same_path_acl(acl, &e))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if ((acl->perm & tomoyo_rw_mask) != tomoyo_rw_mask)
-				acl->perm &= ~(1 << TOMOYO_TYPE_READ_WRITE);
-			else if (!(acl->perm & (1 << TOMOYO_TYPE_READ_WRITE)))
-				acl->perm &= ~tomoyo_rw_mask;
-		} else {
-			acl->perm |= perm;
-			if ((acl->perm & tomoyo_rw_mask) == tomoyo_rw_mask)
-				acl->perm |= 1 << TOMOYO_TYPE_READ_WRITE;
-			else if (acl->perm & (1 << TOMOYO_TYPE_READ_WRITE))
-				acl->perm |= tomoyo_rw_mask;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_path_acl *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			tomoyo_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
- out:
+	error = tomoyo_update_domain(&e.head, sizeof(e), is_delete, domain,
+				  tomoyo_same_path_acl, tomoyo_merge_path_acl);
 	tomoyo_put_name_union(&e.name);
 	return error;
 }
 
+static bool tomoyo_same_path_number3_acl(const struct tomoyo_acl_info *a,
+				      const struct tomoyo_acl_info *b)
+{
+	const struct tomoyo_path_number3_acl *p1 = container_of(a, typeof(*p1),
+							     head);
+	const struct tomoyo_path_number3_acl *p2 = container_of(b, typeof(*p2),
+							     head);
+	return tomoyo_same_acl_head(&p1->head, &p2->head)
+		&& tomoyo_same_name_union(&p1->name, &p2->name)
+		&& tomoyo_same_number_union(&p1->mode, &p2->mode)
+		&& tomoyo_same_number_union(&p1->major, &p2->major)
+		&& tomoyo_same_number_union(&p1->minor, &p2->minor);
+}
+
+static bool tomoyo_merge_path_number3_acl(struct tomoyo_acl_info *a,
+				       struct tomoyo_acl_info *b,
+				       const bool is_delete)
+{
+	u8 *const a_perm = &container_of(a, struct tomoyo_path_number3_acl, head)
+		->perm;
+	u8 perm = *a_perm;
+	const u8 b_perm = container_of(b, struct tomoyo_path_number3_acl, head)
+		->perm;
+	if (is_delete)
+		perm &= ~b_perm;
+	else
+		perm |= b_perm;
+	*a_perm = perm;
+	return !perm;
+}
+
 /**
  * tomoyo_update_path_number3_acl - Update "struct tomoyo_path_number3_acl" list.
  *
@@ -882,26 +768,21 @@ static int tomoyo_update_path_acl(const 
  * @major:     Device major number.
  * @minor:     Device minor number.
  * @domain:    Pointer to "struct tomoyo_domain_info".
- * @cond:      Pointer to "struct tomoyo_condition". Maybe NULL.
+ * @condition: Pointer to "struct tomoyo_condition". May be NULL.
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int tomoyo_update_path_number3_acl(const u8 type,
-						 const char *filename,
-						 char *mode,
-						 char *major, char *minor,
-						 struct tomoyo_domain_info *
-						 const domain,
-						 struct tomoyo_condition *cond,
-						 const bool is_delete)
+static int tomoyo_update_path_number3_acl(const u8 type, const char *filename,
+				       char *mode, char *major, char *minor,
+				       struct tomoyo_domain_info * const domain,
+				       struct tomoyo_condition *condition,
+				       const bool is_delete)
 {
-	const u8 perm = 1 << type;
-	struct tomoyo_acl_info *ptr;
 	struct tomoyo_path_number3_acl e = {
 		.head.type = TOMOYO_TYPE_PATH_NUMBER3_ACL,
-		.head.cond = cond,
-		.perm = perm
+		.head.cond = condition,
+		.perm = 1 << type
 	};
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!tomoyo_parse_name_union(filename, &e.name) ||
@@ -909,29 +790,9 @@ static inline int tomoyo_update_path_num
 	    !tomoyo_parse_number_union(major, &e.major) ||
 	    !tomoyo_parse_number_union(minor, &e.minor))
 		goto out;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct tomoyo_path_number3_acl *acl =
-			container_of(ptr, struct tomoyo_path_number3_acl, head);
-		if (!tomoyo_is_same_path_number3_acl(acl, &e))
-			continue;
-		if (is_delete)
-			acl->perm &= ~perm;
-		else
-			acl->perm |= perm;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_path_number3_acl *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			tomoyo_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
+	error = tomoyo_update_domain(&e.head, sizeof(e), is_delete, domain,
+				  tomoyo_same_path_number3_acl,
+				  tomoyo_merge_path_number3_acl);
  out:
 	tomoyo_put_name_union(&e.name);
 	tomoyo_put_number_union(&e.mode);
@@ -940,6 +801,30 @@ static inline int tomoyo_update_path_num
 	return error;
 }
 
+static bool tomoyo_same_path2_acl(const struct tomoyo_acl_info *a,
+				     const struct tomoyo_acl_info *b)
+{
+	const struct tomoyo_path2_acl *p1 = container_of(a, typeof(*p1), head);
+	const struct tomoyo_path2_acl *p2 = container_of(b, typeof(*p2), head);
+	return tomoyo_same_acl_head(&p1->head, &p2->head)
+		&& tomoyo_same_name_union(&p1->name1, &p2->name1)
+		&& tomoyo_same_name_union(&p1->name2, &p2->name2);
+}
+
+static bool tomoyo_merge_path2_acl(struct tomoyo_acl_info *a, struct tomoyo_acl_info *b,
+				   const bool is_delete)
+{
+	u8 * const a_perm = &container_of(a, struct tomoyo_path2_acl, head)->perm;
+	u8 perm = *a_perm;
+	const u8 b_perm = container_of(b, struct tomoyo_path2_acl, head)->perm;
+	if (is_delete)
+		perm &= ~b_perm;
+	else
+		perm |= b_perm;
+	*a_perm = perm;
+	return !perm;
+}
+
 /**
  * tomoyo_update_path2_acl - Update "struct tomoyo_path2_acl" list.
  *
@@ -947,62 +832,100 @@ static inline int tomoyo_update_path_num
  * @filename1: First filename.
  * @filename2: Second filename.
  * @domain:    Pointer to "struct tomoyo_domain_info".
- * @cond:      Pointer to "struct tomoyo_condition". Maybe NULL.
+ * @condition: Pointer to "struct tomoyo_condition". May be NULL.
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
- *
- * Caller holds tomoyo_read_lock().
  */
 static int tomoyo_update_path2_acl(const u8 type, const char *filename1,
-				   const char *filename2,
-				   struct tomoyo_domain_info *const domain,
-				   struct tomoyo_condition *cond,
-				   const bool is_delete)
+				const char *filename2,
+				struct tomoyo_domain_info * const domain,
+				struct tomoyo_condition *condition,
+				const bool is_delete)
 {
-	const u8 perm = 1 << type;
 	struct tomoyo_path2_acl e = {
 		.head.type = TOMOYO_TYPE_PATH2_ACL,
-		.head.cond = cond,
-		.perm = perm
+		.head.cond = condition,
+		.perm = 1 << type
 	};
-	struct tomoyo_acl_info *ptr;
 	int error = is_delete ? -ENOENT : -ENOMEM;
-
-	if (!domain)
-		return -EINVAL;
 	if (!tomoyo_parse_name_union(filename1, &e.name1) ||
 	    !tomoyo_parse_name_union(filename2, &e.name2))
 		goto out;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct tomoyo_path2_acl *acl =
-			container_of(ptr, struct tomoyo_path2_acl, head);
-		if (!tomoyo_is_same_path2_acl(acl, &e))
-			continue;
-		if (is_delete)
-			acl->perm &= ~perm;
-		else
-			acl->perm |= perm;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_path2_acl *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			tomoyo_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
+	error = tomoyo_update_domain(&e.head, sizeof(e), is_delete, domain,
+				  tomoyo_same_path2_acl, tomoyo_merge_path2_acl);
  out:
 	tomoyo_put_name_union(&e.name1);
 	tomoyo_put_name_union(&e.name2);
 	return error;
 }
 
+static bool tomoyo_same_path_number_acl(const struct tomoyo_acl_info *a,
+				     const struct tomoyo_acl_info *b)
+{
+	const struct tomoyo_path_number_acl *p1 = container_of(a, typeof(*p1),
+							    head);
+	const struct tomoyo_path_number_acl *p2 = container_of(b, typeof(*p2),
+							    head);
+	return tomoyo_same_acl_head(&p1->head, &p2->head)
+		&& tomoyo_same_name_union(&p1->name, &p2->name)
+		&& tomoyo_same_number_union(&p1->number, &p2->number);
+}
+
+static bool tomoyo_merge_path_number_acl(struct tomoyo_acl_info *a,
+				      struct tomoyo_acl_info *b,
+				      const bool is_delete)
+{
+	u8 * const a_perm = &container_of(a, struct tomoyo_path_number_acl, head)
+		->perm;
+	u8 perm = *a_perm;
+	const u8 b_perm = container_of(b, struct tomoyo_path_number_acl, head)
+		->perm;
+	if (is_delete)
+		perm &= ~b_perm;
+	else
+		perm |= b_perm;
+	*a_perm = perm;
+	return !perm;
+}
+
+/**
+ * tomoyo_update_path_number_acl - Update ioctl/chmod/chown/chgrp ACL.
+ *
+ * @type:      Type of operation.
+ * @filename:  Filename.
+ * @number:    Number.
+ * @domain:    Pointer to "struct tomoyo_domain_info".
+ * @condition: Pointer to "struct tomoyo_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_update_path_number_acl(const u8 type, const char *filename,
+				      char *number,
+				      struct tomoyo_domain_info * const domain,
+				      struct tomoyo_condition *condition,
+				      const bool is_delete)
+{
+	struct tomoyo_path_number_acl e = {
+		.head.type = TOMOYO_TYPE_PATH_NUMBER_ACL,
+		.head.cond = condition,
+		.perm = 1 << type
+	};
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!tomoyo_parse_name_union(filename, &e.name))
+		return -EINVAL;
+	if (!tomoyo_parse_number_union(number, &e.number))
+		goto out;
+	error = tomoyo_update_domain(&e.head, sizeof(e), is_delete, domain,
+				  tomoyo_same_path_number_acl,
+				  tomoyo_merge_path_number_acl);
+ out:
+	tomoyo_put_name_union(&e.name);
+	tomoyo_put_number_union(&e.number);
+	return error;
+}
+
 /**
  * tomoyo_path_number3_acl - Check permission for path/number/number/number operation.
  *
@@ -1124,7 +1047,7 @@ static int tomoyo_path_permission(struct
 	 * specified by "deny_rewrite" keyword.
 	 */
 	if (!error && operation == TOMOYO_TYPE_TRUNCATE &&
-	    tomoyo_is_no_rewrite_file(filename)) {
+	    tomoyo_no_rewrite_file(filename)) {
 		operation = TOMOYO_TYPE_REWRITE;
 		goto next;
 	}
@@ -1168,69 +1091,6 @@ static int tomoyo_path_number_acl(struct
 }
 
 /**
- * tomoyo_update_path_number_acl - Update ioctl/chmod/chown/chgrp ACL.
- *
- * @type:      Type of operation.
- * @filename:  Filename.
- * @number:    Number.
- * @domain:    Pointer to "struct tomoyo_domain_info".
- * @cond:      Pointer to "struct tomoyo_condition". Maybe NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static inline int tomoyo_update_path_number_acl(const u8 type,
-						const char *filename,
-						char *number,
-						struct tomoyo_domain_info *
-						const domain,
-						struct tomoyo_condition *cond,
-						const bool is_delete)
-{
-	const u8 perm = 1 << type;
-	struct tomoyo_acl_info *ptr;
-	struct tomoyo_path_number_acl e = {
-		.head.type = TOMOYO_TYPE_PATH_NUMBER_ACL,
-		.head.cond = cond,
-		.perm = perm
-	};
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!domain)
-		return -EINVAL;
-	if (!tomoyo_parse_name_union(filename, &e.name))
-		return -EINVAL;
-	if (!tomoyo_parse_number_union(number, &e.number))
-		goto out;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct tomoyo_path_number_acl *acl =
-			container_of(ptr, struct tomoyo_path_number_acl, head);
-		if (!tomoyo_is_same_path_number_acl(acl, &e))
-			continue;
-		if (is_delete)
-			acl->perm &= ~perm;
-		else
-			acl->perm |= perm;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_path_number_acl *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			tomoyo_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
- out:
-	tomoyo_put_name_union(&e.name);
-	tomoyo_put_number_union(&e.number);
-	return error;
-}
-
-/**
  * tomoyo_path_number_perm2 - Check permission for "create", "mkdir", "mkfifo", "mksock", "ioctl", "chmod", "chown", "chgrp".
  *
  * @r:        Pointer to "strct tomoyo_request_info".
@@ -1375,7 +1235,7 @@ int tomoyo_check_open_permission(struct 
 			error = -ENOMEM;
 			goto out;
 		}
-		if (tomoyo_is_no_rewrite_file(&buf))
+		if (tomoyo_no_rewrite_file(&buf))
 			error = tomoyo_path_permission(&r, TOMOYO_TYPE_REWRITE,
 						       &buf);
 	}
@@ -1422,7 +1282,7 @@ int tomoyo_path_perm(const u8 operation,
 		goto out;
 	switch (operation) {
 	case TOMOYO_TYPE_REWRITE:
-		if (!tomoyo_is_no_rewrite_file(&buf)) {
+		if (!tomoyo_no_rewrite_file(&buf)) {
 			error = 0;
 			goto out;
 		}
@@ -1580,7 +1440,7 @@ int tomoyo_path2_perm(const u8 operation
 }
 
 /**
- * tomoyo_write_file_policy - Update file related list.
+ * tomoyo_write_file - Update file related list.
  *
  * @data:      String to parse.
  * @domain:    Pointer to "struct tomoyo_domain_info".
@@ -1591,9 +1451,8 @@ int tomoyo_path2_perm(const u8 operation
  *
  * Caller holds tomoyo_read_lock().
  */
-int tomoyo_write_file_policy(char *data, struct tomoyo_domain_info *domain,
-			     struct tomoyo_condition *cond,
-			     const bool is_delete)
+int tomoyo_write_file(char *data, struct tomoyo_domain_info *domain,
+		      struct tomoyo_condition *cond, const bool is_delete)
 {
 	char *w[5];
 	u8 type;
--- /dev/null
+++ security-testing-2.6/security/tomoyo/group.c
@@ -0,0 +1,122 @@
+/*
+ * security/tomoyo/group.c
+ *
+ * Copyright (C) 2005-2010  NTT DATA CORPORATION
+ */
+
+#include "common.h"
+
+static bool tomoyo_same_path_group(const struct tomoyo_acl_head *a,
+				const struct tomoyo_acl_head *b)
+{
+	return container_of(a, struct tomoyo_path_group, head)->member_name ==
+		container_of(b, struct tomoyo_path_group, head)->member_name;
+}
+
+static bool tomoyo_same_number_group(const struct tomoyo_acl_head *a,
+				  const struct tomoyo_acl_head *b)
+{
+	return !memcmp(&container_of(a, struct tomoyo_number_group, head)->number,
+		       &container_of(b, struct tomoyo_number_group, head)->number,
+		       sizeof(container_of(a, struct tomoyo_number_group, head)
+			      ->number));
+}
+
+/**
+ * tomoyo_write_group - Write "struct tomoyo_path_group"/"struct tomoyo_number_group" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ * @type:      Type of this group.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int tomoyo_write_group(char *data, const bool is_delete, const u8 type)
+{
+	struct tomoyo_group *group;
+	char *w[2];
+	int error = -EINVAL;
+	if (!tomoyo_tokenize(data, w, sizeof(w)) || !w[1][0])
+		return -EINVAL;
+	group = tomoyo_get_group(w[0], type);
+	if (!group)
+		return -ENOMEM;
+	if (type == TOMOYO_PATH_GROUP) {
+		struct tomoyo_path_group e = { };
+		e.member_name = tomoyo_get_name(w[1]);
+		if (!e.member_name) {
+			error = -ENOMEM;
+			goto out;
+		}
+		error = tomoyo_update_group(&e.head, sizeof(e), is_delete, group,
+					 tomoyo_same_path_group);
+		tomoyo_put_name(e.member_name);
+	} else {
+		struct tomoyo_number_group e = { };
+		if (w[1][0] == '@' || !tomoyo_parse_number_union(w[1], &e.number)
+		    || e.number.values[0] > e.number.values[1])
+			goto out;
+		error = tomoyo_update_group(&e.head, sizeof(e), is_delete, group,
+					 tomoyo_same_number_group);
+		/*
+		 * tomoyo_put_number_union() is not needed because w[1][0] != '@'.
+		 */
+	}
+ out:
+	tomoyo_put_group(group);
+	return error;
+}
+
+/**
+ * tomoyo_path_matches_group - Check whether the given pathname matches members of the given pathname group.
+ *
+ * @pathname:        The name of pathname.
+ * @group:           Pointer to "struct tomoyo_path_group".
+ *
+ * Returns true if @pathname matches pathnames in @group, false otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+bool tomoyo_path_matches_group(const struct tomoyo_path_info *pathname,
+			    const struct tomoyo_group *group)
+{
+	struct tomoyo_path_group *member;
+	bool matched = false;
+	list_for_each_entry_rcu(member, &group->member_list, head.list) {
+		if (member->head.is_deleted)
+			continue;
+		if (!tomoyo_path_matches_pattern(pathname, member->member_name))
+			continue;
+		matched = true;
+		break;
+	}
+	return matched;
+}
+
+/**
+ * tomoyo_number_matches_group - Check whether the given number matches members of the given number group.
+ *
+ * @min:   Min number.
+ * @max:   Max number.
+ * @group: Pointer to "struct tomoyo_number_group".
+ *
+ * Returns true if @min and @max partially overlaps @group, false otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+bool tomoyo_number_matches_group(const unsigned long min, const unsigned long max,
+			      const struct tomoyo_group *group)
+{
+	struct tomoyo_number_group *member;
+	bool matched = false;
+	list_for_each_entry_rcu(member, &group->member_list, head.list) {
+		if (member->head.is_deleted)
+			continue;
+		if (min > member->number.values[1] ||
+		    max < member->number.values[0])
+			continue;
+		matched = true;
+		break;
+	}
+	return matched;
+}
--- security-testing-2.6.orig/security/tomoyo/mount.c
+++ security-testing-2.6/security/tomoyo/mount.c
@@ -114,11 +114,10 @@ static int tomoyo_mount_acl2(struct tomo
 	tomoyo_fill_path_info(&rdev);
 	list_for_each_entry_rcu(ptr, &r->domain->acl_info_list, list) {
 		struct tomoyo_mount_acl *acl;
-		if (ptr->type != TOMOYO_TYPE_MOUNT_ACL)
+		if (ptr->is_deleted || ptr->type != TOMOYO_TYPE_MOUNT_ACL)
 			continue;
 		acl = container_of(ptr, struct tomoyo_mount_acl, head);
-		if (acl->is_deleted ||
-		    !tomoyo_compare_number_union(flags, &acl->flags) ||
+		if (!tomoyo_compare_number_union(flags, &acl->flags) ||
 		    !tomoyo_compare_name_union(&rtype, &acl->fs_type) ||
 		    !tomoyo_compare_name_union(&rdir, &acl->dir_name) ||
 		    (need_dev &&
@@ -259,25 +258,33 @@ int tomoyo_mount_permission(char *dev_na
 	return error;
 }
 
+static bool tomoyo_same_mount_acl(const struct tomoyo_acl_info *a,
+			       const struct tomoyo_acl_info *b)
+{
+	const struct tomoyo_mount_acl *p1 = container_of(a, typeof(*p1), head);
+	const struct tomoyo_mount_acl *p2 = container_of(b, typeof(*p2), head);
+	return tomoyo_same_acl_head(&p1->head, &p2->head) &&
+		tomoyo_same_name_union(&p1->dev_name, &p2->dev_name) &&
+		tomoyo_same_name_union(&p1->dir_name, &p2->dir_name) &&
+		tomoyo_same_name_union(&p1->fs_type, &p2->fs_type) &&
+		tomoyo_same_number_union(&p1->flags, &p2->flags);
+}
+
 /**
- * tomoyo_write_mount_policy - Write "struct tomoyo_mount_acl" list.
+ * tomoyo_write_mount - Write "struct tomoyo_mount_acl" list.
  *
  * @data:      String to parse.
  * @domain:    Pointer to "struct tomoyo_domain_info".
- * @cond:      Pointer to "struct tomoyo_condition". Maybe NULL.
+ * @condition: Pointer to "struct tomoyo_condition". May be NULL.
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int tomoyo_write_mount_policy(char *data, struct tomoyo_domain_info *domain,
-			      struct tomoyo_condition *cond,
-			      const bool is_delete)
+int tomoyo_write_mount(char *data, struct tomoyo_domain_info *domain,
+		    struct tomoyo_condition *condition, const bool is_delete)
 {
-	struct tomoyo_acl_info *ptr;
-	struct tomoyo_mount_acl e = {
-		.head.type = TOMOYO_TYPE_MOUNT_ACL,
-		.head.cond = cond
-	};
+	struct tomoyo_mount_acl e = { .head.type = TOMOYO_TYPE_MOUNT_ACL,
+				   .head.cond = condition };
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	char *w[4];
 	if (!tomoyo_tokenize(data, w, sizeof(w)) || !w[3][0])
@@ -287,26 +294,8 @@ int tomoyo_write_mount_policy(char *data
 	    !tomoyo_parse_name_union(w[2], &e.fs_type) ||
 	    !tomoyo_parse_number_union(w[3], &e.flags))
 		goto out;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct tomoyo_mount_acl *acl =
-			container_of(ptr, struct tomoyo_mount_acl, head);
-		if (!tomoyo_is_same_mount_acl(acl, &e))
-			continue;
-		acl->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_mount_acl *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			tomoyo_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
+	error = tomoyo_update_domain(&e.head, sizeof(e), is_delete, domain,
+				  tomoyo_same_mount_acl, NULL);
  out:
 	tomoyo_put_name_union(&e.dev_name);
 	tomoyo_put_name_union(&e.dir_name);
--- security-testing-2.6.orig/security/tomoyo/number_group.c
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * security/tomoyo/number_group.c
- *
- * Copyright (C) 2005-2009  NTT DATA CORPORATION
- */
-
-#include <linux/slab.h>
-#include "common.h"
-
-/* The list for "struct tomoyo_number_group". */
-LIST_HEAD(tomoyo_number_group_list);
-
-/**
- * tomoyo_get_number_group - Allocate memory for "struct tomoyo_number_group".
- *
- * @group_name: The name of number group.
- *
- * Returns pointer to "struct tomoyo_number_group" on success,
- * NULL otherwise.
- */
-struct tomoyo_number_group *tomoyo_get_number_group(const char *group_name)
-{
-	struct tomoyo_number_group *entry = NULL;
-	struct tomoyo_number_group *group = NULL;
-	const struct tomoyo_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!tomoyo_is_correct_word(group_name))
-		return NULL;
-	saved_group_name = tomoyo_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), GFP_NOFS);
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(group, &tomoyo_number_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && tomoyo_memory_ok(entry)) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &tomoyo_number_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&tomoyo_policy_lock);
- out:
-	tomoyo_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
-}
-
-/**
- * tomoyo_write_number_group_policy - Write "struct tomoyo_number_group" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, nagative value otherwise.
- */
-int tomoyo_write_number_group_policy(char *data, const bool is_delete)
-{
-	struct tomoyo_number_group *group;
-	struct tomoyo_number_group_member e = { };
-	struct tomoyo_number_group_member *member;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	char *w[2];
-	if (!tomoyo_tokenize(data, w, sizeof(w)))
-		return -EINVAL;
-	if (!tomoyo_parse_number_union(w[1], &e.number))
-		return -EINVAL;
-	if (e.number.is_group || e.number.values[0] > e.number.values[1]) {
-		tomoyo_put_number_union(&e.number);
-		return -EINVAL;
-	}
-	group = tomoyo_get_number_group(w[0]);
-	if (!group)
-		return -ENOMEM;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (memcmp(&member->number, &e.number, sizeof(e.number)))
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_number_group_member *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list, &group->member_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
- out:
-	tomoyo_put_number_group(group);
-	return error;
-}
-
-/**
- * tomoyo_read_number_group_policy - Read "struct tomoyo_number_group" list.
- *
- * @head: Pointer to "struct tomoyo_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-bool tomoyo_read_number_group_policy(struct tomoyo_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &tomoyo_number_group_list) {
-		struct tomoyo_number_group *group;
-		const char *name;
-		group = list_entry(gpos, struct tomoyo_number_group, list);
-		name = group->group_name->name;
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			int pos;
-			const struct tomoyo_number_group_member *member
-				= list_entry(mpos,
-					     struct tomoyo_number_group_member,
-					     list);
-			if (member->is_deleted)
-				continue;
-			pos = head->read_avail;
-			if (!tomoyo_io_printf(head, TOMOYO_KEYWORD_NUMBER_GROUP
-					      "%s", name) ||
-			    !tomoyo_print_number_union(head, &member->number) ||
-			    !tomoyo_io_printf(head, "\n")) {
-				head->read_avail = pos;
-				return false;
-			}
-		}
-	}
-	return true;
-}
-
-/**
- * tomoyo_number_matches_group - Check whether the given number matches members of the given number group.
- *
- * @min:   Min number.
- * @max:   Max number.
- * @group: Pointer to "struct tomoyo_number_group".
- *
- * Returns true if @min and @max partially overlaps @group, false otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-bool tomoyo_number_matches_group(const unsigned long min,
-				 const unsigned long max,
-				 const struct tomoyo_number_group *group)
-{
-	struct tomoyo_number_group_member *member;
-	bool matched = false;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->is_deleted)
-			continue;
-		if (min > member->number.values[1] ||
-		    max < member->number.values[0])
-			continue;
-		matched = true;
-		break;
-	}
-	return matched;
-}
--- security-testing-2.6.orig/security/tomoyo/path_group.c
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * security/tomoyo/path_group.c
- *
- * Copyright (C) 2005-2009  NTT DATA CORPORATION
- */
-
-#include <linux/slab.h>
-#include "common.h"
-/* The list for "struct tomoyo_path_group". */
-LIST_HEAD(tomoyo_path_group_list);
-
-/**
- * tomoyo_get_path_group - Allocate memory for "struct tomoyo_path_group".
- *
- * @group_name: The name of pathname group.
- *
- * Returns pointer to "struct tomoyo_path_group" on success, NULL otherwise.
- */
-struct tomoyo_path_group *tomoyo_get_path_group(const char *group_name)
-{
-	struct tomoyo_path_group *entry = NULL;
-	struct tomoyo_path_group *group = NULL;
-	const struct tomoyo_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!tomoyo_is_correct_word(group_name))
-		return NULL;
-	saved_group_name = tomoyo_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), GFP_NOFS);
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(group, &tomoyo_path_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && tomoyo_memory_ok(entry)) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &tomoyo_path_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&tomoyo_policy_lock);
- out:
-	tomoyo_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
-}
-
-/**
- * tomoyo_write_path_group_policy - Write "struct tomoyo_path_group" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, nagative value otherwise.
- */
-int tomoyo_write_path_group_policy(char *data, const bool is_delete)
-{
-	struct tomoyo_path_group *group;
-	struct tomoyo_path_group_member *member;
-	struct tomoyo_path_group_member e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	char *w[2];
-	if (!tomoyo_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	group = tomoyo_get_path_group(w[0]);
-	if (!group)
-		return -ENOMEM;
-	e.member_name = tomoyo_get_name(w[1]);
-	if (!e.member_name)
-		goto out;
-	if (mutex_lock_interruptible(&tomoyo_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->member_name != e.member_name)
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct tomoyo_path_group_member *entry =
-			tomoyo_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list, &group->member_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&tomoyo_policy_lock);
- out:
-	tomoyo_put_name(e.member_name);
-	tomoyo_put_path_group(group);
-	return error;
-}
-
-/**
- * tomoyo_read_path_group_policy - Read "struct tomoyo_path_group" list.
- *
- * @head: Pointer to "struct tomoyo_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-bool tomoyo_read_path_group_policy(struct tomoyo_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &tomoyo_path_group_list) {
-		struct tomoyo_path_group *group;
-		group = list_entry(gpos, struct tomoyo_path_group, list);
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			struct tomoyo_path_group_member *member;
-			member = list_entry(mpos,
-					    struct tomoyo_path_group_member,
-					    list);
-			if (member->is_deleted)
-				continue;
-			if (!tomoyo_io_printf(head, TOMOYO_KEYWORD_PATH_GROUP
-					      "%s %s\n",
-					      group->group_name->name,
-					      member->member_name->name))
-				return false;
-		}
-	}
-	return true;
-}
-
-/**
- * tomoyo_path_matches_group - Check whether the given pathname matches members of the given pathname group.
- *
- * @pathname:        The name of pathname.
- * @group:           Pointer to "struct tomoyo_path_group".
- *
- * Returns true if @pathname matches pathnames in @group, false otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-bool tomoyo_path_matches_group(const struct tomoyo_path_info *pathname,
-			       const struct tomoyo_path_group *group)
-{
-	struct tomoyo_path_group_member *member;
-	bool matched = false;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->is_deleted)
-			continue;
-		if (!tomoyo_path_matches_pattern(pathname,
-						 member->member_name))
-			continue;
-		matched = true;
-		break;
-	}
-	return matched;
-}
