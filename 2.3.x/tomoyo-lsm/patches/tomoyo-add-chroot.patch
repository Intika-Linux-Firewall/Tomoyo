[TOMOYO] Add chroot() handler.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/chroot.c |  152 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 152 insertions(+)

--- /dev/null
+++ linux-2.6.31/security/tomoyo/chroot.c
@@ -0,0 +1,152 @@
+/*
+ * security/tomoyo/chroot.c
+ *
+ * Copyright (C) 2005-2009  NTT DATA CORPORATION
+ */
+#include "internal.h"
+
+/**
+ * tomoyo_audit_chroot_log - Audit chroot log.
+ *
+ * @r:          Pointer to "struct tomoyo_request_info".
+ * @root:       New root directory.
+ * @is_granted: True if this is a granted log.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_audit_chroot_log(struct tomoyo_request_info *r,
+				   const char *root, const bool is_granted)
+{
+	if (!is_granted)
+		tomoyo_warn_log(r, "chroot %s", root);
+	return tomoyo_write_audit_log(is_granted, r,
+				      TOMOYO_KEYWORD_ALLOW_CHROOT "%s\n",
+				      root);
+}
+
+/**
+ * tomoyo_chroot_acl - Check permission for chroot().
+ *
+ * @path: Pointer to "struct path".
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+static int tomoyo_chroot_acl(struct path *path)
+{
+	struct tomoyo_request_info r;
+	int error;
+	struct tomoyo_path_info dir;
+	char *root_name;
+	struct tomoyo_obj_info obj = {
+		.path1 = *path
+	};
+	if (!tomoyo_capable(TOMOYO_SYS_CHROOT))
+		return -EPERM;
+	if (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_CHROOT)
+	    == TOMOYO_CONFIG_DISABLED)
+		return 0;
+	r.obj = &obj;
+	error = -ENOMEM;
+	root_name = tomoyo_realpath_from_path(path);
+	if (!root_name)
+		goto out;
+	dir.name = root_name;
+	tomoyo_fill_path_info(&dir);
+	if (!dir.is_dir)
+		goto out;
+	do {
+		struct tomoyo_acl_info *ptr;
+		error = -EPERM;
+		list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
+			struct tomoyo_chroot_acl *acl;
+			if (ptr->is_deleted ||
+			    ptr->type != TOMOYO_TYPE_CHROOT_ACL)
+				continue;
+			acl = container_of(ptr, struct tomoyo_chroot_acl,
+					   head);
+			if (!tomoyo_compare_name_union(&dir, &acl->dir) ||
+			    !tomoyo_condition(&r, ptr))
+				continue;
+			r.cond = ptr->cond;
+			error = 0;
+			break;
+		}
+		tomoyo_audit_chroot_log(&r, root_name, !error);
+		if (!error)
+			break;
+		error = tomoyo_supervisor(&r, TOMOYO_KEYWORD_ALLOW_CHROOT
+					  "%s\n", tomoyo_file_pattern(&dir));
+	} while (error == 1);
+ out:
+	kfree(root_name);
+	if (r.mode != TOMOYO_CONFIG_ENFORCING)
+		error = 0;
+	return error;
+}
+
+/**
+ * tomoyo_chroot_permission - Check permission for chroot().
+ *
+ * @path: Pointer to "struct path".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int tomoyo_chroot_permission(struct path *path)
+{
+	const int idx = tomoyo_read_lock();
+	const int error = tomoyo_chroot_acl(path);
+	tomoyo_read_unlock(idx);
+	return error;
+}
+
+/**
+ * tomoyo_write_chroot_policy - Write "struct tomoyo_chroot_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct tomoyo_domain_info".
+ * @condition: Pointer to "struct tomoyo_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int tomoyo_write_chroot_policy(char *data, struct tomoyo_domain_info *domain,
+			       struct tomoyo_condition *condition,
+			       const bool is_delete)
+{
+	struct tomoyo_chroot_acl *entry = NULL;
+	struct tomoyo_acl_info *ptr;
+	struct tomoyo_chroot_acl e = {
+		.head.type = TOMOYO_TYPE_CHROOT_ACL,
+		.head.cond = condition
+	};
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (data[0] != '@' && !tomoyo_is_correct_path(data, 1, 0, 1))
+		return -EINVAL;
+	if (!tomoyo_parse_name_union(data, &e.dir))
+		return error;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&tomoyo_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct tomoyo_chroot_acl *acl =
+			container_of(ptr, struct tomoyo_chroot_acl, head);
+		if (ptr->type != TOMOYO_TYPE_CHROOT_ACL ||
+		    ptr->cond != condition
+		    || memcmp(&acl->dir, &e.dir, sizeof(e.dir)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && tomoyo_commit_ok(entry, &e, sizeof(e))) {
+		tomoyo_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&tomoyo_policy_lock);
+	tomoyo_put_name_union(&e.dir);
+	kfree(entry);
+	return error;
+}
