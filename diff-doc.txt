Index: tags/htdocs/ja/1.6.x/new-policy-reference.html
===================================================================
--- tags/htdocs/ja/1.6.x/new-policy-reference.html	(revision 1081)
+++ tags/htdocs/ja/1.6.x/new-policy-reference.html	(working copy)
@@ -25,14 +25,14 @@
 <p><a href="#domain_definition">4.1 ドメインとは</a></p>
 <p><a href="#domain_transition">4.2 ドメイン遷移とは</a></p>
 <p><a href="#access_logs">4.3 アクセスログについて</a></p>
+<h2><a href="#Syntax_Details">5. キーワード詳細</a></h2>
 
-<h2><a href="#features_for_intermediate">中級者向けの機能</a></h2>
+<h2><a href="#features_for_intermediate">6. 便利な機能</a></h2>
 <p><a href="#sleep_penalty">ポリシー違反時のペナルティ指定</a></p>
 <p><a href="#conditional_acl">条件付きアクセス許可の指定</a></p>
-<h2><a href="#features_for_advanced">上級者向けの機能</a></h2>
+<p><a href="#execute_handler">プログラムの実行可否をカーネルの外部で判断</a></p>
 <p><a href="#stateful_acl">ステートフルなアクセス許可の指定</a></p>
-<p><a href="#denied_execute_handler_penalty">許可されていないプログラムの実行が要求された場合の代替処理指定</a></p>
-<p><a href="#always_denied_execute_handler">プログラムの実行可否をカーネルの外部で判断</a></p>
+<p><a href="#denied_execute_handler">許可されていないプログラムの実行が要求された場合の代替処理指定</a></p>
 
 <hr>
 
@@ -1759,8 +1759,68 @@
 
 <p>exec はプログラム実行時（つまり<a href="#domain_policy_allow_execute">allow_execute</a>）に限り指定できます。</p>
 
-<h2><a name="features_for_advanced">上級者向けの機能</a></h2>
 
+
+<h3><a name="execute_handler">プログラムの実行可否をカーネルの外部で判断</a></h3>
+
+<p>TOMOYO Linuxでは、原則としてポリシーに従ってプログラムの実行可否を制御します。プログラム実行時のパラメータをチェックしたい場合には、<a href="#conditional_acl">条件付きアクセス許可の指定</a>で説明したようにexec.argvやexec.envpを使ってチェックを行うことができます。しかし、<a href="#conditional_acl">条件付きアクセス許可の指定</a>では、単純なパターンマッチしかサポートされておらず、また、どのようなプログラムの実行を許可するかを予め指定しておく必要があります。</p>
+
+<p>そこで、TOMOYO Linux 1.6.0では<a href="#domain_policy_execute_handler">execute_handler</a>という仕組みが導入されました。この仕組みは、プログラムの実行可否をカーネルが判断するのではなく、<a href="#domain_policy_execute_handler">execute_handler</a>により指定されたプログラムが判断し、プログラムの実行を許可すべきと判断した場合には実際にプログラムを実行するという動作をします。</p>
+
+<p>Linuxに於いては、プログラムを実行するという動作は、プログラムの実行を要求したプロセスを上書きするという動作であり、プログラムの実行に成功した場合にはプログラムの実行を要求したプロセスに制御が戻ることはありません。つまり、要求されたプログラムの実行に失敗した場合にしか、プログラムの実行を要求したプロセスに対して、要求されたプログラムが実行されなかったことが通知されません。<br>
+例えば、プログラムＡとして動作しているプロセスがプログラムＢの実行を要求する場合を考えてみます。<br>
+プログラムＡとして動作しているプロセスがプログラムＢの実行を要求すると、カーネルが「プログラムＡとして動作しているプロセスからプログラムＢを実行することは適切であるかどうか」をポリシーを照合することで判断し、適切であると判断された場合には「プログラムＡとして動作しているプロセスをプログラムＢで上書き」し、適切では無いと判断された場合には「プログラムＡとして動作しているプロセスにプログラムＢの実行が認められていないことを通知」します。</p>
+
+<p><a href="#domain_policy_execute_handler">execute_handler</a>を指定した場合、
+execute_handlerとして指定されたプログラムＣがこの動作に介在します。<br>
+プログラムＡとして動作しているプロセスがプログラムＢの実行を要求すると、プログラムＣに「プログラムＡとして動作しているプロセスからプログラムＢを実行することは適切であるかどうか」を判断してもらうために「プログラムＡとして動作しているプロセスをプログラムＣで上書き」します。プログラムＣとして動作するようになったプロセスが「プログラムＡとして動作していたプロセスからプログラムＢを実行することは適切であるかどうか」を判断し、適切であると判断した場合には「プログラムＣとして動作しているプロセスをプログラムＢで上書き」し、適切では無いと判断された場合には「プログラムＣとして動作しているプロセスをプログラムＢで上書きせずに終了」します。</p>
+
+<p>このように、プログラムＢの実行を要求したプログラムＡとして動作していたプロセスがに対して、プログラムＢの実行に失敗したことを通知する手段を放棄することになるため、プログラムＢの実行を要求したプログラムＡとして動作していたプロセスが、プログラムＢが実行されなかったという通知を受けることができなくなるという副作用が発生します。<br>
+しかし、たとえ<a href="#domain_policy_execute_handler">execute_handler</a>を指定していない場合であっても、「共有ライブラリの読み込みができなかった」「 KILL シグナルを受信した」「メモリ不足になり OOM killer によって強制終了させられた」など、様々な要因によって「実行には成功したが期待された動作を始める前に終了してしまった」という状況が起こりえます。つまり、「プログラムの実行が失敗しなかった」ということと「要求されたプログラムが期待した動作を始めた」ということの間には、不確定要素が存在します。<br>
+そう考えると、「プログラムの実行に失敗したという通知が無い限りプログラムは期待された動作を始める」という保証は最初から存在しないわけなので、<a href="#domain_policy_execute_handler">execute_handler</a>により指定されたプログラムＣが、プログラムＢの実行に失敗したことをプログラムＢの実行を要求したプログラムＡとして動作していたプロセスに通知できなかったという結果になったとしても、容認できる範囲であると言えると思います。</p>
+
+
+
+どのプログラムからどのプログラムを実行する必要があるかを事前に把握して、必要最小限のプログラムの実行のみを認めるというアプローチを採用しています。そのため、プログラムの実行可否を判断します。
+不要なプログラムの実行を拒否するという振る舞いだけでなく、それ以外の振る舞いを行うこともできます。</p>
+
+<p>execute_handlerで指定されたプログラムは、以下のパラメータを受け取ります。</p>
+
+<ul>
+<li>argv[0] には、execute_handlerで指定されたプログラムのパス名が入っています。</li>
+<li>argv[1] には、プログラムの実行を要求したプロセスのドメイン名が入っています。</li>
+<li>argv[2] には、プログラムの実行を要求したプロセスのパス名が入っています。</li>
+<li>argv[3] には、プログラムの実行を要求したプロセスの情報が入っています。</li>
+<li>argv[4] には、実行が要求されたプログラムのパス名が入っています。</li>
+<li>argv[5] には、プログラム実行要求時の引数の数が入っています。</li>
+<li>argv[6] には、プログラム実行要求時の環境変数の数が入っています。</li>
+<li>argv[7] から argv[6 + argc] には、呼び出し元プロセスが渡した argv[] の内容が入っています。</li>
+<li>argv[7 + argc] から argv [6 + argc + envc] には、呼び出し元プロセスが渡した envp[] の内容が入っています。</li>
+<li>環境変数 envp[] は全てクリアされます。</li>
+<li>標準入出力などは呼び出し元プロセスのものを引き継ぎます。</li>
+</ul>
+
+<p>ccs-tools のソースパッケージには、 audit-exec-param.c というサンプルプログラムが入っています。</p>
+
+
+
+<p><a href="#denied_execute_handler">許可されていないプログラムの実行が要求された場合の代替処理指定</a>で述べたとおり、正常な動作をしている限り、ポリシーで許可されていないプログラムの実行要求は起こらないはずだと仮定すると、全てのプログラムの実行要求を受理して構わないと考えることができます。もしも受理すべきではないプログラムの実行要求が発生した場合、<a href="#domain_policy_denied_execute_handler">denied_execute_handler</a>の機能を使うことで要求を拒否する代わりにそのプロセスを強制終了させるなどの行動を起こすことができます。つまり、カーネルの内部でプログラムの実行可否の判断を行わなくても構わないということです。</p>
+
+<p>そこで、ドメインに対して <a href="#domain_policy_execute_handler">execute_handler</a>キーワードを指定しておくことで、そのドメインから発生する全てのプログラムの実行可否の判断をカーネル外部のプログラムに委ねることができるようになります。</p>
+<p>カーネルの内部では利用可能なライブラリが少ない上に連続したメモリ領域の割り当てが失敗する可能性が高くなりますが、
+カーネルの外部であれば豊富なライブラリを使ってメモリ割り当ての限界を心配せずに詳細なチェックが可能になります。そこで、<a href="#domain_policy_execute_handler">execute_handler</a>で指定したプログラムにプログラム実行時のパラメータをチェックしてもらい、適切であればプログラムを実行してもらうようにすることができます。</p>
+
+<p>この方式の副作用は、プログラムの実行を拒否すべきと判断した場合に、プログラムの実行を要求したプロセスに通知する方法が無い点です。しかし、自由にカスタマイズできるので、 ssh 等を用いて遠隔地のマシンに問い合わせをしながらしながら判断することも可能です。</p>
+
+<p>この機能を使うには、以下のように指定します。</p>
+
+<table border="1">
+<tr><td>/proc/ccs/domain_policy の例</td><td>意味</td></tr>
+<tr><td>execute_handler /usr/sbin/check-and-exec</td><td>このドメインに属しているプロセスがプログラムの実行を要求した場合、要求されたプログラムを実行する代わりに/usr/sbin/check-and-execを実行する。/usr/sbin/check-and-execはパラメータをチェックし、妥当と判断した場合には要求されたプログラムを実行する。</td></tr>
+</table>
+
+
+
 <h3><a name="stateful_acl">ステートフルなアクセス許可の指定</a></h3>
 
 <p>TOMOYO Linux はユーザランドアプリケーションの修正を行わないため、プログラムの実行を伴わずにアクセス可能な資源の範囲を変更することはできません。しかし、例えば接続元クライアントのＩＰアドレスによってアクセスの可否を切り替えたいという場合があります。そのような場合に対応するため、プロセス毎に状態変数を割り当てることができ、条件付きアクセス許可の指定で使えるようになっています。</p>
@@ -1791,7 +1851,7 @@
 <li>上記の @TRUSTED_HOSTS と @UNTRUSTED_HOSTS の両方に含まれていた場合、先に一致したほうの状態変数が使われてしまう。そのため、順番に依存するアクセス許可を定義しないように注意。</li>
 </ul>
 
-<h3><a name="denied_execute_handler_penalty">許可されていないプログラムの実行が要求された場合の代替処理指定</a></h3>
+<h3><a name="denied_execute_handler">許可されていないプログラムの実行が要求された場合の代替処理指定</a></h3>
 
 <p>TOMOYO Linux では、どのプログラムからどのプログラムを実行する必要があるかを事前に把握して、必要最小限のプログラムの実行のみを認めるというアプローチを採用しています。そのため、不要なプログラムの実行を拒否するという振る舞いだけでなく、それ以外の振る舞いを行うこともできます。</p>
 
@@ -1822,81 +1882,8 @@
 <tr><td>3-MAC_FOR_FILE=enforcing</td><td>use_profile 3<br>denied_execute_handler /bin/true</td><td>プロファイル 3 が割り当てられているドメインに属しているプロセスが、許可されていないプログラムの実行を要求した場合、代わりに /bin/true を実行する。</td></tr>
 </table>
 
-<p>denied_execute_handlerで指定されたプログラムは、以下のパラメータを受け取ります。</p>
 
-<ul>
-<li>argv[0] には、denied_execute_handlerで指定されたプログラムのパス名が入っています。</li>
-<li>argv[1] には、許可されていないプログラムの実行を要求したプロセスのドメイン名が入っています。</li>
-<li>argv[2] には、許可されていないプログラムの実行を要求したプロセスのパス名が入っています。</li>
-<li>argv[3] には、許可されていないプログラムの実行を要求したプロセスの情報が入っています。</li>
-<li>argv[4] には、許可されなかったプログラムのパス名が入っています。</li>
-<li>argv[5] には、プログラム実行時の引数の数が入っています。</li>
-<li>argv[6] には、プログラム実行時の環境変数の数が入っています。</li>
-<li>argv[7] から argv[6 + argc] には、呼び出し元プロセスが渡した argv[] の内容が入っています。</li>
-<li>argv[7 + argc] から argv [6 + argc + envc] には、呼び出し元プロセスが渡した envp[] の内容が入っています。</li>
-<li>環境変数 envp[] は全てクリアされます。</li>
-<li>標準入出力などは呼び出し元プロセスのものを引き継ぎます。</li>
-</ul>
 
-<p>パラメータを表示するサンプルプログラムは以下のようになります。</p>
-
-<table border="1">
-<tr><td><pre>
-#! /bin/sh
-# Don't invoke this program from the command line.
-# This program is invoked by the kernel, with all environment variables cleared.
-# You might need to set environment variable PATH to run this program.
-#
-[ $# -ge 6 ] || exit 1
-
-echo "----- Domain information -----"
-echo $1
-shift
-
-echo "----- Program information -----"
-echo $1
-shift
-
-echo "----- Process information -----"
-echo $1
-shift
-
-echo "----- Rejected Program information -----"
-echo $1
-shift
-
-ARGC=$1
-shift
-echo "----- Number of commandline arguments -----"
-echo $ARGC
-
-ENVC=$1
-shift
-echo "----- Number of environment variables -----"
-echo $ENVC
-
-echo "----- argv[] information -----"
-
-while [ $ARGC -gt 0 ]
-do
-  echo $1
-  shift
-  ARGC=`expr $ARGC - 1`
-done
-
-echo "----- envp[] information -----"
-
-while [ $ENVC -gt 0 ]
-do
-  echo $1
-  shift
-  ENVC=`expr $ENVC - 1`
-done
-
-exit 1
-</pre></td></tr>
-</table>
-
 <p>この機能を使用する際には、以下の点に注意してください。</p>
 
 <ul>
@@ -1908,23 +1895,6 @@
 
 <p>この機能は、機構を提供しているだけです。この機構を活用できるかどうかはあなた次第です。</p>
 
-<h3><a name="always_denied_execute_handler">プログラムの実行可否をカーネルの外部で判断</a></h3>
-
-<p><a href="#denied_execute_handler_penalty">許可されていないプログラムの実行が要求された場合の代替処理指定</a>で述べたとおり、正常な動作をしている限り、ポリシーで許可されていないプログラムの実行要求は起こらないはずだと仮定すると、全てのプログラムの実行要求を受理して構わないと考えることができます。もしも受理すべきではないプログラムの実行要求が発生した場合、<a href="#domain_policy_denied_execute_handler">denied_execute_handler</a>の機能を使うことで要求を拒否する代わりにそのプロセスを強制終了させるなどの行動を起こすことができます。つまり、カーネルの内部でプログラムの実行可否の判断を行わなくても構わないということです。</p>
-
-<p>そこで、ドメインに対して <a href="#domain_policy_execute_handler">execute_handler</a>キーワードを指定しておくことで、そのドメインから発生する全てのプログラムの実行可否の判断をカーネル外部のプログラムに委ねることができるようになります。</p>
-<p>カーネルの内部では利用可能なライブラリが少ない上に連続したメモリ領域の割り当てが失敗する可能性が高くなりますが、
-カーネルの外部であれば豊富なライブラリを使ってメモリ割り当ての限界を心配せずに詳細なチェックが可能になります。そこで、<a href="#domain_policy_execute_handler">execute_handler</a>で指定したプログラムにプログラム実行時のパラメータをチェックしてもらい、適切であればプログラムを実行してもらうようにすることができます。</p>
-
-<p>この方式の副作用は、プログラムの実行を拒否すべきと判断した場合に、プログラムの実行を要求したプロセスに通知する方法が無い点です。しかし、自由にカスタマイズできるので、 ssh 等を用いて遠隔地のマシンに問い合わせをしながらしながら判断することも可能です。</p>
-
-<p>この機能を使うには、以下のように指定します。</p>
-
-<table border="1">
-<tr><td>/proc/ccs/domain_policy の例</td><td>意味</td></tr>
-<tr><td>execute_handler /usr/sbin/check-and-exec</td><td>このドメインに属しているプロセスがプログラムの実行を要求した場合、要求されたプログラムを実行する代わりに/usr/sbin/check-and-execを実行する。/usr/sbin/check-and-execはパラメータをチェックし、妥当と判断した場合には要求されたプログラムを実行する。</td></tr>
-</table>
-
 <hr>
 <p><a href="index.html#manual">目次へ戻る</a></p>
 <hr>
