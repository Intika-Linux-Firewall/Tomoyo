[PATCH] TOMOYO 2.5 backport patch for Linux 2.6.34

Apply this patch after overwriting security/tomoyo/ directory by doing

 $ wget http://www.kernel.org/pub/linux/kernel/v3.0/linux-3.5.tar.bz2
 $ tar -jxf linux-3.5.tar.bz2 --strip 1 linux-3.5/security/tomoyo/

.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/domain.c        |    4 -
 security/tomoyo/gc.c            |   12 +++++
 security/tomoyo/realpath.c      |   86 ++++++++++++++++++++++++++++++----------
 security/tomoyo/securityfs_if.c |    1 
 security/tomoyo/tomoyo.c        |   24 ++++++-----
 5 files changed, 94 insertions(+), 33 deletions(-)

--- linux-2.6.34.11.orig/security/tomoyo/domain.c
+++ linux-2.6.34.11/security/tomoyo/domain.c
@@ -886,12 +886,12 @@ bool tomoyo_dump_page(struct linux_binpr
 		 * But remove_arg_zero() uses kmap_atomic()/kunmap_atomic().
 		 * So do I.
 		 */
-		char *kaddr = kmap_atomic(page);
+		char *kaddr = kmap_atomic(page, KM_USER0);
 
 		dump->page = page;
 		memcpy(dump->data + offset, kaddr + offset,
 		       PAGE_SIZE - offset);
-		kunmap_atomic(kaddr);
+		kunmap_atomic(kaddr, KM_USER0);
 	}
 	/* Same with put_arg_page(page) in fs/exec.c */
 #ifdef CONFIG_MMU
--- linux-2.6.34.11.orig/security/tomoyo/gc.c
+++ linux-2.6.34.11/security/tomoyo/gc.c
@@ -362,6 +362,18 @@ static inline void tomoyo_del_number_gro
 }
 
 /**
+ * __list_del_entry - Deletes entry from list without re-initialization.
+ *
+ * @entry: Pointer to "struct list_head".
+ *
+ * Returns nothing.
+ */
+static inline void __list_del_entry(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+/**
  * tomoyo_try_to_gc - Try to kfree() an entry.
  *
  * @type:    One of values in "enum tomoyo_policy_id".
--- linux-2.6.34.11.orig/security/tomoyo/realpath.c
+++ linux-2.6.34.11/security/tomoyo/realpath.c
@@ -5,6 +5,7 @@
  */
 
 #include "common.h"
+#include "../../fs/internal.h"
 #include <linux/magic.h>
 
 /**
@@ -87,24 +88,55 @@ char *tomoyo_encode(const char *str)
  *
  * Returns the buffer on success, an error code otherwise.
  *
+ * Caller holds the dcache_lock and vfsmount_lock.
+ * Based on __d_path() in fs/dcache.c
+ *
  * If dentry is a directory, trailing '/' is appended.
  */
 static char *tomoyo_get_absolute_path(struct path *path, char * const buffer,
 				      const int buflen)
 {
-	char *pos = ERR_PTR(-ENOMEM);
-	if (buflen >= 256) {
-		/* go to whatever namespace root we are under */
-		pos = d_absolute_path(path, buffer, buflen - 1);
-		if (!IS_ERR(pos) && *pos == '/' && pos[1]) {
-			struct inode *inode = path->dentry->d_inode;
-			if (inode && S_ISDIR(inode->i_mode)) {
-				buffer[buflen - 2] = '/';
-				buffer[buflen - 1] = '\0';
-			}
+	char *pos = buffer + buflen - 1;
+	struct dentry *dentry = path->dentry;
+	struct vfsmount *vfsmnt = path->mnt;
+	const char *name;
+	int len;
+
+	if (buflen < 256)
+		goto out;
+
+	*pos = '\0';
+	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode))
+		*--pos = '/';
+	for (;;) {
+		struct dentry *parent;
+		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
+			if (vfsmnt->mnt_parent == vfsmnt)
+				break;
+			dentry = vfsmnt->mnt_mountpoint;
+			vfsmnt = vfsmnt->mnt_parent;
+			continue;
 		}
-	}
+		parent = dentry->d_parent;
+		name = dentry->d_name.name;
+		len = dentry->d_name.len;
+		pos -= len;
+		if (pos <= buffer)
+			goto out;
+		memmove(pos, name, len);
+		*--pos = '/';
+		dentry = parent;
+	}
+	if (*pos == '/')
+		pos++;
+	len = dentry->d_name.len;
+	pos -= len;
+	if (pos < buffer)
+		goto out;
+	memmove(pos, dentry->d_name.name, len);
 	return pos;
+out:
+	return ERR_PTR(-ENOMEM);
 }
 
 /**
@@ -121,17 +153,27 @@ static char *tomoyo_get_absolute_path(st
 static char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,
 				    const int buflen)
 {
-	char *pos = ERR_PTR(-ENOMEM);
-	if (buflen >= 256) {
-		pos = dentry_path_raw(dentry, buffer, buflen - 1);
-		if (!IS_ERR(pos) && *pos == '/' && pos[1]) {
-			struct inode *inode = dentry->d_inode;
-			if (inode && S_ISDIR(inode->i_mode)) {
-				buffer[buflen - 2] = '/';
-				buffer[buflen - 1] = '\0';
-			}
+	char *pos = buffer + buflen - 1;
+	if (buflen < 256)
+		return ERR_PTR(-ENOMEM);
+	*pos = '\0';
+	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode))
+		*--pos = '/';
+	spin_lock(&dcache_lock);
+	while (!IS_ROOT(dentry)) {
+		struct dentry *parent = dentry->d_parent;
+		const char *name = dentry->d_name.name;
+		const int len = dentry->d_name.len;
+		pos -= len;
+		if (pos <= buffer) {
+			pos = ERR_PTR(-ENOMEM);
+			break;
 		}
+		memmove(pos, name, len);
+		*--pos = '/';
+		dentry = parent;
 	}
+	spin_unlock(&dcache_lock);
 	return pos;
 }
 
@@ -287,7 +329,11 @@ char *tomoyo_realpath_from_path(struct p
 						    buf_len - 1);
 		/* Get absolute name for the rest. */
 		else {
+			spin_lock(&dcache_lock);
+			spin_lock(&vfsmount_lock);
 			pos = tomoyo_get_absolute_path(path, buf, buf_len - 1);
+			spin_unlock(&vfsmount_lock);
+			spin_unlock(&dcache_lock);
 			/*
 			 * Fall back to local name if absolute name is not
 			 * available.
--- linux-2.6.34.11.orig/security/tomoyo/securityfs_if.c
+++ linux-2.6.34.11/security/tomoyo/securityfs_if.c
@@ -212,7 +212,6 @@ static const struct file_operations tomo
 	.poll    = tomoyo_poll,
 	.read    = tomoyo_read,
 	.write   = tomoyo_write,
-	.llseek  = noop_llseek,
 };
 
 /**
--- linux-2.6.34.11.orig/security/tomoyo/tomoyo.c
+++ linux-2.6.34.11/security/tomoyo/tomoyo.c
@@ -157,7 +157,8 @@ static int tomoyo_inode_getattr(struct v
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int tomoyo_path_truncate(struct path *path)
+static int tomoyo_path_truncate(struct path *path, loff_t length,
+				unsigned int time_attrs)
 {
 	return tomoyo_path_perm(TOMOYO_TYPE_TRUNCATE, path, NULL);
 }
@@ -186,7 +187,7 @@ static int tomoyo_path_unlink(struct pat
  * Returns 0 on success, negative value otherwise.
  */
 static int tomoyo_path_mkdir(struct path *parent, struct dentry *dentry,
-			     umode_t mode)
+			     int mode)
 {
 	struct path path = { parent->mnt, dentry };
 	return tomoyo_path_number_perm(TOMOYO_TYPE_MKDIR, &path,
@@ -234,7 +235,7 @@ static int tomoyo_path_symlink(struct pa
  * Returns 0 on success, negative value otherwise.
  */
 static int tomoyo_path_mknod(struct path *parent, struct dentry *dentry,
-			     umode_t mode, unsigned int dev)
+			     int mode, unsigned int dev)
 {
 	struct path path = { parent->mnt, dentry };
 	int type = TOMOYO_TYPE_CREATE;
@@ -319,14 +320,14 @@ static int tomoyo_file_fcntl(struct file
 }
 
 /**
- * tomoyo_file_open - Target for security_file_open().
+ * tomoyo_dentry_open - Target for security_dentry_open().
  *
  * @f:    Pointer to "struct file".
  * @cred: Pointer to "struct cred".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int tomoyo_file_open(struct file *f, const struct cred *cred)
+static int tomoyo_dentry_open(struct file *f, const struct cred *cred)
 {
 	int flags = f->f_flags;
 	/* Don't check read permission here if called from do_execve(). */
@@ -353,14 +354,17 @@ static int tomoyo_file_ioctl(struct file
 /**
  * tomoyo_path_chmod - Target for security_path_chmod().
  *
- * @path: Pointer to "struct path".
- * @mode: DAC permission mode.
+ * @dentry: Pointer to "struct dentry".
+ * @mnt:    Pointer to "struct vfsmount".
+ * @mode:   DAC permission mode.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int tomoyo_path_chmod(struct path *path, umode_t mode)
+static int tomoyo_path_chmod(struct dentry *dentry, struct vfsmount *mnt,
+			     mode_t mode)
 {
-	return tomoyo_path_number_perm(TOMOYO_TYPE_CHMOD, path,
+	struct path path = { mnt, dentry };
+	return tomoyo_path_number_perm(TOMOYO_TYPE_CHMOD, &path,
 				       mode & S_IALLUGO);
 }
 
@@ -510,7 +514,7 @@ static struct security_operations tomoyo
 	.bprm_set_creds      = tomoyo_bprm_set_creds,
 	.bprm_check_security = tomoyo_bprm_check_security,
 	.file_fcntl          = tomoyo_file_fcntl,
-	.file_open           = tomoyo_file_open,
+	.dentry_open         = tomoyo_dentry_open,
 	.path_truncate       = tomoyo_path_truncate,
 	.path_unlink         = tomoyo_path_unlink,
 	.path_mkdir          = tomoyo_path_mkdir,
