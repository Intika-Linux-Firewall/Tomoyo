[PATCH] TOMOYO 2.5 backport patch for Linux 2.6.37

Apply this patch after overwriting security/tomoyo/ directory by doing

 $ wget -O linux.tar.gz 'http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=snapshot;h=2380078cdb7e6d520e33dcf834e0be979d542e48;sf=tgz'
 $ tar -zxf linux.tar.gz --strip 1 'linux-*/security/tomoyo/'

.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/gc.c       |   12 ++++++++++++
 security/tomoyo/realpath.c |   28 +++++++++++++++++++---------
 2 files changed, 31 insertions(+), 9 deletions(-)

--- linux-2.6.37.6.orig/security/tomoyo/gc.c
+++ linux-2.6.37.6/security/tomoyo/gc.c
@@ -362,6 +362,18 @@ static inline void tomoyo_del_number_gro
 }
 
 /**
+ * __list_del_entry - Deletes entry from list without re-initialization.
+ *
+ * @entry: Pointer to "struct list_head".
+ *
+ * Returns nothing.
+ */
+static inline void __list_del_entry(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+/**
  * tomoyo_try_to_gc - Try to kfree() an entry.
  *
  * @type:    One of values in "enum tomoyo_policy_id".
--- linux-2.6.37.6.orig/security/tomoyo/realpath.c
+++ linux-2.6.37.6/security/tomoyo/realpath.c
@@ -129,17 +129,27 @@ static char *tomoyo_get_absolute_path(st
 static char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,
 				    const int buflen)
 {
-	char *pos = ERR_PTR(-ENOMEM);
-	if (buflen >= 256) {
-		pos = dentry_path_raw(dentry, buffer, buflen - 1);
-		if (!IS_ERR(pos) && *pos == '/' && pos[1]) {
-			struct inode *inode = dentry->d_inode;
-			if (inode && S_ISDIR(inode->i_mode)) {
-				buffer[buflen - 2] = '/';
-				buffer[buflen - 1] = '\0';
-			}
+	char *pos = buffer + buflen - 1;
+	if (buflen < 256)
+		return ERR_PTR(-ENOMEM);
+	*pos = '\0';
+	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode))
+		*--pos = '/';
+	spin_lock(&dcache_lock);
+	while (!IS_ROOT(dentry)) {
+		struct dentry *parent = dentry->d_parent;
+		const char *name = dentry->d_name.name;
+		const int len = dentry->d_name.len;
+		pos -= len;
+		if (pos <= buffer) {
+			pos = ERR_PTR(-ENOMEM);
+			break;
 		}
+		memmove(pos, name, len);
+		*--pos = '/';
+		dentry = parent;
 	}
+	spin_unlock(&dcache_lock);
 	return pos;
 }
 
