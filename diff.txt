Index: trunk/1.6.x/ccs-patch/include/linux/ccs_common.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(revision 2032)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(working copy)
@@ -229,11 +229,6 @@
 	rcu_assign_pointer(prev->next, new);
 }
 
-/* Temporary buffer for holding pathnames. */
-struct ccs_page_buffer {
-	char buffer[4096];
-};
-
 /* Subset of "struct stat". */
 struct ccs_mini_stat {
 	uid_t uid;
@@ -244,6 +239,12 @@
 	dev_t rdev;
 };
 
+/* Structure for dumping argv[] and envp[] of "struct linux_binprm". */
+struct ccs_page_dump {
+	struct page *page;    /* Previously dumped page. */
+	char *data;           /* Contents of "page". Size is PAGE_SIZE. */
+};
+
 /* Structure for attribute checks in addition to pathname checks. */
 struct ccs_obj_info {
 	bool validate_done;
@@ -258,7 +259,6 @@
 	/* I don't handle path2_stat for rename operation. */
 	struct ccs_mini_stat path1_parent_stat;
 	struct ccs_mini_stat path2_parent_stat;
-	struct ccs_page_buffer *tmp;
 };
 
 /* Structure for " if " and "; set" part. */
@@ -273,11 +273,13 @@
 	/* "struct ccs_envp_entry envp[envc]" follows here. */
 };
 
+struct ccs_execve_entry;
+
 /* Structure for request info. */
 struct ccs_request_info {
 	struct domain_info *domain;
-	struct linux_binprm *bprm;
 	struct ccs_obj_info *obj;
+	struct ccs_execve_entry *ee;
 	const struct ccs_condition_list *cond;
 	u16 retry;
 	u8 profile;
@@ -304,6 +306,26 @@
  */
 #define CCS_MAX_PATHNAME_LEN 4000
 
+#define CCS_EXEC_TMPSIZE     4096
+
+/* Structure for execve() operation. */
+struct ccs_execve_entry {
+	struct list_head list;
+	struct task_struct *task; /* = current */
+	struct ccs_request_info r;
+	struct ccs_obj_info obj;
+	struct linux_binprm *bprm;
+	/* For execute_handler */
+	const struct ccs_path_info *handler;
+	/* For calculating domain to transit to. */
+	struct domain_info *next_domain; /* Initialized to NULL. */
+	char *program_path; /* Size is CCS_MAX_PATHNAME_LEN bytes */
+	/* For dumping argv[] and envp[]. */
+	struct ccs_page_dump dump;
+	/* For temporary use. */
+	char *tmp; /* Size is CCS_EXEC_TMPSIZE bytes */
+};
+
 /* Structure for "path_group" directive. */
 struct ccs_path_group_member {
 	struct list1_head list;
@@ -647,6 +669,9 @@
 			 const struct ccs_acl_info *acl);
 /* Check whether the domain has too many ACL entries to hold. */
 bool ccs_check_domain_quota(struct domain_info * const domain);
+/* Dump a page to buffer. */
+bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos,
+		   struct ccs_page_dump *dump);
 /* Transactional sprintf() for policy dump. */
 bool ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
@@ -896,39 +921,6 @@
 		acl->access_me_via_ccs_get_condition_part : NULL;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
-
-/* Same with get_arg_page(bprm, pos, 0) in fs/exec.c */
-static inline struct page *ccs_get_arg_page(struct linux_binprm *bprm,
-					    unsigned long pos)
-{
-	struct page *page;
-	if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0)
-		return NULL;
-	return page;
-}
-
-/* Same with put_arg_page(page) in fs/exec.c */
-static inline void ccs_put_arg_page(struct page *page)
-{
-	put_page(page);
-}
-
-#else
-
-static inline struct page *ccs_get_arg_page(struct linux_binprm *bprm,
-					    unsigned long pos)
-{
-	return bprm->page[pos / PAGE_SIZE];
-}
-
-static inline void ccs_put_arg_page(struct page *page)
-{
-}
-
-#endif
-
-
 /* A linked list of domains. */
 extern struct list1_head ccs_domain_list;
 /* Has /sbin/init started? */
Index: trunk/1.6.x/ccs-patch/include/linux/realpath.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/realpath.h	(revision 2032)
+++ trunk/1.6.x/ccs-patch/include/linux/realpath.h	(working copy)
@@ -20,6 +20,7 @@
 struct ccs_condition_list;
 struct ccs_path_info;
 struct ccs_io_buffer;
+struct ccs_execve_entry;
 
 /* Returns realpath(3) of the given pathname but ignores chroot'ed root. */
 int ccs_realpath_from_dentry2(struct dentry *dentry, struct vfsmount *mnt,
@@ -31,8 +32,8 @@
  * if these functions didn't return NULL.
  */
 char *ccs_realpath(const char *pathname);
-/* Same with ccs_realpath() except that it doesn't follow the final symlink. */
-char *ccs_realpath_nofollow(const char *pathname);
+/* Get ccs_realpath() of both symlink and dereferenced pathname. */
+bool ccs_realpath_both(const char *pathname, struct ccs_execve_entry *ee);
 /* Same with ccs_realpath() except that the pathname is already solved. */
 char *ccs_realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt);
 
Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(revision 2032)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(working copy)
@@ -161,8 +161,25 @@
 int pre_vfs_mknod(struct inode *dir, struct dentry *dentry, int mode);
 #endif
 
-int search_binary_handler_with_transition(struct linux_binprm *bprm,
-					  struct pt_regs *regs);
+int ccs_start_execve(struct linux_binprm *bprm);
+void ccs_finish_execve(int retval);
+
+struct linux_binprm;
+struct pt_regs;
+int search_binary_handler(struct linux_binprm *, struct pt_regs *);
+
+static inline int
+search_binary_handler_with_transition(struct linux_binprm *bprm,
+				      struct pt_regs *regs)
+{
+	int retval;
+	retval = ccs_start_execve(bprm);
+	if (!retval)
+		retval = search_binary_handler(bprm, regs);
+	ccs_finish_execve(retval);
+	return retval;
+}
+
 #define TOMOYO_CHECK_READ_FOR_OPEN_EXEC 1
 #define CCS_DONT_SLEEP_ON_ENFORCE_ERROR 2
 #define TOMOYO_TASK_IS_EXECUTE_HANDLER  4
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.28.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.28.diff	(revision 2032)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.28.diff	(working copy)
@@ -5,9 +5,9 @@
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
  fs/attr.c                       |   10 +++
- fs/compat.c                     |    5 +
+ fs/compat.c                     |   11 +++
  fs/compat_ioctl.c               |    9 +++
- fs/exec.c                       |   21 ++++++-
+ fs/exec.c                       |   27 +++++++++
  fs/fcntl.c                      |    9 +++
  fs/ioctl.c                      |    7 ++
  fs/namei.c                      |  120 ++++++++++++++++++++++++++++++++++++++++
@@ -34,7 +34,7 @@
  net/ipv4/udp.c                  |    9 ++-
  net/socket.c                    |   41 +++++++++++++
  net/unix/af_unix.c              |   15 +++++
- 32 files changed, 587 insertions(+), 3 deletions(-)
+ 32 files changed, 601 insertions(+), 1 deletion(-)
 
 --- linux-2.6.28.orig/fs/Kconfig
 +++ linux-2.6.28/fs/Kconfig
@@ -91,12 +91,19 @@
  
  int compat_log = 1;
  
-@@ -1437,7 +1440,7 @@ int compat_do_execve(char * filename,
+@@ -1437,7 +1440,15 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
--	retval = search_binary_handler(bprm, regs);
-+	retval = search_binary_handler_with_transition(bprm, regs);
++	/***** TOMOYO Linux start. *****/
++	retval = ccs_start_execve(bprm);
++	if (retval < 0)
++		goto out;
++	/***** TOMOYO Linux end. *****/
+ 	retval = search_binary_handler(bprm, regs);
++	/***** TOMOYO Linux start. *****/
++	ccs_finish_execve(retval);
++	/***** TOMOYO Linux end. *****/
  	if (retval >= 0) {
  		/* execve success */
  		security_bprm_free(bprm);
@@ -167,12 +174,19 @@
  
  	file = nameidata_to_filp(&nd, O_RDONLY|O_LARGEFILE);
  	if (IS_ERR(file))
-@@ -1340,7 +1359,7 @@ int do_execve(char * filename,
+@@ -1340,7 +1359,15 @@ int do_execve(char * filename,
  		goto out;
  
  	current->flags &= ~PF_KTHREAD;
--	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm, regs);
++	/***** TOMOYO Linux start. *****/
++	retval = ccs_start_execve(bprm);
++	if (retval < 0)
++		goto out;
++	/***** TOMOYO Linux end. *****/
+ 	retval = search_binary_handler(bprm,regs);
++	/***** TOMOYO Linux start. *****/
++	ccs_finish_execve(retval);
++	/***** TOMOYO Linux end. *****/
  	if (retval >= 0) {
  		/* execve success */
  		security_bprm_free(bprm);
Index: trunk/1.6.x/ccs-patch/fs/realpath.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/realpath.c	(revision 2032)
+++ trunk/1.6.x/ccs-patch/fs/realpath.c	(working copy)
@@ -271,7 +271,7 @@
  */
 char *ccs_realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt)
 {
-	char *buf = ccs_alloc(sizeof(struct ccs_page_buffer), false);
+	char *buf = ccs_alloc(CCS_MAX_PATHNAME_LEN, false);
 	if (buf && ccs_realpath_from_dentry2(dentry, mnt, buf,
 					     CCS_MAX_PATHNAME_LEN - 1) == 0)
 		return buf;
@@ -304,28 +304,54 @@
 }
 
 /**
- * ccs_realpath_nofollow - Get realpath of a pathname.
+ * ccs_realpath_both - Get realpath of a pathname and symlink.
  *
  * @pathname: The pathname to solve.
+ * @ee:       Pointer to "struct ccs_execve_entry".
  *
- * Returns the realpath of @pathname on success, NULL otherwise.
+ * Returns true on success, false otherwise.
  */
-char *ccs_realpath_nofollow(const char *pathname)
+bool ccs_realpath_both(const char *pathname, struct ccs_execve_entry *ee)
 {
 	struct nameidata nd;
-	if (pathname && path_lookup(pathname, ccs_lookup_flags ^ LOOKUP_FOLLOW,
-				    &nd) == 0) {
+	int ret;
+	bool is_symlink;
+	if (!pathname ||
+	    path_lookup(pathname, ccs_lookup_flags ^ LOOKUP_FOLLOW, &nd))
+		return false;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
-		char *buf = ccs_realpath_from_dentry(nd.path.dentry,
-						     nd.path.mnt);
-		path_put(&nd.path);
+	is_symlink = nd.path.dentry->d_inode &&
+		S_ISLNK(nd.path.dentry->d_inode->i_mode);
+	ret = ccs_realpath_from_dentry2(nd.path.dentry, nd.path.mnt,
+					ee->tmp, CCS_EXEC_TMPSIZE - 1);
+	path_put(&nd.path);
 #else
-		char *buf = ccs_realpath_from_dentry(nd.dentry, nd.mnt);
-		path_release(&nd);
+	is_symlink = nd.dentry->d_inode && S_ISLNK(nd.dentry->d_inode->i_mode);
+	ret = ccs_realpath_from_dentry2(nd.dentry, nd.mnt, ee->tmp,
+					CCS_EXEC_TMPSIZE - 1);
+	path_release(&nd);
 #endif
-		return buf;
+	if (ret)
+		return false;
+	ee->program_path[CCS_MAX_PATHNAME_LEN - 1] = '\0';
+	if (!is_symlink) {
+		strncpy(ee->program_path, ee->tmp,
+			CCS_MAX_PATHNAME_LEN - 1);
+		return true;
 	}
-	return NULL;
+	if (path_lookup(pathname, ccs_lookup_flags, &nd))
+		return false;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	ret = ccs_realpath_from_dentry2(nd.path.dentry, nd.path.mnt,
+					ee->program_path,
+					CCS_MAX_PATHNAME_LEN - 1);
+	path_put(&nd.path);
+#else
+	ret = ccs_realpath_from_dentry2(nd.dentry, nd.mnt, ee->program_path,
+					CCS_MAX_PATHNAME_LEN - 1);
+	path_release(&nd);
+#endif
+	return ret ? false : true;
 }
 
 /**
@@ -518,8 +544,12 @@
 static int __init ccs_realpath_init(void)
 {
 	int i;
+	/* Constraint for ccs_save_name(). */
 	if (CCS_MAX_PATHNAME_LEN > PAGE_SIZE)
 		panic("Bad size.");
+	/* Constraint for "struct ccs_execve_entry"->tmp users. */
+	if (CCS_MAX_PATHNAME_LEN > CCS_EXEC_TMPSIZE)
+		panic("Bad size.");
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
 	ccs_cachep = kmem_cache_create("ccs_cache",
 				       sizeof(struct ccs_cache_entry),
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(revision 2032)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(working copy)
@@ -21,10 +21,12 @@
  * ccs_print_bprm - Print "struct linux_binprm" for auditing.
  *
  * @bprm: Pointer to "struct linux_binprm".
+ * @dump: Pointer to "struct ccs_page_dump".
  *
  * Returns the contents of @bprm on success, NULL otherwise.
  */
-static char *ccs_print_bprm(struct linux_binprm *bprm)
+static char *ccs_print_bprm(struct linux_binprm *bprm,
+			    struct ccs_page_dump *dump)
 {
 	static const int ccs_buffer_len = 4096 * 2;
 	char *buffer = ccs_alloc(ccs_buffer_len, false);
@@ -47,15 +49,12 @@
 	}
 	last_start = cp;
 	while (argv_count || envp_count) {
-		struct page *page = ccs_get_arg_page(bprm, pos);
-		const char *kaddr;
-		if (!page)
+		if (!ccs_dump_page(bprm, pos, dump))
 			goto out;
 		pos += PAGE_SIZE - offset;
-		/* Map */
-		kaddr = kmap(page);
 		/* Read. */
 		while (offset < PAGE_SIZE) {
+			const char *kaddr = dump->data;
 			const unsigned char c = kaddr[offset++];
 			if (cp == last_start)
 				*cp++ = '"';
@@ -103,9 +102,6 @@
 			if (!argv_count && !envp_count)
 				break;
 		}
-		/* Unmap. */
-		kunmap(page);
-		ccs_put_arg_page(page);
 		offset = 0;
 	}
 	*cp++ = '}';
@@ -163,8 +159,8 @@
 	domainname = r->domain->domainname->name;
 	do_gettimeofday(&tv);
 	*len += strlen(domainname) + 256;
-	if (r->bprm) {
-		bprm_info = ccs_print_bprm(r->bprm);
+	if (r->ee) {
+		bprm_info = ccs_print_bprm(r->ee->bprm, &r->ee->dump);
 		if (!bprm_info)
 			return NULL;
 		*len += strlen(bprm_info);
@@ -182,7 +178,7 @@
 			 current_sgid(), current_fsuid(), current_fsgid(),
 			 (u8) (tomoyo_flags >> 24), (u8) (tomoyo_flags >> 16),
 			 (u8) (tomoyo_flags >> 8), bprm_info, domainname);
-	if (r->bprm)
+	if (r->ee)
 		ccs_free(bprm_info);
 	return buf;
 }
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(revision 2032)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(working copy)
@@ -161,20 +161,18 @@
 /**
  * ccs_audit_execute_handler_log - Audit execute_handler log.
  *
+ * @ee:         Pointer to "struct ccs_execve_entry".
  * @is_default: True if it is "execute_handler" log.
- * @handler:    The realpath of the handler.
- * @bprm:       Pointer to "struct linux_binprm".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_audit_execute_handler_log(const bool is_default,
-					 const char *handler,
-					 struct linux_binprm *bprm)
+static int ccs_audit_execute_handler_log(struct ccs_execve_entry *ee,
+					 const bool is_default)
 {
-	struct ccs_request_info r;
-	ccs_init_request_info(&r, NULL, CCS_TOMOYO_MAC_FOR_FILE);
-	r.bprm = bprm;
-	return ccs_write_audit_log(true, &r, "%s %s\n",
+	struct ccs_request_info *r = &ee->r;
+	const char *handler = ee->handler->name;
+	r->mode = ccs_check_flags(r->domain, CCS_TOMOYO_MAC_FOR_FILE);
+	return ccs_write_audit_log(true, r, "%s %s\n",
 				   is_default ? KEYWORD_EXECUTE_HANDLER :
 				   KEYWORD_DENIED_EXECUTE_HANDLER, handler);
 }
@@ -888,15 +886,14 @@
 /**
  * ccs_get_argv0 - Get argv[0].
  *
- * @bprm: Pointer to "struct linux_binprm".
- * @tmp:  Buffer for temporary use.
+ * @ee: Pointer to "struct ccs_execve_entry".
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_get_argv0(struct linux_binprm *bprm,
-			  struct ccs_page_buffer *tmp)
+static bool ccs_get_argv0(struct ccs_execve_entry *ee)
 {
-	char *arg_ptr = tmp->buffer;
+	struct linux_binprm *bprm = ee->bprm;
+	char *arg_ptr = ee->tmp;
 	int arg_len = 0;
 	unsigned long pos = bprm->p;
 	int offset = pos % PAGE_SIZE;
@@ -904,15 +901,12 @@
 	if (!bprm->argc)
 		goto out;
 	while (1) {
-		struct page *page = ccs_get_arg_page(bprm, pos);
-		const char *kaddr;
-		if (!page)
+		if (!ccs_dump_page(bprm, pos, &ee->dump))
 			goto out;
 		pos += PAGE_SIZE - offset;
-		/* Map. */
-		kaddr = kmap(page);
 		/* Read. */
 		while (offset < PAGE_SIZE) {
+			const char *kaddr = ee->dump.data;
 			const unsigned char c = kaddr[offset++];
 			if (c && arg_len < CCS_MAX_PATHNAME_LEN - 10) {
 				if (c == '\\') {
@@ -935,9 +929,6 @@
 				break;
 			}
 		}
-		/* Unmap. */
-		kunmap(page);
-		ccs_put_arg_page(page);
 		offset = 0;
 		if (done)
 			break;
@@ -950,29 +941,22 @@
 /**
  * ccs_find_next_domain - Find a domain.
  *
- * @r:       Pointer to "struct ccs_request_info".
- * @handler: Pathname to verify. May be NULL.
+ * @ee:      Pointer to "struct ccs_request_info".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_find_next_domain(struct ccs_request_info *r,
-				const struct ccs_path_info *handler)
+static int ccs_find_next_domain(struct ccs_execve_entry *ee)
 {
-	/*
-	 * This function assumes that the size of buffer returned by
-	 * ccs_realpath() = CCS_MAX_PATHNAME_LEN.
-	 */
+	struct ccs_request_info *r = &ee->r;
+	const struct ccs_path_info *handler = ee->handler;
 	struct domain_info *domain = NULL;
 	const char *old_domain_name = r->domain->domainname->name;
-	struct linux_binprm *bprm = r->bprm;
-	struct ccs_page_buffer *tmp = r->obj->tmp;
+	struct linux_binprm *bprm = ee->bprm;
 	const char *original_name = bprm->filename;
 	const u8 mode = r->mode;
 	const bool is_enforce = (mode == 3);
 	const u32 tomoyo_flags = current->tomoyo_flags;
 	char *new_domain_name = NULL;
-	char *real_program_name = NULL;
-	char *symlink_program_name = NULL;
 	struct ccs_path_info rn; /* real name */
 	struct ccs_path_info sn; /* symlink name */
 	struct ccs_path_info ln; /* last name */
@@ -998,21 +982,14 @@
  retry:
 	current->tomoyo_flags = tomoyo_flags;
 	r->cond = NULL;
-	/* Get ccs_realpath of program. */
+	/* Get ccs_realpath of program and symbolic link. */
 	retval = -ENOENT; /* I hope ccs_realpath() won't fail with -ENOMEM. */
-	ccs_free(real_program_name);
-	real_program_name = ccs_realpath(original_name);
-	if (!real_program_name)
+	if (!ccs_realpath_both(original_name, ee))
 		goto out;
-	/* Get ccs_realpath of symbolic link. */
-	ccs_free(symlink_program_name);
-	symlink_program_name = ccs_realpath_nofollow(original_name);
-	if (!symlink_program_name)
-		goto out;
 
-	rn.name = real_program_name;
+	rn.name = ee->program_path;
 	ccs_fill_path_info(&rn);
-	sn.name = symlink_program_name;
+	sn.name = ee->tmp;
 	ccs_fill_path_info(&sn);
 	ln.name = ccs_get_last_name(r->domain);
 	ccs_fill_path_info(&ln);
@@ -1040,25 +1017,25 @@
 			    ccs_pathcmp(&rn, ptr->original_name) ||
 			    ccs_pathcmp(&sn, ptr->aliased_name))
 				continue;
-			memset(real_program_name, 0, CCS_MAX_PATHNAME_LEN);
-			strncpy(real_program_name, ptr->aliased_name->name,
+			strncpy(ee->program_path, ptr->aliased_name->name,
 				CCS_MAX_PATHNAME_LEN - 1);
 			ccs_fill_path_info(&rn);
 			break;
 		}
 	}
+	/* sn will be overwritten after here. */
 
-	/* Compare basename of real_program_name and argv[0] */
+	/* Compare basename of program_path and argv[0] */
 	r->mode = ccs_check_flags(r->domain, CCS_TOMOYO_MAC_FOR_ARGV0);
 	if (bprm->argc > 0 && r->mode) {
-		char *base_argv0 = tmp->buffer;
+		char *base_argv0 = ee->tmp;
 		const char *base_filename;
 		retval = -ENOMEM;
-		if (!ccs_get_argv0(bprm, tmp))
+		if (!ccs_get_argv0(ee))
 			goto out;
-		base_filename = strrchr(real_program_name, '/');
+		base_filename = strrchr(ee->program_path, '/');
 		if (!base_filename)
-			base_filename = real_program_name;
+			base_filename = ee->program_path;
 		else
 			base_filename++;
 		if (strcmp(base_argv0, base_filename)) {
@@ -1078,8 +1055,7 @@
 			if (ptr->is_deleted ||
 			    !ccs_path_matches_pattern(&rn, ptr->original_name))
 				continue;
-			memset(real_program_name, 0, CCS_MAX_PATHNAME_LEN);
-			strncpy(real_program_name, ptr->aggregated_name->name,
+			strncpy(ee->program_path, ptr->aggregated_name->name,
 				CCS_MAX_PATHNAME_LEN - 1);
 			ccs_fill_path_info(&rn);
 			break;
@@ -1095,11 +1071,11 @@
 		goto out;
 
  calculate_domain:
-	new_domain_name = tmp->buffer;
+	new_domain_name = ee->tmp;
 	if (ccs_is_domain_initializer(r->domain->domainname, &rn, &ln)) {
 		/* Transit to the child of KERNEL_DOMAIN domain. */
-		snprintf(new_domain_name, CCS_MAX_PATHNAME_LEN + 1,
-			 ROOT_NAME " " "%s", real_program_name);
+		snprintf(new_domain_name, CCS_EXEC_TMPSIZE - 1,
+			 ROOT_NAME " " "%s", ee->program_path);
 	} else if (r->domain == &KERNEL_DOMAIN && !ccs_sbin_init_started) {
 		/*
 		 * Needn't to transit from kernel domain before starting
@@ -1112,8 +1088,8 @@
 		domain = r->domain;
 	} else {
 		/* Normal domain transition. */
-		snprintf(new_domain_name, CCS_MAX_PATHNAME_LEN + 1,
-			 "%s %s", old_domain_name, real_program_name);
+		snprintf(new_domain_name, CCS_EXEC_TMPSIZE - 1,
+			 "%s %s", old_domain_name, ee->program_path);
 	}
 	if (domain || strlen(new_domain_name) >= CCS_MAX_PATHNAME_LEN)
 		goto done;
@@ -1147,8 +1123,6 @@
 		retval = 0;
 	}
  out:
-	ccs_free(real_program_name);
-	ccs_free(symlink_program_name);
 	if (domain)
 		r->domain = domain;
 	return retval;
@@ -1157,15 +1131,15 @@
 /**
  * ccs_check_environ - Check permission for environment variable names.
  *
- * @r: Pointer to "struct ccs_request_info".
+ * @ee: Pointer to "struct ccs_execve_entry".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_check_environ(struct ccs_request_info *r)
+static int ccs_check_environ(struct ccs_execve_entry *ee)
 {
-	struct linux_binprm *bprm = r->bprm;
-	struct ccs_page_buffer *tmp = r->obj->tmp;
-	char *arg_ptr = tmp->buffer;
+	struct ccs_request_info *r = &ee->r;
+	struct linux_binprm *bprm = ee->bprm;
+	char *arg_ptr = ee->tmp;
 	int arg_len = 0;
 	unsigned long pos = bprm->p;
 	int offset = pos % PAGE_SIZE;
@@ -1176,21 +1150,21 @@
 	if (!r->mode || !envp_count)
 		return 0;
 	while (error == -ENOMEM) {
-		struct page *page = ccs_get_arg_page(bprm, pos);
-		const char *kaddr;
-		if (!page)
+		if (!ccs_dump_page(bprm, pos, &ee->dump))
 			goto out;
 		pos += PAGE_SIZE - offset;
-		/* Map. */
-		kaddr = kmap(page);
 		/* Read. */
 		while (argv_count && offset < PAGE_SIZE) {
+			const char *kaddr = ee->dump.data;
 			if (!kaddr[offset++])
 				argv_count--;
 		}
-		if (argv_count)
-			goto unmap_page;
+		if (argv_count) {
+			offset = 0;
+			continue;
+		}
 		while (offset < PAGE_SIZE) {
+			const char *kaddr = ee->dump.data;
 			const unsigned char c = kaddr[offset++];
 			if (c && arg_len < CCS_MAX_PATHNAME_LEN - 10) {
 				if (c == '=') {
@@ -1222,10 +1196,6 @@
 			}
 			arg_len = 0;
 		}
-unmap_page:
-		/* Unmap. */
-		kunmap(page);
-		ccs_put_arg_page(page);
 		offset = 0;
 	}
  out:
@@ -1339,17 +1309,89 @@
 	return depth;
 }
 
+static LIST_HEAD(ccs_execve_list);
+static DEFINE_SPINLOCK(ccs_execve_list_lock);
+
 /**
+ * ccs_allocate_execve_entry - Allocate memory for execve().
+ *
+ * Returns pointer to "struct ccs_execve_entry" on success, NULL otherwise.
+ */
+static struct ccs_execve_entry *ccs_allocate_execve_entry(void)
+{
+	struct ccs_execve_entry *ee = ccs_alloc(sizeof(*ee), false);
+	if (!ee)
+		return NULL;
+	memset(ee, 0, sizeof(*ee));
+	ee->program_path = ccs_alloc(CCS_MAX_PATHNAME_LEN, false);
+	ee->tmp = ccs_alloc(CCS_MAX_PATHNAME_LEN, false);
+	if (!ee->program_path || !ee->tmp) {
+		ccs_free(ee->program_path);
+		ccs_free(ee->tmp);
+		ccs_free(ee);
+		return NULL;
+	}
+	/* ee->dump->data is allocated by ccs_dump_page(). */
+	ee->task = current;
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&ccs_execve_list_lock);
+	list_add(&ee->list, &ccs_execve_list);
+	spin_unlock(&ccs_execve_list_lock);
+	/***** CRITICAL SECTION END *****/
+	return ee;
+}
+
+/**
+ * ccs_find_execve_entry - Find ccs_execve_entry of current process.
+ *
+ * Returns pointer to "struct ccs_execve_entry" on success, NULL otherwise.
+ */
+static struct ccs_execve_entry *ccs_find_execve_entry(void)
+{
+	struct task_struct *task = current;
+	struct ccs_execve_entry *ee = NULL;
+	struct ccs_execve_entry *p;
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&ccs_execve_list_lock);
+	list_for_each_entry(p, &ccs_execve_list, list) {
+		if (p->task != task)
+			continue;
+		ee = p;
+		break;
+	}
+	spin_unlock(&ccs_execve_list_lock);
+	/***** CRITICAL SECTION END *****/
+	return ee;
+}
+
+/**
+ * ccs_free_execve_entry - Free memory for execve().
+ *
+ * @ee: Pointer to "struct ccs_execve_entry".
+ */
+static void ccs_free_execve_entry(struct ccs_execve_entry *ee)
+{
+	if (!ee)
+		return;
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&ccs_execve_list_lock);
+	list_del(&ee->list);
+	spin_unlock(&ccs_execve_list_lock);
+	/***** CRITICAL SECTION END *****/
+	ccs_free(ee->program_path);
+	ccs_free(ee->tmp);
+	kfree(ee->dump.data);
+	ccs_free(ee);
+}
+
+/**
  * ccs_try_alt_exec - Try to start execute handler.
  *
- * @r:           Pointer to "struct ccs_request_info".
- * @handler:     Pointer to the name of execute handler.
- * @eh_path:     Pointer to pointer to the name of execute handler.
+ * @ee:          Pointer to "struct ccs_execve_entry".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_try_alt_exec(struct ccs_request_info *r,
-			    const struct ccs_path_info *handler, char **eh_path)
+static int ccs_try_alt_exec(struct ccs_execve_entry *ee)
 {
 	/*
 	 * Contents of modified bprm.
@@ -1387,41 +1429,20 @@
 	 * modified bprm->argv[bprm->envc + bprm->argc + 6]
 	 *     = original bprm->envp[bprm->envc - 1]
 	 */
-	struct linux_binprm *bprm = r->bprm;
+	struct linux_binprm *bprm = ee->bprm;
 	struct file *filp;
 	int retval;
 	const int original_argc = bprm->argc;
 	const int original_envc = bprm->envc;
 	struct task_struct *task = current;
-	char *buffer = r->obj->tmp->buffer;
-	/* Allocate memory for execute handler's pathname. */
-	char *execute_handler = ccs_alloc(sizeof(struct ccs_page_buffer),
-					  false);
-	*eh_path = execute_handler;
-	if (!execute_handler)
-		return -ENOMEM;
-	strncpy(execute_handler, handler->name,
-		sizeof(struct ccs_page_buffer) - 1);
-	ccs_unescape(execute_handler);
 
 	/* Close the requested program's dentry. */
 	allow_write_access(bprm->file);
 	fput(bprm->file);
 	bprm->file = NULL;
 
-	{ /* Adjust root directory for open_exec(). */
-		int depth = ccs_get_root_depth();
-		char *cp = execute_handler;
-		if (!*cp || *cp != '/')
-			return -ENOENT;
-		while (depth) {
-			cp = strchr(cp + 1, '/');
-			if (!cp)
-				return -ENOENT;
-			depth--;
-		}
-		memmove(execute_handler, cp, strlen(cp) + 1);
-	}
+	/* Invalidate page dump cache. */
+	ee->dump.page = NULL;
 
 	/* Move envp[] to argv[] */
 	bprm->argc += bprm->envc;
@@ -1429,9 +1450,9 @@
 
 	/* Set argv[6] */
 	{
-		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "%d",
-			 original_envc);
-		retval = copy_strings_kernel(1, &buffer, bprm);
+		char *cp = ee->tmp;
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%d", original_envc);
+		retval = copy_strings_kernel(1, &cp, bprm);
 		if (retval < 0)
 			goto out;
 		bprm->argc++;
@@ -1439,9 +1460,9 @@
 
 	/* Set argv[5] */
 	{
-		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "%d",
-			 original_argc);
-		retval = copy_strings_kernel(1, &buffer, bprm);
+		char *cp = ee->tmp;
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%d", original_argc);
+		retval = copy_strings_kernel(1, &cp, bprm);
 		if (retval < 0)
 			goto out;
 		bprm->argc++;
@@ -1449,7 +1470,8 @@
 
 	/* Set argv[4] */
 	{
-		retval = copy_strings_kernel(1, &bprm->filename, bprm);
+		retval = copy_strings_kernel(1, (char **) &bprm->filename,
+					     bprm);
 		if (retval < 0)
 			goto out;
 		bprm->argc++;
@@ -1457,8 +1479,9 @@
 
 	/* Set argv[3] */
 	{
+		char *cp = ee->tmp;
 		const u32 tomoyo_flags = task->tomoyo_flags;
-		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1,
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1,
 			 "pid=%d uid=%d gid=%d euid=%d egid=%d suid=%d "
 			 "sgid=%d fsuid=%d fsgid=%d state[0]=%u "
 			 "state[1]=%u state[2]=%u",
@@ -1467,7 +1490,7 @@
 			 current_sgid(), current_fsuid(), current_fsgid(),
 			 (u8) (tomoyo_flags >> 24), (u8) (tomoyo_flags >> 16),
 			 (u8) (tomoyo_flags >> 8));
-		retval = copy_strings_kernel(1, &buffer, bprm);
+		retval = copy_strings_kernel(1, &cp, bprm);
 		if (retval < 0)
 			goto out;
 		bprm->argc++;
@@ -1480,9 +1503,9 @@
 			retval = copy_strings_kernel(1, &exe, bprm);
 			ccs_free(exe);
 		} else {
-			snprintf(buffer, sizeof(struct ccs_page_buffer) - 1,
-				 "<unknown>");
-			retval = copy_strings_kernel(1, &buffer, bprm);
+			exe = ee->tmp;
+			strncpy(ee->tmp, "<unknown>", CCS_EXEC_TMPSIZE - 1);
+			retval = copy_strings_kernel(1, &exe, bprm);
 		}
 		if (retval < 0)
 			goto out;
@@ -1491,9 +1514,10 @@
 
 	/* Set argv[1] */
 	{
-		strncpy(buffer, task->domain_info->domainname->name,
-			sizeof(struct ccs_page_buffer) - 1);
-		retval = copy_strings_kernel(1, &buffer, bprm);
+		char *cp = ee->tmp;
+		strncpy(ee->tmp, task->domain_info->domainname->name,
+			CCS_EXEC_TMPSIZE - 1);
+		retval = copy_strings_kernel(1, &cp, bprm);
 		if (retval < 0)
 			goto out;
 		bprm->argc++;
@@ -1501,7 +1525,23 @@
 
 	/* Set argv[0] */
 	{
-		retval = copy_strings_kernel(1, &execute_handler, bprm);
+		int depth = ccs_get_root_depth();
+		char *cp = ee->program_path;
+		strncpy(cp, ee->handler->name, CCS_MAX_PATHNAME_LEN - 1);
+		ccs_unescape(cp);
+		retval = -ENOENT;
+		if (!*cp || *cp != '/')
+			goto out;
+		/* Adjust root directory for open_exec(). */
+		while (depth) {
+			cp = strchr(cp + 1, '/');
+			if (!cp)
+				goto out;
+			depth--;
+		}
+		memmove(ee->program_path, cp, strlen(cp) + 1);
+		cp = ee->program_path;
+		retval = copy_strings_kernel(1, &cp, bprm);
 		if (retval < 0)
 			goto out;
 		bprm->argc++;
@@ -1513,22 +1553,33 @@
 #endif
 
 	/* OK, now restart the process with execute handler program's dentry. */
-	filp = open_exec(execute_handler);
+	filp = open_exec(ee->program_path);
 	if (IS_ERR(filp)) {
 		retval = PTR_ERR(filp);
 		goto out;
 	}
 	bprm->file = filp;
-	bprm->filename = execute_handler;
+	bprm->filename = ee->program_path;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
-	bprm->interp = execute_handler;
+	bprm->interp = ee->program_path;
 #endif
 	retval = prepare_binprm(bprm);
 	if (retval < 0)
 		goto out;
+	/*
+	 * Backup ee->propgram_path for ccs_find_next_domain().
+	 * ee->program_path will be overwritten by ccs_find_next_domain().
+	 * But ee->tmp won't be overwritten by ccs_find_next_domain()
+	 * because ee->handler != NULL.
+	 */
+	strncpy(ee->tmp, ee->program_path, CCS_EXEC_TMPSIZE - 1);
 	task->tomoyo_flags |= CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
-	retval = ccs_find_next_domain(r, handler);
+	retval = ccs_find_next_domain(ee);
 	task->tomoyo_flags &= ~CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
+	/*
+	 * Restore ee->program_path for search_binary_handler().
+	 */
+	strncpy(ee->program_path, ee->tmp, CCS_MAX_PATHNAME_LEN - 1);
  out:
 	return retval;
 }
@@ -1536,11 +1587,13 @@
 /**
  * ccs_find_execute_handler - Find an execute handler.
  *
+ * @ee:   Pointer to "struct ccs_execve_entry".
  * @type: Type of execute handler.
  *
- * Returns pointer to "struct ccs_path_info" if found, NULL otherwise.
+ * Returns bool if found, false otherwise.
  */
-static const struct ccs_path_info *ccs_find_execute_handler(const u8 type)
+static bool ccs_find_execute_handler(struct ccs_execve_entry *ee,
+				     const u8 type)
 {
 	struct task_struct *task = current;
 	const struct domain_info *domain = task->domain_info;
@@ -1550,48 +1603,62 @@
 	 * marked as execute handler to avoid infinite execute handler loop.
 	 */
 	if (task->tomoyo_flags & TOMOYO_TASK_IS_EXECUTE_HANDLER)
-		return NULL;
+		return false;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct ccs_execute_handler_record *acl;
 		if (ptr->type != type)
 			continue;
 		acl = container_of(ptr, struct ccs_execute_handler_record,
 				   head);
-		return acl->handler;
+		ee->handler = acl->handler;
+		return true;
 	}
-	return NULL;
+	return false;
 }
 
-/* List of next_domain which is used for checking interpreter's permissions. */
-struct ccs_execve_entry {
-	struct list_head list;
-	struct task_struct *task;
-	struct domain_info *next_domain;
-};
-
-static LIST_HEAD(ccs_execve_list);
-static DEFINE_SPINLOCK(ccs_execve_list_lock);
-
 /**
- * ccs_register_next_domain - Remember next_domain.
+ * ccs_dump_page - Dump a page to buffer.
  *
- * @next_domain: Pointer to "struct domain_info".
+ * @bprm: Pointer to "struct linux_binprm".
+ * @pos:  Location to dump.
+ * @dump: Poiner to "struct ccs_page_dump".
  *
- * Returns 0 on success, -ENOMEM otherwise.
+ * Returns true on success, false otherwise.
  */
-static int ccs_register_next_domain(struct domain_info *next_domain)
+bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos,
+		   struct ccs_page_dump *dump)
 {
-	struct ccs_execve_entry *ee = kmalloc(sizeof(*ee), GFP_KERNEL);
-	if (!ee)
-		return -ENOMEM;
-	ee->task = current;
-	ee->next_domain = next_domain;
-	/***** CRITICAL SECTION START *****/
-	spin_lock(&ccs_execve_list_lock);
-	list_add(&ee->list, &ccs_execve_list);
-	spin_unlock(&ccs_execve_list_lock);
-	/***** CRITICAL SECTION END *****/
-	return 0;
+	struct page *page;
+	/* dump->data is released by ccs_free_execve_entry(). */
+	if (!dump->data) {
+		dump->data = kmalloc(PAGE_SIZE, GFP_KERNEL);
+		if (!dump->data)
+			return false;
+	}
+	/* Same with get_arg_page(bprm, pos, 0) in fs/exec.c */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
+	if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0)
+		return false;
+#else
+	page = bprm->page[pos / PAGE_SIZE];
+#endif
+	if (page != dump->page) {
+		const unsigned int offset = pos % PAGE_SIZE;
+		/*
+		 * Maybe kmap()/kunmap() should be used here.
+		 * But remove_arg_zero() uses kmap_atomic()/kunmap_atomic().
+		 * So do I.
+		 */
+		char *kaddr = kmap_atomic(page, KM_USER0);
+		dump->page = page;
+		memcpy(dump->data + offset, kaddr + offset, PAGE_SIZE - offset);
+		kunmap_atomic(kaddr, KM_USER0);
+	}
+	/* Same with put_arg_page(page) in fs/exec.c */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
+	put_page(page);
+#endif
+	return true;
 }
 
 /**
@@ -1602,151 +1669,117 @@
  */
 struct domain_info *ccs_fetch_next_domain(void)
 {
-	struct task_struct *task = current;
-	struct domain_info *next_domain = task->domain_info;
-	struct ccs_execve_entry *p;
-	/***** CRITICAL SECTION START *****/
-	spin_lock(&ccs_execve_list_lock);
-	list_for_each_entry(p, &ccs_execve_list, list) {
-		if (p->task != task)
-			continue;
-		next_domain = p->next_domain;
-		break;
-	}
-	spin_unlock(&ccs_execve_list_lock);
-	/***** CRITICAL SECTION END *****/
+	struct ccs_execve_entry *ee = ccs_find_execve_entry();
+	struct domain_info *next_domain = NULL;
+	if (ee)
+		next_domain = ee->next_domain;
+	if (!next_domain)
+		next_domain = current->domain_info;
 	return next_domain;
 }
 
 /**
- * ccs_unregister_next_domain - Forget next_domain.
- */
-static void ccs_unregister_next_domain(void)
-{
-	struct task_struct *task = current;
-	struct ccs_execve_entry *p;
-	struct ccs_execve_entry *ee = NULL;
-	/***** CRITICAL SECTION START *****/
-	spin_lock(&ccs_execve_list_lock);
-	list_for_each_entry(p, &ccs_execve_list, list) {
-		if (p->task != task)
-			continue;
-		list_del(&p->list);
-		ee = p;
-		break;
-	}
-	spin_unlock(&ccs_execve_list_lock);
-	/***** CRITICAL SECTION END *****/
-	kfree(ee);
-}
-
-/**
- * search_binary_handler_with_transition - Perform domain transition.
+ * ccs_start_execve - Prepare for execve() operation.
  *
  * @bprm: Pointer to "struct linux_binprm".
- * @regs: Pointer to "struct pt_regs".
  *
- * Returns result of search_binary_handler() on success,
- * negative value otherwise.
+ * Returns 0 on success, negative value otherwise.
  */
-int search_binary_handler_with_transition(struct linux_binprm *bprm,
-					  struct pt_regs *regs)
+int ccs_start_execve(struct linux_binprm *bprm)
 {
 	int retval;
 	struct task_struct *task = current;
-	const struct ccs_path_info *handler;
-	struct ccs_request_info r;
-	struct ccs_obj_info obj;
-	/*
-	 * "eh_path" holds path to execute handler program.
-	 * Thus, keep valid until search_binary_handler() finishes.
-	 */
-	char *eh_path = NULL;
-	struct ccs_page_buffer *tmp = ccs_alloc(sizeof(struct ccs_page_buffer),
-						false);
-	memset(&obj, 0, sizeof(obj));
+	struct ccs_execve_entry *ee = ccs_allocate_execve_entry();
 	if (!ccs_sbin_init_started)
 		ccs_load_policy(bprm->filename);
-	if (!tmp)
+	if (!ee)
 		return -ENOMEM;
-
-	ccs_init_request_info(&r, NULL, CCS_TOMOYO_MAC_FOR_FILE);
-	r.bprm = bprm;
-	r.obj = &obj;
-	obj.path1_dentry = bprm->file->f_dentry;
-	obj.path1_vfsmnt = bprm->file->f_vfsmnt;
-	obj.tmp = tmp;
-
+	ccs_init_request_info(&ee->r, NULL, CCS_TOMOYO_MAC_FOR_FILE);
+	ee->r.ee = ee;
+	ee->bprm = bprm;
+	ee->r.obj = &ee->obj;
+	ee->obj.path1_dentry = bprm->file->f_dentry;
+	ee->obj.path1_vfsmnt = bprm->file->f_vfsmnt;
 	/* Clear manager flag. */
 	task->tomoyo_flags &= ~CCS_TASK_IS_POLICY_MANAGER;
-	handler = ccs_find_execute_handler(TYPE_EXECUTE_HANDLER);
-	if (handler) {
-		retval = ccs_try_alt_exec(&r, handler, &eh_path);
+	if (ccs_find_execute_handler(ee, TYPE_EXECUTE_HANDLER)) {
+		retval = ccs_try_alt_exec(ee);
 		if (!retval)
-			ccs_audit_execute_handler_log(true, handler->name,
-						      bprm);
+			ccs_audit_execute_handler_log(ee, true);
 		goto ok;
 	}
-	retval = ccs_find_next_domain(&r, NULL);
+	retval = ccs_find_next_domain(ee);
 	if (retval != -EPERM)
 		goto ok;
-	handler = ccs_find_execute_handler(TYPE_DENIED_EXECUTE_HANDLER);
-	if (handler) {
-		retval = ccs_try_alt_exec(&r, handler, &eh_path);
+	if (ccs_find_execute_handler(ee, TYPE_DENIED_EXECUTE_HANDLER)) {
+		retval = ccs_try_alt_exec(ee);
 		if (!retval)
-			ccs_audit_execute_handler_log(false, handler->name,
-						      bprm);
+			ccs_audit_execute_handler_log(ee, false);
 	}
  ok:
 	if (retval < 0)
 		goto out;
-	r.mode = ccs_check_flags(r.domain, CCS_TOMOYO_MAC_FOR_ENV);
-	retval = ccs_check_environ(&r);
+	ee->r.mode = ccs_check_flags(ee->r.domain, CCS_TOMOYO_MAC_FOR_ENV);
+	retval = ccs_check_environ(ee);
 	if (retval < 0)
 		goto out;
-	retval = ccs_register_next_domain(r.domain);
-	if (retval < 0)
-		goto out;
+	ee->next_domain = ee->r.domain;
 	task->tomoyo_flags |= TOMOYO_CHECK_READ_FOR_OPEN_EXEC;
-	retval = search_binary_handler(bprm, regs);
+	retval = 0;
+ out:
+	return retval;
+}
+
+/**
+ * ccs_finish_execve - Clean up execve() operation.
+ */
+void ccs_finish_execve(int retval)
+{
+	struct task_struct *task = current;
+	struct ccs_execve_entry *ee = ccs_find_execve_entry();
 	task->tomoyo_flags &= ~TOMOYO_CHECK_READ_FOR_OPEN_EXEC;
+	if (!ee)
+		return;
 	if (retval < 0)
 		goto out;
 	/* Proceed to next domain if execution suceeded. */
-	task->domain_info = r.domain;
+	task->domain_info = ee->r.domain;
 	mb(); /* Make domain transition visible to other CPUs. */
 	/* Mark the current process as execute handler. */
-	if (handler)
+	if (ee->handler)
 		task->tomoyo_flags |= TOMOYO_TASK_IS_EXECUTE_HANDLER;
 	/* Mark the current process as normal process. */
 	else
 		task->tomoyo_flags &= ~TOMOYO_TASK_IS_EXECUTE_HANDLER;
  out:
-	ccs_unregister_next_domain();
-	ccs_free(eh_path);
-	ccs_free(tmp);
-	return retval;
+	ccs_free_execve_entry(ee);
 }
 
 #else
 
 /**
- * search_binary_handler_with_transition - Wrapper for search_binary_handler().
+ * ccs_start_execve - Prepare for execve() operation.
  *
  * @bprm: Pointer to "struct linux_binprm".
- * @regs: Pointer to "struct pt_regs".
  *
- * Returns the result of search_binary_handler().
+ * Returns 0.
  */
-int search_binary_handler_with_transition(struct linux_binprm *bprm,
-					  struct pt_regs *regs)
+int ccs_start_execve(struct linux_binprm *bprm)
 {
 #ifdef CONFIG_SAKURA
 	/* Clear manager flag. */
 	current->tomoyo_flags &= ~CCS_TASK_IS_POLICY_MANAGER;
-	ccs_load_policy(bprm->filename);
+	if (!ccs_sbin_init_started)
+		ccs_load_policy(bprm->filename);
 #endif
-	return search_binary_handler(bprm, regs);
+	return 0;
 }
 
+/**
+ * ccs_finish_execve - Clean up execve() operation.
+ */
+void ccs_finish_execve(int retval)
+{
+}
+
 #endif
Index: trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(revision 2032)
+++ trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(working copy)
@@ -228,8 +228,6 @@
 	ccs_create_entry("version",          0400, ccs_dir, CCS_VERSION);
 	ccs_create_entry(".execute_handler", 0666, ccs_dir,
 			 CCS_EXECUTE_HANDLER);
-	if (sizeof(struct ccs_page_buffer) < CCS_MAX_PATHNAME_LEN + 1)
-		panic("Bad size!");
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_file.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(revision 2032)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(working copy)
@@ -831,7 +831,7 @@
 	if (is_enforce) {
 		int error = ccs_check_supervisor(r, "allow_%s %s\n",
 						 msg, filename->name);
-		if (error == 1 && !r->bprm)
+		if (error == 1 && !r->ee)
 			goto retry;
 		return error;
 	}
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(revision 2032)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(working copy)
@@ -111,19 +111,17 @@
 /**
  * ccs_scan_bprm - Scan "struct linux_binprm".
  *
- * @bprm: Pointer to "struct linux_binprm".
+ * @ee:   Pointer to "struct ccs_execve_entry".
  * @argc: Length of @argc.
  * @argv: Pointer to "struct ccs_argv_entry".
  * @envc: Length of @envp.
  * @envp: Poiner to "struct ccs_envp_entry".
- * @tmp:  Buffer for temporary use.
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_scan_bprm(struct linux_binprm *bprm,
+static bool ccs_scan_bprm(struct ccs_execve_entry *ee,
 			  const u16 argc, const struct ccs_argv_entry *argv,
-			  const u16 envc, const struct ccs_envp_entry *envp,
-			  struct ccs_page_buffer *tmp)
+			  const u16 envc, const struct ccs_envp_entry *envp)
 {
 	/*
 	  if exec.argc=3
@@ -145,7 +143,9 @@
 	  if exec.envp["HOME"]!="/"
 	  if (!getenv("HOME") || strcmp(getenv("HOME", "/"))
 	*/
-	char *arg_ptr = tmp->buffer;
+	struct linux_binprm *bprm = ee->bprm;
+	struct ccs_page_dump *dump = &ee->dump;
+	char *arg_ptr = ee->tmp;
 	int arg_len = 0;
 	unsigned long pos = bprm->p;
 	int offset = pos % PAGE_SIZE;
@@ -163,18 +163,15 @@
 			return false;
 	}
 	while (argv_count || envp_count) {
-		struct page *page = ccs_get_arg_page(bprm, pos);
-		const char *kaddr;
-		if (!page) {
+		if (!ccs_dump_page(bprm, pos, dump)) {
 			result = false;
 			goto out;
 		}
 		pos += PAGE_SIZE - offset;
-		/* Map. */
-		kaddr = kmap(page);
 		while (offset < PAGE_SIZE) {
 			/* Read. */
 			struct ccs_path_info arg;
+			const char *kaddr = dump->data;
 			const unsigned char c = kaddr[offset++];
 			arg.name = arg_ptr;
 			if (c && arg_len < CCS_MAX_PATHNAME_LEN - 10) {
@@ -221,9 +218,6 @@
 			}
 			arg_len = 0;
 		}
-		/* Unmap. */
-		kunmap(page);
-		ccs_put_arg_page(page);
 		offset = 0;
 		if (!result)
 			break;
@@ -1074,14 +1068,15 @@
 	u16 argc;
 	u16 envc;
 	const struct ccs_condition_list *cond = ccs_get_condition_part(acl);
-	struct linux_binprm *bprm;
+	struct linux_binprm *bprm = NULL;
 	if (!cond)
 		return true;
 	condc = cond->condc;
 	argc = cond->argc;
 	envc = cond->envc;
-	bprm = r->bprm;
 	obj = r->obj;
+	if (r->ee)
+		bprm = r->ee->bprm;
 	if (!bprm && (argc || envc))
 		return false;
 	ptr = (unsigned long *) (cond + 1);
@@ -1419,8 +1414,8 @@
 out:
 		return false;
 	}
-	if (bprm && (argc || envc))
-		return ccs_scan_bprm(bprm, argc, argv, envc, envp, obj->tmp);
+	if (r->ee && (argc || envc))
+		return ccs_scan_bprm(r->ee, argc, argv, envc, envp);
 	return true;
 }
 
