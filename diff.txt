Index: trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h	(revision 4710)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -778,7 +778,7 @@
 		       __GFP_NORETRY | __GFP_NOMEMALLOC)
 
 /* Size of read buffer for /proc/ccs/ interface. */
-#define CCS_MAX_IO_READ_QUEUE 32
+#define CCS_MAX_IO_READ_QUEUE 64
 
 /* Structure definition for internal use. */
 
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(revision 4710)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -419,6 +419,18 @@
 }
 
 /**
+ * ccs_set_slash - Put a shash to "struct ccs_io_buffer" structure.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ */
+static void ccs_set_slash(struct ccs_io_buffer *head)
+{
+	ccs_set_string(head, "/");
+}
+
+/**
  * ccs_assign_profile - Create a new profile.
  *
  * @profile: Profile number to create.
@@ -1362,32 +1374,18 @@
 }
 
 /**
- * ccs_fns - Find next set bit.
+ * ccs_set_group - Print "acl_group " header keyword and category name.
  *
- * @perm: 8 bits value.
- * @bit:  First bit to find.
+ * @head:     Pointer to "struct ccs_io_buffer".
+ * @category: Category name.
  *
- * Returns next set bit on success, 8 otherwise.
- */
-static u8 ccs_fns(const u8 perm, u8 bit)
-{
-	for ( ; bit < 8; bit++)
-		if (perm & (1 << bit))
-			break;
-	return bit;
-}
-
-/**
- * ccs_set_group - Print "acl_group " header keyword.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
  * Returns nothing.
  */
-static void ccs_set_group(struct ccs_io_buffer *head)
+static void ccs_set_group(struct ccs_io_buffer *head, const char *category)
 {
 	if (head->type == CCS_EXCEPTIONPOLICY)
 		ccs_io_printf(head, "acl_group %u ", head->r.acl_group_index);
+	ccs_set_string(head, category);
 }
 
 /**
@@ -1403,39 +1401,40 @@
 {
 	const u8 acl_type = acl->type;
 	const bool may_trigger_transition = acl->cond && acl->cond->transit;
+	bool first = true;
 	u8 bit;
 	if (head->r.print_cond_part)
 		goto print_cond_part;
 	if (acl->is_deleted)
 		return true;
-next:
-	bit = head->r.bit;
 	if (!ccs_flush(head))
 		return false;
 	else if (acl_type == CCS_TYPE_PATH_ACL) {
 		struct ccs_path_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
 		const u16 perm = ptr->perm;
-		for ( ; bit < CCS_MAX_PATH_OPERATION; bit++) {
+		for (bit = 0; bit < CCS_MAX_PATH_OPERATION; bit++) {
 			if (!(perm & (1 << bit)))
 				continue;
 			if (head->r.print_transition_related_only &&
 			    bit != CCS_TYPE_EXECUTE && !may_trigger_transition)
 				continue;
-			break;
+			if (first) {
+				ccs_set_group(head, "file ");
+				first = false;
+			} else {
+				ccs_set_slash(head);
+			}
+			ccs_set_string(head, ccs_path_keyword[bit]);
 		}
-		if (bit >= CCS_MAX_PATH_OPERATION)
-			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "file ");
-		ccs_set_string(head, ccs_path_keyword[bit]);
+		if (first)
+			return true;
 		ccs_print_name_union(head, &ptr->name);
 	} else if (acl_type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
 		   acl_type == CCS_TYPE_DENIED_EXECUTE_HANDLER) {
 		struct ccs_handler_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head);
-		ccs_set_string(head, "task ");
+		ccs_set_group(head, "task ");
 		ccs_set_string(head, acl_type == CCS_TYPE_AUTO_EXECUTE_HANDLER
 			       ? "auto_execute_handler " :
 			       "denied_execute_handler ");
@@ -1444,8 +1443,7 @@
 		   acl_type == CCS_TYPE_MANUAL_TASK_ACL) {
 		struct ccs_task_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head);
-		ccs_set_string(head, "task ");
+		ccs_set_group(head, "task ");
 		ccs_set_string(head, acl_type == CCS_TYPE_AUTO_TASK_ACL ?
 			       "auto_domain_transition " :
 			       "manual_domain_transition ");
@@ -1456,12 +1454,21 @@
 	} else if (acl_type == CCS_TYPE_MKDEV_ACL) {
 		struct ccs_mkdev_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		bit = ccs_fns(ptr->perm, bit);
-		if (bit >= CCS_MAX_MKDEV_OPERATION)
-			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "file ");
-		ccs_set_string(head, ccs_mac_keywords[ccs_pnnn2mac[bit]]);
+		const u8 perm = ptr->perm;
+		for (bit = 0; bit < CCS_MAX_MKDEV_OPERATION; bit++) {
+			if (!(perm & (1 << bit)))
+				continue;
+			if (first) {
+				ccs_set_group(head, "file ");
+				first = false;
+			} else {
+				ccs_set_slash(head);
+			}
+			ccs_set_string(head, ccs_mac_keywords
+				       [ccs_pnnn2mac[bit]]);
+		}
+		if (first)
+			return true;
 		ccs_print_name_union(head, &ptr->name);
 		ccs_print_number_union(head, &ptr->mode);
 		ccs_print_number_union(head, &ptr->major);
@@ -1469,50 +1476,75 @@
 	} else if (acl_type == CCS_TYPE_PATH2_ACL) {
 		struct ccs_path2_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		bit = ccs_fns(ptr->perm, bit);
-		if (bit >= CCS_MAX_PATH2_OPERATION)
-			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "file ");
-		ccs_set_string(head, ccs_mac_keywords[ccs_pp2mac[bit]]);
+		const u8 perm = ptr->perm;
+		for (bit = 0; bit < CCS_MAX_PATH2_OPERATION; bit++) {
+			if (!(perm & (1 << bit)))
+				continue;
+			if (first) {
+				ccs_set_group(head, "file ");
+				first = false;
+			} else {
+				ccs_set_slash(head);
+			}
+			ccs_set_string(head, ccs_mac_keywords
+				       [ccs_pp2mac[bit]]);
+		}
+		if (first)
+			return true;
 		ccs_print_name_union(head, &ptr->name1);
 		ccs_print_name_union(head, &ptr->name2);
 	} else if (acl_type == CCS_TYPE_PATH_NUMBER_ACL) {
 		struct ccs_path_number_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		bit = ccs_fns(ptr->perm, bit);
-		if (bit >= CCS_MAX_PATH_NUMBER_OPERATION)
-			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "file ");
-		ccs_set_string(head, ccs_mac_keywords[ccs_pn2mac[bit]]);
+		const u8 perm = ptr->perm;
+		for (bit = 0; bit < CCS_MAX_PATH_NUMBER_OPERATION; bit++) {
+			if (!(perm & (1 << bit)))
+				continue;
+			if (first) {
+				ccs_set_group(head, "file ");
+				first = false;
+			} else {
+				ccs_set_slash(head);
+			}
+			ccs_set_string(head, ccs_mac_keywords
+				       [ccs_pn2mac[bit]]);
+		}
+		if (first)
+			return true;
 		ccs_print_name_union(head, &ptr->name);
 		ccs_print_number_union(head, &ptr->number);
 	} else if (acl_type == CCS_TYPE_ENV_ACL) {
 		struct ccs_env_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head);
-		ccs_set_string(head, "misc env ");
+		ccs_set_group(head, "misc env ");
 		ccs_set_string(head, ptr->env->name);
 	} else if (acl_type == CCS_TYPE_CAPABILITY_ACL) {
 		struct ccs_capability_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head);
-		ccs_set_string(head, "capability ");
-		ccs_set_string(head,
-			       ccs_mac_keywords[ccs_c2mac[ptr->operation]]);
+		ccs_set_group(head, "capability ");
+		ccs_set_string(head, ccs_mac_keywords
+			       [ccs_c2mac[ptr->operation]]);
 	} else if (acl_type == CCS_TYPE_INET_ACL) {
 		struct ccs_inet_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		bit = ccs_fns(ptr->perm, bit);
-		if (bit >= CCS_MAX_NETWORK_OPERATION)
-			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "network inet ");
-		ccs_set_string(head, ccs_proto_keyword[ptr->protocol]);
+		const u8 perm = ptr->perm;
+		for (bit = 0; bit < CCS_MAX_NETWORK_OPERATION; bit++) {
+			if (!(perm & (1 << bit)))
+				continue;
+			if (first) {
+				ccs_set_group(head, "network inet ");
+				ccs_set_string(head, ccs_proto_keyword
+					       [ptr->protocol]);
+				ccs_set_space(head);
+				first = false;
+			} else {
+				ccs_set_slash(head);
+			}
+			ccs_set_string(head, ccs_socket_keyword[bit]);
+		}
+		if (first)
+			return true;
 		ccs_set_space(head);
-		ccs_set_string(head, ccs_socket_keyword[bit]);
-		ccs_set_space(head);
 		switch (ptr->address_type) {
 			char buf[128];
 		case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
@@ -1535,33 +1567,39 @@
 	} else if (acl_type == CCS_TYPE_UNIX_ACL) {
 		struct ccs_unix_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		bit = ccs_fns(ptr->perm, bit);
-		if (bit >= CCS_MAX_NETWORK_OPERATION)
-			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "network unix ");
-		ccs_set_string(head, ccs_proto_keyword[ptr->protocol]);
-		ccs_set_space(head);
-		ccs_set_string(head, ccs_socket_keyword[bit]);
+		const u8 perm = ptr->perm;
+		for (bit = 0; bit < CCS_MAX_NETWORK_OPERATION; bit++) {
+			if (!(perm & (1 << bit)))
+				continue;
+			if (first) {
+				ccs_set_group(head, "network unix ");
+				ccs_set_string(head, ccs_proto_keyword
+					       [ptr->protocol]);
+				ccs_set_space(head);
+				first = false;
+			} else {
+				ccs_set_slash(head);
+			}
+			ccs_set_string(head, ccs_socket_keyword[bit]);
+		}
+		if (first)
+			return true;
 		ccs_print_name_union(head, &ptr->name);
 	} else if (acl_type == CCS_TYPE_SIGNAL_ACL) {
 		struct ccs_signal_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head);
-		ccs_set_string(head, "ipc signal ");
+		ccs_set_group(head, "ipc signal ");
 		ccs_io_printf(head, "%u ", ptr->sig);
 		ccs_set_string(head, ptr->domainname->name);
 	} else if (acl_type == CCS_TYPE_MOUNT_ACL) {
 		struct ccs_mount_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head);
-		ccs_io_printf(head, "file mount");
+		ccs_set_group(head, "file mount");
 		ccs_print_name_union(head, &ptr->dev_name);
 		ccs_print_name_union(head, &ptr->dir_name);
 		ccs_print_name_union(head, &ptr->fs_type);
 		ccs_print_number_union(head, &ptr->flags);
 	}
-	head->r.bit = bit + 1;
 	if (acl->cond) {
 		head->r.print_cond_part = true;
 		head->r.cond_step = 0;
@@ -1574,17 +1612,6 @@
 	} else {
 		ccs_set_lf(head);
 	}
-	switch (acl_type) {
-	case CCS_TYPE_PATH_ACL:
-	case CCS_TYPE_MKDEV_ACL:
-	case CCS_TYPE_PATH2_ACL:
-	case CCS_TYPE_PATH_NUMBER_ACL:
-	case CCS_TYPE_INET_ACL:
-	case CCS_TYPE_UNIX_ACL:
-		goto next;
-	}
-done:
-	head->r.bit = 0;
 	return true;
 }
 
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c	(revision 4710)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c	(working copy)
@@ -1932,13 +1932,22 @@
  * Returns pointer to the shared buffer on success, NULL otherwise.
  *
  * The caller must not free() the returned pointer.
+ *
+ * The caller must repeat calling this function without changing @fp until this
+ * function returns NULL, for this function caches a line if the line is
+ * packed. Otherwise, some garbage lines might be returned to the caller.
  */
 char *ccs_freadline(FILE *fp)
 {
 	static char *policy = NULL;
+	static char *packed_policy = NULL;
+	static int pack_start = 0;
+	static int pack_len = 0;
 	int pos = 0;
 	if (!ccs_buffer_locked)
 		ccs_out_of_memory();
+	if (packed_policy)
+		goto unpack;
 	while (true) {
 		static int max_policy_len = 0;
 		const int c = fgetc(fp);
@@ -1962,7 +1971,79 @@
 	}
 	if (!ccs_freadline_raw)
 		ccs_normalize_line(policy);
+	{
+		char *cp;
+		char *cp2 = NULL;
+		unsigned int len;
+		if (sscanf(policy, "acl_group %u", &len) == 1 && len < 256)
+			cp = strchr(policy + 11, ' ');
+		else
+			cp = NULL;
+		if (cp++)
+			pos = cp - policy;
+		else
+			pos = 0;
+		if (!strncmp(policy + pos, "file ", 5)) {
+			cp = policy + pos + 5;
+			cp2 = strchr(cp + 1, ' ');
+			len = cp2 - cp;
+			if (cp2 && memchr(cp, '/', len)) {
+				packed_policy = policy;
+				pack_start = pos + 5;
+				pack_len = len;
+				policy = NULL;
+				goto unpack;
+			}
+		} else if (!strncmp(policy + pos, "network ", 8)) {
+			cp = strchr(policy + pos + 8, ' ');
+			if (cp)
+				cp = strchr(cp + 1, ' ');
+			if (cp)
+				cp2 = strchr(cp + 1, ' ');
+			cp++;
+			len = cp2 - cp;
+			if (cp2 && memchr(cp, '/', len)) {
+				packed_policy = policy;
+				pack_start = cp - policy;
+				pack_len = len;
+				policy = NULL;
+				goto unpack;
+			}
+		}
+	}
 	return policy;
+unpack:
+	{
+		char *pos = packed_policy + pack_start;
+		char *cp = memchr(pos, '/', pack_len);
+		int len = cp - pos;
+		free(policy);
+		if (!cp) {
+			policy = packed_policy;
+			packed_policy = NULL;
+		} else if (pack_len == 1) {
+			/* Ignore trailing empty word. */
+			policy = NULL;
+			packed_policy = NULL;
+		} else {
+			/* Current string is "abc d/e/f ghi". */
+			policy = strdup(packed_policy);
+			if (!policy)
+				ccs_out_of_memory();
+			/* Overwrite "abc d/e/f ghi" with "abc d ghi". */
+			memmove(policy + pack_start + len, pos + pack_len,
+				strlen(pos + pack_len) + 1);
+			/* Overwrite "abc d/e/f ghi" with "abc e/f ghi". */
+			cp++;
+			memmove(pos, cp, strlen(cp) + 1);
+			/* Forget "d/" component. */
+			pack_len -= len + 1;
+			/* Ignore leading and middle empty word. */
+			if (!len)
+				goto unpack;
+		}
+		return policy;
+	}
 }
 
 /**
