Index: trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h	(revision 2252)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h	(working copy)
@@ -23,7 +23,9 @@
 enum ccs_proc_interface_index {
 	CCS_DOMAINPOLICY,
 	CCS_EXCEPTIONPOLICY,
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	CCS_SYSTEMPOLICY,
+#endif
 	CCS_DOMAIN_STATUS,
 	CCS_PROCESS_STATUS,
 	CCS_MEMINFO,
@@ -34,10 +36,14 @@
 	CCS_SELFDOMAIN,
 	CCS_VERSION,
 	CCS_PROFILE,
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	CCS_QUERY,
+#endif
 	CCS_MANAGER,
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	CCS_UPDATESCOUNTER,
 	CCS_EXECUTE_HANDLER
+#endif
 };
 
 #endif
Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo_socket.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo_socket.h	(revision 2252)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo_socket.h	(working copy)
@@ -20,7 +20,7 @@
 struct sock;
 struct sk_buff;
 
-#if defined(CONFIG_TOMOYO)
+#if defined(CONFIG_TOMOYO) && !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 
 int ccs_socket_create_permission(int family, int type, int protocol);
 int ccs_socket_listen_permission(struct socket *sock);
Index: trunk/1.6.x/ccs-patch/include/linux/ccs_common.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(revision 2252)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(working copy)
@@ -118,6 +118,8 @@
 	rcu_assign_pointer(prev->next, new);
 }
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /* Subset of "struct stat". */
 struct ccs_mini_stat {
 	uid_t uid;
@@ -162,15 +164,21 @@
 	/* "struct ccs_envp_entry envp[envc]" follows here. */
 };
 
+#endif
+
 struct ccs_execve_entry;
 
 /* Structure for request info. */
 struct ccs_request_info {
 	struct domain_info *domain;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	struct ccs_obj_info *obj;
+#endif
 	struct ccs_execve_entry *ee;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	const struct ccs_condition_list *cond;
 	u16 retry;
+#endif
 	u8 profile;
 	u8 mode;
 };
@@ -202,15 +210,21 @@
 	struct list_head list;
 	struct task_struct *task; /* = current */
 	struct ccs_request_info r;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	struct ccs_obj_info obj;
+#endif
 	struct linux_binprm *bprm;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	/* For execute_handler */
 	const struct ccs_path_info *handler;
+#endif
 	/* For calculating domain to transit to. */
 	struct domain_info *next_domain; /* Initialized to NULL. */
 	char *program_path; /* Size is CCS_MAX_PATHNAME_LEN bytes */
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	/* For dumping argv[] and envp[]. */
 	struct ccs_page_dump dump;
+#endif
 	/* For temporary use. */
 	char *tmp; /* Size is CCS_EXEC_TMPSIZE bytes */
 };
@@ -258,12 +272,14 @@
 
 /* Common header for holding ACL entries. */
 struct ccs_acl_info {
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	/*
 	 * Keep "access_me_via_ccs_get_condition_part" first, for
 	 * memory for this filed is not allocated if
 	 * (type & ACL_WITH_CONDITION) == 0.
 	 */
 	const struct ccs_condition_list *access_me_via_ccs_get_condition_part;
+#endif
 	struct list1_head list;
 	/*
 	 * Type of this ACL entry.
@@ -278,6 +294,7 @@
 enum ccs_acl_entry_type_index {
 	TYPE_SINGLE_PATH_ACL,
 	TYPE_DOUBLE_PATH_ACL,
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	TYPE_ARGV0_ACL,
 	TYPE_ENV_ACL,
 	TYPE_CAPABILITY_ACL,
@@ -285,6 +302,7 @@
 	TYPE_SIGNAL_ACL,
 	TYPE_EXECUTE_HANDLER,
 	TYPE_DENIED_EXECUTE_HANDLER
+#endif
 };
 
 /* This ACL entry is deleted.           */
@@ -457,12 +475,16 @@
 	} u;
 };
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 enum ccs_ip_record_type {
 	IP_RECORD_TYPE_ADDRESS_GROUP,
 	IP_RECORD_TYPE_IPv4,
 	IP_RECORD_TYPE_IPv6
 };
 
+#endif
+
 /* Keywords for ACLs. */
 #define KEYWORD_ADDRESS_GROUP             "address_group "
 #define KEYWORD_AGGREGATOR                "aggregator "
@@ -501,6 +523,7 @@
 /* Index numbers for Access Controls. */
 enum ccs_profile_index {
 	CCS_TOMOYO_MAC_FOR_FILE,          /* domain_policy.conf */
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	CCS_TOMOYO_MAC_FOR_ARGV0,         /* domain_policy.conf */
 	CCS_TOMOYO_MAC_FOR_ENV,           /* domain_policy.conf */
 	CCS_TOMOYO_MAC_FOR_NETWORK,       /* domain_policy.conf */
@@ -511,16 +534,20 @@
 	CCS_SAKURA_RESTRICT_UNMOUNT,      /* system_policy.conf */
 	CCS_SAKURA_RESTRICT_PIVOT_ROOT,   /* system_policy.conf */
 	CCS_SAKURA_RESTRICT_AUTOBIND,     /* system_policy.conf */
+#endif
 	CCS_TOMOYO_MAX_ACCEPT_ENTRY,
 #ifdef CONFIG_TOMOYO_AUDIT
 	CCS_TOMOYO_MAX_GRANT_LOG,
 	CCS_TOMOYO_MAX_REJECT_LOG,
 #endif
 	CCS_TOMOYO_VERBOSE,
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	CCS_SLEEP_PERIOD,
+#endif
 	CCS_MAX_CONTROL_INDEX
 };
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Index numbers for updates counter. */
 enum ccs_update_counter_index {
 	CCS_UPDATES_COUNTER_SYSTEM_POLICY,
@@ -535,6 +562,7 @@
 #endif
 	MAX_CCS_UPDATES_COUNTER
 };
+#endif
 
 /* Structure for reading/writing policy via /proc interfaces. */
 struct ccs_io_buffer {
@@ -576,14 +604,19 @@
 /* Prototype definition. */
 struct ccs_condition_list;
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Check conditional part of an ACL entry. */
 bool ccs_check_condition(struct ccs_request_info *r,
 			 const struct ccs_acl_info *acl);
+#endif
+
 /* Check whether the domain has too many ACL entries to hold. */
 bool ccs_domain_quota_ok(struct domain_info * const domain);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Dump a page to buffer. */
 bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos,
 		   struct ccs_page_dump *dump);
+#endif
 /* Transactional sprintf() for policy dump. */
 bool ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
@@ -599,6 +632,7 @@
 /* Check whether the given filename matches the given pattern. */
 bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 			      const struct ccs_path_info *pattern);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Print conditional part of an ACL entry. */
 bool ccs_print_condition(struct ccs_io_buffer *head,
 			 const struct ccs_condition_list *cond);
@@ -606,10 +640,13 @@
 bool ccs_read_address_group_policy(struct ccs_io_buffer *head);
 /* Read "aggregator" entry in exception policy. */
 bool ccs_read_aggregator_policy(struct ccs_io_buffer *head);
+#endif
 /* Read "alias" entry in exception policy. */
 bool ccs_read_alias_policy(struct ccs_io_buffer *head);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Read "allow_chroot" entry in system policy. */
 bool ccs_read_chroot_policy(struct ccs_io_buffer *head);
+#endif
 /*
  * Read "initialize_domain" and "no_initialize_domain" entry
  * in exception policy.
@@ -621,12 +658,15 @@
 bool ccs_read_file_pattern(struct ccs_io_buffer *head);
 /* Read "allow_read" entry in exception policy. */
 bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Read "allow_env" entry in exception policy. */
 bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head);
 /* Read "allow_mount" entry in system policy. */
 bool ccs_read_mount_policy(struct ccs_io_buffer *head);
+#endif
 /* Read "deny_rewrite" entry in exception policy. */
 bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Read "deny_unmount" entry in system policy. */
 bool ccs_read_no_umount_policy(struct ccs_io_buffer *head);
 /* Read "path_group" entry in exception policy. */
@@ -635,12 +675,15 @@
 bool ccs_read_pivot_root_policy(struct ccs_io_buffer *head);
 /* Read "deny_autobind" entry in system policy. */
 bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head);
+#endif
 /* Write domain policy violation warning message to console? */
 bool ccs_verbose_mode(const struct domain_info *domain);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Allocate buffer for domain policy auditing. */
 char *ccs_init_audit_log(int *len, struct ccs_request_info *r);
 /* Convert capability index to capability name. */
 const char *ccs_cap2keyword(const u8 operation);
+#endif
 /* Convert double path operation to operation name. */
 const char *ccs_dp2keyword(const u8 operation);
 /* Get the pathname of current process. */
@@ -649,23 +692,29 @@
 const char *ccs_get_last_name(const struct domain_info *domain);
 /* Get warning message. */
 const char *ccs_get_msg(const bool is_enforce);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Convert network operation index to operation name. */
 const char *ccs_net2keyword(const u8 operation);
+#endif
 /* Convert single path operation to operation name. */
 const char *ccs_sp2keyword(const u8 operation);
 /* Fetch next_domain from the list. */
 struct domain_info *ccs_fetch_next_domain(void);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Create conditional part of an ACL entry. */
 const struct ccs_condition_list *
 ccs_find_or_assign_new_condition(char * const condition);
 /* Create conditional part for execute_handler process. */
 const struct ccs_condition_list *ccs_handler_cond(void);
+#endif
 /* Add an ACL entry to domain's ACL list. */
 int ccs_add_domain_acl(struct domain_info *domain, struct ccs_acl_info *acl);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Ask supervisor's opinion. */
 int ccs_check_supervisor(struct ccs_request_info *r,
 			 const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
+#endif
 /* Close /proc/ccs/ interface. */
 int ccs_close_control(struct file *file);
 /* Delete an ACL entry from domain's ACL list. */
@@ -674,15 +723,18 @@
 int ccs_delete_domain(char *data);
 /* Open operation for /proc/ccs/ interface. */
 int ccs_open_control(const u8 type, struct file *file);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Poll operation for /proc/ccs/ interface. */
 int ccs_poll_control(struct file *file, poll_table *wait);
 /* Check whether there is a grant log. */
 int ccs_poll_grant_log(struct file *file, poll_table *wait);
 /* Check whether there is a reject log. */
 int ccs_poll_reject_log(struct file *file, poll_table *wait);
+#endif
 /* Read operation for /proc/ccs/ interface. */
 int ccs_read_control(struct file *file, char __user *buffer,
 		     const int buffer_len);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Read a grant log. */
 int ccs_read_grant_log(struct ccs_io_buffer *head);
 /* Read a reject log. */
@@ -691,8 +743,10 @@
 int ccs_write_address_group_policy(char *data, const bool is_delete);
 /* Create "aggregator" entry in exception policy. */
 int ccs_write_aggregator_policy(char *data, const bool is_delete);
+#endif
 /* Create "alias" entry in exception policy. */
 int ccs_write_alias_policy(char *data, const bool is_delete);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Create "allow_argv0" entry in domain policy. */
 int ccs_write_argv0_policy(char *data, struct domain_info *domain,
 			   const struct ccs_condition_list *condition,
@@ -707,6 +761,7 @@
 				const bool is_delete);
 /* Create "allow_chroot" entry in system policy. */
 int ccs_write_chroot_policy(char *data, const bool is_delete);
+#endif
 /*
  * Create "initialize_domain" and "no_initialize_domain" entry
  * in exception policy.
@@ -716,10 +771,12 @@
 /* Create "keep_domain" and "no_keep_domain" entry in exception policy. */
 int ccs_write_domain_keeper_policy(char *data, const bool is_not,
 				   const bool is_delete);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Create "allow_env" entry in domain policy. */
 int ccs_write_env_policy(char *data, struct domain_info *domain,
 			 const struct ccs_condition_list *condition,
 			 const bool is_delete);
+#endif
 /*
  * Create "allow_read/write", "allow_execute", "allow_read", "allow_write",
  * "allow_create", "allow_unlink", "allow_mkdir", "allow_rmdir",
@@ -733,6 +790,7 @@
 			  const bool is_delete);
 /* Create "allow_read" entry in exception policy. */
 int ccs_write_globally_readable_policy(char *data, const bool is_delete);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Create "allow_env" entry in exception policy. */
 int ccs_write_globally_usable_env_policy(char *data, const bool is_delete);
 /* Create "allow_mount" entry in system policy. */
@@ -741,14 +799,18 @@
 int ccs_write_network_policy(char *data, struct domain_info *domain,
 			     const struct ccs_condition_list *condition,
 			     const bool is_delete);
+#endif
 /* Create "deny_rewrite" entry in exception policy. */
 int ccs_write_no_rewrite_policy(char *data, const bool is_delete);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Create "deny_unmount" entry in system policy. */
 int ccs_write_no_umount_policy(char *data, const bool is_delete);
 /* Create "path_group" entry in exception policy. */
 int ccs_write_path_group_policy(char *data, const bool is_delete);
+#endif
 /* Create "file_pattern" entry in exception policy. */
 int ccs_write_pattern_policy(char *data, const bool is_delete);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Create "allow_pivot_root" entry in system policy. */
 int ccs_write_pivot_root_policy(char *data, const bool is_delete);
 /* Create "deny_autobind" entry in system policy. */
@@ -757,6 +819,7 @@
 int ccs_write_signal_policy(char *data, struct domain_info *domain,
 			    const struct ccs_condition_list *condition,
 			    const bool is_delete);
+#endif
 /* Write operation for /proc/ccs/ interface. */
 int ccs_write_control(struct file *file, const char __user *buffer,
 		      const int buffer_len);
@@ -781,12 +844,15 @@
 			   struct domain_info *domain, const u8 index);
 /* Run policy loader when /sbin/init starts. */
 void ccs_load_policy(const char *filename);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Print an IPv6 address. */
 void ccs_print_ipv6(char *buffer, const int buffer_len,
 		    const struct in6_addr *ip);
+#endif
 /* Change "struct domain_info"->flags. */
 void ccs_set_domain_flag(struct domain_info *domain, const bool is_delete,
 			 const u8 flags);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /* Update the policy change counter. */
 void ccs_update_counter(const unsigned char index);
 
@@ -796,6 +862,7 @@
 			 const char *argv0);
 /* Check whether the given environment is allowed to be received. */
 int ccs_check_env_perm(struct ccs_request_info *r, const char *env);
+#endif
 /* Check whether the given pathname is allowed to be executed. */
 int ccs_check_exec_perm(struct ccs_request_info *r,
 			const struct ccs_path_info *filename);
@@ -819,6 +886,7 @@
 	return ptr->type & ~ACL_WITH_CONDITION;
 }
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /**
  * ccs_get_condition_part - Get condition part of the given ACL entry.
  *
@@ -832,6 +900,7 @@
 	return (acl->type & ACL_WITH_CONDITION) ?
 		acl->access_me_via_ccs_get_condition_part : NULL;
 }
+#endif
 
 /* A linked list of domains. */
 extern struct list1_head ccs_domain_list;
Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(revision 2252)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(working copy)
@@ -55,12 +55,27 @@
 			 struct vfsmount *mnt2);
 int ccs_check_rewrite_permission(struct file *filp);
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /* Check whether the given signal is allowed to use. */
 int ccs_check_signal_acl(const int sig, const int pid);
 
 /* Check whether the given capability is allowed to use. */
 _Bool ccs_capable(const u8 operation);
 
+#else
+
+static inline int ccs_check_signal_acl(const int sig, const int pid)
+{
+	return 0;
+}
+static inline _Bool ccs_capable(const u8 operation)
+{
+	return 1;
+}
+
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 /* Some of permission checks from vfs_create(). */
 int ccs_pre_vfs_create(struct inode *dir, struct dentry *dentry);
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_env.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_env.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_env.c	(working copy)
@@ -16,6 +16,8 @@
 #include <linux/tomoyo.h>
 #include <linux/realpath.h>
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /**
  * ccs_audit_env_log - Audit environment variable name log.
  *
@@ -295,3 +297,5 @@
 {
 	return ccs_update_env_entry(data, domain, condition, is_delete);
 }
+
+#endif
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_network.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_network.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_network.c	(working copy)
@@ -24,6 +24,8 @@
 #include <net/ipv6.h>
 #include <net/udp.h>
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /* Index numbers for Network Controls. */
 enum ccs_network_acl_index {
 	NETWORK_ACL_UDP_BIND,
@@ -1294,3 +1296,5 @@
 	/* Hope less harmful than -EPERM. */
 	return -EAGAIN;
 }
+
+#endif
Index: trunk/1.6.x/ccs-patch/fs/Config.ccs.in
===================================================================
--- trunk/1.6.x/ccs-patch/fs/Config.ccs.in	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/Config.ccs.in	(working copy)
@@ -1,9 +1,15 @@
 #
 # Mandatory Access Control configuration
 #
-[ -z "$CONFIG_SAKURA" ] && define_bool CONFIG_SAKURA y
-bool 'SAKURA (Domain-Free Mandatory Access Control) support' CONFIG_SAKURA
+[ -z "$CONFIG_TOMOYO_2_2_0_ONLY" ] && define_bool CONFIG_TOMOYO_2_2_0_ONLY n
 
+if [ "$CONFIG_TOMOYO_2_2_0_ONLY" = "n" ]; then
+
+  [ -z "$CONFIG_SAKURA" ] && define_bool CONFIG_SAKURA y
+  bool 'SAKURA (Domain-Free Mandatory Access Control) support' CONFIG_SAKURA
+
+fi
+
 [ -z "$CONFIG_TOMOYO" ] && define_bool CONFIG_TOMOYO y
 bool 'TOMOYO (Domain-Based Mandatory Access Control) support' CONFIG_TOMOYO
 
@@ -13,22 +19,31 @@
   [ $CONFIG_TOMOYO_MAX_ACCEPT_ENTRY -lt 0 ] && define_int CONFIG_TOMOYO_MAX_ACCEPT_ENTRY 0
   int  '  Default maximal count for learning mode' CONFIG_TOMOYO_MAX_ACCEPT_ENTRY
 
-  [ -z "$CONFIG_TOMOYO_AUDIT" ] && define_bool CONFIG_TOMOYO_AUDIT y
-  bool '  Auditing interface support' CONFIG_TOMOYO_AUDIT
+  bool '  Enable only TOMOYO Linux 2.2.0 compatible functionality' CONFIG_TOMOYO_2_2_0_ONLY
 
-  if [ "$CONFIG_TOMOYO_AUDIT" = "y" ]; then
+  if [ "$CONFIG_TOMOYO_2_2_0_ONLY" = "n" ]; then
 
-    [ -z "$CONFIG_TOMOYO_MAX_GRANT_LOG" ] && define_int CONFIG_TOMOYO_MAX_GRANT_LOG 1024
-    [ $CONFIG_TOMOYO_MAX_GRANT_LOG -lt 0 ] && define_int CONFIG_TOMOYO_MAX_GRANT_LOG 0
-    int  '  Default maximal count for grant log' CONFIG_TOMOYO_MAX_GRANT_LOG
+    [ -z "$CONFIG_TOMOYO_AUDIT" ] && define_bool CONFIG_TOMOYO_AUDIT y
+    bool '  Auditing interface support' CONFIG_TOMOYO_AUDIT
 
-    [ -z "$CONFIG_TOMOYO_MAX_REJECT_LOG" ] && define_int CONFIG_TOMOYO_MAX_REJECT_LOG 1024
-    [ $CONFIG_TOMOYO_MAX_REJECT_LOG -lt 0 ] && define_int CONFIG_TOMOYO_MAX_REJECT_LOG 0
-    int  '  Default maximal count for reject log' CONFIG_TOMOYO_MAX_REJECT_LOG
+    if [ "$CONFIG_TOMOYO_AUDIT" = "y" ]; then
 
+      [ -z "$CONFIG_TOMOYO_MAX_GRANT_LOG" ] && define_int CONFIG_TOMOYO_MAX_GRANT_LOG 1024
+      [ $CONFIG_TOMOYO_MAX_GRANT_LOG -lt 0 ] && define_int CONFIG_TOMOYO_MAX_GRANT_LOG 0
+      int  '  Default maximal count for grant log' CONFIG_TOMOYO_MAX_GRANT_LOG
+
+      [ -z "$CONFIG_TOMOYO_MAX_REJECT_LOG" ] && define_int CONFIG_TOMOYO_MAX_REJECT_LOG 1024
+      [ $CONFIG_TOMOYO_MAX_REJECT_LOG -lt 0 ] && define_int CONFIG_TOMOYO_MAX_REJECT_LOG 0
+      int  '  Default maximal count for reject log' CONFIG_TOMOYO_MAX_REJECT_LOG
+    fi
+
   fi
 
 fi
 
-[ -z "$CONFIG_SYAORAN" ] && define_tristate CONFIG_SYAORAN m
-tristate 'SYAORAN (Tamper-Proof Device Filesystem) support' CONFIG_SYAORAN
+if [ "$CONFIG_TOMOYO_2_2_0_ONLY" = "n" ]; then
+
+  [ -z "$CONFIG_SYAORAN" ] && define_tristate CONFIG_SYAORAN m
+  tristate 'SYAORAN (Tamper-Proof Device Filesystem) support' CONFIG_SYAORAN
+
+fi
Index: trunk/1.6.x/ccs-patch/fs/Kconfig.ccs
===================================================================
--- trunk/1.6.x/ccs-patch/fs/Kconfig.ccs	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/Kconfig.ccs	(working copy)
@@ -1,6 +1,7 @@
 config SAKURA
 	bool "SAKURA (Domain-Free Mandatory Access Control) support"
 	default y
+	depends on !TOMOYO_2_2_0_ONLY
 	help
 	  Say Y here to support the Domain-Free Mandatory Access Control.
 
@@ -55,10 +56,19 @@
 	  and consumes much memory.
 	  This is the safeguard for such programs.
 
+config TOMOYO_2_2_0_ONLY
+	bool "Enable only TOMOYO Linux 2.2.0 compatible functionality"
+	default n
+	depends on TOMOYO
+	help
+	  Say Y here to enable only TOMOYO Linux 2.2.0 compatible
+	  functionality.
+
 config TOMOYO_AUDIT
 	bool "Auditing interface support"
 	default y
 	depends on TOMOYO
+	depends on !TOMOYO_2_2_0_ONLY
 	help
 	  This option enables /proc/ccs/grant_log and /proc/ccs/reject_log
 	  interfaces. You may disable these interfaces if you want to apply for
@@ -90,6 +100,7 @@
 
 config SYAORAN
 	tristate "SYAORAN (Tamper-Proof Device Filesystem) support"
+	depends on !TOMOYO_2_2_0_ONLY
 	default m
 	help
 	  Say Y or M here to support the Tamper-Proof Device Filesystem.
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(working copy)
@@ -17,6 +17,8 @@
 #include <linux/realpath.h>
 #include <linux/highmem.h>
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /**
  * ccs_print_bprm - Print "struct linux_binprm" for auditing.
  *
@@ -424,3 +426,5 @@
 	return 0;
 }
 #endif
+
+#endif
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(working copy)
@@ -59,6 +59,8 @@
 	bool is_last_name; /* True if the domainname is ccs_get_last_name(). */
 };
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /* Structure for "aggregator" keyword. */
 struct ccs_aggregator_entry {
 	struct list1_head list;
@@ -67,6 +69,8 @@
 	bool is_deleted;
 };
 
+#endif
+
 /* Structure for "alias" keyword. */
 struct ccs_alias_entry {
 	struct list1_head list;
@@ -139,7 +143,9 @@
 	} else {
 		acl->type &= ~ACL_DELETED;
 	}
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
+#endif
 	return 0;
 }
 
@@ -154,10 +160,14 @@
 {
 	if (acl)
 		acl->type |= ACL_DELETED;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
+#endif
 	return 0;
 }
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /**
  * ccs_audit_execute_handler_log - Audit execute_handler log.
  *
@@ -191,6 +201,8 @@
 	return ccs_write_audit_log(false, &r, "use_profile %u\n", r.profile);
 }
 
+#endif
+
 /* The list for "struct ccs_domain_initializer_entry". */
 static LIST1_HEAD(ccs_domain_initializer_list);
 
@@ -256,7 +268,9 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
+#endif
 	return error;
 }
 
@@ -419,7 +433,9 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
+#endif
 	return error;
 }
 
@@ -562,7 +578,9 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
+#endif
 	return error;
 }
 
@@ -608,6 +626,8 @@
 	return ccs_update_alias_entry(data, cp, is_delete);
 }
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /* The list for "struct ccs_aggregator_entry". */
 static LIST1_HEAD(ccs_aggregator_list);
 
@@ -659,7 +679,9 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
+#endif
 	return error;
 }
 
@@ -705,6 +727,8 @@
 	return ccs_update_aggregator_entry(data, cp, is_delete);
 }
 
+#endif
+
 /* Domain create/delete/undelete handler. */
 
 /* #define DEBUG_DOMAIN_UNDELETE */
@@ -883,6 +907,8 @@
 	return domain;
 }
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /**
  * ccs_get_argv0 - Get argv[0].
  *
@@ -938,6 +964,8 @@
 	return false;
 }
 
+#endif
+
 /**
  * ccs_find_next_domain - Find a domain.
  *
@@ -948,7 +976,9 @@
 static int ccs_find_next_domain(struct ccs_execve_entry *ee)
 {
 	struct ccs_request_info *r = &ee->r;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	const struct ccs_path_info *handler = ee->handler;
+#endif
 	struct domain_info *domain = NULL;
 	const char *old_domain_name = r->domain->domainname->name;
 	struct linux_binprm *bprm = ee->bprm;
@@ -978,9 +1008,13 @@
 		}
 	}
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
  retry:
+#endif
 	current->tomoyo_flags = tomoyo_flags;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	r->cond = NULL;
+#endif
 	/* Get realpath of program and symbolic link. */
 	retval = ccs_realpath_both(bprm->filename, ee);
 	if (retval < 0)
@@ -993,6 +1027,7 @@
 	ln.name = ccs_get_last_name(r->domain);
 	ccs_fill_path_info(&ln);
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (handler) {
 		if (ccs_pathcmp(&rn, handler)) {
 			/* Failed to verify execute handler. */
@@ -1006,6 +1041,7 @@
 		}
 		goto calculate_domain;
 	}
+#endif
 
 	/* Check 'alias' directive. */
 	if (ccs_pathcmp(&rn, &sn)) {
@@ -1024,6 +1060,7 @@
 	}
 	/* sn will be overwritten after here. */
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	/* Compare basename of program_path and argv[0] */
 	r->mode = ccs_check_flags(r->domain, CCS_TOMOYO_MAC_FOR_ARGV0);
 	if (bprm->argc > 0 && r->mode) {
@@ -1060,16 +1097,21 @@
 			break;
 		}
 	}
+#endif
 
 	/* Check execute permission. */
 	r->mode = mode;
 	retval = ccs_check_exec_perm(r, &rn);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (retval == 1)
 		goto retry;
+#endif
 	if (retval < 0)
 		goto out;
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
  calculate_domain:
+#endif
 	new_domain_name = ee->tmp;
 	if (ccs_is_domain_initializer(r->domain->domainname, &rn, &ln)) {
 		/* Transit to the child of KERNEL_DOMAIN domain. */
@@ -1096,17 +1138,21 @@
 	if (domain)
 		goto done;
 	if (is_enforce) {
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 		int error = ccs_check_supervisor(r,
 						 "# wants to create domain\n"
 						 "%s\n", new_domain_name);
 		if (error == 1)
 			goto retry;
 		if (error < 0)
+#endif
 			goto done;
 	}
 	domain = ccs_find_or_assign_new_domain(new_domain_name, r->profile);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (domain)
 		ccs_audit_domain_creation_log(domain);
+#endif
  done:
 	if (!domain) {
 		printk(KERN_WARNING "TOMOYO-ERROR: Domain '%s' not defined.\n",
@@ -1127,6 +1173,8 @@
 	return retval;
 }
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /**
  * ccs_check_environ - Check permission for environment variable names.
  *
@@ -1308,6 +1356,8 @@
 	return depth;
 }
 
+#endif
+
 static LIST_HEAD(ccs_execve_list);
 static DEFINE_SPINLOCK(ccs_execve_list_lock);
 
@@ -1379,10 +1429,14 @@
 	/***** CRITICAL SECTION END *****/
 	ccs_free(ee->program_path);
 	ccs_free(ee->tmp);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	kfree(ee->dump.data);
+#endif
 	ccs_free(ee);
 }
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /**
  * ccs_try_alt_exec - Try to start execute handler.
  *
@@ -1672,6 +1726,8 @@
 	return true;
 }
 
+#endif
+
 /**
  * ccs_fetch_next_domain - Fetch next_domain from the list.
  *
@@ -1707,19 +1763,24 @@
 		return -ENOMEM;
 	ccs_init_request_info(&ee->r, NULL, CCS_TOMOYO_MAC_FOR_FILE);
 	ee->r.ee = ee;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ee->bprm = bprm;
 	ee->r.obj = &ee->obj;
 	ee->obj.path1_dentry = bprm->file->f_dentry;
 	ee->obj.path1_vfsmnt = bprm->file->f_vfsmnt;
+#endif
 	/* Clear manager flag. */
 	task->tomoyo_flags &= ~CCS_TASK_IS_POLICY_MANAGER;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (ccs_find_execute_handler(ee, TYPE_EXECUTE_HANDLER)) {
 		retval = ccs_try_alt_exec(ee);
 		if (!retval)
 			ccs_audit_execute_handler_log(ee, true);
 		goto ok;
 	}
+#endif
 	retval = ccs_find_next_domain(ee);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (retval != -EPERM)
 		goto ok;
 	if (ccs_find_execute_handler(ee, TYPE_DENIED_EXECUTE_HANDLER)) {
@@ -1728,12 +1789,15 @@
 			ccs_audit_execute_handler_log(ee, false);
 	}
  ok:
+#endif
 	if (retval < 0)
 		goto out;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ee->r.mode = ccs_check_flags(ee->r.domain, CCS_TOMOYO_MAC_FOR_ENV);
 	retval = ccs_check_environ(ee);
 	if (retval < 0)
 		goto out;
+#endif
 	ee->next_domain = ee->r.domain;
 	task->tomoyo_flags |= TOMOYO_CHECK_READ_FOR_OPEN_EXEC;
 	retval = 0;
@@ -1760,12 +1824,14 @@
 	/* Proceed to next domain if execution suceeded. */
 	task->domain_info = ee->r.domain;
 	mb(); /* Make domain transition visible to other CPUs. */
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	/* Mark the current process as execute handler. */
 	if (ee->handler)
 		task->tomoyo_flags |= TOMOYO_TASK_IS_EXECUTE_HANDLER;
 	/* Mark the current process as normal process. */
 	else
 		task->tomoyo_flags &= ~TOMOYO_TASK_IS_EXECUTE_HANDLER;
+#endif
  out:
 	ccs_free_execve_entry(ee);
 }
Index: trunk/1.6.x/ccs-patch/fs/ccs_common.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/ccs_common.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/ccs_common.c	(working copy)
@@ -1704,6 +1704,7 @@
 	return false;
 }
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 /**
  * ccs_print_argv0_acl - Print an argv[0] ACL entry.
  *
@@ -1926,6 +1927,7 @@
 {
 	return ccs_io_printf(head, "%s %s\n", keyword, ptr->handler->name);
 }
+#endif
 
 /**
  * ccs_print_entry - Print an ACL entry.
@@ -1948,6 +1950,7 @@
 				       head);
 		return ccs_print_single_path_acl(head, acl, cond);
 	}
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (acl_type == TYPE_EXECUTE_HANDLER) {
 		struct ccs_execute_handler_record *acl
 			= container_of(ptr, struct ccs_execute_handler_record,
@@ -1962,6 +1965,7 @@
 		const char *keyword = KEYWORD_DENIED_EXECUTE_HANDLER;
 		return ccs_print_execute_handler_record(head, keyword, acl);
 	}
+#endif
 	if (head->read_execute_only)
 		return true;
 	if (acl_type == TYPE_DOUBLE_PATH_ACL) {
@@ -1970,6 +1974,7 @@
 				       head);
 		return ccs_print_double_path_acl(head, acl, cond);
 	}
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (acl_type == TYPE_ARGV0_ACL) {
 		struct ccs_argv0_acl_record *acl
 			= container_of(ptr, struct ccs_argv0_acl_record, head);
@@ -1997,6 +2002,7 @@
 			= container_of(ptr, struct ccs_signal_acl_record, head);
 		return ccs_print_signal_acl(head, acl, cond);
 	}
+#endif
 	/* Workaround for gcc 3.2.2's inline bug. */
 	if (acl_type & ACL_DELETED)
 		return true;
@@ -2228,20 +2234,28 @@
 							   is_delete);
 	if (ccs_str_starts(&data, KEYWORD_ALIAS))
 		return ccs_write_alias_policy(data, is_delete);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (ccs_str_starts(&data, KEYWORD_AGGREGATOR))
 		return ccs_write_aggregator_policy(data, is_delete);
+#endif
 	if (ccs_str_starts(&data, KEYWORD_ALLOW_READ))
 		return ccs_write_globally_readable_policy(data, is_delete);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (ccs_str_starts(&data, KEYWORD_ALLOW_ENV))
 		return ccs_write_globally_usable_env_policy(data, is_delete);
+#endif
 	if (ccs_str_starts(&data, KEYWORD_FILE_PATTERN))
 		return ccs_write_pattern_policy(data, is_delete);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (ccs_str_starts(&data, KEYWORD_PATH_GROUP))
 		return ccs_write_path_group_policy(data, is_delete);
+#endif
 	if (ccs_str_starts(&data, KEYWORD_DENY_REWRITE))
 		return ccs_write_no_rewrite_policy(data, is_delete);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (ccs_str_starts(&data, KEYWORD_ADDRESS_GROUP))
 		return ccs_write_address_group_policy(data, is_delete);
+#endif
 	return -EINVAL;
 }
 
@@ -2270,8 +2284,10 @@
 			head->read_var2 = NULL;
 			head->read_step = 3;
 		case 3:
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 			if (!ccs_read_globally_usable_env_policy(head))
 				break;
+#endif
 			head->read_var2 = NULL;
 			head->read_step = 4;
 		case 4:
@@ -2285,8 +2301,10 @@
 			head->read_var2 = NULL;
 			head->read_step = 6;
 		case 6:
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 			if (!ccs_read_aggregator_policy(head))
 				break;
+#endif
 			head->read_var2 = NULL;
 			head->read_step = 7;
 		case 7:
@@ -2300,8 +2318,10 @@
 			head->read_var2 = NULL;
 			head->read_step = 9;
 		case 9:
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 			if (!ccs_read_path_group_policy(head))
 				break;
+#endif
 			head->read_var1 = NULL;
 			head->read_var2 = NULL;
 			head->read_step = 10;
@@ -2847,6 +2867,8 @@
 	return 0;
 }
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 #if !defined(atomic_xchg) || LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 3)
 
 /* Policy updates counter. */
@@ -2981,6 +3003,8 @@
 
 #endif
 
+#endif
+
 /**
  * ccs_read_version: Get version.
  *
@@ -3067,6 +3091,7 @@
 		head->write = ccs_write_domain_profile;
 		head->read = ccs_read_domain_profile;
 		break;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	case CCS_EXECUTE_HANDLER: /* /proc/ccs/.execute_handler */
 		/* Allow execute_handler to read process's status. */
 		if (!(current->tomoyo_flags & TOMOYO_TASK_IS_EXECUTE_HANDLER)) {
@@ -3074,6 +3099,7 @@
 			return -EPERM;
 		}
 		/* fall through */
+#endif
 	case CCS_PROCESS_STATUS: /* /proc/ccs/.process_status */
 		head->write = ccs_write_pid;
 		head->read = ccs_read_pid;
@@ -3091,18 +3117,22 @@
 		head->write = ccs_write_profile;
 		head->read = ccs_read_profile;
 		break;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	case CCS_QUERY: /* /proc/ccs/query */
 		head->poll = ccs_poll_query;
 		head->write = ccs_write_answer;
 		head->read = ccs_read_query;
 		break;
+#endif
 	case CCS_MANAGER: /* /proc/ccs/manager */
 		head->write = ccs_write_manager_policy;
 		head->read = ccs_read_manager_policy;
 		break;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	case CCS_UPDATESCOUNTER: /* /proc/ccs/.ccs_updates_counter */
 		head->read = ccs_read_updates_counter;
 		break;
+#endif
 	}
 	if (!(file->f_mode & FMODE_READ)) {
 		/*
@@ -3111,7 +3141,12 @@
 		 */
 		head->read = NULL;
 		head->poll = NULL;
-	} else if (type != CCS_QUERY
+	} else if (
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+		   type != CCS_QUERY
+#else
+		   1
+#endif
 #ifdef CONFIG_TOMOYO_AUDIT
 		   && type != CCS_GRANTLOG && type != CCS_REJECTLOG
 #endif
@@ -3324,6 +3359,7 @@
 	case TYPE_DOUBLE_PATH_ACL:
 		len = sizeof(struct ccs_double_path_acl_record);
 		break;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	case TYPE_ARGV0_ACL:
 		len = sizeof(struct ccs_argv0_acl_record);
 		break;
@@ -3343,18 +3379,22 @@
 	case TYPE_DENIED_EXECUTE_HANDLER:
 		len = sizeof(struct ccs_execute_handler_record);
 		break;
+#endif
 	default:
 		return NULL;
 	}
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	/*
 	 * If the ACL doesn't have condition part, reduce memory usage
 	 * by eliminating sizeof(struct ccs_condition_list *).
 	 */
 	if (!condition)
 		len -= sizeof(ptr->access_me_via_ccs_get_condition_part);
+#endif
 	ptr = ccs_alloc_element(len);
 	if (!ptr)
 		return NULL;
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (condition) {
 		ptr->access_me_via_ccs_get_condition_part = condition;
 		ptr->type = acl_type | ACL_WITH_CONDITION;
@@ -3367,6 +3407,7 @@
 	 */
 	ptr = (void *) (((u8 *) ptr)
 			- sizeof(ptr->access_me_via_ccs_get_condition_part));
+#endif
 	ptr->type = acl_type;
 	return ptr;
 }
Index: trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(working copy)
@@ -207,7 +207,9 @@
 		ccs_dir_inode_operations.setattr = proc_notify_change;
 	ccs_dir->proc_iops = &ccs_dir_inode_operations;
 #endif
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ccs_create_entry("query",            0600, ccs_dir, CCS_QUERY);
+#endif
 #ifdef CONFIG_SAKURA
 	ccs_create_entry("system_policy",    0600, ccs_dir, CCS_SYSTEMPOLICY);
 #endif
@@ -226,10 +228,14 @@
 	ccs_create_entry("meminfo",          0600, ccs_dir, CCS_MEMINFO);
 	ccs_create_entry("profile",          0600, ccs_dir, CCS_PROFILE);
 	ccs_create_entry("manager",          0600, ccs_dir, CCS_MANAGER);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ccs_create_entry(".updates_counter", 0400, ccs_dir, CCS_UPDATESCOUNTER);
+#endif
 	ccs_create_entry("version",          0400, ccs_dir, CCS_VERSION);
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	ccs_create_entry(".execute_handler", 0666, ccs_dir,
 			 CCS_EXECUTE_HANDLER);
+#endif
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c	(working copy)
@@ -17,6 +17,8 @@
 #include <linux/realpath.h>
 #include <linux/version.h>
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /* To support PID namespace. */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 #define find_task_by_pid find_task_by_vpid
@@ -227,3 +229,5 @@
 					     condition, is_delete);
 	return -EINVAL;
 }
+
+#endif
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_file.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(working copy)
@@ -830,11 +830,15 @@
 		       "for %s\n", ccs_get_msg(is_enforce), msg, operation,
 		       filename->name, ccs_get_last_name(r->domain));
 	if (is_enforce) {
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 		int err = ccs_check_supervisor(r, "allow_%s %s\n",
 					       msg, filename->name);
 		if (err == 1 && !r->ee)
 			goto retry;
 		return err;
+#else
+		return -EPERM;
+#endif
 	}
 	if (r->mode == 1 && ccs_domain_quota_ok(r->domain)) {
 		/* Don't use patterns for execute permission. */
@@ -1285,12 +1289,14 @@
 		printk(KERN_WARNING "TOMOYO-%s: Access '%s %s' denied for %s\n",
 		       ccs_get_msg(is_enforce), msg, filename->name,
 		       ccs_get_last_name(r->domain));
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (is_enforce) {
 		error = ccs_check_supervisor(r, "allow_%s %s\n",
 					     msg, filename->name);
 		if (error == 1)
 			goto retry;
 	}
+#endif
 	if (r->mode == 1 && ccs_domain_quota_ok(r->domain))
 		ccs_update_single_path_acl(operation,
 					   ccs_get_file_pattern(filename),
@@ -1566,12 +1572,14 @@
 		       "denied for %s\n", ccs_get_msg(is_enforce),
 		       msg, buf1->name, buf2->name,
 		       ccs_get_last_name(r.domain));
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
 	if (is_enforce) {
 		error = ccs_check_supervisor(&r, "allow_%s %s %s\n",
 					     msg, buf1->name, buf2->name);
 		if (error == 1)
 			goto retry;
 	}
+#endif
 	if (r.mode == 1 && ccs_domain_quota_ok(r.domain))
 		ccs_update_double_path_acl(operation,
 					   ccs_get_file_pattern(buf1),
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c	(working copy)
@@ -16,6 +16,8 @@
 #include <linux/tomoyo.h>
 #include <linux/realpath.h>
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /**
  * ccs_cap2name - Convert capability operation to capability message.
  *
@@ -222,3 +224,5 @@
 	}
 	return -EINVAL;
 }
+
+#endif
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(working copy)
@@ -19,6 +19,8 @@
 #include <linux/tomoyo.h>
 #include <linux/highmem.h>
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /* Structure for argv[]. */
 struct ccs_argv_entry {
 	unsigned int index;
@@ -1545,3 +1547,5 @@
 	}
 	return ccs_cond;
 }
+
+#endif
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c	(revision 2252)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c	(working copy)
@@ -16,6 +16,8 @@
 #include <linux/tomoyo.h>
 #include <linux/realpath.h>
 
+#if !defined(CONFIG_TOMOYO_2_2_0_ONLY)
+
 /**
  * ccs_audit_argv0_log - Audit argv[0] log.
  *
@@ -197,3 +199,5 @@
 	return ccs_update_argv0_entry(data, argv0, domain, condition,
 				      is_delete);
 }
+
+#endif
