Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(revision 2283)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(working copy)
@@ -114,6 +114,26 @@
 int ccs_may_delete(struct inode *dir, struct dentry *dentry, int is_dir);
 #endif
 
+int ccs_check_mknod_permission(struct inode *dir, struct dentry *dentry,
+			       struct vfsmount *mnt, int mode, unsigned dev);
+int ccs_check_mkdir_permission(struct inode *dir, struct dentry *dentry,
+			       struct vfsmount *mnt, int mode);
+int ccs_check_rmdir_permission(struct inode *dir, struct dentry *dentry,
+			       struct vfsmount *mnt);
+int ccs_check_unlink_permission(struct inode *dir, struct dentry *dentry,
+				struct vfsmount *mnt);
+int ccs_check_symlink_permission(struct inode *dir, struct dentry *dentry,
+				 struct vfsmount *mnt, char *from);
+int ccs_check_truncate_permission(struct dentry *dentry, struct vfsmount *mnt,
+				  loff_t length, unsigned int time_attrs);
+int ccs_check_rename_permission(struct inode *old_dir,
+				struct dentry *old_dentry,
+				struct inode *new_dir,
+				struct dentry *new_dentry,
+				struct vfsmount *mnt);
+int ccs_check_link_permission(struct dentry *old_dentry, struct inode *new_dir,
+			      struct dentry *new_dentry, struct vfsmount *mnt);
+
 #else
 
 static inline int ccs_check_file_perm(const char *filename, const u8 perm,
@@ -217,6 +237,68 @@
 	return 0;
 }
 
+static inline int ccs_check_mknod_permission(struct inode *dir,
+					     struct dentry *dentry,
+					     struct vfsmount *mnt, int mode,
+					     unsigned dev)
+{
+	return 0;
+}
+
+static inline int ccs_check_mkdir_permission(struct inode *dir,
+					     struct dentry *dentry,
+					     struct vfsmount *mnt, int mode)
+{
+	return 0;
+}
+
+static inline int ccs_check_rmdir_permission(struct inode *dir,
+					     struct dentry *dentry,
+					     struct vfsmount *mnt)
+{
+	return 0;
+}
+
+static inline int ccs_check_unlink_permission(struct inode *dir,
+					      struct dentry *dentry,
+					      struct vfsmount *mnt)
+{
+	return 0;
+}
+
+static inline int ccs_check_symlink_permission(struct inode *dir,
+					       struct dentry *dentry,
+					       struct vfsmount *mnt,
+					       char *from)
+{
+	return 0;
+}
+
+static inline int ccs_check_truncate_permission(struct dentry *dentry,
+						struct vfsmount *mnt,
+						loff_t length,
+						unsigned int time_attrs)
+{
+	return 0;
+}
+
+static inline int ccs_check_rename_permission(struct inode *old_dir,
+					      struct dentry *old_dentry,
+					      struct inode *new_dir,
+					      struct dentry *new_dentry,
+					      struct vfsmount *mnt)
+{
+	return 0;
+}
+
+static inline int ccs_check_link_permission(struct dentry *old_dentry,
+					    struct inode *new_dir,
+					    struct dentry *new_dentry,
+					    struct vfsmount *mnt)
+{
+	return 0;
+}
+
 #endif
 
 int ccs_start_execve(struct linux_binprm *bprm);
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.4.37.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.4.37.diff	(revision 2283)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.4.37.diff	(working copy)
@@ -2,7 +2,7 @@
 
 Source code for this patch is http://www.kernel.org/pub/linux/kernel/v2.4/linux-2.4.37.tar.bz2
 ---
- Documentation/Configure.help |   86 +++++++++++++++++++++++++++++
+ Documentation/Configure.help |   86 ++++++++++++++++++++++++++++++++
  arch/alpha/kernel/ptrace.c   |    7 ++
  arch/arm/kernel/ptrace.c     |    7 ++
  arch/cris/kernel/ptrace.c    |    7 ++
@@ -11,7 +11,7 @@
  arch/ia64/kernel/ptrace.c    |    7 ++
  arch/m68k/kernel/ptrace.c    |    7 ++
  arch/mips/kernel/ptrace.c    |    7 ++
- arch/mips64/kernel/ptrace.c  |   11 +++
+ arch/mips64/kernel/ptrace.c  |   11 ++++
  arch/parisc/kernel/ptrace.c  |    7 ++
  arch/ppc/kernel/ptrace.c     |    7 ++
  arch/ppc64/kernel/ptrace.c   |    7 ++
@@ -27,12 +27,12 @@
  fs/Config.in                 |    3 +
  fs/Makefile                  |    2 
  fs/attr.c                    |   10 +++
- fs/exec.c                    |   21 ++++++-
- fs/fcntl.c                   |    8 ++
- fs/ioctl.c                   |   16 +++++
- fs/namei.c                   |  127 +++++++++++++++++++++++++++++++++++++++++++
- fs/namespace.c               |   58 +++++++++++++++++++
- fs/open.c                    |   29 +++++++++
+ fs/exec.c                    |   21 +++++++
+ fs/fcntl.c                   |    8 +++
+ fs/ioctl.c                   |   16 ++++++
+ fs/namei.c                   |   71 +++++++++++++++++++++++++++
+ fs/namespace.c               |   58 +++++++++++++++++++++-
+ fs/open.c                    |   30 +++++++++++
  fs/proc/Makefile             |    4 +
  fs/proc/proc_misc.c          |    5 +
  include/linux/sched.h        |   12 ++++
@@ -40,17 +40,17 @@
  kernel/module.c              |   15 +++++
  kernel/sched.c               |    7 ++
  kernel/signal.c              |   15 +++++
- kernel/sys.c                 |   19 ++++++
- kernel/sysctl.c              |  113 +++++++++++++++++++++++++++++++++++++-
+ kernel/sys.c                 |   19 +++++++
+ kernel/sysctl.c              |  113 ++++++++++++++++++++++++++++++++++++++++++-
  kernel/time.c                |   15 +++++
  net/core/datagram.c          |   10 +++
- net/ipv4/tcp_ipv4.c          |   11 +++
- net/ipv4/udp.c               |   11 +++
+ net/ipv4/tcp_ipv4.c          |   11 ++++
+ net/ipv4/udp.c               |   11 ++++
  net/ipv6/tcp_ipv6.c          |    7 ++
- net/ipv6/udp.c               |   11 +++
- net/socket.c                 |   40 ++++++++++++-
- net/unix/af_unix.c           |   15 +++++
- 48 files changed, 824 insertions(+), 6 deletions(-)
+ net/ipv6/udp.c               |   11 ++++
+ net/socket.c                 |   40 ++++++++++++++-
+ net/unix/af_unix.c           |    8 +++
+ 48 files changed, 762 insertions(+), 6 deletions(-)
 
 --- linux-2.4.37.orig/Documentation/Configure.help
 +++ linux-2.4.37/Documentation/Configure.help
@@ -833,11 +833,11 @@
  	/* Negative dentry, just create the file */
  	if (!dentry->d_inode) {
 +		/***** TOMOYO Linux start. *****/
-+		error = pre_vfs_create(dir->d_inode, dentry);
++		error = ccs_check_mknod_permission(dir->d_inode, dentry,
++						   nd->mnt,
++						   mode & ~current->fs->umask,
++						   0);
 +		if (!error)
-+			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-+						     nd->mnt);
-+		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_create(dir->d_inode, dentry,
  				   mode & ~current->fs->umask);
@@ -856,198 +856,124 @@
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1292,6 +1314,17 @@ asmlinkage long sys_mknod(const char * f
+@@ -1292,6 +1314,7 @@ asmlinkage long sys_mknod(const char * f
  
  	if (S_ISDIR(mode))
  		return -EPERM;
-+	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-+		return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-+		return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-+		return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-+		return -EPERM;
-+	/***** TOMOYO Linux end. *****/
 +
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1306,9 +1339,33 @@ asmlinkage long sys_mknod(const char * f
+@@ -1304,6 +1327,12 @@ asmlinkage long sys_mknod(const char * f
+ 
+ 	mode &= ~current->fs->umask;
  	if (!IS_ERR(dentry)) {
++		/***** TOMOYO Linux start. *****/
++		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
++						   nd.mnt, mode, dev);
++		if (error)
++			goto out_dput;
++		/***** TOMOYO Linux end. *****/
  		switch (mode & S_IFMT) {
  		case 0: case S_IFREG:
-+			/***** TOMOYO Linux start. *****/
-+			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-+			if (error)
-+				break;
-+			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-+						     nd.mnt);
-+			if (error)
-+				break;
-+			/***** TOMOYO Linux end. *****/
  			error = vfs_create(nd.dentry->d_inode,dentry,mode);
- 			break;
- 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-+			/***** TOMOYO Linux start. *****/
-+			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-+			if (error)
-+				break;
-+			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-+						     TYPE_MKCHAR_ACL :
-+						     S_ISBLK(mode) ?
-+						     TYPE_MKBLOCK_ACL :
-+						     S_ISFIFO(mode) ?
-+						     TYPE_MKFIFO_ACL :
-+						     TYPE_MKSOCK_ACL,
-+						     dentry, nd.mnt);
-+			if (error)
-+				break;
-+			/***** TOMOYO Linux end. *****/
- 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
- 			break;
- 		case S_IFDIR:
-@@ -1370,6 +1427,13 @@ asmlinkage long sys_mkdir(const char * p
+@@ -1317,6 +1346,9 @@ asmlinkage long sys_mknod(const char * f
+ 		default:
+ 			error = -EINVAL;
+ 		}
++		/***** TOMOYO Linux start. *****/
++out_dput:
++		/***** TOMOYO Linux end. *****/
+ 		dput(dentry);
+ 	}
+ 	up(&nd.dentry->d_inode->i_sem);
+@@ -1370,6 +1402,12 @@ asmlinkage long sys_mkdir(const char * p
  		dentry = lookup_create(&nd, 1);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
++							   dentry, nd.mnt,
++							   mode);
 +			if (!error)
-+				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-+							     dentry, nd.mnt);
-+			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry,
  					  mode & ~current->fs->umask);
  			dput(dentry);
-@@ -1479,6 +1543,13 @@ asmlinkage long sys_rmdir(const char * p
+@@ -1479,6 +1517,11 @@ asmlinkage long sys_rmdir(const char * p
  	dentry = lookup_hash(&nd.last, nd.dentry);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
++						   nd.mnt);
 +		if (!error)
-+			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-+						     nd.mnt);
-+		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -1530,6 +1601,10 @@ asmlinkage long sys_unlink(const char * 
- 	char * name;
- 	struct dentry *dentry;
- 	struct nameidata nd;
-+	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(CCS_SYS_UNLINK))
-+		return -EPERM;
-+	/***** TOMOYO Linux end. *****/
- 
- 	name = getname(pathname);
- 	if(IS_ERR(name))
-@@ -1548,6 +1623,14 @@ asmlinkage long sys_unlink(const char * 
+@@ -1548,6 +1591,12 @@ asmlinkage long sys_unlink(const char * 
  		/* Why not before? Because we want correct error value */
  		if (nd.last.name[nd.last.len])
  			goto slashes;
 +		/***** TOMOYO Linux start. *****/
-+		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
++						    nd.mnt);
 +		if (error)
 +			goto exit2;
-+		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-+		if (error)
-+			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -1596,6 +1679,10 @@ asmlinkage long sys_symlink(const char *
- 	int error = 0;
- 	char * from;
- 	char * to;
-+	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(CCS_SYS_SYMLINK))
-+		return -EPERM;
-+	/***** TOMOYO Linux end. *****/
- 
- 	from = getname(oldname);
- 	if(IS_ERR(from))
-@@ -1612,6 +1699,13 @@ asmlinkage long sys_symlink(const char *
+@@ -1612,6 +1661,12 @@ asmlinkage long sys_symlink(const char *
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			error = ccs_check_symlink_permission(nd.dentry->d_inode,
++							     dentry, nd.mnt,
++							     from);
 +			if (!error)
-+				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-+							     dentry, nd.mnt);
-+			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
  			dput(dentry);
  		}
-@@ -1679,6 +1773,10 @@ asmlinkage long sys_link(const char * ol
- {
- 	int error;
- 	char * to;
-+	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(CCS_SYS_LINK))
-+		return -EPERM;
-+	/***** TOMOYO Linux end. *****/
- 
- 	to = getname(newname);
- 	error = PTR_ERR(to);
-@@ -1698,6 +1796,17 @@ asmlinkage long sys_link(const char * ol
+@@ -1698,6 +1753,12 @@ asmlinkage long sys_link(const char * ol
  		new_dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(new_dentry);
  		if (!IS_ERR(new_dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-+					     new_dentry);
++			error = ccs_check_link_permission(old_nd.dentry,
++							  nd.dentry->d_inode,
++							  new_dentry, nd.mnt);
 +			if (!error)
-+				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-+							     old_nd.dentry,
-+							     old_nd.mnt,
-+							     new_dentry,
-+							     nd.mnt);
-+			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  			dput(new_dentry);
  		}
-@@ -1928,6 +2037,20 @@ static inline int do_rename(const char *
+@@ -1928,12 +1989,22 @@ static inline int do_rename(const char *
  	error = PTR_ERR(new_dentry);
  	if (IS_ERR(new_dentry))
  		goto exit4;
 +	/***** TOMOYO Linux start. *****/
-+	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-+			       new_dir->d_inode, new_dentry);
-+	if (error) {
-+		dput(new_dentry);
-+		goto exit4;
-+	}
-+	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-+				     new_dentry, newnd.mnt);
-+	if (error) {
-+		dput(new_dentry);
-+		goto exit4;
-+	}
++	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
++					    new_dir->d_inode, new_dentry,
++					    newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	error = vfs_rename(old_dir->d_inode, old_dentry,
-@@ -1952,6 +2075,10 @@ asmlinkage long sys_rename(const char * 
- 	int error;
- 	char * from;
- 	char * to;
+ 				   new_dir->d_inode, new_dentry);
+ 	unlock_kernel();
+ 
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(CCS_SYS_RENAME))
-+		return -EPERM;
++exit5:
 +	/***** TOMOYO Linux end. *****/
- 
- 	from = getname(oldname);
- 	if(IS_ERR(from))
+ 	dput(new_dentry);
+ exit4:
+ 	dput(old_dentry);
 --- linux-2.4.37.orig/fs/namespace.c
 +++ linux-2.4.37/fs/namespace.c
 @@ -21,6 +21,13 @@
@@ -1199,26 +1125,27 @@
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 +	if (!error)
 +	/***** TOMOYO Linux end. *****/
 +
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -217,6 +229,11 @@ static inline long do_sys_ftruncate(unsi
+@@ -217,6 +229,12 @@ static inline long do_sys_ftruncate(unsi
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
++					      0);
 +	if (error)
 +		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length);
-@@ -466,6 +483,14 @@ asmlinkage long sys_chroot(const char * 
+@@ -466,6 +484,14 @@ asmlinkage long sys_chroot(const char * 
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
@@ -1233,7 +1160,7 @@
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -897,6 +922,10 @@ out_unlock:
+@@ -897,6 +923,10 @@ out_unlock:
   */
  asmlinkage long sys_vhangup(void)
  {
@@ -1927,28 +1854,14 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -645,6 +648,11 @@ static int unix_bind(struct socket *sock
- 		err = unix_autobind(sock);
- 		goto out;
- 	}
-+	/***** TOMOYO Linux start. *****/
-+	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-+		goto out;
-+	/***** TOMOYO Linux end. *****/
- 
- 	err = unix_mkname(sunaddr, addr_len, &hash);
- 	if (err < 0)
-@@ -709,6 +717,13 @@ static int unix_bind(struct socket *sock
+@@ -709,6 +712,11 @@ static int unix_bind(struct socket *sock
  		 * All right, let's create it.
  		 */
  		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
++		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
++						 nd.mnt, mode, 0);
 +		if (!err)
-+			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-+						   nd.mnt);
-+		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.29.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.29.diff	(revision 2283)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.29.diff	(working copy)
@@ -4,37 +4,37 @@
 ---
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   10 ++
- fs/compat.c                     |    5 +
- fs/compat_ioctl.c               |   13 +++
- fs/exec.c                       |   20 +++++
- fs/fcntl.c                      |    9 ++
- fs/ioctl.c                      |   11 +++
- fs/namei.c                      |  139 ++++++++++++++++++++++++++++++++++++++++
- fs/namespace.c                  |   49 ++++++++++++++
- fs/open.c                       |   28 ++++++++
- fs/proc/Makefile                |    3 
- fs/proc/version.c               |   11 +++
+ fs/attr.c                       |   10 ++++
+ fs/compat.c                     |    5 +-
+ fs/compat_ioctl.c               |   13 +++++
+ fs/exec.c                       |   20 ++++++++
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |   11 ++++
+ fs/namei.c                      |   59 ++++++++++++++++++++++++
+ fs/namespace.c                  |   49 ++++++++++++++++++++
+ fs/open.c                       |   29 ++++++++++++
+ fs/proc/Makefile                |    3 +
+ fs/proc/version.c               |   11 ++++
  include/linux/init_task.h       |    4 +
- include/linux/sched.h           |    8 ++
+ include/linux/sched.h           |    8 +++
  kernel/compat.c                 |    7 ++
  kernel/kexec.c                  |    7 ++
- kernel/kmod.c                   |    5 +
- kernel/module.c                 |   11 +++
- kernel/ptrace.c                 |   11 +++
+ kernel/kmod.c                   |    5 ++
+ kernel/module.c                 |   11 ++++
+ kernel/ptrace.c                 |   11 ++++
  kernel/sched.c                  |    7 ++
- kernel/signal.c                 |   21 ++++++
- kernel/sys.c                    |   21 ++++++
- kernel/sysctl.c                 |   95 +++++++++++++++++++++++++++
- kernel/time.c                   |   11 +++
- kernel/time/ntp.c               |   11 +++
- net/core/datagram.c             |   11 +++
+ kernel/signal.c                 |   21 ++++++++
+ kernel/sys.c                    |   21 ++++++++
+ kernel/sysctl.c                 |   95 ++++++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   11 ++++
+ kernel/time/ntp.c               |   11 ++++
+ net/core/datagram.c             |   11 ++++
  net/ipv4/inet_connection_sock.c |    7 ++
  net/ipv4/inet_hashtables.c      |    7 ++
- net/ipv4/udp.c                  |    8 ++
- net/socket.c                    |   41 +++++++++++
- net/unix/af_unix.c              |   16 ++++
- 32 files changed, 608 insertions(+), 3 deletions(-)
+ net/ipv4/udp.c                  |    8 ++-
+ net/socket.c                    |   41 +++++++++++++++++
+ net/unix/af_unix.c              |    9 +++
+ 32 files changed, 522 insertions(+), 3 deletions(-)
 
 --- linux-2.6.29-rc8.orig/fs/Kconfig
 +++ linux-2.6.29-rc8/fs/Kconfig
@@ -272,41 +272,19 @@
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1560,6 +1571,18 @@ int may_open(struct path *path, int acc_
- 	return 0;
- }
- 
-+/***** TOMOYO Linux start. *****/
-+static int pre_vfs_create(struct inode *dir, struct dentry *dentry)
-+{
-+	int error = may_create(dir, dentry);
-+	if (error)
-+		return error;
-+	if (!dir->i_op || !dir->i_op->create)
-+		return -EACCES;	/* shouldn't it be ENOSYS? */
-+	return 0;
-+}
-+/***** TOMOYO Linux end. *****/
-+
- /*
-  * Be careful about ever adding any more callers of this
-  * function.  Its flags must be in the namei format, not
-@@ -1574,6 +1597,14 @@ static int __open_namei_create(struct na
+@@ -1574,6 +1585,11 @@ static int __open_namei_create(struct na
  	if (!IS_POSIXACL(dir->d_inode))
  		mode &= ~current->fs->umask;
  	error = security_path_mknod(&nd->path, path->dentry, mode, 0);
 +	/***** TOMOYO Linux start. *****/
 +	if (!error)
-+		error = pre_vfs_create(dir->d_inode, path->dentry);
-+	if (!error)
-+		error = ccs_check_1path_perm(TYPE_CREATE_ACL,
-+					     path->dentry,
-+					     nd->path.mnt);
++		error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
++						   nd->path.mnt, mode, 0);
 +	/***** TOMOYO Linux end. *****/
  	if (error)
  		goto out_unlock;
  	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
-@@ -1587,6 +1618,9 @@ out_unlock:
+@@ -1587,6 +1603,9 @@ out_unlock:
  	return may_open(&nd->path, 0, flag & ~O_TRUNC);
  }
  
@@ -316,198 +294,91 @@
  /*
   * Note that while the flag value (low two bits) for sys_open means:
   *	00 - read-only
-@@ -1947,6 +1981,16 @@ int vfs_mknod(struct inode *dir, struct 
- 
- static int may_mknod(mode_t mode)
- {
+@@ -1991,6 +2010,12 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const
+ 	if (error)
+ 		goto out_dput;
+ 	error = security_path_mknod(&nd.path, dentry, mode, dev);
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-+		return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-+		return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-+		return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-+		return -EPERM;
++	if (!error)
++		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
++						   dentry, nd.path.mnt, mode,
++						   dev);
 +	/***** TOMOYO Linux end. *****/
- 	switch (mode & S_IFMT) {
- 	case S_IFREG:
- 	case S_IFCHR:
-@@ -1995,13 +2039,46 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const
+ 	if (error)
  		goto out_drop_write;
  	switch (mode & S_IFMT) {
- 		case 0: case S_IFREG:
-+			/***** TOMOYO Linux start. *****/
-+			error = pre_vfs_create(nd.path.dentry->d_inode, dentry);
-+			if (error)
-+				break;
-+			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-+						     nd.path.mnt);
-+			if (error)
-+				break;
-+			/***** TOMOYO Linux end. *****/
- 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
- 			break;
- 		case S_IFCHR: case S_IFBLK:
-+			/***** TOMOYO Linux start. *****/
-+			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-+					      mode);
-+			if (error)
-+				break;
-+			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-+						     TYPE_MKCHAR_ACL :
-+						     TYPE_MKBLOCK_ACL,
-+						     dentry, nd.path.mnt);
-+			if (error)
-+				break;
-+			/***** TOMOYO Linux end. *****/
- 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,
- 					new_decode_dev(dev));
- 			break;
- 		case S_IFIFO: case S_IFSOCK:
-+			/***** TOMOYO Linux start. *****/
-+			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-+					      mode);
-+			if (error)
-+				break;
-+			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-+						     TYPE_MKFIFO_ACL :
-+						     TYPE_MKSOCK_ACL,
-+						     dentry, nd.path.mnt);
-+			if (error)
-+				break;
-+			/***** TOMOYO Linux end. *****/
- 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);
- 			break;
- 	}
-@@ -2066,6 +2143,13 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const
+@@ -2066,6 +2091,11 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const
  	if (error)
  		goto out_dput;
  	error = security_path_mkdir(&nd.path, dentry, mode);
 +	/***** TOMOYO Linux start. *****/
 +	if (!error)
-+		error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-+	if (!error)
-+		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-+					     nd.path.mnt);
++		error = ccs_check_mkdir_permission(nd.path.dentry->d_inode,
++						   dentry, nd.path.mnt, mode);
 +	/***** TOMOYO Linux end. *****/
  	if (error)
  		goto out_drop_write;
  	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);
-@@ -2180,6 +2264,13 @@ static long do_rmdir(int dfd, const char
+@@ -2180,6 +2210,11 @@ static long do_rmdir(int dfd, const char
  	if (error)
  		goto exit3;
  	error = security_path_rmdir(&nd.path, dentry);
 +	/***** TOMOYO Linux start. *****/
 +	if (!error)
-+		error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-+	if (!error)
-+		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-+					     nd.path.mnt);
++		error = ccs_check_rmdir_permission(nd.path.dentry->d_inode,
++						   dentry, nd.path.mnt);
 +	/***** TOMOYO Linux end. *****/
  	if (error)
  		goto exit4;
  	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
-@@ -2244,6 +2335,10 @@ static long do_unlinkat(int dfd, const c
- 	struct dentry *dentry;
- 	struct nameidata nd;
- 	struct inode *inode = NULL;
-+	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(CCS_SYS_UNLINK))
-+		return -EPERM;
-+	/***** TOMOYO Linux end. *****/
- 
- 	error = user_path_parent(dfd, pathname, &nd, &name);
- 	if (error)
-@@ -2269,6 +2364,13 @@ static long do_unlinkat(int dfd, const c
+@@ -2269,6 +2304,12 @@ static long do_unlinkat(int dfd, const c
  		if (error)
  			goto exit2;
  		error = security_path_unlink(&nd.path, dentry);
 +		/***** TOMOYO Linux start. *****/
 +		if (!error)
-+			error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-+		if (!error)
-+			error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-+						     nd.path.mnt);
++			error = ccs_check_unlink_permission(nd.path.dentry
++							    ->d_inode, dentry,
++							    nd.path.mnt);
 +		/***** TOMOYO Linux end. *****/
  		if (error)
  			goto exit3;
  		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
-@@ -2336,6 +2438,10 @@ SYSCALL_DEFINE3(symlinkat, const char __
- 	char *to;
- 	struct dentry *dentry;
- 	struct nameidata nd;
-+	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(CCS_SYS_SYMLINK))
-+		return -EPERM;
-+	/***** TOMOYO Linux end. *****/
- 
- 	from = getname(oldname);
- 	if (IS_ERR(from))
-@@ -2354,6 +2460,13 @@ SYSCALL_DEFINE3(symlinkat, const char __
+@@ -2354,6 +2395,11 @@ SYSCALL_DEFINE3(symlinkat, const char __
  	if (error)
  		goto out_dput;
  	error = security_path_symlink(&nd.path, dentry, from);
 +	/***** TOMOYO Linux start. *****/
 +	if (!error)
-+		error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-+	if (!error)
-+		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-+					     nd.path.mnt);
++		error = ccs_check_symlink_permission(nd.path.dentry->d_inode,
++						     dentry, nd.path.mnt, from);
 +	/***** TOMOYO Linux end. *****/
  	if (error)
  		goto out_drop_write;
  	error = vfs_symlink(nd.path.dentry->d_inode, dentry, from);
-@@ -2433,6 +2546,10 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
- 
- 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
- 		return -EINVAL;
-+	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(CCS_SYS_LINK))
-+		return -EPERM;
-+	/***** TOMOYO Linux end. *****/
- 
- 	error = user_path_at(olddfd, oldname,
- 			     flags & AT_SYMLINK_FOLLOW ? LOOKUP_FOLLOW : 0,
-@@ -2454,6 +2571,15 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
+@@ -2454,6 +2500,12 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
  	if (error)
  		goto out_dput;
  	error = security_path_link(old_path.dentry, &nd.path, new_dentry);
 +	/***** TOMOYO Linux start. *****/
 +	if (!error)
-+		error = pre_vfs_link(old_path.dentry, nd.path.dentry->d_inode,
-+				     new_dentry);
-+	if (!error)
-+		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_path.dentry,
-+					     old_path.mnt, new_dentry,
-+					     nd.path.mnt);
++		error = ccs_check_link_permission(old_path.dentry,
++						  nd.path.dentry->d_inode,
++						  new_dentry, nd.path.mnt);
 +	/***** TOMOYO Linux end. *****/
  	if (error)
  		goto out_drop_write;
  	error = vfs_link(old_path.dentry, nd.path.dentry->d_inode, new_dentry);
-@@ -2633,6 +2759,10 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
- 	char *from;
- 	char *to;
- 	int error;
-+	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(CCS_SYS_RENAME))
-+		return -EPERM;
-+	/***** TOMOYO Linux end. *****/
- 
- 	error = user_path_parent(olddfd, oldname, &oldnd, &from);
- 	if (error)
-@@ -2695,6 +2825,15 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
+@@ -2695,6 +2747,13 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
  		goto exit5;
  	error = security_path_rename(&oldnd.path, old_dentry,
  				     &newnd.path, new_dentry);
 +	/***** TOMOYO Linux start. *****/
 +	if (!error)
-+		error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-+				       new_dir->d_inode, new_dentry);
-+	if (!error)
-+		error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-+					     oldnd.path.mnt, new_dentry,
-+					     newnd.path.mnt);
++		error = ccs_check_rename_permission(old_dir->d_inode,
++						    old_dentry,
++						    new_dir->d_inode,
++						    new_dentry, newnd.path.mnt);
 +	/***** TOMOYO Linux end. *****/
  	if (error)
  		goto exit6;
@@ -647,25 +518,26 @@
  		error = security_path_truncate(&path, length, 0);
 +	/***** TOMOYO Linux start. *****/
 +	if (!error)
-+		error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, path.dentry,
-+					     path.mnt);
++		error = ccs_check_truncate_permission(path.dentry, path.mnt,
++						      length, 0);
 +	/***** TOMOYO Linux end. *****/
  	if (!error) {
  		DQUOT_INIT(inode);
  		error = do_truncate(path.dentry, length, 0, NULL);
-@@ -331,6 +342,11 @@ static long do_sys_ftruncate(unsigned in
+@@ -331,6 +342,12 @@ static long do_sys_ftruncate(unsigned in
  	if (!error)
  		error = security_path_truncate(&file->f_path, length,
  					       ATTR_MTIME|ATTR_CTIME);
 +	/***** TOMOYO Linux start. *****/
 +	if (!error)
-+		error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry,
-+					     file->f_vfsmnt);
++		error = ccs_check_truncate_permission(dentry, file->f_vfsmnt,
++						      length,
++						      ATTR_MTIME|ATTR_CTIME);
 +	/***** TOMOYO Linux end. *****/
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, file);
  out_putf:
-@@ -585,6 +601,14 @@ SYSCALL_DEFINE1(chroot, const char __use
+@@ -585,6 +602,14 @@ SYSCALL_DEFINE1(chroot, const char __use
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
@@ -680,7 +552,7 @@
  
  	set_fs_root(current->fs, &path);
  	error = 0;
-@@ -1156,6 +1180,10 @@ EXPORT_SYMBOL(sys_close);
+@@ -1156,6 +1181,10 @@ EXPORT_SYMBOL(sys_close);
   */
  SYSCALL_DEFINE0(vhangup)
  {
@@ -1398,29 +1270,15 @@
  
  static struct hlist_head unix_socket_table[UNIX_HASH_SIZE + 1];
  static DEFINE_SPINLOCK(unix_table_lock);
-@@ -790,6 +793,11 @@ static int unix_bind(struct socket *sock
- 		err = unix_autobind(sock);
- 		goto out;
- 	}
-+	/***** TOMOYO Linux start. *****/
-+	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-+		goto out;
-+	/***** TOMOYO Linux end. *****/
- 
- 	err = unix_mkname(sunaddr, addr_len, &hash);
- 	if (err < 0)
-@@ -837,6 +845,14 @@ static int unix_bind(struct socket *sock
+@@ -837,6 +840,12 @@ static int unix_bind(struct socket *sock
  		if (err)
  			goto out_mknod_dput;
  		err = security_path_mknod(&nd.path, dentry, mode, 0);
 +		/***** TOMOYO Linux start. *****/
 +		if (!err)
-+			err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-+					    mode);
-+		if (!err)
-+			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-+						   nd.path.mnt);
++			err = ccs_check_mknod_permission(nd.path.dentry
++							 ->d_inode, dentry,
++							 nd.path.mnt, mode, 0);
 +		/***** TOMOYO Linux end. *****/
  		if (err)
  			goto out_mknod_drop_write;
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_file.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(revision 2283)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(working copy)
@@ -2084,6 +2084,29 @@
 #define HAVE_IS_DIR_FOR_MAY_CREATE
 #endif
 
+/* Permission checks before security_inode_create() is called. */
+static int ccs_pre_vfs_create(struct inode *dir, struct dentry *dentry)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27)
+#ifdef HAVE_IS_DIR_FOR_MAY_CREATE
+	int error = ccs_may_create(dir, dentry, NULL, 0);
+#else
+	int error = ccs_may_create(dir, dentry, NULL);
+#endif
+#else
+#ifdef HAVE_IS_DIR_FOR_MAY_CREATE
+	int error = ccs_may_create(dir, dentry, 0);
+#else
+	int error = ccs_may_create(dir, dentry);
+#endif
+#endif
+        if (error)
+                return error;
+        if (!dir->i_op || !dir->i_op->create)
+                return -EACCES; /* shouldn't it be ENOSYS? */
+        return 0;
+}
+
 /*
  * Permission checks before security_inode_mknod() is called.
  *
@@ -2268,3 +2291,139 @@
 }
 
 #endif
+
+/*
+ * Permission checks before security_inode_mknod() is called.
+ *
+ * This function is exported because
+ * vfs_mknod() is called from net/unix/af_unix.c.
+ */
+int ccs_check_mknod_permission(struct inode *dir, struct dentry *dentry,
+			       struct vfsmount *mnt, int mode, unsigned dev)
+{
+	int error;
+	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
+		return -EPERM;
+	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
+		return -EPERM;
+	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
+		return -EPERM;
+	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
+		return -EPERM;
+	switch (mode & S_IFMT) {
+	case 0:
+	case S_IFREG:
+		error = ccs_pre_vfs_create(dir, dentry);
+		if (!error)
+			error = ccs_check_1path_perm(TYPE_CREATE_ACL,
+						     dentry, mnt);
+		return error;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	error = ccs_pre_vfs_mknod(dir, dentry);
+#else
+	error = ccs_pre_vfs_mknod(dir, dentry, mode);
+#endif
+	if (error)
+		return error;
+	switch (mode & S_IFMT) {
+	case S_IFCHR:
+                error = ccs_check_1path_perm(TYPE_MKCHAR_ACL, dentry, mnt);
+		break;
+	case S_IFBLK:
+                error = ccs_check_1path_perm(TYPE_MKBLOCK_ACL, dentry, mnt);
+		break;
+	case S_IFIFO:
+		error = ccs_check_1path_perm(TYPE_MKFIFO_ACL, dentry, mnt);
+		break;
+	case S_IFSOCK:
+		error = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, mnt);
+		break;
+	}
+	return error;
+}
+EXPORT_SYMBOL(ccs_check_mknod_permission);
+
+/* Permission checks before security_inode_mkdir() is called. */
+int ccs_check_mkdir_permission(struct inode *dir, struct dentry *dentry,
+			       struct vfsmount *mnt, int mode)
+{
+	int error = ccs_pre_vfs_mkdir(dir, dentry);
+        if (!error)
+                error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, mnt);
+	return error;
+}
+
+/* Permission checks before security_inode_rmdir() is called. */
+int ccs_check_rmdir_permission(struct inode *dir, struct dentry *dentry,
+			       struct vfsmount *mnt)
+{
+        int error = ccs_pre_vfs_rmdir(dir, dentry);
+        if (!error)
+                error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, mnt);
+	return error;
+}
+
+/* Permission checks before security_inode_unlink() is called. */
+int ccs_check_unlink_permission(struct inode *dir, struct dentry *dentry,
+				struct vfsmount *mnt)
+{
+	int error;
+	if (!ccs_capable(CCS_SYS_UNLINK))
+		return -EPERM;
+	error = ccs_pre_vfs_unlink(dir, dentry);
+	if (!error)
+		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, mnt);
+	return error;
+}
+
+/* Permission checks before security_inode_symlink() is called. */
+int ccs_check_symlink_permission(struct inode *dir, struct dentry *dentry,
+				 struct vfsmount *mnt, char *from)
+{
+	int error;
+	if (!ccs_capable(CCS_SYS_SYMLINK))
+		return -EPERM;
+	error = ccs_pre_vfs_symlink(dir, dentry);
+	if (!error)
+		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, mnt);
+	return error;
+}
+
+/* Permission checks before security_inode_setattr() is called. */
+int ccs_check_truncate_permission(struct dentry *dentry, struct vfsmount *mnt,
+				  loff_t length,unsigned int time_attrs)
+{
+	return ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, mnt);
+}
+
+/* Permission checks before security_inode_rename() is called. */
+int ccs_check_rename_permission(struct inode *old_dir,
+				struct dentry *old_dentry,
+				struct inode *new_dir,
+				struct dentry *new_dentry,
+				struct vfsmount *mnt)
+{
+	int error;
+	if (!ccs_capable(CCS_SYS_RENAME))
+		return -EPERM;
+	error = ccs_pre_vfs_rename(old_dir, old_dentry, new_dir, new_dentry);
+	if (!error)
+		error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
+					     mnt, new_dentry, mnt);
+	return error;
+}
+
+/* Permission checks before security_inode_link() is called. */
+int ccs_check_link_permission(struct dentry *old_dentry, struct inode *new_dir,
+			      struct dentry *new_dentry, struct vfsmount *mnt)
+{
+	int error;
+	if (!ccs_capable(CCS_SYS_LINK))
+		return -EPERM;
+	error = ccs_pre_vfs_link(old_dentry, new_dir, new_dentry);
+	if (!error)
+		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_dentry,
+					     mnt, new_dentry, mnt);
+	return error;
+}
