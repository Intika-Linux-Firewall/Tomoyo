Index: security/ccsecurity/file.c
===================================================================
--- security/ccsecurity/file.c	(revision 3744)
+++ security/ccsecurity/file.c	(working copy)
@@ -1420,8 +1420,7 @@
 	struct ccs_request_info r;
 	struct ccs_obj_info obj = {
 		.path1.dentry = dentry,
-		.path1.mnt = mnt,
-		.dev = dev
+		.path1.mnt = mnt
 	};
 	int error = 0;
 	struct ccs_path_info buf;
Index: security/ccsecurity/internal.h
===================================================================
--- security/ccsecurity/internal.h	(revision 3744)
+++ security/ccsecurity/internal.h	(working copy)
@@ -473,7 +473,6 @@
 	struct path path2;
 	struct ccs_mini_stat stat[CCS_MAX_STAT];
 	struct ccs_path_info *symlink_target;
-	unsigned int dev;
 };
 
 struct ccs_condition_element {
Index: security/ccsecurity/policy_io.c
===================================================================
--- security/ccsecurity/policy_io.c	(revision 3744)
+++ security/ccsecurity/policy_io.c	(working copy)
@@ -866,9 +866,8 @@
 }
 
 static int ccs_write_domain2(char *data, struct ccs_domain_info *domain,
-			     struct ccs_condition *cond, const bool is_delete)
+			     const bool is_delete)
 {
-	u8 i;
 	static const struct {
 		const char *keyword;
 		int (*write) (char *, struct ccs_domain_info *,
@@ -882,13 +881,25 @@
 	};
 	int (*write) (char *, struct ccs_domain_info *, struct ccs_condition *,
 		      const bool) = ccs_write_file;
+	int error;
+	u8 i;
+	struct ccs_condition *cond = NULL;
+	char *cp = ccs_find_condition_part(data);
+	if (cp) {
+		cond = ccs_get_condition(cp);
+		if (!cond)
+			return -EINVAL;
+	}
 	for (i = 0; i < 5; i++) {
 		if (!ccs_str_starts(&data, ccs_callback[i].keyword))
 			continue;
 		write = ccs_callback[i].write;
 		break;
 	}
-	return write(data, domain, cond, is_delete);
+	error = write(data, domain, cond, is_delete);
+	if (cond)
+		ccs_put_condition(cond);
+	return error;
 }
 
 /**
@@ -905,9 +916,6 @@
 	bool is_delete = false;
 	bool is_select = false;
 	unsigned int profile;
-	struct ccs_condition *cond = NULL;
-	char *cp;
-	int error;
 	if (ccs_str_starts(&data, CCS_KEYWORD_DELETE))
 		is_delete = true;
 	else if (ccs_str_starts(&data, CCS_KEYWORD_SELECT))
@@ -957,16 +965,7 @@
 		domain->domain_transition_failed = !is_delete;
 		return 0;
 	}
-	cp = ccs_find_condition_part(data);
-	if (cp) {
-		cond = ccs_get_condition(cp);
-		if (!cond)
-			return -EINVAL;
-	}
-	error = ccs_write_domain2(data, domain, cond, is_delete);
-	if (cond)
-		ccs_put_condition(cond);
-	return error;
+	return ccs_write_domain2(data, domain, is_delete);
 }
 
 /**
@@ -1851,21 +1850,7 @@
 		if (ccs_str_starts(&data, ccs_name[i]))
 			return ccs_write_group(data, is_delete, i);
 	}
-	{
-		int error;
-		struct ccs_condition *cond = NULL;
-		char *cp = ccs_find_condition_part(data);
-		if (cp) {
-			cond = ccs_get_condition(cp);
-			if (!cond)
-				return -EINVAL;
-		}
-		error = ccs_write_domain2(data, &ccs_global_domain, cond,
-					  is_delete);
-		if (cond)
-			ccs_put_condition(cond);
-		return error;
-	}
+	return ccs_write_domain2(data, &ccs_global_domain, is_delete);
 }
 
 /**
@@ -2112,104 +2097,6 @@
 	return false;
 }
 
-/**
- * ccs_get_execute_condition - Get condition part for execute requests.
- *
- * @ee: Pointer to "struct ccs_execve".
- *
- * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
- */
-static struct ccs_condition *ccs_get_execute_condition(struct ccs_execve *ee)
-{
-	struct ccs_condition *cond;
-	char *buf;
-	int len = 256;
-	char *realpath = NULL;
-	char *argv0 = NULL;
-	const struct ccs_profile *profile = ccs_profile(ccs_current_domain()->
-							profile);
-	if (profile->learning->learning_exec_realpath) {
-		struct file *file = ee->bprm->file;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
-		struct path path = { file->f_vfsmnt, file->f_dentry };
-		realpath = ccs_realpath_from_path(&path);
-#else
-		realpath = ccs_realpath_from_path(&file->f_path);
-#endif
-		if (realpath)
-			len += strlen(realpath) + 17;
-	}
-	if (profile->learning->learning_exec_argv0) {
-		if (ccs_get_argv0(ee)) {
-			argv0 = ee->tmp;
-			len += strlen(argv0) + 16;
-		}
-	}
-	buf = kmalloc(len, CCS_GFP_FLAGS);
-	if (!buf) {
-		kfree(realpath);
-		return NULL;
-	}
-	snprintf(buf, len - 1, "if");
-	if (current->ccs_flags & CCS_TASK_IS_EXECUTE_HANDLER) {
-		const int pos = strlen(buf);
-		snprintf(buf + pos, len - pos - 1,
-			 " task.type=execute_handler");
-	}
-	if (realpath) {
-		const int pos = strlen(buf);
-		snprintf(buf + pos, len - pos - 1, " exec.realpath=\"%s\"",
-			 realpath);
-		kfree(realpath);
-	}
-	if (argv0) {
-		const int pos = strlen(buf);
-		snprintf(buf + pos, len - pos - 1, " exec.argv[0]=\"%s\"",
-			 argv0);
-	}
-	cond = ccs_get_condition(buf);
-	kfree(buf);
-	return cond;
-}
-
-/**
- * ccs_get_symlink_condition - Get condition part for symlink requests.
- *
- * @r: Pointer to "struct ccs_request_info".
- *
- * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
- */
-static struct ccs_condition *ccs_get_symlink_condition
-(const struct ccs_request_info *r)
-{
-	struct ccs_condition *cond;
-	char *buf;
-	int len = 256;
-	const char *symlink = NULL;
-	const struct ccs_profile *profile = ccs_profile(r->profile);
-	if (profile->learning->learning_symlink_target) {
-		symlink = r->obj->symlink_target->name;
-		len += strlen(symlink) + 18;
-	}
-	buf = kmalloc(len, CCS_GFP_FLAGS);
-	if (!buf)
-		return NULL;
-	snprintf(buf, len - 1, "if");
-	if (current->ccs_flags & CCS_TASK_IS_EXECUTE_HANDLER) {
-		const int pos = strlen(buf);
-		snprintf(buf + pos, len - pos - 1,
-			 " task.type=execute_handler");
-	}
-	if (symlink) {
-		const int pos = strlen(buf);
-		snprintf(buf + pos, len - pos - 1, " symlink.target=\"%s\"",
-			 symlink);
-	}
-	cond = ccs_get_condition(buf);
-	kfree(buf);
-	return cond;
-}
-
 /* Wait queue for ccs_query_list. */
 static DECLARE_WAIT_QUEUE_HEAD(ccs_query_wait);
 
@@ -2232,6 +2119,15 @@
 /* Number of "struct file" referring /proc/ccs/query interface. */
 static atomic_t ccs_query_observers = ATOMIC_INIT(0);
 
+static void ccs_addprintf(char *buffer, int len, const char *fmt, ...)
+{
+	va_list args;
+	const int pos = strlen(buffer);
+	va_start(args, fmt);
+	vsnprintf(buffer + pos, len - pos - 1, fmt, args);
+	va_end(args);
+}
+			
 /**
  * ccs_supervisor - Ask for the supervisor's decision.
  *
@@ -2254,40 +2150,81 @@
 	bool quota_exceeded = false;
 	char *header;
 	struct ccs_domain_info * const domain = ccs_current_domain();
-	switch (r->mode) {
+	va_start(args, fmt);
+	len = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 80;
+	va_end(args);
+	if (r->mode == CCS_CONFIG_LEARNING) {
 		char *buffer;
-		struct ccs_condition *cond;
-	case CCS_CONFIG_LEARNING:
+		char *realpath = NULL;
+		char *argv0 = NULL;
+		const char *symlink = NULL;
+		const struct ccs_preference *pref;
 		if (!ccs_domain_quota_ok(r))
 			return 0;
-		va_start(args, fmt);
-		len = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 4;
-		va_end(args);
-		buffer = kmalloc(len, CCS_GFP_FLAGS);
-		if (!buffer)
-			return 0;
-		va_start(args, fmt);
-		vsnprintf(buffer, len - 1, fmt, args);
-		va_end(args);
-		ccs_normalize_line(buffer);
+		pref = ccs_profile(r->profile)->learning;
 		if (r->param_type == CCS_TYPE_PATH_ACL &&
-		    r->param.path.operation == CCS_TYPE_EXECUTE)
-			cond = ccs_get_execute_condition(r->ee);
-		else if (r->param_type == CCS_TYPE_PATH_ACL &&
-			 r->param.path.operation == CCS_TYPE_SYMLINK)
-			cond = ccs_get_symlink_condition(r);
-		else if ((current->ccs_flags & CCS_TASK_IS_EXECUTE_HANDLER)) {
-			char str[] = "if task.type=execute_handler";
-			cond = ccs_get_condition(str);
-		} else
-			cond = NULL;
-		ccs_write_domain2(buffer, domain, cond, false);
-		ccs_put_condition(cond);
-		kfree(buffer);
-		/* fall through */
-	case CCS_CONFIG_PERMISSIVE:
+		    r->param.path.operation == CCS_TYPE_EXECUTE) {
+			if (pref->learning_exec_realpath) {
+				struct file *file = r->ee->bprm->file;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+				struct path path = { file->f_vfsmnt,
+						     file->f_dentry };
+				realpath = ccs_realpath_from_path(&path);
+#else
+				realpath = ccs_realpath_from_path(&file->
+								  f_path);
+#endif
+				if (realpath)
+					len += strlen(realpath);
+			}
+			if (pref->learning_exec_argv0) {
+				if (ccs_get_argv0(r->ee)) {
+					argv0 = r->ee->tmp;
+					len += strlen(argv0);
+				}
+			}
+		}
+		if (r->param_type == CCS_TYPE_PATH_ACL &&
+		    r->param.path.operation == CCS_TYPE_SYMLINK &&
+		    pref->learning_symlink_target) {
+			symlink = r->obj->symlink_target->name;
+			len += strlen(symlink);
+		}
+		buffer = kmalloc(len, CCS_GFP_FLAGS);
+		if (buffer) {
+			const bool handler = (current->ccs_flags &
+					      CCS_TASK_IS_EXECUTE_HANDLER)
+				!= 0;
+			va_start(args, fmt);
+			vsnprintf(buffer, len - 1, fmt, args);
+			va_end(args);
+			if (handler || realpath || argv0 || symlink) {
+				ccs_addprintf(buffer, len, " if");
+				if (handler)
+					ccs_addprintf(buffer, len, " task.type"
+						      "=execute_handler");
+				if (realpath)
+					ccs_addprintf(buffer, len,
+						      " exec.realpath=\"%s\"",
+						      realpath);
+				if (argv0)
+					ccs_addprintf(buffer, len,
+						      " exec.argv[0]=\"%s\"",
+						      argv0);
+				if (symlink)
+					ccs_addprintf(buffer, len,
+						      " symlink.target=\"%s\"",
+						      symlink);
+			}
+			ccs_normalize_line(buffer);
+			ccs_write_domain2(buffer, domain, false);
+			kfree(buffer);
+		}
+		kfree(realpath);
 		return 0;
 	}
+	if (r->mode != CCS_CONFIG_ENFORCING)
+		return 0;
 	if (!atomic_read(&ccs_query_observers)) {
 		int i;
 		if (current->ccs_flags & CCS_DONT_SLEEP_ON_ENFORCE_ERROR)
@@ -2299,9 +2236,6 @@
 		}
 		return -EPERM;
 	}
-	va_start(args, fmt);
-	len = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 32;
-	va_end(args);
 	header = ccs_init_log(&len, r);
 	if (!header)
 		goto out;
@@ -2324,14 +2258,12 @@
 	spin_unlock(&ccs_query_list_lock);
 	if (quota_exceeded)
 		goto out;
-	pos = snprintf(ccs_query_entry->query, len - 1, "Q%u-%hu\n%s",
-		       ccs_query_entry->serial, r->retry, header);
+	snprintf(ccs_query_entry->query, len - 1, "Q%u-%hu\n%s",
+		 ccs_query_entry->serial, r->retry, header);
 	kfree(header);
 	header = NULL;
-	va_start(args, fmt);
-	vsnprintf(ccs_query_entry->query + pos, len - 1 - pos, fmt, args);
+	ccs_addprintf(ccs_query_entry->query, len, fmt, args);
 	ccs_query_entry->query_len = strlen(ccs_query_entry->query) + 1;
-	va_end(args);
 	spin_lock(&ccs_query_list_lock);
 	list_add_tail(&ccs_query_entry->list, &ccs_query_list);
 	spin_unlock(&ccs_query_list_lock);
