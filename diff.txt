Index: branches/ccs-patch/security/ccsecurity/chroot.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/chroot.c	(revision 2898)
+++ branches/ccs-patch/security/ccsecurity/chroot.c	(working copy)
@@ -111,6 +111,9 @@
 	struct ccs_path_info dir;
 	char *root_name;
 	bool is_enforce;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+	struct path tmp_path = { path->mnt, path->dentry };
+#endif
 	ccs_check_read_lock();
 	if (!ccs_can_sleep())
 		return 0;
@@ -120,10 +123,12 @@
 		return 0;
  retry:
 	error = -EPERM;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25) && LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 26)
-	root_name = ccs_realpath_from_dentry(path->path.dentry, path->path.mnt);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+	root_name = ccs_realpath_from_path(path);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	root_name = ccs_realpath_from_path(&path->path);
 #else
-	root_name = ccs_realpath_from_dentry(path->dentry, path->mnt);
+	root_name = ccs_realpath_from_path(&tmp_path);
 #endif
 	if (!root_name)
 		goto out;
Index: branches/ccs-patch/security/ccsecurity/realpath.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/realpath.c	(revision 2898)
+++ branches/ccs-patch/security/ccsecurity/realpath.c	(working copy)
@@ -34,11 +34,29 @@
 #include <linux/proc_fs.h>
 #include "internal.h"
 
+static int ccs_kern_path(const char *pathname, int flags, struct path *path)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 28)
+	if (!pathname || kern_path(pathname, flags, path))
+		return -ENOENT;
+#else
+	struct nameidata nd;
+	if (!pathname || path_lookup(pathname, flags, &nd))
+		return -ENOENT;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	*path = nd.path;
+#else
+	path->dentry = nd.dentry;
+	path->mnt = nd.mnt;
+#endif
+#endif
+	return 0;
+}
+
 /**
  * ccs_get_absolute_path - Get the path of a dentry but ignores chroot'ed root.
  *
- * @dentry: Pointer to "struct dentry".
- * @vfsmnt: Pointer to "struct vfsmount".
+ * @path:   Pointer to "struct path".
  * @buffer: Pointer to buffer to return value in.
  * @buflen: Sizeof @buffer.
  *
@@ -52,12 +70,13 @@
  * \ooo style octal string.
  * Character \ is converted to \\ string.
  */
-static int ccs_get_absolute_path(struct dentry *dentry, struct vfsmount *vfsmnt,
-				 char *buffer, int buflen)
+static int ccs_get_absolute_path(struct path *path, char *buffer, int buflen)
 {
 	/***** CRITICAL SECTION START *****/
 	char *start = buffer;
 	char *end = buffer + buflen;
+	struct dentry *dentry = path->dentry;
+	struct vfsmount *vfsmnt = path->mnt;
 	bool is_dir = (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode));
 
 	if (buflen < 256)
@@ -187,22 +206,19 @@
 #define SOCKFS_MAGIC 0x534F434B
 
 /**
- * ccs_realpath_from_dentry2 - Returns realpath(3) of the given dentry but ignores chroot'ed root.
+ * ccs_realpath_from_path2 - Returns realpath(3) of the given dentry but ignores chroot'ed root.
  *
- * @dentry:      Pointer to "struct dentry".
- * @mnt:         Pointer to "struct vfsmount".
+ * @path:        Pointer to "struct path".
  * @newname:     Pointer to buffer to return value in.
  * @newname_len: Size of @newname.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_realpath_from_dentry2(struct dentry *dentry,
-				     struct vfsmount *mnt,
-				     char *newname, int newname_len)
+static int ccs_realpath_from_path2(struct path *path, char *newname,
+				   int newname_len)
 {
 	int error = -EINVAL;
-	struct dentry *d_dentry;
-	struct vfsmount *d_mnt;
+	struct dentry *dentry = path->dentry;
 	if (!dentry || !newname || newname_len <= 2048)
 		goto out;
 	/* Get better name for socket. */
@@ -258,17 +274,15 @@
 		goto out;
 	}
 #endif
-	if (!mnt)
+	if (!path->mnt)
 		goto out;
-	d_dentry = dget(dentry);
-	d_mnt = mntget(mnt);
+	path_get(path);
 	/***** CRITICAL SECTION START *****/
 	ccs_realpath_lock();
-	error = ccs_get_absolute_path(d_dentry, d_mnt, newname, newname_len);
+	error = ccs_get_absolute_path(path, newname, newname_len);
 	ccs_realpath_unlock();
 	/***** CRITICAL SECTION END *****/
-	dput(d_dentry);
-	mntput(d_mnt);
+	path_put(path);
  out:
 	if (error)
 		printk(KERN_WARNING "ccs_realpath: Pathname too long. (%d)\n",
@@ -277,22 +291,20 @@
 }
 
 /**
- * ccs_realpath_from_dentry - Returns realpath(3) of the given pathname but ignores chroot'ed root.
+ * ccs_realpath_from_path - Returns realpath(3) of the given pathname but ignores chroot'ed root.
  *
- * @dentry: Pointer to "struct dentry".
- * @mnt:    Pointer to "struct vfsmount".
+ * @path: Pointer to "struct path".
  *
- * Returns the realpath of the given @dentry and @mnt on success,
- * NULL otherwise.
+ * Returns the realpath of the given @path on success, NULL otherwise.
  *
  * These functions use kzalloc(), so caller must kfree()
  * if these functions didn't return NULL.
  */
-char *ccs_realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt)
+char *ccs_realpath_from_path(struct path *path)
 {
 	char *buf = kzalloc(CCS_MAX_PATHNAME_LEN, GFP_KERNEL);
-	if (buf && ccs_realpath_from_dentry2(dentry, mnt, buf,
-					     CCS_MAX_PATHNAME_LEN - 2) == 0)
+	if (buf &&
+	    ccs_realpath_from_path2(path, buf, CCS_MAX_PATHNAME_LEN - 2) == 0)
 		return buf;
 	kfree(buf);
 	return NULL;
@@ -307,16 +319,10 @@
  */
 char *ccs_realpath(const char *pathname)
 {
-	struct nameidata nd;
-	if (pathname && path_lookup(pathname, ccs_lookup_flags, &nd) == 0) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
-		char *buf = ccs_realpath_from_dentry(nd.path.dentry,
-						     nd.path.mnt);
-		path_put(&nd.path);
-#else
-		char *buf = ccs_realpath_from_dentry(nd.dentry, nd.mnt);
-		path_release(&nd);
-#endif
+	struct path path;
+	if (ccs_kern_path(pathname, ccs_lookup_flags, &path) == 0) {
+		char *buf = ccs_realpath_from_path(&path);
+		path_put(&path);
 		return buf;
 	}
 	return NULL;
@@ -332,21 +338,13 @@
  */
 int ccs_symlink_path(const char *pathname, struct ccs_execve_entry *ee)
 {
-	struct nameidata nd;
+	struct path path;
 	int ret;
-	if (!pathname ||
-	    path_lookup(pathname, ccs_lookup_flags ^ LOOKUP_FOLLOW, &nd))
+	if (ccs_kern_path(pathname, ccs_lookup_flags ^ LOOKUP_FOLLOW, &path))
 		return -ENOENT;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
-	ret = ccs_realpath_from_dentry2(nd.path.dentry, nd.path.mnt,
-					ee->program_path,
-					CCS_MAX_PATHNAME_LEN - 1);
-	path_put(&nd.path);
-#else
-	ret = ccs_realpath_from_dentry2(nd.dentry, nd.mnt, ee->program_path,
-					CCS_MAX_PATHNAME_LEN - 1);
-	path_release(&nd);
-#endif
+	ret = ccs_realpath_from_path2(&path, ee->program_path,
+				      CCS_MAX_PATHNAME_LEN - 1);
+	path_put(&path);
 	return ret;
 }
 
@@ -400,3 +398,15 @@
 	return cp0;
 }
 
+/**
+ * ccs_get_path - Get dentry/vfsmmount of a pathname.
+ *
+ * @pathname: The pathname to solve.
+ * @path:     Pointer to "struct path".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_get_path(const char *pathname, struct path *path)
+{
+	return ccs_kern_path(pathname, ccs_lookup_flags, path);
+}
Index: branches/ccs-patch/security/ccsecurity/pivot_root.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/pivot_root.c	(revision 2898)
+++ branches/ccs-patch/security/ccsecurity/pivot_root.c	(working copy)
@@ -124,6 +124,10 @@
 	char *new_root;
 	struct ccs_path_info old_root_dir;
 	struct ccs_path_info new_root_dir;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+	struct path tmp_old_path = { old_path->mnt, old_path->dentry };
+	struct path tmp_new_path = { new_path->mnt, new_path->dentry };
+#endif
 	bool is_enforce;
 	ccs_check_read_lock();
 	if (!ccs_can_sleep())
@@ -134,14 +138,15 @@
 		return 0;
  retry:
 	error = -EPERM;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25) && LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 26)
-	old_root = ccs_realpath_from_dentry(old_path->path.dentry,
-					    old_path->path.mnt);
-	new_root = ccs_realpath_from_dentry(new_path->path.dentry,
-					    new_path->path.mnt);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+	old_root = ccs_realpath_from_path(old_path);
+	new_root = ccs_realpath_from_path(new_path);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	old_root = ccs_realpath_from_path(&old_path->path);
+	new_root = ccs_realpath_from_path(&new_path->path);
 #else
-	old_root = ccs_realpath_from_dentry(old_path->dentry, old_path->mnt);
-	new_root = ccs_realpath_from_dentry(new_path->dentry, new_path->mnt);
+	old_root = ccs_realpath_from_path(&tmp_old_path);
+	new_root = ccs_realpath_from_path(&tmp_new_path);
 #endif
 	if (!old_root || !new_root)
 		goto out;
Index: branches/ccs-patch/security/ccsecurity/util.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/util.c	(revision 2898)
+++ branches/ccs-patch/security/ccsecurity/util.c	(working copy)
@@ -829,8 +829,13 @@
 	down_read(&mm->mmap_sem);
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
 		if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file) {
-			cp = ccs_realpath_from_dentry(vma->vm_file->f_dentry,
-						      vma->vm_file->f_vfsmnt);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+			struct path path = { vma->vm_file->f_vfsmnt,
+					     vma->vm_file->f_dentry };
+			cp = ccs_realpath_from_path(&path);
+#else
+			cp = ccs_realpath_from_path(&vma->vm_file->f_path);
+#endif
 			break;
 		}
 	}
Index: branches/ccs-patch/security/ccsecurity/file.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/file.c	(revision 2898)
+++ branches/ccs-patch/security/ccsecurity/file.c	(working copy)
@@ -192,7 +192,7 @@
 }
 
 /**
- * ccs_get_path - Get realpath.
+ * ccs_get_realpath - Get realpath.
  *
  * @buf:    Pointer to "struct ccs_path_info".
  * @dentry: Pointer to "struct dentry".
@@ -200,10 +200,11 @@
  *
  * Returns true success, false otherwise.
  */
-static bool ccs_get_path(struct ccs_path_info *buf, struct dentry *dentry,
+static bool ccs_get_realpath(struct ccs_path_info *buf, struct dentry *dentry,
 			 struct vfsmount *mnt)
 {
-	buf->name = ccs_realpath_from_dentry(dentry, mnt);
+	struct path path = { mnt, dentry }; 
+	buf->name = ccs_realpath_from_path(&path);
 	if (buf->name) {
 		ccs_fill_path_info(buf);
 		return true;
@@ -430,13 +431,13 @@
 LIST_HEAD(ccs_path_group_list);
 
 /**
- * ccs_get_path_group - Allocate memory for "struct ccs_path_group".
+ * ccs_get_realpath_group - Allocate memory for "struct ccs_path_group".
  *
  * @group_name: The name of pathname group.
  *
  * Returns pointer to "struct ccs_path_group" on success, NULL otherwise.
  */
-struct ccs_path_group *ccs_get_path_group(const char *group_name)
+struct ccs_path_group *ccs_get_realpath_group(const char *group_name)
 {
 	struct ccs_path_group *entry = NULL;
 	struct ccs_path_group *group;
@@ -493,7 +494,7 @@
 	if (!ccs_is_correct_path(member_name, 0, 0, 0) ||
 	    !member_name[0])
 		return -EINVAL;
-	group = ccs_get_path_group(group_name);
+	group = ccs_get_realpath_group(group_name);
 	if (!group)
 		return -ENOMEM;
 	saved_member_name = ccs_get_name(member_name);
@@ -1526,7 +1527,7 @@
 		error = 0;
 		goto out;
 	}
-	if (!ccs_get_path(&buf, dentry, mnt))
+	if (!ccs_get_realpath(&buf, dentry, mnt))
 		goto out;
 	memset(&obj, 0, sizeof(obj));
 	obj.path1_dentry = dentry;
@@ -1588,7 +1589,7 @@
 		error = 0;
 		goto out;
 	}
-	if (!ccs_get_path(&buf, dentry, mnt))
+	if (!ccs_get_realpath(&buf, dentry, mnt))
 		goto out;
 	memset(&obj, 0, sizeof(obj));
 	obj.path1_dentry = dentry;
@@ -1598,7 +1599,7 @@
 	case CCS_TYPE_MKDIR_ACL:
 	case CCS_TYPE_RMDIR_ACL:
 		if (!buf.is_dir) {
-			/* ccs_get_path() reserves space for appending "/". */
+			/* ccs_get_realpath() reserves space for appending "/". */
 			strcat((char *) buf.name, "/");
 			ccs_fill_path_info(&buf);
 		}
@@ -1651,7 +1652,7 @@
 		error = 0;
 		goto out;
 	}
-	if (!ccs_get_path(&buf, dentry, mnt))
+	if (!ccs_get_realpath(&buf, dentry, mnt))
 		goto out;
 	memset(&obj, 0, sizeof(obj));
 	obj.path1_dentry = dentry;
@@ -1692,7 +1693,7 @@
 		error = 0;
 		goto out;
 	}
-	if (!ccs_get_path(&buf, filp->f_dentry, filp->f_vfsmnt))
+	if (!ccs_get_realpath(&buf, filp->f_dentry, filp->f_vfsmnt))
 		goto out;
 	if (!ccs_is_no_rewrite_file(&buf)) {
 		error = 0;
@@ -1744,13 +1745,13 @@
 		error = 0;
 		goto out;
 	}
-	if (!ccs_get_path(&buf1, dentry1, mnt) ||
-	    !ccs_get_path(&buf2, dentry2, mnt))
+	if (!ccs_get_realpath(&buf1, dentry1, mnt) ||
+	    !ccs_get_realpath(&buf2, dentry2, mnt))
 		goto out;
 	if (operation == CCS_TYPE_RENAME_ACL) {
 		/* CCS_TYPE_LINK_ACL can't reach here for directory. */
 		if (dentry1->d_inode && S_ISDIR(dentry1->d_inode->i_mode)) {
-			/* ccs_get_path() reserves space for appending "/". */
+			/* ccs_get_realpath() reserves space for appending "/". */
 			if (!buf1.is_dir) {
 				strcat((char *) buf1.name, "/");
 				ccs_fill_path_info(&buf1);
@@ -1982,7 +1983,7 @@
 		error = 0;
 		goto out;
 	}
-	if (!ccs_get_path(&buf, dentry, vfsmnt))
+	if (!ccs_get_realpath(&buf, dentry, vfsmnt))
 		goto out;
 	memset(&obj, 0, sizeof(obj));
 	obj.path1_dentry = dentry;
Index: branches/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- branches/ccs-patch/security/ccsecurity/internal.h	(revision 2898)
+++ branches/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -861,7 +861,7 @@
 char *ccs_encode(const char *str);
 char *ccs_init_audit_log(int *len, struct ccs_request_info *r);
 char *ccs_realpath(const char *pathname);
-char *ccs_realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt);
+char *ccs_realpath_from_path(struct path *path);
 const char *ccs_cap2keyword(const u8 operation);
 const char *ccs_dp2keyword(const u8 operation);
 const char *ccs_get_exe(void);
@@ -941,6 +941,7 @@
 bool ccs_compare_name_union(const struct ccs_path_info *name, const struct ccs_name_union *ptr);
 bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr);
 const char *ccs_file_pattern(const struct ccs_path_info *filename);
+int ccs_get_path(const char *pathname, struct path *path);
 
 /* strcmp() for "struct ccs_path_info" structure. */
 static inline bool ccs_pathcmp(const struct ccs_path_info *a,
Index: branches/ccs-patch/security/ccsecurity/condition.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/condition.c	(revision 2898)
+++ branches/ccs-patch/security/ccsecurity/condition.c	(working copy)
@@ -237,15 +237,24 @@
 	return result;
 }
 
-static bool ccs_scan_exec_realpath(const struct file *file,
+static bool ccs_scan_exec_realpath(struct file *file,
 				   const struct ccs_name_union *ptr,
 				   const bool match)
 {
 	bool result;
 	struct ccs_path_info exe;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+	struct path path;
+#endif
 	if (!file)
 		return false;
-	exe.name = ccs_realpath_from_dentry(file->f_dentry, file->f_vfsmnt);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+	exe.name = ccs_realpath_from_path(&file->f_path);
+#else
+	path.mnt = file->f_vfsmnt;
+	path.dentry = file->f_dentry;
+	exe.name = ccs_realpath_from_path(&path);
+#endif
 	if (!exe.name)
 		return false;
 	ccs_fill_path_info(&exe);
Index: branches/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/policy_io.c	(revision 2898)
+++ branches/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -1746,8 +1746,12 @@
 	char *argv0 = NULL;
 	if (ccs_check_flags(NULL, CCS_AUTOLEARN_EXEC_REALPATH)) {
 		struct file *file = ee->bprm->file;
-		realpath = ccs_realpath_from_dentry(file->f_dentry,
-						    file->f_vfsmnt);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+		struct path path = { file->f_vfsmnt, file->f_dentry };
+		realpath = ccs_realpath_from_path(&path);
+#else
+		realpath = ccs_realpath_from_path(&file->f_path);
+#endif
 		if (realpath)
 			len += strlen(realpath) + 17;
 	}
Index: branches/ccs-patch/security/ccsecurity/umount.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/umount.c	(revision 2898)
+++ branches/ccs-patch/security/ccsecurity/umount.c	(working copy)
@@ -107,6 +107,7 @@
 	bool is_enforce;
 	struct ccs_acl_info *ptr;
 	struct ccs_path_info dir;
+	struct path path = { mnt, mnt->mnt_root };
 	ccs_check_read_lock();
 	if (!ccs_can_sleep())
 		return 0;
@@ -116,7 +117,7 @@
 		return 0;
  retry:
 	error = -EPERM;
-	dir0 = ccs_realpath_from_dentry(mnt->mnt_root, mnt);
+	dir0 = ccs_realpath_from_path(&path);
 	if (!dir0)
 		goto out;
 	dir.name = dir0;
Index: branches/ccs-patch/security/ccsecurity/compat.h
===================================================================
--- branches/ccs-patch/security/ccsecurity/compat.h	(revision 2898)
+++ branches/ccs-patch/security/ccsecurity/compat.h	(working copy)
@@ -236,3 +236,30 @@
 void synchronize_srcu(struct srcu_struct *sp);
 
 #endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+
+struct path {
+        struct vfsmount *mnt;
+        struct dentry *dentry;
+};
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+
+#include <linux/mount.h>
+
+static inline void path_get(struct path *path)
+{
+	dget(path->dentry);
+	mntget(path->mnt);
+}
+
+static inline void path_put(struct path *path)
+{
+	dput(path->dentry);
+	mntput(path->mnt);
+}
+
+#endif
