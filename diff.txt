Index: trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c	(working copy)
@@ -43,39 +43,47 @@
 /**
  * ccs_update_reserved_entry - Update "struct ccs_reserved" list.
  *
- * @min_port:  Start of port number range.
- * @max_port:  End of port number range.
- * @is_delete: True if it is a delete request.
+ * @param:    Pointer to "struct ccs_element_param".
+ * @min_port: Start of port number range.
+ * @max_port: End of port number range.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_update_reserved_entry(const u16 min_port, const u16 max_port,
-				     const bool is_delete)
+static int ccs_update_reserved_entry(struct ccs_element_param *param,
+				     const u16 min_port, const u16 max_port)
 {
-	struct ccs_reserved *ptr;
 	struct ccs_reserved e = {
 		.min_port = min_port,
 		.max_port = max_port
 	};
-	const int error =
-		ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_RESERVEDPORT],
-				  ccs_same_reserved);
+	struct ccs_policy_namespace *ns = param->ns;
+	int error;
 	u8 *tmp;
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+	param->check_duplicate = ccs_same_reserved;
+	error = ccs_update_list(param);
 	if (error)
 		return error;
 	tmp = kzalloc(sizeof(ccs_reserved_port_map), CCS_GFP_FLAGS);
 	if (!tmp)
 		return -ENOMEM;
-	list_for_each_entry_srcu(ptr, &ccs_policy_list[CCS_ID_RESERVEDPORT],
-				 head.list, &ccs_ss) {
-		unsigned int port;
-		if (ptr->head.is_deleted)
-			continue;
-		for (port = ptr->min_port; port <= ptr->max_port; port++)
-			tmp[port >> 3] |= 1 << (port & 7);
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		struct ccs_reserved *ptr;
+		list_for_each_entry_srcu(ptr,
+					 &ns->policy_list[CCS_ID_RESERVEDPORT],
+					 head.list, &ccs_ss) {
+			unsigned int port;
+			if (ptr->head.is_deleted)
+				continue;
+			for (port = ptr->min_port; port <= ptr->max_port;
+			     port++)
+				tmp[port >> 3] |= 1 << (port & 7);
+		}
 	}
 	memmove(ccs_reserved_port_map, tmp, sizeof(ccs_reserved_port_map));
 	kfree(tmp);
@@ -90,14 +98,14 @@
 /**
  * ccs_write_reserved_port - Write "struct ccs_reserved" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-int ccs_write_reserved_port(char *data, const bool is_delete)
+int ccs_write_reserved_port(struct ccs_element_param *param, char *data)
 {
 	unsigned int from;
 	unsigned int to;
@@ -109,8 +117,7 @@
 		/* fall through */
 	case 2:
 		if (from <= to && to < 65536)
-			return ccs_update_reserved_entry(from, to,
-							 is_delete);
+			return ccs_update_reserved_entry(param, from, to);
 		break;
 	}
 out:
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/audit.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/audit.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/audit.c	(working copy)
@@ -334,26 +334,33 @@
  */
 static void ccs_update_task_domain(struct ccs_request_info *r)
 {
-	const struct ccs_domain_info *domain;
-	char *buf;
+	const char *cp;
 	const struct ccs_acl_info *acl = r->matched_acl;
 	r->matched_acl = NULL;
 	if (!acl || !acl->cond || !acl->cond->transit)
 		return;
-	while (1) {
-		buf = kzalloc(CCS_EXEC_TMPSIZE, CCS_GFP_FLAGS);
-		if (buf)
-			break;
-		ssleep(1);
-		if (fatal_signal_pending(current))
-			return;
+	cp = acl->cond->transit->name;
+	if (*cp == '/') {
+		const struct ccs_domain_info *domain = ccs_current_domain();
+		char *buf;
+		while (1) {
+			buf = kzalloc(CCS_EXEC_TMPSIZE, CCS_GFP_FLAGS);
+			if (buf)
+				break;
+			ssleep(1);
+			if (fatal_signal_pending(current))
+				return;
+		}
+		snprintf(buf, CCS_EXEC_TMPSIZE - 1, "%s %s",
+			 domain->domainname->name, cp);
+		if (!ccs_assign_domain(r->ns, buf, r->profile, domain->group,
+				       true))
+			ccs_transition_failed(buf);
+		kfree(buf);
+		return;
 	}
-	domain = ccs_current_domain();
-	snprintf(buf, CCS_EXEC_TMPSIZE - 1, "%s %s", domain->domainname->name,
-		 acl->cond->transit->name);
-	if (!ccs_assign_domain(buf, r->profile, domain->group, true))
-		ccs_transition_failed(buf);
-	kfree(buf);
+	if (!ccs_assign_domain(r->ns, cp, 0, 0, true))
+		ccs_transition_failed(cp);
 }
 
 /* Wait queue for /proc/ccs/audit. */
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c	(working copy)
@@ -8,59 +8,34 @@
 
 #include "internal.h"
 
-/*
- * The global domains referred by "use_group" keyword.
- *
- * Although "use_group" needs only "struct list_head acl_info_list[2]",
- * we define structure for "use_group" as "struct ccs_domain_info" in order to
- * use common code.
- */
-struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
-
-/* The initial domain. */
-struct ccs_domain_info ccs_kernel_domain;
-
-/* The list for "struct ccs_domain_info". */
-LIST_HEAD(ccs_domain_list);
-
-/* List of policy. */
-struct list_head ccs_policy_list[CCS_MAX_POLICY];
-/* List of "struct ccs_group". */
-struct list_head ccs_group_list[CCS_MAX_GROUP];
 /* List of "struct ccs_condition" and "struct ccs_ipv6addr". */
 struct list_head ccs_shared_list[CCS_MAX_LIST];
 
 /**
- * ccs_update_policy - Update an entry for exception policy.
+ * ccs_update_list - Update an entry for exception policy.
  *
- * @new_entry:       Pointer to "struct ccs_acl_info".
- * @size:            Size of @new_entry in bytes.
- * @is_delete:       True if it is a delete request.
- * @list:            Pointer to "struct list_head".
- * @check_duplicate: Callback function to find duplicated entry.
+ * @param: Pointer to "struct ccs_element_param".
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      bool is_delete, struct list_head *list,
-		      bool (*check_duplicate) (const struct ccs_acl_head *,
-					       const struct ccs_acl_head *))
+int ccs_update_list(struct ccs_element_param *param)
 {
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	struct ccs_acl_head *entry;
+	struct list_head *list = param->list;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return -ENOMEM;
 	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
-		if (!check_duplicate(entry, new_entry))
+		if (!param->check_duplicate(entry, param->new_entry))
 			continue;
-		entry->is_deleted = is_delete;
+		entry->is_deleted = param->is_delete;
 		error = 0;
 		break;
 	}
-	if (error && !is_delete) {
-		entry = ccs_commit_ok(new_entry, size);
+	if (error && !param->is_delete) {
+		entry = ccs_commit_ok(param->new_entry, param->size);
 		if (entry) {
 			list_add_tail_rcu(&entry->list, list);
 			error = 0;
@@ -114,7 +89,7 @@
 		type == CCS_TYPE_DENIED_EXECUTE_HANDLER ||
 		type == CCS_TYPE_AUTO_TASK_ACL;
 	if (param->data[0]) {
-		new_entry->cond = ccs_get_condition(param->data);
+		new_entry->cond = ccs_get_condition(param->ns, param->data);
 		if (!new_entry->cond)
 			return -EINVAL;
 	}
@@ -183,7 +158,7 @@
 	}
 	if (!retried) {
 		retried = true;
-		domain = &ccs_acl_group[domain->group];
+		domain = &r->ns->acl_group[domain->group];
 		goto retry;
 	}
 	r->granted = false;
@@ -212,20 +187,20 @@
 /**
  * ccs_update_transition_control_entry - Update "struct ccs_transition_control" list.
  *
+ * @param:      Pointer to "struct ccs_element_param".
  * @domainname: The name of domain. Maybe NULL.
  * @program:    The name of program. Maybe NULL.
  * @type:       Type of transition.
- * @is_delete:  True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_transition_control_entry(const char *domainname,
+static int ccs_update_transition_control_entry(struct ccs_element_param *param,
+					       const char *domainname,
 					       const char *program,
-					       const u8 type,
-					       const bool is_delete)
+					       const u8 type)
 {
 	struct ccs_transition_control e = { .type = type };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	if (program && strcmp(program, "any")) {
 		if (!ccs_correct_path(program))
 			return -EINVAL;
@@ -243,9 +218,11 @@
 		if (!e.domainname)
 			goto out;
 	}
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_TRANSITION_CONTROL],
-				  ccs_same_transition_control);
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &param->ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+	param->check_duplicate = ccs_same_transition_control;
+	error = ccs_update_list(param);
 out:
 	ccs_put_name(e.domainname);
 	ccs_put_name(e.program);
@@ -255,13 +232,13 @@
 /**
  * ccs_write_transition_control - Write "struct ccs_transition_control" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- * @type:      Type of this entry.
+ * @param: Pointer to "struct ccs_element_param". 
+ * @data:  String to parse.
+ * @type:  Type of this entry.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_transition_control(char *data, const bool is_delete,
+int ccs_write_transition_control(struct ccs_element_param *param, char *data,
 				 const u8 type)
 {
 	char *domainname = strstr(data, " from ");
@@ -273,8 +250,8 @@
 		domainname = data;
 		data = NULL;
 	}
-	return ccs_update_transition_control_entry(domainname, data, type,
-						   is_delete);
+	return ccs_update_transition_control_entry(param, domainname, data,
+						   type);
 }
 
 /**
@@ -295,6 +272,7 @@
 /**
  * ccs_transition_type - Get domain transition type.
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @domainname: The name of domain.
  * @program:    The name of program.
  *
@@ -304,17 +282,18 @@
  *
  * Caller holds ccs_read_lock().
  */
-static u8 ccs_transition_type(const struct ccs_path_info *domainname,
+static u8 ccs_transition_type(const struct ccs_policy_namespace *ns,
+			      const struct ccs_path_info *domainname,
 			      const struct ccs_path_info *program)
 {
 	const struct ccs_transition_control *ptr;
 	const char *last_name = ccs_last_word(domainname->name);
 	u8 type;
 	for (type = 0; type < CCS_MAX_TRANSITION_TYPE; type++) {
+		const struct list_head *list;
 next:
-		list_for_each_entry_srcu(ptr, &ccs_policy_list
-					 [CCS_ID_TRANSITION_CONTROL],
-					 head.list, &ccs_ss) {
+		list = &ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 			if (ptr->head.is_deleted || ptr->type != type)
 				continue;
 			if (ptr->domainname) {
@@ -333,6 +312,14 @@
 			}
 			if (ptr->program && ccs_pathcmp(ptr->program, program))
 				continue;
+			if (type == CCS_TRANSITION_CONTROL_NO_MOVE_NAMESPACE) {
+				/*
+				 * Do not check for move_namespace if
+				 * no_move_namespace matched.
+				 */
+				type = CCS_TRANSITION_CONTROL_NO_INITIALIZE;
+				goto next;
+			}
 			if (type == CCS_TRANSITION_CONTROL_NO_INITIALIZE) {
 				/*
 				 * Do not check for initialize_domain if
@@ -368,18 +355,18 @@
 /**
  * ccs_update_aggregator_entry - Update "struct ccs_aggregator" list.
  *
+ * @param:           Pointer to "struct ccs_element_param".
  * @original_name:   The original program's name.
  * @aggregated_name: The aggregated program's name.
- * @is_delete:       True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_aggregator_entry(const char *original_name,
-				       const char *aggregated_name,
-				       const bool is_delete)
+static int ccs_update_aggregator_entry(struct ccs_element_param *param,
+				       const char *original_name,
+				       const char *aggregated_name)
 {
 	struct ccs_aggregator e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_correct_word(original_name) ||
 	    !ccs_correct_path(aggregated_name))
 		return -EINVAL;
@@ -388,9 +375,11 @@
 	if (!e.original_name || !e.aggregated_name ||
 	    e.aggregated_name->is_patterned) /* No patterns allowed. */
 		goto out;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_AGGREGATOR],
-				  ccs_same_aggregator);
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &param->ns->policy_list[CCS_ID_AGGREGATOR];
+	param->check_duplicate = ccs_same_aggregator;
+	error = ccs_update_list(param);
 out:
 	ccs_put_name(e.original_name);
 	ccs_put_name(e.aggregated_name);
@@ -400,55 +389,26 @@
 /**
  * ccs_write_aggregator - Write "struct ccs_aggregator" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_aggregator(char *data, const bool is_delete)
+int ccs_write_aggregator(struct ccs_element_param *param, char *data)
 {
 	char *w[2];
 	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
 		return -EINVAL;
-	return ccs_update_aggregator_entry(w[0], w[1], is_delete);
+	return ccs_update_aggregator_entry(param, w[0], w[1]);
 }
 
-/* Domain create/delete handler. */
+/* Domain create handler. */
 
 /**
- * ccs_delete_domain - Delete a domain.
+ * ccs_assign_domain - Create a domain or transit a namespace.
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @domainname: The name of domain.
- *
- * Returns 0.
- */
-int ccs_delete_domain(char *domainname)
-{
-	struct ccs_domain_info *domain;
-	struct ccs_path_info name;
-	name.name = domainname;
-	ccs_fill_path_info(&name);
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		return 0;
-	/* Is there an active domain? */
-	list_for_each_entry_srcu(domain, &ccs_domain_list, list, &ccs_ss) {
-		/* Never delete ccs_kernel_domain. */
-		if (domain == &ccs_kernel_domain)
-			continue;
-		if (domain->is_deleted ||
-		    ccs_pathcmp(domain->domainname, &name))
-			continue;
-		domain->is_deleted = true;
-		break;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	return 0;
-}
-
-/**
- * ccs_assign_domain - Create a domain.
- *
- * @domainname: The name of domain.
  * @profile:    Profile number to assign if the domain was newly created.
  * @group:      Group number to assign if the domain was newly created.
  * @transit:    True if transit to domain found or created.
@@ -457,18 +417,41 @@
  *
  * Caller holds ccs_read_lock().
  */
-struct ccs_domain_info *ccs_assign_domain(const char *domainname,
+struct ccs_domain_info *ccs_assign_domain(struct ccs_policy_namespace *ns,
+					  const char *domainname,
 					  const u8 profile, const u8 group,
 					  const bool transit)
 {
 	struct ccs_domain_info e = { };
-	struct ccs_domain_info *entry = ccs_find_domain(domainname);
+	struct ccs_domain_info *entry;
+	const char *nsname = ns->root.domainname->name; 
+	int len = strlen(domainname);
 	bool created = false;
+	if (len >= CCS_EXEC_TMPSIZE - 10 || !ccs_correct_domain(domainname))
+		return NULL;
+	len = strlen(nsname);
+	if (strncmp(nsname, domainname, len) ||
+	    (domainname[len] && domainname[len] != ' ')) {
+		if (!transit) {
+			printk(KERN_INFO
+			       "Domain '%s' not in namespace '%s'.\n",
+			       domainname, nsname);
+			return NULL;
+		}
+		ns = ccs_find_namespace(domainname);
+		if (!ns) {
+			printk(KERN_INFO "Namespace '%s' not found.\n",
+			       domainname);
+			return NULL;
+		}
+		printk(KERN_INFO "Changing namespace to '%s'.\n", domainname);
+		ccs_current_security()->ccs_domain_info = &ns->root;
+		return &ns->root;
+	}
+	entry = ccs_find_domain(ns, domainname);
 	if (entry)
 		goto out;
-	if (strlen(domainname) >= CCS_EXEC_TMPSIZE - 10 ||
-	    !ccs_correct_domain(domainname))
-		return NULL;
+	e.ns = ns;
 	e.profile = profile;
 	e.group = group;
 	e.domainname = ccs_get_name(domainname);
@@ -476,13 +459,13 @@
 		return NULL;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	entry = ccs_find_domain(domainname);
+	entry = ccs_find_domain(ns, domainname);
 	if (!entry) {
 		entry = ccs_commit_ok(&e, sizeof(e));
 		if (entry) {
 			INIT_LIST_HEAD(&entry->acl_info_list[0]);
 			INIT_LIST_HEAD(&entry->acl_info_list[1]);
-			list_add_tail_rcu(&entry->list, &ccs_domain_list);
+			list_add_tail_rcu(&entry->list, &ns->domain_list);
 			created = true;
 		}
 	}
@@ -549,10 +532,10 @@
 		}
 	} else {
 		struct ccs_aggregator *ptr;
+		struct list_head *list =
+			&r->ns->policy_list[CCS_ID_AGGREGATOR];
 		/* Check 'aggregator' directive. */
-		list_for_each_entry_srcu(ptr,
-					 &ccs_policy_list[CCS_ID_AGGREGATOR],
-					 head.list, &ccs_ss) {
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 			if (ptr->head.is_deleted ||
 			    !ccs_path_matches_pattern(&rn, ptr->original_name))
 				continue;
@@ -585,18 +568,23 @@
 	}
 
 	/* Calculate domain to transit to. */
-	switch (ccs_transition_type(old_domain->domainname, &rn)) {
+	switch (ccs_transition_type(r->ns, old_domain->domainname, &rn)) {
+	case CCS_TRANSITION_CONTROL_MOVE_NAMESPACE:
+		/* Transit to the root of specified namespace. */
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "<%s>", rn.name);
+		break;
 	case CCS_TRANSITION_CONTROL_INITIALIZE:
-		/* Transit to the child of ccs_kernel_domain domain. */
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, CCS_ROOT_NAME " " "%s",
-			 rn.name);
+		/* Transit to the child of current namespace's root. */
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%s %s",
+			 r->ns->root.domainname->name, rn.name);
 		break;
 	case CCS_TRANSITION_CONTROL_KEEP:
 		/* Keep current domain. */
 		domain = old_domain;
 		break;
 	default:
-		if (old_domain == &ccs_kernel_domain && !ccs_policy_loaded) {
+		if (!ccs_policy_loaded &&
+		    old_domain == &ccs_default_namespace.root) {
 			/*
 			 * Needn't to transit from kernel domain before
 			 * starting /sbin/init. But transit from kernel domain
@@ -628,7 +616,7 @@
 	 * enforcing mode.
 	 */
 	if (!domain)
-		domain = ccs_assign_domain(ee->tmp, r->profile,
+		domain = ccs_assign_domain(r->ns, ee->tmp, r->profile,
 					   old_domain->group, true);
 	if (domain)
 		retval = 0;
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/memory.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/memory.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/memory.c	(working copy)
@@ -109,15 +109,18 @@
 /**
  * ccs_get_group - Allocate memory for "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group".
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @group_name: The name of address group.
  * @idx:        Index number.
  *
  * Returns pointer to "struct ccs_group" on success, NULL otherwise.
  */
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx)
+struct ccs_group *ccs_get_group(struct ccs_policy_namespace *ns,
+				const char *group_name, const u8 idx)
 {
 	struct ccs_group e = { };
 	struct ccs_group *group = NULL;
+	struct list_head *list;
 	bool found = false;
 	if (!ccs_correct_word(group_name) || idx >= CCS_MAX_GROUP)
 		return NULL;
@@ -126,7 +129,8 @@
 		return NULL;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list_for_each_entry(group, &ccs_group_list[idx], head.list) {
+	list = &ns->group_list[idx];
+	list_for_each_entry(group, list, head.list) {
 		if (e.group_name != group->group_name)
 			continue;
 		atomic_inc(&group->head.users);
@@ -138,8 +142,7 @@
 		if (entry) {
 			INIT_LIST_HEAD(&entry->member_list);
 			atomic_set(&entry->head.users, 1);
-			list_add_tail_rcu(&entry->head.list,
-					  &ccs_group_list[idx]);
+			list_add_tail_rcu(&entry->head.list, list);
 			group = entry;
 			found = true;
 		}
@@ -247,12 +250,12 @@
 
 /* Dummy security context for avoiding NULL pointer dereference. */
 static struct ccs_security ccs_oom_security = {
-	.ccs_domain_info = &ccs_kernel_domain
+	.ccs_domain_info = &ccs_default_namespace.root
 };
 
 /* Dummy security context for avoiding NULL pointer dereference. */
 static struct ccs_security ccs_default_security = {
-	.ccs_domain_info = &ccs_kernel_domain
+	.ccs_domain_info = &ccs_default_namespace.root
 };
 
 /* List of "struct ccs_security". */
@@ -400,6 +403,31 @@
 
 #endif
 
+struct ccs_policy_namespace ccs_default_namespace;
+
+bool ccs_init_policy_namespace(struct ccs_policy_namespace *ns,
+			       const char *name)
+{
+	unsigned int idx;
+	ns->root.ns = ns;
+	INIT_LIST_HEAD(&ns->domain_list);
+	INIT_LIST_HEAD(&ns->root.acl_info_list[0]);
+	INIT_LIST_HEAD(&ns->root.acl_info_list[1]);
+	for (idx = 0; idx < CCS_MAX_ACL_GROUPS; idx++) {
+		INIT_LIST_HEAD(&ns->acl_group[idx].acl_info_list[0]);
+		INIT_LIST_HEAD(&ns->acl_group[idx].acl_info_list[1]);
+	}
+	for (idx = 0; idx < CCS_MAX_GROUP; idx++)
+		INIT_LIST_HEAD(&ns->group_list[idx]);
+	for (idx = 0; idx < CCS_MAX_POLICY; idx++)
+		INIT_LIST_HEAD(&ns->policy_list[idx]);
+	ns->root.domainname = ccs_get_name(name);
+	if (!ns->root.domainname)
+		return false;
+	list_add_tail_rcu(&ns->root.list, &ns->domain_list);
+	return true;
+};
+
 /**
  * ccs_mm_init - Initialize mm related code.
  *
@@ -408,14 +436,12 @@
 void __init ccs_mm_init(void)
 {
 	int idx;
+	for (idx = 0; idx < CCS_MAX_LIST; idx++)
+		INIT_LIST_HEAD(&ccs_shared_list[idx]);
 	for (idx = 0; idx < CCS_MAX_HASH; idx++)
 		INIT_LIST_HEAD(&ccs_name_list[idx]);
-	for (idx = 0; idx < CCS_MAX_ACL_GROUPS; idx++) {
-		INIT_LIST_HEAD(&ccs_acl_group[idx].acl_info_list[0]);
-		INIT_LIST_HEAD(&ccs_acl_group[idx].acl_info_list[1]);
-	}
-	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list[0]);
-	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list[1]);
+	ccs_init_policy_namespace(&ccs_default_namespace, "<kernel>");
+	list_add(&ccs_default_namespace.namespace_list, &ccs_namespace_list);
 #ifdef CONFIG_CCSECURITY_USE_EXTERNAL_TASK_SECURITY
 	for (idx = 0; idx < CCS_MAX_TASK_SECURITY_HASH; idx++)
 		INIT_LIST_HEAD(&ccs_task_security_list[idx]);
@@ -425,27 +451,25 @@
 	ccsecurity_ops.alloc_task_security = __ccs_alloc_task_security;
 	ccsecurity_ops.free_task_security = __ccs_free_task_security;
 #endif
-	ccs_kernel_domain.domainname = ccs_get_name(CCS_ROOT_NAME);
-	list_add_tail_rcu(&ccs_kernel_domain.list, &ccs_domain_list);
+#ifdef CONFIG_CCSECURITY_BUILTIN_INITIALIZERS
 	idx = ccs_read_lock();
-	if (ccs_find_domain(CCS_ROOT_NAME) != &ccs_kernel_domain)
-		panic("Can't register ccs_kernel_domain");
-#ifdef CONFIG_CCSECURITY_BUILTIN_INITIALIZERS
 	{
 		/* Load built-in policy. */
+		struct ccs_element_param param = { };
 		static char ccs_builtin_initializers[] __initdata
 			= CONFIG_CCSECURITY_BUILTIN_INITIALIZERS;
 		char *cp = ccs_builtin_initializers;
 		ccs_normalize_line(cp);
+		param.ns = &ccs_default_namespace;
 		while (cp && *cp) {
 			char *cp2 = strchr(cp, ' ');
 			if (cp2)
 				*cp2++ = '\0';
-			ccs_write_transition_control(cp, false,
+			ccs_write_transition_control(&param, cp,
 				     CCS_TRANSITION_CONTROL_INITIALIZE);
 			cp = cp2;
 		}
 	}
+	ccs_read_unlock(idx);
 #endif
-	ccs_read_unlock(idx);
 }
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/signal.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/signal.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/signal.c	(working copy)
@@ -88,8 +88,6 @@
 			p = find_task_by_pid((pid_t) pid);
 		else if (pid == 0)
 			p = current;
-		else if (pid == -1)
-			dest = &ccs_kernel_domain;
 		else
 			p = find_task_by_pid((pid_t) -pid);
 		if (p)
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/util.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/util.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/util.c	(working copy)
@@ -247,17 +247,19 @@
 /**
  * ccs_parse_name_union - Parse a ccs_name_union.
  *
+ * @ns:       Pointer to "struct ccs_policy_namespace".
  * @filename: Name or name group.
  * @ptr:      Pointer to "struct ccs_name_union".
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr)
+bool ccs_parse_name_union(struct ccs_policy_namespace *ns,
+			  const char *filename, struct ccs_name_union *ptr)
 {
 	if (!ccs_correct_word(filename))
 		return false;
 	if (filename[0] == '@') {
-		ptr->group = ccs_get_group(filename + 1, CCS_PATH_GROUP);
+		ptr->group = ccs_get_group(ns, filename + 1, CCS_PATH_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
@@ -269,12 +271,14 @@
 /**
  * ccs_parse_number_union - Parse a ccs_number_union.
  *
+ * @ns:   Pointer to "struct ccs_policy_namespace".
  * @data: Number or number range or number group.
  * @ptr:  Pointer to "struct ccs_number_union".
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_parse_number_union(char *data, struct ccs_number_union *ptr)
+bool ccs_parse_number_union(struct ccs_policy_namespace *ns, char *data,
+			    struct ccs_number_union *ptr)
 {
 	u8 type;
 	unsigned long v;
@@ -284,7 +288,7 @@
 	if (data[0] == '@') {
 		if (!ccs_correct_word(data))
 			return false;
-		ptr->group = ccs_get_group(data + 1, CCS_NUMBER_GROUP);
+		ptr->group = ccs_get_group(ns, data + 1, CCS_NUMBER_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
@@ -562,26 +566,21 @@
  */
 bool ccs_correct_domain(const unsigned char *domainname)
 {
-	if (!domainname || strncmp(domainname, CCS_ROOT_NAME,
-				   CCS_ROOT_NAME_LEN))
-		goto out;
-	domainname += CCS_ROOT_NAME_LEN;
-	if (!*domainname)
+	if (!domainname || !ccs_domain_def(domainname))
+		return false;
+	domainname = strchr(domainname, ' ');
+	if (!domainname++)
 		return true;
-	if (*domainname++ != ' ')
-		goto out;
 	while (1) {
 		const unsigned char *cp = strchr(domainname, ' ');
 		if (!cp)
 			break;
 		if (*domainname != '/' ||
 		    !ccs_correct_word2(domainname, cp - domainname - 1))
-			goto out;
+			return false;
 		domainname = cp + 1;
 	}
 	return ccs_correct_path(domainname);
-out:
-	return false;
 }
 
 /**
@@ -593,25 +592,39 @@
  */
 bool ccs_domain_def(const unsigned char *buffer)
 {
-	return !strncmp(buffer, CCS_ROOT_NAME, CCS_ROOT_NAME_LEN);
+	const unsigned char *cp;
+	int len;
+	if (*buffer != '<')
+		return false;
+	cp = strchr(buffer, ' ');
+	if (!cp)
+		len = strlen(buffer);
+	else
+		len = cp - buffer;
+	if (buffer[len - 1] != '>' || !ccs_correct_word2(buffer + 1, len - 2))
+		return false;
+	return true;
 }
 
 /**
  * ccs_find_domain - Find a domain by the given name.
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @domainname: The domainname to find.
  *
  * Returns pointer to "struct ccs_domain_info" if found, NULL otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-struct ccs_domain_info *ccs_find_domain(const char *domainname)
+struct ccs_domain_info *ccs_find_domain(const struct ccs_policy_namespace *ns,
+					const char *domainname)
 {
 	struct ccs_domain_info *domain;
 	struct ccs_path_info name;
+	const struct list_head *list = &ns->domain_list;
 	name.name = domainname;
 	ccs_fill_path_info(&name);
-	list_for_each_entry_srcu(domain, &ccs_domain_list, list, &ccs_ss) {
+	list_for_each_entry_srcu(domain, list, list, &ccs_ss) {
 		if (!domain->is_deleted &&
 		    !ccs_pathcmp(&name, domain->domainname))
 			return domain;
@@ -1028,6 +1041,7 @@
 		struct ccs_domain_info *domain = ccs_current_domain();
 		const u8 profile = domain->profile;
 		memset(r, 0, sizeof(*r));
+		r->ns = ccs_current_namespace();
 		r->profile = profile;
 		r->type = index;
 		r->mode = ccs_get_mode(profile, index);
@@ -1037,7 +1051,8 @@
 			return r->mode;
 		buf = container_of(r->matched_acl, typeof(struct ccs_task_acl),
 				   head)->domainname->name;
-		if (!ccs_assign_domain(buf, profile, domain->group, true))
+		if (!ccs_assign_domain(r->ns, buf, profile, domain->group,
+				       true))
 			break;
 	}
 	ccs_transition_failed(buf);
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/file.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/file.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/file.c	(working copy)
@@ -393,7 +393,7 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name))
+	if (!ccs_parse_name_union(param->ns, ccs_read_token(param), &e.name))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -462,10 +462,11 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.mode) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.major) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.minor))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.name) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.mode) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.major) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.minor))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -535,8 +536,9 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name1) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.name2))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.name1) ||
+	    !ccs_parse_name_union(ns, ccs_read_token(param), &e.name2))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -579,10 +581,11 @@
 {
 	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL };
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.dev_name) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.dir_name) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.fs_type) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.flags))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.dev_name) ||
+	    !ccs_parse_name_union(ns, ccs_read_token(param), &e.dir_name) ||
+	    !ccs_parse_name_union(ns, ccs_read_token(param), &e.fs_type) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.flags))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -1001,8 +1004,9 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.number))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.name) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.number))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/proc_if.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/proc_if.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/proc_if.c	(working copy)
@@ -65,7 +65,7 @@
 		if (!r.granted)
 			error = -EPERM;
 		else
-			error = ccs_assign_domain(data, r.profile,
+			error = ccs_assign_domain(r.ns, data, r.profile,
 						  ccs_current_domain()->group,
 						  true) ? 0 : -ENOENT;
 		ccs_read_unlock(idx);
@@ -308,6 +308,7 @@
 		ccs_dir_inode_operations.setattr = proc_notify_change;
 	ccs_dir->proc_iops = &ccs_dir_inode_operations;
 #endif
+	ccs_create_entry("namespace",        0600, ccs_dir, CCS_NAMESPACE);
 	ccs_create_entry("query",            0600, ccs_dir, CCS_QUERY);
 	ccs_create_entry("domain_policy",    0600, ccs_dir, CCS_DOMAINPOLICY);
 	ccs_create_entry("exception_policy", 0600, ccs_dir,
@@ -337,13 +338,6 @@
  */
 static int __init ccs_init_module(void)
 {
-	int i;
-	for (i = 0; i < CCS_MAX_POLICY; i++)
-		INIT_LIST_HEAD(&ccs_policy_list[i]);
-	for (i = 0; i < CCS_MAX_GROUP; i++)
-		INIT_LIST_HEAD(&ccs_group_list[i]);
-	for (i = 0; i < CCS_MAX_LIST; i++)
-		INIT_LIST_HEAD(&ccs_shared_list[i]);
 	if (ccsecurity_ops.disabled)
 		return -EINVAL;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
@@ -353,7 +347,6 @@
 	if (init_srcu_struct(&ccs_ss))
 		panic("Out of memory.");
 #endif
-	ccs_proc_init();
 	ccs_mm_init();
 	ccs_capability_init();
 	ccs_file_init();
@@ -362,6 +355,7 @@
 	ccs_mount_init();
 	ccs_policy_io_init();
 	ccs_domain_init();
+	ccs_proc_init();
 #ifdef CONFIG_CCSECURITY_USE_BUILTIN_POLICY
 	ccs_load_builtin_policy();
 #endif
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -672,6 +672,7 @@
 	CCS_PROFILE,
 	CCS_QUERY,
 	CCS_MANAGER,
+	CCS_NAMESPACE,
 	CCS_EXECUTE_HANDLER,
 };
 
@@ -697,6 +698,8 @@
 /* Index numbers for domain transition control keywords. */
 enum ccs_transition_type {
 	/* Do not change this order, */
+	CCS_TRANSITION_CONTROL_NO_MOVE_NAMESPACE,
+	CCS_TRANSITION_CONTROL_MOVE_NAMESPACE,
 	CCS_TRANSITION_CONTROL_NO_INITIALIZE,
 	CCS_TRANSITION_CONTROL_INITIALIZE,
 	CCS_TRANSITION_CONTROL_NO_KEEP,
@@ -728,10 +731,6 @@
  */
 #define CCS_SOCK_MAX 6
 
-/* A domain definition starts with <kernel>. */
-#define CCS_ROOT_NAME                         "<kernel>"
-#define CCS_ROOT_NAME_LEN                     (sizeof(CCS_ROOT_NAME) - 1)
-
 /* Size of temporary buffer for execve() operation. */
 #define CCS_EXEC_TMPSIZE     4096
 
@@ -934,6 +933,7 @@
 };
 
 struct ccs_execve;
+struct ccs_policy_namespace;
 
 /* Structure for request info. */
 struct ccs_request_info {
@@ -1027,6 +1027,7 @@
 			const struct ccs_path_info *domainname;
 		} task;
 	} param;
+	struct ccs_policy_namespace *ns;
 	u8 param_type; /* One of values in "enum ccs_acl_entry_type_index". */
 	bool granted; /* True if granted, false otherwise. */
 	/* True if current thread should not be carried sleep penalty. */
@@ -1095,6 +1096,8 @@
 	struct list_head acl_info_list[2];
 	/* Name of this domain. Never NULL.          */
 	const struct ccs_path_info *domainname;
+	/* Namespace for this domain. Never NULL. */
+	struct ccs_policy_namespace *ns;
 	u8 profile;        /* Profile number to use. */
 	u8 group;          /* Group number to use.   */
 	bool is_deleted;   /* Delete flag.           */
@@ -1102,7 +1105,8 @@
 };
 
 /*
- * Structure for "initialize_domain"/"no_initialize_domain" and
+ * Structure for "move_namespace"/"no_move_namespace" and
+ * "initialize_domain"/"no_initialize_domain" and
  * "keep_domain"/"no_keep_domain" keyword.
  */
 struct ccs_transition_control {
@@ -1312,14 +1316,33 @@
 struct ccs_acl_param {
 	char *data;
 	struct ccs_domain_info *domain;
+	struct ccs_policy_namespace *ns;
 	bool is_delete;
 };
 
+/* Structure for holding a line from /proc/ccs/ interface. */
+struct ccs_element_param {
+	/* Namespace to use. */
+	struct ccs_policy_namespace *ns;
+	/* Pointer to "struct ccs_acl_info". */
+	struct ccs_acl_head *new_entry;
+	/* Size of @new_entry in bytes. */
+	u8 size;
+	/* True if it is a delete request. */
+	bool is_delete;
+	/* Pointer to "struct list_head". */
+	struct list_head *list;
+	/* Callback function to find duplicated entry. */
+	bool (*check_duplicate) (const struct ccs_acl_head *,
+				 const struct ccs_acl_head *);
+};
+
 /* Structure for reading/writing policy via /proc/ccs/ interfaces. */
 struct ccs_io_buffer {
 	void (*read) (struct ccs_io_buffer *);
 	int (*write) (struct ccs_io_buffer *);
 	int (*poll) (struct file *file, poll_table *wait);
+	struct ccs_policy_namespace *ns;
 	/* Exclusive lock for this structure.   */
 	struct mutex io_sem;
 	char __user *read_user_buf;
@@ -1381,6 +1404,33 @@
 	u8 sec;
 };
 
+/* Structure for policy namespace. */
+struct ccs_policy_namespace {
+	/* Profile table. Memory is allocated as needed. */
+	struct ccs_profile *profile_ptr[CCS_MAX_PROFILES];
+	/*
+	 * The root domain for this namespace.
+	 * This domain's name is like "<kernel>" and "</usr/sbin/httpd>".
+	 */
+	struct ccs_domain_info root;
+	/* The list for "struct ccs_domain_info". */
+	struct list_head domain_list;
+	/* List of "struct ccs_group". */
+	struct list_head group_list[CCS_MAX_GROUP];
+	/* List of policy. */
+	struct list_head policy_list[CCS_MAX_POLICY];
+	/*
+	 * The global domains referred by "use_group" keyword.
+	 *
+	 * Although "use_group" needs only "struct list_head acl_info_list[2]",
+	 * we define structure for "use_group" as "struct ccs_domain_info" in
+	 * order to use common code.
+	 */
+	struct ccs_domain_info acl_group[CCS_MAX_ACL_GROUPS];
+	/* List for connecting to ccs_namespace_list list. */
+	struct list_head namespace_list;
+};
+
 /* Prototype definition for "struct ccsecurity_operations". */
 
 void __init ccs_capability_init(void);
@@ -1407,11 +1457,15 @@
 bool ccs_domain_quota_ok(struct ccs_request_info *r);
 bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos,
 		   struct ccs_page_dump *dump);
+bool ccs_init_policy_namespace(struct ccs_policy_namespace *ns,
+			       const char *name);
 bool ccs_memory_ok(const void *ptr, const unsigned int size);
 bool ccs_number_matches_group(const unsigned long min, const unsigned long max,
 			      const struct ccs_group *group);
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr);
-bool ccs_parse_number_union(char *data, struct ccs_number_union *num);
+bool ccs_parse_name_union(struct ccs_policy_namespace *ns,
+			  const char *filename, struct ccs_name_union *ptr);
+bool ccs_parse_number_union(struct ccs_policy_namespace *ns, char *data,
+			    struct ccs_number_union *num);
 bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 			      const struct ccs_path_info *pattern);
 bool ccs_permstr(const char *string, const char *keyword);
@@ -1433,7 +1487,6 @@
 (const struct ccs_path_info *pathname, const struct ccs_group *group);
 const struct in6_addr *ccs_get_ipv6_address(const struct in6_addr *addr);
 int ccs_close_control(struct file *file);
-int ccs_delete_domain(char *data);
 int ccs_env_perm(struct ccs_request_info *r, const char *env);
 int ccs_get_path(const char *pathname, struct path *path);
 int ccs_init_request_info(struct ccs_request_info *r, const u8 index);
@@ -1453,31 +1506,34 @@
 		      bool (*merge_duplicate) (struct ccs_acl_info *,
 					       struct ccs_acl_info *,
 					       const bool));
-int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      bool is_delete, struct list_head *list,
-		      bool (*check_duplicate) (const struct ccs_acl_head *,
-					       const struct ccs_acl_head *));
-int ccs_write_aggregator(char *data, const bool is_delete);
+int ccs_update_list(struct ccs_element_param *param);
+int ccs_write_aggregator(struct ccs_element_param *param, char *data);
 int ccs_write_capability(struct ccs_acl_param *param);
 int ccs_write_file(struct ccs_acl_param *param);
-int ccs_write_group(char *data, const bool is_delete, const u8 type);
+int ccs_write_group(struct ccs_element_param *param, char *data,
+		    const u8 type);
 int ccs_write_inet_network(struct ccs_acl_param *param);
 int ccs_write_ipc(struct ccs_acl_param *param);
 int ccs_write_misc(struct ccs_acl_param *param);
-int ccs_write_reserved_port(char *data, const bool is_delete);
-int ccs_write_transition_control(char *data, const bool is_delete,
+int ccs_write_reserved_port(struct ccs_element_param *param, char *data);
+int ccs_write_transition_control(struct ccs_element_param *param, char *data,
 				 const u8 type);
 int ccs_write_unix_network(struct ccs_acl_param *param);
 ssize_t ccs_read_control(struct file *file, char __user *buffer,
 			 const size_t buffer_len);
 ssize_t ccs_write_control(struct file *file, const char __user *buffer,
 			  const size_t buffer_len);
-struct ccs_condition *ccs_get_condition(char *condition);
-struct ccs_domain_info *ccs_assign_domain(const char *domainname,
+struct ccs_condition *ccs_get_condition(struct ccs_policy_namespace *ns,
+					char *condition);
+struct ccs_domain_info *ccs_assign_domain(struct ccs_policy_namespace *ns,
+					  const char *domainname,
 					  const u8 profile, const u8 group,
 					  const bool transit);
-struct ccs_domain_info *ccs_find_domain(const char *domainname);
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx);
+struct ccs_domain_info *ccs_find_domain(const struct ccs_policy_namespace *ns,
+					const char *domainname);
+struct ccs_group *ccs_get_group(struct ccs_policy_namespace *ns,
+				const char *group_name, const u8 idx);
+struct ccs_policy_namespace *ccs_find_namespace(const char *domainname); 
 struct ccs_profile *ccs_profile(const u8 profile);
 u8 ccs_get_config(const u8 profile, const u8 index);
 u8 ccs_parse_ulong(unsigned long *result, char **str);
@@ -1529,12 +1585,9 @@
 extern const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION];
 extern const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION];
 extern const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION];
-extern struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
-extern struct ccs_domain_info ccs_kernel_domain;
-extern struct list_head ccs_domain_list;
-extern struct list_head ccs_group_list[CCS_MAX_GROUP];
+extern struct ccs_policy_namespace ccs_default_namespace;
 extern struct list_head ccs_name_list[CCS_MAX_HASH];
-extern struct list_head ccs_policy_list[CCS_MAX_POLICY];
+extern struct list_head ccs_namespace_list;
 extern struct list_head ccs_shared_list[CCS_MAX_LIST];
 extern struct mutex ccs_policy_lock;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
@@ -2037,7 +2090,7 @@
 static inline struct ccs_domain_info *ccs_task_domain(struct task_struct *task)
 {
 	struct ccs_domain_info *domain = task->ccs_domain_info;
-	return domain ? domain : &ccs_kernel_domain;
+	return domain ? domain : &ccs_default_namespace.root;
 }
 
 /**
@@ -2046,14 +2099,14 @@
  * Returns pointer to "struct ccs_domain_info" for current thread.
  *
  * If current thread does not belong to a domain (which is true for initial
- * init_task in order to hide ccs_kernel_domain from this module), current
- * thread enters into ccs_kernel_domain.
+ * init_task in order to hide ccs_default_namespace.root from this module),
+ * current thread enters into ccs_default_namespace.root.
  */
 static inline struct ccs_domain_info *ccs_current_domain(void)
 {
 	struct task_struct *task = current;
 	if (!task->ccs_domain_info)
-		task->ccs_domain_info = &ccs_kernel_domain;
+		task->ccs_domain_info = &ccs_default_namespace.root;
 	return task->ccs_domain_info;
 }
 
@@ -2081,4 +2134,9 @@
 
 #endif
 
+static inline struct ccs_policy_namespace *ccs_current_namespace(void)
+{
+	return ccs_current_domain()->ns;
+}
+
 #endif
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/condition.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/condition.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/condition.c	(working copy)
@@ -277,16 +277,18 @@
 /**
  * ccs_parse_name_union_quoted - Parse a quoted word.
  *
+ * @ns:       Pointer to "struct ccs_policy_namespace".
  * @filename: A line containing a quoted word.
  * @ptr:      Pointer to "struct ccs_name_union".
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_parse_name_union_quoted(char *filename,
+static bool ccs_parse_name_union_quoted(struct ccs_policy_namespace *ns,
+					char *filename,
 					struct ccs_name_union *ptr)
 {
 	if (*filename == '@')
-		return ccs_parse_name_union(filename, ptr);
+		return ccs_parse_name_union(ns, filename, ptr);
 	ptr->is_group = false;
 	ptr->filename = ccs_get_dqword(filename);
 	return ptr->filename != NULL;
@@ -482,11 +484,13 @@
 /**
  * ccs_get_condition - Parse condition part.
  *
+ * @ns:        Pointer to "struct ccs_policy_namespace".
  * @condition: Pointer to string to parse.
  *
  * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
  */
-struct ccs_condition *ccs_get_condition(char *condition)
+struct ccs_condition *ccs_get_condition(struct ccs_policy_namespace *ns,
+					char *condition)
 {
 	char *start;
 	struct ccs_condition *entry = NULL;
@@ -537,7 +541,8 @@
 					goto out;
 				entry->transit = ccs_get_dqword(word);
 				if (!entry->transit ||
-				    entry->transit->name[0] != '/')
+				    (entry->transit->name[0] != '/' &&
+				     !ccs_domain_def(entry->transit->name)))
 					goto out;
 			}
 			continue;
@@ -584,7 +589,8 @@
 			} else {
 				e.numbers_count--;
 				left = CCS_NUMBER_UNION;
-				if (!ccs_parse_number_union(word, numbers_p))
+				if (!ccs_parse_number_union(ns, word,
+							    numbers_p))
 					goto out;
 				if (numbers_p->is_group)
 					goto out;
@@ -605,7 +611,7 @@
 			} else {
 				e.names_count--;
 				right = CCS_NAME_UNION;
-				if (!ccs_parse_name_union_quoted(word,
+				if (!ccs_parse_name_union_quoted(ns, word,
 								 names_p++))
 					goto out;
 			}
@@ -618,7 +624,8 @@
 			} else {
 				e.numbers_count--;
 				right = CCS_NUMBER_UNION;
-				if (!ccs_parse_number_union(word, numbers_p++))
+				if (!ccs_parse_number_union(ns, word,
+							    numbers_p++))
 					goto out;
 			}
 		}
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -83,9 +83,6 @@
 /* Profile version. Currently only 20100903 is defined. */
 static unsigned int ccs_profile_version;
 
-/* Profile table. Memory is allocated as needed. */
-static struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
-
 /* String table for operation mode. */
 const char * const ccs_mode[CCS_CONFIG_MAX_MODE] = {
 	[CCS_CONFIG_DISABLED]   = "disabled",
@@ -433,23 +430,25 @@
 /**
  * ccs_assign_profile - Create a new profile.
  *
+ * @ns:      Pointer to "struct ccs_policy_namespace".
  * @profile: Profile number to create.
  *
  * Returns pointer to "struct ccs_profile" on success, NULL otherwise.
  */
-static struct ccs_profile *ccs_assign_profile(const unsigned int profile)
+static struct ccs_profile *ccs_assign_profile(struct ccs_policy_namespace *ns,
+					      const unsigned int profile)
 {
 	struct ccs_profile *ptr;
 	struct ccs_profile *entry;
 	if (profile >= CCS_MAX_PROFILES)
 		return NULL;
-	ptr = ccs_profile_ptr[profile];
+	ptr = ns->profile_ptr[profile];
 	if (ptr)
 		return ptr;
 	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	ptr = ccs_profile_ptr[profile];
+	ptr = ns->profile_ptr[profile];
 	if (!ptr && ccs_memory_ok(entry, sizeof(*entry))) {
 		ptr = entry;
 		ptr->default_config = CCS_CONFIG_DISABLED |
@@ -461,7 +460,7 @@
 		ptr->pref[CCS_PREF_MAX_LEARNING_ENTRY] =
 			CONFIG_CCSECURITY_MAX_ACCEPT_ENTRY;
 		mb(); /* Avoid out-of-order execution. */
-		ccs_profile_ptr[profile] = ptr;
+		ns->profile_ptr[profile] = ptr;
 		entry = NULL;
 	}
 	mutex_unlock(&ccs_policy_lock);
@@ -477,19 +476,25 @@
  */
 static void ccs_check_profile(void)
 {
-	struct ccs_domain_info *domain;
+	struct ccs_policy_namespace *ns;
 	const int idx = ccs_read_lock();
 	ccs_policy_loaded = true;
-	list_for_each_entry_srcu(domain, &ccs_domain_list, list, &ccs_ss) {
-		const u8 profile = domain->profile;
-		if (ccs_profile_ptr[profile])
-			continue;
-		printk(KERN_ERR "Profile %u must be defined before using it.\n",
-		       profile);
-		printk(KERN_ERR "Please see http://tomoyo.sourceforge.jp/1.8/ "
-		       "for more information.\n");
-		panic("Profile %u (used by '%s') not defined.\n",
-		      profile, domain->domainname->name);
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		struct ccs_domain_info *domain;
+		list_for_each_entry_srcu(domain, &ns->domain_list, list,
+					 &ccs_ss) {
+			const u8 profile = domain->profile;
+			if (ns->profile_ptr[profile])
+				continue;
+			printk(KERN_ERR "Profile %u must be defined before "
+			       "using it.\n", profile);
+			printk(KERN_ERR "Please see "
+			       "http://tomoyo.sourceforge.jp/1.8/ "
+			       "for more information.\n");
+			panic("Profile %u (used by '%s') not defined.\n",
+			      profile, domain->domainname->name);
+		}
 	}
 	ccs_read_unlock(idx);
 	if (ccs_profile_version != 20100903) {
@@ -514,7 +519,8 @@
 struct ccs_profile *ccs_profile(const u8 profile)
 {
 	static struct ccs_profile ccs_null_profile;
-	struct ccs_profile *ptr = ccs_profile_ptr[profile];
+	struct ccs_profile *ptr = ccs_current_namespace()->
+		profile_ptr[profile];
 	if (!ptr)
 		ptr = &ccs_null_profile;
 	return ptr;
@@ -654,7 +660,7 @@
 	if (*cp != '-')
 		return -EINVAL;
 	data = cp + 1;
-	profile = ccs_assign_profile(i);
+	profile = ccs_assign_profile(head->ns, i);
 	if (!profile)
 		return -EINVAL;
 	cp = strchr(data, '=');
@@ -714,7 +720,7 @@
 	const struct ccs_profile *profile;
 next:
 	index = head->r.index;
-	profile = ccs_profile_ptr[index];
+	profile = head->ns->profile_ptr[index];
 	switch (head->r.step) {
 	case 0:
 		ccs_io_printf(head, "PROFILE_VERSION=%u\n", 20100903);
@@ -723,7 +729,7 @@
 	case 1:
 		for ( ; head->r.index < CCS_MAX_PROFILES;
 		      head->r.index++)
-			if (ccs_profile_ptr[head->r.index])
+			if (head->ns->profile_ptr[head->r.index])
 				break;
 		if (head->r.index == CCS_MAX_PROFILES)
 			return;
@@ -783,7 +789,96 @@
 		goto next;
 }
 
+LIST_HEAD(ccs_namespace_list);
+
 /**
+ * ccs_write_namespace - Write namespace list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_namespace(struct ccs_io_buffer *head)
+{
+	char *data = head->write_buf;
+	struct ccs_policy_namespace *new_entry;
+	struct ccs_policy_namespace *ns;
+	int error = -ENOMEM;
+	if (strchr(data, ' ') || !ccs_domain_def(data))
+		return -EINVAL;
+	new_entry = kzalloc(sizeof(*new_entry), CCS_GFP_FLAGS);
+	if (!new_entry)
+		return -ENOMEM;
+	if (!ccs_init_policy_namespace(new_entry, data) ||
+	    mutex_lock_interruptible(&ccs_policy_lock))
+		goto out;
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		if (strcmp(data, ns->root.domainname->name))
+			continue;
+		error = 0;
+		break;
+	}
+	if (error) {
+		list_add_tail_rcu(&new_entry->namespace_list,
+				  &ccs_namespace_list);
+		new_entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+out:
+	if (new_entry) {
+		ccs_put_name(new_entry->root.domainname);
+		kfree(new_entry);
+	}
+	return error;
+}
+
+/**
+ * ccs_read_namespace - Read namespace list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static void ccs_read_namespace(struct ccs_io_buffer *head)
+{
+	if (head->r.eof)
+		return;
+	list_for_each_cookie(head->r.acl, &ccs_namespace_list) {
+		struct ccs_policy_namespace *ptr =
+			list_entry(head->r.acl, typeof(*ptr), namespace_list);
+		if (!ccs_flush(head))
+			return;
+		ccs_set_string(head, ptr->root.domainname->name);
+		ccs_set_lf(head);
+	}
+	head->r.eof = true;
+}
+
+/**
+ * ccs_find_namespace - Find specified namespace.
+ *
+ * @domainname: Name of namespace to find.
+ *
+ * Returns pointer to "struct ccs_policy_namespace" if found, NULL otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+struct ccs_policy_namespace *ccs_find_namespace(const char *domainname)
+{
+	struct ccs_policy_namespace *ns;
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		if (!strcmp(domainname, ns->root.domainname->name))
+			return ns;
+	}
+	return NULL;
+}
+
+/**
  * ccs_same_manager - Check for duplicated "struct ccs_manager" entry.
  *
  * @a: Pointer to "struct ccs_acl_head".
@@ -801,15 +896,16 @@
 /**
  * ccs_update_manager_entry - Add a manager entry.
  *
- * @manager:   The path to manager or the domainnamme.
- * @is_delete: True if it is a delete request.
+ * @param:   Pointer to "struct ccs_element_param".
+ * @manager: The path to manager or the domainnamme.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_manager_entry(const char *manager, const bool is_delete)
+static int ccs_update_manager_entry(struct ccs_element_param *param,
+				    const char *manager)
 {
 	struct ccs_manager e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	if (ccs_domain_def(manager)) {
 		if (!ccs_correct_domain(manager))
 			return -EINVAL;
@@ -821,9 +917,11 @@
 	e.manager = ccs_get_name(manager);
 	if (!e.manager)
 		return error;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_MANAGER],
-				  ccs_same_manager);
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &param->ns->policy_list[CCS_ID_MANAGER];
+	param->check_duplicate = ccs_same_manager;
+	error = ccs_update_list(param);
 	ccs_put_name(e.manager);
 	return error;
 }
@@ -839,11 +937,15 @@
 {
 	char *data = head->write_buf;
 	bool is_delete = ccs_str_starts(&data, "delete ");
+	struct ccs_element_param param = {
+		.ns = head->ns,
+		.is_delete = is_delete,
+	};
 	if (!strcmp(data, "manage_by_non_root")) {
 		ccs_manage_by_non_root = !is_delete;
 		return 0;
 	}
-	return ccs_update_manager_entry(data, is_delete);
+	return ccs_update_manager_entry(&param, data);
 }
 
 /**
@@ -857,9 +959,11 @@
  */
 static void ccs_read_manager(struct ccs_io_buffer *head)
 {
+	struct list_head *list;
 	if (head->r.eof)
 		return;
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[CCS_ID_MANAGER]) {
+	list = &head->ns->policy_list[CCS_ID_MANAGER];
+	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_manager *ptr =
 			list_entry(head->r.acl, typeof(*ptr), head.list);
 		if (ptr->head.is_deleted)
@@ -888,6 +992,7 @@
 	const struct ccs_path_info *domainname
 		= ccs_current_domain()->domainname;
 	bool found = false;
+	struct list_head *list;
 	if (!ccs_policy_loaded)
 		return true;
 	if (task->ccs_flags & CCS_TASK_IS_MANAGER)
@@ -895,8 +1000,8 @@
 	if (!ccs_manage_by_non_root && (current_uid() || current_euid()))
 		return false;
 	exe = ccs_get_exe();
-	list_for_each_entry_srcu(ptr, &ccs_policy_list[CCS_ID_MANAGER],
-				 head.list, &ccs_ss) {
+	list = &ccs_current_namespace()->policy_list[CCS_ID_MANAGER];
+	list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 		if (ptr->head.is_deleted)
 			continue;
 		if (ptr->is_domain) {
@@ -961,7 +1066,7 @@
 		ccs_tasklist_unlock();
 	} else if (!strncmp(data, "domain=", 7)) {
 		if (ccs_domain_def(data + 7))
-			domain = ccs_find_domain(data + 7);
+			domain = ccs_find_domain(head->ns, data + 7);
 	} else
 		return false;
 	head->w.domain = domain;
@@ -1068,20 +1173,23 @@
 /**
  * ccs_write_domain2 - Write domain policy.
  *
+ * @ns:        Pointer to "struct ccs_policy_namespace".
+ * @domain:    Pointer to "struct ccs_domain_info".
  * @data:      Policy to be interpreted.
- * @domain:    Pointer to "struct ccs_domain_info".
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_write_domain2(char *data, struct ccs_domain_info *domain,
+static int ccs_write_domain2(struct ccs_policy_namespace *ns,
+			     struct ccs_domain_info *domain, char *data,
 			     const bool is_delete)
 {
 	struct ccs_acl_param param = {
+		.ns = ns,
+		.domain = domain,
 		.data = data,
-		.domain = domain,
 		.is_delete = is_delete,
 	};
 	static const struct {
@@ -1105,6 +1213,39 @@
 	return -EINVAL;
 }
 
+/**
+ * ccs_delete_domain - Delete a domain.
+ *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
+ * @domainname: The name of domain.
+ *
+ * Returns 0.
+ */
+static int ccs_delete_domain(struct ccs_policy_namespace *ns, char *domainname)
+{
+	struct ccs_domain_info *domain;
+	struct ccs_path_info name;
+	struct list_head *list = &ns->domain_list;
+	name.name = domainname;
+	ccs_fill_path_info(&name);
+	if (mutex_lock_interruptible(&ccs_policy_lock))
+		return 0;
+	/* Is there an active domain? */
+	list_for_each_entry_srcu(domain, list, list, &ccs_ss) {
+		/* Never delete root of a namespace. */
+		if (domain == &ns->root)
+			continue;
+		if (domain->is_deleted ||
+		    ccs_pathcmp(domain->domainname, &name))
+			continue;
+		domain->is_deleted = true;
+		break;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	return 0;
+}
+
+
 /* String table for domain flags. */
 const char * const ccs_dif[CCS_MAX_DOMAIN_INFO_FLAGS] = {
 	[CCS_DIF_QUOTA_WARNED]      = "quota_exceeded\n",
@@ -1123,6 +1264,7 @@
 static int ccs_write_domain(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
+	struct ccs_policy_namespace *ns = head->ns;
 	struct ccs_domain_info *domain = head->w.domain;
 	bool is_delete = false;
 	bool is_select = false;
@@ -1139,11 +1281,11 @@
 	if (ccs_domain_def(data)) {
 		domain = NULL;
 		if (is_delete)
-			ccs_delete_domain(data);
+			ccs_delete_domain(ns, data);
 		else if (is_select)
-			domain = ccs_find_domain(data);
+			domain = ccs_find_domain(ns, data);
 		else
-			domain = ccs_assign_domain(data, 0, 0, false);
+			domain = ccs_assign_domain(ns, data, 0, 0, false);
 		head->w.domain = domain;
 		return 0;
 	}
@@ -1152,7 +1294,7 @@
 
 	if (sscanf(data, "use_profile %u\n", &profile) == 1
 	    && profile < CCS_MAX_PROFILES) {
-		if (!ccs_policy_loaded || ccs_profile_ptr[(u8) profile])
+		if (!ccs_policy_loaded || head->ns->profile_ptr[(u8) profile])
 			if (!is_delete)
 				domain->profile = (u8) profile;
 		return 0;
@@ -1170,7 +1312,7 @@
 		domain->flags[profile] = !is_delete;
 		return 0;
 	}
-	return ccs_write_domain2(data, domain, is_delete);
+	return ccs_write_domain2(ns, domain, data, is_delete);
 }
 
 /**
@@ -1664,9 +1806,11 @@
  */
 static void ccs_read_domain(struct ccs_io_buffer *head)
 {
+	struct list_head *list;
 	if (head->r.eof)
 		return;
-	list_for_each_cookie(head->r.domain, &ccs_domain_list) {
+	list = &head->ns->domain_list;
+	list_for_each_cookie(head->r.domain, list) {
 		struct ccs_domain_info *domain =
 			list_entry(head->r.domain, typeof(*domain), list);
 		switch (head->r.step) {
@@ -1735,8 +1879,9 @@
 	profile = simple_strtoul(data, NULL, 10);
 	if (profile >= CCS_MAX_PROFILES)
 		return -EINVAL;
-	domain = ccs_find_domain(cp + 1);
-	if (domain && (!ccs_policy_loaded || ccs_profile_ptr[(u8) profile]))
+	domain = ccs_find_domain(head->ns, cp + 1);
+	if (domain && (!ccs_policy_loaded ||
+		       head->ns->profile_ptr[(u8) profile]))
 		domain->profile = (u8) profile;
 	return 0;
 }
@@ -1759,9 +1904,11 @@
  */
 static void ccs_read_domain_profile(struct ccs_io_buffer *head)
 {
+	struct list_head *list;
 	if (head->r.eof)
 		return;
-	list_for_each_cookie(head->r.domain, &ccs_domain_list) {
+	list = &head->ns->domain_list;
+	list_for_each_cookie(head->r.domain, list) {
 		struct ccs_domain_info *domain =
 			list_entry(head->r.domain, typeof(*domain), list);
 		if (domain->is_deleted)
@@ -1851,10 +1998,13 @@
 
 /* String table for domain transition control keywords. */
 static const char * const ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
-	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
-	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
-	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
-	[CCS_TRANSITION_CONTROL_KEEP]          = "keep_domain ",
+	[CCS_TRANSITION_CONTROL_MOVE_NAMESPACE]    = "move_namespace ",
+	[CCS_TRANSITION_CONTROL_NO_MOVE_NAMESPACE] = "no_move_namespace ",
+	[CCS_TRANSITION_CONTROL_INITIALIZE]        = "initialize_domain ",
+	[CCS_TRANSITION_CONTROL_NO_INITIALIZE]     = "no_initialize_domain ",
+	[CCS_TRANSITION_CONTROL_INITIALIZE]        = "initialize_domain ",
+	[CCS_TRANSITION_CONTROL_NO_KEEP]           = "no_keep_domain ",
+	[CCS_TRANSITION_CONTROL_KEEP]              = "keep_domain ",
 };
 
 /* String table for grouping keywords. */
@@ -1875,10 +2025,14 @@
 {
 	char *data = head->write_buf;
 	const bool is_delete = ccs_str_starts(&data, "delete ");
+	struct ccs_element_param param = {
+		.ns = head->ns,
+		.is_delete = is_delete,
+	};
 	u8 i;
 	static const struct {
 		const char *keyword;
-		int (*write) (char *, const bool);
+		int (*write) (struct ccs_element_param *, char *);
 	} ccs_callback[2] = {
 		{ "aggregator ",    ccs_write_aggregator },
 		{ "deny_autobind ", ccs_write_reserved_port },
@@ -1893,23 +2047,23 @@
 		return -EPERM;
 	for (i = 0; i < 2; i++)
 		if (ccs_str_starts(&data, ccs_callback[i].keyword))
-			return ccs_callback[i].write(data, is_delete);
+			return ccs_callback[i].write(&param, data);
 	for (i = 0; i < CCS_MAX_TRANSITION_TYPE; i++)
 		if (ccs_str_starts(&data, ccs_transition_type[i]))
-			return ccs_write_transition_control(data, is_delete,
-							    i);
+			return ccs_write_transition_control(&param, data, i);
 	for (i = 0; i < CCS_MAX_GROUP; i++)
 		if (ccs_str_starts(&data, ccs_group_name[i]))
-			return ccs_write_group(data, is_delete, i);
+			return ccs_write_group(&param, data, i);
 	if (ccs_str_starts(&data, "acl_group ")) {
 		unsigned int group;
 		if (sscanf(data, "%u", &group) == 1 &&
 		    group < CCS_MAX_ACL_GROUPS) {
 			data = strchr(data, ' ');
-			if (data)
-				return ccs_write_domain2(data + 1,
-							 &ccs_acl_group[group],
-							 is_delete);
+			if (data++)
+				return ccs_write_domain2(head->ns,
+							 &head->ns->
+							 acl_group[group],
+							 data, is_delete);
 		}
 	}
 	return -EINVAL;
@@ -1927,7 +2081,8 @@
  */
 static bool ccs_read_group(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.group, &ccs_group_list[idx]) {
+	struct list_head *list = &head->ns->group_list[idx];
+	list_for_each_cookie(head->r.group, list) {
 		struct ccs_group *group =
 			list_entry(head->r.group, typeof(*group), head.list);
 		list_for_each_cookie(head->r.acl, &group->member_list) {
@@ -1983,7 +2138,8 @@
  */
 static bool ccs_read_policy(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[idx]) {
+	struct list_head *list = &head->ns->policy_list[idx];
+	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_acl_head *acl =
 			container_of(head->r.acl, typeof(*acl), list);
 		if (acl->is_deleted)
@@ -2066,8 +2222,8 @@
 	       + CCS_MAX_ACL_GROUPS * 2) {
 		head->r.acl_group_index = (head->r.step - CCS_MAX_POLICY
 					   - CCS_MAX_GROUP) / 2;
-		if (!ccs_read_domain2(head,
-				      &ccs_acl_group[head->r.acl_group_index],
+		if (!ccs_read_domain2(head, &head->ns->
+				      acl_group[head->r.acl_group_index],
 				      head->r.step & 1))
 			return;
 		head->r.step++;
@@ -2171,7 +2327,8 @@
 	if (symlink)
 		ccs_addprintf(buffer, len, "%s", symlink);
 	ccs_normalize_line(buffer);
-	if (!ccs_write_domain2(buffer, ccs_current_domain(), false))
+	if (!ccs_write_domain2(ccs_current_namespace(), ccs_current_domain(),
+			       buffer, false))
 		ccs_update_stat(CCS_STAT_POLICY_UPDATES);
 	kfree(buffer);
 }
@@ -2547,6 +2704,7 @@
 	struct ccs_io_buffer *head = kzalloc(sizeof(*head), CCS_GFP_FLAGS);
 	if (!head)
 		return -ENOMEM;
+	head->ns = ccs_current_namespace();
 	mutex_init(&head->io_sem);
 	head->type = type;
 	switch (type) {
@@ -2599,6 +2757,10 @@
 		head->write = ccs_write_manager;
 		head->read = ccs_read_manager;
 		break;
+	case CCS_NAMESPACE: /* /proc/ccs/namespace */
+		head->write = ccs_write_namespace;
+		head->read = ccs_read_namespace;
+		break;
 	}
 	if (!(file->f_mode & FMODE_READ)) {
 		/*
@@ -2681,6 +2843,9 @@
 	int idx;
 	if (!head->read)
 		return -ENOSYS;
+	/* Don't allow read/write if namespace is invalid. */
+	if (!head->ns)
+		return -ENOENT;
 	if (!access_ok(VERIFY_WRITE, buffer, buffer_len))
 		return -EFAULT;
 	if (mutex_lock_interruptible(&head->io_sem))
@@ -2722,13 +2887,6 @@
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
 	idx = ccs_read_lock();
-	/* Don't allow updating policies by non manager programs. */
-	if (head->write != ccs_write_pid && head->write != ccs_write_domain &&
-	    head->write != ccs_write_exception && !ccs_manager()) {
-		ccs_read_unlock(idx);
-		mutex_unlock(&head->io_sem);
-		return -EPERM;
-	}
 	/* Read a line and dispatch it to the policy handler. */
 	while (avail_len > 0) {
 		char c;
@@ -2757,7 +2915,39 @@
 		cp0[head->w.avail - 1] = '\0';
 		head->w.avail = 0;
 		ccs_normalize_line(cp0);
-		{
+		if (!strcmp(cp0, "reset")) {
+			head->w.domain = NULL;
+			memset(&head->r, 0, sizeof(head->r));
+			continue;
+		}
+		switch (head->type) {
+		case CCS_DOMAINPOLICY: /* /proc/ccs/domain_policy */
+		case CCS_EXCEPTIONPOLICY: /* /proc/ccs/exception_policy */
+		case CCS_DOMAIN_STATUS: /* /proc/ccs/.domain_status */
+		case CCS_PROFILE: /* /proc/ccs/profile */
+		case CCS_MANAGER: /* /proc/ccs/manager */
+			/* Selecting namespace to read/write. */
+			if (!strncmp(cp0, "namespace ", 10)) {
+				head->ns = ccs_find_namespace(cp0 + 10);
+				head->w.domain = NULL;
+				memset(&head->r, 0, sizeof(head->r));
+				if (head->ns)
+					continue;
+			}
+			/* Don't allow read/write if namespace is invalid. */
+			if (!head->ns) {
+				error = -ENOENT;
+				goto out;
+			}
+			break;
+		default:
+			break;
+		}
+		/* Don't allow updating policies by non manager programs. */
+		if (head->write == ccs_write_pid ||
+		    head->write == ccs_write_domain ||
+		    head->write == ccs_write_exception ||
+		    ccs_manager()) {
 			const int ret = head->write(head);
 			if (ret == -EPERM) {
 				error = -EPERM;
@@ -2765,6 +2955,9 @@
 			}
 			if (ret)
 				continue;
+		} else {
+			error = -EPERM;
+			break;
 		}
 		switch (head->type) {
 		case CCS_DOMAINPOLICY:
@@ -2773,12 +2966,14 @@
 		case CCS_STAT:
 		case CCS_PROFILE:
 		case CCS_MANAGER:
+		case CCS_NAMESPACE:
 			ccs_update_stat(CCS_STAT_POLICY_UPDATES);
 			break;
 		default:
 			break;
 		}
 	}
+out:
 	ccs_read_unlock(idx);
 	mutex_unlock(&head->io_sem);
 	return error;
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c	(working copy)
@@ -773,19 +773,21 @@
 {
 	int i;
 	enum ccs_policy_id id;
+	struct ccs_policy_namespace *ns;
 	int idx;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return;
 	idx = ccs_read_lock();
-	for (id = 0; id < CCS_MAX_POLICY; id++)
-		if (!ccs_collect_member(id, &ccs_policy_list[id]))
-			goto unlock;
-	for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
-		if (!ccs_collect_acl(&ccs_acl_group[i]))
-			goto unlock;
-	{
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
 		struct ccs_domain_info *domain;
-		list_for_each_entry(domain, &ccs_domain_list, list) {
+		for (id = 0; id < CCS_MAX_POLICY; id++)
+			if (!ccs_collect_member(id, &ns->policy_list[id]))
+				goto unlock;
+		for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
+			if (!ccs_collect_acl(&ns->acl_group[i]))
+				goto unlock;
+		list_for_each_entry(domain, &ns->domain_list, list) {
 			if (!ccs_collect_acl(domain))
 				goto unlock;
 			if (!domain->is_deleted ||
@@ -794,30 +796,32 @@
 			if (!ccs_add_to_gc(CCS_ID_DOMAIN, &domain->list))
 				goto unlock;
 		}
-	}
-	for (i = 0; i < CCS_MAX_GROUP; i++) {
-		struct list_head *list = &ccs_group_list[i];
-		struct ccs_group *group;
-		switch (i) {
-		case 0:
-			id = CCS_ID_PATH_GROUP;
-			break;
-		case 1:
-			id = CCS_ID_NUMBER_GROUP;
-			break;
-		default:
-			id = CCS_ID_ADDRESS_GROUP;
-			break;
+		for (i = 0; i < CCS_MAX_GROUP; i++) {
+			struct list_head *list = &ns->group_list[i];
+			struct ccs_group *group;
+			switch (i) {
+			case 0:
+				id = CCS_ID_PATH_GROUP;
+				break;
+			case 1:
+				id = CCS_ID_NUMBER_GROUP;
+				break;
+			default:
+				id = CCS_ID_ADDRESS_GROUP;
+				break;
+			}
+			list_for_each_entry(group, list, head.list) {
+				if (!ccs_collect_member(id,
+							&group->member_list))
+					goto unlock;
+				if (!list_empty(&group->member_list) ||
+				    atomic_read(&group->head.users))
+					continue;
+				if (!ccs_add_to_gc(CCS_ID_GROUP,
+						   &group->head.list))
+					goto unlock;
+			}
 		}
-		list_for_each_entry(group, list, head.list) {
-			if (!ccs_collect_member(id, &group->member_list))
-				goto unlock;
-			if (!list_empty(&group->member_list) ||
-			    atomic_read(&group->head.users))
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_GROUP, &group->head.list))
-				goto unlock;
-		}
 	}
 	for (i = 0; i < CCS_MAX_LIST + CCS_MAX_HASH; i++) {
 		struct list_head *list = i < CCS_MAX_LIST ?
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/network.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/network.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/network.c	(working copy)
@@ -343,13 +343,13 @@
 		if (address[0] != '@')
 			return -EINVAL;
 		e.address_type = CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
-		e.address.group = ccs_get_group(address + 1,
+		e.address.group = ccs_get_group(param->ns, address + 1,
 						CCS_ADDRESS_GROUP);
 		if (!e.address.group)
 			return -ENOMEM;
 		break;
 	}
-	if (!ccs_parse_number_union(ccs_read_token(param), &e.port))
+	if (!ccs_parse_number_union(param->ns, ccs_read_token(param), &e.port))
 		goto out;
 	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_inet_acl,
 				  ccs_merge_inet_acl);
@@ -386,7 +386,7 @@
 			e.perm |= 1 << type;
 	if (e.protocol == CCS_SOCK_MAX || !e.perm)
 		return -EINVAL;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name))
+	if (!ccs_parse_name_union(param->ns, ccs_read_token(param), &e.name))
 		return -EINVAL;
 	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_unix_acl,
 				  ccs_merge_unix_acl);
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/group.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/group.c	(revision 4951)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/group.c	(working copy)
@@ -63,13 +63,13 @@
 /**
  * ccs_write_group - Write "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- * @type:      Type of this group.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
+ * @type:  Type of this group.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_group(char *data, const bool is_delete, const u8 type)
+int ccs_write_group(struct ccs_element_param *param, char *data, const u8 type)
 {
 	struct ccs_group *group;
 	struct list_head *member;
@@ -77,10 +77,11 @@
 	int error = -EINVAL;
 	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
 		return -EINVAL;
-	group = ccs_get_group(w[0], type);
+	group = ccs_get_group(param->ns, w[0], type);
 	if (!group)
 		return -ENOMEM;
 	member = &group->member_list;
+	param->list = member;
 	if (type == CCS_PATH_GROUP) {
 		struct ccs_path_group e = { };
 		e.member_name = ccs_get_name(w[1]);
@@ -88,16 +89,21 @@
 			error = -ENOMEM;
 			goto out;
 		}
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_path_group);
+		param->new_entry = &e.head;
+		param->size = sizeof(e);
+		param->check_duplicate = ccs_same_path_group;
+		error = ccs_update_list(param);
 		ccs_put_name(e.member_name);
 	} else if (type == CCS_NUMBER_GROUP) {
 		struct ccs_number_group e = { };
-		if (w[1][0] == '@' || !ccs_parse_number_union(w[1], &e.number)
+		if (w[1][0] == '@' || !ccs_parse_number_union(param->ns, w[1],
+							      &e.number)
 		    || e.number.values[0] > e.number.values[1])
 			goto out;
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_number_group);
+		param->new_entry = &e.head;
+		param->size = sizeof(e);
+		param->check_duplicate = ccs_same_number_group;
+		error = ccs_update_list(param);
 		/*
 		 * ccs_put_number_union() is not needed because w[1][0] != '@'.
 		 */
@@ -122,8 +128,10 @@
 		default:
 			goto out_address;
 		}
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_address_group);
+		param->new_entry = &e.head;
+		param->size = sizeof(e);
+		param->check_duplicate = ccs_same_address_group;
+		error = ccs_update_list(param);
 out_address:
 		if (e.is_ipv6) {
 			ccs_put_ipv6_address(e.min.ipv6);
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.h
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.h	(revision 4951)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.h	(working copy)
@@ -51,10 +51,8 @@
 
 /***** CONSTANTS DEFINITION START *****/
 
-#define CCS_ROOT_NAME                    "<kernel>"
-#define CCS_ROOT_NAME_LEN                (sizeof(CCS_ROOT_NAME) - 1)
-
 #define CCS_PROC_POLICY_DIR              "/proc/ccs/"
+#define CCS_PROC_POLICY_NAMESPACE        "/proc/ccs/namespace"
 #define CCS_PROC_POLICY_DOMAIN_POLICY    "/proc/ccs/domain_policy"
 #define CCS_PROC_POLICY_DOMAIN_STATUS    "/proc/ccs/.domain_status"
 #define CCS_PROC_POLICY_EXCEPTION_POLICY "/proc/ccs/exception_policy"
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.c	(revision 4951)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.c	(working copy)
@@ -63,8 +63,8 @@
 /* Currently active screen's index. */
 enum ccs_screen_type ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
 /*
- * Array of "initialize_domain"/"no_initialize_domain"/"keep_domain"/
- * "no_keep_domain" entries.
+ * Array of "move_namespace"/"no_move_namespace"/"initialize_domain"/
+ * "no_initialize_domain"/"keep_domain"/"no_keep_domain" entries.
  */
 static struct ccs_transition_control_entry *ccs_transition_control_list = NULL;
 /* Length of ccs_transition_control_list array. */
@@ -96,15 +96,20 @@
 /* Start from the first line when showing ACL screen? */
 static _Bool ccs_no_restore_cursor = false;
 
+/* Namespace to use. */
+char *current_namespace = NULL;
+
 /* Domain transition coltrol keywords. */
 static const char *ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
+	[CCS_TRANSITION_CONTROL_MOVE] = "move_namespace ",
+	[CCS_TRANSITION_CONTROL_NO_MOVE] = "no_move_namespace ",
 	[CCS_TRANSITION_CONTROL_INITIALIZE] = "initialize_domain ",
 	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
 	[CCS_TRANSITION_CONTROL_KEEP] = "keep_domain ",
 	[CCS_TRANSITION_CONTROL_NO_KEEP] = "no_keep_domain ",
 };
 
-static FILE *ccs_editpolicy_open_write(const char *filename);
+static FILE *ccs_editpolicy_open(const char *filename);
 static _Bool ccs_deleted_domain(const int index);
 static _Bool ccs_domain_unreachable(const int index);
 static _Bool ccs_initializer_source(const int index);
@@ -174,7 +179,7 @@
 static void ccs_copy_file(const char *source, const char *dest)
 {
 	FILE *fp_in = fopen(source, "r");
-	FILE *fp_out = fp_in ? ccs_editpolicy_open_write(dest) : NULL;
+	FILE *fp_out = fp_in ? ccs_editpolicy_open(dest) : NULL;
 	while (fp_in && fp_out) {
 		int c = fgetc(fp_in);
 		if (c == EOF)
@@ -188,19 +193,30 @@
 }
 
 /**
+ * ccs_get_last_word - Get last component of a line.
+ *
+ * @line: A line of words.
+ *
+ * Returns the last component of the line.
+ */
+static const char *ccs_get_last_word(const char *line)
+{
+	const char *cp = strrchr(line, ' ');
+	if (cp)
+		return cp + 1;
+	return line;
+}
+
+/**
  * ccs_get_last_name - Get last component of a domainname.
  *
  * @index: Index in the domain policy.
  *
- * Returns the last componet of the domainname.
+ * Returns the last component of the domainname.
  */
 static const char *ccs_get_last_name(const int index)
 {
-	const char *cp0 = ccs_domain_name(&ccs_dp, index);
-	const char *cp1 = strrchr(cp0, ' ');
-	if (cp1)
-		return cp1 + 1;
-	return cp0;
+	return ccs_get_last_word(ccs_domain_name(&ccs_dp, index));
 }
 
 /**
@@ -364,7 +380,7 @@
 }
 
 /**
- * ccs_add_transition_control_policy - Add "initialize_domain"/"no_initialize_domain"/"keep_domain"/ "no_keep_domain" entries.
+ * ccs_add_transition_control_policy - Add "move_namespace"/"no_move_namespace"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/ "no_keep_domain" entries.
  *
  * @data: Line to parse.
  * @type: One of values in "enum ccs_transition_type".
@@ -414,16 +430,22 @@
 {
 	const struct ccs_transition_control_entry *d_t =
 		ccs_transition_control(domainname, program);
-	if (d_t && d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE) {
+	if (d_t && (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE ||
+		    d_t->type == CCS_TRANSITION_CONTROL_MOVE)) {
 		char *line;
 		int source;
 		ccs_get();
-		line = ccs_shprintf("%s %s", domainname->name, program);
+		if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE)
+			line = ccs_shprintf("%s %s", domainname->name,
+					    program);
+		else
+			line = ccs_shprintf("%s <%s>", domainname->name,
+					    program);
 		ccs_normalize_line(line);
 		source = ccs_assign_domain(&ccs_dp, line, true, false);
 		if (source == EOF)
 			ccs_out_of_memory();
-		line = ccs_shprintf(CCS_ROOT_NAME " %s", program);
+		line = ccs_shprintf("%s %s", current_namespace, program);
 		ccs_dp.list[source].target_domainname = strdup(line);
 		if (!ccs_dp.list[source].target_domainname)
 			ccs_out_of_memory();
@@ -454,12 +476,16 @@
  *
  * @index: Index in the domain policy.
  *
- * Returns index in the domain policy if found, EOF otherwise.
+ * Returns index in the domain policy if found, -2 if namespace jump,
+ * EOF otherwise.
  */
 static int ccs_find_target_domain(const int index)
 {
-	return ccs_find_domain(&ccs_dp, ccs_dp.list[index].target_domainname,
-			       false, false);
+	const char *cp = ccs_dp.list[index].target_domainname;
+	const char *sp = ccs_get_last_word(cp);
+	if (*sp == '<' && strcmp(current_namespace, sp))
+		return -2;
+	return ccs_find_domain(&ccs_dp, cp, false, false);
 }
 
 /**
@@ -533,8 +559,10 @@
 	if (redirect_index >= 0)
 		line = ccs_shprintf(" ( -> %d )",
 				    ccs_dp.list[redirect_index].number);
-	else
+	else if (redirect_index == EOF)
 		line = ccs_shprintf(" ( -> Not Found )");
+	else
+		line = ccs_shprintf(" ( -> Namespace jump )");
 	printw("%s", ccs_eat(line));
 	tmp_col += strlen(line);
 	ccs_put();
@@ -787,7 +815,7 @@
 }
 
 /**
- * ccs_editpolicy_open_write - Wrapper for ccs_open_write().
+ * ccs_editpolicy_open - Wrapper for ccs_open_write().
  *
  * @filename: File to open for writing.
  *
@@ -797,14 +825,9 @@
  * this function sets error line if failed. Also, this function returns NULL if
  * readonly mode.
  */
-static FILE *ccs_editpolicy_open_write(const char *filename)
+static FILE *ccs_editpolicy_open(const char *filename)
 {
-	if (ccs_network_mode) {
-		FILE *fp = ccs_open_write(filename);
-		if (!fp)
-			ccs_set_error(filename);
-		return fp;
-	} else if (ccs_offline_mode) {
+	if (ccs_offline_mode) {
 		char request[1024];
 		int fd[2];
 		if (socketpair(PF_UNIX, SOCK_STREAM, 0, fd)) {
@@ -822,57 +845,16 @@
 		close(fd[0]);
 		exit(1);
 	} else {
-		FILE *fp;
-		if (ccs_readonly_mode)
-			return NULL;
-		fp = ccs_open_write(filename);
+		FILE *fp = fopen(filename, "r+");
 		if (!fp)
 			ccs_set_error(filename);
+		fprintf(fp, "namespace %s\n", current_namespace);
+		fflush(fp);
 		return fp;
 	}
 }
 
 /**
- * ccs_editpolicy_open_read - Wrapper for ccs_open_read().
- *
- * @filename: File to open for reading.
- *
- * Returns pointer to "FILE" on success, NULL otherwise.
- *
- * Since CUI policy editor screen provides a line for printing error message,
- * this function sets error line if failed.
- */
-static FILE *ccs_editpolicy_open_read(const char *filename)
-{
-	if (ccs_network_mode) {
-		return ccs_open_read(filename);
-	} else if (ccs_offline_mode) {
-		char request[1024];
-		int fd[2];
-		FILE *fp;
-		if (socketpair(PF_UNIX, SOCK_STREAM, 0, fd)) {
-			fprintf(stderr, "socketpair()\n");
-			exit(1);
-		}
-		if (shutdown(fd[0], SHUT_WR))
-			goto out;
-		fp = fdopen(fd[0], "r");
-		if (!fp)
-			goto out;
-		memset(request, 0, sizeof(request));
-		snprintf(request, sizeof(request) - 1, "GET %s", filename);
-		ccs_send_fd(request, &fd[1]);
-		return fp;
-out:
-		close(fd[1]);
-		close(fd[0]);
-		exit(1);
-	} else {
-		return fopen(filename, "r");
-	}
-}
-
-/**
  * ccs_open2 - Wrapper for open().
  *
  * @filename: File to open.
@@ -938,11 +920,7 @@
 	int i;
 	u8 type;
 	struct ccs_path_info last_name;
-	last_name.name = strrchr(domainname->name, ' ');
-	if (last_name.name)
-		last_name.name++;
-	else
-		last_name.name = domainname->name;
+	last_name.name = ccs_get_last_word(domainname->name);
 	ccs_fill_path_info(&last_name);
 	for (type = 0; type < CCS_MAX_TRANSITION_TYPE; type++) {
 next:
@@ -965,6 +943,14 @@
 			if (ptr->program &&
 			    strcmp(ptr->program->name, program))
 				continue;
+			if (type == CCS_TRANSITION_CONTROL_NO_MOVE) {
+				/*
+				 * Do not check for move_namespace if
+				 * no_move_namespace matched.
+				 */
+				type = CCS_TRANSITION_CONTROL_NO_INITIALIZE;
+				goto next;
+			}
 			if (type == CCS_TRANSITION_CONTROL_NO_INITIALIZE) {
 				/*
 				 * Do not check for initialize_domain if
@@ -973,7 +959,8 @@
 				type = CCS_TRANSITION_CONTROL_NO_KEEP;
 				goto next;
 			}
-			if (type == CCS_TRANSITION_CONTROL_INITIALIZE ||
+			if (type == CCS_TRANSITION_CONTROL_MOVE ||
+			    type == CCS_TRANSITION_CONTROL_INITIALIZE ||
 			    type == CCS_TRANSITION_CONTROL_KEEP)
 				return ptr;
 			else
@@ -1000,20 +987,10 @@
 	const int a2 = a0->directive;
 	const int b2 = b0->directive;
 	if (a2 >= 256 || b2 >= 256) {
-		int i;
-		static const char *global[5] = {
-			"PROFILE_VERSION=",
-			"PREFERENCE::audit=",
-			"PREFERENCE::learning=",
-			"PREFERENCE::permissive=",
-			"PREFERENCE::enforcing="
-		};
-		for (i = 0; i < 5; i++) {
-			if (!strncmp(a1, global[i], strlen(global[i])))
-				return -1;
-			if (!strncmp(b1, global[i], strlen(global[i])))
-				return 1;
-		}
+		if (a1[0] == 'P')
+			return -1;
+		if (b1[0] == 'P')
+			return 1;
 	}
 	if (!ccs_profile_sort_type) {
 		if (a2 == b2)
@@ -1046,31 +1023,18 @@
 		free((void *)
 		     ccs_gacl_list[--ccs_gacl_list_count].
 		     operand);
+	fp = ccs_editpolicy_open(ccs_policy_file);
+	if (!fp)
+		return;
 	if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+		if (ccs_domain_sort_type)
+			fprintf(fp, "select pid=%u\n", ccs_current_pid);
+		else
+			fprintf(fp, "select domain=%s\n", ccs_current_domain);
 		if (ccs_network_mode)
-			/* We can read after write. */
-			fp = ccs_editpolicy_open_write(ccs_policy_file);
-		else if (!ccs_offline_mode)
-			/* Don't set error message if failed. */
-			fp = fopen(ccs_policy_file, "r+");
-		if (fp) {
-			if (ccs_domain_sort_type)
-				fprintf(fp, "select pid=%u\n",
-					ccs_current_pid);
-			else
-				fprintf(fp, "select domain=%s\n",
-					ccs_current_domain);
-			if (ccs_network_mode)
-				fputc(0, fp);
-			fflush(fp);
-		}
+			fputc(0, fp);
+		fflush(fp);
 	}
-	if (!fp)
-		fp = ccs_editpolicy_open_read(ccs_policy_file);
-	if (!fp) {
-		ccs_set_error(ccs_policy_file);
-		return;
-	}
 	ccs_freadline_raw = ccs_current_screen == CCS_SCREEN_STAT_LIST;
 	ccs_get();
 	while (true) {
@@ -1337,13 +1301,8 @@
 	if (!cp || !ccs_jump_list)
 		ccs_out_of_memory();
 	ccs_jump_list[ccs_jump_list_len++] = cp;
-	cp = strrchr(line, ' ');
-	if (cp)
-		cp++;
-	else
-		cp = line;
 	snprintf(domainname, sizeof(domainname) - 1, "%s %s",
-		 ccs_domain_name(&ccs_dp, index), cp);
+		 ccs_domain_name(&ccs_dp, index), ccs_get_last_word(line));
 	domainname[sizeof(domainname) - 1] = '\0';
 	ccs_normalize_line(domainname);
 	source = ccs_assign_domain(&ccs_dp, domainname, true, false);
@@ -1403,8 +1362,14 @@
 static void ccs_parse_exception_line(char *line, const int max_index)
 {
 	unsigned int group;
-	if (ccs_str_starts(line, "initialize_domain "))
+	if (ccs_str_starts(line, "move_namespace "))
 		ccs_add_transition_control_policy
+			(line, CCS_TRANSITION_CONTROL_MOVE);
+	else if (ccs_str_starts(line, "no_move_namespace "))
+		ccs_add_transition_control_policy
+			(line, CCS_TRANSITION_CONTROL_NO_MOVE);
+	else if (ccs_str_starts(line, "initialize_domain "))
+		ccs_add_transition_control_policy
 			(line, CCS_TRANSITION_CONTROL_INITIALIZE);
 	else if (ccs_str_starts(line, "no_initialize_domain "))
 		ccs_add_transition_control_policy
@@ -1459,25 +1424,15 @@
 	ccs_clear_domain_policy(&ccs_dp);
 	ccs_transition_control_list_len = 0;
 	ccs_editpolicy_clear_groups();
-	ccs_assign_domain(&ccs_dp, CCS_ROOT_NAME, false, false);
+	//ccs_assign_domain(&ccs_dp, current_namespace, false, false);
 
 	/* Load all domain transition related entries. */
-	fp = NULL;
-	if (ccs_network_mode)
-		/* We can read after write. */
-		fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
-	else if (!ccs_offline_mode)
-		/* Don't set error message if failed. */
-		fp = fopen(CCS_PROC_POLICY_DOMAIN_POLICY, "r+");
+	fp = ccs_editpolicy_open(CCS_PROC_POLICY_DOMAIN_POLICY);
 	if (fp) {
 		fprintf(fp, "select transition_only\n");
 		if (ccs_network_mode)
 			fputc(0, fp);
 		fflush(fp);
-	} else {
-		fp = ccs_editpolicy_open_read(CCS_PROC_POLICY_DOMAIN_POLICY);
-	}
-	if (fp) {
 		index = EOF;
 		ccs_get();
 		while (true) {
@@ -1495,31 +1450,17 @@
 		}
 		ccs_put();
 		fclose(fp);
-	} else {
-		ccs_set_error(CCS_PROC_POLICY_DOMAIN_POLICY);
 	}
 
 	max_index = ccs_dp.list_len;
 
 	/* Load domain transition related entries and group entries. */
-	fp = NULL;
-	if (ccs_network_mode)
-		/* We can read after write. */
-		fp = ccs_editpolicy_open_write
-			(CCS_PROC_POLICY_EXCEPTION_POLICY);
-	else if (!ccs_offline_mode)
-		/* Don't set error message if failed. */
-		fp = fopen(CCS_PROC_POLICY_EXCEPTION_POLICY, "r+");
+	fp = ccs_editpolicy_open(CCS_PROC_POLICY_EXCEPTION_POLICY);
 	if (fp) {
 		fprintf(fp, "select transition_only\n");
 		if (ccs_network_mode)
 			fputc(0, fp);
 		fflush(fp);
-	} else {
-		fp = ccs_editpolicy_open_read
-			(CCS_PROC_POLICY_EXCEPTION_POLICY);
-	}
-	if (fp) {
 		ccs_get();
 		while (true) {
 			char *line = ccs_freadline_unpack(fp);
@@ -1529,8 +1470,6 @@
 		}
 		ccs_put();
 		fclose(fp);
-	} else {
-		ccs_set_error(CCS_PROC_POLICY_EXCEPTION_POLICY);
 	}
 
 	/*
@@ -1560,7 +1499,7 @@
 				continue;
 			/* Initializer under <kernel> is reachable. */
 			if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE &&
-			    parent.total_len == CCS_ROOT_NAME_LEN)
+			    !strchr(parent.name, ' '))
 				break;
 			ccs_dp.list[index].d_t = d_t;
 			continue;
@@ -1619,10 +1558,10 @@
 			= ccs_dp.list[index].string_ptr;
 		const int max_count = ccs_dp.list[index].string_count;
 		/*
-		 * Don't create source domain under <kernel> because
-		 * they will become target domains.
+		 * Don't create source domains under root of namespace
+		 * because they will become target domains.
 		 */
-		if (domainname->total_len == CCS_ROOT_NAME_LEN)
+		if (!strchr(domainname->name, ' '))
 			continue;
 		for (i = 0; i < max_count; i++) {
 			const struct ccs_path_info *cp = string_ptr[i];
@@ -1994,8 +1933,14 @@
 		const int index = ccs_editpolicy_get_current();
 		ccs_get();
 		ccs_eat_col = ptr->x;
-		line = ccs_shprintf("%s",
-				    ccs_eat(ccs_domain_name(&ccs_dp, index)));
+		if (index >= 0)
+			line = ccs_shprintf("%s",
+					    ccs_eat(ccs_domain_name(&ccs_dp,
+								    index)));
+		else
+			line = ccs_shprintf("%s does not exist or "
+					    "inaccessible.\n",
+					    current_namespace);
 		if (ccs_window_width < strlen(line))
 			line[ccs_window_width] = '\0';
 		move(2, 0);
@@ -2005,6 +1950,22 @@
 		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
 		ccs_put();
 	}
+	if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST ||
+	    ccs_current_screen == CCS_SCREEN_PROFILE_LIST ||
+	    ccs_current_screen == CCS_SCREEN_MANAGER_LIST) {
+		char *line;
+		ccs_get();
+		ccs_eat_col = ptr->x;
+		line = ccs_shprintf("%s", current_namespace);
+		if (ccs_window_width < strlen(line))
+			line[ccs_window_width] = '\0';
+		move(2, 0);
+		clrtoeol();
+		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		printw("%s", line);
+		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		ccs_put();
+	}
 	move(CCS_HEADER_LINES + ptr->y, 0);
 	ccs_editpolicy_line_draw();     /* add color */
 	refresh();
@@ -2182,8 +2143,7 @@
 	}
 	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
 		int i;
-		FILE *fp = ccs_editpolicy_open_write
-			(CCS_PROC_POLICY_DOMAIN_POLICY);
+		FILE *fp = ccs_editpolicy_open(CCS_PROC_POLICY_DOMAIN_POLICY);
 		if (!fp)
 			return;
 		for (i = 1; i < ccs_dp.list_len; i++) {
@@ -2195,7 +2155,7 @@
 		ccs_close_write(fp);
 	} else {
 		int i;
-		FILE *fp = ccs_editpolicy_open_write(ccs_policy_file);
+		FILE *fp = ccs_editpolicy_open(ccs_policy_file);
 		if (!fp)
 			return;
 		if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
@@ -2236,7 +2196,7 @@
 		goto out;
 	ccs_rl.count = ccs_add_history(line, ccs_rl.history, ccs_rl.count,
 				       ccs_rl.max);
-	fp = ccs_editpolicy_open_write(ccs_policy_file);
+	fp = ccs_editpolicy_open(ccs_policy_file);
 	if (!fp)
 		goto out;
 	switch (ccs_current_screen) {
@@ -2383,7 +2343,7 @@
 	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
+	fp = ccs_editpolicy_open(CCS_PROC_POLICY_DOMAIN_POLICY);
 	if (!fp)
 		goto out;
 	if (!ccs_domain_sort_type) {
@@ -2438,7 +2398,7 @@
 	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_PROFILE);
+	fp = ccs_editpolicy_open(CCS_PROC_POLICY_PROFILE);
 	if (!fp)
 		goto out;
 	for (index = 0; index < ccs_gacl_list_count; index++) {
@@ -2483,7 +2443,7 @@
 	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_STAT);
+	fp = ccs_editpolicy_open(CCS_PROC_POLICY_STAT);
 	if (!fp)
 		goto out;
 	for (index = 0; index < ccs_gacl_list_count; index++) {
@@ -2509,27 +2469,47 @@
  *
  * @current: Index in the domain policy.
  *
- * Returns true if next window is ACL list, false otherwise.
+ * Returns true if next window is ACL list or namespace list, false otherwise.
  */
 static _Bool ccs_select_acl_window(const int current)
 {
 	char *old_domain;
-	if (ccs_current_screen != CCS_SCREEN_DOMAIN_LIST || current == EOF)
+	if (current == EOF)
 		return false;
+	if (ccs_current_screen == CCS_SCREEN_NAMESPACE_LIST) {
+		free(current_namespace);
+		current_namespace = strdup(ccs_gacl_list[current].operand);
+		if (!current_namespace)
+			ccs_out_of_memory();
+		ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
+		return true;
+	}
+	if (ccs_current_screen != CCS_SCREEN_DOMAIN_LIST)
+		return false;
 	ccs_current_pid = 0;
 	if (ccs_domain_sort_type) {
 		ccs_current_pid = ccs_task_list[current].pid;
 	} else if (ccs_initializer_source(current)) {
 		struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
 		const int redirect_index = ccs_find_target_domain(current);
-		if (redirect_index == EOF)
-			return false;
-		ptr->current = redirect_index - ptr->y;
-		while (ptr->current < 0) {
-			ptr->current++;
-			ptr->y--;
+		if (redirect_index >= 0) {
+			ptr->current = redirect_index - ptr->y;
+			while (ptr->current < 0) {
+				ptr->current++;
+				ptr->y--;
+			}
+			ccs_show_list();
 		}
-		ccs_show_list();
+		if (redirect_index == -2) {
+			free(current_namespace);
+			current_namespace =
+				strdup(ccs_get_last_word(ccs_dp.list[current].
+							 target_domainname));
+			if (!current_namespace)
+				ccs_out_of_memory();
+			ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
+			return true;
+		}
 		return false;
 	} else if (ccs_deleted_domain(current)) {
 		return false;
@@ -2544,6 +2524,7 @@
 	ccs_no_restore_cursor = old_domain &&
 		strcmp(old_domain, ccs_current_domain);
 	free(old_domain);
+	ccs_current_screen = CCS_SCREEN_ACL_LIST;
 	return true;
 }
 
@@ -2566,7 +2547,7 @@
 	printw("p     <<< Profile Editor >>>\n");
 	printw("m     <<< Manager Policy Editor >>>\n");
 	if (!ccs_offline_mode) {
-		/* printw("i     <<< Interactive Enforcing Mode >>>\n"); */
+		printw("n     <<< Namespace Selector >>>\n");
 		printw("s     <<< Statistics >>>\n");
 	}
 	printw("q     Quit this editor.\n");
@@ -2580,16 +2561,14 @@
 			return CCS_SCREEN_DOMAIN_LIST;
 		if (c == 'A' || c == 'a')
 			if (ccs_select_acl_window(current))
-				return CCS_SCREEN_ACL_LIST;
+				return ccs_current_screen;
 		if (c == 'P' || c == 'p')
 			return CCS_SCREEN_PROFILE_LIST;
 		if (c == 'M' || c == 'm')
 			return CCS_SCREEN_MANAGER_LIST;
 		if (!ccs_offline_mode) {
-			/*
-			if (c == 'I' || c == 'i')
-				return CCS_SCREEN_QUERY_LIST;
-			*/
+			if (c == 'N' || c == 'n')
+				return CCS_SCREEN_NAMESPACE_LIST;
 			if (c == 'S' || c == 's')
 				return CCS_SCREEN_STAT_LIST;
 		}
@@ -2692,9 +2671,9 @@
 	} else if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
 		ccs_policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
 		ccs_list_caption = "Domain Policy Editor";
-	} else if (ccs_current_screen == CCS_SCREEN_QUERY_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_QUERY;
-		ccs_list_caption = "Interactive Enforcing Mode";
+	} else if (ccs_current_screen == CCS_SCREEN_NAMESPACE_LIST) {
+		ccs_policy_file = CCS_PROC_POLICY_NAMESPACE;
+		ccs_list_caption = "Namespace Selector";
 	} else if (ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
 		ccs_policy_file = CCS_PROC_POLICY_PROFILE;
 		ccs_list_caption = "Profile Editor";
@@ -2841,6 +2820,7 @@
 			case CCS_SCREEN_ACL_LIST:
 			case CCS_SCREEN_PROFILE_LIST:
 			case CCS_SCREEN_MANAGER_LIST:
+			case CCS_SCREEN_NAMESPACE_LIST:
 				ccs_add_entry();
 				goto start;
 			default:
@@ -2850,7 +2830,7 @@
 		case '\r':
 		case '\n':
 			if (ccs_select_acl_window(current))
-				return CCS_SCREEN_ACL_LIST;
+				return ccs_current_screen;
 			break;
 		case 's':
 		case 'S':
@@ -2936,7 +2916,7 @@
  */
 static _Bool ccs_save_to_file(const char *src, const char *dest)
 {
-	FILE *proc_fp = ccs_editpolicy_open_read(src);
+	FILE *proc_fp = ccs_editpolicy_open(src);
 	FILE *file_fp = fopen(dest, "w");
 	if (!file_fp) {
 		fprintf(stderr, "Can't open %s\n", dest);
@@ -2973,6 +2953,11 @@
 				goto usage;
 			ccs_policy_dir = ptr;
 			ccs_offline_mode = true;
+		} else if (*ptr == '<') {
+			if (current_namespace || strchr(ptr, ' ') ||
+			    !ccs_domain_def(ptr))
+				goto usage;
+			current_namespace = strdup(ptr);
 		} else if (cp) {
 			*cp++ = '\0';
 			if (ccs_network_mode || ccs_offline_mode)
@@ -3004,6 +2989,8 @@
 			exit(1);
 		}
 	}
+	if (!current_namespace)
+		current_namespace = strdup("<kernel>");
 }
 
 /**
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_optimizer.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_optimizer.c	(revision 4951)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_optimizer.c	(working copy)
@@ -237,8 +237,10 @@
 		if (!cp)
 			return;
 		if (index == CCS_DIRECTIVE_IPC_SIGNAL && i == 1 &&
-		    !strncmp(buffer, "<kernel>", 8)) {
-			cp = buffer + 8;
+		    ccs_domain_def(buffer)) {
+			cp = strchr(buffer, ' ');
+			if (!cp)
+				return;
 			while (*cp) {
 				if (*cp++ != ' ' || *cp++ == '/')
 					continue;
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_offline.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_offline.c	(revision 4951)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_offline.c	(working copy)
@@ -94,7 +94,7 @@
 	memset(&ccs_dp, 0, sizeof(ccs_dp));
 	memset(&mp, 0, sizeof(mp));
 	ccs_get();
-	ccs_assign_domain(&ccs_dp, CCS_ROOT_NAME, false, false);
+	ccs_assign_domain(&ccs_dp, current_namespace, false, false);
 	while (true) {
 		FILE *fp;
 		struct msghdr msg;
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_keyword.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_keyword.c	(revision 4951)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_keyword.c	(working copy)
@@ -314,12 +314,15 @@
 	[CCS_DIRECTIVE_IPC_SIGNAL]    = { "ipc signal", NULL, 0, 0 },
 	[CCS_DIRECTIVE_KEEP_DOMAIN]   = { "keep_domain", NULL, 0, 0 },
 	[CCS_DIRECTIVE_MISC_ENV]      = { "misc env", NULL, 0, 0 },
+	[CCS_DIRECTIVE_MOVE_NAMESPACE] = { "move_namespace", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NETWORK_INET]  = { "network inet", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NETWORK_UNIX]  = { "network unix", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NONE]          = { "", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN]
 	= { "no_initialize_domain", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NO_KEEP_DOMAIN] = { "no_keep_domain", NULL, 0, 0 },
+	[CCS_DIRECTIVE_NO_MOVE_NAMESPACE]
+	= { "no_move_namespace", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NUMBER_GROUP]  = { "number_group", NULL, 0, 0 },
 	[CCS_DIRECTIVE_PATH_GROUP]    = { "path_group", NULL, 0, 0 },
 	[CCS_DIRECTIVE_QUOTA_EXCEEDED] = { "quota_exceeded", NULL, 0, 0 },
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.h
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.h	(revision 4951)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.h	(working copy)
@@ -29,13 +29,15 @@
 	CCS_SCREEN_ACL_LIST,
 	CCS_SCREEN_PROFILE_LIST,
 	CCS_SCREEN_MANAGER_LIST,
-	CCS_SCREEN_QUERY_LIST,
+	CCS_SCREEN_NAMESPACE_LIST,
 	CCS_SCREEN_STAT_LIST,
 	CCS_MAXSCREEN
 };
 
 enum ccs_transition_type {
 	/* Do not change this order, */
+	CCS_TRANSITION_CONTROL_NO_MOVE,
+	CCS_TRANSITION_CONTROL_MOVE,
 	CCS_TRANSITION_CONTROL_NO_INITIALIZE,
 	CCS_TRANSITION_CONTROL_INITIALIZE,
 	CCS_TRANSITION_CONTROL_NO_KEEP,
@@ -334,10 +336,12 @@
 	CCS_DIRECTIVE_IPC_SIGNAL,
 	CCS_DIRECTIVE_KEEP_DOMAIN,
 	CCS_DIRECTIVE_MISC_ENV,
+	CCS_DIRECTIVE_MOVE_NAMESPACE,
 	CCS_DIRECTIVE_NETWORK_INET,
 	CCS_DIRECTIVE_NETWORK_UNIX,
 	CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN,
 	CCS_DIRECTIVE_NO_KEEP_DOMAIN,
+	CCS_DIRECTIVE_NO_MOVE_NAMESPACE,
 	CCS_DIRECTIVE_NUMBER_GROUP,
 	CCS_DIRECTIVE_PATH_GROUP,
 	CCS_DIRECTIVE_QUOTA_EXCEEDED,
@@ -439,6 +443,7 @@
 void ccs_editpolicy_sttr_restore(void);
 void ccs_editpolicy_sttr_save(void);
 
+extern char *current_namespace;
 extern enum ccs_screen_type ccs_current_screen;
 extern int ccs_gacl_list_count;
 extern int ccs_list_item_count;
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c	(revision 4951)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c	(working copy)
@@ -286,22 +286,6 @@
 }
 
 /**
- * ccs_domain_def - Check whether the given token can be a domainname.
- *
- * @domainname: The token to check.
- *
- * Returns true if @domainname possibly be a domainname, false otherwise.
- *
- * Note that this function in kernel source checks only !strncmp() part.
- */
-_Bool ccs_domain_def(const char *domainname)
-{
-	return !strncmp(domainname, CCS_ROOT_NAME, CCS_ROOT_NAME_LEN) &&
-		(domainname[CCS_ROOT_NAME_LEN] == '\0'
-		 || domainname[CCS_ROOT_NAME_LEN] == ' ');
-}
-
-/**
  * ccs_fprintf_encoded - fprintf() using TOMOYO's escape rules.
  *
  * @fp:       Pointer to "FILE".
@@ -481,6 +465,29 @@
 }
 
 /**
+ * ccs_domain_def - Check whether the given token can be a domainname.
+ *
+ * @buffer: The token to check.
+ *
+ * Returns true if @buffer possibly be a domainname, false otherwise.
+ */
+_Bool ccs_domain_def(const char *buffer)
+{
+	const char *cp;
+	int len;
+	if (*buffer != '<')
+		return false;
+	cp = strchr(buffer, ' ');
+	if (!cp)
+		len = strlen(buffer);
+	else
+		len = cp - buffer;
+	if (buffer[len - 1] != '>' || !ccs_correct_word2(buffer + 1, len - 2))
+		return false;
+	return true;
+}
+
+/**
  * ccs_correct_domain - Check whether the given domainname follows the naming rules.
  *
  * @domainname: The domainname to check.
@@ -489,14 +496,11 @@
  */
 _Bool ccs_correct_domain(const char *domainname)
 {
-	if (!domainname || strncmp(domainname, CCS_ROOT_NAME,
-				   CCS_ROOT_NAME_LEN))
-		goto out;
-	domainname += CCS_ROOT_NAME_LEN;
-	if (!*domainname)
+	if (!domainname || !ccs_domain_def(domainname))
+		return false;
+	domainname = strchr(domainname, ' ');
+	if (!domainname++)
 		return true;
-	if (*domainname++ != ' ')
-		goto out;
 	while (1) {
 		const char *cp = strchr(domainname, ' ');
 		if (!cp)
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/Makefile
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/Makefile	(revision 4951)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/Makefile	(working copy)
@@ -15,8 +15,8 @@
 	sleep 10
 
 libccstools.so: ccstools.c ccstools.h
-	$(CC) $(CFLAGS) -fPIC ccstools.c -shared -Wl,-soname,libccstools.so.1 -o libccstools.so.1.0.3
-	ln -sf libccstools.so.1.0.3 libccstools.so
+	$(CC) $(CFLAGS) -fPIC ccstools.c -shared -Wl,-soname,libccstools.so.1 -o libccstools.so.1.0.4
+	ln -sf libccstools.so.1.0.4 libccstools.so
 
 .c:
 	$(CC) $(CFLAGS) -o $@ -lccstools -L. $<
@@ -29,8 +29,8 @@
 
 install: all
 	mkdir -p -m 0755 $(INSTALLDIR)$(USRLIBDIR)
-	$(INSTALL) -m 0755 libccstools.so.1.0.3 $(INSTALLDIR)$(USRLIBDIR)
-	ln -sf libccstools.so.1.0.3 $(INSTALLDIR)$(USRLIBDIR)/libccstools.so.1
+	$(INSTALL) -m 0755 libccstools.so.1.0.4 $(INSTALLDIR)$(USRLIBDIR)
+	ln -sf libccstools.so.1.0.4 $(INSTALLDIR)$(USRLIBDIR)/libccstools.so.1
 ifeq ($(INSTALLDIR),)
 	ldconfig || true
 endif
Index: trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/init_policy.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/init_policy.c	(revision 4951)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/init_policy.c	(working copy)
@@ -537,7 +537,7 @@
  */
 static void make_initializers(void)
 {
-	static const char const *files[] = {
+	static const char * const files[] = {
 		"/sbin/cardmgr",
 		"/sbin/getty",
 		"/sbin/init",
@@ -1277,10 +1277,12 @@
 "keyword_alias ipc signal                    = ipc signal\n"
 "keyword_alias keep_domain                   = keep_domain\n"
 "keyword_alias misc env                      = misc env\n"
+"keyword_alias move_namespace                = move_namespace\n"
 "keyword_alias network inet                  = network inet\n"
 "keyword_alias network unix                  = network unix\n"
 "keyword_alias no_initialize_domain          = no_initialize_domain\n"
 "keyword_alias no_keep_domain                = no_keep_domain\n"
+"keyword_alias no_move_namespace             = no_move_namespace\n"
 "keyword_alias number_group                  = number_group\n"
 "keyword_alias path_group                    = path_group\n"
 "keyword_alias quota_exceeded                = quota_exceeded\n"
Index: trunk/1.8.x/ccs-tools/ccstools/sbin/ccs-init.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/sbin/ccs-init.c	(revision 4951)
+++ trunk/1.8.x/ccs-tools/ccstools/sbin/ccs-init.c	(working copy)
@@ -242,9 +242,9 @@
 		return;
 	while (memset(buffer, 0, sizeof(buffer)) &&
 	       fgets(buffer, sizeof(buffer) - 1, fp)) {
-		if (!strncmp(buffer, "<kernel>", 8))
+		if (buffer[0] == '<')
 			domain++;
-		else if (buffer[0] && strcmp(buffer, "use_profile"))
+		else if (buffer[0] && strncmp(buffer, "use_", 4))
 			acl++;
 	}
 	fclose(fp);
