Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(revision 1891)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(working copy)
@@ -47,12 +47,20 @@
 #define SYSTEM_POLICY_FILE    "system_policy"
 #define EXCEPTION_POLICY_FILE "exception_policy"
 #define DOMAIN_POLICY_FILE    "domain_policy"
+#define PROFILE_POLICY_FILE   "profile"
+#define MANAGER_POLICY_FILE   "manager"
+#define QUERY_POLICY_FILE     "query"
+#define MEMINFO_POLICY_FILE   "meminfo"
 
 #define SCREEN_SYSTEM_LIST    0
 #define SCREEN_EXCEPTION_LIST 1
 #define SCREEN_DOMAIN_LIST    2
 #define SCREEN_ACL_LIST       3
-#define MAXSCREEN             4
+#define SCREEN_PROFILE_LIST   4
+#define SCREEN_MANAGER_LIST   5
+#define SCREEN_QUERY_LIST     6
+#define SCREEN_MEMINFO_LIST   7
+#define MAXSCREEN             8
 
 #define POLICY_TYPE_UNKNOWN          0
 #define POLICY_TYPE_DOMAIN_POLICY    1
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(revision 1891)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(working copy)
@@ -1452,6 +1452,15 @@
 	return strcmp(a2, b2);
 }
 
+static int string_acl_compare(const void *a, const void *b)
+{
+	const struct generic_acl *a0 = (struct generic_acl *) a;
+	const struct generic_acl *b0 = (struct generic_acl *) b;
+	const char *a2 = a0->operand;
+	const char *b2 = b0->operand;
+	return strcmp(a2, b2);
+}
+
 static void read_generic_policy(void)
 {
 	FILE *fp = NULL;
@@ -1487,9 +1496,16 @@
 			if (!shared_buffer[0])
 				continue;
 		}
-		directive = find_directive(true, shared_buffer);
-		if (directive == DIRECTIVE_NONE)
-			continue;
+		switch (current_screen) {
+		case SCREEN_SYSTEM_LIST:
+		case SCREEN_EXCEPTION_LIST:
+		case SCREEN_ACL_LIST:
+			directive = find_directive(true, shared_buffer);
+			if (directive == DIRECTIVE_NONE)
+				continue;
+		default:
+			directive = DIRECTIVE_NONE;
+		}
 		generic_acl_list = realloc(generic_acl_list,
 					   (generic_acl_list_count + 1) *
 					   sizeof(struct generic_acl));
@@ -1503,14 +1519,21 @@
 		generic_acl_list[generic_acl_list_count++].operand = cp;
 	}
 	put();
-	if (current_screen == SCREEN_ACL_LIST)
+	fclose(fp);
+	switch (current_screen) {
+	case SCREEN_ACL_LIST:
 		qsort(generic_acl_list, generic_acl_list_count,
 		      sizeof(struct generic_acl), generic_acl_compare);
-	else
+		break;
+	case SCREEN_SYSTEM_LIST:
+	case SCREEN_EXCEPTION_LIST:
 		qsort(generic_acl_list, generic_acl_list_count,
 		      sizeof(struct generic_acl), generic_acl_compare0);
-
-	fclose(fp);
+		break;
+	default:
+		qsort(generic_acl_list, generic_acl_list_count,
+		      sizeof(struct generic_acl), string_acl_compare);
+	}
 }
 
 static int add_domain_initializer_entry(const char *domainname,
@@ -2091,16 +2114,16 @@
 	const char *sp;
 	const int number = proc_domain_list[index].number;
 	int redirect_index;
+	move(header_lines + i, 0);
 	if (number >= 0)
-		mvprintw(header_lines + i, 0,
-			 "%c%4d:%3u %c%c%c ",
+		printw("%c%4d:%3u %c%c%c ",
 			 proc_domain_list_selected[index] ? '&' : ' ',
 			 number, proc_domain_list[index].profile,
 			 is_keeper_domain(index) ? '#' : ' ',
 			 is_initializer_target(index) ? '*' : ' ',
 			 is_domain_unreachable(index) ? '!' : ' ');
 	else
-		mvprintw(header_lines + i, 0, "              ");
+		printw("              ");
 	tmp_col += 14;
 	sp = domain_name(index);
 	while (true) {
@@ -2185,15 +2208,26 @@
 	const char *cp1 = directives[directive].alias;
 	const char *cp2 = generic_acl_list[index].operand;
 	int len = list_indent - directives[directive].alias_len;
-	mvprintw(header_lines + i, 0, "%c%4d: %s ",
-		 generic_acl_list[index].selected ? '&' : ' ',
-		 index, eat(cp1));
+	move(header_lines + i, 0);
+	printw("%c%4d: %s ",
+	       generic_acl_list[index].selected ? '&' : ' ',
+	       index, eat(cp1));
 	while (len-- > 0)
 		printw("%s", eat(" "));
 	printw("%s", eat(cp2));
 	return strlen(cp1) + strlen(cp2) + 8 + list_indent;
 }
 
+static int show_literal_line(int i, int index)
+{
+	const char *cp = generic_acl_list[index].operand;
+	move(header_lines + i, 0);
+	printw("%c%4d: %s ",
+	       generic_acl_list[index].selected ? '&' : ' ',
+	       index, eat(cp));
+	return strlen(cp) + 8;
+}
+
 static void show_list(void)
 {
 	const int offset = current_item_index[current_screen];
@@ -2204,10 +2238,10 @@
 	else
 		list_item_count[current_screen] = generic_acl_list_count;
 	clear();
+	move(0, 0);
 	if (window_height < header_lines + 1) {
-		mvprintw(0, 0, "Please resize window. "
-			 "This program needs at least %d lines.\n",
-			 header_lines + 1);
+		printw("Please enlarge window.");
+		clrtobot();
 		refresh();
 		return;
 	}
@@ -2216,14 +2250,14 @@
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		i = list_item_count[SCREEN_DOMAIN_LIST]
 			- unnumbered_domain_count;
-		mvprintw(0, 0, "<<< Domain Transition Editor >>>"
-			 "      %d domain%c    '?' for help",
-			 i, i > 1 ? 's' : ' ');
+		printw("<<< Domain Transition Editor >>>"
+		       "      %d domain%c    '?' for help",
+		       i, i > 1 ? 's' : ' ');
 	} else {
 		i = list_item_count[current_screen];
-		mvprintw(0, 0, "<<< %s Editor >>>"
-			 "      %d entr%s    '?' for help", list_caption,
-			 i, i > 1 ? "ies" : "y");
+		printw("<<< %s >>>"
+		       "      %d entr%s    '?' for help", list_caption,
+		       i, i > 1 ? "ies" : "y");
 	}
 	/* add color */
 	editpolicy_color_change(editpolicy_color_head(current_screen), false);
@@ -2235,28 +2269,41 @@
 		snprintf(shared_buffer, shared_buffer_len - 1, "%s",
 			 eat(current_domain));
 		editpolicy_attr_change(A_REVERSE, true);  /* add color */
-		mvprintw(2, 0, "%s", shared_buffer);
+		move(2, 0);
+		printw("%s", shared_buffer);
 		editpolicy_attr_change(A_REVERSE, false); /* add color */
 		put();
 	}
-	if (current_screen != SCREEN_DOMAIN_LIST) {
-		list_indent = 0;
+	list_indent = 0;
+	switch (current_screen) {
+	case SCREEN_SYSTEM_LIST:
+	case SCREEN_EXCEPTION_LIST:
+	case SCREEN_ACL_LIST:
 		for (i = 0; i < list_item_count[current_screen]; i++) {
 			const u8 directive = generic_acl_list[i].directive;
 			const int len = directives[directive].alias_len;
 			if (len > list_indent)
 				list_indent = len;
 		}
+		break;
 	}
 	for (i = 0; i < body_lines; i++) {
 		const int index = offset + i;
 		eat_col = max_eat_col[current_screen];
 		if (index >= list_item_count[current_screen])
 			break;
-		if (current_screen == SCREEN_DOMAIN_LIST)
+		switch (current_screen) {
+		case SCREEN_DOMAIN_LIST:
 			tmp_col = show_domain_line(i, index);
-		else
+			break;
+		case SCREEN_SYSTEM_LIST:
+		case SCREEN_EXCEPTION_LIST:
+		case SCREEN_ACL_LIST:
 			tmp_col = show_acl_line(i, index, list_indent);
+			break;
+		default:
+			tmp_col = show_literal_line(i, index);
+		}
 		clrtoeol();
 		tmp_col -= window_width;
 		if (tmp_col > max_col)
@@ -2358,8 +2405,8 @@
 
 /* add color start */
 #ifdef COLOR_ON
-static int before_current[MAXSCREEN] = { -1, -1, -1, -1 };
-static int before_y[MAXSCREEN]       = { -1, -1, -1, -1 };
+static int before_current[MAXSCREEN] = { -1, -1, -1, -1, -1, -1, -1, -1 };
+static int before_y[MAXSCREEN]       = { -1, -1, -1, -1, -1, -1, -1, -1 };
 
 static void editpolicy_line_draw(void)
 {
@@ -2934,27 +2981,40 @@
 	if (!line || !*line)
 		goto out;
 	rl->count = simple_add_history(line, rl->history, rl->count, rl->max);
-	if (current_screen == SCREEN_DOMAIN_LIST && !is_correct_domain(line)) {
-		const int len = strlen(line) + 128;
-		rl->last_error = realloc(rl->last_error, len);
-		if (!rl->last_error)
-			out_of_memory();
-		memset(rl->last_error, 0, len);
-		snprintf(rl->last_error, len - 1,
-			 "%s is an invalid domainname.", line);
-	} else {
+	FILE *fp = open_write(policy_file);
+	if (!fp)
+		goto out;
+	switch (current_screen) {
 		u8 directive;
-		FILE *fp = open_write(policy_file);
-		if (!fp)
-			goto out;
-		if (current_screen == SCREEN_ACL_LIST)
-			fprintf(fp, "select %s\n", current_domain);
+	case SCREEN_DOMAIN_LIST:
+		if (!is_correct_domain(line)) {
+			const int len = strlen(line) + 128;
+			rl->last_error = realloc(rl->last_error, len);
+			if (!rl->last_error)
+				out_of_memory();
+			memset(rl->last_error, 0, len);
+			snprintf(rl->last_error, len - 1,
+				 "%s is an invalid domainname.", line);
+			line[0] = '\0';
+		}
+		break;
+	case SCREEN_ACL_LIST:
+		fprintf(fp, "select %s\n", current_domain);
+		/* Fall through. */
+	case SCREEN_SYSTEM_LIST:
+	case SCREEN_EXCEPTION_LIST:
 		directive = find_directive(false, line);
 		if (directive != DIRECTIVE_NONE)
-			fprintf(fp, "%s ", directives[directive].original);
-		fprintf(fp, "%s\n", line);
-		fclose(fp);
+			fprintf(fp, "%s ",
+				directives[directive].original);
+		break;
+	case SCREEN_PROFILE_LIST:
+		if (!strchr(line, '='))
+			fprintf(fp, "%s-COMMENT=\n", line);
+		break;
 	}
+	fprintf(fp, "%s\n", line);
+	fclose(fp);
 out:
 	free(line);
 }
@@ -2970,7 +3030,7 @@
 		goto start_search;
 	editpolicy_attr_change(A_BOLD, true);  /* add color */
 	line = simple_readline(window_height - 1, 0, "Search> ",
-			       rl->history, rl->count, 4000, 8);
+			       rl->history, rl->count, 8192, 8);
 	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
@@ -3015,11 +3075,10 @@
 	int index;
 	FILE *fp;
 	char *line;
-	if (current_screen != SCREEN_DOMAIN_LIST)
-		return;
 	if (!count(proc_domain_list_selected, proc_domain_list_count) &&
 	    !select_item(current)) {
-		mvprintw(1, 0, "Select domain using Space key first.");
+		move(1, 0);
+		printw("Select domain using Space key first.");
 		clrtoeol();
 		refresh();
 		return;
@@ -3044,42 +3103,192 @@
 	free(line);
 }
 
+static void set_level(int current)
+{
+	int index;
+	FILE *fp;
+	char *line;
+	if (!count2(generic_acl_list, generic_acl_list_count))
+		select_item(current);
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
+	line = simple_readline(window_height - 1, 0, "Enter new value> ",
+			       NULL, 0, 8192, 1);
+	editpolicy_attr_change(A_BOLD, false); /* add color */
+	if (!line || !*line)
+		goto out;
+	fp = open_write(PROFILE_POLICY_FILE);
+	if (!fp)
+		goto out;
+	for (index = 0; index < generic_acl_list_count; index++) {
+		char *cp;
+		if (!generic_acl_list[index].selected)
+			continue;
+		get();
+		strncpy(shared_buffer, generic_acl_list[index].operand,
+			shared_buffer_len - 1);
+		cp = strchr(shared_buffer, '=');
+		if (cp)
+			*cp = '\0';
+		fprintf(fp, "%s=%s\n", shared_buffer, line);
+		put();
+	}
+	fclose(fp);
+out:
+	free(line);
+}
+
+static void set_quota(int current)
+{
+	int index;
+	FILE *fp;
+	char *line;
+	if (!count2(generic_acl_list, generic_acl_list_count))
+		select_item(current);
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
+	line = simple_readline(window_height - 1, 0, "Enter new value> ",
+			       NULL, 0, 20, 1);
+	editpolicy_attr_change(A_BOLD, false); /* add color */
+	if (!line || !*line)
+		goto out;
+	fp = open_write(MEMINFO_POLICY_FILE);
+	if (!fp)
+		goto out;
+	for (index = 0; index < generic_acl_list_count; index++) {
+		char *cp;
+		if (!generic_acl_list[index].selected)
+			continue;
+		get();
+		strncpy(shared_buffer, generic_acl_list[index].operand,
+			shared_buffer_len - 1);
+		cp = strchr(shared_buffer, ':');
+		if (cp)
+			*cp = '\0';
+		fprintf(fp, "%s: %s\n", shared_buffer, line);
+		put();
+	}
+	fclose(fp);
+out:
+	free(line);
+}
+
+static int select_window(const int current)
+{
+	move(0, 0);
+	printw("Press one of below keys to switch window.\n\n");
+	printw("s     <<< System Policy Editor >>>\n");
+	printw("e     <<< Exception Policy Editor >>>\n");
+	printw("d     <<< Domain Transition Editor >>>\n");
+	if (current_screen == SCREEN_DOMAIN_LIST &&
+	    !is_initializer_source(current) &&
+	    !is_deleted_domain(current))
+		printw("a     <<< Domain Policy Editor >>>\n");
+	printw("p     <<< Profile Editor >>>\n");
+	printw("m     <<< Manager Policy Editor >>>\n");
+	if (!offline_mode) {
+		/* printw("i     <<< Interactive Enforcing Mode >>>\n"); */
+		printw("q     <<< Memory Quota Editor >>>\n");
+	}
+	clrtobot();
+	refresh();
+	while (true) {
+		int c = getch2();
+		if (c == 'S' || c == 's')
+			return SCREEN_SYSTEM_LIST;
+		if (c == 'E' || c == 'e')
+			return SCREEN_EXCEPTION_LIST;
+		if (c == 'D' || c == 'd')
+			return SCREEN_DOMAIN_LIST;
+		if (c == 'A' || c == 'a') {
+			if (current_screen == SCREEN_DOMAIN_LIST &&
+			    !is_initializer_source(current) &&
+			    !is_deleted_domain(current)) {
+				free(current_domain);
+				current_domain = strdup(domain_name(current));
+				if (!current_domain)
+					out_of_memory();
+				return SCREEN_ACL_LIST;
+			}
+		}
+		if (c == 'P' || c == 'p')
+			return SCREEN_PROFILE_LIST;
+		if (c == 'M' || c == 'm')
+			return SCREEN_MANAGER_LIST;
+		if (!offline_mode) {
+			/*
+			if (c == 'I' || c == 'i')
+				return SCREEN_QUERY_LIST;
+			*/
+			if (c == 'Q' || c == 'q')
+				return SCREEN_MEMINFO_LIST;
+		}
+		if (c == EOF)
+			return MAXSCREEN;
+	}
+}
+
 static void show_command_key(void)
 {
 	int c;
 	clear();
-	printw("Commands available for this screen are:\n\n"
-	       "Q/q        Quit this editor.\n"
-	       "R/r        Refresh to the latest information.\n"
-	       "F/f        Find first.\n"
-	       "N/n        Find next.\n"
-	       "P/p        Find previous.\n"
-	       "Tab        Switch to next screen.\n"
-	       "Insert     Copy an entry at the cursor position to history "
-	       "buffer.\n"
-	       "Space      Invert selection state of an entry at the cursor "
-	       "position.\n"
-	       "C/c        Copy selection state of an entry at the cursor "
+	printw("Commands available for this screen are:\n\n");
+	printw("Q/q        Quit this editor.\n");
+	printw("R/r        Refresh to the latest information.\n");
+	switch (current_screen) {
+	case SCREEN_MEMINFO_LIST:
+		break;
+	default:
+		printw("F/f        Find first.\n");
+		printw("N/n        Find next.\n");
+		printw("P/p        Find previous.\n");
+	}
+	printw("W/w        Switch to selected screen.\n");
+	/* printw("Tab        Switch to next screen.\n"); */
+	switch (current_screen) {
+	case SCREEN_MEMINFO_LIST:
+		break;
+	default:
+		printw("Insert     Copy an entry at the cursor position to history "
+		       "buffer.\n");
+	}
+	printw("Space      Invert selection state of an entry at the cursor "
+	       "position.\n");
+	printw("C/c        Copy selection state of an entry at the cursor "
 	       "position to all entries below the cursor position.\n");
-	if (current_screen != SCREEN_DOMAIN_LIST)
-		goto not_domain_list;
-	printw("A/a        Add a new domain.\n"
-	       "Enter      Edit ACLs of a domain at the cursor position.\n"
-	       "D/d        Delete selected domains.\n"
-	       "S/s        Set profile number of selected domains.\n");
-	goto wait_key;
-not_domain_list:
-	printw("A/a        Add a new entry.\n"
-	       "D/d        Delete selected entries.\n");
-	if (current_screen != SCREEN_ACL_LIST)
-		goto wait_key;
-	printw("O/o        Set selection state to other entries included in "
-	       "an entry at the cursor position.\n");
-	printw("@          Switch sort type.\n");
-wait_key:
+	switch (current_screen) {
+	case SCREEN_DOMAIN_LIST:
+		printw("A/a        Add a new domain.\n");
+		printw("Enter      Edit ACLs of a domain at the cursor position.\n");
+		printw("D/d        Delete selected domains.\n");
+		printw("S/s        Set profile number of selected domains.\n");
+		break;
+	case SCREEN_MEMINFO_LIST:
+		printw("S/s        Set memory quota of selected items.\n");
+		break;
+	case SCREEN_PROFILE_LIST:
+		printw("S/s        Set mode of selected items.\n");
+		break;
+	}
+	switch (current_screen) {
+	case SCREEN_SYSTEM_LIST:
+	case SCREEN_EXCEPTION_LIST:
+	case SCREEN_ACL_LIST:
+	case SCREEN_MANAGER_LIST:
+		printw("A/a        Add a new entry.\n");
+		printw("D/d        Delete selected entries.\n");
+	}
+	switch (current_screen) {
+	case SCREEN_PROFILE_LIST:
+		printw("A/a        Define a new profile.\n");
+	}
+	switch (current_screen) {
+	case SCREEN_ACL_LIST:
+		printw("O/o        Set selection state to other entries included in "
+		       "an entry at the cursor position.\n");
+		printw("@          Switch sort type.\n");
+	}
 	printw("Arrow-keys and PageUp/PageDown/Home/End keys "
-	       "for scroll.\n\n"
-	       "Press '?' to escape from this help.\n");
+	       "for scroll.\n\n");
+	printw("Press '?' to escape from this help.\n");
 	refresh();
 	while (true) {
 		c = getch2();
@@ -3105,16 +3314,28 @@
 	}
 	if (current_screen == SCREEN_SYSTEM_LIST) {
 		policy_file = SYSTEM_POLICY_FILE;
-		list_caption = "System Policy";
+		list_caption = "System Policy Editor";
 	} else if (current_screen == SCREEN_EXCEPTION_LIST) {
 		policy_file = EXCEPTION_POLICY_FILE;
-		list_caption = "Exception Policy";
+		list_caption = "Exception Policy Editor";
 	} else if (current_screen == SCREEN_ACL_LIST) {
 		policy_file = DOMAIN_POLICY_FILE;
-		list_caption = "Domain Policy";
+		list_caption = "Domain Policy Editor";
+	} else if (current_screen == SCREEN_QUERY_LIST) {
+		policy_file = QUERY_POLICY_FILE;
+		list_caption = "Interactive Enforcing Mode";
+	} else if (current_screen == SCREEN_PROFILE_LIST) {
+		policy_file = PROFILE_POLICY_FILE;
+		list_caption = "Profile Editor";
+	} else if (current_screen == SCREEN_MANAGER_LIST) {
+		policy_file = MANAGER_POLICY_FILE;
+		list_caption = "Manager Policy Editor";
+	} else if (current_screen == SCREEN_MEMINFO_LIST) {
+		policy_file = MEMINFO_POLICY_FILE;
+		list_caption = "Memory Quota Editor";
 	} else {
 		policy_file = DOMAIN_POLICY_FILE;
-		/* list_caption = "Domain Transition"; */
+		/* list_caption = "Domain Transition Editor"; */
 	}
 	current_item_index[current_screen]
 		= saved_current_item_index[current_screen];
@@ -3130,7 +3351,8 @@
 start2:
 	show_list();
 	if (rl.last_error && current_screen == SCREEN_DOMAIN_LIST) {
-		mvprintw(1, 0, "ERROR: %s", rl.last_error);
+		move(1, 0);
+		printw("ERROR: %s", rl.last_error);
 		clrtoeol();
 		refresh();
 		free(rl.last_error);
@@ -3210,10 +3432,13 @@
 			break;
 		case 'f':
 		case 'F':
-			find_entry(true, true, current, &rl);
+			if (current_screen != SCREEN_MEMINFO_LIST)
+				find_entry(true, true, current, &rl);
 			break;
 		case 'p':
 		case 'P':
+			if (current_screen == SCREEN_MEMINFO_LIST)
+				break;
 			if (!rl.search_buffer[current_screen])
 				find_entry(true, false, current, &rl);
 			else
@@ -3221,6 +3446,8 @@
 			break;
 		case 'n':
 		case 'N':
+			if (current_screen == SCREEN_MEMINFO_LIST)
+				break;
 			if (!rl.search_buffer[current_screen])
 				find_entry(true, true, current, &rl);
 			else
@@ -3228,12 +3455,28 @@
 			break;
 		case 'd':
 		case 'D':
-			delete_entry(current);
-			goto start;
+			switch (current_screen) {
+			case SCREEN_SYSTEM_LIST:
+			case SCREEN_EXCEPTION_LIST:
+			case SCREEN_ACL_LIST:
+			case SCREEN_DOMAIN_LIST:
+			case SCREEN_PROFILE_LIST:
+				delete_entry(current);
+				goto start;
+			}
+			break;
 		case 'a':
 		case 'A':
-			add_entry(&rl);
-			goto start;
+			switch (current_screen) {
+			case SCREEN_SYSTEM_LIST:
+			case SCREEN_EXCEPTION_LIST:
+			case SCREEN_ACL_LIST:
+			case SCREEN_DOMAIN_LIST:
+			case SCREEN_PROFILE_LIST:
+				add_entry(&rl);
+				goto start;
+			}
+			break;
 		case '\r':
 		case '\n':
 			if (current_screen != SCREEN_DOMAIN_LIST)
@@ -3268,8 +3511,18 @@
 			break;
 		case 's':
 		case 'S':
-			set_profile(current);
-			goto start;
+			switch (current_screen) {
+			case SCREEN_DOMAIN_LIST:
+				set_profile(current);
+				goto start;
+			case SCREEN_PROFILE_LIST:
+				set_level(current);
+				goto start;
+			case SCREEN_MEMINFO_LIST:
+				set_quota(current);
+				goto start;
+			}
+			break;
 		case 'r':
 		case 'R':
 			goto start;
@@ -3291,15 +3544,27 @@
 			if (current == EOF)
 				break;
 			get();
-			if (current_screen == SCREEN_DOMAIN_LIST)
+			switch (current_screen) {
+				u8 directive;
+			case SCREEN_DOMAIN_LIST:
 				line = domain_name(current);
-			else {
-				const u8 directive
-					= generic_acl_list[current].directive;
+				break;
+			case SCREEN_SYSTEM_LIST:
+			case SCREEN_EXCEPTION_LIST:
+			case SCREEN_ACL_LIST:
+				directive = generic_acl_list[current].directive;
 				snprintf(shared_buffer, shared_buffer_len - 1,
 					 "%s %s", directives[directive].alias,
 					 generic_acl_list[current].operand);
 				line = shared_buffer;
+				break;
+			case SCREEN_MEMINFO_LIST:
+				line = NULL;
+				break;
+			default:
+				snprintf(shared_buffer, shared_buffer_len - 1,
+					 "%s", generic_acl_list[current].operand);
+				line = shared_buffer;
 			}
 			rl.count = simple_add_history(line, rl.history,
 						      rl.count, rl.max);
@@ -3315,6 +3580,9 @@
 				break;
 			sort_type = (sort_type + 1) % 2;
 			goto start;
+		case 'w':
+		case 'W':
+			return select_window(current);
 		case '?':
 			show_command_key();
 			goto start;
@@ -3379,10 +3647,10 @@
 	}
 }
 
-static void handle_exception_policy(FILE *fp, bool is_write)
+static void handle_misc_policy(FILE *fp, bool is_write, const int index)
 {
-	static const struct path_info **exception_list = NULL;
-	static int exception_list_count = 0;
+	static const struct path_info **list[4] = { NULL, NULL, NULL, NULL };
+	static int list_count[4] = { 0, 0, 0, 0 };
 	int i;
 	if (!is_write)
 		goto read_policy;
@@ -3395,74 +3663,30 @@
 			goto append_policy;
 		path.name = shared_buffer;
 		fill_path_info(&path);
-		for (i = 0; i < exception_list_count; i++) {
-			if (pathcmp(exception_list[i], &path))
+		for (i = 0; i < list_count[index]; i++) {
+			if (pathcmp(list[index][i], &path))
 				continue;
-			for (exception_list_count--;
-			     i < exception_list_count; i++)
-				exception_list[i]
-					= exception_list[i + 1];
+			for (list_count[index]--; i < list_count[index]; i++)
+				list[index][i] = list[index][i + 1];
 			break;
 		}
 		continue;
 append_policy:
-		exception_list = realloc(exception_list,
-					 (exception_list_count + 1)
-					 * sizeof(const struct path_info *));
-		if (!exception_list)
+		list[index] = realloc(list[index], (list_count[index] + 1)
+				      * sizeof(const struct path_info *));
+		if (!list[index])
 			out_of_memory();
 		cp = savename(shared_buffer);
 		if (!cp)
 			out_of_memory();
-		exception_list[exception_list_count++] = cp;
+		list[index][list_count[index]++] = cp;
 	}
 	return;
 read_policy:
-	for (i = 0; i < exception_list_count; i++)
-		fprintf(fp, "%s\n", exception_list[i]->name);
+	for (i = 0; i < list_count[index]; i++)
+		fprintf(fp, "%s\n", list[index][i]->name);
 }
 
-static void handle_system_policy(FILE *fp, bool is_write)
-{
-	static const struct path_info **system_list = NULL;
-	static int system_list_count = 0;
-	int i;
-	if (!is_write)
-		goto read_policy;
-	while (freadline(fp)) {
-		struct path_info path;
-		const struct path_info *cp;
-		if (!shared_buffer[0])
-			continue;
-		if (!str_starts(shared_buffer, "delete "))
-			goto append_policy;
-		path.name = shared_buffer;
-		fill_path_info(&path);
-		for (i = 0; i < system_list_count; i++) {
-			if (pathcmp(system_list[i], &path))
-				continue;
-			for (system_list_count--;
-			     i < system_list_count; i++)
-				system_list[i] = system_list[i + 1];
-			break;
-		}
-		continue;
-append_policy:
-		system_list = realloc(system_list, (system_list_count + 1)
-				      * sizeof(struct path_info *));
-		if (!system_list)
-			out_of_memory();
-		cp = savename(shared_buffer);
-		if (!cp)
-			out_of_memory();
-		system_list[system_list_count++] = cp;
-	}
-	return;
-read_policy:
-	for (i = 0; i < system_list_count; i++)
-		fprintf(fp, "%s\n", system_list[i]->name);
-}
-
 static void policy_daemon(void)
 {
 	get();
@@ -3501,16 +3725,24 @@
 			if (!strcmp(shared_buffer, "domain_policy"))
 				handle_domain_policy(fp, true);
 			else if (!strcmp(shared_buffer, "exception_policy"))
-				handle_exception_policy(fp, true);
+				handle_misc_policy(fp, true, 0);
 			else if (!strcmp(shared_buffer, "system_policy"))
-				handle_system_policy(fp, true);
+				handle_misc_policy(fp, true, 1);
+			else if (!strcmp(shared_buffer, "profile"))
+				handle_misc_policy(fp, true, 2);
+			else if (!strcmp(shared_buffer, "manager"))
+				handle_misc_policy(fp, true, 3);
 		} else if (str_starts(shared_buffer, "GET ")) {
 			if (!strcmp(shared_buffer, "domain_policy"))
 				handle_domain_policy(fp, false);
 			else if (!strcmp(shared_buffer, "exception_policy"))
-				handle_exception_policy(fp, false);
+				handle_misc_policy(fp, false, 0);
 			else if (!strcmp(shared_buffer, "system_policy"))
-				handle_system_policy(fp, false);
+				handle_misc_policy(fp, false, 1);
+			else if (!strcmp(shared_buffer, "profile"))
+				handle_misc_policy(fp, false, 2);
+			else if (!strcmp(shared_buffer, "manager"))
+				handle_misc_policy(fp, false, 3);
 		}
 		fclose(fp);
 	}
@@ -3544,8 +3776,12 @@
 			current_screen = SCREEN_EXCEPTION_LIST;
 		else if (!strcmp(argv[1], "d"))
 			current_screen = SCREEN_DOMAIN_LIST;
+		else if (!strcmp(argv[1], "p"))
+			current_screen = SCREEN_PROFILE_LIST;
+		else if (!strcmp(argv[1], "m"))
+			current_screen = SCREEN_MANAGER_LIST;
 		else {
-			printf("Usage: %s [s|e|d]\n", argv[0]);
+			printf("Usage: %s [s|e|d|p|m]\n", argv[0]);
 			return 1;
 		}
 	}
@@ -3625,6 +3861,34 @@
 				fclose(fp);
 				close(fd);
 			}
+			fd = open(base_policy_profile, O_RDONLY);
+			if (fd != EOF) {
+				FILE *fp = open_write(PROFILE_POLICY_FILE);
+				copy_fd_to_fp(fd, fp);
+				fclose(fp);
+				close(fd);
+			}
+			fd = open(disk_policy_profile, O_RDONLY);
+			if (fd != EOF) {
+				FILE *fp = open_write(PROFILE_POLICY_FILE);
+				copy_fd_to_fp(fd, fp);
+				fclose(fp);
+				close(fd);
+			}
+			fd = open(base_policy_manager, O_RDONLY);
+			if (fd != EOF) {
+				FILE *fp = open_write(MANAGER_POLICY_FILE);
+				copy_fd_to_fp(fd, fp);
+				fclose(fp);
+				close(fd);
+			}
+			fd = open(disk_policy_manager, O_RDONLY);
+			if (fd != EOF) {
+				FILE *fp = open_write(MANAGER_POLICY_FILE);
+				copy_fd_to_fp(fd, fp);
+				fclose(fp);
+				close(fd);
+			}
 		}
 	} else {
 		if (chdir(proc_policy_dir)) {
@@ -3716,6 +3980,26 @@
 				symlink(filename, "domain_policy.conf");
 			}
 		}
+		filename = make_filename("profile", now);
+		if (move_proc_to_file(NULL, open_read(PROFILE_POLICY_FILE),
+				      base_policy_profile, filename)) {
+			if (is_identical_file("profile.conf", filename)) {
+				unlink(filename);
+			} else {
+				unlink("profile.conf");
+				symlink(filename, "profile.conf");
+			}
+		}
+		filename = make_filename("manager", now);
+		if (move_proc_to_file(NULL, open_read(MANAGER_POLICY_FILE),
+				      base_policy_manager, filename)) {
+			if (is_identical_file("manager.conf", filename)) {
+				unlink(filename);
+			} else {
+				unlink("manager.conf");
+				symlink(filename, "manager.conf");
+			}
+		}
 	}
 	return 0;
 }
