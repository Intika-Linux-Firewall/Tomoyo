Index: branches/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- branches/ccs-patch/security/ccsecurity/internal.h	(revision 3845)
+++ branches/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -869,7 +869,7 @@
 	struct ccs_path_info entry;
 };
 
-#define CCS_MAX_IO_READ_QUEUE 32
+#define CCS_MAX_IO_READ_QUEUE 64
 
 /* Structure for reading/writing policy via /proc interfaces. */
 struct ccs_io_buffer {
Index: branches/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/policy_io.c	(revision 3845)
+++ branches/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -1286,28 +1286,48 @@
 	return false;
 }
 
-/**
- * ccs_fns - Find next set bit.
- *
- * @perm: 8 bits value.
- * @bit:  First bit to find.
- *
- * Returns next set bit on success, 8 otherwise.
- */
-static u8 ccs_fns(const u8 perm, u8 bit)
-{
-	for ( ; bit < 8; bit++)
-		if (perm & (1 << bit))
-			break;
-	return bit;
-}
-
 static void ccs_set_group(struct ccs_io_buffer *head)
 {
 	if (head->type == CCS_EXCEPTIONPOLICY)
 		ccs_io_printf(head, "acl_group %u ", head->r.group_index);
 }
 
+static void ccs_print_bits(struct ccs_io_buffer *head, const u16 perm,
+			   const char *keywords[]) {
+	u8 bit;
+	bool first = true;
+	for (bit = 0; bit < 16; bit++) {
+		if (!(perm & (1 << bit)))
+			continue;
+		if (!first)
+			ccs_set_string(head, "/");
+		first = false;
+		ccs_set_string(head, keywords[bit]);
+	}
+}
+
+static bool ccs_print_file_bits(struct ccs_io_buffer *head, const u16 perm,
+				const char *keywords[]) {
+	if (!perm)
+		return false;
+	ccs_set_group(head);
+	ccs_set_string(head, "file ");
+	ccs_print_bits(head, perm, keywords);
+	return true;
+}
+
+static bool ccs_print_network_bits(struct ccs_io_buffer *head,
+				   const char *protocol, const u8 perm) {
+	if (!perm)
+		return false;
+	ccs_set_group(head);
+	ccs_set_string(head, "network ");
+	ccs_set_string(head, protocol);
+	ccs_set_space(head);
+	ccs_print_bits(head, perm, ccs_net_keyword);
+	return true;
+}
+
 /**
  * ccs_print_entry - Print an ACL entry.
  *
@@ -1320,32 +1340,21 @@
 			    const struct ccs_acl_info *acl)
 {
 	const u8 acl_type = acl->type;
-	u8 bit;
 	if (head->r.print_cond_part)
 		goto print_cond_part;
 	if (acl->is_deleted)
 		return true;
- next:
-	bit = head->r.bit;
 	if (!ccs_flush(head))
 		return false;
 	else if (acl_type == CCS_TYPE_PATH_ACL) {
 		struct ccs_path_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		const u16 perm = ptr->perm;
-		for ( ; bit < CCS_MAX_PATH_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
-				continue;
-			if (head->r.print_execute_only &&
-			    bit != CCS_TYPE_EXECUTE && bit != CCS_TYPE_TRANSIT)
-				continue;
-			break;
-		}
-		if (bit >= CCS_MAX_PATH_OPERATION)
+		u16 perm = ptr->perm;
+		if (head->r.print_execute_only)
+			perm &= (1 << CCS_TYPE_EXECUTE) |
+				(1 << CCS_TYPE_TRANSIT);
+		if (!ccs_print_file_bits(head, perm, ccs_path_keyword))
 			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "file ");
-		ccs_set_string(head, ccs_path_keyword[bit]);
 		ccs_print_name_union(head, &ptr->name);
 	} else if (acl_type == CCS_TYPE_EXECUTE_HANDLER ||
 		   acl_type == CCS_TYPE_DENIED_EXECUTE_HANDLER) {
@@ -1362,12 +1371,8 @@
 	} else if (acl_type == CCS_TYPE_MKDEV_ACL) {
 		struct ccs_mkdev_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		bit = ccs_fns(ptr->perm, bit);
-		if (bit >= CCS_MAX_MKDEV_OPERATION)
+		if (!ccs_print_file_bits(head, ptr->perm, ccs_mkdev_keyword))
 			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "file ");
-		ccs_set_string(head, ccs_mkdev_keyword[bit]);
 		ccs_print_name_union(head, &ptr->name);
 		ccs_print_number_union(head, &ptr->mode);
 		ccs_print_number_union(head, &ptr->major);
@@ -1375,23 +1380,16 @@
 	} else if (acl_type == CCS_TYPE_PATH2_ACL) {
 		struct ccs_path2_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		bit = ccs_fns(ptr->perm, bit);
-		if (bit >= CCS_MAX_PATH2_OPERATION)
+		if (!ccs_print_file_bits(head, ptr->perm, ccs_path2_keyword))
 			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "file ");
-		ccs_set_string(head, ccs_path2_keyword[bit]);
 		ccs_print_name_union(head, &ptr->name1);
 		ccs_print_name_union(head, &ptr->name2);
 	} else if (acl_type == CCS_TYPE_PATH_NUMBER_ACL) {
 		struct ccs_path_number_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		bit = ccs_fns(ptr->perm, bit);
-		if (bit >= CCS_MAX_PATH_NUMBER_OPERATION)
+		if (!ccs_print_file_bits(head, ptr->perm,
+					 ccs_path_number_keyword))
 			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "file ");
-		ccs_set_string(head, ccs_path_number_keyword[bit]);
 		ccs_print_name_union(head, &ptr->name);
 		ccs_print_number_union(head, &ptr->number);
 	} else if (acl_type == CCS_TYPE_ENV_ACL) {
@@ -1409,15 +1407,11 @@
 	} else if (acl_type == CCS_TYPE_IP_NETWORK_ACL) {
 		struct ccs_ip_network_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		bit = ccs_fns(ptr->perm, bit);
-		if (bit >= CCS_MAX_NETWORK_OPERATION)
+		if (!ccs_print_network_bits(head,
+					    ccs_net_protocol_keyword
+					    [ptr->protocol], ptr->perm))
 			goto done;
-		ccs_set_group(head);
-		ccs_set_string(head, "network ");
-		ccs_set_string(head, ccs_net_protocol_keyword[ptr->protocol]);
 		ccs_set_space(head);
-		ccs_set_string(head, ccs_net_keyword[bit]);
-		ccs_set_space(head);
 		switch (ptr->address_type) {
 			char buf[128];
 		case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
@@ -1454,7 +1448,6 @@
 		ccs_print_name_union(head, &ptr->fs_type);
 		ccs_print_number_union(head, &ptr->flags);
 	}
-	head->r.bit = bit + 1;
 	if (acl->cond) {
 		head->r.print_cond_part = true;
 		head->r.cond_step = 0;
@@ -1467,16 +1460,7 @@
 	} else {
 		ccs_set_lf(head);
 	}
-	switch (acl_type) {
-	case CCS_TYPE_PATH_ACL:
-	case CCS_TYPE_MKDEV_ACL:
-	case CCS_TYPE_PATH2_ACL:
-	case CCS_TYPE_PATH_NUMBER_ACL:
-	case CCS_TYPE_IP_NETWORK_ACL:
-		goto next;
-	}
  done:
-	head->r.bit = 0;
 	return true;
 }
 
Index: branches/ccs-tools/ccstools/kernel_test/include.h
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/include.h	(revision 3845)
+++ branches/ccs-tools/ccstools/kernel_test/include.h	(working copy)
@@ -299,6 +299,7 @@
 
 static void BUG(const char *fmt, ...)
 {
+	int i;
 	va_list args;
 	printf("BUG: ");
 	va_start(args, fmt);
@@ -306,17 +307,61 @@
 	va_end(args);
 	putchar('\n');
 	fflush(stdout);
+	for (i = 0; i < 1024; i++)
+		close(i);
 	while (1)
 		sleep(100);
 }
 
+static _Bool policy_match(char *buffer, char *policy)
+{
+	char *buffer_start = buffer;
+	char *policy_start = policy;
+	while (*buffer && *policy) {
+		char *cp1;
+		char *cp2;
+		if (*buffer++ == *policy++)
+			continue;
+		buffer--;
+		policy--;
+		cp1 = strchr(buffer, ' ');
+		cp2 = strchr(policy, ' ');
+		if (!cp1 || !cp2 || strcmp(cp1, cp2))
+			return 0;
+		*cp1 = '\0';
+		*cp2 = '\0';
+		while (buffer > buffer_start && *(buffer - 1) != ' ')
+			buffer--;
+		while (policy > policy_start && *(policy - 1) != ' ')
+			policy--;
+		/* fprintf(stderr, "Find '%s' in '%s'\n", policy, buffer); */
+		while (1) {
+			cp1 = strchr(policy, '/');
+			if (cp1)
+				*cp1 = '\0';
+			cp2 = strstr(buffer, policy);
+			if (!cp2)
+				return 0;
+			if (cp2 > buffer && *(cp2 - 1) != '/')
+				return 0;
+			if (!cp1)
+				return 1;
+			policy = cp1 + 1;
+		}
+	}
+	return !*buffer && !*policy;
+}
+
 static int write_domain_policy(const char *policy, int is_delete)
 {
 	FILE *fp = fopen(proc_policy_domain_policy, "r");
 	char buffer[8192];
+	char tmp_policy[8192];
 	int domain_found = 0;
 	int policy_found = 0;
 	memset(buffer, 0, sizeof(buffer));
+	memset(tmp_policy, 0, sizeof(tmp_policy));
+	strncpy(tmp_policy, policy, sizeof(tmp_policy) - 1);
 	if (!fp) {
 		BUG("Can't read %s", proc_policy_domain_policy);
 		return 0;
@@ -333,18 +378,16 @@
 		if (!domain_found)
 			continue;
 		/* printf("<%s>\n", buffer); */
-		if (strcmp(buffer, policy))
+		strncpy(tmp_policy, policy, sizeof(tmp_policy) - 1);
+		if (!policy_match(buffer, tmp_policy))
 			continue;
 		policy_found = 1;
 		break;
 	}
 	fclose(fp);
 	if (policy_found == is_delete) {
-		if (!strstr(policy, "read/write")) {
-			BUG("Can't %s %s", is_delete ? "delete" : "append",
-			    policy);
-			return 0;
-		}
+		BUG("Can't %s %s", is_delete ? "delete" : "append", policy);
+		return 0;
 	}
 	errno = 0;
 	return 1;
