Index: mount.c
===================================================================
--- mount.c	(revision 3989)
+++ mount.c	(working copy)
@@ -67,31 +67,10 @@
  */
 static int ccs_audit_mount_log(struct ccs_request_info *r)
 {
-	const char *dev = r->param.mount.dev->name;
-	const char *dir = r->param.mount.dir->name;
-	const char *type = r->param.mount.type->name;
-	const unsigned long flags = r->param.mount.flags;
-	ccs_write_log(r, "file mount %s %s %s 0x%lX\n", dev, dir, type, flags);
-	if (r->granted)
-		return 0;
-	if (type == ccs_mounts[CCS_MOUNT_REMOUNT])
-		ccs_warn_log(r, "file mount -o remount %s 0x%lX", dir, flags);
-	else if (type == ccs_mounts[CCS_MOUNT_BIND] || 
-		 type == ccs_mounts[CCS_MOUNT_MOVE])
-		ccs_warn_log(r, "file mount %s %s %s 0x%lX\n", type, dev, dir,
-			     flags);
-	else if (type == ccs_mounts[CCS_MOUNT_MAKE_UNBINDABLE] ||
-		 type == ccs_mounts[CCS_MOUNT_MAKE_PRIVATE] ||
-		 type == ccs_mounts[CCS_MOUNT_MAKE_SLAVE] ||
-		 type == ccs_mounts[CCS_MOUNT_MAKE_SHARED])
-		ccs_warn_log(r, "file mount %s %s 0x%lX", type, dir, flags);
-	else
-		ccs_warn_log(r, "file mount -t %s %s %s 0x%lX", type, dev, dir,
-			     flags);
 	return ccs_supervisor(r, "file mount %s %s %s 0x%lX\n",
-			      ccs_file_pattern(r->param.mount.dev),
-			      ccs_file_pattern(r->param.mount.dir), type,
-			      flags);
+			      r->param.mount.dev->name,
+			      r->param.mount.dir->name,
+			      r->param.mount.type->name, r->param.mount.flags);
 }
 
 static bool ccs_check_mount_acl(struct ccs_request_info *r,
Index: audit.c
===================================================================
--- audit.c	(revision 3989)
+++ audit.c	(working copy)
@@ -228,17 +228,19 @@
 /**
  * ccs_init_log - Allocate buffer for audit logs.
  *
- * @len: Required size.
+ * @len: Allocated size.
  * @r:   Pointer to "struct ccs_request_info".
+ * @fmt: The printf()'s format string, followed by parameters.
  *
  * Returns pointer to allocated memory.
  *
- * The @len is updated to add the header lines' size on success.
+ * The @len is updated to allocated size on success.
  *
  * This function uses kzalloc(), so caller must kfree() if this function
  * didn't return NULL.
  */
-char *ccs_init_log(int *len, struct ccs_request_info *r)
+char *ccs_init_log(int *len, struct ccs_request_info *r, const char *fmt,
+		   va_list args)
 {
 	char *buf = NULL;
 	char *bprm_info = NULL;
@@ -246,11 +248,13 @@
 	const char *symlink = NULL;
 	const char *header = NULL;
 	int pos;
+	char c;
 	const char *domainname = ccs_current_domain()->domainname->name;
+	*len = 0;
 	header = ccs_print_header(r);
 	if (!header)
 		return NULL;
-	*len += strlen(domainname) + strlen(header) + 10;
+	pos = strlen(domainname) + strlen(header) + 10;
 	if (r->ee) {
 		struct file *file = r->ee->bprm->file;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
@@ -262,14 +266,20 @@
 		bprm_info = ccs_print_bprm(r->ee->bprm, &r->ee->dump);
 		if (!realpath || !bprm_info)
 			goto out;
-		*len += strlen(realpath) + 80 + strlen(bprm_info);
+		/* +80 is for " exec={ realpath=\"%s\" argc=%d envc=%d %s }" */
+		pos += strlen(realpath) + 80 + strlen(bprm_info);
 	} else if (r->obj && r->obj->symlink_target) {
 		symlink = r->obj->symlink_target->name;
-		*len += 18 + strlen(symlink);
+		/* +18 is for " symlink.target=\"%s\"" */
+		pos += 18 + strlen(symlink);
 	}
-	buf = kzalloc(*len, CCS_GFP_FLAGS);
+	/* +1 is for '\0'. */
+	pos += vsnprintf(&c, sizeof(c), fmt, args) + 1;
+	pos = ccs_round2(pos);
+	buf = kzalloc(pos, CCS_GFP_FLAGS);
 	if (!buf)
 		goto out;
+	*len = pos;
 	pos = snprintf(buf, (*len) - 1, "%s", header);
 	if (realpath) {
 		struct linux_binprm *bprm = r->ee->bprm;
@@ -279,7 +289,8 @@
 	} else if (symlink)
 		pos += snprintf(buf + pos, (*len) - 1 - pos,
 				" symlink.target=\"%s\"", symlink);
-	snprintf(buf + pos, (*len) - 1 - pos, "\n%s\n", domainname);
+	pos += snprintf(buf + pos, (*len) - 1 - pos, "\n%s\n", domainname);
+	vsnprintf(buf + pos, (*len) - 1 - pos, fmt, args);
  out:
 	kfree(realpath);
 	kfree(bprm_info);
@@ -330,15 +341,17 @@
  *
  * @r:   Pointer to "struct ccs_request_info".
  * @fmt: The printf()'s format string, followed by parameters.
- *
- * Returns 0 on success, -ENOMEM otherwise.
  */
-int ccs_write_log(struct ccs_request_info *r, const char *fmt, ...)
+void ccs_write_log(struct ccs_request_info *r, const char *fmt, ...)
 {
 	ccs_update_task_domain(r);
-	return 0;
 }
 
+void ccs_write_log2(struct ccs_request_info *r, const char *fmt, va_list args)
+{
+	ccs_update_task_domain(r);
+}
+
 #else
 
 static wait_queue_head_t ccs_log_wait[2] = {
@@ -398,14 +411,9 @@
  *
  * @r:   Pointer to "struct ccs_request_info".
  * @fmt: The printf()'s format string, followed by parameters.
- *
- * Returns 0 on success, -ENOMEM otherwise.
  */
-int ccs_write_log(struct ccs_request_info *r, const char *fmt, ...)
+void ccs_write_log2(struct ccs_request_info *r, const char *fmt, va_list args)
 {
-	va_list args;
-	int error = -ENOMEM;
-	int pos;
 	int len;
 	char *buf;
 	struct ccs_log *entry;
@@ -418,16 +426,9 @@
 	if (ccs_log_count[is_granted] >= len ||
 	    !ccs_get_audit(r->profile, r->type, r->matched_acl, is_granted))
 		goto out;
-	va_start(args, fmt);
-	len = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 32;
-	va_end(args);
-	buf = ccs_init_log(&len, r);
+	buf = ccs_init_log(&len, r, fmt, args);
 	if (!buf)
 		goto out;
-	pos = strlen(buf);
-	va_start(args, fmt);
-	vsnprintf(buf + pos, len - pos - 1, fmt, args);
-	va_end(args);
 	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
 	if (!entry) {
 		kfree(buf);
@@ -438,7 +439,7 @@
 	 * The entry->size is used for memory quota checks.
 	 * Don't go beyond strlen(entry->log).
 	 */
-	entry->size = ccs_round2(len) + ccs_round2(sizeof(*entry));
+	entry->size = len + ccs_round2(sizeof(*entry));
 	spin_lock(&ccs_log_lock);
 	if (ccs_quota_for_log && ccs_log_memory_size
 	    + entry->size >= ccs_quota_for_log) {
@@ -455,12 +456,18 @@
 		goto out;
 	}
 	wake_up(&ccs_log_wait[is_granted]);
-	error = 0;
  out:
 	ccs_update_task_domain(r);
-	return error;
 }
 
+void ccs_write_log(struct ccs_request_info *r, const char *fmt, ...)
+{
+	va_list args;
+	va_start(args, fmt);
+	ccs_write_log2(r, fmt, args);
+	va_end(args);
+}
+
 /**
  * ccs_read_log - Read an audit log.
  *
Index: domain.c
===================================================================
--- domain.c	(revision 3989)
+++ domain.c	(working copy)
@@ -256,6 +256,21 @@
 }
 
 /**
+ * ccs_last_word - Get last component of a domainname.
+ *
+ * @name: Domainname to check.
+ *
+ * Returns the last word of @name.
+ */
+static const char *ccs_last_word(const char *name)
+{
+	const char *cp = strrchr(name, ' ');
+	if (cp)
+		return cp + 1;
+	return name;
+}
+
+/**
  * ccs_transition_type - Get domain transition type.
  *
  * @domainname: The name of domain.
@@ -450,7 +465,8 @@
 			struct ccs_request_info r;
 			ccs_init_request_info(&r, CCS_MAC_FILE_EXECUTE);
 			r.granted = false;
-			ccs_write_log(&r, "use_profile %u\n", r.profile);
+			ccs_write_log(&r, "use_profile %u\n", profile);
+			ccs_write_log(&r, "use_group %u\n", group);
 		}
 	}
 	return entry;
Index: signal.c
===================================================================
--- signal.c	(revision 3989)
+++ signal.c	(working copy)
@@ -26,13 +26,8 @@
  */
 static int ccs_audit_signal_log(struct ccs_request_info *r)
 {
-	const int sig = r->param.signal.sig;
-	const char *dest_domain = r->param.signal.dest_pattern;
-	ccs_write_log(r, "ipc signal %d %s\n", sig, dest_domain);
-	if (r->granted)
-		return 0;
-	ccs_warn_log(r, "signal %d to %s", sig, ccs_last_word(dest_domain));
-	return ccs_supervisor(r, "ipc signal %d %s\n", sig, dest_domain);
+	return ccs_supervisor(r, "ipc signal %d %s\n", r->param.signal.sig,
+			      r->param.signal.dest_pattern);
 }
 
 static bool ccs_check_signal_acl(struct ccs_request_info *r,
Index: util.c
===================================================================
--- util.c	(revision 3989)
+++ util.c	(working copy)
@@ -971,63 +971,6 @@
 }
 
 /**
- * ccs_last_word - Get last component of a domainname.
- *
- * @name: Domainname to check.
- *
- * Returns the last word of @name.
- */
-const char *ccs_last_word(const char *name)
-{
-	const char *cp = strrchr(name, ' ');
-	if (cp)
-		return cp + 1;
-	return name;
-}
-
-/**
- * ccs_warn_log - Print warning or error message on console.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @fmt: The printf()'s format string, followed by parameters.
- */
-void ccs_warn_log(struct ccs_request_info *r, const char *fmt, ...)
-{
-	va_list args;
-	char *buffer;
-	char *cp;
-	const struct ccs_domain_info * const domain = ccs_current_domain();
-	switch (r->mode) {
-        case CCS_CONFIG_ENFORCING:
-                if (!ccs_preference.enforcing_verbose)
-                        return;
-                break;
-        case CCS_CONFIG_PERMISSIVE:
-                if (!ccs_preference.permissive_verbose)
-                        return;
-                break;
-        case CCS_CONFIG_LEARNING:
-                if (!ccs_preference.learning_verbose)
-                        return;
-                break;
-        }
-	buffer = kmalloc(4096, CCS_GFP_FLAGS);
-	if (!buffer)
-		return;
-	va_start(args, fmt);
-	vsnprintf(buffer, 4095, fmt, args);
-	va_end(args);
-	buffer[4095] = '\0';
-	cp = strchr(buffer, '\n');
-	if (cp)
-		*cp = '\0';
-	printk(KERN_WARNING "%s: Access %s denied for %s\n",
-	       r->mode == CCS_CONFIG_ENFORCING ? "ERROR" : "WARNING", buffer,
-	       ccs_last_word(domain->domainname->name));
-	kfree(buffer);
-}
-
-/**
  * ccs_domain_quota_ok - Check for domain's quota.
  *
  * @r: Pointer to "struct ccs_request_info".
Index: file.c
===================================================================
--- file.c	(revision 3989)
+++ file.c	(working copy)
@@ -112,23 +112,6 @@
 }
 
 /**
- * ccs_strendswith - Check whether the token ends with the given token.
- *
- * @name: The token to check.
- * @tail: The token to find.
- *
- * Returns true if @name ends with @tail, false otherwise.
- */
-static bool ccs_strendswith(const char *name, const char *tail)
-{
-	int len;
-	if (!name || !tail)
-		return false;
-	len = strlen(name) - strlen(tail);
-	return len >= 0 && !strcmp(name + len, tail);
-}
-
-/**
  * ccs_get_realpath - Get realpath.
  *
  * @buf:    Pointer to "struct ccs_path_info".
@@ -158,14 +141,9 @@
  */
 static int ccs_audit_path_log(struct ccs_request_info *r)
 {
-	const char *operation = ccs_path_keyword[r->param.path.operation];
-	const struct ccs_path_info *filename = r->param.path.filename;
-	ccs_write_log(r, "file %s %s\n", operation, filename->name);
-	if (r->granted)
-		return 0;
-	ccs_warn_log(r, "file %s %s\n", operation, filename->name);
-	return ccs_supervisor(r, "file %s %s\n", operation,
-			      ccs_file_pattern(filename));
+	return ccs_supervisor(r, "file %s %s\n", ccs_path_keyword
+			      [r->param.path.operation],
+			      r->param.path.filename->name);
 }
 
 /**
@@ -177,19 +155,10 @@
  */
 static int ccs_audit_path2_log(struct ccs_request_info *r)
 {
-	const char *operation =
-		ccs_mac_keywords[ccs_pp2mac[r->param.path2.operation]];
-	const struct ccs_path_info *filename1 = r->param.path2.filename1;
-	const struct ccs_path_info *filename2 = r->param.path2.filename2;
-	ccs_write_log(r, "file %s %s %s\n", operation, filename1->name,
-		      filename2->name);
-	if (r->granted)
-		return 0;
-	ccs_warn_log(r, "file %s %s %s\n", operation, filename1->name,
-		     filename2->name);
-	return ccs_supervisor(r, "file %s %s %s\n", operation,
-			      ccs_file_pattern(filename1),
-			      ccs_file_pattern(filename2));
+	return ccs_supervisor(r, "file %s %s %s\n", ccs_mac_keywords
+			      [ccs_pp2mac[r->param.path2.operation]],
+			      r->param.path2.filename1->name,
+			      r->param.path2.filename2->name);
 }
 
 /**
@@ -201,20 +170,11 @@
  */
 static int ccs_audit_mkdev_log(struct ccs_request_info *r)
 {
-	const char *operation =
-		ccs_mac_keywords[ccs_pnnn2mac[r->param.mkdev.operation]];
-	const struct ccs_path_info *filename = r->param.mkdev.filename;
-	const unsigned int major = r->param.mkdev.major;
-	const unsigned int minor = r->param.mkdev.minor;
-	const unsigned int mode = r->param.mkdev.mode;
-	ccs_write_log(r, "file %s %s 0%o %u %u\n", operation, filename->name,
-		      mode, major, minor);
-	if (r->granted)
-		return 0;
-	ccs_warn_log(r, "file %s %s 0%o %u %u\n", operation, filename->name,
-		     mode, major, minor);
-	return ccs_supervisor(r, "file %s %s 0%o %u %u\n", operation,
-			      ccs_file_pattern(filename), mode, major, minor);
+	return ccs_supervisor(r, "file %s %s 0%o %u %u\n", ccs_mac_keywords
+			      [ccs_pnnn2mac[r->param.mkdev.operation]],
+			      r->param.mkdev.filename->name,
+			      r->param.mkdev.mode, r->param.mkdev.major,
+			      r->param.mkdev.minor);
 }
 
 /**
@@ -229,8 +189,6 @@
 {
 	const u8 type = r->param.path_number.operation;
 	u8 radix;
-	const struct ccs_path_info *filename = r->param.path_number.filename;
-	const char *operation = ccs_mac_keywords[ccs_pn2mac[type]];
 	char buffer[64];
 	switch (type) {
 	case CCS_TYPE_CREATE:
@@ -249,76 +207,11 @@
 	}
 	ccs_print_ulong(buffer, sizeof(buffer), r->param.path_number.number,
 			radix);
-	ccs_write_log(r, "file %s %s %s\n", operation, filename->name,
-		      buffer);
-	if (r->granted)
-		return 0;
-	ccs_warn_log(r, "file %s %s %s\n", operation, filename->name, buffer);
-	return ccs_supervisor(r, "file %s %s %s\n", operation,
-			      ccs_file_pattern(filename), buffer);
+	return ccs_supervisor(r, "file %s %s %s\n", ccs_mac_keywords
+			      [ccs_pn2mac[type]],
+			      r->param.path_number.filename->name, buffer);
 }
 
-/**
- * ccs_file_pattern - Get patterned pathname.
- *
- * @filename: Pointer to "struct ccs_path_info".
- *
- * Returns pointer to patterned pathname.
- *
- * Caller holds ccs_read_lock().
- */
-const char *ccs_file_pattern(const struct ccs_path_info *filename)
-{
-	struct ccs_pattern *ptr;
-	const struct ccs_path_info *pattern = NULL;
-	list_for_each_entry_rcu(ptr, &ccs_policy_list[CCS_ID_PATTERN],
-				head.list) {
-		if (ptr->head.is_deleted)
-			continue;
-		if (!ccs_path_matches_pattern(filename, ptr->pattern))
-			continue;
-		pattern = ptr->pattern;
-		if (ccs_strendswith(pattern->name, "/\\*")) {
-			/* Do nothing. Try to find the better match. */
-		} else {
-			/* This would be the better match. Use this. */
-			break;
-		}
-	}
-	return pattern ? pattern->name : filename->name;
-}
-
-static bool ccs_same_pattern(const struct ccs_acl_head *a,
-			     const struct ccs_acl_head *b)
-{
-	return container_of(a, struct ccs_pattern, head)->pattern ==
-		container_of(b, struct ccs_pattern, head)->pattern;
-}
-
-/**
- * ccs_write_pattern - Write "struct ccs_pattern" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_pattern(char *data, const bool is_delete)
-{
-	struct ccs_pattern e = { };
-	int error;
-	if (!ccs_correct_word(data))
-		return -EINVAL;
-	e.pattern = ccs_get_name(data);
-	if (!e.pattern)
-		return -ENOMEM;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_PATTERN],
-				  ccs_same_pattern);
-	ccs_put_name(e.pattern);
-	return error;
-}
-
 static bool ccs_check_path_acl(struct ccs_request_info *r,
 			       const struct ccs_acl_info *ptr)
 {
Index: environ.c
===================================================================
--- environ.c	(revision 3989)
+++ environ.c	(working copy)
@@ -29,12 +29,7 @@
  */
 static int ccs_audit_env_log(struct ccs_request_info *r)
 {
-	const char *env = r->param.environ.name->name;
-	ccs_write_log(r, "misc env %s\n", env);
-	if (r->granted)
-		return 0;
-	ccs_warn_log(r, "environ %s", env);
-	return ccs_supervisor(r, "misc env %s\n", env);
+	return ccs_supervisor(r, "misc env %s\n", r->param.environ.name->name);
 }
 
 /**
Index: internal.h
===================================================================
--- internal.h	(revision 3989)
+++ internal.h	(working copy)
@@ -344,7 +344,6 @@
 	CCS_ID_NUMBER_GROUP,
 	CCS_ID_AGGREGATOR,
 	CCS_ID_TRANSITION_CONTROL,
-	CCS_ID_PATTERN,
 	CCS_ID_MANAGER,
 	CCS_ID_IPV6_ADDRESS,
 	CCS_ID_CONDITION,
@@ -675,12 +674,6 @@
 	bool flags[CCS_MAX_DOMAIN_INFO_FLAGS];
 };
 
-/* Structure for "file_pattern" keyword. */
-struct ccs_pattern {
-	struct ccs_acl_head head;
-	const struct ccs_path_info *pattern;
-};
-
 /*
  * Structure for "initialize_domain"/"no_initialize_domain" and
  * "keep_domain"/"no_keep_domain" keyword.
@@ -949,12 +942,6 @@
 	unsigned int enforcing_penalty;
 	bool audit_task_info;
 	bool audit_path_info;
-	bool enforcing_verbose;
-	bool learning_verbose;
-	bool learning_exec_realpath;
-	bool learning_exec_argv0;
-	bool learning_symlink_target;
-	bool permissive_verbose;
 };
 
 struct ccs_profile {
@@ -1010,11 +997,10 @@
 bool ccs_tokenize(char *buffer, char *w[], size_t size);
 char *ccs_encode(const char *str);
 char *ccs_encode2(const char *str, int str_len);
-char *ccs_init_log(int *len, struct ccs_request_info *r);
+char *ccs_init_log(int *len, struct ccs_request_info *r, const char *fmt,
+		   va_list args);
 char *ccs_realpath_from_path(struct path *path);
-const char *ccs_file_pattern(const struct ccs_path_info *filename);
 const char *ccs_get_exe(void);
-const char *ccs_last_word(const char *name);
 const struct ccs_path_info *ccs_get_domainname(struct ccs_acl_param *param);
 const struct ccs_path_info *ccs_get_name(const char *name);
 const struct in6_addr *ccs_get_ipv6_address(const struct in6_addr *addr);
@@ -1033,7 +1019,7 @@
 int ccs_read_control(struct file *file, char __user *buffer,
 		     const int buffer_len);
 int ccs_supervisor(struct ccs_request_info *r, const char *fmt, ...)
-     __attribute__ ((format(printf, 2, 3)));
+	__attribute__ ((format(printf, 2, 3)));
 int ccs_symlink_path(const char *pathname, struct ccs_path_info *name);
 int ccs_update_domain(struct ccs_acl_info *new_entry, const int size,
 		      struct ccs_acl_param *param,
@@ -1053,13 +1039,10 @@
 int ccs_write_file(struct ccs_acl_param *param);
 int ccs_write_group(char *data, const bool is_delete, const u8 type);
 int ccs_write_ipc(struct ccs_acl_param *param);
-int ccs_write_log(struct ccs_request_info *r, const char *fmt, ...)
-     __attribute__ ((format(printf, 2, 3)));
 int ccs_write_memory_quota(struct ccs_io_buffer *head);
 int ccs_write_misc(struct ccs_acl_param *param);
 int ccs_write_inet_network(struct ccs_acl_param *param);
 int ccs_write_unix_network(struct ccs_acl_param *param);
-int ccs_write_pattern(char *data, const bool is_delete);
 int ccs_write_reserved_port(char *data, const bool is_delete);
 int ccs_write_transition_control(char *data, const bool is_delete,
 				 const u8 type);
@@ -1095,9 +1078,10 @@
 void ccs_run_gc(void);
 void ccs_transition_failed(const char *domainname);
 void ccs_unlock(const int idx);
-void ccs_warn_log(struct ccs_request_info *r, const char *fmt, ...)
-     __attribute__ ((format(printf, 2, 3)));
 void ccs_warn_oom(const char *function);
+void ccs_write_log(struct ccs_request_info *r, const char *fmt, ...)
+	__attribute__ ((format(printf, 2, 3)));
+void ccs_write_log2(struct ccs_request_info *r, const char *fmt, va_list args);
 
 /* strcmp() for "struct ccs_path_info" structure. */
 static inline bool ccs_pathcmp(const struct ccs_path_info *a,
Index: capability.c
===================================================================
--- capability.c	(revision 3989)
+++ capability.c	(working copy)
@@ -29,19 +29,13 @@
  * ccs_audit_capability_log - Audit capability log.
  *
  * @r:     Pointer to "struct ccs_request_info".
- * @error: Error code.
  *
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_audit_capability_log(struct ccs_request_info *r)
 {
-	const char *operation =
-		ccs_mac_keywords[ccs_c2mac[r->param.capability.operation]];
-	ccs_write_log(r, "capability %s\n", operation);
-	if (r->granted)
-		return 0;
-	ccs_warn_log(r, "capability %s\n", operation);
-	return ccs_supervisor(r, "capability %s\n", operation);
+	return ccs_supervisor(r, "capability %s\n", ccs_mac_keywords
+			      [ccs_c2mac[r->param.capability.operation]]);
 }
 
 static bool ccs_check_capability_acl(struct ccs_request_info *r,
Index: policy_io.c
===================================================================
--- policy_io.c	(revision 3989)
+++ policy_io.c	(working copy)
@@ -20,13 +20,7 @@
 	.audit_task_info = true,
 	.audit_path_info = true,
 	.enforcing_penalty = 0,
-	.enforcing_verbose = true,
 	.learning_max_entry = CONFIG_CCSECURITY_MAX_ACCEPT_ENTRY,
-	.learning_verbose = false,
-	.learning_exec_realpath = true,
-	.learning_exec_argv0 = true,
-	.learning_symlink_target = true,
-	.permissive_verbose = true,
 };
 
 /* Profile version. Currently only 20100903 is defined. */
@@ -434,24 +428,11 @@
 		ccs_set_bool(&ccs_preference.audit_path_info, data,
 			     "path_info");
 	} else if (ccs_str_starts(&data, "enforcing")) {
-		ccs_set_bool(&ccs_preference.enforcing_verbose, data,
-			     "verbose");
 		ccs_set_uint(&ccs_preference.enforcing_penalty, data,
 			     "penalty");
-	} else if (ccs_str_starts(&data, "permissive")) {
-		ccs_set_bool(&ccs_preference.permissive_verbose, data,
-			     "verbose");
 	} else if (ccs_str_starts(&data, "learning")) {
-		ccs_set_bool(&ccs_preference.learning_verbose, data,
-			     "verbose");
 		ccs_set_uint(&ccs_preference.learning_max_entry, data,
 			     "max_entry");
-		ccs_set_bool(&ccs_preference.learning_exec_realpath, data,
-			     ccs_condition_keyword[CCS_EXEC_REALPATH]);
-		ccs_set_bool(&ccs_preference.learning_exec_argv0, data,
-			     "exec.argv0");
-		ccs_set_bool(&ccs_preference.learning_symlink_target, data,
-			     ccs_condition_keyword[CCS_SYMLINK_TARGET]);
 	} else
 		return -EINVAL;
 	return 0;
@@ -577,18 +558,10 @@
 #endif
 		      ccs_yesno(ccs_preference.audit_task_info),
 		      ccs_yesno(ccs_preference.audit_path_info));
-	ccs_io_printf(head, "PREFERENCE::%s={ verbose=%s max_entry=%u "
-		      "exec.realpath=%s exec.argv0=%s symlink.target=%s }\n",
-		      "learning", ccs_yesno(ccs_preference.learning_verbose),
-		      ccs_preference.learning_max_entry,
-		      ccs_yesno(ccs_preference.learning_exec_realpath),
-		      ccs_yesno(ccs_preference.learning_exec_argv0),
-		      ccs_yesno(ccs_preference.learning_symlink_target));
-	ccs_io_printf(head, "PREFERENCE::%s={ verbose=%s }\n", "permissive",
-		      ccs_yesno(ccs_preference.permissive_verbose));
-	ccs_io_printf(head, "PREFERENCE::%s={ verbose=%s penalty=%u }\n",
-		      "enforcing", ccs_yesno(ccs_preference.enforcing_verbose),
-		      ccs_preference.enforcing_penalty);
+	ccs_io_printf(head, "PREFERENCE::%s={ max_entry=%u }\n",
+		      "learning", ccs_preference.learning_max_entry);
+	ccs_io_printf(head, "PREFERENCE::%s={ penalty=%u }\n",
+		      "enforcing", ccs_preference.enforcing_penalty);
 }
 
 static void ccs_print_config(struct ccs_io_buffer *head, const u8 config)
@@ -1694,12 +1667,11 @@
 	static const struct {
 		const char *keyword;
 		int (*write) (char *, const bool);
-	} ccs_callback[3] = {
+	} ccs_callback[2] = {
 		{ "aggregator ",    ccs_write_aggregator },
-		{ "file_pattern ",  ccs_write_pattern },
 		{ "deny_autobind ", ccs_write_reserved_port },
 	};
-	for (i = 0; i < 3; i++)
+	for (i = 0; i < 2; i++)
 		if (ccs_str_starts(&data, ccs_callback[i].keyword))
 			return ccs_callback[i].write(data, is_delete);
 	for (i = 0; i < CCS_MAX_TRANSITION_TYPE; i++)
@@ -1823,14 +1795,6 @@
 					       ptr->aggregated_name->name);
 			}
 			break;
-		case CCS_ID_PATTERN:
-			{
-				struct ccs_pattern *ptr =
-					container_of(acl, typeof(*ptr), head);
-				ccs_set_string(head, "file_pattern ");
-				ccs_set_string(head, ptr->pattern->name);
-			}
-			break;
 		case CCS_ID_RESERVEDPORT:
 			{
 				struct ccs_reserved *ptr =
@@ -1888,6 +1852,7 @@
 
 /* Wait queue for ccs_query_list. */
 static DECLARE_WAIT_QUEUE_HEAD(ccs_query_wait);
+static DECLARE_WAIT_QUEUE_HEAD(ccs_answer_wait);
 
 /* Lock for manipulating ccs_query_list. */
 static DEFINE_SPINLOCK(ccs_query_list_lock);
@@ -1900,6 +1865,7 @@
 	unsigned int serial;
 	int timer;
 	int answer;
+	u8 retry;
 };
 
 /* The list for "struct ccs_query". */
@@ -1908,13 +1874,68 @@
 /* Number of "struct file" referring /proc/ccs/query interface. */
 static atomic_t ccs_query_observers = ATOMIC_INIT(0);
 
-static void ccs_truncate(char *str)
+static int ccs_truncate(char *str)
 {
+	char *start = str;
 	while (* (unsigned char *) str > (unsigned char) ' ')
 		str++;
 	*str = '\0';
+	return strlen(start) + 1;
 }
 
+static void ccs_add_entry(char *header)
+{
+	char *buffer;
+	char *realpath = NULL;
+	char *argv0 = NULL;
+	char *symlink = NULL;
+	char *handler;
+	char *cp = strchr(header, '\n');
+	int len;
+	if (!cp)
+		return;
+	cp = strchr(cp + 1, '\n');
+	if (!cp)
+		return;
+	*cp++ = '\0';
+	len = strlen(cp) + 1;
+	/* strstr() will return NULL if ordering is wrong. */
+	if (*cp == 'f') {
+		argv0 = strstr(header, " argv[]={ \"");
+		if (argv0) {
+			argv0 += 10;
+			len += ccs_truncate(argv0) + 14;
+		}
+		realpath = strstr(header, " exec={ realpath=\"");
+		if (realpath) {
+			realpath += 8;
+			len += ccs_truncate(realpath) + 6;
+		}
+		symlink = strstr(header, " symlink.target=\"");
+		if (symlink)
+			len += ccs_truncate(symlink + 1) + 1;
+	}
+	handler = strstr(header, "type=execute_handler");
+	if (handler)
+		len += ccs_truncate(handler) + 6;
+	buffer = kmalloc(len, CCS_GFP_FLAGS);
+	if (!buffer)
+		return;
+	snprintf(buffer, len - 1, "%s", cp);
+	if (handler)
+		ccs_addprintf(buffer, len, " task.%s", handler);
+	if (realpath)
+		ccs_addprintf(buffer, len, " exec.%s", realpath);
+	if (argv0)
+		ccs_addprintf(buffer, len, " exec.argv[0]=%s", argv0);
+	if (symlink)
+		ccs_addprintf(buffer, len, "%s", symlink);
+	//printk(KERN_DEBUG "'%s'\n", buffer);
+	ccs_normalize_line(buffer);
+	ccs_write_domain2(buffer, ccs_current_domain(), false);
+	kfree(buffer);
+}
+
 /**
  * ccs_supervisor - Ask for the supervisor's decision.
  *
@@ -1929,138 +1950,80 @@
 int ccs_supervisor(struct ccs_request_info *r, const char *fmt, ...)
 {
 	va_list args;
-	int error = -EPERM;
-	int pos;
+	int error;
 	int len;
 	static unsigned int ccs_serial;
-	struct ccs_query *entry = NULL;
+	struct ccs_query entry = { };
 	bool quota_exceeded = false;
-	char *header;
-	struct ccs_domain_info * const domain = ccs_current_domain();
+	/* Write /proc/ccs/grant_log or /proc/ccs/reject_log . */
 	va_start(args, fmt);
-	len = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 80;
+	ccs_write_log2(r, fmt, args);
 	va_end(args);
-	if (r->mode == CCS_CONFIG_LEARNING) {
-		char *buffer;
-		char *realpath = NULL;
-		char *argv0 = NULL;
-		char *symlink = NULL;
-		char *handler = NULL;
-		if (!ccs_domain_quota_ok(r))
-			return 0;
-		header = ccs_init_log(&len, r);
-		if (!header)
-			return 0;
-		/* strstr() will return NULL if ordering is wrong. */
-		if (r->param_type == CCS_TYPE_PATH_ACL &&
-		    r->param.path.operation == CCS_TYPE_EXECUTE) {
-			if (ccs_preference.learning_exec_argv0) {
-				argv0 = strstr(header, " argv[]={ \"");
-				if (argv0) {
-					argv0 += 10;
-					ccs_truncate(argv0);
-				}
-			}
-			if (ccs_preference.learning_exec_realpath) {
-				realpath = strstr(header,
-						  " exec={ realpath=\"");
-				if (realpath) {
-					realpath += 8;
-					ccs_truncate(realpath);
-				}
-			}
-		} else if (r->param_type == CCS_TYPE_PATH_ACL &&
-			   r->param.path.operation == CCS_TYPE_SYMLINK &&
-			   ccs_preference.learning_symlink_target) {
-			symlink = strstr(header, " symlink.target=\"");
-			if (symlink)
-				ccs_truncate(symlink + 1);
-		}
-		handler = strstr(header, "type=execute_handler");
-		if (handler)
-			ccs_truncate(handler);
-		buffer = kmalloc(len, CCS_GFP_FLAGS);
-		if (buffer) {
-			va_start(args, fmt);
-			vsnprintf(buffer, len - 1, fmt, args);
-			va_end(args);
-			if (handler)
-				ccs_addprintf(buffer, len, " task.%s",
-					      handler);
-			if (realpath)
-				ccs_addprintf(buffer, len, " exec.%s",
-					      realpath);
-			if (argv0)
-				ccs_addprintf(buffer, len, " exec.argv[0]=%s",
-					      argv0);
-			if (symlink)
-				ccs_addprintf(buffer, len, "%s", symlink);
-			ccs_normalize_line(buffer);
-			ccs_write_domain2(buffer, domain, false);
-			kfree(buffer);
-		}
-		kfree(header);
+	/* Nothing more to do if granted. */
+	if (r->granted)
 		return 0;
-	}
-	if (r->mode != CCS_CONFIG_ENFORCING)
-		return 0;
-	if (!atomic_read(&ccs_query_observers)) {
+	switch (r->mode) {
 		int i;
+	case CCS_CONFIG_ENFORCING:
+		error = -EPERM;
+		if (atomic_read(&ccs_query_observers))
+			break;
 		if (current->ccs_flags & CCS_DONT_SLEEP_ON_ENFORCE_ERROR)
-			return -EPERM;
+			goto out;
+		/* Check PREFERENCE::enforcing sleep parameter. */
 		for (i = 0; i < ccs_preference.enforcing_penalty; i++) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(HZ / 10);
 		}
-		return -EPERM;
+		goto out;
+	case CCS_CONFIG_LEARNING:
+		error = 0;
+		/* Check PREFERENCE::learning max_entry parameter. */
+		if (ccs_domain_quota_ok(r))
+			break;
+		/* fall through */
+	default:
+		return 0;
 	}
-	header = ccs_init_log(&len, r);
-	if (!header)
+	/* Get message. */
+	va_start(args, fmt);
+	entry.query = ccs_init_log(&len, r, fmt, args);
+	va_end(args);
+	if (!entry.query)
 		goto out;
-	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
-	if (!entry)
+	entry.query_len = strlen(entry.query) + 1;
+	if (!error) {
+		ccs_add_entry(entry.query);
 		goto out;
-	len = ccs_round2(len);
-	entry->query = kzalloc(len, CCS_GFP_FLAGS);
-	if (!entry->query)
-		goto out;
+	}
 	spin_lock(&ccs_query_list_lock);
-	if (ccs_quota_for_query && ccs_query_memory_size + len +
-	    sizeof(*entry) >= ccs_quota_for_query) {
+	if (ccs_quota_for_query && ccs_query_memory_size + len
+	    >= ccs_quota_for_query) {
 		quota_exceeded = true;
 	} else {
-		ccs_query_memory_size += len + sizeof(*entry);
-		entry->serial = ccs_serial++;
+		entry.serial = ccs_serial++;
+		entry.retry = r->retry;
+		ccs_query_memory_size += len;
+		list_add_tail(&entry.list, &ccs_query_list);
 	}
 	spin_unlock(&ccs_query_list_lock);
 	if (quota_exceeded)
 		goto out;
-	pos = snprintf(entry->query, len - 1, "Q%u-%hu\n%s",
-		       entry->serial, r->retry, header);
-	kfree(header);
-	header = NULL;
-	va_start(args, fmt);
-	vsnprintf(entry->query + pos, len - 1 - pos, fmt, args);
-	entry->query_len = strlen(entry->query) + 1;
-	va_end(args);
-	spin_lock(&ccs_query_list_lock);
-	list_add_tail(&entry->list, &ccs_query_list);
-	spin_unlock(&ccs_query_list_lock);
 	/* Give 10 seconds for supervisor's opinion. */
-	for (entry->timer = 0;
-	     atomic_read(&ccs_query_observers) && entry->timer < 100;
-	     entry->timer++) {
-		wake_up(&ccs_query_wait);
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(HZ / 10);
-		if (entry->answer)
+	while (entry.timer < 10) {
+		wake_up_all(&ccs_query_wait);
+		if (wait_event_interruptible_timeout
+		    (ccs_answer_wait, entry.answer ||
+		     !atomic_read(&ccs_query_observers), HZ))
 			break;
+		else
+			entry.timer++;
 	}
 	spin_lock(&ccs_query_list_lock);
-	list_del(&entry->list);
-	ccs_query_memory_size -= len + sizeof(*entry);
+	list_del(&entry.list);
+	ccs_query_memory_size -= len;
 	spin_unlock(&ccs_query_list_lock);
-	switch (entry->answer) {
+	switch (entry.answer) {
 	case 3: /* Asked to retry by administrator. */
 		error = CCS_RETRY_REQUEST;
 		r->retry++;
@@ -2069,18 +2032,12 @@
 		/* Granted by administrator. */
 		error = 0;
 		break;
-	case 0:
-		/* Timed out. */
-		break;
 	default:
-		/* Rejected by administrator. */
+		/* Timed out or rejected by administrator. */
 		break;
 	}
  out:
-	if (entry)
-		kfree(entry->query);
-	kfree(entry);
-	kfree(header);
+	kfree(entry.query);
 	return error;
 }
 
@@ -2151,7 +2108,7 @@
 		head->r.query_index = 0;
 		return;
 	}
-	buf = kzalloc(len, CCS_GFP_FLAGS);
+	buf = kzalloc(len + 32, CCS_GFP_FLAGS);
 	if (!buf)
 		return;
 	pos = 0;
@@ -2167,7 +2124,8 @@
 		 * can change, but I don't care.
 		 */
 		if (len == ptr->query_len)
-			memmove(buf, ptr->query, len);
+			snprintf(buf, len + 32, "Q%u-%hu\n%s", ptr->serial,
+				 ptr->retry, ptr->query);
 		break;
 	}
 	spin_unlock(&ccs_query_list_lock);
@@ -2211,6 +2169,7 @@
 		break;
 	}
 	spin_unlock(&ccs_query_list_lock);
+	wake_up_all(&ccs_answer_wait);
 	return 0;
 }
 
@@ -2348,8 +2307,14 @@
 			return -ENOMEM;
 		}
 	}
-	if (type != CCS_QUERY &&
-	    type != CCS_GRANTLOG && type != CCS_REJECTLOG)
+	/*
+	 * If the file is /proc/ccs/query , increment the observer counter.
+	 * The obserber counter is used by ccs_supervisor() to see if
+	 * there is some process monitoring /proc/ccs/query.
+	 */
+	if (type == CCS_QUERY)
+		atomic_inc(&ccs_query_observers);
+	else if (type != CCS_GRANTLOG && type != CCS_REJECTLOG)
 		head->reader_idx = ccs_lock();
 	file->private_data = head;
 	/*
@@ -2359,13 +2324,6 @@
 	 */
 	if (type == CCS_SELFDOMAIN)
 		ccs_read_control(file, NULL, 0);
-	/*
-	 * If the file is /proc/ccs/query , increment the observer counter.
-	 * The obserber counter is used by ccs_supervisor() to see if
-	 * there is some process monitoring /proc/ccs/query.
-	 */
-	else if (type == CCS_QUERY)
-		atomic_inc(&ccs_query_observers);
 	return 0;
 }
 
@@ -2503,10 +2461,10 @@
 	/*
 	 * If the file is /proc/ccs/query , decrement the observer counter.
 	 */
-	if (type == CCS_QUERY)
-		atomic_dec(&ccs_query_observers);
-	if (type != CCS_QUERY &&
-	    type != CCS_GRANTLOG && type != CCS_REJECTLOG)
+	if (type == CCS_QUERY) {
+		if (atomic_dec_and_test(&ccs_query_observers))
+			wake_up_all(&ccs_answer_wait);
+	} else if (type != CCS_GRANTLOG && type != CCS_REJECTLOG)
 		ccs_unlock(head->reader_idx);
 	/* Release memory used for policy I/O. */
 	kfree(head->read_buf);
Index: gc.c
===================================================================
--- gc.c	(revision 3989)
+++ gc.c	(working copy)
@@ -58,21 +58,6 @@
 }
 
 /**
- * ccs_del_file_pattern - Delete members in "struct ccs_pattern".
- *
- * @element: Pointer to "struct list_head".
- *
- * Returns size of @element (for later kfree()).
- */
-static inline size_t ccs_del_file_pattern(struct list_head *element)
-{
-	struct ccs_pattern *ptr =
-		container_of(element, typeof(*ptr), head.list);
-	ccs_put_name(ptr->pattern);
-	return sizeof(*ptr);
-}
-
-/**
  * ccs_del_transition_control - Delete members in "struct ccs_transition_control".
  *
  * @element: Pointer to "struct list_head".
@@ -692,9 +677,6 @@
 		case CCS_ID_TRANSITION_CONTROL:
 			size = ccs_del_transition_control(element);
 			break;
-		case CCS_ID_PATTERN:
-			size = ccs_del_file_pattern(element);
-			break;
 		case CCS_ID_MANAGER:
 			size = ccs_del_manager(element);
 			break;
Index: network.c
===================================================================
--- network.c	(revision 3989)
+++ network.c	(working copy)
@@ -59,18 +59,12 @@
 };
 
 static int ccs_audit_net_log(struct ccs_request_info *r, const char *family,
-			     const u8 proto, const u8 ope, const char *address)
+			     const u8 protocol, const u8 operation,
+			     const char *address)
 {
-	const char *protocol = ccs_proto_keyword[proto];
-	const char *operation = ccs_socket_keyword[ope];
-	ccs_write_log(r, "network %s %s %s %s\n", family,
-		      protocol, operation, address);
-	if (r->granted)
-		return 0;
-	ccs_warn_log(r, "network %s %s %s %s\n", family, protocol, operation,
-		     address);
-	return ccs_supervisor(r, "network %s %s %s %s\n", family, protocol,
-			      operation, address);
+	return ccs_supervisor(r, "network %s %s %s %s\n", family,
+			      ccs_proto_keyword[protocol],
+			      ccs_socket_keyword[operation], address);
 }
 
 /**
