Index: branches/ccs-patch/security/ccsecurity/load_policy.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/load_policy.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/load_policy.c	(working copy)
@@ -191,4 +191,3 @@
 		}
 	}
 }
-
Index: branches/ccs-patch/security/ccsecurity/chroot.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/chroot.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/chroot.c	(working copy)
@@ -31,10 +31,8 @@
 static int ccs_audit_chroot_log(struct ccs_request_info *r,
 				const char *root, const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain))
-		printk(KERN_WARNING "%s: chroot %s denied for %s\n",
-		       ccs_get_msg(r->mode == 3), root,
-		       ccs_get_last_name(r->domain));
+	if (!is_granted)
+		ccs_warn_log(r, "chroot %s", root);
 	return ccs_write_audit_log(is_granted, r, CCS_KEYWORD_ALLOW_CHROOT
 				   "%s\n", root);
 }
@@ -54,25 +52,25 @@
 	int error;
 	struct ccs_path_info dir;
 	char *root_name;
-	bool is_enforce;
 	struct ccs_obj_info obj = {
 		.path1 = *path
 	};
 	ccs_assert_read_lock();
-	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_CHROOT))
+	if (ccs_init_request_info(&r, NULL, CCS_MAC_FILE_CHROOT)
+	    == CCS_MAC_MODE_DISABLED)
 		return 0;
-	is_enforce = (r.mode == 3);
 	r.obj = &obj;
- retry:
-	error = -EPERM;
+	error = -ENOMEM;
 	root_name = ccs_realpath_from_path(path);
 	if (!root_name)
 		goto out;
 	dir.name = root_name;
 	ccs_fill_path_info(&dir);
-	if (dir.is_dir) {
+	if (!dir.is_dir)
+		goto out;
+	do {
 		struct ccs_acl_info *ptr;
+		error = -EPERM;
 		list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
 			struct ccs_chroot_acl *acl;
 			if (ptr->is_deleted ||
@@ -87,16 +85,15 @@
 			error = 0;
 			break;
 		}
-	}
-	ccs_audit_chroot_log(&r, root_name, !error);
-	if (error)
+		ccs_audit_chroot_log(&r, root_name, !error);
+		if (!error)
+			break;
 		error = ccs_supervisor(&r, CCS_KEYWORD_ALLOW_CHROOT
-					     "%s\n", ccs_file_pattern(&dir));
+				       "%s\n", ccs_file_pattern(&dir));
+	} while (error == 1);
  out:
 	kfree(root_name);
-	if (error == 1)
-		goto retry;
-	if (!is_enforce)
+	if (r.mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	return error;
 }
Index: branches/ccs-patch/security/ccsecurity/realpath.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/realpath.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/realpath.c	(working copy)
@@ -80,7 +80,7 @@
 
 	if (buflen < 256)
 		goto out;
-	
+
 	*pos = '\0';
 	for (;;) {
 		struct dentry *parent;
@@ -158,50 +158,51 @@
 	struct dentry *dentry = path->dentry;
 	if (!dentry)
 		return NULL;
- retry:
-	buf_len <<= 1;
-	kfree(buf);
-	buf = kmalloc(buf_len, GFP_KERNEL);
-	if (!buf)
-		goto done;
-	/* Get better name for socket. */
-	if (dentry->d_sb && dentry->d_sb->s_magic == SOCKFS_MAGIC) {
-		struct inode *inode = dentry->d_inode;
-		struct socket *sock = inode ? SOCKET_I(inode) : NULL;
-		struct sock *sk = sock ? sock->sk : NULL;
-		if (sk) {
-			snprintf(buf, buf_len - 1,
-				 "socket:[family=%u:type=%u:protocol=%u]",
-				 sk->sk_family, sk->sk_type, sk->sk_protocol);
-		} else {
-			snprintf(buf, buf_len - 1, "socket:[unknown]");
+	while (1) {
+		buf_len <<= 1;
+		kfree(buf);
+		buf = kmalloc(buf_len, GFP_KERNEL);
+		if (!buf)
+			break;
+		/* Get better name for socket. */
+		if (dentry->d_sb && dentry->d_sb->s_magic == SOCKFS_MAGIC) {
+			struct inode *inode = dentry->d_inode;
+			struct socket *sock = inode ? SOCKET_I(inode) : NULL;
+			struct sock *sk = sock ? sock->sk : NULL;
+			if (sk) {
+				snprintf(buf, buf_len - 1, "socket:[family=%u:"
+					 "type=%u:protocol=%u]", sk->sk_family,
+					 sk->sk_type, sk->sk_protocol);
+			} else {
+				snprintf(buf, buf_len - 1, "socket:[unknown]");
+			}
+			cp = ccs_encode(buf);
+			break;
 		}
-		cp = ccs_encode(buf);
-		goto done;
-	}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
-	/* For "socket:[\$]" and "pipe:[\$]". */
-	if (dentry->d_op && dentry->d_op->d_dname) {
-		cp = dentry->d_op->d_dname(dentry, buf, buf_len - 1);
+		/* For "socket:[\$]" and "pipe:[\$]". */
+		if (dentry->d_op && dentry->d_op->d_dname) {
+			cp = dentry->d_op->d_dname(dentry, buf, buf_len - 1);
+			if (IS_ERR(cp))
+				continue;
+			cp = ccs_encode(cp);
+			break;
+		}
+#endif
+		if (!path->mnt) {
+			cp = NULL;
+			break;
+		}
+		path_get(path);
+		ccs_realpath_lock();
+		cp = ccs_get_absolute_path(path, buf, buf_len - 1);
+		ccs_realpath_unlock();
+		path_put(path);
 		if (IS_ERR(cp))
-			goto retry;
+			continue;
 		cp = ccs_encode(cp);
-		goto done;
+		break;
 	}
-#endif
-	if (!path->mnt) {
-		kfree(buf);
-		return NULL;
-	}
-	path_get(path);
-	ccs_realpath_lock();
-	cp = ccs_get_absolute_path(path, buf, buf_len - 1);
-	ccs_realpath_unlock();
-	path_put(path);
-	if (IS_ERR(cp))
-		goto retry;
-	cp = ccs_encode(cp);
- done:
 	kfree(buf);
 	if (!cp)
 		ccs_warn_oom(__func__);
Index: branches/ccs-patch/security/ccsecurity/address_group.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/address_group.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/address_group.c	(working copy)
@@ -192,8 +192,8 @@
 			char buf[128];
 			struct ccs_address_group_member *member;
 			member = list_entry(mpos,
-					     struct ccs_address_group_member,
-					     list);
+					    struct ccs_address_group_member,
+					    list);
 			if (member->is_deleted)
 				continue;
 			if (member->is_ipv6) {
Index: branches/ccs-patch/security/ccsecurity/mount.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/mount.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/mount.c	(working copy)
@@ -62,29 +62,23 @@
 			       const char *type, const unsigned long flags,
 			       const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain)) {
-		const bool is_enforce = (r->mode == 3);
-		const char *msg = ccs_get_msg(is_enforce);
-		const char *domainname = ccs_get_last_name(r->domain);
+	if (!is_granted) {
 		if (!strcmp(type, CCS_MOUNT_REMOUNT_KEYWORD))
-			printk(KERN_WARNING "%s: mount -o remount %s 0x%lX "
-			       "denied for %s.\n", msg, dir_name, flags,
-			       domainname);
+			ccs_warn_log(r, "mount -o remount %s 0x%lX", dir_name,
+				     flags);
 		else if (!strcmp(type, CCS_MOUNT_BIND_KEYWORD)
 			 || !strcmp(type, CCS_MOUNT_MOVE_KEYWORD))
-			printk(KERN_WARNING "%s: mount %s %s %s 0x%lX "
-			       "denied for %s\n", msg, type, dev_name,
-			       dir_name, flags, domainname);
+			ccs_warn_log(r, "mount %s %s %s 0x%lX", type, dev_name,
+				     dir_name, flags);
 		else if (!strcmp(type, CCS_MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
 			 !strcmp(type, CCS_MOUNT_MAKE_PRIVATE_KEYWORD) ||
 			 !strcmp(type, CCS_MOUNT_MAKE_SLAVE_KEYWORD) ||
 			 !strcmp(type, CCS_MOUNT_MAKE_SHARED_KEYWORD))
-			printk(KERN_WARNING "%s: mount %s %s 0x%lX denied for "
-			       "%s\n", msg, type, dir_name, flags, domainname);
+			ccs_warn_log(r, "mount %s %s 0x%lX", type, dir_name,
+				     flags);
 		else
-			printk(KERN_WARNING "%s: mount -t %s %s %s 0x%lX "
-			       "denied for %s\n", msg, type, dev_name,
-			       dir_name, flags, domainname);
+			ccs_warn_log(r, "mount -t %s %s %s 0x%lX", type,
+				     dev_name, dir_name, flags);
 	}
 	return ccs_write_audit_log(is_granted, r, CCS_KEYWORD_ALLOW_MOUNT
 				   "%s %s %s 0x%lu\n", dev_name, dir_name,
@@ -122,8 +116,8 @@
  * Caller holds ccs_read_lock().
  */
 static int ccs_mount_acl2(struct ccs_request_info *r, char *dev_name,
-				char *dir_name, char *type,
-				unsigned long flags)
+			  char *dir_name, char *type,
+			  unsigned long flags)
 {
 	struct ccs_obj_info obj = { };
 	struct path path;
@@ -226,10 +220,10 @@
 			    requested_type, flags, !error);
 	if (error)
 		error = ccs_supervisor(r, CCS_KEYWORD_ALLOW_MOUNT
-					     "%s %s %s 0x%lX\n",
-					     ccs_file_pattern(&rdev),
-					     ccs_file_pattern(&rdir),
-					     requested_type, flags);
+				       "%s %s %s 0x%lX\n",
+				       ccs_file_pattern(&rdev),
+				       ccs_file_pattern(&rdir),
+				       requested_type, flags);
  out:
 	kfree(requested_dev_name);
 	kfree(requested_dir_name);
@@ -258,12 +252,10 @@
  * Caller holds ccs_read_lock().
  */
 static int ccs_mount_acl(struct ccs_request_info *r, char *dev_name,
-			       char *dir_name, char *type, unsigned long flags)
+			 char *dir_name, char *type, unsigned long flags)
 {
-	const bool is_enforce = (r->mode == 3);
 	int error;
 	ccs_assert_read_lock();
- retry:
 	error = -EPERM;
 	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
 		flags &= ~MS_MGC_MSK;
@@ -299,38 +291,38 @@
 	}
 	if (flags & MS_REMOUNT)
 		error = ccs_mount_acl(r, dev_name, dir_name,
-					    CCS_MOUNT_REMOUNT_KEYWORD,
-					    flags & ~MS_REMOUNT);
+				      CCS_MOUNT_REMOUNT_KEYWORD,
+				      flags & ~MS_REMOUNT);
 	else if (flags & MS_MOVE)
 		error = ccs_mount_acl(r, dev_name, dir_name,
-					    CCS_MOUNT_MOVE_KEYWORD,
-					    flags & ~MS_MOVE);
+				      CCS_MOUNT_MOVE_KEYWORD,
+				      flags & ~MS_MOVE);
 	else if (flags & MS_BIND)
 		error = ccs_mount_acl(r, dev_name, dir_name,
-					    CCS_MOUNT_BIND_KEYWORD,
-					    flags & ~MS_BIND);
+				      CCS_MOUNT_BIND_KEYWORD,
+				      flags & ~MS_BIND);
 	else if (flags & MS_UNBINDABLE)
 		error = ccs_mount_acl(r, dev_name, dir_name,
-					    CCS_MOUNT_MAKE_UNBINDABLE_KEYWORD,
-					    flags & ~MS_UNBINDABLE);
+				      CCS_MOUNT_MAKE_UNBINDABLE_KEYWORD,
+				      flags & ~MS_UNBINDABLE);
 	else if (flags & MS_PRIVATE)
 		error = ccs_mount_acl(r, dev_name, dir_name,
-					    CCS_MOUNT_MAKE_PRIVATE_KEYWORD,
-					    flags & ~MS_PRIVATE);
+				      CCS_MOUNT_MAKE_PRIVATE_KEYWORD,
+				      flags & ~MS_PRIVATE);
 	else if (flags & MS_SLAVE)
 		error = ccs_mount_acl(r, dev_name, dir_name,
-					    CCS_MOUNT_MAKE_SLAVE_KEYWORD,
-					    flags & ~MS_SLAVE);
+				      CCS_MOUNT_MAKE_SLAVE_KEYWORD,
+				      flags & ~MS_SLAVE);
 	else if (flags & MS_SHARED)
 		error = ccs_mount_acl(r, dev_name, dir_name,
-					    CCS_MOUNT_MAKE_SHARED_KEYWORD,
-					    flags & ~MS_SHARED);
+				      CCS_MOUNT_MAKE_SHARED_KEYWORD,
+				      flags & ~MS_SHARED);
 	else
-		error = ccs_mount_acl2(r, dev_name, dir_name, type,
-					     flags);
-	if (error == 1)
-		goto retry;
-	if (!is_enforce)
+		do {
+			error = ccs_mount_acl2(r, dev_name, dir_name, type,
+					       flags);
+		} while (error == 1);
+	if (r->mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	return error;
 }
@@ -346,15 +338,15 @@
  * Returns 0 on success, negative value otherwise.
  */
 int ccs_mount_permission(char *dev_name, char *dir_name, char *type,
-			       const unsigned long *flags)
+			 const unsigned long *flags)
 {
 	struct ccs_request_info r;
 	int error;
 	int idx;
 	if (!ccs_capable(CCS_SYS_MOUNT))
 		return -EPERM;
-	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_MOUNT))
+	if (ccs_init_request_info(&r, NULL, CCS_MAC_FILE_MOUNT)
+	    == CCS_MAC_MODE_DISABLED)
 		return 0;
 	if (!type)
 		type = "<NULL>";
@@ -381,7 +373,7 @@
 	struct ccs_mount_acl *entry = NULL;
 	struct ccs_acl_info *ptr;
 	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL,
-					  .head.cond = condition };
+				   .head.cond = condition };
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	char *w[4];
 	if (!ccs_tokenize(data, w, sizeof(w)) || !w[3][0])
Index: branches/ccs-patch/security/ccsecurity/pivot_root.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/pivot_root.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/pivot_root.c	(working copy)
@@ -33,10 +33,8 @@
 				    const char *new_root, const char *old_root,
 				    const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain))
-		printk(KERN_WARNING "%s: pivot_root %s %s "
-		       "denied for %s\n", ccs_get_msg(r->mode == 3), new_root,
-		       old_root, ccs_get_last_name(r->domain));
+	if (!is_granted)
+		ccs_warn_log(r, "pivot_root %s %s", new_root, old_root);
 	return ccs_write_audit_log(is_granted, r, CCS_KEYWORD_ALLOW_PIVOT_ROOT
 				   "%s %s\n", new_root, old_root);
 }
@@ -63,15 +61,12 @@
 	char *new_root;
 	struct ccs_path_info old_root_dir;
 	struct ccs_path_info new_root_dir;
-	bool is_enforce;
 	ccs_assert_read_lock();
-	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_PIVOT_ROOT))
+	if (ccs_init_request_info(&r, NULL, CCS_MAC_FILE_PIVOT_ROOT)
+	    == CCS_MAC_MODE_DISABLED)
 		return 0;
-	is_enforce = (r.mode == 3);
 	r.obj = &obj;
- retry:
-	error = -EPERM;
+	error = -ENOENT;
 	old_root = ccs_realpath_from_path(old);
 	new_root = ccs_realpath_from_path(new);
 	if (!old_root || !new_root)
@@ -80,15 +75,17 @@
 	ccs_fill_path_info(&old_root_dir);
 	new_root_dir.name = new_root;
 	ccs_fill_path_info(&new_root_dir);
-	if (old_root_dir.is_dir && new_root_dir.is_dir) {
+	if (!old_root_dir.is_dir || !new_root_dir.is_dir)
+		goto out;
+	do {
 		struct ccs_acl_info *ptr;
+		error = -EPERM;
 		list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
 			struct ccs_pivot_root_acl *acl;
 			if (ptr->is_deleted ||
 			    ptr->type != CCS_TYPE_PIVOT_ROOT_ACL)
 				continue;
-			acl = container_of(ptr,
-					   struct ccs_pivot_root_acl,
+			acl = container_of(ptr, struct ccs_pivot_root_acl,
 					   head);
 			if (!ccs_compare_name_union(&old_root_dir,
 						    &acl->old_root) ||
@@ -100,19 +97,18 @@
 			error = 0;
 			break;
 		}
-	}
-	ccs_audit_pivot_root_log(&r, new_root, old_root, !error);
-	if (error)
+		ccs_audit_pivot_root_log(&r, new_root, old_root, !error);
+		if (!error)
+			break;
 		error = ccs_supervisor(&r, CCS_KEYWORD_ALLOW_PIVOT_ROOT
-					     "%s %s\n",
-					     ccs_file_pattern(&new_root_dir),
-					     ccs_file_pattern(&old_root_dir));
+				       "%s %s\n",
+				       ccs_file_pattern(&new_root_dir),
+				       ccs_file_pattern(&old_root_dir));
+	} while (error == 1);
  out:
 	kfree(old_root);
 	kfree(new_root);
-	if (error == 1)
-		goto retry;
-	if (!is_enforce)
+	if (r.mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	return error;
 }
@@ -134,7 +130,7 @@
  * Returns 0 on success, negative value otherwise.
  */
 int ccs_pivot_root_permission(struct PATH_or_NAMEIDATA *old_path,
-				    struct PATH_or_NAMEIDATA *new_path)
+			      struct PATH_or_NAMEIDATA *new_path)
 {
 #if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 25) || LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 26)
 	struct path old = { old_path->path.mnt, old_path->path.dentry };
Index: branches/ccs-patch/security/ccsecurity/audit.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/audit.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/audit.c	(working copy)
@@ -268,12 +268,12 @@
 	if (is_granted) {
 		if (ccs_grant_log_count >=
 		    ccs_flags(r->domain, CCS_MAX_GRANT_LOG) ||
-		    ccs_profile_ptr[r->profile]->no_grant_log[r->type])
+		    !ccs_get_audit(r->profile, r->type, true))
 			goto out;
 	} else {
 		if (ccs_reject_log_count >=
 		    ccs_flags(r->domain, CCS_MAX_REJECT_LOG) ||
-		    ccs_profile_ptr[r->profile]->no_reject_log[r->type])
+		    !ccs_get_audit(r->profile, r->type, false))
 			goto out;
 	}
 	va_start(args, fmt);
@@ -331,14 +331,12 @@
  * ccs_read_grant_log - Read a grant log.
  *
  * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0.
  */
-int ccs_read_grant_log(struct ccs_io_buffer *head)
+void ccs_read_grant_log(struct ccs_io_buffer *head)
 {
 	struct ccs_log_entry *ptr = NULL;
 	if (head->read_avail)
-		return 0;
+		return;
 	if (head->read_buf) {
 		kfree(head->read_buf);
 		head->read_buf = NULL;
@@ -359,7 +357,6 @@
 		head->readbuf_size = head->read_avail;
 		kfree(ptr);
 	}
-	return 0;
 }
 
 /**
@@ -384,14 +381,12 @@
  * ccs_read_reject_log - Read a reject log.
  *
  * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0.
  */
-int ccs_read_reject_log(struct ccs_io_buffer *head)
+void ccs_read_reject_log(struct ccs_io_buffer *head)
 {
 	struct ccs_log_entry *ptr = NULL;
 	if (head->read_avail)
-		return 0;
+		return;
 	if (head->read_buf) {
 		kfree(head->read_buf);
 		head->read_buf = NULL;
@@ -412,7 +407,6 @@
 		head->readbuf_size = head->read_avail;
 		kfree(ptr);
 	}
-	return 0;
 }
 
 /**
Index: branches/ccs-patch/security/ccsecurity/domain.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/domain.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/domain.c	(working copy)
@@ -36,22 +36,6 @@
 LIST_HEAD(ccs_domain_list);
 
 /**
- * ccs_get_last_name - Get last component of a domainname.
- *
- * @domain: Pointer to "struct ccs_domain_info".
- *
- * Returns the last component of the domainname.
- */
-const char *ccs_get_last_name(const struct ccs_domain_info *domain)
-{
-	const char *cp0 = domain->domainname->name;
-	const char *cp1 = strrchr(cp0, ' ');
-	if (cp1)
-		return cp1 + 1;
-	return cp0;
-}
-
-/**
  * ccs_audit_execute_handler_log - Audit execute_handler log.
  *
  * @ee:         Pointer to "struct ccs_execve_entry".
@@ -64,7 +48,7 @@
 {
 	struct ccs_request_info *r = &ee->r;
 	const char *handler = ee->handler->name;
-	r->mode = ccs_flags(r->domain, CCS_MAC_EXECUTE);
+	r->mode = ccs_flags(r->domain, CCS_MAC_FILE_EXECUTE);
 	return ccs_write_audit_log(true, r, "%s %s\n",
 				   is_default ? CCS_KEYWORD_EXECUTE_HANDLER :
 				   CCS_KEYWORD_DENIED_EXECUTE_HANDLER, handler);
@@ -81,7 +65,7 @@
 {
 	int error;
 	struct ccs_request_info r;
-	ccs_init_request_info(&r, domain, CCS_MAC_EXECUTE);
+	ccs_init_request_info(&r, domain, CCS_MAC_FILE_EXECUTE);
 	error = ccs_write_audit_log(false, &r, "use_profile %u\n", r.profile);
 	return error;
 }
@@ -168,7 +152,7 @@
 		const char *domain = "";
 		struct ccs_domain_initializer_entry *ptr;
 		ptr = list_entry(pos, struct ccs_domain_initializer_entry,
-				  list);
+				 list);
 		if (ptr->is_deleted)
 			continue;
 		no = ptr->is_not ? "no_" : "";
@@ -176,9 +160,9 @@
 			from = " from ";
 			domain = ptr->domainname->name;
 		}
-		done = ccs_io_printf(head,
-				     "%s" CCS_KEYWORD_INITIALIZE_DOMAIN "%s%s%s\n",
-				     no, ptr->program->name, from, domain);
+		done = ccs_io_printf(head, "%s" CCS_KEYWORD_INITIALIZE_DOMAIN
+				     "%s%s%s\n", no, ptr->program->name, from,
+				     domain);
 		if (!done)
 			break;
 	}
@@ -595,26 +579,28 @@
 	struct ccs_domain_info *domain = NULL;
 	const char *old_domain_name = r->domain->domainname->name;
 	struct linux_binprm *bprm = ee->bprm;
-	const u8 mode = r->mode;
-	const bool is_enforce = (mode == 3);
 	const u32 ccs_flags = current->ccs_flags;
 	struct ccs_path_info rn = { }; /* real name */
 	struct ccs_path_info ln; /* last name */
 	int retval;
 	bool need_kfree = false;
 	ccs_assert_read_lock();
+	ln.name = ccs_last_word(old_domain_name);
+	ccs_fill_path_info(&ln);
  retry:
 	current->ccs_flags = ccs_flags;
 	r->cond = NULL;
+	if (need_kfree) {
+		kfree(rn.name);
+		need_kfree = false;
+	}
+
 	/* Get symlink's pathname of program. */
 	retval = ccs_symlink_path(bprm->filename, &rn);
 	if (retval < 0)
 		goto out;
 	need_kfree = true;
 
-	ln.name = ccs_get_last_name(r->domain);
-	ccs_fill_path_info(&ln);
-
 	if (handler) {
 		if (ccs_pathcmp(&rn, handler)) {
 			/* Failed to verify execute handler. */
@@ -626,33 +612,29 @@
 			}
 			goto out;
 		}
-		goto calculate_domain;
-	}
-
-	/* Check 'aggregator' directive. */
-	{
+	} else {
 		struct ccs_aggregator_entry *ptr;
-		/* Is this program allowed to be aggregated? */
+		/* Check 'aggregator' directive. */
 		list_for_each_entry_rcu(ptr, &ccs_aggregator_list, list) {
 			if (ptr->is_deleted ||
 			    !ccs_path_matches_pattern(&rn, ptr->original_name))
 				continue;
 			kfree(rn.name);
 			need_kfree = false;
+			/* This is OK because it is read only. */
 			rn = *ptr->aggregated_name;
 			break;
 		}
+
+		/* Check execute permission. */
+		retval = ccs_exec_perm(r, &rn);
+		if (retval == 1)
+			goto retry;
+		if (retval < 0)
+			goto out;
 	}
 
-	/* Check execute permission. */
-	r->mode = mode;
-	retval = ccs_exec_perm(r, &rn);
-	if (retval == 1)
-		goto retry;
-	if (retval < 0)
-		goto out;
-
- calculate_domain:
+	/* Calculate domain to transit to. */
 	if (ccs_is_domain_initializer(r->domain->domainname, &rn, &ln)) {
 		/* Transit to the child of ccs_kernel_domain domain. */
 		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, ROOT_NAME " " "%s",
@@ -677,7 +659,7 @@
 	domain = ccs_find_domain(ee->tmp);
 	if (domain)
 		goto done;
-	if (is_enforce) {
+	if (r->mode == CCS_MAC_MODE_ENFORCING) {
 		int error = ccs_supervisor(r, "# wants to create domain\n"
 					   "%s\n", ee->tmp);
 		if (error == 1)
@@ -692,7 +674,7 @@
 	if (!domain) {
 		printk(KERN_WARNING "ERROR: Domain '%s' not defined.\n",
 		       ee->tmp);
-		if (is_enforce)
+		if (r->mode == CCS_MAC_MODE_ENFORCING)
 			retval = -EPERM;
 		else {
 			retval = 0;
@@ -1267,7 +1249,7 @@
 		ccs_load_policy(bprm->filename);
 	if (!ee)
 		return -ENOMEM;
-	ccs_init_request_info(&ee->r, NULL, CCS_MAC_EXECUTE);
+	ccs_init_request_info(&ee->r, NULL, CCS_MAC_FILE_EXECUTE);
 	ee->r.ee = ee;
 	ee->bprm = bprm;
 	ee->r.obj = &ee->obj;
Index: branches/ccs-patch/security/ccsecurity/memory.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/memory.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/memory.c	(working copy)
@@ -335,42 +335,38 @@
  * ccs_read_memory_counter - Check for memory usage.
  *
  * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns memory usage.
  */
-int ccs_read_memory_counter(struct ccs_io_buffer *head)
+void ccs_read_memory_counter(struct ccs_io_buffer *head)
 {
-	if (!head->read_eof) {
-		const unsigned int usage[3] = {
-			atomic_read(&ccs_policy_memory_size),
-			ccs_audit_log_memory_size,
-			ccs_query_memory_size
-		};
-		const unsigned int quota[3] = {
-			ccs_quota_for_policy,
-			ccs_quota_for_audit_log,
-			ccs_quota_for_query
-		};
-		static const char *header[4] = {
-			"Policy:     ",
-			"Audit logs: ",
-			"Query lists:",
-			"Total:      "
-		};
-		unsigned int total = 0;
-		int i;
-		for (i = 0; i < 3; i++) {
-			total += usage[i];
-			ccs_io_printf(head, "%s %10u", header[i], usage[i]);
-			if (quota[i])
-				ccs_io_printf(head, "   (Quota: %10u)",
-					      quota[i]);
-			ccs_io_printf(head, "\n");
-		}
-		ccs_io_printf(head, "%s %10u\n", header[3], total);
-		head->read_eof = true;
+	const unsigned int usage[3] = {
+		atomic_read(&ccs_policy_memory_size),
+		ccs_audit_log_memory_size,
+		ccs_query_memory_size
+	};
+	const unsigned int quota[3] = {
+		ccs_quota_for_policy,
+		ccs_quota_for_audit_log,
+		ccs_quota_for_query
+	};
+	static const char *header[4] = {
+		"Policy:     ",
+		"Audit logs: ",
+		"Query lists:",
+		"Total:      "
+	};
+	unsigned int total = 0;
+	int i;
+	if (head->read_eof)
+		return;
+	for (i = 0; i < 3; i++) {
+		total += usage[i];
+		ccs_io_printf(head, "%s %10u", header[i], usage[i]);
+		if (quota[i])
+			ccs_io_printf(head, "   (Quota: %10u)", quota[i]);
+		ccs_io_printf(head, "\n");
 	}
-	return 0;
+	ccs_io_printf(head, "%s %10u\n", header[3], total);
+	head->read_eof = true;
 }
 
 /**
Index: branches/ccs-patch/security/ccsecurity/maymount.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/maymount.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/maymount.c	(working copy)
@@ -44,8 +44,8 @@
  * Returns true if @vfsmnt is parent directory compared to @nd, false otherwise.
  */
 static bool ccs_conceal_mount(struct PATH_or_NAMEIDATA *path,
-				    struct vfsmount *vfsmnt,
-				    struct dentry *dentry)
+			      struct vfsmount *vfsmnt,
+			      struct dentry *dentry)
 {
 	while (1) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25) && LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 26)
@@ -88,9 +88,10 @@
 #else
 	struct mnt_namespace *namespace = current->nsproxy->mnt_ns;
 #endif
-	if (!namespace || !ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL,
-				   CCS_MAX_MAC_INDEX + CCS_CONCEAL_MOUNT))
+	if (!namespace ||
+	    ccs_init_request_info(&r, NULL,
+				  CCS_MAX_MAC_INDEX + CCS_CONCEAL_MOUNT)
+	    == CCS_MAC_MODE_DISABLED)
 		return 0;
 	found = false;
 	list_for_each(p, &namespace->list) {
Index: branches/ccs-patch/security/ccsecurity/util.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/util.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/util.c	(working copy)
@@ -20,6 +20,107 @@
 /* Profile table. Memory is allocated as needed. */
 struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
 
+static const u8 ccs_index2category[CCS_MAX_MAC_INDEX +
+				   CCS_MAX_CAPABILITY_INDEX] = {
+	[CCS_MAC_FILE_EXECUTE]    = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_OPEN]       = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_CREATE]     = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_UNLINK]     = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_MKDIR]      = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_RMDIR]      = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_MKFIFO]     = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_MKSOCK]     = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_TRUNCATE]   = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_SYMLINK]    = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_REWRITE]    = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_MKBLOCK]    = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_MKCHAR]     = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_LINK]       = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_RENAME]     = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_CHMOD]      = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_CHOWN]      = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_CHGRP]      = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_IOCTL]      = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_CHROOT]     = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_MOUNT]      = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_UMOUNT]     = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_FILE_PIVOT_ROOT] = CCS_MAC_CATEGORY_FILE,
+	[CCS_MAC_ENVIRON]         = CCS_MAC_CATEGORY_MISC,
+	[CCS_MAC_NETWORK_UDP_BIND]    = CCS_MAC_CATEGORY_NETWORK,
+	[CCS_MAC_NETWORK_UDP_CONNECT] = CCS_MAC_CATEGORY_NETWORK,
+	[CCS_MAC_NETWORK_TCP_BIND]    = CCS_MAC_CATEGORY_NETWORK,
+	[CCS_MAC_NETWORK_TCP_LISTEN]  = CCS_MAC_CATEGORY_NETWORK,
+	[CCS_MAC_NETWORK_TCP_CONNECT] = CCS_MAC_CATEGORY_NETWORK,
+	[CCS_MAC_NETWORK_TCP_ACCEPT]  = CCS_MAC_CATEGORY_NETWORK,
+	[CCS_MAC_NETWORK_RAW_BIND]    = CCS_MAC_CATEGORY_NETWORK,
+	[CCS_MAC_NETWORK_RAW_CONNECT] = CCS_MAC_CATEGORY_NETWORK,
+	[CCS_MAC_SIGNAL]          = CCS_MAC_CATEGORY_IPC,
+	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_CREATE]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_LISTEN]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_CONNECT]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_USE_INET_DGRAM_SOCKET]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_USE_INET_RAW_SOCKET]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_USE_ROUTE_SOCKET]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_USE_PACKET_SOCKET]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_MOUNT]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_UMOUNT]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_REBOOT]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_CHROOT]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_KILL]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_VHANGUP]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_SETTIME]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_NICE]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_SETHOSTNAME]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_USE_KERNEL_MODULE]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_FIFO]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_BLOCK_DEV]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_CHAR_DEV]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_UNIX_SOCKET]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_LINK]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_SYMLINK]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_RENAME]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_UNLINK]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_CHMOD]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_CHOWN]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_IOCTL]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_KEXEC_LOAD]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_PIVOT_ROOT]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_SYS_PTRACE]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+	[CCS_MAX_MAC_INDEX + CCS_CONCEAL_MOUNT]
+	= CCS_MAC_CATEGORY_CAPABILITY,
+};
+
 /* Utility functions. */
 
 /**
@@ -807,47 +908,6 @@
 }
 
 /**
- * ccs_get_msg - Get warning message.
- *
- * @is_enforce: Is it enforcing mode?
- *
- * Returns "ERROR" or "WARNING".
- */
-const char *ccs_get_msg(const bool is_enforce)
-{
-	if (is_enforce)
-		return "ERROR";
-	else
-		return "WARNING";
-}
-
-/**
- * ccs_can_sleep - Check whether it is permitted to do operations that may sleep.
- *
- * Returns true if it is permitted to do operations that may sleep,
- * false otherwise.
- *
- * TOMOYO Linux supports interactive enforcement that lets processes
- * wait for the administrator's decision.
- * All hooks but the one for ccs_may_autobind() are inserted where
- * it is permitted to do operations that may sleep.
- * Thus, this warning should not happen.
- */
-bool ccs_can_sleep(void)
-{
-	static u8 count = 20;
-	if (likely(!in_interrupt()))
-		return true;
-	if (count) {
-		count--;
-		printk(KERN_ERR "BUG: sleeping function called "
-		       "from invalid context.\n");
-		dump_stack();
-	}
-	return false;
-}
-
-/**
  * ccs_flags - Check mode for specified functionality.
  *
  * @domain: Pointer to "struct ccs_domain_info". NULL for ccs_current_domain().
@@ -856,7 +916,7 @@
  * Returns the mode of specified functionality.
  */
 unsigned int ccs_flags(const struct ccs_domain_info *domain,
-			     const u8 index)
+		       const u8 index)
 {
 	u8 profile;
 	if (!domain)
@@ -871,6 +931,55 @@
 }
 
 /**
+ * ccs_get_audit - Get audit mode.
+ *
+ * @profile:    Profile number.
+ * @index:      Index number of functionality.
+ * @is_granted: True if granted log, false otehrwise.
+ *
+ * Returns mode.
+ */
+bool ccs_get_audit(const u8 profile, const u8 index, const bool is_granted)
+{
+	u8 mode;
+	const u8 category = ccs_index2category[index] + CCS_MAX_MAC_INDEX
+		+ CCS_MAX_CAPABILITY_INDEX;
+	if (!ccs_policy_loaded || !ccs_profile_ptr[profile])
+		return false;
+	mode = ccs_profile_ptr[profile]->config[index];
+	if (mode == CCS_MAC_MODE_USE_DEFAULT)
+		mode = ccs_profile_ptr[profile]->config[category];
+	if (mode == CCS_MAC_MODE_USE_DEFAULT)
+		mode = ccs_profile_ptr[profile]->default_config;
+	if (is_granted)
+		return !(mode & CCS_MAC_MODE_NO_GRANT_LOG);
+	return !(mode & CCS_MAC_MODE_NO_REJECT_LOG);
+}
+
+/**
+ * ccs_get_mode - Get MAC mode.
+ *
+ * @profile: Profile number.
+ * @index:   Index number of functionality.
+ *
+ * Returns mode.
+ */
+int ccs_get_mode(const u8 profile, const u8 index)
+{
+	u8 mode;
+	const u8 category = ccs_index2category[index] + CCS_MAX_MAC_INDEX
+		+ CCS_MAX_CAPABILITY_INDEX;
+	if (!ccs_policy_loaded || !ccs_profile_ptr[profile])
+		return CCS_MAC_MODE_DISABLED;
+	mode = ccs_profile_ptr[profile]->config[index];
+	if (mode == CCS_MAC_MODE_USE_DEFAULT)
+		mode = ccs_profile_ptr[profile]->config[category];
+	if (mode == CCS_MAC_MODE_USE_DEFAULT)
+		mode = ccs_profile_ptr[profile]->default_config;
+	return mode & 3;
+}
+
+/**
  * ccs_init_request_info - Initialize "struct ccs_request_info" members.
  *
  * @r:      Pointer to "struct ccs_request_info" to initialize.
@@ -882,32 +991,61 @@
 int ccs_init_request_info(struct ccs_request_info *r,
 			  struct ccs_domain_info *domain, const u8 index)
 {
+	u8 profile;
 	memset(r, 0, sizeof(*r));
 	if (!domain)
 		domain = ccs_current_domain();
 	r->domain = domain;
-	r->profile = domain->profile;
+	profile = domain->profile;
+	r->profile = profile;
 	r->type = index;
-	if (!ccs_policy_loaded || !ccs_profile_ptr[r->profile])
-		r->mode = 0;
-	else
-		r->mode = ccs_profile_ptr[r->profile]->mac_mode[index];
+	r->mode = ccs_get_mode(profile, index);
 	return r->mode;
 }
 
 /**
- * ccs_verbose_mode - Check whether TOMOYO is verbose mode.
+ * ccs_last_word - Get last component of a line.
  *
- * @domain: Pointer to "struct ccs_domain_info". NULL for ccs_current_domain().
+ * @line: A line.
  *
- * Returns true if domain policy violation warning should be printed to
- * console.
+ * Returns the last word of a line.
  */
-bool ccs_verbose_mode(const struct ccs_domain_info *domain)
+const char *ccs_last_word(const char *name)
 {
-	return ccs_flags(domain, CCS_VERBOSE) != 0;
+	const char *cp = strrchr(name, ' ');
+	if (cp)
+		return cp + 1;
+	return name;
 }
 
+void ccs_warn_log(struct ccs_request_info *r, const char *fmt, ...)
+{
+	int len = PAGE_SIZE;
+	va_list args;
+	char *buffer;
+	if (!ccs_flags(r->domain, CCS_VERBOSE))
+		return;
+	while (1) {
+		int len2;
+		buffer = kmalloc(len, GFP_KERNEL);
+		if (!buffer)
+			return;
+		va_start(args, fmt);
+		len2 = vsnprintf(buffer, len - 1, fmt, args);
+		va_end(args);
+		if (len2 < len - 1) {
+			buffer[len2] = '\0';
+			break;
+		}
+		len = len2 + 1;
+		kfree(buffer);
+	}
+	printk(KERN_WARNING "%s: Access %s denied for %s\n",
+	       r->mode == CCS_MAC_MODE_ENFORCING ? "ERROR" : "WARNING", buffer,
+	       ccs_last_word(r->domain->domainname->name));
+	kfree(buffer);
+}
+
 /**
  * ccs_domain_quota_ok - Check for domain's quota.
  *
Index: branches/ccs-patch/security/ccsecurity/signal.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/signal.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/signal.c	(working copy)
@@ -25,17 +25,9 @@
 static int ccs_audit_signal_log(struct ccs_request_info *r, const int signal,
 				const char *dest_domain, const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain)) {
-		const char *dest = strrchr(dest_domain, ' ');
-		if (dest)
-			dest++;
-		else
-			dest = dest_domain;
-		printk(KERN_WARNING
-		       "%s: Signal %d to %s denied for %s\n",
-		       ccs_get_msg(r->mode == 3), signal, dest,
-		       ccs_get_last_name(r->domain));
-	}
+	if (!is_granted)
+		ccs_warn_log(r, "signal %d to %s", signal,
+			     ccs_last_word(dest_domain));
 	return ccs_write_audit_log(is_granted, r, CCS_KEYWORD_ALLOW_SIGNAL
 				   "%d %s\n", signal, dest_domain);
 }
@@ -57,13 +49,11 @@
 	const char *dest_pattern;
 	struct ccs_acl_info *ptr;
 	const u16 hash = sig;
-	bool is_enforce;
 	int error;
 	ccs_assert_read_lock();
-	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_SIGNAL))
+	if (ccs_init_request_info(&r, NULL, CCS_MAC_SIGNAL)
+	    == CCS_MAC_MODE_DISABLED)
 		return 0;
-	is_enforce = (r.mode == 3);
 	if (!sig)
 		return 0;                /* No check for NULL signal. */
 	if (sys_getpid() == pid) {
@@ -92,35 +82,37 @@
 		return 0;                /* No check for self domain. */
 	}
 	dest_pattern = dest->domainname->name;
- retry:
-	error = -EPERM;
-	list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
-		struct ccs_signal_acl *acl;
-		if (ptr->is_deleted || ptr->type != CCS_TYPE_SIGNAL_ACL)
-			continue;
-		acl = container_of(ptr, struct ccs_signal_acl, head);
-		if (acl->sig == hash && ccs_condition(&r, ptr)) {
-			const int len = acl->domainname->total_len;
-			if (strncmp(acl->domainname->name, dest_pattern, len))
+	do {
+		error = -EPERM;
+		list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
+			struct ccs_signal_acl *acl;
+			if (ptr->is_deleted ||
+			    ptr->type != CCS_TYPE_SIGNAL_ACL)
 				continue;
-			switch (dest_pattern[len]) {
-			case ' ':
-			case '\0':
+			acl = container_of(ptr, struct ccs_signal_acl, head);
+			if (acl->sig == hash && ccs_condition(&r, ptr)) {
+				const int len = acl->domainname->total_len;
+				if (strncmp(acl->domainname->name,
+					    dest_pattern, len))
+					continue;
+				switch (dest_pattern[len]) {
+				case ' ':
+				case '\0':
+					break;
+				default:
+					continue;
+				}
+				r.cond = ptr->cond;
+				error = 0;
 				break;
-			default:
-				continue;
 			}
-			r.cond = ptr->cond;
-			error = 0;
-			break;
 		}
-	}
-	ccs_audit_signal_log(&r, sig, dest_pattern, !error);
-	if (error)
-		error = ccs_supervisor(&r, CCS_KEYWORD_ALLOW_SIGNAL
-					     "%d %s\n", sig, dest_pattern);
-	if (error == 1)
-		goto retry;
+		ccs_audit_signal_log(&r, sig, dest_pattern, !error);
+		if (!error)
+			break;
+		error = ccs_supervisor(&r, CCS_KEYWORD_ALLOW_SIGNAL "%d %s\n",
+				       sig, dest_pattern);
+	} while (error == 1);
 	return error;
 }
 
@@ -157,7 +149,7 @@
 	struct ccs_signal_acl *entry = NULL;
 	struct ccs_acl_info *ptr;
 	struct ccs_signal_acl e = { .head.type = CCS_TYPE_SIGNAL_ACL,
-					   .head.cond = condition };
+				    .head.cond = condition };
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	int sig;
 	char *domainname = strchr(data, ' ');
Index: branches/ccs-patch/security/ccsecurity/file.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/file.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/file.c	(working copy)
@@ -47,36 +47,36 @@
 };
 
 static const u8 ccs_p2mac[CCS_MAX_PATH_OPERATION] = {
-	[CCS_TYPE_READ_WRITE] = CCS_MAC_OPEN,
-	[CCS_TYPE_EXECUTE]    = CCS_MAC_EXECUTE,
-	[CCS_TYPE_READ]       = CCS_MAC_OPEN,
-	[CCS_TYPE_WRITE]      = CCS_MAC_OPEN,
-	[CCS_TYPE_UNLINK]     = CCS_MAC_UNLINK,
-	[CCS_TYPE_RMDIR]      = CCS_MAC_RMDIR,
-	[CCS_TYPE_TRUNCATE]   = CCS_MAC_TRUNCATE,
-	[CCS_TYPE_SYMLINK]    = CCS_MAC_SYMLINK,
-	[CCS_TYPE_REWRITE]    = CCS_MAC_REWRITE,
+	[CCS_TYPE_READ_WRITE] = CCS_MAC_FILE_OPEN,
+	[CCS_TYPE_EXECUTE]    = CCS_MAC_FILE_EXECUTE,
+	[CCS_TYPE_READ]       = CCS_MAC_FILE_OPEN,
+	[CCS_TYPE_WRITE]      = CCS_MAC_FILE_OPEN,
+	[CCS_TYPE_UNLINK]     = CCS_MAC_FILE_UNLINK,
+	[CCS_TYPE_RMDIR]      = CCS_MAC_FILE_RMDIR,
+	[CCS_TYPE_TRUNCATE]   = CCS_MAC_FILE_TRUNCATE,
+	[CCS_TYPE_SYMLINK]    = CCS_MAC_FILE_SYMLINK,
+	[CCS_TYPE_REWRITE]    = CCS_MAC_FILE_REWRITE,
 };
 
 static const u8 ccs_pnnn2mac[CCS_MAX_PATH_NUMBER3_OPERATION] = {
-	[CCS_TYPE_MKBLOCK] = CCS_MAC_MKBLOCK,
-	[CCS_TYPE_MKCHAR]  = CCS_MAC_MKCHAR,
+	[CCS_TYPE_MKBLOCK] = CCS_MAC_FILE_MKBLOCK,
+	[CCS_TYPE_MKCHAR]  = CCS_MAC_FILE_MKCHAR,
 };
 
 static const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION] = {
-	[CCS_TYPE_LINK]   = CCS_MAC_LINK,
-	[CCS_TYPE_RENAME] = CCS_MAC_RENAME,
+	[CCS_TYPE_LINK]   = CCS_MAC_FILE_LINK,
+	[CCS_TYPE_RENAME] = CCS_MAC_FILE_RENAME,
 };
 
 static const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION] = {
-	[CCS_TYPE_CREATE] = CCS_MAC_CREATE,
-	[CCS_TYPE_MKDIR]  = CCS_MAC_MKDIR,
-	[CCS_TYPE_MKFIFO] = CCS_MAC_MKFIFO,
-	[CCS_TYPE_MKSOCK] = CCS_MAC_MKSOCK,
-	[CCS_TYPE_IOCTL]  = CCS_MAC_IOCTL,
-	[CCS_TYPE_CHMOD]  = CCS_MAC_CHMOD,
-	[CCS_TYPE_CHOWN]  = CCS_MAC_CHOWN,
-	[CCS_TYPE_CHGRP]  = CCS_MAC_CHGRP,
+	[CCS_TYPE_CREATE] = CCS_MAC_FILE_CREATE,
+	[CCS_TYPE_MKDIR]  = CCS_MAC_FILE_MKDIR,
+	[CCS_TYPE_MKFIFO] = CCS_MAC_FILE_MKFIFO,
+	[CCS_TYPE_MKSOCK] = CCS_MAC_FILE_MKSOCK,
+	[CCS_TYPE_IOCTL]  = CCS_MAC_FILE_IOCTL,
+	[CCS_TYPE_CHMOD]  = CCS_MAC_FILE_CHMOD,
+	[CCS_TYPE_CHOWN]  = CCS_MAC_FILE_CHOWN,
+	[CCS_TYPE_CHGRP]  = CCS_MAC_FILE_CHGRP,
 };
 
 
@@ -207,7 +207,7 @@
 static bool ccs_get_realpath(struct ccs_path_info *buf, struct dentry *dentry,
 			     struct vfsmount *mnt)
 {
-	struct path path = { mnt, dentry }; 
+	struct path path = { mnt, dentry };
 	buf->name = ccs_realpath_from_path(&path);
 	if (buf->name) {
 		ccs_fill_path_info(buf);
@@ -217,9 +217,9 @@
 }
 
 static int ccs_update_path_acl(const u8 type, const char *filename,
-				      struct ccs_domain_info * const domain,
-				      struct ccs_condition *condition,
-				      const bool is_delete);
+			       struct ccs_domain_info * const domain,
+			       struct ccs_condition *condition,
+			       const bool is_delete);
 
 /**
  * ccs_audit_path_log - Audit single path request log.
@@ -232,14 +232,11 @@
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_audit_path_log(struct ccs_request_info *r,
-				     const char *operation,
-				     const char *filename,
-				     const bool is_granted)
+			      const char *operation, const char *filename,
+			      const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain))
-		printk(KERN_WARNING "%s: Access '%s %s' denied "
-		       "for %s\n", ccs_get_msg(r->mode == 3), operation,
-		       filename, ccs_get_last_name(r->domain));
+	if (!is_granted)
+		ccs_warn_log(r, "%s %s", operation, filename);
 	return ccs_write_audit_log(is_granted, r, "allow_%s %s\n", operation,
 				   filename);
 }
@@ -256,16 +253,11 @@
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_audit_path2_log(struct ccs_request_info *r,
-				     const char *operation,
-				     const char *filename1,
-				     const char *filename2,
-				     const bool is_granted)
+			       const char *operation, const char *filename1,
+			       const char *filename2, const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain))
-		printk(KERN_WARNING "%s: Access '%s %s %s' "
-		       "denied for %s\n", ccs_get_msg(r->mode == 3),
-		       operation, filename1, filename2,
-		       ccs_get_last_name(r->domain));
+	if (!is_granted)
+		ccs_warn_log(r, "%s %s %s", operation, filename1, filename2);
 	return ccs_write_audit_log(is_granted, r, "allow_%s %s %s\n",
 				   operation, filename1, filename2);
 }
@@ -291,11 +283,9 @@
 				      const unsigned int minor,
 				      const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain))
-		printk(KERN_WARNING "%s: Access '%s %s 0%o %u %u' denied "
-		       "for %s\n", ccs_get_msg(r->mode == 3), operation,
-		       filename, mode, major, minor,
-		       ccs_get_last_name(r->domain));
+	if (!is_granted)
+		ccs_warn_log(r, "%s %s 0%o %u %u", operation, filename, mode,
+			     major, minor);
 	return ccs_write_audit_log(is_granted, r, "allow_%s %s 0%o %u %u\n",
 				   operation, filename, mode, major, minor);
 }
@@ -316,10 +306,8 @@
 				     const char *filename, const char *value,
 				     const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain))
-		printk(KERN_WARNING "%s: Access '%s %s %s' denied "
-		       "for %s\n", ccs_get_msg(r->mode == 3), operation,
-		       filename, value, ccs_get_last_name(r->domain));
+	if (!is_granted)
+		ccs_warn_log(r, "%s %s %s", operation, filename, value);
 	return ccs_write_audit_log(is_granted, r, "allow_%s %s %s\n",
 				   operation, filename, value);
 }
@@ -604,7 +592,7 @@
 	bool done = true;
 	ccs_assert_read_lock();
 	list_for_each_cookie(pos, head->read_var2,
-			      &ccs_no_rewrite_list) {
+			     &ccs_no_rewrite_list) {
 		struct ccs_no_rewrite_entry *ptr;
 		ptr = list_entry(pos, struct ccs_no_rewrite_entry, list);
 		if (ptr->is_deleted)
@@ -651,13 +639,13 @@
 		return 0;
 	if (perm & 4)
 		ccs_update_path_acl(CCS_TYPE_READ, filename, domain,
-					   condition, is_delete);
+				    condition, is_delete);
 	if (perm & 2)
 		ccs_update_path_acl(CCS_TYPE_WRITE, filename,
-					   domain, condition, is_delete);
+				    domain, condition, is_delete);
 	if (perm & 1)
 		ccs_update_path_acl(CCS_TYPE_EXECUTE, filename,
-					   domain, condition, is_delete);
+				    domain, condition, is_delete);
 	return 0;
 }
 
@@ -674,9 +662,9 @@
  * Caller holds ccs_read_lock().
  */
 static int ccs_path_acl(struct ccs_request_info *r,
-				     const struct ccs_path_info *filename,
-				     const u16 perm,
-				     const bool may_use_pattern)
+			const struct ccs_path_info *filename,
+			const u16 perm,
+			const bool may_use_pattern)
 {
 	struct ccs_domain_info *domain = r->domain;
 	struct ccs_acl_info *ptr;
@@ -729,9 +717,9 @@
 			continue;
 		acl = container_of(ptr, struct ccs_path_number3_acl, head);
 		if (!ccs_compare_number_union(mode, &acl->mode))
-				continue;
+			continue;
 		if (!ccs_compare_number_union(major, &acl->major))
-				continue;
+			continue;
 		if (!ccs_compare_number_union(minor, &acl->minor))
 			continue;
 		if (!(acl->perm & perm) || !ccs_condition(r, ptr))
@@ -757,10 +745,8 @@
  * Caller holds ccs_read_lock().
  */
 static int ccs_file_perm(struct ccs_request_info *r,
-			       const struct ccs_path_info *filename,
-			       const u8 mode)
+			 const struct ccs_path_info *filename, const u8 mode)
 {
-	const bool is_enforce = (r->mode == 3);
 	const char *msg = "<unknown>";
 	int error = 0;
 	u16 perm = 0;
@@ -781,19 +767,23 @@
 		perm = 1 << CCS_TYPE_EXECUTE;
 	} else
 		BUG();
- retry:
-	error = ccs_path_acl(r, filename, perm, mode != 1);
-	if (error && mode == 4 && !r->domain->ignore_global_allow_read
-	    && ccs_is_globally_readable_file(filename))
-		error = 0;
-	ccs_audit_path_log(r, msg, filename->name, !error);
-	if (error)
+	do {
+		error = ccs_path_acl(r, filename, perm, mode != 1);
+		if (error && mode == 4 && !r->domain->ignore_global_allow_read
+		    && ccs_is_globally_readable_file(filename))
+			error = 0;
+		ccs_audit_path_log(r, msg, filename->name, !error);
+		if (!error)
+			break;
 		error = ccs_supervisor(r, "allow_%s %s\n", msg,
-					     mode == 1 ? filename->name :
-					     ccs_file_pattern(filename));
-	if (error == 1 && !r->ee)
-		goto retry;
-	if (!is_enforce)
+				       mode == 1 ? filename->name :
+				       ccs_file_pattern(filename));
+		/*
+		 * Do not retry for execute request, for aggregator may have
+		 * changed.
+		 */
+	} while (error == 1 && !r->ee);
+	if (r->mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	return error;
 }
@@ -877,9 +867,9 @@
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_update_path_acl(const u8 type, const char *filename,
-				      struct ccs_domain_info * const domain,
-				      struct ccs_condition *condition,
-				      const bool is_delete)
+			       struct ccs_domain_info * const domain,
+			       struct ccs_condition *condition,
+			       const bool is_delete)
 {
 	static const u16 ccs_rw_mask =
 		(1 << CCS_TYPE_READ) | (1 << CCS_TYPE_WRITE);
@@ -1026,12 +1016,12 @@
  * Returns 0 on success, negative value otherwise.
  */
 static inline int ccs_update_path2_acl(const u8 type,
-					     const char *filename1,
-					     const char *filename2,
-					     struct ccs_domain_info * const
-					     domain,
-					     struct ccs_condition *condition,
-					     const bool is_delete)
+				       const char *filename1,
+				       const char *filename2,
+				       struct ccs_domain_info * const
+				       domain,
+				       struct ccs_condition *condition,
+				       const bool is_delete)
 {
 	const u8 perm = 1 << type;
 	struct ccs_acl_info *ptr;
@@ -1095,8 +1085,8 @@
  * Caller holds ccs_read_lock().
  */
 static int ccs_path2_acl(struct ccs_request_info *r, const u8 type,
-				     const struct ccs_path_info *filename1,
-				     const struct ccs_path_info *filename2)
+			 const struct ccs_path_info *filename1,
+			 const struct ccs_path_info *filename2)
 {
 	const struct ccs_domain_info *domain = r->domain;
 	struct ccs_acl_info *ptr;
@@ -1132,29 +1122,27 @@
  * Caller holds ccs_read_lock().
  */
 static int ccs_path_permission(struct ccs_request_info *r,
-					    u8 operation,
-					    const struct ccs_path_info *
-					    filename)
+			       u8 operation,
+			       const struct ccs_path_info *
+			       filename)
 {
 	const char *msg;
 	int error;
-	bool is_enforce;
- repeat:
-	r->mode = ccs_profile_ptr[r->profile]->mac_mode[ccs_p2mac[operation]];
 	ccs_assert_read_lock();
-	if (!r->mode)
+ repeat:
+	r->mode = ccs_get_mode(r->profile, ccs_p2mac[operation]);
+	if (r->mode == CCS_MAC_MODE_DISABLED)
 		return 0;
-	is_enforce = (r->mode == 3);
- retry:
-	error = ccs_path_acl(r, filename, 1 << operation, 1);
-	msg = ccs_path2keyword(operation);
-	ccs_audit_path_log(r, msg, filename->name, !error);
-	if (error)
+	do {
+		error = ccs_path_acl(r, filename, 1 << operation, 1);
+		msg = ccs_path2keyword(operation);
+		ccs_audit_path_log(r, msg, filename->name, !error);
+		if (!error)
+			break;
 		error = ccs_supervisor(r, "allow_%s %s\n", msg,
-					     ccs_file_pattern(filename));
-	if (error == 1)
-		goto retry;
-	if (!is_enforce)
+				       ccs_file_pattern(filename));
+	} while (error == 1);
+	if (r->mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	/*
 	 * Since "allow_truncate" doesn't imply "allow_rewrite" permission,
@@ -1190,24 +1178,23 @@
 {
 	int error;
 	const char *msg = ccs_path_number32keyword(operation);
-	const bool is_enforce = (r->mode == 3);
 	const unsigned int major = MAJOR(dev);
 	const unsigned int minor = MINOR(dev);
 	ccs_assert_read_lock();
 	if (!r->mode)
 		return 0;
- retry:
-	error = ccs_path_number3_acl(r, filename, 1 << operation, mode, major,
-				     minor);
-	ccs_audit_path_number3_log(r, msg, filename->name, mode, major, minor,
-				   !error);
-	if (error)
+	do {
+		error = ccs_path_number3_acl(r, filename, 1 << operation, mode,
+					     major, minor);
+		ccs_audit_path_number3_log(r, msg, filename->name, mode, major,
+					   minor, !error);
+		if (!error)
+			break;
 		error = ccs_supervisor(r, "allow_%s %s 0%o %u %u\n", msg,
 				       ccs_file_pattern(filename), mode,
 				       major, minor);
-	if (error == 1)
-		goto retry;
-	if (!is_enforce)
+	} while (error == 1);
+	if (r->mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	return error;
 }
@@ -1223,13 +1210,11 @@
  * Caller holds ccs_read_lock().
  */
 int ccs_exec_perm(struct ccs_request_info *r,
-			const struct ccs_path_info *filename)
+		  const struct ccs_path_info *filename)
 {
 	ccs_assert_read_lock();
-	if (!ccs_can_sleep())
+	if (r->mode == CCS_MAC_MODE_DISABLED)
 		return 0;
-	if (!r->mode)
-		return 0;
 	return ccs_file_perm(r, filename, 1);
 }
 
@@ -1243,7 +1228,7 @@
  * Returns 0 on success, negative value otherwise.
  */
 int ccs_open_permission(struct dentry *dentry, struct vfsmount *mnt,
-			      const int flag)
+			const int flag)
 {
 	struct ccs_request_info r;
 	struct ccs_obj_info obj = {
@@ -1260,8 +1245,6 @@
 	    !(current->ccs_flags & CCS_CHECK_READ_FOR_OPEN_EXEC))
 		return 0;
 #endif
-	if (!ccs_can_sleep())
-		return 0;
 	if (!mnt || (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode)))
 		return 0;
 	buf.name = NULL;
@@ -1275,7 +1258,8 @@
 	 * opened for append mode or the filename is truncated at open time.
 	 */
 	if ((acc_mode & MAY_WRITE) && ((flag & O_TRUNC) || !(flag & O_APPEND))
-	    && ccs_init_request_info(&r, domain, CCS_MAC_REWRITE)) {
+	    && ccs_init_request_info(&r, domain, CCS_MAC_FILE_REWRITE)
+	    != CCS_MAC_MODE_DISABLED) {
 		if (!ccs_get_realpath(&buf, dentry, mnt)) {
 			error = -ENOMEM;
 			goto out;
@@ -1287,7 +1271,8 @@
 		}
 	}
 	if (!error && acc_mode &&
-	    ccs_init_request_info(&r, domain, CCS_MAC_OPEN)) {
+	    ccs_init_request_info(&r, domain, CCS_MAC_FILE_OPEN)
+	    != CCS_MAC_MODE_DISABLED) {
 		if (!buf.name && !ccs_get_realpath(&buf, dentry, mnt)) {
 			error = -ENOMEM;
 			goto out;
@@ -1296,9 +1281,10 @@
 		error = ccs_file_perm(&r, &buf, acc_mode);
 	}
 	if (!error && (flag & O_TRUNC) &&
-	    ccs_init_request_info(&r, domain, CCS_MAC_TRUNCATE)) {
+	    ccs_init_request_info(&r, domain, CCS_MAC_FILE_TRUNCATE)
+	    != CCS_MAC_MODE_DISABLED) {
 		if (!buf.name && !ccs_get_realpath(&buf, dentry, mnt)) {
-			error = -ENOMEM; 
+			error = -ENOMEM;
 			goto out;
 		}
 		r.obj = &obj;
@@ -1307,7 +1293,7 @@
  out:
 	kfree(buf.name);
 	ccs_read_unlock(idx);
-	if (r.mode != 3)
+	if (r.mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	return error;
 }
@@ -1323,7 +1309,7 @@
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_path_perm(const u8 operation, struct dentry *dentry,
-				struct vfsmount *mnt, const char *target)
+			 struct vfsmount *mnt, const char *target)
 {
 	struct ccs_request_info r;
 	struct ccs_obj_info obj = {
@@ -1335,16 +1321,15 @@
 	bool is_enforce = false;
 	struct ccs_path_info symlink_target;
 	int idx;
-	if (!ccs_can_sleep())
-		return 0;
 	buf.name = NULL;
 	symlink_target.name = NULL;
 	idx = ccs_read_lock();
-	if (!mnt || !ccs_init_request_info(&r, NULL, ccs_p2mac[operation])) {
+	if (!mnt || ccs_init_request_info(&r, NULL, ccs_p2mac[operation])
+	    == CCS_MAC_MODE_DISABLED) {
 		error = 0;
 		goto out;
 	}
-	is_enforce = (r.mode == 3);
+	is_enforce = (r.mode == CCS_MAC_MODE_ENFORCING);
 	if (!ccs_get_realpath(&buf, dentry, mnt))
 		goto out;
 	r.obj = &obj;
@@ -1394,18 +1379,14 @@
 	};
 	int error = -ENOMEM;
 	struct ccs_path_info buf;
-	bool is_enforce = false;
 	int idx;
-	if (!ccs_can_sleep())
-		return 0;
 	buf.name = NULL;
 	idx = ccs_read_lock();
-	if (!mnt ||
-	    !ccs_init_request_info(&r, NULL, ccs_pnnn2mac[operation])) {
+	if (!mnt || ccs_init_request_info(&r, NULL, ccs_pnnn2mac[operation])
+	    == CCS_MAC_MODE_DISABLED) {
 		error = 0;
 		goto out;
 	}
-	is_enforce = (r.mode == 3);
 	if (!ccs_get_realpath(&buf, dentry, mnt))
 		goto out;
 	r.obj = &obj;
@@ -1413,7 +1394,7 @@
  out:
 	kfree(buf.name);
 	ccs_read_unlock(idx);
-	if (!is_enforce)
+	if (r.mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	return error;
 }
@@ -1436,16 +1417,15 @@
 	bool is_enforce = false;
 	struct ccs_path_info buf;
 	int idx;
-	if (!ccs_can_sleep())
-		return 0;
 	buf.name = NULL;
 	idx = ccs_read_lock();
 	if (!filp->f_vfsmnt ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_REWRITE)) {
+	    ccs_init_request_info(&r, NULL, CCS_MAC_FILE_REWRITE)
+	    == CCS_MAC_MODE_DISABLED) {
 		error = 0;
 		goto out;
 	}
-	is_enforce = (r.mode == 3);
+	is_enforce = (r.mode == CCS_MAC_MODE_ENFORCING);
 	if (!ccs_get_realpath(&buf, filp->f_dentry, filp->f_vfsmnt))
 		goto out;
 	if (!ccs_is_no_rewrite_file(&buf)) {
@@ -1473,7 +1453,7 @@
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_path2_perm(const u8 operation, struct dentry *dentry1,
-				struct dentry *dentry2, struct vfsmount *mnt)
+			  struct dentry *dentry2, struct vfsmount *mnt)
 {
 	struct ccs_request_info r;
 	int error = -ENOMEM;
@@ -1488,16 +1468,15 @@
 		.path2.mnt = mnt
 	};
 	int idx;
-	if (!ccs_can_sleep())
-		return 0;
 	buf1.name = NULL;
 	buf2.name = NULL;
 	idx = ccs_read_lock();
-	if (!mnt || !ccs_init_request_info(&r, NULL, ccs_pp2mac[operation])) {
+	if (!mnt || ccs_init_request_info(&r, NULL, ccs_pp2mac[operation])
+	    == CCS_MAC_MODE_DISABLED) {
 		error = 0;
 		goto out;
 	}
-	is_enforce = (r.mode == 3);
+	is_enforce = (r.mode == CCS_MAC_MODE_ENFORCING);
 	if (!ccs_get_realpath(&buf1, dentry1, mnt) ||
 	    !ccs_get_realpath(&buf2, dentry2, mnt))
 		goto out;
@@ -1509,15 +1488,15 @@
 		}
 	}
 	r.obj = &obj;
- retry:
-	error = ccs_path2_acl(&r, operation, &buf1, &buf2);
-	ccs_audit_path2_log(&r, msg, buf1.name, buf2.name, !error);
-	if (error)
+	do {
+		error = ccs_path2_acl(&r, operation, &buf1, &buf2);
+		ccs_audit_path2_log(&r, msg, buf1.name, buf2.name, !error);
+		if (!error)
+			break;
 		error = ccs_supervisor(&r, "allow_%s %s %s\n", msg,
-					     ccs_file_pattern(&buf1),
-					     ccs_file_pattern(&buf2));
-	if (error == 1)
-		goto retry;
+				       ccs_file_pattern(&buf1),
+				       ccs_file_pattern(&buf2));
+	} while (error == 1);
  out:
 	kfree(buf1.name);
 	kfree(buf2.name);
@@ -1612,8 +1591,8 @@
  * Caller holds ccs_read_lock().
  */
 static int ccs_path_number_acl(struct ccs_request_info *r, const u8 type,
-				     const struct ccs_path_info *filename,
-				     const unsigned long number)
+			       const struct ccs_path_info *filename,
+			       const unsigned long number)
 {
 	struct ccs_domain_info *domain = r->domain;
 	struct ccs_acl_info *ptr;
@@ -1652,7 +1631,6 @@
 				 const struct ccs_path_info *filename,
 				 const unsigned long number)
 {
-	const bool is_enforce = (r->mode == 3);
 	char buffer[64];
 	int error;
 	u8 radix;
@@ -1676,16 +1654,16 @@
 		break;
 	}
 	ccs_print_ulong(buffer, sizeof(buffer), number, radix);
- retry:
-	error = ccs_path_number_acl(r, type, filename, number);
-	ccs_audit_path_number_log(r, msg, filename->name, buffer, !error);
-	if (!error)
-		return 0;
-	error = ccs_supervisor(r, "allow_%s %s %s\n", msg,
-			       ccs_file_pattern(filename), buffer);
-	if (error == 1)
-		goto retry;
-	if (!is_enforce)
+	do {
+		error = ccs_path_number_acl(r, type, filename, number);
+		ccs_audit_path_number_log(r, msg, filename->name, buffer,
+					  !error);
+		if (!error)
+			return 0;
+		error = ccs_supervisor(r, "allow_%s %s %s\n", msg,
+				       ccs_file_pattern(filename), buffer);
+	} while (error == 1);
+	if (r->mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	return error;
 }
@@ -1710,11 +1688,12 @@
 	int error = -ENOMEM;
 	struct ccs_path_info buf;
 	int idx;
-	if (!ccs_can_sleep() || !vfsmnt || !dentry)
+	if (!vfsmnt || !dentry)
 		return 0;
 	buf.name = NULL;
 	idx = ccs_read_lock();
-	if (!ccs_init_request_info(&r, NULL, ccs_pn2mac[type])) {
+	if (ccs_init_request_info(&r, NULL, ccs_pn2mac[type])
+	    == CCS_MAC_MODE_DISABLED) {
 		error = 0;
 		goto out;
 	}
@@ -1727,7 +1706,7 @@
  out:
 	kfree(buf.name);
 	ccs_read_unlock(idx);
-	if (r.mode != 3)
+	if (r.mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	return error;
 }
@@ -1742,7 +1721,7 @@
  * Returns 0 on success, negative value otherwise.
  */
 int ccs_ioctl_permission(struct file *filp, unsigned int cmd,
-			       unsigned long arg)
+			 unsigned long arg)
 {
 	return ccs_path_number_perm(CCS_TYPE_IOCTL, filp->f_dentry,
 				    filp->f_vfsmnt, cmd);
@@ -2364,18 +2343,18 @@
 
 /* Permission checks for vfs_rmdir(). */
 int ccs_rmdir_permission(struct inode *dir, struct dentry *dentry,
-			       struct vfsmount *mnt)
+			 struct vfsmount *mnt)
 {
 	int error = ccs_pre_vfs_rmdir(dir, dentry);
 	if (!error)
 		error = ccs_path_perm(CCS_TYPE_RMDIR, dentry, mnt,
-					     NULL);
+				      NULL);
 	return error;
 }
 
 /* Permission checks for vfs_unlink(). */
 int ccs_unlink_permission(struct inode *dir, struct dentry *dentry,
-				struct vfsmount *mnt)
+			  struct vfsmount *mnt)
 {
 	int error;
 	if (!ccs_capable(CCS_SYS_UNLINK))
@@ -2383,13 +2362,13 @@
 	error = ccs_pre_vfs_unlink(dir, dentry);
 	if (!error)
 		error = ccs_path_perm(CCS_TYPE_UNLINK, dentry, mnt,
-					     NULL);
+				      NULL);
 	return error;
 }
 
 /* Permission checks for vfs_symlink(). */
 int ccs_symlink_permission(struct inode *dir, struct dentry *dentry,
-				 struct vfsmount *mnt, char *from)
+			   struct vfsmount *mnt, char *from)
 {
 	int error;
 	if (!ccs_capable(CCS_SYS_SYMLINK))
@@ -2397,23 +2376,23 @@
 	error = ccs_pre_vfs_symlink(dir, dentry);
 	if (!error)
 		error = ccs_path_perm(CCS_TYPE_SYMLINK, dentry, mnt,
-					     from);
+				      from);
 	return error;
 }
 
 /* Permission checks for notify_change(). */
 int ccs_truncate_permission(struct dentry *dentry, struct vfsmount *mnt,
-				  loff_t length, unsigned int time_attrs)
+			    loff_t length, unsigned int time_attrs)
 {
 	return ccs_path_perm(CCS_TYPE_TRUNCATE, dentry, mnt, NULL);
 }
 
 /* Permission checks for vfs_rename(). */
 int ccs_rename_permission(struct inode *old_dir,
-				struct dentry *old_dentry,
-				struct inode *new_dir,
-				struct dentry *new_dentry,
-				struct vfsmount *mnt)
+			  struct dentry *old_dentry,
+			  struct inode *new_dir,
+			  struct dentry *new_dentry,
+			  struct vfsmount *mnt)
 {
 	int error;
 	if (!ccs_capable(CCS_SYS_RENAME))
@@ -2421,13 +2400,13 @@
 	error = ccs_pre_vfs_rename(old_dir, old_dentry, new_dir, new_dentry);
 	if (!error)
 		error = ccs_path2_perm(CCS_TYPE_RENAME, old_dentry,
-					     new_dentry, mnt);
+				       new_dentry, mnt);
 	return error;
 }
 
 /* Permission checks for vfs_link(). */
 int ccs_link_permission(struct dentry *old_dentry, struct inode *new_dir,
-			      struct dentry *new_dentry, struct vfsmount *mnt)
+			struct dentry *new_dentry, struct vfsmount *mnt)
 {
 	int error;
 	if (!ccs_capable(CCS_SYS_LINK))
@@ -2435,7 +2414,7 @@
 	error = ccs_pre_vfs_link(old_dentry, new_dir, new_dentry);
 	if (!error)
 		error = ccs_path2_perm(CCS_TYPE_LINK, old_dentry,
-						 new_dentry, mnt);
+				       new_dentry, mnt);
 	return error;
 }
 
@@ -2477,10 +2456,9 @@
 		op |= 002;
 	if (!op) /* Neither read nor write */
 		return 0;
-	if (!ccs_can_sleep())
-		return 0;
 	idx = ccs_read_lock();
-	if (!ccs_init_request_info(&r, NULL, CCS_MAC_OPEN)) {
+	if (ccs_init_request_info(&r, NULL, CCS_MAC_FILE_OPEN)
+	    == CCS_MAC_MODE_DISABLED) {
 		error = 0;
 		goto out;
 	}
@@ -2520,7 +2498,6 @@
 				goto out;
 			buffer[pos++] = '/';
 			memmove(buffer + pos, cp, len + 1);
-			
 		} else {
 			/* Assume nobody assigns "=\$=" for procname. */
 			snprintf(buffer + pos, PAGE_SIZE - pos - 1,
Index: branches/ccs-patch/security/ccsecurity/environ.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/environ.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/environ.c	(working copy)
@@ -24,10 +24,8 @@
 static int ccs_audit_env_log(struct ccs_request_info *r, const char *env,
 			     const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain))
-		printk(KERN_WARNING "%s: Environ %s denied for %s\n",
-		       ccs_get_msg(r->mode == 3), env,
-		       ccs_get_last_name(r->domain));
+	if (!is_granted)
+		ccs_warn_log(r, "environ %s", env);
 	return ccs_write_audit_log(is_granted, r, CCS_KEYWORD_ALLOW_ENV "%s\n",
 				   env);
 }
@@ -117,7 +115,7 @@
 			     &ccs_globally_usable_env_list) {
 		struct ccs_globally_usable_env_entry *ptr;
 		ptr = list_entry(pos, struct ccs_globally_usable_env_entry,
-				  list);
+				 list);
 		if (ptr->is_deleted)
 			continue;
 		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_ENV "%s\n",
@@ -177,23 +175,17 @@
  */
 int ccs_env_perm(struct ccs_request_info *r, const char *env)
 {
-	int error = 0;
-	const bool is_enforce = (r->mode == 3);
+	int error;
 	ccs_assert_read_lock();
-	if (!ccs_can_sleep())
-		return 0;
 	if (!env || !*env)
 		return 0;
- retry:
-	error = ccs_env_acl(r, env);
-	ccs_audit_env_log(r, env, !error);
-	if (error)
-		error = ccs_supervisor(r, CCS_KEYWORD_ALLOW_ENV "%s\n",
-					     env);
-	if (error == 1)
-		goto retry;
-	if (!is_enforce)
-		error = 0;
+	do {
+		error = ccs_env_acl(r, env);
+		ccs_audit_env_log(r, env, !error);
+		if (!error)
+			break;
+		error = ccs_supervisor(r, CCS_KEYWORD_ALLOW_ENV "%s\n", env);
+	} while (error == 1);
 	return error;
 }
 
Index: branches/ccs-patch/security/ccsecurity/capability.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/capability.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/capability.c	(working copy)
@@ -13,59 +13,6 @@
 #include "internal.h"
 
 /**
- * ccs_cap2name - Convert capability operation to capability message.
- *
- * @operation: Type of operation.
- *
- * Returns the name of capability.
- */
-static const char *ccs_cap2name(const u8 operation)
-{
-	static const char *ccs_capability_name[CCS_MAX_CAPABILITY_INDEX] = {
-		[CCS_INET_STREAM_SOCKET_CREATE]  =
-		"socket(PF_INET, SOCK_STREAM)",
-		[CCS_INET_STREAM_SOCKET_LISTEN]  =
-		"listen(PF_INET, SOCK_STREAM)",
-		[CCS_INET_STREAM_SOCKET_CONNECT] =
-		"connect(PF_INET, SOCK_STREAM)",
-		[CCS_USE_INET_DGRAM_SOCKET]      =
-		"socket(PF_INET, SOCK_DGRAM)",
-		[CCS_USE_INET_RAW_SOCKET]        =
-		"socket(PF_INET, SOCK_RAW)",
-		[CCS_USE_ROUTE_SOCKET]           = "socket(PF_ROUTE)",
-		[CCS_USE_PACKET_SOCKET]          = "socket(PF_PACKET)",
-		[CCS_SYS_MOUNT]                  = "sys_mount()",
-		[CCS_SYS_UMOUNT]                 = "sys_umount()",
-		[CCS_SYS_REBOOT]                 = "sys_reboot()",
-		[CCS_SYS_CHROOT]                 = "sys_chroot()",
-		[CCS_SYS_KILL]                   = "sys_kill()",
-		[CCS_SYS_VHANGUP]                = "sys_vhangup()",
-		[CCS_SYS_SETTIME]                = "sys_settimeofday()",
-		[CCS_SYS_NICE]                   = "sys_nice()",
-		[CCS_SYS_SETHOSTNAME]            = "sys_sethostname()",
-		[CCS_USE_KERNEL_MODULE]          = "kernel_module",
-		[CCS_CREATE_FIFO]                = "mknod(FIFO)",
-		[CCS_CREATE_BLOCK_DEV]           = "mknod(BDEV)",
-		[CCS_CREATE_CHAR_DEV]            = "mknod(CDEV)",
-		[CCS_CREATE_UNIX_SOCKET]         = "mknod(SOCKET)",
-		[CCS_SYS_LINK]                   = "sys_link()",
-		[CCS_SYS_SYMLINK]                = "sys_symlink()",
-		[CCS_SYS_RENAME]                 = "sys_rename()",
-		[CCS_SYS_UNLINK]                 = "sys_unlink()",
-		[CCS_SYS_CHMOD]                  = "sys_chmod()",
-		[CCS_SYS_CHOWN]                  = "sys_chown()",
-		[CCS_SYS_IOCTL]                  = "sys_ioctl()",
-		[CCS_SYS_KEXEC_LOAD]             = "sys_kexec_load()",
-		[CCS_SYS_PIVOT_ROOT]             = "sys_pivot_root()",
-		[CCS_SYS_PTRACE]                 = "sys_ptrace()",
-		[CCS_CONCEAL_MOUNT]              = "conceal-mount",
-	};
-	if (operation < CCS_MAX_CAPABILITY_INDEX)
-		return ccs_capability_name[operation];
-	return NULL;
-}
-
-/**
  * ccs_audit_capability_log - Audit capability log.
  *
  * @r:          Pointer to "struct ccs_request_info".
@@ -77,10 +24,8 @@
 static int ccs_audit_capability_log(struct ccs_request_info *r,
 				    const u8 operation, const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain))
-		printk(KERN_WARNING "%s: %s denied for %s\n",
-		       ccs_get_msg(r->mode == 3), ccs_cap2name(operation),
-		       ccs_get_last_name(r->domain));
+	if (!is_granted)
+		ccs_warn_log(r, "capability %s", ccs_cap2keyword(operation));
 	return ccs_write_audit_log(is_granted, r, CCS_KEYWORD_ALLOW_CAPABILITY
 				   "%s\n", ccs_cap2keyword(operation));
 }
@@ -98,36 +43,33 @@
 {
 	struct ccs_request_info r;
 	struct ccs_acl_info *ptr;
-	bool is_enforce;
 	int error;
 	ccs_assert_read_lock();
-	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAX_MAC_INDEX + operation))
+	if (ccs_init_request_info(&r, NULL, CCS_MAX_MAC_INDEX + operation)
+	    == CCS_MAC_MODE_DISABLED)
 		return true;
-	is_enforce = (r.mode == 3);
- retry:
-	error = -EPERM;
-	list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
-		struct ccs_capability_acl *acl;
-		if (ptr->is_deleted || ptr->type != CCS_TYPE_CAPABILITY_ACL)
-			continue;
-		acl = container_of(ptr, struct ccs_capability_acl, head);
-		if (acl->operation != operation ||
-		    !ccs_condition(&r, ptr))
-			continue;
-		r.cond = ptr->cond;
-		error = 0;
-		break;
-	}
-	ccs_audit_capability_log(&r, operation, !error);
-	if (error)
-		error = ccs_supervisor(&r, CCS_KEYWORD_ALLOW_CAPABILITY
-					     "%s\n",
-					     ccs_cap2keyword(operation));
-	if (error == 1)
-		goto retry;
-	if (!is_enforce)
-		error = 0;
+	do {
+		error = -EPERM;
+		list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
+			struct ccs_capability_acl *acl;
+			if (ptr->is_deleted ||
+			    ptr->type != CCS_TYPE_CAPABILITY_ACL)
+				continue;
+			acl = container_of(ptr, struct ccs_capability_acl,
+					   head);
+			if (acl->operation != operation ||
+			    !ccs_condition(&r, ptr))
+				continue;
+			r.cond = ptr->cond;
+			error = 0;
+			break;
+		}
+		ccs_audit_capability_log(&r, operation, !error);
+		if (!error)
+			break;
+		error = ccs_supervisor(&r, CCS_KEYWORD_ALLOW_CAPABILITY "%s\n",
+				       ccs_cap2keyword(operation));
+	} while (error == 1);
 	return !error;
 }
 
Index: branches/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- branches/ccs-patch/security/ccsecurity/internal.h	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -29,11 +29,6 @@
 #include <linux/version.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #include <linux/kmod.h>
-#include <asm/hardirq.h>
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 9)
-#include <asm/hardirq.h>
-#else
-#include <linux/hardirq.h>
 #endif
 #include <linux/in6.h>
 #include <linux/ccsecurity.h>
@@ -152,35 +147,51 @@
 };
 
 enum ccs_mac_index {
-	CCS_MAC_EXECUTE,
-	CCS_MAC_OPEN,
-	CCS_MAC_CREATE,
-	CCS_MAC_UNLINK,
-	CCS_MAC_MKDIR,
-	CCS_MAC_RMDIR,
-	CCS_MAC_MKFIFO,
-	CCS_MAC_MKSOCK,
-	CCS_MAC_TRUNCATE,
-	CCS_MAC_SYMLINK,
-	CCS_MAC_REWRITE,
-	CCS_MAC_MKBLOCK,
-	CCS_MAC_MKCHAR,
-	CCS_MAC_LINK,
-	CCS_MAC_RENAME,
-	CCS_MAC_CHMOD,
-	CCS_MAC_CHOWN,
-	CCS_MAC_CHGRP,
-	CCS_MAC_IOCTL,
-	CCS_MAC_CHROOT,
-	CCS_MAC_MOUNT,
-	CCS_MAC_UMOUNT,
-	CCS_MAC_PIVOT_ROOT,
+	CCS_MAC_FILE_EXECUTE,
+	CCS_MAC_FILE_OPEN,
+	CCS_MAC_FILE_CREATE,
+	CCS_MAC_FILE_UNLINK,
+	CCS_MAC_FILE_MKDIR,
+	CCS_MAC_FILE_RMDIR,
+	CCS_MAC_FILE_MKFIFO,
+	CCS_MAC_FILE_MKSOCK,
+	CCS_MAC_FILE_TRUNCATE,
+	CCS_MAC_FILE_SYMLINK,
+	CCS_MAC_FILE_REWRITE,
+	CCS_MAC_FILE_MKBLOCK,
+	CCS_MAC_FILE_MKCHAR,
+	CCS_MAC_FILE_LINK,
+	CCS_MAC_FILE_RENAME,
+	CCS_MAC_FILE_CHMOD,
+	CCS_MAC_FILE_CHOWN,
+	CCS_MAC_FILE_CHGRP,
+	CCS_MAC_FILE_IOCTL,
+	CCS_MAC_FILE_CHROOT,
+	CCS_MAC_FILE_MOUNT,
+	CCS_MAC_FILE_UMOUNT,
+	CCS_MAC_FILE_PIVOT_ROOT,
+	CCS_MAC_NETWORK_UDP_BIND,
+	CCS_MAC_NETWORK_UDP_CONNECT,
+	CCS_MAC_NETWORK_TCP_BIND,
+	CCS_MAC_NETWORK_TCP_LISTEN,
+	CCS_MAC_NETWORK_TCP_CONNECT,
+	CCS_MAC_NETWORK_TCP_ACCEPT,
+	CCS_MAC_NETWORK_RAW_BIND,
+	CCS_MAC_NETWORK_RAW_CONNECT,
 	CCS_MAC_ENVIRON,
-	CCS_MAC_NETWORK,
 	CCS_MAC_SIGNAL,
 	CCS_MAX_MAC_INDEX
 };
 
+enum ccs_mac_category_index {
+	CCS_MAC_CATEGORY_FILE,
+	CCS_MAC_CATEGORY_NETWORK,
+	CCS_MAC_CATEGORY_MISC,
+	CCS_MAC_CATEGORY_IPC,
+	CCS_MAC_CATEGORY_CAPABILITY,
+	CCS_MAX_MAC_CATEGORY_INDEX
+};
+
 enum ccs_conditions_index {
 	CCS_TASK_UID,             /* current_uid()   */
 	CCS_TASK_EUID,            /* current_euid()  */
@@ -325,11 +336,11 @@
  * @cookie must be NULL when iteration starts, and @cookie will become
  * NULL when iteration finishes.
  */
-#define list_for_each_cookie(pos, cookie, head)                       \
-	for (({ if (!cookie)                                          \
-				     cookie = head; }),               \
-	     pos = rcu_dereference((cookie)->next);                   \
-	     prefetch(pos->next), pos != (head) || ((cookie) = NULL); \
+#define list_for_each_cookie(pos, cookie, head)				\
+	for (({ if (!cookie)						\
+				     cookie = head; }),			\
+		     pos = rcu_dereference((cookie)->next);		\
+	     prefetch(pos->next), pos != (head) || ((cookie) = NULL);	\
 	     (cookie) = pos, pos = rcu_dereference(pos->next))
 
 struct ccs_name_union {
@@ -571,8 +582,8 @@
 struct ccs_domain_initializer_entry {
 	struct list_head list;
 	bool is_deleted;
-	bool is_not;       /* True if this entry is "no_initialize_domain".  */
-	bool is_last_name; /* True if the domainname is ccs_get_last_name(). */
+	bool is_not;       /* True if this entry is "no_initialize_domain". */
+	bool is_last_name; /* True if the domainname is ccs_last_word(). */
 	const struct ccs_path_info *domainname;    /* This may be NULL */
 	const struct ccs_path_info *program;
 };
@@ -581,8 +592,8 @@
 struct ccs_domain_keeper_entry {
 	struct list_head list;
 	bool is_deleted;
-	bool is_not;       /* True if this entry is "no_keep_domain".        */
-	bool is_last_name; /* True if the domainname is ccs_get_last_name(). */
+	bool is_not;       /* True if this entry is "no_keep_domain". */
+	bool is_last_name; /* True if the domainname is ccs_last_word(). */
 	const struct ccs_path_info *domainname;
 	const struct ccs_path_info *program;       /* This may be NULL */
 };
@@ -779,7 +790,7 @@
 
 /* Structure for reading/writing policy via /proc interfaces. */
 struct ccs_io_buffer {
-	int (*read) (struct ccs_io_buffer *);
+	void (*read) (struct ccs_io_buffer *);
 	int (*write) (struct ccs_io_buffer *);
 	int (*poll) (struct file *file, poll_table *wait);
 	/* Exclusive lock for this structure.   */
@@ -820,7 +831,6 @@
 
 /* Prototype definition. */
 
-bool ccs_can_sleep(void);
 bool ccs_condition(struct ccs_request_info *r, const struct ccs_acl_info *acl);
 bool ccs_domain_quota_ok(struct ccs_request_info *r);
 bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos, struct ccs_page_dump *dump);
@@ -844,15 +854,13 @@
 bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head);
 bool ccs_str_starts(char **src, const char *find);
 bool ccs_tokenize(char *buffer, char *w[], size_t size);
-bool ccs_verbose_mode(const struct ccs_domain_info *domain);
 char *ccs_encode(const char *str);
 char *ccs_init_audit_log(int *len, struct ccs_request_info *r);
 char *ccs_realpath_from_path(struct path *path);
 const char *ccs_cap2keyword(const u8 operation);
 const char *ccs_path22keyword(const u8 operation);
 const char *ccs_get_exe(void);
-const char *ccs_get_last_name(const struct ccs_domain_info *domain);
-const char *ccs_get_msg(const bool is_enforce);
+const char *ccs_last_word(const char *name);
 const char *ccs_path_number32keyword(const u8 operation);
 const char *ccs_net2keyword(const u8 operation);
 const char *ccs_path2keyword(const u8 operation);
@@ -868,9 +876,9 @@
 int ccs_poll_grant_log(struct file *file, poll_table *wait);
 int ccs_poll_reject_log(struct file *file, poll_table *wait);
 int ccs_read_control(struct file *file, char __user *buffer, const int buffer_len);
-int ccs_read_grant_log(struct ccs_io_buffer *head);
-int ccs_read_memory_counter(struct ccs_io_buffer *head);
-int ccs_read_reject_log(struct ccs_io_buffer *head);
+void ccs_read_grant_log(struct ccs_io_buffer *head);
+void ccs_read_memory_counter(struct ccs_io_buffer *head);
+void ccs_read_reject_log(struct ccs_io_buffer *head);
 int ccs_symlink_path(const char *pathname, struct ccs_path_info *name);
 int ccs_write_address_group_policy(char *data, const bool is_delete);
 int ccs_write_aggregator_policy(char *data, const bool is_delete);
@@ -945,7 +953,11 @@
 bool ccs_commit_ok(void *ptr, void *data, const unsigned int size);
 int ccs_get_path(const char *pathname, struct path *path);
 void ccs_warn_oom(const char *function);
+void ccs_warn_log(struct ccs_request_info *r, const char *fmt, ...) __attribute__ ((format(printf, 2, 3)));
+bool ccs_get_audit(const u8 profile, const u8 index, const bool is_granted);
+int ccs_get_mode(const u8 profile, const u8 index);
 
+
 /* strcmp() for "struct ccs_path_info" structure. */
 static inline bool ccs_pathcmp(const struct ccs_path_info *a,
 			       const struct ccs_path_info *b)
@@ -986,12 +998,20 @@
 
 extern const char *ccs_condition_keyword[CCS_MAX_CONDITION_KEYWORD];
 
+#define CCS_MAC_MODE_DISABLED        0
+#define CCS_MAC_MODE_LEARNING        1
+#define CCS_MAC_MODE_PERMISSIVE      2
+#define CCS_MAC_MODE_ENFORCING       3
+#define CCS_MAC_MODE_NO_REJECT_LOG  64
+#define CCS_MAC_MODE_NO_GRANT_LOG  128
+#define CCS_MAC_MODE_USE_DEFAULT   255
+
 struct ccs_profile {
 	unsigned int value[CCS_MAX_CONTROL_INDEX];
 	const struct ccs_path_info *comment;
-	u8 mac_mode[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX];
-	bool no_grant_log[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX];
-	bool no_reject_log[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX];
+	u8 default_config;
+	u8 config[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+		  + CCS_MAX_MAC_CATEGORY_INDEX];
 };
 extern struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
 
Index: branches/ccs-patch/security/ccsecurity/condition.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/condition.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/condition.c	(working copy)
@@ -25,8 +25,8 @@
  * Returns true on success, false otherwise.
  */
 static bool ccs_argv(const unsigned int index, const char *arg_ptr,
-			   const int argc, const struct ccs_argv_entry *argv,
-			   u8 *checked)
+		     const int argc, const struct ccs_argv_entry *argv,
+		     u8 *checked)
 {
 	int i;
 	struct ccs_path_info arg;
@@ -58,8 +58,8 @@
  * Returns true on success, false otherwise.
  */
 static bool ccs_envp(const char *env_name, const char *env_value,
-			   const int envc, const struct ccs_envp_entry *envp,
-			   u8 *checked)
+		     const int envc, const struct ccs_envp_entry *envp,
+		     u8 *checked)
 {
 	int i;
 	struct ccs_path_info name;
@@ -175,8 +175,8 @@
 			/* Check. */
 			if (argv_count) {
 				if (!ccs_argv(bprm->argc - argv_count,
-						    arg_ptr, argc, argv,
-						    checked)) {
+					      arg_ptr, argc, argv,
+					      checked)) {
 					result = false;
 					break;
 				}
@@ -186,8 +186,8 @@
 				if (cp) {
 					*cp = '\0';
 					if (!ccs_envp(arg_ptr, cp + 1,
-							    envc, envp,
-							    checked + argc)) {
+						      envc, envp,
+						      checked + argc)) {
 						result = false;
 						break;
 					}
@@ -988,7 +988,7 @@
  * Caller holds ccs_read_lock().
  */
 bool ccs_condition(struct ccs_request_info *r,
-			 const struct ccs_acl_info *acl)
+		   const struct ccs_acl_info *acl)
 {
 	const struct task_struct *task = current;
 	u32 i;
@@ -1037,7 +1037,7 @@
 			continue;
 		/* Check string expressions. */
 		if (right == CCS_NAME_UNION) {
-			const struct ccs_name_union *ptr = names_p++; 
+			const struct ccs_name_union *ptr = names_p++;
 			switch (left) {
 				struct ccs_path_info *symlink;
 				struct ccs_execve_entry *ee;
Index: branches/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/policy_io.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -24,72 +24,149 @@
 	"disabled", "learning", "permissive", "enforcing"
 };
 
-static bool ccs_mac_keywords_used[CCS_MAX_MAC_INDEX +
-				  CCS_MAX_CAPABILITY_INDEX];
-
 static const char *ccs_mac_keywords[CCS_MAX_MAC_INDEX +
-				    CCS_MAX_CAPABILITY_INDEX] = {
-	[CCS_MAC_EXECUTE]    = "execute",
-	[CCS_MAC_OPEN]       = "open",
-	[CCS_MAC_CREATE]     = "create",
-	[CCS_MAC_UNLINK]     = "unlink",
-	[CCS_MAC_MKDIR]      = "mkdir",
-	[CCS_MAC_RMDIR]      = "rmdir",
-	[CCS_MAC_MKFIFO]     = "mkfifo",
-	[CCS_MAC_MKSOCK]     = "mksock",
-	[CCS_MAC_TRUNCATE]   = "truncate",
-	[CCS_MAC_SYMLINK]    = "symlink",
-	[CCS_MAC_REWRITE]    = "rewrite",
-	[CCS_MAC_MKBLOCK]    = "mkblock",
-	[CCS_MAC_MKCHAR]     = "mkchar",
-	[CCS_MAC_LINK]       = "link",
-	[CCS_MAC_RENAME]     = "rename",
-	[CCS_MAC_CHMOD]      = "chmod",
-	[CCS_MAC_CHOWN]      = "chown",
-	[CCS_MAC_CHGRP]      = "chgrp",
-	[CCS_MAC_IOCTL]      = "ioctl",
-	[CCS_MAC_CHROOT]     = "chroot",
-	[CCS_MAC_MOUNT]      = "mount",
-	[CCS_MAC_UMOUNT]     = "umount",
-	[CCS_MAC_PIVOT_ROOT] = "pivot_root",
-	[CCS_MAC_ENVIRON]    = "env",
-	[CCS_MAC_NETWORK]    = "network",
-	[CCS_MAC_SIGNAL]     = "signal",
+				    CCS_MAX_CAPABILITY_INDEX +
+				    CCS_MAX_MAC_CATEGORY_INDEX] = {
+	[CCS_MAC_FILE_EXECUTE]
+	= "file::execute",
+	[CCS_MAC_FILE_OPEN]
+	= "file::open",
+	[CCS_MAC_FILE_CREATE]
+	= "file::create",
+	[CCS_MAC_FILE_UNLINK]
+	= "file::unlink",
+	[CCS_MAC_FILE_MKDIR]
+	= "file::mkdir",
+	[CCS_MAC_FILE_RMDIR]
+	= "file::rmdir",
+	[CCS_MAC_FILE_MKFIFO]
+	= "file::mkfifo",
+	[CCS_MAC_FILE_MKSOCK]
+	= "file::mksock",
+	[CCS_MAC_FILE_TRUNCATE]
+	= "file::truncate",
+	[CCS_MAC_FILE_SYMLINK]
+	= "file::symlink",
+	[CCS_MAC_FILE_REWRITE]
+	= "file::rewrite",
+	[CCS_MAC_FILE_MKBLOCK]
+	= "file::mkblock",
+	[CCS_MAC_FILE_MKCHAR]
+	= "file::mkchar",
+	[CCS_MAC_FILE_LINK]
+	= "file::link",
+	[CCS_MAC_FILE_RENAME]
+	= "file::rename",
+	[CCS_MAC_FILE_CHMOD]
+	= "file::chmod",
+	[CCS_MAC_FILE_CHOWN]
+	= "file::chown",
+	[CCS_MAC_FILE_CHGRP]
+	= "file::chgrp",
+	[CCS_MAC_FILE_IOCTL]
+	= "file::ioctl",
+	[CCS_MAC_FILE_CHROOT]
+	= "file::chroot",
+	[CCS_MAC_FILE_MOUNT]
+	= "file::mount",
+	[CCS_MAC_FILE_UMOUNT]
+	= "file::umount",
+	[CCS_MAC_FILE_PIVOT_ROOT]
+	= "file::pivot_root",
+	[CCS_MAC_ENVIRON]
+	= "misc::env",
+	[CCS_MAC_NETWORK_UDP_BIND]
+	= "network::inet_udp_bind",
+	[CCS_MAC_NETWORK_UDP_CONNECT]
+	= "network::inet_udp_connect",
+	[CCS_MAC_NETWORK_TCP_BIND]
+	= "network::inet_tcp_bind",
+	[CCS_MAC_NETWORK_TCP_LISTEN]
+	= "network::inet_tcp_listen",
+	[CCS_MAC_NETWORK_TCP_CONNECT]
+	= "network::inet_tcp_connect",
+	[CCS_MAC_NETWORK_TCP_ACCEPT]
+	= "network::inet_tcp_accept",
+	[CCS_MAC_NETWORK_RAW_BIND]
+	= "network::inet_raw_bind",
+	[CCS_MAC_NETWORK_RAW_CONNECT]
+	= "network::inet_raw_connect",
+	[CCS_MAC_SIGNAL]
+	= "ipc::signal",
 	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_CREATE]
-	= "inet_tcp_create",
+	= "capability::inet_tcp_create",
 	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_LISTEN]
-	= "inet_tcp_listen",
+	= "capability::inet_tcp_listen",
 	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_CONNECT]
-	= "inet_tcp_connect",
-	[CCS_MAX_MAC_INDEX + CCS_USE_INET_DGRAM_SOCKET] = "use_inet_udp",
-	[CCS_MAX_MAC_INDEX + CCS_USE_INET_RAW_SOCKET]   = "use_inet_ip",
-	[CCS_MAX_MAC_INDEX + CCS_USE_ROUTE_SOCKET]      = "use_route",
-	[CCS_MAX_MAC_INDEX + CCS_USE_PACKET_SOCKET]     = "use_packet",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_MOUNT]             = "SYS_MOUNT",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_UMOUNT]            = "SYS_UMOUNT",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_REBOOT]            = "SYS_REBOOT",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_CHROOT]            = "SYS_CHROOT",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_KILL]              = "SYS_KILL",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_VHANGUP]           = "SYS_VHANGUP",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_SETTIME]           = "SYS_TIME",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_NICE]              = "SYS_NICE",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_SETHOSTNAME]       = "SYS_SETHOSTNAME",
-	[CCS_MAX_MAC_INDEX + CCS_USE_KERNEL_MODULE]     = "use_kernel_module",
-	[CCS_MAX_MAC_INDEX + CCS_CREATE_FIFO]           = "create_fifo",
-	[CCS_MAX_MAC_INDEX + CCS_CREATE_BLOCK_DEV]      = "create_block_dev",
-	[CCS_MAX_MAC_INDEX + CCS_CREATE_CHAR_DEV]       = "create_char_dev",
-	[CCS_MAX_MAC_INDEX + CCS_CREATE_UNIX_SOCKET]    = "create_unix_socket",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_LINK]              = "SYS_LINK",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_SYMLINK]           = "SYS_SYMLINK",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_RENAME]            = "SYS_RENAME",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_UNLINK]            = "SYS_UNLINK",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_CHMOD]             = "SYS_CHMOD",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_CHOWN]             = "SYS_CHOWN",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_IOCTL]             = "SYS_IOCTL",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_KEXEC_LOAD]        = "SYS_KEXEC_LOAD",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_PIVOT_ROOT]        = "SYS_PIVOT_ROOT",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_PTRACE]            = "SYS_PTRACE",
-	[CCS_MAX_MAC_INDEX + CCS_CONCEAL_MOUNT]         = "conceal_mount"
+	= "capability::inet_tcp_connect",
+	[CCS_MAX_MAC_INDEX + CCS_USE_INET_DGRAM_SOCKET]
+	= "capability::use_inet_udp",
+	[CCS_MAX_MAC_INDEX + CCS_USE_INET_RAW_SOCKET]
+	= "capability::use_inet_ip",
+	[CCS_MAX_MAC_INDEX + CCS_USE_ROUTE_SOCKET]
+	= "capability::use_route",
+	[CCS_MAX_MAC_INDEX + CCS_USE_PACKET_SOCKET]
+	= "capability::use_packet",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_MOUNT]
+	= "capability::SYS_MOUNT",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_UMOUNT]
+	= "capability::SYS_UMOUNT",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_REBOOT]
+	= "capability::SYS_REBOOT",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_CHROOT]
+	= "capability::SYS_CHROOT",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_KILL]
+	= "capability::SYS_KILL",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_VHANGUP]
+	= "capability::SYS_VHANGUP",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_SETTIME]
+	= "capability::SYS_TIME",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_NICE]
+	= "capability::SYS_NICE",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_SETHOSTNAME]
+	= "capability::SYS_SETHOSTNAME",
+	[CCS_MAX_MAC_INDEX + CCS_USE_KERNEL_MODULE]
+	= "capability::use_kernel_module",
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_FIFO]
+	= "capability::create_fifo",
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_BLOCK_DEV]
+	= "capability::create_block_dev",
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_CHAR_DEV]
+	= "capability::create_char_dev",
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_UNIX_SOCKET]
+	= "capability::create_unix_socket",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_LINK]
+	= "capability::SYS_LINK",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_SYMLINK]
+	= "capability::SYS_SYMLINK",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_RENAME]
+	= "capability::SYS_RENAME",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_UNLINK]
+	= "capability::SYS_UNLINK",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_CHMOD]
+	= "capability::SYS_CHMOD",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_CHOWN]
+	= "capability::SYS_CHOWN",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_IOCTL]
+	= "capability::SYS_IOCTL",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_KEXEC_LOAD]
+	= "capability::SYS_KEXEC_LOAD",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_PIVOT_ROOT]
+	= "capability::SYS_PIVOT_ROOT",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_PTRACE]
+	= "capability::SYS_PTRACE",
+	[CCS_MAX_MAC_INDEX + CCS_CONCEAL_MOUNT]
+	= "capability::conceal_mount",
+	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+	 + CCS_MAC_CATEGORY_FILE] = "file",
+	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+	 + CCS_MAC_CATEGORY_NETWORK] = "network",
+	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+	 + CCS_MAC_CATEGORY_MISC] = "misc",
+	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+	 + CCS_MAC_CATEGORY_IPC] = "ipc",
+	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+	 + CCS_MAC_CATEGORY_CAPABILITY] = "capability",
 };
 
 /* Table for profile. */
@@ -125,7 +202,7 @@
 const char *ccs_cap2keyword(const u8 operation)
 {
 	return operation < CCS_MAX_CAPABILITY_INDEX
-		? ccs_mac_keywords[CCS_MAX_MAC_INDEX + operation] : NULL;
+		? ccs_mac_keywords[CCS_MAX_MAC_INDEX + operation] + 12 : NULL;
 }
 
 /**
@@ -195,6 +272,9 @@
 		ptr = entry;
 		for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++)
 			ptr->value[i] = ccs_control_array[i].current_value;
+		ptr->default_config = CCS_MAC_MODE_DISABLED;
+		memset(ptr->config, CCS_MAC_MODE_USE_DEFAULT,
+		       sizeof(ptr->config));
 		mb(); /* Avoid out-of-order execution. */
 		ccs_profile_ptr[profile] = ptr;
 		entry = NULL;
@@ -216,8 +296,8 @@
 	char *data = head->write_buf;
 	unsigned int i;
 	unsigned int value;
-	int index = -1;
 	int mode;
+	u8 config;
 	char *cp;
 	struct ccs_profile *ccs_profile;
 	i = simple_strtoul(data, &cp, 10);
@@ -244,33 +324,6 @@
 		ccs_put_name(old_comment);
 		return 0;
 	}
-	if (!ccs_str_starts(&data, "MAC::"))
-		goto not_mac;
-	if (ccs_str_starts(&data, CCS_KEYWORD_CAPABILITY))
-		for (i = 0; i < CCS_MAX_CAPABILITY_INDEX; i++) {
-			if (strcmp(data,
-				   ccs_mac_keywords[CCS_MAX_MAC_INDEX + i]))
-				continue;
-			index = CCS_MAX_MAC_INDEX + i;
-			break;
-		}
-	else
-		for (i = 0; i < CCS_MAX_MAC_INDEX; i++) {
-			if (strcmp(data, ccs_mac_keywords[i]))
-				continue;
-			index = i;
-			break;
-		}
-	if (index < 0)
-		return -EINVAL;
-	ccs_mac_keywords_used[index] = 1;
-	ccs_profile->no_grant_log[index] = !!strstr(cp, "no_grant_log");
-	ccs_profile->no_reject_log[index] = !!strstr(cp, "no_reject_log");
-	for (mode = 0; mode < 4; mode++)
-		if (strstr(cp, ccs_mode_4[mode]))
-			ccs_profile->mac_mode[index] = mode;
-	return 0;
- not_mac:
 	for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++) {
 		if (strcmp(data, ccs_control_array[i].keyword))
 			continue;
@@ -290,7 +343,30 @@
 		ccs_profile->value[i] = value;
 		return 0;
 	}
-	return -EINVAL;
+	config = 0;
+	if (strstr(cp, "no_grant_log"))
+		config |= CCS_MAC_MODE_NO_GRANT_LOG;
+	if (strstr(cp, "no_reject_log"))
+		config |= CCS_MAC_MODE_NO_REJECT_LOG;
+	for (mode = 3; mode >= 0; mode--)
+		if (strstr(cp, ccs_mode_4[mode]))
+			break;
+	if (mode < 0)
+		sscanf(cp, "%u", &mode);
+	if (mode < 0 || mode > 3)
+		return -EINVAL;
+	config |= mode;
+	if (!strcmp(data, "MAC"))
+		ccs_profile->default_config = config;
+	else if (ccs_str_starts(&data, "MAC::"))
+		for (i = 0; i < CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+			     + CCS_MAX_MAC_CATEGORY_INDEX; i++) {
+			if (strcmp(data, ccs_mac_keywords[i]))
+				continue;
+			ccs_profile->config[i] = config;
+			break;
+		}
+	return 0;
 }
 
 static bool ccs_print_mac_mode(struct ccs_io_buffer *head, u8 index)
@@ -298,17 +374,24 @@
 	const int pos = head->read_avail;
 	int i;
 	const struct ccs_profile *ccs_profile = ccs_profile_ptr[index];
+	u8 config = ccs_profile->default_config;
+	if (!ccs_io_printf(head, "%u-MAC=%s %s %s\n", index,
+			   ccs_mode_4[config & 3],
+			   config & CCS_MAC_MODE_NO_GRANT_LOG ?
+			   "no_grant_log" : "",
+			   config & CCS_MAC_MODE_NO_REJECT_LOG ?
+			   "no_reject_log" : ""))
+		goto out;
 	for (i = 0; i < CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX; i++) {
-		if (!ccs_mac_keywords_used[i])
+		config = ccs_profile->config[i];
+		if (config == CCS_MAC_MODE_USE_DEFAULT)
 			continue;
-		if (!ccs_io_printf(head, "%u-MAC::%s%s=%s %s %s\n", index,
-				   i >= CCS_MAX_MAC_INDEX ?
-				   CCS_KEYWORD_CAPABILITY : "",
+		if (!ccs_io_printf(head, "%u-MAC::%s=%s %s %s\n", index,
 				   ccs_mac_keywords[i],
-				   ccs_mode_4[ccs_profile->mac_mode[i]],
-				   ccs_profile->no_grant_log[i] ? 
+				   ccs_mode_4[config & 3],
+				   config & CCS_MAC_MODE_NO_GRANT_LOG ?
 				   "no_grant_log" : "",
-				   ccs_profile->no_reject_log[i] ? 
+				   config & CCS_MAC_MODE_NO_REJECT_LOG ?
 				   "no_reject_log" : ""))
 			goto out;
 	}
@@ -322,15 +405,13 @@
  * ccs_read_profile - Read profile table.
  *
  * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0.
  */
-static int ccs_read_profile(struct ccs_io_buffer *head)
+static void ccs_read_profile(struct ccs_io_buffer *head)
 {
 	static const int ccs_total = CCS_MAX_CONTROL_INDEX + 2;
 	int step;
 	if (head->read_eof)
-		return 0;
+		return;
 	for (step = head->read_step; step < CCS_MAX_PROFILES * ccs_total;
 	     step++) {
 		const u8 index = step / ccs_total;
@@ -371,7 +452,6 @@
 	}
 	if (step == CCS_MAX_PROFILES * ccs_total)
 		head->read_eof = true;
-	return 0;
 }
 
 /* The list for "struct ccs_policy_manager_entry". */
@@ -446,26 +526,23 @@
  *
  * @head: Pointer to "struct ccs_io_buffer".
  *
- * Returns 0.
- *
  * Caller holds ccs_read_lock().
  */
-static int ccs_read_manager_policy(struct ccs_io_buffer *head)
+static void ccs_read_manager_policy(struct ccs_io_buffer *head)
 {
 	struct list_head *pos;
 	ccs_assert_read_lock();
 	if (head->read_eof)
-		return 0;
+		return;
 	list_for_each_cookie(pos, head->read_var2, &ccs_policy_manager_list) {
 		struct ccs_policy_manager_entry *ptr;
 		ptr = list_entry(pos, struct ccs_policy_manager_entry, list);
 		if (ptr->is_deleted)
 			continue;
 		if (!ccs_io_printf(head, "%s\n", ptr->manager->name))
-			return 0;
+			return;
 	}
 	head->read_eof = true;
-	return 0;
 }
 
 /**
@@ -895,8 +972,8 @@
  * Returns true on success, false otherwise.
  */
 static bool ccs_print_path_acl(struct ccs_io_buffer *head,
-				      struct ccs_path_acl *ptr,
-				      const struct ccs_condition *cond)
+			       struct ccs_path_acl *ptr,
+			       const struct ccs_condition *cond)
 {
 	int pos;
 	u8 bit;
@@ -933,8 +1010,8 @@
  * Returns true on success, false otherwise.
  */
 static bool ccs_print_path_number3_acl(struct ccs_io_buffer *head,
-				struct ccs_path_number3_acl *ptr,
-				const struct ccs_condition *cond)
+				       struct ccs_path_number3_acl *ptr,
+				       const struct ccs_condition *cond)
 {
 	int pos;
 	u8 bit;
@@ -970,8 +1047,8 @@
  * Returns true on success, false otherwise.
  */
 static bool ccs_print_path2_acl(struct ccs_io_buffer *head,
-				      struct ccs_path2_acl *ptr,
-				      const struct ccs_condition *cond)
+				struct ccs_path2_acl *ptr,
+				const struct ccs_condition *cond)
 {
 	int pos;
 	u8 bit;
@@ -1412,17 +1489,15 @@
  *
  * @head: Pointer to "struct ccs_io_buffer".
  *
- * Returns 0.
- *
  * Caller holds ccs_read_lock().
  */
-static int ccs_read_domain_policy(struct ccs_io_buffer *head)
+static void ccs_read_domain_policy(struct ccs_io_buffer *head)
 {
 	struct list_head *dpos;
 	struct list_head *apos;
 	ccs_assert_read_lock();
 	if (head->read_eof)
-		return 0;
+		return;
 	if (head->read_step == 0)
 		head->read_step = 1;
 	list_for_each_cookie(dpos, head->read_var1, &ccs_domain_list) {
@@ -1453,7 +1528,7 @@
 				   transition_failed,
 				   ignore_global_allow_read,
 				   ignore_global_allow_env))
-			return 0;
+			return;
 		head->read_step = 2;
  acl_loop:
 		if (head->read_step == 3)
@@ -1464,18 +1539,17 @@
 			struct ccs_acl_info *ptr
 				= list_entry(apos, struct ccs_acl_info, list);
 			if (!ccs_print_entry(head, ptr))
-				return 0;
+				return;
 		}
 		head->read_step = 3;
  tail_mark:
 		if (!ccs_io_printf(head, "\n"))
-			return 0;
+			return;
 		head->read_step = 1;
 		if (head->read_single_domain)
 			break;
 	}
 	head->read_eof = true;
-	return 0;
 }
 
 /**
@@ -1516,8 +1590,6 @@
  *
  * @head: Pointer to "struct ccs_io_buffer".
  *
- * Returns list of profile number and domainname pairs.
- *
  * This is equivalent to doing
  *
  *     grep -A 1 '^<kernel>' /proc/ccs/domain_policy |
@@ -1527,12 +1599,12 @@
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_read_domain_profile(struct ccs_io_buffer *head)
+static void ccs_read_domain_profile(struct ccs_io_buffer *head)
 {
 	struct list_head *pos;
 	ccs_assert_read_lock();
 	if (head->read_eof)
-		return 0;
+		return;
 	list_for_each_cookie(pos, head->read_var1, &ccs_domain_list) {
 		struct ccs_domain_info *domain;
 		domain = list_entry(pos, struct ccs_domain_info, list);
@@ -1540,10 +1612,9 @@
 			continue;
 		if (!ccs_io_printf(head, "%u %s\n", domain->profile,
 				   domain->domainname->name))
-			return 0;
+			return;
 	}
 	head->read_eof = true;
-	return 0;
 }
 
 /**
@@ -1570,7 +1641,7 @@
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_read_pid(struct ccs_io_buffer *head)
+static void ccs_read_pid(struct ccs_io_buffer *head)
 {
 	char *buf = head->write_buf;
 	bool task_info = false;
@@ -1581,9 +1652,9 @@
 	ccs_assert_read_lock();
 	/* Accessing write_buf is safe because head->io_sem is held. */
 	if (!buf)
-		goto done; /* Do nothing if open(O_RDONLY). */
+		return; /* Do nothing if open(O_RDONLY). */
 	if (head->read_avail || head->read_eof)
-		goto done;
+		return;
 	head->read_eof = true;
 	if (ccs_str_starts(&buf, "info "))
 		task_info = true;
@@ -1596,7 +1667,7 @@
 	}
 	read_unlock(&tasklist_lock);
 	if (!domain)
-		goto done;
+		return;
 	if (!task_info)
 		ccs_io_printf(head, "%u %u %s", pid, domain->profile,
 			      domain->domainname->name);
@@ -1610,8 +1681,6 @@
 			      (u8) (ccs_flags >> 24),
 			      (u8) (ccs_flags >> 16),
 			      (u8) (ccs_flags >> 8));
- done:
-	return 0;
 }
 
 /**
@@ -1661,80 +1730,74 @@
  *
  * @head: Pointer to "struct ccs_io_buffer".
  *
- * Returns 0 on success, -EINVAL otherwise.
- *
  * Caller holds ccs_read_lock().
  */
-static int ccs_read_exception_policy(struct ccs_io_buffer *head)
+static void ccs_read_exception_policy(struct ccs_io_buffer *head)
 {
 	ccs_assert_read_lock();
-	if (!head->read_eof) {
-		switch (head->read_step) {
-		case 0:
-			head->read_var2 = NULL;
-			head->read_step = 1;
-		case 1:
-			if (!ccs_read_domain_keeper_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 2;
-		case 2:
-			if (!ccs_read_globally_readable_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 3;
-		case 3:
-			if (!ccs_read_globally_usable_env_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 4;
-		case 4:
-			if (!ccs_read_domain_initializer_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 6;
-		case 6:
-			if (!ccs_read_aggregator_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 7;
-		case 7:
-			if (!ccs_read_file_pattern(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 8;
-		case 8:
-			if (!ccs_read_no_rewrite_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 9;
-		case 9:
-			if (!ccs_read_path_group_policy(head))
-				break;
-			head->read_var1 = NULL;
-			head->read_var2 = NULL;
-			head->read_step = 10;
-		case 10:
-			if (!ccs_read_number_group_policy(head))
-				break;
-			head->read_var1 = NULL;
-			head->read_var2 = NULL;
-			head->read_step = 11;
-		case 11:
-			if (!ccs_read_address_group_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 12;
-		case 12:
-			if (!ccs_read_reserved_port_policy(head))
-				break;
-			head->read_eof = true;
+	if (head->read_eof)
+		return;
+	switch (head->read_step) {
+	case 0:
+		head->read_var2 = NULL;
+		head->read_step = 1;
+	case 1:
+		if (!ccs_read_domain_keeper_policy(head))
 			break;
-		default:
-			return -EINVAL;
-		}
+		head->read_var2 = NULL;
+		head->read_step = 2;
+	case 2:
+		if (!ccs_read_globally_readable_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 3;
+	case 3:
+		if (!ccs_read_globally_usable_env_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 4;
+	case 4:
+		if (!ccs_read_domain_initializer_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 6;
+	case 6:
+		if (!ccs_read_aggregator_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 7;
+	case 7:
+		if (!ccs_read_file_pattern(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 8;
+	case 8:
+		if (!ccs_read_no_rewrite_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 9;
+	case 9:
+		if (!ccs_read_path_group_policy(head))
+			break;
+		head->read_var1 = NULL;
+		head->read_var2 = NULL;
+		head->read_step = 10;
+	case 10:
+		if (!ccs_read_number_group_policy(head))
+			break;
+		head->read_var1 = NULL;
+		head->read_var2 = NULL;
+		head->read_step = 11;
+	case 11:
+		if (!ccs_read_address_group_policy(head))
+			break;
+		head->read_var2 = NULL;
+		head->read_step = 12;
+	case 12:
+		if (!ccs_read_reserved_port_policy(head))
+			break;
+		head->read_eof = true;
 	}
-	return 0;
 }
 
 /**
@@ -1890,7 +1953,7 @@
 	switch (r->mode) {
 		char *buffer;
 		struct ccs_condition *cond;
-	case 1:
+	case CCS_MAC_MODE_LEARNING:
 		if (!ccs_domain_quota_ok(r))
 			return 0;
 		va_start(args, fmt);
@@ -1914,7 +1977,7 @@
 		ccs_put_condition(cond);
 		kfree(buffer);
 		/* fall through */
-	case 2:
+	case CCS_MAC_MODE_PERMISSIVE:
 		return 0;
 	}
 	if (!atomic_read(&ccs_query_observers)) {
@@ -2041,17 +2104,15 @@
  * ccs_read_query - Read access requests which violated policy in enforcing mode.
  *
  * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0.
  */
-static int ccs_read_query(struct ccs_io_buffer *head)
+static void ccs_read_query(struct ccs_io_buffer *head)
 {
 	struct list_head *tmp;
 	int pos = 0;
 	int len = 0;
 	char *buf;
 	if (head->read_avail)
-		return 0;
+		return;
 	if (head->read_buf) {
 		kfree(head->read_buf);
 		head->read_buf = NULL;
@@ -2071,11 +2132,11 @@
 	spin_unlock(&ccs_query_list_lock);
 	if (!len) {
 		head->read_step = 0;
-		return 0;
+		return;
 	}
 	buf = kzalloc(len, GFP_KERNEL);
 	if (!buf)
-		return 0;
+		return;
 	pos = 0;
 	spin_lock(&ccs_query_list_lock);
 	list_for_each(tmp, &ccs_query_list) {
@@ -2102,7 +2163,6 @@
 	} else {
 		kfree(buf);
 	}
-	return 0;
 }
 
 /**
@@ -2145,38 +2205,30 @@
  * ccs_read_version: Get version.
  *
  * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns version information.
  */
-static int ccs_read_version(struct ccs_io_buffer *head)
+static void ccs_read_version(struct ccs_io_buffer *head)
 {
-	if (!head->read_eof) {
-		ccs_io_printf(head, "1.7.0-pre");
-		head->read_eof = true;
-	}
-	return 0;
+	if (head->read_eof)
+		return;
+	ccs_io_printf(head, "1.7.0-pre");
+	head->read_eof = true;
 }
 
 /**
  * ccs_read_self_domain - Get the current process's domainname.
  *
  * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns the current process's domainname.
  */
-static int ccs_read_self_domain(struct ccs_io_buffer *head)
+static void ccs_read_self_domain(struct ccs_io_buffer *head)
 {
-	if (!head->read_eof) {
-		/*
-		 * ccs_current_domain()->domainname != NULL
-		 * because every process belongs to a domain and
-		 * the domain's name cannot be NULL.
-		 */
-		ccs_io_printf(head, "%s",
-			      ccs_current_domain()->domainname->name);
-		head->read_eof = true;
-	}
-	return 0;
+	if (head->read_eof)
+		return;
+	/*
+	 * ccs_current_domain()->domainname != NULL because every process
+	 * belongs to a domain and the domain's name cannot be NULL.
+	 */
+	ccs_io_printf(head, "%s", ccs_current_domain()->domainname->name);
+	head->read_eof = true;
 }
 
 /**
@@ -2347,22 +2399,22 @@
 		return -EFAULT;
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
- retry:
-	/* Call the policy handler. */
-	len = head->read(head);
-	if (len < 0)
-		goto out;
-	/* Write to buffer. */
-	len = head->read_avail;
-	if (!len && !head->poll && !head->read_eof) {
-		const int len = head->readbuf_size * 2;
+	while (1) {
+		/* Call the policy handler. */
+		head->read(head);
+		/* Write to buffer. */
+		len = head->read_avail;
+		if (len || head->poll || head->read_eof)
+			break;
+		len = head->readbuf_size * 2;
 		cp = kzalloc(len, GFP_KERNEL);
-		if (cp) {
-			kfree(head->read_buf);
-			head->read_buf = cp;
-			head->readbuf_size = len;
-			goto retry;
+		if (!cp) {
+			len = -ENOMEM;
+			goto out;
 		}
+		kfree(head->read_buf);
+		head->read_buf = cp;
+		head->readbuf_size = len;
 	}
 	if (len > buffer_len)
 		len = buffer_len;
Index: branches/ccs-patch/security/ccsecurity/umount.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/umount.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/umount.c	(working copy)
@@ -28,13 +28,11 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_audit_umount_log(struct ccs_request_info *r,
-				const char *dir, const bool is_granted)
+static int ccs_audit_umount_log(struct ccs_request_info *r, const char *dir,
+				const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain))
-		printk(KERN_WARNING "%s: umount %s denied for %s\n",
-		       ccs_get_msg(r->mode == 3), dir,
-		       ccs_get_last_name(r->domain));
+	if (!is_granted)
+		ccs_warn_log(r, "umount %s", dir);
 	return ccs_write_audit_log(is_granted, r, CCS_KEYWORD_ALLOW_UNMOUNT
 				   "%s\n", dir);
 }
@@ -53,8 +51,6 @@
 	struct ccs_request_info r;
 	int error;
 	const char *dir0;
-	bool is_enforce;
-	struct ccs_acl_info *ptr;
 	struct ccs_path_info dir;
 	struct path path = { mnt, mnt->mnt_root };
 	struct ccs_obj_info obj = {
@@ -62,40 +58,42 @@
 		.path1.mnt = mnt
 	};
 	ccs_assert_read_lock();
-	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_UMOUNT))
+	if (ccs_init_request_info(&r, NULL, CCS_MAC_FILE_UMOUNT)
+	    == CCS_MAC_MODE_DISABLED)
 		return 0;
-	is_enforce = (r.mode == 3);
 	r.obj = &obj;
- retry:
-	error = -EPERM;
+	error = -ENOMEM;
 	dir0 = ccs_realpath_from_path(&path);
 	if (!dir0)
 		goto out;
 	dir.name = dir0;
 	ccs_fill_path_info(&dir);
-	list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
-		struct ccs_umount_acl *acl;
-		if (ptr->is_deleted || ptr->type != CCS_TYPE_UMOUNT_ACL)
-			continue;
-		acl = container_of(ptr, struct ccs_umount_acl, head);
-		if (!ccs_compare_name_union(&dir, &acl->dir) ||
-		    !ccs_condition(&r, ptr))
-			continue;
-		r.cond = ptr->cond;
-		error = 0;
-		break;
-	}
-	ccs_audit_umount_log(&r, dir0, !error);
-	if (error)
-		error = ccs_supervisor(&r, CCS_KEYWORD_ALLOW_UNMOUNT
-					     "%s", ccs_file_pattern(&dir));
+	do {
+		struct ccs_acl_info *ptr;
+		error = -EPERM;
+		list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
+			struct ccs_umount_acl *acl;
+			if (ptr->is_deleted ||
+			    ptr->type != CCS_TYPE_UMOUNT_ACL)
+				continue;
+			acl = container_of(ptr, struct ccs_umount_acl, head);
+			if (!ccs_compare_name_union(&dir, &acl->dir) ||
+			    !ccs_condition(&r, ptr))
+				continue;
+			r.cond = ptr->cond;
+			error = 0;
+			break;
+		}
+		ccs_audit_umount_log(&r, dir0, !error);
+		if (!error)
+			break;
+		error = ccs_supervisor(&r, CCS_KEYWORD_ALLOW_UNMOUNT "%s",
+				       ccs_file_pattern(&dir));
+	} while (error == 1);
  out:
 	kfree(dir0);
-	if (!is_enforce)
+	if (r.mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
-	if (error == 1)
-		goto retry;
 	return error;
 }
 
@@ -131,7 +129,7 @@
 	struct ccs_umount_acl *entry = NULL;
 	struct ccs_acl_info *ptr;
 	struct ccs_umount_acl e = { .head.type = CCS_TYPE_UMOUNT_ACL,
-					   .head.cond = condition };
+				    .head.cond = condition };
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (data[0] != '@' && !ccs_is_correct_path(data, 1, 0, 1))
 		return -EINVAL;
Index: branches/ccs-patch/security/ccsecurity/compat.h
===================================================================
--- branches/ccs-patch/security/ccsecurity/compat.h	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/compat.h	(working copy)
@@ -80,10 +80,10 @@
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
-#define kzalloc(size, flags) ({						\
-			void *ret = kmalloc((size), (flags));		\
-			if (ret)					\
-				memset(ret, 0, (size));			\
+#define kzalloc(size, flags) ({					\
+			void *ret = kmalloc((size), (flags));	\
+			if (ret)				\
+				memset(ret, 0, (size));		\
 			ret; })
 #endif
 
@@ -96,37 +96,37 @@
 #endif
 
 #ifndef rcu_dereference
-#define rcu_dereference(p)     ({ \
-				typeof(p) _________p1 = ACCESS_ONCE(p); \
-				smp_read_barrier_depends(); /* see RCU */ \
-				(_________p1); \
-				})
+#define rcu_dereference(p)     ({					\
+			typeof(p) _________p1 = ACCESS_ONCE(p);		\
+			smp_read_barrier_depends(); /* see RCU */	\
+			(_________p1);					\
+		})
 #endif
 
 #ifndef rcu_assign_pointer
-#define rcu_assign_pointer(p, v) \
-	({ \
-		if (!__builtin_constant_p(v) || \
-		    ((v) != NULL)) \
-			smp_wmb(); /* see RCU */ \
-		(p) = (v); \
+#define rcu_assign_pointer(p, v)			\
+	({						\
+		if (!__builtin_constant_p(v) ||		\
+		    ((v) != NULL))			\
+			smp_wmb(); /* see RCU */	\
+		(p) = (v);				\
 	})
 #endif
 
 #ifndef list_for_each_rcu
-#define list_for_each_rcu(pos, head) \
-	for (pos = rcu_dereference((head)->next); \
-		prefetch(pos->next), pos != (head); \
-		pos = rcu_dereference(pos->next))
+#define list_for_each_rcu(pos, head)			\
+	for (pos = rcu_dereference((head)->next);	\
+	     prefetch(pos->next), pos != (head);	\
+	     pos = rcu_dereference(pos->next))
 #endif
 
 #ifndef list_for_each_entry_rcu
-#define list_for_each_entry_rcu(pos, head, member) \
+#define list_for_each_entry_rcu(pos, head, member)			\
 	for (pos = list_entry(rcu_dereference((head)->next), typeof(*pos), \
-		member); \
-		prefetch(pos->member.next), &pos->member != (head); \
-		pos = list_entry(rcu_dereference(pos->member.next), \
-		typeof(*pos), member))
+			      member);					\
+	     prefetch(pos->member.next), &pos->member != (head);	\
+	     pos = list_entry(rcu_dereference(pos->member.next),	\
+			      typeof(*pos), member))
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
@@ -164,10 +164,10 @@
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 30)
 #undef ssleep
-#define ssleep(secs) {                              \
-	set_current_state(TASK_UNINTERRUPTIBLE);    \
-	schedule_timeout((HZ * secs) + 1);          \
-}
+#define ssleep(secs) {						\
+		set_current_state(TASK_UNINTERRUPTIBLE);	\
+		schedule_timeout((HZ * secs) + 1);		\
+	}
 #endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
@@ -207,11 +207,11 @@
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
 #if defined(__LITTLE_ENDIAN)
-#define HIPQUAD(addr) \
-	((unsigned char *)&addr)[3], \
-	((unsigned char *)&addr)[2], \
-	((unsigned char *)&addr)[1], \
-	((unsigned char *)&addr)[0]
+#define HIPQUAD(addr)				\
+	((unsigned char *)&addr)[3],		\
+		((unsigned char *)&addr)[2],	\
+		((unsigned char *)&addr)[1],	\
+		((unsigned char *)&addr)[0]
 #elif defined(__BIG_ENDIAN)
 #define HIPQUAD NIPQUAD
 #else
@@ -240,8 +240,8 @@
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
 
 struct path {
-        struct vfsmount *mnt;
-        struct dentry *dentry;
+	struct vfsmount *mnt;
+	struct dentry *dentry;
 };
 
 #endif
Index: branches/ccs-patch/security/ccsecurity/network.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/network.c	(revision 2932)
+++ branches/ccs-patch/security/ccsecurity/network.c	(working copy)
@@ -34,10 +34,8 @@
 				 const char *operation, const char *address,
 				 const u16 port, const bool is_granted)
 {
-	if (!is_granted && ccs_verbose_mode(r->domain))
-		printk(KERN_WARNING "%s: %s to %s %u denied for %s\n",
-		       ccs_get_msg(r->mode == 3), operation, address, port,
-		       ccs_get_last_name(r->domain));
+	if (!is_granted)
+		ccs_warn_log(r, "%s %s %u", operation, address, port);
 	return ccs_write_audit_log(is_granted, r, CCS_KEYWORD_ALLOW_NETWORK
 				   "%s %s %u\n", operation, address, port);
 }
@@ -86,11 +84,11 @@
 }
 
 #if !defined(NIP6)
-#define NIP6(addr)	\
-	ntohs((addr).s6_addr16[0]), ntohs((addr).s6_addr16[1]), \
-	ntohs((addr).s6_addr16[2]), ntohs((addr).s6_addr16[3]), \
-	ntohs((addr).s6_addr16[4]), ntohs((addr).s6_addr16[5]), \
-	ntohs((addr).s6_addr16[6]), ntohs((addr).s6_addr16[7])
+#define NIP6(addr)							\
+	ntohs((addr).s6_addr16[0]), ntohs((addr).s6_addr16[1]),		\
+		ntohs((addr).s6_addr16[2]), ntohs((addr).s6_addr16[3]), \
+		ntohs((addr).s6_addr16[4]), ntohs((addr).s6_addr16[5]), \
+		ntohs((addr).s6_addr16[6]), ntohs((addr).s6_addr16[7])
 #endif
 
 /**
@@ -161,66 +159,74 @@
  * Caller holds ccs_read_lock().
  */
 static int ccs_network_entry2(const bool is_ipv6, const u8 operation,
-				    const u32 *address, const u16 port)
+			      const u32 *address, const u16 port)
 {
 	struct ccs_request_info r;
 	struct ccs_acl_info *ptr;
 	const char *keyword = ccs_net2keyword(operation);
-	bool is_enforce;
 	const u16 perm = 1 << operation;
 	/* using host byte order to allow u32 comparison than memcmp().*/
 	const u32 ip = ntohl(*address);
 	int error;
 	char buf[64];
 	ccs_assert_read_lock();
-	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_NETWORK))
+	if (ccs_init_request_info(&r, NULL,
+				  CCS_MAC_NETWORK_UDP_BIND + operation)
+	    == CCS_MAC_MODE_DISABLED)
 		return 0;
-	is_enforce = (r.mode == 3);
- retry:
-	error = -EPERM;
-	list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
-		struct ccs_ip_network_acl *acl;
-		if (ptr->is_deleted || ptr->type != CCS_TYPE_IP_NETWORK_ACL)
-			continue;
-		acl = container_of(ptr, struct ccs_ip_network_acl, head);
-		if (!(acl->perm & perm))
-			continue;
-		if (!ccs_compare_number_union(port, &acl->port) ||
-		    !ccs_condition(&r, ptr))
-			continue;
-		if (acl->address_type == CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP) {
-			if (!ccs_address_matches_group(is_ipv6, address,
-						       acl->address.group))
+	memset(buf, 0, sizeof(buf));
+	if (is_ipv6)
+		ccs_print_ipv6(buf, sizeof(buf), (const struct in6_addr *)
+			       address);
+	else
+		snprintf(buf, sizeof(buf) - 1, "%u.%u.%u.%u", HIPQUAD(ip));
+	do {
+		error = -EPERM;
+		list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
+			struct ccs_ip_network_acl *acl;
+			if (ptr->is_deleted ||
+			    ptr->type != CCS_TYPE_IP_NETWORK_ACL)
 				continue;
-		} else if (acl->address_type == CCS_IP_ADDRESS_TYPE_IPv4) {
-			if (is_ipv6 ||
-			    ip < acl->address.ipv4.min ||
-			    acl->address.ipv4.max < ip)
+			acl = container_of(ptr, struct ccs_ip_network_acl,
+					   head);
+			if (!(acl->perm & perm))
 				continue;
-		} else {
-			if (!is_ipv6 ||
-			    memcmp(acl->address.ipv6.min, address, 16) > 0 ||
-			    memcmp(address, acl->address.ipv6.max, 16) > 0)
+			if (!ccs_compare_number_union(port, &acl->port) ||
+			    !ccs_condition(&r, ptr))
 				continue;
+			switch (acl->address_type) {
+			case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
+				if (!ccs_address_matches_group(is_ipv6,
+							       address,
+							       acl->address.
+							       group))
+					continue;
+				break;
+			case CCS_IP_ADDRESS_TYPE_IPv4:
+				if (is_ipv6 || ip < acl->address.ipv4.min ||
+				    acl->address.ipv4.max < ip)
+					continue;
+				break;
+			default:
+				if (!is_ipv6 ||
+				    memcmp(acl->address.ipv6.min, address, 16)
+				    > 0 ||
+				    memcmp(address, acl->address.ipv6.max, 16)
+				    > 0)
+					continue;
+				break;
+			}
+			r.cond = ptr->cond;
+			error = 0;
+			break;
 		}
-		r.cond = ptr->cond;
-		error = 0;
-		break;
-	}
-	memset(buf, 0, sizeof(buf));
-	if (is_ipv6)
-		ccs_print_ipv6(buf, sizeof(buf),
-			       (const struct in6_addr *) address);
-	else
-		snprintf(buf, sizeof(buf) - 1, "%u.%u.%u.%u", HIPQUAD(ip));
-	ccs_audit_network_log(&r, keyword, buf, port, !error);
-	if (error)
+		ccs_audit_network_log(&r, keyword, buf, port, !error);
+		if (!error)
+			break;
 		error = ccs_supervisor(&r, CCS_KEYWORD_ALLOW_NETWORK
-					     "%s %s %u\n", keyword, buf, port);
-	if (error == 1)
-		goto retry;
-	if (!is_enforce)
+				       "%s %s %u\n", keyword, buf, port);
+	} while (error == 1);
+	if (r.mode != CCS_MAC_MODE_ENFORCING)
 		error = 0;
 	return error;
 }
@@ -236,11 +242,11 @@
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_network_entry(const bool is_ipv6, const u8 operation,
-				   const u32 *address, const u16 port)
+			     const u32 *address, const u16 port)
 {
 	const int idx = ccs_read_lock();
 	const int error = ccs_network_entry2(is_ipv6, operation,
-						   address, port);
+					     address, port);
 	ccs_read_unlock(idx);
 	return error;
 }
@@ -323,8 +329,8 @@
 	case 1:
 		e.address_type = CCS_IP_ADDRESS_TYPE_IPv4;
 		/* use host byte order to allow u32 comparison.*/
-		e.address.ipv4.min = ntohl(* (u32 *) min_address);
-		e.address.ipv4.max = ntohl(* (u32 *) max_address);
+		e.address.ipv4.min = ntohl(*(u32 *) min_address);
+		e.address.ipv4.max = ntohl(*(u32 *) max_address);
 		break;
 	default:
 		if (w[2][0] != '@')
@@ -390,11 +396,11 @@
  * Returns 0 on success, negative value otherwise.
  */
 static inline int ccs_network_listen_acl(const bool is_ipv6,
-					       const u8 *address,
-					       const u16 port)
+					 const u8 *address,
+					 const u16 port)
 {
 	return ccs_network_entry(is_ipv6, CCS_NETWORK_TCP_LISTEN,
-				       (const u32 *) address, ntohs(port));
+				 (const u32 *) address, ntohs(port));
 }
 
 /**
@@ -408,9 +414,9 @@
  * Returns 0 on success, negative value otherwise.
  */
 static inline int ccs_network_connect_acl(const bool is_ipv6,
-						const int sock_type,
-						const u8 *address,
-						const u16 port)
+					  const int sock_type,
+					  const u8 *address,
+					  const u16 port)
 {
 	u8 operation;
 	switch (sock_type) {
@@ -424,7 +430,7 @@
 		operation = CCS_NETWORK_RAW_CONNECT;
 	}
 	return ccs_network_entry(is_ipv6, operation,
-				       (const u32 *) address, ntohs(port));
+				 (const u32 *) address, ntohs(port));
 }
 
 /**
@@ -438,7 +444,7 @@
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_network_bind_acl(const bool is_ipv6, const int sock_type,
-				      const u8 *address, const u16 port)
+				const u8 *address, const u16 port)
 {
 	u8 operation;
 	switch (sock_type) {
@@ -452,7 +458,7 @@
 		operation = CCS_NETWORK_RAW_BIND;
 	}
 	return ccs_network_entry(is_ipv6, operation,
-				       (const u32 *) address, ntohs(port));
+				 (const u32 *) address, ntohs(port));
 }
 
 /**
@@ -465,13 +471,13 @@
  * Returns 0 on success, negative value otherwise.
  */
 static inline int ccs_network_accept_acl(const bool is_ipv6,
-					       const u8 *address,
-					       const u16 port)
+					 const u8 *address,
+					 const u16 port)
 {
 	int retval;
 	current->ccs_flags |= CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
 	retval = ccs_network_entry(is_ipv6, CCS_NETWORK_TCP_ACCEPT,
-					 (const u32 *) address, ntohs(port));
+				   (const u32 *) address, ntohs(port));
 	current->ccs_flags &= ~CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
 	return retval;
 }
@@ -487,9 +493,9 @@
  * Returns 0 on success, negative value otherwise.
  */
 static inline int ccs_network_sendmsg_acl(const bool is_ipv6,
-						const int sock_type,
-						const u8 *address,
-						const u16 port)
+					  const int sock_type,
+					  const u8 *address,
+					  const u16 port)
 {
 	u8 operation;
 	if (sock_type == SOCK_DGRAM)
@@ -497,7 +503,7 @@
 	else
 		operation = CCS_NETWORK_RAW_CONNECT;
 	return ccs_network_entry(is_ipv6, operation,
-				       (const u32 *) address, ntohs(port));
+				 (const u32 *) address, ntohs(port));
 }
 
 /**
@@ -511,9 +517,9 @@
  * Returns 0 on success, negative value otherwise.
  */
 static inline int ccs_network_recvmsg_acl(const bool is_ipv6,
-						const int sock_type,
-						const u8 *address,
-						const u16 port)
+					  const int sock_type,
+					  const u8 *address,
+					  const u16 port)
 {
 	int retval;
 	const u8 operation
@@ -521,7 +527,7 @@
 		CCS_NETWORK_UDP_CONNECT : CCS_NETWORK_RAW_CONNECT;
 	current->ccs_flags |= CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
 	retval = ccs_network_entry(is_ipv6, operation,
-					 (const u32 *) address, ntohs(port));
+				   (const u32 *) address, ntohs(port));
 	current->ccs_flags &= ~CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
 	return retval;
 }
@@ -586,14 +592,14 @@
 	case AF_INET6:
 		addr6 = (struct sockaddr_in6 *) addr;
 		error = ccs_network_listen_acl(true,
-						     addr6->sin6_addr.s6_addr,
-						     addr6->sin6_port);
+					       addr6->sin6_addr.s6_addr,
+					       addr6->sin6_port);
 		break;
 	case AF_INET:
 		addr4 = (struct sockaddr_in *) addr;
 		error = ccs_network_listen_acl(false,
-						     (u8 *) &addr4->sin_addr,
-						     addr4->sin_port);
+					       (u8 *) &addr4->sin_addr,
+					       addr4->sin_port);
 		break;
 	}
 	return error;
@@ -629,8 +635,8 @@
 		else
 			port = htons(sock->sk->sk_protocol);
 		error = ccs_network_connect_acl(true, type,
-						      addr6->sin6_addr.s6_addr,
-						      port);
+						addr6->sin6_addr.s6_addr,
+						port);
 		break;
 	case AF_INET:
 		if (addr_len < sizeof(struct sockaddr_in))
@@ -641,8 +647,8 @@
 		else
 			port = htons(sock->sk->sk_protocol);
 		error = ccs_network_connect_acl(false, type,
-						      (u8 *) &addr4->sin_addr,
-						      port);
+						(u8 *) &addr4->sin_addr,
+						port);
 		break;
 	}
 	if (type != SOCK_STREAM)
@@ -687,8 +693,8 @@
 		else
 			port = htons(sock->sk->sk_protocol);
 		error = ccs_network_bind_acl(true, type,
-						   addr6->sin6_addr.s6_addr,
-						   port);
+					     addr6->sin6_addr.s6_addr,
+					     port);
 		break;
 	case AF_INET:
 		if (addr_len < sizeof(struct sockaddr_in))
@@ -699,8 +705,8 @@
 		else
 			port = htons(sock->sk->sk_protocol);
 		error = ccs_network_bind_acl(false, type,
-						   (u8 *) &addr4->sin_addr,
-						   port);
+					     (u8 *) &addr4->sin_addr,
+					     port);
 		break;
 	}
 	return error;
@@ -734,14 +740,14 @@
 	case AF_INET6:
 		addr6 = (struct sockaddr_in6 *) addr;
 		error = ccs_network_accept_acl(true,
-						     addr6->sin6_addr.s6_addr,
-						     addr6->sin6_port);
+					       addr6->sin6_addr.s6_addr,
+					       addr6->sin6_port);
 		break;
 	case AF_INET:
 		addr4 = (struct sockaddr_in *) addr;
 		error = ccs_network_accept_acl(false,
-						     (u8 *) &addr4->sin_addr,
-						     addr4->sin_port);
+					       (u8 *) &addr4->sin_addr,
+					       addr4->sin_port);
 		break;
 	}
 	return error;
@@ -771,8 +777,8 @@
 		else
 			port = htons(sock->sk->sk_protocol);
 		error = ccs_network_sendmsg_acl(true, type,
-						      addr6->sin6_addr.s6_addr,
-						      port);
+						addr6->sin6_addr.s6_addr,
+						port);
 		break;
 	case AF_INET:
 		if (addr_len < sizeof(struct sockaddr_in))
@@ -783,8 +789,8 @@
 		else
 			port = htons(sock->sk->sk_protocol);
 		error = ccs_network_sendmsg_acl(false, type,
-						      (u8 *) &addr4->sin_addr,
-						      port);
+						(u8 *) &addr4->sin_addr,
+						port);
 		break;
 	}
 	return error;
@@ -883,7 +889,7 @@
 			port = htons(sk->sk_protocol);
 		}
 		error = ccs_network_recvmsg_acl(true, type,
-						      (u8 *) &sin6, port);
+						(u8 *) &sin6, port);
 		break;
 	case PF_INET:
 		if (type == SOCK_DGRAM) { /* UDP IPv4 */
@@ -894,7 +900,7 @@
 			port = htons(sk->sk_protocol);
 		}
 		error = ccs_network_recvmsg_acl(false, type,
-						      (u8 *) &sin4, port);
+						(u8 *) &sin4, port);
 		break;
 	}
 	if (!error)
Index: branches/ccs-tools/ccstools/kernel_test/ccs_signal_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_signal_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_signal_test.c	(working copy)
@@ -59,13 +59,13 @@
 	int j;
 	for (i = 0; i < 2; i++) {
 		if (i == 0) {
-			fprintf(profile_fp, "255-MAC_FOR_SIGNAL=enforcing\n");
+			fprintf(profile_fp, "255-MAC::ipc::signal=enforcing\n");
 			is_enforce = 1;
 			printf("***** Testing signal hooks in enforce mode. "
 			       "*****\n");
 			fflush(stdout);
 		} else {
-			fprintf(profile_fp, "255-MAC_FOR_SIGNAL=permissive\n");
+			fprintf(profile_fp, "255-MAC::ipc::signal=permissive\n");
 			is_enforce = 0;
 			printf("***** Testing signal hooks in permissive mode. "
 			       "*****\n");
Index: branches/ccs-tools/ccstools/kernel_test/ccs_argv0_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_argv0_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_argv0_test.c	(working copy)
@@ -44,7 +44,7 @@
 	memset(buffer, 0, sizeof(buffer));
 	{
 		is_enforce = 0;
-		fprintf(profile_fp, "255-MAC_FOR_ARGV0=permissive\n");
+		fprintf(profile_fp, "255-MAC::file::execute=permissive\n");
 		if (fork() == 0) {
 			execv("/bin/true", argv);
 			_exit(errno);
@@ -57,7 +57,7 @@
 		show_result(errno ? EOF : 0);
 
 		is_enforce = 1;
-		fprintf(profile_fp, "255-MAC_FOR_ARGV0=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::execute=enforcing\n");
 		if (fork() == 0) {
 			execv("/bin/true", argv);
 			_exit(errno);
Index: branches/ccs-tools/ccstools/kernel_test/ccs_file_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_file_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_file_test.c	(working copy)
@@ -215,9 +215,9 @@
 static void set_file_enforce(int enforce)
 {
 	if (enforce)
-		fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	else
-		fprintf(profile_fp, "255-MAC_FOR_FILE=permissive\n");
+		fprintf(profile_fp, "255-MAC::file=permissive\n");
 }
 
 int main(int argc, char *argv[])
Index: branches/ccs-tools/ccstools/kernel_test/ccs_rewrite_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_rewrite_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_rewrite_test.c	(working copy)
@@ -40,13 +40,13 @@
 
 static void add_domain_policy(const char *data)
 {
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	fprintf(domain_fp, "%s\n", data);
 }
 
 static void add_exception_policy(const char *data)
 {
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	fprintf(exception_fp, "%s\n", data);
 }
 
@@ -65,7 +65,7 @@
 	close(open(REWRITE_PATH, O_WRONLY | O_APPEND | O_CREAT, 0600));
 
 	/* Enforce mode */
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	should_fail = 0;
 
 	show_prompt("open(O_RDONLY)");
@@ -106,7 +106,7 @@
 	close(fd);
 
 	/* Permissive mode */
-	fprintf(profile_fp, "255-MAC_FOR_FILE=permissive\n");
+	fprintf(profile_fp, "255-MAC::file=permissive\n");
 	should_fail = 0;
 
 	show_prompt("open(O_RDONLY)");
Index: branches/ccs-tools/ccstools/kernel_test/ccs_capability_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_capability_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_capability_test.c	(working copy)
@@ -54,17 +54,15 @@
 
 static void set_capability(const char *capability)
 {
-	fprintf(profile_fp, "255-MAC_FOR_CAPABILITY=%s\n",
-		is_enforce ? "enforcing" : "permissive");
-	fprintf(profile_fp, "255-SUPPORTED_CAPABILITIES=%s\n", capability);
+	fprintf(profile_fp, "255-MAC::capability::%s=%s\n",
+		capability, is_enforce ? "enforcing" : "permissive");
 	if (should_success)
 		fprintf(domain_fp, "allow_capability %s\n", capability);
 }
 
 static void unset_capability(const char *capability)
 {
-	fprintf(profile_fp, "255-MAC_FOR_CAPABILITY=disabled\n");
-	fprintf(profile_fp, "255-SUPPORTED_CAPABILITIES=%s\n", capability);
+	fprintf(profile_fp, "255-MAC::capability::%s=disabled\n", capability);
 	if (should_success)
 		fprintf(domain_fp, "delete allow_capability %s\n", capability);
 }
Index: branches/ccs-tools/ccstools/kernel_test/ccs_cond_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_cond_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_cond_test.c	(working copy)
@@ -16,9 +16,9 @@
 	int policy_found = 0;
 	int err = 0;
 	memset(buffer, 0, sizeof(buffer));
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	fp = fopen(proc_policy_domain_policy, "r+");
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	printf("%s: ", policy);
 	fflush(stdout);
 	fprintf(domain_fp, "%s\n", policy);
@@ -303,12 +303,12 @@
 	ccs_test_init();
 	fprintf(domain_fp, "ignore_global_allow_read\n");
 	fprintf(domain_fp, "allow_read/write %s\n", proc_policy_domain_policy);
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	stage_open_test();
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
-	fprintf(profile_fp, "255-MAC_FOR_SIGNAL=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
+	fprintf(profile_fp, "255-MAC::ipc::signal=enforcing\n");
 	stage_signal_test();
-	fprintf(profile_fp, "255-MAC_FOR_SIGNAL=disabled\n");
+	fprintf(profile_fp, "255-MAC::ipc::signal=disabled\n");
 	clear_status();
 	return 0;
 }
Index: branches/ccs-tools/ccstools/kernel_test/ccs_filesystem_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_filesystem_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_filesystem_test.c	(working copy)
@@ -45,7 +45,7 @@
 
 	/* Test mount(). */
 	{
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::mount=enforcing\n");
 		show_prompt("mount('dev\\011name', '/', 'fs\\011name') ", 1);
 		if (mount("dev\tname", "/", "fs\tname", 0, NULL) == EOF &&
 		    errno == EPERM)
@@ -54,7 +54,7 @@
 			printf("OK: No such device.\n");
 		else
 			printf("BUG: %s\n", strerror(errno));
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=learning\n");
+		fprintf(profile_fp, "255-MAC::file::mount=learning\n");
 		show_prompt("mount('dev\\011name', '/', 'fs\\011name') ", 0);
 		if (mount("dev\tname", "/", "fs\tname", 0, NULL) == EOF &&
 		    errno == ENOMEM)
@@ -63,7 +63,7 @@
 			printf("OK: No such device.\n");
 		else
 			printf("BUG: %s\n", strerror(errno));
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::mount=enforcing\n");
 		show_prompt("mount('dev\\011name', '/', 'fs\\011name') ", 0);
 		if (mount("dev\tname", "/", "fs\tname", 0, NULL) == EOF &&
 		    errno == ENOMEM)
@@ -82,13 +82,13 @@
 			printf("OK: No such device.\n");
 		else
 			printf("BUG: %s\n", strerror(errno));
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=learning\n");
+		fprintf(profile_fp, "255-MAC::file::mount=learning\n");
 		show_prompt("mount(NULL, '/', 'tmpfs') ", 0);
 		if (mount(NULL, "/", "tmpfs", 0, NULL))
 			printf("BUG: %s\n", strerror(errno));
 		else
 			printf("OK: Success\n");
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::mount=enforcing\n");
 		show_prompt("mount(NULL, '/', 'tmpfs') ", 0);
 		if (mount(NULL, "/", "tmpfs", 0, NULL))
 			printf("BUG: %s\n", strerror(errno));
@@ -107,7 +107,7 @@
 		else
 			printf("OK: Success\n");
 		fprintf(domain_fp, "delete allow_mount anydev / tmpfs 0\n");
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=permissive\n");
+		fprintf(profile_fp, "255-MAC::file::mount=permissive\n");
 		show_prompt("mount(NULL, NULL, 'tmpfs') ", 1);
 		if (mount(NULL, NULL, "tmpfs", 0, NULL))
 			printf("OK: %s\n", strerror(errno));
@@ -133,7 +133,7 @@
 			printf("OK: %s\n", strerror(errno));
 		else
 			printf("BUG: Did not fail.\n");
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file::mount=disabled\n");
 	}
 
 	mkdir("/tmp/mount/", 0755);
@@ -151,7 +151,7 @@
 			mknod(dev_ram_path, S_IFBLK, MKDEV(1, 0));
 		}
 		memset(buf, 0, sizeof(buf));
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::mount=enforcing\n");
 
 		/* Test standard case */
 		show_prompt("mount('none', '/tmp/mount/', 'tmpfs') for "
@@ -218,7 +218,7 @@
 		fprintf(domain_fp, "delete allow_mount none "
 			"/tmp/\\?\\?\\?\\?\\?/ tmpfs 0\n");
 
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file::mount=disabled\n");
 		while (umount("/tmp/mount/") == 0)
 			c++; /* Dummy. */
 	}
@@ -226,7 +226,7 @@
 	/* Test mount(). */
 	{
 		mount2("none", "/tmp/mount/", "tmpfs");
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::mount=enforcing\n");
 
 		/* Test remount case */
 		show_prompt("mount('/tmp/mount/', MS_REMOUNT)", 1);
@@ -291,13 +291,13 @@
 			printf("OK\n");
 		else
 			printf("FAILED: %s\n", strerror(errno));
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file::mount=disabled\n");
 		umount("/tmp/mount_bind/");
 		fprintf(domain_fp, "delete allow_mount /tmp/mount/ "
 			"/tmp/mount_bind/ --bind 0\n");
 		
 		/* Test move case */
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::mount=enforcing\n");
 		fprintf(domain_fp, "allow_unmount /tmp/mount/\n");
 		fprintf(domain_fp, "allow_mount /tmp/mount/ /tmp/mount_move/ "
 			"--move 0\n");
@@ -308,7 +308,7 @@
 			printf("OK\n");
 		else
 			printf("FAILED: %s\n", strerror(errno));
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file::mount=disabled\n");
 		umount("/tmp/mount_move/");
 		fprintf(domain_fp, "delete allow_unmount /tmp/mount/\n");
 		fprintf(domain_fp, "delete allow_mount /tmp/mount/ "
@@ -325,9 +325,7 @@
 			printf("OK: Permission denied.\n");
 		else
 			printf("BUG: %s\n", strerror(errno));
-		fprintf(profile_fp, "255-MAC_FOR_CAPABILITY=enforcing\n");
-		fprintf(profile_fp,
-			"255-SUPPORTED_CAPABILITIES=conceal_mount\n");
+		fprintf(profile_fp, "255-MAC::capability::conceal_mount=enforcing\n");
 
 		show_prompt("mount('none', '/tmp/mount/', 'tmpfs')", 1);
 		if (mount("none", "/tmp/mount/", "tmpfs", 0, NULL) == EOF &&
@@ -350,9 +348,7 @@
 		else
 			printf("BUG: %s\n", strerror(errno));
 
-		fprintf(profile_fp, "255-MAC_FOR_CAPABILITY=permissive\n");
-		fprintf(profile_fp,
-			"255-SUPPORTED_CAPABILITIES=conceal_mount\n");
+		fprintf(profile_fp, "255-MAC::capability::conceal_mount=permissive\n");
 
 		show_prompt("mount('none', '/tmp/mount/', 'tmpfs')", 0);
 		if (mount("none", "/tmp/mount/", "tmpfs", 0, NULL) == 0)
@@ -360,9 +356,7 @@
 		else
 			printf("FAILED: %s\n", strerror(errno));
 
-		fprintf(profile_fp, "255-MAC_FOR_CAPABILITY=disabled\n");
-		fprintf(profile_fp,
-			"255-SUPPORTED_CAPABILITIES=conceal_mount\n");
+		fprintf(profile_fp, "255-MAC::capability::conceal_mount=disabled\n");
 		while (umount("/tmp/mount/") == 0)
 			c++; /* Dummy. */
 	}
@@ -372,9 +366,9 @@
 		/* Test standard case */
 		fprintf(domain_fp, "allow_unmount /tmp/mount/\n");
 
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file::umount=disabled\n");
 		mount2("none", "/tmp/mount/", "tmpfs");
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::umount=enforcing\n");
 		show_prompt("umount('/tmp/mount/') for '/tmp/mount/'", 0);
 		if (umount("/tmp/mount/") == 0)
 			printf("OK\n");
@@ -382,10 +376,10 @@
 			printf("BUG: %s\n", strerror(errno));
 		fprintf(domain_fp, "delete allow_unmount /tmp/mount/\n");
 
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file::umount=disabled\n");
 		
 		mount2("none", "/tmp/mount/", "tmpfs");
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::umount=enforcing\n");
 		show_prompt("umount('/tmp/mount/') for '/tmp/mount/'", 1);
 		if (umount("/tmp/mount/") == EOF && errno == EPERM)
 			printf("OK: Permission denied.\n");
@@ -394,9 +388,9 @@
 
 		/* Test pattern */
 		fprintf(domain_fp, "allow_unmount /tmp/\\?\\?\\?\\?\\?/\n");
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file::umount=disabled\n");
 		mount2("none", "/tmp/mount/", "tmpfs");
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::umount=enforcing\n");
 		show_prompt("umount('/tmp/mount/') for "
 			    "'/tmp/\\?\\?\\?\\?\\?/'", 1);
 		if (umount("/tmp/mount/") == 0)
@@ -406,14 +400,14 @@
 		fprintf(domain_fp,
 			"delete allow_unmount /tmp/\\?\\?\\?\\?\\?/\n");
 		
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file::umount=disabled\n");
 		while (umount("/tmp/mount/") == 0)
 			c++; /* Dummy. */
 	}
 
 	/* Test chroot(). */
 	{
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::chroot=enforcing\n");
 
 		/* Test standard case */
 		fprintf(domain_fp, "allow_chroot /tmp/mount/\n");
@@ -459,14 +453,14 @@
 		fprintf(domain_fp,
 			"delete allow_chroot /tmp/\\?\\?\\?\\?\\?/\n");
 
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file::chroot=disabled\n");
 	}
 
 	/* Test pivot_root(). */
 	{
 		int error;
 		char *stack = malloc(8192);
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file::pivot_root=enforcing\n");
 		fprintf(domain_fp, "allow_pivot_root %s %s\n",
 			 pivot_root_dir, proc_policy_dir);
 		snprintf(stack, 8191, "pivot_root('%s', '%s')", pivot_root_dir,
@@ -503,7 +497,7 @@
 		else
 			printf("BUG: %s\n", strerror(errno));
 
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=permissive\n");
+		fprintf(profile_fp, "255-MAC::file::pivot_root=permissive\n");
 		snprintf(stack, 8191, "pivot_root('%s', '%s')", pivot_root_dir,
 			 proc_policy_dir);
 		show_prompt(stack, 0);
@@ -520,7 +514,7 @@
 		else
 			printf("FAILED: %s\n", strerror(errno));
 
-		fprintf(profile_fp, "255-MAC_FOR_NAMESPACE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file::pivot_root=disabled\n");
 
 		free(stack);
 	}
Index: branches/ccs-tools/ccstools/kernel_test/ccs_env_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_env_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_env_test.c	(working copy)
@@ -45,7 +45,7 @@
 	memset(buffer, 0, sizeof(buffer));
 	{
 		should_fail = 0;
-		fprintf(profile_fp, "255-MAC_FOR_ENV=permissive\n");
+		fprintf(profile_fp, "255-MAC::misc::env=permissive\n");
 		if (fork() == 0) {
 			execve("/bin/true", argv, envp);
 			_exit(errno);
@@ -58,7 +58,7 @@
 		show_result(errno ? EOF : 0);
 
 		should_fail = 1;
-		fprintf(profile_fp, "255-MAC_FOR_ENV=enforcing\n");
+		fprintf(profile_fp, "255-MAC::misc::env=enforcing\n");
 		if (fork() == 0) {
 			execve("/bin/true", argv, envp);
 			_exit(errno);
Index: branches/ccs-tools/ccstools/kernel_test/ccs_new_file_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_new_file_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_new_file_test.c	(working copy)
@@ -19,9 +19,9 @@
 	int domain_found = 0;
 	int policy_found = 0;
 	memset(buffer, 0, sizeof(buffer));
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	fp = fopen(proc_policy_domain_policy, "r");
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	fprintf(domain_fp, "%s\n", policy);
 	if (!fp) {
 		printf("%s : BUG: policy read failed\n", policy);
@@ -78,41 +78,41 @@
 
 static void create2(const char *pathname)
 {
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	close(creat(pathname, 0600));
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	errno = 0;
 }
 
 static void mkdir2(const char *pathname)
 {
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	mkdir(pathname, 0600);
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	errno = 0;
 }
 
 static void unlink2(const char *pathname)
 {
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	unlink(pathname);
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	errno = 0;
 }
 
 static void rmdir2(const char *pathname)
 {
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	rmdir(pathname);
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	errno = 0;
 }
 
 static void mkfifo2(const char *pathname)
 {
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	mkfifo(pathname, 0600);
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	errno = 0;
 }
 
@@ -130,6 +130,7 @@
 		delete_policy();
 		show_result(sysctl(name, 3, buffer, &size, 0, 0), 0);
 	}
+	return;
 	policy = "allow_write /proc/sys/net/ipv4/ip_local_port_range "
 		"if task.euid=0 0=0 1-100=10-1000";
 	if (write_policy()) {
@@ -256,7 +257,7 @@
 			close(fd);
 	}
 
-	policy = "allow_mkfifo /tmp/mknod_fifo_test "
+	policy = "allow_mkfifo /tmp/mknod_fifo_test 0644"
 		"if path1.parent.perm=01777 path1.parent.perm=sticky "
 		"path1.parent.uid=0 path1.parent.gid=0";
 	if (write_policy()) {
@@ -345,7 +346,7 @@
 			close(fd);
 	}
 
-	policy = "allow_create /tmp/open_test if path1.parent.uid=task.uid";
+	policy = "allow_create /tmp/open_test 0666 if path1.parent.uid=task.uid";
 	if (write_policy()) {
 		policy = "allow_write /tmp/open_test if path1.parent.uid=0";
 		if (write_policy()) {
@@ -363,14 +364,14 @@
 				close(fd);
 			unlink2("/tmp/open_test");
 		}
-		policy = "allow_create /tmp/open_test "
+		policy = "allow_create /tmp/open_test 0666 "
 			"if path1.parent.uid=task.uid";
 		delete_policy();
 	}
 
 	policy = "allow_write /tmp/open_test if task.uid=0 path1.ino!=0";
 	if (write_policy()) {
-		policy = "allow_create /tmp/open_test if 0=0";
+		policy = "allow_create /tmp/open_test 0666 if 0=0";
 		if (write_policy()) {
 			int fd = open("/tmp/open_test",
 				      O_WRONLY | O_CREAT | O_EXCL, 0666);
@@ -441,9 +442,9 @@
 	policy = "allow_truncate /tmp/truncate_test";
 	if (write_policy()) {
 		int fd;
-		fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+		fprintf(profile_fp, "255-MAC::file=disabled\n");
 		fd = open(filename, O_WRONLY);
-		fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file=enforcing\n");
 		show_result(ftruncate(fd, 0), 1);
 		delete_policy();
 		show_result(ftruncate(fd, 0), 0);
@@ -453,7 +454,7 @@
 
 	unlink2(filename);
 
-	policy = "allow_create /tmp/mknod_reg_test";
+	policy = "allow_create /tmp/mknod_reg_test 0666";
 	if (write_policy()) {
 		filename = "/tmp/mknod_reg_test";
 		show_result(mknod(filename, S_IFREG, 0), 1);
@@ -462,7 +463,7 @@
 		show_result(mknod(filename, S_IFREG, 0), 0);
 	}
 
-	policy = "allow_mkchar /tmp/mknod_chr_test 1 3";
+	policy = "allow_mkchar /tmp/mknod_chr_test 0644 1 3";
 	if (write_policy()) {
 		filename = "/tmp/mknod_chr_test";
 		show_result(mknod(filename, S_IFCHR, MKDEV(1, 3)), 1);
@@ -471,7 +472,7 @@
 		show_result(mknod(filename, S_IFCHR, MKDEV(1, 3)), 0);
 	}
 
-	policy = "allow_mkblock /tmp/mknod_blk_test 1 0";
+	policy = "allow_mkblock /tmp/mknod_blk_test 0644 1 0";
 	if (write_policy()) {
 		filename = "/tmp/mknod_blk_test";
 		show_result(mknod(filename, S_IFBLK, MKDEV(1, 0)), 1);
@@ -480,7 +481,7 @@
 		show_result(mknod(filename, S_IFBLK, MKDEV(1, 0)), 0);
 	}
 
-	policy = "allow_mkfifo /tmp/mknod_fifo_test";
+	policy = "allow_mkfifo /tmp/mknod_fifo_test 0644";
 	if (write_policy()) {
 		filename = "/tmp/mknod_fifo_test";
 		show_result(mknod(filename, S_IFIFO, 0), 1);
@@ -489,7 +490,7 @@
 		show_result(mknod(filename, S_IFIFO, 0), 0);
 	}
 
-	policy = "allow_mksock /tmp/mknod_sock_test";
+	policy = "allow_mksock /tmp/mknod_sock_test 0644";
 	if (write_policy()) {
 		filename = "/tmp/mknod_sock_test";
 		show_result(mknod(filename, S_IFSOCK, 0), 1);
@@ -498,7 +499,7 @@
 		show_result(mknod(filename, S_IFSOCK, 0), 0);
 	}
 
-	policy = "allow_mkdir /tmp/mkdir_test/";
+	policy = "allow_mkdir /tmp/mkdir_test/ 0600";
 	if (write_policy()) {
 		filename = "/tmp/mkdir_test";
 		show_result(mkdir(filename, 0600), 1);
@@ -601,7 +602,7 @@
 		unlink2(filename);
 	}
 
-	policy = "allow_mksock /tmp/socket_test";
+	policy = "allow_mksock /tmp/socket_test 0644";
 	if (write_policy()) {
 		struct sockaddr_un addr;
 		int fd;
@@ -659,9 +660,9 @@
 
 			show_result(truncate(filename, 0), 0);
 
-			fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+			fprintf(profile_fp, "255-MAC::file=disabled\n");
 			fd = open(filename, O_WRONLY | O_APPEND);
-			fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+			fprintf(profile_fp, "255-MAC::file=enforcing\n");
 			show_result(ftruncate(fd, 0), 0);
 
 			show_result(fcntl(fd, F_SETFL,
@@ -678,7 +679,7 @@
 	unlink2(filename);
 
 	{
-		fprintf(profile_fp, "255-MAC_FOR_IOCTL=enforcing\n");
+		fprintf(profile_fp, "255-MAC::file=enforcing\n");
 		policy = "allow_ioctl socket:[family=2:type=2:protocol=17] "
 			"35122-35124 if task.uid=0";
 		if (write_policy()) {
@@ -698,7 +699,7 @@
 			if (fd != EOF)
 				close(fd);
 		}
-		fprintf(profile_fp, "255-MAC_FOR_IOCTL=disabled\n");
+		fprintf(profile_fp, "255-MAC::file=disabled\n");
 	}
 }
 
Index: branches/ccs-tools/ccstools/kernel_test/ccs_network_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_network_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_network_test.c	(working copy)
@@ -97,10 +97,25 @@
 static void set_enforce(int flag)
 {
 	is_enforce = flag;
-	if (flag)
-		fprintf(profile_fp, "255-MAC_FOR_NETWORK=enforcing\n");
-	else
-		fprintf(profile_fp, "255-MAC_FOR_NETWORK=permissive\n");
+	if (flag) {
+		fprintf(profile_fp, "255-MAC::network::inet_udp_bind=enforcing\n");
+		fprintf(profile_fp, "255-MAC::network::inet_udp_connect=enforcing\n");
+		fprintf(profile_fp, "255-MAC::network::inet_tcp_bind=enforcing\n");
+		fprintf(profile_fp, "255-MAC::network::inet_tcp_listen=enforcing\n");
+		fprintf(profile_fp, "255-MAC::network::inet_tcp_connect=enforcing\n");
+		fprintf(profile_fp, "255-MAC::network::inet_tcp_accept=enforcing\n");
+		fprintf(profile_fp, "255-MAC::network::inet_raw_bind=enforcing\n");
+		fprintf(profile_fp, "255-MAC::network::inet_raw_connect=enforcing\n");
+	} else {
+		fprintf(profile_fp, "255-MAC::network::inet_udp_bind=permissive\n");
+		fprintf(profile_fp, "255-MAC::network::inet_udp_connect=permissive\n");
+		fprintf(profile_fp, "255-MAC::network::inet_tcp_bind=permissive\n");
+		fprintf(profile_fp, "255-MAC::network::inet_tcp_listen=permissive\n");
+		fprintf(profile_fp, "255-MAC::network::inet_tcp_connect=permissive\n");
+		fprintf(profile_fp, "255-MAC::network::inet_tcp_accept=permissive\n");
+		fprintf(profile_fp, "255-MAC::network::inet_raw_bind=permissive\n");
+		fprintf(profile_fp, "255-MAC::network::inet_raw_connect=permissive\n");
+	}
 }
 
 static void stage_network_test(void)
Index: branches/ccs-tools/ccstools/kernel_test/ccs_new_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_new_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_new_test.c	(working copy)
@@ -431,7 +431,7 @@
 {
 	setup_test_file();
 	write_domain_policy("allow_truncate /tmp/testfile\\$", 0);
-	set_profile(3, "truncate");
+	set_profile(3, "file::truncate");
 }
 
 static void setup_all_test_file(void)
@@ -450,7 +450,7 @@
 {
 	setup_all_test_file();
 	write_domain_policy("allow_truncate /tmp/testfile\\$", 0);
-	set_profile(3, "truncate");
+	set_profile(3, "file::truncate");
 }
 
 static void cleanup_test_file(void)
@@ -470,7 +470,7 @@
 {
 	cleanup_test_file();
 	write_domain_policy("allow_truncate /tmp/testfile\\$", 1);
-	set_profile(0, "truncate");
+	set_profile(0, "file::truncate");
 }
 
 static void test_inet_tcp_create(void)
@@ -885,110 +885,110 @@
 	const char *name;
 	const char *policy;
 } tests[] = {
-	{ NULL, test_read_etc_fstab, cleanup_file_open, "open", "allow_read /etc/fstab" },
-	{ NULL, test_read_etc_fstab, cleanup_file_open, "open", "allow_read /etc/fstab if task.uid=0" },
-	{ NULL, test_read_etc_fstab, cleanup_file_open, "open", "allow_read /etc/fstab if path1.uid=0 path1.parent.uid=0" },
-	{ setup_open_group, test_read_etc_fstab, cleanup_open_group, "open", "allow_read @READABLE if path1.uid=@READABLE_IDS path1.parent.uid=0" },
-	{ NULL, test_write_dev_null, cleanup_file_open, "open", "allow_write /dev/null" },
-	{ NULL, test_write_dev_null, cleanup_file_open, "open", "allow_write /dev/null if task.uid=0" },
-	{ NULL, test_write_dev_null, cleanup_file_open, "open", "allow_write /dev/null if path1.type=char path1.dev_major=1 path1.dev_minor=3 path1.perm=0666" },
-	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir, "mkdir", "allow_mkdir /tmp/testdir/ 0755" },
-	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir, "mkdir", "allow_mkdir /tmp/testdir/ 0755 if path1.parent.uid=0 path1.parent.perm=01777" },
-	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir, "mkdir", "allow_mkdir /tmp/testdir/ 0755 if task.uid=path1.parent.uid" },
-	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir, "rmdir", "allow_rmdir /tmp/testdir/" },
-	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir, "rmdir", "allow_rmdir /tmp/testdir/ if path1.parent.uid=0 path1.parent.perm=01777" },
-	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir, "rmdir", "allow_rmdir /tmp/testdir/ if task.uid=0-100 task.gid=0x0-0xFF path1.uid=0" },
-	{ setup_execute_bin_true, test_execute_bin_true, cleanup_execute_bin_true, "execute", "allow_execute /bin/true" },
-	{ setup_execute_bin_true, test_execute_bin_true, cleanup_execute_bin_true, "execute", "allow_execute /bin/true if exec.argc=1 exec.argv[0]=\"/bin/true\"" },
-	{ setup_execute_bin_true, test_execute_bin_true, cleanup_execute_bin_true, "execute", "allow_execute /bin/true if exec.envc=1 exec.envp[\"HOME\"]=\"/\" exec.envp[\"PATH\"]=NULL" },
-	{ NULL, test_chmod_dev_null, NULL, "chmod", "allow_chmod /dev/null 0666 if path1.perm=00-07777 path1.type=char" },
-	{ NULL, test_chown_dev_null, NULL, "chown", "allow_chown /dev/null 0 if task.gid=path1.gid path1.type!=block" },
-	{ NULL, test_chgrp_dev_null, NULL, "chgrp", "allow_chgrp /dev/null 0 if task.uid=path1.parent.uid" },
-	{ NULL, test_ioctl_dev_null, NULL, "ioctl", "allow_ioctl /dev/null 0x5451 if 0=0-1000" },
-	{ setup_chmod_group, test_chmod_dev_null, cleanup_chmod_group, "chmod", "allow_chmod @CHMOD_TARGET @CHMOD_MODES" },
-	{ setup_chown_group, test_chown_dev_null, cleanup_chown_group, "chown", "allow_chown @CHOWN_TARGET @CHOWN_IDS" },
-	{ setup_chown_group, test_chgrp_dev_null, cleanup_chown_group, "chgrp", "allow_chgrp @CHOWN_TARGET @CHOWN_IDS" },
-	{ setup_ioctl_group, test_ioctl_dev_null, cleanup_ioctl_group, "ioctl", "allow_ioctl @IOCTL_TARGET @IOCTL_NUMBERS" },
-	{ setup_test_file, test_file_open_0, cleanup_test_file, "open", "allow_read /tmp/testfile0 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_1, cleanup_test_file, "open", "allow_read /tmp/testfile1 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_1, cleanup_test_file, "create", "allow_create /tmp/testfile1 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_2, cleanup_test_file, "open", "allow_read /tmp/testfile2 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_2, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile2 if task.uid=path1.uid" },
-	{ setup_test_file_truncate, test_file_open_2, cleanup_test_file_truncate, "rewrite", "allow_rewrite /tmp/testfile2 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_3, cleanup_test_file, "open", "allow_read /tmp/testfile3 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_3, cleanup_test_file, "create", "allow_create /tmp/testfile3 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_4, cleanup_test_file, "open", "allow_read /tmp/testfile4 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_5, cleanup_test_file, "open", "allow_read /tmp/testfile5 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_5, cleanup_test_file, "create", "allow_create /tmp/testfile5 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_6, cleanup_test_file, "open", "allow_read /tmp/testfile6 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_6, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile6 if task.uid=path1.uid" },
-	{ setup_test_file_truncate, test_file_open_6, cleanup_test_file_truncate, "rewrite", "allow_rewrite /tmp/testfile6 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_7, cleanup_test_file, "open", "allow_read /tmp/testfile7 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_7, cleanup_test_file, "create", "allow_create /tmp/testfile7 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_8, cleanup_test_file, "open", "allow_write /tmp/testfile8 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_8, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile8 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_9, cleanup_test_file, "open", "allow_write /tmp/testfile9 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_9, cleanup_test_file, "create", "allow_create /tmp/testfile9 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_9, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile9 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_10, cleanup_test_file, "open", "allow_write /tmp/testfile10 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_10, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile10 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_10, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile10 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_11, cleanup_test_file, "open", "allow_write /tmp/testfile11 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_11, cleanup_test_file, "create", "allow_create /tmp/testfile11 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_11, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile11 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_12, cleanup_test_file, "open", "allow_write /tmp/testfile12 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_13, cleanup_test_file, "open", "allow_write /tmp/testfile13 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_13, cleanup_test_file, "create", "allow_create /tmp/testfile13 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_14, cleanup_test_file, "open", "allow_write /tmp/testfile14 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_14, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile14 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_14, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile14 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_15, cleanup_test_file, "open", "allow_write /tmp/testfile15 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_15, cleanup_test_file, "create", "allow_create /tmp/testfile15 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_16, cleanup_test_file, "open", "allow_read/write /tmp/testfile16 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_16, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile16 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_17, cleanup_test_file, "open", "allow_read/write /tmp/testfile17 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_17, cleanup_test_file, "create", "allow_create /tmp/testfile17 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_17, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile17 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_18, cleanup_test_file, "open", "allow_read/write /tmp/testfile18 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_18, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile18 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_18, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile18 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_19, cleanup_test_file, "open", "allow_read/write /tmp/testfile19 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_19, cleanup_test_file, "create", "allow_create /tmp/testfile19 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_19, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile19 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_20, cleanup_test_file, "open", "allow_read/write /tmp/testfile20 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_21, cleanup_test_file, "open", "allow_read/write /tmp/testfile21 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_21, cleanup_test_file, "create", "allow_create /tmp/testfile21 0600 if task.uid=path1.parent.uid" },
-	{ setup_test_file, test_file_open_22, cleanup_test_file, "open", "allow_read/write /tmp/testfile22 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_22, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile22 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_22, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile22 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_23, cleanup_test_file, "open", "allow_read/write /tmp/testfile23 if task.uid=path1.uid" },
-	{ setup_test_file, test_file_open_23, cleanup_test_file, "create", "allow_create /tmp/testfile23 0600 if task.uid=path1.parent.uid" },
-	{ setup_all_test_file, test_file_open_0, cleanup_test_file, "open", "allow_read /tmp/testfile0 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_2, cleanup_test_file, "open", "allow_read /tmp/testfile2 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_2, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile2 if task.uid=path1.gid" },
-	{ setup_all_test_file_truncate, test_file_open_2, cleanup_test_file_truncate, "rewrite", "allow_rewrite /tmp/testfile2 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_4, cleanup_test_file, "open", "allow_read /tmp/testfile4 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_6, cleanup_test_file, "open", "allow_read /tmp/testfile6 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_6, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile6 if task.uid=path1.gid" },
-	{ setup_all_test_file_truncate, test_file_open_6, cleanup_test_file_truncate, "rewrite", "allow_rewrite /tmp/testfile6 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_8, cleanup_test_file, "open", "allow_write /tmp/testfile8 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_8, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile8 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_10, cleanup_test_file, "open", "allow_write /tmp/testfile10 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_10, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile10 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_10, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile10 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_12, cleanup_test_file, "open", "allow_write /tmp/testfile12 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_14, cleanup_test_file, "open", "allow_write /tmp/testfile14 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_14, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile14 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_14, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile14 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_16, cleanup_test_file, "open", "allow_read/write /tmp/testfile16 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_16, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile16 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_18, cleanup_test_file, "open", "allow_read/write /tmp/testfile18 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_18, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile18 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_18, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile18 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_20, cleanup_test_file, "open", "allow_read/write /tmp/testfile20 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_22, cleanup_test_file, "open", "allow_read/write /tmp/testfile22 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_22, cleanup_test_file, "truncate", "allow_truncate /tmp/testfile22 if task.uid=path1.gid" },
-	{ setup_all_test_file, test_file_open_22, cleanup_test_file, "rewrite", "allow_rewrite /tmp/testfile22 if task.uid=path1.gid" },
+	{ NULL, test_read_etc_fstab, cleanup_file_open, "file::open", "allow_read /etc/fstab" },
+	{ NULL, test_read_etc_fstab, cleanup_file_open, "file::open", "allow_read /etc/fstab if task.uid=0" },
+	{ NULL, test_read_etc_fstab, cleanup_file_open, "file::open", "allow_read /etc/fstab if path1.uid=0 path1.parent.uid=0" },
+	{ setup_open_group, test_read_etc_fstab, cleanup_open_group, "file::open", "allow_read @READABLE if path1.uid=@READABLE_IDS path1.parent.uid=0" },
+	{ NULL, test_write_dev_null, cleanup_file_open, "file::open", "allow_write /dev/null" },
+	{ NULL, test_write_dev_null, cleanup_file_open, "file::open", "allow_write /dev/null if task.uid=0" },
+	{ NULL, test_write_dev_null, cleanup_file_open, "file::open", "allow_write /dev/null if path1.type=char path1.dev_major=1 path1.dev_minor=3 path1.perm=0666" },
+	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir, "file::mkdir", "allow_mkdir /tmp/testdir/ 0755" },
+	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir, "file::mkdir", "allow_mkdir /tmp/testdir/ 0755 if path1.parent.uid=0 path1.parent.perm=01777" },
+	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir, "file::mkdir", "allow_mkdir /tmp/testdir/ 0755 if task.uid=path1.parent.uid" },
+	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir, "file::rmdir", "allow_rmdir /tmp/testdir/" },
+	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir, "file::rmdir", "allow_rmdir /tmp/testdir/ if path1.parent.uid=0 path1.parent.perm=01777" },
+	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir, "file::rmdir", "allow_rmdir /tmp/testdir/ if task.uid=0-100 task.gid=0x0-0xFF path1.uid=0" },
+	{ setup_execute_bin_true, test_execute_bin_true, cleanup_execute_bin_true, "file::execute", "allow_execute /bin/true" },
+	{ setup_execute_bin_true, test_execute_bin_true, cleanup_execute_bin_true, "file::execute", "allow_execute /bin/true if exec.argc=1 exec.argv[0]=\"/bin/true\"" },
+	{ setup_execute_bin_true, test_execute_bin_true, cleanup_execute_bin_true, "file::execute", "allow_execute /bin/true if exec.envc=1 exec.envp[\"HOME\"]=\"/\" exec.envp[\"PATH\"]=NULL" },
+	{ NULL, test_chmod_dev_null, NULL, "file::chmod", "allow_chmod /dev/null 0666 if path1.perm=00-07777 path1.type=char" },
+	{ NULL, test_chown_dev_null, NULL, "file::chown", "allow_chown /dev/null 0 if task.gid=path1.gid path1.type!=block" },
+	{ NULL, test_chgrp_dev_null, NULL, "file::chgrp", "allow_chgrp /dev/null 0 if task.uid=path1.parent.uid" },
+	{ NULL, test_ioctl_dev_null, NULL, "file::ioctl", "allow_ioctl /dev/null 0x5451 if 0=0-1000" },
+	{ setup_chmod_group, test_chmod_dev_null, cleanup_chmod_group, "file::chmod", "allow_chmod @CHMOD_TARGET @CHMOD_MODES" },
+	{ setup_chown_group, test_chown_dev_null, cleanup_chown_group, "file::chown", "allow_chown @CHOWN_TARGET @CHOWN_IDS" },
+	{ setup_chown_group, test_chgrp_dev_null, cleanup_chown_group, "file::chgrp", "allow_chgrp @CHOWN_TARGET @CHOWN_IDS" },
+	{ setup_ioctl_group, test_ioctl_dev_null, cleanup_ioctl_group, "file::ioctl", "allow_ioctl @IOCTL_TARGET @IOCTL_NUMBERS" },
+	{ setup_test_file, test_file_open_0, cleanup_test_file, "file::open", "allow_read /tmp/testfile0 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_1, cleanup_test_file, "file::open", "allow_read /tmp/testfile1 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_1, cleanup_test_file, "file::create", "allow_create /tmp/testfile1 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_2, cleanup_test_file, "file::open", "allow_read /tmp/testfile2 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_2, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile2 if task.uid=path1.uid" },
+	{ setup_test_file_truncate, test_file_open_2, cleanup_test_file_truncate, "file::rewrite", "allow_rewrite /tmp/testfile2 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_3, cleanup_test_file, "file::open", "allow_read /tmp/testfile3 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_3, cleanup_test_file, "file::create", "allow_create /tmp/testfile3 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_4, cleanup_test_file, "file::open", "allow_read /tmp/testfile4 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_5, cleanup_test_file, "file::open", "allow_read /tmp/testfile5 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_5, cleanup_test_file, "file::create", "allow_create /tmp/testfile5 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_6, cleanup_test_file, "file::open", "allow_read /tmp/testfile6 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_6, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile6 if task.uid=path1.uid" },
+	{ setup_test_file_truncate, test_file_open_6, cleanup_test_file_truncate, "file::rewrite", "allow_rewrite /tmp/testfile6 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_7, cleanup_test_file, "file::open", "allow_read /tmp/testfile7 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_7, cleanup_test_file, "file::create", "allow_create /tmp/testfile7 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_8, cleanup_test_file, "file::open", "allow_write /tmp/testfile8 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_8, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile8 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_9, cleanup_test_file, "file::open", "allow_write /tmp/testfile9 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_9, cleanup_test_file, "file::create", "allow_create /tmp/testfile9 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_9, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile9 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_10, cleanup_test_file, "file::open", "allow_write /tmp/testfile10 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_10, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile10 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_10, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile10 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_11, cleanup_test_file, "file::open", "allow_write /tmp/testfile11 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_11, cleanup_test_file, "file::create", "allow_create /tmp/testfile11 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_11, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile11 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_12, cleanup_test_file, "file::open", "allow_write /tmp/testfile12 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_13, cleanup_test_file, "file::open", "allow_write /tmp/testfile13 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_13, cleanup_test_file, "file::create", "allow_create /tmp/testfile13 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_14, cleanup_test_file, "file::open", "allow_write /tmp/testfile14 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_14, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile14 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_14, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile14 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_15, cleanup_test_file, "file::open", "allow_write /tmp/testfile15 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_15, cleanup_test_file, "file::create", "allow_create /tmp/testfile15 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_16, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile16 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_16, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile16 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_17, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile17 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_17, cleanup_test_file, "file::create", "allow_create /tmp/testfile17 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_17, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile17 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_18, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile18 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_18, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile18 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_18, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile18 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_19, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile19 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_19, cleanup_test_file, "file::create", "allow_create /tmp/testfile19 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_19, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile19 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_20, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile20 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_21, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile21 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_21, cleanup_test_file, "file::create", "allow_create /tmp/testfile21 0600 if task.uid=path1.parent.uid" },
+	{ setup_test_file, test_file_open_22, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile22 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_22, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile22 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_22, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile22 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_23, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile23 if task.uid=path1.uid" },
+	{ setup_test_file, test_file_open_23, cleanup_test_file, "file::create", "allow_create /tmp/testfile23 0600 if task.uid=path1.parent.uid" },
+	{ setup_all_test_file, test_file_open_0, cleanup_test_file, "file::open", "allow_read /tmp/testfile0 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_2, cleanup_test_file, "file::open", "allow_read /tmp/testfile2 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_2, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile2 if task.uid=path1.gid" },
+	{ setup_all_test_file_truncate, test_file_open_2, cleanup_test_file_truncate, "file::rewrite", "allow_rewrite /tmp/testfile2 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_4, cleanup_test_file, "file::open", "allow_read /tmp/testfile4 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_6, cleanup_test_file, "file::open", "allow_read /tmp/testfile6 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_6, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile6 if task.uid=path1.gid" },
+	{ setup_all_test_file_truncate, test_file_open_6, cleanup_test_file_truncate, "file::rewrite", "allow_rewrite /tmp/testfile6 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_8, cleanup_test_file, "file::open", "allow_write /tmp/testfile8 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_8, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile8 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_10, cleanup_test_file, "file::open", "allow_write /tmp/testfile10 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_10, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile10 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_10, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile10 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_12, cleanup_test_file, "file::open", "allow_write /tmp/testfile12 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_14, cleanup_test_file, "file::open", "allow_write /tmp/testfile14 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_14, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile14 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_14, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile14 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_16, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile16 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_16, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile16 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_18, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile18 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_18, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile18 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_18, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile18 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_20, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile20 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_22, cleanup_test_file, "file::open", "allow_read/write /tmp/testfile22 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_22, cleanup_test_file, "file::truncate", "allow_truncate /tmp/testfile22 if task.uid=path1.gid" },
+	{ setup_all_test_file, test_file_open_22, cleanup_test_file, "file::rewrite", "allow_rewrite /tmp/testfile22 if task.uid=path1.gid" },
 	{ NULL, test_inet_tcp_create, NULL,    "capability::inet_tcp_create",    "allow_capability inet_tcp_create" },
 	{ NULL, test_inet_tcp_listen, NULL,    "capability::inet_tcp_listen",    "allow_capability inet_tcp_listen" },
 	{ NULL, test_inet_tcp_connect, NULL,   "capability::inet_tcp_connect",   "allow_capability inet_tcp_connect" },
@@ -1049,7 +1049,6 @@
 			}
 		}
 	}
-	return 0;
 	for (i = 0; tests[i].do_test; i++) {
 		int mode;
 		for (mode = 0; mode < 4; mode++) {
Index: branches/ccs-tools/ccstools/kernel_test/ccs_new_capability_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_new_capability_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_new_capability_test.c	(working copy)
@@ -87,14 +87,12 @@
 
 static void set_capability(void)
 {
-	fprintf(profile_fp, "255-MAC_FOR_CAPABILITY=enforcing\n");
-	fprintf(profile_fp, "255-SUPPORTED_CAPABILITIES=%s\n", capability);
+	fprintf(profile_fp, "255-MAC::capability::%s=enforcing\n", capability);
 }
 
 static void unset_capability(void)
 {
-	fprintf(profile_fp, "255-MAC_FOR_CAPABILITY=disabled\n");
-	fprintf(profile_fp, "255-SUPPORTED_CAPABILITIES=%s\n", capability);
+	fprintf(profile_fp, "255-MAC::capability::%s=disabled\n", capability);
 }
 
 static void stage_capability_test(void)
Index: branches/ccs-tools/ccstools/kernel_test/ccs_execute_handler_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_execute_handler_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_execute_handler_test.c	(working copy)
@@ -92,7 +92,7 @@
 	fprintf(domain_fp, "delete allow_execute /bin/echo\n");
 	fprintf(domain_fp, "%s %s\n", self_domain, cp);
 	fprintf(domain_fp, "use_profile 0\n");
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	if (fork() == 0) {
 		char *arg[3] = { "echo", "OK: denied execute handler succeeded",
 				 NULL };
@@ -106,7 +106,7 @@
 		printf("BUG: denied execute handler failed\n");
 		fflush(stdout);
 	}
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	fprintf(domain_fp, "delete denied_execute_handler %s\n", cp);
 	clear_status();
 	return 0;
Index: branches/ccs-tools/ccstools/kernel_test/ccs_accept_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_accept_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_accept_test.c	(working copy)
@@ -10,7 +10,7 @@
 
 static void set_level(const int i)
 {
-	fprintf(profile_fp, "255-MAC_FOR_FILE=%d\n", i);
+	fprintf(profile_fp, "255-MAC::file=%d\n", i);
 }
 
 static void test(int rw_loop, int truncate_loop, int append_loop,
@@ -65,7 +65,7 @@
 	for (i = 1; i < 8; i++)
 		fprintf(domain_fp, "delete %d %s\n", i, buffer);
 	fprintf(domain_fp, "delete allow_truncate %s\n", buffer);
-	fprintf(domain_fp, "delete allow_create %s\n", buffer);
+	fprintf(domain_fp, "delete allow_create %s 0666\n", buffer);
 	fprintf(domain_fp, "delete allow_rewrite %s\n", buffer);
 	fd = open(buffer, flags, 0666);
 	if (fd != EOF) {
@@ -77,8 +77,8 @@
 int main(int argc, char *argv[])
 {
 	ccs_test_init();
-	fprintf(profile_fp, "255-COMMENT=Test\n255-TOMOYO_VERBOSE=disabled\n"
-		"255-MAC_FOR_FILE=disabled\n255-MAX_ACCEPT_ENTRY=2048\n");
+	fprintf(profile_fp, "255-COMMENT=Test\n255-REPORT_VIOLATION=disabled\n"
+		"255-MAC::file=disabled\n255-MAX_ACCEPT_ENTRY=2048\n");
 	{
 		int append_loop;
 		for (append_loop = 0; append_loop < 2; append_loop++) {
@@ -97,7 +97,7 @@
 			}
 		}
 	}
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	printf("Done\n");
 	clear_status();
 	return 0;
Index: branches/ccs-tools/ccstools/kernel_test/ccs_bprm_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_bprm_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_bprm_test.c	(working copy)
@@ -16,9 +16,9 @@
 	int policy_found = 0;
 	int err = 0;
 	int pipe_fd[2] = { EOF, EOF };
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	fp = fopen(proc_policy_domain_policy, "r");
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	pipe(pipe_fd);
 	printf("%s: ", policy);
 	fflush(stdout);
@@ -167,9 +167,9 @@
 	fprintf(domain_fp, "use_profile 255\n");
 	fprintf(domain_fp, "select pid=%u\n", pid);
 	fprintf(domain_fp, "allow_read/write %s\n", proc_policy_domain_policy);
-	fprintf(profile_fp, "255-MAC_FOR_FILE=enforcing\n");
+	fprintf(profile_fp, "255-MAC::file=enforcing\n");
 	stage_exec_test();
-	fprintf(profile_fp, "255-MAC_FOR_FILE=disabled\n");
+	fprintf(profile_fp, "255-MAC::file=disabled\n");
 	clear_status();
 	return 0;
 }
Index: branches/ccs-tools/ccstools/kernel_test/include.h
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/include.h	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/include.h	(working copy)
@@ -111,32 +111,39 @@
 static void clear_status(void)
 {
 	static const char *keywords[] = {
-		"execute",
-		"open",
-		"create",
-		"unlink",
-		"mkdir",
-		"rmdir",
-		"mkfifo",
-		"mksock",
-		"truncate",
-		"symlink",
-		"rewrite",
-		"mkblock",
-		"mkchar",
-		"link",
-		"rename",
-		"chmod",
-		"chown",
-		"chgrp",
-		"ioctl",
-		"chroot",
-		"mount",
-		"umount",
-		"pivot_root",
-		"env",
-		"network",
-		"signal",
+		"file::execute",
+		"file::open",
+		"file::create",
+		"file::unlink",
+		"file::mkdir",
+		"file::rmdir",
+		"file::mkfifo",
+		"file::mksock",
+		"file::truncate",
+		"file::symlink",
+		"file::rewrite",
+		"file::mkblock",
+		"file::mkchar",
+		"file::link",
+		"file::rename",
+		"file::chmod",
+		"file::chown",
+		"file::chgrp",
+		"file::ioctl",
+		"file::chroot",
+		"file::mount",
+		"file::umount",
+		"file::pivot_root",
+		"misc::env",
+		"network::inet_udp_bind",
+		"network::inet_udp_connect",
+		"network::inet_tcp_bind",
+		"network::inet_tcp_listen",
+		"network::inet_tcp_connect",
+		"network::inet_tcp_accept",
+		"network::inet_raw_bind",
+		"network::inet_raw_connect",
+		"ipc::signal",
 		"capability::inet_tcp_create",
 		"capability::inet_tcp_listen",
 		"capability::inet_tcp_connect",
Index: branches/ccs-tools/ccstools/kernel_test/ccs_new_network_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_new_network_test.c	(revision 2932)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_new_network_test.c	(working copy)
@@ -187,7 +187,7 @@
 		int fd1 = socket(PF_INET, SOCK_STREAM, 0);
 		int fd2 = socket(PF_INET, SOCK_STREAM, 0);
 		struct sockaddr_in saddr;
-		fprintf(profile_fp, "255-TOMOYO_VERBOSE=enabled\n");
+		fprintf(profile_fp, "255-REPORT_VIOLATION=enabled\n");
 		memset(buffer, 0, sizeof(buffer));
 		policy = buffer;
 		memset(&saddr, 0, sizeof(saddr));
@@ -225,7 +225,7 @@
 			close(fd1);
 		if (fd2 != EOF)
 			close(fd2);
-		fprintf(profile_fp, "255-TOMOYO_VERBOSE=disabled\n");
+		fprintf(profile_fp, "255-REPORT_VIOLATION=disabled\n");
 	}
 
 	i = socket(PF_INET6, SOCK_STREAM, 0);
@@ -329,7 +329,7 @@
 		int fd1 = socket(PF_INET6, SOCK_STREAM, 0);
 		int fd2 = socket(PF_INET6, SOCK_STREAM, 0);
 		struct sockaddr_in6 saddr;
-		fprintf(profile_fp, "255-TOMOYO_VERBOSE=enabled\n");
+		fprintf(profile_fp, "255-REPORT_VIOLATION=enabled\n");
 		memset(buffer, 0, sizeof(buffer));
 		policy = buffer;
 		memset(&saddr, 0, sizeof(saddr));
@@ -368,7 +368,7 @@
 			close(fd1);
 		if (fd2 != EOF)
 			close(fd2);
-		fprintf(profile_fp, "255-TOMOYO_VERBOSE=disabled\n");
+		fprintf(profile_fp, "255-REPORT_VIOLATION=disabled\n");
 	}
 
 }
@@ -376,7 +376,14 @@
 int main(int argc, char *argv[])
 {
 	ccs_test_init();
-	fprintf(profile_fp, "255-MAC_FOR_NETWORK=enforcing\n");
+	fprintf(profile_fp, "255-MAC::network::inet_udp_bind=enforcing\n");
+	fprintf(profile_fp, "255-MAC::network::inet_udp_connect=enforcing\n");
+	fprintf(profile_fp, "255-MAC::network::inet_tcp_bind=enforcing\n");
+	fprintf(profile_fp, "255-MAC::network::inet_tcp_listen=enforcing\n");
+	fprintf(profile_fp, "255-MAC::network::inet_tcp_connect=enforcing\n");
+	fprintf(profile_fp, "255-MAC::network::inet_tcp_accept=enforcing\n");
+	fprintf(profile_fp, "255-MAC::network::inet_raw_bind=enforcing\n");
+	fprintf(profile_fp, "255-MAC::network::inet_raw_connect=enforcing\n");
 	fprintf(profile_fp, "255-MAX_REJECT_LOG=1024\n");
 	stage_network_test();
 	clear_status();
Index: branches/ccs-tools/ccstools/init_policy.c
===================================================================
--- branches/ccs-tools/ccstools/init_policy.c	(revision 2932)
+++ branches/ccs-tools/ccstools/init_policy.c	(working copy)
@@ -1530,64 +1530,7 @@
 		"0-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"0-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"0-COMMENT=-----Disabled Mode-----\n"
-		"0-MAC::capability::SYS_CHMOD=disabled\n"
-		"0-MAC::capability::SYS_CHOWN=disabled\n"
-		"0-MAC::capability::SYS_CHROOT=disabled\n"
-		"0-MAC::capability::SYS_IOCTL=disabled\n"
-		"0-MAC::capability::SYS_KEXEC_LOAD=disabled\n"
-		"0-MAC::capability::SYS_KILL=disabled\n"
-		"0-MAC::capability::SYS_LINK=disabled\n"
-		"0-MAC::capability::SYS_MOUNT=disabled\n"
-		"0-MAC::capability::SYS_NICE=disabled\n"
-		"0-MAC::capability::SYS_PIVOT_ROOT=disabled\n"
-		"0-MAC::capability::SYS_PTRACE=disabled\n"
-		"0-MAC::capability::SYS_REBOOT=disabled\n"
-		"0-MAC::capability::SYS_RENAME=disabled\n"
-		"0-MAC::capability::SYS_SETHOSTNAME=disabled\n"
-		"0-MAC::capability::SYS_SYMLINK=disabled\n"
-		"0-MAC::capability::SYS_TIME=disabled\n"
-		"0-MAC::capability::SYS_UMOUNT=disabled\n"
-		"0-MAC::capability::SYS_UNLINK=disabled\n"
-		"0-MAC::capability::SYS_VHANGUP=disabled\n"
-		"0-MAC::capability::conceal_mount=disabled\n"
-		"0-MAC::capability::create_block_dev=disabled\n"
-		"0-MAC::capability::create_char_dev=disabled\n"
-		"0-MAC::capability::create_fifo=disabled\n"
-		"0-MAC::capability::create_unix_socket=disabled\n"
-		"0-MAC::capability::inet_tcp_connect=disabled\n"
-		"0-MAC::capability::inet_tcp_create=disabled\n"
-		"0-MAC::capability::inet_tcp_listen=disabled\n"
-		"0-MAC::capability::use_inet_ip=disabled\n"
-		"0-MAC::capability::use_inet_udp=disabled\n"
-		"0-MAC::capability::use_kernel_module=disabled\n"
-		"0-MAC::capability::use_packet=disabled\n"
-		"0-MAC::capability::use_route=disabled\n"
-		"0-MAC::chgrp=disabled\n"
-		"0-MAC::chmod=disabled\n"
-		"0-MAC::chown=disabled\n"
-		"0-MAC::chroot=disabled\n"
-		"0-MAC::create=disabled\n"
-		"0-MAC::env=disabled\n"
-		"0-MAC::execute=disabled\n"
-		"0-MAC::ioctl=disabled\n"
-		"0-MAC::link=disabled\n"
-		"0-MAC::mkblock=disabled\n"
-		"0-MAC::mkchar=disabled\n"
-		"0-MAC::mkdir=disabled\n"
-		"0-MAC::mkfifo=disabled\n"
-		"0-MAC::mksock=disabled\n"
-		"0-MAC::mount=disabled\n"
-		"0-MAC::network=disabled\n"
-		"0-MAC::open=disabled\n"
-		"0-MAC::pivot_root=disabled\n"
-		"0-MAC::rename=disabled\n"
-		"0-MAC::rewrite=disabled\n"
-		"0-MAC::rmdir=disabled\n"
-		"0-MAC::signal=disabled\n"
-		"0-MAC::symlink=disabled\n"
-		"0-MAC::truncate=disabled\n"
-		"0-MAC::umount=disabled\n"
-		"0-MAC::unlink=disabled\n"
+		"0-MAC=disabled\n"
 		"0-MAX_ACCEPT_ENTRY=2048\n"
 		"0-MAX_GRANT_LOG=1024\n"
 		"0-MAX_REJECT_LOG=1024\n"
@@ -1596,64 +1539,7 @@
 		"1-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"1-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"1-COMMENT=-----Learning Mode-----\n"
-		"1-MAC::capability::SYS_CHMOD=learning\n"
-		"1-MAC::capability::SYS_CHOWN=learning\n"
-		"1-MAC::capability::SYS_CHROOT=learning\n"
-		"1-MAC::capability::SYS_IOCTL=learning\n"
-		"1-MAC::capability::SYS_KEXEC_LOAD=learning\n"
-		"1-MAC::capability::SYS_KILL=learning\n"
-		"1-MAC::capability::SYS_LINK=learning\n"
-		"1-MAC::capability::SYS_MOUNT=learning\n"
-		"1-MAC::capability::SYS_NICE=learning\n"
-		"1-MAC::capability::SYS_PIVOT_ROOT=learning\n"
-		"1-MAC::capability::SYS_PTRACE=learning\n"
-		"1-MAC::capability::SYS_REBOOT=learning\n"
-		"1-MAC::capability::SYS_RENAME=learning\n"
-		"1-MAC::capability::SYS_SETHOSTNAME=learning\n"
-		"1-MAC::capability::SYS_SYMLINK=learning\n"
-		"1-MAC::capability::SYS_TIME=learning\n"
-		"1-MAC::capability::SYS_UMOUNT=learning\n"
-		"1-MAC::capability::SYS_UNLINK=learning\n"
-		"1-MAC::capability::SYS_VHANGUP=learning\n"
-		"1-MAC::capability::conceal_mount=learning\n"
-		"1-MAC::capability::create_block_dev=learning\n"
-		"1-MAC::capability::create_char_dev=learning\n"
-		"1-MAC::capability::create_fifo=learning\n"
-		"1-MAC::capability::create_unix_socket=learning\n"
-		"1-MAC::capability::inet_tcp_connect=learning\n"
-		"1-MAC::capability::inet_tcp_create=learning\n"
-		"1-MAC::capability::inet_tcp_listen=learning\n"
-		"1-MAC::capability::use_inet_ip=learning\n"
-		"1-MAC::capability::use_inet_udp=learning\n"
-		"1-MAC::capability::use_kernel_module=learning\n"
-		"1-MAC::capability::use_packet=learning\n"
-		"1-MAC::capability::use_route=learning\n"
-		"1-MAC::chgrp=learning\n"
-		"1-MAC::chmod=learning\n"
-		"1-MAC::chown=learning\n"
-		"1-MAC::chroot=learning\n"
-		"1-MAC::create=learning\n"
-		"1-MAC::env=learning\n"
-		"1-MAC::execute=learning\n"
-		"1-MAC::ioctl=learning\n"
-		"1-MAC::link=learning\n"
-		"1-MAC::mkblock=learning\n"
-		"1-MAC::mkchar=learning\n"
-		"1-MAC::mkdir=learning\n"
-		"1-MAC::mkfifo=learning\n"
-		"1-MAC::mksock=learning\n"
-		"1-MAC::mount=learning\n"
-		"1-MAC::network=learning\n"
-		"1-MAC::open=learning\n"
-		"1-MAC::pivot_root=learning\n"
-		"1-MAC::rename=learning\n"
-		"1-MAC::rewrite=learning\n"
-		"1-MAC::rmdir=learning\n"
-		"1-MAC::signal=learning\n"
-		"1-MAC::symlink=learning\n"
-		"1-MAC::truncate=learning\n"
-		"1-MAC::umount=learning\n"
-		"1-MAC::unlink=learning\n"
+		"1-MAC=learning\n"
 		"1-MAX_ACCEPT_ENTRY=2048\n"
 		"1-MAX_GRANT_LOG=1024\n"
 		"1-MAX_REJECT_LOG=1024\n"
@@ -1662,64 +1548,7 @@
 		"2-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"2-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"2-COMMENT=-----Permissive Mode-----\n"
-		"2-MAC::capability::SYS_CHMOD=permissive\n"
-		"2-MAC::capability::SYS_CHOWN=permissive\n"
-		"2-MAC::capability::SYS_CHROOT=permissive\n"
-		"2-MAC::capability::SYS_IOCTL=permissive\n"
-		"2-MAC::capability::SYS_KEXEC_LOAD=permissive\n"
-		"2-MAC::capability::SYS_KILL=permissive\n"
-		"2-MAC::capability::SYS_LINK=permissive\n"
-		"2-MAC::capability::SYS_MOUNT=permissive\n"
-		"2-MAC::capability::SYS_NICE=permissive\n"
-		"2-MAC::capability::SYS_PIVOT_ROOT=permissive\n"
-		"2-MAC::capability::SYS_PTRACE=permissive\n"
-		"2-MAC::capability::SYS_REBOOT=permissive\n"
-		"2-MAC::capability::SYS_RENAME=permissive\n"
-		"2-MAC::capability::SYS_SETHOSTNAME=permissive\n"
-		"2-MAC::capability::SYS_SYMLINK=permissive\n"
-		"2-MAC::capability::SYS_TIME=permissive\n"
-		"2-MAC::capability::SYS_UMOUNT=permissive\n"
-		"2-MAC::capability::SYS_UNLINK=permissive\n"
-		"2-MAC::capability::SYS_VHANGUP=permissive\n"
-		"2-MAC::capability::conceal_mount=permissive\n"
-		"2-MAC::capability::create_block_dev=permissive\n"
-		"2-MAC::capability::create_char_dev=permissive\n"
-		"2-MAC::capability::create_fifo=permissive\n"
-		"2-MAC::capability::create_unix_socket=permissive\n"
-		"2-MAC::capability::inet_tcp_connect=permissive\n"
-		"2-MAC::capability::inet_tcp_create=permissive\n"
-		"2-MAC::capability::inet_tcp_listen=permissive\n"
-		"2-MAC::capability::use_inet_ip=permissive\n"
-		"2-MAC::capability::use_inet_udp=permissive\n"
-		"2-MAC::capability::use_kernel_module=permissive\n"
-		"2-MAC::capability::use_packet=permissive\n"
-		"2-MAC::capability::use_route=permissive\n"
-		"2-MAC::chgrp=permissive\n"
-		"2-MAC::chmod=permissive\n"
-		"2-MAC::chown=permissive\n"
-		"2-MAC::chroot=permissive\n"
-		"2-MAC::create=permissive\n"
-		"2-MAC::env=permissive\n"
-		"2-MAC::execute=permissive\n"
-		"2-MAC::ioctl=permissive\n"
-		"2-MAC::link=permissive\n"
-		"2-MAC::mkblock=permissive\n"
-		"2-MAC::mkchar=permissive\n"
-		"2-MAC::mkdir=permissive\n"
-		"2-MAC::mkfifo=permissive\n"
-		"2-MAC::mksock=permissive\n"
-		"2-MAC::mount=permissive\n"
-		"2-MAC::network=permissive\n"
-		"2-MAC::open=permissive\n"
-		"2-MAC::pivot_root=permissive\n"
-		"2-MAC::rename=permissive\n"
-		"2-MAC::rewrite=permissive\n"
-		"2-MAC::rmdir=permissive\n"
-		"2-MAC::signal=permissive\n"
-		"2-MAC::symlink=permissive\n"
-		"2-MAC::truncate=permissive\n"
-		"2-MAC::umount=permissive\n"
-		"2-MAC::unlink=permissive\n"
+		"2-MAC=permissive\n"
 		"2-MAX_ACCEPT_ENTRY=2048\n"
 		"2-MAX_GRANT_LOG=1024\n"
 		"2-MAX_REJECT_LOG=1024\n"
@@ -1728,64 +1557,7 @@
 		"3-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"3-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"3-COMMENT=-----Enforcing Mode-----\n"
-		"3-MAC::capability::SYS_CHMOD=enforcing\n"
-		"3-MAC::capability::SYS_CHOWN=enforcing\n"
-		"3-MAC::capability::SYS_CHROOT=enforcing\n"
-		"3-MAC::capability::SYS_IOCTL=enforcing\n"
-		"3-MAC::capability::SYS_KEXEC_LOAD=enforcing\n"
-		"3-MAC::capability::SYS_KILL=enforcing\n"
-		"3-MAC::capability::SYS_LINK=enforcing\n"
-		"3-MAC::capability::SYS_MOUNT=enforcing\n"
-		"3-MAC::capability::SYS_NICE=enforcing\n"
-		"3-MAC::capability::SYS_PIVOT_ROOT=enforcing\n"
-		"3-MAC::capability::SYS_PTRACE=enforcing\n"
-		"3-MAC::capability::SYS_REBOOT=enforcing\n"
-		"3-MAC::capability::SYS_RENAME=enforcing\n"
-		"3-MAC::capability::SYS_SETHOSTNAME=enforcing\n"
-		"3-MAC::capability::SYS_SYMLINK=enforcing\n"
-		"3-MAC::capability::SYS_TIME=enforcing\n"
-		"3-MAC::capability::SYS_UMOUNT=enforcing\n"
-		"3-MAC::capability::SYS_UNLINK=enforcing\n"
-		"3-MAC::capability::SYS_VHANGUP=enforcing\n"
-		"3-MAC::capability::conceal_mount=enforcing\n"
-		"3-MAC::capability::create_block_dev=enforcing\n"
-		"3-MAC::capability::create_char_dev=enforcing\n"
-		"3-MAC::capability::create_fifo=enforcing\n"
-		"3-MAC::capability::create_unix_socket=enforcing\n"
-		"3-MAC::capability::inet_tcp_connect=enforcing\n"
-		"3-MAC::capability::inet_tcp_create=enforcing\n"
-		"3-MAC::capability::inet_tcp_listen=enforcing\n"
-		"3-MAC::capability::use_inet_ip=enforcing\n"
-		"3-MAC::capability::use_inet_udp=enforcing\n"
-		"3-MAC::capability::use_kernel_module=enforcing\n"
-		"3-MAC::capability::use_packet=enforcing\n"
-		"3-MAC::capability::use_route=enforcing\n"
-		"3-MAC::chgrp=enforcing\n"
-		"3-MAC::chmod=enforcing\n"
-		"3-MAC::chown=enforcing\n"
-		"3-MAC::chroot=enforcing\n"
-		"3-MAC::create=enforcing\n"
-		"3-MAC::env=enforcing\n"
-		"3-MAC::execute=enforcing\n"
-		"3-MAC::ioctl=enforcing\n"
-		"3-MAC::link=enforcing\n"
-		"3-MAC::mkblock=enforcing\n"
-		"3-MAC::mkchar=enforcing\n"
-		"3-MAC::mkdir=enforcing\n"
-		"3-MAC::mkfifo=enforcing\n"
-		"3-MAC::mksock=enforcing\n"
-		"3-MAC::mount=enforcing\n"
-		"3-MAC::network=enforcing\n"
-		"3-MAC::open=enforcing\n"
-		"3-MAC::pivot_root=enforcing\n"
-		"3-MAC::rename=enforcing\n"
-		"3-MAC::rewrite=enforcing\n"
-		"3-MAC::rmdir=enforcing\n"
-		"3-MAC::signal=enforcing\n"
-		"3-MAC::symlink=enforcing\n"
-		"3-MAC::truncate=enforcing\n"
-		"3-MAC::umount=enforcing\n"
-		"3-MAC::unlink=enforcing\n"
+		"3-MAC=enforcing\n"
 		"3-MAX_ACCEPT_ENTRY=2048\n"
 		"3-MAX_GRANT_LOG=1024\n"
 		"3-MAX_REJECT_LOG=1024\n"
@@ -1796,30 +1568,7 @@
 		"0-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"0-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"0-COMMENT=-----Disabled Mode-----\n"
-		"0-MAC::chgrp=disabled\n"
-		"0-MAC::chmod=disabled\n"
-		"0-MAC::chown=disabled\n"
-		"0-MAC::chroot=disabled\n"
-		"0-MAC::create=disabled\n"
-		"0-MAC::execute=disabled\n"
-		"0-MAC::ioctl=disabled\n"
-		"0-MAC::link=disabled\n"
-		"0-MAC::mkblock=disabled\n"
-		"0-MAC::mkchar=disabled\n"
-		"0-MAC::mkdir=disabled\n"
-		"0-MAC::mkfifo=disabled\n"
-		"0-MAC::mksock=disabled\n"
-		"0-MAC::mount=disabled\n"
-		"0-MAC::network=disabled\n"
-		"0-MAC::open=disabled\n"
-		"0-MAC::pivot_root=disabled\n"
-		"0-MAC::rename=disabled\n"
-		"0-MAC::rewrite=disabled\n"
-		"0-MAC::rmdir=disabled\n"
-		"0-MAC::symlink=disabled\n"
-		"0-MAC::truncate=disabled\n"
-		"0-MAC::umount=disabled\n"
-		"0-MAC::unlink=disabled\n"
+		"0-MAC::file=disabled\n"
 		"0-MAX_ACCEPT_ENTRY=2048\n"
 		"0-MAX_GRANT_LOG=1024\n"
 		"0-MAX_REJECT_LOG=1024\n"
@@ -1828,30 +1577,7 @@
 		"1-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"1-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"1-COMMENT=-----Learning Mode-----\n"
-		"1-MAC::chgrp=learning\n"
-		"1-MAC::chmod=learning\n"
-		"1-MAC::chown=learning\n"
-		"1-MAC::chroot=learning\n"
-		"1-MAC::create=learning\n"
-		"1-MAC::execute=learning\n"
-		"1-MAC::ioctl=learning\n"
-		"1-MAC::link=learning\n"
-		"1-MAC::mkblock=learning\n"
-		"1-MAC::mkchar=learning\n"
-		"1-MAC::mkdir=learning\n"
-		"1-MAC::mkfifo=learning\n"
-		"1-MAC::mksock=learning\n"
-		"1-MAC::mount=learning\n"
-		"1-MAC::network=learning\n"
-		"1-MAC::open=learning\n"
-		"1-MAC::pivot_root=learning\n"
-		"1-MAC::rename=learning\n"
-		"1-MAC::rewrite=learning\n"
-		"1-MAC::rmdir=learning\n"
-		"1-MAC::symlink=learning\n"
-		"1-MAC::truncate=learning\n"
-		"1-MAC::umount=learning\n"
-		"1-MAC::unlink=learning\n"
+		"1-MAC::file=learning\n"
 		"1-MAX_ACCEPT_ENTRY=2048\n"
 		"1-MAX_GRANT_LOG=1024\n"
 		"1-MAX_REJECT_LOG=1024\n"
@@ -1860,30 +1586,7 @@
 		"2-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"2-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"2-COMMENT=-----Permissive Mode-----\n"
-		"2-MAC::chgrp=permissive\n"
-		"2-MAC::chmod=permissive\n"
-		"2-MAC::chown=permissive\n"
-		"2-MAC::chroot=permissive\n"
-		"2-MAC::create=permissive\n"
-		"2-MAC::execute=permissive\n"
-		"2-MAC::ioctl=permissive\n"
-		"2-MAC::link=permissive\n"
-		"2-MAC::mkblock=permissive\n"
-		"2-MAC::mkchar=permissive\n"
-		"2-MAC::mkdir=permissive\n"
-		"2-MAC::mkfifo=permissive\n"
-		"2-MAC::mksock=permissive\n"
-		"2-MAC::mount=permissive\n"
-		"2-MAC::network=permissive\n"
-		"2-MAC::open=permissive\n"
-		"2-MAC::pivot_root=permissive\n"
-		"2-MAC::rename=permissive\n"
-		"2-MAC::rewrite=permissive\n"
-		"2-MAC::rmdir=permissive\n"
-		"2-MAC::symlink=permissive\n"
-		"2-MAC::truncate=permissive\n"
-		"2-MAC::umount=permissive\n"
-		"2-MAC::unlink=permissive\n"
+		"2-MAC::file=permissive\n"
 		"2-MAX_ACCEPT_ENTRY=2048\n"
 		"2-MAX_GRANT_LOG=1024\n"
 		"2-MAX_REJECT_LOG=1024\n"
@@ -1892,30 +1595,7 @@
 		"3-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"3-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"3-COMMENT=-----Enforcing Mode-----\n"
-		"3-MAC::chgrp=enforcing\n"
-		"3-MAC::chmod=enforcing\n"
-		"3-MAC::chown=enforcing\n"
-		"3-MAC::chroot=enforcing\n"
-		"3-MAC::create=enforcing\n"
-		"3-MAC::execute=enforcing\n"
-		"3-MAC::ioctl=enforcing\n"
-		"3-MAC::link=enforcing\n"
-		"3-MAC::mkblock=enforcing\n"
-		"3-MAC::mkchar=enforcing\n"
-		"3-MAC::mkdir=enforcing\n"
-		"3-MAC::mkfifo=enforcing\n"
-		"3-MAC::mksock=enforcing\n"
-		"3-MAC::mount=enforcing\n"
-		"3-MAC::network=enforcing\n"
-		"3-MAC::open=enforcing\n"
-		"3-MAC::pivot_root=enforcing\n"
-		"3-MAC::rename=enforcing\n"
-		"3-MAC::rewrite=enforcing\n"
-		"3-MAC::rmdir=enforcing\n"
-		"3-MAC::symlink=enforcing\n"
-		"3-MAC::truncate=enforcing\n"
-		"3-MAC::umount=enforcing\n"
-		"3-MAC::unlink=enforcing\n"
+		"3-MAC::file=enforcing\n"
 		"3-MAX_ACCEPT_ENTRY=2048\n"
 		"3-MAX_GRANT_LOG=1024\n"
 		"3-MAX_REJECT_LOG=1024\n"
