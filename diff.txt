Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(revision 1889)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(working copy)
@@ -47,12 +47,20 @@
 #define SYSTEM_POLICY_FILE    "system_policy"
 #define EXCEPTION_POLICY_FILE "exception_policy"
 #define DOMAIN_POLICY_FILE    "domain_policy"
+#define PROFILE_POLICY_FILE   "profile"
+#define MANAGER_POLICY_FILE   "manager"
+#define QUERY_POLICY_FILE     "query"
+#define MEMINFO_POLICY_FILE   "meminfo"
 
 #define SCREEN_SYSTEM_LIST    0
 #define SCREEN_EXCEPTION_LIST 1
 #define SCREEN_DOMAIN_LIST    2
 #define SCREEN_ACL_LIST       3
-#define MAXSCREEN             4
+#define SCREEN_PROFILE_LIST   4
+#define SCREEN_MANAGER_LIST   5
+#define SCREEN_QUERY_LIST     6
+#define SCREEN_MEMORY_LIST    7
+#define MAXSCREEN             8
 
 #define POLICY_TYPE_UNKNOWN          0
 #define POLICY_TYPE_DOMAIN_POLICY    1
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(revision 1889)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(working copy)
@@ -1435,6 +1435,12 @@
 	}
 }
 
+static inline bool has_directive(const int screen)
+{
+	return screen == SCREEN_SYSTEM_LIST || screen == SCREEN_EXCEPTION_LIST
+		|| screen == SCREEN_ACL_LIST;
+}
+
 static u8 find_directive(const bool forward, char *line);
 static int generic_acl_compare(const void *a, const void *b);
 
@@ -1452,6 +1458,15 @@
 	return strcmp(a2, b2);
 }
 
+static int string_acl_compare(const void *a, const void *b)
+{
+	const struct generic_acl *a0 = (struct generic_acl *) a;
+	const struct generic_acl *b0 = (struct generic_acl *) b;
+	const char *a2 = a0->operand;
+	const char *b2 = b0->operand;
+	return strcmp(a2, b2);
+}
+
 static void read_generic_policy(void)
 {
 	FILE *fp = NULL;
@@ -1487,9 +1502,13 @@
 			if (!shared_buffer[0])
 				continue;
 		}
-		directive = find_directive(true, shared_buffer);
-		if (directive == DIRECTIVE_NONE)
-			continue;
+		if (has_directive(current_screen)) {
+			directive = find_directive(true, shared_buffer);
+			if (directive == DIRECTIVE_NONE)
+				continue;
+		} else {
+			directive = DIRECTIVE_NONE;
+		}
 		generic_acl_list = realloc(generic_acl_list,
 					   (generic_acl_list_count + 1) *
 					   sizeof(struct generic_acl));
@@ -1506,10 +1525,12 @@
 	if (current_screen == SCREEN_ACL_LIST)
 		qsort(generic_acl_list, generic_acl_list_count,
 		      sizeof(struct generic_acl), generic_acl_compare);
+	else if (has_directive(current_screen))
+		qsort(generic_acl_list, generic_acl_list_count,
+		      sizeof(struct generic_acl), generic_acl_compare0);
 	else
 		qsort(generic_acl_list, generic_acl_list_count,
-		      sizeof(struct generic_acl), generic_acl_compare0);
-
+		      sizeof(struct generic_acl), string_acl_compare);
 	fclose(fp);
 }
 
@@ -2194,6 +2215,20 @@
 	return strlen(cp1) + strlen(cp2) + 8 + list_indent;
 }
 
+static int show_literal_line(int i, int index)
+{
+	const char *cp1 = "";
+	const char *cp2 = generic_acl_list[index].operand;
+	int len = 0;
+	mvprintw(header_lines + i, 0, "%c%4d: %s ",
+		 generic_acl_list[index].selected ? '&' : ' ',
+		 index, eat(cp1));
+	while (len-- > 0)
+		printw("%s", eat(" "));
+	printw("%s", eat(cp2));
+	return strlen(cp1) + strlen(cp2) + 8;
+}
+
 static void show_list(void)
 {
 	const int offset = current_item_index[current_screen];
@@ -2221,7 +2256,7 @@
 			 i, i > 1 ? 's' : ' ');
 	} else {
 		i = list_item_count[current_screen];
-		mvprintw(0, 0, "<<< %s Editor >>>"
+		mvprintw(0, 0, "<<< %s >>>"
 			 "      %d entr%s    '?' for help", list_caption,
 			 i, i > 1 ? "ies" : "y");
 	}
@@ -2239,7 +2274,7 @@
 		editpolicy_attr_change(A_REVERSE, false); /* add color */
 		put();
 	}
-	if (current_screen != SCREEN_DOMAIN_LIST) {
+	if (has_directive(current_screen)) {
 		list_indent = 0;
 		for (i = 0; i < list_item_count[current_screen]; i++) {
 			const u8 directive = generic_acl_list[i].directive;
@@ -2255,8 +2290,10 @@
 			break;
 		if (current_screen == SCREEN_DOMAIN_LIST)
 			tmp_col = show_domain_line(i, index);
+		else if (has_directive(current_screen))
+			tmp_col = show_acl_line(i, index, list_indent);
 		else
-			tmp_col = show_acl_line(i, index, list_indent);
+			tmp_col = show_literal_line(i, index);
 		clrtoeol();
 		tmp_col -= window_width;
 		if (tmp_col > max_col)
@@ -2358,8 +2395,8 @@
 
 /* add color start */
 #ifdef COLOR_ON
-static int before_current[MAXSCREEN] = { -1, -1, -1, -1 };
-static int before_y[MAXSCREEN]       = { -1, -1, -1, -1 };
+static int before_current[MAXSCREEN] = { -1, -1, -1, -1, -1, -1, -1, -1 };
+static int before_y[MAXSCREEN]       = { -1, -1, -1, -1, -1, -1, -1, -1 };
 
 static void editpolicy_line_draw(void)
 {
@@ -2949,9 +2986,12 @@
 			goto out;
 		if (current_screen == SCREEN_ACL_LIST)
 			fprintf(fp, "select %s\n", current_domain);
-		directive = find_directive(false, line);
-		if (directive != DIRECTIVE_NONE)
-			fprintf(fp, "%s ", directives[directive].original);
+		if (has_directive(current_screen)) {
+			directive = find_directive(false, line);
+			if (directive != DIRECTIVE_NONE)
+				fprintf(fp, "%s ",
+					directives[directive].original);
+		}
 		fprintf(fp, "%s\n", line);
 		fclose(fp);
 	}
@@ -3044,6 +3084,58 @@
 	free(line);
 }
 
+static int select_window(const int current)
+{
+	mvprintw(0, 0, "Press one of below keys to switch window.\n\n");
+	printw("s     <<< System Policy Editor >>>\n");
+	printw("e     <<< Exception Policy Editor >>>\n");
+	printw("d     <<< Domain Transition Editor >>>\n");
+	if (current_screen == SCREEN_DOMAIN_LIST &&
+	    !is_initializer_source(current) &&
+	    !is_deleted_domain(current))
+		printw("a     <<< Domain Policy Editor >>>\n");
+	printw("p     <<< Profile Editor >>>\n");
+	printw("m     <<< Manager Policy Editor >>>\n");
+	if (!offline_mode) {
+		printw("i     <<< Interactive Enforcing Mode >>>\n");
+		printw("q     <<< Memory Quota Editor >>>\n");
+	}
+	clrtobot();
+	refresh();
+	while (true) {
+		int c = getch2();
+		if (c == 'S' || c == 's')
+			return SCREEN_SYSTEM_LIST;
+		if (c == 'E' || c == 'e')
+			return SCREEN_EXCEPTION_LIST;
+		if (c == 'D' || c == 'd')
+			return SCREEN_DOMAIN_LIST;
+		if (c == 'A' || c == 'a') {
+			if (current_screen == SCREEN_DOMAIN_LIST &&
+			    !is_initializer_source(current) &&
+			    !is_deleted_domain(current)) {
+				free(current_domain);
+				current_domain = strdup(domain_name(current));
+				if (!current_domain)
+					out_of_memory();
+				return SCREEN_ACL_LIST;
+			}
+		}
+		if (c == 'P' || c == 'p')
+			return SCREEN_PROFILE_LIST;
+		if (c == 'M' || c == 'm')
+			return SCREEN_MANAGER_LIST;
+		if (!offline_mode) {
+			if (c == 'I' || c == 'i')
+				return SCREEN_QUERY_LIST;
+			if (c == 'Q' || c == 'q')
+				return SCREEN_MEMORY_LIST;
+		}
+		if (c == EOF)
+			return MAXSCREEN;
+	}
+}
+
 static void show_command_key(void)
 {
 	int c;
@@ -3054,6 +3146,7 @@
 	       "F/f        Find first.\n"
 	       "N/n        Find next.\n"
 	       "P/p        Find previous.\n"
+	       "W/w        Switch to selected screen.\n"
 	       "Tab        Switch to next screen.\n"
 	       "Insert     Copy an entry at the cursor position to history "
 	       "buffer.\n"
@@ -3105,16 +3198,28 @@
 	}
 	if (current_screen == SCREEN_SYSTEM_LIST) {
 		policy_file = SYSTEM_POLICY_FILE;
-		list_caption = "System Policy";
+		list_caption = "System Policy Editor";
 	} else if (current_screen == SCREEN_EXCEPTION_LIST) {
 		policy_file = EXCEPTION_POLICY_FILE;
-		list_caption = "Exception Policy";
+		list_caption = "Exception Policy Editor";
 	} else if (current_screen == SCREEN_ACL_LIST) {
 		policy_file = DOMAIN_POLICY_FILE;
-		list_caption = "Domain Policy";
+		list_caption = "Domain Policy Editor";
+	} else if (current_screen == SCREEN_QUERY_LIST) {
+		policy_file = QUERY_POLICY_FILE;
+		list_caption = "Interactive Enforcing Mode";
+	} else if (current_screen == SCREEN_PROFILE_LIST) {
+		policy_file = PROFILE_POLICY_FILE;
+		list_caption = "Profile Editor";
+	} else if (current_screen == SCREEN_MANAGER_LIST) {
+		policy_file = MANAGER_POLICY_FILE;
+		list_caption = "Manager Policy Editor";
+	} else if (current_screen == SCREEN_MEMORY_LIST) {
+		policy_file = MEMINFO_POLICY_FILE;
+		list_caption = "Memory Quota Editor";
 	} else {
 		policy_file = DOMAIN_POLICY_FILE;
-		/* list_caption = "Domain Transition"; */
+		/* list_caption = "Domain Transition Editor"; */
 	}
 	current_item_index[current_screen]
 		= saved_current_item_index[current_screen];
@@ -3315,6 +3420,9 @@
 				break;
 			sort_type = (sort_type + 1) % 2;
 			goto start;
+		case 'w':
+		case 'W':
+			return select_window(current);
 		case '?':
 			show_command_key();
 			goto start;
@@ -3379,10 +3487,10 @@
 	}
 }
 
-static void handle_exception_policy(FILE *fp, bool is_write)
+static void handle_misc_policy(FILE *fp, bool is_write, const int index)
 {
-	static const struct path_info **exception_list = NULL;
-	static int exception_list_count = 0;
+	static const struct path_info **list[4] = { NULL, NULL, NULL, NULL };
+	static int list_count[4] = { 0, 0, 0, 0 };
 	int i;
 	if (!is_write)
 		goto read_policy;
@@ -3395,74 +3503,30 @@
 			goto append_policy;
 		path.name = shared_buffer;
 		fill_path_info(&path);
-		for (i = 0; i < exception_list_count; i++) {
-			if (pathcmp(exception_list[i], &path))
+		for (i = 0; i < list_count[index]; i++) {
+			if (pathcmp(list[index][i], &path))
 				continue;
-			for (exception_list_count--;
-			     i < exception_list_count; i++)
-				exception_list[i]
-					= exception_list[i + 1];
+			for (list_count[index]--; i < list_count[index]; i++)
+				list[index][i] = list[index][i + 1];
 			break;
 		}
 		continue;
 append_policy:
-		exception_list = realloc(exception_list,
-					 (exception_list_count + 1)
-					 * sizeof(const struct path_info *));
-		if (!exception_list)
+		list[index] = realloc(list[index], (list_count[index] + 1)
+				      * sizeof(const struct path_info *));
+		if (!list[index])
 			out_of_memory();
 		cp = savename(shared_buffer);
 		if (!cp)
 			out_of_memory();
-		exception_list[exception_list_count++] = cp;
+		list[index][list_count[index]++] = cp;
 	}
 	return;
 read_policy:
-	for (i = 0; i < exception_list_count; i++)
-		fprintf(fp, "%s\n", exception_list[i]->name);
+	for (i = 0; i < list_count[index]; i++)
+		fprintf(fp, "%s\n", list[index][i]->name);
 }
 
-static void handle_system_policy(FILE *fp, bool is_write)
-{
-	static const struct path_info **system_list = NULL;
-	static int system_list_count = 0;
-	int i;
-	if (!is_write)
-		goto read_policy;
-	while (freadline(fp)) {
-		struct path_info path;
-		const struct path_info *cp;
-		if (!shared_buffer[0])
-			continue;
-		if (!str_starts(shared_buffer, "delete "))
-			goto append_policy;
-		path.name = shared_buffer;
-		fill_path_info(&path);
-		for (i = 0; i < system_list_count; i++) {
-			if (pathcmp(system_list[i], &path))
-				continue;
-			for (system_list_count--;
-			     i < system_list_count; i++)
-				system_list[i] = system_list[i + 1];
-			break;
-		}
-		continue;
-append_policy:
-		system_list = realloc(system_list, (system_list_count + 1)
-				      * sizeof(struct path_info *));
-		if (!system_list)
-			out_of_memory();
-		cp = savename(shared_buffer);
-		if (!cp)
-			out_of_memory();
-		system_list[system_list_count++] = cp;
-	}
-	return;
-read_policy:
-	for (i = 0; i < system_list_count; i++)
-		fprintf(fp, "%s\n", system_list[i]->name);
-}
-
 static void policy_daemon(void)
 {
 	get();
@@ -3501,16 +3565,24 @@
 			if (!strcmp(shared_buffer, "domain_policy"))
 				handle_domain_policy(fp, true);
 			else if (!strcmp(shared_buffer, "exception_policy"))
-				handle_exception_policy(fp, true);
+				handle_misc_policy(fp, true, 0);
 			else if (!strcmp(shared_buffer, "system_policy"))
-				handle_system_policy(fp, true);
+				handle_misc_policy(fp, true, 1);
+			else if (!strcmp(shared_buffer, "profile"))
+				handle_misc_policy(fp, true, 2);
+			else if (!strcmp(shared_buffer, "manager"))
+				handle_misc_policy(fp, true, 3);
 		} else if (str_starts(shared_buffer, "GET ")) {
 			if (!strcmp(shared_buffer, "domain_policy"))
 				handle_domain_policy(fp, false);
 			else if (!strcmp(shared_buffer, "exception_policy"))
-				handle_exception_policy(fp, false);
+				handle_misc_policy(fp, false, 0);
 			else if (!strcmp(shared_buffer, "system_policy"))
-				handle_system_policy(fp, false);
+				handle_misc_policy(fp, false, 1);
+			else if (!strcmp(shared_buffer, "profile"))
+				handle_misc_policy(fp, false, 2);
+			else if (!strcmp(shared_buffer, "manager"))
+				handle_misc_policy(fp, false, 3);
 		}
 		fclose(fp);
 	}
@@ -3544,8 +3616,12 @@
 			current_screen = SCREEN_EXCEPTION_LIST;
 		else if (!strcmp(argv[1], "d"))
 			current_screen = SCREEN_DOMAIN_LIST;
+		else if (!strcmp(argv[1], "p"))
+			current_screen = SCREEN_PROFILE_LIST;
+		else if (!strcmp(argv[1], "m"))
+			current_screen = SCREEN_MANAGER_LIST;
 		else {
-			printf("Usage: %s [s|e|d]\n", argv[0]);
+			printf("Usage: %s [s|e|d|p|m]\n", argv[0]);
 			return 1;
 		}
 	}
@@ -3625,6 +3701,34 @@
 				fclose(fp);
 				close(fd);
 			}
+			fd = open(base_policy_profile, O_RDONLY);
+			if (fd != EOF) {
+				FILE *fp = open_write(PROFILE_POLICY_FILE);
+				copy_fd_to_fp(fd, fp);
+				fclose(fp);
+				close(fd);
+			}
+			fd = open(disk_policy_profile, O_RDONLY);
+			if (fd != EOF) {
+				FILE *fp = open_write(PROFILE_POLICY_FILE);
+				copy_fd_to_fp(fd, fp);
+				fclose(fp);
+				close(fd);
+			}
+			fd = open(base_policy_manager, O_RDONLY);
+			if (fd != EOF) {
+				FILE *fp = open_write(MANAGER_POLICY_FILE);
+				copy_fd_to_fp(fd, fp);
+				fclose(fp);
+				close(fd);
+			}
+			fd = open(disk_policy_manager, O_RDONLY);
+			if (fd != EOF) {
+				FILE *fp = open_write(MANAGER_POLICY_FILE);
+				copy_fd_to_fp(fd, fp);
+				fclose(fp);
+				close(fd);
+			}
 		}
 	} else {
 		if (chdir(proc_policy_dir)) {
@@ -3716,6 +3820,26 @@
 				symlink(filename, "domain_policy.conf");
 			}
 		}
+		filename = make_filename("profile", now);
+		if (move_proc_to_file(NULL, open_read(PROFILE_POLICY_FILE),
+				      base_policy_profile, filename)) {
+			if (is_identical_file("profile.conf", filename)) {
+				unlink(filename);
+			} else {
+				unlink("profile.conf");
+				symlink(filename, "profile.conf");
+			}
+		}
+		filename = make_filename("manager", now);
+		if (move_proc_to_file(NULL, open_read(MANAGER_POLICY_FILE),
+				      base_policy_manager, filename)) {
+			if (is_identical_file("manager.conf", filename)) {
+				unlink(filename);
+			} else {
+				unlink("manager.conf");
+				symlink(filename, "manager.conf");
+			}
+		}
 	}
 	return 0;
 }
