Index: branches/ccs-patch/security/ccsecurity/chroot.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/chroot.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/chroot.c	(working copy)
@@ -56,12 +56,11 @@
 	char *root_name;
 	bool is_enforce;
 	struct ccs_obj_info obj = {
-		.path1_dentry = path->dentry,
-		.path1_vfsmnt = path->mnt
+		.path1 = *path
 	};
 	ccs_check_read_lock();
 	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_NAMESPACE))
+	    !ccs_init_request_info(&r, NULL, CCS_MAC_CHROOT))
 		return 0;
 	is_enforce = (r.mode == 3);
 	r.obj = &obj;
Index: branches/ccs-patch/security/ccsecurity/realpath.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/realpath.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/realpath.c	(working copy)
@@ -311,24 +311,6 @@
 }
 
 /**
- * ccs_realpath - Get realpath of a pathname.
- *
- * @pathname: The pathname to solve.
- *
- * Returns the realpath of @pathname on success, NULL otherwise.
- */
-char *ccs_realpath(const char *pathname)
-{
-	struct path path;
-	if (ccs_kern_path(pathname, ccs_lookup_flags, &path) == 0) {
-		char *buf = ccs_realpath_from_path(&path);
-		path_put(&path);
-		return buf;
-	}
-	return NULL;
-}
-
-/**
  * ccs_symlink_path - Get symlink's pathname.
  *
  * @pathname: The pathname to solve.
Index: branches/ccs-patch/security/ccsecurity/mount.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/mount.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/mount.c	(working copy)
@@ -154,8 +154,7 @@
 		error = -ENOENT;
 		goto out;
 	}
-	obj.path2_dentry = path.dentry;
-	obj.path2_vfsmnt = path.mnt;
+	obj.path2 = path;
 	requested_dir_name = ccs_realpath_from_path(&path);
 	if (!requested_dir_name) {
 		error = -ENOMEM;
@@ -191,8 +190,7 @@
 			error = -ENOENT;
 			goto out;
 		}
-		obj.path1_dentry = path.dentry;
-		obj.path1_vfsmnt = path.mnt;
+		obj.path1 = path;
 		requested_dev_name = ccs_realpath_from_path(&path);
 		if (!requested_dev_name) {
 			error = -ENOENT;
@@ -242,16 +240,10 @@
 		put_filesystem(fstype);
 	kfree(requested_type);
 	/* Drop refcount obtained by ccs_get_path(). */
-	if (obj.path2_dentry) {
-		path.dentry = obj.path2_dentry;
-		path.mnt = obj.path2_vfsmnt;
-		path_put(&path);
-	}
-	if (obj.path1_dentry) {
-		path.dentry = obj.path1_dentry;
-		path.mnt = obj.path1_vfsmnt;
-		path_put(&path);
-	}
+	if (obj.path2.dentry)
+		path_put(&obj.path2);
+	if (obj.path1.dentry)
+		path_put(&obj.path1);
 	return error;
 }
 
@@ -365,7 +357,7 @@
 	if (!ccs_capable(CCS_SYS_MOUNT))
 		return -EPERM;
 	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_NAMESPACE))
+	    !ccs_init_request_info(&r, NULL, CCS_MAC_MOUNT))
 		return 0;
 	if (!type)
 		type = "<NULL>";
Index: branches/ccs-patch/security/ccsecurity/pivot_root.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/pivot_root.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/pivot_root.c	(working copy)
@@ -55,10 +55,8 @@
 {
 	struct ccs_request_info r;
 	struct ccs_obj_info obj = {
-		.path1_dentry = new->dentry,
-		.path1_vfsmnt = new->mnt,
-		.path2_dentry = old->dentry,
-		.path2_vfsmnt = old->mnt
+		.path1 = *new,
+		.path2 = *old
 	};
 	int error;
 	char *old_root;
@@ -68,7 +66,7 @@
 	bool is_enforce;
 	ccs_check_read_lock();
 	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_NAMESPACE))
+	    !ccs_init_request_info(&r, NULL, CCS_MAC_PIVOT_ROOT))
 		return 0;
 	is_enforce = (r.mode == 3);
 	r.obj = &obj;
Index: branches/ccs-patch/security/ccsecurity/domain.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/domain.c	(revision 2907)
+++ branches/ccs-patch/security/ccsecurity/domain.c	(working copy)
@@ -64,7 +64,7 @@
 {
 	struct ccs_request_info *r = &ee->r;
 	const char *handler = ee->handler->name;
-	r->mode = ccs_check_flags(r->domain, CCS_MAC_FOR_FILE);
+	r->mode = ccs_check_flags(r->domain, CCS_MAC_EXECUTE);
 	return ccs_write_audit_log(true, r, "%s %s\n",
 				   is_default ? CCS_KEYWORD_EXECUTE_HANDLER :
 				   CCS_KEYWORD_DENIED_EXECUTE_HANDLER, handler);
@@ -81,7 +81,7 @@
 {
 	int error;
 	struct ccs_request_info r;
-	ccs_init_request_info(&r, domain, CCS_MAC_FOR_FILE);
+	ccs_init_request_info(&r, domain, CCS_MAC_EXECUTE);
 	error = ccs_write_audit_log(false, &r, "use_profile %u\n", r.profile);
 	return error;
 }
@@ -1299,12 +1299,12 @@
 		ccs_load_policy(bprm->filename);
 	if (!ee)
 		return -ENOMEM;
-	ccs_init_request_info(&ee->r, NULL, CCS_MAC_FOR_FILE);
+	ccs_init_request_info(&ee->r, NULL, CCS_MAC_EXECUTE);
 	ee->r.ee = ee;
 	ee->bprm = bprm;
 	ee->r.obj = &ee->obj;
-	ee->obj.path1_dentry = bprm->file->f_dentry;
-	ee->obj.path1_vfsmnt = bprm->file->f_vfsmnt;
+	ee->obj.path1.dentry = bprm->file->f_dentry;
+	ee->obj.path1.mnt = bprm->file->f_vfsmnt;
 	/* Clear manager flag. */
 	task->ccs_flags &= ~CCS_TASK_IS_POLICY_MANAGER;
 	if (ccs_find_execute_handler(ee, CCS_TYPE_EXECUTE_HANDLER)) {
@@ -1324,7 +1324,7 @@
  ok:
 	if (retval < 0)
 		goto out;
-	ee->r.mode = ccs_check_flags(ee->r.domain, CCS_MAC_FOR_ENV);
+	ee->r.mode = ccs_check_flags(ee->r.domain, CCS_MAC_ENVIRON);
 	retval = ccs_check_environ(ee);
 	if (retval < 0)
 		goto out;
Index: branches/ccs-patch/security/ccsecurity/maymount.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/maymount.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/maymount.c	(working copy)
@@ -91,9 +91,8 @@
 	struct mnt_namespace *namespace = current->nsproxy->mnt_ns;
 #endif
 	if (!namespace || !ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_CAPABILITY) ||
-	    !ccs_profile_ptr[r.profile]->
-	    enabled_capabilities[CCS_CONCEAL_MOUNT])
+	    !ccs_init_request_info(&r, NULL,
+				   CCS_MAX_MAC_INDEX + CCS_CONCEAL_MOUNT))
 		return 0;
 	found = false;
 	list_for_each(p, &namespace->list) {
Index: branches/ccs-patch/security/ccsecurity/util.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/util.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/util.c	(working copy)
@@ -936,8 +936,13 @@
 		domain = ccs_current_domain();
 	r->domain = domain;
 	r->profile = domain->profile;
-	if (index < CCS_MAX_CONTROL_INDEX)
-		r->mode = ccs_check_flags(domain, index);
+	if (!ccs_policy_loaded || !ccs_profile_ptr[r->profile])
+		r->mode = 0;
+	else if (index < CCS_MAX_MAC_INDEX)
+		r->mode = ccs_profile_ptr[r->profile]->mac_mode[index];
+	else
+		r->mode = ccs_profile_ptr[r->profile]->
+			mac_capability_mode[index - CCS_MAX_MAC_INDEX];
 	return r->mode;
 }
 
Index: branches/ccs-patch/security/ccsecurity/signal.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/signal.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/signal.c	(working copy)
@@ -61,7 +61,7 @@
 	int error;
 	ccs_check_read_lock();
 	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_SIGNAL))
+	    !ccs_init_request_info(&r, NULL, CCS_MAC_SIGNAL))
 		return 0;
 	is_enforce = (r.mode == 3);
 	if (!sig)
Index: branches/ccs-patch/security/ccsecurity/file.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/file.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/file.c	(working copy)
@@ -49,6 +49,40 @@
 	[CCS_TYPE_CHGRP] = "chgrp",
 };
 
+static const u8 ccs_p2mac[CCS_MAX_SINGLE_PATH_OPERATION] = {
+	[CCS_TYPE_READ_WRITE_ACL] = CCS_MAC_OPEN,
+	[CCS_TYPE_EXECUTE_ACL]    = CCS_MAC_EXECUTE,
+	[CCS_TYPE_READ_ACL]       = CCS_MAC_OPEN,
+	[CCS_TYPE_WRITE_ACL]      = CCS_MAC_OPEN,
+	[CCS_TYPE_CREATE_ACL]     = CCS_MAC_CREATE,
+	[CCS_TYPE_UNLINK_ACL]     = CCS_MAC_UNLINK,
+	[CCS_TYPE_MKDIR_ACL]      = CCS_MAC_MKDIR,
+	[CCS_TYPE_RMDIR_ACL]      = CCS_MAC_RMDIR,
+	[CCS_TYPE_MKFIFO_ACL]     = CCS_MAC_MKFIFO,
+	[CCS_TYPE_MKSOCK_ACL]     = CCS_MAC_MKSOCK,
+	[CCS_TYPE_TRUNCATE_ACL]   = CCS_MAC_TRUNCATE,
+	[CCS_TYPE_SYMLINK_ACL]    = CCS_MAC_SYMLINK,
+	[CCS_TYPE_REWRITE_ACL]    = CCS_MAC_REWRITE,
+};
+
+static const u8 ccs_pnn2mac[CCS_MAX_MKDEV_OPERATION] = {
+	[CCS_TYPE_MKBLOCK_ACL]    = CCS_MAC_MKBLOCK,
+	[CCS_TYPE_MKCHAR_ACL]     = CCS_MAC_MKCHAR,
+};
+
+static const u8 ccs_pp2mac[CCS_MAX_DOUBLE_PATH_OPERATION] = {
+	[CCS_TYPE_LINK_ACL]    = CCS_MAC_LINK,
+	[CCS_TYPE_RENAME_ACL]  = CCS_MAC_RENAME,
+};
+
+static const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION] = {
+	[CCS_TYPE_IOCTL] = CCS_MAC_IOCTL,
+	[CCS_TYPE_CHMOD] = CCS_MAC_CHMOD,
+	[CCS_TYPE_CHOWN] = CCS_MAC_CHOWN,
+	[CCS_TYPE_CHGRP] = CCS_MAC_CHGRP,
+};
+
+
 void ccs_put_name_union(struct ccs_name_union *ptr)
 {
 	if (!ptr)
@@ -1084,10 +1118,13 @@
 {
 	const char *msg;
 	int error;
-	const bool is_enforce = (r->mode == 3);
+	bool is_enforce;
+ repeat:
+	r->mode = ccs_profile_ptr[r->profile]->mac_mode[ccs_p2mac[operation]];
 	ccs_check_read_lock();
 	if (!r->mode)
 		return 0;
+	is_enforce = (r->mode == 3);
  retry:
 	error = ccs_check_single_path_acl(r, filename, 1 << operation, 1);
 	msg = ccs_sp2keyword(operation);
@@ -1107,7 +1144,7 @@
 	if (!error && operation == CCS_TYPE_TRUNCATE_ACL &&
 	    ccs_is_no_rewrite_file(filename)) {
 		operation = CCS_TYPE_REWRITE_ACL;
-		goto retry;
+		goto repeat;
 	}
 	return error;
 }
@@ -1186,8 +1223,8 @@
 {
 	struct ccs_request_info r;
 	struct ccs_obj_info obj = {
-		.path1_dentry = dentry,
-		.path1_vfsmnt = mnt
+		.path1.dentry = dentry,
+		.path1.mnt = mnt
 	};
 	const u8 acc_mode = ACC_MODE(flag);
 	int error = 0;
@@ -1208,8 +1245,7 @@
 	    !ccs_init_request_info(&r, current->ccs_flags &
 				   CCS_CHECK_READ_FOR_OPEN_EXEC ?
 				   ccs_fetch_next_domain() :
-				   ccs_current_domain(),
-				   CCS_MAC_FOR_FILE))
+				   ccs_current_domain(), CCS_MAC_OPEN))
 		goto out;
 	r.obj = &obj;
 	if (!ccs_get_realpath(&buf, dentry, mnt)) {
@@ -1255,8 +1291,8 @@
 {
 	struct ccs_request_info r;
 	struct ccs_obj_info obj = {
-		.path1_dentry = dentry,
-		.path1_vfsmnt = mnt
+		.path1.dentry = dentry,
+		.path1.mnt = mnt
 	};
 	int error = -ENOMEM;
 	struct ccs_path_info buf;
@@ -1268,7 +1304,7 @@
 	buf.name = NULL;
 	symlink_target.name = NULL;
 	idx = ccs_read_lock();
-	if (!mnt || !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_FILE)) {
+	if (!mnt || !ccs_init_request_info(&r, NULL, ccs_p2mac[operation])) {
 		error = 0;
 		goto out;
 	}
@@ -1319,8 +1355,8 @@
 {
 	struct ccs_request_info r;
 	struct ccs_obj_info obj = {
-		.path1_dentry = dentry,
-		.path1_vfsmnt = mnt,
+		.path1.dentry = dentry,
+		.path1.mnt = mnt,
 		.dev = dev
 	};
 	int error = -ENOMEM;
@@ -1331,7 +1367,7 @@
 		return 0;
 	buf.name = NULL;
 	idx = ccs_read_lock();
-	if (!mnt || !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_FILE)) {
+	if (!mnt || !ccs_init_request_info(&r, NULL, ccs_pnn2mac[operation])) {
 		error = 0;
 		goto out;
 	}
@@ -1359,8 +1395,8 @@
 {
 	struct ccs_request_info r;
 	struct ccs_obj_info obj = {
-		.path1_dentry = filp->f_dentry,
-		.path1_vfsmnt = filp->f_vfsmnt
+		.path1.dentry = filp->f_dentry,
+		.path1.mnt = filp->f_vfsmnt
 	};
 	int error = -ENOMEM;
 	bool is_enforce = false;
@@ -1371,7 +1407,7 @@
 	buf.name = NULL;
 	idx = ccs_read_lock();
 	if (!filp->f_vfsmnt ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_FILE)) {
+	    !ccs_init_request_info(&r, NULL, CCS_MAC_REWRITE)) {
 		error = 0;
 		goto out;
 	}
@@ -1413,10 +1449,10 @@
 	struct ccs_path_info buf2;
 	bool is_enforce = false;
 	struct ccs_obj_info obj = {
-		.path1_dentry = dentry1,
-		.path1_vfsmnt = mnt,
-		.path2_dentry = dentry2,
-		.path2_vfsmnt = mnt
+		.path1.dentry = dentry1,
+		.path1.mnt = mnt,
+		.path2.dentry = dentry2,
+		.path2.mnt = mnt
 	};
 	int idx;
 	if (!ccs_can_sleep())
@@ -1424,7 +1460,7 @@
 	buf1.name = NULL;
 	buf2.name = NULL;
 	idx = ccs_read_lock();
-	if (!mnt || !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_FILE)) {
+	if (!mnt || !ccs_init_request_info(&r, NULL, ccs_pp2mac[operation])) {
 		error = 0;
 		goto out;
 	}
@@ -1435,7 +1471,9 @@
 	if (operation == CCS_TYPE_RENAME_ACL) {
 		/* CCS_TYPE_LINK_ACL can't reach here for directory. */
 		if (dentry1->d_inode && S_ISDIR(dentry1->d_inode->i_mode)) {
-			/* ccs_get_realpath() reserves space for appending "/". */
+			/*
+			 * ccs_get_realpath() reserves space for appending "/".
+			 */
 			if (!buf1.is_dir) {
 				strcat((char *) buf1.name, "/");
 				ccs_fill_path_info(&buf1);
@@ -1632,8 +1670,8 @@
 {
 	struct ccs_request_info r;
 	struct ccs_obj_info obj = {
-		.path1_dentry = dentry,
-		.path1_vfsmnt = vfsmnt
+		.path1.dentry = dentry,
+		.path1.mnt = vfsmnt
 	};
 	int error = -ENOMEM;
 	struct ccs_path_info buf;
@@ -1642,8 +1680,7 @@
 		return 0;
 	buf.name = NULL;
 	idx = ccs_read_lock();
-	if (!ccs_init_request_info(&r, NULL, type == CCS_TYPE_IOCTL ?
-				   CCS_MAC_FOR_IOCTL : CCS_MAC_FOR_FILEATTR)) {
+	if (!ccs_init_request_info(&r, NULL, ccs_pn2mac[type])) {
 		error = 0;
 		goto out;
 	}
@@ -2405,7 +2442,7 @@
 		return 0;
 	buf.name = NULL;
 	idx = ccs_read_lock();
-	if (!ccs_init_request_info(&r, NULL, CCS_MAC_FOR_FILE)) {
+	if (!ccs_init_request_info(&r, NULL, CCS_MAC_OPEN)) {
 		error = 0;
 		goto out;
 	}
Index: branches/ccs-patch/security/ccsecurity/capability.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/capability.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/capability.c	(working copy)
@@ -65,13 +65,6 @@
 	return NULL;
 }
 
-static inline bool ccs_capability_enabled(const u8 profile, const u8 operation)
-{
-	return operation < CCS_MAX_CAPABILITY_INDEX ?
-		ccs_profile_ptr[profile]->enabled_capabilities[operation] :
-		false;
-}
-
 /**
  * ccs_audit_capability_log - Audit capability log.
  *
@@ -109,8 +102,7 @@
 	int error;
 	ccs_check_read_lock();
 	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_CAPABILITY) ||
-	    !ccs_capability_enabled(r.profile, operation))
+	    !ccs_init_request_info(&r, NULL, CCS_MAX_MAC_INDEX + operation))
 		return true;
 	is_enforce = (r.mode == 3);
  retry:
Index: branches/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- branches/ccs-patch/security/ccsecurity/internal.h	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -13,6 +13,274 @@
 #ifndef _LINUX_CCS_COMMON_H
 #define _LINUX_CCS_COMMON_H
 
+/* Index numbers for Access Controls. */
+enum ccs_acl_entry_type_index {
+	CCS_TYPE_SINGLE_PATH_ACL,
+	CCS_TYPE_MKDEV_ACL,
+	CCS_TYPE_DOUBLE_PATH_ACL,
+	CCS_TYPE_PATH_NUMBER_ACL,
+	CCS_TYPE_ENV_ACL,
+	CCS_TYPE_CAPABILITY_ACL,
+	CCS_TYPE_IP_NETWORK_ACL,
+	CCS_TYPE_SIGNAL_ACL,
+	CCS_TYPE_MOUNT_ACL,
+	CCS_TYPE_UMOUNT_ACL,
+	CCS_TYPE_CHROOT_ACL,
+	CCS_TYPE_PIVOT_ROOT_ACL,
+	CCS_TYPE_EXECUTE_HANDLER,
+	CCS_TYPE_DENIED_EXECUTE_HANDLER
+};
+
+/*
+ * CCS_TYPE_READ_WRITE_ACL is special. CCS_TYPE_READ_WRITE_ACL is automatically
+ * set if both CCS_TYPE_READ_ACL and CCS_TYPE_WRITE_ACL are set.
+ * Both CCS_TYPE_READ_ACL and CCS_TYPE_WRITE_ACL are automatically set if
+ * CCS_TYPE_READ_WRITE_ACL is set.
+ * CCS_TYPE_READ_WRITE_ACL is automatically cleared if either CCS_TYPE_READ_ACL
+ * or CCS_TYPE_WRITE_ACL is cleared. Both CCS_TYPE_READ_ACL and
+ * CCS_TYPE_WRITE_ACL are automatically cleared if CCS_TYPE_READ_WRITE_ACL is
+ * cleared.
+ */
+
+enum ccs_single_path_acl_index {
+	CCS_TYPE_READ_WRITE_ACL,
+	CCS_TYPE_EXECUTE_ACL,
+	CCS_TYPE_READ_ACL,
+	CCS_TYPE_WRITE_ACL,
+	CCS_TYPE_CREATE_ACL,
+	CCS_TYPE_UNLINK_ACL,
+	CCS_TYPE_MKDIR_ACL,
+	CCS_TYPE_RMDIR_ACL,
+	CCS_TYPE_MKFIFO_ACL,
+	CCS_TYPE_MKSOCK_ACL,
+	CCS_TYPE_TRUNCATE_ACL,
+	CCS_TYPE_SYMLINK_ACL,
+	CCS_TYPE_REWRITE_ACL,
+	CCS_MAX_SINGLE_PATH_OPERATION
+};
+
+enum ccs_mkdev_acl_index {
+	CCS_TYPE_MKBLOCK_ACL,
+	CCS_TYPE_MKCHAR_ACL,
+	CCS_MAX_MKDEV_OPERATION
+};
+
+enum ccs_double_path_acl_index {
+	CCS_TYPE_LINK_ACL,
+	CCS_TYPE_RENAME_ACL,
+	CCS_MAX_DOUBLE_PATH_OPERATION
+};
+
+enum ccs_path_number_acl_index {
+	CCS_TYPE_IOCTL,
+	CCS_TYPE_CHMOD,
+	CCS_TYPE_CHOWN,
+	CCS_TYPE_CHGRP,
+	CCS_MAX_PATH_NUMBER_OPERATION
+};
+
+enum ccs_ip_record_type {
+	CCS_IP_RECORD_TYPE_ADDRESS_GROUP,
+	CCS_IP_RECORD_TYPE_IPv4,
+	CCS_IP_RECORD_TYPE_IPv6
+};
+
+enum ccs_profile_index {
+	CCS_AUTOLEARN_EXEC_REALPATH,
+	CCS_AUTOLEARN_EXEC_ARGV0,
+	CCS_RESTRICT_AUTOBIND,     /* exception_policy.conf */
+	CCS_MAX_ACCEPT_ENTRY,
+#ifdef CONFIG_CCSECURITY_AUDIT
+	CCS_MAX_GRANT_LOG,
+	CCS_MAX_REJECT_LOG,
+#endif
+	CCS_VERBOSE,
+	CCS_SLEEP_PERIOD,
+	CCS_MAX_CONTROL_INDEX
+};
+
+/* Indexes for /proc/ccs/ interfaces. */
+enum ccs_proc_interface_index {
+	CCS_DOMAINPOLICY,
+	CCS_EXCEPTIONPOLICY,
+	CCS_DOMAIN_STATUS,
+	CCS_PROCESS_STATUS,
+	CCS_MEMINFO,
+	CCS_GRANTLOG,
+	CCS_REJECTLOG,
+	CCS_SELFDOMAIN,
+	CCS_VERSION,
+	CCS_PROFILE,
+	CCS_QUERY,
+	CCS_MANAGER,
+	CCS_EXECUTE_HANDLER
+};
+
+enum ccs_mac_index {
+	CCS_MAC_EXECUTE,
+	CCS_MAC_OPEN,
+	CCS_MAC_CREATE,
+	CCS_MAC_UNLINK,
+	CCS_MAC_MKDIR,
+	CCS_MAC_RMDIR,
+	CCS_MAC_MKFIFO,
+	CCS_MAC_MKSOCK,
+	CCS_MAC_TRUNCATE,
+	CCS_MAC_SYMLINK,
+	CCS_MAC_REWRITE,
+	CCS_MAC_MKBLOCK,
+	CCS_MAC_MKCHAR,
+	CCS_MAC_LINK,
+	CCS_MAC_RENAME,
+	CCS_MAC_CHMOD,
+	CCS_MAC_CHOWN,
+	CCS_MAC_CHGRP,
+	CCS_MAC_IOCTL,
+	CCS_MAC_CHROOT,
+	CCS_MAC_MOUNT,
+	CCS_MAC_UMOUNT,
+	CCS_MAC_PIVOT_ROOT,
+	CCS_MAC_ENVIRON,
+	CCS_MAC_NETWORK,
+	CCS_MAC_SIGNAL,
+	CCS_MAX_MAC_INDEX
+};
+
+enum ccs_conditions_index {
+	CCS_TASK_UID,             /* current_uid()   */
+	CCS_TASK_EUID,            /* current_euid()  */
+	CCS_TASK_SUID,            /* current_suid()  */
+	CCS_TASK_FSUID,           /* current_fsuid() */
+	CCS_TASK_GID,             /* current_gid()   */
+	CCS_TASK_EGID,            /* current_egid()  */
+	CCS_TASK_SGID,            /* current_sgid()  */
+	CCS_TASK_FSGID,           /* current_fsgid() */
+	CCS_TASK_PID,             /* sys_getpid()   */
+	CCS_TASK_PPID,            /* sys_getppid()  */
+	CCS_EXEC_ARGC,            /* "struct linux_binprm *"->argc */
+	CCS_EXEC_ENVC,            /* "struct linux_binprm *"->envc */
+	CCS_TASK_STATE_0,         /* (u8) (current->ccs_flags >> 24) */
+	CCS_TASK_STATE_1,         /* (u8) (current->ccs_flags >> 16) */
+	CCS_TASK_STATE_2,         /* (u8) (task->ccs_flags >> 8)     */
+	CCS_TYPE_SOCKET,          /* S_IFSOCK */
+	CCS_TYPE_SYMLINK,         /* S_IFLNK */
+	CCS_TYPE_FILE,            /* S_IFREG */
+	CCS_TYPE_BLOCK_DEV,       /* S_IFBLK */
+	CCS_TYPE_DIRECTORY,       /* S_IFDIR */
+	CCS_TYPE_CHAR_DEV,        /* S_IFCHR */
+	CCS_TYPE_FIFO,            /* S_IFIFO */
+	CCS_MODE_SETUID,          /* S_ISUID */
+	CCS_MODE_SETGID,          /* S_ISGID */
+	CCS_MODE_STICKY,          /* S_ISVTX */
+	CCS_MODE_OWNER_READ,      /* S_IRUSR */
+	CCS_MODE_OWNER_WRITE,     /* S_IWUSR */
+	CCS_MODE_OWNER_EXECUTE,   /* S_IXUSR */
+	CCS_MODE_GROUP_READ,      /* S_IRGRP */
+	CCS_MODE_GROUP_WRITE,     /* S_IWGRP */
+	CCS_MODE_GROUP_EXECUTE,   /* S_IXGRP */
+	CCS_MODE_OTHERS_READ,     /* S_IROTH */
+	CCS_MODE_OTHERS_WRITE,    /* S_IWOTH */
+	CCS_MODE_OTHERS_EXECUTE,  /* S_IXOTH */
+	CCS_TASK_TYPE,            /* ((u8) task->ccs_flags) &
+				     CCS_TASK_IS_EXECUTE_HANDLER */
+	CCS_TASK_EXECUTE_HANDLER, /* CCS_TASK_IS_EXECUTE_HANDLER */
+	CCS_EXEC_REALPATH,
+	CCS_SYMLINK_TARGET,
+	CCS_PATH1_UID,
+	CCS_PATH1_GID,
+	CCS_PATH1_INO,
+	CCS_PATH1_MAJOR,
+	CCS_PATH1_MINOR,
+	CCS_PATH1_PERM,
+	CCS_PATH1_TYPE,
+	CCS_PATH1_DEV_MAJOR,
+	CCS_PATH1_DEV_MINOR,
+	CCS_PATH2_UID,
+	CCS_PATH2_GID,
+	CCS_PATH2_INO,
+	CCS_PATH2_MAJOR,
+	CCS_PATH2_MINOR,
+	CCS_PATH2_PERM,
+	CCS_PATH2_TYPE,
+	CCS_PATH2_DEV_MAJOR,
+	CCS_PATH2_DEV_MINOR,
+	CCS_PATH1_PARENT_UID,
+	CCS_PATH1_PARENT_GID,
+	CCS_PATH1_PARENT_INO,
+	CCS_PATH1_PARENT_PERM,
+	CCS_PATH2_PARENT_UID,
+	CCS_PATH2_PARENT_GID,
+	CCS_PATH2_PARENT_INO,
+	CCS_PATH2_PARENT_PERM,
+	CCS_MAX_CONDITION_KEYWORD,
+	CCS_NUMBER_UNION,
+	CCS_NAME_UNION,
+	CCS_ARGV_ENTRY,
+	CCS_ENVP_ENTRY
+};
+
+/* Keywords for ACLs. */
+#define CCS_KEYWORD_ADDRESS_GROUP             "address_group "
+#define CCS_KEYWORD_AGGREGATOR                "aggregator "
+#define CCS_KEYWORD_ALLOW_CAPABILITY          "allow_capability "
+#define CCS_KEYWORD_ALLOW_CHROOT              "allow_chroot "
+#define CCS_KEYWORD_ALLOW_ENV                 "allow_env "
+#define CCS_KEYWORD_ALLOW_IOCTL               "allow_ioctl "
+#define CCS_KEYWORD_ALLOW_CHMOD               "allow_chmod "
+#define CCS_KEYWORD_ALLOW_CHOWN               "allow_chown "
+#define CCS_KEYWORD_ALLOW_CHGRP               "allow_chgrp "
+#define CCS_KEYWORD_ALLOW_MOUNT               "allow_mount "
+#define CCS_KEYWORD_ALLOW_NETWORK             "allow_network "
+#define CCS_KEYWORD_ALLOW_PIVOT_ROOT          "allow_pivot_root "
+#define CCS_KEYWORD_ALLOW_READ                "allow_read "
+#define CCS_KEYWORD_ALLOW_SIGNAL              "allow_signal "
+#define CCS_KEYWORD_DELETE                    "delete "
+#define CCS_KEYWORD_DENY_AUTOBIND             "deny_autobind "
+#define CCS_KEYWORD_DENY_REWRITE              "deny_rewrite "
+#define CCS_KEYWORD_ALLOW_UNMOUNT             "allow_unmount "
+#define CCS_KEYWORD_FILE_PATTERN              "file_pattern "
+#define CCS_KEYWORD_INITIALIZE_DOMAIN         "initialize_domain "
+#define CCS_KEYWORD_KEEP_DOMAIN               "keep_domain "
+#define CCS_KEYWORD_NO_INITIALIZE_DOMAIN      "no_initialize_domain "
+#define CCS_KEYWORD_NO_KEEP_DOMAIN            "no_keep_domain "
+#define CCS_KEYWORD_PATH_GROUP                "path_group "
+#define CCS_KEYWORD_NUMBER_GROUP              "number_group "
+#define CCS_KEYWORD_SELECT                    "select "
+#define CCS_KEYWORD_USE_PROFILE               "use_profile "
+#define CCS_KEYWORD_IGNORE_GLOBAL_ALLOW_READ  "ignore_global_allow_read"
+#define CCS_KEYWORD_IGNORE_GLOBAL_ALLOW_ENV   "ignore_global_allow_env"
+#define CCS_KEYWORD_EXECUTE_HANDLER           "execute_handler"
+#define CCS_KEYWORD_DENIED_EXECUTE_HANDLER    "denied_execute_handler"
+
+/* A domain definition starts with <kernel>. */
+#define ROOT_NAME                         "<kernel>"
+#define ROOT_NAME_LEN                     (sizeof(ROOT_NAME) - 1)
+
+/* Value type definition. */
+#define CCS_VALUE_TYPE_INVALID     0
+#define CCS_VALUE_TYPE_DECIMAL     1
+#define CCS_VALUE_TYPE_OCTAL       2
+#define CCS_VALUE_TYPE_HEXADECIMAL 3
+
+/*
+ * This is the max length of a token.
+ *
+ * A token consists of only ASCII printable characters.
+ * Non printable characters in a token is represented in \ooo style
+ * octal string. Thus, \ itself is represented as \\.
+ */
+#define CCS_MAX_PATHNAME_LEN 4000
+
+#define CCS_EXEC_TMPSIZE     4096
+
+/* Profile number is an integer between 0 and 255. */
+#define CCS_MAX_PROFILES 256
+
+#define CCS_CHECK_READ_FOR_OPEN_EXEC     16
+#define CCS_DONT_SLEEP_ON_ENFORCE_ERROR  32
+#define CCS_TASK_IS_EXECUTE_HANDLER      64
+#define CCS_TASK_IS_POLICY_MANAGER      128
+
 #include <linux/string.h>
 #include <linux/mm.h>
 #include <linux/utime.h>
@@ -151,10 +419,8 @@
 	bool path1_parent_valid;
 	bool path2_valid;
 	bool path2_parent_valid;
-	struct dentry *path1_dentry;
-	struct vfsmount *path1_vfsmnt;
-	struct dentry *path2_dentry;
-	struct vfsmount *path2_vfsmnt;
+	struct path path1;
+	struct path path2;
 	struct ccs_mini_stat path1_stat;
 	/* I don't handle path2_stat for rename operation. */
 	struct ccs_mini_stat path2_stat;
@@ -164,12 +430,6 @@
 	unsigned int dev;
 };
 
-/* Value type definition. */
-#define CCS_VALUE_TYPE_INVALID     0
-#define CCS_VALUE_TYPE_DECIMAL     1
-#define CCS_VALUE_TYPE_OCTAL       2
-#define CCS_VALUE_TYPE_HEXADECIMAL 3
-
 struct ccs_condition_element {
 	/*
 	 * Left hand operand. A "struct ccs_argv_entry" for CCS_ARGV_ENTRY, a
@@ -231,17 +491,6 @@
 	u16 depth;         /* = ccs_path_depth(name)               */
 };
 
-/*
- * This is the max length of a token.
- *
- * A token consists of only ASCII printable characters.
- * Non printable characters in a token is represented in \ooo style
- * octal string. Thus, \ itself is represented as \\.
- */
-#define CCS_MAX_PATHNAME_LEN 4000
-
-#define CCS_EXEC_TMPSIZE     4096
-
 /* Structure for execve() operation. */
 struct ccs_execve_entry {
 	struct list_head list;
@@ -276,24 +525,6 @@
 	u8 type; /* = one of values in "enum ccs_acl_entry_type_index" */
 } __attribute__((__packed__));
 
-/* Index numbers for Access Controls. */
-enum ccs_acl_entry_type_index {
-	CCS_TYPE_SINGLE_PATH_ACL,
-	CCS_TYPE_MKDEV_ACL,
-	CCS_TYPE_DOUBLE_PATH_ACL,
-	CCS_TYPE_PATH_NUMBER_ACL,
-	CCS_TYPE_ENV_ACL,
-	CCS_TYPE_CAPABILITY_ACL,
-	CCS_TYPE_IP_NETWORK_ACL,
-	CCS_TYPE_SIGNAL_ACL,
-	CCS_TYPE_MOUNT_ACL,
-	CCS_TYPE_UMOUNT_ACL,
-	CCS_TYPE_CHROOT_ACL,
-	CCS_TYPE_PIVOT_ROOT_ACL,
-	CCS_TYPE_EXECUTE_HANDLER,
-	CCS_TYPE_DENIED_EXECUTE_HANDLER
-};
-
 /* Structure for domain information. */
 struct ccs_domain_info {
 	struct list_head list;
@@ -316,14 +547,6 @@
 	bool domain_transition_failed;
 };
 
-/* Profile number is an integer between 0 and 255. */
-#define CCS_MAX_PROFILES 256
-
-#define CCS_CHECK_READ_FOR_OPEN_EXEC     16
-#define CCS_DONT_SLEEP_ON_ENFORCE_ERROR  32
-#define CCS_TASK_IS_EXECUTE_HANDLER      64
-#define CCS_TASK_IS_POLICY_MANAGER      128
-
 /* Structure for "allow_read" keyword. */
 struct ccs_globally_readable_file_entry {
 	struct list_head list;
@@ -574,141 +797,7 @@
 	struct ccs_number_union port;
 };
 
-/* Index numbers for File Controls. */
 
-/*
- * CCS_TYPE_READ_WRITE_ACL is special. CCS_TYPE_READ_WRITE_ACL is automatically
- * set if both CCS_TYPE_READ_ACL and CCS_TYPE_WRITE_ACL are set.
- * Both CCS_TYPE_READ_ACL and CCS_TYPE_WRITE_ACL are automatically set if
- * CCS_TYPE_READ_WRITE_ACL is set.
- * CCS_TYPE_READ_WRITE_ACL is automatically cleared if either CCS_TYPE_READ_ACL
- * or CCS_TYPE_WRITE_ACL is cleared. Both CCS_TYPE_READ_ACL and
- * CCS_TYPE_WRITE_ACL are automatically cleared if CCS_TYPE_READ_WRITE_ACL is
- * cleared.
- */
-
-enum ccs_single_path_acl_index {
-	CCS_TYPE_READ_WRITE_ACL,
-	CCS_TYPE_EXECUTE_ACL,
-	CCS_TYPE_READ_ACL,
-	CCS_TYPE_WRITE_ACL,
-	CCS_TYPE_CREATE_ACL,
-	CCS_TYPE_UNLINK_ACL,
-	CCS_TYPE_MKDIR_ACL,
-	CCS_TYPE_RMDIR_ACL,
-	CCS_TYPE_MKFIFO_ACL,
-	CCS_TYPE_MKSOCK_ACL,
-	CCS_TYPE_TRUNCATE_ACL,
-	CCS_TYPE_SYMLINK_ACL,
-	CCS_TYPE_REWRITE_ACL,
-	CCS_MAX_SINGLE_PATH_OPERATION
-};
-
-enum ccs_mkdev_acl_index {
-	CCS_TYPE_MKBLOCK_ACL,
-	CCS_TYPE_MKCHAR_ACL,
-	CCS_MAX_MKDEV_OPERATION
-};
-
-enum ccs_double_path_acl_index {
-	CCS_TYPE_LINK_ACL,
-	CCS_TYPE_RENAME_ACL,
-	CCS_MAX_DOUBLE_PATH_OPERATION
-};
-
-enum ccs_path_number_acl_index {
-	CCS_TYPE_IOCTL,
-	CCS_TYPE_CHMOD,
-	CCS_TYPE_CHOWN,
-	CCS_TYPE_CHGRP,
-	CCS_MAX_PATH_NUMBER_OPERATION
-};
-
-enum ccs_ip_record_type {
-	CCS_IP_RECORD_TYPE_ADDRESS_GROUP,
-	CCS_IP_RECORD_TYPE_IPv4,
-	CCS_IP_RECORD_TYPE_IPv6
-};
-
-/* Keywords for ACLs. */
-#define CCS_KEYWORD_ADDRESS_GROUP             "address_group "
-#define CCS_KEYWORD_AGGREGATOR                "aggregator "
-#define CCS_KEYWORD_ALLOW_CAPABILITY          "allow_capability "
-#define CCS_KEYWORD_ALLOW_CHROOT              "allow_chroot "
-#define CCS_KEYWORD_ALLOW_ENV                 "allow_env "
-#define CCS_KEYWORD_ALLOW_IOCTL               "allow_ioctl "
-#define CCS_KEYWORD_ALLOW_CHMOD               "allow_chmod "
-#define CCS_KEYWORD_ALLOW_CHOWN               "allow_chown "
-#define CCS_KEYWORD_ALLOW_CHGRP               "allow_chgrp "
-#define CCS_KEYWORD_ALLOW_MOUNT               "allow_mount "
-#define CCS_KEYWORD_ALLOW_NETWORK             "allow_network "
-#define CCS_KEYWORD_ALLOW_PIVOT_ROOT          "allow_pivot_root "
-#define CCS_KEYWORD_ALLOW_READ                "allow_read "
-#define CCS_KEYWORD_ALLOW_SIGNAL              "allow_signal "
-#define CCS_KEYWORD_DELETE                    "delete "
-#define CCS_KEYWORD_DENY_AUTOBIND             "deny_autobind "
-#define CCS_KEYWORD_DENY_REWRITE              "deny_rewrite "
-#define CCS_KEYWORD_ALLOW_UNMOUNT             "allow_unmount "
-#define CCS_KEYWORD_FILE_PATTERN              "file_pattern "
-#define CCS_KEYWORD_INITIALIZE_DOMAIN         "initialize_domain "
-#define CCS_KEYWORD_KEEP_DOMAIN               "keep_domain "
-#define CCS_KEYWORD_NO_INITIALIZE_DOMAIN      "no_initialize_domain "
-#define CCS_KEYWORD_NO_KEEP_DOMAIN            "no_keep_domain "
-#define CCS_KEYWORD_PATH_GROUP                "path_group "
-#define CCS_KEYWORD_NUMBER_GROUP              "number_group "
-#define CCS_KEYWORD_SELECT                    "select "
-#define CCS_KEYWORD_USE_PROFILE               "use_profile "
-#define CCS_KEYWORD_IGNORE_GLOBAL_ALLOW_READ  "ignore_global_allow_read"
-#define CCS_KEYWORD_IGNORE_GLOBAL_ALLOW_ENV   "ignore_global_allow_env"
-#define CCS_KEYWORD_EXECUTE_HANDLER           "execute_handler"
-#define CCS_KEYWORD_DENIED_EXECUTE_HANDLER    "denied_execute_handler"
-#define CCS_KEYWORD_CAPABILITIES              "SUPPORTED_CAPABILITIES"
-/* A domain definition starts with <kernel>. */
-#define ROOT_NAME                         "<kernel>"
-#define ROOT_NAME_LEN                     (sizeof(ROOT_NAME) - 1)
-
-/* Index numbers for Access Controls. */
-enum ccs_profile_index {
-	CCS_MAC_FOR_FILE,          /* domain_policy.conf */
-	CCS_AUTOLEARN_EXEC_REALPATH,
-	CCS_AUTOLEARN_EXEC_ARGV0,
-	CCS_MAC_FOR_IOCTL,         /* domain_policy.conf */
-	CCS_MAC_FOR_FILEATTR,      /* domain_policy.conf */
-	CCS_MAC_FOR_ENV,           /* domain_policy.conf */
-	CCS_MAC_FOR_NETWORK,       /* domain_policy.conf */
-	CCS_MAC_FOR_SIGNAL,        /* domain_policy.conf */
-	CCS_MAC_FOR_NAMESPACE,     /* domain_policy.conf */
-	CCS_MAC_FOR_CAPABILITY,    /* domain_policy.conf */
-	CCS_RESTRICT_AUTOBIND,     /* exception_policy.conf */
-	CCS_MAX_ACCEPT_ENTRY,
-#ifdef CONFIG_CCSECURITY_AUDIT
-	CCS_MAX_GRANT_LOG,
-	CCS_MAX_REJECT_LOG,
-#endif
-	CCS_VERBOSE,
-	CCS_SLEEP_PERIOD,
-	CCS_MAX_CONTROL_INDEX
-};
-
-/* Indexes for /proc/ccs/ interfaces. */
-enum ccs_proc_interface_index {
-	CCS_DOMAINPOLICY,
-	CCS_EXCEPTIONPOLICY,
-	CCS_SYSTEMPOLICY,
-	CCS_DOMAIN_STATUS,
-	CCS_PROCESS_STATUS,
-	CCS_MEMINFO,
-	CCS_GRANTLOG,
-	CCS_REJECTLOG,
-	CCS_SELFDOMAIN,
-	CCS_VERSION,
-	CCS_PROFILE,
-	CCS_QUERY,
-	CCS_MANAGER,
-	CCS_UPDATESCOUNTER,
-	CCS_EXECUTE_HANDLER
-};
-
 /* Structure for reading/writing policy via /proc interfaces. */
 struct ccs_io_buffer {
 	int (*read) (struct ccs_io_buffer *);
@@ -750,79 +839,6 @@
 	u8 type;
 };
 
-enum ccs_conditions_index {
-	CCS_TASK_UID,             /* current_uid()   */
-	CCS_TASK_EUID,            /* current_euid()  */
-	CCS_TASK_SUID,            /* current_suid()  */
-	CCS_TASK_FSUID,           /* current_fsuid() */
-	CCS_TASK_GID,             /* current_gid()   */
-	CCS_TASK_EGID,            /* current_egid()  */
-	CCS_TASK_SGID,            /* current_sgid()  */
-	CCS_TASK_FSGID,           /* current_fsgid() */
-	CCS_TASK_PID,             /* sys_getpid()   */
-	CCS_TASK_PPID,            /* sys_getppid()  */
-	CCS_EXEC_ARGC,            /* "struct linux_binprm *"->argc */
-	CCS_EXEC_ENVC,            /* "struct linux_binprm *"->envc */
-	CCS_TASK_STATE_0,         /* (u8) (current->ccs_flags >> 24) */
-	CCS_TASK_STATE_1,         /* (u8) (current->ccs_flags >> 16) */
-	CCS_TASK_STATE_2,         /* (u8) (task->ccs_flags >> 8)     */
-	CCS_TYPE_SOCKET,          /* S_IFSOCK */
-	CCS_TYPE_SYMLINK,         /* S_IFLNK */
-	CCS_TYPE_FILE,            /* S_IFREG */
-	CCS_TYPE_BLOCK_DEV,       /* S_IFBLK */
-	CCS_TYPE_DIRECTORY,       /* S_IFDIR */
-	CCS_TYPE_CHAR_DEV,        /* S_IFCHR */
-	CCS_TYPE_FIFO,            /* S_IFIFO */
-	CCS_MODE_SETUID,          /* S_ISUID */
-	CCS_MODE_SETGID,          /* S_ISGID */
-	CCS_MODE_STICKY,          /* S_ISVTX */
-	CCS_MODE_OWNER_READ,      /* S_IRUSR */
-	CCS_MODE_OWNER_WRITE,     /* S_IWUSR */
-	CCS_MODE_OWNER_EXECUTE,   /* S_IXUSR */
-	CCS_MODE_GROUP_READ,      /* S_IRGRP */
-	CCS_MODE_GROUP_WRITE,     /* S_IWGRP */
-	CCS_MODE_GROUP_EXECUTE,   /* S_IXGRP */
-	CCS_MODE_OTHERS_READ,     /* S_IROTH */
-	CCS_MODE_OTHERS_WRITE,    /* S_IWOTH */
-	CCS_MODE_OTHERS_EXECUTE,  /* S_IXOTH */
-	CCS_TASK_TYPE,            /* ((u8) task->ccs_flags) &
-				     CCS_TASK_IS_EXECUTE_HANDLER */
-	CCS_TASK_EXECUTE_HANDLER, /* CCS_TASK_IS_EXECUTE_HANDLER */
-	CCS_EXEC_REALPATH,
-	CCS_SYMLINK_TARGET,
-	CCS_PATH1_UID,
-	CCS_PATH1_GID,
-	CCS_PATH1_INO,
-	CCS_PATH1_MAJOR,
-	CCS_PATH1_MINOR,
-	CCS_PATH1_PERM,
-	CCS_PATH1_TYPE,
-	CCS_PATH1_DEV_MAJOR,
-	CCS_PATH1_DEV_MINOR,
-	CCS_PATH2_UID,
-	CCS_PATH2_GID,
-	CCS_PATH2_INO,
-	CCS_PATH2_MAJOR,
-	CCS_PATH2_MINOR,
-	CCS_PATH2_PERM,
-	CCS_PATH2_TYPE,
-	CCS_PATH2_DEV_MAJOR,
-	CCS_PATH2_DEV_MINOR,
-	CCS_PATH1_PARENT_UID,
-	CCS_PATH1_PARENT_GID,
-	CCS_PATH1_PARENT_INO,
-	CCS_PATH1_PARENT_PERM,
-	CCS_PATH2_PARENT_UID,
-	CCS_PATH2_PARENT_GID,
-	CCS_PATH2_PARENT_INO,
-	CCS_PATH2_PARENT_PERM,
-	CCS_MAX_CONDITION_KEYWORD,
-	CCS_NUMBER_UNION,
-	CCS_NAME_UNION,
-	CCS_ARGV_ENTRY,
-	CCS_ENVP_ENTRY
-};
-
 /* Prototype definition. */
 
 bool ccs_can_sleep(void);
@@ -852,7 +868,6 @@
 bool ccs_verbose_mode(const struct ccs_domain_info *domain);
 char *ccs_encode(const char *str);
 char *ccs_init_audit_log(int *len, struct ccs_request_info *r);
-char *ccs_realpath(const char *pathname);
 char *ccs_realpath_from_path(struct path *path);
 const char *ccs_cap2keyword(const u8 operation);
 const char *ccs_dp2keyword(const u8 operation);
@@ -994,7 +1009,8 @@
 struct ccs_profile {
 	unsigned int value[CCS_MAX_CONTROL_INDEX];
 	const struct ccs_path_info *comment;
-	bool enabled_capabilities[CCS_MAX_CAPABILITY_INDEX];
+	u8 mac_mode[CCS_MAX_MAC_INDEX];
+	u8 mac_capability_mode[CCS_MAX_CAPABILITY_INDEX];
 };
 extern struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
 
Index: branches/ccs-patch/security/ccsecurity/condition.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/condition.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/condition.c	(working copy)
@@ -812,7 +812,7 @@
 	struct inode *inode;
 
 	/* Get information on "path1". */
-	dentry = obj->path1_dentry;
+	dentry = obj->path1.dentry;
 	inode = dentry->d_inode;
 	if (inode) {
 		if (inode->i_op && inode->i_op->revalidate &&
@@ -832,7 +832,7 @@
 	/* Get information on "path1.parent". */
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&dcache_lock);
-	dentry = dget(obj->path1_dentry->d_parent);
+	dentry = dget(obj->path1.dentry->d_parent);
 	spin_unlock(&dcache_lock);
 	/***** CRITICAL SECTION END *****/
 	inode = dentry->d_inode;
@@ -856,7 +856,7 @@
 		return;
 
 	/* Get information on "path2". */
-	dentry = obj->path2_dentry;
+	dentry = obj->path2.dentry;
 	inode = dentry->d_inode;
 	if (inode) {
 		if (inode->i_op && inode->i_op->revalidate &&
@@ -876,7 +876,7 @@
 	/* Get information on "path2.parent". */
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&dcache_lock);
-	dentry = dget(obj->path2_dentry->d_parent);
+	dentry = dget(obj->path2.dentry->d_parent);
 	spin_unlock(&dcache_lock);
 	/***** CRITICAL SECTION END *****/
 	inode = dentry->d_inode;
@@ -905,8 +905,8 @@
 	struct kstat stat;
 
 	/* Get information on "path1". */
-	mnt = obj->path1_vfsmnt;
-	dentry = obj->path1_dentry;
+	mnt = obj->path1.mnt;
+	dentry = obj->path1.dentry;
 	inode = dentry->d_inode;
 	if (inode) {
 		if (!inode->i_op || vfs_getattr(mnt, dentry, &stat)) {
@@ -923,7 +923,7 @@
 	}
 
 	/* Get information on "path1.parent". */
-	dentry = dget_parent(obj->path1_dentry);
+	dentry = dget_parent(obj->path1.dentry);
 	inode = dentry->d_inode;
 	if (inode) {
 		if (!inode->i_op || vfs_getattr(mnt, dentry, &stat)) {
@@ -940,12 +940,12 @@
 	}
 	dput(dentry);
 
-	mnt = obj->path2_vfsmnt;
+	mnt = obj->path2.mnt;
 	if (!mnt)
 		return;
 
 	/* Get information on "path2". */
-	dentry = obj->path2_dentry;
+	dentry = obj->path2.dentry;
 	inode = dentry->d_inode;
 	if (inode) {
 		if (!inode->i_op || vfs_getattr(mnt, dentry, &stat)) {
@@ -962,7 +962,7 @@
 	}
 
 	/* Get information on "path2.parent". */
-	dentry = dget_parent(obj->path2_dentry);
+	dentry = dget_parent(obj->path2.dentry);
 	inode = dentry->d_inode;
 	if (inode) {
 		if (!inode->i_op || vfs_getattr(mnt, dentry, &stat)) {
Index: branches/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/policy_io.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -15,34 +15,58 @@
 /* Lock for protecting ccs_profile->comment  */
 static DEFINE_SPINLOCK(ccs_profile_comment_lock);
 
-static bool ccs_profile_entry_used[CCS_MAX_CONTROL_INDEX +
-				   CCS_MAX_CAPABILITY_INDEX + 1];
+/* String table for functionality that takes 2 modes. */
+static const char *ccs_mode_2[2] = {
+	"disabled", "enabled"
+};
 
-/* String table for functionality that takes 4 modes. */
-static const char *ccs_mode_4[4] = {
-	"disabled", "learning", "permissive", "enforcing"
+static const char *ccs_keyword_mode[4] = {
+	"MAC_MODE_DISABLED", "MAC_MODE_LEARNING",
+	"MAC_MODE_PERMISSIVE", "MAC_MODE_ENFORCING"
 };
-/* String table for functionality that takes 2 modes. */
-static const char *ccs_mode_2[4] = {
-	"disabled", "enabled", "enabled", "enabled"
+
+static const char *ccs_keyword_capability_mode[4] = {
+	"MAC_MODE_CAPABILITY_DISABLED", "MAC_MODE_CAPABILITY_LEARNING",
+	"MAC_MODE_CAPABILITY_PERMISSIVE", "MAC_MODE_CAPABILITY_ENFORCING"
 };
 
+static const char *ccs_mac_keywords[CCS_MAX_MAC_INDEX] = {
+	[CCS_MAC_EXECUTE]    = "execute",
+	[CCS_MAC_OPEN]       = "open",
+	[CCS_MAC_CREATE]     = "create",
+	[CCS_MAC_UNLINK]     = "unlink",
+	[CCS_MAC_MKDIR]      = "mkdir",
+	[CCS_MAC_RMDIR]      = "rmdir",
+	[CCS_MAC_MKFIFO]     = "mkfifo",
+	[CCS_MAC_MKSOCK]     = "mksock",
+	[CCS_MAC_TRUNCATE]   = "truncate",
+	[CCS_MAC_SYMLINK]    = "symlink",
+	[CCS_MAC_REWRITE]    = "rewrite",
+	[CCS_MAC_MKBLOCK]    = "mkblock",
+	[CCS_MAC_MKCHAR]     = "mkchar",
+	[CCS_MAC_LINK]       = "link",
+	[CCS_MAC_RENAME]     = "rename",
+	[CCS_MAC_CHMOD]      = "chmod",
+	[CCS_MAC_CHOWN]      = "chown",
+	[CCS_MAC_CHGRP]      = "chgrp",
+	[CCS_MAC_IOCTL]      = "ioctl",
+	[CCS_MAC_CHROOT]     = "chroot",
+	[CCS_MAC_MOUNT]      = "mount",
+	[CCS_MAC_UMOUNT]     = "umount",
+	[CCS_MAC_PIVOT_ROOT] = "pivot_root",
+	[CCS_MAC_ENVIRON]    = "env",
+	[CCS_MAC_NETWORK]    = "network",
+	[CCS_MAC_SIGNAL]     = "signal"
+};
+
 /* Table for profile. */
 static struct {
 	const char *keyword;
 	unsigned int current_value;
 	const unsigned int max_value;
 } ccs_control_array[CCS_MAX_CONTROL_INDEX] = {
-	[CCS_MAC_FOR_FILE]        = { "MAC_FOR_FILE",        0, 3 },
 	[CCS_AUTOLEARN_EXEC_REALPATH] = { "AUTOLEARN_EXEC_REALPATH", 0, 1 },
 	[CCS_AUTOLEARN_EXEC_ARGV0] = { "AUTOLEARN_EXEC_ARGV0", 0, 1 },
-	[CCS_MAC_FOR_IOCTL]       = { "MAC_FOR_IOCTL",       0, 3 },
-	[CCS_MAC_FOR_FILEATTR]    = { "MAC_FOR_FILEATTR",    0, 3 },
-	[CCS_MAC_FOR_ENV]         = { "MAC_FOR_ENV",         0, 3 },
-	[CCS_MAC_FOR_NETWORK]     = { "MAC_FOR_NETWORK",     0, 3 },
-	[CCS_MAC_FOR_SIGNAL]      = { "MAC_FOR_SIGNAL",      0, 3 },
-	[CCS_MAC_FOR_NAMESPACE]   = { "MAC_FOR_NAMESPACE",   0, 3 },
-	[CCS_MAC_FOR_CAPABILITY]  = { "MAC_FOR_CAPABILITY",   0, 3 },
 	[CCS_RESTRICT_AUTOBIND]   = { "RESTRICT_AUTOBIND",   0, 1 },
 	[CCS_MAX_ACCEPT_ENTRY]
 	= { "MAX_ACCEPT_ENTRY", CONFIG_CCSECURITY_MAX_ACCEPT_ENTRY, INT_MAX },
@@ -127,10 +151,6 @@
 		ptr = entry;
 		for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++)
 			ptr->value[i] = ccs_control_array[i].current_value;
-		/*
-		 * Needn't to initialize "ptr->capability_value"
-		 * because they are always 0.
-		 */
 		mb(); /* Avoid out-of-order execution. */
 		ccs_profile_ptr[profile] = ptr;
 		entry = NULL;
@@ -152,6 +172,7 @@
 	char *data = head->write_buf;
 	unsigned int i;
 	unsigned int value;
+	int mode;
 	char *cp;
 	struct ccs_profile *ccs_profile;
 	i = simple_strtoul(data, &cp, 10);
@@ -179,28 +200,44 @@
 		spin_unlock(&ccs_profile_comment_lock);
 		/***** CRITICAL SECTION END *****/
 		ccs_put_name(old_comment);
-		ccs_profile_entry_used[0] = true;
 		return 0;
 	}
-	if (!strcmp(data, CCS_KEYWORD_CAPABILITIES)) {
-		unsigned char capabilities[CCS_MAX_CAPABILITY_INDEX];
-		memset(capabilities, 0, sizeof(capabilities));
+	for (mode = 0; mode < 4; mode++) {
+		if (strcmp(data, ccs_keyword_mode[mode]))
+			continue;
 		cp++;
 		while (1) {
 			char *cp2 = strchr(cp, ' ');
 			if (cp2)
 				*cp2 = '\0';
+			for (i = 0; i < CCS_MAX_MAC_INDEX; i++) {
+				if (strcmp(cp, ccs_mac_keywords[i]))
+					continue;
+				ccs_profile->mac_mode[i] = mode;
+			}
+			if (!cp2)
+				break;
+			cp = cp2 + 1;
+		}
+		return 0;
+	}
+	for (mode = 0; mode < 4; mode++) {
+		if (strcmp(data, ccs_keyword_capability_mode[mode]))
+			continue;
+		cp++;
+		while (1) {
+			char *cp2 = strchr(cp, ' ');
+			if (cp2)
+				*cp2 = '\0';
 			for (i = 0; i < CCS_MAX_CAPABILITY_INDEX; i++) {
 				if (strcmp(cp, ccs_capability_list[i]))
 					continue;
-				capabilities[i] = 1;
+				ccs_profile->mac_capability_mode[i] = mode;
 			}
 			if (!cp2)
 				break;
 			cp = cp2 + 1;
 		}
-		for (i = 0; i < CCS_MAX_CAPABILITY_INDEX; i++)
-			ccs_profile->enabled_capabilities[i] = capabilities[i];
 		return 0;
 	}
 	for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++) {
@@ -208,20 +245,8 @@
 			continue;
 		if (sscanf(cp + 1, "%u", &value) != 1) {
 			int j;
-			const char **modes;
-			switch (i) {
-			case CCS_AUTOLEARN_EXEC_REALPATH:
-			case CCS_AUTOLEARN_EXEC_ARGV0:
-			case CCS_RESTRICT_AUTOBIND:
-			case CCS_VERBOSE:
-				modes = ccs_mode_2;
-				break;
-			default:
-				modes = ccs_mode_4;
-				break;
-			}
-			for (j = 0; j < 4; j++) {
-				if (strcmp(cp + 1, modes[j]))
+			for (j = 0; j < 2; j++) {
+				if (strcmp(cp + 1, ccs_mode_2[j]))
 					continue;
 				value = j;
 				break;
@@ -232,33 +257,59 @@
 			value = ccs_control_array[i].max_value;
 		}
 		ccs_profile->value[i] = value;
-		ccs_profile_entry_used[i + 1] = true;
 		return 0;
 	}
 	return -EINVAL;
 }
 
-static bool ccs_print_capability_list(struct ccs_io_buffer *head, u8 index)
+static bool ccs_print_mac_mode(struct ccs_io_buffer *head, u8 index)
 {
 	const int pos = head->read_avail;
 	int i;
+	int mode;
 	const struct ccs_profile *ccs_profile = ccs_profile_ptr[index];
-	if (!ccs_io_printf(head, "%u-" CCS_KEYWORD_CAPABILITIES "={", index))
-		return false;
-	for (i = 0; i < CCS_MAX_CAPABILITY_INDEX; i++) {
-		if (!ccs_profile->enabled_capabilities[i])
-			continue;
-		if (!ccs_io_printf(head, " %s", ccs_capability_list[i]))
+	for (mode = 0; mode < 4; mode++) {
+		if (!ccs_io_printf(head, "%u-%s={", index, ccs_keyword_mode[mode]))
 			goto out;
+		for (i = 0; i < CCS_MAX_MAC_INDEX; i++) {
+			if (ccs_profile->mac_mode[i] != mode)
+				continue;
+			if (!ccs_io_printf(head, " %s", ccs_mac_keywords[i]))
+				goto out;
+		}
+		if (!ccs_io_printf(head, " }\n"))
+			goto out;
 	}
-	if (!ccs_io_printf(head, " }\n"))
-		goto out;
 	return true;
  out:
 	head->read_avail = pos;
 	return false;
 }
 
+static bool ccs_print_capability_mode(struct ccs_io_buffer *head, u8 index)
+{
+	const int pos = head->read_avail;
+	int i;
+	int mode;
+	const struct ccs_profile *ccs_profile = ccs_profile_ptr[index];
+	for (mode = 0; mode < 4; mode++) {
+		if (!ccs_io_printf(head, "%u-%s={", index, ccs_keyword_capability_mode[mode]))
+			goto out;
+		for (i = 0; i < CCS_MAX_CAPABILITY_INDEX; i++) {
+			if (ccs_profile->mac_capability_mode[i] != mode)
+				continue;
+			if (!ccs_io_printf(head, " %s", ccs_capability_list[i]))
+				goto out;
+		}
+		if (!ccs_io_printf(head, " }\n"))
+			goto out;
+	}
+	return true;
+ out:
+	head->read_avail = pos;
+	return false;
+}
+
 /**
  * ccs_read_profile - Read profile table.
  *
@@ -280,8 +331,6 @@
 		head->read_step = step;
 		if (!ccs_profile)
 			continue;
-		if (!ccs_profile_entry_used[type])
-			continue;
 		if (!type) { /* Print profile' comment tag. */
 			bool done;
 			/***** CRITICAL SECTION START *****/
@@ -294,28 +343,22 @@
 			if (!done)
 				break;
 			continue;
-		}
-		if (type == 1) {
-			if (!ccs_print_capability_list(head, index))
+		} else if (type == 1) {
+			if (!ccs_print_mac_mode(head, index))
 				break;
 			continue;
+		} else if (type == 2) {
+			if (!ccs_print_capability_mode(head, index))
+				break;
+			continue;
 		}
-		type -= 2;
+		type -= 3;
 		{
 			const unsigned int value = ccs_profile->value[type];
-			const char **modes = NULL;
 			const char *keyword = ccs_control_array[type].keyword;
-			switch (ccs_control_array[type].max_value) {
-			case 3:
-				modes = ccs_mode_4;
-				break;
-			case 1:
-				modes = ccs_mode_2;
-				break;
-			}
-			if (modes) {
+			if (ccs_control_array[type].max_value == 1) {
 				if (!ccs_io_printf(head, "%u-%s=%s\n", index,
-						   keyword, modes[value]))
+						   keyword, ccs_mode_2[value]))
 					break;
 			} else {
 				if (!ccs_io_printf(head, "%u-%s=%u\n", index,
Index: branches/ccs-patch/security/ccsecurity/umount.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/umount.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/umount.c	(working copy)
@@ -58,12 +58,12 @@
 	struct ccs_path_info dir;
 	struct path path = { mnt, mnt->mnt_root };
 	struct ccs_obj_info obj = {
-		.path1_dentry = mnt->mnt_root,
-		.path1_vfsmnt = mnt
+		.path1.dentry = mnt->mnt_root,
+		.path1.mnt = mnt
 	};
 	ccs_check_read_lock();
 	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_NAMESPACE))
+	    !ccs_init_request_info(&r, NULL, CCS_MAC_UMOUNT))
 		return 0;
 	is_enforce = (r.mode == 3);
 	r.obj = &obj;
Index: branches/ccs-patch/security/ccsecurity/network.c
===================================================================
--- branches/ccs-patch/security/ccsecurity/network.c	(revision 2911)
+++ branches/ccs-patch/security/ccsecurity/network.c	(working copy)
@@ -185,7 +185,7 @@
 	char buf[64];
 	ccs_check_read_lock();
 	if (!ccs_can_sleep() ||
-	    !ccs_init_request_info(&r, NULL, CCS_MAC_FOR_NETWORK))
+	    !ccs_init_request_info(&r, NULL, CCS_MAC_NETWORK))
 		return 0;
 	is_enforce = (r.mode == 3);
  retry:
Index: branches/ccs-tools/ccstools/init_policy.sh
===================================================================
--- branches/ccs-tools/ccstools/init_policy.sh	(revision 2907)
+++ branches/ccs-tools/ccstools/init_policy.sh	(working copy)
@@ -1,3 +1,3 @@
 #! /bin/sh
 cd ${0%/*}
-exec ./init_policy version=1.7.0-pre policy_dir=/etc/ccs "$@"
+exec ./init_policy policy_dir=/etc/ccs "$@"
Index: branches/ccs-tools/ccstools/init_policy.c
===================================================================
--- branches/ccs-tools/ccstools/init_policy.c	(revision 2908)
+++ branches/ccs-tools/ccstools/init_policy.c	(working copy)
@@ -1528,14 +1528,6 @@
 {
 	static const char full_profile_text[] = {
 		"0-COMMENT=-----Disabled Mode-----\n"
-		"0-MAC_FOR_FILE=disabled\n"
-		"0-MAC_FOR_IOCTL=disabled\n"
-		"0-MAC_FOR_FILEATTR=disabled\n"
-		"0-MAC_FOR_ENV=disabled\n"
-		"0-MAC_FOR_NETWORK=disabled\n"
-		"0-MAC_FOR_SIGNAL=disabled\n"
-		"0-MAC_FOR_NAMESPACE=disabled\n"
-		"0-MAC_FOR_CAPABILITY=disabled\n"
 		"0-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"0-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"0-RESTRICT_AUTOBIND=disabled\n"
@@ -1544,23 +1536,20 @@
 		"0-MAX_REJECT_LOG=1024\n"
 		"0-TOMOYO_VERBOSE=enabled\n"
 		"0-SLEEP_PERIOD=0\n"
-		"0-SUPPORTED_CAPABILITIES={ inet_tcp_create inet_tcp_listen "
-		"inet_tcp_connect use_inet_udp use_inet_ip use_route "
-		"use_packet SYS_MOUNT SYS_UMOUNT SYS_REBOOT SYS_CHROOT "
+		"0-MAC_MODE_DISABLED={ execute open create unlink mkdir "
+		"rmdir mkfifo mksock truncate symlink rewrite mkblock mkchar "
+		"link rename chmod chown chgrp ioctl chroot mount umount "
+		"pivot_root env network signal }\n"
+		"0-MAC_MODE_CAPABILITY_DISABLED={ "
+		"inet_tcp_create inet_tcp_listen inet_tcp_connect "
+		"use_inet_udp use_inet_ip use_route use_packet "
+		"SYS_MOUNT SYS_UMOUNT SYS_REBOOT SYS_CHROOT "
 		"SYS_KILL SYS_VHANGUP SYS_TIME SYS_NICE SYS_SETHOSTNAME "
 		"use_kernel_module create_fifo create_block_dev "
 		"create_char_dev create_unix_socket SYS_LINK SYS_SYMLINK "
 		"SYS_RENAME SYS_UNLINK SYS_CHMOD SYS_CHOWN SYS_IOCTL "
 		"SYS_KEXEC_LOAD SYS_PIVOT_ROOT SYS_PTRACE conceal_mount }\n"
 		"1-COMMENT=-----Learning Mode-----\n"
-		"1-MAC_FOR_FILE=learning\n"
-		"1-MAC_FOR_IOCTL=learning\n"
-		"1-MAC_FOR_FILEATTR=learning\n"
-		"1-MAC_FOR_ENV=learning\n"
-		"1-MAC_FOR_NETWORK=learning\n"
-		"1-MAC_FOR_SIGNAL=learning\n"
-		"1-MAC_FOR_NAMESPACE=learning\n"
-		"1-MAC_FOR_CAPABILITY=learning\n"
 		"1-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"1-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"1-RESTRICT_AUTOBIND=enabled\n"
@@ -1569,23 +1558,20 @@
 		"1-MAX_REJECT_LOG=1024\n"
 		"1-TOMOYO_VERBOSE=disabled\n"
 		"1-SLEEP_PERIOD=0\n"
-		"1-SUPPORTED_CAPABILITIES={ inet_tcp_create inet_tcp_listen "
-		"inet_tcp_connect use_inet_udp use_inet_ip use_route "
-		"use_packet SYS_MOUNT SYS_UMOUNT SYS_REBOOT SYS_CHROOT "
+		"1-MAC_MODE_LEARNING={ execute open create unlink mkdir "
+		"rmdir mkfifo mksock truncate symlink rewrite mkblock mkchar "
+		"link rename chmod chown chgrp ioctl chroot mount umount "
+		"pivot_root env network signal }\n"
+		"1-MAC_MODE_CAPABILITY_LEARNING={ "
+		"inet_tcp_create inet_tcp_listen inet_tcp_connect "
+		"use_inet_udp use_inet_ip use_route use_packet "
+		"SYS_MOUNT SYS_UMOUNT SYS_REBOOT SYS_CHROOT "
 		"SYS_KILL SYS_VHANGUP SYS_TIME SYS_NICE SYS_SETHOSTNAME "
 		"use_kernel_module create_fifo create_block_dev "
 		"create_char_dev create_unix_socket SYS_LINK SYS_SYMLINK "
 		"SYS_RENAME SYS_UNLINK SYS_CHMOD SYS_CHOWN SYS_IOCTL "
 		"SYS_KEXEC_LOAD SYS_PIVOT_ROOT SYS_PTRACE conceal_mount }\n"
 		"2-COMMENT=-----Permissive Mode-----\n"
-		"2-MAC_FOR_FILE=permissive\n"
-		"2-MAC_FOR_IOCTL=permissive\n"
-		"2-MAC_FOR_FILEATTR=permissive\n"
-		"2-MAC_FOR_ENV=permissive\n"
-		"2-MAC_FOR_NETWORK=permissive\n"
-		"2-MAC_FOR_SIGNAL=permissive\n"
-		"2-MAC_FOR_NAMESPACE=permissive\n"
-		"2-MAC_FOR_CAPABILITY=permissive\n"
 		"2-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"2-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"2-RESTRICT_AUTOBIND=enabled\n"
@@ -1594,23 +1580,20 @@
 		"2-MAX_REJECT_LOG=1024\n"
 		"2-TOMOYO_VERBOSE=enabled\n"
 		"2-SLEEP_PERIOD=0\n"
-		"2-SUPPORTED_CAPABILITIES={ inet_tcp_create inet_tcp_listen "
-		"inet_tcp_connect use_inet_udp use_inet_ip use_route "
-		"use_packet SYS_MOUNT SYS_UMOUNT SYS_REBOOT SYS_CHROOT "
+		"2-MAC_MODE_PERMISSIVE={ execute open create unlink mkdir "
+		"rmdir mkfifo mksock truncate symlink rewrite mkblock mkchar "
+		"link rename chmod chown chgrp ioctl chroot mount umount "
+		"pivot_root env network signal }\n"
+		"2-MAC_MODE_CAPABILITY_PERMISSIVE={ "
+		"inet_tcp_create inet_tcp_listen inet_tcp_connect "
+		"use_inet_udp use_inet_ip use_route use_packet "
+		"SYS_MOUNT SYS_UMOUNT SYS_REBOOT SYS_CHROOT "
 		"SYS_KILL SYS_VHANGUP SYS_TIME SYS_NICE SYS_SETHOSTNAME "
 		"use_kernel_module create_fifo create_block_dev "
 		"create_char_dev create_unix_socket SYS_LINK SYS_SYMLINK "
 		"SYS_RENAME SYS_UNLINK SYS_CHMOD SYS_CHOWN SYS_IOCTL "
 		"SYS_KEXEC_LOAD SYS_PIVOT_ROOT SYS_PTRACE conceal_mount }\n"
 		"3-COMMENT=-----Enforcing Mode-----\n"
-		"3-MAC_FOR_FILE=enforcing\n"
-		"3-MAC_FOR_IOCTL=enforcing\n"
-		"3-MAC_FOR_FILEATTR=enforcing\n"
-		"3-MAC_FOR_ENV=enforcing\n"
-		"3-MAC_FOR_NETWORK=enforcing\n"
-		"3-MAC_FOR_SIGNAL=enforcing\n"
-		"3-MAC_FOR_NAMESPACE=enforcing\n"
-		"3-MAC_FOR_CAPABILITY=enforcing\n"
 		"3-AUTOLEARN_EXEC_REALPATH=enabled\n"
 		"3-AUTOLEARN_EXEC_ARGV0=enabled\n"
 		"3-RESTRICT_AUTOBIND=enabled\n"
@@ -1619,9 +1602,14 @@
 		"3-MAX_REJECT_LOG=1024\n"
 		"3-TOMOYO_VERBOSE=enabled\n"
 		"3-SLEEP_PERIOD=0\n"
-		"3-SUPPORTED_CAPABILITIES={ inet_tcp_create inet_tcp_listen "
-		"inet_tcp_connect use_inet_udp use_inet_ip use_route "
-		"use_packet SYS_MOUNT SYS_UMOUNT SYS_REBOOT SYS_CHROOT "
+		"3-MAC_MODE_ENFORCING={ execute open create unlink mkdir "
+		"rmdir mkfifo mksock truncate symlink rewrite mkblock mkchar "
+		"link rename chmod chown chgrp ioctl chroot mount umount "
+		"pivot_root env network signal }\n"
+		"3-MAC_MODE_CAPABILITY_ENFORCING={ "
+		"inet_tcp_create inet_tcp_listen inet_tcp_connect "
+		"use_inet_udp use_inet_ip use_route use_packet "
+		"SYS_MOUNT SYS_UMOUNT SYS_REBOOT SYS_CHROOT "
 		"SYS_KILL SYS_VHANGUP SYS_TIME SYS_NICE SYS_SETHOSTNAME "
 		"use_kernel_module create_fifo create_block_dev "
 		"create_char_dev create_unix_socket SYS_LINK SYS_SYMLINK "
@@ -1630,16 +1618,31 @@
 	};
 	static const char file_only_profile_text[] = {
 		"0-COMMENT=-----Disabled Mode-----\n"
-		"0-MAC_FOR_FILE=disabled\n"
+		"0-MAC_MODE_DISABLED={ execute open create unlink mkdir "
+		"rmdir mkfifo mksock truncate symlink rewrite mkblock mkchar "
+		"link rename chmod chown chgrp ioctl chroot mount umount "
+		"pivot_root env network signal }\n"
 		"0-TOMOYO_VERBOSE=disabled\n"
 		"1-COMMENT=-----Learning Mode-----\n"
-		"1-MAC_FOR_FILE=learning\n"
+		"1-MAC_MODE_DISABLED={ env network signal }\n"
+		"1-MAC_MODE_LEARNING={ execute open create unlink mkdir "
+		"rmdir mkfifo mksock truncate symlink rewrite mkblock mkchar "
+		"link rename chmod chown chgrp ioctl chroot mount umount "
+		"pivot_root }\n"
 		"1-TOMOYO_VERBOSE=disabled\n"
 		"2-COMMENT=-----Permissive Mode-----\n"
-		"2-MAC_FOR_FILE=permissive\n"
+		"2-MAC_MODE_DISABLED={ env network signal }\n"
+		"2-MAC_MODE_LEARNING={ execute open create unlink mkdir "
+		"rmdir mkfifo mksock truncate symlink rewrite mkblock mkchar "
+		"link rename chmod chown chgrp ioctl chroot mount umount "
+		"pivot_root }\n"
 		"2-TOMOYO_VERBOSE=enabled\n"
 		"3-COMMENT=-----Enforcing Mode-----\n"
-		"3-MAC_FOR_FILE=enforcing\n"
+		"3-MAC_MODE_DISABLED={ env network signal }\n"
+		"3-MAC_MODE_LEARNING={ execute open create unlink mkdir "
+		"rmdir mkfifo mksock truncate symlink rewrite mkblock mkchar "
+		"link rename chmod chown chgrp ioctl chroot mount umount "
+		"pivot_root }\n"
 		"3-TOMOYO_VERBOSE=enabled\n"
 	};
 	FILE *fp;
Index: branches/ccs-tools/ccstools/kernel_test/ccs_new_test.c
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/ccs_new_test.c	(revision 0)
+++ branches/ccs-tools/ccstools/kernel_test/ccs_new_test.c	(revision 0)
@@ -0,0 +1,299 @@
+#include "include.h"
+#include <stdarg.h>
+
+static void BUG(const char *fmt, ...)
+	__attribute__ ((format(printf, 1, 2)));
+
+static void BUG(const char *fmt, ...)
+{
+	va_list args;
+	printf("BUG: ");
+	va_start(args, fmt);
+	vprintf(fmt, args);
+	va_end(args);
+	putchar('\n');
+	fflush(stdout);
+	while (1)
+		sleep(100);
+}
+
+static int write_domain_policy(const char *policy, int is_delete)
+{
+	FILE *fp = fopen(proc_policy_domain_policy, "r");
+	char buffer[8192];
+	int domain_found = 0;
+	int policy_found = 0;
+	memset(buffer, 0, sizeof(buffer));
+	if (!fp) {
+		BUG("Can't read %s", proc_policy_domain_policy);
+		return 0;
+	}
+	if (is_delete)
+		fprintf(domain_fp, "delete ");
+	fprintf(domain_fp, "%s\n", policy);
+	while (fgets(buffer, sizeof(buffer) - 1, fp)) {
+		char *cp = strchr(buffer, '\n');
+		if (cp)
+			*cp = '\0';
+		if (!strncmp(buffer, "<kernel>", 8))
+			domain_found = !strcmp(self_domain, buffer);
+		if (!domain_found)
+			continue;
+		/* printf("<%s>\n", buffer); */
+		if (strcmp(buffer, policy))
+			continue;
+		policy_found = 1;
+		break;
+	}
+	fclose(fp);
+	if (policy_found == is_delete) {
+		BUG("Can't %s %s", is_delete ? "delete" : "append",
+		    policy);
+		return 0;
+	}
+	errno = 0;
+	return 1;
+
+}
+
+static int check_exception_policy_state(const char *policy, int is_delete)
+{
+	FILE *fp = fopen(proc_policy_exception_policy, "r");
+	char buffer[8192];
+	int policy_found = 0;
+	memset(buffer, 0, sizeof(buffer));
+	if (!fp) {
+		BUG("Can't read %s", proc_policy_exception_policy);
+		return 0;
+	}
+	if (is_delete)
+		fprintf(exception_fp, "delete ");
+	fprintf(exception_fp, "%s\n", policy);
+	while (fgets(buffer, sizeof(buffer) - 1, fp)) {
+		char *cp = strchr(buffer, '\n');
+		if (cp)
+			*cp = '\0';
+		if (strcmp(buffer, policy))
+			continue;
+		policy_found = 1;
+		break;
+	}
+	fclose(fp);
+	if (policy_found == is_delete) {
+		BUG("Can't %s %s", is_delete ? "delete" : "append",
+		    policy);
+		return 0;
+	}
+	errno = 0;
+	return 1;
+
+}
+
+static int set_profile(const int mode, const char *name)
+{
+	static const char *modes[4] = { "DISABLED", "LEARNING", "PERMISSIVE", "ENFORCING" };
+	FILE *fp = fopen(proc_policy_profile, "r");
+	char buffer[8192];
+	int policy_found = 0;
+	const int len = strlen(modes[mode]);
+	if (!fp) {
+		BUG("Can't read %s", proc_policy_profile);
+		return 0;
+	}
+	fprintf(profile_fp, "255-MAC_MODE_%s=%s\n", modes[mode], name);
+	while (memset(buffer, 0, sizeof(buffer)),
+	       fgets(buffer, sizeof(buffer) - 1, fp)) {
+		char *cp = strchr(buffer, '\n');
+		if (cp)
+			*cp = '\0';
+		if (strncmp(buffer, "255-MAC_MODE_", 13) ||
+		    strncmp(buffer + 13, modes[mode], len) ||
+		    buffer[13 + len] != '=')
+			continue;
+		if (strstr(buffer + 14 + len, name))
+			policy_found = 1;
+		break;
+	}
+	fclose(fp);
+	if (!policy_found) {
+		BUG("Can't change profile to 255-MAC_MODE_%s=%s",
+		    modes[mode], name);
+		return 0;
+	}
+	errno = 0;
+	return 1;
+}
+
+static int result = 0;
+static int err = 0;
+
+static void show_result(const char *test, int should_success)
+{
+	err = errno;
+	printf("%s : ", test);
+	if (should_success) {
+		if (err == 0)
+			printf("OK (%d)\n", result);
+		else
+			printf("FAILED: %s\n", strerror(err));
+	} else {
+		if (err == 0)
+			printf("BUG: Didn't fail (%d)\n", result);
+		else if (err == EPERM)
+			printf("OK: permission denied\n");
+		else
+			printf("FAILED: %s\n", strerror(err));
+	}
+}
+
+static void test_read_etc_fstab(void)
+{
+	result = open("/etc/fstab", O_RDONLY);
+}
+
+static void test_write_dev_null(void)
+{
+	result = open("/dev/null", O_WRONLY);
+}
+
+static void cleanup_file_open(void)
+{
+	if (result != EOF)
+		close(result);
+}
+
+static void test_mkdir_testdir(void)
+{
+	result = mkdir("/tmp/testdir", 0755);
+}
+
+static void cleanup_mkdir_testdir(void)
+{
+	rmdir("/tmp/testdir");
+}
+
+static void setup_mkdir_testdir(void)
+{
+	mkdir("/tmp/testdir", 0755);
+}
+
+static void test_rmdir_testdir(void)
+{
+	result = rmdir("/tmp/testdir");
+}
+
+static void setup_execute_bin_true(void)
+{
+	fprintf(domain_fp, "%s /bin/true\n", self_domain);
+	fprintf(domain_fp, "use_profile 0\n");
+	fprintf(domain_fp, "select pid=%u\n", pid);
+}
+
+static void cleanup_execute_bin_true(void)
+{
+	wait(NULL);
+	fprintf(domain_fp, "delete %s /bin/true\n", self_domain);
+	fprintf(domain_fp, "select pid=%u\n", pid);
+}
+
+static void test_execute_bin_true(void)
+{
+	char *argv[] = { "/bin/true", NULL };
+	char *envp[] = { "HOME=/", NULL };
+	int pipe_fd[2] = { EOF, EOF };
+	int err = 0;
+	pipe(pipe_fd);
+	switch (fork()) {
+	case 0:
+		execve("/bin/true", argv, envp);
+		err = errno;
+		write(pipe_fd[1], &err, sizeof(err));
+		_exit(0);
+		break;
+	case -1:
+		err = -ENOMEM;
+		break;
+	}
+	close(pipe_fd[1]);
+	read(pipe_fd[0], &err, sizeof(err));
+	close(pipe_fd[0]);
+	result = err ? EOF : 0;
+	errno = err;
+}
+
+static struct test_struct {
+	void (*do_setup) (void);
+	void (*do_test) (void);
+	void (*do_cleanup) (void);
+	const char *name;
+	const char *policy;
+	void (*do_add_policy) (void);
+	void (*do_delete_policy) (void);
+} tests[] = {
+	/*
+	{ NULL, test_read_etc_fstab, cleanup_file_open, "open", "allow_read /etc/fstab" },
+	{ NULL, test_read_etc_fstab, cleanup_file_open, "open", "allow_read /etc/fstab if task.uid=0" },
+	{ NULL, test_read_etc_fstab, cleanup_file_open, "open", "allow_read /etc/fstab if path1.uid=0 path1.parent.uid=0" },
+	{ NULL, test_write_dev_null, cleanup_file_open, "open", "allow_write /dev/null" },
+	{ NULL, test_write_dev_null, cleanup_file_open, "open", "allow_write /dev/null if task.uid=0" },
+	{ NULL, test_write_dev_null, cleanup_file_open, "open", "allow_write /dev/null if path1.type=char path1.dev_major=1 path1.dev_minor=3 path1.perm=0666" },
+	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir, "mkdir", "allow_mkdir /tmp/testdir/" },
+	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir, "mkdir", "allow_mkdir /tmp/testdir/ if path1.parent.uid=0 path1.parent.perm=01777" },
+	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir, "mkdir", "allow_mkdir /tmp/testdir/ if task.uid=path1.parent.uid" },
+	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir, "rmdir", "allow_rmdir /tmp/testdir/" },
+	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir, "rmdir", "allow_rmdir /tmp/testdir/ if path1.parent.uid=0 path1.parent.perm=01777" },
+	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir, "rmdir", "allow_rmdir /tmp/testdir/ if task.uid=0-100 task.gid=0x0-0xFF path1.uid=0" },
+	*/
+	{ setup_execute_bin_true, test_execute_bin_true, cleanup_execute_bin_true, "execute", "allow_execute /bin/true" },
+	{ setup_execute_bin_true, test_execute_bin_true, cleanup_execute_bin_true, "execute", "allow_execute /bin/true if exec.argc=1 exec.argv[0]=\"/bin/true\"" },
+	{ setup_execute_bin_true, test_execute_bin_true, cleanup_execute_bin_true, "execute", "allow_execute /bin/true if exec.envc=1 exec.envp[\"HOME\"]=\"/\" exec.envp[\"PATH\"]=NULL" },
+	{ NULL }
+};
+
+int main(int argc, char *argv[])
+{
+	int i;
+	int j;
+	int mode;
+	ccs_test_init();
+	for (j = 0; j < 2; j++) {
+		for (i = 0; tests[i].do_test; i++) {
+			if (tests[i].do_setup)
+				tests[i].do_setup();
+			if (tests[i].do_add_policy)
+				tests[i].do_add_policy();
+			else
+				write_domain_policy(tests[i].policy, 0);
+			set_profile(3, tests[i].name);
+			tests[i].do_test();
+			show_result(tests[i].policy, 1);
+			set_profile(0, tests[i].name);
+			if (tests[i].do_cleanup)
+				tests[i].do_cleanup();
+			if (tests[i].do_delete_policy)
+				tests[i].do_delete_policy();
+			else
+				write_domain_policy(tests[i].policy, 1);
+			if (tests[i].do_setup)
+				tests[i].do_setup();
+			set_profile(3, tests[i].name);
+			tests[i].do_test();
+			show_result(tests[i].policy, 0);
+			set_profile(0, tests[i].name);
+		}
+	}
+	for (mode = 0; mode < 4; mode++) {
+		for (i = 0; tests[i].do_test; i++) {
+			if (tests[i].do_setup)
+				tests[i].do_setup();
+			set_profile(mode, tests[i].name);
+			tests[i].do_test();
+			show_result(tests[i].name, 1);
+			set_profile(0, tests[i].name);
+			if (tests[i].do_cleanup)
+				tests[i].do_cleanup();
+		}
+	}
+	fprintf(domain_fp, "delete %s\n", self_domain);
+	return 0;
+}
Index: branches/ccs-tools/ccstools/kernel_test/include.h
===================================================================
--- branches/ccs-tools/ccstools/kernel_test/include.h	(revision 2908)
+++ branches/ccs-tools/ccstools/kernel_test/include.h	(working copy)
@@ -137,12 +137,20 @@
 		*/
 		fprintf(profile_fp, "255-%s", cp);
 		if (!strcmp(cp, "COMMENT"))
-			mode = "=Profile for kernel test\n";
+			mode = "Profile for kernel test\n";
 		else if (sscanf(mode, "%u", &v) == 1)
-			mode = "=0\n";
+			mode = "0\n";
+		else if (!strcmp(cp, "MAC_MODE_LEARNING") ||
+			 !strcmp(cp, "MAC_MODE_PERMISSIVE") ||
+			 !strcmp(cp, "MAC_MODE_ENFORCING"))
+			cp = "MAC_MODE_DISABLED";
+		else if (!strcmp(cp, "MAC_MODE_CAPABILITY_LEARNING") ||
+			 !strcmp(cp, "MAC_MODE_CAPABILITY_PERMISSIVE") ||
+			 !strcmp(cp, "MAC_MODE_CAPABILITY_ENFORCING"))
+			cp = "MAC_MODE_CAPABILITY_DISABLED";
 		else
-			mode = "=disabled\n";
-		fprintf(profile_fp, "%s", mode);
+			mode = "disabled\n";
+		fprintf(profile_fp, "255-%s=%s", cp, mode);
 	}
 	/* fprintf(profile_fp, "255-SLEEP_PERIOD=1\n"); */
 	/* fprintf(profile_fp, "255-TOMOYO_VERBOSE=enabled\n"); */
@@ -205,4 +213,8 @@
 	}
 	fprintf(domain_fp, "select pid=%u\n", pid);
 	fprintf(domain_fp, "use_profile 255\n");
+	fprintf(domain_fp, "allow_read/write /proc/ccs/domain_policy\n");
+	fprintf(domain_fp, "allow_truncate /proc/ccs/domain_policy\n");
+	fprintf(domain_fp, "allow_read/write /proc/ccs/profile\n");
+	fprintf(domain_fp, "allow_truncate /proc/ccs/profile\n");
 }
Index: branches/ccs-tools/ccstools/tomoyo_init_policy.sh
===================================================================
--- branches/ccs-tools/ccstools/tomoyo_init_policy.sh	(revision 2907)
+++ branches/ccs-tools/ccstools/tomoyo_init_policy.sh	(working copy)
@@ -1,3 +0,0 @@
-#! /bin/sh
-cd ${0%/*}
-exec ./init_policy version=2.2.0 policy_dir=/etc/tomoyo
