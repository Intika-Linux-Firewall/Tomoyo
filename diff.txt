Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(revision 2226)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(working copy)
@@ -375,8 +375,7 @@
 		       const int history_count, const int max_history);
 int getch2(void);
 
-extern _Bool offline_mode;
-extern int persistent_fd;
+extern _Bool network_mode;
 extern int query_fd;
 extern int path_group_list_len;
 extern int address_group_list_len;
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(revision 2226)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(working copy)
@@ -5,7 +5,7 @@
  *
  * Copyright (C) 2005-2009  NTT DATA CORPORATION
  *
- * Version: 1.6.7-rc   2009/03/04
+ * Version: 1.6.7-rc   2009/03/06
  *
  */
 #include "ccstools.h"
@@ -82,21 +82,9 @@
 static int select_window(struct domain_policy *dp, const int current);
 static void show_command_key(const int screen, const _Bool readonly);
 static int generic_list_loop(struct domain_policy *dp);
-static void copy_fd_to_fp(int fd, FILE *fp);
 
 /* Utility Functions */
 
-static void copy_fd_to_fp(int fd, FILE *fp)
-{
-	char buffer[1024];
-	while (true) {
-		const int len = read(fd, buffer, sizeof(buffer));
-		if (len <= 0)
-			break;
-		fwrite(buffer, len, 1, fp);
-	}
-}
-
 static const char *get_last_name(const struct domain_policy *dp,
 				 const int index)
 {
@@ -589,7 +577,9 @@
 static unsigned int refresh_interval = 0;
 static _Bool need_reload = false;
 
-_Bool offline_mode = false;
+_Bool network_mode = false;
+static u32 network_ip = INADDR_NONE;
+static u16 network_port = 0;
 
 struct path_group_entry *path_group_list = NULL;
 int path_group_list_len = 0;
@@ -733,23 +723,29 @@
 
 static FILE *open_write(const char *filename)
 {
-	if (offline_mode) {
-		char request[1024];
-		int fd[2];
-		if (socketpair(PF_UNIX, SOCK_STREAM, 0, fd)) {
-			fprintf(stderr, "socketpair()\n");
-			exit(1);
+	if (network_mode) {
+		const int fd = socket(AF_INET, SOCK_STREAM, 0);
+		struct sockaddr_in addr;
+		FILE *fp;
+		memset(&addr, 0, sizeof(addr));
+		addr.sin_family = AF_INET;
+		addr.sin_addr.s_addr = network_ip;
+		addr.sin_port = network_port;
+		if (connect(fd, (struct sockaddr *) &addr, sizeof(addr))) {
+			close(fd);
+			set_error(filename);
+			return NULL;
 		}
-		if (shutdown(fd[0], SHUT_RD))
-			goto out;
-		memset(request, 0, sizeof(request));
-		snprintf(request, sizeof(request) - 1, "POST %s", filename);
-		send_fd(request, &fd[1]);
-		return fdopen(fd[0], "w");
-out:
-		close(fd[1]);
-		close(fd[0]);
-		exit(1);
+		fp = fdopen(fd, "r+");
+		fprintf(fp, "%s", filename);
+		fputc(0, fp);
+		fflush(fp);
+		if (fgetc(fp) != 0) {
+			fclose(fp);
+			set_error(filename);
+			return NULL;
+		}
+		return fp;
 	} else {
 		FILE *fp;
 		if (readonly_mode)
@@ -761,6 +757,37 @@
 	}
 }
 
+FILE *open_read(const char *filename)
+{
+	if (network_mode) {
+		const int fd = socket(AF_INET, SOCK_STREAM, 0);
+		struct sockaddr_in addr;
+		FILE *fp;
+		memset(&addr, 0, sizeof(addr));
+		addr.sin_family = AF_INET;
+		addr.sin_addr.s_addr = network_ip;
+		addr.sin_port = network_port;
+		if (connect(fd, (struct sockaddr *) &addr, sizeof(addr))) {
+			close(fd);
+			set_error(filename);
+			return NULL;
+		}
+		fp = fdopen(fd, "r+");
+		fprintf(fp, "%s", filename);
+		fputc(0, fp);
+		fflush(fp);
+		if (fgetc(fp) != 0) {
+			fclose(fp);
+			set_error(filename);
+			return NULL;
+		}
+		fputc(0, fp);
+		fflush(fp);
+		return fp;
+	} else {
+		return fopen(filename, "r");
+	}
+}
 
 static int profile_entry_compare(const void *a, const void *b)
 {
@@ -795,11 +822,17 @@
 	while (generic_acl_list_count)
 		free((void *)
 		     generic_acl_list[--generic_acl_list_count].operand);
-	if (!offline_mode && current_screen == SCREEN_ACL_LIST) {
-		/* Don't set error message if failed. */
-		fp = fopen(policy_file, "r+");
+	if (current_screen == SCREEN_ACL_LIST) {
+		if (network_mode)
+			/* We can read after write. */
+			fp = open_write(policy_file);
+		else
+			/* Don't set error message if failed. */
+			fp = fopen(policy_file, "r+");
 		if (fp) {
 			fprintf(fp, "select domain=%s\n", current_domain);
+			if (network_mode)
+				fputc(0, fp);
 			fflush(fp);
 		}
 	}
@@ -1045,14 +1078,17 @@
 no_exception:
 
 	/* Load all domain list. */
-	fp = NULL;
-	if (!offline_mode) {
+	if (network_mode)
+		/* We can read after write. */
+		fp = open_write(policy_file);
+	else
 		/* Don't set error message if failed. */
 		fp = fopen(policy_file, "r+");
-		if (fp) {
-			fprintf(fp, "select allow_execute\n");
-			fflush(fp);
-		}
+	if (fp) {
+		fprintf(fp, "select allow_execute\n");
+		if (network_mode)
+			fputc(0, fp);
+		fflush(fp);
 	}
 	if (!fp)
 		fp = open_read(proc_policy_domain_policy);
@@ -1796,11 +1832,11 @@
 
 static int select_window(struct domain_policy *dp, const int current)
 {
-	const _Bool s_ok = offline_mode ||
+	const _Bool s_ok = network_mode ||
 		access(proc_policy_system_policy, F_OK) == 0;
-	const _Bool e_ok = offline_mode ||
+	const _Bool e_ok = network_mode ||
 		access(proc_policy_exception_policy, F_OK) == 0;
-	const _Bool d_ok = offline_mode ||
+	const _Bool d_ok = network_mode ||
 		access(proc_policy_domain_policy, F_OK) == 0;
 	move(0, 0);
 	printw("Press one of below keys to switch window.\n\n");
@@ -1816,7 +1852,7 @@
 		printw("a     <<< Domain Policy Editor >>>\n");
 	printw("p     <<< Profile Editor >>>\n");
 	printw("m     <<< Manager Policy Editor >>>\n");
-	if (!offline_mode) {
+	if (!network_mode) {
 		/* printw("i     <<< Interactive Enforcing Mode >>>\n"); */
 		printw("q     <<< Memory Quota Editor >>>\n");
 	}
@@ -1846,7 +1882,7 @@
 			return SCREEN_PROFILE_LIST;
 		if (c == 'M' || c == 'm')
 			return SCREEN_MANAGER_LIST;
-		if (!offline_mode) {
+		if (!network_mode) {
 			/*
 			if (c == 'I' || c == 'i')
 				return SCREEN_QUERY_LIST;
@@ -2178,6 +2214,15 @@
 	memset(current_item_index, 0, sizeof(current_item_index));
 	memset(list_item_count, 0, sizeof(list_item_count));
 	memset(max_eat_col, 0, sizeof(max_eat_col));
+	{
+		char *cp = strrchr(argv[0], '/');
+		if (!cp)
+			cp = argv[0];
+		else
+			cp++;
+		if (strstr(cp, "editpolicy_network"))
+			network_mode = true;
+	}
 	if (argc > 1) {
 		int i;
 		for (i = 1; i < argc; i++) {
@@ -2198,148 +2243,35 @@
 			else if (sscanf(argv[i], "refresh=%u",
 					&refresh_interval) == 1) {
 				/* */
+			} else if (network_mode && strchr(argv[i], ':')) {
+				char *cp = strchr(argv[i], ':');
+				*cp = '\0';
+				network_ip = inet_addr(argv[i]);
+				network_port = htons(atoi(cp + 1));
 			} else {
 				printf("Usage: %s [s|e|d|p|m|q] [readonly] "
-				       "[refresh=interval]\n", argv[0]);
+				       "[refresh=interval]%s\n", argv[0],
+				       network_mode ? " ip:port" : "");
 				return 1;
 			}
 		}
 	}
 	editpolicy_init_keyword_map();
-	{
-		char *cp = strrchr(argv[0], '/');
-		if (!cp)
-			cp = argv[0];
-		else
-			cp++;
-		if (strstr(cp, "editpolicy_offline"))
-			offline_mode = true;
-	}
-	if (offline_mode) {
-		int fd[2] = { EOF, EOF };
-		if (chdir(disk_policy_dir)) {
-			printf("Directory %s doesn't exist.\n",
-			       disk_policy_dir);
-			if (!chdir("/etc/tomoyo/"))
-				printf("If you want to edit /etc/tomoyo/ "
-				       "directory, please run \"ln -s tomoyo "
-				       "/etc/ccs\" manually.");
+	if (network_mode) {
+		const int fd = socket(AF_INET, SOCK_STREAM, 0);
+		struct sockaddr_in addr;
+		memset(&addr, 0, sizeof(addr));
+		addr.sin_family = AF_INET;
+		addr.sin_addr.s_addr = network_ip;
+		addr.sin_port = network_port;
+		if (connect(fd, (struct sockaddr *) &addr, sizeof(addr))) {
+			const u32 ip = ntohl(ip);
+			fprintf(stderr, "Can't connect to %u.%u.%u.%u:%u\n",
+				(u8) (ip >> 24), (u8) (ip >> 16),
+				(u8) (ip >> 8), (u8) ip, ntohs(network_port));
 			return 1;
 		}
-		if (socketpair(PF_UNIX, SOCK_STREAM, 0, fd)) {
-			fprintf(stderr, "socketpair()\n");
-			exit(1);
-		}
-		switch (fork()) {
-		case 0:
-			close(fd[0]);
-			persistent_fd = fd[1];
-			editpolicy_offline_daemon();
-			_exit(0);
-		case -1:
-			fprintf(stderr, "fork()\n");
-			exit(1);
-		}
-		close(fd[1]);
-		persistent_fd = fd[0];
-		{
-			int fd = open2(base_policy_system_policy, O_RDONLY);
-			if (fd != EOF) {
-				FILE *fp =
-					open_write(proc_policy_system_policy);
-				if (fp) {
-					copy_fd_to_fp(fd, fp);
-					fclose(fp);
-				}
-				close(fd);
-			}
-			fd = open2(disk_policy_system_policy, O_RDONLY);
-			if (fd != EOF) {
-				FILE *fp =
-					open_write(proc_policy_system_policy);
-				if (fp) {
-					copy_fd_to_fp(fd, fp);
-					fclose(fp);
-				}
-				close(fd);
-			}
-			fd = open2(base_policy_exception_policy, O_RDONLY);
-			if (fd != EOF) {
-				FILE *fp =
-				open_write(proc_policy_exception_policy);
-				if (fp) {
-					copy_fd_to_fp(fd, fp);
-					fclose(fp);
-				}
-				close(fd);
-			}
-			fd = open2(disk_policy_exception_policy, O_RDONLY);
-			if (fd != EOF) {
-				FILE *fp =
-				open_write(proc_policy_exception_policy);
-				if (fp) {
-					copy_fd_to_fp(fd, fp);
-					fclose(fp);
-				}
-				close(fd);
-			}
-			fd = open2(base_policy_domain_policy, O_RDONLY);
-			if (fd != EOF) {
-				FILE *fp =
-					open_write(proc_policy_domain_policy);
-				if (fp) {
-					copy_fd_to_fp(fd, fp);
-					fclose(fp);
-				}
-				close(fd);
-			}
-			fd = open2(disk_policy_domain_policy, O_RDONLY);
-			if (fd != EOF) {
-				FILE *fp =
-					open_write(proc_policy_domain_policy);
-				if (fp) {
-					copy_fd_to_fp(fd, fp);
-					fclose(fp);
-				}
-				close(fd);
-			}
-			fd = open2(base_policy_profile, O_RDONLY);
-			if (fd != EOF) {
-				FILE *fp = open_write(proc_policy_profile);
-				if (fp) {
-					copy_fd_to_fp(fd, fp);
-					fclose(fp);
-				}
-				close(fd);
-			}
-			fd = open2(disk_policy_profile, O_RDONLY);
-			if (fd != EOF) {
-				FILE *fp = open_write(proc_policy_profile);
-				if (fp) {
-					copy_fd_to_fp(fd, fp);
-					fclose(fp);
-				}
-				close(fd);
-			}
-			fd = open2(base_policy_manager, O_RDONLY);
-			if (fd != EOF) {
-				FILE *fp = open_write(proc_policy_manager);
-				if (fp) {
-					copy_fd_to_fp(fd, fp);
-					fclose(fp);
-				}
-				close(fd);
-			}
-			fd = open2(disk_policy_manager, O_RDONLY);
-			if (fd != EOF) {
-				FILE *fp = open_write(proc_policy_manager);
-				if (fp) {
-					copy_fd_to_fp(fd, fp);
-					fclose(fp);
-				}
-				close(fd);
-			}
-		}
+		close(fd);
 	} else {
 		if (chdir(proc_policy_dir)) {
 			fprintf(stderr,
@@ -2381,7 +2313,7 @@
 		timeout(1000);
 	}
 	while (current_screen < MAXSCREEN) {
-		if (!offline_mode) {
+		if (!network_mode) {
 			if (current_screen == SCREEN_DOMAIN_LIST &&
 			    access(proc_policy_domain_policy, F_OK))
 				current_screen = SCREEN_SYSTEM_LIST;
@@ -2403,63 +2335,6 @@
 	move(0, 0);
 	refresh();
 	endwin();
-	if (offline_mode && !readonly_mode) {
-		time_t now = time(NULL);
-		char *filename = make_filename("system_policy", now);
-		if (move_proc_to_file(proc_policy_system_policy,
-				      base_policy_system_policy, filename)) {
-			if (is_identical_file("system_policy.conf", filename)) {
-				unlink(filename);
-			} else {
-				unlink("system_policy.conf");
-				symlink(filename, "system_policy.conf");
-			}
-		}
-		filename = make_filename("exception_policy", now);
-		if (move_proc_to_file(proc_policy_exception_policy,
-				      base_policy_exception_policy, filename)) {
-			if (is_identical_file("exception_policy.conf",
-					      filename)) {
-				unlink(filename);
-			} else {
-				unlink("exception_policy.conf");
-				symlink(filename, "exception_policy.conf");
-			}
-		}
-		clear_domain_policy(&dp);
-		filename = make_filename("domain_policy", now);
-		if (save_domain_policy_with_diff(&dp, &bp,
-						 proc_policy_domain_policy,
-						 base_policy_domain_policy,
-						 filename)) {
-			if (is_identical_file("domain_policy.conf", filename)) {
-				unlink(filename);
-			} else {
-				unlink("domain_policy.conf");
-				symlink(filename, "domain_policy.conf");
-			}
-		}
-		filename = make_filename("profile", now);
-		if (move_proc_to_file(proc_policy_profile, base_policy_profile,
-				      filename)) {
-			if (is_identical_file("profile.conf", filename)) {
-				unlink(filename);
-			} else {
-				unlink("profile.conf");
-				symlink(filename, "profile.conf");
-			}
-		}
-		filename = make_filename("manager", now);
-		if (move_proc_to_file(proc_policy_manager, base_policy_manager,
-				      filename)) {
-			if (is_identical_file("manager.conf", filename)) {
-				unlink(filename);
-			} else {
-				unlink("manager.conf");
-				symlink(filename, "manager.conf");
-			}
-		}
-	}
 	clear_domain_policy(&bp);
 	clear_domain_policy(&dp);
 	return 0;
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy_offline.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy_offline.c	(revision 2226)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy_offline.c	(working copy)
@@ -1,172 +0,0 @@
-/*
- * editpolicy_offline.c
- *
- * TOMOYO Linux's utilities.
- *
- * Copyright (C) 2005-2009  NTT DATA CORPORATION
- *
- * Version: 1.6.7-rc   2009/03/04
- *
- */
-#include "ccstools.h"
-
-struct misc_policy {
-	const struct path_info **list;
-	int list_len;
-};
-
-/* Prototypes */
-
-static void handle_misc_policy(struct misc_policy *mp, FILE *fp,
-			       _Bool is_write);
-
-/* Utility functions */
-
-static void handle_misc_policy(struct misc_policy *mp, FILE *fp, _Bool is_write)
-{
-	int i;
-	if (!is_write)
-		goto read_policy;
-	while (freadline(fp)) {
-		const struct path_info *cp;
-		_Bool is_delete;
-		if (!shared_buffer[0])
-			continue;
-		is_delete = str_starts(shared_buffer, "delete ");
-		cp = savename(shared_buffer);
-		if (!cp)
-			out_of_memory();
-		if (!is_delete)
-			goto append_policy;
-		for (i = 0; i < mp->list_len; i++)
-			/* Faster comparison, for they are savename'd. */
-			if (mp->list[i] == cp)
-				break;
-		if (i < mp->list_len)
-			for (mp->list_len--; i < mp->list_len; i++)
-				mp->list[i] = mp->list[i + 1];
-		continue;
-append_policy:
-		for (i = 0; i < mp->list_len; i++)
-			/* Faster comparison, for they are savename'd. */
-			if (mp->list[i] == cp)
-				break;
-		if (i < mp->list_len)
-			continue;
-		mp->list = realloc(mp->list, (mp->list_len + 1)
-				   * sizeof(const struct path_info *));
-		if (!mp->list)
-			out_of_memory();
-		mp->list[mp->list_len++] = cp;
-	}
-	return;
-read_policy:
-	for (i = 0; i < mp->list_len; i++)
-		fprintf(fp, "%s\n", mp->list[i]->name);
-}
-
-/* Variables */
-
-int persistent_fd = EOF;
-
-/* Main functions */
-
-void send_fd(char *data, int *fd)
-{
-	struct msghdr msg;
-	struct iovec iov = { data, strlen(data) };
-	char cmsg_buf[CMSG_SPACE(sizeof(int))];
-	struct cmsghdr *cmsg = (struct cmsghdr *) cmsg_buf;
-	memset(&msg, 0, sizeof(msg));
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-	msg.msg_control = cmsg_buf;
-	msg.msg_controllen = sizeof(cmsg_buf);
-	cmsg->cmsg_level = SOL_SOCKET;
-	cmsg->cmsg_type = SCM_RIGHTS;
-	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
-	msg.msg_controllen = cmsg->cmsg_len;
-	memmove(CMSG_DATA(cmsg), fd, sizeof(int));
-	sendmsg(persistent_fd, &msg, 0);
-	close(*fd);
-}
-
-void editpolicy_offline_daemon(void)
-{
-	struct misc_policy mp[4];
-	struct domain_policy dp;
-	memset(&dp, 0, sizeof(dp));
-	memset(&mp, 0, sizeof(mp));
-	get();
-	find_or_assign_new_domain(&dp, ROOT_NAME, false, false);
-	while (true) {
-		FILE *fp;
-		struct msghdr msg;
-		struct iovec iov = { shared_buffer, sizeof(shared_buffer) - 1 };
-		char cmsg_buf[CMSG_SPACE(sizeof(int))];
-		struct cmsghdr *cmsg = (struct cmsghdr *) cmsg_buf;
-		memset(&msg, 0, sizeof(msg));
-		msg.msg_iov = &iov;
-		msg.msg_iovlen = 1;
-		msg.msg_control = cmsg_buf;
-		msg.msg_controllen = sizeof(cmsg_buf);
-		memset(shared_buffer, 0, sizeof(shared_buffer));
-		errno = 0;
-		if (recvmsg(persistent_fd, &msg, 0) <= 0)
-			break;
-		cmsg = CMSG_FIRSTHDR(&msg);
-		if (!cmsg)
-			break;
-		if (cmsg->cmsg_level == SOL_SOCKET &&
-		    cmsg->cmsg_type == SCM_RIGHTS &&
-		    cmsg->cmsg_len == CMSG_LEN(sizeof(int))) {
-			const int fd = *(int *) CMSG_DATA(cmsg);
-			fp = fdopen(fd, "w+");
-			if (!fp) {
-				close(fd);
-				continue;
-			}
-		} else {
-			break;
-		}
-		if (str_starts(shared_buffer, "POST ")) {
-			if (!strcmp(shared_buffer, proc_policy_domain_policy))
-				handle_domain_policy(&dp, fp, true);
-			else if (!strcmp(shared_buffer,
-					 proc_policy_exception_policy))
-				handle_misc_policy(&mp[0], fp, true);
-			else if (!strcmp(shared_buffer,
-					 proc_policy_system_policy))
-				handle_misc_policy(&mp[1], fp, true);
-			else if (!strcmp(shared_buffer, proc_policy_profile))
-				handle_misc_policy(&mp[2], fp, true);
-			else if (!strcmp(shared_buffer, proc_policy_manager))
-				handle_misc_policy(&mp[3], fp, true);
-		} else if (str_starts(shared_buffer, "GET ")) {
-			if (!strcmp(shared_buffer, proc_policy_domain_policy))
-				handle_domain_policy(&dp, fp, false);
-			else if (!strcmp(shared_buffer,
-					 proc_policy_exception_policy))
-				handle_misc_policy(&mp[0], fp, false);
-			else if (!strcmp(shared_buffer,
-					 proc_policy_system_policy))
-				handle_misc_policy(&mp[1], fp, false);
-			else if (!strcmp(shared_buffer, proc_policy_profile))
-				handle_misc_policy(&mp[2], fp, false);
-			else if (!strcmp(shared_buffer, proc_policy_manager))
-				handle_misc_policy(&mp[3], fp, false);
-		}
-		fclose(fp);
-	}
-	put();
-	clear_domain_policy(&dp);
-	{
-		int i;
-		for (i = 0; i < 3; i++) {
-			free(mp[i].list);
-			mp[i].list = NULL;
-			mp[i].list_len = 0;
-		}
-	}
-	_exit(0);
-}
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.c	(revision 2226)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.c	(working copy)
@@ -5,7 +5,7 @@
  *
  * Copyright (C) 2005-2009  NTT DATA CORPORATION
  *
- * Version: 1.6.7-rc   2009/03/05
+ * Version: 1.6.7-rc   2009/03/06
  *
  */
 #include "ccstools.h"
@@ -672,35 +672,6 @@
 	return ptr ? &ptr->entry : NULL;
 }
 
-
-FILE *open_read(const char *filename)
-{
-	if (offline_mode) {
-		char request[1024];
-		int fd[2];
-		FILE *fp;
-		if (socketpair(PF_UNIX, SOCK_STREAM, 0, fd)) {
-			fprintf(stderr, "socketpair()\n");
-			exit(1);
-		}
-		if (shutdown(fd[0], SHUT_WR))
-			goto out;
-		fp = fdopen(fd[0], "r");
-		if (!fp)
-			goto out;
-		memset(request, 0, sizeof(request));
-		snprintf(request, sizeof(request) - 1, "GET %s", filename);
-		send_fd(request, &fd[1]);
-		return fp;
-out:
-		close(fd[1]);
-		close(fd[0]);
-		exit(1);
-	} else {
-		return fopen(filename, "r");
-	}
-}
-
 _Bool move_proc_to_file(const char *src, const char *base, const char *dest)
 {
 	FILE *proc_fp;
@@ -869,10 +840,10 @@
 	}
 	read_domain_policy(dp, proc);
 	if (!access(base, R_OK)) {
-		_Bool om = offline_mode;
-		offline_mode = false;
+		_Bool om = network_mode;
+		network_mode = false;
 		read_domain_policy(bp, base);
-		offline_mode = om;
+		network_mode = om;
 	}
 
 	for (base_index = 0; base_index < bp->list_len; base_index++) {
@@ -1132,8 +1103,19 @@
 	if (!buffer_locked)
 		out_of_memory();
 	memset(shared_buffer, 0, sizeof(shared_buffer));
-	if (!fgets(shared_buffer, sizeof(shared_buffer) - 1, fp))
-		return false;
+	if (network_mode) {
+		int i;
+		for (i = 0; i < sizeof(shared_buffer) - 1; i++) {
+			if (fread(shared_buffer + i, 1, 1, fp) != 1 ||
+			    !shared_buffer[i])
+				return false;
+			if (shared_buffer[i] == '\n')
+				break;
+		}
+	} else {
+		if (!fgets(shared_buffer, sizeof(shared_buffer) - 1, fp))
+			return false;
+	}
 	cp = strchr(shared_buffer, '\n');
 	if (!cp)
 		return false;
@@ -1224,7 +1206,7 @@
 	else if (!strcmp(argv0, "findtemp"))
 		ret = findtemp_main(argc, argv);
 	else if (!strcmp(argv0, "editpolicy") ||
-		 !strcmp(argv0, "editpolicy_offline"))
+		 !strcmp(argv0, "editpolicy_network"))
 		ret = editpolicy_main(argc, argv);
 	else if (!strcmp(argv0, "checkpolicy"))
 		ret = checkpolicy_main(argc, argv);
@@ -1250,7 +1232,7 @@
 	 * You should use either "symbolic links with 'alias' directive" or
 	 * "hard links".
 	 */
-	printf("ccstools version 1.6.7-rc build 2009/03/05\n");
+	printf("ccstools version 1.6.7-rc build 2009/03/06\n");
 	fprintf(stderr, "Function %s not implemented.\n", argv0);
 	return 1;
 }
Index: trunk/1.6.x/ccs-tools/ccstools/Makefile
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/Makefile	(revision 2226)
+++ trunk/1.6.x/ccs-tools/ccstools/Makefile	(working copy)
@@ -4,7 +4,7 @@
 
 MISC_FILES = makesyaoranconf candy chaplet checktoken gettoken groovy honey mailauth proxy timeauth falsh ccs-notifyd force-logout audit-exec-param convert-exec-param
 
-ALIAS_LIST = ccs-auditd ccs-queryd ccstree checkpolicy editpolicy editpolicy_offline findtemp ld-watch loadpolicy pathmatch patternize savepolicy setlevel setprofile sortpolicy domainmatch
+ALIAS_LIST = ccs-auditd ccs-queryd ccstree checkpolicy editpolicy editpolicy_network findtemp ld-watch loadpolicy pathmatch patternize savepolicy setlevel setprofile sortpolicy domainmatch
 
 all: main misc
 
