<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>各種ツールのドキュメント</title>
<link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<p>Info: Version <a href="../1.3/">1.3</a> is available.</p>
<h1>各種ツールのドキュメント</h1>
<p style="text-align:right;">Last modified: $Date$</p>
<hr>
<h2><a name="administration_tool">＜＜システム管理者用ツール＞＞</a></h2>
<p>ほとんどのユーザはこの章と次の章で紹介されているツールだけで足りるはずである。</p>
<h3><a name="editpolicy">＜ポリシーエディタ　editpolicy＞</a></h3>
<p>現在のポリシーを /proc/ccs/policy/ ディレクトリから読み込み、編集を行う。</p>
<p>コマンドラインパラメータとして s e d のいずれかの文字を指定することで最初に表示される画面を指定できる。省略すると最初にドメイン一覧表示画面が表示される。</p>
<p>以下のキーを使用して操作する。</p>

<p>＜全画面共通のキー＞</p>
<table border="1">
<tr><td>q/Q</td><td>終了する。</td></tr>
<tr><td>r/R</td><td>最新の情報に更新する。</td></tr>
<tr><td>↑</td><td>１行上へ移動する。</td></tr>
<tr><td>↓</td><td>１行下へ移動する。</td></tr>
<tr><td>PageUp</td><td>１画面上へ移動する。</td></tr>
<tr><td>PageDown</td><td>１画面下へ移動する。</td></tr>
</table>

<p>＜システムポリシー編集画面でのみ有効なキー＞</p>
<table border="1">
<tr><td>a/A</td><td>エントリを追加する。</td></tr>
<tr><td>d/D</td><td>エントリを削除する。</td></tr>
<tr><td>Tab</td><td>例外ポリシー編集画面へ移動する。</td></tr>
</table>

<p>＜例外ポリシー編集画面でのみ有効なキー＞</p>
<table border="1">
<tr><td>a/A</td><td>エントリを追加する。</td></tr>
<tr><td>d/D</td><td>エントリを削除する。</td></tr>
<tr><td>Tab</td><td>ドメイン一覧表示画面へ移動する。</td></tr>
</table>

<p>＜ドメイン一覧表示画面でのみ有効なキー＞</p>
<table border="1">
<tr><td>a/A</td><td>ドメインを作成する。</td></tr>
<tr><td>d/D</td><td>選択中のドメイン以下を削除する。</td></tr>
<tr><td>Tab</td><td>システムポリシー編集画面へ移動する。</td></tr>
<tr><td>Enter</td><td>選択中のドメインに対するアクセス許可編集画面へ移動する。</td></tr>
<tr><td>@</td><td>ドメインを検索する。</td></tr>
<tr><td>←</td><td>逆方向へドメインを検索する。</td></tr>
<tr><td>→</td><td>順方向へドメインを検索する。</td></tr>
</table>

<p>＜ドメインに対するアクセス許可編集画面でのみ有効なキー＞</p>
<table border="1">
<tr><td>Enter</td><td>ドメイン一覧表示画面に戻る。</td></tr>
<tr><td>a/A</td><td>アクセス許可を追加する。</td></tr>
<tr><td>d/D</td><td>アクセス許可を削除する。</td></tr>
</table>

<p>このプログラムはファイル名を記憶するメモリ領域を節約するために、初出のファイル名を動的メモリに保存して、以後、同名のファイル名が現れた場合にはそのメモリのポインタを返すようにしている。そのため、この動的メモリはプログラムが終了するまで解放されない。</p>
<p>同じ事が TOMOYO Linux カーネルにも当てはまる。カーネルがファイル名を記憶しておくために割り当てたメモリは解放されない。そのため、永遠に学習モードで稼働していると、システムがメモリ不足に陥る可能性があるので注意が必要である。 ただし、実際のドメインの数やアクセス許可を与えるファイルの数にもよるが、 TOMOYO Linux カーネルが消費するＲＡＭはほとんどの環境では１ＭＢ以内であろう。</p>
<p>カーネルがアクセスログを記憶するためのＲＡＭは動的に確保され、ユーザランドプログラムから読み出され次第そのＲＡＭは解放される。カーネルが記憶可能なアクセスログの件数には上限を設けているため、アクセスログを読み出さなくともカーネルが全てのＲＡＭを消費してしまうことが無いようになっている。</p>
<h3><a name="loadpolicy">＜ポリシー再読み込みプログラム　loadpolicy＞</a></h3>
<p>ディスク上のポリシーをカーネルに読み込む。</p>
<p>以下のコマンドラインオプションを指定可能である。</p>
<ul>
<li>s ・・・システム用ポリシーを再読み込みする。
<li>e ・・・例外用ポリシーを再読み込みする。
<li>d ・・・ドメイン用ポリシーを再読み込みする。
<li>a ・・・上記３種類のポリシーを再読み込みする。
<li>f ・・・ディスク上のポリシーを再読み込みする前に、メモリ上のポリシーを消去する。
</ul>
<h3><a name="setlevel">＜制御レベル変更プログラム　setlevel＞</a></h3>
<p>現在の制御レベルの変更（ /proc/ccs/status への書き込み）を行う。</p>
<p>コマンドラインパラメータで制御レベルを指定する。コマンドラインパラメータの有無に関係なく現在の制御レベルを表示する。</p>
<p>/proc/ccs/ への書き込みは /root/security/manager.txt に記述されたプログラムのみが行える。ポリシー策定時はシェルや /bin/cat 等も指定しても構わないが、システム運用時は loadpolicy editpolicy setlevel だけを指定するべきである。</p>
<h3><a name="savepolicy">＜ポリシー保存プログラム　savepolicy＞</a></h3>
<p>カーネル内のポリシーをディスクに保存する。</p>
<p>以下のコマンドラインオプションを指定可能である。</p>
<ul>
<li>s ・・・システム用ポリシーを保存する。
<li>e ・・・例外用ポリシーを保存する。
<li>d ・・・ドメイン用ポリシーを保存する。
<li>a ・・・上記３種類のポリシーを保存する。
<li>f ・・・ディスク上のポリシーとメモリ上のポリシーが同一内容であっても保存する。
</ul>
<h3><a name="makesyaoranconf">＜syaoran 用設定ファイル作成プログラム　makesyaoranconf＞</a></h3>
<p>/dev 用のファイルシステム SYAORAN 用の設定ファイルである syaoran.conf を作成する。ルートファイルシステムが読み込み専用の場合や /dev ディレクトリ内のデバイスファイルの改ざんを防止したい場合に使用する。</p>
<p>syaoran.conf に記録されていないファイルは作成できないので、動的にデバイスファイルが作成される環境の場合はこのプログラムを実行する前に全てのデバイスを接続し、必要なデバイスファイルが全て syaoran.conf に記録されるように注意する。</p>
<h3><a name="ccs-auditd">＜アクセスログ保存デーモン　ccs-auditd＞</a></h3>
<p>/proc/ccs/info/grant_log および /proc/ccs/info/reject_log の内容をコマンドラインで指定された場所に保存する。</p>
<p>コマンドラインの最初のパラメータがアクセス許可ログを保存するファイル名、２番目のパラメータがアクセス拒否ログを保存するファイル名である。ファイル名として /dev/null を指定しても良い。アクセスログをファイルに保存する必要が無い場合は実行する必要はない。</p>
<p>デーモンとして動作するので、 RedHat Linux の場合、 /etc/rc.d/rc.local で起動すればよい。 /proc/ccs/info/grant_log および /proc/ccs/info/reject_log に保持できる件数は、プロファイルの「MAX_GRANT_LOG=数値」および「MAX_REJECT_LOG=数値」という行で指定できる。</p>
<h3><a name="findtemp">＜テンポラリパス検出プログラム　findtemp＞</a></h3>
<p>標準入力からドメイン用ポリシーの内容を受け取り、書き込み許可を含むパーミッションに対してパス名が存在するかどうかをチェックし、存在しなかったパス名を表示する。</p>
<p>存在しなかったパス名はテンポラリなパス名として使用されている可能性が高いので、同様のパス名から規則性を判断して /root/security/exception_policy.txt および /proc/ccs/policy/exception_policy にパターン化したパス名を追加していく。</p>
<p>コマンドラインパラメータとして --all が指定された場合、全ての存在しないパス名を表示する。</p>
<p>/root/security/domain_policy.txt または /proc/ccs/policy/domain_policy の内容をリダイレクトまたはパイプを使用して標準入力へ渡せばよい。</p>
<h3><a name="ld-watch">＜ライブラリファイルのパス名更新プログラム　ld-watch＞</a></h3>
<p>/etc/ld.so.cache に登録されている共有ライブラリファイルのパス名の変化を検出し、自動的に allow_read キーワードを使って例外ポリシーに登録する。</p>
<p>このプログラムをソフトウェアのアップデート時に実行しておくことで、共有ライブラリファイルのパス名が変化したために共有ライブラリファイルへアクセスできないことが原因でプログラムの起動に失敗するというエラーを回避することができる。</p>
<h3><a name="ccs-queryd">＜遅延強制モード用アクセス承認プログラム　ccs-queryd＞</a></h3>
<p>ポリシー違反を検出し、要求されたアクセスの内容を表示する。管理者は、その内容の妥当性を判断して許可（あるいは許可およびポリシーへの追加）あるいは拒否をシステムに伝えることができる。</p>
<p>このプログラムをソフトウェアのアップデート時に実行しておくことで、アクセス許可の不足によるエラーを回避することができる。</p>
<p>無条件に要求されたアクセスを許可しないこと。ポリシー違反の原因はパッケージの更新によって発生するものとは限らず、攻撃者による悪意ある要求の可能性もある。もし、攻撃者による悪意ある要求に対して許可を与えてしまった場合、システムに侵入されることになる。</p>
<p>このプログラムを使うには、 /proc/ccs/status の「MAX_ENFORCE_GRACE=数値」という行に適切な最大遅延時間（秒）を指定する必要がある。</p>
<hr>
<h2><a name="authentication_tool">＜＜ログイン認証強化用ツール＞＞</a></h2>
<p>この章で説明しているプログラムは、ログイン認証の強化を行う場合のみ使用する。</p>
<h3><a name="falsh">＜ログイン認証用機能限定シェル　falsh＞</a></h3>
<p>kill 等の内部コマンドを持たないシェルである。 /etc/passwd でログインシェルとして指定する。不正ログイン対策として追加のログイン認証を行う場合のみ使用する。</p>
<p>追加のログイン認証を行うためのプログラムは自分で作成することを推奨する。以下のサンプルプログラムをそのまま使用してはいけない。</p>
<h3><a name="honey">＜タイミング付きパスワード認証のサンプルプログラム　honey＞</a></h3>
<p>正しいタイミングで正しいパスワードを入力しないと認証が失敗する。通常の認証ではパスワードを入力するタイミングはチェックしないが、このプログラムではタイミングもチェックすることで、総当り攻撃を防止する。</p>
<h3><a name="candy">＜時間制限付きパスワード認証のサンプルプログラム　candy＞</a></h3>
<p>親プロセスが起動してから１０秒以内に起動して正しいパスワードを入力しないと認証が失敗する。通常の認証では、認証を開始するまでの時間制限を設けていないが、このプログラムでは一定時間内に認証を開始しないと認証が成功しないようにすることで、総当り攻撃を防止する。</p>
<h3><a name="groovy">＜ロックファイルの有無を用いた認証を行うサンプルプログラム　groovy＞</a></h3>
<p>パスワードを入力するためのプロンプトが表示されるが、パスワードの入力内容はチェックせず、 /tmp/.lockme というファイルの有無で認証を行う。普段はロックされた状態にしておくことで、総当り攻撃を防止する。このプログラムはデモ用であり、攻撃者が一目で正解だと判るようなファイル名を使用している。利用する場合は必ずカスタマイズすること。</p>
<h3><a name="checktoken">＜トークンを用いた認証を行うサンプルプログラム　gettoken／checktoken＞</a></h3>
<p>これらのプログラムは時間同期方式でトークンを生成する。 gettoken が生成したトークンを checktoken に渡すことで認証が成功するようになっている。これらはデモ用プログラムであり、トークンの生成アルゴリズムも貧弱である。利用する場合は必ずカスタマイズすること。</p>
<h3><a name="chaplet">＜チャレンジ・ハンドシェイク型の認証を行うサンプルプログラム　chaplet＞</a></h3>
<p>このプログラムを実行すると、チャレンジとして文字列が表示される。表示された文字列の中から、レスポンスとして数字のみを抽出したものを入力することで認証が成功する。このプログラムはデモ用であり、アルゴリズムが単純すぎる。利用する場合は必ずカスタマイズすること。</p>
<hr>
<h2><a name="looproot_tool">＜＜読み込み専用化支援ツール＞＞</a></h2>
<p>この章で説明しているプログラムは、ルートファイルシステムを読み込み専用で運用する場合のみ使用する。</p>
<h3><a name="remount_rootfs">＜条件付再マウントプログラム　remount_rootfs＞</a></h3>
<p>ルートファイルシステムを読み書きモードで再マウントし、スワップパーティションをマウントする。また、 /initrd/ にマウントされた initrd.img を強制的にアンマウントする。</p>
<p>カーネルのコマンドラインに readonly という文字列が含まれていた場合はルートファイルシステムを読み書きモードで再マウントしない。また、 noswap という文字列が含まれていた場合はスワップパーティションをマウントしない。</p>
<h3><a name="initrd-loop.img">＜ループバックマウント専用初期RAMディスク　initrd-loop.img＞</a></h3>
<p>ルートファイルシステムのループバックマウントを行うための linuxrc を含んだ初期RAMディスクである。ルートファイルシステムがループバックマウントで動作するイメージファイルの場合のみ使用する。ループバックマウントは、このプログラムを使用せずとも標準の nash スクリプトで実現できるが、 nash スクリプトの場合はエラーハンドラが存在しないため、カーネルパニックになるまで停止できない。このプログラムでは、エラーが発生した時点で停止するようになっている。</p>
<p>置き換える前の linuxrc （ nash スクリプト）が linuxrc.org という名前で存在する場合、それを読み込み、 insmod または sleep で始まる行を実行する。 insmod は外部コマンドを使用するので、 initrd.img の中に含めておく必要がある。ただし、 insmod を実行するために共有ライブラリファイルを必要とする場合、 initrd.img が大きくなってしまうので、 initrd.img で組み込むべきモジュールはカーネルコンパイル時にビルトインしてしまうことを推奨する。</p>
<p>ループバックマウントしたイメージファイルの中に /.linuxrc というファイルが存在する場合、それを実行する。</p>
<p>イメージファイルの場所はカーネルのコマンドラインから ROOTIMG= で指定する。デフォルトは /rootimg である。</p>
<p>イメージファイルを含むデバイスは root= で指定する。ただし、 /dev/sda のようにデバイスファイル名で指定する必要がある。（ nash ではないので root=LABEL=/ という指定は認識できない。）</p>
<p>イメージファイルのファイルシステムタイプは IMAGE= で指定する。また、イメージファイルを含むデバイスのファイルシステムタイプは CONTAINER= で指定する。なお、ファイルシステムタイプが ext2 ext3 iso9660 vfat reiserfs xfs jfs のいずれか場合は自動認識するので省略できる。</p>
<hr>
<h2><a name="miniroot_tool">＜＜カスタムルートファイルシステム作成支援ツール＞＞</a></h2>
<p>この章で説明しているプログラムは、必要最低限のファイルを含む最小サイズのルートファイルシステムを作成する場合のみ使用する。</p>
<h3><a name="makelink">＜ハードリンク作成プログラム　makelink＞</a></h3>
<p>標準入力からハードリンクすべきファイルの一覧を受け取り、ハードリンクを作成する。これは、コピー元においてハードリンクされていたファイルを、コピー先においてもハードリンクされた状態を実現するために使用する。ハードリンクを一覧表示するプログラムと作成するプログラムを分離しているのは、コピー先がコピー元の一部に含まれていると都合が悪い場合があったり、コピー元とコピー先が別マシンであったりするような場合に対処するためである。</p>
<h3><a name="dumplink">＜ハードリンク一覧表示プログラム　dumplink＞</a></h3>
<p>ハードリンクされたファイルの一覧を表示する。このプログラムの出力をファイルに保存後、 makelink に渡す。</p>
<h3><a name="makesymlink">＜シンボリックリンク作成プログラム　makesymlink＞</a></h3>
<p>標準入力からシンボリックリンクすべきファイルの一覧を受け取り、シンボリックリンクを作成する。シンボリックリンクとハードリンクが相互に依存している場合があるので、ハードリンク作成プログラムと交互に使用する。</p>
<h3><a name="dumpsymlink">＜シンボリックリンク一覧表示プログラム　dumpsymlink＞</a></h3>
<p>シンボリックリンクされたファイルの一覧を表示する。このプログラムの出力をファイルに保存後、 makesymlink に渡す。</p>
<hr>
<p><a href="index.html#manual">目次へ戻る</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="sflogo.php" title="SourceForge.jp"></a></p>
</body>
</html>
