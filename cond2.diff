Index: trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h	(revision 1878)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h	(working copy)
@@ -33,7 +33,6 @@
 #define CCS_PROFILE              10
 #define CCS_QUERY                11
 #define CCS_MANAGER              12
-#define CCS_UPDATESCOUNTER       13
-#define CCS_EXECUTE_HANDLER      14
+#define CCS_EXECUTE_HANDLER      13
 
 #endif
Index: trunk/1.6.x/ccs-patch/include/linux/ccs_common.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(revision 1878)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(working copy)
@@ -213,6 +213,8 @@
 	uid_t uid;
 	gid_t gid;
 	ino_t ino;
+	mode_t mode;
+	dev_t rdev;
 };
 
 /* Structure for attribute checks in addition to pathname checks. */
@@ -508,6 +510,40 @@
 #define IP_RECORD_TYPE_IPv4          1
 #define IP_RECORD_TYPE_IPv6          2
 
+/* Structure for "deny_unmount" directive. */
+struct no_umount_entry {
+	struct acl_info head; /* type = TYPE_NO_UMOUNT_ACL */
+	const struct path_info *dir;
+};
+
+/* Structure for "allow_mount" directive. */
+struct mount_entry {
+	struct acl_info head; /* type = TYPE_MOUNT_ACL */
+	const struct path_info *dev_name;
+	const struct path_info *dir_name;
+	const struct path_info *fs_type;
+	unsigned long flags;
+};
+
+/* Structure for "allow_chroot" directive. */
+struct chroot_entry {
+	struct acl_info head; /* type = TYPE_CHROOT_ACL */
+	const struct path_info *dir;
+};
+
+/* Structure for "allow_pivot_root" directive. */
+struct pivot_root_entry {
+	struct acl_info head; /* type = TYPE_PIVOT_ROOT_ACL */
+	const struct path_info *old_root;
+	const struct path_info *new_root;
+};
+
+/* Index numbers for Access Controls. See include/linux/tomoyo.h */
+#define TYPE_NO_UMOUNT_ACL          10
+#define TYPE_MOUNT_ACL              11
+#define TYPE_CHROOT_ACL             12
+#define TYPE_PIVOT_ROOT_ACL         13
+
 /* Keywords for ACLs. */
 #define KEYWORD_ADDRESS_GROUP             "address_group "
 #define KEYWORD_AGGREGATOR                "aggregator "
@@ -640,8 +676,6 @@
 bool ccs_read_aggregator_policy(struct ccs_io_buffer *head);
 /* Read "alias" entry in exception policy. */
 bool ccs_read_alias_policy(struct ccs_io_buffer *head);
-/* Read "allow_chroot" entry in system policy. */
-bool ccs_read_chroot_policy(struct ccs_io_buffer *head);
 /*
  * Read "initialize_domain" and "no_initialize_domain" entry
  * in exception policy.
@@ -655,16 +689,10 @@
 bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head);
 /* Read "allow_env" entry in exception policy. */
 bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head);
-/* Read "allow_mount" entry in system policy. */
-bool ccs_read_mount_policy(struct ccs_io_buffer *head);
 /* Read "deny_rewrite" entry in exception policy. */
 bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head);
-/* Read "deny_unmount" entry in system policy. */
-bool ccs_read_no_umount_policy(struct ccs_io_buffer *head);
 /* Read "path_group" entry in exception policy. */
 bool ccs_read_path_group_policy(struct ccs_io_buffer *head);
-/* Read "allow_pivot_root" entry in system policy. */
-bool ccs_read_pivot_root_policy(struct ccs_io_buffer *head);
 /* Read "deny_autobind" entry in system policy. */
 bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head);
 /* Write domain policy violation warning message to console? */
@@ -690,6 +718,8 @@
 /* Create conditional part of an ACL entry. */
 const struct condition_list *
 ccs_find_or_assign_new_condition(char * const condition);
+/* Create conditional part for execute_handler process. */
+const struct condition_list *ccs_handler_cond(void);
 /* Add an ACL entry to domain's ACL list. */
 int ccs_add_domain_acl(struct domain_info *domain, struct acl_info *acl);
 /* Ask supervisor's opinion. */
@@ -736,7 +766,9 @@
 				const struct condition_list *condition,
 				const bool is_delete);
 /* Create "allow_chroot" entry in system policy. */
-int ccs_write_chroot_policy(char *data, const bool is_delete);
+int ccs_write_chroot_policy(char *data, struct domain_info *domain,
+			    const struct condition_list *condition,
+			    const bool is_delete);
 /*
  * Create "initialize_domain" and "no_initialize_domain" entry
  * in exception policy.
@@ -766,7 +798,9 @@
 /* Create "allow_env" entry in exception policy. */
 int ccs_write_globally_usable_env_policy(char *data, const bool is_delete);
 /* Create "allow_mount" entry in system policy. */
-int ccs_write_mount_policy(char *data, const bool is_delete);
+int ccs_write_mount_policy(char *data, struct domain_info *domain,
+			   const struct condition_list *condition,
+			   const bool is_delete);
 /* Create "allow_network" entry in domain policy. */
 int ccs_write_network_policy(char *data, struct domain_info *domain,
 			     const struct condition_list *condition,
@@ -774,13 +808,17 @@
 /* Create "deny_rewrite" entry in exception policy. */
 int ccs_write_no_rewrite_policy(char *data, const bool is_delete);
 /* Create "deny_unmount" entry in system policy. */
-int ccs_write_no_umount_policy(char *data, const bool is_delete);
+int ccs_write_no_umount_policy(char *data, struct domain_info *domain,
+			       const struct condition_list *condition,
+			       const bool is_delete);
 /* Create "path_group" entry in exception policy. */
 int ccs_write_path_group_policy(char *data, const bool is_delete);
 /* Create "file_pattern" entry in exception policy. */
 int ccs_write_pattern_policy(char *data, const bool is_delete);
 /* Create "allow_pivot_root" entry in system policy. */
-int ccs_write_pivot_root_policy(char *data, const bool is_delete);
+int ccs_write_pivot_root_policy(char *data, struct domain_info *domain,
+				const struct condition_list *condition,
+				const bool is_delete);
 /* Create "deny_autobind" entry in system policy. */
 int ccs_write_reserved_port_policy(char *data, const bool is_delete);
 /* Create "allow_signal" entry in domain policy. */
@@ -817,9 +855,6 @@
 /* Change "struct domain_info"->flags. */
 void ccs_set_domain_flag(struct domain_info *domain, const bool is_delete,
 			 const u8 flags);
-/* Update the policy change counter. */
-void ccs_update_counter(const unsigned char index);
-
 /* Check whether the basename of program and argv0 is allowed to differ. */
 int ccs_check_argv0_perm(struct ccs_request_info *r,
 			 const struct path_info *filename, const char *argv0);
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_env.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_env.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_env.c	(working copy)
@@ -83,7 +83,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
 
@@ -274,7 +273,7 @@
 		return error;
 	}
 	if (r->mode == 1 && ccs_check_domain_quota(r->domain))
-		update_env_entry(env, r->domain, NULL, false);
+		update_env_entry(env, r->domain, ccs_handler_cond(), false);
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_network.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_network.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_network.c	(working copy)
@@ -182,7 +182,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
 
@@ -643,7 +642,7 @@
 		update_network_entry(operation, is_ipv6 ?
 				     IP_RECORD_TYPE_IPv6 : IP_RECORD_TYPE_IPv4,
 				     NULL, address, address, port, port,
-				     r.domain, NULL, 0);
+				     r.domain, ccs_handler_cond(), 0);
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/sakura_chroot.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_chroot.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/sakura_chroot.c	(working copy)
@@ -21,28 +21,22 @@
 #include <linux/fs.h>
 #endif
 
-/* Structure for "allow_chroot" keyword. */
-struct chroot_entry {
-	struct list1_head list;
-	const struct path_info *dir;
-	bool is_deleted;
-};
-
-/* The list for "struct chroot_entry". */
-static LIST1_HEAD(chroot_list);
-
 /**
  * update_chroot_acl - Update "struct chroot_entry" list.
  *
  * @dir:       The name of directory.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int update_chroot_acl(const char *dir, const bool is_delete)
+static int update_chroot_acl(const char *dir, struct domain_info *domain,
+			     const struct condition_list *condition,
+			     const bool is_delete)
 {
-	struct chroot_entry *new_entry;
-	struct chroot_entry *ptr;
+	struct acl_info *ptr;
+	struct chroot_entry *acl;
 	const struct path_info *saved_dir;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
@@ -52,10 +46,18 @@
 	if (!saved_dir)
 		return -ENOMEM;
 	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &chroot_list, list) {
-		if (ptr->dir != saved_dir)
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if (ccs_acl_type1(ptr) != TYPE_CHROOT_ACL)
+                        continue;
+                if (ccs_get_condition_part(ptr) != condition)
+                        continue;
+                acl = container_of(ptr, struct chroot_entry, head);
+		if (acl->dir != saved_dir)
 			continue;
-		ptr->is_deleted = is_delete;
+		if (is_delete)
+                        ptr->type |= ACL_DELETED;
+                else
+                        ptr->type &= ~ACL_DELETED;
 		error = 0;
 		goto out;
 	}
@@ -63,16 +65,14 @@
 		error = -ENOENT;
 		goto out;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
+	acl = ccs_alloc_acl_element(TYPE_CHROOT_ACL, condition);
+	if (!acl)
 		goto out;
-	new_entry->dir = saved_dir;
-	list1_add_tail_mb(&new_entry->list, &chroot_list);
-	error = 0;
+	acl->dir = saved_dir;
+	error = ccs_add_domain_acl(domain, &acl->head);
 	printk(KERN_CONT "%sAllow chroot() to %s\n", ccs_log_level, dir);
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 	return error;
 }
 
@@ -102,7 +102,8 @@
 	if (exename)
 		ccs_free(exename);
 	if (r->mode == 1 && root_name)
-		update_chroot_acl(root_name, false);
+		update_chroot_acl(root_name, r->domain, ccs_handler_cond(),
+				  false);
 	return error;
 }
 
@@ -141,12 +142,18 @@
 		dir.name = root_name;
 		ccs_fill_path_info(&dir);
 		if (dir.is_dir) {
-			struct chroot_entry *ptr;
-			list1_for_each_entry(ptr, &chroot_list, list) {
-				if (ptr->is_deleted)
+			struct acl_info *ptr;
+			list1_for_each_entry(ptr, &r.domain->acl_info_list,
+					     list) {
+				struct chroot_entry *acl;
+				if (ccs_acl_type2(ptr) != TYPE_NO_UMOUNT_ACL)
 					continue;
-				if (!ccs_path_matches_pattern(&dir, ptr->dir))
+				acl = container_of(ptr, struct chroot_entry,
+						   head);
+				if (!ccs_path_matches_pattern(&dir, acl->dir))
 					continue;
+				if (!ccs_check_condition(&r, ptr))
+					continue;
 				error = 0;
 				break;
 			}
@@ -164,35 +171,15 @@
  * ccs_write_chroot_policy - Write "struct chroot_entry" list.
  *
  * @data:      String to parse.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL. 
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_chroot_policy(char *data, const bool is_delete)
+int ccs_write_chroot_policy(char *data, struct domain_info *domain,
+			    const struct condition_list *condition,
+			    const bool is_delete)
 {
-	return update_chroot_acl(data, is_delete);
+	return update_chroot_acl(data, condition, domain, is_delete);
 }
-
-/**
- * ccs_read_chroot_policy - Read "struct chroot_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_read_chroot_policy(struct ccs_io_buffer *head)
-{
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &chroot_list) {
-		struct chroot_entry *ptr;
-		ptr = list1_entry(pos, struct chroot_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		if (!ccs_io_printf(head, KEYWORD_ALLOW_CHROOT "%s\n",
-				   ptr->dir->name))
-			goto out;
-	}
-	return true;
- out:
-	return false;
-}
Index: trunk/1.6.x/ccs-patch/fs/sakura_pivot.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_pivot.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/sakura_pivot.c	(working copy)
@@ -21,31 +21,24 @@
 #include <linux/fs.h>
 #endif
 
-/* Structure for "allow_pivot_root" keyword. */
-struct pivot_root_entry {
-	struct list1_head list;
-	const struct path_info *old_root;
-	const struct path_info *new_root;
-	bool is_deleted;
-};
-
-/* The list for "struct pivot_root_entry". */
-static LIST1_HEAD(pivot_root_list);
-
 /**
  * update_pivot_root_acl - Update "struct pivot_root_entry" list.
  *
  * @old_root:  The name of old root directory.
  * @new_root:  The name of new root directory.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
 static int update_pivot_root_acl(const char *old_root, const char *new_root,
+				 struct domain_info *domain,
+				 const struct condition_list *condition,
 				 const bool is_delete)
 {
-	struct pivot_root_entry *new_entry;
-	struct pivot_root_entry *ptr;
+	struct acl_info *ptr;
+	struct pivot_root_entry *acl;
 	const struct path_info *saved_old_root;
 	const struct path_info *saved_new_root;
 	static DEFINE_MUTEX(lock);
@@ -58,11 +51,19 @@
 	if (!saved_old_root || !saved_new_root)
 		return -ENOMEM;
 	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &pivot_root_list, list) {
-		if (ptr->old_root != saved_old_root ||
-		    ptr->new_root != saved_new_root)
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if (ccs_acl_type1(ptr) != TYPE_PIVOT_ROOT_ACL)
+                        continue;
+                if (ccs_get_condition_part(ptr) != condition)
+                        continue;
+                acl = container_of(ptr, struct pivot_root_entry, head);
+		if (acl->old_root != saved_old_root ||
+		    acl->new_root != saved_new_root)
 			continue;
-		ptr->is_deleted = is_delete;
+		if (is_delete)
+                        ptr->type |= ACL_DELETED;
+                else
+                        ptr->type &= ~ACL_DELETED;
 		error = 0;
 		goto out;
 	}
@@ -70,18 +71,16 @@
 		error = -ENOENT;
 		goto out;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
+	acl = ccs_alloc_acl_element(TYPE_PIVOT_ROOT_ACL, condition);
+	if (!acl)
 		goto out;
-	new_entry->old_root = saved_old_root;
-	new_entry->new_root = saved_new_root;
-	list1_add_tail_mb(&new_entry->list, &pivot_root_list);
-	error = 0;
+	acl->old_root = saved_old_root;
+	acl->new_root = saved_new_root;
+	error = ccs_add_domain_acl(domain, &acl->head);
 	printk(KERN_CONT "%sAllow pivot_root(%s, %s)\n", ccs_log_level,
 	       new_root, old_root);
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 	return error;
 }
 
@@ -124,20 +123,26 @@
 	new_root = ccs_realpath_from_dentry(new_path->dentry, new_path->mnt);
 #endif
 	if (old_root && new_root) {
-		struct path_info old_root_dir, new_root_dir;
+		struct path_info old_root_dir;
+		struct path_info new_root_dir;
 		old_root_dir.name = old_root;
 		ccs_fill_path_info(&old_root_dir);
 		new_root_dir.name = new_root;
 		ccs_fill_path_info(&new_root_dir);
 		if (old_root_dir.is_dir && new_root_dir.is_dir) {
-			struct pivot_root_entry *ptr;
-			list1_for_each_entry(ptr, &pivot_root_list, list) {
-				if (ptr->is_deleted)
+			struct acl_info *ptr;
+			list1_for_each_entry(ptr, &r.domain->acl_info_list,
+					     list) {
+				struct pivot_root_entry *acl;
+				if (ccs_acl_type2(ptr) != TYPE_PIVOT_ROOT_ACL)
 					continue;
+				acl = container_of(ptr, struct pivot_root_entry,
+						   head);
 				if (!ccs_path_matches_pattern(&old_root_dir,
-							      ptr->old_root) ||
+							      acl->old_root) ||
 				    !ccs_path_matches_pattern(&new_root_dir,
-							      ptr->new_root))
+							      acl->new_root) ||
+				    !ccs_check_condition(&r, ptr))
 					continue;
 				error = 0;
 				break;
@@ -161,7 +166,8 @@
 		if (exename)
 			ccs_free(exename);
 		if (r.mode == 1 && old_root && new_root)
-			update_pivot_root_acl(old_root, new_root, 0);
+			update_pivot_root_acl(old_root, new_root, r.domain,
+					      ccs_handler_cond(), false);
 	}
 	ccs_free(old_root);
 	ccs_free(new_root);
@@ -174,39 +180,19 @@
  * ccs_write_pivot_root_policy - Write "struct pivot_root_entry" list.
  *
  * @data:      String to parse.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL. 
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_pivot_root_policy(char *data, const bool is_delete)
+int ccs_write_pivot_root_policy(char *data, struct domain_info *domain,
+				const struct condition_list *condition,
+				const bool is_delete)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return update_pivot_root_acl(cp, data, is_delete);
+	return update_pivot_root_acl(cp, data, domain, condition, is_delete);
 }
-
-/**
- * ccs_read_pivot_root_policy - Read "struct pivot_root_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_read_pivot_root_policy(struct ccs_io_buffer *head)
-{
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &pivot_root_list) {
-		struct pivot_root_entry *ptr;
-		ptr = list1_entry(pos, struct pivot_root_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		if (!ccs_io_printf(head, KEYWORD_ALLOW_PIVOT_ROOT "%s %s\n",
-				   ptr->new_root->name, ptr->old_root->name))
-			goto out;
-	}
-	return true;
- out:
-	return false;
-}
Index: trunk/1.6.x/ccs-patch/fs/sakura_mount.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_mount.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/sakura_mount.c	(working copy)
@@ -54,16 +54,6 @@
 /* Allow to call 'mount --make-shared /dir'           */
 #define MOUNT_MAKE_SHARED_KEYWORD                        "--make-shared"
 
-/* Structure for "allow_mount" keyword. */
-struct mount_entry {
-	struct list1_head list;
-	const struct path_info *dev_name;
-	const struct path_info *dir_name;
-	const struct path_info *fs_type;
-	unsigned long flags;
-	bool is_deleted;
-};
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 /* For compatibility with older kernels. */
 static void put_filesystem(struct file_system_type *fs)
@@ -72,9 +62,6 @@
 }
 #endif
 
-/* The list for "struct mount_entry". */
-static LIST1_HEAD(mount_list);
-
 /**
  * update_mount_acl - Update "struct mount_entry" list.
  *
@@ -82,17 +69,21 @@
  * @dir_name:  Name of mount point.
  * @fs_type:   Name of filesystem.
  * @flags:     Mount options.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
 static int update_mount_acl(const char *dev_name, const char *dir_name,
 			    const char *fs_type, const unsigned long flags,
+			    struct domain_info *domain,
+			    const struct condition_list *condition,
 			    const bool is_delete)
 {
 	struct file_system_type *type = NULL;
-	struct mount_entry *new_entry;
-	struct mount_entry *ptr;
+	struct acl_info *ptr;
+	struct mount_entry *acl;
 	const struct path_info *fs;
 	const struct path_info *dev;
 	const struct path_info *dir;
@@ -120,19 +111,24 @@
 	if (!dev || !dir)
 		return -ENOMEM;
 	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &mount_list, list) {
-		if (ptr->flags != flags ||
-		    ccs_pathcmp(ptr->dev_name, dev) ||
-		    ccs_pathcmp(ptr->dir_name, dir) ||
-		    ccs_pathcmp(ptr->fs_type, fs))
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if (ccs_acl_type1(ptr) != TYPE_MOUNT_ACL)
+                        continue;
+                if (ccs_get_condition_part(ptr) != condition)
+                        continue;
+                acl = container_of(ptr, struct mount_entry, head);
+		if (acl->flags != flags ||
+		    ccs_pathcmp(acl->dev_name, dev) ||
+		    ccs_pathcmp(acl->dir_name, dir) ||
+		    ccs_pathcmp(acl->fs_type, fs))
 			continue;
 		error = 0;
 		if (is_delete) {
-			ptr->is_deleted = true;
+			ptr->type |= ACL_DELETED;
 			goto out;
 		} else {
-			if (ptr->is_deleted) {
-				ptr->is_deleted = false;
+			if (ptr->type & ACL_DELETED) {
+				ptr->type &= ~ACL_DELETED;
 				goto update;
 			}
 			goto out; /* No changes. */
@@ -142,47 +138,44 @@
 		error = -ENOENT;
 		goto out;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
+	acl = ccs_alloc_acl_element(TYPE_MOUNT_ACL, condition);
+	if (!acl)
 		goto out;
-	new_entry->dev_name = dev;
-	new_entry->dir_name = dir;
-	new_entry->fs_type = fs;
-	new_entry->flags = flags;
-	list1_add_tail_mb(&new_entry->list, &mount_list);
-	error = 0;
-	ptr = new_entry;
+	acl->dev_name = dev;
+	acl->dir_name = dir;
+	acl->fs_type = fs;
+	acl->flags = flags;
+	error = ccs_add_domain_acl(domain, &acl->head);
  update:
 	if (!strcmp(fs->name, MOUNT_REMOUNT_KEYWORD)) {
 		printk(KERN_CONT "%sAllow remount %s with options 0x%lX.\n",
-		       ccs_log_level, dir->name, ptr->flags);
+		       ccs_log_level, dir->name, acl->flags);
 	} else if (!strcmp(fs->name, MOUNT_BIND_KEYWORD)
 		   || !strcmp(fs->name, MOUNT_MOVE_KEYWORD)) {
 		printk(KERN_CONT "%sAllow mount %s %s %s with options 0x%lX\n",
 		       ccs_log_level, fs->name, dev->name, dir->name,
-		       ptr->flags);
+		       acl->flags);
 	} else if (!strcmp(fs->name, MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
 		   !strcmp(fs->name, MOUNT_MAKE_PRIVATE_KEYWORD) ||
 		   !strcmp(fs->name, MOUNT_MAKE_SLAVE_KEYWORD) ||
 		   !strcmp(fs->name, MOUNT_MAKE_SHARED_KEYWORD)) {
 		printk(KERN_CONT "%sAllow mount %s %s with options 0x%lX.\n",
-		       ccs_log_level, fs->name, dir->name, ptr->flags);
+		       ccs_log_level, fs->name, dir->name, acl->flags);
 	} else {
 		type = get_fs_type(fs->name);
 		if (type && (type->fs_flags & FS_REQUIRES_DEV) != 0)
 			printk(KERN_CONT "%sAllow mount -t %s %s %s "
 			       "with options 0x%lX.\n", ccs_log_level,
-			       fs->name, dev->name, dir->name, ptr->flags);
+			       fs->name, dev->name, dir->name, acl->flags);
 		else
 			printk(KERN_CONT "%sAllow mount %s on %s "
 			       "with options 0x%lX.\n", ccs_log_level,
-			       fs->name, dir->name, ptr->flags);
+			       fs->name, dir->name, acl->flags);
 	}
 	if (type)
 		put_filesystem(type);
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 	return error;
 }
 
@@ -397,7 +390,7 @@
 						MOUNT_MAKE_SHARED_KEYWORD,
 						flags & ~MS_SHARED);
 	} else {
-		struct mount_entry *ptr;
+		struct acl_info *ptr;
 		struct file_system_type *fstype = NULL;
 		const char *requested_dir_name = NULL;
 		const char *requested_dev_name = NULL;
@@ -452,27 +445,32 @@
 				goto cleanup;
 			}
 		}
-		list1_for_each_entry(ptr, &mount_list, list) {
-			if (ptr->is_deleted)
+		list1_for_each_entry(ptr, &r->domain->acl_info_list, list) {
+			struct mount_entry *acl;
+			if (ccs_acl_type2(ptr) != TYPE_MOUNT_ACL)
 				continue;
-
+			acl = container_of(ptr, struct mount_entry, head);
+			
 			/* Compare options */
-			if (ptr->flags != flags)
+			if (acl->flags != flags)
 				continue;
 
 			/* Compare fs name. */
-			if (strcmp(type, ptr->fs_type->name))
+			if (strcmp(type, acl->fs_type->name))
 				continue;
 
 			/* Compare mount point. */
-			if (ccs_path_matches_pattern(&rdir, ptr->dir_name) == 0)
+			if (!ccs_path_matches_pattern(&rdir, acl->dir_name))
 				continue;
 
 			/* Compare device name. */
 			if (requested_dev_name &&
-			    ccs_path_matches_pattern(&rdev, ptr->dev_name) == 0)
+			    !ccs_path_matches_pattern(&rdev, acl->dev_name))
 				continue;
 
+			if (!ccs_check_condition(r, ptr))
+				continue;
+
 			/* OK. */
 			error = 0;
 			print_success(requested_dev_name, requested_dir_name,
@@ -485,7 +483,8 @@
 		if (error && r->mode == 1)
 			update_mount_acl(need_dev ?
 					 requested_dev_name : dev_name,
-					 requested_dir_name, type, flags, 0);
+					 requested_dir_name, type, flags,
+					 r->domain, ccs_handler_cond(), false);
  cleanup:
 		ccs_free(requested_dev_name);
 		ccs_free(requested_dir_name);
@@ -525,11 +524,15 @@
  * ccs_write_mount_policy - Write "struct mount_entry" list.
  *
  * @data:      String to parse.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL. 
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_mount_policy(char *data, const bool is_delete)
+int ccs_write_mount_policy(char *data, struct domain_info *domain,
+			   const struct condition_list *condition,
+			   const bool is_delete)
 {
 	char *cp;
 	char *cp2;
@@ -556,30 +559,6 @@
 	*cp = '\0';
 	fs = cp2;
 	flags = simple_strtoul(cp + 1, NULL, 0);
-	return update_mount_acl(dev, dir, fs, flags, is_delete);
+	return update_mount_acl(dev, dir, fs, flags, domain, condition,
+				is_delete);
 }
-
-/**
- * ccs_read_mount_policy - Read "struct mount_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_read_mount_policy(struct ccs_io_buffer *head)
-{
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &mount_list) {
-		struct mount_entry *ptr;
-		ptr = list1_entry(pos, struct mount_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		if (!ccs_io_printf(head, KEYWORD_ALLOW_MOUNT "%s %s %s 0x%lX\n",
-				   ptr->dev_name->name, ptr->dir_name->name,
-				   ptr->fs_type->name, ptr->flags))
-			goto out;
-	}
-	return true;
- out:
-	return false;
-}
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(working copy)
@@ -267,11 +267,9 @@
 	if (is_granted) {
 		list_add_tail(&new_entry->list, &grant_log);
 		grant_log_count++;
-		ccs_update_counter(CCS_UPDATES_COUNTER_GRANT_LOG);
 	} else {
 		list_add_tail(&new_entry->list, &reject_log);
 		reject_log_count++;
-		ccs_update_counter(CCS_UPDATES_COUNTER_REJECT_LOG);
 	}
 	spin_unlock(&audit_log_lock);
 	/***** CRITICAL SECTION END *****/
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(working copy)
@@ -140,7 +140,6 @@
 	} else {
 		acl->type &= ~ACL_DELETED;
 	}
-	ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 	return 0;
 }
 
@@ -155,7 +154,6 @@
 {
 	if (acl)
 		acl->type |= ACL_DELETED;
-	ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 	return 0;
 }
 
@@ -259,7 +257,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
 
@@ -418,7 +415,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
 
@@ -561,7 +557,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
 
@@ -658,7 +653,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/ccs_common.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/ccs_common.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/ccs_common.c	(working copy)
@@ -58,6 +58,9 @@
 /* Has /sbin/init started? */
 bool sbin_init_started;
 
+/* Domain for keeping system policy. */
+static struct domain_info ccs_system_policy;
+
 /* Log level for SAKURA's printk(). */
 const char *ccs_log_level = KERN_DEBUG;
 
@@ -1118,7 +1121,6 @@
 	if (!cp)
 		return -EINVAL;
 	*cp = '\0';
-	ccs_update_counter(CCS_UPDATES_COUNTER_PROFILE);
 	if (!strcmp(data, "COMMENT")) {
 		profile->comment = ccs_save_name(cp + 1);
 		return 0;
@@ -1336,8 +1338,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	if (!error)
-		ccs_update_counter(CCS_UPDATES_COUNTER_MANAGER);
 	return error;
 }
 
@@ -1554,7 +1554,6 @@
 		else
 			domain = ccs_find_or_assign_new_domain(data, 0);
 		head->write_var1 = domain;
-		ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 		return 0;
 	}
 	if (!domain)
@@ -1593,6 +1592,16 @@
 		return ccs_write_argv0_policy(data, domain, cond, is_delete);
 	else if (str_starts(&data, KEYWORD_ALLOW_ENV))
 		return ccs_write_env_policy(data, domain, cond, is_delete);
+	else if (str_starts(&data, KEYWORD_ALLOW_MOUNT))
+		return ccs_write_mount_policy(data, domain, cond, is_delete);
+	else if (str_starts(&data, KEYWORD_DENY_UNMOUNT))
+		return ccs_write_no_umount_policy(data, domain, cond, is_delete);
+	else if (str_starts(&data, KEYWORD_ALLOW_CHROOT))
+		return ccs_write_chroot_policy(data, domain, cond, is_delete);
+	else if (str_starts(&data, KEYWORD_ALLOW_PIVOT_ROOT))
+		return ccs_write_pivot_root_policy(data, domain, cond, is_delete);
+	else if (str_starts(&data, KEYWORD_DENY_AUTOBIND))
+		return ccs_write_reserved_port_policy(data, is_delete);
 	else
 		return ccs_write_file_policy(data, domain, cond, is_delete);
 }
@@ -1879,7 +1888,7 @@
  * print_signal_acl - Print a signal ACL entry.
  *
  * @head: Pointer to "struct ccs_io_buffer".
- * @ptr:  Pointer to "struct signale_acl_record".
+ * @ptr:  Pointer to "struct signal_acl_record".
  * @cond: Pointer to "struct condition_list". May be NULL.
  *
  * Returns true on success, false otherwise.
@@ -1917,6 +1926,106 @@
 }
 
 /**
+ * print_no_umount_acl - Print a deny_umount ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct no_umount_entry".
+ * @cond: Pointer to "struct condition_list". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_no_umount_acl(struct ccs_io_buffer *head,
+				struct no_umount_entry *ptr,
+				const struct condition_list *cond)
+{
+	int pos = head->read_avail;
+	if (!ccs_io_printf(head, KEYWORD_DENY_UNMOUNT "%s", ptr->dir->name))
+			goto out;
+	if (!ccs_print_condition(head, cond))
+		goto out;
+	return true;
+ out:
+	head->read_avail = pos;
+	return false;
+}
+
+/**
+ * print_mount_acl - Print a umount ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct mount_entry".
+ * @cond: Pointer to "struct condition_list". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_mount_acl(struct ccs_io_buffer *head,
+			    struct mount_entry *ptr,
+			    const struct condition_list *cond)
+{
+	int pos = head->read_avail;
+	if (!ccs_io_printf(head, KEYWORD_ALLOW_MOUNT "%s %s %s 0x%lX",
+			   ptr->dev_name->name, ptr->dir_name->name,
+			   ptr->fs_type->name, ptr->flags))
+		goto out;
+	if (!ccs_print_condition(head, cond))
+		goto out;
+	return true;
+ out:
+	head->read_avail = pos;
+	return false;
+}
+
+/**
+ * print_chroot_acl - Print a chroot ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct chroot_entry".
+ * @cond: Pointer to "struct condition_list". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_chroot_acl(struct ccs_io_buffer *head,
+			     struct chroot_entry *ptr,
+			     const struct condition_list *cond)
+{
+	int pos = head->read_avail;
+	if (!ccs_io_printf(head, KEYWORD_ALLOW_CHROOT "%s", ptr->dir->name))
+		goto out;
+	if (!ccs_print_condition(head, cond))
+		goto out;
+	return true;
+ out:
+	head->read_avail = pos;
+	return false;
+}
+
+/**
+ * print_pivot_root_acl - Print a pivot_root ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct chroot_entry".
+ * @cond: Pointer to "struct condition_list". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_pivot_root_acl(struct ccs_io_buffer *head,
+			     struct pivot_root_entry *ptr,
+			     const struct condition_list *cond)
+{
+	int pos = head->read_avail;
+	if (!ccs_io_printf(head, KEYWORD_ALLOW_PIVOT_ROOT
+			   "%s %s", ptr->new_root->name,
+			   ptr->old_root->name))
+		goto out;
+	if (!ccs_print_condition(head, cond))
+		goto out;
+	return true;
+ out:
+	head->read_avail = pos;
+	return false;
+}
+
+/**
  * print_entry - Print an ACL entry.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -1981,6 +2090,26 @@
 		const char *keyword = KEYWORD_DENIED_EXECUTE_HANDLER;
 		return print_execute_handler_record(head, keyword, acl);
 	}
+	if (acl_type == TYPE_NO_UMOUNT_ACL) {
+		struct no_umount_entry *acl
+			= list1_entry(ptr, struct no_umount_entry, head);
+		return print_no_umount_acl(head, acl, cond);
+	}
+	if (acl_type == TYPE_MOUNT_ACL) {
+		struct mount_entry *acl
+			= list1_entry(ptr, struct mount_entry, head);
+		return print_mount_acl(head, acl, cond);
+	}
+	if (acl_type == TYPE_CHROOT_ACL) {
+		struct chroot_entry *acl
+			= list1_entry(ptr, struct chroot_entry, head);
+		return print_chroot_acl(head, acl, cond);
+	}
+	if (acl_type == TYPE_PIVOT_ROOT_ACL) {
+		struct pivot_root_entry *acl
+			= list1_entry(ptr, struct pivot_root_entry, head);
+		return print_pivot_root_acl(head, acl, cond);
+	}
 	/* Workaround for gcc 3.2.2's inline bug. */
 	if (acl_type & ACL_DELETED)
 		return true;
@@ -2084,7 +2213,6 @@
 	if (domain && profile < MAX_PROFILES
 	    && (profile_ptr[profile] || !sbin_init_started))
 		domain->profile = (u8) profile;
-	ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 	return 0;
 }
 
@@ -2314,24 +2442,55 @@
  */
 static int write_system_policy(struct ccs_io_buffer *head)
 {
+        const struct condition_list *cond = NULL;
 	char *data = head->write_buf;
 	bool is_delete = false;
+        char *cp = ccs_find_condition_part(data);
+        if (cp) {
+                cond = ccs_find_or_assign_new_condition(cp);
+                if (!cond)
+                        return -EINVAL;
+        }
 	if (str_starts(&data, KEYWORD_DELETE))
 		is_delete = true;
 	if (str_starts(&data, KEYWORD_ALLOW_MOUNT))
-		return ccs_write_mount_policy(data, is_delete);
-	if (str_starts(&data, KEYWORD_DENY_UNMOUNT))
-		return ccs_write_no_umount_policy(data, is_delete);
-	if (str_starts(&data, KEYWORD_ALLOW_CHROOT))
-		return ccs_write_chroot_policy(data, is_delete);
-	if (str_starts(&data, KEYWORD_ALLOW_PIVOT_ROOT))
-		return ccs_write_pivot_root_policy(data, is_delete);
-	if (str_starts(&data, KEYWORD_DENY_AUTOBIND))
+		return ccs_write_mount_policy(data, &ccs_system_policy, cond,
+					      is_delete);
+	else if (str_starts(&data, KEYWORD_DENY_UNMOUNT))
+		return ccs_write_no_umount_policy(data, &ccs_system_policy,
+						  cond, is_delete);
+	else if (str_starts(&data, KEYWORD_ALLOW_CHROOT))
+		return ccs_write_chroot_policy(data, &ccs_system_policy, cond,
+					       is_delete);
+	else if (str_starts(&data, KEYWORD_ALLOW_PIVOT_ROOT))
+		return ccs_write_pivot_root_policy(data, &ccs_system_policy,
+						   cond, is_delete);
+	else if (str_starts(&data, KEYWORD_DENY_AUTOBIND))
 		return ccs_write_reserved_port_policy(data, is_delete);
 	return -EINVAL;
 }
 
 /**
+ * ccs_read_system_policy - Read system policy list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_read_system_policy(struct ccs_io_buffer *head)
+{
+	struct list1_head *pos;
+	/* Print ACL entries in the domain. */
+	list1_for_each_cookie(pos, head->read_var2,
+			      &ccs_system_policy.acl_info_list) {
+		struct acl_info *ptr = list1_entry(pos, struct acl_info, list);
+		if (!print_entry(head, ptr))
+			return false;
+	}
+	return true;
+}
+
+/**
  * read_system_policy - Read system policy.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -2346,26 +2505,11 @@
 			head->read_var2 = NULL;
 			head->read_step = 1;
 		case 1:
-			if (!ccs_read_mount_policy(head))
+			if (!ccs_read_system_policy(head))
 				break;
 			head->read_var2 = NULL;
 			head->read_step = 2;
 		case 2:
-			if (!ccs_read_no_umount_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 3;
-		case 3:
-			if (!ccs_read_chroot_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 4;
-		case 4:
-			if (!ccs_read_pivot_root_policy(head))
-				break;
-			head->read_var2 = NULL;
-			head->read_step = 5;
-		case 5:
 			if (!ccs_read_reserved_port_policy(head))
 				break;
 			head->read_eof = true;
@@ -2641,7 +2785,6 @@
 	list_add_tail(&query_entry->list, &query_list);
 	spin_unlock(&query_list_lock);
 	/***** CRITICAL SECTION END *****/
-	ccs_update_counter(CCS_UPDATES_COUNTER_QUERY);
 	/* Give 10 seconds for supervisor's opinion. */
 	for (query_entry->timer = 0; atomic_read(&queryd_watcher)
 		     && query_entry->timer < 100; query_entry->timer++) {
@@ -2651,7 +2794,6 @@
 		if (query_entry->answer)
 			break;
 	}
-	ccs_update_counter(CCS_UPDATES_COUNTER_QUERY);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&query_list_lock);
 	list_del(&query_entry->list);
@@ -2830,69 +2972,7 @@
 	return 0;
 }
 
-/* Policy updates counter. */
-static unsigned int updates_counter[MAX_CCS_UPDATES_COUNTER];
-
-/* Policy updates counter lock. */
-static DEFINE_SPINLOCK(updates_counter_lock);
-
 /**
- * ccs_update_counter - Increment policy change counter.
- *
- * @index: Type of policy.
- *
- * Returns nothing.
- */
-void ccs_update_counter(const unsigned char index)
-{
-	/***** CRITICAL SECTION START *****/
-	spin_lock(&updates_counter_lock);
-	if (index < MAX_CCS_UPDATES_COUNTER)
-		updates_counter[index]++;
-	spin_unlock(&updates_counter_lock);
-	/***** CRITICAL SECTION END *****/
-}
-
-/**
- * read_updates_counter - Check for policy change counter.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns how many times policy has changed since the previous check.
- */
-static int read_updates_counter(struct ccs_io_buffer *head)
-{
-	if (!head->read_eof) {
-		unsigned int counter[MAX_CCS_UPDATES_COUNTER];
-		/***** CRITICAL SECTION START *****/
-		spin_lock(&updates_counter_lock);
-		memmove(counter, updates_counter, sizeof(updates_counter));
-		memset(updates_counter, 0, sizeof(updates_counter));
-		spin_unlock(&updates_counter_lock);
-		/***** CRITICAL SECTION END *****/
-		ccs_io_printf(head,
-			      "/proc/ccs/system_policy:    %10u\n"
-			      "/proc/ccs/domain_policy:    %10u\n"
-			      "/proc/ccs/exception_policy: %10u\n"
-			      "/proc/ccs/profile:          %10u\n"
-			      "/proc/ccs/query:            %10u\n"
-			      "/proc/ccs/manager:          %10u\n"
-			      "/proc/ccs/grant_log:        %10u\n"
-			      "/proc/ccs/reject_log:       %10u\n",
-			      counter[CCS_UPDATES_COUNTER_SYSTEM_POLICY],
-			      counter[CCS_UPDATES_COUNTER_DOMAIN_POLICY],
-			      counter[CCS_UPDATES_COUNTER_EXCEPTION_POLICY],
-			      counter[CCS_UPDATES_COUNTER_PROFILE],
-			      counter[CCS_UPDATES_COUNTER_QUERY],
-			      counter[CCS_UPDATES_COUNTER_MANAGER],
-			      counter[CCS_UPDATES_COUNTER_GRANT_LOG],
-			      counter[CCS_UPDATES_COUNTER_REJECT_LOG]);
-		head->read_eof = true;
-	}
-	return 0;
-}
-
-/**
  * read_version: Get version.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -3009,9 +3089,6 @@
 		head->write = write_manager_policy;
 		head->read = read_manager_policy;
 		break;
-	case CCS_UPDATESCOUNTER: /* /proc/ccs/.updates_counter */
-		head->read = read_updates_counter;
-		break;
 	}
 	if (!(file->f_mode & FMODE_READ)) {
 		/*
@@ -3248,6 +3325,18 @@
 	case TYPE_DENIED_EXECUTE_HANDLER:
 		len = sizeof(struct execute_handler_record);
 		break;
+	case TYPE_NO_UMOUNT_ACL:
+		len = sizeof(struct no_umount_entry);
+		break;
+	case TYPE_MOUNT_ACL:
+		len = sizeof(struct mount_entry);
+		break;
+	case TYPE_CHROOT_ACL:
+		len = sizeof(struct chroot_entry);
+		break;
+	case TYPE_PIVOT_ROOT_ACL:
+		len = sizeof(struct pivot_root_entry);
+		break;
 	default:
 		return NULL;
 	}
@@ -3275,3 +3364,22 @@
 	ptr->type = acl_type;
 	return ptr;
 }
+
+/**
+ * ccs_common_init - Initialize realpath related code.
+ *
+ * Returns 0.
+ */
+static int __init ccs_common_init(void)
+{
+	INIT_LIST1_HEAD(&ccs_system_policy.list);
+	INIT_LIST1_HEAD(&ccs_system_policy.acl_info_list);
+	ccs_system_policy.domainname = ccs_save_name("<SYSTEM>");
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+__initcall(ccs_common_init);
+#else
+core_initcall(ccs_common_init);
+#endif
Index: trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(working copy)
@@ -221,7 +221,6 @@
 	create_entry("meminfo",          0600, ccs_dir, CCS_MEMINFO);
 	create_entry("profile",          0600, ccs_dir, CCS_PROFILE);
 	create_entry("manager",          0600, ccs_dir, CCS_MANAGER);
-	create_entry(".updates_counter", 0400, ccs_dir, CCS_UPDATESCOUNTER);
 	create_entry("version",          0400, ccs_dir, CCS_VERSION);
 	create_entry(".execute_handler", 0666, ccs_dir, CCS_EXECUTE_HANDLER);
 	if (sizeof(struct ccs_page_buffer) < CCS_MAX_PATHNAME_LEN + 1)
Index: trunk/1.6.x/ccs-patch/fs/sakura_bind.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_bind.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/sakura_bind.c	(working copy)
@@ -63,7 +63,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 	return error;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c	(working copy)
@@ -200,7 +200,8 @@
 		return error;
 	}
 	if (r.mode == 1 && ccs_check_domain_quota(r.domain))
-		update_signal_acl(sig, dest_pattern, r.domain, NULL, false);
+		update_signal_acl(sig, dest_pattern, r.domain,
+				  ccs_handler_cond(), false);
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_file.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(working copy)
@@ -209,7 +209,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
 
@@ -343,7 +342,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
 
@@ -493,7 +491,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
 
@@ -606,7 +603,6 @@
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
 
@@ -832,7 +828,8 @@
 		/* Don't use patterns for execute permission. */
 		const char *patterned_file = (perm != 1) ?
 			get_file_pattern(filename) : filename->name;
-		update_file_acl(patterned_file, perm, r->domain, NULL, false);
+		update_file_acl(patterned_file, perm, r->domain,
+				ccs_handler_cond(), false);
 	}
 	return 0;
 }
@@ -1271,7 +1268,7 @@
 	}
 	if (r->mode == 1 && ccs_check_domain_quota(r->domain))
 		update_single_path_acl(operation, get_file_pattern(filename),
-				       r->domain, NULL, false);
+				       r->domain, ccs_handler_cond(), false);
 	if (!is_enforce)
 		error = 0;
  ok:
@@ -1550,8 +1547,8 @@
 	}
 	if (r.mode == 1 && ccs_check_domain_quota(r.domain))
 		update_double_path_acl(operation, get_file_pattern(buf1),
-				       get_file_pattern(buf2), r.domain, NULL,
-				       false);
+				       get_file_pattern(buf2), r.domain,
+				       ccs_handler_cond(), false);
  out:
 	ccs_free(buf1);
 	ccs_free(buf2);
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c	(working copy)
@@ -191,7 +191,8 @@
 		return !error;
 	}
 	if (r.mode == 1 && ccs_check_domain_quota(r.domain))
-		update_capability_acl(operation, r.domain, NULL, false);
+		update_capability_acl(operation, r.domain, ccs_handler_cond(),
+				      false);
 	return true;
 }
 EXPORT_SYMBOL(ccs_capable); /* for net/unix/af_unix.c */
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(working copy)
@@ -460,60 +460,114 @@
 /* The list for "struct condition_list". */
 static LIST1_HEAD(condition_list);
 
-#define TASK_UID          0
-#define TASK_EUID         1
-#define TASK_SUID         2
-#define TASK_FSUID        3
-#define TASK_GID          4
-#define TASK_EGID         5
-#define TASK_SGID         6
-#define TASK_FSGID        7
-#define TASK_PID          8
-#define TASK_PPID         9
-#define PATH1_UID        10
-#define PATH1_GID        11
-#define PATH1_INO        12
-#define PATH1_PARENT_UID 13
-#define PATH1_PARENT_GID 14
-#define PATH1_PARENT_INO 15
-#define PATH2_PARENT_UID 16
-#define PATH2_PARENT_GID 17
-#define PATH2_PARENT_INO 18
-#define EXEC_ARGC        19
-#define EXEC_ENVC        20
-#define TASK_STATE_0     21
-#define TASK_STATE_1     22
-#define TASK_STATE_2     23
-#define MAX_KEYWORD      24
+enum conditions_index {
+	TASK_UID,             /* current->uid   */
+	TASK_EUID,            /* current->euid  */
+	TASK_SUID,            /* current->suid  */
+	TASK_FSUID,           /* current->fsuid */
+	TASK_GID,             /* current->gid   */
+	TASK_EGID,            /* current->egid  */
+	TASK_SGID,            /* current->sgid  */
+	TASK_FSGID,           /* current->fsgid */
+	TASK_PID,             /* sys_getpid()   */
+	TASK_PPID,            /* sys_getppid()  */
+	EXEC_ARGC,            /* "struct linux_binprm *"->argc */
+	EXEC_ENVC,            /* "struct linux_binprm *"->envc */
+	TASK_STATE_0,         /* (u8) (current->tomoyo_flags >> 24) */ 
+	TASK_STATE_1,         /* (u8) (current->tomoyo_flags >> 16) */
+	TASK_STATE_2,         /* (u8) (task->tomoyo_flags >> 8)     */
+	TYPE_SOCKET,          /* S_IFSOCK */
+	TYPE_SYMLINK,         /* S_IFLNK */
+	TYPE_FILE,            /* S_IFREG */
+	TYPE_BLOCK_DEV,       /* S_IFBLK */
+	TYPE_DIRECTORY,       /* S_IFDIR */
+	TYPE_CHAR_DEV,        /* S_IFCHR */
+	TYPE_FIFO,            /* S_IFIFO */
+	MODE_SETUID,          /* S_ISUID */
+	MODE_SETGID,          /* S_ISGID */
+	MODE_STICKY,          /* S_ISVTX */
+	MODE_OWNER_READ,      /* S_IRUSR */
+	MODE_OWNER_WRITE,     /* S_IWUSR */
+	MODE_OWNER_EXECUTE,   /* S_IXUSR */
+	MODE_GROUP_READ,      /* S_IRGRP */
+	MODE_GROUP_WRITE,     /* S_IWGRP */
+	MODE_GROUP_EXECUTE,   /* S_IXGRP */
+	MODE_OTHERS_READ,     /* S_IROTH */
+	MODE_OTHERS_WRITE,    /* S_IWOTH */
+	MODE_OTHERS_EXECUTE,  /* S_IXOTH */
+	TASK_TYPE,            /* ((u8) task->tomoyo_flags) &
+				 TOMOYO_TASK_IS_EXECUTE_HANDLER */
+	TASK_EXECUTE_HANDLER, /* TOMOYO_TASK_IS_EXECUTE_HANDLER */
+	PATH1_UID,
+	PATH1_GID,
+	PATH1_INO,
+	PATH1_PARENT_UID,
+	PATH1_PARENT_GID,
+	PATH1_PARENT_INO,
+	PATH2_PARENT_UID,
+	PATH2_PARENT_GID,
+	PATH2_PARENT_INO,
+	PATH1_TYPE,
+	PATH1_DEV_MAJOR,
+	PATH1_DEV_MINOR,
+	PATH1_MODE,
+	PATH1_PARENT_MODE,
+	PATH2_PARENT_MODE,
+	MAX_KEYWORD
+}; 
 
-static struct {
-	const char *keyword;
-	const int keyword_len; /* strlen(keyword) */
-} condition_control_keyword[MAX_KEYWORD] = {
-	[TASK_UID]         = { "task.uid",           8 },
-	[TASK_EUID]        = { "task.euid",          9 },
-	[TASK_SUID]        = { "task.suid",          9 },
-	[TASK_FSUID]       = { "task.fsuid",        10 },
-	[TASK_GID]         = { "task.gid",           8 },
-	[TASK_EGID]        = { "task.egid",          9 },
-	[TASK_SGID]        = { "task.sgid",          9 },
-	[TASK_FSGID]       = { "task.fsgid",        10 },
-	[TASK_PID]         = { "task.pid",           8 },
-	[TASK_PPID]        = { "task.ppid",          9 },
-	[PATH1_UID]        = { "path1.uid",          9 },
-	[PATH1_GID]        = { "path1.gid",          9 },
-	[PATH1_INO]        = { "path1.ino",          9 },
-	[PATH1_PARENT_UID] = { "path1.parent.uid",  16 },
-	[PATH1_PARENT_GID] = { "path1.parent.gid",  16 },
-	[PATH1_PARENT_INO] = { "path1.parent.ino",  16 },
-	[PATH2_PARENT_UID] = { "path2.parent.uid",  16 },
-	[PATH2_PARENT_GID] = { "path2.parent.gid",  16 },
-	[PATH2_PARENT_INO] = { "path2.parent.ino",  16 },
-	[EXEC_ARGC]        = { "exec.argc",          9 },
-	[EXEC_ENVC]        = { "exec.envc",          9 },
-	[TASK_STATE_0]     = { "task.state[0]",     13 },
-	[TASK_STATE_1]     = { "task.state[1]",     13 },
-	[TASK_STATE_2]     = { "task.state[2]",     13 },
+static const char *condition_control_keyword[MAX_KEYWORD] = {
+	[TASK_UID]             = "task.uid",
+	[TASK_EUID]            = "task.euid",
+	[TASK_SUID]            = "task.suid",
+	[TASK_FSUID]           = "task.fsuid",
+	[TASK_GID]             = "task.gid",
+	[TASK_EGID]            = "task.egid",
+	[TASK_SGID]            = "task.sgid",
+	[TASK_FSGID]           = "task.fsgid",
+	[TASK_PID]             = "task.pid",
+	[TASK_PPID]            = "task.ppid",
+	[EXEC_ARGC]            = "exec.argc",
+	[EXEC_ENVC]            = "exec.envc",
+	[TASK_STATE_0]         = "task.state[0]",
+	[TASK_STATE_1]         = "task.state[1]",
+	[TASK_STATE_2]         = "task.state[2]",
+	[TYPE_SOCKET]          = "socket",
+	[TYPE_SYMLINK]         = "symlink",
+	[TYPE_FILE]            = "file",
+	[TYPE_BLOCK_DEV]       = "block",
+	[TYPE_DIRECTORY]       = "directory",
+	[TYPE_CHAR_DEV]        = "char",
+	[TYPE_FIFO]            = "fifo",
+	[MODE_SETUID]          = "setuid",
+	[MODE_SETGID]          = "setgid",
+	[MODE_STICKY]          = "sticky",
+	[MODE_OWNER_READ]      = "user_read",
+	[MODE_OWNER_WRITE]     = "user_write",
+	[MODE_OWNER_EXECUTE]   = "user_execute",
+	[MODE_GROUP_READ]      = "group_read",
+	[MODE_GROUP_WRITE]     = "group_write",
+	[MODE_GROUP_EXECUTE]   = "group_execute",
+	[MODE_OTHERS_READ]     = "others_read",
+	[MODE_OTHERS_WRITE]    = "others_write",
+	[MODE_OTHERS_EXECUTE]  = "others_execute",
+	[TASK_TYPE]            = "task.type",
+	[TASK_EXECUTE_HANDLER] = "execute_handler",
+	[PATH1_UID]            = "path1.uid",
+	[PATH1_GID]            = "path1.gid",
+	[PATH1_INO]            = "path1.ino",
+	[PATH1_PARENT_UID]     = "path1.parent.uid",
+	[PATH1_PARENT_GID]     = "path1.parent.gid",
+	[PATH1_PARENT_INO]     = "path1.parent.ino",
+	[PATH2_PARENT_UID]     = "path2.parent.uid",
+	[PATH2_PARENT_GID]     = "path2.parent.gid",
+	[PATH2_PARENT_INO]     = "path2.parent.ino",
+	[PATH1_TYPE]           = "path1.type",
+	[PATH1_DEV_MAJOR]      = "path1.major",
+	[PATH1_DEV_MINOR]      = "path1.minor",
+	[PATH1_MODE]           = "path1.mode",
+	[PATH1_PARENT_MODE]    = "path1.parent.mode",
+	[PATH2_PARENT_MODE]    = "path2.parent.mode",
 };
 
 /**
@@ -634,6 +688,13 @@
 	u16 argc = 0;
 	u16 envc = 0;
 	u8 post_state[4] = { 0, 0, 0, 0 };
+	/* Calculate at runtime. */
+	static u8 condition_control_keyword_len[MAX_KEYWORD];
+	if (!condition_control_keyword_len[MAX_KEYWORD - 1]) {
+		for (i = 0; i < MAX_KEYWORD; i++)
+			condition_control_keyword_len[i]
+				= strlen(condition_control_keyword[i]);
+	}
 	if (!parse_post_condition(start, post_state))
 		goto out;
 	start = condition;
@@ -661,9 +722,8 @@
 		}
 		for (left = 0; left < MAX_KEYWORD; left++) {
 			const int len =
-				condition_control_keyword[left].keyword_len;
-			if (strncmp(start,
-				    condition_control_keyword[left].keyword,
+				condition_control_keyword_len[left];
+			if (strncmp(start, condition_control_keyword[left],
 				    len))
 				continue;
 			start += len;
@@ -690,9 +750,8 @@
 		condc++; /* header */
 		for (right = 0; right < MAX_KEYWORD; right++) {
 			const int len =
-				condition_control_keyword[right].keyword_len;
-			if (strncmp(start,
-				    condition_control_keyword[right].keyword,
+				condition_control_keyword_len[right];
+			if (strncmp(start, condition_control_keyword[right],
 				    len))
 				continue;
 			start += len;
@@ -771,9 +830,8 @@
 		}
 		for (left = 0; left < MAX_KEYWORD; left++) {
 			const int len =
-				condition_control_keyword[left].keyword_len;
-			if (strncmp(start,
-				    condition_control_keyword[left].keyword,
+				condition_control_keyword_len[left];
+			if (strncmp(start, condition_control_keyword[left],
 				    len))
 				continue;
 			start += len;
@@ -801,9 +859,8 @@
 		condc--; /* header */
 		for (right = 0; right < MAX_KEYWORD; right++) {
 			const int len =
-				condition_control_keyword[right].keyword_len;
-			if (strncmp(start,
-				    condition_control_keyword[right].keyword,
+				condition_control_keyword_len[right];
+			if (strncmp(start, condition_control_keyword[right],
 				    len))
 				continue;
 			start += len;
@@ -942,6 +999,7 @@
 			obj->path1_stat.uid = stat.uid;
 			obj->path1_stat.gid = stat.gid;
 			obj->path1_stat.ino = stat.ino;
+			obj->path1_stat.rdev = stat.rdev;
 			obj->path1_valid = true;
 		}
 	}
@@ -955,6 +1013,7 @@
 			obj->path1_parent_stat.uid = stat.uid;
 			obj->path1_parent_stat.gid = stat.gid;
 			obj->path1_parent_stat.ino = stat.ino;
+			obj->path1_parent_stat.rdev = stat.rdev;
 			obj->path1_parent_valid = true;
 		}
 	}
@@ -971,6 +1030,7 @@
 				obj->path2_parent_stat.uid = stat.uid;
 				obj->path2_parent_stat.gid = stat.gid;
 				obj->path2_parent_stat.ino = stat.ino;
+				obj->path2_parent_stat.rdev = stat.rdev;
 				obj->path2_parent_valid = true;
 			}
 		}
@@ -1022,240 +1082,289 @@
 		const bool match = (header >> 16) & 1;
 		const u8 left = header >> 8;
 		const u8 right = header;
+		bool left_is_bitop = false;
+		bool right_is_bitop = false;
+		u8 j;
 		ptr++;
-		if ((left >= PATH1_UID && left < EXEC_ARGC) ||
-		    (right >= PATH1_UID && right < EXEC_ARGC)) {
-			if (!obj)
-				goto out;
-			if (!obj->validate_done) {
-				get_attributes(obj);
-				obj->validate_done = true;
+		for (j = 0; j < 2; j++) {
+			const u8 index = j ? right : left;
+			unsigned long min_v = 0;
+			unsigned long max_v = 0;
+			bool is_bitop = false;
+			switch (index) {
+			case TASK_UID:
+				max_v = task->uid;
+				break;
+			case TASK_EUID:
+				max_v = task->euid;
+				break;
+			case TASK_SUID:
+				max_v = task->suid;
+				break;
+			case TASK_FSUID:
+				max_v = task->fsuid;
+				break;
+			case TASK_GID:
+				max_v = task->gid;
+				break;
+			case TASK_EGID:
+				max_v = task->egid;
+				break;
+			case TASK_SGID:
+				max_v = task->sgid;
+				break;
+			case TASK_FSGID:
+				max_v = task->fsgid;
+				break;
+			case TASK_PID:
+				max_v = sys_getpid();
+				break;
+			case TASK_PPID:
+				max_v = sys_getppid();
+				break;
+			case TYPE_SOCKET:
+				max_v = S_IFSOCK;
+				break;
+			case TYPE_SYMLINK:
+				max_v = S_IFLNK;
+				break;
+			case TYPE_FILE:
+				max_v = S_IFREG;
+				break;
+			case TYPE_BLOCK_DEV:
+				max_v = S_IFBLK;
+				break;
+			case TYPE_DIRECTORY:
+				max_v = S_IFDIR;
+				break;
+			case TYPE_CHAR_DEV:
+				max_v = S_IFCHR;
+				break;
+			case TYPE_FIFO:
+				max_v = S_IFIFO;
+				break;
+			case MODE_SETUID:
+				max_v = S_ISUID;
+				is_bitop = true;
+				break;
+			case MODE_SETGID:
+				max_v = S_ISGID;
+				is_bitop = true;
+				break;
+			case MODE_STICKY:
+				max_v = S_ISVTX;
+				is_bitop = true;
+				break;
+			case MODE_OWNER_READ:
+				max_v = S_IRUSR;
+				is_bitop = true;
+				break;
+			case MODE_OWNER_WRITE:
+				max_v = S_IWUSR;
+				is_bitop = true;
+				break;
+			case MODE_OWNER_EXECUTE:
+				max_v = S_IXUSR;
+				is_bitop = true;
+				break;
+			case MODE_GROUP_READ:
+				max_v = S_IRGRP;
+				is_bitop = true;
+				break;
+			case MODE_GROUP_WRITE:
+				max_v = S_IWGRP;
+				is_bitop = true;
+				break;
+			case MODE_GROUP_EXECUTE:
+				max_v = S_IXGRP;
+				is_bitop = true;
+				break;
+			case MODE_OTHERS_READ:
+				max_v = S_IROTH;
+				is_bitop = true;
+				break;
+			case MODE_OTHERS_WRITE:
+				max_v = S_IWOTH;
+				is_bitop = true;
+				break;
+			case MODE_OTHERS_EXECUTE:
+				max_v = S_IXOTH;
+				is_bitop = true;
+				break;
+			case EXEC_ARGC:
+				if (!bprm)
+					goto out;
+				max_v = bprm->argc;
+				i++;
+				break;
+			case EXEC_ENVC:
+				if (!bprm)
+					goto out;
+				max_v = bprm->envc;
+				i++;
+				break;
+			case TASK_STATE_0:
+				max_v = (u8) (task->tomoyo_flags >> 24);
+				break;
+			case TASK_STATE_1:
+				max_v = (u8) (task->tomoyo_flags >> 16);
+				break;
+			case TASK_STATE_2:
+				max_v = (u8) (task->tomoyo_flags >> 8);
+				break;
+			case TASK_TYPE:
+				max_v = ((u8) task->tomoyo_flags)
+					& TOMOYO_TASK_IS_EXECUTE_HANDLER;
+				break;
+			case TASK_EXECUTE_HANDLER:
+				max_v = TOMOYO_TASK_IS_EXECUTE_HANDLER;
+				break;
+			case MAX_KEYWORD:
+				max_v = *ptr;
+				ptr++;
+				i++;
+				break;
+			case MAX_KEYWORD + 1:
+				min_v = *ptr;
+				ptr++;
+				max_v = *ptr;
+				ptr++;
+				i += 2;
+				break;
+			default:
+				if (!obj)
+					goto out;
+				if (!obj->validate_done) {
+					get_attributes(obj);
+					obj->validate_done = true;
+				}
+				switch (index) {
+				case PATH1_UID:
+					if (!obj->path1_valid)
+						goto out;
+					max_v = obj->path1_stat.uid;
+					break;
+				case PATH1_GID:
+					if (!obj->path1_valid)
+						goto out;
+					max_v = obj->path1_stat.gid;
+					break;
+				case PATH1_INO:
+					if (!obj->path1_valid)
+						goto out;
+					max_v = obj->path1_stat.ino;
+					break;
+				case PATH1_PARENT_UID:
+					if (!obj->path1_parent_valid)
+						goto out;
+					max_v = obj->path1_parent_stat.uid;
+					break;
+				case PATH1_PARENT_GID:
+					if (!obj->path1_parent_valid)
+						goto out;
+					max_v = obj->path1_parent_stat.gid;
+					break;
+				case PATH1_PARENT_INO:
+					if (!obj->path1_parent_valid)
+						goto out;
+					max_v = obj->path1_parent_stat.ino;
+					break;
+				case PATH2_PARENT_UID:
+					if (!obj->path2_parent_valid)
+						goto out;
+					max_v = obj->path2_parent_stat.uid;
+					break;
+				case PATH2_PARENT_GID:
+					if (!obj->path2_parent_valid)
+						goto out;
+					max_v = obj->path2_parent_stat.gid;
+					break;
+				case PATH2_PARENT_INO:
+					if (!obj->path2_parent_valid)
+						goto out;
+					max_v = obj->path2_parent_stat.ino;
+					break;
+				case PATH1_TYPE:
+					if (!obj->path1_valid)
+						goto out;
+					max_v = obj->path1_stat.mode & S_IFMT;
+					break;
+				case PATH1_DEV_MAJOR:
+					if (!obj->path1_valid)
+						goto out;
+					max_v = MAJOR(obj->path1_stat.rdev);
+					break;
+				case PATH1_DEV_MINOR:
+					if (!obj->path1_valid)
+						goto out;
+					max_v = MINOR(obj->path1_stat.rdev);
+					break;
+				case PATH1_MODE:
+					if (!obj->path1_valid)
+						goto out;
+					max_v = obj->path1_stat.mode
+						& S_IALLUGO;
+					break;
+				case PATH1_PARENT_MODE:
+					if (!obj->path1_parent_valid)
+						goto out;
+					max_v = obj->path1_parent_stat.mode
+						& S_IALLUGO;
+					break;
+				case PATH2_PARENT_MODE:
+					if (!obj->path2_parent_valid)
+						goto out;
+					max_v = obj->path2_parent_stat.mode
+						& S_IALLUGO;
+					break;
+				}
+				break;
 			}
+			if (index != MAX_KEYWORD + 1)
+				min_v = max_v;
+			if (j) {
+				right_max = max_v;
+				right_min = min_v;
+				right_is_bitop = is_bitop;
+			} else {
+				left_max = max_v;
+				left_min = min_v;
+				left_is_bitop = is_bitop;
+			}
 		}
-		switch (left) {
-		case TASK_UID:
-			left_max = task->uid;
-			break;
-		case TASK_EUID:
-			left_max = task->euid;
-			break;
-		case TASK_SUID:
-			left_max = task->suid;
-			break;
-		case TASK_FSUID:
-			left_max = task->fsuid;
-			break;
-		case TASK_GID:
-			left_max = task->gid;
-			break;
-		case TASK_EGID:
-			left_max = task->egid;
-			break;
-		case TASK_SGID:
-			left_max = task->sgid;
-			break;
-		case TASK_FSGID:
-			left_max = task->fsgid;
-			break;
-		case TASK_PID:
-			left_max = sys_getpid();
-			break;
-		case TASK_PPID:
-			left_max = sys_getppid();
-			break;
-		case PATH1_UID:
-			if (!obj->path1_valid)
-				goto out;
-			left_max = obj->path1_stat.uid;
-			break;
-		case PATH1_GID:
-			if (!obj->path1_valid)
-				goto out;
-			left_max = obj->path1_stat.gid;
-			break;
-		case PATH1_INO:
-			if (!obj->path1_valid)
-				goto out;
-			left_max = obj->path1_stat.ino;
-			break;
-		case PATH1_PARENT_UID:
-			if (!obj->path1_parent_valid)
-				goto out;
-			left_max = obj->path1_parent_stat.uid;
-			break;
-		case PATH1_PARENT_GID:
-			if (!obj->path1_parent_valid)
-				goto out;
-			left_max = obj->path1_parent_stat.gid;
-			break;
-		case PATH1_PARENT_INO:
-			if (!obj->path1_parent_valid)
-				goto out;
-			left_max = obj->path1_parent_stat.ino;
-			break;
-		case PATH2_PARENT_UID:
-			if (!obj->path2_parent_valid)
-				goto out;
-			left_max = obj->path2_parent_stat.uid;
-			break;
-		case PATH2_PARENT_GID:
-			if (!obj->path2_parent_valid)
-				goto out;
-			left_max = obj->path2_parent_stat.gid;
-			break;
-		case PATH2_PARENT_INO:
-			if (!obj->path2_parent_valid)
-				goto out;
-			left_max = obj->path2_parent_stat.ino;
-			break;
-		case EXEC_ARGC:
-			if (!bprm)
-				goto out;
-			left_max = bprm->argc;
-			i++;
-			break;
-		case EXEC_ENVC:
-			if (!bprm)
-				goto out;
-			left_max = bprm->envc;
-			i++;
-			break;
-		case TASK_STATE_0:
-			left_max = (u8) (task->tomoyo_flags >> 24);
-			break;
-		case TASK_STATE_1:
-			left_max = (u8) (task->tomoyo_flags >> 16);
-			break;
-		case TASK_STATE_2:
-			left_max = (u8) (task->tomoyo_flags >> 8);
-			break;
-		case MAX_KEYWORD:
-			left_max = *ptr;
-			ptr++;
-			i++;
-			break;
-		case MAX_KEYWORD + 1:
-			left_min = *ptr;
-			ptr++;
-			left_max = *ptr;
-			ptr++;
-			i += 2;
-			break;
+		/*
+		 * Bit operation is valid only when counterpart value
+		 * represents permission.
+		 */
+		if (left_is_bitop && right_is_bitop)
+			goto out;
+		if (left_is_bitop) {
+			if (right == PATH1_MODE || right == PATH1_PARENT_MODE
+			    || right == PATH2_PARENT_MODE) {
+				if (match) {
+					if ((right_max & left_max))
+						continue;
+				} else {
+					if (!(right_max & left_max))
+						continue;
+				}
+			}
+			goto out;
 		}
-		if (left != MAX_KEYWORD + 1)
-			left_min = left_max;
-		switch (right) {
-		case TASK_UID:
-			right_max = task->uid;
-			break;
-		case TASK_EUID:
-			right_max = task->euid;
-			break;
-		case TASK_SUID:
-			right_max = task->suid;
-			break;
-		case TASK_FSUID:
-			right_max = task->fsuid;
-			break;
-		case TASK_GID:
-			right_max = task->gid;
-			break;
-		case TASK_EGID:
-			right_max = task->egid;
-			break;
-		case TASK_SGID:
-			right_max = task->sgid;
-			break;
-		case TASK_FSGID:
-			right_max = task->fsgid;
-			break;
-		case TASK_PID:
-			right_max = sys_getpid();
-			break;
-		case TASK_PPID:
-			right_max = sys_getppid();
-			break;
-		case PATH1_UID:
-			if (!obj->path1_valid)
-				goto out;
-			right_max = obj->path1_stat.uid;
-			break;
-		case PATH1_GID:
-			if (!obj->path1_valid)
-				goto out;
-			right_max = obj->path1_stat.gid;
-			break;
-		case PATH1_INO:
-			if (!obj->path1_valid)
-				goto out;
-			right_max = obj->path1_stat.ino;
-			break;
-		case PATH1_PARENT_UID:
-			if (!obj->path1_parent_valid)
-				goto out;
-			right_max = obj->path1_parent_stat.uid;
-			break;
-		case PATH1_PARENT_GID:
-			if (!obj->path1_parent_valid)
-				goto out;
-			right_max = obj->path1_parent_stat.gid;
-			break;
-		case PATH1_PARENT_INO:
-			if (!obj->path1_parent_valid)
-				goto out;
-			right_max = obj->path1_parent_stat.ino;
-			break;
-		case PATH2_PARENT_UID:
-			if (!obj->path2_parent_valid)
-				goto out;
-			right_max = obj->path2_parent_stat.uid;
-			break;
-		case PATH2_PARENT_GID:
-			if (!obj->path2_parent_valid)
-				goto out;
-			right_max = obj->path2_parent_stat.gid;
-			break;
-		case PATH2_PARENT_INO:
-			if (!obj->path2_parent_valid)
-				goto out;
-			right_max = obj->path2_parent_stat.ino;
-			break;
-		case EXEC_ARGC:
-			if (!bprm)
-				goto out;
-			right_max = bprm->argc;
-			i++;
-			break;
-		case EXEC_ENVC:
-			if (!bprm)
-				goto out;
-			right_max = bprm->envc;
-			i++;
-			break;
-		case TASK_STATE_0:
-			right_max = (u8) (task->tomoyo_flags >> 24);
-			break;
-		case TASK_STATE_1:
-			right_max = (u8) (task->tomoyo_flags >> 16);
-			break;
-		case TASK_STATE_2:
-			right_max = (u8) (task->tomoyo_flags >> 8);
-			break;
-		case MAX_KEYWORD:
-			right_max = *ptr;
-			ptr++;
-			i++;
-			break;
-		case MAX_KEYWORD + 1:
-			right_min = *ptr;
-			ptr++;
-			right_max = *ptr;
-			ptr++;
-			i += 2;
-			break;
+		if (right_is_bitop) {
+			if (left == PATH1_MODE || left == PATH1_PARENT_MODE
+			    || left == PATH2_PARENT_MODE) {
+				if (match) {
+					if ((left_max & right_max))
+						continue;
+				} else {
+					if (!(left_max & right_max))
+						continue;
+				}
+			}
+			goto out;
 		}
-		if (right != MAX_KEYWORD + 1)
-			right_min = right_max;
+		/* Normal value range comparison. */
 		if (match) {
 			if (left_min <= right_max && left_max >= right_min)
 				continue;
@@ -1313,8 +1422,7 @@
 		if (!ccs_io_printf(head, "%s", i ? " " : " if "))
 			goto out;
 		if (left < MAX_KEYWORD) {
-			const char *keyword
-				= condition_control_keyword[left].keyword;
+			const char *keyword = condition_control_keyword[left];
 			if (!ccs_io_printf(head, "%s", keyword))
 				goto out;
 			goto print_operator;
@@ -1335,8 +1443,7 @@
 		if (!ccs_io_printf(head, "%s", match ? "=" : "!="))
 			goto out;
 		if (right < MAX_KEYWORD) {
-			const char *keyword
-				= condition_control_keyword[right].keyword;
+			const char *keyword = condition_control_keyword[right];
 			if (!ccs_io_printf(head, "%s", keyword))
 				goto out;
 			continue;
@@ -1399,3 +1506,33 @@
  out:
 	return false;
 }
+
+/**
+ * ccs_handler_cond - Create conditional part for execute_handler process.
+ *
+ * Returns pointer to "struct condition_list" if current process is an
+ * execute handler, NULL otherwise.
+ */
+const struct condition_list *ccs_handler_cond(void)
+{
+	static const struct condition_list *cond;
+	if (!(current->tomoyo_flags & TOMOYO_TASK_IS_EXECUTE_HANDLER))
+		return NULL;
+	if (!cond) {
+		static u8 counter = 20;
+		const char *str = "if task.type=execute_handler";
+		const int len = strlen(str) + 1;
+		char *tmp = kzalloc(len, GFP_KERNEL);
+		if (tmp) {
+			memmove(tmp, str, len);
+			cond = ccs_find_or_assign_new_condition(tmp);
+			kfree(tmp);
+		}
+		if (!cond && counter) {
+			counter--;
+			printk(KERN_WARNING "TOMOYO-WARNING: Failed to create "
+			       "condition for execute_handler.\n");
+		}
+	}
+	return cond;
+}
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c	(working copy)
@@ -169,8 +169,8 @@
 		return ccs_check_supervisor(r, KEYWORD_ALLOW_ARGV0 "%s %s\n",
 					    filename->name, argv0);
 	if (r->mode == 1 && ccs_check_domain_quota(r->domain))
-		update_argv0_entry(filename->name, argv0, r->domain, NULL,
-				   false);
+		update_argv0_entry(filename->name, argv0, r->domain,
+				   ccs_handler_cond(), false);
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/sakura_umount.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_umount.c	(revision 1878)
+++ trunk/1.6.x/ccs-patch/fs/sakura_umount.c	(working copy)
@@ -21,28 +21,22 @@
 #include <linux/namespace.h>
 #endif
 
-/* Structure for "deny_unmount" keyword. */
-struct no_umount_entry {
-	struct list1_head list;
-	const struct path_info *dir;
-	bool is_deleted;
-};
-
-/* The list for "struct no_umount_entry". */
-static LIST1_HEAD(no_umount_list);
-
 /**
  * update_no_umount_acl - Update "struct no_umount_entry" list.
  *
  * @dir:       The name of directrory.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL. 
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int update_no_umount_acl(const char *dir, const bool is_delete)
+static int update_no_umount_acl(const char *dir, struct domain_info *domain,
+				const struct condition_list *condition,
+				const bool is_delete)
 {
-	struct no_umount_entry *new_entry;
-	struct no_umount_entry *ptr;
+	struct acl_info *ptr;
+	struct no_umount_entry *acl;
 	const struct path_info *saved_dir;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
@@ -52,10 +46,18 @@
 	if (!saved_dir)
 		return -ENOMEM;
 	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &no_umount_list, list) {
-		if (ptr->dir != saved_dir)
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+                if (ccs_acl_type1(ptr) != TYPE_NO_UMOUNT_ACL)
+                        continue;
+                if (ccs_get_condition_part(ptr) != condition)
+                        continue;
+		acl = container_of(ptr, struct no_umount_entry, head);
+		if (acl->dir != saved_dir)
 			continue;
-		ptr->is_deleted = is_delete;
+		if (is_delete)
+			ptr->type |= ACL_DELETED;
+		else
+			ptr->type &= ~ACL_DELETED;
 		error = 0;
 		goto out;
 	}
@@ -63,16 +65,14 @@
 		error = -ENOENT;
 		goto out;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
+	acl = ccs_alloc_acl_element(TYPE_NO_UMOUNT_ACL, condition);
+	if (!acl)
 		goto out;
-	new_entry->dir = saved_dir;
-	list1_add_tail_mb(&new_entry->list, &no_umount_list);
-	error = 0;
+	acl->dir = saved_dir;
+	error = ccs_add_domain_acl(domain, &acl->head);
 	printk(KERN_CONT "%sDon't allow umount %s\n", ccs_log_level, dir);
  out:
 	mutex_unlock(&lock);
-	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 	return error;
 }
 
@@ -89,7 +89,7 @@
 	int error;
 	const char *dir0;
 	bool is_enforce;
-	struct no_umount_entry *ptr;
+	struct acl_info *ptr;
 	struct path_info dir;
 	bool found = false;
 	if (!ccs_can_sleep())
@@ -105,11 +105,14 @@
 		goto out;
 	dir.name = dir0;
 	ccs_fill_path_info(&dir);
-	list1_for_each_entry(ptr, &no_umount_list, list) {
-		if (ptr->is_deleted)
+	list1_for_each_entry(ptr, &r.domain->acl_info_list, list) {
+		struct no_umount_entry *acl;
+		if (ccs_acl_type2(ptr) != TYPE_NO_UMOUNT_ACL)
+                        continue;
+		acl = container_of(ptr, struct no_umount_entry, head);
+		if (!ccs_path_matches_pattern(&dir, acl->dir) ||
+		    !ccs_check_condition(&r, ptr))
 			continue;
-		if (!ccs_path_matches_pattern(&dir, ptr->dir))
-			continue;
 		found = true;
 		break;
 	}
@@ -139,35 +142,15 @@
  * ccs_write_no_umount_policy - Write "struct no_umount_entry" list.
  *
  * @data:      String to parse.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL. 
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on sucess, negative value otherwise.
  */
-int ccs_write_no_umount_policy(char *data, const bool is_delete)
+int ccs_write_no_umount_policy(char *data, struct domain_info *domain,
+			       const struct condition_list *condition,
+			       const bool is_delete)
 {
-	return update_no_umount_acl(data, is_delete);
+	return update_no_umount_acl(data, domain, condition, is_delete);
 }
-
-/**
- * ccs_read_no_umount_policy - Read "struct no_umount_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_read_no_umount_policy(struct ccs_io_buffer *head)
-{
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &no_umount_list) {
-		struct no_umount_entry *ptr;
-		ptr = list1_entry(pos, struct no_umount_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		if (!ccs_io_printf(head, KEYWORD_DENY_UNMOUNT "%s\n",
-				   ptr->dir->name))
-			goto out;
-	}
-	return true;
- out:
-	return false;
-}
