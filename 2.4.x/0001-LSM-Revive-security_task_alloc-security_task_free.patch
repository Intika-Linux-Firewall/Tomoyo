From 273eae691eb0f53bb9045ce067d08551d3be8191 Mon Sep 17 00:00:00 2001
From: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date: Sun, 23 Jan 2011 12:26:50 +0900
Subject: [PATCH] LSM: Revive security_task_alloc()/security_task_free() hooks.

If a task is doing do_execve(), the kernel does not allow other threads to
access the task's new "struct cred" which will be used if do_execve() succeeds.

The "void *security" variable which is used by LSM modules is embedded into
"struct cred". Thus, other threads cannot access the "void *security" of the
task's new "struct cred" until do_execve() succeeds.

The aforementioned behavior is conflicting with TOMOYO's interactive enforcing
mode. TOMOYO allows administrators to interactively determine whether to grant
the access request or not. ( http://www.youtube.com/watch?v=t_jZZfmNKpc )

Inside do_execve(), TOMOYO checks interpreter's read permission (and will check
environment variable names in the future) using "void *security" of the task's
new "struct cred".

To make TOMOYO's interactive enforcing mode work, the kernel needs to allow
other threads to access the "void *security" of the task's new "struct cred"
before do_execve() succeeds. But making the task's new "struct cred" visible to
other threads before do_execve() succeeds (in order to allow other threads to
access "void *security" of the task's new "struct cred" for the sake of
TOMOYO's interactive enforcing mode) is not acceptable because it will break
other subsystems.

The credentials mechanism also conflicts with TOMOYO outside do_execve(), for
the mapping of "struct cred" and "struct task_struct" is not one to one.
TOMOYO wants to use per a "struct task_struct" variables but a "struct cred"
might be shared between multiple threads. Also, a "struct task_struct" can
temporarily have multiple "struct cred" instances but these instances are
switched without calling LSM hooks. TOMOYO cannot carry changes made against
previous "struct cred"->security to next "struct cred"->security.
These limitations indicate that "struct cred"->security is not suitable for
maintaining per a "struct task_struct" variables.

Therefore, this patch revives security_task_alloc()/security_task_free() hooks.
By reviving these hooks, TOMOYO can use per a "struct task_struct" variables
rather than per a "struct cred" variables by maintaining "void *security" in an
external hashtable rather than "struct cred".

This patch will pave the way for running multiple LSM modules in parallel, for
each LSM module can maintain "void *security" in its own table rather than
scrambling for "void *security" of "struct cred" (e.g. SELinux/SMACK/AppArmor
can use "struct cred"->security if TOMOYO uses external hashtable).
Currently, TOMOYO is the only in-tree LSM module who wants this patch.
But other currently out-of-tree LSM modules (e.g. YAMA) can use these hooks
when it became possible to run multiple LSM modules in parallel.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 include/linux/security.h |   22 ++++++++++++++++++++++
 kernel/fork.c            |    5 +++++
 security/capability.c    |   11 +++++++++++
 security/security.c      |   10 ++++++++++
 4 files changed, 48 insertions(+), 0 deletions(-)

diff --git a/include/linux/security.h b/include/linux/security.h
index c642bb8..5d45ea2 100644
--- a/include/linux/security.h
+++ b/include/linux/security.h
@@ -636,6 +636,15 @@ static inline void security_free_mnt_opts(struct security_mnt_opts *opts)
  *	manual page for definitions of the @clone_flags.
  *	@clone_flags contains the flags indicating what should be shared.
  *	Return 0 if permission is granted.
+ * @task_alloc_security:
+ *      Copy current thread's per task_struct variables to a chlid thread.
+ *      Note that the task_struct does not provide ->security field.
+ *      @p contains the task_struct for child process.
+ *      Return 0 on success, negative value otherwise.
+ * @task_free_security:
+ *      Clean up per task_struct variables.
+ *      Note that this hook is also called when security_task_alloc() failed.
+ *      @p contains the task_struct.
  * @cred_alloc_blank:
  *	@cred points to the credentials.
  *	@gfp indicates the atomicity of any memory allocations.
@@ -1490,6 +1499,8 @@ struct security_operations {
 	int (*dentry_open) (struct file *file, const struct cred *cred);
 
 	int (*task_create) (unsigned long clone_flags);
+	int (*task_alloc_security) (struct task_struct *p);
+	void (*task_free_security) (struct task_struct *p);
 	int (*cred_alloc_blank) (struct cred *cred, gfp_t gfp);
 	void (*cred_free) (struct cred *cred);
 	int (*cred_prepare)(struct cred *new, const struct cred *old,
@@ -1744,6 +1755,8 @@ int security_file_send_sigiotask(struct task_struct *tsk,
 int security_file_receive(struct file *file);
 int security_dentry_open(struct file *file, const struct cred *cred);
 int security_task_create(unsigned long clone_flags);
+int security_task_alloc(struct task_struct *p);
+void security_task_free(struct task_struct *p);
 int security_cred_alloc_blank(struct cred *cred, gfp_t gfp);
 void security_cred_free(struct cred *cred);
 int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp);
@@ -2245,6 +2258,15 @@ static inline int security_dentry_open(struct file *file,
 	return 0;
 }
 
+static inline int security_task_alloc(struct task_struct *p)
+{
+	return 0;
+}
+
+static inline void security_task_free(struct task_struct *p)
+{
+}
+
 static inline int security_task_create(unsigned long clone_flags)
 {
 	return 0;
diff --git a/kernel/fork.c b/kernel/fork.c
index d9b44f2..ffb1300 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -189,6 +189,7 @@ void __put_task_struct(struct task_struct *tsk)
 	delayacct_tsk_free(tsk);
 	put_signal_struct(tsk->signal);
 
+	security_task_free(tsk);
 	if (!profile_handoff_task(tsk))
 		free_task(tsk);
 }
@@ -1141,6 +1142,9 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 
 	if ((retval = audit_alloc(p)))
 		goto bad_fork_cleanup_policy;
+	retval = security_task_alloc(p);
+	if (retval)
+		goto bad_fork_cleanup_audit;
 	/* copy all the process information */
 	if ((retval = copy_semundo(clone_flags, p)))
 		goto bad_fork_cleanup_audit;
@@ -1328,6 +1332,7 @@ bad_fork_cleanup_semundo:
 	exit_sem(p);
 bad_fork_cleanup_audit:
 	audit_free(p);
+	security_task_free(p);
 bad_fork_cleanup_policy:
 	perf_event_free_task(p);
 #ifdef CONFIG_NUMA
diff --git a/security/capability.c b/security/capability.c
index 2a5df2b..6d34770 100644
--- a/security/capability.c
+++ b/security/capability.c
@@ -358,6 +358,15 @@ static int cap_task_create(unsigned long clone_flags)
 	return 0;
 }
 
+static int cap_task_alloc_security(struct task_struct *p)
+{
+	return 0;
+}
+
+static void cap_task_free_security(struct task_struct *p)
+{
+}
+
 static int cap_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 {
 	return 0;
@@ -954,6 +963,8 @@ void __init security_fixup_ops(struct security_operations *ops)
 	set_to_cap_if_null(ops, file_receive);
 	set_to_cap_if_null(ops, dentry_open);
 	set_to_cap_if_null(ops, task_create);
+	set_to_cap_if_null(ops, task_alloc_security);
+	set_to_cap_if_null(ops, task_free_security);
 	set_to_cap_if_null(ops, cred_alloc_blank);
 	set_to_cap_if_null(ops, cred_free);
 	set_to_cap_if_null(ops, cred_prepare);
diff --git a/security/security.c b/security/security.c
index 739e403..f96c436 100644
--- a/security/security.c
+++ b/security/security.c
@@ -696,6 +696,16 @@ int security_task_create(unsigned long clone_flags)
 	return security_ops->task_create(clone_flags);
 }
 
+int security_task_alloc(struct task_struct *p)
+{
+	return security_ops->task_alloc_security(p);
+}
+
+void security_task_free(struct task_struct *p)
+{
+	security_ops->task_free_security(p);
+}
+
 int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 {
 	return security_ops->cred_alloc_blank(cred, gfp);
-- 
1.6.1

