Subject: TOMOYO: Remove unused argument from request_info.

Since TOMOYO always uses current domain for checking permission, domain
argument is no longer needed.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.h |   43 ++++++++++++++++++++++++++++---------------
 security/tomoyo/domain.c |   14 ++++++++++++--
 security/tomoyo/file.c   |   14 ++++++++------
 security/tomoyo/mount.c  |    2 +-
 security/tomoyo/util.c   |   12 +++---------
 5 files changed, 52 insertions(+), 33 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -231,17 +231,12 @@ struct tomoyo_acl_head {
 	bool is_deleted;
 } __packed;
 
-/*
- * tomoyo_request_info is a structure which is used for holding
- *
- * (1) Domain information of current process.
- * (2) How many retries are made for this request.
- * (3) Profile number used for this request.
- * (4) Access control mode of the profile.
- */
+/* Structure for request info. */
 struct tomoyo_request_info {
-	struct tomoyo_domain_info *domain;
-	/* For holding parameters. */
+	/*
+	 * For holding parameters.
+	 * Pointers in this union are not NULL except path->matched_path.
+	 */
 	union {
 		struct {
 			const struct tomoyo_path_info *filename;
@@ -274,11 +269,31 @@ struct tomoyo_request_info {
 			int need_dev;
 		} mount;
 	} param;
+	/* One of values in "enum tomoyo_acl_entry_type_index". */
 	u8 param_type;
-	bool granted;
+	bool granted; /* True if granted, false otherwise. */
+	/*
+	 * For counting number of retries made for this request.
+	 * This counter is incremented whenever tomoyo_supervisor() returned
+	 * TOMOYO_RETRY_REQUEST.
+	 */
 	u8 retry;
+	/*
+	 * For holding profile number used for this request.
+	 * One of values between 0 and TOMOYO_MAX_PROFILES - 1.
+	 */
 	u8 profile;
-	u8 mode; /* One of tomoyo_mode_index . */
+	/*
+	 * For holding operation mode used for this request.
+	 * One of TOMOYO_CONFIG_DISABLED, TOMOYO_CONFIG_LEARNING,
+	 * TOMOYO_CONFIG_PERMISSIVE, TOMOYO_CONFIG_ENFORCING.
+	 */
+	u8 mode;
+	/*
+	 * For holding operation index used for this request.
+	 * Used by tomoyo_init_request_info() / tomoyo_get_mode() /
+	 * tomoyo_write_log(). One of values in "enum tomoyo_mac_index".
+	 */
 	u8 type;
 };
 
@@ -781,9 +796,7 @@ bool tomoyo_tokenize(char *buffer, char 
 /* Write domain policy violation warning message to console? */
 bool tomoyo_verbose_mode(const struct tomoyo_domain_info *domain);
 /* Fill "struct tomoyo_request_info". */
-int tomoyo_init_request_info(struct tomoyo_request_info *r,
-			     struct tomoyo_domain_info *domain,
-			     const u8 index);
+int tomoyo_init_request_info(struct tomoyo_request_info *r, const u8 index);
 /* Check permission for mount operation. */
 int tomoyo_mount_permission(char *dev_name, struct path *path, char *type,
 			    unsigned long flags, void *data_page);
--- security-testing-2.6.orig/security/tomoyo/domain.c
+++ security-testing-2.6/security/tomoyo/domain.c
@@ -109,11 +109,21 @@ int tomoyo_update_domain(struct tomoyo_a
 	return error;
 }
 
+/**
+ * tomoyo_check_acl - Do permission check.
+ *
+ * @r:           Pointer to "struct tomoyo_request_info".
+ * @check_entry: Callback function to check type specific parameters.
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
 void tomoyo_check_acl(struct tomoyo_request_info *r,
 		      bool (*check_entry) (struct tomoyo_request_info *,
 					   const struct tomoyo_acl_info *))
 {
-	const struct tomoyo_domain_info *domain = r->domain;
+	const struct tomoyo_domain_info *domain = tomoyo_current_domain();
 	struct tomoyo_acl_info *ptr;
 
 	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
@@ -425,7 +435,7 @@ int tomoyo_find_next_domain(struct linux
 	bool need_kfree = false;
 	struct tomoyo_path_info rn = { }; /* real name */
 
-	mode = tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_EXECUTE);
+	mode = tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_EXECUTE);
 	is_enforce = (mode == TOMOYO_CONFIG_ENFORCING);
 	if (!tmp)
 		goto out;
--- security-testing-2.6.orig/security/tomoyo/file.c
+++ security-testing-2.6/security/tomoyo/file.c
@@ -571,6 +571,8 @@ int tomoyo_path_permission(struct tomoyo
 			   const struct tomoyo_path_info *filename)
 {
 	int error;
+	const bool ignore_global_allow_read =
+		tomoyo_current_domain()->ignore_global_allow_read;
 
 	r->type = tomoyo_p2mac[operation];
 	r->mode = tomoyo_get_mode(r->profile, r->type);
@@ -582,7 +584,7 @@ int tomoyo_path_permission(struct tomoyo
 	do {
 		tomoyo_check_acl(r, tomoyo_check_path_acl);
 		if (!r->granted && operation == TOMOYO_TYPE_READ &&
-		    !r->domain->ignore_global_allow_read &&
+		    !ignore_global_allow_read &&
 		    tomoyo_globally_readable_file(filename))
 			r->granted = true;
 		error = tomoyo_audit_path_log(r);
@@ -676,7 +678,7 @@ int tomoyo_path_number_perm(const u8 typ
 	struct tomoyo_path_info buf;
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])
+	if (tomoyo_init_request_info(&r, tomoyo_pn2mac[type])
 	    == TOMOYO_CONFIG_DISABLED || !path->mnt || !path->dentry)
 		return 0;
 	idx = tomoyo_read_lock();
@@ -731,7 +733,7 @@ int tomoyo_check_open_permission(struct 
 	r.mode = TOMOYO_CONFIG_DISABLED;
 	idx = tomoyo_read_lock();
 	if (acc_mode &&
-	    tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_OPEN)
+	    tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_OPEN)
 	    != TOMOYO_CONFIG_DISABLED) {
 		if (!tomoyo_get_realpath(&buf, path)) {
 			error = -ENOMEM;
@@ -772,7 +774,7 @@ int tomoyo_path_perm(const u8 operation,
 
 	if (!path->mnt)
 		return 0;
-	if (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])
+	if (tomoyo_init_request_info(&r, tomoyo_p2mac[operation])
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	is_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);
@@ -815,7 +817,7 @@ int tomoyo_mkdev_perm(const u8 operation
 	int idx;
 
 	if (!path->mnt ||
-	    tomoyo_init_request_info(&r, NULL, tomoyo_pnnn2mac[operation])
+	    tomoyo_init_request_info(&r, tomoyo_pnnn2mac[operation])
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	idx = tomoyo_read_lock();
@@ -857,7 +859,7 @@ int tomoyo_path2_perm(const u8 operation
 	int idx;
 
 	if (!path1->mnt || !path2->mnt ||
-	    tomoyo_init_request_info(&r, NULL, tomoyo_pp2mac[operation])
+	    tomoyo_init_request_info(&r, tomoyo_pp2mac[operation])
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	buf1.name = NULL;
--- security-testing-2.6.orig/security/tomoyo/mount.c
+++ security-testing-2.6/security/tomoyo/mount.c
@@ -178,7 +178,7 @@ int tomoyo_mount_permission(char *dev_na
 	int error;
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_MOUNT)
+	if (tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_MOUNT)
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
--- security-testing-2.6.orig/security/tomoyo/util.c
+++ security-testing-2.6/security/tomoyo/util.c
@@ -817,20 +817,14 @@ int tomoyo_get_mode(const u8 profile, co
  * tomoyo_init_request_info - Initialize "struct tomoyo_request_info" members.
  *
  * @r:      Pointer to "struct tomoyo_request_info" to initialize.
- * @domain: Pointer to "struct tomoyo_domain_info". NULL for tomoyo_domain().
  * @index:  Index number of functionality.
  *
  * Returns mode.
  */
-int tomoyo_init_request_info(struct tomoyo_request_info *r,
-			     struct tomoyo_domain_info *domain, const u8 index)
+int tomoyo_init_request_info(struct tomoyo_request_info *r, const u8 index)
 {
-	u8 profile;
+	const u8 profile = tomoyo_domain()->profile;
 	memset(r, 0, sizeof(*r));
-	if (!domain)
-		domain = tomoyo_domain();
-	r->domain = domain;
-	profile = domain->profile;
 	r->profile = profile;
 	r->type = index;
 	r->mode = tomoyo_get_mode(profile, index);
@@ -864,7 +858,7 @@ const char *tomoyo_last_word(const char 
 bool tomoyo_domain_quota_is_ok(struct tomoyo_request_info *r)
 {
 	unsigned int count = 0;
-	struct tomoyo_domain_info *domain = r->domain;
+	struct tomoyo_domain_info * const domain = tomoyo_current_domain();
 	struct tomoyo_acl_info *ptr;
 
 	if (r->mode != TOMOYO_CONFIG_LEARNING)
