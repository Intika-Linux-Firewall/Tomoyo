Subject: TOMOYO: Add ACL group support.

ACL group allows administrator to globally grant not only "file read"
permission but also other permissions.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.c |   47 ++++++++++++++++++++++++++++++++++++++++++++---
 security/tomoyo/common.h |   16 ++++++++++++----
 security/tomoyo/domain.c |   16 ++++++++++++++++
 security/tomoyo/gc.c     |    3 +++
 security/tomoyo/memory.c |    2 ++
 5 files changed, 77 insertions(+), 7 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/common.c
+++ security-testing-2.6/security/tomoyo/common.c
@@ -869,7 +869,7 @@ static int tomoyo_write_domain(struct to
 	else if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_SELECT))
 		is_select = true;
 	if (is_select && tomoyo_select_one(head, data))
-		return 0;
+		return -EAGAIN;
 	/* Don't allow updating policies by non manager programs. */
 	if (!tomoyo_manager())
 		return -EPERM;
@@ -893,6 +893,12 @@ static int tomoyo_write_domain(struct to
 			domain->profile = (u8) profile;
 		return 0;
 	}
+	if (sscanf(data, "use_group %u\n", &profile) == 1
+	    && profile < TOMOYO_MAX_ACL_GROUPS) {
+		if (!is_delete)
+			domain->group = (u8) profile;
+		return 0;
+	}
 	if (!strcmp(data, TOMOYO_KEYWORD_QUOTA_EXCEEDED)) {
 		domain->quota_warned = !is_delete;
 		return 0;
@@ -905,7 +911,7 @@ static int tomoyo_write_domain(struct to
 }
 
 /**
- * tomoyo_set_group - Print category name.
+ * tomoyo_set_group - Print "acl_group " header keyword and category name.
  *
  * @head:     Pointer to "struct tomoyo_io_buffer".
  * @category: Category name.
@@ -915,6 +921,9 @@ static int tomoyo_write_domain(struct to
 static void tomoyo_set_group(struct tomoyo_io_buffer *head,
 			     const char *category)
 {
+	if (head->type == TOMOYO_EXCEPTIONPOLICY)
+		tomoyo_io_printf(head, "acl_group %u ",
+				 head->r.acl_group_index);
 	tomoyo_set_string(head, category);
 }
 
@@ -1083,6 +1092,8 @@ static void tomoyo_read_domain(struct to
 			tomoyo_io_printf(head,
 					 TOMOYO_KEYWORD_USE_PROFILE "%u\n",
 					 domain->profile);
+			tomoyo_io_printf(head, "use_group %u\n",
+					 domain->group);
 			if (domain->quota_warned)
 				tomoyo_set_string(head, "quota_exceeded\n");
 			if (domain->transition_failed)
@@ -1267,6 +1278,14 @@ static int tomoyo_write_exception(struct
 		{ TOMOYO_KEYWORD_AGGREGATOR, tomoyo_write_aggregator },
 	};
 
+	if (!is_delete && tomoyo_str_starts(&data, "select ") &&
+	    !strcmp(data, "transition_only")) {
+		head->r.print_transition_related_only = true;
+		return -EAGAIN;
+	}
+	/* Don't allow updating policies by non manager programs. */
+	if (!tomoyo_manager())
+		return -EPERM;
 	for (i = 0; i < TOMOYO_MAX_TRANSITION_TYPE; i++)
 		if (tomoyo_str_starts(&data, tomoyo_transition_type[i]))
 			return tomoyo_write_transition_control(data, is_delete,
@@ -1277,6 +1296,18 @@ static int tomoyo_write_exception(struct
 	for (i = 0; i < TOMOYO_MAX_GROUP; i++)
 		if (tomoyo_str_starts(&data, tomoyo_group_name[i]))
 			return tomoyo_write_group(data, is_delete, i);
+	if (tomoyo_str_starts(&data, "acl_group ")) {
+		unsigned int group;
+		if (sscanf(data, "%u", &group) == 1 &&
+		    group < TOMOYO_MAX_ACL_GROUPS) {
+			data = strchr(data, ' ');
+			if (data)
+				return tomoyo_write_domain2(data + 1,
+							    &tomoyo_acl_group
+							    [group],
+							    is_delete);
+		}
+	}
 	return -EINVAL;
 }
 
@@ -1400,6 +1431,15 @@ static void tomoyo_read_exception(struct
 		head->r.step++;
 	if (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP)
 		return;
+	while (head->r.step < TOMOYO_MAX_POLICY + TOMOYO_MAX_GROUP
+	       + TOMOYO_MAX_ACL_GROUPS) {
+		head->r.acl_group_index = head->r.step - TOMOYO_MAX_POLICY
+			- TOMOYO_MAX_GROUP;
+		if (!tomoyo_read_domain2(head, &tomoyo_acl_group
+					 [head->r.acl_group_index]))
+			return;
+		head->r.step++;
+	}
 	head->r.eof = true;
 }
 
@@ -1932,7 +1972,8 @@ int tomoyo_write_control(struct file *fi
 		return -EFAULT;
 	/* Don't allow updating policies by non manager programs. */
 	if (head->write != tomoyo_write_pid &&
-	    head->write != tomoyo_write_domain && !tomoyo_manager())
+	    head->write != tomoyo_write_domain &&
+	    head->write != tomoyo_write_exception && !tomoyo_manager())
 		return -EPERM;
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -38,6 +38,9 @@ struct linux_binprm;
 /* Profile number is an integer between 0 and 255. */
 #define TOMOYO_MAX_PROFILES 256
 
+/* Group number is an integer between 0 and 255. */
+#define TOMOYO_MAX_ACL_GROUPS 256
+
 /* Index numbers for operation mode. */
 enum tomoyo_mode_index {
 	TOMOYO_CONFIG_DISABLED,
@@ -394,11 +397,12 @@ struct tomoyo_acl_info {
  *  (2) "acl_info_list" which is linked to "struct tomoyo_acl_info".
  *  (3) "domainname" which holds the name of the domain.
  *  (4) "profile" which remembers profile number assigned to this domain.
- *  (5) "is_deleted" is a bool which is true if this domain is marked as
+ *  (5) "group" which remembers group number assigned to this domain.
+ *  (6) "is_deleted" is a bool which is true if this domain is marked as
  *      "deleted", false otherwise.
- *  (6) "quota_warned" is a bool which is used for suppressing warning message
+ *  (7) "quota_warned" is a bool which is used for suppressing warning message
  *      when learning mode learned too much entries.
- *  (7) "transition_failed" is a bool which is set to true when this domain was
+ *  (8) "transition_failed" is a bool which is set to true when this domain was
  *      unable to create a new domain at tomoyo_find_next_domain() because the
  *      name of the domain to be created was too long or it could not allocate
  *      memory. If set to true, more than one process continued execve()
@@ -417,6 +421,7 @@ struct tomoyo_domain_info {
 	/* Name of this domain. Never NULL.          */
 	const struct tomoyo_path_info *domainname;
 	u8 profile;        /* Profile number to use. */
+	u8 group;          /* Group number to use.   */
 	bool is_deleted;   /* Delete flag.           */
 	bool quota_warned; /* Quota warnning flag.   */
 	bool transition_failed; /* Domain transition failed flag. */
@@ -535,7 +540,7 @@ struct tomoyo_acl_param {
 	bool is_delete;
 };
 
-#define TOMOYO_MAX_IO_READ_QUEUE 32
+#define TOMOYO_MAX_IO_READ_QUEUE 64
 
 /*
  * Structure for reading/writing policy via /sys/kernel/security/tomoyo
@@ -559,6 +564,7 @@ struct tomoyo_io_buffer {
 		int step;
 		int query_index;
 		u16 index;
+		u8 acl_group_index;
 		u8 bit;
 		u8 w_pos;
 		bool eof;
@@ -928,6 +934,8 @@ extern struct mutex tomoyo_policy_lock;
 /* Has /sbin/init started? */
 extern bool tomoyo_policy_loaded;
 
+extern struct tomoyo_domain_info tomoyo_acl_group[TOMOYO_MAX_ACL_GROUPS];
+
 /* The kernel's domain. */
 extern struct tomoyo_domain_info tomoyo_kernel_domain;
 
--- security-testing-2.6.orig/security/tomoyo/domain.c
+++ security-testing-2.6/security/tomoyo/domain.c
@@ -12,6 +12,15 @@
 
 /* Variables definitions.*/
 
+/*
+ * The global domains referred by "use_group" keyword.
+ *
+ * Although "use_group" needs only "struct list_head acl_info_list[2]",
+ * we define structure for "use_group" as "struct tomoyo_domain_info" in order
+ * to use common code.
+ */
+struct tomoyo_domain_info tomoyo_acl_group[TOMOYO_MAX_ACL_GROUPS];
+
 /* The initial domain. */
 struct tomoyo_domain_info tomoyo_kernel_domain;
 
@@ -127,7 +136,9 @@ void tomoyo_check_acl(struct tomoyo_requ
 {
 	const struct tomoyo_domain_info *domain = tomoyo_current_domain();
 	struct tomoyo_acl_info *ptr;
+	bool retried = false;
 
+retry:
 	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
 		if (ptr->is_deleted || ptr->type != r->param_type)
 			continue;
@@ -136,6 +147,11 @@ void tomoyo_check_acl(struct tomoyo_requ
 			return;
 		}
 	}
+	if (!retried) {
+		retried = true;
+		domain = &tomoyo_acl_group[domain->group];
+		goto retry;
+	}
 	r->granted = false;
 }
 
--- security-testing-2.6.orig/security/tomoyo/gc.c
+++ security-testing-2.6/security/tomoyo/gc.c
@@ -242,6 +242,9 @@ static void tomoyo_collect_entry(void)
 		if (!tomoyo_collect_member(&tomoyo_policy_list[i], i))
 			goto unlock;
 	}
+	for (i = 0; i < TOMOYO_MAX_ACL_GROUPS; i++)
+		if (!tomoyo_collect_acl(&tomoyo_acl_group[i]))
+			goto unlock;
 	{
 		struct tomoyo_domain_info *domain;
 		list_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {
--- security-testing-2.6.orig/security/tomoyo/memory.c
+++ security-testing-2.6/security/tomoyo/memory.c
@@ -212,6 +212,8 @@ void __init tomoyo_mm_init(void)
 	INIT_LIST_HEAD(&tomoyo_kernel_domain.acl_info_list);
 	for (idx = 0; idx < TOMOYO_MAX_TASK_SECURITY_HASH; idx++)
 		INIT_LIST_HEAD(&tomoyo_task_security_list[idx]);
+	for (idx = 0; idx < TOMOYO_MAX_ACL_GROUPS; idx++)
+		INIT_LIST_HEAD(&tomoyo_acl_group[idx].acl_info_list);
 	tomoyo_kernel_domain.domainname = tomoyo_get_name(TOMOYO_ROOT_NAME);
 	list_add_tail_rcu(&tomoyo_kernel_domain.list, &tomoyo_domain_list);
 	idx = tomoyo_read_lock();
