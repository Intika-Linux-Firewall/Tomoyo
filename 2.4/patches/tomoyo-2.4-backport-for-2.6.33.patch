[PATCH] TOMOYO 2.4 backport patch for Linux 2.6.33

Apply this patch after overwriting security/tomoyo/ directory by doing

 $ wget -O linux-3.1.10.tar.bz2 https://www.kernel.org/pub/linux/kernel/v3.0/linux-3.1.10.tar.bz2
 $ tar -jxf linux-3.1.10.tar.bz2 --strip 1 linux-3.1.10/security/tomoyo/

.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.c        |   11 ++---
 security/tomoyo/common.h        |    4 -
 security/tomoyo/domain.c        |    4 +
 security/tomoyo/realpath.c      |   83 ++++++++++++++++++++++++++++++----------
 security/tomoyo/securityfs_if.c |    2 
 security/tomoyo/tomoyo.c        |    3 -
 security/tomoyo/util.c          |    3 -
 7 files changed, 79 insertions(+), 31 deletions(-)

--- linux-2.6.33.20.orig/security/tomoyo/common.c
+++ linux-2.6.33.20/security/tomoyo/common.c
@@ -466,8 +466,10 @@ static struct tomoyo_profile *tomoyo_ass
 			TOMOYO_CONFIG_WANT_REJECT_LOG;
 		memset(ptr->config, TOMOYO_CONFIG_USE_DEFAULT,
 		       sizeof(ptr->config));
-		ptr->pref[TOMOYO_PREF_MAX_AUDIT_LOG] = 1024;
-		ptr->pref[TOMOYO_PREF_MAX_LEARNING_ENTRY] = 2048;
+		ptr->pref[TOMOYO_PREF_MAX_AUDIT_LOG] =
+			CONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG;
+		ptr->pref[TOMOYO_PREF_MAX_LEARNING_ENTRY] =
+			CONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY;
 		mb(); /* Avoid out-of-order execution. */
 		ns->profile_ptr[profile] = ptr;
 		entry = NULL;
@@ -951,14 +953,12 @@ static bool tomoyo_select_domain(struct 
 	    (global_pid = true, sscanf(data, "global-pid=%u", &pid) == 1)) {
 		struct task_struct *p;
 		rcu_read_lock();
-		read_lock(&tasklist_lock);
 		if (global_pid)
 			p = find_task_by_pid_ns(pid, &init_pid_ns);
 		else
 			p = find_task_by_vpid(pid);
 		if (p)
 			domain = tomoyo_real_domain(p);
-		read_unlock(&tasklist_lock);
 		rcu_read_unlock();
 	} else if (!strncmp(data, "domain=", 7)) {
 		if (tomoyo_domain_def(data + 7))
@@ -1510,14 +1510,12 @@ static void tomoyo_read_pid(struct tomoy
 		global_pid = true;
 	pid = (unsigned int) simple_strtoul(buf, NULL, 10);
 	rcu_read_lock();
-	read_lock(&tasklist_lock);
 	if (global_pid)
 		p = find_task_by_pid_ns(pid, &init_pid_ns);
 	else
 		p = find_task_by_vpid(pid);
 	if (p)
 		domain = tomoyo_real_domain(p);
-	read_unlock(&tasklist_lock);
 	rcu_read_unlock();
 	if (!domain)
 		return;
@@ -2453,6 +2451,7 @@ ssize_t tomoyo_write_control(struct tomo
 		return -EFAULT;
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
+	head->read_user_buf_avail = 0;
 	idx = tomoyo_read_lock();
 	/* Read a line and dispatch it to the policy handler. */
 	while (avail_len > 0) {
--- linux-2.6.33.20.orig/security/tomoyo/common.h
+++ linux-2.6.33.20/security/tomoyo/common.h
@@ -1158,7 +1158,7 @@ static inline int tomoyo_round2(size_t s
  */
 #define list_for_each_cookie(pos, head)					\
 	if (!pos)							\
-		pos =  srcu_dereference((head)->next, &tomoyo_ss);	\
-	for ( ; pos != (head); pos = srcu_dereference(pos->next, &tomoyo_ss))
+		pos =  rcu_dereference((head)->next);	\
+	for ( ; pos != (head); pos = rcu_dereference(pos->next))
 
 #endif /* !defined(_SECURITY_TOMOYO_COMMON_H) */
--- linux-2.6.33.20.orig/security/tomoyo/domain.c
+++ linux-2.6.33.20/security/tomoyo/domain.c
@@ -501,7 +501,8 @@ struct tomoyo_domain_info *tomoyo_assign
 			 * that domain. Do not perform domain transition if
 			 * profile for that domain is not yet created.
 			 */
-			if (!entry->ns->profile_ptr[entry->profile])
+			if (tomoyo_policy_loaded &&
+			    !entry->ns->profile_ptr[entry->profile])
 				return NULL;
 		}
 		return entry;
@@ -557,6 +558,7 @@ out:
 			tomoyo_write_log(&r, "use_profile %u\n",
 					 entry->profile);
 			tomoyo_write_log(&r, "use_group %u\n", entry->group);
+			tomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);
 		}
 	}
 	return entry;
--- linux-2.6.33.20.orig/security/tomoyo/realpath.c
+++ linux-2.6.33.20/security/tomoyo/realpath.c
@@ -76,24 +76,55 @@ char *tomoyo_encode(const char *str)
  *
  * Returns the buffer on success, an error code otherwise.
  *
+ * Caller holds the dcache_lock and vfsmount_lock.
+ * Based on __d_path() in fs/dcache.c
+ *
  * If dentry is a directory, trailing '/' is appended.
  */
 static char *tomoyo_get_absolute_path(struct path *path, char * const buffer,
 				      const int buflen)
 {
-	char *pos = ERR_PTR(-ENOMEM);
-	if (buflen >= 256) {
-		/* go to whatever namespace root we are under */
-		pos = d_absolute_path(path, buffer, buflen - 1);
-		if (!IS_ERR(pos) && *pos == '/' && pos[1]) {
-			struct inode *inode = path->dentry->d_inode;
-			if (inode && S_ISDIR(inode->i_mode)) {
-				buffer[buflen - 2] = '/';
-				buffer[buflen - 1] = '\0';
-			}
+	char *pos = buffer + buflen - 1;
+	struct dentry *dentry = path->dentry;
+	struct vfsmount *vfsmnt = path->mnt;
+	const char *name;
+	int len;
+
+	if (buflen < 256)
+		goto out;
+
+	*pos = '\0';
+	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode))
+		*--pos = '/';
+	for (;;) {
+		struct dentry *parent;
+		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
+			if (vfsmnt->mnt_parent == vfsmnt)
+				break;
+			dentry = vfsmnt->mnt_mountpoint;
+			vfsmnt = vfsmnt->mnt_parent;
+			continue;
 		}
+		parent = dentry->d_parent;
+		name = dentry->d_name.name;
+		len = dentry->d_name.len;
+		pos -= len;
+		if (pos <= buffer)
+			goto out;
+		memmove(pos, name, len);
+		*--pos = '/';
+		dentry = parent;
 	}
+	if (*pos == '/')
+		pos++;
+	len = dentry->d_name.len;
+	pos -= len;
+	if (pos < buffer)
+		goto out;
+	memmove(pos, dentry->d_name.name, len);
 	return pos;
+out:
+	return ERR_PTR(-ENOMEM);
 }
 
 /**
@@ -110,17 +141,27 @@ static char *tomoyo_get_absolute_path(st
 static char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,
 				    const int buflen)
 {
-	char *pos = ERR_PTR(-ENOMEM);
-	if (buflen >= 256) {
-		pos = dentry_path_raw(dentry, buffer, buflen - 1);
-		if (!IS_ERR(pos) && *pos == '/' && pos[1]) {
-			struct inode *inode = dentry->d_inode;
-			if (inode && S_ISDIR(inode->i_mode)) {
-				buffer[buflen - 2] = '/';
-				buffer[buflen - 1] = '\0';
-			}
+	char *pos = buffer + buflen - 1;
+	if (buflen < 256)
+		return ERR_PTR(-ENOMEM);
+	*pos = '\0';
+	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode))
+		*--pos = '/';
+	spin_lock(&dcache_lock);
+	while (!IS_ROOT(dentry)) {
+		struct dentry *parent = dentry->d_parent;
+		const char *name = dentry->d_name.name;
+		const int len = dentry->d_name.len;
+		pos -= len;
+		if (pos <= buffer) {
+			pos = ERR_PTR(-ENOMEM);
+			break;
 		}
+		memmove(pos, name, len);
+		*--pos = '/';
+		dentry = parent;
 	}
+	spin_unlock(&dcache_lock);
 	return pos;
 }
 
@@ -276,7 +317,11 @@ char *tomoyo_realpath_from_path(struct p
 						    buf_len - 1);
 		/* Get absolute name for the rest. */
 		else {
+			spin_lock(&dcache_lock);
+			spin_lock(&vfsmount_lock);
 			pos = tomoyo_get_absolute_path(path, buf, buf_len - 1);
+			spin_unlock(&vfsmount_lock);
+			spin_unlock(&dcache_lock);
 			/*
 			 * Fall back to local name if absolute name is not
 			 * available.
--- linux-2.6.33.20.orig/security/tomoyo/securityfs_if.c
+++ linux-2.6.33.20/security/tomoyo/securityfs_if.c
@@ -93,7 +93,6 @@ static const struct file_operations tomo
 	.poll    = tomoyo_poll,
 	.read    = tomoyo_read,
 	.write   = tomoyo_write,
-	.llseek  = noop_llseek,
 };
 
 /**
@@ -147,6 +146,7 @@ static int __init tomoyo_initerface_init
 			    TOMOYO_MANAGER);
 	tomoyo_create_entry("version",          0400, tomoyo_dir,
 			    TOMOYO_VERSION);
+	tomoyo_load_builtin_policy();
 	return 0;
 }
 
--- linux-2.6.33.20.orig/security/tomoyo/tomoyo.c
+++ linux-2.6.33.20/security/tomoyo/tomoyo.c
@@ -157,7 +157,8 @@ static int tomoyo_inode_getattr(struct v
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int tomoyo_path_truncate(struct path *path)
+static int tomoyo_path_truncate(struct path *path, loff_t length,
+				unsigned int time_attrs)
 {
 	return tomoyo_path_perm(TOMOYO_TYPE_TRUNCATE, path, NULL);
 }
--- linux-2.6.33.20.orig/security/tomoyo/util.c
+++ linux-2.6.33.20/security/tomoyo/util.c
@@ -925,7 +925,8 @@ int tomoyo_get_mode(const struct tomoyo_
 		return TOMOYO_CONFIG_DISABLED;
 	mode = tomoyo_profile(ns, profile)->config[index];
 	if (mode == TOMOYO_CONFIG_USE_DEFAULT)
-		mode = tomoyo_profile(ns, profile)->config[category];
+		mode = tomoyo_profile(ns, profile)->config
+			[category + TOMOYO_MAX_MAC_INDEX];
 	if (mode == TOMOYO_CONFIG_USE_DEFAULT)
 		mode = tomoyo_profile(ns, profile)->default_config;
 	return mode & 3;
