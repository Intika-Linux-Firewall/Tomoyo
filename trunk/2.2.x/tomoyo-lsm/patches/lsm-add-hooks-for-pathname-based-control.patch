Subject: Introduce new LSM hooks.

This patch allows LSM to check permission using "struct vfsmount"
without passing "struct vfsmount" to VFS helper functions.

Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Signed-off-by: Toshiharu Harada <haradats@nttdata.co.jp>
---
 fs/namei.c               |   85 ++++++++++++++++----------
 fs/open.c                |    7 ++
 include/linux/security.h |  152 +++++++++++++++++++++++++++++++++++++++++++++++
 security/dummy.c         |   60 ++++++++++++++++++
 security/security.c      |   54 ++++++++++++++++
 5 files changed, 326 insertions(+), 32 deletions(-)

--- vfs.orig/fs/namei.c
+++ vfs/fs/namei.c
@@ -1613,11 +1613,13 @@ int path_create(struct path *dir_path, s
 {
 	int error = mnt_want_write(dir_path->mnt);
 
-	if (!error) {
+	if (error)
+		goto out;
+	error = security_path_create(dir_path, dentry, mode, nd);
+	if (!error)
 		error = vfs_create(dir_path->dentry, dentry, mode, nd);
-		mnt_drop_write(dir_path->mnt);
-	}
-
+	mnt_drop_write(dir_path->mnt);
+ out:
 	return error;
 }
 EXPORT_SYMBOL(path_create);
@@ -1687,6 +1689,10 @@ int may_open(struct nameidata *nd, int a
 		 * Refuse to truncate files with mandatory locks held on them.
 		 */
 		error = locks_verify_locked(inode);
+		if (!error)
+			error = security_path_truncate(&nd->path, 0,
+					       ATTR_MTIME|ATTR_CTIME|ATTR_OPEN,
+						       NULL);
 		if (!error) {
 			DQUOT_INIT(inode);
 
@@ -2078,11 +2084,13 @@ int path_mknod(struct path *dir_path, st
 {
 	int error = mnt_want_write(dir_path->mnt);
 
-	if (!error) {
+	if (error)
+		goto out;
+	error = security_path_mknod(dir_path, dentry, mode, dev);
+	if (!error)
 		error = vfs_mknod(dir_path->dentry, dentry, mode, dev);
-		mnt_drop_write(dir_path->mnt);
-	}
-
+	mnt_drop_write(dir_path->mnt);
+ out:
 	return error;
 }
 EXPORT_SYMBOL(path_mknod);
@@ -2169,11 +2177,13 @@ int path_mkdir(struct path *dir_path, st
 {
 	int error = mnt_want_write(dir_path->mnt);
 
-	if (!error) {
+	if (error)
+		goto out;
+	error = security_path_mkdir(dir_path, dentry, mode);
+	if (!error)
 		error = vfs_mkdir(dir_path->dentry, dentry, mode);
-		mnt_drop_write(dir_path->mnt);
-	}
-
+	mnt_drop_write(dir_path->mnt);
+ out:
 	return error;
 }
 EXPORT_SYMBOL(path_mkdir);
@@ -2281,11 +2291,13 @@ int path_rmdir(struct path *dir_path, st
 {
 	int error = mnt_want_write(dir_path->mnt);
 
-	if (!error) {
+	if (error)
+		goto out;
+	error = security_path_rmdir(dir_path, dentry);
+	if (!error)
 		error = vfs_rmdir(dir_path->dentry, dentry);
-		mnt_drop_write(dir_path->mnt);
-	}
-
+	mnt_drop_write(dir_path->mnt);
+ out:
 	return error;
 }
 EXPORT_SYMBOL(path_rmdir);
@@ -2373,11 +2385,13 @@ int path_unlink(struct path *dir_path, s
 {
 	int error = mnt_want_write(dir_path->mnt);
 
-	if (!error) {
+	if (error)
+		goto out;
+	error = security_path_unlink(dir_path, dentry);
+	if (!error)
 		error = vfs_unlink(dir_path->dentry, dentry);
-		mnt_drop_write(dir_path->mnt);
-	}
-
+	mnt_drop_write(dir_path->mnt);
+ out:
 	return error;
 }
 EXPORT_SYMBOL(path_unlink);
@@ -2479,11 +2493,13 @@ int path_symlink(struct path *dir_path, 
 {
 	int error = mnt_want_write(dir_path->mnt);
 
-	if (!error) {
+	if (error)
+		goto out;
+	error = security_path_symlink(dir_path, dentry, oldname);
+	if (!error)
 		error = vfs_symlink(dir_path->dentry, dentry, oldname);
-		mnt_drop_write(dir_path->mnt);
-	}
-
+	mnt_drop_write(dir_path->mnt);
+ out:
 	return error;
 }
 EXPORT_SYMBOL(path_symlink);
@@ -2575,11 +2591,13 @@ int path_link(struct dentry *old_dentry,
 {
 	int error = mnt_want_write(dir_path->mnt);
 
-	if (!error) {
+	if (error)
+		goto out;
+	error = security_path_link(old_dentry, dir_path, new_dentry);
+	if (!error)
 		error = vfs_link(old_dentry, dir_path->dentry, new_dentry);
-		mnt_drop_write(dir_path->mnt);
-	}
-
+	mnt_drop_write(dir_path->mnt);
+ out:
 	return error;
 }
 EXPORT_SYMBOL(path_link);
@@ -2800,12 +2818,15 @@ int path_rename(struct path *old_dir_pat
 	BUG_ON(mnt != new_dir_path->mnt);
 
 	error = mnt_want_write(mnt);
-	if (!error) {
+	if (error)
+		goto out;
+	error = security_path_rename(old_dir_path, old_dentry,
+				     new_dir_path, new_dentry);
+	if (!error)
 		error = vfs_rename(old_dir_path->dentry, old_dentry,
 				   new_dir_path->dentry, new_dentry);
-		mnt_drop_write(mnt);
-	}
-
+	mnt_drop_write(mnt);
+ out:
 	return error;
 }
 EXPORT_SYMBOL(path_rename);
--- vfs.orig/fs/open.c
+++ vfs/fs/open.c
@@ -236,6 +236,10 @@ int do_truncate(struct dentry *dentry, l
  */
 int file_truncate(struct file *filp, loff_t length, unsigned int time_attrs)
 {
+	int error = security_path_truncate(&filp->f_path, length, time_attrs,
+					   filp);
+	if (error)
+		return error;
 	return do_truncate(filp->f_path.dentry, length, time_attrs, filp);
 }
 
@@ -287,6 +291,9 @@ static long do_sys_truncate(const char _
 	if (error)
 		goto put_write_and_out;
 
+	error = security_path_truncate(&nd.path, length, 0, NULL);
+	if (error)
+		goto put_write_and_out;
 	error = locks_verify_truncate(inode, NULL, length);
 	if (!error) {
 		DQUOT_INIT(inode);
--- vfs.orig/include/linux/security.h
+++ vfs/include/linux/security.h
@@ -343,23 +343,50 @@ static inline void security_free_mnt_opt
  *	@dentry contains the dentry structure for the file to be created.
  *	@mode contains the file mode of the file to be created.
  *	Return 0 if permission is granted.
+ * @path_create:
+ *	Check permission to create a regular file.
+ *	@dir contains path structure of the parent of the new file.
+ *	@dentry contains the dentry structure for the file to be created.
+ *	@mode contains the file mode of the file to be created.
+ *	@nd contains the nameidata structure for the parent directory.
+ *	Return 0 if permission is granted.
  * @inode_link:
  *	Check permission before creating a new hard link to a file.
  *	@old_dentry contains the dentry structure for an existing link to the file.
  *	@dir contains the inode structure of the parent directory of the new link.
  *	@new_dentry contains the dentry structure for the new link.
  *	Return 0 if permission is granted.
+ * @path_link:
+ *	Check permission before creating a new hard link to a file.
+ *	@old_dentry contains the dentry structure for an existing link
+ *	to the file.
+ *	@new_dir contains the path structure of the parent directory of
+ *	the new link.
+ *	@new_dentry contains the dentry structure for the new link.
+ *	Return 0 if permission is granted.
  * @inode_unlink:
  *	Check the permission to remove a hard link to a file.
  *	@dir contains the inode structure of parent directory of the file.
  *	@dentry contains the dentry structure for file to be unlinked.
  *	Return 0 if permission is granted.
+ * @path_unlink:
+ *	Check the permission to remove a hard link to a file.
+ *	@dir contains the path structure of parent directory of the file.
+ *	@dentry contains the dentry structure for file to be unlinked.
+ *	Return 0 if permission is granted.
  * @inode_symlink:
  *	Check the permission to create a symbolic link to a file.
  *	@dir contains the inode structure of parent directory of the symbolic link.
  *	@dentry contains the dentry structure of the symbolic link.
  *	@old_name contains the pathname of file.
  *	Return 0 if permission is granted.
+ * @path_symlink:
+ *	Check the permission to create a symbolic link to a file.
+ *	@dir contains the path structure of parent directory of
+ *	the symbolic link.
+ *	@dentry contains the dentry structure of the symbolic link.
+ *	@old_name contains the pathname of file.
+ *	Return 0 if permission is granted.
  * @inode_mkdir:
  *	Check permissions to create a new directory in the existing directory
  *	associated with inode strcture @dir.
@@ -367,11 +394,25 @@ static inline void security_free_mnt_opt
  *	@dentry contains the dentry structure of new directory.
  *	@mode contains the mode of new directory.
  *	Return 0 if permission is granted.
+ * @path_mkdir:
+ *	Check permissions to create a new directory in the existing directory
+ *	associated with path strcture @path.
+ *	@dir containst the path structure of parent of the directory
+ *	to be created.
+ *	@dentry contains the dentry structure of new directory.
+ *	@mode contains the mode of new directory.
+ *	Return 0 if permission is granted.
  * @inode_rmdir:
  *	Check the permission to remove a directory.
  *	@dir contains the inode structure of parent of the directory to be removed.
  *	@dentry contains the dentry structure of directory to be removed.
  *	Return 0 if permission is granted.
+ * @path_rmdir:
+ *	Check the permission to remove a directory.
+ *	@dir contains the path structure of parent of the directory to be
+ *	removed.
+ *	@dentry contains the dentry structure of directory to be removed.
+ *	Return 0 if permission is granted.
  * @inode_mknod:
  *	Check permissions when creating a special file (or a socket or a fifo
  *	file created via the mknod system call).  Note that if mknod operation
@@ -382,6 +423,15 @@ static inline void security_free_mnt_opt
  *	@mode contains the mode of the new file.
  *	@dev contains the device number.
  *	Return 0 if permission is granted.
+ * @path_mknod:
+ *	Check permissions when creating a file. Note that this hook is called
+ *	even if mknod operation is being done for a regular file.
+ *	@dir contains the path structure of parent of the new file.
+ *	@dentry contains the dentry structure of the new file.
+ *	@mode contains the mode of the new file.
+ *	@dev contains the undecoded device number. Use new_decode_dev() to get
+ *	the decoded device number.
+ *	Return 0 if permission is granted.
  * @inode_rename:
  *	Check for permission to rename a file or directory.
  *	@old_dir contains the inode structure for parent of the old link.
@@ -389,6 +439,13 @@ static inline void security_free_mnt_opt
  *	@new_dir contains the inode structure for parent of the new link.
  *	@new_dentry contains the dentry structure of the new link.
  *	Return 0 if permission is granted.
+ * @path_rename:
+ *	Check for permission to rename a file or directory.
+ *	@old_dir contains the path structure for parent of the old link.
+ *	@old_dentry contains the dentry structure of the old link.
+ *	@new_dir contains the path structure for parent of the new link.
+ *	@new_dentry contains the dentry structure of the new link.
+ *	Return 0 if permission is granted.
  * @inode_readlink:
  *	Check the permission to read the symbolic link.
  *	@dentry contains the dentry structure for the file link.
@@ -416,6 +473,13 @@ static inline void security_free_mnt_opt
  *	@dentry contains the dentry structure for the file.
  *	@attr is the iattr structure containing the new file attributes.
  *	Return 0 if permission is granted.
+ * @path_truncate:
+ *	Check permission before truncating a file.
+ *	@path contains the path structure for the file.
+ *	@length is the new length of the file.
+ *	@time_attrs is the flags passed to do_truncate().
+ *	@filp is the file structure (may be NULL).
+ *	Return 0 if permission is granted.
  * @inode_getattr:
  *	Check permission before obtaining file attributes.
  *	@mnt is the vfsmount where the dentry was looked up
@@ -1350,6 +1414,22 @@ struct security_operations {
 				   struct super_block *newsb);
 	int (*sb_parse_opts_str) (char *options, struct security_mnt_opts *opts);
 
+	int (*path_create) (struct path *dir, struct dentry *dentry, int mode,
+			    struct nameidata *nd);
+	int (*path_unlink) (struct path *dir, struct dentry *dentry);
+	int (*path_mkdir) (struct path *dir, struct dentry *dentry, int mode);
+	int (*path_rmdir) (struct path *dir, struct dentry *dentry);
+	int (*path_mknod) (struct path *dir, struct dentry *dentry, int mode,
+			   unsigned int dev);
+	int (*path_truncate) (struct path *path, loff_t length,
+			      unsigned int time_attrs, struct file *filp);
+	int (*path_symlink) (struct path *dir, struct dentry *dentry,
+			     const char *old_name);
+	int (*path_link) (struct dentry *old_dentry, struct path *new_dir,
+			  struct dentry *new_dentry);
+	int (*path_rename) (struct path *old_dir, struct dentry *old_dentry,
+			    struct path *new_dir, struct dentry *new_dentry);
+
 	int (*inode_alloc_security) (struct inode *inode);
 	void (*inode_free_security) (struct inode *inode);
 	int (*inode_init_security) (struct inode *inode, struct inode *dir,
@@ -1623,6 +1703,22 @@ void security_sb_clone_mnt_opts(const st
 				struct super_block *newsb);
 int security_sb_parse_opts_str(char *options, struct security_mnt_opts *opts);
 
+int security_path_create(struct path *dir, struct dentry *dentry, int mode,
+			 struct nameidata *nd);
+int security_path_unlink(struct path *dir, struct dentry *dentry);
+int security_path_mkdir(struct path *dir, struct dentry *dentry, int mode);
+int security_path_rmdir(struct path *dir, struct dentry *dentry);
+int security_path_mknod(struct path *dir, struct dentry *dentry, int mode,
+			unsigned int dev);
+int security_path_truncate(struct path *path, loff_t length,
+			   unsigned int time_attrs, struct file *filp);
+int security_path_symlink(struct path *dir, struct dentry *dentry,
+			  const char *old_name);
+int security_path_link(struct dentry *old_dentry, struct path *new_dir,
+		       struct dentry *new_dentry);
+int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
+			 struct path *new_dir, struct dentry *new_dentry);
+
 int security_inode_alloc(struct inode *inode);
 void security_inode_free(struct inode *inode);
 int security_inode_init_security(struct inode *inode, struct inode *dir,
@@ -1948,6 +2044,62 @@ static inline int security_sb_parse_opts
 	return 0;
 }
 
+static inline int security_path_create(struct path *dir, struct dentry *dentry,
+				       int mode, struct nameidata *nd)
+{
+	return 0;
+}
+
+static inline int security_path_unlink(struct path *dir, struct dentry *dentry)
+{
+	return 0;
+}
+
+static inline int security_path_mkdir(struct path *dir, struct dentry *dentry,
+				      int mode)
+{
+	return 0;
+}
+
+static inline int security_path_rmdir(struct path *dir, struct dentry *dentry)
+{
+	return 0;
+}
+
+static inline int security_path_mknod(struct path *dir, struct dentry *dentry,
+				      int mode, unsigned int dev)
+{
+	return 0;
+}
+
+static inline int security_path_truncate(struct path *path, loff_t length,
+					 unsigned int time_attrs,
+					 struct file *filp)
+{
+	return 0;
+}
+
+static inline int security_path_symlink(struct path *dir, struct dentry *dentry,
+					const char *old_name)
+{
+	return 0;
+}
+
+static inline int security_path_link(struct dentry *old_dentry,
+				     struct path *new_dir,
+				     struct dentry *new_dentry)
+{
+	return 0;
+}
+
+static inline int security_path_rename(struct path *old_dir,
+				       struct dentry *old_dentry,
+				       struct path *new_dir,
+				       struct dentry *new_dentry)
+{
+	return 0;
+}
+
 static inline int security_inode_alloc(struct inode *inode)
 {
 	return 0;
--- vfs.orig/security/dummy.c
+++ vfs/security/dummy.c
@@ -270,6 +270,57 @@ static int dummy_sb_parse_opts_str(char 
 	return 0;
 }
 
+static int dummy_path_create(struct path *dir, struct dentry *dentry, int mode,
+			     struct nameidata *nd)
+{
+	return 0;
+}
+
+static int dummy_path_mknod(struct path *dir, struct dentry *dentry, int mode,
+			    unsigned int dev)
+{
+	return 0;
+}
+
+static int dummy_path_mkdir(struct path *dir, struct dentry *dentry, int mode)
+{
+	return 0;
+}
+
+static int dummy_path_rmdir(struct path *dir, struct dentry *dentry)
+{
+	return 0;
+}
+
+static int dummy_path_unlink(struct path *dir, struct dentry *dentry)
+{
+	return 0;
+}
+
+static int dummy_path_symlink(struct path *dir, struct dentry *dentry,
+			      const char *old_name)
+{
+	return 0;
+}
+
+static int dummy_path_link(struct dentry *old_dentry, struct path *new_dir,
+			   struct dentry *new_dentry)
+{
+	return 0;
+}
+
+static int dummy_path_rename(struct path *old_path, struct dentry *old_dentry,
+			     struct path *new_path, struct dentry *new_dentry)
+{
+	return 0;
+}
+
+static int dummy_path_truncate(struct path *path, loff_t length,
+			       unsigned int time_attrs, struct file *filp)
+{
+	return 0;
+}
+
 static int dummy_inode_alloc_security (struct inode *inode)
 {
 	return 0;
@@ -1079,6 +1130,15 @@ void security_fixup_ops (struct security
 	set_to_dummy_if_null(ops, sb_set_mnt_opts);
 	set_to_dummy_if_null(ops, sb_clone_mnt_opts);
 	set_to_dummy_if_null(ops, sb_parse_opts_str);
+	set_to_dummy_if_null(ops, path_create);
+	set_to_dummy_if_null(ops, path_mknod);
+	set_to_dummy_if_null(ops, path_mkdir);
+	set_to_dummy_if_null(ops, path_rmdir);
+	set_to_dummy_if_null(ops, path_unlink);
+	set_to_dummy_if_null(ops, path_symlink);
+	set_to_dummy_if_null(ops, path_link);
+	set_to_dummy_if_null(ops, path_rename);
+	set_to_dummy_if_null(ops, path_truncate);
 	set_to_dummy_if_null(ops, inode_alloc_security);
 	set_to_dummy_if_null(ops, inode_free_security);
 	set_to_dummy_if_null(ops, inode_init_security);
--- vfs.orig/security/security.c
+++ vfs/security/security.c
@@ -388,6 +388,60 @@ int security_inode_init_security(struct 
 }
 EXPORT_SYMBOL(security_inode_init_security);
 
+int security_path_create(struct path *dir, struct dentry *dentry, int mode,
+			 struct nameidata *nd)
+{
+	if (unlikely(IS_PRIVATE(dir->dentry->d_inode)))
+		return 0;
+	return security_ops->path_create(dir, dentry, mode, nd);
+}
+
+int security_path_mknod(struct path *path, struct dentry *dentry, int mode,
+			unsigned int dev)
+{
+	return security_ops->path_mknod(path, dentry, mode, dev);
+}
+
+int security_path_mkdir(struct path *path, struct dentry *dentry, int mode)
+{
+	return security_ops->path_mkdir(path, dentry, mode);
+}
+
+int security_path_rmdir(struct path *path, struct dentry *dentry)
+{
+	return security_ops->path_rmdir(path, dentry);
+}
+
+int security_path_unlink(struct path *path, struct dentry *dentry)
+{
+	return security_ops->path_unlink(path, dentry);
+}
+
+int security_path_symlink(struct path *path, struct dentry *dentry,
+			  const char *old_name)
+{
+	return security_ops->path_symlink(path, dentry, old_name);
+}
+
+int security_path_link(struct dentry *old_dentry, struct path *new_dir,
+		       struct dentry *new_dentry)
+{
+	return security_ops->path_link(old_dentry, new_dir, new_dentry);
+}
+
+int security_path_rename(struct path *old_dir, struct dentry *old_dentry,
+			 struct path *new_dir, struct dentry *new_dentry)
+{
+	return security_ops->path_rename(old_dir, old_dentry, new_dir,
+					 new_dentry);
+}
+
+int security_path_truncate(struct path *path, loff_t length,
+			   unsigned int time_attrs, struct file *filp)
+{
+	return security_ops->path_truncate(path, length, time_attrs, filp);
+}
+
 int security_inode_create(struct inode *dir, struct dentry *dentry, int mode)
 {
 	if (unlikely(IS_PRIVATE(dir)))
