Subject: TOMOYO: Add garbage collector support. (v3)

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.c   |  222 +++++++++++++++++++++++++++++++------
 security/tomoyo/common.h   |   65 ++++++++++-
 security/tomoyo/domain.c   |  205 +++++++++++++++++++++++++++-------
 security/tomoyo/file.c     |  264 ++++++++++++++++++++++++++++++++++-----------
 security/tomoyo/realpath.c |   54 ++++++---
 security/tomoyo/realpath.h |    5 
 security/tomoyo/tomoyo.c   |   11 +
 7 files changed, 669 insertions(+), 157 deletions(-)

--- security-testing-2.6.git.orig/security/tomoyo/common.c
+++ security-testing-2.6.git/security/tomoyo/common.c
@@ -339,7 +339,7 @@ struct tomoyo_domain_info *tomoyo_find_d
 
 	name.name = domainname;
 	tomoyo_fill_path_info(&name);
-	list_for_each_entry(domain, &tomoyo_domain_list, list) {
+	list_for_each_entry(domain, &tomoyo_domain_list, entry.list) {
 		if (!domain->is_deleted &&
 		    !tomoyo_pathcmp(&name, domain->domainname))
 			return domain;
@@ -706,6 +706,7 @@ static const char *tomoyo_get_exe(void)
 
 	if (!mm)
 		return NULL;
+	/***** READER SECTION START *****/
 	down_read(&mm->mmap_sem);
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
 		if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file) {
@@ -714,6 +715,7 @@ static const char *tomoyo_get_exe(void)
 		}
 	}
 	up_read(&mm->mmap_sem);
+	/***** READER SECTION END *****/
 	return cp;
 }
 
@@ -784,8 +786,9 @@ bool tomoyo_domain_quota_is_ok(struct to
 
 	if (!domain)
 		return true;
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_domain_acl_info_list_lock);
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		if (ptr->type & TOMOYO_ACL_DELETED)
 			continue;
 		switch (tomoyo_acl_type2(ptr)) {
@@ -839,6 +842,7 @@ bool tomoyo_domain_quota_is_ok(struct to
 		}
 	}
 	up_read(&tomoyo_domain_acl_info_list_lock);
+	/***** READER SECTION END *****/
 	if (count < tomoyo_check_flags(domain, TOMOYO_MAX_ACCEPT_ENTRY))
 		return true;
 	if (!domain->quota_warned) {
@@ -850,6 +854,8 @@ bool tomoyo_domain_quota_is_ok(struct to
 	return false;
 }
 
+static DEFINE_MUTEX(tomoyo_profile_lock);
+
 /**
  * tomoyo_find_or_assign_new_profile - Create a new profile.
  *
@@ -860,7 +866,6 @@ bool tomoyo_domain_quota_is_ok(struct to
 static struct tomoyo_profile *tomoyo_find_or_assign_new_profile(const unsigned
 								int profile)
 {
-	static DEFINE_MUTEX(lock);
 	struct tomoyo_profile *new_ptr = NULL;
 	struct tomoyo_profile *ptr;
 
@@ -868,7 +873,7 @@ static struct tomoyo_profile *tomoyo_fin
 		return NULL;
 	new_ptr = kmalloc(sizeof(*new_ptr), GFP_KERNEL);
 	/***** EXCLUSIVE SECTION START *****/
-	mutex_lock(&lock);
+	mutex_lock(&tomoyo_profile_lock);
 	ptr = tomoyo_profile_ptr[profile];
 	if (!ptr && tomoyo_memory_ok(new_ptr)) {
 		int i;
@@ -879,7 +884,7 @@ static struct tomoyo_profile *tomoyo_fin
 		mb(); /* Avoid out-of-order execution. */
 		tomoyo_profile_ptr[profile] = ptr;
 	}
-	mutex_unlock(&lock);
+	mutex_unlock(&tomoyo_profile_lock);
 	/***** EXCLUSIVE SECTION END *****/
 	kfree(new_ptr);
 	return ptr;
@@ -916,7 +921,16 @@ static int tomoyo_write_profile(struct t
 		return -EINVAL;
 	*cp = '\0';
 	if (!strcmp(data, "COMMENT")) {
-		profile->comment = tomoyo_save_name(cp + 1);
+		const struct tomoyo_path_info *new_comment
+			= tomoyo_get_name(cp + 1);
+		const struct tomoyo_path_info *old_comment;
+		/***** EXCLUSIVE SECTION START *****/
+		mutex_lock(&tomoyo_profile_lock);
+		old_comment = profile->comment;
+		profile->comment = new_comment;
+		mutex_unlock(&tomoyo_profile_lock);
+		/***** EXCLUSIVE SECTION END *****/
+		tomoyo_put_name(old_comment);
 		return 0;
 	}
 	for (i = 0; i < TOMOYO_MAX_CONTROL_INDEX; i++) {
@@ -974,9 +988,15 @@ static int tomoyo_read_profile(struct to
 		if (!profile)
 			continue;
 		if (!type) { /* Print profile' comment tag. */
-			if (!tomoyo_io_printf(head, "%u-COMMENT=%s\n",
-					      index, profile->comment ?
-					      profile->comment->name : ""))
+			bool done;
+			/***** EXCLUSIVE SECTION START *****/
+			mutex_lock(&tomoyo_profile_lock);
+			done = tomoyo_io_printf(head, "%u-COMMENT=%s\n",
+						index, profile->comment ?
+						profile->comment->name : "");
+			mutex_unlock(&tomoyo_profile_lock);
+			/***** EXCLUSIVE SECTION END *****/
+			if (!done)
 				break;
 			continue;
 		}
@@ -1012,7 +1032,7 @@ static int tomoyo_read_profile(struct to
 
 /* Structure for policy manager. */
 struct tomoyo_policy_manager_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	/* A path to program or a domainname. */
 	const struct tomoyo_path_info *manager;
 	bool is_domain;  /* True if manager is a domainname. */
@@ -1048,14 +1068,14 @@ static int tomoyo_update_manager_entry(c
 		if (!tomoyo_is_correct_path(manager, 1, -1, -1, __func__))
 			return -EINVAL;
 	}
-	saved_manager = tomoyo_save_name(manager);
+	saved_manager = tomoyo_get_name(manager);
 	if (!saved_manager)
 		return -ENOMEM;
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_policy_manager_list_lock);
-	list_for_each_entry(ptr, &tomoyo_policy_manager_list, list) {
+	list_for_each_entry(ptr, &tomoyo_policy_manager_list, entry.list) {
 		if (ptr->manager != saved_manager)
 			continue;
 		ptr->is_deleted = is_delete;
@@ -1064,18 +1084,47 @@ static int tomoyo_update_manager_entry(c
 	}
 	if (!is_delete && error && tomoyo_memory_ok(new_entry)) {
 		new_entry->manager = saved_manager;
+		saved_manager = NULL;
 		new_entry->is_domain = is_domain;
-		list_add_tail(&new_entry->list, &tomoyo_policy_manager_list);
+		list_add_tail(&new_entry->entry.list,
+			      &tomoyo_policy_manager_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	up_write(&tomoyo_policy_manager_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
+	tomoyo_put_name(saved_manager);
 	kfree(new_entry);
 	return error;
 }
 
 /**
+ * tomoyo_cleanup_manager - Clean up deleted "struct tomoyo_policy_manager_entry".
+ */
+static void tomoyo_cleanup_manager(void)
+{
+	struct tomoyo_policy_manager_entry *ptr;
+	struct tomoyo_policy_manager_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&tomoyo_policy_manager_list_lock);
+	list_for_each_entry_safe(ptr, tmp, &tomoyo_policy_manager_list,
+				 entry.list) {
+		if (!ptr->is_deleted || !atomic_read(&ptr->entry.users))
+			continue;
+		list_del(&ptr->entry.list);
+		list_add(&ptr->entry.list, &q);
+	}
+	up_write(&tomoyo_policy_manager_list_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, entry.list) {
+		tomoyo_put_name(ptr->manager);
+		list_del(&ptr->entry.list);
+		tomoyo_free_element(ptr);
+	}
+}
+
+/**
  * tomoyo_write_manager_policy - Write manager policy.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
@@ -1108,12 +1157,13 @@ static int tomoyo_read_manager_policy(st
 
 	if (head->read_eof)
 		return 0;
-	down_read(&tomoyo_policy_manager_list_lock);
+	/***** READER SECTION START *****/
+	tomoyo_down_read(&tomoyo_policy_manager_list_lock, head->read_var2);
 	list_for_each_cookie(pos, head->read_var2,
 			     &tomoyo_policy_manager_list) {
 		struct tomoyo_policy_manager_entry *ptr;
 		ptr = list_entry(pos, struct tomoyo_policy_manager_entry,
-				 list);
+				 entry.list);
 		if (ptr->is_deleted)
 			continue;
 		if (!tomoyo_io_printf(head, "%s\n", ptr->manager->name)) {
@@ -1121,7 +1171,8 @@ static int tomoyo_read_manager_policy(st
 			break;
 		}
 	}
-	up_read(&tomoyo_policy_manager_list_lock);
+	tomoyo_up_read(&tomoyo_policy_manager_list_lock, head->read_var2);
+	/***** READER SECTION END *****/
 	head->read_eof = done;
 	return 0;
 }
@@ -1144,8 +1195,9 @@ static bool tomoyo_is_policy_manager(voi
 		return true;
 	if (!tomoyo_manage_by_non_root && (task->cred->uid || task->cred->euid))
 		return false;
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_policy_manager_list_lock);
-	list_for_each_entry(ptr, &tomoyo_policy_manager_list, list) {
+	list_for_each_entry(ptr, &tomoyo_policy_manager_list, entry.list) {
 		if (!ptr->is_deleted && ptr->is_domain
 		    && !tomoyo_pathcmp(domainname, ptr->manager)) {
 			found = true;
@@ -1153,13 +1205,15 @@ static bool tomoyo_is_policy_manager(voi
 		}
 	}
 	up_read(&tomoyo_policy_manager_list_lock);
+	/***** READER SECTION END *****/
 	if (found)
 		return true;
 	exe = tomoyo_get_exe();
 	if (!exe)
 		return false;
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_policy_manager_list_lock);
-	list_for_each_entry(ptr, &tomoyo_policy_manager_list, list) {
+	list_for_each_entry(ptr, &tomoyo_policy_manager_list, entry.list) {
 		if (!ptr->is_deleted && !ptr->is_domain
 		    && !strcmp(exe, ptr->manager->name)) {
 			found = true;
@@ -1167,6 +1221,7 @@ static bool tomoyo_is_policy_manager(voi
 		}
 	}
 	up_read(&tomoyo_policy_manager_list_lock);
+	/***** READER SECTION END *****/
 	if (!found) { /* Reduce error messages. */
 		static pid_t last_pid;
 		const pid_t pid = current->pid;
@@ -1205,13 +1260,15 @@ static bool tomoyo_is_select_one(struct 
 		/***** CRITICAL SECTION END *****/
 	} else if (!strncmp(data, "domain=", 7)) {
 		if (tomoyo_is_domain_def(data + 7)) {
+			/***** READER SECTION START *****/
 			down_read(&tomoyo_domain_list_lock);
 			domain = tomoyo_find_domain(data + 7);
 			up_read(&tomoyo_domain_list_lock);
+			/***** READER SECTION END *****/
 		}
 	} else
 		return false;
-	head->write_var1 = domain;
+	head->write_var1 = &domain->entry.list;
 	/* Accessing read_buf is safe because head->io_sem is held. */
 	if (!head->read_buf)
 		return true; /* Do nothing if open(O_WRONLY). */
@@ -1222,13 +1279,15 @@ static bool tomoyo_is_select_one(struct 
 	if (domain) {
 		struct tomoyo_domain_info *d;
 		head->read_var1 = NULL;
+		/***** READER SECTION START *****/
 		down_read(&tomoyo_domain_list_lock);
-		list_for_each_entry(d, &tomoyo_domain_list, list) {
+		list_for_each_entry(d, &tomoyo_domain_list, entry.list) {
 			if (d == domain)
 				break;
-			head->read_var1 = &d->list;
+			head->read_var1 = &d->entry.list;
 		}
 		up_read(&tomoyo_domain_list_lock);
+		/***** READER SECTION END *****/
 		head->read_var2 = NULL;
 		head->read_bit = 0;
 		head->read_step = 0;
@@ -1248,7 +1307,9 @@ static bool tomoyo_is_select_one(struct 
 static int tomoyo_write_domain_policy(struct tomoyo_io_buffer *head)
 {
 	char *data = head->write_buf;
-	struct tomoyo_domain_info *domain = head->write_var1;
+	struct tomoyo_domain_info *domain
+		= container_of(head->write_var1, struct tomoyo_domain_info,
+			       entry.list);
 	bool is_delete = false;
 	bool is_select = false;
 	unsigned int profile;
@@ -1267,12 +1328,14 @@ static int tomoyo_write_domain_policy(st
 		if (is_delete)
 			tomoyo_delete_domain(data);
 		else if (is_select) {
+			/***** READER SECTION START *****/
 			down_read(&tomoyo_domain_list_lock);
 			domain = tomoyo_find_domain(data);
 			up_read(&tomoyo_domain_list_lock);
+			/***** READER SECTION END *****/
 		} else
 			domain = tomoyo_find_or_assign_new_domain(data, 0);
-		head->write_var1 = domain;
+		head->write_var1 = &domain->entry.list;
 		return 0;
 	}
 	if (!domain)
@@ -1426,13 +1489,15 @@ static int tomoyo_read_domain_policy(str
 		return 0;
 	if (head->read_step == 0)
 		head->read_step = 1;
-	down_read(&tomoyo_domain_list_lock);
+	/***** READER SECTION START *****/
+	tomoyo_down_read(&tomoyo_domain_list_lock, head->read_var1);
 	list_for_each_cookie(dpos, head->read_var1, &tomoyo_domain_list) {
 		struct tomoyo_domain_info *domain;
 		const char *quota_exceeded = "";
 		const char *transition_failed = "";
 		const char *ignore_global_allow_read = "";
-		domain = list_entry(dpos, struct tomoyo_domain_info, list);
+		domain = list_entry(dpos, struct tomoyo_domain_info,
+				    entry.list);
 		if (head->read_step != 1)
 			goto acl_loop;
 		if (domain->is_deleted && !head->read_single_domain)
@@ -1460,18 +1525,22 @@ acl_loop:
 		if (head->read_step == 3)
 			goto tail_mark;
 		/* Print ACL entries in the domain. */
-		down_read(&tomoyo_domain_acl_info_list_lock);
+		/***** READER SECTION START *****/
+		tomoyo_down_read(&tomoyo_domain_acl_info_list_lock,
+				 head->read_var2);
 		list_for_each_cookie(apos, head->read_var2,
 				      &domain->acl_info_list) {
 			struct tomoyo_acl_info *ptr
 				= list_entry(apos, struct tomoyo_acl_info,
-					      list);
+					      entry.list);
 			if (!tomoyo_print_entry(head, ptr)) {
 				done = false;
 				break;
 			}
 		}
-		up_read(&tomoyo_domain_acl_info_list_lock);
+		tomoyo_up_read(&tomoyo_domain_acl_info_list_lock,
+			       head->read_var2);
+		/***** READER SECTION END *****/
 		if (!done)
 			break;
 		head->read_step = 3;
@@ -1484,12 +1553,78 @@ tail_mark:
 		if (head->read_single_domain)
 			break;
 	}
-	up_read(&tomoyo_domain_list_lock);
+	tomoyo_up_read(&tomoyo_domain_list_lock, head->read_var1);
+	/***** READER SECTION END *****/
 	head->read_eof = done;
 	return 0;
 }
 
 /**
+ * tomoyo_cleanup_domain_policy - Clean up deleted domain policy.
+ */
+static void tomoyo_cleanup_domain_policy(void)
+{
+	struct tomoyo_domain_info *domain;
+	struct tomoyo_domain_info *next_domain;
+	struct tomoyo_acl_info *acl;
+	struct tomoyo_acl_info *next_acl;
+	LIST_HEAD(q_domain);
+	LIST_HEAD(q_acl);
+	/***** WRITER SECTION START *****/
+	down_write(&tomoyo_domain_list_lock);
+	list_for_each_entry_safe(domain, next_domain, &tomoyo_domain_list,
+				 entry.list) {
+		const bool can_delete_domain = domain->is_deleted &&
+			!atomic_read(&domain->entry.users);
+		if (can_delete_domain) {
+			list_for_each_entry(acl, &domain->acl_info_list,
+					    entry.list)
+				acl->type |= TOMOYO_ACL_DELETED;
+		}
+		list_for_each_entry_safe(acl, next_acl, &domain->acl_info_list,
+					 entry.list) {
+			if (!(acl->type & TOMOYO_ACL_DELETED)
+			    || !atomic_read(&acl->entry.users))
+				continue;
+			list_del(&acl->entry.list);
+			list_add(&acl->entry.list, &q_acl);
+		}
+		if (can_delete_domain && list_empty(&domain->acl_info_list)) {
+			list_del(&domain->entry.list);
+			list_add(&domain->entry.list, &q_domain);
+		}
+	}
+	up_write(&tomoyo_domain_list_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(acl, next_acl, &q_acl, entry.list) {
+		switch (tomoyo_acl_type1(acl)) {
+			struct tomoyo_single_path_acl_record *acl1;
+			struct tomoyo_double_path_acl_record *acl2;
+		case TOMOYO_TYPE_SINGLE_PATH_ACL:
+			acl1 = container_of(acl,
+				    struct tomoyo_single_path_acl_record,
+					    head);
+			tomoyo_put_name(acl1->filename);
+			break;
+		case TOMOYO_TYPE_DOUBLE_PATH_ACL:
+			acl2 = container_of(acl,
+				    struct tomoyo_double_path_acl_record,
+					    head);
+			tomoyo_put_name(acl2->filename1);
+			tomoyo_put_name(acl2->filename2);
+			break;
+		}
+		list_del(&acl->entry.list);
+		tomoyo_free_element(acl);
+	}
+	list_for_each_entry_safe(domain, next_domain, &q_domain, entry.list) {
+		tomoyo_put_name(domain->domainname);
+		list_del(&domain->entry.list);
+		tomoyo_free_element(domain);
+	}
+}
+
+/**
  * tomoyo_write_domain_profile - Assign profile for specified domain.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
@@ -1511,9 +1646,11 @@ static int tomoyo_write_domain_profile(s
 	if (!cp)
 		return -EINVAL;
 	*cp = '\0';
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_domain_list_lock);
 	domain = tomoyo_find_domain(cp + 1);
 	up_read(&tomoyo_domain_list_lock);
+	/***** READER SECTION END *****/
 	if (strict_strtoul(data, 10, &profile))
 		return -EINVAL;
 	if (domain && profile < TOMOYO_MAX_PROFILES
@@ -1543,10 +1680,11 @@ static int tomoyo_read_domain_profile(st
 
 	if (head->read_eof)
 		return 0;
-	down_read(&tomoyo_domain_list_lock);
+	/***** READER SECTION START *****/
+	tomoyo_down_read(&tomoyo_domain_list_lock, head->read_var1);
 	list_for_each_cookie(pos, head->read_var1, &tomoyo_domain_list) {
 		struct tomoyo_domain_info *domain;
-		domain = list_entry(pos, struct tomoyo_domain_info, list);
+		domain = list_entry(pos, struct tomoyo_domain_info, entry.list);
 		if (domain->is_deleted)
 			continue;
 		if (!tomoyo_io_printf(head, "%u %s\n", domain->profile,
@@ -1555,7 +1693,8 @@ static int tomoyo_read_domain_profile(st
 			break;
 		}
 	}
-	up_read(&tomoyo_domain_list_lock);
+	tomoyo_up_read(&tomoyo_domain_list_lock, head->read_var1);
+	/***** READER SECTION END *****/
 	head->read_eof = done;
 	return 0;
 }
@@ -1777,8 +1916,9 @@ void tomoyo_load_policy(const char *file
 	tomoyo_policy_loaded = true;
 	{ /* Check all profiles currently assigned to domains are defined. */
 		struct tomoyo_domain_info *domain;
+		/***** READER SECTION START *****/
 		down_read(&tomoyo_domain_list_lock);
-		list_for_each_entry(domain, &tomoyo_domain_list, list) {
+		list_for_each_entry(domain, &tomoyo_domain_list, entry.list) {
 			const u8 profile = domain->profile;
 			if (tomoyo_profile_ptr[profile])
 				continue;
@@ -1786,6 +1926,7 @@ void tomoyo_load_policy(const char *file
 			      profile, domain->domainname->name);
 		}
 		up_read(&tomoyo_domain_list_lock);
+		/***** READER SECTION END *****/
 	}
 }
 
@@ -2036,6 +2177,7 @@ static int tomoyo_write_control(struct f
 static int tomoyo_close_control(struct file *file)
 {
 	struct tomoyo_io_buffer *head = file->private_data;
+	const bool is_write = head->write_buf != NULL;
 
 	/* Release memory used for policy I/O. */
 	tomoyo_free(head->read_buf);
@@ -2045,6 +2187,16 @@ static int tomoyo_close_control(struct f
 	tomoyo_free(head);
 	head = NULL;
 	file->private_data = NULL;
+	if (is_write) {
+		tomoyo_cleanup_allow_read();
+		tomoyo_cleanup_file_pattern();
+		tomoyo_cleanup_no_rewrite();
+		tomoyo_cleanup_initializer();
+		tomoyo_cleanup_keep_domain();
+		tomoyo_cleanup_alias();
+		tomoyo_cleanup_manager();
+		tomoyo_cleanup_domain_policy();
+	}
 	return 0;
 }
 
--- security-testing-2.6.git.orig/security/tomoyo/common.h
+++ security-testing-2.6.git/security/tomoyo/common.h
@@ -23,6 +23,58 @@
 #include <linux/mount.h>
 #include <linux/list.h>
 
+struct tomoyo_entry {
+	struct list_head list;
+	atomic_t users;
+};
+
+static inline void tomoyo_down_read(struct rw_semaphore *lock,
+				    struct list_head *item)
+{
+	down_read(lock);
+	if (item)
+		atomic_dec(&(container_of(item, struct tomoyo_entry,
+					  list)->users));
+}
+
+static inline void tomoyo_up_read(struct rw_semaphore *lock,
+				  struct list_head *item)
+{
+	if (item)
+		atomic_inc(&(container_of(item, struct tomoyo_entry,
+					  list)->users));
+	up_read(lock);
+}
+
+static inline void tomoyo_down_write(struct rw_semaphore *lock,
+				     struct list_head *item)
+{
+	down_write(lock);
+	if (item)
+		atomic_dec(&(container_of(item, struct tomoyo_entry,
+					  list)->users));
+}
+
+static inline void tomoyo_up_write(struct rw_semaphore *lock,
+				   struct list_head *item)
+{
+	if (item)
+		atomic_inc(&(container_of(item, struct tomoyo_entry,
+					  list)->users));
+	up_write(lock);
+}
+
+/* Caller must hold appropriate lock. */
+static inline void tomoyo_update_entry(struct tomoyo_entry *dest,
+				       struct tomoyo_entry *src)
+{
+	if (dest)
+		atomic_dec(&dest->users);
+	dest = src;
+	if (src)
+		atomic_inc(&src->users);
+}
+
 struct dentry;
 struct vfsmount;
 
@@ -69,7 +121,7 @@ struct tomoyo_path_info_with_data {
  * without enlarging their structure size.
  */
 struct tomoyo_acl_info {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	/*
 	 * Type of this ACL entry.
 	 *
@@ -83,7 +135,7 @@ struct tomoyo_acl_info {
 
 /* Structure for domain information. */
 struct tomoyo_domain_info {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	struct list_head acl_info_list;
 	/* Name of this domain. Never NULL.          */
 	const struct tomoyo_path_info *domainname;
@@ -164,7 +216,7 @@ struct tomoyo_io_buffer {
 	/* Extra variables for reading.         */
 	struct list_head *read_var2;
 	/* The position currently writing to.   */
-	struct tomoyo_domain_info *write_var1;
+	struct list_head *write_var1;
 	/* The step for reading.                */
 	int read_step;
 	/* Buffer for reading.                  */
@@ -274,6 +326,13 @@ void tomoyo_load_policy(const char *file
 void tomoyo_set_domain_flag(struct tomoyo_domain_info *domain,
 			    const bool is_delete, const u8 flags);
 
+void tomoyo_cleanup_allow_read(void);
+void tomoyo_cleanup_file_pattern(void);
+void tomoyo_cleanup_no_rewrite(void);
+void tomoyo_cleanup_initializer(void);
+void tomoyo_cleanup_keep_domain(void);
+void tomoyo_cleanup_alias(void);
+
 /* strcmp() for "struct tomoyo_path_info" structure. */
 static inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,
 				  const struct tomoyo_path_info *b)
--- security-testing-2.6.git.orig/security/tomoyo/domain.c
+++ security-testing-2.6.git/security/tomoyo/domain.c
@@ -25,7 +25,7 @@ DECLARE_RWSEM(tomoyo_domain_list_lock);
 
 /* Structure for "initialize_domain" and "no_initialize_domain" keyword. */
 struct tomoyo_domain_initializer_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *domainname;    /* This may be NULL */
 	const struct tomoyo_path_info *program;
 	bool is_deleted;
@@ -36,7 +36,7 @@ struct tomoyo_domain_initializer_entry {
 
 /* Structure for "keep_domain" and "no_keep_domain" keyword. */
 struct tomoyo_domain_keeper_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *domainname;
 	const struct tomoyo_path_info *program;       /* This may be NULL */
 	bool is_deleted;
@@ -47,7 +47,7 @@ struct tomoyo_domain_keeper_entry {
 
 /* Structure for "alias" keyword. */
 struct tomoyo_alias_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *original_name;
 	const struct tomoyo_path_info *aliased_name;
 	bool is_deleted;
@@ -128,18 +128,20 @@ static int tomoyo_update_domain_initiali
 			is_last_name = true;
 		else if (!tomoyo_is_correct_domain(domainname, __func__))
 			return -EINVAL;
-		saved_domainname = tomoyo_save_name(domainname);
+		saved_domainname = tomoyo_get_name(domainname);
 		if (!saved_domainname)
 			return -ENOMEM;
 	}
-	saved_program = tomoyo_save_name(program);
-	if (!saved_program)
+	saved_program = tomoyo_get_name(program);
+	if (!saved_program) {
+		tomoyo_put_name(saved_domainname);
 		return -ENOMEM;
+	}
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_domain_initializer_list_lock);
-	list_for_each_entry(ptr, &tomoyo_domain_initializer_list, list) {
+	list_for_each_entry(ptr, &tomoyo_domain_initializer_list, entry.list) {
 		if (ptr->is_not != is_not ||
 		    ptr->domainname != saved_domainname ||
 		    ptr->program != saved_program)
@@ -150,21 +152,52 @@ static int tomoyo_update_domain_initiali
 	}
 	if (!is_delete && error && tomoyo_memory_ok(new_entry)) {
 		new_entry->domainname = saved_domainname;
+		saved_domainname = NULL;
 		new_entry->program = saved_program;
+		saved_program = NULL;
 		new_entry->is_not = is_not;
 		new_entry->is_last_name = is_last_name;
-		list_add_tail(&new_entry->list,
+		list_add_tail(&new_entry->entry.list,
 			      &tomoyo_domain_initializer_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	up_write(&tomoyo_domain_initializer_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
+	tomoyo_put_name(saved_domainname);
+	tomoyo_put_name(saved_program);
 	kfree(new_entry);
 	return error;
 }
 
 /**
+ * tomoyo_cleanup_initializer - Clean up deleted "struct tomoyo_domain_initializer_entry".
+ */
+void tomoyo_cleanup_initializer(void)
+{
+	struct tomoyo_domain_initializer_entry *ptr;
+	struct tomoyo_domain_initializer_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&tomoyo_domain_initializer_list_lock);
+	list_for_each_entry_safe(ptr, tmp, &tomoyo_domain_initializer_list,
+				 entry.list) {
+		if (!ptr->is_deleted || !atomic_read(&ptr->entry.users))
+			continue;
+		list_del(&ptr->entry.list);
+		list_add(&ptr->entry.list, &q);
+	}
+	up_write(&tomoyo_domain_initializer_list_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, entry.list) {
+		tomoyo_put_name(ptr->domainname);
+		tomoyo_put_name(ptr->program);
+		list_del(&ptr->entry.list);
+		tomoyo_free_element(ptr);
+	}
+}
+
+/**
  * tomoyo_read_domain_initializer_policy - Read "struct tomoyo_domain_initializer_entry" list.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
@@ -176,7 +209,8 @@ bool tomoyo_read_domain_initializer_poli
 	struct list_head *pos;
 	bool done = true;
 
-	down_read(&tomoyo_domain_initializer_list_lock);
+	/***** READER SECTION START *****/
+	tomoyo_down_read(&tomoyo_domain_initializer_list_lock, head->read_var2);
 	list_for_each_cookie(pos, head->read_var2,
 			     &tomoyo_domain_initializer_list) {
 		const char *no;
@@ -184,7 +218,7 @@ bool tomoyo_read_domain_initializer_poli
 		const char *domain = "";
 		struct tomoyo_domain_initializer_entry *ptr;
 		ptr = list_entry(pos, struct tomoyo_domain_initializer_entry,
-				  list);
+				 entry.list);
 		if (ptr->is_deleted)
 			continue;
 		no = ptr->is_not ? "no_" : "";
@@ -200,7 +234,8 @@ bool tomoyo_read_domain_initializer_poli
 			break;
 		}
 	}
-	up_read(&tomoyo_domain_initializer_list_lock);
+	tomoyo_up_read(&tomoyo_domain_initializer_list_lock, head->read_var2);
+	/***** READER SECTION END *****/
 	return done;
 }
 
@@ -247,8 +282,9 @@ static bool tomoyo_is_domain_initializer
 	struct tomoyo_domain_initializer_entry *ptr;
 	bool flag = false;
 
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_domain_initializer_list_lock);
-	list_for_each_entry(ptr,  &tomoyo_domain_initializer_list, list) {
+	list_for_each_entry(ptr,  &tomoyo_domain_initializer_list, entry.list) {
 		if (ptr->is_deleted)
 			continue;
 		if (ptr->domainname) {
@@ -269,6 +305,7 @@ static bool tomoyo_is_domain_initializer
 		flag = true;
 	}
 	up_read(&tomoyo_domain_initializer_list_lock);
+	/***** READER SECTION END *****/
 	return flag;
 }
 
@@ -307,18 +344,20 @@ static int tomoyo_update_domain_keeper_e
 	if (program) {
 		if (!tomoyo_is_correct_path(program, 1, -1, -1, __func__))
 			return -EINVAL;
-		saved_program = tomoyo_save_name(program);
+		saved_program = tomoyo_get_name(program);
 		if (!saved_program)
 			return -ENOMEM;
 	}
-	saved_domainname = tomoyo_save_name(domainname);
-	if (!saved_domainname)
+	saved_domainname = tomoyo_get_name(domainname);
+	if (!saved_domainname) {
+		tomoyo_put_name(saved_program);
 		return -ENOMEM;
+	}
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_domain_keeper_list_lock);
-	list_for_each_entry(ptr, &tomoyo_domain_keeper_list, list) {
+	list_for_each_entry(ptr, &tomoyo_domain_keeper_list, entry.list) {
 		if (ptr->is_not != is_not ||
 		    ptr->domainname != saved_domainname ||
 		    ptr->program != saved_program)
@@ -329,20 +368,52 @@ static int tomoyo_update_domain_keeper_e
 	}
 	if (!is_delete && error && tomoyo_memory_ok(new_entry)) {
 		new_entry->domainname = saved_domainname;
+		saved_domainname = NULL;
 		new_entry->program = saved_program;
+		saved_program = NULL;
 		new_entry->is_not = is_not;
 		new_entry->is_last_name = is_last_name;
-		list_add_tail(&new_entry->list, &tomoyo_domain_keeper_list);
+		list_add_tail(&new_entry->entry.list,
+			      &tomoyo_domain_keeper_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	up_write(&tomoyo_domain_keeper_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
+	tomoyo_put_name(saved_domainname);
+	tomoyo_put_name(saved_program);
 	kfree(new_entry);
 	return error;
 }
 
 /**
+ * tomoyo_cleanup_keep_domain - Clean up deleted "struct tomoyo_domain_keeper_entry".
+ */
+void tomoyo_cleanup_keep_domain(void)
+{
+	struct tomoyo_domain_keeper_entry *ptr;
+	struct tomoyo_domain_keeper_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&tomoyo_domain_keeper_list_lock);
+	list_for_each_entry_safe(ptr, tmp, &tomoyo_domain_keeper_list,
+				 entry.list) {
+		if (!ptr->is_deleted || !atomic_read(&ptr->entry.users))
+			continue;
+		list_del(&ptr->entry.list);
+		list_add(&ptr->entry.list, &q);
+	}
+	up_write(&tomoyo_domain_keeper_list_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, entry.list) {
+		tomoyo_put_name(ptr->domainname);
+		tomoyo_put_name(ptr->program);
+		list_del(&ptr->entry.list);
+		tomoyo_free_element(ptr);
+	}
+}
+
+/**
  * tomoyo_write_domain_keeper_policy - Write "struct tomoyo_domain_keeper_entry" list.
  *
  * @data:      String to parse.
@@ -375,7 +446,8 @@ bool tomoyo_read_domain_keeper_policy(st
 	struct list_head *pos;
 	bool done = true;
 
-	down_read(&tomoyo_domain_keeper_list_lock);
+	/***** READER SECTION START *****/
+	tomoyo_down_read(&tomoyo_domain_keeper_list_lock, head->read_var2);
 	list_for_each_cookie(pos, head->read_var2,
 			     &tomoyo_domain_keeper_list) {
 		struct tomoyo_domain_keeper_entry *ptr;
@@ -383,7 +455,8 @@ bool tomoyo_read_domain_keeper_policy(st
 		const char *from = "";
 		const char *program = "";
 
-		ptr = list_entry(pos, struct tomoyo_domain_keeper_entry, list);
+		ptr = list_entry(pos, struct tomoyo_domain_keeper_entry,
+				 entry.list);
 		if (ptr->is_deleted)
 			continue;
 		no = ptr->is_not ? "no_" : "";
@@ -399,7 +472,8 @@ bool tomoyo_read_domain_keeper_policy(st
 			break;
 		}
 	}
-	up_read(&tomoyo_domain_keeper_list_lock);
+	tomoyo_up_read(&tomoyo_domain_keeper_list_lock, head->read_var2);
+	/***** READER SECTION END *****/
 	return done;
 }
 
@@ -420,8 +494,9 @@ static bool tomoyo_is_domain_keeper(cons
 	struct tomoyo_domain_keeper_entry *ptr;
 	bool flag = false;
 
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_domain_keeper_list_lock);
-	list_for_each_entry(ptr, &tomoyo_domain_keeper_list, list) {
+	list_for_each_entry(ptr, &tomoyo_domain_keeper_list, entry.list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!ptr->is_last_name) {
@@ -440,6 +515,7 @@ static bool tomoyo_is_domain_keeper(cons
 		flag = true;
 	}
 	up_read(&tomoyo_domain_keeper_list_lock);
+	/***** READER SECTION END *****/
 	return flag;
 }
 
@@ -469,15 +545,18 @@ static int tomoyo_update_alias_entry(con
 	if (!tomoyo_is_correct_path(original_name, 1, -1, -1, __func__) ||
 	    !tomoyo_is_correct_path(aliased_name, 1, -1, -1, __func__))
 		return -EINVAL; /* No patterns allowed. */
-	saved_original_name = tomoyo_save_name(original_name);
-	saved_aliased_name = tomoyo_save_name(aliased_name);
-	if (!saved_original_name || !saved_aliased_name)
+	saved_original_name = tomoyo_get_name(original_name);
+	saved_aliased_name = tomoyo_get_name(aliased_name);
+	if (!saved_original_name || !saved_aliased_name) {
+		tomoyo_put_name(saved_original_name);
+		tomoyo_put_name(saved_aliased_name);
 		return -ENOMEM;
+	}
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_alias_list_lock);
-	list_for_each_entry(ptr, &tomoyo_alias_list, list) {
+	list_for_each_entry(ptr, &tomoyo_alias_list, entry.list) {
 		if (ptr->original_name != saved_original_name ||
 		    ptr->aliased_name != saved_aliased_name)
 			continue;
@@ -487,18 +566,48 @@ static int tomoyo_update_alias_entry(con
 	}
 	if (!is_delete && error && tomoyo_memory_ok(new_entry)) {
 		new_entry->original_name = saved_original_name;
+		saved_original_name = NULL;
 		new_entry->aliased_name = saved_aliased_name;
-		list_add_tail(&new_entry->list, &tomoyo_alias_list);
+		saved_aliased_name = NULL;
+		list_add_tail(&new_entry->entry.list, &tomoyo_alias_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	up_write(&tomoyo_alias_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
+	tomoyo_put_name(saved_original_name);
+	tomoyo_put_name(saved_aliased_name);
 	kfree(new_entry);
 	return error;
 }
 
 /**
+ * tomoyo_cleanup_alias - Clean up deleted "struct tomoyo_alias_entry".
+ */
+void tomoyo_cleanup_alias(void)
+{
+	struct tomoyo_alias_entry *ptr;
+	struct tomoyo_alias_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&tomoyo_alias_list_lock);
+	list_for_each_entry_safe(ptr, tmp, &tomoyo_alias_list, entry.list) {
+		if (!ptr->is_deleted || !atomic_read(&ptr->entry.users))
+			continue;
+		list_del(&ptr->entry.list);
+		list_add(&ptr->entry.list, &q);
+	}
+	up_write(&tomoyo_alias_list_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, entry.list) {
+		tomoyo_put_name(ptr->original_name);
+		tomoyo_put_name(ptr->aliased_name);
+		list_del(&ptr->entry.list);
+		tomoyo_free_element(ptr);
+	}
+}
+
+/**
  * tomoyo_read_alias_policy - Read "struct tomoyo_alias_entry" list.
  *
  * @head: Pointer to "struct tomoyo_io_buffer".
@@ -510,11 +619,12 @@ bool tomoyo_read_alias_policy(struct tom
 	struct list_head *pos;
 	bool done = true;
 
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_alias_list_lock);
 	list_for_each_cookie(pos, head->read_var2, &tomoyo_alias_list) {
 		struct tomoyo_alias_entry *ptr;
 
-		ptr = list_entry(pos, struct tomoyo_alias_entry, list);
+		ptr = list_entry(pos, struct tomoyo_alias_entry, entry.list);
 		if (ptr->is_deleted)
 			continue;
 		if (!tomoyo_io_printf(head, TOMOYO_KEYWORD_ALIAS "%s %s\n",
@@ -525,6 +635,7 @@ bool tomoyo_read_alias_policy(struct tom
 		}
 	}
 	up_read(&tomoyo_alias_list_lock);
+	/***** READER SECTION END *****/
 	return done;
 }
 
@@ -562,10 +673,10 @@ int tomoyo_delete_domain(char *domainnam
 
 	name.name = domainname;
 	tomoyo_fill_path_info(&name);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_domain_list_lock);
 	/* Is there an active domain? */
-	list_for_each_entry(domain, &tomoyo_domain_list, list) {
+	list_for_each_entry(domain, &tomoyo_domain_list, entry.list) {
 		/* Never delete tomoyo_kernel_domain */
 		if (domain == &tomoyo_kernel_domain)
 			continue;
@@ -576,7 +687,7 @@ int tomoyo_delete_domain(char *domainnam
 		break;
 	}
 	up_write(&tomoyo_domain_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
 	return 0;
 }
 
@@ -594,21 +705,21 @@ struct tomoyo_domain_info *tomoyo_find_o
 {
 	struct tomoyo_domain_info *new_domain = NULL;
 	struct tomoyo_domain_info *domain;
-	const struct tomoyo_path_info *saved_domainname;
+	const struct tomoyo_path_info *saved_domainname = NULL;
 
 	new_domain = kmalloc(sizeof(*new_domain), GFP_KERNEL);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_domain_list_lock);
 	domain = tomoyo_find_domain(domainname);
 	if (domain)
 		goto out;
 	if (!tomoyo_is_correct_domain(domainname, __func__))
 		goto out;
-	saved_domainname = tomoyo_save_name(domainname);
+	saved_domainname = tomoyo_get_name(domainname);
 	if (!saved_domainname)
 		goto out;
 	/* Can I reuse memory of deleted domain? */
-	list_for_each_entry(domain, &tomoyo_domain_list, list) {
+	list_for_each_entry(domain, &tomoyo_domain_list, entry.list) {
 		struct task_struct *p;
 		struct tomoyo_acl_info *ptr;
 		bool flag;
@@ -628,7 +739,7 @@ struct tomoyo_domain_info *tomoyo_find_o
 		/***** CRITICAL SECTION END *****/
 		if (flag)
 			continue;
-		list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 			ptr->type |= TOMOYO_ACL_DELETED;
 		}
 		tomoyo_set_domain_flag(domain, true, domain->flags);
@@ -644,12 +755,14 @@ struct tomoyo_domain_info *tomoyo_find_o
 		new_domain = NULL;
 		INIT_LIST_HEAD(&domain->acl_info_list);
 		domain->domainname = saved_domainname;
+		saved_domainname = NULL;
 		domain->profile = profile;
-		list_add_tail(&domain->list, &tomoyo_domain_list);
+		list_add_tail(&domain->entry.list, &tomoyo_domain_list);
 	}
  out:
 	up_write(&tomoyo_domain_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
+	tomoyo_put_name(saved_domainname);
 	kfree(new_domain);
 	return domain;
 }
@@ -722,8 +835,9 @@ int tomoyo_find_next_domain(struct linux
 	if (tomoyo_pathcmp(&r, &s)) {
 		struct tomoyo_alias_entry *ptr;
 		/* Is this program allowed to be called via symbolic links? */
+		/***** READER SECTION START *****/
 		down_read(&tomoyo_alias_list_lock);
-		list_for_each_entry(ptr, &tomoyo_alias_list, list) {
+		list_for_each_entry(ptr, &tomoyo_alias_list, entry.list) {
 			if (ptr->is_deleted ||
 			    tomoyo_pathcmp(&r, ptr->original_name) ||
 			    tomoyo_pathcmp(&s, ptr->aliased_name))
@@ -735,6 +849,7 @@ int tomoyo_find_next_domain(struct linux
 			break;
 		}
 		up_read(&tomoyo_alias_list_lock);
+		/***** READER SECTION END *****/
 	}
 
 	/* Check execute permission. */
@@ -765,9 +880,11 @@ int tomoyo_find_next_domain(struct linux
 	}
 	if (domain || strlen(new_domain_name) >= TOMOYO_MAX_PATHNAME_LEN)
 		goto done;
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_domain_list_lock);
 	domain = tomoyo_find_domain(new_domain_name);
 	up_read(&tomoyo_domain_list_lock);
+	/***** READER SECTION END *****/
 	if (domain)
 		goto done;
 	if (is_enforce)
--- security-testing-2.6.git.orig/security/tomoyo/file.c
+++ security-testing-2.6.git/security/tomoyo/file.c
@@ -16,21 +16,21 @@
 
 /* Structure for "allow_read" keyword. */
 struct tomoyo_globally_readable_file_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *filename;
 	bool is_deleted;
 };
 
 /* Structure for "file_pattern" keyword. */
 struct tomoyo_pattern_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *pattern;
 	bool is_deleted;
 };
 
 /* Structure for "deny_rewrite" keyword. */
 struct tomoyo_no_rewrite_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *pattern;
 	bool is_deleted;
 };
@@ -163,14 +163,14 @@ static int tomoyo_update_globally_readab
 
 	if (!tomoyo_is_correct_path(filename, 1, 0, -1, __func__))
 		return -EINVAL;
-	saved_filename = tomoyo_save_name(filename);
+	saved_filename = tomoyo_get_name(filename);
 	if (!saved_filename)
 		return -ENOMEM;
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_globally_readable_list_lock);
-	list_for_each_entry(ptr, &tomoyo_globally_readable_list, list) {
+	list_for_each_entry(ptr, &tomoyo_globally_readable_list, entry.list) {
 		if (ptr->filename != saved_filename)
 			continue;
 		ptr->is_deleted = is_delete;
@@ -179,17 +179,46 @@ static int tomoyo_update_globally_readab
 	}
 	if (!is_delete && error && tomoyo_memory_ok(new_entry)) {
 		new_entry->filename = saved_filename;
-		list_add_tail(&new_entry->list, &tomoyo_globally_readable_list);
+		saved_filename = NULL;
+		list_add_tail(&new_entry->entry.list,
+			      &tomoyo_globally_readable_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	up_write(&tomoyo_globally_readable_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
+	tomoyo_put_name(saved_filename);
 	kfree(new_entry);
 	return error;
 }
 
 /**
+ * tomoyo_cleanup_allow_read - Clean up deleted "struct tomoyo_globally_readable_file_entry".
+ */
+void tomoyo_cleanup_allow_read(void)
+{
+	struct tomoyo_globally_readable_file_entry *ptr;
+	struct tomoyo_globally_readable_file_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&tomoyo_globally_readable_list_lock);
+	list_for_each_entry_safe(ptr, tmp, &tomoyo_globally_readable_list,
+				 entry.list) {
+		if (!ptr->is_deleted || !atomic_read(&ptr->entry.users))
+			continue;
+		list_del(&ptr->entry.list);
+		list_add(&ptr->entry.list, &q);
+	}
+	up_write(&tomoyo_globally_readable_list_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, entry.list) {
+		tomoyo_put_name(ptr->filename);
+		list_del(&ptr->entry.list);
+		tomoyo_free_element(ptr);
+	}
+}
+
+/**
  * tomoyo_is_globally_readable_file - Check if the file is unconditionnaly permitted to be open()ed for reading.
  *
  * @filename: The filename to check.
@@ -201,8 +230,9 @@ static bool tomoyo_is_globally_readable_
 {
 	struct tomoyo_globally_readable_file_entry *ptr;
 	bool found = false;
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_globally_readable_list_lock);
-	list_for_each_entry(ptr, &tomoyo_globally_readable_list, list) {
+	list_for_each_entry(ptr, &tomoyo_globally_readable_list, entry.list) {
 		if (!ptr->is_deleted &&
 		    tomoyo_path_matches_pattern(filename, ptr->filename)) {
 			found = true;
@@ -210,6 +240,7 @@ static bool tomoyo_is_globally_readable_
 		}
 	}
 	up_read(&tomoyo_globally_readable_list_lock);
+	/***** READER SECTION END *****/
 	return found;
 }
 
@@ -238,13 +269,14 @@ bool tomoyo_read_globally_readable_polic
 	struct list_head *pos;
 	bool done = true;
 
-	down_read(&tomoyo_globally_readable_list_lock);
+	/***** READER SECTION START *****/
+	tomoyo_down_read(&tomoyo_globally_readable_list_lock, head->read_var2);
 	list_for_each_cookie(pos, head->read_var2,
 			     &tomoyo_globally_readable_list) {
 		struct tomoyo_globally_readable_file_entry *ptr;
 		ptr = list_entry(pos,
 				 struct tomoyo_globally_readable_file_entry,
-				 list);
+				 entry.list);
 		if (ptr->is_deleted)
 			continue;
 		if (!tomoyo_io_printf(head, TOMOYO_KEYWORD_ALLOW_READ "%s\n",
@@ -253,7 +285,8 @@ bool tomoyo_read_globally_readable_polic
 			break;
 		}
 	}
-	up_read(&tomoyo_globally_readable_list_lock);
+	tomoyo_up_read(&tomoyo_globally_readable_list_lock, head->read_var2);
+	/***** READER SECTION END *****/
 	return done;
 }
 
@@ -279,14 +312,14 @@ static int tomoyo_update_file_pattern_en
 
 	if (!tomoyo_is_correct_path(pattern, 0, 1, 0, __func__))
 		return -EINVAL;
-	saved_pattern = tomoyo_save_name(pattern);
+	saved_pattern = tomoyo_get_name(pattern);
 	if (!saved_pattern)
 		return -ENOMEM;
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_pattern_list_lock);
-	list_for_each_entry(ptr, &tomoyo_pattern_list, list) {
+	list_for_each_entry(ptr, &tomoyo_pattern_list, entry.list) {
 		if (saved_pattern != ptr->pattern)
 			continue;
 		ptr->is_deleted = is_delete;
@@ -295,22 +328,52 @@ static int tomoyo_update_file_pattern_en
 	}
 	if (!is_delete && error && tomoyo_memory_ok(new_entry)) {
 		new_entry->pattern = saved_pattern;
-		list_add_tail(&new_entry->list, &tomoyo_pattern_list);
+		saved_pattern = NULL;
+		list_add_tail(&new_entry->entry.list, &tomoyo_pattern_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	up_write(&tomoyo_pattern_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
+	tomoyo_put_name(saved_pattern);
 	kfree(new_entry);
 	return error;
 }
 
 /**
+ * tomoyo_cleanup_file_pattern - Clean up deleted "struct tomoyo_pattern_entry".
+ */
+void tomoyo_cleanup_file_pattern(void)
+{
+	struct tomoyo_pattern_entry *ptr;
+	struct tomoyo_pattern_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&tomoyo_pattern_list_lock);
+	list_for_each_entry_safe(ptr, tmp, &tomoyo_pattern_list, entry.list) {
+		if (!ptr->is_deleted || !atomic_read(&ptr->entry.users))
+			continue;
+		list_del(&ptr->entry.list);
+		list_add(&ptr->entry.list, &q);
+	}
+	up_write(&tomoyo_pattern_list_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, entry.list) {
+		tomoyo_put_name(ptr->pattern);
+		list_del(&ptr->entry.list);
+		tomoyo_free_element(ptr);
+	}
+}
+
+/**
  * tomoyo_get_file_pattern - Get patterned pathname.
  *
- * @filename: The filename to find patterned pathname.
+ *  @filename: The filename to find patterned pathname.
+ *
+ * Returns pointer to pathname pattern if matched, NULL otherwise.
  *
- * Returns pointer to pathname pattern if matched, @filename otherwise.
+ * Caller must call tomoyo_put_file_pattern() if this function didn't return
+ * NULL.
  */
 static const struct tomoyo_path_info *
 tomoyo_get_file_pattern(const struct tomoyo_path_info *filename)
@@ -318,8 +381,9 @@ tomoyo_get_file_pattern(const struct tom
 	struct tomoyo_pattern_entry *ptr;
 	const struct tomoyo_path_info *pattern = NULL;
 
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_pattern_list_lock);
-	list_for_each_entry(ptr, &tomoyo_pattern_list, list) {
+	list_for_each_entry(ptr, &tomoyo_pattern_list, entry.list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!tomoyo_path_matches_pattern(filename, ptr->pattern))
@@ -332,12 +396,26 @@ tomoyo_get_file_pattern(const struct tom
 			break;
 		}
 	}
-	up_read(&tomoyo_pattern_list_lock);
 	if (pattern)
-		filename = pattern;
-	return filename;
+		atomic_inc(&ptr->entry.users);
+	up_read(&tomoyo_pattern_list_lock);
+	/***** READER SECTION END *****/
+	return pattern;
+}
+
+static void tomoyo_put_file_pattern(const struct tomoyo_path_info *name)
+{
+	if (!name)
+		return;
+	/***** READER SECTION START *****/
+	down_read(&tomoyo_pattern_list_lock);
+	atomic_dec(&container_of(&name, struct tomoyo_pattern_entry,
+				 pattern)->entry.users);
+	up_read(&tomoyo_pattern_list_lock);
+	/***** READER SECTION END *****/
 }
 
+
 /**
  * tomoyo_write_pattern_policy - Write "struct tomoyo_pattern_entry" list.
  *
@@ -363,10 +441,11 @@ bool tomoyo_read_file_pattern(struct tom
 	struct list_head *pos;
 	bool done = true;
 
-	down_read(&tomoyo_pattern_list_lock);
+	/***** READER SECTION START *****/
+	tomoyo_down_read(&tomoyo_pattern_list_lock, head->read_var2);
 	list_for_each_cookie(pos, head->read_var2, &tomoyo_pattern_list) {
 		struct tomoyo_pattern_entry *ptr;
-		ptr = list_entry(pos, struct tomoyo_pattern_entry, list);
+		ptr = list_entry(pos, struct tomoyo_pattern_entry, entry.list);
 		if (ptr->is_deleted)
 			continue;
 		if (!tomoyo_io_printf(head, TOMOYO_KEYWORD_FILE_PATTERN "%s\n",
@@ -375,7 +454,8 @@ bool tomoyo_read_file_pattern(struct tom
 			break;
 		}
 	}
-	up_read(&tomoyo_pattern_list_lock);
+	tomoyo_up_read(&tomoyo_pattern_list_lock, head->read_var2);
+	/***** READER SECTION END *****/
 	return done;
 }
 
@@ -401,14 +481,14 @@ static int tomoyo_update_no_rewrite_entr
 
 	if (!tomoyo_is_correct_path(pattern, 0, 0, 0, __func__))
 		return -EINVAL;
-	saved_pattern = tomoyo_save_name(pattern);
+	saved_pattern = tomoyo_get_name(pattern);
 	if (!saved_pattern)
 		return -ENOMEM;
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_no_rewrite_list_lock);
-	list_for_each_entry(ptr, &tomoyo_no_rewrite_list, list) {
+	list_for_each_entry(ptr, &tomoyo_no_rewrite_list, entry.list) {
 		if (ptr->pattern != saved_pattern)
 			continue;
 		ptr->is_deleted = is_delete;
@@ -417,17 +497,45 @@ static int tomoyo_update_no_rewrite_entr
 	}
 	if (!is_delete && error && tomoyo_memory_ok(new_entry)) {
 		new_entry->pattern = saved_pattern;
-		list_add_tail(&new_entry->list, &tomoyo_no_rewrite_list);
+		saved_pattern = NULL;
+		list_add_tail(&new_entry->entry.list, &tomoyo_no_rewrite_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	up_write(&tomoyo_no_rewrite_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
+	tomoyo_put_name(saved_pattern);
 	kfree(new_entry);
 	return error;
 }
 
 /**
+ * tomoyo_cleanup_no_rewrite - Clean up deleted "struct tomoyo_no_rewrite_entry".
+ */
+void tomoyo_cleanup_no_rewrite(void)
+{
+	struct tomoyo_no_rewrite_entry *ptr;
+	struct tomoyo_no_rewrite_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&tomoyo_no_rewrite_list_lock);
+	list_for_each_entry_safe(ptr, tmp, &tomoyo_no_rewrite_list,
+				 entry.list) {
+		if (!ptr->is_deleted || !atomic_read(&ptr->entry.users))
+			continue;
+		list_del(&ptr->entry.list);
+		list_add(&ptr->entry.list, &q);
+	}
+	up_write(&tomoyo_no_rewrite_list_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, entry.list) {
+		tomoyo_put_name(ptr->pattern);
+		list_del(&ptr->entry.list);
+		tomoyo_free_element(ptr);
+	}
+}
+
+/**
  * tomoyo_is_no_rewrite_file - Check if the given pathname is not permitted to be rewrited.
  *
  * @filename: Filename to check.
@@ -440,8 +548,9 @@ static bool tomoyo_is_no_rewrite_file(co
 	struct tomoyo_no_rewrite_entry *ptr;
 	bool found = false;
 
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_no_rewrite_list_lock);
-	list_for_each_entry(ptr, &tomoyo_no_rewrite_list, list) {
+	list_for_each_entry(ptr, &tomoyo_no_rewrite_list, entry.list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!tomoyo_path_matches_pattern(filename, ptr->pattern))
@@ -450,6 +559,7 @@ static bool tomoyo_is_no_rewrite_file(co
 		break;
 	}
 	up_read(&tomoyo_no_rewrite_list_lock);
+	/***** READER SECTION END *****/
 	return found;
 }
 
@@ -478,10 +588,12 @@ bool tomoyo_read_no_rewrite_policy(struc
 	struct list_head *pos;
 	bool done = true;
 
-	down_read(&tomoyo_no_rewrite_list_lock);
+	/***** READER SECTION START *****/
+	tomoyo_down_read(&tomoyo_no_rewrite_list_lock, head->read_var2);
 	list_for_each_cookie(pos, head->read_var2, &tomoyo_no_rewrite_list) {
 		struct tomoyo_no_rewrite_entry *ptr;
-		ptr = list_entry(pos, struct tomoyo_no_rewrite_entry, list);
+		ptr = list_entry(pos, struct tomoyo_no_rewrite_entry,
+				 entry.list);
 		if (ptr->is_deleted)
 			continue;
 		if (!tomoyo_io_printf(head, TOMOYO_KEYWORD_DENY_REWRITE "%s\n",
@@ -490,7 +602,8 @@ bool tomoyo_read_no_rewrite_policy(struc
 			break;
 		}
 	}
-	up_read(&tomoyo_no_rewrite_list_lock);
+	tomoyo_up_read(&tomoyo_no_rewrite_list_lock, head->read_var2);
+	/***** READER SECTION END *****/
 	return done;
 }
 
@@ -556,8 +669,9 @@ static int tomoyo_check_single_path_acl2
 	struct tomoyo_acl_info *ptr;
 	int error = -EPERM;
 
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_domain_acl_info_list_lock);
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_single_path_acl_record *acl;
 		if (tomoyo_acl_type2(ptr) != TOMOYO_TYPE_SINGLE_PATH_ACL)
 			continue;
@@ -576,6 +690,7 @@ static int tomoyo_check_single_path_acl2
 		break;
 	}
 	up_read(&tomoyo_domain_acl_info_list_lock);
+	/***** READER SECTION END *****/
 	return error;
 }
 
@@ -656,11 +771,15 @@ static int tomoyo_check_file_perm2(struc
 	if (is_enforce)
 		return error;
 	if (mode == 1 && tomoyo_domain_quota_is_ok(domain)) {
+		const struct tomoyo_path_info *pattern;
 		/* Don't use patterns for execute permission. */
-		const struct tomoyo_path_info *patterned_file = (perm != 1) ?
-			tomoyo_get_file_pattern(filename) : filename;
-		tomoyo_update_file_acl(patterned_file->name, perm,
-				       domain, false);
+		if (perm != 1)
+			pattern = tomoyo_get_file_pattern(filename);
+		else
+			pattern = NULL;
+		tomoyo_update_file_acl(pattern ? pattern->name : filename->name,
+				       perm, domain, false);
+		tomoyo_put_file_pattern(pattern);
 	}
 	return 0;
 }
@@ -737,16 +856,16 @@ static int tomoyo_update_single_path_acl
 		return -EINVAL;
 	if (!tomoyo_is_correct_path(filename, 0, 0, 0, __func__))
 		return -EINVAL;
-	saved_filename = tomoyo_save_name(filename);
+	saved_filename = tomoyo_get_name(filename);
 	if (!saved_filename)
 		return -ENOMEM;
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_domain_acl_info_list_lock);
 	if (is_delete)
 		goto delete;
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_single_path_acl_record *acl;
 		if (tomoyo_acl_type1(ptr) != TOMOYO_TYPE_SINGLE_PATH_ACL)
 			continue;
@@ -773,13 +892,15 @@ static int tomoyo_update_single_path_acl
 		if (perm == (1 << TOMOYO_TYPE_READ_WRITE_ACL))
 			new_entry->perm |= rw_mask;
 		new_entry->filename = saved_filename;
-		list_add_tail(&new_entry->head.list, &domain->acl_info_list);
+		saved_filename = NULL;
+		list_add_tail(&new_entry->head.entry.list,
+			      &domain->acl_info_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	goto out;
  delete:
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_single_path_acl_record *acl;
 		if (tomoyo_acl_type2(ptr) != TOMOYO_TYPE_SINGLE_PATH_ACL)
 			continue;
@@ -799,7 +920,8 @@ static int tomoyo_update_single_path_acl
 	}
  out:
 	up_write(&tomoyo_domain_acl_info_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
+	tomoyo_put_name(saved_filename);
 	kfree(new_entry);
 	return error;
 }
@@ -832,17 +954,20 @@ static int tomoyo_update_double_path_acl
 	if (!tomoyo_is_correct_path(filename1, 0, 0, 0, __func__) ||
 	    !tomoyo_is_correct_path(filename2, 0, 0, 0, __func__))
 		return -EINVAL;
-	saved_filename1 = tomoyo_save_name(filename1);
-	saved_filename2 = tomoyo_save_name(filename2);
-	if (!saved_filename1 || !saved_filename2)
+	saved_filename1 = tomoyo_get_name(filename1);
+	saved_filename2 = tomoyo_get_name(filename2);
+	if (!saved_filename1 || !saved_filename2) {
+		tomoyo_put_name(saved_filename1);
+		tomoyo_put_name(saved_filename2);
 		return -ENOMEM;
+	}
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
-	/***** EXCLUSIVE SECTION START *****/
+	/***** WRITER SECTION START *****/
 	down_write(&tomoyo_domain_acl_info_list_lock);
 	if (is_delete)
 		goto delete;
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_double_path_acl_record *acl;
 		if (tomoyo_acl_type1(ptr) != TOMOYO_TYPE_DOUBLE_PATH_ACL)
 			continue;
@@ -864,14 +989,17 @@ static int tomoyo_update_double_path_acl
 		new_entry->head.type = TOMOYO_TYPE_DOUBLE_PATH_ACL;
 		new_entry->perm = perm;
 		new_entry->filename1 = saved_filename1;
+		saved_filename1 = NULL;
 		new_entry->filename2 = saved_filename2;
-		list_add_tail(&new_entry->head.list, &domain->acl_info_list);
+		saved_filename2 = NULL;
+		list_add_tail(&new_entry->head.entry.list,
+			      &domain->acl_info_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	goto out;
  delete:
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_double_path_acl_record *acl;
 		if (tomoyo_acl_type2(ptr) != TOMOYO_TYPE_DOUBLE_PATH_ACL)
 			continue;
@@ -888,7 +1016,9 @@ static int tomoyo_update_double_path_acl
 	}
  out:
 	up_write(&tomoyo_domain_acl_info_list_lock);
-	/***** EXCLUSIVE SECTION END *****/
+	/***** WRITER SECTION END *****/
+	tomoyo_put_name(saved_filename1);
+	tomoyo_put_name(saved_filename2);
 	kfree(new_entry);
 	return error;
 }
@@ -934,8 +1064,9 @@ static int tomoyo_check_double_path_acl(
 
 	if (!tomoyo_check_flags(domain, TOMOYO_MAC_FOR_FILE))
 		return 0;
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_domain_acl_info_list_lock);
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_double_path_acl_record *acl;
 		if (tomoyo_acl_type2(ptr) != TOMOYO_TYPE_DOUBLE_PATH_ACL)
 			continue;
@@ -951,6 +1082,7 @@ static int tomoyo_check_double_path_acl(
 		break;
 	}
 	up_read(&tomoyo_domain_acl_info_list_lock);
+	/***** READER SECTION END *****/
 	return error;
 }
 
@@ -985,8 +1117,12 @@ static int tomoyo_check_single_path_perm
 		       tomoyo_get_msg(is_enforce), msg, filename->name,
 		       tomoyo_get_last_name(domain));
 	if (mode == 1 && tomoyo_domain_quota_is_ok(domain)) {
-		const char *name = tomoyo_get_file_pattern(filename)->name;
-		tomoyo_update_single_path_acl(operation, name, domain, false);
+		const struct tomoyo_path_info *pattern
+			= tomoyo_get_file_pattern(filename);
+		tomoyo_update_single_path_acl(operation,
+					      pattern ? pattern->name :
+					      filename->name, domain, false);
+		tomoyo_put_file_pattern(pattern);
 	}
 	if (!is_enforce)
 		error = 0;
@@ -1232,10 +1368,18 @@ int tomoyo_check_2path_perm(struct tomoy
 		       msg, buf1->name, buf2->name,
 		       tomoyo_get_last_name(domain));
 	if (mode == 1 && tomoyo_domain_quota_is_ok(domain)) {
-		const char *name1 = tomoyo_get_file_pattern(buf1)->name;
-		const char *name2 = tomoyo_get_file_pattern(buf2)->name;
-		tomoyo_update_double_path_acl(operation, name1, name2, domain,
+		const struct tomoyo_path_info *pattern1
+			= tomoyo_get_file_pattern(buf1);
+		const struct tomoyo_path_info *pattern2
+			= tomoyo_get_file_pattern(buf2);
+		tomoyo_update_double_path_acl(operation,
+					      pattern1 ? pattern1->name :
+					      buf1->name,
+					      pattern2 ? pattern2->name :
+					      buf2->name, domain,
 					      false);
+		tomoyo_put_file_pattern(pattern1);
+		tomoyo_put_file_pattern(pattern2);
 	}
  out:
 	tomoyo_free(buf1);
--- security-testing-2.6.git.orig/security/tomoyo/realpath.c
+++ security-testing-2.6.git/security/tomoyo/realpath.c
@@ -238,27 +238,22 @@ static unsigned int tomoyo_quota_for_sav
 /* Structure for string data. */
 struct tomoyo_name_entry {
 	struct list_head list;
+	atomic_t users;
 	struct tomoyo_path_info entry;
 };
 
-/*
- * The list for "struct tomoyo_name_entry".
- *
- * This list is updated only inside tomoyo_save_name(), thus
- * no global mutex exists.
- */
+/* The list for "struct tomoyo_name_entry". */
 static struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];
+static DEFINE_MUTEX(tomoyo_name_list_lock);
 
 /**
- * tomoyo_save_name - Allocate permanent memory for string data.
+ * tomoyo_get_name - Allocate permanent memory for string data.
  *
  * @name: The string to store into the permernent memory.
  *
  * Returns pointer to "struct tomoyo_path_info" on success, NULL otherwise.
- *
- * The RAM is shared, so NEVER try to modify or kfree() the returned name.
  */
-const struct tomoyo_path_info *tomoyo_save_name(const char *name)
+const struct tomoyo_path_info *tomoyo_get_name(const char *name)
 {
 	static DEFINE_MUTEX(lock);
 	struct tomoyo_name_entry *entry;
@@ -278,11 +273,12 @@ const struct tomoyo_path_info *tomoyo_sa
 	entry = kmalloc(sizeof(*entry) + len, GFP_KERNEL);
 	allocated_len = entry ? ksize(entry) : 0;
 	/***** EXCLUSIVE SECTION START *****/
-	mutex_lock(&lock);
+	mutex_lock(&tomoyo_name_list_lock);
 	list_for_each_entry(ptr, &tomoyo_name_list[hash % TOMOYO_MAX_HASH],
 			     list) {
 		if (hash != ptr->entry.hash || strcmp(name, ptr->entry.name))
 			continue;
+		atomic_inc(&ptr->users);
 		error = 0;
 		break;
 	}
@@ -297,12 +293,13 @@ const struct tomoyo_path_info *tomoyo_sa
 		ptr->entry.name = ((char *) ptr) + sizeof(*ptr);
 		memmove((char *) ptr->entry.name, name, len);
 		tomoyo_fill_path_info(&ptr->entry);
+		atomic_set(&ptr->users, 1);
 		list_add_tail(&ptr->list,
 			      &tomoyo_name_list[hash % TOMOYO_MAX_HASH]);
 		entry = NULL;
 		error = 0;
 	}
-	mutex_unlock(&lock);
+	mutex_unlock(&tomoyo_name_list_lock);
 	/***** EXCLUSIVE SECTION END *****/
 	kfree(entry);
 	if (!error)
@@ -314,6 +311,33 @@ const struct tomoyo_path_info *tomoyo_sa
 }
 
 /**
+ * tomoyo_put_name - Delete shared memory for string data.
+ *
+ * @ptr: Pointer to "struct tomoyo_path_info".
+ */
+void tomoyo_put_name(const struct tomoyo_path_info *name)
+{
+	struct tomoyo_name_entry *ptr;
+	bool can_delete = false;
+
+	if (!name)
+		return;
+	ptr = container_of(name, struct tomoyo_name_entry, entry);
+	/***** EXCLUSIVE SECTION START *****/
+	mutex_lock(&tomoyo_name_list_lock);
+	if (atomic_dec_and_test(&ptr->users)) {
+		list_del(&ptr->list);
+		can_delete = true;
+	}
+	mutex_unlock(&tomoyo_name_list_lock);
+	/***** EXCLUSIVE SECTION END *****/
+	if (can_delete) {
+		atomic_sub(ksize(ptr), &tomoyo_allocated_memory_for_savename);
+		kfree(ptr);
+	}
+}
+
+/**
  * tomoyo_realpath_init - Initialize realpath related code.
  */
 void __init tomoyo_realpath_init(void)
@@ -324,12 +348,14 @@ void __init tomoyo_realpath_init(void)
 	for (i = 0; i < TOMOYO_MAX_HASH; i++)
 		INIT_LIST_HEAD(&tomoyo_name_list[i]);
 	INIT_LIST_HEAD(&tomoyo_kernel_domain.acl_info_list);
-	tomoyo_kernel_domain.domainname = tomoyo_save_name(TOMOYO_ROOT_NAME);
-	list_add_tail(&tomoyo_kernel_domain.list, &tomoyo_domain_list);
+	tomoyo_kernel_domain.domainname = tomoyo_get_name(TOMOYO_ROOT_NAME);
+	list_add_tail(&tomoyo_kernel_domain.entry.list, &tomoyo_domain_list);
+	/***** READER SECTION START *****/
 	down_read(&tomoyo_domain_list_lock);
 	if (tomoyo_find_domain(TOMOYO_ROOT_NAME) != &tomoyo_kernel_domain)
 		panic("Can't register tomoyo_kernel_domain");
 	up_read(&tomoyo_domain_list_lock);
+	/***** READER SECTION END *****/
 }
 
 /* Memory allocated for temporary purpose. */
--- security-testing-2.6.git.orig/security/tomoyo/realpath.h
+++ security-testing-2.6.git/security/tomoyo/realpath.h
@@ -43,7 +43,8 @@ bool tomoyo_memory_ok(void *ptr);
  * Keep the given name on the RAM.
  * The RAM is shared, so NEVER try to modify or kfree() the returned name.
  */
-const struct tomoyo_path_info *tomoyo_save_name(const char *name);
+const struct tomoyo_path_info *tomoyo_get_name(const char *name);
+void tomoyo_put_name(const struct tomoyo_path_info *name);
 
 /* Allocate memory for temporary use (e.g. permission checks). */
 void *tomoyo_alloc(const size_t size);
@@ -51,6 +52,8 @@ void *tomoyo_alloc(const size_t size);
 /* Free memory allocated by tomoyo_alloc(). */
 void tomoyo_free(const void *p);
 
+void tomoyo_free_element(void *p);
+
 /* Check for memory usage. */
 int tomoyo_read_memory_counter(struct tomoyo_io_buffer *head);
 
--- security-testing-2.6.git.orig/security/tomoyo/tomoyo.c
+++ security-testing-2.6.git/security/tomoyo/tomoyo.c
@@ -22,9 +22,19 @@ static int tomoyo_cred_prepare(struct cr
 	 * we don't need to duplicate.
 	 */
 	new->security = old->security;
+	if (new->security)
+		atomic_inc(&((struct tomoyo_domain_info *)
+			     new->security)->entry.users);
 	return 0;
 }
 
+static void tomoyo_cred_free(struct cred *cred)
+{
+	struct tomoyo_domain_info *domain = cred->security;
+	if (domain)
+		atomic_dec(&domain->entry.users);
+}
+
 static int tomoyo_bprm_set_creds(struct linux_binprm *bprm)
 {
 	/*
@@ -259,6 +269,7 @@ static int tomoyo_dentry_open(struct fil
 static struct security_operations tomoyo_security_ops = {
 	.name                = "tomoyo",
 	.cred_prepare        = tomoyo_cred_prepare,
+	.cred_free           = tomoyo_cred_free,
 	.bprm_set_creds      = tomoyo_bprm_set_creds,
 	.bprm_check_security = tomoyo_bprm_check_security,
 #ifdef CONFIG_SYSCTL
