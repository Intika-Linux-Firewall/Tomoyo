Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.18.8-0.9_SUSE.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.18.8-0.9_SUSE.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.18.8-0.9_SUSE.diff	(作業コピー)
@@ -3,50 +3,50 @@
 Source code for this patch is http://ftp.riken.jp/Linux/suse/suse/update/10.2/rpm/i586/kernel-source-2.6.18.8-0.9.i586.rpm
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 ++++
- arch/sparc64/kernel/ptrace.c    |   11 ++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 ++++
- fs/compat.c                     |    8 +++
- fs/exec.c                       |   15 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   61 ++++++++++++++++++++++++++
- fs/namespace.c                  |   39 ++++++++++++++++
- fs/open.c                       |   21 +++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |   11 +++
+ fs/exec.c                       |   21 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  118 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   50 ++++++++++++++++
+ fs/open.c                       |   27 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
  include/linux/sched.h           |    9 +++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |   11 +++-
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 ++++++
- kernel/sys.c                    |   15 ++++++
- kernel/sysctl.c                 |   93 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |   12 +++++
- net/core/datagram.c             |    9 +++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 +++
- net/ipv6/inet6_hashtables.c     |    8 +++
- net/ipv6/udp.c                  |    9 +++
- net/socket.c                    |   29 +++++++++++-
- net/unix/af_unix.c              |   10 ++++
- 44 files changed, 543 insertions(+), 9 deletions(-)
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   13 +++-
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |  111 +++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   15 +++++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    9 ++-
+ net/ipv6/udp.c                  |   11 +++
+ net/socket.c                    |   43 +++++++++++++-
+ net/unix/af_unix.c              |   15 +++++
+ 44 files changed, 713 insertions(+), 9 deletions(-)
 
 --- linux-2.6.18.8-0.9.orig/Makefile
 +++ linux-2.6.18.8-0.9/Makefile
@@ -89,13 +89,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry * dentry
+@@ -145,12 +148,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -104,8 +108,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -122,17 +130,20 @@
  
  extern void sigset_from_compat(sigset_t *set, compat_sigset_t *compat);
  
-@@ -421,6 +424,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -421,6 +424,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1567,7 +1573,7 @@ int compat_do_execve(char * filename,
+@@ -1567,7 +1576,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -154,34 +165,40 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  int suid_dumpable = 0;
-@@ -139,6 +143,11 @@ asmlinkage long sys_uselib(const char __
+@@ -139,6 +143,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -486,6 +495,9 @@ struct file *open_exec(const char *name)
+@@ -486,6 +497,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1193,7 +1205,8 @@ int do_execve(char * filename,
+@@ -1193,7 +1211,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
@@ -198,12 +215,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -214,6 +217,10 @@ static int setfl(int fd, struct file * f
+@@ -214,6 +217,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -221,12 +240,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -23,6 +26,9 @@ static long do_ioctl(struct file *filp, 
+@@ -23,6 +26,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -244,29 +264,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1481,6 +1485,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1481,6 +1485,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1536,6 +1543,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1536,6 +1547,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1567,6 +1579,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1567,6 +1585,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -276,136 +302,187 @@
  /*
   *	open_namei()
   *
-@@ -1835,6 +1850,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1835,6 +1856,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1853,10 +1874,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1853,10 +1884,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1921,6 +1948,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1921,6 +1974,13 @@ asmlinkage long sys_mkdirat(int dfd, con
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -2029,6 +2059,9 @@ static long do_rmdir(int dfd, const char
+@@ -2029,6 +2089,13 @@ static long do_rmdir(int dfd, const char
  	dentry = lookup_hash(&nd);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -2088,6 +2121,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2088,6 +2155,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2109,6 +2145,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2109,6 +2180,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2171,6 +2210,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2171,6 +2250,10 @@ asmlinkage long sys_symlinkat(const char
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2187,6 +2229,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2187,6 +2270,13 @@ asmlinkage long sys_symlinkat(const char
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2259,6 +2304,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2259,6 +2349,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2281,6 +2329,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2281,6 +2375,15 @@ asmlinkage long sys_linkat(int olddfd, c
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2507,6 +2558,13 @@ static int do_rename(int olddfd, const c
+@@ -2507,6 +2610,17 @@ static int do_rename(int olddfd, const c
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2529,6 +2587,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2529,6 +2643,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -425,91 +502,102 @@
  
  extern int __init init_rootfs(void);
  
-@@ -554,6 +560,10 @@ static int do_umount(struct vfsmount *mn
+@@ -554,6 +560,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -642,6 +652,9 @@ asmlinkage long sys_umount(char __user *
+@@ -642,6 +653,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -926,6 +939,10 @@ static int do_loopback(struct nameidata 
+@@ -926,6 +941,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1010,7 +1027,10 @@ static int do_move_mount(struct nameidat
+@@ -1010,7 +1030,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1112,6 +1132,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1112,6 +1136,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1403,6 +1427,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1403,6 +1432,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1692,6 +1723,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1692,6 +1732,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1708,6 +1742,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1708,6 +1752,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -529,45 +617,51 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -267,6 +273,9 @@ static long do_sys_truncate(const char _
+@@ -267,6 +273,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -320,6 +329,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -320,6 +330,11 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, file);
-@@ -608,6 +620,12 @@ asmlinkage long sys_chroot(const char __
+@@ -608,6 +623,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1199,6 +1217,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1199,6 +1222,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
@@ -589,7 +683,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.18.8-0.9_SUSE 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.18.8-0.9_SUSE 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -643,12 +737,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -836,6 +839,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -836,6 +839,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -665,12 +760,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -922,6 +925,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -922,6 +925,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -701,24 +797,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -666,7 +669,9 @@ sys_delete_module(const char __user *nam
+@@ -666,7 +669,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1926,7 +1931,9 @@ sys_init_module(void __user *umod,
+@@ -1926,7 +1932,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (mutex_lock_interruptible(&module_mutex) != 0)
@@ -735,12 +833,13 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -4004,6 +4007,9 @@ int can_nice(const struct task_struct *p
+@@ -4004,6 +4007,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -757,35 +856,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2183,6 +2186,10 @@ asmlinkage long
+@@ -2183,6 +2186,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2241,6 +2248,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2241,6 +2250,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2254,6 +2265,10 @@ sys_tkill(int pid, int sig)
+@@ -2254,6 +2269,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -802,42 +907,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -467,6 +470,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -467,6 +470,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -693,6 +699,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -693,6 +702,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1690,6 +1699,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1690,6 +1703,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1735,6 +1747,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1735,6 +1752,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -854,24 +965,28 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1178,6 +1181,87 @@ void __init sysctl_init(void)
+@@ -1178,6 +1181,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -889,35 +1004,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -942,25 +1066,30 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1203,6 +1287,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1203,6 +1300,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1275,6 +1362,12 @@ repeat:
+@@ -1275,6 +1377,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
@@ -977,32 +1106,35 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -91,6 +94,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -91,6 +94,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -161,6 +167,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -161,6 +168,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -221,6 +230,9 @@ int do_adjtimex(struct timex *txc)
+@@ -221,6 +232,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
@@ -1021,12 +1153,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1044,12 +1178,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -87,6 +90,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -87,6 +90,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1066,12 +1201,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -263,6 +266,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -263,6 +266,10 @@ int inet_hash_connect(struct inet_timewa
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1088,22 +1224,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -146,6 +149,9 @@ static int udp_v4_get_port(struct sock *
+@@ -146,6 +149,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -162,6 +168,9 @@ static int udp_v4_get_port(struct sock *
+@@ -162,6 +169,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1129,12 +1267,13 @@
  						inet->dport);
  	struct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);
  	struct sock *sk2;
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1151,22 +1290,24 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6) __read_mostly;
  
-@@ -88,6 +91,9 @@ static int udp_v6_get_port(struct sock *
+@@ -88,6 +91,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -104,6 +110,9 @@ static int udp_v6_get_port(struct sock *
+@@ -104,6 +111,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1185,54 +1326,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -592,7 +597,9 @@ static inline int __sock_sendmsg(struct 
+@@ -592,7 +597,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1148,6 +1155,10 @@ static int __sock_create(int family, int
+@@ -1148,6 +1158,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1342,6 +1353,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1342,6 +1358,13 @@ asmlinkage long sys_bind(int fd, struct 
  	{
  		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
  			err = security_socket_bind(sock, (struct sockaddr *)address, addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  					(struct sockaddr *)address, addrlen);
-@@ -1370,6 +1384,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1370,6 +1393,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1434,6 +1451,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1434,6 +1461,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1240,13 +1392,16 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1490,7 +1513,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1490,7 +1524,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
@@ -1263,23 +1418,28 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -764,6 +767,10 @@ static int unix_bind(struct socket *sock
+@@ -764,6 +767,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -807,6 +814,9 @@ static int unix_bind(struct socket *sock
+@@ -807,6 +815,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1296,13 +1456,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1320,13 +1481,14 @@
  
  #include "entry.h"
  
-@@ -1417,6 +1420,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1417,6 +1420,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1344,13 +1506,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -742,6 +745,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -742,6 +745,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1368,13 +1531,14 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -711,6 +714,11 @@ sys_ptrace(long request, long pid, long 
+@@ -711,6 +714,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -1446,13 +1610,14 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -509,6 +512,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -509,6 +512,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -1470,13 +1635,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -271,6 +274,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -271,6 +274,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1494,13 +1660,14 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -230,6 +233,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -230,6 +233,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1518,13 +1685,14 @@
  
  #include "ia32priv.h"
  
-@@ -1741,6 +1744,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1741,6 +1744,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1542,13 +1710,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1566,13 +1735,14 @@
  
  #include "ptrace-common.h"
  
-@@ -45,6 +48,11 @@ long compat_sys_ptrace(int request, int 
+@@ -45,6 +48,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22.17-0.1_SUSE.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22.17-0.1_SUSE.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22.17-0.1_SUSE.diff	(作業コピー)
@@ -3,52 +3,52 @@
 Source code for this patch is http://download.opensuse.org/update/10.3/rpm/i586/kernel-source-2.6.22.17-0.1.i586.rpm
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 +++++
- arch/sparc64/kernel/ptrace.c    |   11 +++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 +++++
- fs/compat.c                     |    5 +-
- fs/compat_ioctl.c               |    6 ++
- fs/exec.c                       |   14 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   60 +++++++++++++++++++++++++++++
- fs/namespace.c                  |   38 ++++++++++++++++++
- fs/open.c                       |   21 ++++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |    5 +
+ fs/compat_ioctl.c               |    9 +++
+ fs/exec.c                       |   20 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  112 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   49 +++++++++++++++++
+ fs/open.c                       |   27 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
- include/linux/sched.h           |    9 ++++
- include/linux/syaoran.h         |    7 +--
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |    9 ++++
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 +++++++
- kernel/sys.c                    |   15 +++++++
- kernel/sysctl.c                 |   81 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |    9 ++++
- kernel/time/ntp.c               |    6 ++
- net/core/datagram.c             |    9 ++++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 ++++
- net/ipv6/inet6_hashtables.c     |    6 ++
- net/socket.c                    |   28 +++++++++++++
- net/unix/af_unix.c              |   10 ++++
- 46 files changed, 530 insertions(+), 6 deletions(-)
+ include/linux/sched.h           |    9 +++
+ include/linux/syaoran.h         |    7 +-
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   11 +++
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |   95 +++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   11 +++
+ kernel/time/ntp.c               |    7 ++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    7 ++
+ net/socket.c                    |   41 ++++++++++++++
+ net/unix/af_unix.c              |   15 +++++
+ 46 files changed, 688 insertions(+), 6 deletions(-)
 
 --- linux-2.6.22.17-0.1.orig/Makefile
 +++ linux-2.6.22.17-0.1/Makefile
@@ -91,13 +91,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry *dentry,
+@@ -145,12 +148,28 @@ int notify_change(struct dentry *dentry,
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, mnt, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -106,8 +110,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, mnt, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -145,12 +153,15 @@
  
  static int do_ioctl32_pointer(unsigned int fd, unsigned int cmd,
  			      unsigned long arg, struct file *f)
-@@ -3567,6 +3570,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -3567,6 +3570,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
@@ -168,34 +179,40 @@
  int core_uses_pid;
  char core_pattern[CORENAME_MAX_SIZE] = "core";
  int suid_dumpable = 0;
-@@ -145,6 +149,11 @@ asmlinkage long sys_uselib(const char __
+@@ -145,6 +149,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -490,6 +499,9 @@ struct file *open_exec(const char *name)
+@@ -490,6 +501,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1212,7 +1224,7 @@ int do_execve(char * filename,
+@@ -1212,7 +1230,7 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
  	if (retval >= 0) {
  		free_arg_pages(bprm);
  
@@ -211,12 +228,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -213,6 +216,10 @@ static int setfl(int fd, struct file * f
+@@ -213,6 +216,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (((arg ^ filp->f_flags) & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -234,12 +253,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -25,6 +28,9 @@ static long do_ioctl(struct file *filp, 
+@@ -25,6 +28,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -257,29 +277,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1535,6 +1539,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1535,6 +1539,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, nd ? nd->mnt : NULL, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1590,6 +1597,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1590,6 +1601,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1640,6 +1652,9 @@ static int open_namei_create(struct name
+@@ -1640,6 +1658,9 @@ static int open_namei_create(struct name
  	return may_open(nd, 0, flag & ~O_TRUNC);
  }
  
@@ -289,135 +315,181 @@
  /*
   *	open_namei()
   *
-@@ -1901,6 +1916,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1901,6 +1922,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1919,10 +1940,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1919,10 +1950,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
  					  mode, new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
  					  mode, 0);
  			break;
-@@ -1992,6 +2019,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1992,6 +2045,12 @@ asmlinkage long sys_mkdirat(int dfd, con
  
  	if (!IS_POSIXACL(nd.dentry->d_inode))
  		mode &= ~current->fs->umask;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_mkdir(nd.dentry->d_inode, dentry, nd.mnt, mode);
  	dput(dentry);
  out_unlock:
-@@ -2100,6 +2130,9 @@ static long do_rmdir(int dfd, const char
+@@ -2100,6 +2159,12 @@ static long do_rmdir(int dfd, const char
  	error = PTR_ERR(dentry);
  	if (IS_ERR(dentry))
  		goto exit2;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_rmdir(nd.dentry->d_inode, dentry, nd.mnt);
  	dput(dentry);
  exit2:
-@@ -2159,6 +2192,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2159,6 +2224,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2180,6 +2216,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2180,6 +2249,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry, nd.mnt);
  	exit2:
  		dput(dentry);
-@@ -2245,6 +2284,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2245,6 +2322,10 @@ asmlinkage long sys_symlinkat(const char
  	char * to;
  	struct dentry *dentry;
  	struct nameidata nd;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2262,6 +2304,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2262,6 +2343,12 @@ asmlinkage long sys_symlinkat(const char
  	if (IS_ERR(dentry))
  		goto out_unlock;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_symlink(nd.dentry->d_inode, dentry, nd.mnt, from,
  			    S_IALLUGO);
  	dput(dentry);
-@@ -2336,6 +2381,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2336,6 +2423,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2359,6 +2407,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2359,6 +2450,13 @@ asmlinkage long sys_linkat(int olddfd, c
  	error = PTR_ERR(new_dentry);
  	if (IS_ERR(new_dentry))
  		goto out_unlock;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
++	if (!error)
++		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
++					     old_nd.mnt, new_dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_link(old_nd.dentry, old_nd.mnt, nd.dentry->d_inode,
  			 new_dentry, nd.mnt);
  	dput(new_dentry);
-@@ -2592,6 +2643,12 @@ static int do_rename(int olddfd, const c
+@@ -2592,6 +2690,16 @@ static int do_rename(int olddfd, const c
  	error = -ENOTEMPTY;
  	if (new_dentry == trap)
  		goto exit5;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
  
  	error = vfs_rename(old_dir->d_inode, old_dentry, oldnd.mnt,
  			   new_dir->d_inode, new_dentry, newnd.mnt);
-@@ -2615,6 +2672,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2615,6 +2723,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -437,90 +509,101 @@
  
  /* spinlock for vfsmount related operations, inplace of dcache_lock */
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(vfsmount_lock);
-@@ -549,6 +555,10 @@ static int do_umount(struct vfsmount *mn
+@@ -549,6 +555,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -637,6 +647,9 @@ asmlinkage long sys_umount(char __user *
+@@ -637,6 +648,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -924,6 +937,10 @@ static int do_loopback(struct nameidata 
+@@ -924,6 +939,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1009,6 +1026,10 @@ static int do_move_mount(struct nameidat
+@@ -1009,6 +1029,11 @@ static int do_move_mount(struct nameidat
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
  
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1110,6 +1131,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1110,6 +1135,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1401,6 +1426,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1401,6 +1431,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1677,6 +1709,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1677,6 +1718,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1693,6 +1728,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1693,6 +1738,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -540,45 +623,51 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -266,6 +272,9 @@ static long do_sys_truncate(const char _
+@@ -266,6 +272,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -319,6 +328,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -319,6 +329,11 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, file->f_path.mnt, length,
-@@ -482,6 +494,12 @@ asmlinkage long sys_chroot(const char __
+@@ -482,6 +497,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1093,6 +1111,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1093,6 +1116,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		/* XXX: this needs locking */
@@ -600,7 +689,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.22.17-0.1_SUSE 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.22.17-0.1_SUSE 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -684,12 +773,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -869,6 +872,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -869,6 +872,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -706,12 +796,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -961,6 +964,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -961,6 +964,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -742,22 +833,24 @@
  
  extern int module_sysfs_initialized;
  
-@@ -679,6 +682,9 @@ sys_delete_module(const char __user *nam
+@@ -679,6 +682,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
-@@ -2024,6 +2030,9 @@ sys_init_module(void __user *umod,
+@@ -2024,6 +2031,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Only one module load at a time, please */
@@ -774,12 +867,13 @@
  
  /*
   * Scheduler clock - returns current time in nanosec units.
-@@ -4273,6 +4276,9 @@ int can_nice(const struct task_struct *p
+@@ -4273,6 +4276,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -796,35 +890,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2159,6 +2162,10 @@ asmlinkage long
+@@ -2159,6 +2162,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2217,6 +2224,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2217,6 +2226,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2230,6 +2241,10 @@ sys_tkill(int pid, int sig)
+@@ -2230,6 +2245,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -841,42 +941,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -662,6 +665,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -662,6 +665,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > PRIO_USER || which < PRIO_PROCESS)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -892,6 +898,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -892,6 +901,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1867,6 +1876,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1867,6 +1880,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1912,6 +1924,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1912,6 +1929,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -893,25 +999,29 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1170,6 +1173,81 @@ char *sysctl_pathname(ctl_table *table, 
+@@ -1170,6 +1173,93 @@ char *sysctl_pathname(ctl_table *table, 
  EXPORT_SYMBOL(sysctl_pathname);
  
  #ifdef CONFIG_SYSCTL_SYSCALL
 +
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -929,30 +1039,38 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", n);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", n);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				name++;
@@ -975,12 +1093,14 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1186,6 +1264,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1186,6 +1276,11 @@ int do_sysctl(int __user *name, int nlen
  
  	for (head = sysctl_head_next(NULL); head;
  			head = sysctl_head_next(head)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table);
@@ -997,22 +1117,24 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -90,6 +93,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -90,6 +93,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -160,6 +166,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -160,6 +167,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
@@ -1029,12 +1151,13 @@
  
  /*
   * Timekeeping variables
-@@ -203,6 +206,9 @@ int do_adjtimex(struct timex *txc)
+@@ -203,6 +206,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Now we validate the data before disabling interrupts */
@@ -1053,12 +1176,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1076,12 +1201,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -85,6 +88,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -85,6 +88,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1098,12 +1224,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -292,6 +295,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -292,6 +295,10 @@ int inet_hash_connect(struct inet_timewa
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
@@ -1120,22 +1247,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -162,6 +165,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -162,6 +165,10 @@ int __udp_lib_get_port(struct sock *sk, 
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -181,6 +187,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -181,6 +188,10 @@ int __udp_lib_get_port(struct sock *sk, 
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (! __udp_lib_lport_inuse(result, udptable))
  				break;
@@ -1152,12 +1281,13 @@
  
  void __inet6_hash(struct inet_hashinfo *hashinfo,
  				struct sock *sk)
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
@@ -1176,53 +1306,64 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
  			 unsigned long nr_segs, loff_t pos);
-@@ -553,6 +558,9 @@ static inline int __sock_sendmsg(struct 
+@@ -553,6 +558,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
-@@ -1102,6 +1110,10 @@ static int __sock_create(int family, int
+@@ -1102,6 +1113,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1333,6 +1345,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1333,6 +1350,13 @@ asmlinkage long sys_bind(int fd, struct 
  			err = security_socket_bind(sock,
  						   (struct sockaddr *)address,
  						   addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  						      (struct sockaddr *)
-@@ -1362,6 +1377,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1362,6 +1386,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1426,6 +1444,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1426,6 +1454,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1230,13 +1371,15 @@
  	if (upeer_sockaddr) {
  		if (newsock->ops->getname(newsock, (struct sockaddr *)address,
  					  &len, 2) < 0) {
-@@ -1490,6 +1514,10 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1490,6 +1525,12 @@ asmlinkage long sys_connect(int fd, stru
  	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 +	/***** TOMOYO Linux start. *****/
-+	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen);
-+	if (err) goto out_put;
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  
  	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
@@ -1253,23 +1396,28 @@
  
  int sysctl_unix_max_dgram_qlen __read_mostly = 10;
  
-@@ -764,6 +767,10 @@ static int unix_bind(struct socket *sock
+@@ -764,6 +767,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -807,6 +814,9 @@ static int unix_bind(struct socket *sock
+@@ -807,6 +815,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt, mode, 0);
  		if (err)
@@ -1286,13 +1434,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1310,13 +1459,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -742,6 +745,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -742,6 +745,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1334,13 +1484,14 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -712,6 +715,11 @@ sys_ptrace(long request, long pid, long 
+@@ -712,6 +715,12 @@ sys_ptrace(long request, long pid, long 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1358,13 +1509,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -271,6 +274,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -271,6 +274,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1382,13 +1534,14 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -234,6 +237,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -234,6 +237,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1406,13 +1559,14 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -455,6 +458,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -455,6 +458,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1430,13 +1584,14 @@
  
  #include "entry.h"
  
-@@ -1418,6 +1421,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1418,6 +1421,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1454,13 +1609,14 @@
  
  #include "ia32priv.h"
  
-@@ -1758,6 +1761,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1758,6 +1761,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1478,13 +1634,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1502,13 +1659,14 @@
  
  #include "ptrace-common.h"
  
-@@ -45,6 +48,11 @@ long compat_sys_ptrace(int request, int 
+@@ -45,6 +48,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22.14-72.fc6.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22.14-72.fc6.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22.14-72.fc6.diff	(作業コピー)
@@ -3,46 +3,46 @@
 Source code for this patch is http://ftp.riken.jp/Linux/fedora/core/updates/6/SRPMS/kernel-2.6.22.14-72.fc6.src.rpm
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 +++++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 +++++
- fs/compat.c                     |    5 +-
- fs/compat_ioctl.c               |    6 ++
- fs/exec.c                       |   14 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   60 +++++++++++++++++++++++++++++
- fs/namespace.c                  |   38 ++++++++++++++++++
- fs/open.c                       |   21 ++++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |    5 +
+ fs/compat_ioctl.c               |    9 +++
+ fs/exec.c                       |   20 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  112 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   49 +++++++++++++++++
+ fs/open.c                       |   26 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
- include/linux/sched.h           |    9 ++++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |    9 ++++
- kernel/ptrace.c                 |   13 ++++++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 +++++++
- kernel/sys.c                    |   15 +++++++
- kernel/sysctl.c                 |   81 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |    9 ++++
- kernel/time/ntp.c               |    6 ++
- net/core/datagram.c             |    9 ++++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 ++++
- net/ipv6/inet6_hashtables.c     |    6 ++
- net/socket.c                    |   28 +++++++++++++
- net/unix/af_unix.c              |   10 ++++
- 40 files changed, 488 insertions(+), 3 deletions(-)
+ include/linux/sched.h           |    9 +++
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   11 +++
+ kernel/ptrace.c                 |   15 +++++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |   95 +++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   11 +++
+ kernel/time/ntp.c               |    7 ++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    7 ++
+ net/socket.c                    |   41 ++++++++++++++
+ net/unix/af_unix.c              |   15 +++++
+ 40 files changed, 642 insertions(+), 3 deletions(-)
 
 --- linux-2.6.22.14-72.fc6.orig/Makefile
 +++ linux-2.6.22.14-72.fc6/Makefile
@@ -85,13 +85,17 @@
  
  /* Taken over from the old code... */
  
-@@ -144,12 +147,20 @@ int notify_change(struct dentry * dentry
+@@ -144,12 +147,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -100,8 +104,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -139,12 +147,15 @@
  
  static int do_ioctl32_pointer(unsigned int fd, unsigned int cmd,
  			      unsigned long arg, struct file *f)
-@@ -3567,6 +3570,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -3567,6 +3570,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
@@ -162,34 +173,40 @@
  int core_uses_pid;
  char core_pattern[CORENAME_MAX_SIZE] = "core";
  int suid_dumpable = 0;
-@@ -145,6 +149,11 @@ asmlinkage long sys_uselib(const char __
+@@ -145,6 +149,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -490,6 +499,9 @@ struct file *open_exec(const char *name)
+@@ -490,6 +501,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1207,7 +1219,7 @@ int do_execve(char * filename,
+@@ -1207,7 +1225,7 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
  	if (retval >= 0) {
  		free_arg_pages(bprm);
  
@@ -205,12 +222,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -213,6 +216,10 @@ static int setfl(int fd, struct file * f
+@@ -213,6 +216,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (((arg ^ filp->f_flags) & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -228,12 +247,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -25,6 +28,9 @@ static long do_ioctl(struct file *filp, 
+@@ -25,6 +28,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -251,29 +271,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1524,6 +1528,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1524,6 +1528,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1579,6 +1586,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1579,6 +1590,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1628,6 +1640,9 @@ static int open_namei_create(struct name
+@@ -1628,6 +1646,9 @@ static int open_namei_create(struct name
  	return may_open(nd, 0, flag & ~O_TRUNC);
  }
  
@@ -283,135 +309,181 @@
  /*
   *	open_namei()
   *
-@@ -1888,6 +1903,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1888,6 +1909,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1906,10 +1927,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1906,10 +1937,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1977,6 +2004,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1977,6 +2030,12 @@ asmlinkage long sys_mkdirat(int dfd, con
  
  	if (!IS_POSIXACL(nd.dentry->d_inode))
  		mode &= ~current->fs->umask;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  	dput(dentry);
  out_unlock:
-@@ -2084,6 +2114,9 @@ static long do_rmdir(int dfd, const char
+@@ -2084,6 +2143,12 @@ static long do_rmdir(int dfd, const char
  	error = PTR_ERR(dentry);
  	if (IS_ERR(dentry))
  		goto exit2;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_rmdir(nd.dentry->d_inode, dentry);
  	dput(dentry);
  exit2:
-@@ -2143,6 +2176,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2143,6 +2208,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2164,6 +2200,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2164,6 +2233,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2228,6 +2267,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2228,6 +2305,10 @@ asmlinkage long sys_symlinkat(const char
  	char * to;
  	struct dentry *dentry;
  	struct nameidata nd;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2245,6 +2287,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2245,6 +2326,12 @@ asmlinkage long sys_symlinkat(const char
  	if (IS_ERR(dentry))
  		goto out_unlock;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  	dput(dentry);
  out_unlock:
-@@ -2317,6 +2362,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2317,6 +2404,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2340,6 +2388,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2340,6 +2431,13 @@ asmlinkage long sys_linkat(int olddfd, c
  	error = PTR_ERR(new_dentry);
  	if (IS_ERR(new_dentry))
  		goto out_unlock;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
++	if (!error)
++		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
++					     old_nd.mnt, new_dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  	dput(new_dentry);
  out_unlock:
-@@ -2565,6 +2616,12 @@ static int do_rename(int olddfd, const c
+@@ -2565,6 +2663,16 @@ static int do_rename(int olddfd, const c
  	error = -ENOTEMPTY;
  	if (new_dentry == trap)
  		goto exit5;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
  
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
-@@ -2588,6 +2645,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2588,6 +2696,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -431,90 +503,101 @@
  
  /* spinlock for vfsmount related operations, inplace of dcache_lock */
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(vfsmount_lock);
-@@ -549,6 +555,10 @@ static int do_umount(struct vfsmount *mn
+@@ -549,6 +555,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -637,6 +647,9 @@ asmlinkage long sys_umount(char __user *
+@@ -637,6 +648,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -924,6 +937,10 @@ static int do_loopback(struct nameidata 
+@@ -924,6 +939,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1009,6 +1026,10 @@ static int do_move_mount(struct nameidat
+@@ -1009,6 +1029,11 @@ static int do_move_mount(struct nameidat
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
  
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1110,6 +1131,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1110,6 +1135,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1401,6 +1426,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1401,6 +1431,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1677,6 +1709,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1677,6 +1718,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1693,6 +1728,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1693,6 +1738,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -534,45 +617,50 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -266,6 +272,9 @@ static long do_sys_truncate(const char _
+@@ -266,6 +272,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -319,6 +328,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -319,6 +329,10 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, file);
-@@ -483,6 +495,12 @@ asmlinkage long sys_chroot(const char __
+@@ -483,6 +497,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1086,6 +1104,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1086,6 +1108,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		/* XXX: this needs locking */
@@ -594,7 +682,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.22.14-72.fc6 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.22.14-72.fc6 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -648,12 +736,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -869,6 +872,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -869,6 +872,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -670,12 +759,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -924,6 +927,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -924,6 +927,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -706,22 +796,24 @@
  
  extern int module_sysfs_initialized;
  
-@@ -666,6 +669,9 @@ sys_delete_module(const char __user *nam
+@@ -666,6 +669,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
-@@ -1996,6 +2002,9 @@ sys_init_module(void __user *umod,
+@@ -1996,6 +2003,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Only one module load at a time, please */
@@ -738,12 +830,13 @@
  
  /*
   * Scheduler clock - returns current time in nanosec units.
-@@ -4057,6 +4060,9 @@ int can_nice(const struct task_struct *p
+@@ -4057,6 +4060,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -760,35 +853,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2064,6 +2067,10 @@ asmlinkage long
+@@ -2064,6 +2067,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2122,6 +2129,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2122,6 +2131,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2135,6 +2146,10 @@ sys_tkill(int pid, int sig)
+@@ -2135,6 +2150,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -805,42 +904,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -663,6 +666,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -663,6 +666,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > PRIO_USER || which < PRIO_PROCESS)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -894,6 +900,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -894,6 +903,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1869,6 +1878,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1869,6 +1882,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1914,6 +1926,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1914,6 +1931,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -857,25 +962,29 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1234,6 +1237,81 @@ struct ctl_table_header *sysctl_head_nex
+@@ -1234,6 +1237,93 @@ struct ctl_table_header *sysctl_head_nex
  }
  
  #ifdef CONFIG_SYSCTL_SYSCALL
 +
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -893,30 +1002,38 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", n);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", n);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				name++;
@@ -939,12 +1056,14 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1250,6 +1328,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1250,6 +1340,11 @@ int do_sysctl(int __user *name, int nlen
  
  	for (head = sysctl_head_next(NULL); head;
  			head = sysctl_head_next(head)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table);
@@ -961,22 +1080,24 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -90,6 +93,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -90,6 +93,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -160,6 +166,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -160,6 +167,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
@@ -993,12 +1114,13 @@
  
  /*
   * Timekeeping variables
-@@ -203,6 +206,9 @@ int do_adjtimex(struct timex *txc)
+@@ -203,6 +206,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Now we validate the data before disabling interrupts */
@@ -1017,12 +1139,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1040,12 +1164,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -85,6 +88,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -85,6 +88,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1062,12 +1187,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -292,6 +295,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -292,6 +295,10 @@ int inet_hash_connect(struct inet_timewa
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
@@ -1084,22 +1210,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -162,6 +165,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -162,6 +165,10 @@ int __udp_lib_get_port(struct sock *sk, 
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -181,6 +187,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -181,6 +188,10 @@ int __udp_lib_get_port(struct sock *sk, 
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (! __udp_lib_lport_inuse(result, udptable))
  				break;
@@ -1116,12 +1244,13 @@
  
  void __inet6_hash(struct inet_hashinfo *hashinfo,
  				struct sock *sk)
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
@@ -1140,53 +1269,64 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
  			 unsigned long nr_segs, loff_t pos);
-@@ -553,6 +558,9 @@ static inline int __sock_sendmsg(struct 
+@@ -553,6 +558,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
-@@ -1102,6 +1110,10 @@ static int __sock_create(int family, int
+@@ -1102,6 +1113,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1333,6 +1345,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1333,6 +1350,13 @@ asmlinkage long sys_bind(int fd, struct 
  			err = security_socket_bind(sock,
  						   (struct sockaddr *)address,
  						   addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  						      (struct sockaddr *)
-@@ -1362,6 +1377,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1362,6 +1386,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1426,6 +1444,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1426,6 +1454,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1194,13 +1334,15 @@
  	if (upeer_sockaddr) {
  		if (newsock->ops->getname(newsock, (struct sockaddr *)address,
  					  &len, 2) < 0) {
-@@ -1490,6 +1514,10 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1490,6 +1525,12 @@ asmlinkage long sys_connect(int fd, stru
  	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 +	/***** TOMOYO Linux start. *****/
-+	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen);
-+	if (err) goto out_put;
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  
  	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
@@ -1217,23 +1359,28 @@
  
  int sysctl_unix_max_dgram_qlen __read_mostly = 10;
  
-@@ -764,6 +767,10 @@ static int unix_bind(struct socket *sock
+@@ -764,6 +767,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -807,6 +814,9 @@ static int unix_bind(struct socket *sock
+@@ -807,6 +815,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1250,13 +1397,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1274,13 +1422,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -742,6 +745,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -742,6 +745,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1325,25 +1474,27 @@
  
  #ifdef CONFIG_DEBUG_PREEMPT
  #define NO_LOCKS	WARN_ON(preempt_count() != 0)
-@@ -997,6 +1000,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -997,6 +1000,12 @@ asmlinkage long sys_ptrace(long request,
  	struct utrace_attached_engine *engine = NULL;
  	struct ptrace_state *state = NULL;
  	long ret, val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	pr_debug("%d sys_ptrace(%ld, %ld, %lx, %lx)\n",
  		 current->pid, request, pid, addr, data);
-@@ -1084,6 +1092,11 @@ asmlinkage long compat_sys_ptrace(compat
+@@ -1084,6 +1093,12 @@ asmlinkage long compat_sys_ptrace(compat
  	struct utrace_attached_engine *engine;
  	struct ptrace_state *state;
  	compat_long_t ret, val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1361,13 +1512,14 @@
  
  #include "ia32priv.h"
  
-@@ -1741,6 +1744,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1741,6 +1744,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1385,13 +1537,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1409,13 +1562,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -271,6 +274,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -271,6 +274,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.23.15-80.fc7.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.23.15-80.fc7.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.23.15-80.fc7.diff	(作業コピー)
@@ -3,46 +3,46 @@
 Source code for this patch is http://ftp.riken.jp/Linux/fedora/updates/7/SRPMS/kernel-2.6.23.15-80.fc7.src.rpm
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 +++++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 +++++
- fs/compat.c                     |    5 +-
- fs/compat_ioctl.c               |    6 ++
- fs/exec.c                       |   14 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   60 +++++++++++++++++++++++++++++
- fs/namespace.c                  |   38 ++++++++++++++++++
- fs/open.c                       |   21 ++++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |    5 +
+ fs/compat_ioctl.c               |    9 +++
+ fs/exec.c                       |   20 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  112 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   49 +++++++++++++++++
+ fs/open.c                       |   26 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
- include/linux/sched.h           |    9 ++++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |    9 ++++
- kernel/ptrace.c                 |   13 ++++++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 +++++++
- kernel/sys.c                    |   15 +++++++
- kernel/sysctl.c                 |   81 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |    9 ++++
- kernel/time/ntp.c               |    6 ++
- net/core/datagram.c             |    9 ++++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 ++++
- net/ipv6/inet6_hashtables.c     |    6 ++
- net/socket.c                    |   28 +++++++++++++
- net/unix/af_unix.c              |   10 ++++
- 40 files changed, 488 insertions(+), 3 deletions(-)
+ include/linux/sched.h           |    9 +++
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   11 +++
+ kernel/ptrace.c                 |   15 +++++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |   95 +++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   11 +++
+ kernel/time/ntp.c               |    7 ++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    7 ++
+ net/socket.c                    |   41 ++++++++++++++
+ net/unix/af_unix.c              |   15 +++++
+ 40 files changed, 642 insertions(+), 3 deletions(-)
 
 --- linux-2.6.23.15-80.fc7.orig/Makefile
 +++ linux-2.6.23.15-80.fc7/Makefile
@@ -85,13 +85,17 @@
  
  /* Taken over from the old code... */
  
-@@ -144,12 +147,20 @@ int notify_change(struct dentry * dentry
+@@ -144,12 +147,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -100,8 +104,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -139,12 +147,15 @@
  
  #ifdef CONFIG_SPARC
  #include <asm/fbio.h>
-@@ -3603,6 +3606,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -3603,6 +3606,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
@@ -162,34 +173,40 @@
  int core_uses_pid;
  char core_pattern[CORENAME_MAX_SIZE] = "core";
  int suid_dumpable = 0;
-@@ -145,6 +149,11 @@ asmlinkage long sys_uselib(const char __
+@@ -145,6 +149,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -683,6 +692,9 @@ struct file *open_exec(const char *name)
+@@ -683,6 +694,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1390,7 +1402,7 @@ int do_execve(char * filename,
+@@ -1390,7 +1408,7 @@ int do_execve(char * filename,
  		goto out;
  	bprm->argv_len = env_p - bprm->p;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
  	if (retval >= 0) {
  		/* execve success */
  		free_arg_pages(bprm);
@@ -205,12 +222,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -213,6 +216,10 @@ static int setfl(int fd, struct file * f
+@@ -213,6 +216,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (((arg ^ filp->f_flags) & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -228,12 +247,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -23,6 +26,9 @@ static long do_ioctl(struct file *filp, 
+@@ -23,6 +26,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -251,29 +271,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1557,6 +1561,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1557,6 +1561,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1612,6 +1619,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1612,6 +1623,13 @@ int may_open(struct nameidata *nd, int a
  		if (!is_owner_or_cap(inode))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1661,6 +1673,9 @@ static int open_namei_create(struct name
+@@ -1661,6 +1679,9 @@ static int open_namei_create(struct name
  	return may_open(nd, 0, flag & ~O_TRUNC);
  }
  
@@ -283,135 +309,181 @@
  /*
   *	open_namei()
   *
-@@ -1921,6 +1936,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1921,6 +1942,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1939,10 +1960,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1939,10 +1970,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -2010,6 +2037,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -2010,6 +2063,12 @@ asmlinkage long sys_mkdirat(int dfd, con
  
  	if (!IS_POSIXACL(nd.dentry->d_inode))
  		mode &= ~current->fs->umask;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  	dput(dentry);
  out_unlock:
-@@ -2117,6 +2147,9 @@ static long do_rmdir(int dfd, const char
+@@ -2117,6 +2176,12 @@ static long do_rmdir(int dfd, const char
  	error = PTR_ERR(dentry);
  	if (IS_ERR(dentry))
  		goto exit2;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_rmdir(nd.dentry->d_inode, dentry);
  	dput(dentry);
  exit2:
-@@ -2176,6 +2209,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2176,6 +2241,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2197,6 +2233,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2197,6 +2266,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2261,6 +2300,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2261,6 +2338,10 @@ asmlinkage long sys_symlinkat(const char
  	char * to;
  	struct dentry *dentry;
  	struct nameidata nd;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2278,6 +2320,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2278,6 +2359,12 @@ asmlinkage long sys_symlinkat(const char
  	if (IS_ERR(dentry))
  		goto out_unlock;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  	dput(dentry);
  out_unlock:
-@@ -2350,6 +2395,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2350,6 +2437,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2373,6 +2421,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2373,6 +2464,13 @@ asmlinkage long sys_linkat(int olddfd, c
  	error = PTR_ERR(new_dentry);
  	if (IS_ERR(new_dentry))
  		goto out_unlock;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
++	if (!error)
++		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
++					     old_nd.mnt, new_dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  	dput(new_dentry);
  out_unlock:
-@@ -2598,6 +2649,12 @@ static int do_rename(int olddfd, const c
+@@ -2598,6 +2696,16 @@ static int do_rename(int olddfd, const c
  	error = -ENOTEMPTY;
  	if (new_dentry == trap)
  		goto exit5;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
  
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
-@@ -2621,6 +2678,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2621,6 +2729,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -431,90 +503,101 @@
  
  /* spinlock for vfsmount related operations, inplace of dcache_lock */
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(vfsmount_lock);
-@@ -544,6 +550,10 @@ static int do_umount(struct vfsmount *mn
+@@ -544,6 +550,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -632,6 +642,9 @@ asmlinkage long sys_umount(char __user *
+@@ -632,6 +643,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -919,6 +932,10 @@ static int do_loopback(struct nameidata 
+@@ -919,6 +934,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1004,6 +1021,10 @@ static int do_move_mount(struct nameidat
+@@ -1004,6 +1024,11 @@ static int do_move_mount(struct nameidat
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
  
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1105,6 +1126,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1105,6 +1130,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1396,6 +1421,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1396,6 +1426,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1672,6 +1704,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1672,6 +1713,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1688,6 +1723,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1688,6 +1733,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -534,45 +617,50 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -268,6 +274,9 @@ static long do_sys_truncate(const char _
+@@ -268,6 +274,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto put_write_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -322,6 +331,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -322,6 +332,10 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, file);
-@@ -544,6 +556,12 @@ asmlinkage long sys_chroot(const char __
+@@ -544,6 +558,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1155,6 +1173,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1155,6 +1177,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		/* XXX: this needs locking */
@@ -594,7 +682,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.23.15-80.fc7 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.23.15-80.fc7 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -648,12 +736,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -869,6 +872,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -869,6 +872,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -670,12 +759,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -924,6 +927,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -924,6 +927,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -706,22 +796,24 @@
  
  extern int module_sysfs_initialized;
  
-@@ -663,6 +666,9 @@ sys_delete_module(const char __user *nam
+@@ -663,6 +666,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
-@@ -1989,6 +1995,9 @@ sys_init_module(void __user *umod,
+@@ -1989,6 +1996,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Only one module load at a time, please */
@@ -738,12 +830,13 @@
  
  /*
   * Scheduler clock - returns current time in nanosec units.
-@@ -4062,6 +4065,9 @@ int can_nice(const struct task_struct *p
+@@ -4062,6 +4065,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -760,35 +853,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2072,6 +2075,10 @@ asmlinkage long
+@@ -2072,6 +2075,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2130,6 +2137,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2130,6 +2139,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2143,6 +2154,10 @@ sys_tkill(int pid, int sig)
+@@ -2143,6 +2158,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -805,42 +904,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -672,6 +675,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -672,6 +675,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > PRIO_USER || which < PRIO_PROCESS)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -908,6 +914,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -908,6 +917,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1883,6 +1892,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1883,6 +1896,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1928,6 +1940,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1928,6 +1945,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -857,25 +962,29 @@
  
  #ifdef CONFIG_X86
  #include <asm/nmi.h>
-@@ -1344,6 +1347,81 @@ struct ctl_table_header *sysctl_head_nex
+@@ -1344,6 +1347,93 @@ struct ctl_table_header *sysctl_head_nex
  }
  
  #ifdef CONFIG_SYSCTL_SYSCALL
 +
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -893,30 +1002,38 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", n);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", n);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				name++;
@@ -939,12 +1056,14 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1360,6 +1438,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1360,6 +1450,11 @@ int do_sysctl(int __user *name, int nlen
  
  	for (head = sysctl_head_next(NULL); head;
  			head = sysctl_head_next(head)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table);
@@ -961,22 +1080,24 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -90,6 +93,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -90,6 +93,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -159,6 +165,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -159,6 +166,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
@@ -993,12 +1114,13 @@
  
  /*
   * Timekeeping variables
-@@ -246,6 +249,9 @@ int do_adjtimex(struct timex *txc)
+@@ -246,6 +249,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Now we validate the data before disabling interrupts */
@@ -1017,12 +1139,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1040,12 +1164,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -85,6 +88,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -85,6 +88,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1062,12 +1187,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -292,6 +295,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -292,6 +295,10 @@ int inet_hash_connect(struct inet_timewa
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
@@ -1084,22 +1210,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -163,6 +166,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -163,6 +166,10 @@ int __udp_lib_get_port(struct sock *sk, 
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -182,6 +188,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -182,6 +189,10 @@ int __udp_lib_get_port(struct sock *sk, 
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (! __udp_lib_lport_inuse(result, udptable))
  				break;
@@ -1116,12 +1244,13 @@
  
  void __inet6_hash(struct inet_hashinfo *hashinfo,
  				struct sock *sk)
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
@@ -1140,53 +1269,64 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
  			 unsigned long nr_segs, loff_t pos);
-@@ -552,6 +557,9 @@ static inline int __sock_sendmsg(struct 
+@@ -552,6 +557,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
-@@ -1101,6 +1109,10 @@ static int __sock_create(int family, int
+@@ -1101,6 +1112,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1332,6 +1344,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1332,6 +1349,13 @@ asmlinkage long sys_bind(int fd, struct 
  			err = security_socket_bind(sock,
  						   (struct sockaddr *)address,
  						   addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  						      (struct sockaddr *)
-@@ -1361,6 +1376,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1361,6 +1385,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1425,6 +1443,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1425,6 +1453,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1194,13 +1334,15 @@
  	if (upeer_sockaddr) {
  		if (newsock->ops->getname(newsock, (struct sockaddr *)address,
  					  &len, 2) < 0) {
-@@ -1489,6 +1513,10 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1489,6 +1524,12 @@ asmlinkage long sys_connect(int fd, stru
  	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 +	/***** TOMOYO Linux start. *****/
-+	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen);
-+	if (err) goto out_put;
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  
  	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
@@ -1217,23 +1359,28 @@
  
  int sysctl_unix_max_dgram_qlen __read_mostly = 10;
  
-@@ -791,6 +794,10 @@ static int unix_bind(struct socket *sock
+@@ -791,6 +794,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -834,6 +841,9 @@ static int unix_bind(struct socket *sock
+@@ -834,6 +842,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1250,13 +1397,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1274,13 +1422,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -732,6 +735,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -732,6 +735,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1325,25 +1474,27 @@
  
  #ifdef CONFIG_DEBUG_PREEMPT
  #define NO_LOCKS	WARN_ON(preempt_count() != 0)
-@@ -999,6 +1002,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -999,6 +1002,12 @@ asmlinkage long sys_ptrace(long request,
  	struct utrace_attached_engine *engine = NULL;
  	struct ptrace_state *state = NULL;
  	long ret, val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	pr_debug("%d sys_ptrace(%ld, %ld, %lx, %lx)\n",
  		 current->pid, request, pid, addr, data);
-@@ -1086,6 +1094,11 @@ asmlinkage long compat_sys_ptrace(compat
+@@ -1086,6 +1095,12 @@ asmlinkage long compat_sys_ptrace(compat
  	struct utrace_attached_engine *engine;
  	struct ptrace_state *state;
  	compat_long_t ret, val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1361,13 +1512,14 @@
  
  #include "ia32priv.h"
  
-@@ -1742,6 +1745,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1742,6 +1745,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1385,13 +1537,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1409,13 +1562,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -260,6 +263,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -260,6 +263,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.12-2.3.legacy_FC3.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.12-2.3.legacy_FC3.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.12-2.3.legacy_FC3.diff	(作業コピー)
@@ -3,63 +3,63 @@
 Source code for this patch is http://ftp.riken.jp/Linux/fedoralegacy/fedora/3/updates/SRPMS/kernel-2.6.12-2.3.legacy_FC3.src.rpm
 ---
  Makefile                           |    2 
- arch/alpha/kernel/ptrace.c         |    8 +++
- arch/arm/kernel/ptrace.c           |    8 +++
- arch/arm26/kernel/ptrace.c         |    8 +++
- arch/cris/arch-v10/kernel/ptrace.c |    8 +++
- arch/frv/kernel/ptrace.c           |    8 +++
- arch/h8300/kernel/ptrace.c         |    8 +++
- arch/i386/kernel/ptrace.c          |    8 +++
- arch/ia64/ia32/sys_ia32.c          |    8 +++
- arch/ia64/kernel/ptrace.c          |    8 +++
- arch/m32r/kernel/ptrace.c          |    8 +++
- arch/m68k/kernel/ptrace.c          |    8 +++
- arch/m68knommu/kernel/ptrace.c     |    8 +++
- arch/mips/kernel/ptrace.c          |    8 +++
- arch/mips/kernel/ptrace32.c        |    8 +++
- arch/parisc/kernel/ptrace.c        |    8 +++
- arch/ppc/kernel/ptrace.c           |    8 +++
- arch/ppc64/kernel/ptrace.c         |    8 +++
- arch/ppc64/kernel/ptrace32.c       |    8 +++
- arch/s390/kernel/ptrace.c          |    8 +++
- arch/sh/kernel/ptrace.c            |    8 +++
- arch/sh64/kernel/ptrace.c          |    8 +++
- arch/sparc/kernel/ptrace.c         |   11 ++++
- arch/sparc64/kernel/ptrace.c       |   11 ++++
- arch/um/kernel/ptrace.c            |    8 +++
- arch/v850/kernel/ptrace.c          |    8 +++
- arch/x86_64/ia32/ptrace32.c        |    8 +++
- arch/x86_64/kernel/ptrace.c        |    8 +++
+ arch/alpha/kernel/ptrace.c         |    9 ++
+ arch/arm/kernel/ptrace.c           |    9 ++
+ arch/arm26/kernel/ptrace.c         |    9 ++
+ arch/cris/arch-v10/kernel/ptrace.c |    9 ++
+ arch/frv/kernel/ptrace.c           |    9 ++
+ arch/h8300/kernel/ptrace.c         |    9 ++
+ arch/i386/kernel/ptrace.c          |    9 ++
+ arch/ia64/ia32/sys_ia32.c          |    9 ++
+ arch/ia64/kernel/ptrace.c          |    9 ++
+ arch/m32r/kernel/ptrace.c          |    9 ++
+ arch/m68k/kernel/ptrace.c          |    9 ++
+ arch/m68knommu/kernel/ptrace.c     |    9 ++
+ arch/mips/kernel/ptrace.c          |    9 ++
+ arch/mips/kernel/ptrace32.c        |    9 ++
+ arch/parisc/kernel/ptrace.c        |    9 ++
+ arch/ppc/kernel/ptrace.c           |    9 ++
+ arch/ppc64/kernel/ptrace.c         |    9 ++
+ arch/ppc64/kernel/ptrace32.c       |    9 ++
+ arch/s390/kernel/ptrace.c          |    9 ++
+ arch/sh/kernel/ptrace.c            |    9 ++
+ arch/sh64/kernel/ptrace.c          |    9 ++
+ arch/sparc/kernel/ptrace.c         |   11 +++
+ arch/sparc64/kernel/ptrace.c       |   11 +++
+ arch/um/kernel/ptrace.c            |    9 ++
+ arch/v850/kernel/ptrace.c          |    9 ++
+ arch/x86_64/ia32/ptrace32.c        |    9 ++
+ arch/x86_64/kernel/ptrace.c        |    9 ++
  fs/Kconfig                         |    2 
  fs/Makefile                        |    2 
- fs/attr.c                          |   11 ++++
- fs/compat.c                        |    8 ++-
- fs/exec.c                          |   15 +++++
- fs/fcntl.c                         |    7 ++
- fs/ioctl.c                         |    6 ++
- fs/namei.c                         |   61 +++++++++++++++++++++++
- fs/namespace.c                     |   43 +++++++++++++++-
- fs/open.c                          |   22 ++++++++
- fs/proc/Makefile                   |    3 +
+ fs/attr.c                          |   19 +++++
+ fs/compat.c                        |   11 +++
+ fs/exec.c                          |   21 ++++++
+ fs/fcntl.c                         |    8 ++
+ fs/ioctl.c                         |    7 ++
+ fs/namei.c                         |  118 +++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                     |   54 ++++++++++++++++
+ fs/open.c                          |   28 ++++++++
+ fs/proc/Makefile                   |    3 
  fs/proc/proc_misc.c                |    5 +
  include/linux/init_task.h          |    4 +
- include/linux/sched.h              |    9 +++
- kernel/compat.c                    |    6 ++
+ include/linux/sched.h              |    9 ++
+ kernel/compat.c                    |    7 ++
  kernel/kmod.c                      |    5 +
- kernel/module.c                    |   11 +++-
- kernel/sched.c                     |    6 ++
- kernel/signal.c                    |   16 ++++++
- kernel/sys.c                       |   15 +++++
- kernel/sysctl.c                    |   95 ++++++++++++++++++++++++++++++++++++-
- kernel/time.c                      |   12 ++++
- net/core/datagram.c                |    8 +++
- net/ipv4/tcp_ipv4.c                |    9 +++
- net/ipv4/udp.c                     |    9 +++
- net/ipv6/tcp_ipv6.c                |    9 +++
- net/ipv6/udp.c                     |    9 +++
- net/socket.c                       |   30 ++++++++++-
- net/unix/af_unix.c                 |   10 +++
- 57 files changed, 661 insertions(+), 11 deletions(-)
+ kernel/module.c                    |   13 +++-
+ kernel/sched.c                     |    7 ++
+ kernel/signal.c                    |   22 ++++++
+ kernel/sys.c                       |   21 ++++++
+ kernel/sysctl.c                    |  113 +++++++++++++++++++++++++++++++++++
+ kernel/time.c                      |   15 ++++
+ net/core/datagram.c                |   10 +++
+ net/ipv4/tcp_ipv4.c                |   11 +++
+ net/ipv4/udp.c                     |   11 +++
+ net/ipv6/tcp_ipv6.c                |   11 +++
+ net/ipv6/udp.c                     |   11 +++
+ net/socket.c                       |   43 ++++++++++++-
+ net/unix/af_unix.c                 |   15 ++++
+ 57 files changed, 844 insertions(+), 11 deletions(-)
 
 --- linux-2.6.12-2.3.legacy_FC3.orig/Makefile
 +++ linux-2.6.12-2.3.legacy_FC3/Makefile
@@ -84,13 +84,14 @@
  
  #include "proto.h"
  
-@@ -261,6 +264,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -261,6 +264,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -108,13 +109,14 @@
  
  #include "ptrace.h"
  
-@@ -786,6 +789,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -786,6 +789,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -132,13 +134,14 @@
  
  #include "ptrace.h"
  
-@@ -669,6 +672,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -669,6 +672,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -156,13 +159,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -112,6 +115,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -112,6 +115,12 @@ asmlinkage int sys_ptrace(long request, 
  	unsigned long tmp;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -180,13 +184,14 @@
  
  /* cpu depend functions */
  extern long h8300_get_reg(struct task_struct *task, int regno);
-@@ -61,6 +64,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -61,6 +64,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -204,13 +209,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -358,6 +361,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -358,6 +361,12 @@ asmlinkage int sys_ptrace(long request, 
  	struct user * dummy = NULL;
  	int i, ret;
  	unsigned long __user *datap = (unsigned long __user *)data;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -228,13 +234,14 @@
  
  #include "entry.h"
  
-@@ -1404,6 +1407,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1404,6 +1407,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -252,13 +259,14 @@
  
  /*
   * Get the address of the live pt_regs for the specified task.
-@@ -760,6 +763,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -760,6 +763,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -276,13 +284,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -121,6 +124,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -121,6 +124,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -300,13 +309,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -105,6 +108,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -105,6 +108,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -324,13 +334,14 @@
  
  /*
   * Called by kernel/ptrace.c when detaching..
-@@ -51,6 +54,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -51,6 +54,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -348,13 +359,14 @@
  
  /* PSW bits we allow the debugger to modify */
  #define USER_PSW_BITS	(PSW_N | PSW_V | PSW_CB)
-@@ -85,6 +88,11 @@ long sys_ptrace(long request, pid_t pid,
+@@ -85,6 +88,12 @@ long sys_ptrace(long request, pid_t pid,
  #ifdef DEBUG_PTRACE
  	long oaddr=addr, odata=data;
  #endif
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -372,13 +384,14 @@
  
  /*
   * Set of msr bits that gdb can change on behalf of a process.
-@@ -244,6 +247,11 @@ int sys_ptrace(long request, long pid, l
+@@ -244,6 +247,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -396,13 +409,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -56,6 +59,11 @@ int sys_ptrace(long request, long pid, l
+@@ -56,6 +59,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -420,13 +434,14 @@
  
  #ifdef CONFIG_S390_SUPPORT
  #include "compat_ptrace.h"
-@@ -710,6 +713,11 @@ sys_ptrace(long request, long pid, long 
+@@ -710,6 +713,12 @@ sys_ptrace(long request, long pid, long 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -444,13 +459,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -85,6 +88,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -85,6 +88,12 @@ asmlinkage int sys_ptrace(long request, 
  	struct task_struct *child;
  	struct user * dummy = NULL;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -468,13 +484,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -128,6 +131,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -128,6 +131,12 @@ asmlinkage int sys_ptrace(long request, 
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -546,13 +563,14 @@
  
  static inline void set_singlestepping(struct task_struct *child, int on)
  {
-@@ -47,6 +50,11 @@ long sys_ptrace(long request, long pid, 
+@@ -47,6 +50,12 @@ long sys_ptrace(long request, long pid, 
  {
  	struct task_struct *child;
  	int i, ret;
 +/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +/***** TOMOYO Linux end. *****/
  
@@ -570,13 +588,14 @@
  
  /* Returns the address where the register at REG_OFFS in P is stashed away.  */
  static v850_reg_t *reg_save_addr (unsigned reg_offs, struct task_struct *t)
-@@ -117,6 +120,11 @@ int sys_ptrace(long request, long pid, l
+@@ -117,6 +120,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int rval;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -594,13 +613,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -318,6 +321,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -318,6 +321,12 @@ asmlinkage long sys_ptrace(long request,
  	struct task_struct *child;
  	long i, ret;
  	unsigned ui;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -636,13 +656,17 @@
  
  /* Taken over from the old code... */
  
-@@ -179,12 +182,20 @@ int notify_change(struct dentry * dentry
+@@ -179,12 +182,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -651,8 +675,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -669,17 +697,20 @@
  
  /*
   * Not all architectures have sys_utime, so implement this in terms
-@@ -466,6 +469,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -466,6 +469,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1557,7 +1563,7 @@ int compat_do_execve(char * filename,
+@@ -1557,7 +1566,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -701,34 +732,40 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  /* The maximal length of core_pattern is also specified in sysctl.c */
-@@ -136,6 +140,11 @@ asmlinkage long sys_uselib(const char __
+@@ -136,6 +140,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -504,6 +513,9 @@ struct file *open_exec(const char *name)
+@@ -504,6 +515,13 @@ struct file *open_exec(const char *name)
  			int err = permission(inode, MAY_EXEC, &nd);
  			if (!err && !(inode->i_mode & 0111))
  				err = -EACCES;
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
-@@ -1189,7 +1201,8 @@ int do_execve(char * filename,
+@@ -1189,7 +1207,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
@@ -745,12 +782,13 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -195,6 +198,10 @@ static int setfl(int fd, struct file * f
+@@ -195,6 +198,11 @@ static int setfl(int fd, struct file * f
  	if (!(arg & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -768,12 +806,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -23,6 +26,9 @@ static long do_ioctl(struct file *filp, 
+@@ -23,6 +26,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -791,29 +830,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1317,6 +1321,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1317,6 +1321,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error) {
-@@ -1374,6 +1381,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1374,6 +1385,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1405,6 +1417,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1405,6 +1423,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -823,136 +868,187 @@
  /*
   *	open_namei()
   *
-@@ -1644,6 +1659,12 @@ asmlinkage long sys_mknod(const char __u
+@@ -1644,6 +1665,16 @@ asmlinkage long sys_mknod(const char __u
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1662,10 +1683,16 @@ asmlinkage long sys_mknod(const char __u
+@@ -1662,10 +1693,32 @@ asmlinkage long sys_mknod(const char __u
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1727,6 +1754,9 @@ asmlinkage long sys_mkdir(const char __u
+@@ -1727,6 +1780,13 @@ asmlinkage long sys_mkdir(const char __u
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -1831,6 +1861,9 @@ asmlinkage long sys_rmdir(const char __u
+@@ -1831,6 +1891,13 @@ asmlinkage long sys_rmdir(const char __u
  	dentry = lookup_hash(&nd.last, nd.dentry);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -1885,6 +1918,9 @@ asmlinkage long sys_unlink(const char __
+@@ -1885,6 +1952,10 @@ asmlinkage long sys_unlink(const char __
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -1906,6 +1942,9 @@ asmlinkage long sys_unlink(const char __
+@@ -1906,6 +1977,14 @@ asmlinkage long sys_unlink(const char __
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -1953,6 +1992,9 @@ asmlinkage long sys_symlink(const char _
+@@ -1953,6 +2032,10 @@ asmlinkage long sys_symlink(const char _
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -1969,6 +2011,9 @@ asmlinkage long sys_symlink(const char _
+@@ -1969,6 +2052,13 @@ asmlinkage long sys_symlink(const char _
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2036,6 +2081,9 @@ asmlinkage long sys_link(const char __us
+@@ -2036,6 +2126,10 @@ asmlinkage long sys_link(const char __us
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	to = getname(newname);
  	if (IS_ERR(to))
-@@ -2053,6 +2101,9 @@ asmlinkage long sys_link(const char __us
+@@ -2053,6 +2147,15 @@ asmlinkage long sys_link(const char __us
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2275,6 +2326,13 @@ static inline int do_rename(const char *
+@@ -2275,6 +2378,17 @@ static inline int do_rename(const char *
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2296,6 +2354,9 @@ asmlinkage long sys_rename(const char __
+@@ -2296,6 +2410,10 @@ asmlinkage long sys_rename(const char __
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -972,39 +1068,42 @@
  
  extern int __init init_rootfs(void);
  
-@@ -373,6 +379,10 @@ static int do_umount(struct vfsmount *mn
+@@ -373,6 +379,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -469,6 +479,9 @@ asmlinkage long sys_umount(char __user *
+@@ -469,6 +480,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -634,6 +647,10 @@ static int do_loopback(struct nameidata 
+@@ -634,6 +649,11 @@ static int do_loopback(struct nameidata 
  	down_write(&current->namespace->sem);
  	err = -EINVAL;
  	if (check_mnt(nd->mnt) && (!recurse || check_mnt(old_nd.mnt))) {
 +		/***** SAKURA Linux start. *****/
 +		err = -EPERM;
-+		if (ccs_may_mount(nd) < 0) goto out;
++		if (ccs_may_mount(nd))
++			goto out;
 +		/***** SAKURA Linux end. *****/
  		err = -ENOMEM;
  		if (recurse)
  			mnt = copy_tree(old_nd.mnt, old_nd.dentry);
-@@ -655,7 +672,9 @@ static int do_loopback(struct nameidata 
+@@ -655,7 +675,9 @@ static int do_loopback(struct nameidata 
  		} else
  			mntput(mnt);
  	}
@@ -1015,59 +1114,67 @@
  	up_write(&current->namespace->sem);
  	path_release(&old_nd);
  	return err;
-@@ -711,7 +730,10 @@ static int do_move_mount(struct nameidat
+@@ -711,7 +733,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	down(&nd->dentry->d_inode->i_sem);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -805,6 +827,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -805,6 +831,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	err = graft_tree(newmnt, nd);
-@@ -1026,6 +1052,13 @@ long do_mount(char * dev_name, char * di
+@@ -1026,6 +1057,17 @@ long do_mount(char * dev_name, char * di
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1286,6 +1319,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1286,6 +1328,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1301,6 +1337,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1301,6 +1347,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -1088,45 +1195,51 @@
  int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
  {
  	int retval = -ENODEV;
-@@ -257,6 +264,9 @@ static inline long do_sys_truncate(const
+@@ -257,6 +264,10 @@ static inline long do_sys_truncate(const
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -310,6 +320,9 @@ static inline long do_sys_ftruncate(unsi
+@@ -310,6 +321,11 @@ static inline long do_sys_ftruncate(unsi
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length);
-@@ -584,6 +597,12 @@ asmlinkage long sys_chroot(const char __
+@@ -584,6 +600,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1044,6 +1063,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1044,6 +1068,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
@@ -1148,7 +1261,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.12-2.3.legacy_FC3 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.12-2.3.legacy_FC3 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -1202,12 +1315,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -852,6 +855,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -852,6 +855,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -1238,24 +1352,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -538,7 +541,9 @@ sys_delete_module(const char __user *nam
+@@ -538,7 +541,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1777,7 +1782,9 @@ sys_init_module(void __user *umod,
+@@ -1777,7 +1783,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (down_interruptible(&module_mutex) != 0)
@@ -1272,12 +1388,13 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -3252,6 +3255,9 @@ asmlinkage long sys_nice(int increment)
+@@ -3252,6 +3255,10 @@ asmlinkage long sys_nice(int increment)
  {
  	int retval;
  	long nice;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -1294,36 +1411,42 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2288,6 +2291,10 @@ asmlinkage long
+@@ -2288,6 +2291,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2318,6 +2325,11 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2318,6 +2327,13 @@ asmlinkage long sys_tgkill(int tgid, int
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	info.si_signo = sig;
  	info.si_errno = 0;
  	info.si_code = SI_TKILL;
-@@ -2358,6 +2370,10 @@ sys_tkill(int pid, int sig)
+@@ -2358,6 +2374,12 @@ sys_tkill(int pid, int sig)
  	if (pid <= 0)
  		return -EINVAL;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	info.si_signo = sig;
  	info.si_errno = 0;
@@ -1340,42 +1463,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -252,6 +255,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -252,6 +255,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -383,6 +389,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -383,6 +392,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	switch (cmd) {
-@@ -1385,6 +1394,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1385,6 +1398,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1430,6 +1442,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1430,6 +1447,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -1392,24 +1521,28 @@
  
  #ifdef CONFIG_ROOT_NFS
  #include <linux/nfs_fs.h>
-@@ -1052,6 +1055,87 @@ void __init sysctl_init(void)
+@@ -1052,6 +1055,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -1427,35 +1560,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -1480,30 +1622,35 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1077,6 +1161,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1077,6 +1174,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1150,6 +1237,12 @@ repeat:
+@@ -1150,6 +1252,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
  						oldval, oldlenp,
-@@ -2234,7 +2327,7 @@ int sysctl_string(ctl_table *table, int 
+@@ -2234,7 +2345,7 @@ int sysctl_string(ctl_table *table, int 
  			len--;
  		((char *) table->data)[len] = 0;
  	}
@@ -1524,32 +1671,35 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -90,6 +93,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -90,6 +93,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -157,6 +163,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -157,6 +164,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -235,6 +244,9 @@ int do_adjtimex(struct timex *txc)
+@@ -235,6 +246,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
@@ -1567,12 +1717,14 @@
  
  /*
   *	Is a socket 'connection oriented' ?
-@@ -177,6 +181,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -177,6 +181,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1590,22 +1742,24 @@
  
  extern int sysctl_ip_dynaddr;
  int sysctl_tcp_tw_reuse;
-@@ -232,6 +235,9 @@ static int tcp_v4_get_port(struct sock *
+@@ -232,6 +235,10 @@ static int tcp_v4_get_port(struct sock *
  				rover = low;
  			head = &tcp_bhash[tcp_bhashfn(rover)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			tb_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
-@@ -672,6 +678,9 @@ static inline int tcp_v4_hash_connect(st
+@@ -672,6 +679,10 @@ static inline int tcp_v4_hash_connect(st
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &tcp_bhash[tcp_bhashfn(port)];
   			spin_lock(&head->lock);
@@ -1622,22 +1776,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -145,6 +148,9 @@ static int udp_v4_get_port(struct sock *
+@@ -145,6 +148,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -161,6 +167,9 @@ static int udp_v4_get_port(struct sock *
+@@ -161,6 +168,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1654,22 +1810,24 @@
  
  static void	tcp_v6_send_reset(struct sk_buff *skb);
  static void	tcp_v6_or_send_ack(struct sk_buff *skb, struct open_request *req);
-@@ -148,6 +151,9 @@ static int tcp_v6_get_port(struct sock *
+@@ -148,6 +151,10 @@ static int tcp_v6_get_port(struct sock *
  				rover = low;
  			head = &tcp_bhash[tcp_bhashfn(rover)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			tb_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
-@@ -551,6 +557,9 @@ static int tcp_v6_hash_connect(struct so
+@@ -551,6 +558,10 @@ static int tcp_v6_hash_connect(struct so
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &tcp_bhash[tcp_bhashfn(port)];
   			spin_lock(&head->lock);
@@ -1686,22 +1844,24 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6);
  
-@@ -87,6 +90,9 @@ static int udp_v6_get_port(struct sock *
+@@ -87,6 +90,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -103,6 +109,9 @@ static int udp_v6_get_port(struct sock *
+@@ -103,6 +110,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1720,55 +1880,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -555,7 +560,9 @@ static inline int __sock_sendmsg(struct 
+@@ -555,7 +560,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1110,6 +1117,10 @@ static int __sock_create(int family, int
+@@ -1110,6 +1120,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1304,6 +1315,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1304,6 +1320,12 @@ asmlinkage long sys_bind(int fd, struct 
  				sockfd_put(sock);
  				return err;
  			}
 +			/***** TOMOYO Linux start. *****/
-+			if ((err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++			err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++							 address, addrlen);
++			if (!err)
 +			/***** TOMOYO Linux end. *****/
  			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
  		}
  		sockfd_put(sock);
-@@ -1334,7 +1348,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1334,7 +1356,10 @@ asmlinkage long sys_listen(int fd, int b
  			sockfd_put(sock);
  			return err;
  		}
 -
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = ccs_socket_listen_permission(sock)) == 0)
++		err = ccs_socket_listen_permission(sock);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err=sock->ops->listen(sock, backlog);
  		sockfd_put(sock);
  	}
-@@ -1385,6 +1401,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1385,6 +1410,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_release;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_release;
 +	}
@@ -1776,13 +1946,16 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1440,7 +1462,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1440,7 +1472,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
@@ -1799,23 +1972,28 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -738,6 +741,10 @@ static int unix_bind(struct socket *sock
+@@ -738,6 +741,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -781,6 +788,9 @@ static int unix_bind(struct socket *sock
+@@ -781,6 +789,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1832,13 +2010,14 @@
  
  /* 
   * Determines which bits in DCCR the user has access to.
-@@ -81,6 +84,11 @@ sys_ptrace(long request, long pid, long 
+@@ -81,6 +84,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  	unsigned long __user *datap = (unsigned long __user *)data;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1856,13 +2035,14 @@
  
  #include "ia32priv.h"
  
-@@ -1757,6 +1760,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1757,6 +1760,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1880,13 +2060,14 @@
  
  /*
   * Tracing a 32-bit process with a 64-bit strace and vice versa will not
-@@ -43,6 +46,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -43,6 +46,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1904,13 +2085,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -43,6 +46,11 @@ int sys32_ptrace(long request, long pid,
+@@ -43,6 +46,12 @@ int sys32_ptrace(long request, long pid,
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1928,13 +2110,14 @@
  
  /* determines which flags the user has access to. */
  /* 1 = access 0 = no access */
-@@ -233,6 +236,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -233,6 +236,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.20.3-ubuntu1.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.20.3-ubuntu1.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.20.3-ubuntu1.diff	(作業コピー)
@@ -3,53 +3,53 @@
 Source code for this patch is "apt-get install linux-source-2.6.20"
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 ++++
- arch/sparc64/kernel/ptrace.c    |   11 ++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 ++++
- fs/compat.c                     |    8 ++-
- fs/exec.c                       |   15 +++++-
- fs/fcntl.c                      |    7 ++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   60 +++++++++++++++++++++++++
- fs/namespace.c                  |   39 ++++++++++++++++
- fs/open.c                       |   21 ++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |   11 +++
+ fs/exec.c                       |   21 +++++++
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  112 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   50 +++++++++++++++++
+ fs/open.c                       |   26 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
  include/linux/sched.h           |    9 +++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |   11 +++-
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 ++++++
- kernel/sys.c                    |   15 ++++++
- kernel/sysctl.c                 |   94 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |    9 +++
- kernel/time/ntp.c               |    6 ++
- net/core/datagram.c             |    9 +++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 +++
- net/ipv6/inet6_hashtables.c     |    6 ++
- net/socket.c                    |   29 +++++++++++-
- net/unix/af_unix.c              |   10 ++++
- 44 files changed, 537 insertions(+), 7 deletions(-)
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   13 +++-
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |  112 ++++++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   11 +++
+ kernel/time/ntp.c               |    7 ++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    7 ++
+ net/socket.c                    |   42 ++++++++++++++-
+ net/unix/af_unix.c              |   15 +++++
+ 44 files changed, 698 insertions(+), 7 deletions(-)
 
---- linux-source-2.6.20-2.6.20.orig/Makefile
-+++ linux-source-2.6.20-2.6.20/Makefile
+--- linux-source-2.6.20.3-ubuntu1.orig/Makefile
++++ linux-source-2.6.20.3-ubuntu1/Makefile
 @@ -1,7 +1,7 @@
  VERSION = 2
  PATCHLEVEL = 6
@@ -59,8 +59,8 @@
  NAME = Homicidal Dwarf Hamster
  
  ifdef UBUNTUBUILD
---- linux-source-2.6.20-2.6.20.orig/fs/Kconfig
-+++ linux-source-2.6.20-2.6.20/fs/Kconfig
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/Kconfig
++++ linux-source-2.6.20.3-ubuntu1/fs/Kconfig
 @@ -2095,5 +2095,7 @@ endif
  source "fs/nls/Kconfig"
  source "fs/dlm/Kconfig"
@@ -69,16 +69,16 @@
 +
  endmenu
  
---- linux-source-2.6.20-2.6.20.orig/fs/Makefile
-+++ linux-source-2.6.20-2.6.20/fs/Makefile
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/Makefile
++++ linux-source-2.6.20.3-ubuntu1/fs/Makefile
 @@ -115,3 +115,5 @@ obj-$(CONFIG_HPPFS)		+= hppfs/
  obj-$(CONFIG_DEBUG_FS)		+= debugfs/
  obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
  obj-$(CONFIG_GFS2_FS)           += gfs2/
 +
 +include $(srctree)/fs/Makefile-2.6.ccs
---- linux-source-2.6.20-2.6.20.orig/fs/attr.c
-+++ linux-source-2.6.20-2.6.20/fs/attr.c
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/attr.c
++++ linux-source-2.6.20.3-ubuntu1/fs/attr.c
 @@ -15,6 +15,9 @@
  #include <linux/fcntl.h>
  #include <linux/quotaops.h>
@@ -89,13 +89,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry * dentry
+@@ -145,12 +148,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -104,14 +108,18 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
  			    (ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid))
---- linux-source-2.6.20-2.6.20.orig/fs/compat.c
-+++ linux-source-2.6.20-2.6.20/fs/compat.c
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/compat.c
++++ linux-source-2.6.20.3-ubuntu1/fs/compat.c
 @@ -55,6 +55,9 @@
  #include <asm/mmu_context.h>
  #include <asm/ioctls.h>
@@ -122,17 +130,20 @@
  
  int compat_log = 1;
  
-@@ -421,6 +424,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -421,6 +424,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1551,7 +1557,7 @@ int compat_do_execve(char * filename,
+@@ -1551,7 +1560,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -141,8 +152,8 @@
  	if (retval >= 0) {
  		free_arg_pages(bprm);
  
---- linux-source-2.6.20-2.6.20.orig/fs/exec.c
-+++ linux-source-2.6.20-2.6.20/fs/exec.c
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/exec.c
++++ linux-source-2.6.20.3-ubuntu1/fs/exec.c
 @@ -58,6 +58,10 @@
  #include <linux/kmod.h>
  #endif
@@ -154,40 +165,46 @@
  int core_uses_pid;
  char core_pattern[128] = "core";
  int suid_dumpable = 0;
-@@ -140,6 +144,11 @@ asmlinkage long sys_uselib(const char __
+@@ -140,6 +144,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -487,6 +496,9 @@ struct file *open_exec(const char *name)
+@@ -487,6 +498,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1190,7 +1202,8 @@ int do_execve(char * filename,
+@@ -1190,7 +1208,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
  
---- linux-source-2.6.20-2.6.20.orig/fs/fcntl.c
-+++ linux-source-2.6.20-2.6.20/fs/fcntl.c
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/fcntl.c
++++ linux-source-2.6.20.3-ubuntu1/fs/fcntl.c
 @@ -22,6 +22,9 @@
  #include <asm/poll.h>
  #include <asm/siginfo.h>
@@ -198,19 +215,21 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -213,6 +216,10 @@ static int setfl(int fd, struct file * f
+@@ -213,6 +216,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
  	if ((arg & O_NOATIME) && !(filp->f_flags & O_NOATIME))
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
---- linux-source-2.6.20-2.6.20.orig/fs/ioctl.c
-+++ linux-source-2.6.20-2.6.20/fs/ioctl.c
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/ioctl.c
++++ linux-source-2.6.20.3-ubuntu1/fs/ioctl.c
 @@ -15,6 +15,9 @@
  
  #include <asm/uaccess.h>
@@ -221,18 +240,19 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -23,6 +26,9 @@ static long do_ioctl(struct file *filp, 
+@@ -23,6 +26,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
  		error = filp->f_op->unlocked_ioctl(filp, cmd, arg);
---- linux-source-2.6.20-2.6.20.orig/fs/namei.c
-+++ linux-source-2.6.20-2.6.20/fs/namei.c
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/namei.c
++++ linux-source-2.6.20.3-ubuntu1/fs/namei.c
 @@ -37,6 +37,10 @@
  
  #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
@@ -244,29 +264,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1506,6 +1510,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1506,6 +1510,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1561,6 +1568,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1561,6 +1572,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1610,6 +1622,9 @@ static int open_namei_create(struct name
+@@ -1610,6 +1628,9 @@ static int open_namei_create(struct name
  	return may_open(nd, 0, flag & ~O_TRUNC);
  }
  
@@ -276,141 +302,187 @@
  /*
   *	open_namei()
   *
-@@ -1870,6 +1885,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1870,6 +1891,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1888,10 +1909,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1888,10 +1919,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1959,6 +1986,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1959,6 +2012,12 @@ asmlinkage long sys_mkdirat(int dfd, con
  
  	if (!IS_POSIXACL(nd.dentry->d_inode))
  		mode &= ~current->fs->umask;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  	dput(dentry);
  out_unlock:
-@@ -2066,6 +2096,9 @@ static long do_rmdir(int dfd, const char
+@@ -2066,6 +2125,12 @@ static long do_rmdir(int dfd, const char
  	error = PTR_ERR(dentry);
  	if (IS_ERR(dentry))
  		goto exit2;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_rmdir(nd.dentry->d_inode, dentry);
  	dput(dentry);
  exit2:
-@@ -2125,6 +2158,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2125,6 +2190,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2146,6 +2182,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2146,6 +2215,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2210,6 +2249,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2210,6 +2287,10 @@ asmlinkage long sys_symlinkat(const char
  	char * to;
  	struct dentry *dentry;
  	struct nameidata nd;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2227,6 +2269,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2227,6 +2308,12 @@ asmlinkage long sys_symlinkat(const char
  	if (IS_ERR(dentry))
  		goto out_unlock;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  	dput(dentry);
  out_unlock:
-@@ -2299,6 +2344,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2299,6 +2386,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2322,6 +2370,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2322,6 +2413,13 @@ asmlinkage long sys_linkat(int olddfd, c
  	error = PTR_ERR(new_dentry);
  	if (IS_ERR(new_dentry))
  		goto out_unlock;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
++	if (!error)
++		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
++					     old_nd.mnt, new_dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  	dput(new_dentry);
  out_unlock:
-@@ -2547,6 +2598,12 @@ static int do_rename(int olddfd, const c
+@@ -2547,6 +2645,16 @@ static int do_rename(int olddfd, const c
  	error = -ENOTEMPTY;
  	if (new_dentry == trap)
  		goto exit5;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
  
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
-@@ -2570,6 +2627,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2570,6 +2678,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
---- linux-source-2.6.20-2.6.20.orig/fs/namespace.c
-+++ linux-source-2.6.20-2.6.20/fs/namespace.c
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/namespace.c
++++ linux-source-2.6.20.3-ubuntu1/fs/namespace.c
 @@ -28,6 +28,12 @@
  #include <asm/uaccess.h>
  #include <asm/unistd.h>
@@ -424,97 +496,108 @@
  
  /* spinlock for vfsmount related operations, inplace of dcache_lock */
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(vfsmount_lock);
-@@ -547,6 +553,10 @@ static int do_umount(struct vfsmount *mn
+@@ -547,6 +553,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -635,6 +645,9 @@ asmlinkage long sys_umount(char __user *
+@@ -635,6 +646,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -919,6 +932,10 @@ static int do_loopback(struct nameidata 
+@@ -919,6 +934,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1003,7 +1020,10 @@ static int do_move_mount(struct nameidat
+@@ -1003,7 +1023,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1105,6 +1125,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1105,6 +1129,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1396,6 +1420,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1396,6 +1425,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1688,6 +1719,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1688,6 +1728,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1704,6 +1738,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1704,6 +1748,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
  		goto out1;
---- linux-source-2.6.20-2.6.20.orig/fs/open.c
-+++ linux-source-2.6.20-2.6.20/fs/open.c
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/open.c
++++ linux-source-2.6.20.3-ubuntu1/fs/open.c
 @@ -27,6 +27,12 @@
  #include <linux/syscalls.h>
  #include <linux/rcupdate.h>
@@ -528,51 +611,56 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -264,6 +270,9 @@ static long do_sys_truncate(const char _
+@@ -264,6 +270,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -317,6 +326,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -317,6 +327,10 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, file);
-@@ -481,6 +493,12 @@ asmlinkage long sys_chroot(const char __
+@@ -481,6 +495,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1085,6 +1103,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1085,6 +1107,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		/* XXX: this needs locking */
  		tty_vhangup(current->signal->tty);
---- linux-source-2.6.20-2.6.20.orig/fs/proc/Makefile
-+++ linux-source-2.6.20-2.6.20/fs/proc/Makefile
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/proc/Makefile
++++ linux-source-2.6.20.3-ubuntu1/fs/proc/Makefile
 @@ -14,3 +14,6 @@ proc-$(CONFIG_PROC_KCORE)	+= kcore.o
  proc-$(CONFIG_PROC_VMCORE)	+= vmcore.o
  proc-$(CONFIG_PROC_DEVICETREE)	+= proc_devtree.o
@@ -580,20 +668,20 @@
 +
 +proc-$(CONFIG_SAKURA) += ccs_proc.o
 +proc-$(CONFIG_TOMOYO) += ccs_proc.o
---- linux-source-2.6.20-2.6.20.orig/fs/proc/proc_misc.c
-+++ linux-source-2.6.20-2.6.20/fs/proc/proc_misc.c
+--- linux-source-2.6.20.3-ubuntu1.orig/fs/proc/proc_misc.c
++++ linux-source-2.6.20.3-ubuntu1/fs/proc/proc_misc.c
 @@ -763,4 +763,9 @@ void __init proc_misc_init(void)
  	if (entry)
  		entry->proc_fops = &proc_sysrq_trigger_operations;
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.20.3-ubuntu1 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.20.3-ubuntu1 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
---- linux-source-2.6.20-2.6.20.orig/include/linux/init_task.h
-+++ linux-source-2.6.20-2.6.20/include/linux/init_task.h
+--- linux-source-2.6.20.3-ubuntu1.orig/include/linux/init_task.h
++++ linux-source-2.6.20.3-ubuntu1/include/linux/init_task.h
 @@ -141,6 +141,10 @@ extern struct group_info init_groups;
  	.pi_lock	= SPIN_LOCK_UNLOCKED,				\
  	INIT_TRACE_IRQFLAGS						\
@@ -605,8 +693,8 @@
  }
  
  
---- linux-source-2.6.20-2.6.20.orig/include/linux/sched.h
-+++ linux-source-2.6.20-2.6.20/include/linux/sched.h
+--- linux-source-2.6.20.3-ubuntu1.orig/include/linux/sched.h
++++ linux-source-2.6.20.3-ubuntu1/include/linux/sched.h
 @@ -27,6 +27,11 @@
  #define CLONE_NEWUTS		0x04000000	/* New utsname group? */
  #define CLONE_NEWIPC		0x08000000	/* New ipcs */
@@ -630,8 +718,8 @@
  };
  
  static inline pid_t process_group(struct task_struct *tsk)
---- linux-source-2.6.20-2.6.20.orig/kernel/compat.c
-+++ linux-source-2.6.20-2.6.20/kernel/compat.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/compat.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/compat.c
 @@ -25,6 +25,9 @@
  #include <linux/posix-timers.h>
  
@@ -642,18 +730,19 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -869,6 +872,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -869,6 +872,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
---- linux-source-2.6.20-2.6.20.orig/kernel/kexec.c
-+++ linux-source-2.6.20-2.6.20/kernel/kexec.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/kexec.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/kexec.c
 @@ -28,6 +28,9 @@
  #include <asm/io.h>
  #include <asm/system.h>
@@ -664,18 +753,19 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -924,6 +927,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -924,6 +927,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
  	 * Verify we have a legal set of flags
---- linux-source-2.6.20-2.6.20.orig/kernel/kmod.c
-+++ linux-source-2.6.20-2.6.20/kernel/kmod.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/kmod.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/kmod.c
 @@ -166,6 +166,11 @@ static int ____call_usermodehelper(void 
  	/* We can run anywhere, unlike our parent keventd(). */
  	set_cpus_allowed(current, CPU_MASK_ALL);
@@ -688,8 +778,8 @@
  	retval = -EPERM;
  	if (current->fs->root)
  		retval = kernel_execve(sub_info->path,
---- linux-source-2.6.20-2.6.20.orig/kernel/module.c
-+++ linux-source-2.6.20-2.6.20/kernel/module.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/module.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/module.c
 @@ -44,6 +44,9 @@
  #include <asm/semaphore.h>
  #include <asm/cacheflush.h>
@@ -700,30 +790,32 @@
  
  #if 0
  #define DEBUGP printk
-@@ -658,7 +661,9 @@ sys_delete_module(const char __user *nam
+@@ -658,7 +661,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1964,7 +1969,9 @@ sys_init_module(void __user *umod,
+@@ -1964,7 +1970,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (mutex_lock_interruptible(&module_mutex) != 0)
  		return -EINTR;
---- linux-source-2.6.20-2.6.20.orig/kernel/sched.c
-+++ linux-source-2.6.20-2.6.20/kernel/sched.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/sched.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/sched.c
 @@ -55,6 +55,9 @@
  #include <asm/tlb.h>
  
@@ -734,18 +826,19 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -4101,6 +4104,9 @@ int can_nice(const struct task_struct *p
+@@ -4101,6 +4104,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
  	 * Setpriority might change our priority at the same moment.
---- linux-source-2.6.20-2.6.20.orig/kernel/signal.c
-+++ linux-source-2.6.20-2.6.20/kernel/signal.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/signal.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/signal.c
 @@ -32,6 +32,9 @@
  #include <asm/unistd.h>
  #include <asm/siginfo.h>
@@ -756,41 +849,47 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2235,6 +2238,10 @@ asmlinkage long
+@@ -2235,6 +2238,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2293,6 +2300,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2293,6 +2302,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2306,6 +2317,10 @@ sys_tkill(int pid, int sig)
+@@ -2306,6 +2321,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
  }
---- linux-source-2.6.20-2.6.20.orig/kernel/sys.c
-+++ linux-source-2.6.20-2.6.20/kernel/sys.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/sys.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/sys.c
 @@ -37,6 +37,9 @@
  #include <asm/uaccess.h>
  #include <asm/io.h>
@@ -801,48 +900,54 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -599,6 +602,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -599,6 +602,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -822,6 +828,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -822,6 +831,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1799,6 +1808,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1799,6 +1812,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1844,6 +1856,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1844,6 +1861,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
  	errno = -EFAULT;
---- linux-source-2.6.20-2.6.20.orig/kernel/sysctl.c
-+++ linux-source-2.6.20-2.6.20/kernel/sysctl.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/sysctl.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/sysctl.c
 @@ -48,6 +48,9 @@
  
  #include <asm/uaccess.h>
@@ -853,25 +958,29 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1226,6 +1229,88 @@ void __init sysctl_init(void)
+@@ -1226,6 +1229,101 @@ void __init sysctl_init(void)
  }
  
  #ifdef CONFIG_SYSCTL_SYSCALL
 +
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -889,35 +998,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -942,31 +1060,36 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1250,6 +1335,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1250,6 +1348,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table);
  
-@@ -1324,6 +1412,12 @@ repeat:
+@@ -1324,6 +1427,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
  						oldval, oldlenp,
---- linux-source-2.6.20-2.6.20.orig/kernel/time.c
-+++ linux-source-2.6.20-2.6.20/kernel/time.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/time.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/time.c
 @@ -39,6 +39,9 @@
  
  #include <asm/uaccess.h>
@@ -977,28 +1100,30 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -91,6 +94,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -91,6 +94,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -161,6 +167,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -161,6 +168,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
---- linux-source-2.6.20-2.6.20.orig/kernel/time/ntp.c
-+++ linux-source-2.6.20-2.6.20/kernel/time/ntp.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/time/ntp.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/time/ntp.c
 @@ -14,6 +14,9 @@
  
  #include <asm/div64.h>
@@ -1009,18 +1134,19 @@
  
  /*
   * Timekeeping variables
-@@ -199,6 +202,9 @@ int do_adjtimex(struct timex *txc)
+@@ -199,6 +202,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Now we validate the data before disabling interrupts */
  
---- linux-source-2.6.20-2.6.20.orig/net/core/datagram.c
-+++ linux-source-2.6.20-2.6.20/net/core/datagram.c
+--- linux-source-2.6.20.3-ubuntu1.orig/net/core/datagram.c
++++ linux-source-2.6.20.3-ubuntu1/net/core/datagram.c
 @@ -56,6 +56,11 @@
  #include <net/sock.h>
  #include <net/tcp_states.h>
@@ -1033,19 +1159,21 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
  			return skb;
  
---- linux-source-2.6.20-2.6.20.orig/net/ipv4/inet_connection_sock.c
-+++ linux-source-2.6.20-2.6.20/net/ipv4/inet_connection_sock.c
+--- linux-source-2.6.20.3-ubuntu1.orig/net/ipv4/inet_connection_sock.c
++++ linux-source-2.6.20.3-ubuntu1/net/ipv4/inet_connection_sock.c
 @@ -23,6 +23,9 @@
  #include <net/route.h>
  #include <net/tcp_states.h>
@@ -1056,18 +1184,19 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -87,6 +90,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -87,6 +90,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
---- linux-source-2.6.20-2.6.20.orig/net/ipv4/inet_hashtables.c
-+++ linux-source-2.6.20-2.6.20/net/ipv4/inet_hashtables.c
+--- linux-source-2.6.20.3-ubuntu1.orig/net/ipv4/inet_hashtables.c
++++ linux-source-2.6.20.3-ubuntu1/net/ipv4/inet_hashtables.c
 @@ -22,6 +22,9 @@
  #include <net/inet_connection_sock.h>
  #include <net/inet_hashtables.h>
@@ -1078,18 +1207,19 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -292,6 +295,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -292,6 +295,10 @@ int inet_hash_connect(struct inet_timewa
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
  
---- linux-source-2.6.20-2.6.20.orig/net/ipv4/udp.c
-+++ linux-source-2.6.20-2.6.20/net/ipv4/udp.c
+--- linux-source-2.6.20.3-ubuntu1.orig/net/ipv4/udp.c
++++ linux-source-2.6.20.3-ubuntu1/net/ipv4/udp.c
 @@ -102,6 +102,9 @@
  #include <net/checksum.h>
  #include <net/xfrm.h>
@@ -1100,28 +1230,30 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -162,6 +165,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -162,6 +165,10 @@ int __udp_lib_get_port(struct sock *sk, 
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -180,6 +186,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -180,6 +187,10 @@ int __udp_lib_get_port(struct sock *sk, 
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (! __udp_lib_lport_inuse(result, udptable))
  				break;
  		}
---- linux-source-2.6.20-2.6.20.orig/net/ipv6/inet6_hashtables.c
-+++ linux-source-2.6.20-2.6.20/net/ipv6/inet6_hashtables.c
+--- linux-source-2.6.20.3-ubuntu1.orig/net/ipv6/inet6_hashtables.c
++++ linux-source-2.6.20.3-ubuntu1/net/ipv6/inet6_hashtables.c
 @@ -21,6 +21,9 @@
  #include <net/inet_hashtables.h>
  #include <net/inet6_hashtables.h>
@@ -1132,18 +1264,19 @@
  
  void __inet6_hash(struct inet_hashinfo *hashinfo,
  				struct sock *sk)
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
  
---- linux-source-2.6.20-2.6.20.orig/net/socket.c
-+++ linux-source-2.6.20-2.6.20/net/socket.c
+--- linux-source-2.6.20.3-ubuntu1.orig/net/socket.c
++++ linux-source-2.6.20.3-ubuntu1/net/socket.c
 @@ -93,6 +93,11 @@
  #include <net/sock.h>
  #include <linux/netfilter.h>
@@ -1156,54 +1289,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
  			 unsigned long nr_segs, loff_t pos);
-@@ -562,7 +567,9 @@ static inline int __sock_sendmsg(struct 
+@@ -562,7 +567,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1083,6 +1090,10 @@ static int __sock_create(int family, int
+@@ -1083,6 +1093,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1285,6 +1296,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1285,6 +1301,13 @@ asmlinkage long sys_bind(int fd, struct 
  			err = security_socket_bind(sock,
  						   (struct sockaddr *)address,
  						   addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  						      (struct sockaddr *)
-@@ -1314,6 +1328,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1314,6 +1337,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1378,6 +1395,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1378,6 +1405,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1211,19 +1355,21 @@
  	if (upeer_sockaddr) {
  		if (newsock->ops->getname(newsock, (struct sockaddr *)address,
  					  &len, 2) < 0) {
-@@ -1437,6 +1460,10 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1437,6 +1471,12 @@ asmlinkage long sys_connect(int fd, stru
  	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 +	/***** TOMOYO Linux start. *****/
-+	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen);
-+	if (err) goto out_put;
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  
  	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
  				 sock->file->f_flags);
---- linux-source-2.6.20-2.6.20.orig/net/unix/af_unix.c
-+++ linux-source-2.6.20-2.6.20/net/unix/af_unix.c
+--- linux-source-2.6.20.3-ubuntu1.orig/net/unix/af_unix.c
++++ linux-source-2.6.20.3-ubuntu1/net/unix/af_unix.c
 @@ -116,6 +116,9 @@
  #include <linux/mount.h>
  #include <net/checksum.h>
@@ -1234,29 +1380,34 @@
  
  int sysctl_unix_max_dgram_qlen __read_mostly = 10;
  
-@@ -765,6 +768,10 @@ static int unix_bind(struct socket *sock
+@@ -765,6 +768,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -808,6 +815,9 @@ static int unix_bind(struct socket *sock
+@@ -808,6 +816,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
  			goto out_mknod_dput;
---- linux-source-2.6.20-2.6.20.orig/arch/alpha/kernel/ptrace.c
-+++ linux-source-2.6.20-2.6.20/arch/alpha/kernel/ptrace.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/alpha/kernel/ptrace.c
++++ linux-source-2.6.20.3-ubuntu1/arch/alpha/kernel/ptrace.c
 @@ -20,6 +20,9 @@
  #include <asm/pgtable.h>
  #include <asm/system.h>
@@ -1267,20 +1418,21 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	DBG(DBG_MEM, ("request=%ld pid=%ld addr=0x%lx data=0x%lx\n",
---- linux-source-2.6.20-2.6.20.orig/arch/ia64/kernel/ptrace.c
-+++ linux-source-2.6.20-2.6.20/arch/ia64/kernel/ptrace.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/ia64/kernel/ptrace.c
++++ linux-source-2.6.20.3-ubuntu1/arch/ia64/kernel/ptrace.c
 @@ -28,6 +28,9 @@
  #ifdef CONFIG_PERFMON
  #include <asm/perfmon.h>
@@ -1291,20 +1443,21 @@
  
  #include "entry.h"
  
-@@ -1417,6 +1420,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1417,6 +1420,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	ret = -EPERM;
---- linux-source-2.6.20-2.6.20.orig/arch/m32r/kernel/ptrace.c
-+++ linux-source-2.6.20-2.6.20/arch/m32r/kernel/ptrace.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/m32r/kernel/ptrace.c
++++ linux-source-2.6.20.3-ubuntu1/arch/m32r/kernel/ptrace.c
 @@ -32,6 +32,9 @@
  #include <asm/system.h>
  #include <asm/processor.h>
@@ -1315,20 +1468,21 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -742,6 +745,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -742,6 +745,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
---- linux-source-2.6.20-2.6.20.orig/arch/s390/kernel/ptrace.c
-+++ linux-source-2.6.20-2.6.20/arch/s390/kernel/ptrace.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/s390/kernel/ptrace.c
++++ linux-source-2.6.20.3-ubuntu1/arch/s390/kernel/ptrace.c
 @@ -41,6 +41,9 @@
  #include <asm/system.h>
  #include <asm/uaccess.h>
@@ -1339,20 +1493,21 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -711,6 +714,11 @@ sys_ptrace(long request, long pid, long 
+@@ -711,6 +714,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
  		 ret = ptrace_traceme();
---- linux-source-2.6.20-2.6.20.orig/arch/sparc/kernel/ptrace.c
-+++ linux-source-2.6.20-2.6.20/arch/sparc/kernel/ptrace.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/sparc/kernel/ptrace.c
++++ linux-source-2.6.20.3-ubuntu1/arch/sparc/kernel/ptrace.c
 @@ -23,6 +23,9 @@
  #include <asm/pgtable.h>
  #include <asm/system.h>
@@ -1378,8 +1533,8 @@
  
  	lock_kernel();
  #ifdef DEBUG_PTRACE
---- linux-source-2.6.20-2.6.20.orig/arch/sparc64/kernel/ptrace.c
-+++ linux-source-2.6.20-2.6.20/arch/sparc64/kernel/ptrace.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/sparc64/kernel/ptrace.c
++++ linux-source-2.6.20.3-ubuntu1/arch/sparc64/kernel/ptrace.c
 @@ -32,6 +32,9 @@
  #include <asm/spitfire.h>
  #include <asm/page.h>
@@ -1405,8 +1560,8 @@
  
  	if (test_thread_flag(TIF_32BIT)) {
  		addr &= 0xffffffffUL;
---- linux-source-2.6.20-2.6.20.orig/kernel/ptrace.c
-+++ linux-source-2.6.20-2.6.20/kernel/ptrace.c
+--- linux-source-2.6.20.3-ubuntu1.orig/kernel/ptrace.c
++++ linux-source-2.6.20.3-ubuntu1/kernel/ptrace.c
 @@ -21,6 +21,9 @@
  
  #include <asm/pgtable.h>
@@ -1417,20 +1572,21 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -456,6 +459,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -456,6 +459,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
  		ret = ptrace_traceme();
---- linux-source-2.6.20-2.6.20.orig/arch/sh64/kernel/ptrace.c
-+++ linux-source-2.6.20-2.6.20/arch/sh64/kernel/ptrace.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/sh64/kernel/ptrace.c
++++ linux-source-2.6.20.3-ubuntu1/arch/sh64/kernel/ptrace.c
 @@ -35,6 +35,9 @@
  #include <asm/system.h>
  #include <asm/processor.h>
@@ -1441,20 +1597,21 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -271,6 +274,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -271,6 +274,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (first_call) {
---- linux-source-2.6.20-2.6.20.orig/arch/x86_64/ia32/ptrace32.c
-+++ linux-source-2.6.20-2.6.20/arch/x86_64/ia32/ptrace32.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/x86_64/ia32/ptrace32.c
++++ linux-source-2.6.20.3-ubuntu1/arch/x86_64/ia32/ptrace32.c
 @@ -26,6 +26,9 @@
  #include <asm/i387.h>
  #include <asm/fpu32.h>
@@ -1465,20 +1622,21 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -234,6 +237,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -234,6 +237,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	switch (request) { 
  	case PTRACE_TRACEME:
---- linux-source-2.6.20-2.6.20.orig/arch/ia64/ia32/sys_ia32.c
-+++ linux-source-2.6.20-2.6.20/arch/ia64/ia32/sys_ia32.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/ia64/ia32/sys_ia32.c
++++ linux-source-2.6.20.3-ubuntu1/arch/ia64/ia32/sys_ia32.c
 @@ -56,6 +56,9 @@
  #include <asm/types.h>
  #include <asm/uaccess.h>
@@ -1489,20 +1647,21 @@
  
  #include "ia32priv.h"
  
-@@ -1754,6 +1757,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1754,6 +1757,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
---- linux-source-2.6.20-2.6.20.orig/arch/mips/kernel/ptrace32.c
-+++ linux-source-2.6.20-2.6.20/arch/mips/kernel/ptrace32.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/mips/kernel/ptrace32.c
++++ linux-source-2.6.20.3-ubuntu1/arch/mips/kernel/ptrace32.c
 @@ -35,6 +35,9 @@
  #include <asm/system.h>
  #include <asm/uaccess.h>
@@ -1513,20 +1672,21 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  #if 0
  	printk("ptrace(r=%d,pid=%d,addr=%08lx,data=%08lx)\n",
---- linux-source-2.6.20-2.6.20.orig/arch/powerpc/kernel/ptrace32.c
-+++ linux-source-2.6.20-2.6.20/arch/powerpc/kernel/ptrace32.c
+--- linux-source-2.6.20.3-ubuntu1.orig/arch/powerpc/kernel/ptrace32.c
++++ linux-source-2.6.20.3-ubuntu1/arch/powerpc/kernel/ptrace32.c
 @@ -32,6 +32,9 @@
  #include <asm/page.h>
  #include <asm/pgtable.h>
@@ -1537,13 +1697,14 @@
  
  #include "ptrace-common.h"
  
-@@ -45,6 +48,11 @@ long compat_sys_ptrace(int request, int 
+@@ -45,6 +48,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.18-53.1.14.el5.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.18-53.1.14.el5.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.18-53.1.14.el5.diff	(作業コピー)
@@ -3,47 +3,47 @@
 Source code for this patch is http://ftp.riken.jp/Linux/centos/5.1/updates/SRPMS/kernel-2.6.18-53.1.14.el5.src.rpm
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 ++++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 ++++
- fs/compat.c                     |    8 +++
- fs/exec.c                       |   15 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   61 ++++++++++++++++++++++++++
- fs/namespace.c                  |   39 ++++++++++++++++
- fs/open.c                       |   21 +++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |   11 +++
+ fs/exec.c                       |   21 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  118 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   50 ++++++++++++++++
+ fs/open.c                       |   27 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  fs/syaoran_2.6.c                |    2 
  include/linux/init_task.h       |    4 +
  include/linux/sched.h           |    9 +++
  include/linux/syaoran.h         |    2 
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |   11 +++-
- kernel/ptrace.c                 |   13 +++++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 ++++++
- kernel/sys.c                    |   15 ++++++
- kernel/sysctl.c                 |   93 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |   12 +++++
- net/core/datagram.c             |    9 +++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 +++
- net/ipv6/inet6_hashtables.c     |    8 +++
- net/ipv6/udp.c                  |    9 +++
- net/socket.c                    |   29 +++++++++++-
- net/unix/af_unix.c              |   10 ++++
- 41 files changed, 507 insertions(+), 11 deletions(-)
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   13 +++-
+ kernel/ptrace.c                 |   15 +++++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |  111 +++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   15 +++++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    9 ++-
+ net/ipv6/udp.c                  |   11 +++
+ net/socket.c                    |   43 +++++++++++++-
+ net/unix/af_unix.c              |   15 +++++
+ 41 files changed, 674 insertions(+), 11 deletions(-)
 
 --- linux-2.6.18-53.1.14.el5.orig/Makefile
 +++ linux-2.6.18-53.1.14.el5/Makefile
@@ -86,13 +86,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry * dentry
+@@ -145,12 +148,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -101,8 +105,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -119,17 +127,20 @@
  
  extern void sigset_from_compat(sigset_t *set, compat_sigset_t *compat);
  
-@@ -421,6 +424,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -421,6 +424,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1575,7 +1581,7 @@ int compat_do_execve(char * filename,
+@@ -1575,7 +1584,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -151,34 +162,40 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  int suid_dumpable = 0;
-@@ -139,6 +143,11 @@ asmlinkage long sys_uselib(const char __
+@@ -139,6 +143,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -486,6 +495,9 @@ struct file *open_exec(const char *name)
+@@ -486,6 +497,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1188,7 +1200,8 @@ int do_execve(char * filename,
+@@ -1188,7 +1206,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
@@ -195,12 +212,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -216,6 +219,10 @@ static int setfl(int fd, struct file * f
+@@ -216,6 +219,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -218,12 +237,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -23,6 +26,9 @@ static long do_ioctl(struct file *filp, 
+@@ -23,6 +26,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -241,29 +261,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1508,6 +1512,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1508,6 +1512,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1563,6 +1570,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1563,6 +1574,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1594,6 +1606,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1594,6 +1612,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -273,136 +299,187 @@
  /*
   *	open_namei()
   *
-@@ -1862,6 +1877,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1862,6 +1883,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1880,10 +1901,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1880,10 +1911,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1948,6 +1975,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1948,6 +2001,13 @@ asmlinkage long sys_mkdirat(int dfd, con
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -2056,6 +2086,9 @@ static long do_rmdir(int dfd, const char
+@@ -2056,6 +2116,13 @@ static long do_rmdir(int dfd, const char
  	dentry = lookup_hash(&nd);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -2115,6 +2148,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2115,6 +2182,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2136,6 +2172,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2136,6 +2207,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2198,6 +2237,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2198,6 +2277,10 @@ asmlinkage long sys_symlinkat(const char
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2214,6 +2256,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2214,6 +2297,13 @@ asmlinkage long sys_symlinkat(const char
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2286,6 +2331,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2286,6 +2376,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2308,6 +2356,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2308,6 +2402,15 @@ asmlinkage long sys_linkat(int olddfd, c
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2534,6 +2585,13 @@ static int do_rename(int olddfd, const c
+@@ -2534,6 +2637,17 @@ static int do_rename(int olddfd, const c
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2556,6 +2614,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2556,6 +2670,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -422,91 +499,102 @@
  
  extern int __init init_rootfs(void);
  
-@@ -553,6 +559,10 @@ static int do_umount(struct vfsmount *mn
+@@ -553,6 +559,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -641,6 +651,9 @@ asmlinkage long sys_umount(char __user *
+@@ -641,6 +652,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -945,6 +958,10 @@ static int do_loopback(struct nameidata 
+@@ -945,6 +960,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1029,7 +1046,10 @@ static int do_move_mount(struct nameidat
+@@ -1029,7 +1049,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1131,6 +1151,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1131,6 +1155,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1422,6 +1446,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1422,6 +1451,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1713,6 +1744,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1713,6 +1753,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1729,6 +1763,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1729,6 +1773,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -526,45 +614,51 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -267,6 +273,9 @@ static long do_sys_truncate(const char _
+@@ -267,6 +273,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -320,6 +329,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -320,6 +330,11 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, file);
-@@ -611,6 +623,12 @@ asmlinkage long sys_chroot(const char __
+@@ -611,6 +626,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1203,6 +1221,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1203,6 +1226,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
@@ -586,7 +680,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.18-53.1.14.el5 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.18-53.1.14.el5 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -662,12 +756,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -836,6 +839,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -836,6 +839,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -684,12 +779,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -964,6 +967,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -964,6 +967,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -720,24 +816,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -653,7 +656,9 @@ sys_delete_module(const char __user *nam
+@@ -653,7 +656,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1898,7 +1903,9 @@ sys_init_module(void __user *umod,
+@@ -1898,7 +1904,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (mutex_lock_interruptible(&module_mutex) != 0)
@@ -754,12 +852,13 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -3979,6 +3982,9 @@ int can_nice(const struct task_struct *p
+@@ -3979,6 +3982,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -776,35 +875,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -1985,6 +1988,10 @@ asmlinkage long
+@@ -1985,6 +1988,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2043,6 +2050,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2043,6 +2052,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2056,6 +2067,10 @@ sys_tkill(int pid, int sig)
+@@ -2056,6 +2071,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -821,42 +926,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -468,6 +471,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -468,6 +471,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -694,6 +700,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -694,6 +703,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1691,6 +1700,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1691,6 +1704,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1736,6 +1748,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1736,6 +1753,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -873,24 +984,28 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1233,6 +1236,87 @@ void __init sysctl_init(void)
+@@ -1233,6 +1236,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -908,35 +1023,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -961,25 +1085,30 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1258,6 +1342,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1258,6 +1355,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1330,6 +1417,12 @@ repeat:
+@@ -1330,6 +1432,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
@@ -996,32 +1125,35 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -91,6 +94,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -91,6 +94,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -161,6 +167,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -161,6 +168,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -221,6 +230,9 @@ int do_adjtimex(struct timex *txc)
+@@ -221,6 +232,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
@@ -1040,12 +1172,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1063,12 +1197,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -87,6 +90,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -87,6 +90,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1085,12 +1220,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -263,6 +266,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -263,6 +266,10 @@ int inet_hash_connect(struct inet_timewa
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1107,22 +1243,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -146,6 +149,9 @@ static int udp_v4_get_port(struct sock *
+@@ -146,6 +149,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -162,6 +168,9 @@ static int udp_v4_get_port(struct sock *
+@@ -162,6 +169,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1148,12 +1286,13 @@
  						inet->dport);
  	struct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);
  	struct sock *sk2;
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1170,22 +1309,24 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6) __read_mostly;
  
-@@ -88,6 +91,9 @@ static int udp_v6_get_port(struct sock *
+@@ -88,6 +91,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -104,6 +110,9 @@ static int udp_v6_get_port(struct sock *
+@@ -104,6 +111,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1204,54 +1345,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -595,7 +600,9 @@ static inline int __sock_sendmsg(struct 
+@@ -595,7 +600,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1160,6 +1167,10 @@ static int __sock_create(int family, int
+@@ -1160,6 +1170,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1362,6 +1373,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1362,6 +1378,13 @@ asmlinkage long sys_bind(int fd, struct 
  	{
  		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
  			err = security_socket_bind(sock, (struct sockaddr *)address, addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  					(struct sockaddr *)address, addrlen);
-@@ -1390,6 +1404,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1390,6 +1413,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1454,6 +1471,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1454,6 +1481,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1259,13 +1411,16 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1510,7 +1533,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1510,7 +1544,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
@@ -1282,23 +1437,28 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -764,6 +767,10 @@ static int unix_bind(struct socket *sock
+@@ -764,6 +767,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -807,6 +814,9 @@ static int unix_bind(struct socket *sock
+@@ -807,6 +815,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1315,13 +1475,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1339,13 +1500,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -742,6 +745,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -742,6 +745,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1390,25 +1552,27 @@
  
  
  /*
-@@ -1080,6 +1083,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -1080,6 +1083,12 @@ asmlinkage long sys_ptrace(long request,
  	struct utrace_attached_engine *engine = NULL;
  	struct ptrace_state *state = NULL;
  	long ret, val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	pr_debug("%d sys_ptrace(%ld, %ld, %lx, %lx)\n",
  		 current->pid, request, pid, addr, data);
-@@ -1167,6 +1175,11 @@ asmlinkage long compat_sys_ptrace(compat
+@@ -1167,6 +1176,12 @@ asmlinkage long compat_sys_ptrace(compat
  	struct utrace_attached_engine *engine;
  	struct ptrace_state *state;
  	compat_long_t ret, val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1426,13 +1590,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -271,6 +274,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -271,6 +274,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1450,13 +1615,14 @@
  
  #include "ia32priv.h"
  
-@@ -1737,6 +1740,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1737,6 +1740,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1474,13 +1640,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.16-0vl76.33.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.16-0vl76.33.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.16-0vl76.33.diff	(作業コピー)
@@ -3,50 +3,50 @@
 Source code for this patch is http://updates.vinelinux.org/Vine-4.2/updates/SRPMS/kernel-2.6.16-0vl76.33.src.rpm
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 ++++
- arch/sparc64/kernel/ptrace.c    |   11 ++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 ++++
- fs/compat.c                     |    8 +++
- fs/exec.c                       |   15 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   61 ++++++++++++++++++++++++++
- fs/namespace.c                  |   39 ++++++++++++++++
- fs/open.c                       |   23 +++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |   11 +++
+ fs/exec.c                       |   21 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  118 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   50 ++++++++++++++++
+ fs/open.c                       |   29 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
  include/linux/sched.h           |    9 +++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |   11 +++-
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 ++++++
- kernel/sys.c                    |   15 ++++++
- kernel/sysctl.c                 |   93 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |   12 +++++
- net/core/datagram.c             |    9 +++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 +++
- net/ipv6/inet6_hashtables.c     |    8 +++
- net/ipv6/udp.c                  |    9 +++
- net/socket.c                    |   30 +++++++++++-
- net/unix/af_unix.c              |   10 ++++
- 44 files changed, 544 insertions(+), 11 deletions(-)
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   13 +++-
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |  111 +++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   15 +++++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    9 ++-
+ net/ipv6/udp.c                  |   11 +++
+ net/socket.c                    |   43 +++++++++++++-
+ net/unix/af_unix.c              |   15 +++++
+ 44 files changed, 713 insertions(+), 11 deletions(-)
 
 --- linux-2.6.16-0vl76.33.orig/Makefile
 +++ linux-2.6.16-0vl76.33/Makefile
@@ -89,13 +89,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry * dentry
+@@ -145,12 +148,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -104,8 +108,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -122,17 +130,20 @@
  
  extern void sigset_from_compat(sigset_t *set, compat_sigset_t *compat);
  
-@@ -405,6 +408,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -405,6 +408,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1532,7 +1538,7 @@ int compat_do_execve(char * filename,
+@@ -1532,7 +1541,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -154,34 +165,40 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  int suid_dumpable = 0;
-@@ -139,6 +143,11 @@ asmlinkage long sys_uselib(const char __
+@@ -139,6 +143,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -488,6 +497,9 @@ struct file *open_exec(const char *name)
+@@ -488,6 +499,13 @@ struct file *open_exec(const char *name)
  			int err = vfs_permission(&nd, MAY_EXEC);
  			if (!err && !(inode->i_mode & 0111))
  				err = -EACCES;
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1201,7 +1213,8 @@ int do_execve(char * filename,
+@@ -1201,7 +1219,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
@@ -198,12 +215,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -215,6 +218,10 @@ static int setfl(int fd, struct file * f
+@@ -215,6 +218,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -221,12 +240,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -24,6 +27,9 @@ static long do_ioctl(struct file *filp, 
+@@ -24,6 +27,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -244,29 +264,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1470,6 +1474,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1470,6 +1474,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1525,6 +1532,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1525,6 +1536,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1556,6 +1568,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1556,6 +1574,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -276,136 +302,187 @@
  /*
   *	open_namei()
   *
-@@ -1820,6 +1835,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1820,6 +1841,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1838,10 +1859,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1838,10 +1869,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1906,6 +1933,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1906,6 +1959,13 @@ asmlinkage long sys_mkdirat(int dfd, con
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -2014,6 +2044,9 @@ static long do_rmdir(int dfd, const char
+@@ -2014,6 +2074,13 @@ static long do_rmdir(int dfd, const char
  	dentry = lookup_hash(&nd);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -2073,6 +2106,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2073,6 +2140,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2094,6 +2130,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2094,6 +2165,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2156,6 +2195,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2156,6 +2235,10 @@ asmlinkage long sys_symlinkat(const char
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2172,6 +2214,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2172,6 +2255,13 @@ asmlinkage long sys_symlinkat(const char
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2244,6 +2289,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2244,6 +2334,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (flags != 0)
  		return -EINVAL;
-@@ -2264,6 +2312,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2264,6 +2358,15 @@ asmlinkage long sys_linkat(int olddfd, c
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2490,6 +2541,13 @@ static int do_rename(int olddfd, const c
+@@ -2490,6 +2593,17 @@ static int do_rename(int olddfd, const c
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2512,6 +2570,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2512,6 +2626,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -425,91 +502,102 @@
  
  extern int __init init_rootfs(void);
  
-@@ -509,6 +515,10 @@ static int do_umount(struct vfsmount *mn
+@@ -509,6 +515,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -597,6 +607,9 @@ asmlinkage long sys_umount(char __user *
+@@ -597,6 +608,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -881,6 +894,10 @@ static int do_loopback(struct nameidata 
+@@ -881,6 +896,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -965,7 +982,10 @@ static int do_move_mount(struct nameidat
+@@ -965,7 +985,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1067,6 +1087,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1067,6 +1091,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1284,6 +1308,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1284,6 +1313,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1582,6 +1613,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1582,6 +1622,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1598,6 +1632,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1598,6 +1642,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -530,46 +618,52 @@
  int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
  {
  	int retval = -ENODEV;
-@@ -266,6 +273,9 @@ static long do_sys_truncate(const char _
+@@ -266,6 +273,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -318,7 +328,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -318,7 +329,11 @@ static long do_sys_ftruncate(unsigned in
  	error = -EPERM;
  	if (IS_APPEND(inode))
  		goto out_putf;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, 0, file);
-@@ -607,6 +619,12 @@ asmlinkage long sys_chroot(const char __
+@@ -607,6 +622,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1189,6 +1207,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1189,6 +1212,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
@@ -591,7 +685,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.16-0vl76.33 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.16-0vl76.33 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -645,12 +739,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -864,6 +867,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -864,6 +867,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -667,12 +762,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -922,6 +925,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -922,6 +925,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -703,24 +799,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -578,7 +581,9 @@ sys_delete_module(const char __user *nam
+@@ -578,7 +581,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1931,7 +1936,9 @@ sys_init_module(void __user *umod,
+@@ -1931,7 +1937,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (down_interruptible(&module_mutex) != 0)
@@ -737,12 +835,13 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -3545,6 +3548,9 @@ asmlinkage long sys_nice(int increment)
+@@ -3545,6 +3548,10 @@ asmlinkage long sys_nice(int increment)
  {
  	int retval;
  	long nice;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -759,35 +858,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2336,6 +2339,10 @@ asmlinkage long
+@@ -2336,6 +2339,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2394,6 +2401,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2394,6 +2403,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2407,6 +2418,10 @@ sys_tkill(int pid, int sig)
+@@ -2407,6 +2422,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -804,42 +909,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -269,6 +272,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -269,6 +272,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -496,6 +502,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -496,6 +505,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1533,6 +1542,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1533,6 +1546,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1578,6 +1590,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1578,6 +1595,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -856,24 +967,28 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1108,6 +1111,87 @@ void __init sysctl_init(void)
+@@ -1108,6 +1111,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -891,35 +1006,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -944,25 +1068,30 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1133,6 +1217,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1133,6 +1230,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1205,6 +1292,12 @@ repeat:
+@@ -1205,6 +1307,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
@@ -979,32 +1108,35 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -91,6 +94,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -91,6 +94,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -161,6 +167,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -161,6 +168,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -239,6 +248,9 @@ int do_adjtimex(struct timex *txc)
+@@ -239,6 +250,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
@@ -1023,12 +1155,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1046,12 +1180,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -88,6 +91,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -88,6 +91,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1068,12 +1203,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -268,6 +271,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -268,6 +271,10 @@ int inet_hash_connect(struct inet_timewa
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1090,22 +1226,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -147,6 +150,9 @@ static int udp_v4_get_port(struct sock *
+@@ -147,6 +150,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -163,6 +169,9 @@ static int udp_v4_get_port(struct sock *
+@@ -163,6 +170,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1131,12 +1269,13 @@
  						inet->dport);
  	struct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);
  	struct sock *sk2;
-@@ -187,6 +190,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -187,6 +190,10 @@ int inet6_hash_connect(struct inet_timew
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1153,22 +1292,24 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6) __read_mostly;
  
-@@ -89,6 +92,9 @@ static int udp_v6_get_port(struct sock *
+@@ -89,6 +92,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -105,6 +111,9 @@ static int udp_v6_get_port(struct sock *
+@@ -105,6 +112,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1187,55 +1328,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -546,7 +551,9 @@ static inline int __sock_sendmsg(struct 
+@@ -546,7 +551,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1102,6 +1109,10 @@ static int __sock_create(int family, int
+@@ -1102,6 +1112,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1299,6 +1310,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1299,6 +1315,12 @@ asmlinkage long sys_bind(int fd, struct 
  				sockfd_put(sock);
  				return err;
  			}
 +			/***** TOMOYO Linux start. *****/
-+			if ((err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++			err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++							 address, addrlen);
++			if (!err)
 +			/***** TOMOYO Linux end. *****/
  			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
  		}
  		sockfd_put(sock);
-@@ -1329,7 +1343,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1329,7 +1351,10 @@ asmlinkage long sys_listen(int fd, int b
  			sockfd_put(sock);
  			return err;
  		}
 -
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = ccs_socket_listen_permission(sock)) == 0)
++		err = ccs_socket_listen_permission(sock);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err=sock->ops->listen(sock, backlog);
  		sockfd_put(sock);
  	}
-@@ -1380,6 +1396,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1380,6 +1405,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_release;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_release;
 +	}
@@ -1243,13 +1394,16 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1435,7 +1457,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1435,7 +1467,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
@@ -1266,23 +1420,28 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -738,6 +741,10 @@ static int unix_bind(struct socket *sock
+@@ -738,6 +741,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -781,6 +788,9 @@ static int unix_bind(struct socket *sock
+@@ -781,6 +789,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1299,13 +1458,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1323,13 +1483,14 @@
  
  #include "entry.h"
  
-@@ -1418,6 +1421,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1418,6 +1421,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1347,13 +1508,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -743,6 +746,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -743,6 +746,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1371,13 +1533,14 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -711,6 +714,11 @@ sys_ptrace(long request, long pid, long 
+@@ -711,6 +714,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -1449,13 +1612,14 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -495,6 +498,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -495,6 +498,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -1473,13 +1637,14 @@
  
  #include "ia32priv.h"
  
-@@ -1755,6 +1758,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1755,6 +1758,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1497,13 +1662,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1521,13 +1687,14 @@
  
  #include "ptrace-common.h"
  
-@@ -46,6 +49,11 @@ long compat_sys_ptrace(int request, int 
+@@ -46,6 +49,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1545,13 +1712,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -272,6 +275,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -272,6 +275,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1569,13 +1737,14 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -206,6 +209,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -206,6 +209,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22-6.lenny1.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22-6.lenny1.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22-6.lenny1.diff	(作業コピー)
@@ -3,51 +3,51 @@
 Source code for this patch is "apt-get install linux-source-2.6.22"
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 +++++
- arch/sparc64/kernel/ptrace.c    |   11 +++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 +++++
- fs/compat.c                     |    5 +-
- fs/compat_ioctl.c               |    6 ++
- fs/exec.c                       |   14 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   60 +++++++++++++++++++++++++++++
- fs/namespace.c                  |   38 ++++++++++++++++++
- fs/open.c                       |   21 ++++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |    5 +
+ fs/compat_ioctl.c               |    9 +++
+ fs/exec.c                       |   20 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  112 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   49 +++++++++++++++++
+ fs/open.c                       |   26 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    9 ++++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
- include/linux/sched.h           |    9 ++++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |    9 ++++
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 +++++++
- kernel/sys.c                    |   15 +++++++
- kernel/sysctl.c                 |   81 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |    9 ++++
- kernel/time/ntp.c               |    6 ++
- net/core/datagram.c             |    9 ++++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 ++++
- net/ipv6/inet6_hashtables.c     |    6 ++
- net/socket.c                    |   28 +++++++++++++
- net/unix/af_unix.c              |   10 ++++
- 45 files changed, 530 insertions(+), 3 deletions(-)
+ include/linux/sched.h           |    9 +++
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   11 +++
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |   95 +++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   11 +++
+ kernel/time/ntp.c               |    7 ++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    7 ++
+ net/socket.c                    |   41 ++++++++++++++
+ net/unix/af_unix.c              |   15 +++++
+ 45 files changed, 683 insertions(+), 3 deletions(-)
 
 --- linux-source-2.6.22-6.lenny1.orig/Makefile
 +++ linux-source-2.6.22-6.lenny1/Makefile
@@ -90,13 +90,17 @@
  
  /* Taken over from the old code... */
  
-@@ -144,12 +147,20 @@ int notify_change(struct dentry * dentry
+@@ -144,12 +147,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -105,8 +109,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -144,12 +152,15 @@
  
  static int do_ioctl32_pointer(unsigned int fd, unsigned int cmd,
  			      unsigned long arg, struct file *f)
-@@ -3566,6 +3569,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -3566,6 +3569,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
@@ -167,29 +178,35 @@
  int core_uses_pid;
  char core_pattern[CORENAME_MAX_SIZE] = "core";
  int suid_dumpable = 0;
-@@ -145,6 +149,11 @@ asmlinkage long sys_uselib(const char __
+@@ -145,6 +149,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -490,6 +499,9 @@ struct file *open_exec(const char *name)
+@@ -490,6 +501,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1212,7 +1224,7 @@ int do_execve(char * filename,
+@@ -1212,7 +1230,7 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -210,12 +227,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -213,6 +216,10 @@ static int setfl(int fd, struct file * f
+@@ -213,6 +216,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (((arg ^ filp->f_flags) & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -233,12 +252,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -25,6 +28,9 @@ static long do_ioctl(struct file *filp, 
+@@ -25,6 +28,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -256,29 +276,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1524,6 +1528,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1524,6 +1528,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1579,6 +1586,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1579,6 +1590,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1628,6 +1640,9 @@ static int open_namei_create(struct name
+@@ -1628,6 +1646,9 @@ static int open_namei_create(struct name
  	return may_open(nd, 0, flag & ~O_TRUNC);
  }
  
@@ -288,135 +314,181 @@
  /*
   *	open_namei()
   *
-@@ -1888,6 +1903,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1888,6 +1909,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1906,10 +1927,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1906,10 +1937,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1977,6 +2004,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1977,6 +2030,12 @@ asmlinkage long sys_mkdirat(int dfd, con
  
  	if (!IS_POSIXACL(nd.dentry->d_inode))
  		mode &= ~current->fs->umask;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  	dput(dentry);
  out_unlock:
-@@ -2084,6 +2114,9 @@ static long do_rmdir(int dfd, const char
+@@ -2084,6 +2143,12 @@ static long do_rmdir(int dfd, const char
  	error = PTR_ERR(dentry);
  	if (IS_ERR(dentry))
  		goto exit2;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_rmdir(nd.dentry->d_inode, dentry);
  	dput(dentry);
  exit2:
-@@ -2143,6 +2176,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2143,6 +2208,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2164,6 +2200,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2164,6 +2233,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2228,6 +2267,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2228,6 +2305,10 @@ asmlinkage long sys_symlinkat(const char
  	char * to;
  	struct dentry *dentry;
  	struct nameidata nd;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2245,6 +2287,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2245,6 +2326,12 @@ asmlinkage long sys_symlinkat(const char
  	if (IS_ERR(dentry))
  		goto out_unlock;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  	dput(dentry);
  out_unlock:
-@@ -2317,6 +2362,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2317,6 +2404,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2340,6 +2388,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2340,6 +2431,13 @@ asmlinkage long sys_linkat(int olddfd, c
  	error = PTR_ERR(new_dentry);
  	if (IS_ERR(new_dentry))
  		goto out_unlock;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
++	if (!error)
++		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
++					     old_nd.mnt, new_dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  	dput(new_dentry);
  out_unlock:
-@@ -2565,6 +2616,12 @@ static int do_rename(int olddfd, const c
+@@ -2565,6 +2663,16 @@ static int do_rename(int olddfd, const c
  	error = -ENOTEMPTY;
  	if (new_dentry == trap)
  		goto exit5;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
  
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
-@@ -2588,6 +2645,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2588,6 +2696,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -436,90 +508,101 @@
  
  /* spinlock for vfsmount related operations, inplace of dcache_lock */
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(vfsmount_lock);
-@@ -549,6 +555,10 @@ static int do_umount(struct vfsmount *mn
+@@ -549,6 +555,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -637,6 +647,9 @@ asmlinkage long sys_umount(char __user *
+@@ -637,6 +648,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -924,6 +937,10 @@ static int do_loopback(struct nameidata 
+@@ -924,6 +939,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1009,6 +1026,10 @@ static int do_move_mount(struct nameidat
+@@ -1009,6 +1029,11 @@ static int do_move_mount(struct nameidat
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
  
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1110,6 +1131,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1110,6 +1135,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1401,6 +1426,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1401,6 +1431,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1677,6 +1709,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1677,6 +1718,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1693,6 +1728,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1693,6 +1738,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -539,45 +622,50 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -266,6 +272,9 @@ static long do_sys_truncate(const char _
+@@ -266,6 +272,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -319,6 +328,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -319,6 +329,10 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, file);
-@@ -483,6 +495,12 @@ asmlinkage long sys_chroot(const char __
+@@ -483,6 +497,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1087,6 +1105,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1087,6 +1109,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		/* XXX: this needs locking */
@@ -593,17 +681,13 @@
 +proc-$(CONFIG_TOMOYO) += ccs_proc.o
 --- linux-source-2.6.22-6.lenny1.orig/fs/proc/proc_misc.c
 +++ linux-source-2.6.22-6.lenny1/fs/proc/proc_misc.c
-@@ -737,4 +737,13 @@ void __init proc_misc_init(void)
+@@ -737,4 +737,9 @@ void __init proc_misc_init(void)
  			entry->proc_fops = &proc_sysrq_trigger_operations;
  	}
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	{
-+		extern void __init CCSProc_Init(void);
-+		CCSProc_Init();
-+		printk("Hook version: 2.6.22-6.lenny1 2008/02/18\n");
-+	}
++	printk(KERN_INFO "Hook version: 2.6.22-6.lenny1 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -657,12 +741,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -869,6 +872,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -869,6 +872,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -679,12 +764,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -924,6 +927,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -924,6 +927,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -715,22 +801,24 @@
  
  extern int module_sysfs_initialized;
  
-@@ -665,6 +668,9 @@ sys_delete_module(const char __user *nam
+@@ -665,6 +668,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
-@@ -1988,6 +1994,9 @@ sys_init_module(void __user *umod,
+@@ -1988,6 +1995,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Only one module load at a time, please */
@@ -747,12 +835,13 @@
  
  /*
   * Scheduler clock - returns current time in nanosec units.
-@@ -4245,6 +4248,9 @@ int can_nice(const struct task_struct *p
+@@ -4245,6 +4248,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -769,35 +858,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2159,6 +2162,10 @@ asmlinkage long
+@@ -2159,6 +2162,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2217,6 +2224,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2217,6 +2226,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2230,6 +2241,10 @@ sys_tkill(int pid, int sig)
+@@ -2230,6 +2245,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -814,42 +909,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -663,6 +666,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -663,6 +666,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > PRIO_USER || which < PRIO_PROCESS)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -894,6 +900,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -894,6 +903,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1869,6 +1878,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1869,6 +1882,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1914,6 +1926,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1914,6 +1931,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -866,25 +967,29 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1111,6 +1114,81 @@ struct ctl_table_header *sysctl_head_nex
+@@ -1111,6 +1114,93 @@ struct ctl_table_header *sysctl_head_nex
  }
  
  #ifdef CONFIG_SYSCTL_SYSCALL
 +
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -902,30 +1007,38 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", n);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", n);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				name++;
@@ -948,12 +1061,14 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1127,6 +1205,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1127,6 +1217,11 @@ int do_sysctl(int __user *name, int nlen
  
  	for (head = sysctl_head_next(NULL); head;
  			head = sysctl_head_next(head)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table);
@@ -970,22 +1085,24 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -90,6 +93,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -90,6 +93,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -160,6 +166,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -160,6 +167,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
@@ -1002,12 +1119,13 @@
  
  /*
   * Timekeeping variables
-@@ -203,6 +206,9 @@ int do_adjtimex(struct timex *txc)
+@@ -203,6 +206,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Now we validate the data before disabling interrupts */
@@ -1026,12 +1144,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1049,12 +1169,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -85,6 +88,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -85,6 +88,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1071,12 +1192,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -292,6 +295,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -292,6 +295,10 @@ int inet_hash_connect(struct inet_timewa
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
@@ -1093,22 +1215,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -162,6 +165,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -162,6 +165,10 @@ int __udp_lib_get_port(struct sock *sk, 
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -181,6 +187,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -181,6 +188,10 @@ int __udp_lib_get_port(struct sock *sk, 
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (! __udp_lib_lport_inuse(result, udptable))
  				break;
@@ -1125,12 +1249,13 @@
  
  void __inet6_hash(struct inet_hashinfo *hashinfo,
  				struct sock *sk)
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
@@ -1149,53 +1274,64 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
  			 unsigned long nr_segs, loff_t pos);
-@@ -553,6 +558,9 @@ static inline int __sock_sendmsg(struct 
+@@ -553,6 +558,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
-@@ -1102,6 +1110,10 @@ static int __sock_create(int family, int
+@@ -1102,6 +1113,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1330,6 +1342,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1330,6 +1347,13 @@ asmlinkage long sys_bind(int fd, struct 
  			err = security_socket_bind(sock,
  						   (struct sockaddr *)address,
  						   addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  						      (struct sockaddr *)
-@@ -1359,6 +1374,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1359,6 +1383,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1423,6 +1441,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1423,6 +1451,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1203,13 +1339,15 @@
  	if (upeer_sockaddr) {
  		if (newsock->ops->getname(newsock, (struct sockaddr *)address,
  					  &len, 2) < 0) {
-@@ -1487,6 +1511,10 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1487,6 +1522,12 @@ asmlinkage long sys_connect(int fd, stru
  	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 +	/***** TOMOYO Linux start. *****/
-+	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen);
-+	if (err) goto out_put;
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  
  	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
@@ -1226,23 +1364,28 @@
  
  int sysctl_unix_max_dgram_qlen __read_mostly = 10;
  
-@@ -764,6 +767,10 @@ static int unix_bind(struct socket *sock
+@@ -764,6 +767,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -807,6 +814,9 @@ static int unix_bind(struct socket *sock
+@@ -807,6 +815,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1259,13 +1402,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1283,13 +1427,14 @@
  
  #include "entry.h"
  
-@@ -1418,6 +1421,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1418,6 +1421,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1307,13 +1452,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -742,6 +745,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -742,6 +745,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1331,13 +1477,14 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -713,6 +716,11 @@ sys_ptrace(long request, long pid, long 
+@@ -713,6 +716,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -1409,13 +1556,14 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -459,6 +462,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -459,6 +462,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -1433,13 +1581,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -271,6 +274,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -271,6 +274,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1457,13 +1606,14 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -234,6 +237,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -234,6 +237,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1481,13 +1631,14 @@
  
  #include "ia32priv.h"
  
-@@ -1758,6 +1761,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1758,6 +1761,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1505,13 +1656,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1529,13 +1681,14 @@
  
  #include "ptrace-common.h"
  
-@@ -45,6 +48,11 @@ long compat_sys_ptrace(int request, int 
+@@ -45,6 +48,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22.9-ubuntu1.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22.9-ubuntu1.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.22.9-ubuntu1.diff	(作業コピー)
@@ -3,55 +3,55 @@
 Source code for this patch is "apt-get install linux-source-2.6.22"
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 +++++
- arch/sparc64/kernel/ptrace.c    |   11 +++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 +++++
- fs/compat.c                     |    5 +-
- fs/compat_ioctl.c               |    6 ++
- fs/exec.c                       |   14 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   60 +++++++++++++++++++++++++++++
- fs/namespace.c                  |   38 ++++++++++++++++++
- fs/open.c                       |   21 ++++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |    5 +
+ fs/compat_ioctl.c               |    9 +++
+ fs/exec.c                       |   20 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  112 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   49 +++++++++++++++++
+ fs/open.c                       |   26 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
- include/linux/sched.h           |    9 ++++
- include/linux/syaoran.h         |    7 +--
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |    9 ++++
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 +++++++
- kernel/sys.c                    |   15 +++++++
- kernel/sysctl.c                 |   81 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |    9 ++++
- kernel/time/ntp.c               |    6 ++
- net/core/datagram.c             |    9 ++++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 ++++
- net/ipv6/inet6_hashtables.c     |    6 ++
- net/socket.c                    |   28 +++++++++++++
- net/unix/af_unix.c              |   10 ++++
- 46 files changed, 530 insertions(+), 6 deletions(-)
+ include/linux/sched.h           |    9 +++
+ include/linux/syaoran.h         |    7 +-
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   11 +++
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |   95 +++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   11 +++
+ kernel/time/ntp.c               |    7 ++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    7 ++
+ net/socket.c                    |   41 ++++++++++++++
+ net/unix/af_unix.c              |   15 +++++
+ 46 files changed, 687 insertions(+), 6 deletions(-)
 
---- linux-source-2.6.22-2.6.22.orig/Makefile
-+++ linux-source-2.6.22-2.6.22/Makefile
+--- linux-source-2.6.22.9.orig/Makefile
++++ linux-source-2.6.22.9/Makefile
 @@ -1,7 +1,7 @@
  VERSION = 2
  PATCHLEVEL = 6
@@ -61,8 +61,8 @@
  NAME = Holy Dancing Manatees, Batman!
  
  # *DOCUMENTATION*
---- linux-source-2.6.22-2.6.22.orig/fs/Kconfig
-+++ linux-source-2.6.22-2.6.22/fs/Kconfig
+--- linux-source-2.6.22.9.orig/fs/Kconfig
++++ linux-source-2.6.22.9/fs/Kconfig
 @@ -2074,5 +2074,7 @@ endif
  source "fs/nls/Kconfig"
  source "fs/dlm/Kconfig"
@@ -71,16 +71,16 @@
 +
  endmenu
  
---- linux-source-2.6.22-2.6.22.orig/fs/Makefile
-+++ linux-source-2.6.22-2.6.22/fs/Makefile
+--- linux-source-2.6.22.9.orig/fs/Makefile
++++ linux-source-2.6.22.9/fs/Makefile
 @@ -118,3 +118,5 @@ obj-$(CONFIG_HPPFS)		+= hppfs/
  obj-$(CONFIG_DEBUG_FS)		+= debugfs/
  obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
  obj-$(CONFIG_GFS2_FS)           += gfs2/
 +
 +include $(srctree)/fs/Makefile-2.6.ccs
---- linux-source-2.6.22-2.6.22.orig/fs/attr.c
-+++ linux-source-2.6.22-2.6.22/fs/attr.c
+--- linux-source-2.6.22.9.orig/fs/attr.c
++++ linux-source-2.6.22.9/fs/attr.c
 @@ -14,6 +14,9 @@
  #include <linux/fcntl.h>
  #include <linux/quotaops.h>
@@ -91,13 +91,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry *dentry,
+@@ -145,12 +148,28 @@ int notify_change(struct dentry *dentry,
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, mnt, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -106,14 +110,18 @@
  		if (!error)
  			error = security_inode_setattr(dentry, mnt, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
  			    (ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid))
---- linux-source-2.6.22-2.6.22.orig/fs/compat.c
-+++ linux-source-2.6.22-2.6.22/fs/compat.c
+--- linux-source-2.6.22.9.orig/fs/compat.c
++++ linux-source-2.6.22.9/fs/compat.c
 @@ -55,6 +55,9 @@
  #include <asm/mmu_context.h>
  #include <asm/ioctls.h>
@@ -133,8 +141,8 @@
  	if (retval >= 0) {
  		free_arg_pages(bprm);
  
---- linux-source-2.6.22-2.6.22.orig/fs/compat_ioctl.c
-+++ linux-source-2.6.22-2.6.22/fs/compat_ioctl.c
+--- linux-source-2.6.22.9.orig/fs/compat_ioctl.c
++++ linux-source-2.6.22.9/fs/compat_ioctl.c
 @@ -113,6 +113,9 @@
  #include <linux/dvb/frontend.h>
  #include <linux/dvb/video.h>
@@ -145,18 +153,21 @@
  
  static int do_ioctl32_pointer(unsigned int fd, unsigned int cmd,
  			      unsigned long arg, struct file *f)
-@@ -3566,6 +3569,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -3566,6 +3569,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
---- linux-source-2.6.22-2.6.22.orig/fs/exec.c
-+++ linux-source-2.6.22-2.6.22/fs/exec.c
+--- linux-source-2.6.22.9.orig/fs/exec.c
++++ linux-source-2.6.22.9/fs/exec.c
 @@ -59,6 +59,10 @@
  #include <linux/kmod.h>
  #endif
@@ -168,39 +179,45 @@
  int core_uses_pid;
  char core_pattern[CORENAME_MAX_SIZE] = "core";
  int suid_dumpable = 0;
-@@ -145,6 +149,11 @@ asmlinkage long sys_uselib(const char __
+@@ -145,6 +149,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -490,6 +499,9 @@ struct file *open_exec(const char *name)
+@@ -490,6 +501,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1212,7 +1224,7 @@ int do_execve(char * filename,
+@@ -1212,7 +1230,7 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
  	if (retval >= 0) {
  		free_arg_pages(bprm);
  
---- linux-source-2.6.22-2.6.22.orig/fs/fcntl.c
-+++ linux-source-2.6.22-2.6.22/fs/fcntl.c
+--- linux-source-2.6.22.9.orig/fs/fcntl.c
++++ linux-source-2.6.22.9/fs/fcntl.c
 @@ -22,6 +22,9 @@
  #include <asm/poll.h>
  #include <asm/siginfo.h>
@@ -211,19 +228,21 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -213,6 +216,10 @@ static int setfl(int fd, struct file * f
+@@ -213,6 +216,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (((arg ^ filp->f_flags) & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
  	if ((arg & O_NOATIME) && !(filp->f_flags & O_NOATIME))
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
---- linux-source-2.6.22-2.6.22.orig/fs/ioctl.c
-+++ linux-source-2.6.22-2.6.22/fs/ioctl.c
+--- linux-source-2.6.22.9.orig/fs/ioctl.c
++++ linux-source-2.6.22.9/fs/ioctl.c
 @@ -16,6 +16,9 @@
  
  #include <asm/uaccess.h>
@@ -234,18 +253,19 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -25,6 +28,9 @@ static long do_ioctl(struct file *filp, 
+@@ -25,6 +28,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
  		error = filp->f_op->unlocked_ioctl(filp, cmd, arg);
---- linux-source-2.6.22-2.6.22.orig/fs/namei.c
-+++ linux-source-2.6.22-2.6.22/fs/namei.c
+--- linux-source-2.6.22.9.orig/fs/namei.c
++++ linux-source-2.6.22.9/fs/namei.c
 @@ -36,6 +36,10 @@
  
  #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
@@ -257,29 +277,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1540,6 +1544,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1540,6 +1544,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, nd ? nd->mnt : NULL, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1595,6 +1602,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1595,6 +1606,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1645,6 +1657,9 @@ static int open_namei_create(struct name
+@@ -1645,6 +1663,9 @@ static int open_namei_create(struct name
  	return may_open(nd, 0, flag & ~O_TRUNC);
  }
  
@@ -289,141 +315,187 @@
  /*
   *	open_namei()
   *
-@@ -1906,6 +1921,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1906,6 +1927,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1924,10 +1945,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1924,10 +1955,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
  					  mode, new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
  					  mode, 0);
  			break;
-@@ -1997,6 +2024,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1997,6 +2050,12 @@ asmlinkage long sys_mkdirat(int dfd, con
  
  	if (!IS_POSIXACL(nd.dentry->d_inode))
  		mode &= ~current->fs->umask;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_mkdir(nd.dentry->d_inode, dentry, nd.mnt, mode);
  	dput(dentry);
  out_unlock:
-@@ -2105,6 +2135,9 @@ static long do_rmdir(int dfd, const char
+@@ -2105,6 +2164,12 @@ static long do_rmdir(int dfd, const char
  	error = PTR_ERR(dentry);
  	if (IS_ERR(dentry))
  		goto exit2;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_rmdir(nd.dentry->d_inode, dentry, nd.mnt);
  	dput(dentry);
  exit2:
-@@ -2164,6 +2197,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2164,6 +2229,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2185,6 +2221,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2185,6 +2254,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry, nd.mnt);
  	exit2:
  		dput(dentry);
-@@ -2250,6 +2289,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2250,6 +2327,10 @@ asmlinkage long sys_symlinkat(const char
  	char * to;
  	struct dentry *dentry;
  	struct nameidata nd;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2267,6 +2309,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2267,6 +2348,12 @@ asmlinkage long sys_symlinkat(const char
  	if (IS_ERR(dentry))
  		goto out_unlock;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_symlink(nd.dentry->d_inode, dentry, nd.mnt, from,
  			    S_IALLUGO);
  	dput(dentry);
-@@ -2341,6 +2386,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2341,6 +2428,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2364,6 +2412,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2364,6 +2455,13 @@ asmlinkage long sys_linkat(int olddfd, c
  	error = PTR_ERR(new_dentry);
  	if (IS_ERR(new_dentry))
  		goto out_unlock;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
++	if (!error)
++		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
++					     old_nd.mnt, new_dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_link(old_nd.dentry, old_nd.mnt, nd.dentry->d_inode,
  			 new_dentry, nd.mnt);
  	dput(new_dentry);
-@@ -2597,6 +2648,12 @@ static int do_rename(int olddfd, const c
+@@ -2597,6 +2695,16 @@ static int do_rename(int olddfd, const c
  	error = -ENOTEMPTY;
  	if (new_dentry == trap)
  		goto exit5;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
  
  	error = vfs_rename(old_dir->d_inode, old_dentry, oldnd.mnt,
  			   new_dir->d_inode, new_dentry, newnd.mnt);
-@@ -2620,6 +2677,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2620,6 +2728,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
---- linux-source-2.6.22-2.6.22.orig/fs/namespace.c
-+++ linux-source-2.6.22-2.6.22/fs/namespace.c
+--- linux-source-2.6.22.9.orig/fs/namespace.c
++++ linux-source-2.6.22.9/fs/namespace.c
 @@ -28,6 +28,12 @@
  #include <asm/uaccess.h>
  #include <asm/unistd.h>
@@ -437,96 +509,107 @@
  
  /* spinlock for vfsmount related operations, inplace of dcache_lock */
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(vfsmount_lock);
-@@ -550,6 +556,10 @@ static int do_umount(struct vfsmount *mn
+@@ -550,6 +556,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -638,6 +648,9 @@ asmlinkage long sys_umount(char __user *
+@@ -638,6 +649,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -925,6 +938,10 @@ static int do_loopback(struct nameidata 
+@@ -925,6 +940,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1010,6 +1027,10 @@ static int do_move_mount(struct nameidat
+@@ -1010,6 +1030,11 @@ static int do_move_mount(struct nameidat
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
  
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1111,6 +1132,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1111,6 +1136,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1402,6 +1427,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1402,6 +1432,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1678,6 +1710,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1678,6 +1719,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1694,6 +1729,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1694,6 +1739,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
  		goto out1;
---- linux-source-2.6.22-2.6.22.orig/fs/open.c
-+++ linux-source-2.6.22-2.6.22/fs/open.c
+--- linux-source-2.6.22.9.orig/fs/open.c
++++ linux-source-2.6.22.9/fs/open.c
 @@ -26,6 +26,12 @@
  #include <linux/syscalls.h>
  #include <linux/rcupdate.h>
@@ -540,51 +623,56 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -266,6 +272,9 @@ static long do_sys_truncate(const char _
+@@ -266,6 +272,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -319,6 +328,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -319,6 +329,10 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, file->f_path.mnt, length,
-@@ -482,6 +494,12 @@ asmlinkage long sys_chroot(const char __
+@@ -482,6 +496,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1093,6 +1111,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1093,6 +1115,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		/* XXX: this needs locking */
  		tty_vhangup(current->signal->tty);
---- linux-source-2.6.22-2.6.22.orig/fs/proc/Makefile
-+++ linux-source-2.6.22-2.6.22/fs/proc/Makefile
+--- linux-source-2.6.22.9.orig/fs/proc/Makefile
++++ linux-source-2.6.22.9/fs/proc/Makefile
 @@ -15,3 +15,6 @@ proc-$(CONFIG_PROC_KCORE)	+= kcore.o
  proc-$(CONFIG_PROC_VMCORE)	+= vmcore.o
  proc-$(CONFIG_PROC_DEVICETREE)	+= proc_devtree.o
@@ -592,20 +680,20 @@
 +
 +proc-$(CONFIG_SAKURA) += ccs_proc.o
 +proc-$(CONFIG_TOMOYO) += ccs_proc.o
---- linux-source-2.6.22-2.6.22.orig/fs/proc/proc_misc.c
-+++ linux-source-2.6.22-2.6.22/fs/proc/proc_misc.c
+--- linux-source-2.6.22.9.orig/fs/proc/proc_misc.c
++++ linux-source-2.6.22.9/fs/proc/proc_misc.c
 @@ -753,4 +753,9 @@ void __init proc_misc_init(void)
  			entry->proc_fops = &proc_sysrq_trigger_operations;
  	}
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.22.9 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.22.9 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
---- linux-source-2.6.22-2.6.22.orig/include/linux/init_task.h
-+++ linux-source-2.6.22-2.6.22/include/linux/init_task.h
+--- linux-source-2.6.22.9.orig/include/linux/init_task.h
++++ linux-source-2.6.22.9/include/linux/init_task.h
 @@ -169,6 +169,10 @@ extern struct group_info init_groups;
  	},								\
  	INIT_TRACE_IRQFLAGS						\
@@ -617,8 +705,8 @@
  }
  
  
---- linux-source-2.6.22-2.6.22.orig/include/linux/sched.h
-+++ linux-source-2.6.22-2.6.22/include/linux/sched.h
+--- linux-source-2.6.22.9.orig/include/linux/sched.h
++++ linux-source-2.6.22.9/include/linux/sched.h
 @@ -27,6 +27,11 @@
  #define CLONE_NEWUTS		0x04000000	/* New utsname group? */
  #define CLONE_NEWIPC		0x08000000	/* New ipcs */
@@ -642,8 +730,8 @@
  };
  
  static inline pid_t process_group(struct task_struct *tsk)
---- linux-source-2.6.22-2.6.22.orig/include/linux/syaoran.h
-+++ linux-source-2.6.22-2.6.22/include/linux/syaoran.h
+--- linux-source-2.6.22.9.orig/include/linux/syaoran.h
++++ linux-source-2.6.22.9/include/linux/syaoran.h
 @@ -161,7 +161,7 @@ static int fs_mkdir(const char *pathname
  	struct dentry *dentry = lookup_create2(pathname, base, 1);
  	int error = PTR_ERR(dentry);
@@ -672,8 +760,8 @@
  #else
  		error = vfs_symlink(base->d_inode, dentry, oldname);
  #endif
---- linux-source-2.6.22-2.6.22.orig/kernel/compat.c
-+++ linux-source-2.6.22-2.6.22/kernel/compat.c
+--- linux-source-2.6.22.9.orig/kernel/compat.c
++++ linux-source-2.6.22.9/kernel/compat.c
 @@ -25,6 +25,9 @@
  #include <linux/posix-timers.h>
  
@@ -684,18 +772,19 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -869,6 +872,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -869,6 +872,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
---- linux-source-2.6.22-2.6.22.orig/kernel/kexec.c
-+++ linux-source-2.6.22-2.6.22/kernel/kexec.c
+--- linux-source-2.6.22.9.orig/kernel/kexec.c
++++ linux-source-2.6.22.9/kernel/kexec.c
 @@ -28,6 +28,9 @@
  #include <asm/io.h>
  #include <asm/system.h>
@@ -706,18 +795,19 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -924,6 +927,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -924,6 +927,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
  	 * Verify we have a legal set of flags
---- linux-source-2.6.22-2.6.22.orig/kernel/kmod.c
-+++ linux-source-2.6.22-2.6.22/kernel/kmod.c
+--- linux-source-2.6.22.9.orig/kernel/kmod.c
++++ linux-source-2.6.22.9/kernel/kmod.c
 @@ -170,6 +170,11 @@ static int ____call_usermodehelper(void 
  	 */
  	set_user_nice(current, 0);
@@ -730,8 +820,8 @@
  	retval = -EPERM;
  	if (current->fs->root)
  		retval = kernel_execve(sub_info->path,
---- linux-source-2.6.22-2.6.22.orig/kernel/module.c
-+++ linux-source-2.6.22-2.6.22/kernel/module.c
+--- linux-source-2.6.22.9.orig/kernel/module.c
++++ linux-source-2.6.22.9/kernel/module.c
 @@ -45,6 +45,9 @@
  #include <asm/semaphore.h>
  #include <asm/cacheflush.h>
@@ -742,28 +832,30 @@
  
  extern int module_sysfs_initialized;
  
-@@ -665,6 +668,9 @@ sys_delete_module(const char __user *nam
+@@ -665,6 +668,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
-@@ -1988,6 +1994,9 @@ sys_init_module(void __user *umod,
+@@ -1988,6 +1995,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Only one module load at a time, please */
  	if (mutex_lock_interruptible(&module_mutex) != 0)
---- linux-source-2.6.22-2.6.22.orig/kernel/sched.c
-+++ linux-source-2.6.22-2.6.22/kernel/sched.c
+--- linux-source-2.6.22.9.orig/kernel/sched.c
++++ linux-source-2.6.22.9/kernel/sched.c
 @@ -56,6 +56,9 @@
  
  #include <asm/tlb.h>
@@ -774,18 +866,19 @@
  
  /*
   * Scheduler clock - returns current time in nanosec units.
-@@ -4245,6 +4248,9 @@ int can_nice(const struct task_struct *p
+@@ -4245,6 +4248,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
  	 * Setpriority might change our priority at the same moment.
---- linux-source-2.6.22-2.6.22.orig/kernel/signal.c
-+++ linux-source-2.6.22-2.6.22/kernel/signal.c
+--- linux-source-2.6.22.9.orig/kernel/signal.c
++++ linux-source-2.6.22.9/kernel/signal.c
 @@ -32,6 +32,9 @@
  #include <asm/unistd.h>
  #include <asm/siginfo.h>
@@ -796,41 +889,47 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2159,6 +2162,10 @@ asmlinkage long
+@@ -2159,6 +2162,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2217,6 +2224,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2217,6 +2226,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2230,6 +2241,10 @@ sys_tkill(int pid, int sig)
+@@ -2230,6 +2245,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
  }
---- linux-source-2.6.22-2.6.22.orig/kernel/sys.c
-+++ linux-source-2.6.22-2.6.22/kernel/sys.c
+--- linux-source-2.6.22.9.orig/kernel/sys.c
++++ linux-source-2.6.22.9/kernel/sys.c
 @@ -39,6 +39,9 @@
  #include <asm/uaccess.h>
  #include <asm/io.h>
@@ -841,48 +940,54 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -662,6 +665,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -662,6 +665,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > PRIO_USER || which < PRIO_PROCESS)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -892,6 +898,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -892,6 +901,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1867,6 +1876,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1867,6 +1880,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1912,6 +1924,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1912,6 +1929,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
  	errno = -EFAULT;
---- linux-source-2.6.22-2.6.22.orig/kernel/sysctl.c
-+++ linux-source-2.6.22-2.6.22/kernel/sysctl.c
+--- linux-source-2.6.22.9.orig/kernel/sysctl.c
++++ linux-source-2.6.22.9/kernel/sysctl.c
 @@ -48,6 +48,9 @@
  
  #include <asm/uaccess.h>
@@ -893,25 +998,29 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1138,6 +1141,81 @@ char *sysctl_pathname(ctl_table *table, 
+@@ -1138,6 +1141,93 @@ char *sysctl_pathname(ctl_table *table, 
  EXPORT_SYMBOL(sysctl_pathname);
  
  #ifdef CONFIG_SYSCTL_SYSCALL
 +
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -929,30 +1038,38 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", n);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", n);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				name++;
@@ -975,18 +1092,20 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1154,6 +1232,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1154,6 +1244,11 @@ int do_sysctl(int __user *name, int nlen
  
  	for (head = sysctl_head_next(NULL); head;
  			head = sysctl_head_next(head)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table);
  		if (error != -ENOTDIR) {
---- linux-source-2.6.22-2.6.22.orig/kernel/time.c
-+++ linux-source-2.6.22-2.6.22/kernel/time.c
+--- linux-source-2.6.22.9.orig/kernel/time.c
++++ linux-source-2.6.22.9/kernel/time.c
 @@ -38,6 +38,9 @@
  
  #include <asm/uaccess.h>
@@ -997,28 +1116,30 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -90,6 +93,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -90,6 +93,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -160,6 +166,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -160,6 +167,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
---- linux-source-2.6.22-2.6.22.orig/kernel/time/ntp.c
-+++ linux-source-2.6.22-2.6.22/kernel/time/ntp.c
+--- linux-source-2.6.22.9.orig/kernel/time/ntp.c
++++ linux-source-2.6.22.9/kernel/time/ntp.c
 @@ -16,6 +16,9 @@
  
  #include <asm/div64.h>
@@ -1029,18 +1150,19 @@
  
  /*
   * Timekeeping variables
-@@ -203,6 +206,9 @@ int do_adjtimex(struct timex *txc)
+@@ -203,6 +206,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Now we validate the data before disabling interrupts */
  
---- linux-source-2.6.22-2.6.22.orig/net/core/datagram.c
-+++ linux-source-2.6.22-2.6.22/net/core/datagram.c
+--- linux-source-2.6.22.9.orig/net/core/datagram.c
++++ linux-source-2.6.22.9/net/core/datagram.c
 @@ -56,6 +56,11 @@
  #include <net/sock.h>
  #include <net/tcp_states.h>
@@ -1053,19 +1175,21 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
  			return skb;
  
---- linux-source-2.6.22-2.6.22.orig/net/ipv4/inet_connection_sock.c
-+++ linux-source-2.6.22-2.6.22/net/ipv4/inet_connection_sock.c
+--- linux-source-2.6.22.9.orig/net/ipv4/inet_connection_sock.c
++++ linux-source-2.6.22.9/net/ipv4/inet_connection_sock.c
 @@ -23,6 +23,9 @@
  #include <net/route.h>
  #include <net/tcp_states.h>
@@ -1076,18 +1200,19 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -85,6 +88,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -85,6 +88,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
---- linux-source-2.6.22-2.6.22.orig/net/ipv4/inet_hashtables.c
-+++ linux-source-2.6.22-2.6.22/net/ipv4/inet_hashtables.c
+--- linux-source-2.6.22.9.orig/net/ipv4/inet_hashtables.c
++++ linux-source-2.6.22.9/net/ipv4/inet_hashtables.c
 @@ -22,6 +22,9 @@
  #include <net/inet_connection_sock.h>
  #include <net/inet_hashtables.h>
@@ -1098,18 +1223,19 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -292,6 +295,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -292,6 +295,10 @@ int inet_hash_connect(struct inet_timewa
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
  
---- linux-source-2.6.22-2.6.22.orig/net/ipv4/udp.c
-+++ linux-source-2.6.22-2.6.22/net/ipv4/udp.c
+--- linux-source-2.6.22.9.orig/net/ipv4/udp.c
++++ linux-source-2.6.22.9/net/ipv4/udp.c
 @@ -102,6 +102,9 @@
  #include <net/checksum.h>
  #include <net/xfrm.h>
@@ -1120,28 +1246,30 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -162,6 +165,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -162,6 +165,10 @@ int __udp_lib_get_port(struct sock *sk, 
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -181,6 +187,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -181,6 +188,10 @@ int __udp_lib_get_port(struct sock *sk, 
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (! __udp_lib_lport_inuse(result, udptable))
  				break;
  		}
---- linux-source-2.6.22-2.6.22.orig/net/ipv6/inet6_hashtables.c
-+++ linux-source-2.6.22-2.6.22/net/ipv6/inet6_hashtables.c
+--- linux-source-2.6.22.9.orig/net/ipv6/inet6_hashtables.c
++++ linux-source-2.6.22.9/net/ipv6/inet6_hashtables.c
 @@ -21,6 +21,9 @@
  #include <net/inet_hashtables.h>
  #include <net/inet6_hashtables.h>
@@ -1152,18 +1280,19 @@
  
  void __inet6_hash(struct inet_hashinfo *hashinfo,
  				struct sock *sk)
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
  
---- linux-source-2.6.22-2.6.22.orig/net/socket.c
-+++ linux-source-2.6.22-2.6.22/net/socket.c
+--- linux-source-2.6.22.9.orig/net/socket.c
++++ linux-source-2.6.22.9/net/socket.c
 @@ -93,6 +93,11 @@
  #include <net/sock.h>
  #include <linux/netfilter.h>
@@ -1176,53 +1305,64 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
  			 unsigned long nr_segs, loff_t pos);
-@@ -553,6 +558,9 @@ static inline int __sock_sendmsg(struct 
+@@ -553,6 +558,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
-@@ -1105,6 +1113,10 @@ static int __sock_create(int family, int
+@@ -1105,6 +1116,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1333,6 +1345,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1333,6 +1350,13 @@ asmlinkage long sys_bind(int fd, struct 
  			err = security_socket_bind(sock,
  						   (struct sockaddr *)address,
  						   addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  						      (struct sockaddr *)
-@@ -1362,6 +1377,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1362,6 +1386,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1426,6 +1444,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1426,6 +1454,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1230,19 +1370,21 @@
  	if (upeer_sockaddr) {
  		if (newsock->ops->getname(newsock, (struct sockaddr *)address,
  					  &len, 2) < 0) {
-@@ -1490,6 +1514,10 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1490,6 +1525,12 @@ asmlinkage long sys_connect(int fd, stru
  	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 +	/***** TOMOYO Linux start. *****/
-+	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen);
-+	if (err) goto out_put;
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  
  	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
  				 sock->file->f_flags);
---- linux-source-2.6.22-2.6.22.orig/net/unix/af_unix.c
-+++ linux-source-2.6.22-2.6.22/net/unix/af_unix.c
+--- linux-source-2.6.22.9.orig/net/unix/af_unix.c
++++ linux-source-2.6.22.9/net/unix/af_unix.c
 @@ -115,6 +115,9 @@
  #include <linux/mount.h>
  #include <net/checksum.h>
@@ -1253,29 +1395,34 @@
  
  int sysctl_unix_max_dgram_qlen __read_mostly = 10;
  
-@@ -764,6 +767,10 @@ static int unix_bind(struct socket *sock
+@@ -764,6 +767,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -807,6 +814,9 @@ static int unix_bind(struct socket *sock
+@@ -807,6 +815,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt, mode, 0);
  		if (err)
  			goto out_mknod_dput;
---- linux-source-2.6.22-2.6.22.orig/arch/alpha/kernel/ptrace.c
-+++ linux-source-2.6.22-2.6.22/arch/alpha/kernel/ptrace.c
+--- linux-source-2.6.22.9.orig/arch/alpha/kernel/ptrace.c
++++ linux-source-2.6.22.9/arch/alpha/kernel/ptrace.c
 @@ -20,6 +20,9 @@
  #include <asm/pgtable.h>
  #include <asm/system.h>
@@ -1286,20 +1433,21 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	DBG(DBG_MEM, ("request=%ld pid=%ld addr=0x%lx data=0x%lx\n",
---- linux-source-2.6.22-2.6.22.orig/arch/ia64/kernel/ptrace.c
-+++ linux-source-2.6.22-2.6.22/arch/ia64/kernel/ptrace.c
+--- linux-source-2.6.22.9.orig/arch/ia64/kernel/ptrace.c
++++ linux-source-2.6.22.9/arch/ia64/kernel/ptrace.c
 @@ -28,6 +28,9 @@
  #ifdef CONFIG_PERFMON
  #include <asm/perfmon.h>
@@ -1310,20 +1458,21 @@
  
  #include "entry.h"
  
-@@ -1418,6 +1421,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1418,6 +1421,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	ret = -EPERM;
---- linux-source-2.6.22-2.6.22.orig/arch/m32r/kernel/ptrace.c
-+++ linux-source-2.6.22-2.6.22/arch/m32r/kernel/ptrace.c
+--- linux-source-2.6.22.9.orig/arch/m32r/kernel/ptrace.c
++++ linux-source-2.6.22.9/arch/m32r/kernel/ptrace.c
 @@ -32,6 +32,9 @@
  #include <asm/system.h>
  #include <asm/processor.h>
@@ -1334,20 +1483,21 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -742,6 +745,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -742,6 +745,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
---- linux-source-2.6.22-2.6.22.orig/arch/s390/kernel/ptrace.c
-+++ linux-source-2.6.22-2.6.22/arch/s390/kernel/ptrace.c
+--- linux-source-2.6.22.9.orig/arch/s390/kernel/ptrace.c
++++ linux-source-2.6.22.9/arch/s390/kernel/ptrace.c
 @@ -41,6 +41,9 @@
  #include <asm/system.h>
  #include <asm/uaccess.h>
@@ -1358,20 +1508,21 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -713,6 +716,11 @@ sys_ptrace(long request, long pid, long 
+@@ -713,6 +716,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
  		 ret = ptrace_traceme();
---- linux-source-2.6.22-2.6.22.orig/arch/sparc/kernel/ptrace.c
-+++ linux-source-2.6.22-2.6.22/arch/sparc/kernel/ptrace.c
+--- linux-source-2.6.22.9.orig/arch/sparc/kernel/ptrace.c
++++ linux-source-2.6.22.9/arch/sparc/kernel/ptrace.c
 @@ -23,6 +23,9 @@
  #include <asm/pgtable.h>
  #include <asm/system.h>
@@ -1397,8 +1548,8 @@
  
  	lock_kernel();
  #ifdef DEBUG_PTRACE
---- linux-source-2.6.22-2.6.22.orig/arch/sparc64/kernel/ptrace.c
-+++ linux-source-2.6.22-2.6.22/arch/sparc64/kernel/ptrace.c
+--- linux-source-2.6.22.9.orig/arch/sparc64/kernel/ptrace.c
++++ linux-source-2.6.22.9/arch/sparc64/kernel/ptrace.c
 @@ -32,6 +32,9 @@
  #include <asm/spitfire.h>
  #include <asm/page.h>
@@ -1424,8 +1575,8 @@
  
  	if (test_thread_flag(TIF_32BIT)) {
  		addr &= 0xffffffffUL;
---- linux-source-2.6.22-2.6.22.orig/kernel/ptrace.c
-+++ linux-source-2.6.22-2.6.22/kernel/ptrace.c
+--- linux-source-2.6.22.9.orig/kernel/ptrace.c
++++ linux-source-2.6.22.9/kernel/ptrace.c
 @@ -22,6 +22,9 @@
  
  #include <asm/pgtable.h>
@@ -1436,20 +1587,21 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -459,6 +462,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -459,6 +462,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
  		ret = ptrace_traceme();
---- linux-source-2.6.22-2.6.22.orig/arch/x86_64/ia32/ptrace32.c
-+++ linux-source-2.6.22-2.6.22/arch/x86_64/ia32/ptrace32.c
+--- linux-source-2.6.22.9.orig/arch/x86_64/ia32/ptrace32.c
++++ linux-source-2.6.22.9/arch/x86_64/ia32/ptrace32.c
 @@ -26,6 +26,9 @@
  #include <asm/i387.h>
  #include <asm/fpu32.h>
@@ -1460,20 +1612,21 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -234,6 +237,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -234,6 +237,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	switch (request) { 
  	case PTRACE_TRACEME:
---- linux-source-2.6.22-2.6.22.orig/arch/sh64/kernel/ptrace.c
-+++ linux-source-2.6.22-2.6.22/arch/sh64/kernel/ptrace.c
+--- linux-source-2.6.22.9.orig/arch/sh64/kernel/ptrace.c
++++ linux-source-2.6.22.9/arch/sh64/kernel/ptrace.c
 @@ -35,6 +35,9 @@
  #include <asm/system.h>
  #include <asm/processor.h>
@@ -1484,20 +1637,21 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -271,6 +274,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -271,6 +274,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (first_call) {
---- linux-source-2.6.22-2.6.22.orig/arch/ia64/ia32/sys_ia32.c
-+++ linux-source-2.6.22-2.6.22/arch/ia64/ia32/sys_ia32.c
+--- linux-source-2.6.22.9.orig/arch/ia64/ia32/sys_ia32.c
++++ linux-source-2.6.22.9/arch/ia64/ia32/sys_ia32.c
 @@ -56,6 +56,9 @@
  #include <asm/types.h>
  #include <asm/uaccess.h>
@@ -1508,20 +1662,21 @@
  
  #include "ia32priv.h"
  
-@@ -1758,6 +1761,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1758,6 +1761,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
---- linux-source-2.6.22-2.6.22.orig/arch/mips/kernel/ptrace32.c
-+++ linux-source-2.6.22-2.6.22/arch/mips/kernel/ptrace32.c
+--- linux-source-2.6.22.9.orig/arch/mips/kernel/ptrace32.c
++++ linux-source-2.6.22.9/arch/mips/kernel/ptrace32.c
 @@ -35,6 +35,9 @@
  #include <asm/system.h>
  #include <asm/uaccess.h>
@@ -1532,20 +1687,21 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  #if 0
  	printk("ptrace(r=%d,pid=%d,addr=%08lx,data=%08lx)\n",
---- linux-source-2.6.22-2.6.22.orig/arch/powerpc/kernel/ptrace32.c
-+++ linux-source-2.6.22-2.6.22/arch/powerpc/kernel/ptrace32.c
+--- linux-source-2.6.22.9.orig/arch/powerpc/kernel/ptrace32.c
++++ linux-source-2.6.22.9/arch/powerpc/kernel/ptrace32.c
 @@ -32,6 +32,9 @@
  #include <asm/page.h>
  #include <asm/pgtable.h>
@@ -1556,13 +1712,14 @@
  
  #include "ptrace-common.h"
  
-@@ -45,6 +48,11 @@ long compat_sys_ptrace(int request, int 
+@@ -45,6 +48,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.9-67.0.7.EL.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.9-67.0.7.EL.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.9-67.0.7.EL.diff	(作業コピー)
@@ -3,62 +3,62 @@
 Source code for this patch is http://ftp.riken.jp/Linux/centos/4.6/updates/SRPMS/kernel-2.6.9-67.0.7.EL.src.rpm
 ---
  Makefile                           |    2 
- arch/alpha/kernel/ptrace.c         |    8 +++
- arch/arm/kernel/ptrace.c           |    8 +++
- arch/arm26/kernel/ptrace.c         |    8 +++
- arch/cris/arch-v10/kernel/ptrace.c |    8 +++
- arch/h8300/kernel/ptrace.c         |    8 +++
- arch/i386/kernel/ptrace.c          |    8 +++
- arch/ia64/ia32/sys_ia32.c          |    8 +++
- arch/ia64/kernel/ptrace.c          |    8 +++
- arch/m32r/kernel/ptrace.c          |    8 +++
- arch/m68k/kernel/ptrace.c          |    8 +++
- arch/m68knommu/kernel/ptrace.c     |    8 +++
- arch/mips/kernel/ptrace.c          |    8 +++
- arch/mips/kernel/ptrace32.c        |    8 +++
- arch/parisc/kernel/ptrace.c        |    8 +++
- arch/ppc/kernel/ptrace.c           |    8 +++
- arch/ppc64/kernel/ptrace.c         |    8 +++
- arch/ppc64/kernel/ptrace32.c       |    8 +++
- arch/s390/kernel/ptrace.c          |    8 +++
- arch/sh/kernel/ptrace.c            |    8 +++
- arch/sh64/kernel/ptrace.c          |    8 +++
- arch/sparc/kernel/ptrace.c         |   11 ++++
- arch/sparc64/kernel/ptrace.c       |   11 ++++
- arch/um/kernel/ptrace.c            |    8 +++
- arch/v850/kernel/ptrace.c          |    8 +++
- arch/x86_64/ia32/ptrace32.c        |    8 +++
- arch/x86_64/kernel/ptrace.c        |    8 +++
+ arch/alpha/kernel/ptrace.c         |    9 ++
+ arch/arm/kernel/ptrace.c           |    9 ++
+ arch/arm26/kernel/ptrace.c         |    9 ++
+ arch/cris/arch-v10/kernel/ptrace.c |    9 ++
+ arch/h8300/kernel/ptrace.c         |    9 ++
+ arch/i386/kernel/ptrace.c          |    9 ++
+ arch/ia64/ia32/sys_ia32.c          |    9 ++
+ arch/ia64/kernel/ptrace.c          |    9 ++
+ arch/m32r/kernel/ptrace.c          |    9 ++
+ arch/m68k/kernel/ptrace.c          |    9 ++
+ arch/m68knommu/kernel/ptrace.c     |    9 ++
+ arch/mips/kernel/ptrace.c          |    9 ++
+ arch/mips/kernel/ptrace32.c        |    9 ++
+ arch/parisc/kernel/ptrace.c        |    9 ++
+ arch/ppc/kernel/ptrace.c           |    9 ++
+ arch/ppc64/kernel/ptrace.c         |    9 ++
+ arch/ppc64/kernel/ptrace32.c       |    9 ++
+ arch/s390/kernel/ptrace.c          |    9 ++
+ arch/sh/kernel/ptrace.c            |    9 ++
+ arch/sh64/kernel/ptrace.c          |    9 ++
+ arch/sparc/kernel/ptrace.c         |   11 +++
+ arch/sparc64/kernel/ptrace.c       |   11 +++
+ arch/um/kernel/ptrace.c            |    9 ++
+ arch/v850/kernel/ptrace.c          |    9 ++
+ arch/x86_64/ia32/ptrace32.c        |    9 ++
+ arch/x86_64/kernel/ptrace.c        |    9 ++
  fs/Kconfig                         |    2 
  fs/Makefile                        |    1 
- fs/attr.c                          |   11 ++++
- fs/compat.c                        |   13 ++++-
- fs/exec.c                          |   20 +++++++
- fs/fcntl.c                         |    7 ++
- fs/ioctl.c                         |    6 ++
- fs/namei.c                         |   61 +++++++++++++++++++++++
- fs/namespace.c                     |   42 +++++++++++++++-
- fs/open.c                          |   22 ++++++++
- fs/proc/Makefile                   |    3 +
+ fs/attr.c                          |   19 +++++
+ fs/compat.c                        |   16 ++++-
+ fs/exec.c                          |   26 +++++++-
+ fs/fcntl.c                         |    8 ++
+ fs/ioctl.c                         |    7 ++
+ fs/namei.c                         |  118 +++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                     |   53 ++++++++++++++++
+ fs/open.c                          |   28 ++++++++
+ fs/proc/Makefile                   |    3 
  fs/proc/proc_misc.c                |    5 +
  include/linux/init_task.h          |    4 +
- include/linux/sched.h              |    9 +++
- kernel/compat.c                    |    6 ++
+ include/linux/sched.h              |    9 ++
+ kernel/compat.c                    |    7 ++
  kernel/kmod.c                      |    5 +
- kernel/module.c                    |   11 +++-
- kernel/sched.c                     |    6 ++
- kernel/signal.c                    |   16 ++++++
- kernel/sys.c                       |   15 +++++
- kernel/sysctl.c                    |   95 ++++++++++++++++++++++++++++++++++++-
- kernel/time.c                      |   12 ++++
- net/core/datagram.c                |    8 +++
- net/ipv4/tcp_ipv4.c                |    9 +++
- net/ipv4/udp.c                     |    9 +++
- net/ipv6/tcp_ipv6.c                |    6 ++
- net/ipv6/udp.c                     |    9 +++
- net/socket.c                       |   30 ++++++++++-
- net/unix/af_unix.c                 |   10 +++
- 56 files changed, 657 insertions(+), 12 deletions(-)
+ kernel/module.c                    |   13 +++-
+ kernel/sched.c                     |    7 ++
+ kernel/signal.c                    |   22 ++++++
+ kernel/sys.c                       |   21 ++++++
+ kernel/sysctl.c                    |  113 +++++++++++++++++++++++++++++++++++
+ kernel/time.c                      |   15 ++++
+ net/core/datagram.c                |   10 +++
+ net/ipv4/tcp_ipv4.c                |   11 +++
+ net/ipv4/udp.c                     |   11 +++
+ net/ipv6/tcp_ipv6.c                |    7 ++
+ net/ipv6/udp.c                     |   11 +++
+ net/socket.c                       |   43 ++++++++++++-
+ net/unix/af_unix.c                 |   15 ++++
+ 56 files changed, 838 insertions(+), 12 deletions(-)
 
 --- linux-2.6.9-67.0.7.EL.orig/Makefile
 +++ linux-2.6.9-67.0.7.EL/Makefile
@@ -100,13 +100,17 @@
  
  /* Taken over from the old code... */
  
-@@ -176,12 +179,20 @@ int notify_change(struct dentry * dentry
+@@ -176,12 +179,28 @@ int notify_change(struct dentry * dentry
  	if (inode->i_op && inode->i_op->setattr) {
  		audit_notify_watch(inode, MAY_WRITE);
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -115,8 +119,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -133,17 +141,20 @@
  
  /*
   * Not all architectures have sys_utime, so implement this in terms
-@@ -399,6 +402,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -399,6 +402,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		error = sys_ioctl (fd, cmd, arg);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out; }
++	if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	down_read(&ioctl32_sem);
  
-@@ -1461,8 +1467,11 @@ int compat_do_execve(char * filename,
+@@ -1461,8 +1470,11 @@ int compat_do_execve(char * filename,
  
  	retval = -ENOMEM;
  	bprm = kmalloc(sizeof(*bprm), GFP_KERNEL);
@@ -156,7 +167,7 @@
  	memset(bprm, 0, sizeof(*bprm));
  
  	bprm->p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
-@@ -1506,7 +1515,7 @@ int compat_do_execve(char * filename,
+@@ -1506,7 +1518,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -178,29 +189,35 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  int suid_dumpable = 0;
-@@ -140,6 +144,11 @@ asmlinkage long sys_uselib(const char __
+@@ -140,6 +144,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -494,6 +503,9 @@ struct file *open_exec(const char *name)
+@@ -494,6 +505,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = permission(inode, MAY_EXEC, &nd);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
-@@ -1182,8 +1194,11 @@ int do_execve(char * filename,
+@@ -1182,8 +1200,11 @@ int do_execve(char * filename,
  
  	retval = -ENOMEM;
  	bprm = kmalloc(sizeof(*bprm), GFP_KERNEL);
@@ -213,7 +230,7 @@
  	memset(bprm, 0, sizeof(*bprm));
  
  	bprm->p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
-@@ -1228,7 +1243,8 @@ int do_execve(char * filename,
+@@ -1228,7 +1249,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -235,12 +252,13 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -225,6 +228,10 @@ static int setfl(int fd, struct file * f
+@@ -225,6 +228,11 @@ static int setfl(int fd, struct file * f
  	if (!(arg & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -258,12 +276,13 @@
  
  static int file_ioctl(struct file *filp,unsigned int cmd,unsigned long arg)
  {
-@@ -60,6 +63,9 @@ asmlinkage long sys_ioctl(unsigned int f
+@@ -60,6 +63,10 @@ asmlinkage long sys_ioctl(unsigned int f
  	filp = fget(fd);
  	if (!filp)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	error = security_file_ioctl(filp, cmd, arg);
@@ -281,29 +300,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1309,6 +1313,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1309,6 +1313,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error) {
-@@ -1367,6 +1374,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1367,6 +1378,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1398,6 +1410,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1398,6 +1416,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -313,136 +338,187 @@
  /*
   *	open_namei()
   *
-@@ -1651,6 +1666,12 @@ asmlinkage long sys_mknod(const char __u
+@@ -1651,6 +1672,16 @@ asmlinkage long sys_mknod(const char __u
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1669,10 +1690,16 @@ asmlinkage long sys_mknod(const char __u
+@@ -1669,10 +1700,32 @@ asmlinkage long sys_mknod(const char __u
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1735,6 +1762,9 @@ asmlinkage long sys_mkdir(const char __u
+@@ -1735,6 +1788,13 @@ asmlinkage long sys_mkdir(const char __u
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -1843,6 +1873,9 @@ asmlinkage long sys_rmdir(const char __u
+@@ -1843,6 +1903,13 @@ asmlinkage long sys_rmdir(const char __u
  	dentry = lookup_hash(&nd.last, nd.dentry);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -1897,6 +1930,9 @@ asmlinkage long sys_unlink(const char __
+@@ -1897,6 +1964,10 @@ asmlinkage long sys_unlink(const char __
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -1918,6 +1954,9 @@ asmlinkage long sys_unlink(const char __
+@@ -1918,6 +1989,14 @@ asmlinkage long sys_unlink(const char __
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -1966,6 +2005,9 @@ asmlinkage long sys_symlink(const char _
+@@ -1966,6 +2045,10 @@ asmlinkage long sys_symlink(const char _
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -1982,6 +2024,9 @@ asmlinkage long sys_symlink(const char _
+@@ -1982,6 +2065,13 @@ asmlinkage long sys_symlink(const char _
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2050,6 +2095,9 @@ asmlinkage long sys_link(const char __us
+@@ -2050,6 +2140,10 @@ asmlinkage long sys_link(const char __us
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	to = getname(newname);
  	if (IS_ERR(to))
-@@ -2067,6 +2115,9 @@ asmlinkage long sys_link(const char __us
+@@ -2067,6 +2161,15 @@ asmlinkage long sys_link(const char __us
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2291,6 +2342,13 @@ static inline int do_rename(const char *
+@@ -2291,6 +2394,17 @@ static inline int do_rename(const char *
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2312,6 +2370,9 @@ asmlinkage long sys_rename(const char __
+@@ -2312,6 +2426,10 @@ asmlinkage long sys_rename(const char __
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -462,39 +538,42 @@
  
  extern int __init init_rootfs(void);
  
-@@ -412,6 +418,10 @@ static int do_umount(struct vfsmount *mn
+@@ -412,6 +418,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -507,6 +517,9 @@ asmlinkage long sys_umount(char __user *
+@@ -507,6 +518,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -672,6 +685,10 @@ static int do_loopback(struct nameidata 
+@@ -672,6 +687,11 @@ static int do_loopback(struct nameidata 
  	down_write(&current->namespace->sem);
  	err = -EINVAL;
  	if (check_mnt(nd->mnt) && (!recurse || check_mnt(old_nd.mnt))) {
 +		/***** SAKURA Linux start. *****/
 +		err = -EPERM;
-+		if (ccs_may_mount(nd) < 0) goto out;
++		if (ccs_may_mount(nd))
++			goto out;
 +		/***** SAKURA Linux end. *****/
  		err = -ENOMEM;
  		if (recurse)
  			mnt = copy_tree(old_nd.mnt, old_nd.dentry);
-@@ -694,6 +711,9 @@ static int do_loopback(struct nameidata 
+@@ -694,6 +714,9 @@ static int do_loopback(struct nameidata 
  			mntput(mnt);
  	}
  
@@ -504,59 +583,67 @@
  	up_write(&current->namespace->sem);
  	path_release(&old_nd);
  	return err;
-@@ -749,7 +769,10 @@ static int do_move_mount(struct nameidat
+@@ -749,7 +772,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	down(&nd->dentry->d_inode->i_sem);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -843,6 +866,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -843,6 +870,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	err = graft_tree(newmnt, nd);
-@@ -1064,6 +1091,13 @@ long do_mount(char * dev_name, char * di
+@@ -1064,6 +1096,17 @@ long do_mount(char * dev_name, char * di
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1314,6 +1348,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1314,6 +1357,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1329,6 +1366,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1329,6 +1376,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -577,45 +664,51 @@
  int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
  {
  	int retval = -ENODEV;
-@@ -256,6 +263,9 @@ static inline long do_sys_truncate(const
+@@ -256,6 +263,10 @@ static inline long do_sys_truncate(const
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -309,6 +319,9 @@ static inline long do_sys_ftruncate(unsi
+@@ -309,6 +320,11 @@ static inline long do_sys_ftruncate(unsi
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME);
-@@ -583,6 +596,12 @@ asmlinkage long sys_chroot(const char __
+@@ -583,6 +599,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1078,6 +1097,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1078,6 +1102,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
@@ -637,7 +730,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.9-67.0.7.EL 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.9-67.0.7.EL 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -691,12 +784,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -788,6 +791,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -788,6 +791,10 @@ asmlinkage long compat_sys_stime(compat_
  		return -EPERM;
  	if (get_user(tv.tv_sec, tptr))
  		return -EFAULT;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	tv.tv_nsec = 0;
@@ -727,24 +821,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -547,7 +550,9 @@ sys_delete_module(const char __user *nam
+@@ -547,7 +550,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1878,7 +1883,9 @@ sys_init_module(void __user *umod,
+@@ -1878,7 +1884,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (down_interruptible(&module_mutex) != 0)
@@ -761,12 +857,13 @@
  
  #ifdef CONFIG_NUMA
  #define cpu_to_node_mask(cpu) node_to_cpumask(cpu_to_node(cpu))
-@@ -3217,6 +3220,9 @@ asmlinkage long sys_nice(int increment)
+@@ -3217,6 +3220,10 @@ asmlinkage long sys_nice(int increment)
  {
  	int retval;
  	long nice;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -783,36 +880,42 @@
  
  extern void k_getrusage(struct task_struct *, int, struct rusage *);
  
-@@ -2339,6 +2342,10 @@ asmlinkage long
+@@ -2339,6 +2342,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2369,6 +2376,11 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2369,6 +2378,13 @@ asmlinkage long sys_tgkill(int tgid, int
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	info.si_signo = sig;
  	info.si_errno = 0;
  	info.si_code = SI_TKILL;
-@@ -2409,6 +2421,10 @@ sys_tkill(int pid, int sig)
+@@ -2409,6 +2425,12 @@ sys_tkill(int pid, int sig)
  	if (pid <= 0)
  		return -EINVAL;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	info.si_signo = sig;
  	info.si_errno = 0;
@@ -829,42 +932,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -329,6 +332,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -329,6 +332,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -460,6 +466,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -460,6 +469,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	switch (cmd) {
-@@ -1461,6 +1470,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1461,6 +1474,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1506,6 +1518,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1506,6 +1523,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -881,24 +990,28 @@
  
  #ifdef CONFIG_ROOT_NFS
  #include <linux/nfs_fs.h>
-@@ -1155,6 +1158,87 @@ void __init sysctl_init(void)
+@@ -1155,6 +1158,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -916,35 +1029,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -969,30 +1091,35 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1180,6 +1264,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1180,6 +1277,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1253,6 +1340,12 @@ repeat:
+@@ -1253,6 +1355,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
  						oldval, oldlenp,
-@@ -2280,7 +2373,7 @@ int sysctl_string(ctl_table *table, int 
+@@ -2280,7 +2391,7 @@ int sysctl_string(ctl_table *table, int 
  			len--;
  		((char *) table->data)[len] = 0;
  	}
@@ -1013,32 +1140,35 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -81,6 +84,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -81,6 +84,10 @@ asmlinkage long sys_stime(time_t __user 
  
  	if (!capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (get_user(tv.tv_sec, tptr))
  		return -EFAULT;
  
-@@ -149,6 +155,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -149,6 +156,10 @@ int do_sys_settimeofday(struct timespec 
  
  	if (!capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -219,6 +228,9 @@ int do_adjtimex(struct timex *txc)
+@@ -219,6 +230,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
@@ -1056,12 +1186,14 @@
  
  /*
   *	Is a socket 'connection oriented' ?
-@@ -177,6 +181,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -177,6 +181,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1079,22 +1211,24 @@
  
  extern int sysctl_ip_dynaddr;
  int sysctl_tcp_tw_reuse;
-@@ -229,6 +232,9 @@ static int tcp_v4_get_port(struct sock *
+@@ -229,6 +232,10 @@ static int tcp_v4_get_port(struct sock *
  				rover = low;
  			head = &tcp_bhash[tcp_bhashfn(rover)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			tb_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
-@@ -676,6 +682,9 @@ static int tcp_v4_hash_connect(struct so
+@@ -676,6 +683,10 @@ static int tcp_v4_hash_connect(struct so
   				rover = low;
   			head = &tcp_bhash[tcp_bhashfn(rover)];
   			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next_port;
++			if (ccs_may_autobind(rover))
++				goto next_port;
 +			/***** SAKURA Linux end. *****/
  
   			/* Does not bother with rcv_saddr checks,
@@ -1111,22 +1245,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -145,6 +148,9 @@ static int udp_v4_get_port(struct sock *
+@@ -145,6 +148,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -161,6 +167,9 @@ static int udp_v4_get_port(struct sock *
+@@ -161,6 +168,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1143,12 +1279,13 @@
  
  static void	tcp_v6_send_reset(struct sk_buff *skb);
  static void	tcp_v6_or_send_ack(struct sk_buff *skb, struct open_request *req);
-@@ -145,6 +148,9 @@ static int tcp_v6_get_port(struct sock *
+@@ -145,6 +148,10 @@ static int tcp_v6_get_port(struct sock *
  				rover = low;
  			head = &tcp_bhash[tcp_bhashfn(rover)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			tb_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1165,22 +1302,24 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6);
  
-@@ -87,6 +90,9 @@ static int udp_v6_get_port(struct sock *
+@@ -87,6 +90,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -103,6 +109,9 @@ static int udp_v6_get_port(struct sock *
+@@ -103,6 +110,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1199,55 +1338,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -554,7 +559,9 @@ static inline int __sock_sendmsg(struct 
+@@ -554,7 +559,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1114,6 +1121,10 @@ static int __sock_create(int family, int
+@@ -1114,6 +1124,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1311,6 +1322,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1311,6 +1327,12 @@ asmlinkage long sys_bind(int fd, struct 
  				sockfd_put(sock);
  				return err;
  			}
 +			/***** TOMOYO Linux start. *****/
-+			if ((err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++			err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++							 address, addrlen);
++			if (!err)
 +			/***** TOMOYO Linux end. *****/
  			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
  		}
  		sockfd_put(sock);
-@@ -1341,7 +1355,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1341,7 +1363,10 @@ asmlinkage long sys_listen(int fd, int b
  			sockfd_put(sock);
  			return err;
  		}
 -
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = ccs_socket_listen_permission(sock)) == 0)
++		err = ccs_socket_listen_permission(sock);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err=sock->ops->listen(sock, backlog);
  		sockfd_put(sock);
  	}
-@@ -1392,6 +1408,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1392,6 +1417,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_release;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_release;
 +	}
@@ -1255,13 +1404,16 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1447,7 +1469,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1447,7 +1479,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
@@ -1278,23 +1430,28 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -741,6 +744,10 @@ static int unix_bind(struct socket *sock
+@@ -741,6 +744,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -805,6 +812,9 @@ static int unix_bind(struct socket *sock
+@@ -805,6 +813,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1311,13 +1468,14 @@
  
  #include "proto.h"
  
-@@ -260,6 +263,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -260,6 +263,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1335,13 +1493,14 @@
  
  #include "ptrace.h"
  
-@@ -731,6 +734,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -731,6 +734,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1359,13 +1518,14 @@
  
  #include "ptrace.h"
  
-@@ -668,6 +671,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -668,6 +671,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1383,13 +1543,14 @@
  
  /* cpu depend functions */
  extern long h8300_get_reg(struct task_struct *task, int regno);
-@@ -60,6 +63,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -60,6 +63,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1407,13 +1568,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -237,6 +240,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -237,6 +240,12 @@ asmlinkage int sys_ptrace(long request, 
  	struct user * dummy = NULL;
  	int i, ret;
  	unsigned long __user *datap = (unsigned long __user *)data;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1431,13 +1593,14 @@
  
  #include "entry.h"
  
-@@ -1299,6 +1302,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1299,6 +1302,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1455,13 +1618,14 @@
  
  /*
   * Get the address of the live pt_regs for the specified task.
-@@ -787,6 +790,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -787,6 +790,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1479,13 +1643,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -120,6 +123,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -120,6 +123,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1503,13 +1668,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -104,6 +107,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -104,6 +107,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1527,13 +1693,14 @@
  
  /*
   * Called by kernel/ptrace.c when detaching..
-@@ -49,6 +52,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -49,6 +52,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1551,13 +1718,14 @@
  
  /* PSW bits we allow the debugger to modify */
  #define USER_PSW_BITS	(PSW_N | PSW_V | PSW_CB)
-@@ -84,6 +87,11 @@ long sys_ptrace(long request, pid_t pid,
+@@ -84,6 +87,12 @@ long sys_ptrace(long request, pid_t pid,
  #ifdef DEBUG_PTRACE
  	long oaddr=addr, odata=data;
  #endif
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1575,13 +1743,14 @@
  
  /*
   * Set of msr bits that gdb can change on behalf of a process.
-@@ -239,6 +242,11 @@ int sys_ptrace(long request, long pid, l
+@@ -239,6 +242,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1599,13 +1768,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -54,6 +57,11 @@ int sys_ptrace(long request, long pid, l
+@@ -54,6 +57,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1623,13 +1793,14 @@
  
  #ifdef CONFIG_S390_SUPPORT
  #include "compat_ptrace.h"
-@@ -705,6 +708,11 @@ sys_ptrace(long request, long pid, long 
+@@ -705,6 +708,12 @@ sys_ptrace(long request, long pid, long 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1647,13 +1818,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -85,6 +88,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -85,6 +88,12 @@ asmlinkage int sys_ptrace(long request, 
  	struct task_struct *child;
  	struct user * dummy = NULL;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1671,13 +1843,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -124,6 +127,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -124,6 +127,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1749,13 +1922,14 @@
  
  /*
   * Called by kernel/ptrace.c when detaching..
-@@ -28,6 +31,11 @@ int sys_ptrace(long request, long pid, l
+@@ -28,6 +31,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int i, ret;
 +/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +/***** TOMOYO Linux end. *****/
  
@@ -1773,13 +1947,14 @@
  
  /* Returns the address where the register at REG_OFFS in P is stashed away.  */
  static v850_reg_t *reg_save_addr (unsigned reg_offs, struct task_struct *t)
-@@ -116,6 +119,11 @@ int sys_ptrace(long request, long pid, l
+@@ -116,6 +119,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int rval;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1797,13 +1972,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -193,6 +196,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -193,6 +196,12 @@ asmlinkage long sys_ptrace(long request,
  	struct task_struct *child;
  	long i, ret;
  	unsigned ui;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1821,13 +1997,14 @@
  
  /* 
   * Determines which bits in DCCR the user has access to.
-@@ -50,6 +53,11 @@ sys_ptrace(long request, long pid, long 
+@@ -50,6 +53,12 @@ sys_ptrace(long request, long pid, long 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1845,13 +2022,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -42,6 +45,11 @@ int sys32_ptrace(long request, long pid,
+@@ -42,6 +45,12 @@ int sys32_ptrace(long request, long pid,
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1869,13 +2047,14 @@
  
  /* determines which flags the user has access to. */
  /* 1 = access 0 = no access */
-@@ -232,6 +235,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -232,6 +235,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1893,13 +2072,14 @@
  
  #include "ia32priv.h"
  
-@@ -1769,6 +1772,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1769,6 +1772,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1917,13 +2097,14 @@
  
  /*
   * Tracing a 32-bit process with a 64-bit strace and vice versa will not
-@@ -42,6 +45,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -42,6 +45,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.23-gentoo-r9.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.23-gentoo-r9.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.23-gentoo-r9.diff	(作業コピー)
@@ -1,53 +1,53 @@
-This is TOMOYO Linux patch for Gentoo Linux 2007.0.
+This is TOMOYO Linux patch for Gentoo Linux.
 
 Source code for this patch is "emerge gentoo-sources"
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 +++++
- arch/sparc64/kernel/ptrace.c    |   11 +++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 +++++
- fs/compat.c                     |    5 +-
- fs/compat_ioctl.c               |    6 ++
- fs/exec.c                       |   14 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   60 +++++++++++++++++++++++++++++
- fs/namespace.c                  |   38 ++++++++++++++++++
- fs/open.c                       |   21 ++++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |    5 +
+ fs/compat_ioctl.c               |    9 +++
+ fs/exec.c                       |   20 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  112 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   49 +++++++++++++++++
+ fs/open.c                       |   27 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    9 ++++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
- include/linux/sched.h           |    9 ++++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |    9 ++++
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 +++++++
- kernel/sys.c                    |   15 +++++++
- kernel/sysctl.c                 |   81 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |    9 ++++
- kernel/time/ntp.c               |    6 ++
- net/core/datagram.c             |    9 ++++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 ++++
- net/ipv6/inet6_hashtables.c     |    6 ++
- net/socket.c                    |   28 +++++++++++++
- net/unix/af_unix.c              |   10 ++++
- 45 files changed, 530 insertions(+), 3 deletions(-)
+ include/linux/sched.h           |    9 +++
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   11 +++
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |   95 +++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   11 +++
+ kernel/time/ntp.c               |    7 ++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    7 ++
+ net/socket.c                    |   41 ++++++++++++++
+ net/unix/af_unix.c              |   15 +++++
+ 45 files changed, 684 insertions(+), 3 deletions(-)
 
 --- linux-2.6.23-gentoo-r9.orig/Makefile
 +++ linux-2.6.23-gentoo-r9/Makefile
@@ -72,13 +72,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -96,13 +97,14 @@
  
  #include "entry.h"
  
-@@ -1422,6 +1425,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1422,6 +1425,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -120,13 +122,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -732,6 +735,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -732,6 +735,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -144,13 +147,14 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -706,6 +709,11 @@ sys_ptrace(long request, long pid, long 
+@@ -706,6 +709,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -240,13 +244,17 @@
  
  /* Taken over from the old code... */
  
-@@ -144,12 +147,20 @@ int notify_change(struct dentry * dentry
+@@ -144,12 +147,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -255,8 +263,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -294,12 +306,15 @@
  
  #ifdef CONFIG_SPARC
  #include <asm/fbio.h>
-@@ -3603,6 +3606,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -3603,6 +3606,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
@@ -317,34 +332,40 @@
  int core_uses_pid;
  char core_pattern[CORENAME_MAX_SIZE] = "core";
  int suid_dumpable = 0;
-@@ -145,6 +149,11 @@ asmlinkage long sys_uselib(const char __
+@@ -145,6 +149,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -683,6 +692,9 @@ struct file *open_exec(const char *name)
+@@ -683,6 +694,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1395,7 +1407,7 @@ int do_execve(char * filename,
+@@ -1395,7 +1413,7 @@ int do_execve(char * filename,
  		goto out;
  	bprm->argv_len = env_p - bprm->p;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
  	if (retval >= 0) {
  		/* execve success */
  		free_arg_pages(bprm);
@@ -360,12 +381,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -213,6 +216,10 @@ static int setfl(int fd, struct file * f
+@@ -213,6 +216,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (((arg ^ filp->f_flags) & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -383,12 +406,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -23,6 +26,9 @@ static long do_ioctl(struct file *filp, 
+@@ -23,6 +26,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -406,29 +430,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1557,6 +1561,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1557,6 +1561,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1612,6 +1619,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1612,6 +1623,13 @@ int may_open(struct nameidata *nd, int a
  		if (!is_owner_or_cap(inode))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1661,6 +1673,9 @@ static int open_namei_create(struct name
+@@ -1661,6 +1679,9 @@ static int open_namei_create(struct name
  	return may_open(nd, 0, flag & ~O_TRUNC);
  }
  
@@ -438,135 +468,181 @@
  /*
   *	open_namei()
   *
-@@ -1921,6 +1936,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1921,6 +1942,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1939,10 +1960,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1939,10 +1970,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -2010,6 +2037,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -2010,6 +2063,12 @@ asmlinkage long sys_mkdirat(int dfd, con
  
  	if (!IS_POSIXACL(nd.dentry->d_inode))
  		mode &= ~current->fs->umask;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  	dput(dentry);
  out_unlock:
-@@ -2117,6 +2147,9 @@ static long do_rmdir(int dfd, const char
+@@ -2117,6 +2176,12 @@ static long do_rmdir(int dfd, const char
  	error = PTR_ERR(dentry);
  	if (IS_ERR(dentry))
  		goto exit2;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_rmdir(nd.dentry->d_inode, dentry);
  	dput(dentry);
  exit2:
-@@ -2176,6 +2209,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2176,6 +2241,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2197,6 +2233,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2197,6 +2266,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2261,6 +2300,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2261,6 +2338,10 @@ asmlinkage long sys_symlinkat(const char
  	char * to;
  	struct dentry *dentry;
  	struct nameidata nd;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2278,6 +2320,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2278,6 +2359,12 @@ asmlinkage long sys_symlinkat(const char
  	if (IS_ERR(dentry))
  		goto out_unlock;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  	dput(dentry);
  out_unlock:
-@@ -2350,6 +2395,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2350,6 +2437,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2373,6 +2421,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2373,6 +2464,13 @@ asmlinkage long sys_linkat(int olddfd, c
  	error = PTR_ERR(new_dentry);
  	if (IS_ERR(new_dentry))
  		goto out_unlock;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
++	if (!error)
++		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
++					     old_nd.mnt, new_dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  	dput(new_dentry);
  out_unlock:
-@@ -2598,6 +2649,12 @@ static int do_rename(int olddfd, const c
+@@ -2598,6 +2696,16 @@ static int do_rename(int olddfd, const c
  	error = -ENOTEMPTY;
  	if (new_dentry == trap)
  		goto exit5;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
  
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
-@@ -2621,6 +2678,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2621,6 +2729,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -586,90 +662,101 @@
  
  /* spinlock for vfsmount related operations, inplace of dcache_lock */
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(vfsmount_lock);
-@@ -544,6 +550,10 @@ static int do_umount(struct vfsmount *mn
+@@ -544,6 +550,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -632,6 +642,9 @@ asmlinkage long sys_umount(char __user *
+@@ -632,6 +643,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -919,6 +932,10 @@ static int do_loopback(struct nameidata 
+@@ -919,6 +934,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1004,6 +1021,10 @@ static int do_move_mount(struct nameidat
+@@ -1004,6 +1024,11 @@ static int do_move_mount(struct nameidat
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
  
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1105,6 +1126,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1105,6 +1130,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1396,6 +1421,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1396,6 +1426,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1672,6 +1704,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1672,6 +1713,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1688,6 +1723,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1688,6 +1733,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -689,45 +776,51 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -268,6 +274,9 @@ static long do_sys_truncate(const char _
+@@ -268,6 +274,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto put_write_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -322,6 +331,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -322,6 +332,11 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, file);
-@@ -544,6 +556,12 @@ asmlinkage long sys_chroot(const char __
+@@ -544,6 +559,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1156,6 +1174,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1156,6 +1179,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		/* XXX: this needs locking */
@@ -743,17 +836,13 @@
 +proc-$(CONFIG_TOMOYO) += ccs_proc.o
 --- linux-2.6.23-gentoo-r9.orig/fs/proc/proc_misc.c
 +++ linux-2.6.23-gentoo-r9/fs/proc/proc_misc.c
-@@ -748,4 +748,13 @@ void __init proc_misc_init(void)
+@@ -748,4 +748,9 @@ void __init proc_misc_init(void)
  			entry->proc_fops = &proc_sysrq_trigger_operations;
  	}
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	{
-+		extern void __init CCSProc_Init(void);
-+		CCSProc_Init();
-+		printk("Hook version: 2.6.23-gentoo-r9 2008/03/02\n");
-+	}
++	printk(KERN_INFO "Hook version: 2.6.23-gentoo-r9 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -807,12 +896,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -869,6 +872,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -869,6 +872,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -829,12 +919,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -924,6 +927,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -924,6 +927,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -865,22 +956,24 @@
  
  extern int module_sysfs_initialized;
  
-@@ -662,6 +665,9 @@ sys_delete_module(const char __user *nam
+@@ -662,6 +665,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
-@@ -1981,6 +1987,9 @@ sys_init_module(void __user *umod,
+@@ -1981,6 +1988,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Only one module load at a time, please */
@@ -897,13 +990,14 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -459,6 +462,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -459,6 +462,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -921,12 +1015,13 @@
  
  /*
   * Scheduler clock - returns current time in nanosec units.
-@@ -4062,6 +4065,9 @@ int can_nice(const struct task_struct *p
+@@ -4062,6 +4065,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -943,35 +1038,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2196,6 +2199,10 @@ asmlinkage long
+@@ -2196,6 +2199,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2254,6 +2261,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2254,6 +2263,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2267,6 +2278,10 @@ sys_tkill(int pid, int sig)
+@@ -2267,6 +2282,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -988,42 +1089,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -672,6 +675,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -672,6 +675,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > PRIO_USER || which < PRIO_PROCESS)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -908,6 +914,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -908,6 +917,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1883,6 +1892,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1883,6 +1896,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1928,6 +1940,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1928,6 +1945,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -1040,25 +1147,29 @@
  
  #ifdef CONFIG_X86
  #include <asm/nmi.h>
-@@ -1341,6 +1344,81 @@ struct ctl_table_header *sysctl_head_nex
+@@ -1341,6 +1344,93 @@ struct ctl_table_header *sysctl_head_nex
  }
  
  #ifdef CONFIG_SYSCTL_SYSCALL
 +
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -1076,30 +1187,38 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", n);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", n);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				name++;
@@ -1122,12 +1241,14 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1357,6 +1435,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1357,6 +1447,11 @@ int do_sysctl(int __user *name, int nlen
  
  	for (head = sysctl_head_next(NULL); head;
  			head = sysctl_head_next(head)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table);
@@ -1144,22 +1265,24 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -90,6 +93,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -90,6 +93,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -159,6 +165,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -159,6 +166,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
@@ -1176,12 +1299,13 @@
  
  /*
   * Timekeeping variables
-@@ -246,6 +249,9 @@ int do_adjtimex(struct timex *txc)
+@@ -246,6 +249,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Now we validate the data before disabling interrupts */
@@ -1200,12 +1324,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1223,12 +1349,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -85,6 +88,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -85,6 +88,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1245,12 +1372,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -292,6 +295,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -292,6 +295,10 @@ int inet_hash_connect(struct inet_timewa
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
@@ -1267,22 +1395,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -163,6 +166,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -163,6 +166,10 @@ int __udp_lib_get_port(struct sock *sk, 
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -182,6 +188,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -182,6 +189,10 @@ int __udp_lib_get_port(struct sock *sk, 
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (! __udp_lib_lport_inuse(result, udptable))
  				break;
@@ -1299,12 +1429,13 @@
  
  void __inet6_hash(struct inet_hashinfo *hashinfo,
  				struct sock *sk)
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
  		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
  			spin_lock(&head->lock);
@@ -1323,53 +1454,64 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
  			 unsigned long nr_segs, loff_t pos);
-@@ -552,6 +557,9 @@ static inline int __sock_sendmsg(struct 
+@@ -552,6 +557,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
-@@ -1101,6 +1109,10 @@ static int __sock_create(int family, int
+@@ -1101,6 +1112,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1332,6 +1344,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1332,6 +1349,13 @@ asmlinkage long sys_bind(int fd, struct 
  			err = security_socket_bind(sock,
  						   (struct sockaddr *)address,
  						   addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  						      (struct sockaddr *)
-@@ -1361,6 +1376,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1361,6 +1385,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1425,6 +1443,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1425,6 +1453,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1377,13 +1519,15 @@
  	if (upeer_sockaddr) {
  		if (newsock->ops->getname(newsock, (struct sockaddr *)address,
  					  &len, 2) < 0) {
-@@ -1489,6 +1513,10 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1489,6 +1524,12 @@ asmlinkage long sys_connect(int fd, stru
  	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 +	/***** TOMOYO Linux start. *****/
-+	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen);
-+	if (err) goto out_put;
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  
  	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
@@ -1400,23 +1544,28 @@
  
  int sysctl_unix_max_dgram_qlen __read_mostly = 10;
  
-@@ -791,6 +794,10 @@ static int unix_bind(struct socket *sock
+@@ -791,6 +794,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -834,6 +841,9 @@ static int unix_bind(struct socket *sock
+@@ -834,6 +842,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1433,13 +1582,14 @@
  
  #include "ia32priv.h"
  
-@@ -1758,6 +1761,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1758,6 +1761,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1457,13 +1607,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1481,13 +1632,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -87,6 +90,11 @@ long compat_sys_ptrace(int request, int 
+@@ -87,6 +90,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1505,13 +1657,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -260,6 +263,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -260,6 +263,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1529,13 +1682,14 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -235,6 +238,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -235,6 +238,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.9-42.21AX.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.9-42.21AX.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.9-42.21AX.diff	(作業コピー)
@@ -3,61 +3,61 @@
 Source code for this patch is http://ftp.miraclelinux.com/pub/Miracle/ia32/standard/4.0/updates/SRPMS/kernel-2.6.9-42.21AX.src.rpm
 ---
  Makefile                           |    2 
- arch/alpha/kernel/ptrace.c         |    8 +++
- arch/arm/kernel/ptrace.c           |    8 +++
- arch/arm26/kernel/ptrace.c         |    8 +++
- arch/cris/arch-v10/kernel/ptrace.c |    8 +++
- arch/h8300/kernel/ptrace.c         |    8 +++
- arch/i386/kernel/ptrace.c          |    8 +++
- arch/ia64/ia32/sys_ia32.c          |    8 +++
- arch/ia64/kernel/ptrace.c          |    8 +++
- arch/m32r/kernel/ptrace.c          |    8 +++
- arch/m68k/kernel/ptrace.c          |    8 +++
- arch/m68knommu/kernel/ptrace.c     |    8 +++
- arch/mips/kernel/ptrace.c          |    8 +++
- arch/mips/kernel/ptrace32.c        |    8 +++
- arch/parisc/kernel/ptrace.c        |    8 +++
- arch/ppc/kernel/ptrace.c           |    8 +++
- arch/ppc64/kernel/ptrace.c         |    8 +++
- arch/ppc64/kernel/ptrace32.c       |    8 +++
- arch/s390/kernel/ptrace.c          |    8 +++
- arch/sh/kernel/ptrace.c            |    8 +++
- arch/sh64/kernel/ptrace.c          |    8 +++
- arch/sparc/kernel/ptrace.c         |   11 ++++
- arch/sparc64/kernel/ptrace.c       |   11 ++++
- arch/um/kernel/ptrace.c            |    8 +++
- arch/v850/kernel/ptrace.c          |    8 +++
- arch/x86_64/ia32/ptrace32.c        |    8 +++
- arch/x86_64/kernel/ptrace.c        |    8 +++
+ arch/alpha/kernel/ptrace.c         |    9 ++
+ arch/arm/kernel/ptrace.c           |    9 ++
+ arch/arm26/kernel/ptrace.c         |    9 ++
+ arch/cris/arch-v10/kernel/ptrace.c |    9 ++
+ arch/h8300/kernel/ptrace.c         |    9 ++
+ arch/i386/kernel/ptrace.c          |    9 ++
+ arch/ia64/ia32/sys_ia32.c          |    9 ++
+ arch/ia64/kernel/ptrace.c          |    9 ++
+ arch/m32r/kernel/ptrace.c          |    9 ++
+ arch/m68k/kernel/ptrace.c          |    9 ++
+ arch/m68knommu/kernel/ptrace.c     |    9 ++
+ arch/mips/kernel/ptrace.c          |    9 ++
+ arch/mips/kernel/ptrace32.c        |    9 ++
+ arch/parisc/kernel/ptrace.c        |    9 ++
+ arch/ppc/kernel/ptrace.c           |    9 ++
+ arch/ppc64/kernel/ptrace.c         |    9 ++
+ arch/ppc64/kernel/ptrace32.c       |    9 ++
+ arch/s390/kernel/ptrace.c          |    9 ++
+ arch/sh/kernel/ptrace.c            |    9 ++
+ arch/sh64/kernel/ptrace.c          |    9 ++
+ arch/sparc/kernel/ptrace.c         |   11 +++
+ arch/sparc64/kernel/ptrace.c       |   11 +++
+ arch/um/kernel/ptrace.c            |    9 ++
+ arch/v850/kernel/ptrace.c          |    9 ++
+ arch/x86_64/ia32/ptrace32.c        |    9 ++
+ arch/x86_64/kernel/ptrace.c        |    9 ++
  fs/Kconfig                         |    2 
  fs/Makefile                        |    2 
- fs/attr.c                          |   11 ++++
- fs/compat.c                        |   13 ++++-
- fs/exec.c                          |   20 ++++++-
- fs/fcntl.c                         |    7 ++
- fs/ioctl.c                         |    6 ++
- fs/namei.c                         |   61 +++++++++++++++++++++++
- fs/namespace.c                     |   43 +++++++++++++++-
- fs/open.c                          |   22 ++++++++
- fs/proc/Makefile                   |    3 +
+ fs/attr.c                          |   19 +++++
+ fs/compat.c                        |   16 ++++-
+ fs/exec.c                          |   26 +++++++-
+ fs/fcntl.c                         |    8 ++
+ fs/ioctl.c                         |    7 ++
+ fs/namei.c                         |  118 +++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                     |   54 ++++++++++++++++
+ fs/open.c                          |   28 ++++++++
+ fs/proc/Makefile                   |    3 
  fs/proc/proc_misc.c                |    5 +
  include/linux/init_task.h          |    4 +
- include/linux/sched.h              |    9 +++
+ include/linux/sched.h              |    9 ++
  kernel/kmod.c                      |    5 +
- kernel/module.c                    |   11 +++-
- kernel/sched.c                     |    6 ++
- kernel/signal.c                    |   16 ++++++
- kernel/sys.c                       |   15 +++++
- kernel/sysctl.c                    |   96 ++++++++++++++++++++++++++++++++++++-
- kernel/time.c                      |   12 ++++
- net/core/datagram.c                |    8 +++
- net/ipv4/tcp_ipv4.c                |    9 +++
- net/ipv4/udp.c                     |    9 +++
- net/ipv6/tcp_ipv6.c                |    6 ++
- net/ipv6/udp.c                     |    9 +++
- net/socket.c                       |   30 ++++++++++-
- net/unix/af_unix.c                 |   10 +++
- 55 files changed, 653 insertions(+), 13 deletions(-)
+ kernel/module.c                    |   13 +++-
+ kernel/sched.c                     |    7 ++
+ kernel/signal.c                    |   22 ++++++
+ kernel/sys.c                       |   21 ++++++
+ kernel/sysctl.c                    |  114 +++++++++++++++++++++++++++++++++++
+ kernel/time.c                      |   15 ++++
+ net/core/datagram.c                |   10 +++
+ net/ipv4/tcp_ipv4.c                |   11 +++
+ net/ipv4/udp.c                     |   11 +++
+ net/ipv6/tcp_ipv6.c                |    7 ++
+ net/ipv6/udp.c                     |   11 +++
+ net/socket.c                       |   43 ++++++++++++-
+ net/unix/af_unix.c                 |   15 ++++
+ 55 files changed, 833 insertions(+), 13 deletions(-)
 
 --- linux-2.6.9-42.21AX.orig/Makefile
 +++ linux-2.6.9-42.21AX/Makefile
@@ -100,13 +100,17 @@
  
  /* Taken over from the old code... */
  
-@@ -180,12 +183,20 @@ int notify_change(struct dentry * dentry
+@@ -180,12 +183,28 @@ int notify_change(struct dentry * dentry
  	if (inode->i_op && inode->i_op->setattr) {
  		audit_notify_watch(inode, MAY_WRITE);
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -115,8 +119,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -133,17 +141,20 @@
  
  /*
   * Not all architectures have sys_utime, so implement this in terms
-@@ -399,6 +402,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -399,6 +402,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		error = sys_ioctl (fd, cmd, arg);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out; }
++	if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	down_read(&ioctl32_sem);
  
-@@ -1461,8 +1467,11 @@ int compat_do_execve(char * filename,
+@@ -1461,8 +1470,11 @@ int compat_do_execve(char * filename,
  
  	retval = -ENOMEM;
  	bprm = kmalloc(sizeof(*bprm), GFP_KERNEL);
@@ -156,7 +167,7 @@
  	memset(bprm, 0, sizeof(*bprm));
  
  	bprm->p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
-@@ -1506,7 +1515,7 @@ int compat_do_execve(char * filename,
+@@ -1506,7 +1518,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -178,29 +189,35 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  int suid_dumpable = 0;
-@@ -146,6 +150,11 @@ asmlinkage long sys_uselib(const char __
+@@ -146,6 +150,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -505,6 +514,9 @@ struct file *open_exec(const char *name)
+@@ -505,6 +516,13 @@ struct file *open_exec(const char *name)
  			int err = permission(inode, MAY_EXEC, &nd);
  			if (!err && !(inode->i_mode & 0111))
  				err = -EACCES;
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
-@@ -1183,8 +1195,11 @@ int do_execve(char * filename,
+@@ -1183,8 +1201,11 @@ int do_execve(char * filename,
  
  	retval = -ENOMEM;
  	bprm = kmalloc(sizeof(*bprm), GFP_KERNEL);
@@ -213,12 +230,12 @@
  	memset(bprm, 0, sizeof(*bprm));
  
  	bprm->p = PAGE_SIZE*MAX_ARG_PAGES-sizeof(void *);
-@@ -1229,7 +1244,8 @@ int do_execve(char * filename,
+@@ -1229,7 +1250,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
@@ -235,12 +252,13 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -248,6 +251,10 @@ static int setfl(int fd, struct file * f
+@@ -248,6 +251,11 @@ static int setfl(int fd, struct file * f
  	if (!(arg & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -258,12 +276,13 @@
  
  static int file_ioctl(struct file *filp,unsigned int cmd,unsigned long arg)
  {
-@@ -60,6 +63,9 @@ asmlinkage long sys_ioctl(unsigned int f
+@@ -60,6 +63,10 @@ asmlinkage long sys_ioctl(unsigned int f
  	filp = fget(fd);
  	if (!filp)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	error = security_file_ioctl(filp, cmd, arg);
@@ -281,29 +300,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1387,6 +1391,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1387,6 +1391,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error) {
-@@ -1445,6 +1452,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1445,6 +1456,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1476,6 +1488,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1476,6 +1494,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -313,136 +338,187 @@
  /*
   *	open_namei()
   *
-@@ -1730,6 +1745,12 @@ asmlinkage long sys_mknod(const char __u
+@@ -1730,6 +1751,16 @@ asmlinkage long sys_mknod(const char __u
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1751,10 +1772,16 @@ asmlinkage long sys_mknod(const char __u
+@@ -1751,10 +1782,32 @@ asmlinkage long sys_mknod(const char __u
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1823,6 +1850,9 @@ asmlinkage long sys_mkdir(const char __u
+@@ -1823,6 +1876,13 @@ asmlinkage long sys_mkdir(const char __u
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -1937,6 +1967,9 @@ asmlinkage long sys_rmdir(const char __u
+@@ -1937,6 +1997,13 @@ asmlinkage long sys_rmdir(const char __u
  	dentry = lookup_hash(&nd.last, nd.dentry);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -1994,6 +2027,9 @@ asmlinkage long sys_unlink(const char __
+@@ -1994,6 +2061,10 @@ asmlinkage long sys_unlink(const char __
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2018,6 +2054,9 @@ asmlinkage long sys_unlink(const char __
+@@ -2018,6 +2089,14 @@ asmlinkage long sys_unlink(const char __
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2069,6 +2108,9 @@ asmlinkage long sys_symlink(const char _
+@@ -2069,6 +2148,10 @@ asmlinkage long sys_symlink(const char _
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2088,6 +2130,9 @@ asmlinkage long sys_symlink(const char _
+@@ -2088,6 +2171,13 @@ asmlinkage long sys_symlink(const char _
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2159,6 +2204,9 @@ asmlinkage long sys_link(const char __us
+@@ -2159,6 +2249,10 @@ asmlinkage long sys_link(const char __us
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	to = getname(newname);
  	if (IS_ERR(to))
-@@ -2179,6 +2227,9 @@ asmlinkage long sys_link(const char __us
+@@ -2179,6 +2273,15 @@ asmlinkage long sys_link(const char __us
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2409,6 +2460,13 @@ static inline int do_rename(const char *
+@@ -2409,6 +2512,17 @@ static inline int do_rename(const char *
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2433,6 +2491,9 @@ asmlinkage long sys_rename(const char __
+@@ -2433,6 +2547,10 @@ asmlinkage long sys_rename(const char __
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -462,39 +538,42 @@
  
  extern int __init init_rootfs(void);
  
-@@ -389,6 +395,10 @@ static int do_umount(struct vfsmount *mn
+@@ -389,6 +395,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -634,6 +644,9 @@ asmlinkage long sys_umount(char __user *
+@@ -634,6 +645,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  #ifdef CONFIG_FUMOUNT
          if (flags & MNT_FFORCE) {
-@@ -806,6 +819,10 @@ static int do_loopback(struct nameidata 
+@@ -806,6 +821,11 @@ static int do_loopback(struct nameidata 
  	down_write(&current->namespace->sem);
  	err = -EINVAL;
  	if (check_mnt(nd->mnt) && (!recurse || check_mnt(old_nd.mnt))) {
 +		/***** SAKURA Linux start. *****/
 +		err = -EPERM;
-+		if (ccs_may_mount(nd) < 0) goto out;
++		if (ccs_may_mount(nd))
++			goto out;
 +		/***** SAKURA Linux end. *****/
  		err = -ENOMEM;
  		if (recurse)
  			mnt = copy_tree(old_nd.mnt, old_nd.dentry);
-@@ -827,7 +844,9 @@ static int do_loopback(struct nameidata 
+@@ -827,7 +847,9 @@ static int do_loopback(struct nameidata 
  		} else
  			mntput(mnt);
  	}
@@ -505,59 +584,67 @@
  	up_write(&current->namespace->sem);
  	path_release(&old_nd);
  	return err;
-@@ -888,7 +907,10 @@ static int do_move_mount(struct nameidat
+@@ -888,7 +910,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	down(&nd->dentry->d_inode->i_sem);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -987,6 +1009,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -987,6 +1013,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	err = graft_tree(newmnt, nd);
-@@ -1210,6 +1236,13 @@ long do_mount(char * dev_name, char * di
+@@ -1210,6 +1241,17 @@ long do_mount(char * dev_name, char * di
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1467,6 +1500,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1467,6 +1509,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1482,6 +1518,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1482,6 +1528,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -578,45 +665,51 @@
  int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
  {
  	int retval = -ENODEV;
-@@ -270,6 +277,9 @@ static inline long do_sys_truncate(const
+@@ -270,6 +277,10 @@ static inline long do_sys_truncate(const
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -326,6 +336,9 @@ static inline long do_sys_ftruncate(unsi
+@@ -326,6 +337,11 @@ static inline long do_sys_ftruncate(unsi
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length);
-@@ -618,6 +631,12 @@ asmlinkage long sys_chroot(const char __
+@@ -618,6 +634,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1220,6 +1239,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1220,6 +1244,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
@@ -638,7 +731,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.9-42.21AX 2008/04/13\n");
++	printk(KERN_INFO "Hook version: 2.6.9-42.21AX 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -706,24 +799,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -547,7 +550,9 @@ sys_delete_module(const char __user *nam
+@@ -547,7 +550,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1855,7 +1860,9 @@ sys_init_module(void __user *umod,
+@@ -1855,7 +1861,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (down_interruptible(&module_mutex) != 0)
@@ -740,12 +835,13 @@
  
  #ifdef CONFIG_NUMA
  #define cpu_to_node_mask(cpu) node_to_cpumask(cpu_to_node(cpu))
-@@ -3203,6 +3206,9 @@ asmlinkage long sys_nice(int increment)
+@@ -3203,6 +3206,10 @@ asmlinkage long sys_nice(int increment)
  {
  	int retval;
  	long nice;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -762,36 +858,42 @@
  
  extern void k_getrusage(struct task_struct *, int, struct rusage *);
  
-@@ -2320,6 +2323,10 @@ asmlinkage long
+@@ -2320,6 +2323,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2350,6 +2357,11 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2350,6 +2359,13 @@ asmlinkage long sys_tgkill(int tgid, int
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	info.si_signo = sig;
  	info.si_errno = 0;
  	info.si_code = SI_TKILL;
-@@ -2390,6 +2402,10 @@ sys_tkill(int pid, int sig)
+@@ -2390,6 +2406,12 @@ sys_tkill(int pid, int sig)
  	if (pid <= 0)
  		return -EINVAL;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	info.si_signo = sig;
  	info.si_errno = 0;
@@ -808,42 +910,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -322,6 +325,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -322,6 +325,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -453,6 +459,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -453,6 +462,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	switch (cmd) {
-@@ -1454,6 +1463,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1454,6 +1467,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1499,6 +1511,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1499,6 +1516,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -861,24 +969,28 @@
  #ifdef CONFIG_ROOT_NFS
  #include <linux/nfs_fs.h>
  #endif
-@@ -1115,6 +1119,87 @@ void __init sysctl_init(void)
+@@ -1115,6 +1119,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -896,35 +1008,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -949,30 +1070,35 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1140,6 +1225,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1140,6 +1238,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1213,6 +1301,12 @@ repeat:
+@@ -1213,6 +1316,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
  						oldval, oldlenp,
-@@ -2240,7 +2334,7 @@ int sysctl_string(ctl_table *table, int 
+@@ -2240,7 +2352,7 @@ int sysctl_string(ctl_table *table, int 
  			len--;
  		((char *) table->data)[len] = 0;
  	}
@@ -993,32 +1119,35 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -81,6 +84,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -81,6 +84,10 @@ asmlinkage long sys_stime(time_t __user 
  
  	if (!capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (get_user(tv.tv_sec, tptr))
  		return -EFAULT;
  
-@@ -149,6 +155,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -149,6 +156,10 @@ int do_sys_settimeofday(struct timespec 
  
  	if (!capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -219,6 +228,9 @@ int do_adjtimex(struct timex *txc)
+@@ -219,6 +230,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
@@ -1036,12 +1165,14 @@
  
  /*
   *	Is a socket 'connection oriented' ?
-@@ -177,6 +181,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -177,6 +181,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1059,22 +1190,24 @@
  
  extern int sysctl_ip_dynaddr;
  int sysctl_tcp_tw_reuse;
-@@ -230,6 +233,9 @@ static int tcp_v4_get_port(struct sock *
+@@ -230,6 +233,10 @@ static int tcp_v4_get_port(struct sock *
  				rover = low;
  			head = &tcp_bhash[tcp_bhashfn(rover)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			tb_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
-@@ -677,6 +683,9 @@ static int tcp_v4_hash_connect(struct so
+@@ -677,6 +684,10 @@ static int tcp_v4_hash_connect(struct so
   				rover = low;
   			head = &tcp_bhash[tcp_bhashfn(rover)];
   			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next_port;
++			if (ccs_may_autobind(rover))
++				goto next_port;
 +			/***** SAKURA Linux end. *****/
  
   			/* Does not bother with rcv_saddr checks,
@@ -1091,22 +1224,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -145,6 +148,9 @@ static int udp_v4_get_port(struct sock *
+@@ -145,6 +148,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -161,6 +167,9 @@ static int udp_v4_get_port(struct sock *
+@@ -161,6 +168,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1123,12 +1258,13 @@
  
  static void	tcp_v6_send_reset(struct sk_buff *skb);
  static void	tcp_v6_or_send_ack(struct sk_buff *skb, struct open_request *req);
-@@ -149,6 +152,9 @@ static int tcp_v6_get_port(struct sock *
+@@ -149,6 +152,10 @@ static int tcp_v6_get_port(struct sock *
  				rover = low;
  			head = &tcp_bhash[tcp_bhashfn(rover)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			tb_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1145,22 +1281,24 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6);
  
-@@ -87,6 +90,9 @@ static int udp_v6_get_port(struct sock *
+@@ -87,6 +90,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -103,6 +109,9 @@ static int udp_v6_get_port(struct sock *
+@@ -103,6 +110,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1179,55 +1317,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -554,7 +559,9 @@ static inline int __sock_sendmsg(struct 
+@@ -554,7 +559,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1114,6 +1121,10 @@ static int __sock_create(int family, int
+@@ -1114,6 +1124,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1311,6 +1322,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1311,6 +1327,12 @@ asmlinkage long sys_bind(int fd, struct 
  				sockfd_put(sock);
  				return err;
  			}
 +			/***** TOMOYO Linux start. *****/
-+			if ((err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++			err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++							 address, addrlen);
++			if (!err)
 +			/***** TOMOYO Linux end. *****/
  			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
  		}
  		sockfd_put(sock);
-@@ -1341,7 +1355,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1341,7 +1363,10 @@ asmlinkage long sys_listen(int fd, int b
  			sockfd_put(sock);
  			return err;
  		}
 -
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = ccs_socket_listen_permission(sock)) == 0)
++		err = ccs_socket_listen_permission(sock);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err=sock->ops->listen(sock, backlog);
  		sockfd_put(sock);
  	}
-@@ -1392,6 +1408,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1392,6 +1417,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_release;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_release;
 +	}
@@ -1235,13 +1383,16 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1447,7 +1469,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1447,7 +1479,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
@@ -1258,23 +1409,28 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -741,6 +744,10 @@ static int unix_bind(struct socket *sock
+@@ -741,6 +744,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -805,6 +812,9 @@ static int unix_bind(struct socket *sock
+@@ -805,6 +813,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1291,13 +1447,14 @@
  
  #include "proto.h"
  
-@@ -260,6 +263,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -260,6 +263,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1315,13 +1472,14 @@
  
  #include "ptrace.h"
  
-@@ -731,6 +734,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -731,6 +734,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1339,13 +1497,14 @@
  
  #include "ptrace.h"
  
-@@ -668,6 +671,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -668,6 +671,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1363,13 +1522,14 @@
  
  /* cpu depend functions */
  extern long h8300_get_reg(struct task_struct *task, int regno);
-@@ -60,6 +63,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -60,6 +63,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1387,13 +1547,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -237,6 +240,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -237,6 +240,12 @@ asmlinkage int sys_ptrace(long request, 
  	struct user * dummy = NULL;
  	int i, ret;
  	unsigned long __user *datap = (unsigned long __user *)data;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1411,13 +1572,14 @@
  
  #include "entry.h"
  
-@@ -1312,6 +1315,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1312,6 +1315,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1435,13 +1597,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -120,6 +123,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -120,6 +123,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1459,13 +1622,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -104,6 +107,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -104,6 +107,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1483,13 +1647,14 @@
  
  /*
   * Called by kernel/ptrace.c when detaching..
-@@ -49,6 +52,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -49,6 +52,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1507,13 +1672,14 @@
  
  /* PSW bits we allow the debugger to modify */
  #define USER_PSW_BITS	(PSW_N | PSW_V | PSW_CB)
-@@ -84,6 +87,11 @@ long sys_ptrace(long request, pid_t pid,
+@@ -84,6 +87,12 @@ long sys_ptrace(long request, pid_t pid,
  #ifdef DEBUG_PTRACE
  	long oaddr=addr, odata=data;
  #endif
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1531,13 +1697,14 @@
  
  /*
   * Set of msr bits that gdb can change on behalf of a process.
-@@ -239,6 +242,11 @@ int sys_ptrace(long request, long pid, l
+@@ -239,6 +242,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1555,13 +1722,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -54,6 +57,11 @@ int sys_ptrace(long request, long pid, l
+@@ -54,6 +57,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1579,13 +1747,14 @@
  
  #ifdef CONFIG_S390_SUPPORT
  #include "compat_ptrace.h"
-@@ -705,6 +708,11 @@ sys_ptrace(long request, long pid, long 
+@@ -705,6 +708,12 @@ sys_ptrace(long request, long pid, long 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1603,13 +1772,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -85,6 +88,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -85,6 +88,12 @@ asmlinkage int sys_ptrace(long request, 
  	struct task_struct *child;
  	struct user * dummy = NULL;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1627,13 +1797,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -124,6 +127,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -124,6 +127,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1705,13 +1876,14 @@
  
  /*
   * Called by kernel/ptrace.c when detaching..
-@@ -28,6 +31,11 @@ int sys_ptrace(long request, long pid, l
+@@ -28,6 +31,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int i, ret;
 +/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +/***** TOMOYO Linux end. *****/
  
@@ -1729,13 +1901,14 @@
  
  /* Returns the address where the register at REG_OFFS in P is stashed away.  */
  static v850_reg_t *reg_save_addr (unsigned reg_offs, struct task_struct *t)
-@@ -116,6 +119,11 @@ int sys_ptrace(long request, long pid, l
+@@ -116,6 +119,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int rval;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1753,13 +1926,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -193,6 +196,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -193,6 +196,12 @@ asmlinkage long sys_ptrace(long request,
  	struct task_struct *child;
  	long i, ret;
  	unsigned ui;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1777,13 +1951,14 @@
  
  /*
   * Get the address of the live pt_regs for the specified task.
-@@ -787,6 +790,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -787,6 +790,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1801,13 +1976,14 @@
  
  /* 
   * Determines which bits in DCCR the user has access to.
-@@ -50,6 +53,11 @@ sys_ptrace(long request, long pid, long 
+@@ -50,6 +53,12 @@ sys_ptrace(long request, long pid, long 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1825,13 +2001,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -42,6 +45,11 @@ int sys32_ptrace(long request, long pid,
+@@ -42,6 +45,12 @@ int sys32_ptrace(long request, long pid,
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1849,13 +2026,14 @@
  
  /* determines which flags the user has access to. */
  /* 1 = access 0 = no access */
-@@ -232,6 +235,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -232,6 +235,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1873,13 +2051,14 @@
  
  #include "ia32priv.h"
  
-@@ -1787,6 +1790,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1787,6 +1790,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1897,13 +2076,14 @@
  
  /*
   * Tracing a 32-bit process with a 64-bit strace and vice versa will not
-@@ -42,6 +45,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -42,6 +45,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.17-1.2142_FC4.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.17-1.2142_FC4.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.17-1.2142_FC4.diff	(作業コピー)
@@ -3,50 +3,50 @@
 Source code for this patch is http://download.fedora.redhat.com/pub/fedora/linux/core/updates/4/SRPMS/kernel-2.6.17-1.2142_FC4.src.rpm
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 ++++
- arch/sparc64/kernel/ptrace.c    |   11 ++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 ++++
- fs/compat.c                     |    8 +++
- fs/exec.c                       |   15 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   61 ++++++++++++++++++++++++++
- fs/namespace.c                  |   39 ++++++++++++++++
- fs/open.c                       |   23 +++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |   11 +++
+ fs/exec.c                       |   21 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  118 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   50 ++++++++++++++++
+ fs/open.c                       |   29 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
  include/linux/sched.h           |    9 +++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |   11 +++-
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 ++++++
- kernel/sys.c                    |   15 ++++++
- kernel/sysctl.c                 |   93 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |   12 +++++
- net/core/datagram.c             |    9 +++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 +++
- net/ipv6/inet6_hashtables.c     |    8 +++
- net/ipv6/udp.c                  |    9 +++
- net/socket.c                    |   29 +++++++++++-
- net/unix/af_unix.c              |   10 ++++
- 44 files changed, 544 insertions(+), 10 deletions(-)
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   13 +++-
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |  111 +++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   15 +++++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    9 ++-
+ net/ipv6/udp.c                  |   11 +++
+ net/socket.c                    |   43 +++++++++++++-
+ net/unix/af_unix.c              |   15 +++++
+ 44 files changed, 714 insertions(+), 10 deletions(-)
 
 --- linux-2.6.17-1.2142_FC4.orig/Makefile
 +++ linux-2.6.17-1.2142_FC4/Makefile
@@ -71,13 +71,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -95,13 +96,14 @@
  
  #include "entry.h"
  
-@@ -1418,6 +1421,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1418,6 +1421,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -119,13 +121,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -743,6 +746,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -743,6 +746,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -143,13 +146,14 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -711,6 +714,11 @@ sys_ptrace(long request, long pid, long 
+@@ -711,6 +714,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -239,13 +243,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry * dentry
+@@ -145,12 +148,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -254,8 +262,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -272,17 +284,20 @@
  
  extern void sigset_from_compat(sigset_t *set, compat_sigset_t *compat);
  
-@@ -407,6 +410,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -407,6 +410,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1553,7 +1559,7 @@ int compat_do_execve(char * filename,
+@@ -1553,7 +1562,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -304,34 +319,40 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  int suid_dumpable = 0;
-@@ -139,6 +143,11 @@ asmlinkage long sys_uselib(const char __
+@@ -139,6 +143,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -491,6 +500,9 @@ struct file *open_exec(const char *name)
+@@ -488,6 +499,13 @@ struct file *open_exec(const char *name)
+ 			int err = vfs_permission(&nd, MAY_EXEC);
+ 			if (!err && !(inode->i_mode & 0111))
+ 				err = -EACCES;
++			/***** TOMOYO Linux start. *****/
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
++			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-+				/***** TOMOYO Linux start. *****/
-+				if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+				/***** TOMOYO Linux end. *****/
- 				if (!IS_ERR(file)) {
- 					err = deny_write_access(file);
- 					if (err) {
-@@ -1203,7 +1215,8 @@ int do_execve(char * filename,
+@@ -1203,7 +1221,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
@@ -348,12 +369,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -216,6 +219,10 @@ static int setfl(int fd, struct file * f
+@@ -216,6 +219,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -371,12 +394,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -24,6 +27,9 @@ static long do_ioctl(struct file *filp, 
+@@ -24,6 +27,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -394,29 +418,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1482,6 +1486,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1482,6 +1486,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1537,6 +1544,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1537,6 +1548,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1568,6 +1580,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1568,6 +1586,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -426,136 +456,187 @@
  /*
   *	open_namei()
   *
-@@ -1826,6 +1841,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1826,6 +1847,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1844,10 +1865,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1844,10 +1875,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1912,6 +1939,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1912,6 +1965,13 @@ asmlinkage long sys_mkdirat(int dfd, con
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -2020,6 +2050,9 @@ static long do_rmdir(int dfd, const char
+@@ -2020,6 +2080,13 @@ static long do_rmdir(int dfd, const char
  	dentry = lookup_hash(&nd);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -2079,6 +2112,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2079,6 +2146,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2100,6 +2136,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2100,6 +2171,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2162,6 +2201,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2162,6 +2241,10 @@ asmlinkage long sys_symlinkat(const char
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2178,6 +2220,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2178,6 +2261,13 @@ asmlinkage long sys_symlinkat(const char
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2250,6 +2295,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2250,6 +2340,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (flags != 0)
  		return -EINVAL;
-@@ -2270,6 +2318,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2270,6 +2364,15 @@ asmlinkage long sys_linkat(int olddfd, c
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2496,6 +2547,13 @@ static int do_rename(int olddfd, const c
+@@ -2496,6 +2599,17 @@ static int do_rename(int olddfd, const c
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2518,6 +2576,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2518,6 +2632,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -575,91 +656,102 @@
  
  extern int __init init_rootfs(void);
  
-@@ -547,6 +553,10 @@ static int do_umount(struct vfsmount *mn
+@@ -547,6 +553,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -635,6 +645,9 @@ asmlinkage long sys_umount(char __user *
+@@ -635,6 +646,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -919,6 +932,10 @@ static int do_loopback(struct nameidata 
+@@ -919,6 +934,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1003,7 +1020,10 @@ static int do_move_mount(struct nameidat
+@@ -1003,7 +1023,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1105,6 +1125,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1105,6 +1129,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1322,6 +1346,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1322,6 +1351,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1613,6 +1644,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1613,6 +1653,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1629,6 +1663,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1629,6 +1673,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -680,46 +772,52 @@
  int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
  {
  	int retval = -ENODEV;
-@@ -267,6 +274,9 @@ static long do_sys_truncate(const char _
+@@ -267,6 +274,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -319,7 +329,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -319,7 +330,11 @@ static long do_sys_ftruncate(unsigned in
  	error = -EPERM;
  	if (IS_APPEND(inode))
  		goto out_putf;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, 0, file);
-@@ -610,6 +622,12 @@ asmlinkage long sys_chroot(const char __
+@@ -610,6 +625,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1202,6 +1220,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1202,6 +1225,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
@@ -741,7 +839,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.17-1.2142_FC4 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.17-1.2142_FC4 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -795,12 +893,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -842,6 +845,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -842,6 +845,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -817,12 +916,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -922,6 +925,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -922,6 +925,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -853,24 +953,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -597,7 +600,9 @@ sys_delete_module(const char __user *nam
+@@ -597,7 +600,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1797,7 +1802,9 @@ sys_init_module(void __user *umod,
+@@ -1797,7 +1803,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (mutex_lock_interruptible(&module_mutex) != 0)
@@ -887,13 +989,14 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -494,6 +497,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -494,6 +497,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -911,12 +1014,13 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -3550,6 +3553,9 @@ asmlinkage long sys_nice(int increment)
+@@ -3550,6 +3553,10 @@ asmlinkage long sys_nice(int increment)
  {
  	int retval;
  	long nice;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -933,35 +1037,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2186,6 +2189,10 @@ asmlinkage long
+@@ -2186,6 +2189,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2244,6 +2251,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2244,6 +2253,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2257,6 +2268,10 @@ sys_tkill(int pid, int sig)
+@@ -2257,6 +2272,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -978,42 +1088,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -462,6 +465,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -462,6 +465,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -689,6 +695,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -689,6 +698,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1686,6 +1695,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1686,6 +1699,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1731,6 +1743,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1731,6 +1748,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -1030,24 +1146,28 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1164,6 +1167,87 @@ void __init sysctl_init(void)
+@@ -1164,6 +1167,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -1065,35 +1185,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -1118,25 +1247,30 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1189,6 +1273,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1189,6 +1286,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1261,6 +1348,12 @@ repeat:
+@@ -1261,6 +1363,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
@@ -1153,32 +1287,35 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -91,6 +94,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -91,6 +94,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -161,6 +167,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -161,6 +168,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -221,6 +230,9 @@ int do_adjtimex(struct timex *txc)
+@@ -221,6 +232,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
@@ -1197,12 +1334,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1220,12 +1359,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -88,6 +91,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -88,6 +91,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1242,12 +1382,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -264,6 +267,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -264,6 +267,10 @@ int inet_hash_connect(struct inet_timewa
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1264,22 +1405,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -147,6 +150,9 @@ static int udp_v4_get_port(struct sock *
+@@ -147,6 +150,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -163,6 +169,9 @@ static int udp_v4_get_port(struct sock *
+@@ -163,6 +170,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1305,12 +1448,13 @@
  						inet->dport);
  	struct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);
  	struct sock *sk2;
-@@ -267,6 +270,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -267,6 +270,10 @@ int inet6_hash_connect(struct inet_timew
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1327,22 +1471,24 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6) __read_mostly;
  
-@@ -89,6 +92,9 @@ static int udp_v6_get_port(struct sock *
+@@ -89,6 +92,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -105,6 +111,9 @@ static int udp_v6_get_port(struct sock *
+@@ -105,6 +112,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1361,54 +1507,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -595,7 +600,9 @@ static inline int __sock_sendmsg(struct 
+@@ -595,7 +600,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1153,6 +1160,10 @@ static int __sock_create(int family, int
+@@ -1153,6 +1163,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1346,6 +1357,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1346,6 +1362,13 @@ asmlinkage long sys_bind(int fd, struct 
  	{
  		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
  			err = security_socket_bind(sock, (struct sockaddr *)address, addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  					(struct sockaddr *)address, addrlen);
-@@ -1374,6 +1388,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1374,6 +1397,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1438,6 +1455,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1438,6 +1465,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1416,13 +1573,16 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1494,7 +1517,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1494,7 +1528,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
@@ -1439,23 +1599,28 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -738,6 +741,10 @@ static int unix_bind(struct socket *sock
+@@ -738,6 +741,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -781,6 +788,9 @@ static int unix_bind(struct socket *sock
+@@ -781,6 +789,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1472,13 +1637,14 @@
  
  #include "ia32priv.h"
  
-@@ -1742,6 +1745,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1742,6 +1745,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1496,13 +1662,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1520,13 +1687,14 @@
  
  #include "ptrace-common.h"
  
-@@ -46,6 +49,11 @@ long compat_sys_ptrace(int request, int 
+@@ -46,6 +49,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1544,13 +1712,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -272,6 +275,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -272,6 +275,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1568,13 +1737,14 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -206,6 +209,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -206,6 +209,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.12.3-a9-13.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.12.3-a9-13.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.12.3-a9-13.diff	(作業コピー)
@@ -3,63 +3,63 @@
 Source code for this patch is http://download.atmark-techno.com/armadillo-9/source/linux-2.6.12.3-a9-13.tar.gz
 ---
  Makefile                           |    2 
- arch/alpha/kernel/ptrace.c         |    8 +++
- arch/arm/kernel/ptrace.c           |    8 +++
- arch/arm26/kernel/ptrace.c         |    8 +++
- arch/cris/arch-v10/kernel/ptrace.c |    8 +++
- arch/frv/kernel/ptrace.c           |    8 +++
- arch/h8300/kernel/ptrace.c         |    8 +++
- arch/i386/kernel/ptrace.c          |    8 +++
- arch/ia64/ia32/sys_ia32.c          |    8 +++
- arch/ia64/kernel/ptrace.c          |    8 +++
- arch/m32r/kernel/ptrace.c          |    8 +++
- arch/m68k/kernel/ptrace.c          |    8 +++
- arch/m68knommu/kernel/ptrace.c     |    8 +++
- arch/mips/kernel/ptrace.c          |    8 +++
- arch/mips/kernel/ptrace32.c        |    8 +++
- arch/parisc/kernel/ptrace.c        |    8 +++
- arch/ppc/kernel/ptrace.c           |    8 +++
- arch/ppc64/kernel/ptrace.c         |    8 +++
- arch/ppc64/kernel/ptrace32.c       |    8 +++
- arch/s390/kernel/ptrace.c          |    8 +++
- arch/sh/kernel/ptrace.c            |    8 +++
- arch/sh64/kernel/ptrace.c          |    8 +++
- arch/sparc/kernel/ptrace.c         |   11 ++++
- arch/sparc64/kernel/ptrace.c       |   11 ++++
- arch/um/kernel/ptrace.c            |    8 +++
- arch/v850/kernel/ptrace.c          |    8 +++
- arch/x86_64/ia32/ptrace32.c        |    8 +++
- arch/x86_64/kernel/ptrace.c        |    8 +++
+ arch/alpha/kernel/ptrace.c         |    9 ++
+ arch/arm/kernel/ptrace.c           |    9 ++
+ arch/arm26/kernel/ptrace.c         |    9 ++
+ arch/cris/arch-v10/kernel/ptrace.c |    9 ++
+ arch/frv/kernel/ptrace.c           |    9 ++
+ arch/h8300/kernel/ptrace.c         |    9 ++
+ arch/i386/kernel/ptrace.c          |    9 ++
+ arch/ia64/ia32/sys_ia32.c          |    9 ++
+ arch/ia64/kernel/ptrace.c          |    9 ++
+ arch/m32r/kernel/ptrace.c          |    9 ++
+ arch/m68k/kernel/ptrace.c          |    9 ++
+ arch/m68knommu/kernel/ptrace.c     |    9 ++
+ arch/mips/kernel/ptrace.c          |    9 ++
+ arch/mips/kernel/ptrace32.c        |    9 ++
+ arch/parisc/kernel/ptrace.c        |    9 ++
+ arch/ppc/kernel/ptrace.c           |    9 ++
+ arch/ppc64/kernel/ptrace.c         |    9 ++
+ arch/ppc64/kernel/ptrace32.c       |    9 ++
+ arch/s390/kernel/ptrace.c          |    9 ++
+ arch/sh/kernel/ptrace.c            |    9 ++
+ arch/sh64/kernel/ptrace.c          |    9 ++
+ arch/sparc/kernel/ptrace.c         |   11 +++
+ arch/sparc64/kernel/ptrace.c       |   11 +++
+ arch/um/kernel/ptrace.c            |    9 ++
+ arch/v850/kernel/ptrace.c          |    9 ++
+ arch/x86_64/ia32/ptrace32.c        |    9 ++
+ arch/x86_64/kernel/ptrace.c        |    9 ++
  fs/Kconfig                         |    2 
  fs/Makefile                        |    2 
- fs/attr.c                          |   11 ++++
- fs/compat.c                        |    8 ++-
- fs/exec.c                          |   15 +++++
- fs/fcntl.c                         |    7 ++
- fs/ioctl.c                         |    6 ++
- fs/namei.c                         |   61 +++++++++++++++++++++++
- fs/namespace.c                     |   43 +++++++++++++++-
- fs/open.c                          |   22 ++++++++
- fs/proc/Makefile                   |    3 +
+ fs/attr.c                          |   19 +++++
+ fs/compat.c                        |   11 +++
+ fs/exec.c                          |   21 ++++++
+ fs/fcntl.c                         |    8 ++
+ fs/ioctl.c                         |    7 ++
+ fs/namei.c                         |  118 +++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                     |   54 ++++++++++++++++
+ fs/open.c                          |   28 ++++++++
+ fs/proc/Makefile                   |    3 
  fs/proc/proc_misc.c                |    5 +
  include/linux/init_task.h          |    4 +
- include/linux/sched.h              |    9 +++
- kernel/compat.c                    |    6 ++
+ include/linux/sched.h              |    9 ++
+ kernel/compat.c                    |    7 ++
  kernel/kmod.c                      |    5 +
- kernel/module.c                    |   11 +++-
- kernel/sched.c                     |    6 ++
- kernel/signal.c                    |   16 ++++++
- kernel/sys.c                       |   15 +++++
- kernel/sysctl.c                    |   98 ++++++++++++++++++++++++++++++++++++-
- kernel/time.c                      |   12 ++++
- net/core/datagram.c                |    8 +++
- net/ipv4/tcp_ipv4.c                |    9 +++
- net/ipv4/udp.c                     |    9 +++
- net/ipv6/tcp_ipv6.c                |    9 +++
- net/ipv6/udp.c                     |    9 +++
- net/socket.c                       |   30 ++++++++++-
- net/unix/af_unix.c                 |   10 +++
- 57 files changed, 663 insertions(+), 12 deletions(-)
+ kernel/module.c                    |   13 +++-
+ kernel/sched.c                     |    7 ++
+ kernel/signal.c                    |   22 ++++++
+ kernel/sys.c                       |   21 ++++++
+ kernel/sysctl.c                    |  116 +++++++++++++++++++++++++++++++++++-
+ kernel/time.c                      |   15 ++++
+ net/core/datagram.c                |   10 +++
+ net/ipv4/tcp_ipv4.c                |   11 +++
+ net/ipv4/udp.c                     |   11 +++
+ net/ipv6/tcp_ipv6.c                |   11 +++
+ net/ipv6/udp.c                     |   11 +++
+ net/socket.c                       |   43 ++++++++++++-
+ net/unix/af_unix.c                 |   15 ++++
+ 57 files changed, 846 insertions(+), 12 deletions(-)
 
 --- linux-2.6.12.3-a9-13.orig/Makefile
 +++ linux-2.6.12.3-a9-13/Makefile
@@ -84,13 +84,14 @@
  
  #include "proto.h"
  
-@@ -261,6 +264,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -261,6 +264,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -108,13 +109,14 @@
  
  #include "ptrace.h"
  
-@@ -786,6 +789,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -786,6 +789,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -132,13 +134,14 @@
  
  #include "ptrace.h"
  
-@@ -669,6 +672,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -669,6 +672,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -156,13 +159,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -112,6 +115,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -112,6 +115,12 @@ asmlinkage int sys_ptrace(long request, 
  	unsigned long tmp;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -180,13 +184,14 @@
  
  /* cpu depend functions */
  extern long h8300_get_reg(struct task_struct *task, int regno);
-@@ -61,6 +64,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -61,6 +64,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -204,13 +209,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -358,6 +361,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -358,6 +361,12 @@ asmlinkage int sys_ptrace(long request, 
  	struct user * dummy = NULL;
  	int i, ret;
  	unsigned long __user *datap = (unsigned long __user *)data;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -228,13 +234,14 @@
  
  #include "entry.h"
  
-@@ -1404,6 +1407,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1404,6 +1407,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -252,13 +259,14 @@
  
  /*
   * Get the address of the live pt_regs for the specified task.
-@@ -760,6 +763,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -760,6 +763,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -276,13 +284,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -121,6 +124,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -121,6 +124,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -300,13 +309,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -105,6 +108,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -105,6 +108,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -324,13 +334,14 @@
  
  /*
   * Called by kernel/ptrace.c when detaching..
-@@ -51,6 +54,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -51,6 +54,12 @@ asmlinkage int sys_ptrace(long request, 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -348,13 +359,14 @@
  
  /* PSW bits we allow the debugger to modify */
  #define USER_PSW_BITS	(PSW_N | PSW_V | PSW_CB)
-@@ -85,6 +88,11 @@ long sys_ptrace(long request, pid_t pid,
+@@ -85,6 +88,12 @@ long sys_ptrace(long request, pid_t pid,
  #ifdef DEBUG_PTRACE
  	long oaddr=addr, odata=data;
  #endif
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -372,13 +384,14 @@
  
  /*
   * Set of msr bits that gdb can change on behalf of a process.
-@@ -241,6 +244,11 @@ int sys_ptrace(long request, long pid, l
+@@ -241,6 +244,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -396,13 +409,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -56,6 +59,11 @@ int sys_ptrace(long request, long pid, l
+@@ -56,6 +59,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -420,13 +434,14 @@
  
  #ifdef CONFIG_S390_SUPPORT
  #include "compat_ptrace.h"
-@@ -710,6 +713,11 @@ sys_ptrace(long request, long pid, long 
+@@ -710,6 +713,12 @@ sys_ptrace(long request, long pid, long 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -444,13 +459,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -85,6 +88,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -85,6 +88,12 @@ asmlinkage int sys_ptrace(long request, 
  	struct task_struct *child;
  	struct user * dummy = NULL;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -468,13 +484,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -128,6 +131,11 @@ asmlinkage int sys_ptrace(long request, 
+@@ -128,6 +131,12 @@ asmlinkage int sys_ptrace(long request, 
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -546,13 +563,14 @@
  
  static inline void set_singlestepping(struct task_struct *child, int on)
  {
-@@ -47,6 +50,11 @@ long sys_ptrace(long request, long pid, 
+@@ -47,6 +50,12 @@ long sys_ptrace(long request, long pid, 
  {
  	struct task_struct *child;
  	int i, ret;
 +/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +/***** TOMOYO Linux end. *****/
  
@@ -570,13 +588,14 @@
  
  /* Returns the address where the register at REG_OFFS in P is stashed away.  */
  static v850_reg_t *reg_save_addr (unsigned reg_offs, struct task_struct *t)
-@@ -117,6 +120,11 @@ int sys_ptrace(long request, long pid, l
+@@ -117,6 +120,12 @@ int sys_ptrace(long request, long pid, l
  {
  	struct task_struct *child;
  	int rval;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -594,13 +613,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -318,6 +321,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -318,6 +321,12 @@ asmlinkage long sys_ptrace(long request,
  	struct task_struct *child;
  	long i, ret;
  	unsigned ui;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -636,13 +656,17 @@
  
  /* Taken over from the old code... */
  
-@@ -179,12 +182,20 @@ int notify_change(struct dentry * dentry
+@@ -179,12 +182,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -651,8 +675,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -669,17 +697,20 @@
  
  /*
   * Not all architectures have sys_utime, so implement this in terms
-@@ -466,6 +469,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -466,6 +469,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1557,7 +1563,7 @@ int compat_do_execve(char * filename,
+@@ -1557,7 +1566,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -701,34 +732,40 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  /* The maximal length of core_pattern is also specified in sysctl.c */
-@@ -136,6 +140,11 @@ asmlinkage long sys_uselib(const char __
+@@ -136,6 +140,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -504,6 +513,9 @@ struct file *open_exec(const char *name)
+@@ -504,6 +515,13 @@ struct file *open_exec(const char *name)
  			int err = permission(inode, MAY_EXEC, &nd);
  			if (!err && !(inode->i_mode & 0111))
  				err = -EACCES;
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = dentry_open(nd.dentry, nd.mnt, O_RDONLY);
-@@ -1191,7 +1203,8 @@ int do_execve(char * filename,
+@@ -1191,7 +1209,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
@@ -745,12 +782,13 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -193,6 +196,10 @@ static int setfl(int fd, struct file * f
+@@ -193,6 +196,11 @@ static int setfl(int fd, struct file * f
  	if (!(arg & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -768,12 +806,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -23,6 +26,9 @@ static long do_ioctl(struct file *filp, 
+@@ -23,6 +26,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -791,29 +830,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1311,6 +1315,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1311,6 +1315,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error) {
-@@ -1368,6 +1375,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1368,6 +1379,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1399,6 +1411,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1399,6 +1417,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -823,136 +868,187 @@
  /*
   *	open_namei()
   *
-@@ -1638,6 +1653,12 @@ asmlinkage long sys_mknod(const char __u
+@@ -1638,6 +1659,16 @@ asmlinkage long sys_mknod(const char __u
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1656,10 +1677,16 @@ asmlinkage long sys_mknod(const char __u
+@@ -1656,10 +1687,32 @@ asmlinkage long sys_mknod(const char __u
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1721,6 +1748,9 @@ asmlinkage long sys_mkdir(const char __u
+@@ -1721,6 +1774,13 @@ asmlinkage long sys_mkdir(const char __u
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -1825,6 +1855,9 @@ asmlinkage long sys_rmdir(const char __u
+@@ -1825,6 +1885,13 @@ asmlinkage long sys_rmdir(const char __u
  	dentry = lookup_hash(&nd.last, nd.dentry);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -1879,6 +1912,9 @@ asmlinkage long sys_unlink(const char __
+@@ -1879,6 +1946,10 @@ asmlinkage long sys_unlink(const char __
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -1900,6 +1936,9 @@ asmlinkage long sys_unlink(const char __
+@@ -1900,6 +1971,14 @@ asmlinkage long sys_unlink(const char __
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -1947,6 +1986,9 @@ asmlinkage long sys_symlink(const char _
+@@ -1947,6 +2026,10 @@ asmlinkage long sys_symlink(const char _
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -1963,6 +2005,9 @@ asmlinkage long sys_symlink(const char _
+@@ -1963,6 +2046,13 @@ asmlinkage long sys_symlink(const char _
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2030,6 +2075,9 @@ asmlinkage long sys_link(const char __us
+@@ -2030,6 +2120,10 @@ asmlinkage long sys_link(const char __us
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	to = getname(newname);
  	if (IS_ERR(to))
-@@ -2047,6 +2095,9 @@ asmlinkage long sys_link(const char __us
+@@ -2047,6 +2141,15 @@ asmlinkage long sys_link(const char __us
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2269,6 +2320,13 @@ static inline int do_rename(const char *
+@@ -2269,6 +2372,17 @@ static inline int do_rename(const char *
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2290,6 +2348,9 @@ asmlinkage long sys_rename(const char __
+@@ -2290,6 +2404,10 @@ asmlinkage long sys_rename(const char __
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -972,39 +1068,42 @@
  
  extern int __init init_rootfs(void);
  
-@@ -373,6 +379,10 @@ static int do_umount(struct vfsmount *mn
+@@ -373,6 +379,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -469,6 +479,9 @@ asmlinkage long sys_umount(char __user *
+@@ -469,6 +480,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -634,6 +647,10 @@ static int do_loopback(struct nameidata 
+@@ -634,6 +649,11 @@ static int do_loopback(struct nameidata 
  	down_write(&current->namespace->sem);
  	err = -EINVAL;
  	if (check_mnt(nd->mnt) && (!recurse || check_mnt(old_nd.mnt))) {
 +		/***** SAKURA Linux start. *****/
 +		err = -EPERM;
-+		if (ccs_may_mount(nd) < 0) goto out;
++		if (ccs_may_mount(nd))
++			goto out;
 +		/***** SAKURA Linux end. *****/
  		err = -ENOMEM;
  		if (recurse)
  			mnt = copy_tree(old_nd.mnt, old_nd.dentry);
-@@ -655,7 +672,9 @@ static int do_loopback(struct nameidata 
+@@ -655,7 +675,9 @@ static int do_loopback(struct nameidata 
  		} else
  			mntput(mnt);
  	}
@@ -1015,59 +1114,67 @@
  	up_write(&current->namespace->sem);
  	path_release(&old_nd);
  	return err;
-@@ -711,7 +730,10 @@ static int do_move_mount(struct nameidat
+@@ -711,7 +733,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	down(&nd->dentry->d_inode->i_sem);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -805,6 +827,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -805,6 +831,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	err = graft_tree(newmnt, nd);
-@@ -1026,6 +1052,13 @@ long do_mount(char * dev_name, char * di
+@@ -1026,6 +1057,17 @@ long do_mount(char * dev_name, char * di
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1284,6 +1317,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1284,6 +1326,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1299,6 +1335,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1299,6 +1345,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -1088,45 +1195,51 @@
  int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
  {
  	int retval = -ENODEV;
-@@ -257,6 +264,9 @@ static inline long do_sys_truncate(const
+@@ -257,6 +264,10 @@ static inline long do_sys_truncate(const
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -310,6 +320,9 @@ static inline long do_sys_ftruncate(unsi
+@@ -310,6 +321,11 @@ static inline long do_sys_ftruncate(unsi
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length);
-@@ -582,6 +595,12 @@ asmlinkage long sys_chroot(const char __
+@@ -582,6 +598,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1041,6 +1060,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1041,6 +1065,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
@@ -1148,7 +1261,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.12.3-a9-13 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.12.3-a9-13 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -1202,12 +1315,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -852,6 +855,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -852,6 +855,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -1238,24 +1352,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -531,7 +534,9 @@ sys_delete_module(const char __user *nam
+@@ -531,7 +534,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1764,7 +1769,9 @@ sys_init_module(void __user *umod,
+@@ -1764,7 +1770,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (down_interruptible(&module_mutex) != 0)
@@ -1272,12 +1388,13 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -3250,6 +3253,9 @@ asmlinkage long sys_nice(int increment)
+@@ -3250,6 +3253,10 @@ asmlinkage long sys_nice(int increment)
  {
  	int retval;
  	long nice;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -1294,36 +1411,42 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2255,6 +2258,10 @@ asmlinkage long
+@@ -2255,6 +2258,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2285,6 +2292,11 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2285,6 +2294,13 @@ asmlinkage long sys_tgkill(int tgid, int
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	info.si_signo = sig;
  	info.si_errno = 0;
  	info.si_code = SI_TKILL;
-@@ -2325,6 +2337,10 @@ sys_tkill(int pid, int sig)
+@@ -2325,6 +2341,12 @@ sys_tkill(int pid, int sig)
  	if (pid <= 0)
  		return -EINVAL;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	info.si_signo = sig;
  	info.si_errno = 0;
@@ -1340,42 +1463,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -252,6 +255,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -252,6 +255,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -383,6 +389,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -383,6 +392,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	switch (cmd) {
-@@ -1385,6 +1394,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1385,6 +1398,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1430,6 +1442,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1430,6 +1447,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -1392,24 +1521,28 @@
  
  #ifdef CONFIG_ROOT_NFS
  #include <linux/nfs_fs.h>
-@@ -971,6 +974,87 @@ void __init sysctl_init(void)
+@@ -971,6 +974,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -1427,35 +1560,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -1480,33 +1622,38 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -988,7 +1072,11 @@ int do_sysctl(int __user *name, int nlen
+@@ -988,7 +1085,13 @@ int do_sysctl(int __user *name, int nlen
  		struct ctl_table_header *head =
  			list_entry(tmp, struct ctl_table_header, ctl_entry);
  		void *context = NULL;
 -		int error = parse_table(name, nlen, oldval, oldlenp, 
 +		int error;
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
 +		error = parse_table(name, nlen, oldval, oldlenp,
  					newval, newlen, head->ctl_table,
  					&context);
  		if (context)
-@@ -1058,6 +1146,12 @@ repeat:
+@@ -1058,6 +1161,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
  						oldval, oldlenp,
-@@ -2116,7 +2210,7 @@ int sysctl_string(ctl_table *table, int 
+@@ -2116,7 +2228,7 @@ int sysctl_string(ctl_table *table, int 
  			len--;
  		((char *) table->data)[len] = 0;
  	}
@@ -1527,32 +1674,35 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -90,6 +93,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -90,6 +93,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -157,6 +163,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -157,6 +164,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -235,6 +244,9 @@ int do_adjtimex(struct timex *txc)
+@@ -235,6 +246,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
@@ -1570,12 +1720,14 @@
  
  /*
   *	Is a socket 'connection oriented' ?
-@@ -177,6 +181,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -177,6 +181,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1593,22 +1745,24 @@
  
  extern int sysctl_ip_dynaddr;
  int sysctl_tcp_tw_reuse;
-@@ -232,6 +235,9 @@ static int tcp_v4_get_port(struct sock *
+@@ -232,6 +235,10 @@ static int tcp_v4_get_port(struct sock *
  				rover = low;
  			head = &tcp_bhash[tcp_bhashfn(rover)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			tb_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
-@@ -671,6 +677,9 @@ static inline int tcp_v4_hash_connect(st
+@@ -671,6 +678,10 @@ static inline int tcp_v4_hash_connect(st
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &tcp_bhash[tcp_bhashfn(port)];
   			spin_lock(&head->lock);
@@ -1625,22 +1779,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -145,6 +148,9 @@ static int udp_v4_get_port(struct sock *
+@@ -145,6 +148,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -161,6 +167,9 @@ static int udp_v4_get_port(struct sock *
+@@ -161,6 +168,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1657,22 +1813,24 @@
  
  static void	tcp_v6_send_reset(struct sk_buff *skb);
  static void	tcp_v6_or_send_ack(struct sk_buff *skb, struct open_request *req);
-@@ -148,6 +151,9 @@ static int tcp_v6_get_port(struct sock *
+@@ -148,6 +151,10 @@ static int tcp_v6_get_port(struct sock *
  				rover = low;
  			head = &tcp_bhash[tcp_bhashfn(rover)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			tb_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
-@@ -551,6 +557,9 @@ static int tcp_v6_hash_connect(struct so
+@@ -551,6 +558,10 @@ static int tcp_v6_hash_connect(struct so
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &tcp_bhash[tcp_bhashfn(port)];
   			spin_lock(&head->lock);
@@ -1689,22 +1847,24 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6);
  
-@@ -87,6 +90,9 @@ static int udp_v6_get_port(struct sock *
+@@ -87,6 +90,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -103,6 +109,9 @@ static int udp_v6_get_port(struct sock *
+@@ -103,6 +110,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1723,55 +1883,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -540,7 +545,9 @@ static inline int __sock_sendmsg(struct 
+@@ -540,7 +545,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1093,6 +1100,10 @@ static int __sock_create(int family, int
+@@ -1093,6 +1103,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1287,6 +1298,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1287,6 +1303,12 @@ asmlinkage long sys_bind(int fd, struct 
  				sockfd_put(sock);
  				return err;
  			}
 +			/***** TOMOYO Linux start. *****/
-+			if ((err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++			err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++							 address, addrlen);
++			if (!err)
 +			/***** TOMOYO Linux end. *****/
  			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
  		}
  		sockfd_put(sock);
-@@ -1317,7 +1331,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1317,7 +1339,10 @@ asmlinkage long sys_listen(int fd, int b
  			sockfd_put(sock);
  			return err;
  		}
 -
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = ccs_socket_listen_permission(sock)) == 0)
++		err = ccs_socket_listen_permission(sock);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err=sock->ops->listen(sock, backlog);
  		sockfd_put(sock);
  	}
-@@ -1368,6 +1384,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1368,6 +1393,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_release;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_release;
 +	}
@@ -1779,13 +1949,16 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1423,7 +1445,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1423,7 +1455,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
@@ -1802,23 +1975,28 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -738,6 +741,10 @@ static int unix_bind(struct socket *sock
+@@ -738,6 +741,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -781,6 +788,9 @@ static int unix_bind(struct socket *sock
+@@ -781,6 +789,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1835,13 +2013,14 @@
  
  /* 
   * Determines which bits in DCCR the user has access to.
-@@ -81,6 +84,11 @@ sys_ptrace(long request, long pid, long 
+@@ -81,6 +84,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  	unsigned long __user *datap = (unsigned long __user *)data;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1859,13 +2038,14 @@
  
  #include "ia32priv.h"
  
-@@ -1757,6 +1760,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1757,6 +1760,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1883,13 +2063,14 @@
  
  /*
   * Tracing a 32-bit process with a 64-bit strace and vice versa will not
-@@ -43,6 +46,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -43,6 +46,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1907,13 +2088,14 @@
  
  /*
   * does not yet catch signals sent when the child dies.
-@@ -43,6 +46,11 @@ int sys32_ptrace(long request, long pid,
+@@ -43,6 +46,12 @@ int sys32_ptrace(long request, long pid,
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1931,13 +2113,14 @@
  
  /* determines which flags the user has access to. */
  /* 1 = access 0 = no access */
-@@ -233,6 +236,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -233,6 +236,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.17.14-ubuntu1.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.17.14-ubuntu1.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.17.14-ubuntu1.diff	(作業コピー)
@@ -3,53 +3,53 @@
 Source code for this patch is "apt-get install linux-source-2.6.17"
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 ++++
- arch/sparc64/kernel/ptrace.c    |   11 ++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    1 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 ++++
- fs/compat.c                     |    8 +++
- fs/exec.c                       |   14 +++++-
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   61 ++++++++++++++++++++++++++
- fs/namespace.c                  |   39 ++++++++++++++++
- fs/open.c                       |   23 +++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |   11 +++
+ fs/exec.c                       |   20 ++++++
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  118 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   50 ++++++++++++++++
+ fs/open.c                       |   29 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
  include/linux/sched.h           |    9 +++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |   11 +++-
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 ++++++
- kernel/sys.c                    |   15 ++++++
- kernel/sysctl.c                 |   93 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |   12 +++++
- net/core/datagram.c             |    9 +++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 +++
- net/ipv6/inet6_hashtables.c     |    8 +++
- net/ipv6/udp.c                  |    9 +++
- net/socket.c                    |   29 +++++++++++-
- net/unix/af_unix.c              |   10 ++++
- 44 files changed, 542 insertions(+), 10 deletions(-)
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   13 +++-
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |  111 +++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   15 +++++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    9 ++-
+ net/ipv6/udp.c                  |   11 +++
+ net/socket.c                    |   43 +++++++++++++-
+ net/unix/af_unix.c              |   15 +++++
+ 44 files changed, 712 insertions(+), 10 deletions(-)
 
---- linux-source-2.6.17-2.6.17.1.orig/Makefile
-+++ linux-source-2.6.17-2.6.17.1/Makefile
+--- linux-source-2.6.17.14-ubuntu1.orig/Makefile
++++ linux-source-2.6.17.14-ubuntu1/Makefile
 @@ -1,7 +1,7 @@
  VERSION = 2
  PATCHLEVEL = 6
@@ -59,8 +59,8 @@
  NAME=Crazed Snow-Weasel
  
  ifdef UBUNTUBUILD
---- linux-source-2.6.17-2.6.17.1.orig/fs/Kconfig
-+++ linux-source-2.6.17-2.6.17.1/fs/Kconfig
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/Kconfig
++++ linux-source-2.6.17.14-ubuntu1/fs/Kconfig
 @@ -1904,6 +1904,7 @@ endmenu
  
  source "fs/nls/Kconfig"
@@ -69,16 +69,16 @@
  
  endmenu
  
---- linux-source-2.6.17-2.6.17.1.orig/fs/Makefile
-+++ linux-source-2.6.17-2.6.17.1/fs/Makefile
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/Makefile
++++ linux-source-2.6.17.14-ubuntu1/fs/Makefile
 @@ -110,3 +110,5 @@ obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
  obj-$(CONFIG_GFS2_FS)           += gfs2/
  obj-$(CONFIG_GFS_FS)		+= gfs/
  obj-$(CONFIG_DAZUKO)		+= dazuko/
 +
 +include $(srctree)/fs/Makefile-2.6.ccs
---- linux-source-2.6.17-2.6.17.1.orig/fs/attr.c
-+++ linux-source-2.6.17-2.6.17.1/fs/attr.c
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/attr.c
++++ linux-source-2.6.17.14-ubuntu1/fs/attr.c
 @@ -15,6 +15,9 @@
  #include <linux/fcntl.h>
  #include <linux/quotaops.h>
@@ -89,13 +89,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry * dentry
+@@ -145,12 +148,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -104,14 +108,18 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
  			    (ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid))
---- linux-source-2.6.17-2.6.17.1.orig/fs/compat.c
-+++ linux-source-2.6.17-2.6.17.1/fs/compat.c
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/compat.c
++++ linux-source-2.6.17.14-ubuntu1/fs/compat.c
 @@ -52,6 +52,9 @@
  #include <asm/uaccess.h>
  #include <asm/mmu_context.h>
@@ -122,17 +130,20 @@
  
  extern void sigset_from_compat(sigset_t *set, compat_sigset_t *compat);
  
-@@ -407,6 +410,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -407,6 +410,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1557,7 +1563,7 @@ int compat_do_execve(char * filename,
+@@ -1557,7 +1566,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -141,8 +152,8 @@
  	if (retval >= 0) {
  		free_arg_pages(bprm);
  
---- linux-source-2.6.17-2.6.17.1.orig/fs/exec.c
-+++ linux-source-2.6.17-2.6.17.1/fs/exec.c
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/exec.c
++++ linux-source-2.6.17.14-ubuntu1/fs/exec.c
 @@ -56,6 +56,9 @@
  #ifdef CONFIG_KMOD
  #include <linux/kmod.h>
@@ -153,40 +164,46 @@
  
  /* A program that gets called and passed a core dump whenever a program
   * crashes for certain reasons (sigsegv, etc). Default dump size is
-@@ -146,6 +149,11 @@ asmlinkage long sys_uselib(const char __
+@@ -146,6 +149,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -495,6 +503,9 @@ struct file *open_exec(const char *name)
+@@ -495,6 +505,13 @@ struct file *open_exec(const char *name)
  			int err = vfs_permission(&nd, MAY_EXEC);
  			if (!err && !(inode->i_mode & 0111))
  				err = -EACCES;
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1215,7 +1226,8 @@ int do_execve(char * filename,
+@@ -1215,7 +1232,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
  
---- linux-source-2.6.17-2.6.17.1.orig/fs/fcntl.c
-+++ linux-source-2.6.17-2.6.17.1/fs/fcntl.c
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/fcntl.c
++++ linux-source-2.6.17.14-ubuntu1/fs/fcntl.c
 @@ -22,6 +22,9 @@
  #include <asm/poll.h>
  #include <asm/siginfo.h>
@@ -197,19 +214,21 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -214,6 +217,10 @@ static int setfl(int fd, struct file * f
+@@ -214,6 +217,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
  	if ((arg & O_NOATIME) && !(filp->f_flags & O_NOATIME))
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
---- linux-source-2.6.17-2.6.17.1.orig/fs/ioctl.c
-+++ linux-source-2.6.17-2.6.17.1/fs/ioctl.c
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/ioctl.c
++++ linux-source-2.6.17.14-ubuntu1/fs/ioctl.c
 @@ -16,6 +16,9 @@
  
  #include <asm/uaccess.h>
@@ -220,18 +239,19 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -24,6 +27,9 @@ static long do_ioctl(struct file *filp, 
+@@ -24,6 +27,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
  		error = filp->f_op->unlocked_ioctl(filp, cmd, arg);
---- linux-source-2.6.17-2.6.17.1.orig/fs/namei.c
-+++ linux-source-2.6.17-2.6.17.1/fs/namei.c
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/namei.c
++++ linux-source-2.6.17.14-ubuntu1/fs/namei.c
 @@ -37,6 +37,10 @@
  
  #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
@@ -243,29 +263,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1474,6 +1478,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1474,6 +1478,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1529,6 +1536,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1529,6 +1540,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1560,6 +1572,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1560,6 +1578,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -275,142 +301,193 @@
  /*
   *	open_namei()
   *
-@@ -1824,6 +1839,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1824,6 +1845,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1842,10 +1863,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1842,10 +1873,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1910,6 +1937,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1910,6 +1963,13 @@ asmlinkage long sys_mkdirat(int dfd, con
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -2018,6 +2048,9 @@ static long do_rmdir(int dfd, const char
+@@ -2018,6 +2078,13 @@ static long do_rmdir(int dfd, const char
  	dentry = lookup_hash(&nd);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -2077,6 +2110,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2077,6 +2144,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2098,6 +2134,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2098,6 +2169,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2160,6 +2199,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2160,6 +2239,10 @@ asmlinkage long sys_symlinkat(const char
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2176,6 +2218,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2176,6 +2259,13 @@ asmlinkage long sys_symlinkat(const char
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2248,6 +2293,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2248,6 +2338,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (flags != 0)
  		return -EINVAL;
-@@ -2268,6 +2316,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2268,6 +2362,15 @@ asmlinkage long sys_linkat(int olddfd, c
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2494,6 +2545,13 @@ static int do_rename(int olddfd, const c
+@@ -2494,6 +2597,17 @@ static int do_rename(int olddfd, const c
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2516,6 +2574,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2516,6 +2630,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
---- linux-source-2.6.17-2.6.17.1.orig/fs/namespace.c
-+++ linux-source-2.6.17-2.6.17.1/fs/namespace.c
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/namespace.c
++++ linux-source-2.6.17.14-ubuntu1/fs/namespace.c
 @@ -26,6 +26,12 @@
  #include <asm/uaccess.h>
  #include <asm/unistd.h>
@@ -424,97 +501,108 @@
  
  extern int __init init_rootfs(void);
  
-@@ -547,6 +553,10 @@ static int do_umount(struct vfsmount *mn
+@@ -547,6 +553,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -635,6 +645,9 @@ asmlinkage long sys_umount(char __user *
+@@ -635,6 +646,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -919,6 +932,10 @@ static int do_loopback(struct nameidata 
+@@ -919,6 +934,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1003,7 +1020,10 @@ static int do_move_mount(struct nameidat
+@@ -1003,7 +1023,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1105,6 +1125,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1105,6 +1129,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1396,6 +1420,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1396,6 +1425,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1685,6 +1716,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1685,6 +1725,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1701,6 +1735,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1701,6 +1745,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
  		goto out1;
---- linux-source-2.6.17-2.6.17.1.orig/fs/open.c
-+++ linux-source-2.6.17-2.6.17.1/fs/open.c
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/open.c
++++ linux-source-2.6.17.14-ubuntu1/fs/open.c
 @@ -31,6 +31,13 @@
  
  #include <asm/unistd.h>
@@ -529,52 +617,58 @@
  int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
  {
  	int retval = -ENODEV;
-@@ -267,6 +274,9 @@ static long do_sys_truncate(const char _
+@@ -267,6 +274,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -319,7 +329,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -319,7 +330,11 @@ static long do_sys_ftruncate(unsigned in
  	error = -EPERM;
  	if (IS_APPEND(inode))
  		goto out_putf;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, 0, file);
-@@ -608,6 +620,12 @@ asmlinkage long sys_chroot(const char __
+@@ -608,6 +623,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1199,6 +1217,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1199,6 +1222,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
  		return 0;
---- linux-source-2.6.17-2.6.17.1.orig/fs/proc/Makefile
-+++ linux-source-2.6.17-2.6.17.1/fs/proc/Makefile
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/proc/Makefile
++++ linux-source-2.6.17.14-ubuntu1/fs/proc/Makefile
 @@ -13,3 +13,6 @@ proc-y       += inode.o root.o base.o ge
  proc-$(CONFIG_PROC_KCORE)	+= kcore.o
  proc-$(CONFIG_PROC_VMCORE)	+= vmcore.o
@@ -582,20 +676,20 @@
 +
 +proc-$(CONFIG_SAKURA) += ccs_proc.o
 +proc-$(CONFIG_TOMOYO) += ccs_proc.o
---- linux-source-2.6.17-2.6.17.1.orig/fs/proc/proc_misc.c
-+++ linux-source-2.6.17-2.6.17.1/fs/proc/proc_misc.c
+--- linux-source-2.6.17.14-ubuntu1.orig/fs/proc/proc_misc.c
++++ linux-source-2.6.17.14-ubuntu1/fs/proc/proc_misc.c
 @@ -735,4 +735,9 @@ void __init proc_misc_init(void)
  	if (entry)
  		entry->proc_fops = &proc_sysrq_trigger_operations;
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.17.14-ubuntu1 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.17.14-ubuntu1 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
---- linux-source-2.6.17-2.6.17.1.orig/include/linux/init_task.h
-+++ linux-source-2.6.17-2.6.17.1/include/linux/init_task.h
+--- linux-source-2.6.17.14-ubuntu1.orig/include/linux/init_task.h
++++ linux-source-2.6.17.14-ubuntu1/include/linux/init_task.h
 @@ -123,6 +123,10 @@ extern struct group_info init_groups;
  	.journal_info	= NULL,						\
  	.cpu_timers	= INIT_CPU_TIMERS(tsk.cpu_timers),		\
@@ -607,8 +701,8 @@
  }
  
  
---- linux-source-2.6.17-2.6.17.1.orig/include/linux/sched.h
-+++ linux-source-2.6.17-2.6.17.1/include/linux/sched.h
+--- linux-source-2.6.17.14-ubuntu1.orig/include/linux/sched.h
++++ linux-source-2.6.17.14-ubuntu1/include/linux/sched.h
 @@ -25,6 +25,11 @@
  #define CLONE_CHILD_SETTID	0x01000000	/* set the TID in the child */
  #define CLONE_STOPPED		0x02000000	/* Start in stopped state */
@@ -632,8 +726,8 @@
  };
  
  static inline pid_t process_group(struct task_struct *tsk)
---- linux-source-2.6.17-2.6.17.1.orig/kernel/compat.c
-+++ linux-source-2.6.17-2.6.17.1/kernel/compat.c
+--- linux-source-2.6.17.14-ubuntu1.orig/kernel/compat.c
++++ linux-source-2.6.17.14-ubuntu1/kernel/compat.c
 @@ -23,6 +23,9 @@
  #include <linux/timex.h>
  
@@ -644,18 +738,19 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -842,6 +845,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -842,6 +845,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
---- linux-source-2.6.17-2.6.17.1.orig/kernel/kexec.c
-+++ linux-source-2.6.17-2.6.17.1/kernel/kexec.c
+--- linux-source-2.6.17.14-ubuntu1.orig/kernel/kexec.c
++++ linux-source-2.6.17.14-ubuntu1/kernel/kexec.c
 @@ -26,6 +26,9 @@
  #include <asm/io.h>
  #include <asm/system.h>
@@ -666,18 +761,19 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -922,6 +925,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -922,6 +925,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
  	 * Verify we have a legal set of flags
---- linux-source-2.6.17-2.6.17.1.orig/kernel/kmod.c
-+++ linux-source-2.6.17-2.6.17.1/kernel/kmod.c
+--- linux-source-2.6.17.14-ubuntu1.orig/kernel/kmod.c
++++ linux-source-2.6.17.14-ubuntu1/kernel/kmod.c
 @@ -149,6 +149,11 @@ static int ____call_usermodehelper(void 
  	/* We can run anywhere, unlike our parent keventd(). */
  	set_cpus_allowed(current, CPU_MASK_ALL);
@@ -690,8 +786,8 @@
  	retval = -EPERM;
  	if (current->fs->root)
  		retval = execve(sub_info->path, sub_info->argv,sub_info->envp);
---- linux-source-2.6.17-2.6.17.1.orig/kernel/module.c
-+++ linux-source-2.6.17-2.6.17.1/kernel/module.c
+--- linux-source-2.6.17.14-ubuntu1.orig/kernel/module.c
++++ linux-source-2.6.17.14-ubuntu1/kernel/module.c
 @@ -43,6 +43,9 @@
  #include <asm/uaccess.h>
  #include <asm/semaphore.h>
@@ -702,30 +798,32 @@
  
  #if 0
  #define DEBUGP printk
-@@ -596,7 +599,9 @@ sys_delete_module(const char __user *nam
+@@ -596,7 +599,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1789,7 +1794,9 @@ sys_init_module(void __user *umod,
+@@ -1789,7 +1795,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (mutex_lock_interruptible(&module_mutex) != 0)
  		return -EINTR;
---- linux-source-2.6.17-2.6.17.1.orig/kernel/sched.c
-+++ linux-source-2.6.17-2.6.17.1/kernel/sched.c
+--- linux-source-2.6.17.14-ubuntu1.orig/kernel/sched.c
++++ linux-source-2.6.17.14-ubuntu1/kernel/sched.c
 @@ -53,6 +53,9 @@
  #include <asm/tlb.h>
  
@@ -736,18 +834,19 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -3553,6 +3556,9 @@ asmlinkage long sys_nice(int increment)
+@@ -3553,6 +3556,10 @@ asmlinkage long sys_nice(int increment)
  {
  	int retval;
  	long nice;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
  	 * Setpriority might change our priority at the same moment.
---- linux-source-2.6.17-2.6.17.1.orig/kernel/signal.c
-+++ linux-source-2.6.17-2.6.17.1/kernel/signal.c
+--- linux-source-2.6.17.14-ubuntu1.orig/kernel/signal.c
++++ linux-source-2.6.17.14-ubuntu1/kernel/signal.c
 @@ -29,6 +29,9 @@
  #include <asm/uaccess.h>
  #include <asm/unistd.h>
@@ -758,41 +857,47 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2147,6 +2150,10 @@ asmlinkage long
+@@ -2147,6 +2150,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2205,6 +2212,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2205,6 +2214,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2218,6 +2229,10 @@ sys_tkill(int pid, int sig)
+@@ -2218,6 +2233,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
  }
---- linux-source-2.6.17-2.6.17.1.orig/kernel/sys.c
-+++ linux-source-2.6.17-2.6.17.1/kernel/sys.c
+--- linux-source-2.6.17.14-ubuntu1.orig/kernel/sys.c
++++ linux-source-2.6.17.14-ubuntu1/kernel/sys.c
 @@ -38,6 +38,9 @@
  #include <asm/uaccess.h>
  #include <asm/io.h>
@@ -803,48 +908,54 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -462,6 +465,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -462,6 +465,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -689,6 +695,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -689,6 +698,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1686,6 +1695,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1686,6 +1699,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1731,6 +1743,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1731,6 +1748,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
  	errno = -EFAULT;
---- linux-source-2.6.17-2.6.17.1.orig/kernel/sysctl.c
-+++ linux-source-2.6.17-2.6.17.1/kernel/sysctl.c
+--- linux-source-2.6.17.14-ubuntu1.orig/kernel/sysctl.c
++++ linux-source-2.6.17.14-ubuntu1/kernel/sysctl.c
 @@ -49,6 +49,9 @@
  
  #include <asm/uaccess.h>
@@ -855,24 +966,28 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1126,6 +1129,87 @@ void __init sysctl_init(void)
+@@ -1126,6 +1129,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -890,35 +1005,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -943,31 +1067,36 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1151,6 +1235,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1151,6 +1248,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1223,6 +1310,12 @@ repeat:
+@@ -1223,6 +1325,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
  						oldval, oldlenp,
---- linux-source-2.6.17-2.6.17.1.orig/kernel/time.c
-+++ linux-source-2.6.17-2.6.17.1/kernel/time.c
+--- linux-source-2.6.17.14-ubuntu1.orig/kernel/time.c
++++ linux-source-2.6.17.14-ubuntu1/kernel/time.c
 @@ -39,6 +39,9 @@
  
  #include <asm/uaccess.h>
@@ -978,38 +1107,41 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -91,6 +94,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -91,6 +94,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -161,6 +167,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -161,6 +168,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -221,6 +230,9 @@ int do_adjtimex(struct timex *txc)
+@@ -221,6 +232,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
  
---- linux-source-2.6.17-2.6.17.1.orig/net/core/datagram.c
-+++ linux-source-2.6.17-2.6.17.1/net/core/datagram.c
+--- linux-source-2.6.17.14-ubuntu1.orig/net/core/datagram.c
++++ linux-source-2.6.17.14-ubuntu1/net/core/datagram.c
 @@ -56,6 +56,11 @@
  #include <net/sock.h>
  #include <net/tcp_states.h>
@@ -1022,19 +1154,21 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
  			return skb;
  
---- linux-source-2.6.17-2.6.17.1.orig/net/ipv4/inet_connection_sock.c
-+++ linux-source-2.6.17-2.6.17.1/net/ipv4/inet_connection_sock.c
+--- linux-source-2.6.17.14-ubuntu1.orig/net/ipv4/inet_connection_sock.c
++++ linux-source-2.6.17.14-ubuntu1/net/ipv4/inet_connection_sock.c
 @@ -24,6 +24,9 @@
  #include <net/route.h>
  #include <net/tcp_states.h>
@@ -1045,18 +1179,19 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -88,6 +91,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -88,6 +91,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
---- linux-source-2.6.17-2.6.17.1.orig/net/ipv4/inet_hashtables.c
-+++ linux-source-2.6.17-2.6.17.1/net/ipv4/inet_hashtables.c
+--- linux-source-2.6.17.14-ubuntu1.orig/net/ipv4/inet_hashtables.c
++++ linux-source-2.6.17.14-ubuntu1/net/ipv4/inet_hashtables.c
 @@ -23,6 +23,9 @@
  #include <net/inet_connection_sock.h>
  #include <net/inet_hashtables.h>
@@ -1067,18 +1202,19 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -264,6 +267,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -264,6 +267,10 @@ int inet_hash_connect(struct inet_timewa
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
  
---- linux-source-2.6.17-2.6.17.1.orig/net/ipv4/udp.c
-+++ linux-source-2.6.17-2.6.17.1/net/ipv4/udp.c
+--- linux-source-2.6.17.14-ubuntu1.orig/net/ipv4/udp.c
++++ linux-source-2.6.17.14-ubuntu1/net/ipv4/udp.c
 @@ -109,6 +109,9 @@
  #include <net/inet_common.h>
  #include <net/checksum.h>
@@ -1089,28 +1225,30 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -147,6 +150,9 @@ static int udp_v4_get_port(struct sock *
+@@ -147,6 +150,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -163,6 +169,9 @@ static int udp_v4_get_port(struct sock *
+@@ -163,6 +170,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
  		}
---- linux-source-2.6.17-2.6.17.1.orig/net/ipv6/inet6_hashtables.c
-+++ linux-source-2.6.17-2.6.17.1/net/ipv6/inet6_hashtables.c
+--- linux-source-2.6.17.14-ubuntu1.orig/net/ipv6/inet6_hashtables.c
++++ linux-source-2.6.17.14-ubuntu1/net/ipv6/inet6_hashtables.c
 @@ -22,6 +22,9 @@
  #include <net/inet_hashtables.h>
  #include <net/inet6_hashtables.h>
@@ -1130,18 +1268,19 @@
  						inet->dport);
  	struct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);
  	struct sock *sk2;
-@@ -267,6 +270,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -267,6 +270,10 @@ int inet6_hash_connect(struct inet_timew
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
  
---- linux-source-2.6.17-2.6.17.1.orig/net/ipv6/udp.c
-+++ linux-source-2.6.17-2.6.17.1/net/ipv6/udp.c
+--- linux-source-2.6.17.14-ubuntu1.orig/net/ipv6/udp.c
++++ linux-source-2.6.17.14-ubuntu1/net/ipv6/udp.c
 @@ -59,6 +59,9 @@
  
  #include <linux/proc_fs.h>
@@ -1152,28 +1291,30 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6) __read_mostly;
  
-@@ -89,6 +92,9 @@ static int udp_v6_get_port(struct sock *
+@@ -89,6 +92,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -105,6 +111,9 @@ static int udp_v6_get_port(struct sock *
+@@ -105,6 +112,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
  		}
---- linux-source-2.6.17-2.6.17.1.orig/net/socket.c
-+++ linux-source-2.6.17-2.6.17.1/net/socket.c
+--- linux-source-2.6.17.14-ubuntu1.orig/net/socket.c
++++ linux-source-2.6.17.14-ubuntu1/net/socket.c
 @@ -95,6 +95,11 @@
  #include <net/sock.h>
  #include <linux/netfilter.h>
@@ -1186,54 +1327,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -592,7 +597,9 @@ static inline int __sock_sendmsg(struct 
+@@ -592,7 +597,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1148,6 +1155,10 @@ static int __sock_create(int family, int
+@@ -1148,6 +1158,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1341,6 +1352,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1341,6 +1357,13 @@ asmlinkage long sys_bind(int fd, struct 
  	{
  		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
  			err = security_socket_bind(sock, (struct sockaddr *)address, addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  					(struct sockaddr *)address, addrlen);
-@@ -1369,6 +1383,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1369,6 +1392,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1433,6 +1450,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1433,6 +1460,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1241,19 +1393,22 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1489,7 +1512,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1489,7 +1523,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
  out_put:
---- linux-source-2.6.17-2.6.17.1.orig/net/unix/af_unix.c
-+++ linux-source-2.6.17-2.6.17.1/net/unix/af_unix.c
+--- linux-source-2.6.17.14-ubuntu1.orig/net/unix/af_unix.c
++++ linux-source-2.6.17.14-ubuntu1/net/unix/af_unix.c
 @@ -117,6 +117,9 @@
  #include <linux/mount.h>
  #include <net/checksum.h>
@@ -1264,29 +1419,34 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -738,6 +741,10 @@ static int unix_bind(struct socket *sock
+@@ -738,6 +741,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -781,6 +788,9 @@ static int unix_bind(struct socket *sock
+@@ -781,6 +789,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
  			goto out_mknod_dput;
---- linux-source-2.6.17-2.6.17.1.orig/arch/alpha/kernel/ptrace.c
-+++ linux-source-2.6.17-2.6.17.1/arch/alpha/kernel/ptrace.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/alpha/kernel/ptrace.c
++++ linux-source-2.6.17.14-ubuntu1/arch/alpha/kernel/ptrace.c
 @@ -20,6 +20,9 @@
  #include <asm/pgtable.h>
  #include <asm/system.h>
@@ -1297,20 +1457,21 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	DBG(DBG_MEM, ("request=%ld pid=%ld addr=0x%lx data=0x%lx\n",
---- linux-source-2.6.17-2.6.17.1.orig/arch/ia64/kernel/ptrace.c
-+++ linux-source-2.6.17-2.6.17.1/arch/ia64/kernel/ptrace.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/ia64/kernel/ptrace.c
++++ linux-source-2.6.17.14-ubuntu1/arch/ia64/kernel/ptrace.c
 @@ -29,6 +29,9 @@
  #ifdef CONFIG_PERFMON
  #include <asm/perfmon.h>
@@ -1321,20 +1482,21 @@
  
  #include "entry.h"
  
-@@ -1418,6 +1421,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1418,6 +1421,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	ret = -EPERM;
---- linux-source-2.6.17-2.6.17.1.orig/arch/m32r/kernel/ptrace.c
-+++ linux-source-2.6.17-2.6.17.1/arch/m32r/kernel/ptrace.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/m32r/kernel/ptrace.c
++++ linux-source-2.6.17.14-ubuntu1/arch/m32r/kernel/ptrace.c
 @@ -33,6 +33,9 @@
  #include <asm/system.h>
  #include <asm/processor.h>
@@ -1345,20 +1507,21 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -743,6 +746,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -743,6 +746,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
---- linux-source-2.6.17-2.6.17.1.orig/arch/s390/kernel/ptrace.c
-+++ linux-source-2.6.17-2.6.17.1/arch/s390/kernel/ptrace.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/s390/kernel/ptrace.c
++++ linux-source-2.6.17.14-ubuntu1/arch/s390/kernel/ptrace.c
 @@ -41,6 +41,9 @@
  #include <asm/system.h>
  #include <asm/uaccess.h>
@@ -1369,20 +1532,21 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -711,6 +714,11 @@ sys_ptrace(long request, long pid, long 
+@@ -711,6 +714,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
  		 ret = ptrace_traceme();
---- linux-source-2.6.17-2.6.17.1.orig/arch/sparc/kernel/ptrace.c
-+++ linux-source-2.6.17-2.6.17.1/arch/sparc/kernel/ptrace.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/sparc/kernel/ptrace.c
++++ linux-source-2.6.17.14-ubuntu1/arch/sparc/kernel/ptrace.c
 @@ -23,6 +23,9 @@
  #include <asm/pgtable.h>
  #include <asm/system.h>
@@ -1408,8 +1572,8 @@
  
  	lock_kernel();
  #ifdef DEBUG_PTRACE
---- linux-source-2.6.17-2.6.17.1.orig/arch/sparc64/kernel/ptrace.c
-+++ linux-source-2.6.17-2.6.17.1/arch/sparc64/kernel/ptrace.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/sparc64/kernel/ptrace.c
++++ linux-source-2.6.17.14-ubuntu1/arch/sparc64/kernel/ptrace.c
 @@ -32,6 +32,9 @@
  #include <asm/spitfire.h>
  #include <asm/page.h>
@@ -1435,8 +1599,8 @@
  
  	if (test_thread_flag(TIF_32BIT)) {
  		addr &= 0xffffffffUL;
---- linux-source-2.6.17-2.6.17.1.orig/kernel/ptrace.c
-+++ linux-source-2.6.17-2.6.17.1/kernel/ptrace.c
+--- linux-source-2.6.17.14-ubuntu1.orig/kernel/ptrace.c
++++ linux-source-2.6.17.14-ubuntu1/kernel/ptrace.c
 @@ -21,6 +21,9 @@
  
  #include <asm/pgtable.h>
@@ -1447,20 +1611,21 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -494,6 +497,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -494,6 +497,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
  		ret = ptrace_traceme();
---- linux-source-2.6.17-2.6.17.1.orig/arch/sh64/kernel/ptrace.c
-+++ linux-source-2.6.17-2.6.17.1/arch/sh64/kernel/ptrace.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/sh64/kernel/ptrace.c
++++ linux-source-2.6.17.14-ubuntu1/arch/sh64/kernel/ptrace.c
 @@ -36,6 +36,9 @@
  #include <asm/system.h>
  #include <asm/processor.h>
@@ -1471,20 +1636,21 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -272,6 +275,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -272,6 +275,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (first_call) {
---- linux-source-2.6.17-2.6.17.1.orig/arch/x86_64/ia32/ptrace32.c
-+++ linux-source-2.6.17-2.6.17.1/arch/x86_64/ia32/ptrace32.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/x86_64/ia32/ptrace32.c
++++ linux-source-2.6.17.14-ubuntu1/arch/x86_64/ia32/ptrace32.c
 @@ -27,6 +27,9 @@
  #include <asm/debugreg.h>
  #include <asm/i387.h>
@@ -1495,20 +1661,21 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -206,6 +209,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -206,6 +209,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	switch (request) { 
  	default:
---- linux-source-2.6.17-2.6.17.1.orig/arch/ia64/ia32/sys_ia32.c
-+++ linux-source-2.6.17-2.6.17.1/arch/ia64/ia32/sys_ia32.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/ia64/ia32/sys_ia32.c
++++ linux-source-2.6.17.14-ubuntu1/arch/ia64/ia32/sys_ia32.c
 @@ -57,6 +57,9 @@
  #include <asm/types.h>
  #include <asm/uaccess.h>
@@ -1519,20 +1686,21 @@
  
  #include "ia32priv.h"
  
-@@ -1742,6 +1745,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1742,6 +1745,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
---- linux-source-2.6.17-2.6.17.1.orig/arch/mips/kernel/ptrace32.c
-+++ linux-source-2.6.17-2.6.17.1/arch/mips/kernel/ptrace32.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/mips/kernel/ptrace32.c
++++ linux-source-2.6.17.14-ubuntu1/arch/mips/kernel/ptrace32.c
 @@ -35,6 +35,9 @@
  #include <asm/system.h>
  #include <asm/uaccess.h>
@@ -1543,20 +1711,21 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  #if 0
  	printk("ptrace(r=%d,pid=%d,addr=%08lx,data=%08lx)\n",
---- linux-source-2.6.17-2.6.17.1.orig/arch/powerpc/kernel/ptrace32.c
-+++ linux-source-2.6.17-2.6.17.1/arch/powerpc/kernel/ptrace32.c
+--- linux-source-2.6.17.14-ubuntu1.orig/arch/powerpc/kernel/ptrace32.c
++++ linux-source-2.6.17.14-ubuntu1/arch/powerpc/kernel/ptrace32.c
 @@ -33,6 +33,9 @@
  #include <asm/page.h>
  #include <asm/pgtable.h>
@@ -1567,13 +1736,14 @@
  
  #include "ptrace-common.h"
  
-@@ -46,6 +49,11 @@ long compat_sys_ptrace(int request, int 
+@@ -46,6 +49,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.18-8.16AX.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.18-8.16AX.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.18-8.16AX.diff	(作業コピー)
@@ -3,47 +3,47 @@
 Source code for this patch is http://ftp.miraclelinux.com/pub/Asianux/Server/3.0/updates/src/kernel-2.6.18-8.15AX.src.rpm
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 ++++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 ++++
- fs/compat.c                     |    8 +++
- fs/exec.c                       |   15 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   61 ++++++++++++++++++++++++++
- fs/namespace.c                  |   39 ++++++++++++++++
- fs/open.c                       |   21 +++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |   11 +++
+ fs/exec.c                       |   21 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  118 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   50 ++++++++++++++++
+ fs/open.c                       |   27 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  fs/syaoran_2.6.c                |    2 
  include/linux/init_task.h       |    4 +
  include/linux/sched.h           |    9 +++
  include/linux/syaoran.h         |    2 
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |   11 +++-
- kernel/ptrace.c                 |   13 +++++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 ++++++
- kernel/sys.c                    |   15 ++++++
- kernel/sysctl.c                 |   93 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |   12 +++++
- net/core/datagram.c             |    9 +++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 +++
- net/ipv6/inet6_hashtables.c     |    8 +++
- net/ipv6/udp.c                  |    9 +++
- net/socket.c                    |   29 +++++++++++-
- net/unix/af_unix.c              |   10 ++++
- 41 files changed, 507 insertions(+), 11 deletions(-)
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   13 +++-
+ kernel/ptrace.c                 |   15 +++++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |  111 +++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   15 +++++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    9 ++-
+ net/ipv6/udp.c                  |   11 +++
+ net/socket.c                    |   43 +++++++++++++-
+ net/unix/af_unix.c              |   15 +++++
+ 41 files changed, 674 insertions(+), 11 deletions(-)
 
 --- linux-2.6.18-8.16AX.orig/Makefile
 +++ linux-2.6.18-8.16AX/Makefile
@@ -86,13 +86,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry * dentry
+@@ -145,12 +148,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -101,8 +105,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -119,17 +127,20 @@
  
  extern void sigset_from_compat(sigset_t *set, compat_sigset_t *compat);
  
-@@ -421,6 +424,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -421,6 +424,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1575,7 +1581,7 @@ int compat_do_execve(char * filename,
+@@ -1575,7 +1584,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -151,34 +162,40 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  int suid_dumpable = 0;
-@@ -139,6 +143,11 @@ asmlinkage long sys_uselib(const char __
+@@ -139,6 +143,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -486,6 +495,9 @@ struct file *open_exec(const char *name)
+@@ -486,6 +497,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1188,7 +1200,8 @@ int do_execve(char * filename,
+@@ -1188,7 +1206,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
@@ -195,12 +212,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -216,6 +219,10 @@ static int setfl(int fd, struct file * f
+@@ -216,6 +219,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -218,12 +237,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -23,6 +26,9 @@ static long do_ioctl(struct file *filp, 
+@@ -23,6 +26,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -241,29 +261,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1510,6 +1514,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1510,6 +1514,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1565,6 +1572,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1565,6 +1576,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1596,6 +1608,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1596,6 +1614,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -273,136 +299,187 @@
  /*
   *	open_namei()
   *
-@@ -1864,6 +1879,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1864,6 +1885,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1882,10 +1903,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1882,10 +1913,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1950,6 +1977,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1950,6 +2003,13 @@ asmlinkage long sys_mkdirat(int dfd, con
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -2058,6 +2088,9 @@ static long do_rmdir(int dfd, const char
+@@ -2058,6 +2118,13 @@ static long do_rmdir(int dfd, const char
  	dentry = lookup_hash(&nd);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -2117,6 +2150,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2117,6 +2184,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2138,6 +2174,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2138,6 +2209,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2200,6 +2239,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2200,6 +2279,10 @@ asmlinkage long sys_symlinkat(const char
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2216,6 +2258,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2216,6 +2299,13 @@ asmlinkage long sys_symlinkat(const char
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2288,6 +2333,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2288,6 +2378,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2310,6 +2358,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2310,6 +2404,15 @@ asmlinkage long sys_linkat(int olddfd, c
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2536,6 +2587,13 @@ static int do_rename(int olddfd, const c
+@@ -2536,6 +2639,17 @@ static int do_rename(int olddfd, const c
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2558,6 +2616,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2558,6 +2672,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -422,91 +499,102 @@
  
  extern int __init init_rootfs(void);
  
-@@ -560,6 +566,10 @@ static int do_umount(struct vfsmount *mn
+@@ -560,6 +566,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -656,6 +666,9 @@ asmlinkage long sys_umount(char __user *
+@@ -656,6 +667,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -940,6 +953,10 @@ static int do_loopback(struct nameidata 
+@@ -940,6 +955,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1024,7 +1041,10 @@ static int do_move_mount(struct nameidat
+@@ -1024,7 +1044,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1126,6 +1146,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1126,6 +1150,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1417,6 +1441,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1417,6 +1446,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1708,6 +1739,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1708,6 +1748,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1724,6 +1758,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1724,6 +1768,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -526,45 +614,51 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -267,6 +273,9 @@ static long do_sys_truncate(const char _
+@@ -267,6 +273,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -320,6 +329,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -320,6 +330,11 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, file);
-@@ -611,6 +623,12 @@ asmlinkage long sys_chroot(const char __
+@@ -611,6 +626,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1203,6 +1221,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1203,6 +1226,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
@@ -586,7 +680,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.18-8.16AX 2008/04/08\n");
++	printk(KERN_INFO "Hook version: 2.6.18-8.16AX 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -662,12 +756,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -836,6 +839,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -836,6 +839,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -684,12 +779,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -923,6 +926,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -923,6 +926,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -720,24 +816,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -653,7 +656,9 @@ sys_delete_module(const char __user *nam
+@@ -653,7 +656,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1898,7 +1903,9 @@ sys_init_module(void __user *umod,
+@@ -1898,7 +1904,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (mutex_lock_interruptible(&module_mutex) != 0)
@@ -754,12 +852,13 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -3979,6 +3982,9 @@ int can_nice(const struct task_struct *p
+@@ -3979,6 +3982,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -776,35 +875,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2090,6 +2093,10 @@ asmlinkage long
+@@ -2090,6 +2093,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2148,6 +2155,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2148,6 +2157,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2161,6 +2172,10 @@ sys_tkill(int pid, int sig)
+@@ -2161,6 +2176,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -821,42 +926,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -467,6 +470,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -467,6 +470,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -693,6 +699,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -693,6 +702,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1690,6 +1699,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1690,6 +1703,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1735,6 +1747,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1735,6 +1752,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -873,24 +984,28 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1222,6 +1225,87 @@ void __init sysctl_init(void)
+@@ -1222,6 +1225,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -908,35 +1023,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -961,25 +1085,30 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1247,6 +1331,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1247,6 +1344,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1319,6 +1406,12 @@ repeat:
+@@ -1319,6 +1421,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
@@ -996,32 +1125,35 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -91,6 +94,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -91,6 +94,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -161,6 +167,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -161,6 +168,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -221,6 +230,9 @@ int do_adjtimex(struct timex *txc)
+@@ -221,6 +232,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
@@ -1040,12 +1172,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1063,12 +1197,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -87,6 +90,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -87,6 +90,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1085,12 +1220,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -263,6 +266,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -263,6 +266,10 @@ int inet_hash_connect(struct inet_timewa
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1107,22 +1243,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -146,6 +149,9 @@ static int udp_v4_get_port(struct sock *
+@@ -146,6 +149,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -162,6 +168,9 @@ static int udp_v4_get_port(struct sock *
+@@ -162,6 +169,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1148,12 +1286,13 @@
  						inet->dport);
  	struct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);
  	struct sock *sk2;
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1170,22 +1309,24 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6) __read_mostly;
  
-@@ -88,6 +91,9 @@ static int udp_v6_get_port(struct sock *
+@@ -88,6 +91,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -104,6 +110,9 @@ static int udp_v6_get_port(struct sock *
+@@ -104,6 +111,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1204,54 +1345,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -595,7 +600,9 @@ static inline int __sock_sendmsg(struct 
+@@ -595,7 +600,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1160,6 +1167,10 @@ static int __sock_create(int family, int
+@@ -1160,6 +1170,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1362,6 +1373,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1362,6 +1378,13 @@ asmlinkage long sys_bind(int fd, struct 
  	{
  		if((err=move_addr_to_kernel(umyaddr,addrlen,address))>=0) {
  			err = security_socket_bind(sock, (struct sockaddr *)address, addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  					(struct sockaddr *)address, addrlen);
-@@ -1390,6 +1404,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1390,6 +1413,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1454,6 +1471,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1454,6 +1481,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1259,13 +1411,16 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1510,7 +1533,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1510,7 +1544,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
@@ -1282,23 +1437,28 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -764,6 +767,10 @@ static int unix_bind(struct socket *sock
+@@ -764,6 +767,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -807,6 +814,9 @@ static int unix_bind(struct socket *sock
+@@ -807,6 +815,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1315,13 +1475,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1339,13 +1500,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -742,6 +745,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -742,6 +745,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1390,25 +1552,27 @@
  
  #ifdef CONFIG_PTRACE
  #include <linux/utrace.h>
-@@ -932,6 +935,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -932,6 +935,12 @@ asmlinkage long sys_ptrace(long request,
  	struct utrace_attached_engine *engine;
  	struct ptrace_state *state;
  	long ret, val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  #ifdef PTRACE_DEBUG
  	printk("%d sys_ptrace(%ld, %ld, %lx, %lx)\n",
-@@ -1022,6 +1030,11 @@ asmlinkage long compat_sys_ptrace(compat
+@@ -1022,6 +1031,12 @@ asmlinkage long compat_sys_ptrace(compat
  	struct utrace_attached_engine *engine;
  	struct ptrace_state *state;
  	compat_long_t ret, val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1426,13 +1590,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -271,6 +274,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -271,6 +274,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1450,13 +1615,14 @@
  
  #include "ia32priv.h"
  
-@@ -1737,6 +1740,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1737,6 +1740,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1474,13 +1640,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.16.54-0.2.5_SUSE.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.16.54-0.2.5_SUSE.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.16.54-0.2.5_SUSE.diff	(作業コピー)
@@ -3,50 +3,50 @@
 Source code for this patch is http://ftp.riken.jp/Linux/suse/suse/update/10.1/rpm/src/kernel-source-2.6.16.54-0.2.5.src.rpm
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 ++++
- arch/sparc64/kernel/ptrace.c    |   11 ++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 ++++
- fs/compat.c                     |    8 +++
- fs/exec.c                       |   15 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   61 ++++++++++++++++++++++++++
- fs/namespace.c                  |   39 ++++++++++++++++
- fs/open.c                       |   23 +++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |   11 +++
+ fs/exec.c                       |   21 ++++++-
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  118 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   50 ++++++++++++++++
+ fs/open.c                       |   29 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
  include/linux/sched.h           |    9 +++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |   11 +++-
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 ++++++
- kernel/sys.c                    |   15 ++++++
- kernel/sysctl.c                 |   93 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |   12 +++++
- net/core/datagram.c             |    9 +++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 +++
- net/ipv6/inet6_hashtables.c     |    6 ++
- net/ipv6/udp.c                  |    9 +++
- net/socket.c                    |   30 +++++++++++-
- net/unix/af_unix.c              |   10 ++++
- 44 files changed, 543 insertions(+), 10 deletions(-)
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   13 +++-
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |  111 +++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   15 +++++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    7 ++
+ net/ipv6/udp.c                  |   11 +++
+ net/socket.c                    |   43 +++++++++++++-
+ net/unix/af_unix.c              |   15 +++++
+ 44 files changed, 712 insertions(+), 10 deletions(-)
 
 --- linux-2.6.16.54-0.2.5.orig/Makefile
 +++ linux-2.6.16.54-0.2.5/Makefile
@@ -89,13 +89,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry * dentry
+@@ -145,12 +148,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -104,8 +108,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -122,17 +130,20 @@
  
  extern void sigset_from_compat(sigset_t *set, compat_sigset_t *compat);
  
-@@ -405,6 +408,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -405,6 +408,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1532,7 +1538,7 @@ int compat_do_execve(char * filename,
+@@ -1532,7 +1541,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -154,34 +165,40 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  int suid_dumpable = 0;
-@@ -141,6 +145,11 @@ asmlinkage long sys_uselib(const char __
+@@ -141,6 +145,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -492,6 +501,9 @@ struct file *open_exec(const char *name)
+@@ -492,6 +503,13 @@ struct file *open_exec(const char *name)
  			int err = vfs_permission(&nd, MAY_EXEC);
  			if (!err && !(inode->i_mode & 0111))
  				err = -EACCES;
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1234,7 +1246,8 @@ int do_execve(char * filename,
+@@ -1234,7 +1252,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
@@ -198,12 +215,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -215,6 +218,10 @@ static int setfl(int fd, struct file * f
+@@ -215,6 +218,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -221,12 +240,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -24,6 +27,9 @@ static long do_ioctl(struct file *filp, 
+@@ -24,6 +27,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -244,29 +264,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1471,6 +1475,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1471,6 +1475,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1526,6 +1533,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1526,6 +1537,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1557,6 +1569,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1557,6 +1575,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -276,136 +302,187 @@
  /*
   *	open_namei()
   *
-@@ -1823,6 +1838,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1823,6 +1844,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1841,10 +1862,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1841,10 +1872,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1909,6 +1936,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1909,6 +1962,13 @@ asmlinkage long sys_mkdirat(int dfd, con
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -2017,6 +2047,9 @@ static long do_rmdir(int dfd, const char
+@@ -2017,6 +2077,13 @@ static long do_rmdir(int dfd, const char
  	dentry = lookup_hash(&nd);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -2076,6 +2109,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2076,6 +2143,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2097,6 +2133,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2097,6 +2168,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2159,6 +2198,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2159,6 +2238,10 @@ asmlinkage long sys_symlinkat(const char
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2175,6 +2217,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2175,6 +2258,13 @@ asmlinkage long sys_symlinkat(const char
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2247,6 +2292,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2247,6 +2337,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (flags != 0)
  		return -EINVAL;
-@@ -2267,6 +2315,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2267,6 +2361,15 @@ asmlinkage long sys_linkat(int olddfd, c
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2493,6 +2544,13 @@ static int do_rename(int olddfd, const c
+@@ -2493,6 +2596,17 @@ static int do_rename(int olddfd, const c
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2515,6 +2573,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2515,6 +2629,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -425,91 +502,102 @@
  
  extern int __init init_rootfs(void);
  
-@@ -510,6 +516,10 @@ static int do_umount(struct vfsmount *mn
+@@ -510,6 +516,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -598,6 +608,9 @@ asmlinkage long sys_umount(char __user *
+@@ -598,6 +609,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -882,6 +895,10 @@ static int do_loopback(struct nameidata 
+@@ -882,6 +897,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -966,7 +983,10 @@ static int do_move_mount(struct nameidat
+@@ -966,7 +986,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1068,6 +1088,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1068,6 +1092,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1285,6 +1309,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1285,6 +1314,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1574,6 +1605,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1574,6 +1614,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1590,6 +1624,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1590,6 +1634,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -530,46 +618,52 @@
  int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
  {
  	int retval = -ENODEV;
-@@ -267,6 +274,9 @@ static long do_sys_truncate(const char _
+@@ -267,6 +274,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -319,7 +329,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -319,7 +330,11 @@ static long do_sys_ftruncate(unsigned in
  	error = -EPERM;
  	if (IS_APPEND(inode))
  		goto out_putf;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, 0, file);
-@@ -608,6 +620,12 @@ asmlinkage long sys_chroot(const char __
+@@ -608,6 +623,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1196,6 +1214,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1196,6 +1219,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
@@ -591,7 +685,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.16.54-0.2.5_SUSE 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.16.54-0.2.5_SUSE 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -645,12 +739,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -864,6 +867,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -864,6 +867,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -667,12 +762,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -945,6 +948,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -945,6 +948,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -703,24 +799,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -624,7 +627,9 @@ sys_delete_module(const char __user *nam
+@@ -624,7 +627,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1873,7 +1878,9 @@ sys_init_module(void __user *umod,
+@@ -1873,7 +1879,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (down_interruptible(&module_mutex) != 0)
@@ -737,12 +835,13 @@
  
  #if defined(CONFIG_LKCD_DUMP) || defined(CONFIG_LKCD_DUMP_MODULE)
  /* used to soft spin in sched while dump is in progress */
-@@ -3569,6 +3572,9 @@ asmlinkage long sys_nice(int increment)
+@@ -3569,6 +3572,10 @@ asmlinkage long sys_nice(int increment)
  {
  	int retval;
  	long nice;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -759,35 +858,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2362,6 +2365,10 @@ asmlinkage long
+@@ -2362,6 +2365,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2420,6 +2427,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2420,6 +2429,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2433,6 +2444,10 @@ sys_tkill(int pid, int sig)
+@@ -2433,6 +2448,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -804,42 +909,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -275,6 +278,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -275,6 +278,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -502,6 +508,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -502,6 +511,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1539,6 +1548,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1539,6 +1552,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1584,6 +1596,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1584,6 +1601,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -856,24 +967,28 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1161,6 +1164,87 @@ void __init sysctl_init(void)
+@@ -1161,6 +1164,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -891,35 +1006,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -944,25 +1068,30 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1186,6 +1270,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1186,6 +1283,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1258,6 +1345,12 @@ repeat:
+@@ -1258,6 +1360,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
@@ -979,32 +1108,35 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -91,6 +94,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -91,6 +94,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -161,6 +167,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -161,6 +168,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -239,6 +248,9 @@ int do_adjtimex(struct timex *txc)
+@@ -239,6 +250,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
@@ -1023,12 +1155,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1046,12 +1180,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -86,6 +89,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -86,6 +89,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1068,12 +1203,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -268,6 +271,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -268,6 +271,10 @@ int inet_hash_connect(struct inet_timewa
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1090,22 +1226,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -147,6 +150,9 @@ static int udp_v4_get_port(struct sock *
+@@ -147,6 +150,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -163,6 +169,9 @@ static int udp_v4_get_port(struct sock *
+@@ -163,6 +170,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1122,12 +1260,13 @@
  
  struct sock *inet6_lookup_listener(struct inet_hashinfo *hashinfo,
  				   const struct in6_addr *daddr,
-@@ -187,6 +190,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -187,6 +190,10 @@ int inet6_hash_connect(struct inet_timew
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1144,22 +1283,24 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6) __read_mostly;
  
-@@ -89,6 +92,9 @@ static int udp_v6_get_port(struct sock *
+@@ -89,6 +92,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -105,6 +111,9 @@ static int udp_v6_get_port(struct sock *
+@@ -105,6 +112,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
@@ -1178,55 +1319,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -549,7 +554,9 @@ static inline int __sock_sendmsg(struct 
+@@ -549,7 +554,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1105,6 +1112,10 @@ static int __sock_create(int family, int
+@@ -1105,6 +1115,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1302,6 +1313,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1302,6 +1318,12 @@ asmlinkage long sys_bind(int fd, struct 
  				sockfd_put(sock);
  				return err;
  			}
 +			/***** TOMOYO Linux start. *****/
-+			if ((err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++			err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++							 address, addrlen);
++			if (!err)
 +			/***** TOMOYO Linux end. *****/
  			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
  		}
  		sockfd_put(sock);
-@@ -1332,7 +1346,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1332,7 +1354,10 @@ asmlinkage long sys_listen(int fd, int b
  			sockfd_put(sock);
  			return err;
  		}
 -
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = ccs_socket_listen_permission(sock)) == 0)
++		err = ccs_socket_listen_permission(sock);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err=sock->ops->listen(sock, backlog);
  		sockfd_put(sock);
  	}
-@@ -1383,6 +1399,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1383,6 +1408,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_release;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_release;
 +	}
@@ -1234,13 +1385,16 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1438,7 +1460,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1438,7 +1470,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
@@ -1257,23 +1411,28 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -738,6 +741,10 @@ static int unix_bind(struct socket *sock
+@@ -738,6 +741,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -781,6 +788,9 @@ static int unix_bind(struct socket *sock
+@@ -781,6 +789,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1290,13 +1449,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1314,13 +1474,14 @@
  
  #include "entry.h"
  
-@@ -1492,6 +1495,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1492,6 +1495,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1338,13 +1499,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -743,6 +746,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -743,6 +746,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1362,13 +1524,14 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -711,6 +714,11 @@ sys_ptrace(long request, long pid, long 
+@@ -711,6 +714,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -1440,13 +1603,14 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -495,6 +498,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -495,6 +498,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -1464,13 +1628,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -272,6 +275,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -272,6 +275,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1488,13 +1653,14 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -206,6 +209,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -206,6 +209,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1512,13 +1678,14 @@
  
  #include "ia32priv.h"
  
-@@ -1755,6 +1758,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1755,6 +1758,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1536,13 +1703,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1560,13 +1728,14 @@
  
  #include "ptrace-common.h"
  
-@@ -46,6 +49,11 @@ long compat_sys_ptrace(int request, int 
+@@ -46,6 +49,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.20-1.2320.fc5.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.20-1.2320.fc5.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.20-1.2320.fc5.diff	(作業コピー)
@@ -3,50 +3,50 @@
 Source code for this patch is http://ftp.riken.jp/Linux/fedora/core/updates/5/SRPMS/kernel-2.6.20-1.2320.fc5.src.rpm
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 ++++
- arch/sparc64/kernel/ptrace.c    |   11 ++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 ++++
- fs/compat.c                     |    8 ++-
- fs/exec.c                       |   15 +++++-
- fs/fcntl.c                      |    7 ++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   60 +++++++++++++++++++++++++
- fs/namespace.c                  |   39 ++++++++++++++++
- fs/open.c                       |   21 ++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |   11 +++
+ fs/exec.c                       |   21 +++++++
+ fs/fcntl.c                      |    9 +++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  112 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   50 +++++++++++++++++
+ fs/open.c                       |   26 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
  include/linux/sched.h           |    9 +++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |   11 +++-
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 ++++++
- kernel/sys.c                    |   15 ++++++
- kernel/sysctl.c                 |   94 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |    9 +++
- kernel/time/ntp.c               |    6 ++
- net/core/datagram.c             |    9 +++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/inet_hashtables.c      |    6 ++
- net/ipv4/udp.c                  |    9 +++
- net/ipv6/inet6_hashtables.c     |    6 ++
- net/socket.c                    |   29 +++++++++++-
- net/unix/af_unix.c              |   10 ++++
- 44 files changed, 537 insertions(+), 7 deletions(-)
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   13 +++-
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |  112 ++++++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   11 +++
+ kernel/time/ntp.c               |    7 ++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/inet_hashtables.c      |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/inet6_hashtables.c     |    7 ++
+ net/socket.c                    |   42 ++++++++++++++-
+ net/unix/af_unix.c              |   15 +++++
+ 44 files changed, 698 insertions(+), 7 deletions(-)
 
 --- linux-2.6.20-1.2320.fc5.orig/Makefile
 +++ linux-2.6.20-1.2320.fc5/Makefile
@@ -71,13 +71,14 @@
  
  #include "proto.h"
  
-@@ -268,6 +271,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -268,6 +271,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -95,13 +96,14 @@
  
  #include "entry.h"
  
-@@ -1417,6 +1420,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1417,6 +1420,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -119,13 +121,14 @@
  
  /*
   * This routine will get a word off of the process kernel stack.
-@@ -742,6 +745,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -742,6 +745,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -143,13 +146,14 @@
  
  #ifdef CONFIG_COMPAT
  #include "compat_ptrace.h"
-@@ -711,6 +714,11 @@ sys_ptrace(long request, long pid, long 
+@@ -711,6 +714,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -239,13 +243,17 @@
  
  /* Taken over from the old code... */
  
-@@ -145,12 +148,20 @@ int notify_change(struct dentry * dentry
+@@ -145,12 +148,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -254,8 +262,12 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
@@ -272,17 +284,20 @@
  
  int compat_log = 1;
  
-@@ -421,6 +424,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -421,6 +424,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1551,7 +1557,7 @@ int compat_do_execve(char * filename,
+@@ -1551,7 +1560,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -304,34 +319,40 @@
  int core_uses_pid;
  char core_pattern[128] = "core";
  int suid_dumpable = 0;
-@@ -140,6 +144,11 @@ asmlinkage long sys_uselib(const char __
+@@ -140,6 +144,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -487,6 +496,9 @@ struct file *open_exec(const char *name)
+@@ -487,6 +498,13 @@ struct file *open_exec(const char *name)
  		if (!(nd.mnt->mnt_flags & MNT_NOEXEC) &&
  		    S_ISREG(inode->i_mode)) {
  			int err = vfs_permission(&nd, MAY_EXEC);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1185,7 +1197,8 @@ int do_execve(char * filename,
+@@ -1185,7 +1203,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
@@ -348,12 +369,14 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -213,6 +216,10 @@ static int setfl(int fd, struct file * f
+@@ -213,6 +216,12 @@ static int setfl(int fd, struct file * f
  	if (((arg ^ filp->f_flags) & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (((arg ^ filp->f_flags) & O_APPEND) &&
++	    ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
@@ -371,12 +394,13 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -23,6 +26,9 @@ static long do_ioctl(struct file *filp, 
+@@ -23,6 +26,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
@@ -394,29 +418,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1506,6 +1510,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1506,6 +1510,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1561,6 +1568,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1561,6 +1572,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1610,6 +1622,9 @@ static int open_namei_create(struct name
+@@ -1610,6 +1628,9 @@ static int open_namei_create(struct name
  	return may_open(nd, 0, flag & ~O_TRUNC);
  }
  
@@ -426,135 +456,181 @@
  /*
   *	open_namei()
   *
-@@ -1870,6 +1885,12 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1870,6 +1891,16 @@ asmlinkage long sys_mknodat(int dfd, con
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1888,10 +1909,16 @@ asmlinkage long sys_mknodat(int dfd, con
+@@ -1888,10 +1919,32 @@ asmlinkage long sys_mknodat(int dfd, con
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1959,6 +1986,9 @@ asmlinkage long sys_mkdirat(int dfd, con
+@@ -1959,6 +2012,12 @@ asmlinkage long sys_mkdirat(int dfd, con
  
  	if (!IS_POSIXACL(nd.dentry->d_inode))
  		mode &= ~current->fs->umask;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  	dput(dentry);
  out_unlock:
-@@ -2066,6 +2096,9 @@ static long do_rmdir(int dfd, const char
+@@ -2066,6 +2125,12 @@ static long do_rmdir(int dfd, const char
  	error = PTR_ERR(dentry);
  	if (IS_ERR(dentry))
  		goto exit2;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_rmdir(nd.dentry->d_inode, dentry);
  	dput(dentry);
  exit2:
-@@ -2125,6 +2158,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2125,6 +2190,10 @@ static long do_unlinkat(int dfd, const c
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2146,6 +2182,9 @@ static long do_unlinkat(int dfd, const c
+@@ -2146,6 +2215,14 @@ static long do_unlinkat(int dfd, const c
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2210,6 +2249,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2210,6 +2287,10 @@ asmlinkage long sys_symlinkat(const char
  	char * to;
  	struct dentry *dentry;
  	struct nameidata nd;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2227,6 +2269,9 @@ asmlinkage long sys_symlinkat(const char
+@@ -2227,6 +2308,12 @@ asmlinkage long sys_symlinkat(const char
  	if (IS_ERR(dentry))
  		goto out_unlock;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++	if (!error)
++		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  	dput(dentry);
  out_unlock:
-@@ -2299,6 +2344,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2299,6 +2386,10 @@ asmlinkage long sys_linkat(int olddfd, c
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
  		return -EINVAL;
-@@ -2322,6 +2370,9 @@ asmlinkage long sys_linkat(int olddfd, c
+@@ -2322,6 +2413,13 @@ asmlinkage long sys_linkat(int olddfd, c
  	error = PTR_ERR(new_dentry);
  	if (IS_ERR(new_dentry))
  		goto out_unlock;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
++	if (!error)
++		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
++					     old_nd.mnt, new_dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  	dput(new_dentry);
  out_unlock:
-@@ -2547,6 +2598,12 @@ static int do_rename(int olddfd, const c
+@@ -2547,6 +2645,16 @@ static int do_rename(int olddfd, const c
  	error = -ENOTEMPTY;
  	if (new_dentry == trap)
  		goto exit5;
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
  
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
-@@ -2570,6 +2627,9 @@ asmlinkage long sys_renameat(int olddfd,
+@@ -2570,6 +2678,10 @@ asmlinkage long sys_renameat(int olddfd,
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
@@ -574,91 +650,102 @@
  
  /* spinlock for vfsmount related operations, inplace of dcache_lock */
  __cacheline_aligned_in_smp DEFINE_SPINLOCK(vfsmount_lock);
-@@ -546,6 +552,10 @@ static int do_umount(struct vfsmount *mn
+@@ -546,6 +552,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -634,6 +644,9 @@ asmlinkage long sys_umount(char __user *
+@@ -634,6 +645,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -918,6 +931,10 @@ static int do_loopback(struct nameidata 
+@@ -918,6 +933,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -1002,7 +1019,10 @@ static int do_move_mount(struct nameidat
+@@ -1002,7 +1022,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	mutex_lock(&nd->dentry->d_inode->i_mutex);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1104,6 +1124,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1104,6 +1128,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1395,6 +1419,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1395,6 +1424,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1687,6 +1718,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1687,6 +1727,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1703,6 +1737,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1703,6 +1747,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
@@ -678,45 +765,50 @@
  
  int vfs_statfs(struct dentry *dentry, struct kstatfs *buf)
  {
-@@ -264,6 +270,9 @@ static long do_sys_truncate(const char _
+@@ -264,6 +270,10 @@ static long do_sys_truncate(const char _
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -317,6 +326,9 @@ static long do_sys_ftruncate(unsigned in
+@@ -317,6 +327,10 @@ static long do_sys_ftruncate(unsigned in
  	if (IS_APPEND(inode))
  		goto out_putf;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, ATTR_MTIME|ATTR_CTIME, file);
-@@ -481,6 +493,12 @@ asmlinkage long sys_chroot(const char __
+@@ -481,6 +495,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1084,6 +1102,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1084,6 +1106,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		/* XXX: this needs locking */
@@ -738,7 +830,7 @@
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.20-1.2320.fc5 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.20-1.2320.fc5 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
@@ -792,12 +884,13 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -869,6 +872,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -869,6 +872,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
@@ -814,12 +907,13 @@
  
  /* Per cpu memory for storing cpu states in case of system crash. */
  note_buf_t* crash_notes;
-@@ -924,6 +927,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -924,6 +927,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -850,24 +944,26 @@
  
  #if 0
  #define DEBUGP printk
-@@ -659,7 +662,9 @@ sys_delete_module(const char __user *nam
+@@ -659,7 +662,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1972,7 +1977,9 @@ sys_init_module(void __user *umod,
+@@ -1972,7 +1978,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (mutex_lock_interruptible(&module_mutex) != 0)
@@ -884,13 +980,14 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -456,6 +459,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -456,6 +459,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
@@ -908,12 +1005,13 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -4097,6 +4100,9 @@ int can_nice(const struct task_struct *p
+@@ -4097,6 +4100,10 @@ int can_nice(const struct task_struct *p
  asmlinkage long sys_nice(int increment)
  {
  	long nice, retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
@@ -930,35 +1028,41 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2267,6 +2270,10 @@ asmlinkage long
+@@ -2267,6 +2270,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2325,6 +2332,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2325,6 +2334,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2338,6 +2349,10 @@ sys_tkill(int pid, int sig)
+@@ -2338,6 +2353,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
@@ -975,42 +1079,48 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -599,6 +602,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -599,6 +602,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -822,6 +828,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -822,6 +831,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Instead of trying to make the power_off code look like
  	 * halt when pm_power_off is not set do it the easy way.
-@@ -1799,6 +1808,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1799,6 +1812,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1844,6 +1856,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1844,6 +1861,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
@@ -1027,25 +1137,29 @@
  
  extern int proc_nr_files(ctl_table *table, int write, struct file *filp,
                       void __user *buffer, size_t *lenp, loff_t *ppos);
-@@ -1260,6 +1263,88 @@ void __init sysctl_init(void)
+@@ -1260,6 +1263,101 @@ void __init sysctl_init(void)
  }
  
  #ifdef CONFIG_SYSCTL_SYSCALL
 +
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -1063,35 +1177,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -1116,25 +1239,30 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1284,6 +1369,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1284,6 +1382,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table);
  
-@@ -1358,6 +1446,12 @@ repeat:
+@@ -1358,6 +1461,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
@@ -1151,22 +1279,24 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -91,6 +94,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -91,6 +94,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -161,6 +167,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -161,6 +168,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
@@ -1183,12 +1313,13 @@
  
  /*
   * Timekeeping variables
-@@ -199,6 +202,9 @@ int do_adjtimex(struct timex *txc)
+@@ -199,6 +202,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/* Now we validate the data before disabling interrupts */
@@ -1207,12 +1338,14 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -178,6 +183,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -178,6 +183,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
@@ -1230,12 +1363,13 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -85,6 +88,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -85,6 +88,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
@@ -1252,12 +1386,13 @@
  
  /*
   * Allocate and initialize a new local port bind bucket.
-@@ -292,6 +295,9 @@ int inet_hash_connect(struct inet_timewa
+@@ -292,6 +295,10 @@ int inet_hash_connect(struct inet_timewa
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1274,22 +1409,24 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -162,6 +165,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -162,6 +165,10 @@ int __udp_lib_get_port(struct sock *sk, 
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -180,6 +186,9 @@ int __udp_lib_get_port(struct sock *sk, 
+@@ -180,6 +187,10 @@ int __udp_lib_get_port(struct sock *sk, 
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (! __udp_lib_lport_inuse(result, udptable))
  				break;
@@ -1306,12 +1443,13 @@
  
  void __inet6_hash(struct inet_hashinfo *hashinfo,
  				struct sock *sk)
-@@ -266,6 +269,9 @@ int inet6_hash_connect(struct inet_timew
+@@ -266,6 +269,10 @@ int inet6_hash_connect(struct inet_timew
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &hinfo->bhash[inet_bhashfn(port, hinfo->bhash_size)];
   			spin_lock(&head->lock);
@@ -1330,54 +1468,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,
  			 unsigned long nr_segs, loff_t pos);
-@@ -562,7 +567,9 @@ static inline int __sock_sendmsg(struct 
+@@ -562,7 +567,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1083,6 +1090,10 @@ static int __sock_create(int family, int
+@@ -1083,6 +1093,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1285,6 +1296,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1285,6 +1301,13 @@ asmlinkage long sys_bind(int fd, struct 
  			err = security_socket_bind(sock,
  						   (struct sockaddr *)address,
  						   addrlen);
 +			/***** TOMOYO Linux start. *****/
-+			if (!err) err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen);
++			if (!err)
++				err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++								 address,
++								 addrlen);
 +			/***** TOMOYO Linux end. *****/
  			if (!err)
  				err = sock->ops->bind(sock,
  						      (struct sockaddr *)
-@@ -1314,6 +1328,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1314,6 +1337,10 @@ asmlinkage long sys_listen(int fd, int b
  			backlog = sysctl_somaxconn;
  
  		err = security_socket_listen(sock, backlog);
 +		/***** TOMOYO Linux start. *****/
-+		if (!err) err = ccs_socket_listen_permission(sock);
++		if (!err)
++			err = ccs_socket_listen_permission(sock);
 +		/***** TOMOYO Linux end. *****/
  		if (!err)
  			err = sock->ops->listen(sock, backlog);
  
-@@ -1378,6 +1395,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1378,6 +1405,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_fd;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_fd;
 +	}
@@ -1385,13 +1534,15 @@
  	if (upeer_sockaddr) {
  		if (newsock->ops->getname(newsock, (struct sockaddr *)address,
  					  &len, 2) < 0) {
-@@ -1442,6 +1465,10 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1442,6 +1476,12 @@ asmlinkage long sys_connect(int fd, stru
  	    security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 +	/***** TOMOYO Linux start. *****/
-+	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen);
-+	if (err) goto out_put;
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  
  	err = sock->ops->connect(sock, (struct sockaddr *)address, addrlen,
@@ -1408,23 +1559,28 @@
  
  int sysctl_unix_max_dgram_qlen __read_mostly = 10;
  
-@@ -765,6 +768,10 @@ static int unix_bind(struct socket *sock
+@@ -765,6 +768,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -808,6 +815,9 @@ static int unix_bind(struct socket *sock
+@@ -808,6 +816,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
@@ -1441,13 +1597,14 @@
  
  #include "ia32priv.h"
  
-@@ -1754,6 +1757,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1754,6 +1757,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1465,13 +1622,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1489,13 +1647,14 @@
  
  #include "ptrace-common.h"
  
-@@ -45,6 +48,11 @@ long compat_sys_ptrace(int request, int 
+@@ -45,6 +48,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1513,13 +1672,14 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -271,6 +274,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -271,6 +274,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
@@ -1537,13 +1697,14 @@
  
  /*
   * Determines which flags the user has access to [1 = access, 0 = no access].
-@@ -234,6 +237,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -234,6 +237,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
Index: trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.15.7-ubuntu1.diff
===================================================================
--- trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.15.7-ubuntu1.diff	(リビジョン 1169)
+++ trunk/1.6.x/ccs-patch/patches/ccs-patch-2.6.15.7-ubuntu1.diff	(作業コピー)
@@ -3,53 +3,53 @@
 Source code for this patch is "apt-get install linux-source-2.6.15"
 ---
  Makefile                        |    2 
- arch/alpha/kernel/ptrace.c      |    8 +++
- arch/ia64/ia32/sys_ia32.c       |    8 +++
- arch/ia64/kernel/ptrace.c       |    8 +++
- arch/m32r/kernel/ptrace.c       |    8 +++
- arch/mips/kernel/ptrace32.c     |    8 +++
- arch/powerpc/kernel/ptrace32.c  |    8 +++
- arch/s390/kernel/ptrace.c       |    8 +++
- arch/sh64/kernel/ptrace.c       |    8 +++
- arch/sparc/kernel/ptrace.c      |   11 ++++
- arch/sparc64/kernel/ptrace.c    |   11 ++++
- arch/x86_64/ia32/ptrace32.c     |    8 +++
+ arch/alpha/kernel/ptrace.c      |    9 +++
+ arch/ia64/ia32/sys_ia32.c       |    9 +++
+ arch/ia64/kernel/ptrace.c       |    9 +++
+ arch/m32r/kernel/ptrace.c       |    9 +++
+ arch/mips/kernel/ptrace32.c     |    9 +++
+ arch/powerpc/kernel/ptrace32.c  |    9 +++
+ arch/s390/kernel/ptrace.c       |    9 +++
+ arch/sh64/kernel/ptrace.c       |    9 +++
+ arch/sparc/kernel/ptrace.c      |   11 +++
+ arch/sparc64/kernel/ptrace.c    |   11 +++
+ arch/x86_64/ia32/ptrace32.c     |    9 +++
  fs/Kconfig                      |    2 
  fs/Makefile                     |    2 
- fs/attr.c                       |   11 ++++
- fs/compat.c                     |    8 +++
- fs/exec.c                       |   15 ++++++
- fs/fcntl.c                      |    7 +++
- fs/ioctl.c                      |    6 ++
- fs/namei.c                      |   61 ++++++++++++++++++++++++++
- fs/namespace.c                  |   39 ++++++++++++++++
- fs/open.c                       |   23 +++++++++
+ fs/attr.c                       |   19 ++++++
+ fs/compat.c                     |   11 +++
+ fs/exec.c                       |   21 ++++++-
+ fs/fcntl.c                      |    8 ++
+ fs/ioctl.c                      |    7 ++
+ fs/namei.c                      |  118 ++++++++++++++++++++++++++++++++++++++++
+ fs/namespace.c                  |   50 ++++++++++++++++
+ fs/open.c                       |   29 +++++++++
  fs/proc/Makefile                |    3 +
- fs/proc/proc_misc.c             |    5 ++
+ fs/proc/proc_misc.c             |    5 +
  include/linux/init_task.h       |    4 +
  include/linux/sched.h           |    9 +++
- kernel/compat.c                 |    6 ++
- kernel/kexec.c                  |    6 ++
- kernel/kmod.c                   |    5 ++
- kernel/module.c                 |   11 +++-
- kernel/ptrace.c                 |    8 +++
- kernel/sched.c                  |    6 ++
- kernel/signal.c                 |   15 ++++++
- kernel/sys.c                    |   15 ++++++
- kernel/sysctl.c                 |   93 ++++++++++++++++++++++++++++++++++++++++
- kernel/time.c                   |   12 +++++
- net/core/datagram.c             |    9 +++
- net/ipv4/inet_connection_sock.c |    6 ++
- net/ipv4/tcp_ipv4.c             |    6 ++
- net/ipv4/udp.c                  |    9 +++
- net/ipv6/tcp_ipv6.c             |    9 +++
- net/ipv6/udp.c                  |    9 +++
- net/socket.c                    |   30 +++++++++++-
- net/unix/af_unix.c              |   10 ++++
- 44 files changed, 546 insertions(+), 10 deletions(-)
+ kernel/compat.c                 |    7 ++
+ kernel/kexec.c                  |    7 ++
+ kernel/kmod.c                   |    5 +
+ kernel/module.c                 |   13 +++-
+ kernel/ptrace.c                 |    9 +++
+ kernel/sched.c                  |    7 ++
+ kernel/signal.c                 |   21 +++++++
+ kernel/sys.c                    |   21 +++++++
+ kernel/sysctl.c                 |  111 +++++++++++++++++++++++++++++++++++++
+ kernel/time.c                   |   15 +++++
+ net/core/datagram.c             |   11 +++
+ net/ipv4/inet_connection_sock.c |    7 ++
+ net/ipv4/tcp_ipv4.c             |    7 ++
+ net/ipv4/udp.c                  |   11 +++
+ net/ipv6/tcp_ipv6.c             |   11 +++
+ net/ipv6/udp.c                  |   11 +++
+ net/socket.c                    |   43 +++++++++++++-
+ net/unix/af_unix.c              |   15 +++++
+ 44 files changed, 715 insertions(+), 10 deletions(-)
 
---- linux-source-2.6.15-2.6.15.orig/Makefile
-+++ linux-source-2.6.15-2.6.15/Makefile
+--- linux-source-2.6.15.7-ubuntu1.orig/Makefile
++++ linux-source-2.6.15.7-ubuntu1/Makefile
 @@ -1,7 +1,7 @@
  VERSION = 2
  PATCHLEVEL = 6
@@ -59,8 +59,8 @@
  NAME=Sliding Snow Leopard
  
  ifdef UBUNTUBUILD
---- linux-source-2.6.15-2.6.15.orig/arch/alpha/kernel/ptrace.c
-+++ linux-source-2.6.15-2.6.15/arch/alpha/kernel/ptrace.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/alpha/kernel/ptrace.c
++++ linux-source-2.6.15.7-ubuntu1/arch/alpha/kernel/ptrace.c
 @@ -20,6 +20,9 @@
  #include <asm/pgtable.h>
  #include <asm/system.h>
@@ -71,20 +71,21 @@
  
  #include "proto.h"
  
-@@ -261,6 +264,11 @@ do_sys_ptrace(long request, long pid, lo
+@@ -261,6 +264,12 @@ do_sys_ptrace(long request, long pid, lo
  	unsigned long tmp;
  	size_t copied;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	DBG(DBG_MEM, ("request=%ld pid=%ld addr=0x%lx data=0x%lx\n",
---- linux-source-2.6.15-2.6.15.orig/arch/ia64/kernel/ptrace.c
-+++ linux-source-2.6.15-2.6.15/arch/ia64/kernel/ptrace.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/ia64/kernel/ptrace.c
++++ linux-source-2.6.15.7-ubuntu1/arch/ia64/kernel/ptrace.c
 @@ -29,6 +29,9 @@
  #ifdef CONFIG_PERFMON
  #include <asm/perfmon.h>
@@ -95,20 +96,21 @@
  
  #include "entry.h"
  
-@@ -1418,6 +1421,11 @@ sys_ptrace (long request, pid_t pid, uns
+@@ -1418,6 +1421,12 @@ sys_ptrace (long request, pid_t pid, uns
  	struct task_struct *child;
  	struct switch_stack *sw;
  	long ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	ret = -EPERM;
---- linux-source-2.6.15-2.6.15.orig/arch/m32r/kernel/ptrace.c
-+++ linux-source-2.6.15-2.6.15/arch/m32r/kernel/ptrace.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/m32r/kernel/ptrace.c
++++ linux-source-2.6.15.7-ubuntu1/arch/m32r/kernel/ptrace.c
 @@ -33,6 +33,9 @@
  #include <asm/system.h>
  #include <asm/processor.h>
@@ -119,20 +121,21 @@
  
  /*
   * Get the address of the live pt_regs for the specified task.
-@@ -760,6 +763,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -760,6 +763,12 @@ asmlinkage long sys_ptrace(long request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	ret = -EPERM;
---- linux-source-2.6.15-2.6.15.orig/arch/s390/kernel/ptrace.c
-+++ linux-source-2.6.15-2.6.15/arch/s390/kernel/ptrace.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/s390/kernel/ptrace.c
++++ linux-source-2.6.15.7-ubuntu1/arch/s390/kernel/ptrace.c
 @@ -41,6 +41,9 @@
  #include <asm/system.h>
  #include <asm/uaccess.h>
@@ -143,20 +146,21 @@
  
  #ifdef CONFIG_S390_SUPPORT
  #include "compat_ptrace.h"
-@@ -711,6 +714,11 @@ sys_ptrace(long request, long pid, long 
+@@ -711,6 +714,12 @@ sys_ptrace(long request, long pid, long 
  	struct task_struct *child;
  	int ret;
  
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
  
  	if (request == PTRACE_TRACEME) {
---- linux-source-2.6.15-2.6.15.orig/arch/sparc/kernel/ptrace.c
-+++ linux-source-2.6.15-2.6.15/arch/sparc/kernel/ptrace.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/sparc/kernel/ptrace.c
++++ linux-source-2.6.15.7-ubuntu1/arch/sparc/kernel/ptrace.c
 @@ -23,6 +23,9 @@
  #include <asm/pgtable.h>
  #include <asm/system.h>
@@ -182,8 +186,8 @@
  
  	lock_kernel();
  #ifdef DEBUG_PTRACE
---- linux-source-2.6.15-2.6.15.orig/arch/sparc64/kernel/ptrace.c
-+++ linux-source-2.6.15-2.6.15/arch/sparc64/kernel/ptrace.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/sparc64/kernel/ptrace.c
++++ linux-source-2.6.15.7-ubuntu1/arch/sparc64/kernel/ptrace.c
 @@ -32,6 +32,9 @@
  #include <asm/spitfire.h>
  #include <asm/page.h>
@@ -209,8 +213,8 @@
  
  	if (test_thread_flag(TIF_32BIT)) {
  		addr &= 0xffffffffUL;
---- linux-source-2.6.15-2.6.15.orig/fs/Kconfig
-+++ linux-source-2.6.15-2.6.15/fs/Kconfig
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/Kconfig
++++ linux-source-2.6.15.7-ubuntu1/fs/Kconfig
 @@ -1910,5 +1910,7 @@ endmenu
  
  source "fs/nls/Kconfig"
@@ -219,16 +223,16 @@
 +
  endmenu
  
---- linux-source-2.6.15-2.6.15.orig/fs/Makefile
-+++ linux-source-2.6.15-2.6.15/fs/Makefile
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/Makefile
++++ linux-source-2.6.15.7-ubuntu1/fs/Makefile
 @@ -108,3 +108,5 @@ obj-$(CONFIG_CONFIGFS_FS)	+= configfs/
  obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
  obj-$(CONFIG_UNION_FS)          += unionfs/
  obj-$(CONFIG_DAZUKO)		+= dazuko/
 +
 +include $(srctree)/fs/Makefile-2.6.ccs
---- linux-source-2.6.15-2.6.15.orig/fs/attr.c
-+++ linux-source-2.6.15-2.6.15/fs/attr.c
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/attr.c
++++ linux-source-2.6.15.7-ubuntu1/fs/attr.c
 @@ -15,6 +15,9 @@
  #include <linux/quotaops.h>
  #include <linux/security.h>
@@ -239,13 +243,17 @@
  
  /* Taken over from the old code... */
  
-@@ -153,12 +156,20 @@ int notify_change(struct dentry * dentry
+@@ -153,12 +156,28 @@ int notify_change(struct dentry * dentry
  
  	if (inode->i_op && inode->i_op->setattr) {
  		error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error)
  			error = inode->i_op->setattr(dentry, attr);
@@ -254,14 +262,18 @@
  		if (!error)
  			error = security_inode_setattr(dentry, attr);
 +		/***** TOMOYO Linux start. *****/
-+		if (!error && (ia_valid & ATTR_MODE) && !ccs_capable(TOMOYO_SYS_CHMOD)) error = -EPERM;
-+		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) && !ccs_capable(TOMOYO_SYS_CHOWN)) error = -EPERM;
++		if (!error && (ia_valid & ATTR_MODE) &&
++		    !ccs_capable(TOMOYO_SYS_CHMOD))
++			error = -EPERM;
++		if (!error && (ia_valid & (ATTR_UID | ATTR_GID)) &&
++		    !ccs_capable(TOMOYO_SYS_CHOWN))
++			error = -EPERM;
 +		/***** TOMOYO Linux end. *****/
  		if (!error) {
  			if ((ia_valid & ATTR_UID && attr->ia_uid != inode->i_uid) ||
  			    (ia_valid & ATTR_GID && attr->ia_gid != inode->i_gid))
---- linux-source-2.6.15-2.6.15.orig/fs/compat.c
-+++ linux-source-2.6.15-2.6.15/fs/compat.c
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/compat.c
++++ linux-source-2.6.15.7-ubuntu1/fs/compat.c
 @@ -52,6 +52,9 @@
  #include <asm/uaccess.h>
  #include <asm/mmu_context.h>
@@ -272,17 +284,20 @@
  
  /*
   * Not all architectures have sys_utime, so implement this in terms
-@@ -377,6 +380,9 @@ asmlinkage long compat_sys_ioctl(unsigne
+@@ -377,6 +380,12 @@ asmlinkage long compat_sys_ioctl(unsigne
  		/*FALL THROUGH*/
  
  	default:
 +		/***** TOMOYO Linux start. *****/
-+		if (!ccs_capable(TOMOYO_SYS_IOCTL)) { error = -EPERM; goto out_fput; }
++		if (!ccs_capable(TOMOYO_SYS_IOCTL)) {
++			error = -EPERM;
++			goto out_fput;
++		}
 +		/***** TOMOYO Linux end. *****/
  		if (filp->f_op && filp->f_op->compat_ioctl) {
  			error = filp->f_op->compat_ioctl(filp, cmd, arg);
  			if (error != -ENOIOCTLCMD)
-@@ -1480,7 +1486,7 @@ int compat_do_execve(char * filename,
+@@ -1480,7 +1489,7 @@ int compat_do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
@@ -291,8 +306,8 @@
  	if (retval >= 0) {
  		free_arg_pages(bprm);
  
---- linux-source-2.6.15-2.6.15.orig/fs/exec.c
-+++ linux-source-2.6.15-2.6.15/fs/exec.c
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/exec.c
++++ linux-source-2.6.15.7-ubuntu1/fs/exec.c
 @@ -57,6 +57,10 @@
  #include <linux/kmod.h>
  #endif
@@ -304,40 +319,46 @@
  int core_uses_pid;
  char core_pattern[65] = "core";
  int suid_dumpable = 0;
-@@ -139,6 +143,11 @@ asmlinkage long sys_uselib(const char __
+@@ -139,6 +143,13 @@ asmlinkage long sys_uselib(const char __
  	if (error)
  		goto exit;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
-+	if (error) goto exit;
++	/* 01 means "read". */
++	error = ccs_check_open_permission(nd.dentry, nd.mnt, 01);
++	if (error)
++		goto exit;
 +	/***** TOMOYO Linux end. *****/
 +
  	file = nameidata_to_filp(&nd, O_RDONLY);
  	error = PTR_ERR(file);
  	if (IS_ERR(file))
-@@ -488,6 +497,9 @@ struct file *open_exec(const char *name)
+@@ -488,6 +499,13 @@ struct file *open_exec(const char *name)
  			int err = vfs_permission(&nd, MAY_EXEC);
  			if (!err && !(inode->i_mode & 0111))
  				err = -EACCES;
 +			/***** TOMOYO Linux start. *****/
-+			if (!err && (current->tomoyo_flags & TOMOYO_CHECK_READ_FOR_OPEN_EXEC)) err = ccs_check_open_permission(nd.dentry, nd.mnt, 01); /* 01 means "read". */
++			if (!err && (current->tomoyo_flags &
++				     TOMOYO_CHECK_READ_FOR_OPEN_EXEC))
++				/* 01 means "read". */
++				err = ccs_check_open_permission(nd.dentry,
++								nd.mnt, 01);
 +			/***** TOMOYO Linux end. *****/
  			file = ERR_PTR(err);
  			if (!err) {
  				file = nameidata_to_filp(&nd, O_RDONLY);
-@@ -1197,7 +1209,8 @@ int do_execve(char * filename,
+@@ -1197,7 +1215,8 @@ int do_execve(char * filename,
  	if (retval < 0)
  		goto out;
  
 -	retval = search_binary_handler(bprm,regs);
-+	retval = search_binary_handler_with_transition(bprm,regs);
++	retval = search_binary_handler_with_transition(bprm, regs);
 +
  	if (retval >= 0) {
  		free_arg_pages(bprm);
  
---- linux-source-2.6.15-2.6.15.orig/fs/fcntl.c
-+++ linux-source-2.6.15-2.6.15/fs/fcntl.c
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/fcntl.c
++++ linux-source-2.6.15.7-ubuntu1/fs/fcntl.c
 @@ -21,6 +21,9 @@
  #include <asm/poll.h>
  #include <asm/siginfo.h>
@@ -348,19 +369,20 @@
  
  void fastcall set_close_on_exec(unsigned int fd, int flag)
  {
-@@ -211,6 +214,10 @@ static int setfl(int fd, struct file * f
+@@ -211,6 +214,11 @@ static int setfl(int fd, struct file * f
  	if (!(arg & O_APPEND) && IS_APPEND(inode))
  		return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp)) return -EPERM;
++	if (!(arg & O_APPEND) && ccs_check_rewrite_permission(filp))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +
  	/* O_NOATIME can only be set by the owner or superuser */
  	if ((arg & O_NOATIME) && !(filp->f_flags & O_NOATIME))
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
---- linux-source-2.6.15-2.6.15.orig/fs/ioctl.c
-+++ linux-source-2.6.15-2.6.15/fs/ioctl.c
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/ioctl.c
++++ linux-source-2.6.15.7-ubuntu1/fs/ioctl.c
 @@ -15,6 +15,9 @@
  
  #include <asm/uaccess.h>
@@ -371,18 +393,19 @@
  
  static long do_ioctl(struct file *filp, unsigned int cmd,
  		unsigned long arg)
-@@ -23,6 +26,9 @@ static long do_ioctl(struct file *filp, 
+@@ -23,6 +26,10 @@ static long do_ioctl(struct file *filp, 
  
  	if (!filp->f_op)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_IOCTL)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_IOCTL))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (filp->f_op->unlocked_ioctl) {
  		error = filp->f_op->unlocked_ioctl(filp, cmd, arg);
---- linux-source-2.6.15-2.6.15.orig/fs/namei.c
-+++ linux-source-2.6.15-2.6.15/fs/namei.c
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/namei.c
++++ linux-source-2.6.15.7-ubuntu1/fs/namei.c
 @@ -34,6 +34,10 @@
  
  #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
@@ -394,29 +417,35 @@
  /* [Feb-1997 T. Schoebel-Theuer]
   * Fundamental changes in the pathname lookup mechanisms (namei)
   * were necessary because of omirr.  The reason is that omirr needs
-@@ -1418,6 +1422,9 @@ int vfs_create(struct inode *dir, struct
+@@ -1418,6 +1422,13 @@ int vfs_create(struct inode *dir, struct
  	error = security_inode_create(dir, dentry, mode);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (nd && (error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt)) < 0) return error;
++	if (nd) {
++		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
++		if (error)
++			return error;
++	}
 +	/***** TOMOYO Linux end. *****/
  	DQUOT_INIT(dir);
  	error = dir->i_op->create(dir, dentry, mode, nd);
  	if (!error)
-@@ -1473,6 +1480,11 @@ int may_open(struct nameidata *nd, int a
+@@ -1473,6 +1484,13 @@ int may_open(struct nameidata *nd, int a
  		if (current->fsuid != inode->i_uid && !capable(CAP_FOWNER))
  			return -EPERM;
  
 +	/***** TOMOYO Linux start. *****/
-+	error = ccs_check_open_permission(dentry, nd->mnt, flag); /* includes O_APPEND and O_TRUNC checks */
-+	if (error) return error;
++	/* includes O_APPEND and O_TRUNC checks */
++	error = ccs_check_open_permission(dentry, nd->mnt, flag);
++	if (error)
++		return error;
 +	/***** TOMOYO Linux end. *****/
 +
  	/*
  	 * Ensure there are no outstanding leases on the file.
  	 */
-@@ -1504,6 +1516,9 @@ int may_open(struct nameidata *nd, int a
+@@ -1504,6 +1522,9 @@ int may_open(struct nameidata *nd, int a
  	return 0;
  }
  
@@ -426,142 +455,193 @@
  /*
   *	open_namei()
   *
-@@ -1753,6 +1768,12 @@ asmlinkage long sys_mknod(const char __u
+@@ -1753,6 +1774,16 @@ asmlinkage long sys_mknod(const char __u
  
  	if (S_ISDIR(mode))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV)) return -EPERM;
-+	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV)) return -EPERM;
-+	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO)) return -EPERM;
-+	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) return -EPERM;
++	if (S_ISCHR(mode) && !ccs_capable(TOMOYO_CREATE_CHAR_DEV))
++		return -EPERM;
++	if (S_ISBLK(mode) && !ccs_capable(TOMOYO_CREATE_BLOCK_DEV))
++		return -EPERM;
++	if (S_ISFIFO(mode) && !ccs_capable(TOMOYO_CREATE_FIFO))
++		return -EPERM;
++	if (S_ISSOCK(mode) && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	tmp = getname(filename);
  	if (IS_ERR(tmp))
  		return PTR_ERR(tmp);
-@@ -1771,10 +1792,16 @@ asmlinkage long sys_mknod(const char __u
+@@ -1771,10 +1802,32 @@ asmlinkage long sys_mknod(const char __u
  			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
  			break;
  		case S_IFCHR: case S_IFBLK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISCHR(mode) ? TYPE_MKCHAR_ACL : TYPE_MKBLOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISCHR(mode) ?
++						     TYPE_MKCHAR_ACL :
++						     TYPE_MKBLOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
  					new_decode_dev(dev));
  			break;
  		case S_IFIFO: case S_IFSOCK:
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (error = ccs_check_1path_perm(S_ISFIFO(mode) ? TYPE_MKFIFO_ACL : TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++			if (error)
++				break;
++			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
++						     TYPE_MKFIFO_ACL :
++						     TYPE_MKSOCK_ACL,
++						     dentry, nd.mnt);
++			if (error)
++				break;
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
  			break;
  		case S_IFDIR:
-@@ -1834,6 +1861,9 @@ asmlinkage long sys_mkdir(const char __u
+@@ -1834,6 +1887,13 @@ asmlinkage long sys_mkdir(const char __u
  		if (!IS_ERR(dentry)) {
  			if (!IS_POSIXACL(nd.dentry->d_inode))
  				mode &= ~current->fs->umask;
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_mkdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
  			dput(dentry);
  		}
-@@ -1937,6 +1967,9 @@ asmlinkage long sys_rmdir(const char __u
+@@ -1937,6 +1997,13 @@ asmlinkage long sys_rmdir(const char __u
  	dentry = lookup_hash(&nd);
  	error = PTR_ERR(dentry);
  	if (!IS_ERR(dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_rmdir(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
++		if (!error)
++			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
++						     nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_rmdir(nd.dentry->d_inode, dentry);
  		dput(dentry);
  	}
-@@ -1991,6 +2024,9 @@ asmlinkage long sys_unlink(const char __
+@@ -1991,6 +2058,10 @@ asmlinkage long sys_unlink(const char __
  	struct dentry *dentry;
  	struct nameidata nd;
  	struct inode *inode = NULL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UNLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UNLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	name = getname(pathname);
  	if(IS_ERR(name))
-@@ -2012,6 +2048,9 @@ asmlinkage long sys_unlink(const char __
+@@ -2012,6 +2083,14 @@ asmlinkage long sys_unlink(const char __
  		inode = dentry->d_inode;
  		if (inode)
  			atomic_inc(&inode->i_count);
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_unlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt)) == 0)
++		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
++		if (error)
++			goto exit2;
++		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
++		if (error)
++			goto exit2;
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_unlink(nd.dentry->d_inode, dentry);
  	exit2:
  		dput(dentry);
-@@ -2057,6 +2096,9 @@ asmlinkage long sys_symlink(const char _
+@@ -2057,6 +2136,10 @@ asmlinkage long sys_symlink(const char _
  	int error = 0;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SYMLINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SYMLINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
-@@ -2073,6 +2115,9 @@ asmlinkage long sys_symlink(const char _
+@@ -2073,6 +2156,13 @@ asmlinkage long sys_symlink(const char _
  		dentry = lookup_create(&nd, 0);
  		error = PTR_ERR(dentry);
  		if (!IS_ERR(dentry)) {
 +			/***** TOMOYO Linux start. *****/
-+			if ((error = pre_vfs_symlink(nd.dentry->d_inode, dentry)) == 0 && (error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt)) == 0)
++			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
++			if (!error)
++				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
++							     dentry, nd.mnt);
++			if (!error)
 +			/***** TOMOYO Linux end. *****/
  			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
  			dput(dentry);
  		}
-@@ -2138,6 +2183,9 @@ asmlinkage long sys_link(const char __us
+@@ -2138,6 +2228,10 @@ asmlinkage long sys_link(const char __us
  	struct nameidata nd, old_nd;
  	int error;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_LINK)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_LINK))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	to = getname(newname);
  	if (IS_ERR(to))
-@@ -2155,6 +2203,9 @@ asmlinkage long sys_link(const char __us
+@@ -2155,6 +2249,15 @@ asmlinkage long sys_link(const char __us
  	new_dentry = lookup_create(&nd, 0);
  	error = PTR_ERR(new_dentry);
  	if (!IS_ERR(new_dentry)) {
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry)) == 0 && (error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry, old_nd.mnt, new_dentry, nd.mnt)) == 0)
++		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
++				     new_dentry);
++		if (!error)
++			error = ccs_check_2path_perm(TYPE_LINK_ACL,
++						     old_nd.dentry, old_nd.mnt,
++						     new_dentry, nd.mnt);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
  		dput(new_dentry);
  	}
-@@ -2375,6 +2426,13 @@ static inline int do_rename(const char *
+@@ -2375,6 +2478,17 @@ static inline int do_rename(const char *
  	if (new_dentry == trap)
  		goto exit5;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = pre_vfs_rename(old_dir->d_inode, old_dentry, new_dir->d_inode, new_dentry)) < 0 ||
-+		(error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt, new_dentry, newnd.mnt)) < 0) {
++	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
++			       new_dir->d_inode, new_dentry);
++	if (error)
 +		goto exit5;
-+	}
++	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
++				     new_dentry, newnd.mnt);
++	if (error)
++		goto exit5;
 +	/***** TOMOYO Linux end. *****/
 +
  	error = vfs_rename(old_dir->d_inode, old_dentry,
  				   new_dir->d_inode, new_dentry);
  exit5:
-@@ -2396,6 +2454,9 @@ asmlinkage long sys_rename(const char __
+@@ -2396,6 +2510,10 @@ asmlinkage long sys_rename(const char __
  	int error;
  	char * from;
  	char * to;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_RENAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_RENAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	from = getname(oldname);
  	if(IS_ERR(from))
---- linux-source-2.6.15-2.6.15.orig/fs/namespace.c
-+++ linux-source-2.6.15-2.6.15/fs/namespace.c
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/namespace.c
++++ linux-source-2.6.15.7-ubuntu1/fs/namespace.c
 @@ -25,6 +25,12 @@
  #include <asm/uaccess.h>
  #include <asm/unistd.h>
@@ -575,97 +655,108 @@
  
  extern int __init init_rootfs(void);
  
-@@ -504,6 +510,10 @@ static int do_umount(struct vfsmount *mn
+@@ -504,6 +510,11 @@ static int do_umount(struct vfsmount *mn
  	if (retval)
  		return retval;
  
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_may_umount(mnt) < 0) return -EPERM;
++	if (ccs_may_umount(mnt))
++		return -EPERM;
 +	/***** SAKURA Linux end. *****/
 +
  	/*
  	 * Allow userspace to request a mountpoint be expired rather than
  	 * unmounting unconditionally. Unmount only happens if:
-@@ -592,6 +602,9 @@ asmlinkage long sys_umount(char __user *
+@@ -592,6 +603,10 @@ asmlinkage long sys_umount(char __user *
  {
  	struct nameidata nd;
  	int retval;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_UMOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_UMOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
  	if (retval)
-@@ -876,6 +889,10 @@ static int do_loopback(struct nameidata 
+@@ -876,6 +891,11 @@ static int do_loopback(struct nameidata 
  
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  
  	err = -ENOMEM;
  	if (recurse)
-@@ -960,7 +977,10 @@ static int do_move_mount(struct nameidat
+@@ -960,7 +980,11 @@ static int do_move_mount(struct nameidat
  	err = -EINVAL;
  	if (!check_mnt(nd->mnt) || !check_mnt(old_nd.mnt))
  		goto out;
 -
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_umount(old_nd.mnt) < 0 || ccs_may_mount(nd) < 0) goto out;
++	if (ccs_may_umount(old_nd.mnt) || ccs_may_mount(nd))
++		goto out;
 +	/***** SAKURA Linux end. *****/
  	err = -ENOENT;
  	down(&nd->dentry->d_inode->i_sem);
  	if (IS_DEADDIR(nd->dentry->d_inode))
-@@ -1062,6 +1082,10 @@ int do_add_mount(struct vfsmount *newmnt
+@@ -1062,6 +1086,11 @@ int do_add_mount(struct vfsmount *newmnt
  	err = -EINVAL;
  	if (S_ISLNK(newmnt->mnt_root->d_inode->i_mode))
  		goto unlock;
 +	/***** SAKURA Linux start. *****/
 +	err = -EPERM;
-+	if (ccs_may_mount(nd) < 0) goto unlock;
++	if (ccs_may_mount(nd))
++		goto unlock;
 +	/***** SAKURA Linux end. *****/
  
  	newmnt->mnt_flags = mnt_flags;
  	if ((err = graft_tree(newmnt, nd)))
-@@ -1279,6 +1303,13 @@ long do_mount(char *dev_name, char *dir_
+@@ -1279,6 +1308,17 @@ long do_mount(char *dev_name, char *dir_
  	if (data_page)
  		((char *)data_page)[PAGE_SIZE - 1] = 0;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_MOUNT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_MOUNT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if ((retval = ccs_check_mount_permission(dev_name, dir_name, type_page, &flags)) < 0) return retval;
++	retval = ccs_check_mount_permission(dev_name, dir_name, type_page,
++					    &flags);
++	if (retval)
++		return retval;
 +	/***** SAKURA Linux end. *****/
 +
  	/* Separate the per-mountpoint flags */
  	if (flags & MS_NOSUID)
  		mnt_flags |= MNT_NOSUID;
-@@ -1543,6 +1574,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1543,6 +1583,10 @@ asmlinkage long sys_pivot_root(const cha
  
  	if (!capable(CAP_SYS_ADMIN))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PIVOT_ROOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  
-@@ -1559,6 +1593,9 @@ asmlinkage long sys_pivot_root(const cha
+@@ -1559,6 +1603,10 @@ asmlinkage long sys_pivot_root(const cha
  		goto out1;
  
  	error = security_sb_pivotroot(&old_nd, &new_nd);
 +	/***** SAKURA Linux start. *****/
-+	if (!error) error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
++	if (!error)
++		error = ccs_check_pivot_root_permission(&old_nd, &new_nd);
 +	/***** SAKURA Linux end. *****/
  	if (error) {
  		path_release(&old_nd);
  		goto out1;
---- linux-source-2.6.15-2.6.15.orig/fs/open.c
-+++ linux-source-2.6.15-2.6.15/fs/open.c
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/open.c
++++ linux-source-2.6.15.7-ubuntu1/fs/open.c
 @@ -28,6 +28,13 @@
  
  #include <asm/unistd.h>
@@ -680,52 +771,58 @@
  int vfs_statfs(struct super_block *sb, struct kstatfs *buf)
  {
  	int retval = -ENODEV;
-@@ -263,6 +270,9 @@ static inline long do_sys_truncate(const
+@@ -263,6 +270,10 @@ static inline long do_sys_truncate(const
  	if (error)
  		goto dput_and_out;
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
++	if (!error)
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, NULL, length);
  	if (!error) {
  		DQUOT_INIT(inode);
-@@ -315,7 +325,9 @@ static inline long do_sys_ftruncate(unsi
+@@ -315,7 +326,11 @@ static inline long do_sys_ftruncate(unsi
  	error = -EPERM;
  	if (IS_APPEND(inode))
  		goto out_putf;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt)) == 0)
++	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
++	if (error)
++		goto out_putf;
 +	/***** TOMOYO Linux end. *****/
  	error = locks_verify_truncate(inode, file, length);
  	if (!error)
  		error = do_truncate(dentry, length, file);
-@@ -588,6 +600,12 @@ asmlinkage long sys_chroot(const char __
+@@ -588,6 +603,14 @@ asmlinkage long sys_chroot(const char __
  	error = -EPERM;
  	if (!capable(CAP_SYS_CHROOT))
  		goto dput_and_out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_CHROOT)) goto dput_and_out;
++	if (!ccs_capable(TOMOYO_SYS_CHROOT))
++		goto dput_and_out;
 +	/***** TOMOYO Linux end. *****/
 +	/***** SAKURA Linux start. *****/
-+	if (ccs_check_chroot_permission(&nd)) goto dput_and_out;
++	if (ccs_check_chroot_permission(&nd))
++		goto dput_and_out;
 +	/***** SAKURA Linux end. *****/
  
  	set_fs_root(current->fs, nd.mnt, nd.dentry);
  	set_fs_altroot();
-@@ -1119,6 +1137,9 @@ EXPORT_SYMBOL(sys_close);
+@@ -1119,6 +1142,10 @@ EXPORT_SYMBOL(sys_close);
   */
  asmlinkage long sys_vhangup(void)
  {
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_VHANGUP)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_VHANGUP))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (capable(CAP_SYS_TTY_CONFIG)) {
  		tty_vhangup(current->signal->tty);
  		return 0;
---- linux-source-2.6.15-2.6.15.orig/fs/proc/Makefile
-+++ linux-source-2.6.15-2.6.15/fs/proc/Makefile
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/proc/Makefile
++++ linux-source-2.6.15.7-ubuntu1/fs/proc/Makefile
 @@ -13,3 +13,6 @@ proc-y       += inode.o root.o base.o ge
  proc-$(CONFIG_PROC_KCORE)	+= kcore.o
  proc-$(CONFIG_PROC_VMCORE)	+= vmcore.o
@@ -733,20 +830,20 @@
 +
 +proc-$(CONFIG_SAKURA) += ccs_proc.o
 +proc-$(CONFIG_TOMOYO) += ccs_proc.o
---- linux-source-2.6.15-2.6.15.orig/fs/proc/proc_misc.c
-+++ linux-source-2.6.15-2.6.15/fs/proc/proc_misc.c
+--- linux-source-2.6.15.7-ubuntu1.orig/fs/proc/proc_misc.c
++++ linux-source-2.6.15.7-ubuntu1/fs/proc/proc_misc.c
 @@ -629,4 +629,9 @@ void __init proc_misc_init(void)
  	if (entry)
  		entry->proc_fops = &proc_sysrq_trigger_operations;
  #endif
 +	/***** CCS start. *****/
 +#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
-+	printk(KERN_INFO "Hook version: 2.6.15.7-ubuntu1 2008/04/07\n");
++	printk(KERN_INFO "Hook version: 2.6.15.7-ubuntu1 2008/05/03\n");
 +#endif
 +	/***** CCS end. *****/
  }
---- linux-source-2.6.15-2.6.15.orig/include/linux/init_task.h
-+++ linux-source-2.6.15-2.6.15/include/linux/init_task.h
+--- linux-source-2.6.15.7-ubuntu1.orig/include/linux/init_task.h
++++ linux-source-2.6.15.7-ubuntu1/include/linux/init_task.h
 @@ -121,6 +121,10 @@ extern struct group_info init_groups;
  	.journal_info	= NULL,						\
  	.cpu_timers	= INIT_CPU_TIMERS(tsk.cpu_timers),		\
@@ -758,8 +855,8 @@
  }
  
  
---- linux-source-2.6.15-2.6.15.orig/include/linux/sched.h
-+++ linux-source-2.6.15-2.6.15/include/linux/sched.h
+--- linux-source-2.6.15.7-ubuntu1.orig/include/linux/sched.h
++++ linux-source-2.6.15.7-ubuntu1/include/linux/sched.h
 @@ -39,6 +39,11 @@
  
  struct exec_domain;
@@ -783,8 +880,8 @@
  };
  
  static inline pid_t process_group(struct task_struct *tsk)
---- linux-source-2.6.15-2.6.15.orig/kernel/compat.c
-+++ linux-source-2.6.15-2.6.15/kernel/compat.c
+--- linux-source-2.6.15.7-ubuntu1.orig/kernel/compat.c
++++ linux-source-2.6.15.7-ubuntu1/kernel/compat.c
 @@ -24,6 +24,9 @@
  
  #include <asm/uaccess.h>
@@ -795,18 +892,19 @@
  
  int get_compat_timespec(struct timespec *ts, const struct compat_timespec __user *cts)
  {
-@@ -849,6 +852,9 @@ asmlinkage long compat_sys_stime(compat_
+@@ -849,6 +852,10 @@ asmlinkage long compat_sys_stime(compat_
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
---- linux-source-2.6.15-2.6.15.orig/kernel/kexec.c
-+++ linux-source-2.6.15-2.6.15/kernel/kexec.c
+--- linux-source-2.6.15.7-ubuntu1.orig/kernel/kexec.c
++++ linux-source-2.6.15.7-ubuntu1/kernel/kexec.c
 @@ -25,6 +25,9 @@
  #include <asm/io.h>
  #include <asm/system.h>
@@ -817,18 +915,19 @@
  
  /* Location of the reserved area for the crash kernel */
  struct resource crashk_res = {
-@@ -918,6 +921,9 @@ asmlinkage long sys_kexec_load(unsigned 
+@@ -918,6 +921,10 @@ asmlinkage long sys_kexec_load(unsigned 
  	/* We only trust the superuser with rebooting the system. */
  	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_KEXEC_LOAD))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
  	 * Verify we have a legal set of flags
---- linux-source-2.6.15-2.6.15.orig/kernel/kmod.c
-+++ linux-source-2.6.15-2.6.15/kernel/kmod.c
+--- linux-source-2.6.15.7-ubuntu1.orig/kernel/kmod.c
++++ linux-source-2.6.15.7-ubuntu1/kernel/kmod.c
 @@ -149,6 +149,11 @@ static int ____call_usermodehelper(void 
  	/* We can run anywhere, unlike our parent keventd(). */
  	set_cpus_allowed(current, CPU_MASK_ALL);
@@ -841,8 +940,8 @@
  	retval = -EPERM;
  	if (current->fs->root)
  		retval = execve(sub_info->path, sub_info->argv,sub_info->envp);
---- linux-source-2.6.15-2.6.15.orig/kernel/module.c
-+++ linux-source-2.6.15-2.6.15/kernel/module.c
+--- linux-source-2.6.15.7-ubuntu1.orig/kernel/module.c
++++ linux-source-2.6.15.7-ubuntu1/kernel/module.c
 @@ -41,6 +41,9 @@
  #include <asm/uaccess.h>
  #include <asm/semaphore.h>
@@ -853,30 +952,32 @@
  
  #if 0
  #define DEBUGP printk
-@@ -577,7 +580,9 @@ sys_delete_module(const char __user *nam
+@@ -577,7 +580,10 @@ sys_delete_module(const char __user *nam
  
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
  		return -EFAULT;
  	name[MODULE_NAME_LEN-1] = '\0';
-@@ -1886,7 +1891,9 @@ sys_init_module(void __user *umod,
+@@ -1886,7 +1892,10 @@ sys_init_module(void __user *umod,
  	/* Must have permission */
  	if (!capable(CAP_SYS_MODULE))
  		return -EPERM;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_USE_KERNEL_MODULE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	/* Only one module load at a time, please */
  	if (down_interruptible(&module_mutex) != 0)
  		return -EINTR;
---- linux-source-2.6.15-2.6.15.orig/kernel/ptrace.c
-+++ linux-source-2.6.15-2.6.15/kernel/ptrace.c
+--- linux-source-2.6.15.7-ubuntu1.orig/kernel/ptrace.c
++++ linux-source-2.6.15.7-ubuntu1/kernel/ptrace.c
 @@ -20,6 +20,9 @@
  
  #include <asm/pgtable.h>
@@ -887,20 +988,21 @@
  
  /*
   * ptrace a task: make the debugger its new parent and
-@@ -469,6 +472,11 @@ asmlinkage long sys_ptrace(long request,
+@@ -469,6 +472,12 @@ asmlinkage long sys_ptrace(long request,
  	/*
  	 * This lock_kernel fixes a subtle race with suid exec
  	 */
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  	lock_kernel();
  	ret = ptrace_get_task_struct(request, pid, &child);
  	if (!child)
---- linux-source-2.6.15-2.6.15.orig/kernel/sched.c
-+++ linux-source-2.6.15-2.6.15/kernel/sched.c
+--- linux-source-2.6.15.7-ubuntu1.orig/kernel/sched.c
++++ linux-source-2.6.15.7-ubuntu1/kernel/sched.c
 @@ -50,6 +50,9 @@
  #include <asm/tlb.h>
  
@@ -911,18 +1013,19 @@
  
  /*
   * Convert user-nice values [ -20 ... 0 ... 19 ]
-@@ -3603,6 +3606,9 @@ asmlinkage long sys_nice(int increment)
+@@ -3603,6 +3606,10 @@ asmlinkage long sys_nice(int increment)
  {
  	int retval;
  	long nice;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	/*
  	 * Setpriority might change our priority at the same moment.
---- linux-source-2.6.15-2.6.15.orig/kernel/signal.c
-+++ linux-source-2.6.15-2.6.15/kernel/signal.c
+--- linux-source-2.6.15.7-ubuntu1.orig/kernel/signal.c
++++ linux-source-2.6.15.7-ubuntu1/kernel/signal.c
 @@ -29,6 +29,9 @@
  #include <asm/uaccess.h>
  #include <asm/unistd.h>
@@ -933,41 +1036,47 @@
  
  /*
   * SLAB caches for signal bits.
-@@ -2241,6 +2244,10 @@ asmlinkage long
+@@ -2241,6 +2244,12 @@ asmlinkage long
  sys_kill(int pid, int sig)
  {
  	struct siginfo info;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	info.si_signo = sig;
  	info.si_errno = 0;
-@@ -2299,6 +2306,10 @@ asmlinkage long sys_tgkill(int tgid, int
+@@ -2299,6 +2308,12 @@ asmlinkage long sys_tgkill(int tgid, int
  	/* This is only valid for single tasks */
  	if (pid <= 0 || tgid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(tgid, pid, sig);
  }
-@@ -2312,6 +2323,10 @@ sys_tkill(int pid, int sig)
+@@ -2312,6 +2327,12 @@ sys_tkill(int pid, int sig)
  	/* This is only valid for single tasks */
  	if (pid <= 0)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (sig && !ccs_capable(TOMOYO_SYS_KILL)) return -EPERM;
-+	if (sig && ccs_check_signal_acl(sig, pid) < 0) return -EPERM;
++	if (sig && !ccs_capable(TOMOYO_SYS_KILL))
++		return -EPERM;
++	if (sig && ccs_check_signal_acl(sig, pid))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	return do_tkill(0, pid, sig);
  }
---- linux-source-2.6.15-2.6.15.orig/kernel/sys.c
-+++ linux-source-2.6.15-2.6.15/kernel/sys.c
+--- linux-source-2.6.15.7-ubuntu1.orig/kernel/sys.c
++++ linux-source-2.6.15.7-ubuntu1/kernel/sys.c
 @@ -37,6 +37,9 @@
  #include <asm/uaccess.h>
  #include <asm/io.h>
@@ -978,48 +1087,54 @@
  
  #ifndef SET_UNALIGN_CTL
  # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
-@@ -256,6 +259,9 @@ asmlinkage long sys_setpriority(int whic
+@@ -256,6 +259,12 @@ asmlinkage long sys_setpriority(int whic
  
  	if (which > 2 || which < 0)
  		goto out;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_NICE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_NICE)) {
++		error = -EPERM;
++		goto out;
++	}
 +	/***** TOMOYO Linux end. *****/
  
  	/* normalize: avoid signed division (rounding problems) */
  	error = -ESRCH;
-@@ -483,6 +489,9 @@ asmlinkage long sys_reboot(int magic1, i
+@@ -483,6 +492,10 @@ asmlinkage long sys_reboot(int magic1, i
  			magic2 != LINUX_REBOOT_MAGIC2B &&
  	                magic2 != LINUX_REBOOT_MAGIC2C))
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_REBOOT)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_REBOOT))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	switch (cmd) {
-@@ -1515,6 +1524,9 @@ asmlinkage long sys_sethostname(char __u
+@@ -1515,6 +1528,10 @@ asmlinkage long sys_sethostname(char __u
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	down_write(&uts_sem);
  	errno = -EFAULT;
  	if (!copy_from_user(tmp, name, len)) {
-@@ -1560,6 +1572,9 @@ asmlinkage long sys_setdomainname(char _
+@@ -1560,6 +1577,10 @@ asmlinkage long sys_setdomainname(char _
  		return -EPERM;
  	if (len < 0 || len > __NEW_UTS_LEN)
  		return -EINVAL;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETHOSTNAME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	down_write(&uts_sem);
  	errno = -EFAULT;
---- linux-source-2.6.15-2.6.15.orig/kernel/sysctl.c
-+++ linux-source-2.6.15-2.6.15/kernel/sysctl.c
+--- linux-source-2.6.15.7-ubuntu1.orig/kernel/sysctl.c
++++ linux-source-2.6.15.7-ubuntu1/kernel/sysctl.c
 @@ -45,6 +45,9 @@
  
  #include <asm/uaccess.h>
@@ -1030,24 +1145,28 @@
  
  #ifdef CONFIG_ROOT_NFS
  #include <linux/nfs_fs.h>
-@@ -1041,6 +1044,87 @@ void __init sysctl_init(void)
+@@ -1041,6 +1044,100 @@ void __init sysctl_init(void)
  #endif
  }
  
 +/***** TOMOYO Linux start. *****/
-+static int try_parse_table(int __user *name, int nlen, void __user *oldval, void __user *newval, ctl_table *table)
++static int try_parse_table(int __user *name, int nlen, void __user *oldval,
++			   void __user *newval, ctl_table *table)
 +{
 +	int n;
 +	int error = -ENOMEM;
 +	int op = 0;
 +	char *buffer = kmalloc(PAGE_SIZE, GFP_KERNEL);
-+	if (oldval) op |= 004;
-+	if (newval) op |= 002;
++	if (oldval)
++		op |= 004;
++	if (newval)
++		op |= 002;
 +	if (!op) { /* Neither read nor write */
 +		error = 0;
 +		goto out;
 +	}
-+	if (!buffer) goto out;
++	if (!buffer)
++		goto out;
 +	memset(buffer, 0, PAGE_SIZE);
 +	snprintf(buffer, PAGE_SIZE - 1, "/proc/sys");
 + repeat:
@@ -1065,35 +1184,44 @@
 +			const char *cp = table->procname;
 +			error = -ENOMEM;
 +			if (cp) {
-+				if (pos + 1 >= PAGE_SIZE - 1) goto out;
++				if (pos + 1 >= PAGE_SIZE - 1)
++					goto out;
 +				buffer[pos++] = '/';
 +				while (*cp) {
-+					const unsigned char c = * (const unsigned char *) cp;
++					const unsigned char c
++						= *(const unsigned char *) cp;
 +					if (c == '\\') {
-+						if (pos + 2 >= PAGE_SIZE - 1) goto out;
++						if (pos + 2 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = '\\';
 +					} else if (c > ' ' && c < 127) {
-+						if (pos + 1 >= PAGE_SIZE - 1) goto out;
++						if (pos + 1 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = c;
 +					} else {
-+						if (pos + 4 >= PAGE_SIZE - 1) goto out;
++						if (pos + 4 >= PAGE_SIZE - 1)
++							goto out;
 +						buffer[pos++] = '\\';
 +						buffer[pos++] = (c >> 6) + '0';
-+						buffer[pos++] = ((c >> 3) & 7) + '0';
++						buffer[pos++] = ((c >> 3) & 7)
++							+ '0';
 +						buffer[pos++] = (c & 7) + '0';
 +					}
 +					cp++;
 +				}
 +			} else {
 +				/* Assume nobody assigns "=\$=" for procname. */
-+				snprintf(buffer + pos, PAGE_SIZE - pos - 1, "/=%d=", table->ctl_name);
-+				if (memchr(buffer, '\0', PAGE_SIZE - 2) == NULL) goto out;
++				snprintf(buffer + pos, PAGE_SIZE - pos - 1,
++					 "/=%d=", table->ctl_name);
++				if (!memchr(buffer, '\0', PAGE_SIZE - 2))
++					goto out;
 +			}
 +			if (table->child) {
 +				if (table->strategy) {
 +					/* printk("sysctl='%s'\n", buffer); */
-+					if (ccs_check_file_perm(buffer, op, "sysctl")) {
++					if (ccs_check_file_perm(buffer, op,
++								"sysctl")) {
 +						error = -EPERM;
 +						goto out;
 +					}
@@ -1118,31 +1246,36 @@
  int do_sysctl(int __user *name, int nlen, void __user *oldval, size_t __user *oldlenp,
  	       void __user *newval, size_t newlen)
  {
-@@ -1066,6 +1150,9 @@ int do_sysctl(int __user *name, int nlen
+@@ -1066,6 +1163,11 @@ int do_sysctl(int __user *name, int nlen
  
  		spin_unlock(&sysctl_lock);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = try_parse_table(name, nlen, oldval, newval, head->ctl_table)) == 0)
++		error = try_parse_table(name, nlen, oldval, newval,
++					head->ctl_table);
++		if (!error)
 +		/***** TOMOYO Linux end. *****/
  		error = parse_table(name, nlen, oldval, oldlenp, 
  					newval, newlen, head->ctl_table,
  					&context);
-@@ -1138,6 +1225,12 @@ repeat:
+@@ -1138,6 +1240,15 @@ repeat:
  				if (ctl_perm(table, 001))
  					return -EPERM;
  				if (table->strategy) {
 +					/***** TOMOYO Linux start. *****/
 +					int op = 0;
-+					if (oldval) op |= 004;
-+					if (newval) op |= 002;
-+					if (ctl_perm(table, op)) return -EPERM;
++					if (oldval)
++						op |= 004;
++					if (newval)
++						op |= 002;
++					if (ctl_perm(table, op))
++						return -EPERM;
 +					/***** TOMOYO Linux end. *****/
  					error = table->strategy(
  						table, name, nlen,
  						oldval, oldlenp,
---- linux-source-2.6.15-2.6.15.orig/kernel/time.c
-+++ linux-source-2.6.15-2.6.15/kernel/time.c
+--- linux-source-2.6.15.7-ubuntu1.orig/kernel/time.c
++++ linux-source-2.6.15.7-ubuntu1/kernel/time.c
 @@ -38,6 +38,9 @@
  
  #include <asm/uaccess.h>
@@ -1153,38 +1286,41 @@
  
  /* 
   * The timezone where the local system is located.  Used as a default by some
-@@ -90,6 +93,9 @@ asmlinkage long sys_stime(time_t __user 
+@@ -90,6 +93,10 @@ asmlinkage long sys_stime(time_t __user 
  	err = security_settime(&tv, NULL);
  	if (err)
  		return err;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	do_settimeofday(&tv);
  	return 0;
-@@ -157,6 +163,9 @@ int do_sys_settimeofday(struct timespec 
+@@ -157,6 +164,10 @@ int do_sys_settimeofday(struct timespec 
  	error = security_settime(tv, tz);
  	if (error)
  		return error;
 +	/***** TOMOYO Linux start. *****/
-+	if (!ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  
  	if (tz) {
  		/* SMP safe, global irq locking makes it work. */
-@@ -235,6 +244,9 @@ int do_adjtimex(struct timex *txc)
+@@ -235,6 +246,10 @@ int do_adjtimex(struct timex *txc)
  	/* In order to modify anything, you gotta be super-user! */
  	if (txc->modes && !capable(CAP_SYS_TIME))
  		return -EPERM;
 +	/***** TOMOYO Linux start. *****/
-+	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME)) return -EPERM;
++	if (txc->modes && !ccs_capable(TOMOYO_SYS_SETTIME))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  		
  	/* Now we validate the data before disabling interrupts */
  
---- linux-source-2.6.15-2.6.15.orig/net/core/datagram.c
-+++ linux-source-2.6.15-2.6.15/net/core/datagram.c
+--- linux-source-2.6.15.7-ubuntu1.orig/net/core/datagram.c
++++ linux-source-2.6.15.7-ubuntu1/net/core/datagram.c
 @@ -55,6 +55,11 @@
  #include <net/sock.h>
  #include <net/tcp_states.h>
@@ -1197,19 +1333,21 @@
  /*
   *	Is a socket 'connection oriented' ?
   */
-@@ -177,6 +182,10 @@ struct sk_buff *skb_recv_datagram(struct
+@@ -177,6 +182,12 @@ struct sk_buff *skb_recv_datagram(struct
  		} else
  			skb = skb_dequeue(&sk->sk_receive_queue);
  
 +		/***** TOMOYO Linux start. *****/
-+		if ((error = ccs_socket_recv_datagram_permission(sk, skb, flags)) < 0) goto no_packet;
++		error = ccs_socket_recv_datagram_permission(sk, skb, flags);
++		if (error)
++			goto no_packet;
 +		/***** TOMOYO Linux end. *****/
 +
  		if (skb)
  			return skb;
  
---- linux-source-2.6.15-2.6.15.orig/net/ipv4/inet_connection_sock.c
-+++ linux-source-2.6.15-2.6.15/net/ipv4/inet_connection_sock.c
+--- linux-source-2.6.15.7-ubuntu1.orig/net/ipv4/inet_connection_sock.c
++++ linux-source-2.6.15.7-ubuntu1/net/ipv4/inet_connection_sock.c
 @@ -24,6 +24,9 @@
  #include <net/route.h>
  #include <net/tcp_states.h>
@@ -1220,18 +1358,19 @@
  
  #ifdef INET_CSK_DEBUG
  const char inet_csk_timer_bug_msg[] = "inet_csk BUG: unknown timer value\n";
-@@ -83,6 +86,9 @@ int inet_csk_get_port(struct inet_hashin
+@@ -83,6 +86,10 @@ int inet_csk_get_port(struct inet_hashin
  		do {
  			head = &hashinfo->bhash[inet_bhashfn(rover, hashinfo->bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
---- linux-source-2.6.15-2.6.15.orig/net/ipv4/tcp_ipv4.c
-+++ linux-source-2.6.15-2.6.15/net/ipv4/tcp_ipv4.c
+--- linux-source-2.6.15.7-ubuntu1.orig/net/ipv4/tcp_ipv4.c
++++ linux-source-2.6.15.7-ubuntu1/net/ipv4/tcp_ipv4.c
 @@ -76,6 +76,9 @@
  #include <linux/stddef.h>
  #include <linux/proc_fs.h>
@@ -1242,18 +1381,19 @@
  
  int sysctl_tcp_tw_reuse;
  int sysctl_tcp_low_latency;
-@@ -243,6 +246,9 @@ static inline int tcp_v4_hash_connect(st
+@@ -243,6 +246,10 @@ static inline int tcp_v4_hash_connect(st
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &tcp_hashinfo.bhash[inet_bhashfn(port, tcp_hashinfo.bhash_size)];
   			spin_lock(&head->lock);
  
---- linux-source-2.6.15-2.6.15.orig/net/ipv4/udp.c
-+++ linux-source-2.6.15-2.6.15/net/ipv4/udp.c
+--- linux-source-2.6.15.7-ubuntu1.orig/net/ipv4/udp.c
++++ linux-source-2.6.15.7-ubuntu1/net/ipv4/udp.c
 @@ -108,6 +108,9 @@
  #include <net/inet_common.h>
  #include <net/checksum.h>
@@ -1264,28 +1404,30 @@
  
  /*
   *	Snmp MIB for the UDP layer
-@@ -146,6 +149,9 @@ static int udp_v4_get_port(struct sock *
+@@ -146,6 +149,10 @@ static int udp_v4_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -162,6 +168,9 @@ static int udp_v4_get_port(struct sock *
+@@ -162,6 +169,10 @@ static int udp_v4_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
  		}
---- linux-source-2.6.15-2.6.15.orig/net/ipv6/tcp_ipv6.c
-+++ linux-source-2.6.15-2.6.15/net/ipv6/tcp_ipv6.c
+--- linux-source-2.6.15.7-ubuntu1.orig/net/ipv6/tcp_ipv6.c
++++ linux-source-2.6.15.7-ubuntu1/net/ipv6/tcp_ipv6.c
 @@ -64,6 +64,9 @@
  
  #include <linux/proc_fs.h>
@@ -1296,28 +1438,30 @@
  
  static void	tcp_v6_send_reset(struct sk_buff *skb);
  static void	tcp_v6_reqsk_send_ack(struct sk_buff *skb, struct request_sock *req);
-@@ -119,6 +122,9 @@ static int tcp_v6_get_port(struct sock *
+@@ -119,6 +122,10 @@ static int tcp_v6_get_port(struct sock *
  		do {
  			head = &tcp_hashinfo.bhash[inet_bhashfn(rover, tcp_hashinfo.bhash_size)];
  			spin_lock(&head->lock);
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(rover) < 0) goto next;
++			if (ccs_may_autobind(rover))
++				goto next;
 +			/***** SAKURA Linux end. *****/
  			inet_bind_bucket_for_each(tb, node, &head->chain)
  				if (tb->port == rover)
  					goto next;
-@@ -419,6 +425,9 @@ static int tcp_v6_hash_connect(struct so
+@@ -419,6 +426,10 @@ static int tcp_v6_hash_connect(struct so
   		local_bh_disable();
  		for (i = 1; i <= range; i++) {
  			port = low + (i + offset) % range;
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(port) < 0) continue;
++			if (ccs_may_autobind(port))
++				continue;
 +			/***** SAKURA Linux end. *****/
   			head = &tcp_hashinfo.bhash[inet_bhashfn(port, tcp_hashinfo.bhash_size)];
   			spin_lock(&head->lock);
  
---- linux-source-2.6.15-2.6.15.orig/net/ipv6/udp.c
-+++ linux-source-2.6.15-2.6.15/net/ipv6/udp.c
+--- linux-source-2.6.15.7-ubuntu1.orig/net/ipv6/udp.c
++++ linux-source-2.6.15.7-ubuntu1/net/ipv6/udp.c
 @@ -58,6 +58,9 @@
  
  #include <linux/proc_fs.h>
@@ -1328,28 +1472,30 @@
  
  DEFINE_SNMP_STAT(struct udp_mib, udp_stats_in6) __read_mostly;
  
-@@ -88,6 +91,9 @@ static int udp_v6_get_port(struct sock *
+@@ -88,6 +91,10 @@ static int udp_v6_get_port(struct sock *
  					result = sysctl_local_port_range[0] +
  						((result - sysctl_local_port_range[0]) &
  						 (UDP_HTABLE_SIZE - 1));
 +				/***** SAKURA Linux start. *****/
-+				if (ccs_may_autobind(result) < 0) continue;
++				if (ccs_may_autobind(result))
++					continue;
 +				/***** SAKURA Linux end. *****/
  				goto gotit;
  			}
  			size = 0;
-@@ -104,6 +110,9 @@ static int udp_v6_get_port(struct sock *
+@@ -104,6 +111,10 @@ static int udp_v6_get_port(struct sock *
  				result = sysctl_local_port_range[0]
  					+ ((result - sysctl_local_port_range[0]) &
  					   (UDP_HTABLE_SIZE - 1));
 +			/***** SAKURA Linux start. *****/
-+			if (ccs_may_autobind(result) < 0) continue;
++			if (ccs_may_autobind(result))
++				continue;
 +			/***** SAKURA Linux end. *****/
  			if (!udp_lport_inuse(result))
  				break;
  		}
---- linux-source-2.6.15-2.6.15.orig/net/socket.c
-+++ linux-source-2.6.15-2.6.15/net/socket.c
+--- linux-source-2.6.15.7-ubuntu1.orig/net/socket.c
++++ linux-source-2.6.15.7-ubuntu1/net/socket.c
 @@ -97,6 +97,11 @@
  #include <net/sock.h>
  #include <linux/netfilter.h>
@@ -1362,55 +1508,65 @@
  static int sock_no_open(struct inode *irrelevant, struct file *dontcare);
  static ssize_t sock_aio_read(struct kiocb *iocb, char __user *buf,
  			 size_t size, loff_t pos);
-@@ -546,7 +551,9 @@ static inline int __sock_sendmsg(struct 
+@@ -546,7 +551,12 @@ static inline int __sock_sendmsg(struct 
  	err = security_socket_sendmsg(sock, msg, size);
  	if (err)
  		return err;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_sendmsg_permission(sock, (struct sockaddr *) msg->msg_name, msg->msg_namelen)) return -EPERM;
++	if (ccs_socket_sendmsg_permission(sock,
++					  (struct sockaddr *) msg->msg_name,
++					  msg->msg_namelen))
++		return -EPERM;
 +	/***** TOMOYO Linux end. *****/
  	return sock->ops->sendmsg(iocb, sock, msg, size);
  }
  
-@@ -1099,6 +1106,10 @@ static int __sock_create(int family, int
+@@ -1099,6 +1109,12 @@ static int __sock_create(int family, int
  		family = PF_PACKET;
  	}
  
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_create_permission(family, type, protocol)) < 0) return err;
++	err = ccs_socket_create_permission(family, type, protocol);
++	if (err)
++		return err;
 +	/***** TOMOYO Linux end. *****/
 +
  	err = security_socket_create(family, type, protocol, kern);
  	if (err)
  		return err;
-@@ -1296,6 +1307,9 @@ asmlinkage long sys_bind(int fd, struct 
+@@ -1296,6 +1312,12 @@ asmlinkage long sys_bind(int fd, struct 
  				sockfd_put(sock);
  				return err;
  			}
 +			/***** TOMOYO Linux start. *****/
-+			if ((err = ccs_socket_bind_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++			err = ccs_socket_bind_permission(sock,
++							 (struct sockaddr *)
++							 address, addrlen);
++			if (!err)
 +			/***** TOMOYO Linux end. *****/
  			err = sock->ops->bind(sock, (struct sockaddr *)address, addrlen);
  		}
  		sockfd_put(sock);
-@@ -1326,7 +1340,9 @@ asmlinkage long sys_listen(int fd, int b
+@@ -1326,7 +1348,10 @@ asmlinkage long sys_listen(int fd, int b
  			sockfd_put(sock);
  			return err;
  		}
 -
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = ccs_socket_listen_permission(sock)) == 0)
++		err = ccs_socket_listen_permission(sock);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err=sock->ops->listen(sock, backlog);
  		sockfd_put(sock);
  	}
-@@ -1377,6 +1393,12 @@ asmlinkage long sys_accept(int fd, struc
+@@ -1377,6 +1402,13 @@ asmlinkage long sys_accept(int fd, struc
  	if (err < 0)
  		goto out_release;
  
 +	/***** TOMOYO Linux start. *****/
-+	if (ccs_socket_accept_permission(newsock, (struct sockaddr *) address)) {
++	if (ccs_socket_accept_permission(newsock,
++					 (struct sockaddr *) address)) {
 +		err = -ECONNABORTED; /* Hope less harmful than -EPERM. */
 +		goto out_release;
 +	}
@@ -1418,19 +1574,22 @@
  	if (upeer_sockaddr) {
  		if(newsock->ops->getname(newsock, (struct sockaddr *)address, &len, 2)<0) {
  			err = -ECONNABORTED;
-@@ -1432,7 +1454,9 @@ asmlinkage long sys_connect(int fd, stru
+@@ -1432,7 +1464,12 @@ asmlinkage long sys_connect(int fd, stru
  	err = security_socket_connect(sock, (struct sockaddr *)address, addrlen);
  	if (err)
  		goto out_put;
 -
 +	/***** TOMOYO Linux start. *****/
-+	if ((err = ccs_socket_connect_permission(sock, (struct sockaddr *) address, addrlen)) == 0)
++	err = ccs_socket_connect_permission(sock, (struct sockaddr *) address,
++					    addrlen);
++	if (err)
++		goto out_put;
 +	/***** TOMOYO Linux end. *****/
  	err = sock->ops->connect(sock, (struct sockaddr *) address, addrlen,
  				 sock->file->f_flags);
  out_put:
---- linux-source-2.6.15-2.6.15.orig/net/unix/af_unix.c
-+++ linux-source-2.6.15-2.6.15/net/unix/af_unix.c
+--- linux-source-2.6.15.7-ubuntu1.orig/net/unix/af_unix.c
++++ linux-source-2.6.15.7-ubuntu1/net/unix/af_unix.c
 @@ -117,6 +117,9 @@
  #include <linux/mount.h>
  #include <net/checksum.h>
@@ -1441,29 +1600,34 @@
  
  int sysctl_unix_max_dgram_qlen = 10;
  
-@@ -738,6 +741,10 @@ static int unix_bind(struct socket *sock
+@@ -738,6 +741,11 @@ static int unix_bind(struct socket *sock
  		err = unix_autobind(sock);
  		goto out;
  	}
 +	/***** TOMOYO Linux start. *****/
 +	err = -EPERM;
-+	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET)) goto out;
++	if (sunaddr->sun_path[0] && !ccs_capable(TOMOYO_CREATE_UNIX_SOCKET))
++		goto out;
 +	/***** TOMOYO Linux end. *****/
  
  	err = unix_mkname(sunaddr, addr_len, &hash);
  	if (err < 0)
-@@ -781,6 +788,9 @@ static int unix_bind(struct socket *sock
+@@ -781,6 +789,13 @@ static int unix_bind(struct socket *sock
  		 */
  		mode = S_IFSOCK |
  		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 +		/***** TOMOYO Linux start. *****/
-+		if ((err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode)) == 0 && (err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry, nd.mnt)) == 0)
++		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
++		if (!err)
++			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
++						   nd.mnt);
++		if (!err)
 +		/***** TOMOYO Linux end. *****/
  		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
  		if (err)
  			goto out_mknod_dput;
---- linux-source-2.6.15-2.6.15.orig/arch/powerpc/kernel/ptrace32.c
-+++ linux-source-2.6.15-2.6.15/arch/powerpc/kernel/ptrace32.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/powerpc/kernel/ptrace32.c
++++ linux-source-2.6.15.7-ubuntu1/arch/powerpc/kernel/ptrace32.c
 @@ -33,6 +33,9 @@
  #include <asm/page.h>
  #include <asm/pgtable.h>
@@ -1474,20 +1638,21 @@
  
  #include "ptrace-common.h"
  
-@@ -46,6 +49,11 @@ long compat_sys_ptrace(int request, int 
+@@ -46,6 +49,12 @@ long compat_sys_ptrace(int request, int 
  {
  	struct task_struct *child;
  	int ret = -EPERM;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
---- linux-source-2.6.15-2.6.15.orig/arch/sh64/kernel/ptrace.c
-+++ linux-source-2.6.15-2.6.15/arch/sh64/kernel/ptrace.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/sh64/kernel/ptrace.c
++++ linux-source-2.6.15.7-ubuntu1/arch/sh64/kernel/ptrace.c
 @@ -36,6 +36,9 @@
  #include <asm/system.h>
  #include <asm/processor.h>
@@ -1498,20 +1663,21 @@
  
  /* This mask defines the bits of the SR which the user is not allowed to
     change, which are everything except S, Q, M, PR, SZ, FR. */
-@@ -272,6 +275,11 @@ asmlinkage int sh64_ptrace(long request,
+@@ -272,6 +275,12 @@ asmlinkage int sh64_ptrace(long request,
  	extern void poke_real_address_q(unsigned long long addr, unsigned long long data);
  #define WPC_DBRMODE 0x0d104008
  	static int first_call = 1;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (first_call) {
---- linux-source-2.6.15-2.6.15.orig/arch/x86_64/ia32/ptrace32.c
-+++ linux-source-2.6.15-2.6.15/arch/x86_64/ia32/ptrace32.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/x86_64/ia32/ptrace32.c
++++ linux-source-2.6.15.7-ubuntu1/arch/x86_64/ia32/ptrace32.c
 @@ -27,6 +27,9 @@
  #include <asm/debugreg.h>
  #include <asm/i387.h>
@@ -1522,20 +1688,21 @@
  
  /* determines which flags the user has access to. */
  /* 1 = access 0 = no access */
-@@ -233,6 +236,11 @@ asmlinkage long sys32_ptrace(long reques
+@@ -233,6 +236,12 @@ asmlinkage long sys32_ptrace(long reques
  	void __user *datap = compat_ptr(data);
  	int ret;
  	__u32 val;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	switch (request) { 
  	default:
---- linux-source-2.6.15-2.6.15.orig/arch/ia64/ia32/sys_ia32.c
-+++ linux-source-2.6.15-2.6.15/arch/ia64/ia32/sys_ia32.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/ia64/ia32/sys_ia32.c
++++ linux-source-2.6.15.7-ubuntu1/arch/ia64/ia32/sys_ia32.c
 @@ -57,6 +57,9 @@
  #include <asm/types.h>
  #include <asm/uaccess.h>
@@ -1546,20 +1713,21 @@
  
  #include "ia32priv.h"
  
-@@ -1758,6 +1761,11 @@ sys32_ptrace (int request, pid_t pid, un
+@@ -1758,6 +1761,12 @@ sys32_ptrace (int request, pid_t pid, un
  	struct task_struct *child;
  	unsigned int value, tmp;
  	long i, ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
  	lock_kernel();
  	if (request == PTRACE_TRACEME) {
---- linux-source-2.6.15-2.6.15.orig/arch/mips/kernel/ptrace32.c
-+++ linux-source-2.6.15-2.6.15/arch/mips/kernel/ptrace32.c
+--- linux-source-2.6.15.7-ubuntu1.orig/arch/mips/kernel/ptrace32.c
++++ linux-source-2.6.15.7-ubuntu1/arch/mips/kernel/ptrace32.c
 @@ -35,6 +35,9 @@
  #include <asm/system.h>
  #include <asm/uaccess.h>
@@ -1570,13 +1738,14 @@
  
  int ptrace_getregs (struct task_struct *child, __s64 __user *data);
  int ptrace_setregs (struct task_struct *child, __s64 __user *data);
-@@ -50,6 +53,11 @@ asmlinkage int sys32_ptrace(int request,
+@@ -50,6 +53,12 @@ asmlinkage int sys32_ptrace(int request,
  {
  	struct task_struct *child;
  	int ret;
 +	/***** TOMOYO Linux start. *****/
 +#ifdef TOMOYO_SYS_PTRACE
-+	if (!ccs_capable(TOMOYO_SYS_PTRACE)) return -EPERM;
++	if (!ccs_capable(TOMOYO_SYS_PTRACE))
++		return -EPERM;
 +#endif
 +	/***** TOMOYO Linux end. *****/
  
