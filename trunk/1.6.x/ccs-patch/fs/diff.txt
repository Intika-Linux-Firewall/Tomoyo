Index: trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h	(revision 1045)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h	(working copy)
@@ -1,7 +1,7 @@
 /*
  * include/linux/ccs_proc.h
  *
- * /proc interface for SAKURA and TOMOYO.
+ * /proc/ccs/ interface for SAKURA and TOMOYO.
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
@@ -19,10 +19,10 @@
 #define __user
 #endif
 
-extern void __init realpath_Init(void);
+/* Initialize realpath() related code. */
+extern void __init ccs_realpath_init(void);
 
-/*************************  Indexes for /proc interfaces.  *************************/
-
+/* Indexes for /proc/ccs/ interfaces. */
 #define CCS_DOMAINPOLICY          0
 #define CCS_EXCEPTIONPOLICY       1
 #define CCS_SYSTEMPOLICY          2
Index: trunk/1.6.x/ccs-patch/include/linux/syaoran.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/syaoran.h	(revision 1045)
+++ trunk/1.6.x/ccs-patch/include/linux/syaoran.h	(working copy)
@@ -14,115 +14,140 @@
 /*
  * A brief description about SYAORAN:
  *
- *  SYAORAN stands for "Simple Yet All-important Object Realizing Abiding Nexus".
- *  SYAORAN is a filesystem for /dev with Mandatory Access Control.
+ *  SYAORAN stands for "Simple Yet All-important Object Realizing Abiding
+ *  Nexus". SYAORAN is a filesystem for /dev with Mandatory Access Control.
  *
- *  /dev needs to be writable, but this means that files on /dev might be tampered with.
- *  SYAORAN can restrict combinations of (pathname, attribute) that the system can create.
+ *  /dev cannot be mounted for read-only mode, but this means that files on
+ *  /dev might be tampered with. In other words, a device file might have
+ *  inappropriate attributes (e.g. /dev/null has char-1-5 attributes).
+ *  SYAORAN can restrict combinations of (pathname, attribute) that
+ *  the system can create so that all files on this filesystem have appropriate
+ *  attributes (e.g. /dev/null has char-1-3 attributes).
+ *
  *  The attribute is one of directory, regular file, FIFO, UNIX domain socket,
- *  symbolic link, character or block device file with major/minor device numbers.
+ *  symbolic link, character or block device file with major/minor device
+ *  numbers.
  *
- *  You can use SYAORAN alone, but I recommend you to use with SAKURA and TOMOYO.
+ *  You can use SYAORAN alone, but I recommend you to use SYAORAN
+ *  with SAKURA and TOMOYO.
  */
 
 #ifndef _LINUX_SYAORAN_H
 #define _LINUX_SYAORAN_H
 
+#include <linux/version.h>
+
+#define false 0
+#define true 1
+
 #ifndef __user
 #define __user
 #endif
 
-/***** SYAORAN start. *****/
-
-#include <linux/version.h>
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #define s_fs_info u.generic_sbp
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#ifndef DEFINE_SPINLOCK
+#define DEFINE_SPINLOCK(x) spinlock_t x = SPIN_LOCK_UNLOCKED
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 typedef _Bool bool;
 #endif
 
-#define false 0
-#define true 1
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
 static inline void *kzalloc(int size, int flags)
 {
 	void *p = kmalloc(size, flags);
-	if (p) memset(p, 0, size);
+	if (p)
+		memset(p, 0, size);
 	return p;
 }
 #endif
 
-#define list_for_each_cookie(pos, cookie, head) \
-	for (({if (!cookie) cookie = head;}), pos = (cookie)->next; \
-		prefetch(pos->next), pos != (head) || ((cookie) = NULL); \
-		(cookie) = pos, pos = pos->next)
-
 #ifndef list_for_each_entry_safe
 #define list_for_each_entry_safe(pos, n, head, member)                  \
 	for (pos = list_entry((head)->next, typeof(*pos), member),      \
-		n = list_entry(pos->member.next, typeof(*pos), member); \
-		&pos->member != (head);                                    \
-		pos = n, n = list_entry(n->member.next, typeof(*n), member))
+		     n = list_entry(pos->member.next, typeof(*pos), member); \
+	     &pos->member != (head);					\
+	     pos = n, n = list_entry(n->member.next, typeof(*n), member))
 #endif
 
+/**
+ * list_for_each_cookie - iterate over a list with cookie.
+ * @pos:        the &struct list_head to use as a loop cursor.
+ * @cookie:     the &struct list_head to use as a cookie.
+ * @head:       the head for your list.
+ *
+ * Same with list_for_each except that this primitive uses cookie
+ * so that we can continue iteration.
+ */
+#define list_for_each_cookie(pos, cookie, head)				\
+	for (({ if (!cookie)						\
+				     cookie = head; }), pos = (cookie)->next; \
+	     prefetch(pos->next), pos != (head) || ((cookie) = NULL);	\
+	     (cookie) = pos, pos = pos->next)
+
 /* The following constants are used to restrict operations.*/
+#define MAY_CREATE         1 /* This file is allowed to mknod()              */
+#define MAY_DELETE         2 /* This file is allowed to unlink()             */
+#define MAY_CHMOD          4 /* This file is allowed to chmod()              */
+#define MAY_CHOWN          8 /* This file is allowed to chown()              */
+#define DEVICE_USED       16 /* This block or character device file is used. */
+#define NO_CREATE_AT_MOUNT 32 /* Don't create this file at mount().          */
 
-#define MAY_CREATE          1 /* This file is allowed to mknod()              */
-#define MAY_DELETE          2 /* This file is allowed to unlink()             */
-#define MAY_CHMOD           4 /* This file is allowed to chmod()              */
-#define MAY_CHOWN           8 /* This file is allowed to chown()              */
-#define DEVICE_USED        16 /* This block or character device file is used. */
-#define NO_CREATE_AT_MOUNT 32 /* Don't create this file at mount().           */
-
 /* some random number */
 #define SYAORAN_MAGIC    0x2F646576 /* = '/dev' */
 
 static void syaoran_put_super(struct super_block *sb);
-static int Syaoran_Initialize(struct super_block *sb, void *data);
-static void MakeInitialNodes(struct super_block *sb);
-static int MayCreateNode(struct dentry *dentry, int mode, int dev);
-static int MayModifyNode(struct dentry *dentry, unsigned int flags);
-static int syaoran_create_tracelog(struct super_block *sb, const char *filename);
+static int syaoran_initialize(struct super_block *sb, void *data);
+static void syaoran_make_initial_nodes(struct super_block *sb);
+static int syaoran_may_create_node(struct dentry *dentry, int mode, int dev);
+static int syaoran_may_modify_node(struct dentry *dentry, unsigned int flags);
+static int syaoran_create_tracelog(struct super_block *sb,
+				   const char *filename);
 
 /* Wraps blkdev_open() to trace open operation for block devices. */
-static int (*org_blkdev_open) (struct inode * inode, struct file * filp) = NULL;
+static int (*org_blkdev_open) (struct inode *inode, struct file *filp);
 static struct file_operations wrapped_def_blk_fops;
 
-static int wrapped_blkdev_open(struct inode * inode, struct file * filp)
+static int wrapped_blkdev_open(struct inode *inode, struct file *filp)
 {
 	int error = org_blkdev_open(inode, filp);
-	if (error != -ENXIO) MayModifyNode(filp->f_dentry, DEVICE_USED);
+	if (error != -ENXIO)
+		syaoran_may_modify_node(filp->f_dentry, DEVICE_USED);
 	return error;
 }
 
 /* Wraps chrdev_open() to trace open operation for character devices. */
-static int (*org_chrdev_open) (struct inode * inode, struct file * filp) = NULL;
+static int (*org_chrdev_open) (struct inode *inode, struct file *filp);
 static struct file_operations wrapped_def_chr_fops;
 
-static int wrapped_chrdev_open(struct inode * inode, struct file * filp)
+static int wrapped_chrdev_open(struct inode *inode, struct file *filp)
 {
 	int error = org_chrdev_open(inode, filp);
-	if (error != -ENXIO) MayModifyNode(filp->f_dentry, DEVICE_USED);
+	if (error != -ENXIO)
+		syaoran_may_modify_node(filp->f_dentry, DEVICE_USED);
 	return error;
 }
 
 /* lookup_create() without nameidata. Called only while initialization. */
-static struct dentry *lookup_create2(const char *name, struct dentry *base, const u8 is_dir)
+static struct dentry *lookup_create2(const char *name, struct dentry *base,
+				     const bool is_dir)
 {
 	struct dentry *dentry;
 	const int len = name ? strlen(name) : 0;
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 	mutex_lock(&base->d_inode->i_mutex);
 #else
 	down(&base->d_inode->i_sem);
 #endif
 	dentry = lookup_one_len(name, base, len);
-	if (IS_ERR(dentry)) goto fail;
-	if (!is_dir && name[len] && !dentry->d_inode) goto enoent;
+	if (IS_ERR(dentry))
+		goto fail;
+	if (!is_dir && name[len] && !dentry->d_inode)
+		goto enoent;
 	return dentry;
  enoent:
 	dput(dentry);
@@ -132,7 +157,8 @@
 }
 
 /* mkdir(). Called only while initialization. */
-static int fs_mkdir(const char *pathname, struct dentry *base, int mode, uid_t user, gid_t group)
+static int fs_mkdir(const char *pathname, struct dentry *base, int mode,
+		    uid_t user, gid_t group)
 {
 	struct dentry *dentry = lookup_create2(pathname, base, 1);
 	int error = PTR_ERR(dentry);
@@ -146,7 +172,7 @@
 		}
 		dput(dentry);
 	}
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 	mutex_unlock(&base->d_inode->i_mutex);
 #else
 	up(&base->d_inode->i_sem);
@@ -155,12 +181,17 @@
 }
 
 /* mknod(). Called only while initialization. */
-static int fs_mknod(const char *filename, struct dentry *base, int mode, dev_t dev, uid_t user, gid_t group)
+static int fs_mknod(const char *filename, struct dentry *base, int mode,
+		    dev_t dev, uid_t user, gid_t group)
 {
 	struct dentry *dentry;
 	int error;
 	switch (mode & S_IFMT) {
-	case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK: case S_IFREG:
+	case S_IFCHR:
+	case S_IFBLK:
+	case S_IFIFO:
+	case S_IFSOCK:
+	case S_IFREG:
 		break;
 	default:
 		return -EPERM;
@@ -177,7 +208,7 @@
 		}
 		dput(dentry);
 	}
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 	mutex_unlock(&base->d_inode->i_mutex);
 #else
 	up(&base->d_inode->i_sem);
@@ -186,12 +217,13 @@
 }
 
 /* symlink(). Called only while initialization. */
-static int fs_symlink(const char *pathname, struct dentry *base, char *oldname, int mode, uid_t user, gid_t group)
+static int fs_symlink(const char *pathname, struct dentry *base, char *oldname,
+		      int mode, uid_t user, gid_t group)
 {
 	struct dentry *dentry = lookup_create2(pathname, base, 0);
 	int error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 		error = vfs_symlink(base->d_inode, dentry, oldname, S_IALLUGO);
 #else
 		error = vfs_symlink(base->d_inode, dentry, oldname);
@@ -205,7 +237,7 @@
 		}
 		dput(dentry);
 	}
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 	mutex_unlock(&base->d_inode->i_mutex);
 #else
 	up(&base->d_inode->i_sem);
@@ -218,86 +250,113 @@
  * Leading and trailing whitespaces are removed.
  * Multiple whitespaces are packed into single space.
  */
-static void NormalizeLine(unsigned char *buffer)
+static void normalize_line(unsigned char *buffer)
 {
 	unsigned char *sp = buffer, *dp = buffer;
 	bool first = true;
-	while (*sp && (*sp <= ' ' || *sp >= 127)) sp++;
+	while (*sp && (*sp <= ' ' || *sp >= 127))
+		sp++;
 	while (*sp) {
-		if (!first) *dp++ = ' ';
+		if (!first)
+			*dp++ = ' ';
 		first = false;
-		while (*sp > ' ' && *sp < 127) *dp++ = *sp++;
-		while (*sp && (*sp <= ' ' || *sp >= 127)) sp++;
+		while (*sp > ' ' && *sp < 127)
+			*dp++ = *sp++;
+		while (*sp && (*sp <= ' ' || *sp >= 127))
+			sp++;
 	}
 	*dp = '\0';
 }
 
 /* Convert text form of filename into binary form. */
-static void UnEscape(char *filename)
+static void unescape(char *filename)
 {
 	char *cp = filename;
 	char c, d, e;
-	if (!cp) return;
+	if (!cp)
+		return;
 	while ((c = *filename++) != '\0') {
 		if (c != '\\') {
 			*cp++ = c;
 			continue;
 		}
-		if ((c = *filename++) == '\\') {
+		c = *filename++;
+		if (c == '\\') {
 			*cp++ = c;
 			continue;
 		}
 		if (c < '0' || c > '3' ||
-			(d = *filename++) < '0' || d > '7' ||
-			(e = *filename++) < '0' || e > '7') {
+		    (d = *filename++) < '0' || d > '7' ||
+		    (e = *filename++) < '0' || e > '7') {
 			break;
 		}
-		* (unsigned char *) cp++ = (unsigned char) (((unsigned char) (c - '0') << 6) + ((unsigned char) (d - '0') << 3) + (unsigned char) (e - '0'));
+		*(unsigned char *) cp++ = (unsigned char)
+			(((unsigned char) (c - '0') << 6)
+			 + ((unsigned char) (d - '0') << 3)
+			 + (unsigned char) (e - '0'));
 	}
 	*cp = '\0';
 }
 
 static char *strdup(const char *str)
 {
-	char *cp;
 	const int len = str ? strlen(str) + 1 : 0;
-	if ((cp = kzalloc(len, GFP_KERNEL)) != NULL) memmove(cp, str, len);
+	char *cp = kzalloc(len, GFP_KERNEL);
+	if (cp)
+		memmove(cp, str, len);
 	return cp;
 }
 
-static int syaoran_default_mode = -1; /* -1: Not specified, 0: Enforce by default, 1: Accept by default. */
+/* -1: Not specified, 0: Enforce by default, 1: Accept by default. */
+static int syaoran_default_mode = -1;
 
 #if !defined(MODULE)
-static int __init SYAORAN_Setup(char *str)
+static int __init syaoran_setup(char *str)
 {
-	if (strcmp(str, "accept") == 0) syaoran_default_mode = 1;
-	else if (strcmp(str, "enforce") == 0) syaoran_default_mode = 0;
+	if (strcmp(str, "accept") == 0)
+		syaoran_default_mode = 1;
+	else if (strcmp(str, "enforce") == 0)
+		syaoran_default_mode = 0;
 	return 0;
 }
 
-__setup("SYAORAN=", SYAORAN_Setup);
+__setup("SYAORAN=", syaoran_setup);
 #endif
 
+/* The structure for possible device list. */
 struct dev_entry {
 	struct list_head list;
-	char *name;                         /* Binary form of pathname under mount point. Never NULL.                */
-	mode_t mode;                        /* Mode and permissions. setuid/setgid/sticky bits are not supported.    */
+	/* Binary form of pathname under mount point. Never NULL. */
+	char *name;
+	/*
+	 * Mode and permissions.
+	 * setuid/setgid/sticky bits are not supported.
+	 */
+	mode_t mode;
 	uid_t uid;
 	gid_t gid;
 	dev_t kdev;
-	char *symlink_data;                 /* Binary form of initial contents for the symlink. NULL if not symlink. */
-	unsigned int flags;                 /* File access control flags.                                            */
-	const char *printable_name;         /* Text form of pathname under mount point. Never NULL.                  */
-	const char *printable_symlink_data; /* Text form of initial contents for the symlink. NULL if not symlink.   */
+	/*
+	 * Binary form of initial contents for the symlink. NULL if not symlink.
+	 */
+	char *symlink_data;
+	/* File access control flags. */
+	unsigned int flags;
+	/* Text form of pathname under mount point. Never NULL. */
+	const char *printable_name;
+	/*
+	 * Text form of initial contents for the symlink. NULL if not symlink.
+	 */
+	const char *printable_symlink_data;
 };
 
 struct syaoran_sb_info {
 	struct list_head list;
-	bool initialize_done;           /* False if initialization is in progress. */
-	bool is_permissive_mode;        /* True if permissive mode.                */
+	bool initialize_done;     /* False if initialization is in progress. */
+	bool is_permissive_mode;  /* True if permissive mode.                */
 };
 
-static int RegisterNodeInfo(char *buffer, struct super_block *sb)
+static int syaoran_register_node_info(char *buffer, struct super_block *sb)
 {
 	enum {
 		ARG_FILENAME     = 0,
@@ -315,33 +374,54 @@
 	int i;
 	int error = -EINVAL;
 	unsigned int perm, uid, gid, flags, major = 0, minor = 0;
-	struct syaoran_sb_info *info = (struct syaoran_sb_info *) sb->s_fs_info;
+	struct syaoran_sb_info *info =
+		(struct syaoran_sb_info *) sb->s_fs_info;
 	struct dev_entry *entry;
+	if (!info)
+		return -EINVAL;
 	memset(args, 0, sizeof(args));
 	args[0] = buffer;
 	for (i = 1; i < MAX_ARG; i++) {
 		args[i] = strchr(args[i - 1] + 1, ' ');
-		if (!args[i]) break;
+		if (!args[i])
+			break;
 		*args[i]++ = '\0';
 	}
-	/* printk("<%s> <%s> <%s> <%s> <%s> <%s> <%s> <%s>\n", args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]); */
-	if (!args[ARG_FILENAME] || !args[ARG_PERMISSION] || !args[ARG_UID] || !args[ARG_GID] || !args[ARG_DEV_TYPE] || !args[ARG_FLAGS]) goto out;
-	if (sscanf(args[ARG_PERMISSION], "%o", &perm) != 1 || !(perm <= 0777) || sscanf(args[ARG_UID], "%u", &uid) != 1
-		|| sscanf(args[ARG_GID], "%u", &gid) != 1 || sscanf(args[ARG_FLAGS], "%u", &flags) != 1 || *(args[ARG_DEV_TYPE] + 1)) goto out;
+	/*
+	  printk(KERN_DEBUG "<%s> <%s> <%s> <%s> <%s> <%s> <%s> <%s>\n",
+	  args[0], args[1], args[2], args[3], args[4], args[5], args[6],
+	  args[7]);
+	*/
+	if (!args[ARG_FILENAME] || !args[ARG_PERMISSION] || !args[ARG_UID] ||
+	    !args[ARG_GID] || !args[ARG_DEV_TYPE] || !args[ARG_FLAGS])
+		goto out;
+	if (sscanf(args[ARG_PERMISSION], "%o", &perm) != 1 ||
+	    !(perm <= 0777) || sscanf(args[ARG_UID], "%u", &uid) != 1 ||
+	    sscanf(args[ARG_GID], "%u", &gid) != 1 ||
+	    sscanf(args[ARG_FLAGS], "%u", &flags) != 1 ||
+	    *(args[ARG_DEV_TYPE] + 1))
+		goto out;
 	switch (*args[ARG_DEV_TYPE]) {
 	case 'c':
 		perm |= S_IFCHR;
-		if (!args[ARG_DEV_MAJOR] || sscanf(args[ARG_DEV_MAJOR], "%u", &major) != 1
-			|| !args[ARG_DEV_MINOR] || sscanf(args[ARG_DEV_MINOR], "%u", &minor) != 1) goto out;
+		if (!args[ARG_DEV_MAJOR] ||
+		    sscanf(args[ARG_DEV_MAJOR], "%u", &major) != 1 ||
+		    !args[ARG_DEV_MINOR] ||
+		    sscanf(args[ARG_DEV_MINOR], "%u", &minor) != 1)
+			goto out;
 		break;
 	case 'b':
 		perm |= S_IFBLK;
-		if (!args[ARG_DEV_MAJOR] || sscanf(args[ARG_DEV_MAJOR], "%u", &major) != 1
-			|| !args[ARG_DEV_MINOR] || sscanf(args[ARG_DEV_MINOR], "%u", &minor) != 1) goto out;
+		if (!args[ARG_DEV_MAJOR] ||
+		    sscanf(args[ARG_DEV_MAJOR], "%u", &major) != 1 ||
+		    !args[ARG_DEV_MINOR] ||
+		    sscanf(args[ARG_DEV_MINOR], "%u", &minor) != 1)
+			goto out;
 		break;
 	case 'l':
 		perm |= S_IFLNK;
-		if (!args[ARG_SYMLINK_DATA]) goto out;
+		if (!args[ARG_SYMLINK_DATA])
+			goto out;
 		break;
 	case 'd':
 		perm |= S_IFDIR;
@@ -359,20 +439,35 @@
 		goto out;
 	}
 	error = -ENOMEM;
-	if ((entry = kzalloc(sizeof(*entry), GFP_KERNEL)) == NULL) goto out;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		goto out;
 	if (S_ISLNK(perm)) {
-		if ((entry->printable_symlink_data = strdup(args[ARG_SYMLINK_DATA])) == NULL) goto out_freemem;
+		entry->printable_symlink_data = strdup(args[ARG_SYMLINK_DATA]);
+		if (!entry->printable_symlink_data)
+			goto out_freemem;
 	}
-	if ((entry->printable_name = strdup(args[ARG_FILENAME])) == NULL) goto out_freemem;
+	entry->printable_name = strdup(args[ARG_FILENAME]);
+	if (!entry->printable_name)
+		goto out_freemem;
 	if (S_ISLNK(perm)) {
-		if ((entry->symlink_data = strdup(entry->printable_symlink_data)) == NULL) goto out_freemem;
-		UnEscape(entry->symlink_data);
+		entry->symlink_data = strdup(entry->printable_symlink_data);
+		if (!entry->symlink_data)
+			goto out_freemem;
+		unescape(entry->symlink_data);
 	}
-	if ((entry->name = strdup(entry->printable_name)) == NULL) goto out_freemem;
-	UnEscape(entry->name);
-	{   /* Drop trailing '/', for GetLocalAbsolutePath() doesn't append trailing '/'. */
+	entry->name = strdup(entry->printable_name);
+	if (!entry->name)
+		goto out_freemem;
+	unescape(entry->name);
+	{
+		/*
+		 * Drop trailing '/', for get_local_absolute_path() doesn't
+		 * append trailing '/'.
+		 */
 		const int len = strlen(entry->name);
-		if (len && entry->name[len - 1] == '/') entry->name[len - 1] = '\0';
+		if (len && entry->name[len - 1] == '/')
+			entry->name[len - 1] = '\0';
 	}
 	entry->mode = perm;
 	entry->uid = uid;
@@ -380,7 +475,7 @@
 	entry->kdev = S_ISCHR(perm) || S_ISBLK(perm) ? MKDEV(major, minor) : 0;
 	entry->flags = flags;
 	list_add_tail(&entry->list, &info->list);
-	/* printk("Entry added.\n"); */
+	/* printk(KERN_DEBUG "Entry added.\n"); */
 	error = 0;
  out:
 	return error;
@@ -396,46 +491,54 @@
 {
 	struct syaoran_sb_info *info;
 	struct dev_entry *entry, *tmp;
-	if (!sb) return;
+	if (!sb)
+		return;
 	info = (struct syaoran_sb_info *) sb->s_fs_info;
-	if (!info) return;
+	if (!info)
+		return;
+	sb->s_fs_info = NULL;
+	/* FIXME: I need to make sure nobody is accessing sb->s_fs_info . */
+	mb();
 	list_for_each_entry_safe(entry, tmp, &info->list, list) {
 		kfree(entry->name);
 		kfree(entry->symlink_data);
 		kfree(entry->printable_name);
 		kfree(entry->printable_symlink_data);
 		list_del(&entry->list);
-		/* printk("Entry removed.\n"); */
+		/* printk(KERN_DEBUG "Entry removed.\n"); */
 		kfree(entry);
 	}
 	kfree(info);
-	sb->s_fs_info = NULL;
-	printk("%s: Unused memory freed.\n", __FUNCTION__);
+	printk(KERN_INFO "%s: Unused memory freed.\n", __func__);
 }
 
-static int ReadConfigFile(struct file *file, struct super_block *sb)
+static int syaoran_read_config_file(struct file *file, struct super_block *sb)
 {
 	char *buffer;
+	int len;
+	char *cp;
+	unsigned long offset = 0;
 	int error = -ENOMEM;
-	if (!file) return -EINVAL;
-	if ((buffer = kzalloc(PAGE_SIZE, GFP_KERNEL)) != NULL) {
-		int len;
-		char *cp;
-		unsigned long offset = 0;
-		while ((len = kernel_read(file, offset, buffer, PAGE_SIZE)) > 0 && (cp = memchr(buffer, '\n', len)) != NULL) {
-			*cp = '\0';
-			offset += cp - buffer + 1;
-			NormalizeLine(buffer);
-			if (RegisterNodeInfo(buffer, sb) == -ENOMEM) goto out;
-		}
-		error = 0;
+	if (!file)
+		return -EINVAL;
+	buffer = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buffer)
+		goto out;
+	while ((len = kernel_read(file, offset, buffer, PAGE_SIZE)) > 0 &&
+	       (cp = memchr(buffer, '\n', len)) != NULL) {
+		*cp = '\0';
+		offset += cp - buffer + 1;
+		normalize_line(buffer);
+		if (syaoran_register_node_info(buffer, sb) == -ENOMEM)
+			goto out;
 	}
+	error = 0;
  out:
 	kfree(buffer);
 	return error;
 }
 
-static void MakeNode(struct dev_entry *entry, struct dentry *root)
+static void syaoran_make_node(struct dev_entry *entry, struct dentry *root)
 {
 	struct dentry *base = dget(root);
 	char *filename = entry->name;
@@ -445,12 +548,12 @@
 	const uid_t uid = entry->uid;
 	const gid_t gid = entry->gid;
 	goto start;
-	while ((c = * (unsigned char *) filename) != '\0') {
+	while ((c = *(unsigned char *) filename) != '\0') {
 		if (c == '/') {
 			struct dentry *new_base;
 			const int len = filename - name;
 			*filename = '\0';
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 			mutex_lock(&base->d_inode->i_mutex);
 			new_base = lookup_one_len(name, base, len);
 			mutex_unlock(&base->d_inode->i_mutex);
@@ -460,73 +563,83 @@
 			up(&base->d_inode->i_sem);
 #endif
 			dput(base);
-			/*
+			*filename++ = '/';
 			if (IS_ERR(new_base)) {
-				printk("'%s' = %ld\n", entry->name, PTR_ERR(new_base));
-			} else if (!new_base->d_inode || !S_ISDIR(new_base->d_inode->i_mode)) {
-				printk("Directory '%s' does not exist.\n", entry->name);
-			} else {
-				printk("Directory '%s' exists.\n", entry->name);
-			}
-			*/
-			*filename = '/';
-			filename++;
-			if (IS_ERR(new_base)) {
+				/*
+				  printk(KERN_DEBUG "'%s' = %ld\n", entry->name,
+				  PTR_ERR(new_base));
+				*/
 				return;
-			} else if (!new_base->d_inode || !S_ISDIR(new_base->d_inode->i_mode)) {
+			} else if (!new_base->d_inode ||
+				   !S_ISDIR(new_base->d_inode->i_mode)) {
+				/*
+				  printk(KERN_DEBUG
+				  "Directory '%s' does not exist.\n",
+				  entry->name);
+				*/
 				dput(new_base);
 				return;
 			}
+			/*
+			  printk(KERN_DEBUG "Directory '%s' exists.\n",
+			  entry->name);
+			*/
 			base = new_base;
-		start:
+ start:
 			name = filename;
 		} else {
 			filename++;
 		}
 	}
 	filename = (char *) name;
-	if (S_ISLNK(perm)) {
+	if (S_ISLNK(perm))
 		fs_symlink(filename, base, entry->symlink_data, perm, uid, gid);
-	} else if (S_ISDIR(perm)) {
+	else if (S_ISDIR(perm))
 		fs_mkdir(filename, base, perm ^ S_IFDIR, uid, gid);
-	} else if (S_ISSOCK(perm) || S_ISFIFO(perm) || S_ISREG(perm)) {
+	else if (S_ISSOCK(perm) || S_ISFIFO(perm) || S_ISREG(perm))
 		fs_mknod(filename, base, perm, 0, uid, gid);
-	} else if (S_ISCHR(perm) || S_ISBLK(perm)) {
+	else if (S_ISCHR(perm) || S_ISBLK(perm))
 		fs_mknod(filename, base, perm, entry->kdev, uid, gid);
-	}
 	dput(base);
 }
 
 /* Create files according to the policy file. */
-static void MakeInitialNodes(struct super_block *sb)
+static void syaoran_make_initial_nodes(struct super_block *sb)
 {
 	struct syaoran_sb_info *info;
 	struct dev_entry *entry;
-	if (!sb) return;
+	if (!sb)
+		return;
 	info = (struct syaoran_sb_info *) sb->s_fs_info;
-	if (!info) return;
+	if (!info)
+		return;
 	if (info->is_permissive_mode) {
 		syaoran_create_tracelog(sb, ".syaoran");
 		syaoran_create_tracelog(sb, ".syaoran_all");
 	}
 	list_for_each_entry(entry, &info->list, list) {
-		if ((entry->flags & NO_CREATE_AT_MOUNT) == 0) MakeNode(entry, sb->s_root);
+		if ((entry->flags & NO_CREATE_AT_MOUNT) == 0)
+			syaoran_make_node(entry, sb->s_root);
 	}
 	info->initialize_done = true;
 }
 
 /* Read policy file. */
-static int Syaoran_Initialize(struct super_block *sb, void *data)
+static int syaoran_initialize(struct super_block *sb, void *data)
 {
 	int error = -EINVAL;
+	struct file *f;
+	char *filename = (char *) data;
+	bool is_permissive_mode = syaoran_default_mode;
 	static bool first = true;
 	if (first) {
 		first = false;
-		printk("SYAORAN: 1.6.0-pre   2008/03/04\n");
+		printk(KERN_INFO "SYAORAN: 1.6.0-pre   2008/03/04\n");
 	}
 	{
 		struct inode *inode = new_inode(sb);
-		if (!inode) return -EINVAL;
+		if (!inode)
+			return -EINVAL;
 		/* Create /dev/ram0 to get the value of blkdev_open(). */
 		init_special_inode(inode, S_IFBLK | 0666, MKDEV(1, 0));
 		wrapped_def_blk_fops = *inode->i_fop;
@@ -536,7 +649,8 @@
 	}
 	{
 		struct inode *inode = new_inode(sb);
-		if (!inode) return -EINVAL;
+		if (!inode)
+			return -EINVAL;
 		/* Create /dev/null to get the value of chrdev_open(). */
 		init_special_inode(inode, S_IFCHR | 0666, MKDEV(1, 3));
 		wrapped_def_chr_fops = *inode->i_fop;
@@ -544,70 +658,83 @@
 		org_chrdev_open = wrapped_def_chr_fops.open;
 		wrapped_def_chr_fops.open = wrapped_chrdev_open;
 	}
-	if (data) {
-		struct file *f;
-		char *filename = (char *) data;
-		bool is_permissive_mode = syaoran_default_mode;
-		/* If mode is given with mount operation, use it. */
-		if (strncmp(filename, "accept=", 7) == 0) {
-			filename += 7;
-			is_permissive_mode = true;
-		} else if (strncmp(filename, "enforce=", 8) == 0) {
-			filename += 8;
-			is_permissive_mode = false;
-		} else if (syaoran_default_mode == -1) {
-			/* If mode is not given with command line, abort mount. */
-			printk("SYAORAN: Missing 'accept=' or 'enforce='.\n");
-			return -EINVAL;
-		}
-		f = filp_open(filename, O_RDONLY, 0600);
-		if (!IS_ERR(f)) {
-			struct syaoran_sb_info *p;
-			if (!S_ISREG(f->f_dentry->d_inode->i_mode)) goto out;
-			if ((p = sb->s_fs_info = kzalloc(sizeof(*p), GFP_KERNEL)) == NULL) goto out;
-			p->is_permissive_mode = is_permissive_mode;
-			INIT_LIST_HEAD(&((struct syaoran_sb_info *) sb->s_fs_info)->list);
-			printk("SYAORAN: Reading '%s'\n", filename);
-			error = ReadConfigFile(f, sb);
-		out:
-			if (error) printk("SYAORAN: Can't read '%s'\n", filename);
-			filp_close(f, NULL);
-		} else {
-			printk("SYAORAN: Can't open '%s'\n", filename);
-		}
-	} else {
-		printk("SYAORAN: Missing config-file path.\n");
+	if (!filename) {
+		printk(KERN_WARNING "SYAORAN: Missing config-file path.\n");
+		return -EINVAL;
 	}
+	/* If mode is given with mount operation, use it. */
+	if (strncmp(filename, "accept=", 7) == 0) {
+		filename += 7;
+		is_permissive_mode = true;
+	} else if (strncmp(filename, "enforce=", 8) == 0) {
+		filename += 8;
+		is_permissive_mode = false;
+	} else if (syaoran_default_mode == -1) {
+		/*
+		 * If mode is not given with command line,
+		 * abort mount.
+		 */
+		printk(KERN_WARNING
+		       "SYAORAN: Missing 'accept=' or 'enforce='.\n");
+		return -EINVAL;
+	}
+	f = filp_open(filename, O_RDONLY, 0600);
+	if (IS_ERR(f)) {
+		printk(KERN_WARNING "SYAORAN: Can't open '%s'\n", filename);
+		return -EINVAL;
+	}
+	if (!S_ISREG(f->f_dentry->d_inode->i_mode))
+		goto out;
+	sb->s_fs_info = kzalloc(sizeof(struct syaoran_sb_info), GFP_KERNEL);
+	if (!sb->s_fs_info)
+		goto out;
+	((struct syaoran_sb_info *) sb->s_fs_info)->is_permissive_mode
+		= is_permissive_mode;
+	INIT_LIST_HEAD(&((struct syaoran_sb_info *) sb->s_fs_info)->list);
+	printk(KERN_INFO "SYAORAN: Reading '%s'\n", filename);
+	error = syaoran_read_config_file(f, sb);
+ out:
+	if (error)
+		printk(KERN_WARNING "SYAORAN: Can't read '%s'\n", filename);
+	filp_close(f, NULL);
 	return error;
 }
 
 /* Get absolute pathname from mount point. */
-static int GetLocalAbsolutePath(struct dentry *dentry, char *buffer, int buflen)
+static int get_local_absolute_path(struct dentry *dentry, char *buffer,
+				   int buflen)
 {
 	char *start = buffer;
 	char *end = buffer + buflen;
 	int namelen;
 
-	if (buflen < 256) goto out;
+	if (buflen < 256)
+		goto out;
 
 	*--end = '\0';
 	buflen--;
 	for (;;) {
 		struct dentry *parent;
-		if (IS_ROOT(dentry)) break;
+		if (IS_ROOT(dentry))
+			break;
 		parent = dentry->d_parent;
 		namelen = dentry->d_name.len;
 		buflen -= namelen + 1;
-		if (buflen < 0) goto out;
+		if (buflen < 0)
+			goto out;
 		end -= namelen;
 		memcpy(end, dentry->d_name.name, namelen);
 		*--end = '/';
 		dentry = parent;
 	}
-	if (*end == '/') { buflen++; end++; }
+	if (*end == '/') {
+		buflen++;
+		end++;
+	}
 	namelen = dentry->d_name.len;
 	buflen -= namelen;
-	if (buflen < 0) goto out;
+	if (buflen < 0)
+		goto out;
 	end -= namelen;
 	memcpy(end, dentry->d_name.name, namelen);
 	memmove(start, end, strlen(end) + 1);
@@ -617,54 +744,70 @@
 }
 
 /* Get absolute pathname of the given dentry from mount point. */
-static int local_realpath_from_dentry(struct dentry *dentry, char *newname, int newname_len)
+static int local_ccs_realpath_from_dentry(struct dentry *dentry, char *newname,
+					  int newname_len)
 {
 	int error;
 	struct dentry *d_dentry;
-	if (!dentry || !newname || newname_len <= 0) return -EINVAL;
+	if (!dentry || !newname || newname_len <= 0)
+		return -EINVAL;
 	d_dentry = dget(dentry);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&dcache_lock);
-	error = GetLocalAbsolutePath(d_dentry, newname, newname_len);
+	error = get_local_absolute_path(d_dentry, newname, newname_len);
 	spin_unlock(&dcache_lock);
 	/***** CRITICAL SECTION END *****/
 	dput(d_dentry);
 	return error;
 }
 
-static int CheckFlags(struct syaoran_sb_info *info, struct dentry *dentry, int mode, int dev, unsigned int flags)
+static int syaoran_check_flags(struct syaoran_sb_info *info,
+			       struct dentry *dentry,
+			       int mode, int dev, unsigned int flags)
 {
-	int error = -EPERM;
-	/* I use static buffer, for local_realpath_from_dentry() needs dcache_lock. */
+	int error;
+	/*
+	 * I use static buffer, for local_ccs_realpath_from_dentry() needs
+	 * dcache_lock.
+	 */
 	static char filename[PAGE_SIZE];
-	static spinlock_t lock = SPIN_LOCK_UNLOCKED;
+	static DEFINE_SPINLOCK(lock);
+	/***** CRITICAL SECTION START *****/
 	spin_lock(&lock);
 	memset(filename, 0, sizeof(filename));
-	if (local_realpath_from_dentry(dentry, filename, sizeof(filename) - 1) == 0) {
+	error = local_ccs_realpath_from_dentry(dentry, filename,
+					       sizeof(filename) - 1);
+	if (!error) {
 		struct dev_entry *entry;
+		error = -EPERM;
 		list_for_each_entry(entry, &info->list, list) {
-			if ((mode & S_IFMT) != (entry->mode & S_IFMT)) continue;
-			if ((S_ISBLK(mode) || S_ISCHR(mode)) && dev != entry->kdev) continue;
-			if (strcmp(entry->name, filename + 1)) continue;
+			if ((mode & S_IFMT) != (entry->mode & S_IFMT))
+				continue;
+			if ((S_ISBLK(mode) || S_ISCHR(mode)) &&
+			    dev != entry->kdev)
+				continue;
+			if (strcmp(entry->name, filename + 1))
+				continue;
 			if (info->is_permissive_mode) {
 				entry->flags |= flags;
 				error = 0;
-			} else {
-				if ((entry->flags & flags) == flags) error = 0;
-			}
+			} else if ((entry->flags & flags) == flags)
+				error = 0;
 			break;
 		}
 	}
-	if (error && strlen(filename) < (sizeof(filename) / 4) - 16) {
+	if (!error) {
 		const char *name;
-		const uid_t uid = current->fsuid;
-		const gid_t gid = current->fsgid;
+		struct task_struct *task = current;
+		const uid_t uid = task->fsuid;
+		const gid_t gid = task->fsgid;
 		const mode_t perm = mode & 0777;
 		flags &= ~DEVICE_USED;
 		{
 			char *end = filename + sizeof(filename) - 1;
 			const char *cp = strchr(filename, '\0') - 1;
-			while (cp > filename) {
+			while (cp > filename && end > cp &&
+			       end > filename + 16) {
 				const unsigned char c = *cp--;
 				if (c == '\\') {
 					*--end = '\\';
@@ -682,59 +825,85 @@
 		}
 		switch (mode & S_IFMT) {
 		case S_IFCHR:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %3u %3u\n", name, perm, uid, gid, flags, 'c', MAJOR(dev), MINOR(dev));
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %3u %3u\n",
+			       name, perm, uid, gid, flags, 'c',
+			       MAJOR(dev), MINOR(dev));
 			break;
 		case S_IFBLK:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %3u %3u\n", name, perm, uid, gid, flags, 'b', MAJOR(dev), MINOR(dev));
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %3u %3u\n",
+			       name, perm, uid, gid, flags, 'b',
+			       MAJOR(dev), MINOR(dev));
 			break;
 		case S_IFIFO:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'p');
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name,
+			       perm, uid, gid, flags, 'p');
 			break;
 		case S_IFSOCK:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 's');
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name,
+			       perm, uid, gid, flags, 's');
 			break;
 		case S_IFDIR:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'd');
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name,
+			       perm, uid, gid, flags, 'd');
 			break;
 		case S_IFLNK:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %s\n", name, perm, uid, gid, flags, 'l', "unknown");
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %s\n",
+			       name, perm, uid, gid, flags, 'l', "unknown");
 			break;
 		case S_IFREG:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'f');
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name,
+			       perm, uid, gid, flags, 'f');
 			break;
 		}
 	}
 	spin_unlock(&lock);
+	/***** CRITICAL SECTION END *****/
 	return error;
 }
 
 /* Check whether the given dentry is allowed to mknod. */
-static int MayCreateNode(struct dentry *dentry, int mode, int dev)
+static int syaoran_may_create_node(struct dentry *dentry, int mode, int dev)
 {
-	struct syaoran_sb_info *info = (struct syaoran_sb_info *) dentry->d_sb->s_fs_info;
+	struct syaoran_sb_info *info
+		= (struct syaoran_sb_info *) dentry->d_sb->s_fs_info;
 	if (!info) {
-		printk("%s: dentry->d_sb->s_fs_info == NULL\n", __FUNCTION__);
+		printk(KERN_WARNING "%s: dentry->d_sb->s_fs_info == NULL\n",
+		       __func__);
 		return -EPERM;
 	}
-	if (!info->initialize_done) return 0;
-	return CheckFlags(info, dentry, mode, dev, MAY_CREATE);
+	if (!info->initialize_done)
+		return 0;
+	return syaoran_check_flags(info, dentry, mode, dev, MAY_CREATE);
 }
 
 /* Check whether the given dentry is allowed to chmod/chown/unlink. */
-static int MayModifyNode(struct dentry *dentry, unsigned int flags)
+static int syaoran_may_modify_node(struct dentry *dentry, unsigned int flags)
 {
-	struct syaoran_sb_info *info = (struct syaoran_sb_info *) dentry->d_sb->s_fs_info;
+	struct syaoran_sb_info *info
+		= (struct syaoran_sb_info *) dentry->d_sb->s_fs_info;
 	if (!info) {
-		printk("%s: dentry->d_sb->s_fs_info == NULL\n", __FUNCTION__);
+		printk(KERN_WARNING "%s: dentry->d_sb->s_fs_info == NULL\n",
+		       __func__);
 		return -EPERM;
 	}
-	if (flags == DEVICE_USED && !info->is_permissive_mode) return 0;
-	if (!dentry->d_inode) return -ENOENT;
-	return CheckFlags(info, dentry, dentry->d_inode->i_mode, dentry->d_inode->i_rdev, flags);
+	if (flags == DEVICE_USED && !info->is_permissive_mode)
+		return 0;
+	if (!dentry->d_inode)
+		return -ENOENT;
+	return syaoran_check_flags(info, dentry, dentry->d_inode->i_mode,
+				   dentry->d_inode->i_rdev, flags);
 }
 
 /*
- * The following structure and codes are used for transferring data to interfaces files.
+ * The following structure and codes are used for transferring data
+ * to interfaces files.
  */
 
 struct syaoran_read_struct {
@@ -746,17 +915,22 @@
 	struct list_head *pos;   /* Current position.                  */
 };
 
-static void ReadTable(struct syaoran_read_struct *head, char *buf, int count)
+static void syaoran_read_table(struct syaoran_read_struct *head, char *buf,
+			       int count)
 {
 	struct super_block *sb = head->sb;
 	struct syaoran_sb_info *info = (struct syaoran_sb_info *) sb->s_fs_info;
 	struct list_head *pos;
 	const bool read_all = head->read_all;
-	if (!info) return;
-	if (!head->pos) return;
+	if (!info)
+		return;
+	if (!head->pos)
+		return;
 	list_for_each_cookie(pos, head->pos, &info->list) {
-		struct dev_entry *entry = list_entry(pos, struct dev_entry, list);
-		const unsigned int flags = read_all ? entry->flags : entry->flags & ~DEVICE_USED;
+		struct dev_entry *entry
+			= list_entry(pos, struct dev_entry, list);
+		const unsigned int flags
+			= read_all ? entry->flags : entry->flags & ~DEVICE_USED;
 		const char *name = entry->printable_name;
 		const uid_t uid = entry->uid;
 		const gid_t gid = entry->gid;
@@ -764,30 +938,46 @@
 		int len = 0;
 		switch (entry->mode & S_IFMT) {
 		case S_IFCHR:
-			if (!head->read_all && !(entry->flags & DEVICE_USED)) break;
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c %3u %3u\n", name, perm, uid, gid, flags, 'c', MAJOR(entry->kdev), MINOR(entry->kdev));
+			if (!head->read_all && !(entry->flags & DEVICE_USED))
+				break;
+			len = snprintf(buf, count,
+				       "%-20s %3o %3u %3u %2u %c %3u %3u\n",
+				       name, perm, uid, gid, flags, 'c',
+				       MAJOR(entry->kdev), MINOR(entry->kdev));
 			break;
 		case S_IFBLK:
-			if (!head->read_all && !(entry->flags & DEVICE_USED)) break;
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c %3u %3u\n", name, perm, uid, gid, flags, 'b', MAJOR(entry->kdev), MINOR(entry->kdev));
+			if (!head->read_all && !(entry->flags & DEVICE_USED))
+				break;
+			len = snprintf(buf, count,
+				       "%-20s %3o %3u %3u %2u %c %3u %3u\n",
+				       name, perm, uid, gid, flags, 'b',
+				       MAJOR(entry->kdev), MINOR(entry->kdev));
 			break;
 		case S_IFIFO:
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'p');
+			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n",
+				       name, perm, uid, gid, flags, 'p');
 			break;
 		case S_IFSOCK:
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 's');
+			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n",
+				       name, perm, uid, gid, flags, 's');
 			break;
 		case S_IFDIR:
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'd');
+			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n",
+				       name, perm, uid, gid, flags, 'd');
 			break;
 		case S_IFLNK:
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c %s\n", name, perm, uid, gid, flags, 'l', entry->printable_symlink_data);
+			len = snprintf(buf, count,
+				       "%-20s %3o %3u %3u %2u %c %s\n", name,
+				       perm, uid, gid, flags, 'l',
+				       entry->printable_symlink_data);
 			break;
 		case S_IFREG:
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'f');
+			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n",
+				       name, perm, uid, gid, flags, 'f');
 			break;
 		}
-		if (len < 0 || count <= len) break;
+		if (len < 0 || count <= len)
+			break;
 		count -= len;
 		buf += len;
 		head->avail += len;
@@ -796,12 +986,17 @@
 
 static int syaoran_trace_open(struct inode *inode, struct file *file)
 {
-	struct syaoran_read_struct *head;
-	if ((head = kzalloc(sizeof(*head), GFP_KERNEL)) == NULL) return -ENOMEM;
+	struct syaoran_read_struct *head = kzalloc(sizeof(*head), GFP_KERNEL);
+	if (!head)
+		return -ENOMEM;
 	head->sb = inode->i_sb;
-	head->read_all = (strcmp(file->f_dentry->d_name.name, ".syaoran_all") == 0);
+	head->read_all
+		= (strcmp(file->f_dentry->d_name.name, ".syaoran_all") == 0);
 	head->pos = &((struct syaoran_sb_info *) head->sb->s_fs_info)->list;
-	if ((head->buf = kzalloc(PAGE_SIZE * 2, GFP_KERNEL)) == NULL) {
+	/* Don't allow open() after unmount() */
+	if (head->sb->s_fs_info)
+		head->buf = kzalloc(PAGE_SIZE * 2, GFP_KERNEL);
+	if (!head->buf) {
 		kfree(head);
 		return -ENOMEM;
 	}
@@ -818,17 +1013,22 @@
 	return 0;
 }
 
-static ssize_t syaoran_trace_read(struct file *file, char __user *buf, size_t count, loff_t * ppos)
+static ssize_t syaoran_trace_read(struct file *file, char __user *buf,
+				  size_t count, loff_t *ppos)
 {
-	struct syaoran_read_struct *head = (struct syaoran_read_struct *) file->private_data;
+	struct syaoran_read_struct *head
+		= (struct syaoran_read_struct *) file->private_data;
 	int len = head->avail;
 	char *cp = head->buf;
-	if (!access_ok(VERIFY_WRITE, buf, count)) return -EFAULT;
-	ReadTable(head, cp + len, PAGE_SIZE * 2 - len);
+	if (!access_ok(VERIFY_WRITE, buf, count))
+		return -EFAULT;
+	syaoran_read_table(head, cp + len, PAGE_SIZE * 2 - len);
 	len = head->avail;
-	if (len > count) len = count;
+	if (len > count)
+		len = count;
 	if (len > 0) {
-		if (copy_to_user(buf, cp, len)) return -EFAULT;
+		if (copy_to_user(buf, cp, len))
+			return -EFAULT;
 		head->avail -= len;
 		memmove(cp, cp + len, head->avail);
 	}
@@ -836,9 +1036,9 @@
 }
 
 static struct file_operations syaoran_trace_operations = {
-	open:    syaoran_trace_open,
-	release: syaoran_trace_release,
-	read:    syaoran_trace_read,
+	.open    = syaoran_trace_open,
+	.release = syaoran_trace_release,
+	.read    = syaoran_trace_read,
 };
 
 /* Create interface files for reading status. */
@@ -853,18 +1053,21 @@
 			inode->i_mode = S_IFREG | 0400;
 			inode->i_uid = 0;
 			inode->i_gid = 0;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 			inode->i_blksize = PAGE_CACHE_SIZE;
 #endif
 			inode->i_blocks = 0;
 			inode->i_mapping->a_ops = &syaoran_aops;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-			inode->i_mapping->backing_dev_info = &syaoran_backing_dev_info;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+			inode->i_mapping->backing_dev_info
+				= &syaoran_backing_dev_info;
 			inode->i_op = &syaoran_file_inode_operations;
 #else
 			inode->i_rdev = NODEV;
 #endif
-			inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+			inode->i_ctime = CURRENT_TIME;
+			inode->i_mtime = inode->i_ctime;
+			inode->i_atime = inode->i_mtime;
 			inode->i_fop = &syaoran_trace_operations;
 			d_instantiate(dentry, inode);
 			dget(dentry); /* Extra count - pin the dentry in core */
@@ -872,7 +1075,7 @@
 		}
 		dput(dentry);
 	}
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 	mutex_unlock(&base->d_inode->i_mutex);
 #else
 	up(&base->d_inode->i_sem);
@@ -881,5 +1084,4 @@
 	return error;
 }
 
-/***** SYAORAN end. *****/
 #endif
Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo_socket.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo_socket.h	(revision 1045)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo_socket.h	(working copy)
@@ -15,195 +15,292 @@
 #ifndef _LINUX_TOMOYO_SOCKET_H
 #define _LINUX_TOMOYO_SOCKET_H
 
-/***** TOMOYO Linux start. *****/
-
-#if defined(CONFIG_TOMOYO)
-
 #include <net/ip.h>
 #include <net/ipv6.h>
 #include <net/udp.h>
 #include <asm/uaccess.h>
+#include <linux/version.h>
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if defined(CONFIG_TOMOYO)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #define sk_family family
 #define sk_protocol protocol
 #define sk_type type
 #define sk_receive_queue receive_queue
 #endif
 
+#define false 0
+#define true 1
+
 #define MAX_SOCK_ADDR 128 /* net/socket.c */
 
-static inline int CheckSocketCreatePermission(int family, int type, int protocol)
+/* Check permission for creating a socket. */
+static inline int ccs_socket_create_permission(int family, int type,
+					       int protocol)
 {
 	int error = 0;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-	if (family == PF_INET || family == PF_INET6) {
-		switch (type) {
-		case SOCK_STREAM:
-			error = CheckCapabilityACL(TOMOYO_INET_STREAM_SOCKET_CREATE);
-			break;
-		case SOCK_DGRAM:
-			error = CheckCapabilityACL(TOMOYO_USE_INET_DGRAM_SOCKET);
-			break;
-		case SOCK_RAW:
-			error = CheckCapabilityACL(TOMOYO_USE_INET_RAW_SOCKET);
-			break;
-		}
-	} else if (family == PF_PACKET) {
-		error = CheckCapabilityACL(TOMOYO_USE_PACKET_SOCKET);
-	} else if (family == PF_ROUTE) {
-		error = CheckCapabilityACL(TOMOYO_USE_ROUTE_SOCKET);
+	/* Nothing to do if I am a kernel service. */
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	if (family == PF_PACKET)
+		return ccs_capable(TOMOYO_USE_PACKET_SOCKET);
+	if (family == PF_ROUTE)
+		return ccs_capable(TOMOYO_USE_ROUTE_SOCKET);
+	if (family != PF_INET && family != PF_INET6)
+		return 0;
+	switch (type) {
+	case SOCK_STREAM:
+		error = ccs_capable(TOMOYO_INET_STREAM_SOCKET_CREATE);
+		break;
+	case SOCK_DGRAM:
+		error = ccs_capable(TOMOYO_USE_INET_DGRAM_SOCKET);
+		break;
+	case SOCK_RAW:
+		error = ccs_capable(TOMOYO_USE_INET_RAW_SOCKET);
+		break;
 	}
 	return error;
 }
 
-static inline int CheckSocketListenPermission(struct socket *sock)
+/* Check permission for listening a TCP socket. */
+static inline int ccs_socket_listen_permission(struct socket *sock)
 {
 	int error = 0;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-	if (sock->type == SOCK_STREAM) {
-		switch (sock->sk->sk_family) {
-		case PF_INET:
-		case PF_INET6:
-			error = CheckCapabilityACL(TOMOYO_INET_STREAM_SOCKET_LISTEN);
-			if (!error) {
-				char addr[MAX_SOCK_ADDR];
-				int addr_len;
-				if (sock->ops->getname(sock, (struct sockaddr *) addr, &addr_len, 0) == 0) {
-					switch (((struct sockaddr *) addr)->sa_family) {
-					case AF_INET6:
-						error = CheckNetworkListenACL(1, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, ((struct sockaddr_in6 *) addr)->sin6_port);
-						break;
-					case AF_INET:
-						error = CheckNetworkListenACL(0, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, ((struct sockaddr_in *) addr)->sin_port);
-						break;
-					}
-				} else {
-					error = -EPERM;
-				}
-			}
-			break;
-		}
+	char addr[MAX_SOCK_ADDR];
+	int addr_len;
+	/* Nothing to do if I am a kernel service. */
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	if (sock->type != SOCK_STREAM)
+		return 0;
+	switch (sock->sk->sk_family) {
+	case PF_INET:
+	case PF_INET6:
+		break;
+	default:
+		return 0;
 	}
+	error = ccs_capable(TOMOYO_INET_STREAM_SOCKET_LISTEN);
+	if (error)
+		return error;
+	if (sock->ops->getname(sock, (struct sockaddr *) addr, &addr_len, 0))
+		return -EPERM;
+	switch (((struct sockaddr *) addr)->sa_family) {
+		struct sockaddr_in6 *addr6;
+		struct sockaddr_in *addr4;
+	case AF_INET6:
+		addr6 = (struct sockaddr_in6 *) addr;
+		error = ccs_check_network_listen_acl(true,
+						     addr6->sin6_addr.s6_addr,
+						     addr6->sin6_port);
+		break;
+	case AF_INET:
+		addr4 = (struct sockaddr_in *) addr;
+		error = ccs_check_network_listen_acl(false,
+						     (u8 *) &addr4->sin_addr,
+						     addr4->sin_port);
+		break;
+	}
 	return error;
 }
 
-static inline int CheckSocketConnectPermission(struct socket *sock, struct sockaddr *addr, int addr_len)
+/* Check permission for setting the remote IP address/port pair of a socket. */
+static inline int ccs_socket_connect_permission(struct socket *sock,
+						struct sockaddr *addr,
+						int addr_len)
 {
 	int error = 0;
 	const unsigned int type = sock->type;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-	if (type == SOCK_STREAM || type == SOCK_DGRAM || type == SOCK_RAW) {
-		switch (addr->sa_family) {
-		case AF_INET6:
-			if (addr_len >= SIN6_LEN_RFC2133) {
-				if (type != SOCK_RAW) {
-					error = CheckNetworkConnectACL(1, type, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, ((struct sockaddr_in6 *) addr)->sin6_port);
-				} else {
-					error = CheckNetworkConnectACL(1, SOCK_RAW, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, htons(sock->sk->sk_protocol));
-				}
-			}
+	/* Nothing to do if I am a kernel service. */
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	switch (type) {
+	case SOCK_STREAM:
+	case SOCK_DGRAM:
+	case SOCK_RAW:
+		break;
+	default:
+		return 0;
+	}
+	switch (addr->sa_family) {
+		struct sockaddr_in6 *addr6;
+		struct sockaddr_in *addr4;
+		u16 port;
+	case AF_INET6:
+		if (addr_len < SIN6_LEN_RFC2133)
 			break;
-		case AF_INET:
-			if (addr_len >= sizeof(struct sockaddr_in)) {
-				if (type != SOCK_RAW) {
-					error = CheckNetworkConnectACL(0, type, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, ((struct sockaddr_in *) addr)->sin_port);
-				} else {
-					error = CheckNetworkConnectACL(0, SOCK_RAW, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, htons(sock->sk->sk_protocol));
-				}
-			}
+		addr6 = (struct sockaddr_in6 *) addr;
+		if (type != SOCK_RAW)
+			port = addr6->sin6_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = ccs_check_network_connect_acl(true, type,
+						      addr6->sin6_addr.s6_addr,
+						      port);
+		break;
+	case AF_INET:
+		if (addr_len < sizeof(struct sockaddr_in))
 			break;
-		}
+		addr4 = (struct sockaddr_in *) addr;
+		if (type != SOCK_RAW)
+			port = addr4->sin_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = ccs_check_network_connect_acl(false, type,
+						      (u8 *) &addr4->sin_addr,
+						      port);
+		break;
 	}
-	if (type == SOCK_STREAM) {
-		switch (sock->sk->sk_family) {
-		case PF_INET:
-		case PF_INET6:
-			error = CheckCapabilityACL(TOMOYO_INET_STREAM_SOCKET_CONNECT) ? -EPERM : error;
-			break;
-		}
+	if (type != SOCK_STREAM)
+		return error;
+	switch (sock->sk->sk_family) {
+	case PF_INET:
+	case PF_INET6:
+		if (ccs_capable(TOMOYO_INET_STREAM_SOCKET_CONNECT))
+			error = -EPERM;
+		break;
 	}
 	return error;
 }
 
-static inline int CheckSocketBindPermission(struct socket *sock, struct sockaddr *addr, int addr_len)
+/* Check permission for setting the local IP address/port pair of a socket. */
+static inline int ccs_socket_bind_permission(struct socket *sock,
+					     struct sockaddr *addr,
+					     int addr_len)
 {
 	int error = 0;
 	const unsigned int type = sock->type;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-	if (type == SOCK_STREAM || type == SOCK_DGRAM || type == SOCK_RAW) {
-		switch (addr->sa_family) {
-		case AF_INET6:
-			if (addr_len >= SIN6_LEN_RFC2133) {
-				if (type != SOCK_RAW) {
-					error = CheckNetworkBindACL(1, type, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, ((struct sockaddr_in6 *) addr)->sin6_port);
-				} else {
-					error = CheckNetworkBindACL(1, SOCK_RAW, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, htons(sock->sk->sk_protocol));
-				}
-			}
+	/* Nothing to do if I am a kernel service. */
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	switch (type) {
+	case SOCK_STREAM:
+	case SOCK_DGRAM:
+	case SOCK_RAW:
+		break;
+	default:
+		return 0;
+	}
+	switch (addr->sa_family) {
+		struct sockaddr_in6 *addr6;
+		struct sockaddr_in *addr4;
+		u16 port;
+	case AF_INET6:
+		if (addr_len < SIN6_LEN_RFC2133)
 			break;
-		case AF_INET:
-			if (addr_len >= sizeof(struct sockaddr_in)) {
-				if (type != SOCK_RAW) {
-					error = CheckNetworkBindACL(0, type, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, ((struct sockaddr_in *) addr)->sin_port);
-				} else {
-					error = CheckNetworkBindACL(0, SOCK_RAW, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, htons(sock->sk->sk_protocol));
-				}
-			}
+		addr6 = (struct sockaddr_in6 *) addr;
+		if (type != SOCK_RAW)
+			port = addr6->sin6_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = ccs_check_network_bind_acl(true, type,
+						   addr6->sin6_addr.s6_addr,
+						   port);
+		break;
+	case AF_INET:
+		if (addr_len < sizeof(struct sockaddr_in))
 			break;
-		}
+		addr4 = (struct sockaddr_in *) addr;
+		if (type != SOCK_RAW)
+			port = addr4->sin_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = ccs_check_network_bind_acl(false, type,
+						   (u8 *) &addr4->sin_addr,
+						   port);
+		break;
 	}
 	return error;
 }
 
-static inline int CheckSocketAcceptPermission(struct socket *sock, struct sockaddr *addr)
+/*
+ * Check permission for accepting a TCP socket.
+ *
+ * Currently, the LSM hook for this purpose is not provided.
+ */
+static inline int ccs_socket_accept_permission(struct socket *sock,
+					       struct sockaddr *addr)
 {
 	int error = 0;
 	int addr_len;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
+	/* Nothing to do if I am a kernel service. */
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
 	switch (sock->sk->sk_family) {
 	case PF_INET:
 	case PF_INET6:
-		if (sock->ops->getname(sock, addr, &addr_len, 2) == 0) {
-			switch (addr->sa_family) {
-			case AF_INET6:
-				error = CheckNetworkAcceptACL(1, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, ((struct sockaddr_in6 *) addr)->sin6_port);
-				break;
-			case AF_INET:
-				error = CheckNetworkAcceptACL(0, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, ((struct sockaddr_in *) addr)->sin_port);
-				break;
-			}
-		} else {
-			error = -EPERM;
-		}
+		break;
+	default:
+		return 0;
 	}
+	error = sock->ops->getname(sock, addr, &addr_len, 2);
+	if (error)
+		return error;
+	switch (addr->sa_family) {
+		struct sockaddr_in6 *addr6;
+		struct sockaddr_in *addr4;
+	case AF_INET6:
+		addr6 = (struct sockaddr_in6 *) addr;
+		error = ccs_check_network_accept_acl(true,
+						     addr6->sin6_addr.s6_addr,
+						     addr6->sin6_port);
+		break;
+	case AF_INET:
+		addr4 = (struct sockaddr_in *) addr;
+		error = ccs_check_network_accept_acl(false,
+						     (u8 *) &addr4->sin_addr,
+						     addr4->sin_port);
+		break;
+	}
 	return error;
 }
 
-static inline int CheckSocketSendMsgPermission(struct socket *sock, struct sockaddr *addr, int addr_len)
+/* Check permission for sending a datagram via a UDP or RAW socket. */
+static inline int ccs_socket_sendmsg_permission(struct socket *sock,
+						struct sockaddr *addr,
+						int addr_len)
 {
 	int error = 0;
 	const int type = sock->type;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-	if (addr && (type == SOCK_DGRAM || type == SOCK_RAW)) {
-		switch (addr->sa_family) {
-		case AF_INET6:
-			if (addr_len >= SIN6_LEN_RFC2133) {
-				error = CheckNetworkSendMsgACL(1, type, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, type == SOCK_DGRAM ? ((struct sockaddr_in6 *) addr)->sin6_port : htons(sock->sk->sk_protocol));
-			}
+	/* Nothing to do if I am a kernel service. */
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	if (!addr || (type != SOCK_DGRAM && type != SOCK_RAW))
+		return 0;
+	switch (addr->sa_family) {
+		struct sockaddr_in6 *addr6;
+		struct sockaddr_in *addr4;
+		u16 port;
+	case AF_INET6:
+		if (addr_len < SIN6_LEN_RFC2133)
 			break;
-		case AF_INET:
-			if (addr_len >= sizeof(struct sockaddr_in)) {
-				error = CheckNetworkSendMsgACL(0, type, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, type == SOCK_DGRAM ? ((struct sockaddr_in *) addr)->sin_port : htons(sock->sk->sk_protocol));
-			}
+		addr6 = (struct sockaddr_in6 *) addr;
+		if (type == SOCK_DGRAM)
+			port = addr6->sin6_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = ccs_check_network_sendmsg_acl(true, type,
+						      addr6->sin6_addr.s6_addr,
+						      port);
+		break;
+	case AF_INET:
+		if (addr_len < sizeof(struct sockaddr_in))
 			break;
-		}
+		addr4 = (struct sockaddr_in *) addr;
+		if (type == SOCK_DGRAM)
+			port = addr4->sin_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = ccs_check_network_sendmsg_acl(false, type,
+						      (u8 *) &addr4->sin_addr,
+						      port);
+		break;
 	}
 	return error;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
 
 static inline struct iphdr *ip_hdr(const struct sk_buff *skb)
 {
@@ -222,31 +319,43 @@
 
 #endif
 
-static inline int CheckSocketRecvDatagramPermission(struct sock *sk, struct sk_buff *skb, const unsigned int flags)
+/*
+ * Check permission for receiving a datagram via a UDP or RAW socket.
+ *
+ * Currently, the LSM hook for this purpose is not provided.
+ */
+static inline int ccs_socket_recv_datagram_permission(struct sock *sk,
+						      struct sk_buff *skb,
+						      const unsigned int flags)
 {
 	int error = 0;
 	const unsigned int type = sk->sk_type;
-	struct in6_addr sin6;
-	struct in_addr sin;
-	u16 port;
-
-	if (!skb) return 0;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if (in_interrupt()) return 0;
+	/* Nothing to do if I didn't receive a datagram. */
+	if (!skb)
+		return 0;
+	/* Nothing to do if I can't sleep. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (in_interrupt())
+		return 0;
 #else
-	if (in_atomic()) return 0;
+	if (in_atomic())
+		return 0;
 #endif
+	/* Nothing to do if I am a kernel service. */
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	if (type != SOCK_DGRAM && type != SOCK_RAW)
+		return 0;
 
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-
-	if (type != SOCK_DGRAM && type != SOCK_RAW) return 0;
-
 	switch (sk->sk_family) {
+		struct in6_addr sin6;
+		struct in_addr sin4;
+		u16 port;
 	case PF_INET6:
 		if (type == SOCK_DGRAM) { /* UDP IPv6 */
 			if (skb->protocol == htons(ETH_P_IP)) {
-				ipv6_addr_set(&sin6, 0, 0, htonl(0xffff), ip_hdr(skb)->saddr);
+				ipv6_addr_set(&sin6, 0, 0, htonl(0xffff),
+					      ip_hdr(skb)->saddr);
 			} else {
 				ipv6_addr_copy(&sin6, &ipv6_hdr(skb)->saddr);
 			}
@@ -255,60 +364,102 @@
 			ipv6_addr_copy(&sin6, &ipv6_hdr(skb)->saddr);
 			port = htons(sk->sk_protocol);
 		}
-		error = CheckNetworkRecvMsgACL(1, type, (u8 *) &sin6, port);
+		error = ccs_check_network_recvmsg_acl(true, type,
+						      (u8 *) &sin6, port);
 		break;
 	case PF_INET:
 		if (type == SOCK_DGRAM) { /* UDP IPv4 */
-			sin.s_addr = ip_hdr(skb)->saddr;
+			sin4.s_addr = ip_hdr(skb)->saddr;
 			port = udp_hdr(skb)->source;
 		} else { /* RAW IPv4 */
-			sin.s_addr = ip_hdr(skb)->saddr;
+			sin4.s_addr = ip_hdr(skb)->saddr;
 			port = htons(sk->sk_protocol);
 		}
-		error = CheckNetworkRecvMsgACL(0, type, (u8 *) &sin, port);
+		error = ccs_check_network_recvmsg_acl(false, type,
+						      (u8 *) &sin4, port);
 		break;
 	}
-	if (error) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-		lock_sock(sk);
+	if (!error)
+		return 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	lock_sock(sk);
 #endif
-		/*
-		 * Remove from queue if MSG_PEEK is used so that
-		 * the head message from unwanted source in receive queue will not
-		 * prevent the caller from picking up next message from wanted source
-		 * when the caller is using MSG_PEEK flag for picking up.
-		 */
-		if (flags & MSG_PEEK) {
-			unsigned long cpu_flags;
-			spin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);
-			if (skb == skb_peek(&sk->sk_receive_queue)) {
-				__skb_unlink(skb, &sk->sk_receive_queue);
-				atomic_dec(&skb->users);
-			}
-			spin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);
+	/*
+	 * Remove from queue if MSG_PEEK is used so that
+	 * the head message from unwanted source in receive queue will not
+	 * prevent the caller from picking up next message from wanted source
+	 * when the caller is using MSG_PEEK flag for picking up.
+	 */
+	if (flags & MSG_PEEK) {
+		unsigned long cpu_flags;
+		/***** CRITICAL SECTION START *****/
+		spin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);
+		if (skb == skb_peek(&sk->sk_receive_queue)) {
+			__skb_unlink(skb, &sk->sk_receive_queue);
+			atomic_dec(&skb->users);
 		}
-		/* Drop reference count. */
-		skb_free_datagram(sk, skb);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-		release_sock(sk);
+		spin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);
+		/***** CRITICAL SECTION END *****/
+	}
+	/* Drop reference count. */
+	skb_free_datagram(sk, skb);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	release_sock(sk);
 #endif
-		/* Hope less harmful than -EPERM. */
-		error = -EAGAIN;
-	}
-	return error;
+	/* Hope less harmful than -EPERM. */
+	return -EAGAIN;
 }
 
 #else
 
-static inline int CheckSocketCreatePermission(int family, int type, int protocol) { return 0; }
-static inline int CheckSocketListenPermission(struct socket *sock) { return 0; }
-static inline int CheckSocketConnectPermission(struct socket *sock, struct sockaddr *addr, int addr_len) { return 0; }
-static inline int CheckSocketBindPermission(struct socket *sock, struct sockaddr *addr, int addr_len) { return 0; }
-static inline int CheckSocketAcceptPermission(struct socket *sock, struct sockaddr *addr) { return 0; }
-static inline int CheckSocketSendMsgPermission(struct socket *sock, struct sockaddr *addr, int addr_len) { return 0; }
-static inline int CheckSocketRecvDatagramPermission(struct sock *sk, struct sk_buff *skb, const unsigned int flags) { return 0; }
+static inline int ccs_socket_create_permission(int family, int type,
+					       int protocol)
+{
+	return 0;
+}
+static inline int ccs_socket_listen_permission(struct socket *sock)
+{
+	return 0;
+}
+static inline int ccs_socket_connect_permission(struct socket *sock,
+						struct sockaddr *addr,
+						int addr_len)
+{
+	return 0;
+}
+static inline int ccs_socket_bind_permission(struct socket *sock,
+					     struct sockaddr *addr,
+					     int addr_len)
+{
+	return 0;
+}
+static inline int ccs_socket_accept_permission(struct socket *sock,
+					       struct sockaddr *addr)
+{
+	return 0;
+}
+static inline int ccs_socket_sendmsg_permission(struct socket *sock,
+						struct sockaddr *addr,
+						int addr_len)
+{
+	return 0;
+}
+static inline int ccs_socket_recv_datagram_permission(struct sock *sk,
+						      struct sk_buff *skb,
+						      const unsigned int flags)
+{
+	return 0;
+}
 
 #endif
 
-/***** TOMOYO Linux end. *****/
+/* For compatibility with 1.4.x/1.5.x patches */
+#define CheckSocketSendMsgPermission      ccs_socket_sendmsg_permission
+#define CheckSocketCreatePermission       ccs_socket_create_permission
+#define CheckSocketBindPermission         ccs_socket_bind_permission
+#define CheckSocketListenPermission       ccs_socket_listen_permission
+#define CheckSocketAcceptPermission       ccs_socket_accept_permission
+#define CheckSocketConnectPermission      ccs_socket_connect_permission
+#define CheckSocketRecvDatagramPermission ccs_socket_recv_datagram_permission
+
 #endif
Index: trunk/1.6.x/ccs-patch/include/linux/ccs_common.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(revision 1045)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(working copy)
@@ -28,13 +28,21 @@
 #include <stdarg.h>
 #include <linux/delay.h>
 #include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #include <linux/kmod.h>
 #include <asm/hardirq.h>
 #else
 #include <linux/hardirq.h>
 #endif
 
+struct dentry;
+struct vfsmount;
+struct in6_addr;
+extern asmlinkage long sys_getppid(void);
+
+#define false 0
+#define true 1
+
 #ifndef __user
 #define __user
 #endif
@@ -43,13 +51,19 @@
 #define WARN_ON(x) do { } while (0)
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#ifndef DEFINE_SPINLOCK
+#define DEFINE_SPINLOCK(x) spinlock_t x = SPIN_LOCK_UNLOCKED
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 typedef _Bool bool;
 #endif
 
-#define false 0
-#define true 1
 
+#ifndef KERN_CONT
+#define KERN_CONT ""
+#endif
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
 #define mutex semaphore
 #define mutex_init(mutex) init_MUTEX(mutex)
@@ -59,39 +73,33 @@
 #define DEFINE_MUTEX(mutexname) DECLARE_MUTEX(mutexname)
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#define container_of(ptr, type, member) ({                      \
-	const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
-		(type *)( (char *)__mptr - offsetof(type,member) );})
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+#define container_of(ptr, type, member) ({				\
+			const typeof(((type *)0)->member) *__mptr = (ptr); \
+			(type *)((char *)__mptr - offsetof(type, member)); })
 #endif
 
-#if 0
-
-#define list1_head list_head
-#define LIST1_HEAD_INIT LIST_HEAD_INIT
-#define LIST1_HEAD LIST_HEAD
-#define INIT_LIST1_HEAD INIT_LIST_HEAD
-#define list1_entry list_entry
-#define list1_for_each list_for_each
-#define list1_for_each_entry list_for_each_entry
-#define list1_for_each_cookie(pos, cookie, head) \
-	for (({if (!cookie) cookie = head;}), pos = (cookie)->next; \
-		prefetch(pos->next), pos != (head) || ((cookie) = NULL); \
-		(cookie) = pos, pos = pos->next)
-static inline void list1_add_tail_mb(struct list1_head *new,
-				     struct list1_head *head)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+static inline void *kzalloc(int size, int flags)
 {
-	struct list_head *prev = head->prev;
-	struct list_head *next = head;
-	new->next = next;
-	new->prev = prev;
-	mb(); /* Avoid out-of-order execution. */
-	next->prev = new;
-	prev->next = new;
+	void *p = kmalloc(size, flags);
+	if (p)
+		memset(p, 0, size);
+	return p;
 }
+#endif
 
-#else /////////////////////////////////////////////////////////////////////////
-
+/*
+ * Singly linked list.
+ *
+ * This list holds ACL entries used for access control.
+ * Since TOMOYO Linux performs string pattern matching which takes long time,
+ * I don't want to take any locks which disable preemption.
+ * Threfore, I use singly linked list that cannot delete an element
+ * but can make the code read-lock free.
+ * This is OK because ACL entries in this list are seldom deleted.
+ * You don't append garbage ACL entries without reasons, do you?
+ */
 struct list1_head {
 	struct list1_head *next;
 };
@@ -117,9 +125,9 @@
  * @pos:        the &struct list1_head to use as a loop cursor.
  * @head:       the head for your list.
  */
-#define list1_for_each(pos, head) \
-	for (pos = (head)->next; prefetch(pos->next), pos != (head); \
-		pos = pos->next)
+#define list1_for_each(pos, head)					\
+	for (pos = (head)->next; prefetch(pos->next), pos != (head);	\
+	     pos = pos->next)
 
 /**
  * list1_for_each_entry  -       iterate over list of given type
@@ -127,10 +135,10 @@
  * @head:       the head for your list.
  * @member:     the name of the list1_struct within the struct.
  */
-#define list1_for_each_entry(pos, head, member)                          \
-	for (pos = list1_entry((head)->next, typeof(*pos), member);      \
-		prefetch(pos->member.next), &pos->member != (head);        \
-		pos = list1_entry(pos->member.next, typeof(*pos), member))
+#define list1_for_each_entry(pos, head, member)				\
+	for (pos = list1_entry((head)->next, typeof(*pos), member);	\
+	     prefetch(pos->member.next), &pos->member != (head);        \
+	     pos = list1_entry(pos->member.next, typeof(*pos), member))
 
 /**
  * list1_for_each_cookie - iterate over a list with cookie.
@@ -141,10 +149,11 @@
  * Same with list_for_each except that this primitive uses cookie
  * so that we can continue iteration.
  */
-#define list1_for_each_cookie(pos, cookie, head) \
-	for (({if (!cookie) cookie = head;}), pos = (cookie)->next; \
-		prefetch(pos->next), pos != (head) || ((cookie) = NULL); \
-		(cookie) = pos, pos = pos->next)
+#define list1_for_each_cookie(pos, cookie, head)			\
+	for (({ if (!cookie)						\
+				     cookie = head; }), pos = (cookie)->next; \
+	     prefetch(pos->next), pos != (head) || ((cookie) = NULL);	\
+	     (cookie) = pos, pos = pos->next)
 
 /**
  * list_add_tail_mb - add a new entry with memory barrier.
@@ -166,19 +175,19 @@
 	pos->next = new;
 }
 
-#endif
-
+/* Temporary buffer for holding pathnames. */
 struct ccs_page_buffer {
 	char buffer[4096];
 };
 
+/* Subset of "struct stat". */
 struct mini_stat {
 	uid_t uid;
 	gid_t gid;
 	ino_t ino;
 };
-struct dentry;
-struct vfsmount;
+
+/* Structure for attribute checks in addition to pathname checks. */
 struct obj_info {
 	bool validate_done;
 	bool path1_valid;
@@ -196,31 +205,41 @@
 	struct ccs_page_buffer *tmp;
 };
 
+/* Structure for holding a token. */
 struct path_info {
 	const char *name;
-	u32 hash;        /* = full_name_hash(name, strlen(name)) */
-	u16 total_len;   /* = strlen(name)                       */
-	u16 const_len;   /* = const_part_length(name)            */
+	u32 hash;          /* = full_name_hash(name, strlen(name)) */
+	u16 total_len;     /* = strlen(name)                       */
+	u16 const_len;     /* = const_part_length(name)            */
 	bool is_dir;       /* = strendswith(name, "/")             */
-	bool is_patterned; /* = PathContainsPattern(name)          */
-	u16 depth;       /* = PathDepth(name)                    */
+	bool is_patterned; /* = path_contains_pattern(name)        */
+	u16 depth;         /* = path_depth(name)                   */
 };
 
+/*
+ * This is the max length of a token.
+ *
+ * A token consists of only ASCII printable characters.
+ * Non printable characters in a token is represented in \ooo style
+ * octal string. Thus, \ itself is represented as \\ .
+ */
 #define CCS_MAX_PATHNAME_LEN 4000
 
+/* Structure for "path_group" directive. */
 struct path_group_member {
 	struct list1_head list;
 	const struct path_info *member_name;
 	bool is_deleted;
 };
 
+/* Structure for "path_group" directive. */
 struct path_group_entry {
 	struct list1_head list;
 	const struct path_info *group_name;
 	struct list1_head path_group_member_list;
 };
 
-struct in6_addr;
+/* Structure for "address_group" directive. */
 struct address_group_member {
 	struct list1_head list;
 	union {
@@ -231,213 +250,251 @@
 	bool is_ipv6;
 };
 
+/* Structure for "address_group" directive. */
 struct address_group_entry {
 	struct list1_head list;
 	const struct path_info *group_name;
 	struct list1_head address_group_member_list;
 };
 
+/* Structure for holding requested pathname. */
 struct path_info_with_data {
-	struct path_info head; /* Keep this first, for this pointer is passed to ccs_free(). */
-	char bariier1[16];
+	/* Keep "head" first, for this pointer is passed to ccs_free(). */
+	struct path_info head;
+	char bariier1[16]; /* Safeguard for overrun. */
 	char body[CCS_MAX_PATHNAME_LEN];
-	char barrier2[16];
+	char barrier2[16]; /* Safeguard for overrun. */
 };
 
-/*
- *  TOMOYO uses the following structures.
- *  Memory allocated for these structures are never kfree()ed.
- *  Since no locks are used for reading, assignment must be performed atomically.
- */
+/* Common header for holding ACL entries. */
+struct acl_info {
+	/*
+	 * Keep "access_me_via_ccs_get_condition_part" first, for
+	 * memory for this filed is not allocated if
+	 * (type & ACL_WITH_CONDITION) == 0.
+	 */
+	const struct condition_list *access_me_via_ccs_get_condition_part;
+	struct list1_head list;
+	/*
+	 * Type of this ACL entry.
+	 *
+	 * MSB is is_deleted flag.
+	 * Next bit is with_condition flag.
+	 */
+	u8 type;
+} __attribute__((__packed__));
 
-/*************************  The structure for domains.  *************************/
-
+/* This ACL entry is deleted.           */
 #define ACL_DELETED        0x80
+/* This ACL entry has conditional part. */
 #define ACL_WITH_CONDITION 0x40
 
-struct acl_info {
-	const struct condition_list *cond; /* Use GetConditionPart() to read me. */
-	struct list1_head list;
-	u8 type; /* MSB is is_deleted flag. Next bit is with_condition flag. */
-} __attribute__((__packed__));
-
+/* Structure for domain information. */
 struct domain_info {
 	struct list1_head list;
 	struct list1_head acl_info_list;
-	const struct path_info *domainname; /* Name of this domain. Never NULL.      */
-	u8 profile;                         /* Profile to use.                       */
-	u8 is_deleted;                      /* Delete flag.                          */
-	bool quota_warned;                  /* Quota warnning done flag.             */
-	u8 flags;                           /* Ignore default?                       */
+	/* Name of this domain. Never NULL.          */
+	const struct path_info *domainname;
+	u8 profile;        /* Profile number to use. */
+	u8 is_deleted;     /* Delete flag.           */
+	bool quota_warned; /* Quota warnning flag.   */
+	/* DOMAIN_FLAGS_IGNORE_* . Use ccs_set_domain_flag() to modify. */
+	u8 flags;
 };
 
+/* Profile number is an integer between 0 and 255. */
 #define MAX_PROFILES 256
 
-#define DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ 1 /* Ignore "allow_read" in exception_policy */
-#define DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV  2 /* Ignore "allow_env" in exception_policy  */
+/* Ignore "allow_read" directive in exception policy. */
+#define DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ 1
+/* Ignore "allow_env" directive in exception policy.  */
+#define DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV  2
 
+/*
+ * Structure for "preferred_execute_handler" and "default_execute_handler"
+ * directive. These directives can exist only one entry in a domain.
+ * If "preferred_execute_handler" directive exists, all "allow_execute"
+ * and "default_execute_handler" directive are ignored.
+ */
 struct execute_handler_record {
-	struct acl_info head;                         /* type = TYPE_*_EXECUTE_HANDLER */
-	const struct path_info *handler;              /* Pointer to single pathname.   */
+	struct acl_info head;            /* type = TYPE_*_EXECUTE_HANDLER */
+	const struct path_info *handler; /* Pointer to single pathname.   */
 };
 
+/*
+ * Structure for "allow_read/write", "allow_execute", "allow_read",
+ * "allow_write", "allow_create", "allow_unlink", "allow_mkdir", "allow_rmdir",
+ * "allow_mkfifo", "allow_mksock", "allow_mkblock", "allow_mkchar",
+ * "allow_truncate", "allow_symlink" and "allow_rewrite" directive.
+ */
 struct single_path_acl_record {
-	struct acl_info head;                         /* type = TYPE_SINGLE_PATH_ACL */
-	bool u_is_group;
+	struct acl_info head; /* type = TYPE_SINGLE_PATH_ACL */
+	bool u_is_group; /* True if u points to "path_group" directive. */
 	u16 perm;
 	union {
-		const struct path_info *filename;     /* Pointer to single pathname. */
-		const struct path_group_entry *group; /* Pointer to pathname group.  */
+		/* Pointer to single pathname. */
+		const struct path_info *filename;
+		/* Pointer to pathname group. */
+		const struct path_group_entry *group;
 	} u;
 };
 
+/* Structure for "allow_rename" and "allow_link" directive. */
 struct double_path_acl_record {
-	struct acl_info head;                          /* type = TYPE_DOUBLE_PATH_ACL */
+	struct acl_info head; /* type = TYPE_DOUBLE_PATH_ACL */
 	u8 perm;
-	bool u1_is_group;
-	bool u2_is_group;
+	bool u1_is_group; /* True if u1 points to "path_group" directive. */
+	bool u2_is_group; /* True if u2 points to "path_group" directive. */
 	union {
-		const struct path_info *filename1;     /* Pointer to single pathname. */
-		const struct path_group_entry *group1; /* Pointer to pathname group.  */
+		/* Pointer to single pathname. */
+		const struct path_info *filename1;
+		/* Pointer to pathname group. */
+		const struct path_group_entry *group1;
 	} u1;
 	union {
-		const struct path_info *filename2;     /* Pointer to single pathname. */
-		const struct path_group_entry *group2; /* Pointer to pathname group.  */
+		/* Pointer to single pathname. */
+		const struct path_info *filename2;
+		/* Pointer to pathname group. */
+		const struct path_group_entry *group2;
 	} u2;
 };
 
+/* Structure for "allow_argv0" directive. */
 struct argv0_acl_record {
 	struct acl_info head;             /* type = TYPE_ARGV0_ACL       */
 	const struct path_info *filename; /* Pointer to single pathname. */
-	const struct path_info *argv0;    /* strrchr(argv[0], '/') + 1   */
+	const struct path_info *argv0;    /* = strrchr(argv[0], '/') + 1 */
 };
 
+/* Structure for "allow_env" directive in domain policy. */
 struct env_acl_record {
-	struct acl_info head;           /* type = TYPE_ENV_ACL  */
-	const struct path_info *env;    /* environment variable */
+	struct acl_info head;        /* type = TYPE_ENV_ACL  */
+	const struct path_info *env; /* environment variable */
 };
 
+/* Structure for "allow_capability" directive. */
 struct capability_acl_record {
 	struct acl_info head; /* type = TYPE_CAPABILITY_ACL */
 	u8 operation;
 };
 
+/* Structure for "allow_signal" directive. */
 struct signal_acl_record {
-	struct acl_info head;               /* type = TYPE_SIGNAL_ACL          */
+	struct acl_info head; /* type = TYPE_SIGNAL_ACL */
 	u16 sig;
-	const struct path_info *domainname; /* Pointer to destination pattern. */
+	/* Pointer to destination pattern. */
+	const struct path_info *domainname;
 };
 
-#define IP_RECORD_TYPE_ADDRESS_GROUP 0
-#define IP_RECORD_TYPE_IPv4          1
-#define IP_RECORD_TYPE_IPv6          2
-
+/* Structure for "allow_network" directive. */
 struct ip_network_acl_record {
-	struct acl_info head;   /* type = TYPE_IP_NETWORK_ACL */
+	struct acl_info head; /* type = TYPE_IP_NETWORK_ACL */
+	/*
+	 * operation_type takes one of the following constants.
+	 *   NETWORK_ACL_UDP_BIND for UDP's bind() operation.
+	 *   NETWORK_ACL_UDP_CONNECT for UDP's connect()/send()/recv()
+	 *                               operation.
+	 *   NETWORK_ACL_TCP_BIND for TCP's bind() operation.
+	 *   NETWORK_ACL_TCP_LISTEN for TCP's listen() operation.
+	 *   NETWORK_ACL_TCP_CONNECT for TCP's connect() operation.
+	 *   NETWORK_ACL_TCP_ACCEPT for TCP's accept() operation.
+	 *   NETWORK_ACL_RAW_BIND for IP's bind() operation.
+	 *   NETWORK_ACL_RAW_CONNECT for IP's connect()/send()/recv()
+	 *                               operation.
+	 */
 	u8 operation_type;
-	u8 record_type;         /* IP_RECORD_TYPE_*           */
-	u16 min_port;           /* Start of port number range.                   */
-	u16 max_port;           /* End of port number range.                     */
+	/*
+	 * record_type takes one of the following constants.
+	 *   IP_RECORD_TYPE_ADDRESS_GROUP
+	 *                if u points to "address_group" directive.
+	 *   IP_RECORD_TYPE_IPv4
+	 *                if u points to an IPv4 address.
+	 *   IP_RECORD_TYPE_IPv6
+	 *                if u points to an IPv6 address.
+	 */
+	u8 record_type;
+	/* Start of port number range. */
+	u16 min_port;
+	/* End of port number range.   */
+	u16 max_port;
 	union {
 		struct {
-			u32 min; /* Start of IPv4 address range. Host endian. */
-			u32 max; /* End of IPv4 address range. Host endian.   */
+			/* Start of IPv4 address range. Host endian. */
+			u32 min;
+			/* End of IPv4 address range. Host endian.   */
+			u32 max;
 		} ipv4;
 		struct {
-			const struct in6_addr *min; /* Start of IPv6 address range. Big endian.      */
-			const struct in6_addr *max; /* End of IPv6 address range. Big endian.        */
+			/* Start of IPv6 address range. Big endian.  */
+			const struct in6_addr *min;
+			/* End of IPv6 address range. Big endian.    */
+			const struct in6_addr *max;
 		} ipv6;
-		const struct address_group_entry *group; /* Pointer to address group. */
+		/* Pointer to address group. */
+		const struct address_group_entry *group;
 	} u;
 };
 
-/*************************  Keywords for ACLs.  *************************/
+#define IP_RECORD_TYPE_ADDRESS_GROUP 0
+#define IP_RECORD_TYPE_IPv4          1
+#define IP_RECORD_TYPE_IPv6          2
 
-#define KEYWORD_ADDRESS_GROUP            "address_group "
-#define KEYWORD_ADDRESS_GROUP_LEN        (sizeof(KEYWORD_ADDRESS_GROUP) - 1)
-#define KEYWORD_AGGREGATOR               "aggregator "
-#define KEYWORD_AGGREGATOR_LEN           (sizeof(KEYWORD_AGGREGATOR) - 1)
-#define KEYWORD_ALIAS                    "alias "
-#define KEYWORD_ALIAS_LEN                (sizeof(KEYWORD_ALIAS) - 1)
-#define KEYWORD_ALLOW_ARGV0              "allow_argv0 "
-#define KEYWORD_ALLOW_ARGV0_LEN          (sizeof(KEYWORD_ALLOW_ARGV0) - 1)
-#define KEYWORD_ALLOW_CAPABILITY         "allow_capability "
-#define KEYWORD_ALLOW_CAPABILITY_LEN     (sizeof(KEYWORD_ALLOW_CAPABILITY) - 1)
-#define KEYWORD_ALLOW_CHROOT             "allow_chroot "
-#define KEYWORD_ALLOW_CHROOT_LEN         (sizeof(KEYWORD_ALLOW_CHROOT) - 1)
-#define KEYWORD_ALLOW_ENV                "allow_env "
-#define KEYWORD_ALLOW_ENV_LEN            (sizeof(KEYWORD_ALLOW_ENV) - 1)
-#define KEYWORD_ALLOW_MOUNT              "allow_mount "
-#define KEYWORD_ALLOW_MOUNT_LEN          (sizeof(KEYWORD_ALLOW_MOUNT) - 1)
-#define KEYWORD_ALLOW_NETWORK            "allow_network "
-#define KEYWORD_ALLOW_NETWORK_LEN        (sizeof(KEYWORD_ALLOW_NETWORK) - 1)
-#define KEYWORD_ALLOW_PIVOT_ROOT         "allow_pivot_root "
-#define KEYWORD_ALLOW_PIVOT_ROOT_LEN     (sizeof(KEYWORD_ALLOW_PIVOT_ROOT) - 1)
-#define KEYWORD_ALLOW_READ               "allow_read "
-#define KEYWORD_ALLOW_READ_LEN           (sizeof(KEYWORD_ALLOW_READ) - 1)
-#define KEYWORD_ALLOW_SIGNAL             "allow_signal "
-#define KEYWORD_ALLOW_SIGNAL_LEN         (sizeof(KEYWORD_ALLOW_SIGNAL) - 1)
-#define KEYWORD_DELETE                   "delete "
-#define KEYWORD_DELETE_LEN               (sizeof(KEYWORD_DELETE) - 1)
-#define KEYWORD_DENY_AUTOBIND            "deny_autobind "
-#define KEYWORD_DENY_AUTOBIND_LEN        (sizeof(KEYWORD_DENY_AUTOBIND) - 1)
-#define KEYWORD_DENY_REWRITE             "deny_rewrite "
-#define KEYWORD_DENY_REWRITE_LEN         (sizeof(KEYWORD_DENY_REWRITE) - 1)
-#define KEYWORD_DENY_UNMOUNT             "deny_unmount "
-#define KEYWORD_DENY_UNMOUNT_LEN         (sizeof(KEYWORD_DENY_UNMOUNT) - 1)
-#define KEYWORD_FILE_PATTERN             "file_pattern "
-#define KEYWORD_FILE_PATTERN_LEN         (sizeof(KEYWORD_FILE_PATTERN) - 1)
-#define KEYWORD_INITIALIZE_DOMAIN        "initialize_domain "
-#define KEYWORD_INITIALIZE_DOMAIN_LEN    (sizeof(KEYWORD_INITIALIZE_DOMAIN) - 1)
-#define KEYWORD_KEEP_DOMAIN              "keep_domain "
-#define KEYWORD_KEEP_DOMAIN_LEN          (sizeof(KEYWORD_KEEP_DOMAIN) - 1)
-#define KEYWORD_NO_INITIALIZE_DOMAIN     "no_initialize_domain "
-#define KEYWORD_NO_INITIALIZE_DOMAIN_LEN (sizeof(KEYWORD_NO_INITIALIZE_DOMAIN) - 1)
-#define KEYWORD_NO_KEEP_DOMAIN           "no_keep_domain "
-#define KEYWORD_NO_KEEP_DOMAIN_LEN       (sizeof(KEYWORD_NO_KEEP_DOMAIN) - 1)
-#define KEYWORD_PATH_GROUP               "path_group "
-#define KEYWORD_PATH_GROUP_LEN           (sizeof(KEYWORD_PATH_GROUP) - 1)
-#define KEYWORD_SELECT                   "select "
-#define KEYWORD_SELECT_LEN               (sizeof(KEYWORD_SELECT) - 1)
-#define KEYWORD_UNDELETE                 "undelete "
-#define KEYWORD_UNDELETE_LEN             (sizeof(KEYWORD_UNDELETE) - 1)
+/* Keywords for ACLs. */
+#define KEYWORD_ADDRESS_GROUP             "address_group "
+#define KEYWORD_AGGREGATOR                "aggregator "
+#define KEYWORD_ALIAS                     "alias "
+#define KEYWORD_ALLOW_ARGV0               "allow_argv0 "
+#define KEYWORD_ALLOW_CAPABILITY          "allow_capability "
+#define KEYWORD_ALLOW_CHROOT              "allow_chroot "
+#define KEYWORD_ALLOW_ENV                 "allow_env "
+#define KEYWORD_ALLOW_MOUNT               "allow_mount "
+#define KEYWORD_ALLOW_NETWORK             "allow_network "
+#define KEYWORD_ALLOW_PIVOT_ROOT          "allow_pivot_root "
+#define KEYWORD_ALLOW_READ                "allow_read "
+#define KEYWORD_ALLOW_SIGNAL              "allow_signal "
+#define KEYWORD_DELETE                    "delete "
+#define KEYWORD_DENY_AUTOBIND             "deny_autobind "
+#define KEYWORD_DENY_REWRITE              "deny_rewrite "
+#define KEYWORD_DENY_UNMOUNT              "deny_unmount "
+#define KEYWORD_FILE_PATTERN              "file_pattern "
+#define KEYWORD_INITIALIZE_DOMAIN         "initialize_domain "
+#define KEYWORD_KEEP_DOMAIN               "keep_domain "
+#define KEYWORD_NO_INITIALIZE_DOMAIN      "no_initialize_domain "
+#define KEYWORD_NO_KEEP_DOMAIN            "no_keep_domain "
+#define KEYWORD_PATH_GROUP                "path_group "
+#define KEYWORD_SELECT                    "select "
+#define KEYWORD_UNDELETE                  "undelete "
+#define KEYWORD_USE_PROFILE               "use_profile "
+#define KEYWORD_IGNORE_GLOBAL_ALLOW_READ  "ignore_global_allow_read"
+#define KEYWORD_IGNORE_GLOBAL_ALLOW_ENV   "ignore_global_allow_env"
+#define KEYWORD_PREFERRED_EXECUTE_HANDLER "preferred_execute_handler "
+#define KEYWORD_DEFAULT_EXECUTE_HANDLER   "default_execute_handler "
+#define KEYWORD_MAC_FOR_CAPABILITY        "MAC_FOR_CAPABILITY::"
+/* A domain definition starts with <kernel> . */
+#define ROOT_NAME                         "<kernel>"
+#define ROOT_NAME_LEN                     (sizeof(ROOT_NAME) - 1)
 
-#define KEYWORD_USE_PROFILE              "use_profile "
-#define KEYWORD_IGNORE_GLOBAL_ALLOW_READ "ignore_global_allow_read"
-#define KEYWORD_IGNORE_GLOBAL_ALLOW_ENV  "ignore_global_allow_env"
-#define KEYWORD_PREFERRED_EXECUTE_HANDLER "preferred_execute_handler"
-#define KEYWORD_DEFAULT_EXECUTE_HANDLER   "default_execute_handler"
+/* Index numbers for Access Controls. */
+#define CCS_TOMOYO_MAC_FOR_FILE                  0  /* domain_policy.conf */
+#define CCS_TOMOYO_MAC_FOR_ARGV0                 1  /* domain_policy.conf */
+#define CCS_TOMOYO_MAC_FOR_ENV                   2  /* domain_policy.conf */
+#define CCS_TOMOYO_MAC_FOR_NETWORK               3  /* domain_policy.conf */
+#define CCS_TOMOYO_MAC_FOR_SIGNAL                4  /* domain_policy.conf */
+#define CCS_SAKURA_DENY_CONCEAL_MOUNT            5
+#define CCS_SAKURA_RESTRICT_CHROOT               6  /* system_policy.conf */
+#define CCS_SAKURA_RESTRICT_MOUNT                7  /* system_policy.conf */
+#define CCS_SAKURA_RESTRICT_UNMOUNT              8  /* system_policy.conf */
+#define CCS_SAKURA_RESTRICT_PIVOT_ROOT           9  /* system_policy.conf */
+#define CCS_SAKURA_RESTRICT_AUTOBIND            10  /* system_policy.conf */
+#define CCS_TOMOYO_MAX_ACCEPT_ENTRY             11
+#define CCS_TOMOYO_MAX_GRANT_LOG                12
+#define CCS_TOMOYO_MAX_REJECT_LOG               13
+#define CCS_TOMOYO_VERBOSE                      14
+#define CCS_ALLOW_ENFORCE_GRACE                 15
+#define CCS_SLEEP_PERIOD                        16  /* profile.conf       */
+#define CCS_MAX_CONTROL_INDEX                   17
 
-#define KEYWORD_MAC_FOR_CAPABILITY       "MAC_FOR_CAPABILITY::"
-#define KEYWORD_MAC_FOR_CAPABILITY_LEN   (sizeof(KEYWORD_MAC_FOR_CAPABILITY) - 1)
-
-#define ROOT_NAME "<kernel>"             /* A domain definition starts with <kernel> . */
-#define ROOT_NAME_LEN (sizeof(ROOT_NAME) - 1)
-
-/*************************  Index numbers for Access Controls.  *************************/
-
-#define CCS_PROFILE_COMMENT                      0  /* profile.conf            */
-#define CCS_TOMOYO_MAC_FOR_FILE                  1  /* domain_policy.conf      */
-#define CCS_TOMOYO_MAC_FOR_ARGV0                 2  /* domain_policy.conf      */
-#define CCS_TOMOYO_MAC_FOR_ENV                   3  /* domain_policy.conf      */
-#define CCS_TOMOYO_MAC_FOR_NETWORK               4  /* domain_policy.conf      */
-#define CCS_TOMOYO_MAC_FOR_SIGNAL                5  /* domain_policy.conf      */
-#define CCS_SAKURA_DENY_CONCEAL_MOUNT            6
-#define CCS_SAKURA_RESTRICT_CHROOT               7  /* system_policy.conf      */
-#define CCS_SAKURA_RESTRICT_MOUNT                8  /* system_policy.conf      */
-#define CCS_SAKURA_RESTRICT_UNMOUNT              9  /* system_policy.conf      */
-#define CCS_SAKURA_RESTRICT_PIVOT_ROOT          10  /* system_policy.conf      */
-#define CCS_SAKURA_RESTRICT_AUTOBIND            11  /* system_policy.conf      */
-#define CCS_TOMOYO_MAX_ACCEPT_ENTRY             12
-#define CCS_TOMOYO_MAX_GRANT_LOG                13
-#define CCS_TOMOYO_MAX_REJECT_LOG               14
-#define CCS_TOMOYO_VERBOSE                      15
-#define CCS_ALLOW_ENFORCE_GRACE                 16
-#define CCS_SLEEP_PERIOD                        17  /* profile.conf            */
-#define CCS_MAX_CONTROL_INDEX                   18
-
-/*************************  Index numbers for updates counter.  *************************/
-
+/* Index numbers for updates counter. */
 #define CCS_UPDATES_COUNTER_SYSTEM_POLICY    0
 #define CCS_UPDATES_COUNTER_DOMAIN_POLICY    1
 #define CCS_UPDATES_COUNTER_EXCEPTION_POLICY 2
@@ -448,138 +505,271 @@
 #define CCS_UPDATES_COUNTER_REJECT_LOG       7
 #define MAX_CCS_UPDATES_COUNTER              8
 
-/*************************  The structure for /proc interfaces.  *************************/
-
-struct io_buffer {
-	int (*read) (struct io_buffer *);
+/* The structure for reading/writing policy via /proc interfaces. */
+struct ccs_io_buffer {
+	int (*read) (struct ccs_io_buffer *);
+	int (*write) (struct ccs_io_buffer *);
+	int (*poll) (struct file *file, poll_table *wait);
+	/* Exclusive lock for read_buf .        */
 	struct mutex read_sem;
-	int (*write) (struct io_buffer *);
+	/* Exclusive lock for write_buf .       */
 	struct mutex write_sem;
-	int (*poll) (struct file *file, poll_table *wait);
-	struct list1_head *read_var1;     /* The position currently reading from. */
-	struct list1_head *read_var2;     /* Extra variables for reading.         */
-	struct domain_info *write_var1;   /* The position currently writing to.   */
-	int read_step;                    /* The step for reading.                */
-	char *read_buf;                   /* Buffer for reading.                  */
-	bool read_eof;                    /* EOF flag for reading.                */
-	u8 read_bit;                      /* Extra variable for reading.          */
-	int read_avail;                   /* Bytes available for reading.         */
-	int readbuf_size;                 /* Size of read buffer.                 */
-	char *write_buf;                  /* Buffer for writing.                  */
-	int write_avail;                  /* Bytes available for writing.         */
-	int writebuf_size;                /* Size of write buffer.                */
+	/* The position currently reading from. */
+	struct list1_head *read_var1;
+	/* Extra variables for reading.         */
+	struct list1_head *read_var2;
+	/* The position currently writing to.   */
+	struct domain_info *write_var1;
+	/* The step for reading.                */
+	int read_step;
+	/* Buffer for reading.                  */
+	char *read_buf;
+	/* EOF flag for reading.                */
+	bool read_eof;
+	/* Extra variable for reading.          */
+	u8 read_bit;
+	/* Bytes available for reading.         */
+	int read_avail;
+	/* Size of read buffer.                 */
+	int readbuf_size;
+	/* Buffer for writing.                  */
+	char *write_buf;
+	/* Bytes available for writing.         */
+	int write_avail;
+	/* Size of write buffer.                */
+	int writebuf_size;
 };
 
-/*************************  PROTOTYPES  *************************/
-
+/* Prototype definition. */
 struct condition_list;
 
-char *InitAuditLog(int *len, const u8 profile, const u8 mode, struct linux_binprm *bprm);
-void *ccs_alloc(const size_t size);
-char *print_ipv6(char *buffer, const int buffer_len, const struct in6_addr *ip);
-const char *GetEXE(void);
-const char *GetLastName(const struct domain_info *domain);
-const char *GetMSG(const bool is_enforce);
-const char *cap_operation2keyword(const u8 operation);
-const char *dp_operation2keyword(const u8 operation);
-const char *sp_operation2keyword(const u8 operation);
-const char *net_operation2keyword(const u8 operation);
-const struct condition_list *FindOrAssignNewCondition(char *condition);
-int AddAddressGroupPolicy(char *data, const bool is_delete);
-int AddAggregatorPolicy(char *data, const bool is_delete);
-int AddAliasPolicy(char *data, const bool is_delete);
-int AddArgv0Policy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
-int AddCapabilityPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
-int AddChrootPolicy(char *data, const bool is_delete);
-int AddDomainACL(struct domain_info *domain, struct acl_info *acl);
-int AddDomainInitializerPolicy(char *data, const bool is_not, const bool is_delete);
-int AddDomainKeeperPolicy(char *data, const bool is_not, const bool is_delete);
-int AddEnvPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
-int AddFilePolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
-int AddGloballyReadablePolicy(char *data, const bool is_delete);
-int AddGloballyUsableEnvPolicy(char *env, const bool is_delete);
-int AddFilePatternPolicy(char *data, const bool is_delete);
-int AddMountPolicy(char *data, const bool is_delete);
-int AddNetworkPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
-int AddNoRewritePolicy(char *pattern, const bool is_delete);
-int AddNoUmountPolicy(char *data, const bool is_delete);
-int AddPathGroupPolicy(char *data, const bool is_delete);
-int AddPivotRootPolicy(char *data, const bool is_delete);
-int AddReservedPortPolicy(char *data, const bool is_delete);
-int AddSignalPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
-int CCS_CloseControl(struct file *file);
-int CCS_OpenControl(const u8 type, struct file *file);
-int CCS_PollControl(struct file *file, poll_table *wait);
-int CCS_ReadControl(struct file *file, char __user *buffer, const int buffer_len);
-int CCS_WriteControl(struct file *file, const char __user *buffer, const int buffer_len);
-int CanSaveAuditLog(const bool is_granted);
-int CheckSupervisor(const char *fmt, ...) __attribute__ ((format(printf, 1, 2)));
-int DelDomainACL(struct acl_info *acl);
-int DeleteDomain(char *data);
-int DumpCondition(struct io_buffer *head, const struct condition_list *ptr);
-bool CheckCondition(const struct acl_info *acl, struct obj_info *obj_info);
-bool IsCorrectDomain(const unsigned char *domainname, const char *function);
-bool IsCorrectPath(const char *filename, const s8 start_type, const s8 pattern_type, const s8 end_type, const char *function);
-bool IsDomainDef(const unsigned char *buffer);
-bool PathMatchesToPattern(const struct path_info *pathname0, const struct path_info *pattern0);
-int PollGrantLog(struct file *file, poll_table *wait);
-int PollRejectLog(struct file *file, poll_table *wait);
-int ReadAddressGroupPolicy(struct io_buffer *head);
-int ReadAggregatorPolicy(struct io_buffer *head);
-int ReadAliasPolicy(struct io_buffer *head);
-int ReadChrootPolicy(struct io_buffer *head);
-int ReadDomainInitializerPolicy(struct io_buffer *head);
-int ReadDomainKeeperPolicy(struct io_buffer *head);
-int ReadGloballyReadablePolicy(struct io_buffer *head);
-int ReadGloballyUsableEnvPolicy(struct io_buffer *head);
-int ReadGrantLog(struct io_buffer *head);
-int ReadFilePatternPolicy(struct io_buffer *head);
-int ReadMountPolicy(struct io_buffer *head);
-int ReadNoRewritePolicy(struct io_buffer *head);
-int ReadNoUmountPolicy(struct io_buffer *head);
-int ReadPathGroupPolicy(struct io_buffer *head);
-int ReadPivotRootPolicy(struct io_buffer *head);
-int ReadRejectLog(struct io_buffer *head);
-int ReadReservedPortPolicy(struct io_buffer *head);
-int WriteAuditLog(char *log, const bool is_granted);
-int io_printf(struct io_buffer *head, const char *fmt, ...) __attribute__ ((format(printf, 2, 3)));
-struct domain_info *FindDomain(const char *domainname);
-struct domain_info *FindOrAssignNewDomain(const char *domainname, const u8 profile);
-struct domain_info *UndeleteDomain(const char *domainname0);
-bool CheckCCSQuota(struct domain_info * const domain);
-unsigned int CheckCCSFlags(const u8 index);
-unsigned int CheckCCSFlags_NoSleepCheck(const u8 index);
-u8 CheckCapabilityFlags(const u8 index);
-bool CheckDomainQuota(struct domain_info * const domain);
-bool TomoyoVerboseMode(void);
-void *alloc_acl_element(const u8 acl_type, const struct condition_list *condition);
-const struct condition_list *GetConditionPart(const struct acl_info *acl);
-void CCS_LoadPolicy(const char *filename);
-void UpdateCounter(const unsigned char index);
-void ccs_free(const void *p);
-void fill_path_info(struct path_info *ptr);
-void UpdateCondition(const struct acl_info *acl);
-void SetDomainFlag(struct domain_info *domain, const bool is_delete, const u8 flags);
+/* Check conditional part of an ACL entry. */
+bool ccs_check_condition(const struct acl_info *acl,
+			 struct obj_info *obj_info);
+/* Check whether the domain has too many ACL entries to hold. */
+bool ccs_check_domain_quota(struct domain_info * const domain);
+/* Dump conditional part of an ACL entry. */
+bool ccs_dump_condition(struct ccs_io_buffer *head,
+			const struct condition_list *cond);
+/* Transactional sprintf() for policy dump. */
+bool ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
+	__attribute__ ((format(printf, 2, 3)));
+/* Check whether the domainname is correct. */
+bool ccs_is_correct_domain(const unsigned char *domainname,
+			   const char *function);
+/* Check whether the token is correct. */
+bool ccs_is_correct_path(const char *filename, const s8 start_type,
+			 const s8 pattern_type, const s8 end_type,
+			 const char *function);
+/* Check whether the token can be a domainname. */
+bool ccs_is_domain_def(const unsigned char *buffer);
+/* Check whether the given filename matches the given pattern. */
+bool ccs_path_matches_pattern(const struct path_info *filename,
+			      const struct path_info *pattern);
+/* Dump "address_group" entry in exception policy. */
+bool ccs_read_address_group_policy(struct ccs_io_buffer *head);
+/* Dump "aggregator" entry in exception policy. */
+bool ccs_read_aggregator_policy(struct ccs_io_buffer *head);
+/* Dump "alias" entry in exception policy. */
+bool ccs_read_alias_policy(struct ccs_io_buffer *head);
+/* Dump "allow_chroot" entry in system policy. */
+bool ccs_read_chroot_policy(struct ccs_io_buffer *head);
+/*
+ * Dump "initialize_domain" and "no_initialize_domain" entry
+ * in exception policy.
+ */
+bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head);
+/* Dump "keep_domain" and "no_keep_domain" entry in exception policy. */
+bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head);
+/* Dump "file_pattern" entry in exception policy. */
+bool ccs_read_file_pattern(struct ccs_io_buffer *head);
+/* Dump "allow_read" entry in exception policy. */
+bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head);
+/* Dump "allow_env" entry in exception policy. */
+bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head);
+/* Dump "allow_mount" entry in system policy. */
+bool ccs_read_mount_policy(struct ccs_io_buffer *head);
+/* Dump "deny_rewrite" entry in exception policy. */
+bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head);
+/* Dump "deny_unmount" entry in system policy. */
+bool ccs_read_no_umount_policy(struct ccs_io_buffer *head);
+/* Dump "path_group" entry in exception policy. */
+bool ccs_read_path_group_policy(struct ccs_io_buffer *head);
+/* Dump "allow_pivot_root" entry in system policy. */
+bool ccs_read_pivot_root_policy(struct ccs_io_buffer *head);
+/* Dump "deny_autobind" entry in system policy. */
+bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head);
+/* Write domain policy violation warning message to console? */
+bool ccs_verbose_mode(void);
+/* Allocate buffer for domain policy auditing. */
+char *ccs_init_audit_log(int *len, const u8 profile, const u8 mode,
+			 struct linux_binprm *bprm);
+/* Dump an IPv6 address. */
+char *ccs_print_ipv6(char *buffer, const int buffer_len,
+		     const struct in6_addr *ip);
+/* Convert capability index to capability name. */
+const char *ccs_cap2keyword(const u8 operation);
+/* Convert double path operation to operation name. */
+const char *ccs_dp2keyword(const u8 operation);
+/* Get the pathname of current process. */
+const char *ccs_get_exe(void);
+/* Get the last component of the given domainname. */
+const char *ccs_get_last_name(const struct domain_info *domain);
+/* Get warning message. */
+const char *ccs_get_msg(const bool is_enforce);
+/* Convert network operation index to operation name. */
+const char *ccs_net2keyword(const u8 operation);
+/* Convert single path operation to operation name. */
+const char *ccs_sp2keyword(const u8 operation);
+/* Create conditional part of an ACL entry. */
+const struct condition_list *
+ccs_find_or_assign_new_condition(char * const condition);
+/* Read conditional part of an ACL entry. */
+const struct condition_list *
+ccs_get_condition_part(const struct acl_info *acl);
+/* Add an ACL entry to domain's ACL list. */
+int ccs_add_domain_acl(struct domain_info *domain, struct acl_info *acl);
+/* Check whether there is space for audit logs. */
+int ccs_can_save_audit_log(const bool is_granted);
+/* Ask supervisor's opinion. */
+int ccs_check_supervisor(const char *fmt, ...)
+	__attribute__ ((format(printf, 1, 2)));
+/* Close /proc/ccs/ interface. */
+int ccs_close_control(struct file *file);
+/* Delete an ACL entry from domain's ACL list. */
+int ccs_del_domain_acl(struct acl_info *acl);
+/* Delete a domain. */
+int ccs_delete_domain(char *data);
+/* Open operation for /proc/ccs/ interface. */
+int ccs_open_control(const u8 type, struct file *file);
+/* Poll operation for /proc/ccs/ interface. */
+int ccs_poll_control(struct file *file, poll_table *wait);
+/* Check whether there is a grant log. */
+int ccs_poll_grant_log(struct file *file, poll_table *wait);
+/* Check whether there is a reject log. */
+int ccs_poll_reject_log(struct file *file, poll_table *wait);
+/* Read operation for /proc/ccs/ interface. */
+int ccs_read_control(struct file *file, char __user *buffer,
+		     const int buffer_len);
+/* Read a grant log. */
+int ccs_read_grant_log(struct ccs_io_buffer *head);
+/* Read a reject log. */
+int ccs_read_reject_log(struct ccs_io_buffer *head);
+/* Add "address_group" entry in exception policy. */
+int ccs_write_address_group_policy(char *data, const bool is_delete);
+/* Create "aggregator" entry in exception policy. */
+int ccs_write_aggregator_policy(char *data, const bool is_delete);
+/* Create "alias" entry in exception policy. */
+int ccs_write_alias_policy(char *data, const bool is_delete);
+/* Create "allow_argv0" entry in domain policy. */
+int ccs_write_argv0_policy(char *data, struct domain_info *domain,
+			   const struct condition_list *condition,
+			   const bool is_delete);
+/* Write an audit log. */
+int ccs_write_audit_log(char *log, const bool is_granted);
+/* Create "allow_capability" entry in domain policy. */
+int ccs_write_capability_policy(char *data, struct domain_info *domain,
+				const struct condition_list *condition,
+				const bool is_delete);
+/* Create "allow_chroot" entry in system policy. */
+int ccs_write_chroot_policy(char *data, const bool is_delete);
+/*
+ * Create "initialize_domain" and "no_initialize_domain" entry
+ * in exception policy.
+ */
+int ccs_write_domain_initializer_policy(char *data, const bool is_not,
+					const bool is_delete);
+/* Create "keep_domain" and "no_keep_domain" entry in exception policy. */
+int ccs_write_domain_keeper_policy(char *data, const bool is_not,
+				   const bool is_delete);
+/* Create "allow_env" entry in domain policy. */
+int ccs_write_env_policy(char *data, struct domain_info *domain,
+			 const struct condition_list *condition,
+			 const bool is_delete);
+/*
+ * Create "allow_read/write", "allow_execute", "allow_read", "allow_write",
+ * "allow_create", "allow_unlink", "allow_mkdir", "allow_rmdir",
+ * "allow_mkfifo", "allow_mksock", "allow_mkblock", "allow_mkchar",
+ * "allow_truncate", "allow_symlink", "allow_rewrite", "allow_rename",
+ * "allow_link", "preferred_execute_handler" and "default_execute_handler"
+ * entry in domain policy.
+ */
+int ccs_write_file_policy(char *data, struct domain_info *domain,
+			  const struct condition_list *condition,
+			  const bool is_delete);
+/* Create "allow_read" entry in exception policy. */
+int ccs_write_globally_readable_policy(char *data, const bool is_delete);
+/* Create "allow_env" entry in exception policy. */
+int ccs_write_globally_usable_env_policy(char *data, const bool is_delete);
+/* Create "allow_mount" entry in system policy. */
+int ccs_write_mount_policy(char *data, const bool is_delete);
+/* Create "allow_network" entry in domain policy. */
+int ccs_write_network_policy(char *data, struct domain_info *domain,
+			     const struct condition_list *condition,
+			     const bool is_delete);
+/* Create "deny_rewrite" entry in exception policy. */
+int ccs_write_no_rewrite_policy(char *data, const bool is_delete);
+/* Create "deny_unmount" entry in system policy. */
+int ccs_write_no_umount_policy(char *data, const bool is_delete);
+/* Create "path_group" entry in exception policy. */
+int ccs_write_path_group_policy(char *data, const bool is_delete);
+/* Create "file_pattern" entry in exception policy. */
+int ccs_write_pattern_policy(char *data, const bool is_delete);
+/* Create "allow_pivot_root" entry in system policy. */
+int ccs_write_pivot_root_policy(char *data, const bool is_delete);
+/* Create "deny_autobind" entry in system policy. */
+int ccs_write_reserved_port_policy(char *data, const bool is_delete);
+/* Create "allow_signal" entry in domain policy. */
+int ccs_write_signal_policy(char *data, struct domain_info *domain,
+			    const struct condition_list *condition,
+			    const bool is_delete);
+/* Write operation for /proc/ccs/ interface. */
+int ccs_write_control(struct file *file, const char __user *buffer,
+		      const int buffer_len);
+/* Find a domain by the given name. */
+struct domain_info *ccs_find_domain(const char *domainname);
+/* Find or create a domain by the given name. */
+struct domain_info *ccs_find_or_assign_new_domain(const char *domainname,
+						  const u8 profile);
+/* Undelete a domain. */
+struct domain_info *ccs_undelete_domain(const char *domainname);
+/* Write a grant log. */
+u8 ccs_check_capability_flags(const u8 index);
+/* Check mode for specified functionality. */
+unsigned int ccs_check_flags(const u8 index);
+/* Same with ccs_check_flags() except that it doesn't check might_sleep(). */
+unsigned int ccs_check_flags_no_sleep_check(const u8 index);
+/* Allocate memory for structures. */
+void *ccs_alloc_acl_element(const u8 acl_type,
+			    const struct condition_list *condition);
+/* Fill in "struct path_info" members. */
+void ccs_fill_path_info(struct path_info *ptr);
+/* Run policy loader when /sbin/init starts. */
+void ccs_load_policy(const char *filename);
+/* Change "struct domain_info"->flags . */
+void ccs_set_domain_flag(struct domain_info *domain, const bool is_delete,
+			 const u8 flags);
+/* Update the process's state. */
+void ccs_update_condition(const struct acl_info *acl);
+/* Update the policy change counter. */
+void ccs_update_counter(const unsigned char index);
 
-static inline bool pathcmp(const struct path_info *a, const struct path_info *b)
+/* strcmp() for "struct path_info" structure. */
+static inline bool ccs_pathcmp(const struct path_info *a,
+			       const struct path_info *b)
 {
 	return a->hash != b->hash || strcmp(a->name, b->name);
 }
 
+/* A linked list of domains. */
 extern struct list1_head domain_list;
-extern asmlinkage long sys_getppid(void);
+/* Has /sbin/init started? */
 extern bool sbin_init_started;
+/* Log level for printk(). */
 extern const char *ccs_log_level;
+/* The kernel's domain. */
 extern struct domain_info KERNEL_DOMAIN;
+/* Exclusive lock for updating domain policy. */
 extern struct mutex domain_acl_lock;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
-static inline void *kzalloc(int size, int flags)
-{
-	void *p = kmalloc(size, flags);
-	if (p) memset(p, 0, size);
-	return p;
-}
 #endif
-
-#endif
Index: trunk/1.6.x/ccs-patch/include/linux/realpath.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/realpath.h	(revision 1045)
+++ trunk/1.6.x/ccs-patch/include/linux/realpath.h	(working copy)
@@ -15,29 +15,51 @@
 #ifndef _LINUX_REALPATH_H
 #define _LINUX_REALPATH_H
 
+struct dentry;
+struct vfsmount;
+struct condition_list;
 struct path_info;
 
 /* Returns realpath(3) of the given pathname but ignores chroot'ed root. */
-int realpath_from_dentry2(struct dentry *dentry, struct vfsmount *mnt, char *newname, int newname_len);
+int ccs_realpath_from_dentry2(struct dentry *dentry, struct vfsmount *mnt,
+			      char *newname, int newname_len);
 
-/* Returns realpath(3) of the given pathname but ignores chroot'ed root. */
-/* These functions use ccs_alloc(), so caller must ccs_free() if these functions didn't return NULL. */
-char *realpath(const char *pathname);
-char *realpath_nofollow(const char *pathname);
-char *realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt);
+/*
+ * Returns realpath(3) of the given pathname but ignores chroot'ed root.
+ * These functions use ccs_alloc(), so caller must ccs_free()
+ * if these functions didn't return NULL.
+ */
+char *ccs_realpath(const char *pathname);
+/* Same with ccs_realpath() except that it doesn't follow the final symlink. */
+char *ccs_realpath_nofollow(const char *pathname);
+/* Same with ccs_realpath() except that the pathname is already solved. */
+char *ccs_realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt);
 
-/* Allocate memory for structures. The RAM is chunked, so NEVER try to kfree() the returned pointer. */
-void *alloc_element(const unsigned int size);
+/*
+ * Allocate memory for ACL entry.
+ * The RAM is chunked, so NEVER try to kfree() the returned pointer.
+ */
+void *ccs_alloc_element(const unsigned int size);
 
-/* Get used RAM size for alloc_elements(). */
-unsigned int GetMemoryUsedForElements(void);
+/* Get used RAM size for ccs_alloc_elements(). */
+unsigned int ccs_get_memory_used_for_elements(void);
 
-/* Keep the given name on the RAM. The RAM is shared, so NEVER try to modify or kfree() the returned name. */
-const struct path_info *SaveName(const char *name);
+/*
+ * Keep the given name on the RAM.
+ * The RAM is shared, so NEVER try to modify or kfree() the returned name.
+ */
+const struct path_info *ccs_save_name(const char *name);
 
-/* Get used RAM size for SaveName(). */
-unsigned int GetMemoryUsedForSaveName(void);
+/* Get used RAM size for ccs_save_name(). */
+unsigned int ccs_get_memory_used_for_save_name(void);
 
-unsigned int GetMemoryUsedForDynamic(void);
+/* Allocate memory for temporary use (e.g. permission checks). */
+void *ccs_alloc(const size_t size);
 
+/* Get used RAM size for ccs_alloc(). */
+unsigned int ccs_get_memory_used_for_dynamic(void);
+
+/* Free memory allocated by ccs_alloc(). */
+void ccs_free(const void *p);
+
 #endif
Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo_vfs.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo_vfs.h	(revision 1045)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo_vfs.h	(working copy)
@@ -15,199 +15,357 @@
 #ifndef _LINUX_TOMOYO_VFS_H
 #define _LINUX_TOMOYO_VFS_H
 
-/***** TOMOYO Linux start. *****/
-
 #include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 
+/*
+ * This file contains copy of some of VFS helper functions.
+ *
+ * Since TOMOYO Linux requires "struct vfsmount" parameter to calculate
+ * an absolute pathname of the requested "struct dentry" parameter
+ * but the VFS helper functions don't receive "struct vfsmount" parameter,
+ * TOMOYO Linux checks permission outside VFS helper functions.
+ * To keep the DAC's permission checks are performed before the
+ * TOMOYO Linux's permission checks are performed, I'm manually inserting
+ * these functions that performs the DAC's permission checks into fs/namei.c .
+ *
+ * The approach to obtain "struct vfsmount" parameter from
+ * the "struct task_struct" doesn't work because it triggers deadlock.
+ */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+
+/* Some of permission checks from vfs_create() . */
 static inline int pre_vfs_create(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	down(&dir->i_zombie);
 	error = may_create(dir, dentry);
-	if (!error && (!dir->i_op || !dir->i_op->create)) error = -EPERM; /* -ENOSYS ? */
+	if (!error && (!dir->i_op || !dir->i_op->create))
+		error = -EACCES;
 	up(&dir->i_zombie);
 	return error;
 }
 
+/*
+ * Some of permission checks from vfs_mknod() .
+ *
+ * This function is exported because
+ * vfs_mknod() is called from net/unix/af_unix.c .
+ */
 int pre_vfs_mknod(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	down(&dir->i_zombie);
 	error = may_create(dir, dentry);
-	if (!error && (!dir->i_op || !dir->i_op->mknod)) error = -EPERM; /* -ENOSYS ? */
+	if (!error && (!dir->i_op || !dir->i_op->mknod))
+		error = -EPERM;
 	up(&dir->i_zombie);
 	return error;
 }
 EXPORT_SYMBOL(pre_vfs_mknod);
 
+/* Some of permission checks from vfs_mkdir() . */
 static inline int pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	down(&dir->i_zombie);
 	error = may_create(dir, dentry);
-	if (!error && (!dir->i_op || !dir->i_op->mkdir)) error = -EPERM;
+	if (!error && (!dir->i_op || !dir->i_op->mkdir))
+		error = -EPERM;
 	up(&dir->i_zombie);
 	return error;
 }
 
+/* Some of permission checks from vfs_rmdir() . */
 static inline int pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = may_delete(dir, dentry, 1);
-	if (!error && (!dir->i_op || !dir->i_op->rmdir)) error = -EPERM;
+	if (!error && (!dir->i_op || !dir->i_op->rmdir))
+		error = -EPERM;
 	return error;
 }
 
+/* Some of permission checks from vfs_unlink() . */
 static inline int pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 33)
 	int error;
 	down(&dir->i_zombie);
 	error = may_delete(dir, dentry, 0);
-	if (!error && (!dir->i_op || !dir->i_op->unlink)) error = -EPERM;
+	if (!error && (!dir->i_op || !dir->i_op->unlink))
+		error = -EPERM;
 	up(&dir->i_zombie);
 	return error;
+#else
+	int error;
+	struct inode *inode;
+	error = may_delete(dir, dentry, 0);
+	if (error)
+		return error;
+	inode = dentry->d_inode;
+	atomic_inc(&inode->i_count);
+	double_down(&dir->i_zombie, &inode->i_zombie);
+	error = -EPERM;
+	if (dir->i_op && dir->i_op->unlink)
+		error = 0;
+	double_up(&dir->i_zombie, &inode->i_zombie);
+	iput(inode);
+	return error;
+#endif
 }
 
-static inline int pre_vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
+/* Permission checks from vfs_symlink() . */
+static inline int pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
 {
+	int error;
+	down(&dir->i_zombie);
+	error = may_create(dir, dentry);
+	if (error)
+		goto exit_lock;
+	if (!dir->i_op || !dir->i_op->symlink)
+		error = -EPERM;
+ exit_lock:
+	up(&dir->i_zombie);
+	return error;
+}
+
+/* Some of permission checks from vfs_link() . */
+static inline int pre_vfs_link(struct dentry *old_dentry, struct inode *dir,
+			       struct dentry *new_dentry)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 33)
 	struct inode *inode;
 	int error;
 	down(&dir->i_zombie);
 	error = -ENOENT;
 	inode = old_dentry->d_inode;
-	if (!inode) goto exit_lock;
+	if (!inode)
+		goto exit_lock;
 	error = may_create(dir, new_dentry);
-	if (error) goto exit_lock;
+	if (error)
+		goto exit_lock;
 	error = -EXDEV;
-	if (dir->i_dev != inode->i_dev) goto exit_lock;
+	if (dir->i_dev != inode->i_dev)
+		goto exit_lock;
 	error = -EPERM;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode)) goto exit_lock;
-	if (!dir->i_op || !dir->i_op->link) goto exit_lock;
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		goto exit_lock;
+	if (!dir->i_op || !dir->i_op->link)
+		goto exit_lock;
 	error = 0;
  exit_lock:
 	up(&dir->i_zombie);
 	return error;
-}
-
-static inline int pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
-{
+#else
+	struct inode *inode;
 	int error;
-	down(&dir->i_zombie);
-	error = may_create(dir, dentry);
-	if (error) goto exit_lock;
-	if (!dir->i_op || !dir->i_op->symlink) error = -EPERM;
+	error = -ENOENT;
+	inode = old_dentry->d_inode;
+	if (!inode)
+		goto exit;
+	error = -EXDEV;
+	if (dir->i_dev != inode->i_dev)
+		goto exit;
+	double_down(&dir->i_zombie, &old_dentry->d_inode->i_zombie);
+	error = may_create(dir, new_dentry);
+	if (error)
+		goto exit_lock;
+	error = -EPERM;
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		goto exit_lock;
+	if (!dir->i_op || !dir->i_op->link)
+		goto exit_lock;
+	error = 0;
  exit_lock:
-	up(&dir->i_zombie);
+	double_up(&dir->i_zombie, &old_dentry->d_inode->i_zombie);
+ exit:
 	return error;
+#endif
 }
 
-static inline int pre_vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
+/* Some of permission checks from vfs_rename_dir() . */
+static inline int pre_vfs_rename_dir(struct inode *old_dir,
+				     struct dentry *old_dentry,
+				     struct inode *new_dir,
+				     struct dentry *new_dentry)
 {
 	int error;
-	if (old_dentry->d_inode == new_dentry->d_inode) return 0;
+	if (old_dentry->d_inode == new_dentry->d_inode)
+		return 0;
 	error = may_delete(old_dir, old_dentry, 1);
-	if (error) return error;
-	if (new_dir->i_dev != old_dir->i_dev) return -EXDEV;
-	if (!new_dentry->d_inode) error = may_create(new_dir, new_dentry);
-	else error = may_delete(new_dir, new_dentry, 1);
-	if (error) return error;
-	if (!old_dir->i_op || !old_dir->i_op->rename) return -EPERM;
-	if (new_dir != old_dir) error = permission(old_dentry->d_inode, MAY_WRITE);
+	if (error)
+		return error;
+	if (new_dir->i_dev != old_dir->i_dev)
+		return -EXDEV;
+	if (!new_dentry->d_inode)
+		error = may_create(new_dir, new_dentry);
+	else
+		error = may_delete(new_dir, new_dentry, 1);
+	if (error)
+		return error;
+	if (!old_dir->i_op || !old_dir->i_op->rename)
+		return -EPERM;
+	if (new_dir != old_dir)
+		error = permission(old_dentry->d_inode, MAY_WRITE);
 	return error;
 }
 
-static inline int pre_vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
+/* Some of permission checks from vfs_rename_other() . */
+static inline int pre_vfs_rename_other(struct inode *old_dir,
+				       struct dentry *old_dentry,
+				       struct inode *new_dir,
+				       struct dentry *new_dentry)
 {
 	int error;
-	if (old_dentry->d_inode == new_dentry->d_inode) return 0;
+	if (old_dentry->d_inode == new_dentry->d_inode)
+		return 0;
 	error = may_delete(old_dir, old_dentry, 0);
-	if (error) return error;
-	if (new_dir->i_dev != old_dir->i_dev) return -EXDEV;
-	if (!new_dentry->d_inode) error = may_create(new_dir, new_dentry);
-	else error = may_delete(new_dir, new_dentry, 0);
-	if (error) return error;
-	if (!old_dir->i_op || !old_dir->i_op->rename) return -EPERM;
+	if (error)
+		return error;
+	if (new_dir->i_dev != old_dir->i_dev)
+		return -EXDEV;
+	if (!new_dentry->d_inode)
+		error = may_create(new_dir, new_dentry);
+	else
+		error = may_delete(new_dir, new_dentry, 0);
+	if (error)
+		return error;
+	if (!old_dir->i_op || !old_dir->i_op->rename)
+		return -EPERM;
 	return 0;
 }
 
-static inline int pre_vfs_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
+/* Some of permission checks from vfs_rename() . */
+static inline int pre_vfs_rename(struct inode *old_dir,
+				 struct dentry *old_dentry,
+				 struct inode *new_dir,
+				 struct dentry *new_dentry)
 {
 	int error;
-	lock_kernel();
-	if (S_ISDIR(old_dentry->d_inode->i_mode)) error = pre_vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
-	else error = pre_vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);
-	unlock_kernel();
+	lock_kernel(); /* From do_rename(). */
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		error = pre_vfs_rename_dir(old_dir, old_dentry,
+					   new_dir, new_dentry);
+	else
+		error = pre_vfs_rename_other(old_dir, old_dentry,
+					     new_dir, new_dentry);
+	unlock_kernel(); /* From do_rename(). */
 	return error;
 }
 
 #else
 
+/*
+ * Permission checks before security_inode_mknod() is called.
+ *
+ * This function is exported because
+ * vfs_mknod() is called from net/unix/af_unix.c .
+ */
 int pre_vfs_mknod(struct inode *dir, struct dentry *dentry, int mode)
 {
 	int error = may_create(dir, dentry, NULL);
-	if (error) return error;
-	if ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD)) return -EPERM;
-	if (!dir->i_op || !dir->i_op->mknod) return -EPERM;
+	if (error)
+		return error;
+	if ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))
+		return -EPERM;
+	if (!dir->i_op || !dir->i_op->mknod)
+		return -EPERM;
 	return 0;
 }
 EXPORT_SYMBOL(pre_vfs_mknod);
 
+/* Permission checks before security_inode_mkdir() is called. */
 static inline int pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = may_create(dir, dentry, NULL);
-	if (error) return error;
-	if (!dir->i_op || !dir->i_op->mkdir) return -EPERM;
+	if (error)
+		return error;
+	if (!dir->i_op || !dir->i_op->mkdir)
+		return -EPERM;
 	return 0;
 }
 
+/* Some of permission checks before security_inode_rmdir() is called. */
 static inline int pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = may_delete(dir, dentry, 1);
-	if (error) return error;
-	if (!dir->i_op || !dir->i_op->rmdir) return -EPERM;
+	if (error)
+		return error;
+	if (!dir->i_op || !dir->i_op->rmdir)
+		return -EPERM;
 	return 0;
 }
 
+/* Some of permission checks before security_inode_unlink() is called. */
 static inline int pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int error = may_delete(dir, dentry, 0);
-	if (error) return error;
-	if (!dir->i_op || !dir->i_op->unlink) return -EPERM;
+	if (error)
+		return error;
+	if (!dir->i_op || !dir->i_op->unlink)
+		return -EPERM;
 	return 0;
 }
 
-static inline int pre_vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
+/* Permission checks before security_inode_link() is called. */
+static inline int pre_vfs_link(struct dentry *old_dentry, struct inode *dir,
+			       struct dentry *new_dentry)
 {
 	struct inode *inode = old_dentry->d_inode;
 	int error;
-	if (!inode) return -ENOENT;
+	if (!inode)
+		return -ENOENT;
 	error = may_create(dir, new_dentry, NULL);
-	if (error) return error;
-	if (dir->i_sb != inode->i_sb) return -EXDEV;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode)) return -EPERM;
-	if (!dir->i_op || !dir->i_op->link) return -EPERM;
-	if (S_ISDIR(old_dentry->d_inode->i_mode)) return -EPERM;
+	if (error)
+		return error;
+	if (dir->i_sb != inode->i_sb)
+		return -EXDEV;
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return -EPERM;
+	if (!dir->i_op || !dir->i_op->link)
+		return -EPERM;
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		return -EPERM;
 	return 0;
 }
 
+/* Permission checks before security_inode_symlink() is called. */
 static inline int pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
 {
 	int error = may_create(dir, dentry, NULL);
-	if (error) return error;
-	if (!dir->i_op || !dir->i_op->symlink) return -EPERM;
+	if (error)
+		return error;
+	if (!dir->i_op || !dir->i_op->symlink)
+		return -EPERM;
 	return 0;
 }
 
-static inline int pre_vfs_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
+/* Permission checks before security_inode_rename() is called. */
+static inline int pre_vfs_rename(struct inode *old_dir,
+				 struct dentry *old_dentry,
+				 struct inode *new_dir,
+				 struct dentry *new_dentry)
 {
-	int error = 0;
-	lock_kernel();
-	if (S_ISDIR(old_dentry->d_inode->i_mode) && new_dir != old_dir) error = permission(old_dentry->d_inode, MAY_WRITE, NULL);
-	unlock_kernel();
+	int error;
+	const int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
+	if (old_dentry->d_inode == new_dentry->d_inode)
+		return 0;
+	error = may_delete(old_dir, old_dentry, is_dir);
+	if (error)
+		return error;
+	if (!new_dentry->d_inode)
+		error = may_create(new_dir, new_dentry, NULL);
+	else
+		error = may_delete(new_dir, new_dentry, is_dir);
+	if (error)
+		return error;
+	if (!old_dir->i_op || !old_dir->i_op->rename)
+		return -EPERM;
+	if (is_dir && new_dir != old_dir)
+		error = permission(old_dentry->d_inode, MAY_WRITE, NULL);
 	return error;
 }
 
 #endif
 
-/***** TOMOYO Linux end. *****/
 #endif
Index: trunk/1.6.x/ccs-patch/include/linux/sakura.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/sakura.h	(revision 1045)
+++ trunk/1.6.x/ccs-patch/include/linux/sakura.h	(working copy)
@@ -15,12 +15,14 @@
  * A brief description about SAKURA:
  *
  *  SAKURA stands for "Security Advancement Know-how Upon Read-only Approach".
- *  As the name shows, SAKURA was originally a methodology to make root fs read-only
- *  to avoid tampering the system files.
+ *  As the name shows, SAKURA was originally a methodology to make root fs
+ *  read-only to avoid tampering the system files.
  *  But now, SAKURA is not only a methodology but also a kernel patch
  *  that improves the system security with less effort.
  *
  *  SAKURA can restrict operations that affect systemwide.
+ *  SAKURA manages the filesystem's namespace related operations so that
+ *  files remains where the administrator expects.
  */
 
 #ifndef _LINUX_SAKURA_H
@@ -30,38 +32,66 @@
 #define __user
 #endif
 
-/***** SAKURA Linux start. *****/
-
 #if defined(CONFIG_SAKURA)
 
 /* Check whether the given pathname is allowed to chroot to. */
-int CheckChRootPermission(struct nameidata *nd);
+int ccs_check_chroot_permission(struct nameidata *nd);
 
 /* Check whether the mount operation with the given parameters is allowed. */
-int CheckMountPermission(char *dev_name, char *dir_name, char *type, const unsigned long *flags);
+int ccs_check_mount_permission(char *dev_name, char *dir_name, char *type,
+			       const unsigned long *flags);
 
 /* Check whether the current process is allowed to pivot_root. */
-int CheckPivotRootPermission(struct nameidata *old_nd, struct nameidata *new_nd);
+int ccs_check_pivot_root_permission(struct nameidata *old_nd,
+				    struct nameidata *new_nd);
 
 /* Check whether the given mount operation hides an mounted partition. */
-int SAKURA_MayMount(struct nameidata *nd);
+int ccs_may_mount(struct nameidata *nd);
 
 /* Check whether the given mountpoint is allowed to umount. */
-int SAKURA_MayUmount(struct vfsmount *mnt);
+int ccs_may_umount(struct vfsmount *mnt);
 
 /* Check whether the given port is allowed to autobind. */
-int SAKURA_MayAutobind(const u16 port);
+int ccs_may_autobind(const u16 port);
 
 #else
 
-static inline int CheckChRootPermission(struct nameidata *nd) { return 0; }
-static inline int CheckMountPermission(char *dev_name, char *dir_name, char *type, const unsigned long *flags) { return 0; }
-static inline int CheckPivotRootPermission(struct nameidata *old_nd, struct nameidata *new_nd) { return 0; }
-static inline int SAKURA_MayMount(struct nameidata *nd) { return 0; }
-static inline int SAKURA_MayUmount(struct vfsmount *mnt) { return 0; }
-static inline int SAKURA_MayAutobind(const u16 port) { return 0; }
+static inline int ccs_check_chroot_permission(struct nameidata *nd)
+{
+	return 0;
+}
+static inline int ccs_check_mount_permission(char *dev_name, char *dir_name,
+					     char *type,
+					     const unsigned long *flags)
+{
+	return 0;
+}
+static inline int ccs_check_pivot_root_permission(struct nameidata *old_nd,
+						  struct nameidata *new_nd)
+{
+	return 0;
+}
+static inline int ccs_may_mount(struct nameidata *nd)
+{
+	return 0;
+}
+static inline int ccs_may_umount(struct vfsmount *mnt)
+{
+	return 0;
+}
+static inline int ccs_may_autobind(const u16 port)
+{
+	return 0;
+}
 
 #endif
 
-/***** SAKURA Linux end. *****/
+/* For compatibility with 1.4.x/1.5.x patches */
+#define CheckChRootPermission    ccs_check_chroot_permission
+#define SAKURA_MayUmount         ccs_may_umount
+#define SAKURA_MayMount          ccs_may_mount
+#define CheckMountPermission     ccs_check_mount_permission
+#define CheckPivotRootPermission ccs_check_pivot_root_permission
+#define SAKURA_MayAutobind       ccs_may_autobind
+
 #endif
Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(revision 1045)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(working copy)
@@ -22,18 +22,19 @@
  *  and dramatically reduces the policy definition labors.
  *
  *  TOMOYO is applicable to figuring out the system's behavior, for
- *  TOMOYO uses the canonicalized absolute pathnames and TreeView style domain transitions.
+ *  TOMOYO uses the canonicalized absolute pathnames and
+ *  TreeView style domain transitions.
  */
 
 #ifndef _LINUX_TOMOYO_H
 #define _LINUX_TOMOYO_H
 
+#include <linux/version.h>
+
 #ifndef __user
 #define __user
 #endif
 
-/***** TOMOYO Linux start. *****/
-
 struct path_info;
 struct dentry;
 struct vfsmount;
@@ -42,71 +43,160 @@
 struct pt_regs;
 struct ccs_page_buffer;
 
-#define CheckSingleWritePermission CheckSinglePathPermission
-#define CheckDoubleWritePermission CheckDoublePathPermission
-
 #if defined(CONFIG_TOMOYO)
 
-int CheckFilePerm(const char *filename, const u8 perm, const char *operation);
-int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm, struct ccs_page_buffer *buf);
-int CheckOpenPermission(struct dentry *dentry, struct vfsmount *mnt, const int flag);
-int CheckSinglePathPermission(const u8 operation, struct dentry *dentry, struct vfsmount *mnt);
-int CheckDoublePathPermission(const u8 operation, struct dentry *dentry1, struct vfsmount *mnt1, struct dentry *dentry2, struct vfsmount *mnt2);
-int CheckReWritePermission(struct file *filp);
+int ccs_check_file_perm(const char *filename, const u8 perm,
+			const char *operation);
+int ccs_check_exec_perm(const struct path_info *filename,
+			struct linux_binprm *bprm,
+			struct ccs_page_buffer *buf);
+int ccs_check_open_permission(struct dentry *dentry, struct vfsmount *mnt,
+			      const int flag);
+int ccs_check_single_path_permission(const u8 operation,
+				     struct dentry *dentry,
+				     struct vfsmount *mnt);
+int ccs_check_double_path_permission(const u8 operation,
+				     struct dentry *dentry1,
+				     struct vfsmount *mnt1,
+				     struct dentry *dentry2,
+				     struct vfsmount *mnt2);
+int ccs_check_rewrite_permission(struct file *filp);
 
 /* Check whether the basename of program and argv0 is allowed to differ. */
-int CheckArgv0Perm(const struct path_info *filename, const char *argv0);
+int ccs_check_argv0_perm(const struct path_info *filename, const char *argv0);
 
 /* Check whether the given environment is allowed to be received. */
-int CheckEnvPerm(const char *env, const u8 profile, const u8 mode);
+int ccs_check_env_perm(const char *env, const u8 profile, const u8 mode);
 
 /* Check whether the given IP address and port number are allowed to use. */
-int CheckNetworkListenACL(const _Bool is_ipv6, const u8 *address, const u16 port);
-int CheckNetworkConnectACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port);
-int CheckNetworkBindACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port);
-int CheckNetworkAcceptACL(const _Bool is_ipv6, const u8 *address, const u16 port);
-int CheckNetworkSendMsgACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port);
-int CheckNetworkRecvMsgACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port);
+int ccs_check_network_listen_acl(const _Bool is_ipv6, const u8 *address,
+				 const u16 port);
+int ccs_check_network_connect_acl(const _Bool is_ipv6, const int sock_type,
+				  const u8 *address, const u16 port);
+int ccs_check_network_bind_acl(const _Bool is_ipv6, const int sock_type,
+			       const u8 *address, const u16 port);
+int ccs_check_network_accept_acl(const _Bool is_ipv6, const u8 *address,
+				 const u16 port);
+int ccs_check_network_sendmsg_acl(const _Bool is_ipv6, const int sock_type,
+				  const u8 *address, const u16 port);
+int ccs_check_network_recvmsg_acl(const _Bool is_ipv6, const int sock_type,
+				  const u8 *address, const u16 port);
 
 /* Check whether the given signal is allowed to use. */
-int CheckSignalACL(const int sig, const int pid);
+int ccs_check_signal_acl(const int sig, const int pid);
 
 /* Check whether the given capability is allowed to use. */
-int CheckCapabilityACL(const u8 operation);
+int ccs_capable(const u8 operation);
 
 #else
 
-static inline int CheckFilePerm(const char *filename, const u8 perm, const char *operation) { return 0; }
-static inline int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm, struct ccs_page_buffer *buf)  { return 0; }
-static inline int CheckOpenPermission(struct dentry *dentry, struct vfsmount *mnt, const int flag) { return 0; }
-static inline int CheckSinglePathPermission(const u8 operation, struct dentry *dentry, struct vfsmount *mnt) { return 0; }
-static inline int CheckDoublePathPermission(const u8 operation, struct dentry *dentry1, struct vfsmount *mnt1, struct dentry *dentry2, struct vfsmount *mnt2) { return 0; }
-static inline int CheckReWritePermission(struct file *filp) { return 0; }
-static inline int CheckArgv0Perm(const struct path_info *filename, const char *argv0) { return 0; }
-static inline int CheckEnvPerm(const char *env, const u8 profile, const u8 mode) { return 0; }
-static inline int CheckNetworkListenACL(const _Bool is_ipv6, const u8 *address, const u16 port) { return 0; }
-static inline int CheckNetworkConnectACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port) { return 0; }
-static inline int CheckNetworkBindACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port) { return 0; }
-static inline int CheckNetworkAcceptACL(const _Bool is_ipv6, const u8 *address, const u16 port) { return 0; }
-static inline int CheckNetworkSendMsgACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port) { return 0; }
-static inline int CheckNetworkRecvMsgACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port) { return 0; }
-static inline int CheckSignalACL(const int sig, const int pid) { return 0; }
-static inline int CheckCapabilityACL(const u8 operation) { return 0; }
+static inline int ccs_check_file_perm(const char *filename, const u8 perm,
+				      const char *operation)
+{
+	return 0;
+}
+static inline int ccs_check_exec_perm(const struct path_info *filename,
+				      struct linux_binprm *bprm,
+				      struct ccs_page_buffer *buf)
+{
+	return 0;
+}
+static inline int ccs_check_open_permission(struct dentry *dentry,
+					    struct vfsmount *mnt,
+					    const int flag)
+{
+	return 0;
+}
+static inline int ccs_check_single_path_permission(const u8 operation,
+						   struct dentry *dentry,
+						   struct vfsmount *mnt)
+{
+	return 0;
+}
+static inline int ccs_check_double_path_permission(const u8 operation,
+						   struct dentry *dentry1,
+						   struct vfsmount *mnt1,
+						   struct dentry *dentry2,
+						   struct vfsmount *mnt2)
+{
+	return 0;
+}
+static inline int ccs_check_rewrite_permission(struct file *filp)
+{
+	return 0;
+}
+static inline int ccs_check_argv0_perm(const struct path_info *filename,
+				       const char *argv0)
+{
+	return 0;
+}
+static inline int ccs_check_env_perm(const char *env, const u8 profile,
+				     const u8 mode)
+{
+	return 0;
+}
+static inline int ccs_check_network_listen_acl(const _Bool is_ipv6,
+					       const u8 *address,
+					       const u16 port)
+{
+	return 0;
+}
+static inline int ccs_check_network_connect_acl(const _Bool is_ipv6,
+						const int sock_type,
+						const u8 *address,
+						const u16 port)
+{
+	return 0;
+}
+static inline int ccs_check_network_bind_acl(const _Bool is_ipv6,
+					     const int sock_type,
+					     const u8 *address, const u16 port)
+{
+	return 0;
+}
+static inline int ccs_check_network_accept_acl(const _Bool is_ipv6,
+					       const u8 *address,
+					       const u16 port)
+{
+	return 0;
+}
+static inline int ccs_check_network_sendmsg_acl(const _Bool is_ipv6,
+						const int sock_type,
+						const u8 *address,
+						const u16 port)
+{
+	return 0;
+}
+static inline int ccs_check_network_recvmsg_acl(const _Bool is_ipv6,
+						const int sock_type,
+						const u8 *address,
+						const u16 port)
+{
+	return 0;
+}
+static inline int ccs_check_signal_acl(const int sig, const int pid)
+{
+	return 0;
+}
+static inline int ccs_capable(const u8 operation)
+{
+	return 0;
+}
 
 #endif
 
-#include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 int pre_vfs_mknod(struct inode *dir, struct dentry *dentry);
 #else
 int pre_vfs_mknod(struct inode *dir, struct dentry *dentry, int mode);
 #endif
 
-int search_binary_handler_with_transition(struct linux_binprm *bprm, struct pt_regs *regs);
+int search_binary_handler_with_transition(struct linux_binprm *bprm,
+					  struct pt_regs *regs);
 #define TOMOYO_CHECK_READ_FOR_OPEN_EXEC 1
 #define CCS_DONT_SLEEP_ON_ENFORCE_ERROR 2
 
-/*************************  Index numbers for Access Controls.  *************************/
+/* Index numbers for Access Controls. */
 
 #define TYPE_SINGLE_PATH_ACL                 0
 #define TYPE_DOUBLE_PATH_ACL                 1
@@ -118,7 +208,7 @@
 #define TYPE_PREFERRED_EXECUTE_HANDLER       7
 #define TYPE_DEFAULT_EXECUTE_HANDLER         8
 
-/*************************  Index numbers for File Controls.  *************************/
+/* Index numbers for File Controls. */
 
 /*
  * TYPE_READ_WRITE_ACL is special. TYPE_READ_WRITE_ACL is automatically set
@@ -150,42 +240,73 @@
 #define TYPE_RENAME_ACL           1
 #define MAX_DOUBLE_PATH_OPERATION 2
 
-/*************************  Index numbers for Capability Controls.  *************************/
+/* Index numbers for Capability Controls. */
 
-#define TOMOYO_INET_STREAM_SOCKET_CREATE         0  /* socket(PF_INET or PF_INET6, SOCK_STREAM, *)                 */
-#define TOMOYO_INET_STREAM_SOCKET_LISTEN         1  /* listen() for PF_INET or PF_INET6, SOCK_STREAM               */
-#define TOMOYO_INET_STREAM_SOCKET_CONNECT        2  /* connect() for PF_INET or PF_INET6, SOCK_STREAM              */
-#define TOMOYO_USE_INET_DGRAM_SOCKET             3  /* socket(PF_INET or PF_INET6, SOCK_DGRAM, *)                  */
-#define TOMOYO_USE_INET_RAW_SOCKET               4  /* socket(PF_INET or PF_INET6, SOCK_RAW, *)                    */
-#define TOMOYO_USE_ROUTE_SOCKET                  5  /* socket(PF_ROUTE, *, *)                                      */
-#define TOMOYO_USE_PACKET_SOCKET                 6  /* socket(PF_PACKET, *, *)                                     */
-#define TOMOYO_SYS_MOUNT                         7  /* sys_mount()                                                 */
-#define TOMOYO_SYS_UMOUNT                        8  /* sys_umount()                                                */
-#define TOMOYO_SYS_REBOOT                        9  /* sys_reboot()                                                */
-#define TOMOYO_SYS_CHROOT                       10  /* sys_chroot()                                                */
-#define TOMOYO_SYS_KILL                         11  /* sys_kill(), sys_tkill(), sys_tgkill()                       */
-#define TOMOYO_SYS_VHANGUP                      12  /* sys_vhangup()                                               */
-#define TOMOYO_SYS_SETTIME                      13  /* do_settimeofday(), sys_adjtimex()                           */
-#define TOMOYO_SYS_NICE                         14  /* sys_nice(), sys_setpriority()                               */
-#define TOMOYO_SYS_SETHOSTNAME                  15  /* sys_sethostname(), sys_setdomainname()                      */
-#define TOMOYO_USE_KERNEL_MODULE                16  /* sys_create_module(), sys_init_module(), sys_delete_module() */
-#define TOMOYO_CREATE_FIFO                      17  /* sys_mknod(S_IFIFO)                                          */
-#define TOMOYO_CREATE_BLOCK_DEV                 18  /* sys_mknod(S_IFBLK)                                          */
-#define TOMOYO_CREATE_CHAR_DEV                  19  /* sys_mknod(S_IFCHR)                                          */
-#define TOMOYO_CREATE_UNIX_SOCKET               20  /* sys_mknod(S_IFSOCK)                                         */
-#define TOMOYO_SYS_LINK                         21  /* sys_link()                                                  */
-#define TOMOYO_SYS_SYMLINK                      22  /* sys_symlink()                                               */
-#define TOMOYO_SYS_RENAME                       23  /* sys_rename()                                                */
-#define TOMOYO_SYS_UNLINK                       24  /* sys_unlink()                                                */
-#define TOMOYO_SYS_CHMOD                        25  /* sys_chmod(), sys_fchmod()                                   */
-#define TOMOYO_SYS_CHOWN                        26  /* sys_chown(), sys_fchown(), sys_lchown()                     */
-#define TOMOYO_SYS_IOCTL                        27  /* sys_ioctl(), compat_sys_ioctl()                             */
-#define TOMOYO_SYS_KEXEC_LOAD                   28  /* sys_kexec_load()                                            */
-#define TOMOYO_SYS_PIVOT_ROOT                   29  /* sys_pivot_root()                                            */
-#define TOMOYO_SYS_PTRACE                       30  /* sys_ptrace()                                                */
+/* socket(PF_INET or PF_INET6, SOCK_STREAM, *)                 */
+#define TOMOYO_INET_STREAM_SOCKET_CREATE         0
+/* listen() for PF_INET or PF_INET6, SOCK_STREAM               */
+#define TOMOYO_INET_STREAM_SOCKET_LISTEN         1
+/* connect() for PF_INET or PF_INET6, SOCK_STREAM              */
+#define TOMOYO_INET_STREAM_SOCKET_CONNECT        2
+/* socket(PF_INET or PF_INET6, SOCK_DGRAM, *)                  */
+#define TOMOYO_USE_INET_DGRAM_SOCKET             3
+/* socket(PF_INET or PF_INET6, SOCK_RAW, *)                    */
+#define TOMOYO_USE_INET_RAW_SOCKET               4
+/* socket(PF_ROUTE, *, *)                                      */
+#define TOMOYO_USE_ROUTE_SOCKET                  5
+/* socket(PF_PACKET, *, *)                                     */
+#define TOMOYO_USE_PACKET_SOCKET                 6
+/* sys_mount()                                                 */
+#define TOMOYO_SYS_MOUNT                         7
+/* sys_umount()                                                */
+#define TOMOYO_SYS_UMOUNT                        8
+/* sys_reboot()                                                */
+#define TOMOYO_SYS_REBOOT                        9
+/* sys_chroot()                                                */
+#define TOMOYO_SYS_CHROOT                       10
+/* sys_kill(), sys_tkill(), sys_tgkill()                       */
+#define TOMOYO_SYS_KILL                         11
+/* sys_vhangup()                                               */
+#define TOMOYO_SYS_VHANGUP                      12
+/* do_settimeofday(), sys_adjtimex()                           */
+#define TOMOYO_SYS_SETTIME                      13
+/* sys_nice(), sys_setpriority()                               */
+#define TOMOYO_SYS_NICE                         14
+/* sys_sethostname(), sys_setdomainname()                      */
+#define TOMOYO_SYS_SETHOSTNAME                  15
+/* sys_create_module(), sys_init_module(), sys_delete_module() */
+#define TOMOYO_USE_KERNEL_MODULE                16
+/* sys_mknod(S_IFIFO)                                          */
+#define TOMOYO_CREATE_FIFO                      17
+/* sys_mknod(S_IFBLK)                                          */
+#define TOMOYO_CREATE_BLOCK_DEV                 18
+/* sys_mknod(S_IFCHR)                                          */
+#define TOMOYO_CREATE_CHAR_DEV                  19
+/* sys_mknod(S_IFSOCK)                                         */
+#define TOMOYO_CREATE_UNIX_SOCKET               20
+/* sys_link()                                                  */
+#define TOMOYO_SYS_LINK                         21
+/* sys_symlink()                                               */
+#define TOMOYO_SYS_SYMLINK                      22
+/* sys_rename()                                                */
+#define TOMOYO_SYS_RENAME                       23
+/* sys_unlink()                                                */
+#define TOMOYO_SYS_UNLINK                       24
+/* sys_chmod(), sys_fchmod()                                   */
+#define TOMOYO_SYS_CHMOD                        25
+/* sys_chown(), sys_fchown(), sys_lchown()                     */
+#define TOMOYO_SYS_CHOWN                        26
+/* sys_ioctl(), compat_sys_ioctl()                             */
+#define TOMOYO_SYS_IOCTL                        27
+/* sys_kexec_load()                                            */
+#define TOMOYO_SYS_KEXEC_LOAD                   28
+/* sys_pivot_root()                                            */
+#define TOMOYO_SYS_PIVOT_ROOT                   29
+/* sys_ptrace()                                                */
+#define TOMOYO_SYS_PTRACE                       30
 #define TOMOYO_MAX_CAPABILITY_INDEX             31
 
-/*************************  Index numbers for Network Controls.  *************************/
+/* Index numbers for Network Controls. */
 
 #define NETWORK_ACL_UDP_BIND    0
 #define NETWORK_ACL_UDP_CONNECT 1
@@ -196,5 +317,13 @@
 #define NETWORK_ACL_RAW_BIND    6
 #define NETWORK_ACL_RAW_CONNECT 7
 
-/***** TOMOYO Linux end. *****/
+/* For compatibility with 1.4.x/1.5.x patches */
+#define CheckSingleWritePermission ccs_check_single_path_permission
+#define CheckDoubleWritePermission ccs_check_double_path_permission
+#define CheckCapabilityACL         ccs_capable
+#define CheckFilePerm              ccs_check_file_perm
+#define CheckSignalACL             ccs_check_signal_acl
+#define CheckOpenPermission        ccs_check_open_permission
+#define CheckReWritePermission     ccs_check_rewrite_permission
+
 #endif
Index: trunk/1.6.x/ccs-patch/README.ccs
===================================================================
--- trunk/1.6.x/ccs-patch/README.ccs	(revision 1045)
+++ trunk/1.6.x/ccs-patch/README.ccs	(working copy)
@@ -1326,3 +1326,13 @@
 
       This keyword is designed for handling unexpected/undesirable execve()
       requests, to redirect the process issuing such requests to somewhere.
+
+Fix 2008/03/18
+
+    @ Fix wrong/redundant locks in pre-vfs functions.
+
+      lock_kernel()/unlock_kernel() in pre_vfs_rename() were redundant for
+      2.6 kernels.
+
+      Locking order in pre_vfs_link() and pre_vfs_unlink() for 2.4 kernels
+      after 2.4.33 were different from before 2.4.32 .
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_env.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_env.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_env.c	(working copy)
@@ -11,26 +11,41 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** TOMOYO Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/tomoyo.h>
 #include <linux/realpath.h>
 
-/*************************  AUDIT FUNCTIONS  *************************/
+/* Auditing functions. */
 
-static int AuditEnvLog(const char *env, const bool is_granted, const u8 profile, const u8 mode)
+/**
+ * audit_env_log -
+ *
+ * @env:        The name of environment variable.
+ * @is_granted: True if this is a granted log.
+ * @profile:    Profile number.
+ * @mode:       Access control mode.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int audit_env_log(const char *env, const bool is_granted,
+			 const u8 profile, const u8 mode)
 {
 	char *buf;
 	int len;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
+	int len2;
+	if (ccs_can_save_audit_log(is_granted) < 0)
+		return -ENOMEM;
 	len = strlen(env) + 8;
-	if ((buf = InitAuditLog(&len, profile, mode, NULL)) == NULL) return -ENOMEM;
-	snprintf(buf + strlen(buf), len - strlen(buf) - 1, KEYWORD_ALLOW_ENV "%s\n", env);
-	return WriteAuditLog(buf, is_granted);
+	buf = ccs_init_audit_log(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
+	len2 = strlen(buf);
+	snprintf(buf + len2, len - len2 - 1, KEYWORD_ALLOW_ENV "%s\n", env);
+	return ccs_write_audit_log(buf, is_granted);
 }
 
-/***** The structure for globally usable environments. *****/
+/* The structure for globally usable environments. */
 
 struct globally_usable_env_entry {
 	struct list1_head list;
@@ -38,18 +53,30 @@
 	bool is_deleted;
 };
 
-/*************************  GLOBALLY USABLE ENVIRONMENT HANDLER  *************************/
+/* "allow_env" handler. */
 
 static LIST1_HEAD(globally_usable_env_list);
 
-static int AddGloballyUsableEnvEntry(const char *env, const bool is_delete)
+/**
+ * update_globally_usable_env_entry -
+ *
+ * @env:       The name of environment variable.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_globally_usable_env_entry(const char *env,
+					    const bool is_delete)
 {
 	struct globally_usable_env_entry *new_entry, *ptr;
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_env;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(env, 0, 0, 0, __FUNCTION__)) return -EINVAL;
-	if ((saved_env = SaveName(env)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(env, 0, 0, 0, __func__))
+		return -EINVAL;
+	saved_env = ccs_save_name(env);
+	if (!saved_env)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &globally_usable_env_list, list) {
 		if (ptr->env == saved_env) {
@@ -59,127 +86,220 @@
 		}
 	}
 	if (is_delete) {
-		error = -ENOENT; goto out;
+		error = -ENOENT;
+		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->env = saved_env;
 	list1_add_tail_mb(&new_entry->list, &globally_usable_env_list);
 	error = 0;
- out: ;
+ out:
 	mutex_unlock(&lock);
 	return error;
 }
 
-static bool IsGloballyUsableEnv(const struct path_info *env)
+/**
+ * is_globally_usable_env -
+ *
+ * @env: The name of environment variable.
+ *
+ * Returns true if @env is globally permitted environment variable's name,
+ * false otherwise.
+ */
+static bool is_globally_usable_env(const struct path_info *env)
 {
 	struct globally_usable_env_entry *ptr;
 	list1_for_each_entry(ptr, &globally_usable_env_list, list) {
-		if (!ptr->is_deleted && PathMatchesToPattern(env, ptr->env)) return true;
+		if (!ptr->is_deleted && ccs_path_matches_pattern(env, ptr->env))
+			return true;
 	}
 	return false;
 }
 
-int AddGloballyUsableEnvPolicy(char *env, const bool is_delete)
+/**
+ * ccs_write_globally_usable_env_policy -
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_globally_usable_env_policy(char *data, const bool is_delete)
 {
-	return AddGloballyUsableEnvEntry(env, is_delete);
+	return update_globally_usable_env_entry(data, is_delete);
 }
 
-int ReadGloballyUsableEnvPolicy(struct io_buffer *head)
+/**
+ * ccs_read_globally_usable_env_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, false otherwise.
+ */
+bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &globally_usable_env_list) {
+	list1_for_each_cookie(pos, head->read_var2,
+			      &globally_usable_env_list) {
 		struct globally_usable_env_entry *ptr;
 		ptr = list1_entry(pos, struct globally_usable_env_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALLOW_ENV "%s\n", ptr->env->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, KEYWORD_ALLOW_ENV "%s\n",
+				   ptr->env->name))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
 
-/*************************  ENVIRONMENT VARIABLE CHECKING HANDLER  *************************/
+/* "allow_env" handler. */
 
-static int AddEnvEntry(const char *env, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * update_env_entry -
+ *
+ * @env:       The name of environment variable.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_env_entry(const char *env, struct domain_info *domain,
+			    const struct condition_list *condition,
+			    const bool is_delete)
 {
 	struct acl_info *ptr;
 	struct env_acl_record *acl;
 	const struct path_info *saved_env;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(env, 0, 0, 0, __FUNCTION__)) return -EINVAL;
-	if ((saved_env = SaveName(env)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(env, 0, 0, 0, __func__))
+		return -EINVAL;
+	saved_env = ccs_save_name(env);
+	if (!saved_env)
+		return -ENOMEM;
 
 	mutex_lock(&domain_acl_lock);
-	if (!is_delete) {
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_ENV_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct env_acl_record, head);
-			if (acl->env != saved_env) continue;
-			error = AddDomainACL(NULL, ptr);
-			goto out;
-		}
-		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_ENV_ACL, condition)) == NULL) goto out;
-		acl->env = saved_env;
-		error = AddDomainACL(domain, &acl->head);
-	} else {
-		error = -ENOENT;
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ENV_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct env_acl_record, head);
-			if (acl->env != saved_env) continue;
-			error = DelDomainACL(ptr);
-			break;
-		}
+	if (is_delete)
+		goto delete;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION))
+		    != TYPE_ENV_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct env_acl_record, head);
+		if (acl->env != saved_env)
+			continue;
+		error = ccs_add_domain_acl(NULL, ptr);
+		goto out;
 	}
- out: ;
+	/* Not found. Append it to the tail. */
+	acl = ccs_alloc_acl_element(TYPE_ENV_ACL, condition);
+	if (!acl)
+		goto out;
+	acl->env = saved_env;
+	error = ccs_add_domain_acl(domain, &acl->head);
+	goto out;
+ delete:
+	error = -ENOENT;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ENV_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct env_acl_record, head);
+		if (acl->env != saved_env)
+			continue;
+		error = ccs_del_domain_acl(ptr);
+		break;
+	}
+ out:
 	mutex_unlock(&domain_acl_lock);
 	return error;
 }
 
-static int CheckEnvACL(const char *env_)
+/**
+ * check_env_acl -
+ *
+ * @environ: The name of environment variable.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int check_env_acl(const char *environ)
 {
 	const struct domain_info *domain = current->domain_info;
 	int error = -EPERM;
 	struct acl_info *ptr;
 	struct path_info env;
-	env.name = env_;
-	fill_path_info(&env);
-
+	env.name = environ;
+	ccs_fill_path_info(&env);
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct env_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ENV_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ENV_ACL)
+			continue;
 		acl = container_of(ptr, struct env_acl_record, head);
-		if (!CheckCondition(ptr, NULL) ||
-		    !PathMatchesToPattern(&env, acl->env)) continue;
-		UpdateCondition(ptr);
+		if (!ccs_check_condition(ptr, NULL) ||
+		    !ccs_path_matches_pattern(&env, acl->env))
+			continue;
+		ccs_update_condition(ptr);
 		error = 0;
 		break;
 	}
-	if (error && (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV) == 0 && IsGloballyUsableEnv(&env)) error = 0;
+	if (error &&
+	    (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV) == 0 &&
+	    is_globally_usable_env(&env))
+		error = 0;
 	return error;
 }
 
-int CheckEnvPerm(const char *env, const u8 profile, const u8 mode)
+/**
+ * ccs_check_env_perm -
+ *
+ * @env:     The name of environment variable.
+ * @profile: Profile number.
+ * @mode:    Access control mode.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_env_perm(const char *env, const u8 profile, const u8 mode)
 {
 	int error = 0;
 	struct domain_info * const domain = current->domain_info;
 	const bool is_enforce = (mode == 3);
-	if (!env || !*env) return 0;
-	error = CheckEnvACL(env);
-	AuditEnvLog(env, !error, profile, mode);
-	if (!error) return 0;
-	if (TomoyoVerboseMode()) {
-		printk("TOMOYO-%s: Environ %s denied for %s\n", GetMSG(is_enforce), env, GetLastName(domain));
-	}
-	if (is_enforce) return CheckSupervisor("%s\n" KEYWORD_ALLOW_ENV "%s\n", domain->domainname->name, env);
-	else if (mode == 1 && CheckDomainQuota(domain)) AddEnvEntry(env, domain, NULL, 0);
+	if (!env || !*env)
+		return 0;
+	error = check_env_acl(env);
+	audit_env_log(env, !error, profile, mode);
+	if (!error)
+		return 0;
+	if (ccs_verbose_mode())
+		printk(KERN_WARNING "TOMOYO-%s: Environ %s denied for %s\n",
+		       ccs_get_msg(is_enforce), env, ccs_get_last_name(domain));
+	if (is_enforce)
+		return ccs_check_supervisor("%s\n" KEYWORD_ALLOW_ENV "%s\n",
+					    domain->domainname->name, env);
+	else if (mode == 1 && ccs_check_domain_quota(domain))
+		update_env_entry(env, domain, NULL, false);
 	return 0;
 }
 
-int AddEnvPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * ccs_write_env_policy -
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_env_policy(char *data, struct domain_info *domain,
+			 const struct condition_list *condition,
+			 const bool is_delete)
 {
-	return AddEnvEntry(data, domain, condition, is_delete);
+	return update_env_entry(data, domain, condition, is_delete);
 }
-
-/***** TOMOYO Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_network.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_network.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_network.c	(working copy)
@@ -11,36 +11,68 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** TOMOYO Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/tomoyo.h>
 #include <linux/realpath.h>
 #include <net/ip.h>
 
-/*************************  AUDIT FUNCTIONS  *************************/
+/* Auditing functions. */
 
-static int AuditNetworkLog(const bool is_ipv6, const char *operation, const u32 *address, const u16 port, const bool is_granted, const u8 profile, const u8 mode)
+/**
+ * audit_network_log -
+ *
+ * @is_ipv6:    True if @address is an IPv6 address.
+ * @operation:  The name of operation.
+ * @address:    An IPv4 or IPv6 address.
+ * @port:       Port number.
+ * @is_granted: True if this is a granted log.
+ * @profile:    Profile number.
+ * @mode:       Access control mode.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int audit_network_log(const bool is_ipv6, const char *operation,
+			     const u32 *address, const u16 port,
+			     const bool is_granted, const u8 profile,
+			     const u8 mode)
 {
 	char *buf;
-	int len = 256;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
-	if ((buf = InitAuditLog(&len, profile, mode, NULL)) == NULL) return -ENOMEM;
-	snprintf(buf + strlen(buf), len - strlen(buf) - 1, KEYWORD_ALLOW_NETWORK "%s ", operation);
+	int len = 256, len2;
+	if (ccs_can_save_audit_log(is_granted) < 0)
+		return -ENOMEM;
+	buf = ccs_init_audit_log(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
+	len2 = strlen(buf);
+	snprintf(buf + len2, len - len2 - 1, KEYWORD_ALLOW_NETWORK "%s ",
+		 operation);
+	len2 = strlen(buf);
 	if (is_ipv6) {
-		print_ipv6(buf + strlen(buf), len - strlen(buf), (const struct in6_addr *) address);
+		ccs_print_ipv6(buf + len2, len - len2,
+			       (const struct in6_addr *) address);
 	} else {
 		u32 ip = *address;
-		snprintf(buf + strlen(buf), len - strlen(buf) - 1, "%u.%u.%u.%u", NIPQUAD(ip));
+		snprintf(buf + len2, len - len2 - 1, "%u.%u.%u.%u",
+			 NIPQUAD(ip));
 	}
-	snprintf(buf + strlen(buf), len - strlen(buf) - 1, " %u\n", port);
-	return WriteAuditLog(buf, is_granted);
+	len2 = strlen(buf);
+	snprintf(buf + len2, len - len2 - 1, " %u\n", port);
+	return ccs_write_audit_log(buf, is_granted);
 }
 
-/*************************  UTILITY FUNCTIONS  *************************/
+/* Utility functions. */
 
-/* Keep the given IPv6 address on the RAM. The RAM is shared, so NEVER try to modify or kfree() the returned address. */
-static const struct in6_addr *SaveIPv6Address(const struct in6_addr *addr)
+/**
+ * save_ipv6_address - Keep the given IPv6 address on the RAM.
+ *
+ * @addr: Pointer to "struct in6_addr".
+ *
+ * Returns pointer to "struct in6_addr" on success, NULL otherwise.
+ *
+ * The RAM is shared, so NEVER try to modify or kfree() the returned address.
+ */
+static const struct in6_addr *save_ipv6_address(const struct in6_addr *addr)
 {
 	static const u8 block_size = 16;
 	struct addr_list {
@@ -52,54 +84,91 @@
 	struct addr_list *ptr;
 	static DEFINE_MUTEX(lock);
 	u8 i = block_size;
-	if (!addr) return NULL;
+	if (!addr)
+		return NULL;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &address_list, list) {
 		for (i = 0; i < ptr->in_use_count; i++) {
-			if (memcmp(&ptr->addr[i], addr, sizeof(*addr)) == 0) goto ok;
+			if (memcmp(&ptr->addr[i], addr, sizeof(*addr)) == 0)
+				goto ok;
 		}
-		if (i < block_size) break;
+		if (i < block_size)
+			break;
 	}
 	if (i == block_size) {
-		ptr = alloc_element(sizeof(*ptr));
-		if (!ptr) goto ok;
+		ptr = ccs_alloc_element(sizeof(*ptr));
+		if (!ptr)
+			goto ok;
 		list1_add_tail_mb(&ptr->list, &address_list);
 		i = 0;
 	}
 	ptr->addr[ptr->in_use_count++] = *addr;
-ok:
+ ok:
 	mutex_unlock(&lock);
 	return ptr ? &ptr->addr[i] : NULL;
 }
 
-/*************************  ADDRESS GROUP HANDLER  *************************/
+/* "address_group" handler. */
 
+/* The list for "struct address_group_entry". */
 static LIST1_HEAD(address_group_list);
 
-static int AddAddressGroupEntry(const char *group_name, const bool is_ipv6, const u16 *min_address, const u16 *max_address, const bool is_delete)
+/**
+ * update_address_group_entry -
+ *
+ * @group_name:  The name of group.
+ * @is_ipv6:     True if @address is an IPv6 address.
+ * @min_address: Start of IPv4 or IPv6 address range.
+ * @max_address: End of IPv4 or IPv6 address range.
+ * @is_delete:   True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_address_group_entry(const char *group_name,
+				      const bool is_ipv6,
+				      const u16 *min_address,
+				      const u16 *max_address,
+				      const bool is_delete)
 {
 	static DEFINE_MUTEX(lock);
 	struct address_group_entry *new_group, *group;
 	struct address_group_member *new_member, *member;
 	const struct path_info *saved_group_name;
-	const struct in6_addr *saved_min_address = NULL, *saved_max_address = NULL;
+	const struct in6_addr *saved_min_address = NULL;
+	const struct in6_addr *saved_max_address = NULL;
 	int error = -ENOMEM;
 	bool found = false;
-	if (!IsCorrectPath(group_name, 0, 0, 0, __FUNCTION__) || !group_name[0]) return -EINVAL;
-	if ((saved_group_name = SaveName(group_name)) == NULL) return -ENOMEM;
-	if (is_ipv6) {
-		if ((saved_min_address = SaveIPv6Address((struct in6_addr *) min_address)) == NULL
-		    || (saved_max_address = SaveIPv6Address((struct in6_addr *) max_address)) == NULL) return -ENOMEM;
-	}
+	if (!ccs_is_correct_path(group_name, 0, 0, 0, __func__) ||
+	    !group_name[0])
+		return -EINVAL;
+	saved_group_name = ccs_save_name(group_name);
+	if (!saved_group_name)
+		return -ENOMEM;
+	if (!is_ipv6)
+		goto not_ipv6;
+	saved_min_address
+		= save_ipv6_address((struct in6_addr *) min_address);
+	saved_max_address
+		= save_ipv6_address((struct in6_addr *) max_address);
+	if (!saved_min_address || !saved_max_address)
+		return -ENOMEM;
+ not_ipv6:
 	mutex_lock(&lock);
 	list1_for_each_entry(group, &address_group_list, list) {
-		if (saved_group_name != group->group_name) continue;
-		list1_for_each_entry(member, &group->address_group_member_list, list) {
-			if (member->is_ipv6 != is_ipv6) continue;
+		if (saved_group_name != group->group_name)
+			continue;
+		list1_for_each_entry(member, &group->address_group_member_list,
+				     list) {
+			if (member->is_ipv6 != is_ipv6)
+				continue;
 			if (is_ipv6) {
-				if (member->min.ipv6 != saved_min_address || member->max.ipv6 != saved_max_address) continue;
+				if (member->min.ipv6 != saved_min_address ||
+				    member->max.ipv6 != saved_max_address)
+					continue;
 			} else {
-				if (member->min.ipv4 != * (u32 *) min_address || member->max.ipv4 != * (u32 *) max_address) continue;
+				if (member->min.ipv4 != *(u32 *) min_address ||
+				    member->max.ipv4 != *(u32 *) max_address)
+					continue;
 			}
 			member->is_deleted = is_delete;
 			error = 0;
@@ -113,20 +182,24 @@
 		goto out;
 	}
 	if (!found) {
-		if ((new_group = alloc_element(sizeof(*new_group))) == NULL) goto out;
+		new_group = ccs_alloc_element(sizeof(*new_group));
+		if (!new_group)
+			goto out;
 		INIT_LIST1_HEAD(&new_group->address_group_member_list);
 		new_group->group_name = saved_group_name;
 		list1_add_tail_mb(&new_group->list, &address_group_list);
 		group = new_group;
 	}
-	if ((new_member = alloc_element(sizeof(*new_member))) == NULL) goto out;
+	new_member = ccs_alloc_element(sizeof(*new_member));
+	if (!new_member)
+		goto out;
 	new_member->is_ipv6 = is_ipv6;
 	if (is_ipv6) {
 		new_member->min.ipv6 = saved_min_address;
 		new_member->max.ipv6 = saved_max_address;
 	} else {
-		new_member->min.ipv4 = * (u32 *) min_address;
-		new_member->max.ipv4 = * (u32 *) max_address;
+		new_member->min.ipv4 = *(u32 *) min_address;
+		new_member->max.ipv4 = *(u32 *) max_address;
 	}
 	list1_add_tail_mb(&new_member->list, &group->address_group_member_list);
 	error = 0;
@@ -135,129 +208,229 @@
 	return error;
 }
 
-int AddAddressGroupPolicy(char *data, const bool is_delete)
+/**
+ * ccs_write_address_group_policy -
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_address_group_policy(char *data, const bool is_delete)
 {
 	u8 count;
 	bool is_ipv6;
 	u16 min_address[8], max_address[8];
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
-	if ((count = sscanf(cp, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
-			    &min_address[0], &min_address[1], &min_address[2], &min_address[3],
-			    &min_address[4], &min_address[5], &min_address[6], &min_address[7],
-			    &max_address[0], &max_address[1], &max_address[2], &max_address[3],
-			    &max_address[4], &max_address[5], &max_address[6], &max_address[7])) == 8 || count == 16) {
+	count = sscanf(cp, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx"
+		       "-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
+		       &min_address[0], &min_address[1],
+		       &min_address[2], &min_address[3],
+		       &min_address[4], &min_address[5],
+		       &min_address[6], &min_address[7],
+		       &max_address[0], &max_address[1],
+		       &max_address[2], &max_address[3],
+		       &max_address[4], &max_address[5],
+		       &max_address[6], &max_address[7]);
+	if (count == 8 || count == 16) {
 		u8 i;
 		for (i = 0; i < 8; i++) {
 			min_address[i] = htons(min_address[i]);
 			max_address[i] = htons(max_address[i]);
 		}
-		if (count == 8) memmove(max_address, min_address, sizeof(min_address));
+		if (count == 8)
+			memmove(max_address, min_address, sizeof(min_address));
 		is_ipv6 = true;
-	} else if ((count = sscanf(cp, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
-				   &min_address[0], &min_address[1], &min_address[2], &min_address[3],
-				   &max_address[0], &max_address[1], &max_address[2], &max_address[3])) == 4 || count == 8) {
-		u32 ip = ((((u8) min_address[0]) << 24) + (((u8) min_address[1]) << 16) + (((u8) min_address[2]) << 8) + (u8) min_address[3]);
-		* (u32 *) min_address = ip;
-		if (count == 8) ip = ((((u8) max_address[0]) << 24) + (((u8) max_address[1]) << 16) + (((u8) max_address[2]) << 8) + (u8) max_address[3]);
-		* (u32 *) max_address = ip;
+		goto ok;
+	}
+	count = sscanf(cp, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
+		       &min_address[0], &min_address[1],
+		       &min_address[2], &min_address[3],
+		       &max_address[0], &max_address[1],
+		       &max_address[2], &max_address[3]);
+	if (count == 4 || count == 8) {
+		u32 ip = ((((u8) min_address[0]) << 24)
+			  + (((u8) min_address[1]) << 16)
+			  + (((u8) min_address[2]) << 8)
+			  + (u8) min_address[3]);
+		*(u32 *) min_address = ip;
+		if (count == 8)
+			ip = ((((u8) max_address[0]) << 24)
+			      + (((u8) max_address[1]) << 16)
+			      + (((u8) max_address[2]) << 8)
+			      + (u8) max_address[3]);
+		*(u32 *) max_address = ip;
 		is_ipv6 = false;
 	} else {
 		return -EINVAL;
 	}
-	return AddAddressGroupEntry(data, is_ipv6, min_address, max_address, is_delete);
+ ok:
+	return update_address_group_entry(data, is_ipv6,
+					  min_address, max_address, is_delete);
 }
 
-static struct address_group_entry *FindOrAssignNewAddressGroup(const char *group_name)
+/**
+ * find_or_assign_new_address_group -
+ *
+ * @group_name: The name of group.
+ *
+ * Returns pointer to "struct address_group_entry" on success, NULL otherwise.
+ */
+static struct address_group_entry *
+find_or_assign_new_address_group(const char *group_name)
 {
 	u8 i;
 	struct address_group_entry *group;
 	for (i = 0; i <= 1; i++) {
 		list1_for_each_entry(group, &address_group_list, list) {
-			if (strcmp(group_name, group->group_name->name) == 0) return group;
+			if (strcmp(group_name, group->group_name->name) == 0)
+				return group;
 		}
 		if (i == 0) {
 			const u16 dummy[2] = { 0, 0 };
-			AddAddressGroupEntry(group_name, 0, dummy, dummy, 0);
-			AddAddressGroupEntry(group_name, 0, dummy, dummy, 1);
+			update_address_group_entry(group_name, false,
+						   dummy, dummy, false);
+			update_address_group_entry(group_name, false,
+						   dummy, dummy, true);
 		}
 	}
 	return NULL;
 }
 
-static bool AddressMatchesToGroup(const bool is_ipv6, const u32 *address, const struct address_group_entry *group)
+/**
+ * address_matches_to_group -
+ *
+ * @is_ipv6: True if @address is an IPv6 address.
+ * @address: An IPv4 or IPv6 address.
+ * @group:   Pointer to "struct address_group_entry".
+ *
+ * Returns true if @address matches addresses in @group group, false otherwise.
+ */
+static bool address_matches_to_group(const bool is_ipv6, const u32 *address,
+				     const struct address_group_entry *group)
 {
 	struct address_group_member *member;
 	const u32 ip = ntohl(*address);
 	list1_for_each_entry(member, &group->address_group_member_list, list) {
-		if (member->is_deleted) continue;
+		if (member->is_deleted)
+			continue;
 		if (member->is_ipv6) {
-			if (is_ipv6 && memcmp(member->min.ipv6, address, 16) <= 0 && memcmp(address, member->max.ipv6, 16) <= 0) return true;
+			if (is_ipv6 &&
+			    memcmp(member->min.ipv6, address, 16) <= 0 &&
+			    memcmp(address, member->max.ipv6, 16) <= 0)
+				return true;
 		} else {
-			if (!is_ipv6 && member->min.ipv4 <= ip && ip <= member->max.ipv4) return true;
+			if (!is_ipv6 &&
+			    member->min.ipv4 <= ip && ip <= member->max.ipv4)
+				return true;
 		}
 	}
 	return false;
 }
 
-int ReadAddressGroupPolicy(struct io_buffer *head)
+/**
+ * ccs_read_address_group_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_address_group_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *gpos;
 	struct list1_head *mpos;
 	list1_for_each_cookie(gpos, head->read_var1, &address_group_list) {
 		struct address_group_entry *group;
 		group = list1_entry(gpos, struct address_group_entry, list);
-		list1_for_each_cookie(mpos, head->read_var2, &group->address_group_member_list) {
+		list1_for_each_cookie(mpos, head->read_var2,
+				      &group->address_group_member_list) {
 			char buf[128];
 			struct address_group_member *member;
-			member = list1_entry(mpos, struct address_group_member, list);
-			if (member->is_deleted) continue;
-			if (member->is_ipv6) {
-				const struct in6_addr *min_address = member->min.ipv6, *max_address = member->max.ipv6;
-				print_ipv6(buf, sizeof(buf), min_address);
+			member = list1_entry(mpos, struct address_group_member,
+					     list);
+			if (member->is_deleted)
+				continue;
+			if (!member->is_ipv6) {
+				const struct in6_addr *min_address
+					= member->min.ipv6;
+				const struct in6_addr *max_address
+					= member->max.ipv6;
+				ccs_print_ipv6(buf, sizeof(buf), min_address);
 				if (min_address != max_address) {
+					int len;
 					char *cp = strchr(buf, '\0');
 					*cp++ = '-';
-					print_ipv6(cp, sizeof(buf) - strlen(buf), max_address);
+					len = strlen(buf);
+					ccs_print_ipv6(cp, sizeof(buf) - len,
+						       max_address);
 				}
 			} else {
-				const u32 min_address = member->min.ipv4, max_address = member->max.ipv4;
+				const u32 min_address = member->min.ipv4;
+				const u32 max_address = member->max.ipv4;
 				memset(buf, 0, sizeof(buf));
-				snprintf(buf, sizeof(buf) - 1, "%u.%u.%u.%u", HIPQUAD(min_address));
+				snprintf(buf, sizeof(buf) - 1, "%u.%u.%u.%u",
+					 HIPQUAD(min_address));
 				if (min_address != max_address) {
 					const int len = strlen(buf);
-					snprintf(buf + len, sizeof(buf) - 1 - len, "-%u.%u.%u.%u", HIPQUAD(max_address));
+					snprintf(buf + len,
+						 sizeof(buf) - 1 - len,
+						 "-%u.%u.%u.%u",
+						 HIPQUAD(max_address));
 				}
 			}
-			if (io_printf(head, KEYWORD_ADDRESS_GROUP "%s %s\n", group->group_name->name, buf)) return -ENOMEM;
+			if (!ccs_io_printf(head, KEYWORD_ADDRESS_GROUP
+					   "%s %s\n", group->group_name->name,
+					   buf))
+				goto out;
 		}
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
 
-/*************************  NETWORK NETWORK ACL HANDLER  *************************/
+/* Network ACL handler. */
 
 #if !defined(NIP6)
-#define NIP6(addr) \
-	ntohs((addr).s6_addr16[0]), \
-	ntohs((addr).s6_addr16[1]), \
-	ntohs((addr).s6_addr16[2]), \
-	ntohs((addr).s6_addr16[3]), \
-	ntohs((addr).s6_addr16[4]), \
-	ntohs((addr).s6_addr16[5]), \
-	ntohs((addr).s6_addr16[6]), \
-	ntohs((addr).s6_addr16[7])
+#define NIP6(addr)				\
+	ntohs((addr).s6_addr16[0]),		\
+		ntohs((addr).s6_addr16[1]),	\
+		ntohs((addr).s6_addr16[2]),	\
+		ntohs((addr).s6_addr16[3]),	\
+		ntohs((addr).s6_addr16[4]),	\
+		ntohs((addr).s6_addr16[5]),	\
+		ntohs((addr).s6_addr16[6]),	\
+		ntohs((addr).s6_addr16[7])
 #endif
 
-char *print_ipv6(char *buffer, const int buffer_len, const struct in6_addr *ip)
+/**
+ * ccs_print_ipv6 -
+ *
+ * @buffer:     Buffer to write to.
+ * @buffer_len: Size of @buffer .
+ * @ip:         Pointer to "struct in6_addr".
+ *
+ * Returns @buffer.
+ */
+char *ccs_print_ipv6(char *buffer, const int buffer_len,
+		     const struct in6_addr *ip)
 {
 	memset(buffer, 0, buffer_len);
 	snprintf(buffer, buffer_len - 1, "%x:%x:%x:%x:%x:%x:%x:%x", NIP6(*ip));
 	return buffer;
 }
 
-const char *net_operation2keyword(const u8 operation)
+/**
+ * ccs_net2keyword -
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of operation.
+ */
+const char *ccs_net2keyword(const u8 operation)
 {
 	const char *keyword = "unknown";
 	switch (operation) {
@@ -289,125 +462,232 @@
 	return keyword;
 }
 
-static int AddNetworkEntry(const u8 operation, const u8 record_type, const struct address_group_entry *group, const u32 *min_address, const u32 *max_address, const u16 min_port, const u16 max_port, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * update_network_entry -
+ *
+ * @operation:   Type of operation.
+ * @record_type: Type of address.
+ * @group:       Pointer to "struct address_group_entry". May be NULL.
+ * @min_address: Start of IPv4 or IPv6 address range.
+ * @max_address: End of IPv4 or IPv6 address range.
+ * @min_port:    Start of port number range.
+ * @max_port:    End of port number range.
+ * @domain:      Pointer to "struct domain_info".
+ * @condition:   Pointer to "struct condition_list". May be NULL.
+ * @is_delete:   True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_network_entry(const u8 operation, const u8 record_type,
+				const struct address_group_entry *group,
+				const u32 *min_address, const u32 *max_address,
+				const u16 min_port, const u16 max_port,
+				struct domain_info *domain,
+				const struct condition_list *condition,
+				const bool is_delete)
 {
 	struct acl_info *ptr;
 	struct ip_network_acl_record *acl;
 	int error = -ENOMEM;
-	const u32 min_ip = ntohl(*min_address), max_ip = ntohl(*max_address); /* using host byte order to allow u32 comparison than memcmp().*/
-	const struct in6_addr *saved_min_address = NULL, *saved_max_address = NULL;
-	if (!domain) return -EINVAL;
-	if (record_type == IP_RECORD_TYPE_IPv6) {
-		if ((saved_min_address = SaveIPv6Address((struct in6_addr *) min_address)) == NULL
-		    || (saved_max_address = SaveIPv6Address((struct in6_addr *) max_address)) == NULL) return -ENOMEM;
-	}
+	/* using host byte order to allow u32 comparison than memcmp().*/
+	const u32 min_ip = ntohl(*min_address);
+	const u32 max_ip = ntohl(*max_address);
+	const struct in6_addr *saved_min_address = NULL;
+	const struct in6_addr *saved_max_address = NULL;
+	if (!domain)
+		return -EINVAL;
+	if (record_type != IP_RECORD_TYPE_IPv6)
+		goto not_ipv6;
+	saved_min_address = save_ipv6_address((struct in6_addr *) min_address);
+	saved_max_address = save_ipv6_address((struct in6_addr *) max_address);
+	if (!saved_min_address || !saved_max_address)
+		return -ENOMEM;
+ not_ipv6:
 	mutex_lock(&domain_acl_lock);
-	if (!is_delete) {
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_IP_NETWORK_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct ip_network_acl_record, head);
-			if (acl->operation_type != operation || acl->record_type != record_type || acl->min_port != min_port || max_port != acl->max_port) continue;
-			if (record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
-				if (acl->u.group != group) continue;
-			} else if (record_type == IP_RECORD_TYPE_IPv4) {
-				if (acl->u.ipv4.min != min_ip || max_ip != acl->u.ipv4.max) continue;
-			} else if (record_type == IP_RECORD_TYPE_IPv6) {
-				if (acl->u.ipv6.min != saved_min_address || saved_max_address != acl->u.ipv6.max) continue;
-			}
-			error = AddDomainACL(NULL, ptr);
-			goto out;
-		}
-		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_IP_NETWORK_ACL, condition)) == NULL) goto out;
-		acl->operation_type = operation;
-		acl->record_type = record_type;
+	if (is_delete)
+		goto delete;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION))
+		    != TYPE_IP_NETWORK_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct ip_network_acl_record, head);
+		if (acl->operation_type != operation ||
+		    acl->record_type != record_type ||
+		    acl->min_port != min_port || max_port != acl->max_port)
+			continue;
 		if (record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
-			acl->u.group = group;
+			if (acl->u.group != group)
+				continue;
 		} else if (record_type == IP_RECORD_TYPE_IPv4) {
-			acl->u.ipv4.min = min_ip;
-			acl->u.ipv4.max = max_ip;
-		} else {
-			acl->u.ipv6.min = saved_min_address;
-			acl->u.ipv6.max = saved_max_address;
+			if (acl->u.ipv4.min != min_ip ||
+			    max_ip != acl->u.ipv4.max)
+				continue;
+		} else if (record_type == IP_RECORD_TYPE_IPv6) {
+			if (acl->u.ipv6.min != saved_min_address ||
+			    saved_max_address != acl->u.ipv6.max)
+				continue;
 		}
-		acl->min_port = min_port;
-		acl->max_port = max_port;
-		error = AddDomainACL(domain, &acl->head);
+		error = ccs_add_domain_acl(NULL, ptr);
+		goto out;
+	}
+	/* Not found. Append it to the tail. */
+	acl = ccs_alloc_acl_element(TYPE_IP_NETWORK_ACL, condition);
+	if (!acl)
+		goto out;
+	acl->operation_type = operation;
+	acl->record_type = record_type;
+	if (record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
+		acl->u.group = group;
+	} else if (record_type == IP_RECORD_TYPE_IPv4) {
+		acl->u.ipv4.min = min_ip;
+		acl->u.ipv4.max = max_ip;
 	} else {
-		error = -ENOENT;
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_IP_NETWORK_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct ip_network_acl_record, head);
-			if (acl->operation_type != operation || acl->record_type != record_type || acl->min_port != min_port || max_port != acl->max_port) continue;
-			if (record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
-				if (acl->u.group != group) continue;
-			} else if (record_type == IP_RECORD_TYPE_IPv4) {
-				if (acl->u.ipv4.min != min_ip || max_ip != acl->u.ipv4.max) continue;
-			} else if (record_type == IP_RECORD_TYPE_IPv6) {
-				if (acl->u.ipv6.min != saved_min_address || saved_max_address != acl->u.ipv6.max) continue;
-			}
-			error = DelDomainACL(ptr);
-			break;
+		acl->u.ipv6.min = saved_min_address;
+		acl->u.ipv6.max = saved_max_address;
+	}
+	acl->min_port = min_port;
+	acl->max_port = max_port;
+	error = ccs_add_domain_acl(domain, &acl->head);
+	goto out;
+ delete:
+	error = -ENOENT;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_IP_NETWORK_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct ip_network_acl_record, head);
+		if (acl->operation_type != operation ||
+		    acl->record_type != record_type ||
+		    acl->min_port != min_port || max_port != acl->max_port)
+			continue;
+		if (record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
+			if (acl->u.group != group)
+				continue;
+		} else if (record_type == IP_RECORD_TYPE_IPv4) {
+			if (acl->u.ipv4.min != min_ip ||
+			    max_ip != acl->u.ipv4.max)
+				continue;
+		} else if (record_type == IP_RECORD_TYPE_IPv6) {
+			if (acl->u.ipv6.min != saved_min_address ||
+			    saved_max_address != acl->u.ipv6.max)
+				continue;
 		}
+		error = ccs_del_domain_acl(ptr);
+		break;
 	}
- out: ;
+ out:
 	mutex_unlock(&domain_acl_lock);
 	return error;
 }
 
-static int CheckNetworkEntry(const bool is_ipv6, const u8 operation, const u32 *address, const u16 port)
+/**
+ * check_network_entry -
+ *
+ * @is_ipv6:   True if @address is an IPv6 address.
+ * @operation: Type of operation.
+ * @address:   An IPv4 or IPv6 address.
+ * @port:      Port number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int check_network_entry(const bool is_ipv6, const u8 operation,
+			       const u32 *address, const u16 port)
 {
 	struct domain_info * const domain = current->domain_info;
 	struct acl_info *ptr;
-	const char *keyword = net_operation2keyword(operation);
+	const char *keyword = ccs_net2keyword(operation);
 	const u8 profile = current->domain_info->profile;
-	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_NETWORK);
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_NETWORK);
 	const bool is_enforce = (mode == 3);
-	const u32 ip = ntohl(*address); /* using host byte order to allow u32 comparison than memcmp().*/
+	/* using host byte order to allow u32 comparison than memcmp().*/
+	const u32 ip = ntohl(*address);
 	bool found = false;
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct ip_network_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_IP_NETWORK_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_IP_NETWORK_ACL)
+			continue;
 		acl = container_of(ptr, struct ip_network_acl_record, head);
-		if (acl->operation_type != operation || port < acl->min_port || acl->max_port < port || !CheckCondition(ptr, NULL)) continue;
+		if (acl->operation_type != operation || port < acl->min_port ||
+		    acl->max_port < port || !ccs_check_condition(ptr, NULL))
+			continue;
 		if (acl->record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
-			if (!AddressMatchesToGroup(is_ipv6, address, acl->u.group)) continue;
+			if (!address_matches_to_group(is_ipv6, address,
+						      acl->u.group))
+				continue;
 		} else if (acl->record_type == IP_RECORD_TYPE_IPv4) {
-			if (is_ipv6 || ip < acl->u.ipv4.min || acl->u.ipv4.max < ip) continue;
+			if (is_ipv6 ||
+			    ip < acl->u.ipv4.min || acl->u.ipv4.max < ip)
+				continue;
 		} else {
-			if (!is_ipv6 || memcmp(acl->u.ipv6.min, address, 16) > 0 || memcmp(address, acl->u.ipv6.max, 16) > 0) continue;
+			if (!is_ipv6 ||
+			    memcmp(acl->u.ipv6.min, address, 16) > 0 ||
+			    memcmp(address, acl->u.ipv6.max, 16) > 0)
+				continue;
 		}
-		UpdateCondition(ptr);
+		ccs_update_condition(ptr);
 		found = true;
 		break;
 	}
-	AuditNetworkLog(is_ipv6, keyword, address, port, found, profile, mode);
-	if (found) return 0;
-	if (TomoyoVerboseMode()) {
+	audit_network_log(is_ipv6, keyword, address, port, found, profile,
+			  mode);
+	if (found)
+		return 0;
+	if (ccs_verbose_mode()) {
 		if (is_ipv6) {
 			char buf[64];
-			print_ipv6(buf, sizeof(buf), (const struct in6_addr *) address);
-			printk("TOMOYO-%s: %s to %s %u denied for %s\n", GetMSG(is_enforce), keyword, buf, port, GetLastName(domain));
+			ccs_print_ipv6(buf, sizeof(buf),
+				       (const struct in6_addr *) address);
+			printk(KERN_WARNING "TOMOYO-%s: %s to %s %u "
+			       "denied for %s\n", ccs_get_msg(is_enforce),
+			       keyword, buf, port, ccs_get_last_name(domain));
 		} else {
-			printk("TOMOYO-%s: %s to %u.%u.%u.%u %u denied for %s\n", GetMSG(is_enforce), keyword, HIPQUAD(ip), port, GetLastName(domain));
+			printk(KERN_WARNING "TOMOYO-%s: %s to %u.%u.%u.%u %u "
+			       "denied for %s\n", ccs_get_msg(is_enforce),
+			       keyword, HIPQUAD(ip), port,
+			       ccs_get_last_name(domain));
 		}
 	}
 	if (is_enforce) {
 		if (is_ipv6) {
 			char buf[64];
-			print_ipv6(buf, sizeof(buf), (const struct in6_addr *) address);
-			return CheckSupervisor("%s\n" KEYWORD_ALLOW_NETWORK "%s %s %u\n", domain->domainname->name, keyword, buf, port);
+			ccs_print_ipv6(buf, sizeof(buf),
+				       (const struct in6_addr *) address);
+			return ccs_check_supervisor("%s\n"
+						    KEYWORD_ALLOW_NETWORK "%s "
+						    "%s %u\n",
+						    domain->domainname->name,
+						    keyword, buf, port);
 		}
-		return CheckSupervisor("%s\n" KEYWORD_ALLOW_NETWORK "%s %u.%u.%u.%u %u\n", domain->domainname->name, keyword, HIPQUAD(ip), port);
-	}
-	else if (mode == 1 && CheckDomainQuota(domain)) AddNetworkEntry(operation, is_ipv6 ? IP_RECORD_TYPE_IPv6 : IP_RECORD_TYPE_IPv4, NULL, address, address, port, port, domain, NULL, 0);
+		return ccs_check_supervisor("%s\n" KEYWORD_ALLOW_NETWORK "%s "
+					    "%u.%u.%u.%u %u\n",
+					    domain->domainname->name, keyword,
+					    HIPQUAD(ip), port);
+	} else if (mode == 1 && ccs_check_domain_quota(domain))
+		update_network_entry(operation, is_ipv6 ?
+				     IP_RECORD_TYPE_IPv6 : IP_RECORD_TYPE_IPv4,
+				     NULL, address, address, port, port, domain,
+				     NULL, 0);
 	return 0;
 }
 
-int AddNetworkPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * ccs_write_network_policy -
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_network_policy(char *data, struct domain_info *domain,
+			     const struct condition_list *condition,
+			     const bool is_delete)
 {
 	u8 sock_type, operation, record_type;
 	u16 min_address[8], max_address[8];
@@ -415,95 +695,251 @@
 	u16 min_port, max_port;
 	u8 count;
 	char *cp1 = NULL, *cp2 = NULL;
-	if ((cp1 = strchr(data, ' ')) == NULL) goto out; cp1++;
-	if (strncmp(data, "TCP ", 4) == 0) sock_type = SOCK_STREAM;
-	else if (strncmp(data, "UDP ", 4) == 0) sock_type = SOCK_DGRAM;
-	else if (strncmp(data, "RAW ", 4) == 0) sock_type = SOCK_RAW;
-	else goto out;
-	if ((cp2 = strchr(cp1, ' ')) == NULL) goto out; cp2++;
-	if (strncmp(cp1, "bind ", 5) == 0) {
-		operation = (sock_type == SOCK_STREAM) ? NETWORK_ACL_TCP_BIND : (sock_type == SOCK_DGRAM) ? NETWORK_ACL_UDP_BIND : NETWORK_ACL_RAW_BIND;
-	} else if (strncmp(cp1, "connect ", 8) == 0) {
-		operation = (sock_type == SOCK_STREAM) ? NETWORK_ACL_TCP_CONNECT : (sock_type == SOCK_DGRAM) ? NETWORK_ACL_UDP_CONNECT : NETWORK_ACL_RAW_CONNECT;
-	} else if (sock_type == SOCK_STREAM && strncmp(cp1, "listen ", 7) == 0) {
+	cp1 = strchr(data, ' ');
+	if (!cp1)
+		goto out;
+	cp1++;
+	if (!strncmp(data, "TCP ", 4))
+		sock_type = SOCK_STREAM;
+	else if (!strncmp(data, "UDP ", 4))
+		sock_type = SOCK_DGRAM;
+	else if (!strncmp(data, "RAW ", 4))
+		sock_type = SOCK_RAW;
+	else
+		goto out;
+	cp2 = strchr(cp1, ' ');
+	if (!cp2)
+		goto out;
+	cp2++;
+	if (!strncmp(cp1, "bind ", 5))
+		switch (sock_type) {
+		case SOCK_STREAM:
+			operation = NETWORK_ACL_TCP_BIND;
+			break;
+		case SOCK_DGRAM:
+			operation = NETWORK_ACL_UDP_BIND;
+			break;
+		default:
+			operation = NETWORK_ACL_RAW_BIND;
+		}
+	else if (!strncmp(cp1, "connect ", 8))
+		switch (sock_type) {
+		case SOCK_STREAM:
+			operation = NETWORK_ACL_TCP_CONNECT;
+			break;
+		case SOCK_DGRAM:
+			operation = NETWORK_ACL_UDP_CONNECT;
+			break;
+		default:
+			operation = NETWORK_ACL_RAW_CONNECT;
+		}
+	else if (sock_type == SOCK_STREAM && !strncmp(cp1, "listen ", 7))
 		operation = NETWORK_ACL_TCP_LISTEN;
-	} else if (sock_type == SOCK_STREAM && strncmp(cp1, "accept ", 7) == 0) {
+	else if (sock_type == SOCK_STREAM && !strncmp(cp1, "accept ", 7))
 		operation = NETWORK_ACL_TCP_ACCEPT;
-	} else {
+	else
 		goto out;
-	}
-	if ((cp1 = strchr(cp2, ' ')) == NULL) goto out; *cp1++ = '\0';
-	if ((count = sscanf(cp2, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
-			    &min_address[0], &min_address[1], &min_address[2], &min_address[3],
-			    &min_address[4], &min_address[5], &min_address[6], &min_address[7],
-			    &max_address[0], &max_address[1], &max_address[2], &max_address[3],
-			    &max_address[4], &max_address[5], &max_address[6], &max_address[7])) == 8 || count == 16) {
+	cp1 = strchr(cp2, ' ');
+	if (!cp1)
+		goto out;
+	*cp1++ = '\0';
+	count = sscanf(cp2, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx"
+		       "-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
+		       &min_address[0], &min_address[1],
+		       &min_address[2], &min_address[3],
+		       &min_address[4], &min_address[5],
+		       &min_address[6], &min_address[7],
+		       &max_address[0], &max_address[1],
+		       &max_address[2], &max_address[3],
+		       &max_address[4], &max_address[5],
+		       &max_address[6], &max_address[7]);
+	if (count == 8 || count == 16) {
 		u8 i;
 		for (i = 0; i < 8; i++) {
 			min_address[i] = htons(min_address[i]);
 			max_address[i] = htons(max_address[i]);
 		}
-		if (count == 8) memmove(max_address, min_address, sizeof(min_address));
+		if (count == 8)
+			memmove(max_address, min_address, sizeof(min_address));
 		record_type = IP_RECORD_TYPE_IPv6;
-	} else if ((count = sscanf(cp2, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
-				   &min_address[0], &min_address[1], &min_address[2], &min_address[3],
-				   &max_address[0], &max_address[1], &max_address[2], &max_address[3])) == 4 || count == 8) {
-		u32 ip = htonl((((u8) min_address[0]) << 24) + (((u8) min_address[1]) << 16) + (((u8) min_address[2]) << 8) + (u8) min_address[3]);
-		* (u32 *) min_address = ip;
-		if (count == 8) ip = htonl((((u8) max_address[0]) << 24) + (((u8) max_address[1]) << 16) + (((u8) max_address[2]) << 8) + (u8) max_address[3]);
-		* (u32 *) max_address = ip;
+		goto ok;
+	}
+	count = sscanf(cp2, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
+		       &min_address[0], &min_address[1],
+		       &min_address[2], &min_address[3],
+		       &max_address[0], &max_address[1],
+		       &max_address[2], &max_address[3]);
+	if (count == 4 || count == 8) {
+		u32 ip = htonl((((u8) min_address[0]) << 24)
+			       + (((u8) min_address[1]) << 16)
+			       + (((u8) min_address[2]) << 8)
+			       + (u8) min_address[3]);
+		*(u32 *) min_address = ip;
+		if (count == 8)
+			ip = htonl((((u8) max_address[0]) << 24)
+				   + (((u8) max_address[1]) << 16)
+				   + (((u8) max_address[2]) << 8)
+				   + (u8) max_address[3]);
+		*(u32 *) max_address = ip;
 		record_type = IP_RECORD_TYPE_IPv4;
 	} else if (*cp2 == '@') {
-		if ((group = FindOrAssignNewAddressGroup(cp2 + 1)) == NULL) return -ENOMEM;
+		group = find_or_assign_new_address_group(cp2 + 1);
+		if (!group)
+			return -ENOMEM;
 		record_type = IP_RECORD_TYPE_ADDRESS_GROUP;
 	} else {
 		goto out;
 	}
-	if (strchr(cp1, ' ')) goto out;
-	if ((count = sscanf(cp1, "%hu-%hu", &min_port, &max_port)) == 1 || count == 2) {
-		if (count == 1) max_port = min_port;
-		return AddNetworkEntry(operation, record_type, group, (u32 *) min_address, (u32 *) max_address, min_port, max_port, domain, condition, is_delete);
-	}
- out: ;
+ ok:
+	if (strchr(cp1, ' '))
+		goto out;
+	count = sscanf(cp1, "%hu-%hu", &min_port, &max_port);
+	if (count != 1 && count != 2)
+		goto out;
+	if (count == 1)
+		max_port = min_port;
+	return update_network_entry(operation, record_type, group,
+				    (u32 *) min_address, (u32 *) max_address,
+				    min_port, max_port, domain, condition,
+				    is_delete);
+ out:
 	return -EINVAL;
 }
 
-int CheckNetworkListenACL(const _Bool is_ipv6, const u8 *address, const u16 port)
+/**
+ * ccs_check_network_listen_acl -
+ *
+ * @is_ipv6: True if @address is an IPv6 address.
+ * @address: An IPv4 or IPv6 address.
+ * @port:    Port number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_network_listen_acl(const _Bool is_ipv6, const u8 *address,
+				 const u16 port)
 {
-	return CheckNetworkEntry(is_ipv6, NETWORK_ACL_TCP_LISTEN, (const u32 *) address, ntohs(port));
+	return check_network_entry(is_ipv6, NETWORK_ACL_TCP_LISTEN,
+				   (const u32 *) address, ntohs(port));
 }
 
-int CheckNetworkConnectACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port)
+/**
+ * ccs_check_network_connect_acl -
+ *
+ * @is_ipv6:   True if @address is an IPv6 address.
+ * @sock_type: Type of socket. (TCP or UDP or RAW)
+ * @address:   An IPv4 or IPv6 address.
+ * @port:      Port number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_network_connect_acl(const _Bool is_ipv6, const int sock_type,
+				  const u8 *address, const u16 port)
 {
-	return CheckNetworkEntry(is_ipv6, sock_type == SOCK_STREAM ? NETWORK_ACL_TCP_CONNECT : (sock_type == SOCK_DGRAM ? NETWORK_ACL_UDP_CONNECT : NETWORK_ACL_RAW_CONNECT), (const u32 *) address, ntohs(port));
+	u8 operation;
+	switch (sock_type) {
+	case SOCK_STREAM:
+		operation = NETWORK_ACL_TCP_CONNECT;
+		break;
+	case SOCK_DGRAM:
+		operation = NETWORK_ACL_UDP_CONNECT;
+		break;
+	default:
+		operation = NETWORK_ACL_RAW_CONNECT;
+	}
+	return check_network_entry(is_ipv6, operation, (const u32 *) address,
+				   ntohs(port));
 }
 
-int CheckNetworkBindACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port)
+/**
+ * ccs_check_network_bind_acl -
+ *
+ * @is_ipv6:   True if @address is an IPv6 address.
+ * @sock_type: Type of socket. (TCP or UDP or RAW)
+ * @address:   An IPv4 or IPv6 address.
+ * @port:      Port number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_network_bind_acl(const _Bool is_ipv6, const int sock_type,
+			       const u8 *address, const u16 port)
 {
-	return CheckNetworkEntry(is_ipv6, sock_type == SOCK_STREAM ? NETWORK_ACL_TCP_BIND : (sock_type == SOCK_DGRAM ? NETWORK_ACL_UDP_BIND : NETWORK_ACL_RAW_BIND), (const u32 *) address, ntohs(port));
+	u8 operation;
+	switch (sock_type) {
+	case SOCK_STREAM:
+		operation = NETWORK_ACL_TCP_BIND;
+		break;
+	case SOCK_DGRAM:
+		operation = NETWORK_ACL_UDP_BIND;
+		break;
+	default:
+		operation = NETWORK_ACL_RAW_BIND;
+	}
+	return check_network_entry(is_ipv6, operation, (const u32 *) address,
+				   ntohs(port));
 }
 
-int CheckNetworkAcceptACL(const _Bool is_ipv6, const u8 *address, const u16 port)
+/**
+ * ccs_check_network_accept_acl -
+ *
+ * @is_ipv6: True if @address is an IPv6 address.
+ * @address: An IPv4 or IPv6 address.
+ * @port:    Port number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_network_accept_acl(const _Bool is_ipv6, const u8 *address,
+				 const u16 port)
 {
 	int retval;
 	current->tomoyo_flags |= CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
-	retval = CheckNetworkEntry(is_ipv6, NETWORK_ACL_TCP_ACCEPT, (const u32 *) address, ntohs(port));
+	retval = check_network_entry(is_ipv6, NETWORK_ACL_TCP_ACCEPT,
+				     (const u32 *) address, ntohs(port));
 	current->tomoyo_flags &= ~CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
 	return retval;
 }
 
-int CheckNetworkSendMsgACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port)
+/**
+ * ccs_check_network_sendmsg_acl -
+ *
+ * @is_ipv6:   True if @address is an IPv6 address.
+ * @sock_type: Type of socket. (UDP or RAW)
+ * @address:   An IPv4 or IPv6 address.
+ * @port:      Port number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_network_sendmsg_acl(const _Bool is_ipv6, const int sock_type,
+				  const u8 *address, const u16 port)
 {
-	return CheckNetworkEntry(is_ipv6, sock_type == SOCK_DGRAM ? NETWORK_ACL_UDP_CONNECT : NETWORK_ACL_RAW_CONNECT, (const u32 *) address, ntohs(port));
+	u8 operation;
+	if (sock_type == SOCK_DGRAM)
+		operation = NETWORK_ACL_UDP_CONNECT;
+	else
+		operation = NETWORK_ACL_RAW_CONNECT;
+	return check_network_entry(is_ipv6, operation, (const u32 *) address,
+				   ntohs(port));
 }
 
-int CheckNetworkRecvMsgACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port)
+/**
+ * ccs_check_network_recvmsg_acl -
+ *
+ * @is_ipv6:   True if @address is an IPv6 address.
+ * @sock_type: Type of socket. (UDP or RAW)
+ * @address:   An IPv4 or IPv6 address.
+ * @port:      Port number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_network_recvmsg_acl(const _Bool is_ipv6, const int sock_type,
+				  const u8 *address, const u16 port)
 {
 	int retval;
+	const u8 operation
+		= sock_type == SOCK_DGRAM ?
+		NETWORK_ACL_UDP_CONNECT : NETWORK_ACL_RAW_CONNECT;
 	current->tomoyo_flags |= CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
-	retval = CheckNetworkEntry(is_ipv6, sock_type == SOCK_DGRAM ? NETWORK_ACL_UDP_CONNECT : NETWORK_ACL_RAW_CONNECT, (const u32 *) address, ntohs(port));
+	retval = check_network_entry(is_ipv6, operation, (const u32 *) address,
+				     ntohs(port));
 	current->tomoyo_flags &= ~CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
 	return retval;
 }
-
-/***** TOMOYO Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/realpath.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/realpath.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/realpath.c	(working copy)
@@ -21,7 +21,7 @@
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 #include <linux/version.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #include <linux/mount.h>
 static const int lookup_flags = LOOKUP_FOLLOW;
@@ -32,29 +32,34 @@
 #include <linux/proc_fs.h>
 #include <linux/ccs_common.h>
 
-/***** realpath handler *****/
-
-/*
- * GetAbsolutePath - return the path of a dentry but ignores chroot'ed root.
- * @dentry: dentry to report
- * @vfsmnt: vfsmnt to which the dentry belongs
- * @buffer: buffer to return value in
- * @buflen: buffer length
+/**
+ * get_absolute_path - Get the path of a dentry but ignores chroot'ed root.
  *
- * Caller holds the dcache_lock.
+ * @dentry: Pointer to "struct dentry".
+ * @vfsmnt: Pointer to "struct vfsmount".
+ * @buffer: Pointer to buffer to return value in.
+ * @buflen: Sizeof @buffer.
+ *
+ * Returns 0 on success, -ENOMEM otherwise.
+ *
+ * Caller holds the dcache_lock and vfsmount_lock .
  * Based on __d_path() in fs/dcache.c
  *
  * If dentry is a directory, trailing '/' is appended.
- * Characters other than ' ' < c < 127 are converted to \ooo style octal string.
+ * Characters out of 0x20 < c < 0x7F range are converted to
+ * \ooo style octal string.
  * Character \ is converted to \\ string.
  */
-static int GetAbsolutePath(struct dentry *dentry, struct vfsmount *vfsmnt, char *buffer, int buflen)
+static int get_absolute_path(struct dentry *dentry, struct vfsmount *vfsmnt,
+			     char *buffer, int buflen)
 {
+	/***** CRITICAL SECTION START *****/
 	char *start = buffer;
 	char *end = buffer + buflen;
 	bool is_dir = (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode));
 
-	if (buflen < 256) goto out;
+	if (buflen < 256)
+		goto out;
 
 	*--end = '\0';
 	buflen--;
@@ -64,24 +69,16 @@
 
 		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
 			/* Global root? */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-			spin_lock(&vfsmount_lock);
-#endif
-			if (vfsmnt->mnt_parent == vfsmnt) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-				spin_unlock(&vfsmount_lock);
-#endif
+			if (vfsmnt->mnt_parent == vfsmnt)
 				break;
-			}
 			dentry = vfsmnt->mnt_mountpoint;
 			vfsmnt = vfsmnt->mnt_parent;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-			spin_unlock(&vfsmount_lock);
-#endif
 			continue;
 		}
 		if (is_dir) {
-			is_dir = false; *--end = '/'; buflen--;
+			is_dir = false;
+			*--end = '/';
+			buflen--;
 		}
 		parent = dentry->d_parent;
 		{
@@ -89,30 +86,45 @@
 			const char *cp = sp + dentry->d_name.len - 1;
 			unsigned char c;
 
-			/* Exception: Use /proc/self/ rather than /proc/\$/ for current process. */
-			if (IS_ROOT(parent) && *sp > '0' && *sp <= '9' && parent->d_sb && parent->d_sb->s_magic == PROC_SUPER_MAGIC) {
+			/*
+			 * Exception: Use /proc/self/ rather than
+			 * /proc/\$/ for current process.
+			 */
+			if (IS_ROOT(parent) && *sp > '0' && *sp <= '9' &&
+			    parent->d_sb &&
+			    parent->d_sb->s_magic == PROC_SUPER_MAGIC) {
 				char *ep;
-				const pid_t pid = (pid_t) simple_strtoul(sp, &ep, 10);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-				if (!*ep && pid == current->tgid) { sp = "self"; cp = sp + 3; }
+				const pid_t pid
+					= (pid_t) simple_strtoul(sp, &ep, 10);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+				if (!*ep && pid == current->tgid) {
+					sp = "self";
+					cp = sp + 3;
+				}
 #else
-				if (!*ep && pid == current->pid) { sp = "self"; cp = sp + 3; }
+				if (!*ep && pid == current->pid) {
+					sp = "self";
+					cp = sp + 3;
+				}
 #endif
 			}
 
 			while (sp <= cp) {
-				c = * (unsigned char *) cp;
+				c = *(unsigned char *) cp;
 				if (c == '\\') {
 					buflen -= 2;
-					if (buflen < 0) goto out;
+					if (buflen < 0)
+						goto out;
 					*--end = '\\';
 					*--end = '\\';
 				} else if (c > ' ' && c < 127) {
-					if (--buflen < 0) goto out;
+					if (--buflen < 0)
+						goto out;
 					*--end = (char) c;
 				} else {
 					buflen -= 4;
-					if (buflen < 0) goto out;
+					if (buflen < 0)
+						goto out;
 					*--end = (c & 7) + '0';
 					*--end = ((c >> 3) & 7) + '0';
 					*--end = (c >> 6) + '0';
@@ -120,29 +132,36 @@
 				}
 				cp--;
 			}
-			if (--buflen < 0) goto out;
+			if (--buflen < 0)
+				goto out;
 			*--end = '/';
 		}
 		dentry = parent;
 	}
-	if (*end == '/') { buflen++; end++; }
+	if (*end == '/') {
+		buflen++;
+		end++;
+	}
 	{
 		const char *sp = dentry->d_name.name;
 		const char *cp = sp + dentry->d_name.len - 1;
 		unsigned char c;
 		while (sp <= cp) {
-			c = * (unsigned char *) cp;
+			c = *(unsigned char *) cp;
 			if (c == '\\') {
 				buflen -= 2;
-				if (buflen < 0) goto out;
+				if (buflen < 0)
+					goto out;
 				*--end = '\\';
 				*--end = '\\';
 			} else if (c > ' ' && c < 127) {
-				if (--buflen < 0) goto out;
+				if (--buflen < 0)
+					goto out;
 				*--end = (char) c;
 			} else {
 				buflen -= 4;
-				if (buflen < 0) goto out;
+				if (buflen < 0)
+					goto out;
 				*--end = (c & 7) + '0';
 				*--end = ((c >> 3) & 7) + '0';
 				*--end = (c >> 6) + '0';
@@ -156,20 +175,39 @@
 	return 0;
  out:
 	return -ENOMEM;
+	/***** CRITICAL SECTION END *****/
 }
 
-/* Returns realpath(3) of the given dentry but ignores chroot'ed root. */
-int realpath_from_dentry2(struct dentry *dentry, struct vfsmount *mnt, char *newname, int newname_len)
+/**
+ * ccs_realpath_from_dentry2 - Returns realpath(3) of the given dentry
+ *                             but ignores chroot'ed root.
+ *
+ * @dentry:      Pointer to "struct dentry".
+ * @mnt:         Pointer to "struct vfsmount".
+ * @newname:     Pointer to buffer to return value in.
+ * @newname_len: Size of @newname .
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_realpath_from_dentry2(struct dentry *dentry, struct vfsmount *mnt,
+			      char *newname, int newname_len)
 {
 	int error;
 	struct dentry *d_dentry;
 	struct vfsmount *d_mnt;
-	if (!dentry || !mnt || !newname || newname_len <= 0) return -EINVAL;
+	if (!dentry || !mnt || !newname || newname_len <= 0)
+		return -EINVAL;
 	d_dentry = dget(dentry);
 	d_mnt = mntget(mnt);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&dcache_lock);
-	error = GetAbsolutePath(d_dentry, d_mnt, newname, newname_len);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+	spin_lock(&vfsmount_lock);
+#endif
+	error = get_absolute_path(d_dentry, d_mnt, newname, newname_len);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+	spin_unlock(&vfsmount_lock);
+#endif
 	spin_unlock(&dcache_lock);
 	/***** CRITICAL SECTION END *****/
 	dput(d_dentry);
@@ -177,25 +215,46 @@
 	return error;
 }
 
-/* Returns realpath(3) of the given pathname but ignores chroot'ed root. */
-/* These functions use ccs_alloc(), so caller must ccs_free() if these functions didn't return NULL. */
-char *realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt)
+/**
+ * ccs_realpath_from_dentry - Returns realpath(3) of the given pathname
+ *                            but ignores chroot'ed root.
+ *
+ * @dentry: Pointer to "struct dentry".
+ * @mnt:    Pointer to "struct vfsmount".
+ *
+ * Returns the realpath of the given @dentry and @mnt on success,
+ * NULL otherwise.
+ *
+ * These functions use ccs_alloc(), so caller must ccs_free()
+ * if these functions didn't return NULL.
+ */
+char *ccs_realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt)
 {
 	char *buf = ccs_alloc(sizeof(struct ccs_page_buffer));
-	if (buf && realpath_from_dentry2(dentry, mnt, buf, CCS_MAX_PATHNAME_LEN - 1) == 0) return buf;
+	if (buf && ccs_realpath_from_dentry2(dentry, mnt, buf,
+					     CCS_MAX_PATHNAME_LEN - 1) == 0)
+		return buf;
 	ccs_free(buf);
 	return NULL;
 }
 
-char *realpath(const char *pathname)
+/**
+ * ccs_realpath - Get realpath of a pathname.
+ *
+ * @pathname: The pathname to solve.
+ *
+ * Returns the realpath of @pathname on success, NULL otherwise.
+ */
+char *ccs_realpath(const char *pathname)
 {
 	struct nameidata nd;
 	if (pathname && path_lookup(pathname, lookup_flags, &nd) == 0) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-		char *buf = realpath_from_dentry(nd.path.dentry, nd.path.mnt);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+		char *buf = ccs_realpath_from_dentry(nd.path.dentry,
+						     nd.path.mnt);
 		path_put(&nd.path);
 #else
-		char *buf = realpath_from_dentry(nd.dentry, nd.mnt);
+		char *buf = ccs_realpath_from_dentry(nd.dentry, nd.mnt);
 		path_release(&nd);
 #endif
 		return buf;
@@ -203,15 +262,24 @@
 	return NULL;
 }
 
-char *realpath_nofollow(const char *pathname)
+/**
+ * ccs_realpath_nofollow - Get realpath of a pathname.
+ *
+ * @pathname: The pathname to solve.
+ *
+ * Returns the realpath of @pathname on success, NULL otherwise.
+ */
+char *ccs_realpath_nofollow(const char *pathname)
 {
 	struct nameidata nd;
-	if (pathname && path_lookup(pathname, lookup_flags ^ LOOKUP_FOLLOW, &nd) == 0) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-		char *buf = realpath_from_dentry(nd.path.dentry, nd.path.mnt);
+	if (pathname && path_lookup(pathname, lookup_flags ^ LOOKUP_FOLLOW,
+				    &nd) == 0) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+		char *buf = ccs_realpath_from_dentry(nd.path.dentry,
+						     nd.path.mnt);
 		path_put(&nd.path);
 #else
-		char *buf = realpath_from_dentry(nd.dentry, nd.mnt);
+		char *buf = ccs_realpath_from_dentry(nd.dentry, nd.mnt);
 		path_release(&nd);
 #endif
 		return buf;
@@ -219,41 +287,66 @@
 	return NULL;
 }
 
-/***** Private memory allocator. *****/
-
-/*
- * Round up an integer so that the returned pointers are appropriately aligned.
- * FIXME: Are there more requirements that is needed for assigning value atomically?
+/**
+ * round_up - Round up an integer so that the returned pointers are
+ *            appropriately aligned.
+ *
+ * @size: Size in bytes.
+ *
+ * Returns rounded value of @size.
+ *
+ * FIXME: Are there more requirements that is needed for assigning value
+ * atomically?
  */
-static inline unsigned int ROUNDUP(const unsigned int size) {
-	if (sizeof(void *) >= sizeof(long)) {
-		return ((size + sizeof(void *) - 1) / sizeof(void *)) * sizeof(void *);
-	} else {
-		return ((size + sizeof(long) - 1) / sizeof(long)) * sizeof(long);
-	}
+static inline unsigned int round_up(const unsigned int size)
+{
+	if (sizeof(void *) >= sizeof(long))
+		return ((size + sizeof(void *) - 1)
+			/ sizeof(void *)) * sizeof(void *);
+	else
+		return ((size + sizeof(long) - 1)
+			/ sizeof(long)) * sizeof(long);
 }
 
-static unsigned int allocated_memory_for_elements = 0;
+static unsigned int allocated_memory_for_elements;
 
-unsigned int GetMemoryUsedForElements(void)
+/**
+ * ccs_get_memory_used_for_elements - Get memory used for keeping
+ *                                    ACL structures.
+ *
+ * Returns memory used for keeping ACL structures.
+ */
+unsigned int ccs_get_memory_used_for_elements(void)
 {
 	return allocated_memory_for_elements;
 }
 
-/* Allocate memory for structures. The RAM is chunked, so NEVER try to kfree() the returned pointer. */
-void *alloc_element(const unsigned int size)
+/**
+ * ccs_alloc_element - Allocate permanent memory for structures.
+ *
+ * @size: Size in bytes.
+ *
+ * Returns pointer to allocated memory on success, NULL otherwise.
+ *
+ * The RAM is chunked, so NEVER try to kfree() the returned pointer.
+ */
+void *ccs_alloc_element(const unsigned int size)
 {
 	static DEFINE_MUTEX(lock);
-	static char *buf = NULL;
+	static char *buf;
 	static unsigned int buf_used_len = PAGE_SIZE;
 	char *ptr = NULL;
-	const unsigned int word_aligned_size = ROUNDUP(size);
-	if (word_aligned_size > PAGE_SIZE) return NULL;
+	const unsigned int word_aligned_size = round_up(size);
+	if (word_aligned_size > PAGE_SIZE)
+		return NULL;
 	mutex_lock(&lock);
 	if (buf_used_len + word_aligned_size > PAGE_SIZE) {
-		if ((ptr = kzalloc(PAGE_SIZE, GFP_KERNEL)) == NULL) {
-			printk("ERROR: Out of memory for alloc_element().\n");
-			if (!sbin_init_started) panic("MAC Initialization failed.\n");
+		ptr = kzalloc(PAGE_SIZE, GFP_KERNEL);
+		if (!ptr) {
+			printk(KERN_WARNING "ERROR: Out of memory "
+			       "for ccs_alloc_element().\n");
+			if (!sbin_init_started)
+				panic("MAC Initialization failed.\n");
 		} else {
 			buf = ptr;
 			allocated_memory_for_elements += PAGE_SIZE;
@@ -265,22 +358,28 @@
 		ptr = buf + buf_used_len;
 		buf_used_len += word_aligned_size;
 		for (i = 0; i < word_aligned_size; i++) {
-			if (ptr[i]) {
-				printk(KERN_ERR "WARNING: Reserved memory was tainted! The system might go wrong.\n");
-				ptr[i] = '\0';
-			}
+			if (!ptr[i])
+				continue;
+			printk(KERN_ERR "WARNING: Reserved memory was tainted! "
+			       "The system might go wrong.\n");
+			ptr[i] = '\0';
 		}
 	}
 	mutex_unlock(&lock);
 	return ptr;
 }
 
-/***** Shared memory allocator. *****/
+static unsigned int allocated_memory_for_savename;
+static unsigned int allocated_memory_for_pool;
 
-static unsigned int allocated_memory_for_savename = 0;
-static unsigned int allocated_memory_for_pool = 0;
 
-unsigned int GetMemoryUsedForSaveName(void)
+/**
+ * ccs_get_memory_used_for_save_name - Get memory used for keeping
+ *                                     string data.
+ *
+ * Returns memory used for keeping string data.
+ */
+unsigned int ccs_get_memory_used_for_save_name(void)
 {
 	return allocated_memory_for_savename + allocated_memory_for_pool;
 }
@@ -294,14 +393,22 @@
 
 struct free_memory_block_list {
 	struct list_head list;
-	char *ptr;                           /* Pointer to a free area.               */
-	int len;                             /* Length of the area.                   */
+	char *ptr;             /* Pointer to a free area. */
+	int len;               /* Length of the area.     */
 };
 
 static struct list1_head name_list[MAX_HASH]; /* The list of names. */
 
-/* Keep the given name on the RAM. The RAM is shared, so NEVER try to modify or kfree() the returned name. */
-const struct path_info *SaveName(const char *name)
+/**
+ * ccs_save_name - Allocate permanent memory for string data.
+ *
+ * @name: The string to store into the permernent memory.
+ *
+ * Returns pointer to "struct path_info" on success, NULL otherwise.
+ *
+ * The RAM is shared, so NEVER try to modify or kfree() the returned name.
+ */
+const struct path_info *ccs_save_name(const char *name)
 {
 	static LIST_HEAD(fmb_list);
 	static DEFINE_MUTEX(lock);
@@ -310,27 +417,33 @@
 	struct free_memory_block_list *fmb;
 	int len;
 	char *cp;
-	if (!name) return NULL;
+	if (!name)
+		return NULL;
 	len = strlen(name) + 1;
 	if (len > CCS_MAX_PATHNAME_LEN) {
-		printk("ERROR: Name too long for SaveName().\n");
+		printk(KERN_WARNING "ERROR: Name too long "
+		       "for ccs_save_name().\n");
 		return NULL;
 	}
 	hash = full_name_hash((const unsigned char *) name, len - 1);
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &name_list[hash % MAX_HASH], list) {
-		if (hash == ptr->entry.hash && strcmp(name, ptr->entry.name) == 0) goto out;
+		if (hash == ptr->entry.hash && !strcmp(name, ptr->entry.name))
+			goto out;
 	}
 	list_for_each_entry(fmb, &fmb_list, list) {
-		if (len <= fmb->len) goto ready;
+		if (len <= fmb->len)
+			goto ready;
 	}
 	cp = kzalloc(PAGE_SIZE, GFP_KERNEL);
 	fmb = kzalloc(sizeof(*fmb), GFP_KERNEL);
 	if (!cp || !fmb) {
 		kfree(cp);
 		kfree(fmb);
-		printk("ERROR: Out of memory for SaveName().\n");
-		if (!sbin_init_started) panic("MAC Initialization failed.\n");
+		printk(KERN_WARNING "ERROR: Out of memory "
+		       "for ccs_save_name().\n");
+		if (!sbin_init_started)
+			panic("MAC Initialization failed.\n");
 		ptr = NULL;
 		goto out;
 	}
@@ -339,11 +452,12 @@
 	fmb->ptr = cp;
 	fmb->len = PAGE_SIZE;
  ready:
-	ptr = alloc_element(sizeof(*ptr));
-	if (!ptr) goto out;
+	ptr = ccs_alloc_element(sizeof(*ptr));
+	if (!ptr)
+		goto out;
 	ptr->entry.name = fmb->ptr;
 	memmove(fmb->ptr, name, len);
-	fill_path_info(&ptr->entry);
+	ccs_fill_path_info(&ptr->entry);
 	fmb->ptr += len;
 	fmb->len -= len;
 	list1_add_tail_mb(&ptr->list, &name_list[hash % MAX_HASH]);
@@ -356,7 +470,7 @@
 	return ptr ? &ptr->entry : NULL;
 }
 
-/***** Dynamic memory allocator. *****/
+/* Dynamic memory allocator. */
 
 struct cache_entry {
 	struct list_head list;
@@ -364,10 +478,10 @@
 	int size;
 };
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-static struct kmem_cache *ccs_cachep = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+static struct kmem_cache *ccs_cachep;
 #else
-static kmem_cache_t *ccs_cachep = NULL;
+static kmem_cache_t *ccs_cachep;
 #endif
 
 #ifdef CCS_MAX_RESERVED_PAGES
@@ -379,38 +493,61 @@
 static struct ccs_page_buffer *ccs_page_buffer_pool[MAX_CCS_PAGE_BUFFER_POOL];
 static bool ccs_page_buffer_pool_in_use[MAX_CCS_PAGE_BUFFER_POOL];
 
-void __init realpath_Init(void)
+/**
+ * ccs_realpath_init - Initialize realpath related code.
+ *
+ * Returns nothing.
+ */
+void __init ccs_realpath_init(void)
 {
 	int i;
-	if (CCS_MAX_PATHNAME_LEN > PAGE_SIZE) panic("Bad size.");
-	if (sizeof(struct path_info_with_data) > sizeof(struct ccs_page_buffer)) panic("Bad size.");
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
-	ccs_cachep = kmem_cache_create("ccs_cache", sizeof(struct cache_entry), 0, 0, NULL);
+	if (CCS_MAX_PATHNAME_LEN > PAGE_SIZE)
+		panic("Bad size.");
+	if (sizeof(struct path_info_with_data) > sizeof(struct ccs_page_buffer))
+		panic("Bad size.");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
+	ccs_cachep = kmem_cache_create("ccs_cache", sizeof(struct cache_entry),
+				       0, 0, NULL);
 #else
-	ccs_cachep = kmem_cache_create("ccs_cache", sizeof(struct cache_entry), 0, 0, NULL, NULL);
+	ccs_cachep = kmem_cache_create("ccs_cache", sizeof(struct cache_entry),
+				       0, 0, NULL, NULL);
 #endif
-	if (!ccs_cachep) panic("Can't create cache.\n");
-	for (i = 0; i < MAX_HASH; i++) {
+	if (!ccs_cachep)
+		panic("Can't create cache.\n");
+	for (i = 0; i < MAX_HASH; i++)
 		INIT_LIST1_HEAD(&name_list[i]);
-	}
 	INIT_LIST1_HEAD(&KERNEL_DOMAIN.acl_info_list);
-	KERNEL_DOMAIN.domainname = SaveName(ROOT_NAME);
+	KERNEL_DOMAIN.domainname = ccs_save_name(ROOT_NAME);
 	list1_add_tail_mb(&KERNEL_DOMAIN.list, &domain_list);
-	if (FindDomain(ROOT_NAME) != &KERNEL_DOMAIN) panic("Can't register KERNEL_DOMAIN");
+	if (ccs_find_domain(ROOT_NAME) != &KERNEL_DOMAIN)
+		panic("Can't register KERNEL_DOMAIN");
 	memset(ccs_page_buffer_pool, 0, sizeof(ccs_page_buffer_pool));
-	for (i = 0; i < MAX_CCS_PAGE_BUFFER_POOL; i++) ccs_page_buffer_pool_in_use[i] = false;
+	for (i = 0; i < MAX_CCS_PAGE_BUFFER_POOL; i++)
+		ccs_page_buffer_pool_in_use[i] = false;
 }
 
 static LIST_HEAD(cache_list);
-static spinlock_t cache_list_lock = SPIN_LOCK_UNLOCKED;
-static unsigned int dynamic_memory_size = 0;
+static DEFINE_SPINLOCK(cache_list_lock);
+static unsigned int dynamic_memory_size;
 
-unsigned int GetMemoryUsedForDynamic(void)
+/**
+ * ccs_get_memory_used_for_dynamic - Get memory used for temporal purpose.
+ *
+ * Returns memory used for temporal purpose.
+ */
+unsigned int ccs_get_memory_used_for_dynamic(void)
 {
 	return dynamic_memory_size;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+/**
+ * round2 - Rounded up to power-of-two value.
+ *
+ * @size: Size in bytes.
+ *
+ * Returns power-of-two of @size.
+ */
 static int round2(size_t size)
 {
 #if PAGE_SIZE == 4096
@@ -423,48 +560,66 @@
 }
 #endif
 
-static spinlock_t ccs_page_buffer_pool_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(ccs_page_buffer_pool_lock);
 
+/**
+ * ccs_alloc - Allocate memory for temporal purpose.
+ *
+ * @size: Size in bytes.
+ *
+ * Returns pointer to allocated memory on success, NULL otherwise.
+ */
 void *ccs_alloc(const size_t size)
 {
 	int i;
 	void *ret;
 	struct cache_entry *new_entry;
-	if (size != sizeof(struct ccs_page_buffer)) goto normal;
+	if (size != sizeof(struct ccs_page_buffer))
+		goto normal;
 	for (i = 0; i < MAX_CCS_PAGE_BUFFER_POOL; i++) {
 		struct ccs_page_buffer *ptr;
-		if (ccs_page_buffer_pool_in_use[i]) continue;
+		bool in_use;
+		if (ccs_page_buffer_pool_in_use[i])
+			continue;
+		/***** CRITICAL SECTION START *****/
 		spin_lock(&ccs_page_buffer_pool_lock);
-		if (ccs_page_buffer_pool_in_use[i]) {
-			spin_unlock(&ccs_page_buffer_pool_lock);
+		in_use = ccs_page_buffer_pool_in_use[i];
+		if (!in_use)
+			ccs_page_buffer_pool_in_use[i] = true;
+		spin_unlock(&ccs_page_buffer_pool_lock);
+		/***** CRITICAL SECTION END *****/
+		if (in_use)
 			continue;
-		}
-		ccs_page_buffer_pool_in_use[i] = true;
-		spin_unlock(&ccs_page_buffer_pool_lock);
 		ptr = ccs_page_buffer_pool[i];
-		if (!ptr) {
-			ptr = kmalloc(sizeof(struct ccs_page_buffer), GFP_KERNEL);
-			spin_lock(&ccs_page_buffer_pool_lock);
-			if (ptr) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-				allocated_memory_for_pool += ksize(ptr);
+		if (ptr)
+			goto ok;
+		ptr = kmalloc(sizeof(struct ccs_page_buffer), GFP_KERNEL);
+		/***** CRITICAL SECTION START *****/
+		spin_lock(&ccs_page_buffer_pool_lock);
+		if (ptr) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+			allocated_memory_for_pool += ksize(ptr);
 #else
-				allocated_memory_for_pool += round2(sizeof(struct ccs_page_buffer));
+			allocated_memory_for_pool += round2(size);
 #endif
-			} else {
-				ccs_page_buffer_pool_in_use[i] = false;
-			}
-			spin_unlock(&ccs_page_buffer_pool_lock);
-			if (!ptr) goto normal;
-			ccs_page_buffer_pool[i] = ptr;
-			printk(KERN_DEBUG "Allocated permanent buffer %d/%d\n", i, MAX_CCS_PAGE_BUFFER_POOL);
+		} else {
+			ccs_page_buffer_pool_in_use[i] = false;
 		}
+		spin_unlock(&ccs_page_buffer_pool_lock);
+		/***** CRITICAL SECTION END *****/
+		if (!ptr)
+			goto normal;
+		ccs_page_buffer_pool[i] = ptr;
+		printk(KERN_DEBUG "Allocated permanent buffer %d/%d\n",
+		       i, MAX_CCS_PAGE_BUFFER_POOL);
+ ok:
 		memset(ptr, 0, sizeof(struct ccs_page_buffer));
 		return ptr;
 	}
  normal:
 	ret = kzalloc(size, GFP_KERNEL);
-	if (!ret) goto out;
+	if (!ret)
+		goto out;
 	new_entry = kmem_cache_alloc(ccs_cachep, GFP_KERNEL);
 	if (!new_entry) {
 		kfree(ret); ret = NULL;
@@ -472,34 +627,50 @@
 	}
 	INIT_LIST_HEAD(&new_entry->list);
 	new_entry->ptr = ret;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 	new_entry->size = ksize(ret);
 #else
 	new_entry->size = round2(size);
 #endif
+	/***** CRITICAL SECTION START *****/
 	spin_lock(&cache_list_lock);
 	list_add_tail(&new_entry->list, &cache_list);
 	dynamic_memory_size += new_entry->size;
 	spin_unlock(&cache_list_lock);
+	/***** CRITICAL SECTION END *****/
  out:
 	return ret;
 }
 
+/**
+ * ccs_free - Release memory allocated by ccs_alloc().
+ *
+ * @p: Pointer returned by ccs_alloc(). May be NULL.
+ *
+ * Returns nothing.
+ */
 void ccs_free(const void *p)
 {
 	int i;
 	struct list_head *v;
 	struct cache_entry *entry = NULL;
-	if (!p) return;
+	if (!p)
+		return;
 	for (i = 0; i < MAX_CCS_PAGE_BUFFER_POOL; i++) {
 		bool done;
-		if (p != ccs_page_buffer_pool[i]) continue;
+		if (p != ccs_page_buffer_pool[i])
+			continue;
+		/***** CRITICAL SECTION START *****/
 		spin_lock(&ccs_page_buffer_pool_lock);
 		done = ccs_page_buffer_pool_in_use[i];
-		if (done) ccs_page_buffer_pool_in_use[i] = false;
+		if (done)
+			ccs_page_buffer_pool_in_use[i] = false;
 		spin_unlock(&ccs_page_buffer_pool_lock);
-		if (done) return;
+		/***** CRITICAL SECTION END *****/
+		if (done)
+			return;
 	}
+	/***** CRITICAL SECTION START *****/
 	spin_lock(&cache_list_lock);
 	list_for_each(v, &cache_list) {
 		entry = list_entry(v, struct cache_entry, list);
@@ -511,10 +682,11 @@
 		break;
 	}
 	spin_unlock(&cache_list_lock);
+	/***** CRITICAL SECTION END *****/
 	if (entry) {
 		kfree(p);
 		kmem_cache_free(ccs_cachep, entry);
 	} else {
-		printk("BUG: ccs_free() with invalid pointer.\n");
+		printk(KERN_WARNING "BUG: ccs_free() with invalid pointer.\n");
 	}
 }
Index: trunk/1.6.x/ccs-patch/fs/syaoran_2.6.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/syaoran_2.6.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/syaoran_2.6.c	(working copy)
@@ -61,38 +61,44 @@
 static struct file_operations syaoran_file_operations;
 
 static struct backing_dev_info syaoran_backing_dev_info = {
-	.ra_pages = 0,        /* No readahead */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
-	.memory_backed  = 1,    /* Does not contribute to dirty memory */
+	.ra_pages      = 0,    /* No readahead */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 12)
+	.memory_backed = 1,    /* Does not contribute to dirty memory */
 #else
-	.capabilities = BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_WRITEBACK |
-					BDI_CAP_MAP_DIRECT | BDI_CAP_MAP_COPY |
-					BDI_CAP_READ_MAP | BDI_CAP_WRITE_MAP | BDI_CAP_EXEC_MAP,
+	.capabilities  = BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_WRITEBACK |
+	BDI_CAP_MAP_DIRECT | BDI_CAP_MAP_COPY |
+	BDI_CAP_READ_MAP | BDI_CAP_WRITE_MAP |
+	BDI_CAP_EXEC_MAP,
 #endif
 };
 
 #include <linux/syaoran.h>
 
-static struct inode *syaoran_get_inode(struct super_block *sb, int mode, dev_t dev)
+static struct inode *syaoran_get_inode(struct super_block *sb, int mode,
+				       dev_t dev)
 {
-	struct inode * inode = new_inode(sb);
+	struct inode *inode = new_inode(sb);
 
 	if (inode) {
 		inode->i_mode = mode;
 		inode->i_uid = current->fsuid;
 		inode->i_gid = current->fsgid;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 		inode->i_blksize = PAGE_CACHE_SIZE;
 #endif
 		inode->i_blocks = 0;
 		inode->i_mapping->a_ops = &syaoran_aops;
 		inode->i_mapping->backing_dev_info = &syaoran_backing_dev_info;
-		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+		inode->i_ctime = CURRENT_TIME;
+		inode->i_mtime = inode->i_ctime;
+		inode->i_atime = inode->i_mtime;
 		switch (mode & S_IFMT) {
 		default:
 			init_special_inode(inode, mode, dev);
-			if (S_ISBLK(mode)) inode->i_fop = &wrapped_def_blk_fops;
-			else if (S_ISCHR(mode)) inode->i_fop = &wrapped_def_chr_fops;
+			if (S_ISBLK(mode))
+				inode->i_fop = &wrapped_def_blk_fops;
+			else if (S_ISCHR(mode))
+				inode->i_fop = &wrapped_def_chr_fops;
 			inode->i_op = &syaoran_file_inode_operations;
 			break;
 		case S_IFREG:
@@ -102,8 +108,10 @@
 		case S_IFDIR:
 			inode->i_op = &syaoran_dir_inode_operations;
 			inode->i_fop = &simple_dir_operations;
-
-			/* directory inodes start off with i_nlink == 2 (for "." entry) */
+			/*
+			 * directory inodes start off with i_nlink == 2
+			 * (for "." entry)
+			 */
 			inode->i_nlink++;
 			break;
 		case S_IFLNK:
@@ -118,11 +126,13 @@
  * File creation. Allocate an inode, and we're done..
  */
 /* SMP-safe */
-static int syaoran_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
+static int syaoran_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			 dev_t dev)
 {
-	struct inode * inode;
+	struct inode *inode;
 	int error = -ENOSPC;
-	if (MayCreateNode(dentry, mode, dev) < 0) return -EPERM;
+	if (syaoran_may_create_node(dentry, mode, dev) < 0)
+		return -EPERM;
 	inode = syaoran_get_inode(dir->i_sb, mode, dev);
 	if (inode) {
 		if (dir->i_mode & S_ISGID) {
@@ -137,7 +147,7 @@
 	return error;
 }
 
-static int syaoran_mkdir(struct inode * dir, struct dentry * dentry, int mode)
+static int syaoran_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	int retval = syaoran_mknod(dir, dentry, mode | S_IFDIR, 0);
 	if (!retval)
@@ -145,16 +155,19 @@
 	return retval;
 }
 
-static int syaoran_create(struct inode *dir, struct dentry *dentry, int mode, struct nameidata *nd)
+static int syaoran_create(struct inode *dir, struct dentry *dentry, int mode,
+			  struct nameidata *nd)
 {
 	return syaoran_mknod(dir, dentry, mode | S_IFREG, 0);
 }
 
-static int syaoran_symlink(struct inode * dir, struct dentry *dentry, const char * symname)
+static int syaoran_symlink(struct inode *dir, struct dentry *dentry,
+			   const char *symname)
 {
 	struct inode *inode;
 	int error = -ENOSPC;
-	if (MayCreateNode(dentry, S_IFLNK, 0) < 0) return -EPERM;
+	if (syaoran_may_create_node(dentry, S_IFLNK, 0) < 0)
+		return -EPERM;
 	inode = syaoran_get_inode(dir->i_sb, S_IFLNK|S_IRWXUGO, 0);
 	if (inode) {
 		int l = strlen(symname)+1;
@@ -170,48 +183,61 @@
 	return error;
 }
 
-static int syaoran_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
+static int syaoran_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *dentry)
 {
 	struct inode *inode = old_dentry->d_inode;
-	if (!inode || MayCreateNode(dentry, inode->i_mode, inode->i_rdev) < 0) return -EPERM;
+	if (!inode || syaoran_may_create_node(dentry, inode->i_mode,
+					      inode->i_rdev) < 0)
+		return -EPERM;
 	return simple_link(old_dentry, dir, dentry);
 }
 
-static int syaoran_unlink(struct inode * dir, struct dentry *dentry)
+static int syaoran_unlink(struct inode *dir, struct dentry *dentry)
 {
-	if (MayModifyNode(dentry, MAY_DELETE) < 0) return -EPERM;
+	if (syaoran_may_modify_node(dentry, MAY_DELETE) < 0)
+		return -EPERM;
 	return simple_unlink(dir, dentry);
 }
 
-static int syaoran_rename(struct inode * old_dir, struct dentry *old_dentry, struct inode * new_dir,struct dentry *new_dentry)
+static int syaoran_rename(struct inode *old_dir, struct dentry *old_dentry,
+			  struct inode *new_dir, struct dentry *new_dentry)
 {
 	struct inode *inode = old_dentry->d_inode;
-	if (!inode || MayModifyNode(old_dentry, MAY_DELETE) < 0 || MayCreateNode(new_dentry, inode->i_mode, inode->i_rdev) < 0) return -EPERM;
+	if (!inode || syaoran_may_modify_node(old_dentry, MAY_DELETE) < 0 ||
+	    syaoran_may_create_node(new_dentry, inode->i_mode,
+				    inode->i_rdev) < 0)
+		return -EPERM;
 	return simple_rename(old_dir, old_dentry, new_dir, new_dentry);
 }
 
 static int syaoran_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	if (MayModifyNode(dentry, MAY_DELETE) < 0) return -EPERM;
+	if (syaoran_may_modify_node(dentry, MAY_DELETE) < 0)
+		return -EPERM;
 	return simple_rmdir(dir, dentry);
 }
 
-static int syaoran_setattr(struct dentry * dentry, struct iattr * attr)
+static int syaoran_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct inode *inode = dentry->d_inode;
 	int error = inode_change_ok(inode, attr);
 	if (!error) {
 		unsigned int ia_valid = attr->ia_valid;
 		unsigned int flags = 0;
-		if (ia_valid & (ATTR_UID | ATTR_GID)) flags |= MAY_CHOWN;
-		if (ia_valid & ATTR_MODE) flags |= MAY_CHMOD;
-		if (MayModifyNode(dentry, flags) < 0) return -EPERM;
-		if (!error) error = inode_setattr(inode, attr);
+		if (ia_valid & (ATTR_UID | ATTR_GID))
+			flags |= MAY_CHOWN;
+		if (ia_valid & ATTR_MODE)
+			flags |= MAY_CHMOD;
+		if (syaoran_may_modify_node(dentry, flags) < 0)
+			return -EPERM;
+		if (!error)
+			error = inode_setattr(inode, attr);
 	}
 	return error;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 static struct address_space_operations syaoran_aops = {
 	.readpage       = simple_readpage,
 	.prepare_write  = simple_prepare_write,
@@ -233,23 +259,23 @@
 #endif
 
 static struct file_operations syaoran_file_operations = {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
-	.read       = generic_file_read,
-	.write      = generic_file_write,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+	.read        = generic_file_read,
+	.write       = generic_file_write,
 #else
-	.aio_read   = generic_file_aio_read,
-	.read       = do_sync_read,
-	.aio_write  = generic_file_aio_write,
-	.write      = do_sync_write,
+	.aio_read    = generic_file_aio_read,
+	.read        = do_sync_read,
+	.aio_write   = generic_file_aio_write,
+	.write       = do_sync_write,
 #endif
-	.mmap       = generic_file_mmap,
-	.fsync      = simple_sync_file,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
-	.sendfile   = generic_file_sendfile,
+	.mmap        = generic_file_mmap,
+	.fsync       = simple_sync_file,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+	.sendfile    = generic_file_sendfile,
 #else
-	.splice_read    = generic_file_splice_read,
+	.splice_read = generic_file_splice_read,
 #endif
-	.llseek     = generic_file_llseek,
+	.llseek      = generic_file_llseek,
 };
 
 static struct inode_operations syaoran_file_inode_operations = {
@@ -283,22 +309,23 @@
 	.put_super  = syaoran_put_super,
 };
 
-static int syaoran_fill_super(struct super_block * sb, void * data, int silent)
+static int syaoran_fill_super(struct super_block *sb, void *data, int silent)
 {
-	struct inode * inode;
-	struct dentry * root;
+	struct inode *inode;
+	struct dentry *root;
 
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->s_magic = SYAORAN_MAGIC;
 	sb->s_op = &syaoran_ops;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,9)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
 	sb->s_time_gran = 1;
 #endif
 	{
-		int error;
-		if ((error = Syaoran_Initialize(sb, data)) < 0) return error;
+		int error = syaoran_initialize(sb, data);
+		if (error < 0)
+			return error;
 	}
 	inode = syaoran_get_inode(sb, S_IFDIR | 0755, 0);
 	if (!inode)
@@ -310,19 +337,21 @@
 		return -ENOMEM;
 	}
 	sb->s_root = root;
-	MakeInitialNodes(sb);
+	syaoran_make_initial_nodes(sb);
 	return 0;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 static struct super_block *syaoran_get_sb(struct file_system_type *fs_type,
-	int flags, const char *dev_name, void *data)
+					  int flags, const char *dev_name,
+					  void *data)
 {
 	return get_sb_nodev(fs_type, flags, data, syaoran_fill_super);
 }
 #else
 static int syaoran_get_sb(struct file_system_type *fs_type,
-	int flags, const char *dev_name, void *data, struct vfsmount *mnt)
+			  int flags, const char *dev_name, void *data,
+			  struct vfsmount *mnt)
 {
 	return get_sb_nodev(fs_type, flags, data, syaoran_fill_super, mnt);
 }
Index: trunk/1.6.x/ccs-patch/fs/sakura_chroot.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_chroot.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/sakura_chroot.c	(working copy)
@@ -11,18 +11,17 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** SAKURA Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #else
 #include <linux/fs.h>
 #endif
 
-/***** The structure for chroot restrictions. *****/
+/* The structure for chroot restrictions. */
 
 struct chroot_entry {
 	struct list1_head list;
@@ -30,18 +29,29 @@
 	bool is_deleted;
 };
 
-/*************************  CHROOT RESTRICTION HANDLER  *************************/
+/* Chroot restriction handler. */
 
 static LIST1_HEAD(chroot_list);
 
-static int AddChrootACL(const char *dir, const bool is_delete)
+/**
+ * update_chroot_acl -
+ *
+ * @dir:       The name of directory.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_chroot_acl(const char *dir, const bool is_delete)
 {
 	struct chroot_entry *new_entry, *ptr;
 	const struct path_info *saved_dir;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
-	if (!IsCorrectPath(dir, 1, 0, 1, __FUNCTION__)) return -EINVAL;
-	if ((saved_dir = SaveName(dir)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(dir, 1, 0, 1, __func__))
+		return -EINVAL;
+	saved_dir = ccs_save_name(dir);
+	if (!saved_dir)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &chroot_list, list) {
 		if (ptr->dir == saved_dir) {
@@ -54,73 +64,124 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->dir = saved_dir;
 	list1_add_tail_mb(&new_entry->list, &chroot_list);
 	error = 0;
-	printk("%sAllow chroot() to %s\n", ccs_log_level, dir);
+	printk(KERN_CONT "%sAllow chroot() to %s\n", ccs_log_level, dir);
  out:
 	mutex_unlock(&lock);
 	return error;
 }
 
-int CheckChRootPermission(struct nameidata *nd)
+/**
+ * print_error - Print error message.
+ *
+ * @root_name: Requested directory name.
+ * @mode:      Access control mode.
+ * @error:     Error value.
+ *
+ * Returns 0 if @mode is not enforcing mode or permitted by the administrator's
+ * decision, negative value otherwise.
+ */
+static int print_error(const char *root_name, const u8 mode, int error)
 {
+	const bool is_enforce = (mode == 3);
+	const char *exename = ccs_get_exe();
+	printk(KERN_WARNING "SAKURA-%s: chroot %s (pid=%d:exe=%s): "
+	       "Permission denied.\n", ccs_get_msg(is_enforce),
+	       root_name, current->pid, exename);
+	if (is_enforce &&
+	    ccs_check_supervisor("# %s is requesting\n"
+				 "chroot %s\n", exename, root_name) == 0)
+		error = 0;
+	if (exename)
+		ccs_free(exename);
+	if (mode == 1 && root_name) {
+		update_chroot_acl(root_name, 0);
+		ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
+	}
+	if (!is_enforce)
+		error = 0;
+	return error;
+}
+
+/**
+ * ccs_check_chroot_permission - Check permission for chroot().
+ *
+ * @nd: Pointer to "struct nameidata".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_chroot_permission(struct nameidata *nd)
+{
 	int error = -EPERM;
 	char *root_name;
-	const u8 mode = CheckCCSFlags(CCS_SAKURA_RESTRICT_CHROOT);
-	if (!mode) return 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-	root_name = realpath_from_dentry(nd->path.dentry, nd->path.mnt);
+	const u8 mode = ccs_check_flags(CCS_SAKURA_RESTRICT_CHROOT);
+	if (!mode)
+		return 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	root_name = ccs_realpath_from_dentry(nd->path.dentry, nd->path.mnt);
 #else
-	root_name = realpath_from_dentry(nd->dentry, nd->mnt);
+	root_name = ccs_realpath_from_dentry(nd->dentry, nd->mnt);
 #endif
 	if (root_name) {
 		struct path_info dir;
 		dir.name = root_name;
-		fill_path_info(&dir);
+		ccs_fill_path_info(&dir);
 		if (dir.is_dir) {
 			struct chroot_entry *ptr;
 			list1_for_each_entry(ptr, &chroot_list, list) {
-				if (ptr->is_deleted) continue;
-				if (PathMatchesToPattern(&dir, ptr->dir)) {
+				if (ptr->is_deleted)
+					continue;
+				if (ccs_path_matches_pattern(&dir, ptr->dir)) {
 					error = 0;
 					break;
 				}
 			}
 		}
 	}
-	if (error) {
-		const bool is_enforce = (mode == 3);
-		const char *exename = GetEXE();
-		printk("SAKURA-%s: chroot %s (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), root_name, current->pid, exename);
-		if (is_enforce && CheckSupervisor("# %s is requesting\nchroot %s\n", exename, root_name) == 0) error = 0;
-		if (exename) ccs_free(exename);
-		if (mode == 1 && root_name) {
-			AddChrootACL(root_name, 0);
-			UpdateCounter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
-		}
-		if (!is_enforce) error = 0;
-	}
+	if (error)
+		error = print_error(root_name, mode, error);
 	ccs_free(root_name);
 	return error;
 }
 
-int AddChrootPolicy(char *data, const bool is_delete)
+/**
+ * ccs_write_chroot_policy -
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_chroot_policy(char *data, const bool is_delete)
 {
-	return AddChrootACL(data, is_delete);
+	return update_chroot_acl(data, is_delete);
 }
 
-int ReadChrootPolicy(struct io_buffer *head)
+/**
+ * ccs_read_chroot_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_chroot_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &chroot_list) {
 		struct chroot_entry *ptr;
 		ptr = list1_entry(pos, struct chroot_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALLOW_CHROOT "%s\n", ptr->dir->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, KEYWORD_ALLOW_CHROOT "%s\n",
+				   ptr->dir->name))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
-
-/***** SAKURA Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/sakura_pivot.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_pivot.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/sakura_pivot.c	(working copy)
@@ -11,18 +11,17 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** SAKURA Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #else
 #include <linux/fs.h>
 #endif
 
-/***** The structure for pivot_root restrictions. *****/
+/* The structure for pivot_root restrictions. */
 
 struct pivot_root_entry {
 	struct list1_head list;
@@ -31,21 +30,37 @@
 	bool is_deleted;
 };
 
-/*************************  PIVOT_ROOT RESTRICTION HANDLER  *************************/
+/* Pivot_root restriction handler. */
 
 static LIST1_HEAD(pivot_root_list);
 
-static int AddPivotRootACL(const char *old_root, const char *new_root, const bool is_delete)
+/**
+ * update_pivot_root_acl -
+ *
+ * @old_root:  The name of old root directory.
+ * @new_root:  The name of new root directory.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_pivot_root_acl(const char *old_root, const char *new_root,
+				 const bool is_delete)
 {
 	struct pivot_root_entry *new_entry, *ptr;
 	const struct path_info *saved_old_root, *saved_new_root;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
-	if (!IsCorrectPath(old_root, 1, 0, 1, __FUNCTION__) || !IsCorrectPath(new_root, 1, 0, 1, __FUNCTION__)) return -EINVAL;
-	if ((saved_old_root = SaveName(old_root)) == NULL || (saved_new_root = SaveName(new_root)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(old_root, 1, 0, 1, __func__) ||
+	    !ccs_is_correct_path(new_root, 1, 0, 1, __func__))
+		return -EINVAL;
+	saved_old_root = ccs_save_name(old_root);
+	saved_new_root = ccs_save_name(new_root);
+	if (!saved_old_root || !saved_new_root)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &pivot_root_list, list) {
-		if (ptr->old_root == saved_old_root && ptr->new_root == saved_new_root) {
+		if (ptr->old_root == saved_old_root &&
+		    ptr->new_root == saved_new_root) {
 			ptr->is_deleted = is_delete;
 			error = 0;
 			goto out;
@@ -55,41 +70,60 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->old_root = saved_old_root;
 	new_entry->new_root = saved_new_root;
 	list1_add_tail_mb(&new_entry->list, &pivot_root_list);
 	error = 0;
-	printk("%sAllow pivot_root(%s, %s)\n", ccs_log_level, new_root, old_root);
+	printk(KERN_CONT "%sAllow pivot_root(%s, %s)\n", ccs_log_level,
+	       new_root, old_root);
  out:
 	mutex_unlock(&lock);
 	return error;
 }
 
-int CheckPivotRootPermission(struct nameidata *old_nd, struct nameidata *new_nd)
+/**
+ * ccs_check_pivot_root_permission -
+ *
+ * @old_nd: Pointer to "struct nameidata".
+ * @new_nd: Pointer to "struct nameidata".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_pivot_root_permission(struct nameidata *old_nd,
+				    struct nameidata *new_nd)
 {
 	int error = -EPERM;
 	char *old_root, *new_root;
-	const u8 mode = CheckCCSFlags(CCS_SAKURA_RESTRICT_PIVOT_ROOT);
-	if (!mode) return 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-	old_root = realpath_from_dentry(old_nd->path.dentry, old_nd->path.mnt);
-	new_root = realpath_from_dentry(new_nd->path.dentry, new_nd->path.mnt);
+	const u8 mode = ccs_check_flags(CCS_SAKURA_RESTRICT_PIVOT_ROOT);
+	if (!mode)
+		return 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	old_root = ccs_realpath_from_dentry(old_nd->path.dentry,
+					    old_nd->path.mnt);
+	new_root = ccs_realpath_from_dentry(new_nd->path.dentry,
+					    new_nd->path.mnt);
 #else
-	old_root = realpath_from_dentry(old_nd->dentry, old_nd->mnt);
-	new_root = realpath_from_dentry(new_nd->dentry, new_nd->mnt);
+	old_root = ccs_realpath_from_dentry(old_nd->dentry, old_nd->mnt);
+	new_root = ccs_realpath_from_dentry(new_nd->dentry, new_nd->mnt);
 #endif
 	if (old_root && new_root) {
 		struct path_info old_root_dir, new_root_dir;
 		old_root_dir.name = old_root;
-		fill_path_info(&old_root_dir);
+		ccs_fill_path_info(&old_root_dir);
 		new_root_dir.name = new_root;
-		fill_path_info(&new_root_dir);
+		ccs_fill_path_info(&new_root_dir);
 		if (old_root_dir.is_dir && new_root_dir.is_dir) {
 			struct pivot_root_entry *ptr;
 			list1_for_each_entry(ptr, &pivot_root_list, list) {
-				if (ptr->is_deleted) continue;
-				if (PathMatchesToPattern(&old_root_dir, ptr->old_root) && PathMatchesToPattern(&new_root_dir, ptr->new_root)) {
+				if (ptr->is_deleted)
+					continue;
+				if (ccs_path_matches_pattern(&old_root_dir,
+							     ptr->old_root) &&
+				    ccs_path_matches_pattern(&new_root_dir,
+							     ptr->new_root)) {
 					error = 0;
 					break;
 				}
@@ -98,39 +132,67 @@
 	}
 	if (error) {
 		const bool is_enforce = (mode == 3);
-		const char *exename = GetEXE();
-		printk("SAKURA-%s: pivot_root %s %s (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), new_root, old_root, current->pid, exename);
-		if (is_enforce && CheckSupervisor("# %s is requesting\npivot_root %s %s\n", exename, new_root, old_root) == 0) error = 0;
-		if (exename) ccs_free(exename);
+		const char *exename = ccs_get_exe();
+		printk(KERN_WARNING "SAKURA-%s: pivot_root %s %s "
+		       "(pid=%d:exe=%s): Permission denied.\n",
+		       ccs_get_msg(is_enforce), new_root, old_root,
+		       current->pid, exename);
+		if (is_enforce && ccs_check_supervisor("# %s is requesting\n"
+						       "pivot_root %s %s\n",
+						       exename, new_root,
+						       old_root) == 0)
+			error = 0;
+		if (exename)
+			ccs_free(exename);
 		if (mode == 1 && old_root && new_root) {
-			AddPivotRootACL(old_root, new_root, 0);
-			UpdateCounter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
+			update_pivot_root_acl(old_root, new_root, 0);
+			ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 		}
-		if (!is_enforce) error = 0;
+		if (!is_enforce)
+			error = 0;
 	}
 	ccs_free(old_root);
 	ccs_free(new_root);
 	return error;
 }
 
-int AddPivotRootPolicy(char *data, const bool is_delete)
+/**
+ * ccs_write_pivot_root_policy -
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_pivot_root_policy(char *data, const bool is_delete)
 {
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
-	return AddPivotRootACL(cp, data, is_delete);
+	return update_pivot_root_acl(cp, data, is_delete);
 }
 
-int ReadPivotRootPolicy(struct io_buffer *head)
+/**
+ * ccs_read_pivot_root_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_pivot_root_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &pivot_root_list) {
 		struct pivot_root_entry *ptr;
 		ptr = list1_entry(pos, struct pivot_root_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALLOW_PIVOT_ROOT "%s %s\n", ptr->new_root->name, ptr->old_root->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, KEYWORD_ALLOW_PIVOT_ROOT "%s %s\n",
+				   ptr->new_root->name, ptr->old_root->name))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
-
-/***** SAKURA Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/sakura_mount.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_mount.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/sakura_mount.c	(working copy)
@@ -11,42 +11,50 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** SAKURA Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
 #include <linux/namespace.h>
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15)
 #define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
 #define MS_PRIVATE	(1<<18)	/* change to private */
 #define MS_SLAVE	(1<<19)	/* change to slave */
 #define MS_SHARED	(1<<20)	/* change to shared */
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #else
+/* For compatibility with older kernels. */
 static inline void module_put(struct module *module)
 {
-	if (module) __MOD_DEC_USE_COUNT(module);
+	if (module)
+		__MOD_DEC_USE_COUNT(module);
 }
 #endif
 
-/***** KEYWORDS for mount restrictions. *****/
+/* Keywords for mount restrictions. */
 
-#define MOUNT_BIND_KEYWORD    "--bind"    /* Allow to call 'mount --bind /source_dir /dest_dir' */
-#define MOUNT_MOVE_KEYWORD    "--move"    /* Allow to call 'mount --move /old_dir    /new_dir ' */
-#define MOUNT_REMOUNT_KEYWORD "--remount" /* Allow to call 'mount -o remount /dir             ' */
-#define MOUNT_MAKE_UNBINDABLE_KEYWORD "--make-unbindable" /* Allow to call 'mount --make-unbindable /dir' */
-#define MOUNT_MAKE_PRIVATE_KEYWORD    "--make-private"    /* Allow to call 'mount --make-private /dir'    */
-#define MOUNT_MAKE_SLAVE_KEYWORD      "--make-slave"      /* Allow to call 'mount --make-slave /dir'      */
-#define MOUNT_MAKE_SHARED_KEYWORD     "--make-shared"     /* Allow to call 'mount --make-shared /dir'     */
+/* Allow to call 'mount --bind /source_dir /dest_dir' */
+#define MOUNT_BIND_KEYWORD                               "--bind"
+/* Allow to call 'mount --move /old_dir    /new_dir ' */
+#define MOUNT_MOVE_KEYWORD                               "--move"
+/* Allow to call 'mount -o remount /dir             ' */
+#define MOUNT_REMOUNT_KEYWORD                            "--remount"
+/* Allow to call 'mount --make-unbindable /dir'       */
+#define MOUNT_MAKE_UNBINDABLE_KEYWORD                    "--make-unbindable"
+/* Allow to call 'mount --make-private /dir'          */
+#define MOUNT_MAKE_PRIVATE_KEYWORD                       "--make-private"
+/* Allow to call 'mount --make-slave /dir'            */
+#define MOUNT_MAKE_SLAVE_KEYWORD                         "--make-slave"
+/* Allow to call 'mount --make-shared /dir'           */
+#define MOUNT_MAKE_SHARED_KEYWORD                        "--make-shared"
 
-/***** The structure for mount restrictions. *****/
+/* The structure for mount restrictions. */
 
 struct mount_entry {
 	struct list1_head list;
@@ -57,35 +65,65 @@
 	bool is_deleted;
 };
 
-/*************************  MOUNT RESTRICTION HANDLER  *************************/
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+/* For compatibility with older kernels. */
 static void put_filesystem(struct file_system_type *fs)
 {
 	module_put(fs->owner);
 }
 #endif
 
+/* The list for "struct mount_entry". */
 static LIST1_HEAD(mount_list);
 
-static int AddMountACL(const char *dev_name, const char *dir_name, const char *fs_type, const unsigned long flags, const bool is_delete)
+/**
+ * update_mount_acl -
+ *
+ * @dev_name:  Name of device file.
+ * @dir_name:  Name of mount point.
+ * @fs_type:   Name of filesystem.
+ * @flags:     Mount options.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_mount_acl(const char *dev_name, const char *dir_name,
+			    const char *fs_type, const unsigned long flags,
+			    const bool is_delete)
 {
+	struct file_system_type *type = NULL;
 	struct mount_entry *new_entry, *ptr;
 	const struct path_info *fs, *dev, *dir;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
-	if ((fs = SaveName(fs_type)) == NULL) return -EINVAL;
-	if (!dev_name) dev_name = "<NULL>"; /* Map dev_name to "<NULL>" for if no dev_name given. */
-	if (strcmp(fs->name, MOUNT_REMOUNT_KEYWORD) == 0) dev_name = "any"; /* Fix dev_name to "any" for remount permission. */
-	if (strcmp(fs->name, MOUNT_MAKE_UNBINDABLE_KEYWORD) == 0 ||
-		strcmp(fs->name, MOUNT_MAKE_PRIVATE_KEYWORD) == 0 ||
-		strcmp(fs->name, MOUNT_MAKE_SLAVE_KEYWORD) == 0 ||
-		strcmp(fs->name, MOUNT_MAKE_SHARED_KEYWORD) == 0) dev_name = "any";
-	if (!IsCorrectPath(dev_name, 0, 0, 0, __FUNCTION__) || !IsCorrectPath(dir_name, 0, 0, 0, __FUNCTION__)) return -EINVAL;
-	if ((dev = SaveName(dev_name)) == NULL || (dir = SaveName(dir_name)) == NULL) return -ENOMEM;
+	fs = ccs_save_name(fs_type);
+	if (!fs)
+		return -EINVAL;
+	if (!dev_name)
+		/* Map dev_name to "<NULL>" for if no dev_name given. */
+		dev_name = "<NULL>";
+	if (!strcmp(fs->name, MOUNT_REMOUNT_KEYWORD))
+		/* Fix dev_name to "any" for remount permission. */
+		dev_name = "any";
+	if (!strcmp(fs->name, MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
+	    !strcmp(fs->name, MOUNT_MAKE_PRIVATE_KEYWORD) ||
+	    !strcmp(fs->name, MOUNT_MAKE_SLAVE_KEYWORD) ||
+	    !strcmp(fs->name, MOUNT_MAKE_SHARED_KEYWORD))
+		dev_name = "any";
+	if (!ccs_is_correct_path(dev_name, 0, 0, 0, __func__) ||
+	    !ccs_is_correct_path(dir_name, 0, 0, 0, __func__))
+		return -EINVAL;
+	dev = ccs_save_name(dev_name);
+	dir = ccs_save_name(dir_name);
+	if (!dev || !dir)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &mount_list, list) {
-		if (ptr->flags != flags || pathcmp(ptr->dev_name, dev) || pathcmp(ptr->dir_name, dir) || pathcmp(ptr->fs_type, fs)) continue;
+		if (ptr->flags != flags ||
+		    ccs_pathcmp(ptr->dev_name, dev) ||
+		    ccs_pathcmp(ptr->dir_name, dir) ||
+		    ccs_pathcmp(ptr->fs_type, fs))
+			continue;
 		error = 0;
 		if (is_delete) {
 			ptr->is_deleted = true;
@@ -102,7 +140,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->dev_name = dev;
 	new_entry->dir_name = dir;
 	new_entry->fs_type = fs;
@@ -111,37 +151,187 @@
 	error = 0;
 	ptr = new_entry;
  update:
-	{
-		struct file_system_type *type = NULL;
-		if (strcmp(fs->name, MOUNT_REMOUNT_KEYWORD) == 0) {
-			printk("%sAllow remount %s with options 0x%lX.\n", ccs_log_level, dir->name, ptr->flags);
-		} else if (strcmp(fs->name, MOUNT_BIND_KEYWORD) == 0 || strcmp(fs->name, MOUNT_MOVE_KEYWORD) == 0) {
-			printk("%sAllow mount %s %s %s with options 0x%lX\n", ccs_log_level, fs->name, dev->name, dir->name, ptr->flags);
-		} else if (strcmp(fs->name, MOUNT_MAKE_UNBINDABLE_KEYWORD) == 0 ||
-				   strcmp(fs->name, MOUNT_MAKE_PRIVATE_KEYWORD) == 0 ||
-				   strcmp(fs->name, MOUNT_MAKE_SLAVE_KEYWORD) == 0 ||
-				   strcmp(fs->name, MOUNT_MAKE_SHARED_KEYWORD) == 0) {
-			printk("%sAllow mount %s %s with options 0x%lX.\n", ccs_log_level, fs->name, dir->name, ptr->flags);
-		} else if ((type = get_fs_type(fs->name)) != NULL && (type->fs_flags & FS_REQUIRES_DEV) != 0) {
-			printk("%sAllow mount -t %s %s %s with options 0x%lX.\n", ccs_log_level, fs->name, dev->name, dir->name, ptr->flags);
-		} else {
-			printk("%sAllow mount %s on %s with options 0x%lX.\n", ccs_log_level, fs->name, dir->name, ptr->flags);
-		}
-		if (type) put_filesystem(type);
+	if (!strcmp(fs->name, MOUNT_REMOUNT_KEYWORD)) {
+		printk(KERN_CONT "%sAllow remount %s with options 0x%lX.\n",
+		       ccs_log_level, dir->name, ptr->flags);
+	} else if (!strcmp(fs->name, MOUNT_BIND_KEYWORD)
+		   || !strcmp(fs->name, MOUNT_MOVE_KEYWORD)) {
+		printk(KERN_CONT "%sAllow mount %s %s %s with options 0x%lX\n",
+		       ccs_log_level, fs->name, dev->name, dir->name,
+		       ptr->flags);
+	} else if (!strcmp(fs->name, MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
+		   !strcmp(fs->name, MOUNT_MAKE_PRIVATE_KEYWORD) ||
+		   !strcmp(fs->name, MOUNT_MAKE_SLAVE_KEYWORD) ||
+		   !strcmp(fs->name, MOUNT_MAKE_SHARED_KEYWORD)) {
+		printk(KERN_CONT "%sAllow mount %s %s with options 0x%lX.\n",
+		       ccs_log_level, fs->name, dir->name, ptr->flags);
+	} else {
+		type = get_fs_type(fs->name);
+		if (type && (type->fs_flags & FS_REQUIRES_DEV) != 0)
+			printk(KERN_CONT "%sAllow mount -t %s %s %s "
+			       "with options 0x%lX.\n", ccs_log_level,
+			       fs->name, dev->name, dir->name, ptr->flags);
+		else
+			printk(KERN_CONT "%sAllow mount %s on %s "
+			       "with options 0x%lX.\n", ccs_log_level,
+			       fs->name, dir->name, ptr->flags);
 	}
+	if (type)
+		put_filesystem(type);
  out:
 	mutex_unlock(&lock);
 	return error;
 }
 
-static int CheckMountPermission2(char *dev_name, char *dir_name, char *type, unsigned long flags)
+/**
+ * print_success - Print success messages.
+ *
+ * @dev_name: Name of device file.
+ * @dir_name: Name of mount point.
+ * @type:     Name of filesystem type.
+ * @flags:    Mount options.
+ * @need_dev: Type of @dev_name .
+ *
+ * Returns nothing.
+ */
+static void print_success(const char *dev_name, const char *dir_name,
+			  const char *type, const unsigned long flags,
+			  const int need_dev)
 {
-	const u8 mode = CheckCCSFlags(CCS_SAKURA_RESTRICT_MOUNT);
+	if (need_dev > 0) {
+		printk(KERN_DEBUG "SAKURA-NOTICE: "
+		       "'mount -t %s %s %s 0x%lX' accepted.\n",
+		       type, dev_name, dir_name, flags);
+	} else if (need_dev < 0) {
+		printk(KERN_DEBUG "SAKURA-NOTICE: "
+		       "'mount %s %s %s 0x%lX' accepted.\n",
+		       type, dev_name, dir_name, flags);
+	} else if (!strcmp(type, MOUNT_REMOUNT_KEYWORD)) {
+		printk(KERN_DEBUG "SAKURA-NOTICE: "
+		       "'mount -o remount %s 0x%lX' accepted.\n",
+		       dir_name, flags);
+	} else if (!strcmp(type, MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
+		   !strcmp(type, MOUNT_MAKE_PRIVATE_KEYWORD) ||
+		   !strcmp(type, MOUNT_MAKE_SLAVE_KEYWORD) ||
+		   !strcmp(type, MOUNT_MAKE_SHARED_KEYWORD)) {
+		printk(KERN_DEBUG "SAKURA-NOTICE: "
+		       "'mount %s %s 0x%lX' accepted.\n",
+		       type, dir_name, flags);
+	} else {
+		printk(KERN_DEBUG "SAKURA-NOTICE: "
+		       "'mount %s on %s 0x%lX' accepted.\n",
+		       type, dir_name, flags);
+	}
+}
+
+/**
+ * print_error - Print error messages.
+ *
+ * @dev_name:   Name of device file.
+ * @dir_name:   Name of mount point.
+ * @type:       Name of filesystem type.
+ * @flags:      Mount options.
+ * @is_enforce: True if it is enforcing mode.
+ * @error:      Error value.
+ *
+ * Returns 0 if permitted by the administrator's decision, negative value
+ * otherwise.
+ */
+static int print_error(const char *dev_name, const char *dir_name,
+		       const char *type, const unsigned long flags,
+		       const bool is_enforce, int error)
+{
+	const char *realname1 = ccs_realpath(dev_name);
+	const char *realname2 = ccs_realpath(dir_name);
+	const char *exename = ccs_get_exe();
+	if (!strcmp(type, MOUNT_REMOUNT_KEYWORD)) {
+		printk(KERN_WARNING "SAKURA-%s: mount -o remount %s 0x%lX "
+		       "(pid=%d:exe=%s): Permission denied.\n",
+		       ccs_get_msg(is_enforce),
+		       realname2 ? realname2 : dir_name,
+		       flags, current->pid, exename);
+		if (is_enforce &&
+		    ccs_check_supervisor("# %s is requesting\n"
+					 "mount -o remount %s 0x%lX\n",
+					 exename,
+					 realname2 ? realname2 : dir_name,
+					 flags) == 0)
+			error = 0;
+	} else if (!strcmp(type, MOUNT_BIND_KEYWORD)
+		   || !strcmp(type, MOUNT_MOVE_KEYWORD)) {
+		printk(KERN_WARNING "SAKURA-%s: mount %s %s %s 0x%lX "
+		       "(pid=%d:exe=%s): Permission denied.\n",
+		       ccs_get_msg(is_enforce), type,
+		       realname1 ? realname1 : dev_name,
+		       realname2 ? realname2 : dir_name,
+		       flags, current->pid, exename);
+		if (is_enforce &&
+		    ccs_check_supervisor("# %s is requesting\n"
+					 "mount %s %s %s 0x%lX\n", exename,
+					 type,
+					 realname1 ? realname1 : dev_name,
+					 realname2 ? realname2 : dir_name,
+					 flags) == 0)
+			error = 0;
+	} else if (!strcmp(type, MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
+		   !strcmp(type, MOUNT_MAKE_PRIVATE_KEYWORD) ||
+		   !strcmp(type, MOUNT_MAKE_SLAVE_KEYWORD) ||
+		   !strcmp(type, MOUNT_MAKE_SHARED_KEYWORD)) {
+		printk(KERN_WARNING "SAKURA-%s: mount %s %s 0x%lX "
+		       "(pid=%d:exe=%s): Permission denied.\n",
+		       ccs_get_msg(is_enforce), type,
+		       realname2 ? realname2 : dir_name,
+		       flags, current->pid, exename);
+		if (is_enforce &&
+		    ccs_check_supervisor("# %s is requesting\n"
+					 "mount %s %s 0x%lX", exename, type,
+					 realname2 ? realname2 : dir_name,
+					 flags) == 0)
+			error = 0;
+	} else {
+		printk(KERN_WARNING "SAKURA-%s: mount -t %s %s %s 0x%lX "
+		       "(pid=%d:exe=%s): Permission denied.\n",
+		       ccs_get_msg(is_enforce), type,
+		       realname1 ? realname1 : dev_name,
+		       realname2 ? realname2 : dir_name,
+		       flags, current->pid, exename);
+		if (is_enforce &&
+		    ccs_check_supervisor("# %s is requesting\n"
+					 "mount -t %s %s %s 0x%lX\n",
+					 exename, type,
+					 realname1 ? realname1 : dev_name,
+					 realname2 ? realname2 : dir_name,
+					 flags) == 0)
+			error = 0;
+	}
+	ccs_free(exename);
+	ccs_free(realname2);
+	ccs_free(realname1);
+	return error;
+}
+
+/**
+ * check_mount_permission2 -
+ *
+ * @dev_name: Name of device file.
+ * @dir_name: Name of mount point.
+ * @type:     Name of filesystem type. May be NULL.
+ * @flags:    Mount options.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int check_mount_permission2(char *dev_name, char *dir_name, char *type,
+				   unsigned long flags)
+{
+	const u8 mode = ccs_check_flags(CCS_SAKURA_RESTRICT_MOUNT);
 	const bool is_enforce = (mode == 3);
 	int error = -EPERM;
-	if (!mode) return 0;
-	if (!type) type = "<NULL>";
-	if ((flags & MS_MGC_MSK) == MS_MGC_VAL) flags &= ~MS_MGC_MSK;
+	if (!mode)
+		return 0;
+	if (!type)
+		type = "<NULL>";
+	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
+		flags &= ~MS_MGC_MSK;
 	switch (flags & (MS_REMOUNT | MS_MOVE | MS_BIND)) {
 	case MS_REMOUNT:
 	case MS_MOVE:
@@ -149,7 +339,8 @@
 	case 0:
 		break;
 	default:
-		printk("SAKURA-ERROR: %s%s%sare given for single mount operation.\n",
+		printk(KERN_WARNING "SAKURA-ERROR: "
+		       "%s%s%sare given for single mount operation.\n",
 		       flags & MS_REMOUNT ? "'remount' " : "",
 		       flags & MS_MOVE    ? "'move' " : "",
 		       flags & MS_BIND    ? "'bind' " : "");
@@ -163,7 +354,8 @@
 	case 0:
 		break;
 	default:
-		printk("SAKURA-ERROR: %s%s%s%sare given for single mount operation.\n",
+		printk(KERN_WARNING "SAKURA-ERROR: "
+		       "%s%s%s%sare given for single mount operation.\n",
 		       flags & MS_UNBINDABLE ? "'unbindable' " : "",
 		       flags & MS_PRIVATE    ? "'private' " : "",
 		       flags & MS_SLAVE      ? "'slave' " : "",
@@ -171,19 +363,33 @@
 		return -EINVAL;
 	}
 	if (flags & MS_REMOUNT) {
-		error = CheckMountPermission2(dev_name, dir_name, MOUNT_REMOUNT_KEYWORD, flags & ~MS_REMOUNT);
+		error = check_mount_permission2(dev_name, dir_name,
+						MOUNT_REMOUNT_KEYWORD,
+						flags & ~MS_REMOUNT);
 	} else if (flags & MS_MOVE) {
-		error = CheckMountPermission2(dev_name, dir_name, MOUNT_MOVE_KEYWORD, flags & ~MS_MOVE);
+		error = check_mount_permission2(dev_name, dir_name,
+						MOUNT_MOVE_KEYWORD,
+						flags & ~MS_MOVE);
 	} else if (flags & MS_BIND) {
-		error = CheckMountPermission2(dev_name, dir_name, MOUNT_BIND_KEYWORD, flags & ~MS_BIND);
+		error = check_mount_permission2(dev_name, dir_name,
+						MOUNT_BIND_KEYWORD,
+						flags & ~MS_BIND);
 	} else if (flags & MS_UNBINDABLE) {
-		error = CheckMountPermission2(dev_name, dir_name, MOUNT_MAKE_UNBINDABLE_KEYWORD, flags & ~MS_UNBINDABLE);
+		error = check_mount_permission2(dev_name, dir_name,
+						MOUNT_MAKE_UNBINDABLE_KEYWORD,
+						flags & ~MS_UNBINDABLE);
 	} else if (flags & MS_PRIVATE) {
-		error = CheckMountPermission2(dev_name, dir_name, MOUNT_MAKE_PRIVATE_KEYWORD, flags & ~MS_PRIVATE);
+		error = check_mount_permission2(dev_name, dir_name,
+						MOUNT_MAKE_PRIVATE_KEYWORD,
+						flags & ~MS_PRIVATE);
 	} else if (flags & MS_SLAVE) {
-		error = CheckMountPermission2(dev_name, dir_name, MOUNT_MAKE_SLAVE_KEYWORD, flags & ~MS_SLAVE);
+		error = check_mount_permission2(dev_name, dir_name,
+						MOUNT_MAKE_SLAVE_KEYWORD,
+						flags & ~MS_SLAVE);
 	} else if (flags & MS_SHARED) {
-		error = CheckMountPermission2(dev_name, dir_name, MOUNT_MAKE_SHARED_KEYWORD, flags & ~MS_SHARED);
+		error = check_mount_permission2(dev_name, dir_name,
+						MOUNT_MAKE_SHARED_KEYWORD,
+						flags & ~MS_SHARED);
 	} else {
 		struct mount_entry *ptr;
 		struct file_system_type *fstype = NULL;
@@ -192,140 +398,174 @@
 		struct path_info rdev, rdir;
 		int need_dev = 0;
 
-		if ((requested_dir_name = realpath(dir_name)) == NULL) {
+		requested_dir_name = ccs_realpath(dir_name);
+		if (!requested_dir_name) {
 			error = -ENOENT;
 			goto cleanup;
 		}
 		rdir.name = requested_dir_name;
-		fill_path_info(&rdir);
+		ccs_fill_path_info(&rdir);
 
 		/* Compare fs name. */
-		if (strcmp(type, MOUNT_REMOUNT_KEYWORD) == 0) {
+		if (!strcmp(type, MOUNT_REMOUNT_KEYWORD)) {
 			/* Needn't to resolve dev_name */
-		} else if (strcmp(type, MOUNT_MAKE_UNBINDABLE_KEYWORD) == 0 ||
-			   strcmp(type, MOUNT_MAKE_PRIVATE_KEYWORD) == 0 ||
-			   strcmp(type, MOUNT_MAKE_SLAVE_KEYWORD) == 0 ||
-			   strcmp(type, MOUNT_MAKE_SHARED_KEYWORD) == 0) {
+		} else if (!strcmp(type, MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
+			   !strcmp(type, MOUNT_MAKE_PRIVATE_KEYWORD) ||
+			   !strcmp(type, MOUNT_MAKE_SLAVE_KEYWORD) ||
+			   !strcmp(type, MOUNT_MAKE_SHARED_KEYWORD)) {
 			/* Needn't to resolve dev_name */
-		} else if (strcmp(type, MOUNT_BIND_KEYWORD) == 0 || strcmp(type, MOUNT_MOVE_KEYWORD) == 0) {
-			if ((requested_dev_name = realpath(dev_name)) == NULL) {
+		} else if (!strcmp(type, MOUNT_BIND_KEYWORD) ||
+			   !strcmp(type, MOUNT_MOVE_KEYWORD)) {
+			requested_dev_name = ccs_realpath(dev_name);
+			if (!requested_dev_name) {
 				error = -ENOENT;
 				goto cleanup;
 			}
 			rdev.name = requested_dev_name;
-			fill_path_info(&rdev);
-			need_dev = -1; /* dev_name is a directory */
-		} else if ((fstype = get_fs_type(type)) != NULL) {
-			if (fstype->fs_flags & FS_REQUIRES_DEV) {
-				if ((requested_dev_name = realpath(dev_name)) == NULL) {
-					error = -ENOENT;
-					goto cleanup;
+			ccs_fill_path_info(&rdev);
+			/* dev_name is a directory */
+			need_dev = -1;
+		} else {
+			fstype = get_fs_type(type);
+			if (fstype) {
+				if (fstype->fs_flags & FS_REQUIRES_DEV) {
+					requested_dev_name
+						= ccs_realpath(dev_name);
+					if (!requested_dev_name) {
+						error = -ENOENT;
+						goto cleanup;
+					}
+					rdev.name = requested_dev_name;
+					ccs_fill_path_info(&rdev);
+					/* dev_name is a block device file */
+					need_dev = 1;
 				}
-				rdev.name = requested_dev_name;
-				fill_path_info(&rdev);
-				need_dev = 1; /* dev_name is a block device file */
+			} else {
+				error = -ENODEV;
+				goto cleanup;
 			}
-		} else {
-			error = -ENODEV;
-			goto cleanup;
 		}
 		list1_for_each_entry(ptr, &mount_list, list) {
-			if (ptr->is_deleted) continue;
+			if (ptr->is_deleted)
+				continue;
 
 			/* Compare options */
-			if (ptr->flags != flags) continue;
+			if (ptr->flags != flags)
+				continue;
 
 			/* Compare fs name. */
-			if (strcmp(type, ptr->fs_type->name)) continue;
+			if (strcmp(type, ptr->fs_type->name))
+				continue;
 
 			/* Compare mount point. */
-			if (PathMatchesToPattern(&rdir, ptr->dir_name) == 0) continue;
+			if (ccs_path_matches_pattern(&rdir, ptr->dir_name) == 0)
+				continue;
 
 			/* Compare device name. */
-			if (requested_dev_name && PathMatchesToPattern(&rdev, ptr->dev_name) == 0) continue;
+			if (requested_dev_name &&
+			    ccs_path_matches_pattern(&rdev, ptr->dev_name) == 0)
+				continue;
 
 			/* OK. */
 			error = 0;
-
-			if (need_dev > 0) {
-				printk(KERN_DEBUG "SAKURA-NOTICE: 'mount -t %s %s %s 0x%lX' accepted.\n", type, requested_dev_name, requested_dir_name, flags);
-			} else if (need_dev < 0) {
-				printk(KERN_DEBUG "SAKURA-NOTICE: 'mount %s %s %s 0x%lX' accepted.\n", type, requested_dev_name, requested_dir_name, flags);
-			} else if (strcmp(type, MOUNT_REMOUNT_KEYWORD) == 0) {
-				printk(KERN_DEBUG "SAKURA-NOTICE: 'mount -o remount %s 0x%lX' accepted.\n", requested_dir_name, flags);
-			} else if (strcmp(type, MOUNT_MAKE_UNBINDABLE_KEYWORD) == 0 ||
-				   strcmp(type, MOUNT_MAKE_PRIVATE_KEYWORD) == 0 ||
-				   strcmp(type, MOUNT_MAKE_SLAVE_KEYWORD) == 0 ||
-				   strcmp(type, MOUNT_MAKE_SHARED_KEYWORD) == 0) {
-				printk(KERN_DEBUG "SAKURA-NOTICE: 'mount %s %s 0x%lX' accepted.\n", type, requested_dir_name, flags);
-			} else {
-				printk(KERN_DEBUG "SAKURA-NOTICE: 'mount %s on %s 0x%lX' accepted.\n", type, requested_dir_name, flags);
-			}
+			print_success(requested_dev_name, requested_dir_name,
+				      type, flags, need_dev);
 			break;
 		}
-		if (error) {
-			const char *realname1 = realpath(dev_name), *realname2 = realpath(dir_name), *exename = GetEXE();
-			if (strcmp(type, MOUNT_REMOUNT_KEYWORD) == 0) {
-				printk("SAKURA-%s: mount -o remount %s 0x%lX (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), realname2 ? realname2 : dir_name, flags, current->pid, exename);
-				if (is_enforce && CheckSupervisor("# %s is requesting\nmount -o remount %s 0x%lX\n", exename, realname2 ? realname2 : dir_name, flags) == 0) error = 0;
-			} else if (strcmp(type, MOUNT_BIND_KEYWORD) == 0 || strcmp(type, MOUNT_MOVE_KEYWORD) == 0) {
-				printk("SAKURA-%s: mount %s %s %s 0x%lX (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), type, realname1 ? realname1 : dev_name, realname2 ? realname2 : dir_name, flags, current->pid, exename);
-				if (is_enforce && CheckSupervisor("# %s is requesting\nmount %s %s %s 0x%lX\n", exename, type, realname1 ? realname1 : dev_name, realname2 ? realname2 : dir_name, flags) == 0) error = 0;
-			} else if (strcmp(type, MOUNT_MAKE_UNBINDABLE_KEYWORD) == 0 ||
-				   strcmp(type, MOUNT_MAKE_PRIVATE_KEYWORD) == 0 ||
-				   strcmp(type, MOUNT_MAKE_SLAVE_KEYWORD) == 0 ||
-				   strcmp(type, MOUNT_MAKE_SHARED_KEYWORD) == 0) {
-				printk("SAKURA-%s: mount %s %s 0x%lX (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), type, realname2 ? realname2 : dir_name, flags, current->pid, exename);
-				if (is_enforce && CheckSupervisor("# %s is requesting\nmount %s %s 0x%lX", exename, type, realname2 ? realname2 : dir_name, flags) == 0) error = 0;
-			} else {
-				printk("SAKURA-%s: mount -t %s %s %s 0x%lX (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), type, realname1 ? realname1 : dev_name, realname2 ? realname2 : dir_name, flags, current->pid, exename);
-				if (is_enforce && CheckSupervisor("# %s is requesting\nmount -t %s %s %s 0x%lX\n", exename, type, realname1 ? realname1 : dev_name, realname2 ? realname2 : dir_name, flags) == 0) error = 0;
-			}
-			ccs_free(exename);
-			ccs_free(realname2);
-			ccs_free(realname1);
-		}
+		if (error)
+			error = print_error(dev_name, dir_name, type, flags,
+					    is_enforce, error);
 		if (error && mode == 1) {
-			AddMountACL(need_dev ? requested_dev_name : dev_name, requested_dir_name, type, flags, 0);
-			UpdateCounter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
+			update_mount_acl(need_dev ?
+					 requested_dev_name : dev_name,
+					 requested_dir_name, type, flags, 0);
+			ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 		}
-	cleanup:
+ cleanup:
 		ccs_free(requested_dev_name);
 		ccs_free(requested_dir_name);
-		if (fstype) put_filesystem(fstype);
+		if (fstype)
+			put_filesystem(fstype);
 	}
-	if (!is_enforce) error = 0;
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
 
-/* This is a wrapper to allow use of 1.4.x patch for 1.5.x . */
-int CheckMountPermission(char *dev_name, char *dir_name, char *type, const unsigned long *flags)
+/**
+ * ccs_check_mount_permission -
+ *
+ * @dev_name: Name of device file.
+ * @dir_name: Name of mount point.
+ * @type:     Name of filesystem type. May be NULL.
+ * @flags:    Mount options.
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * This is a wrapper to allow use of 1.4.x patch for 1.5.x .
+ */
+int ccs_check_mount_permission(char *dev_name, char *dir_name, char *type,
+			       const unsigned long *flags)
 {
-	return CheckMountPermission2(dev_name, dir_name, type, *flags);
+	return check_mount_permission2(dev_name, dir_name, type, *flags);
 }
 
-int AddMountPolicy(char *data, const bool is_delete)
+/**
+ * ccs_write_mount_policy -
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_mount_policy(char *data, const bool is_delete)
 {
 	char *cp, *cp2;
 	const char *fs, *dev, *dir;
 	unsigned long flags = 0;
-	cp2 = data; if ((cp = strchr(cp2, ' ')) == NULL) return -EINVAL; *cp = '\0'; dev = cp2;
-	cp2 = cp + 1; if ((cp = strchr(cp2, ' ')) == NULL) return -EINVAL; *cp = '\0'; dir = cp2;
-	cp2 = cp + 1; if ((cp = strchr(cp2, ' ')) == NULL) return -EINVAL; *cp = '\0'; fs = cp2;
+	cp2 = data;
+	cp = strchr(cp2, ' ');
+	if (!cp)
+		return -EINVAL;
+	*cp = '\0';
+	dev = cp2;
+	cp2 = cp + 1;
+	cp = strchr(cp2, ' ');
+	if (!cp)
+		return -EINVAL;
+	*cp = '\0';
+	dir = cp2;
+	cp2 = cp + 1;
+	cp = strchr(cp2, ' ');
+	if (!cp)
+		return -EINVAL;
+	*cp = '\0';
+	fs = cp2;
 	flags = simple_strtoul(cp + 1, NULL, 0);
-	return AddMountACL(dev, dir, fs, flags, is_delete);
+	return update_mount_acl(dev, dir, fs, flags, is_delete);
 }
 
-int ReadMountPolicy(struct io_buffer *head)
+/**
+ * ccs_read_mount_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_mount_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &mount_list) {
 		struct mount_entry *ptr;
 		ptr = list1_entry(pos, struct mount_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALLOW_MOUNT "%s %s %s 0x%lX\n", ptr->dev_name->name, ptr->dir_name->name, ptr->fs_type->name, ptr->flags)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, KEYWORD_ALLOW_MOUNT "%s %s %s 0x%lX\n",
+				   ptr->dev_name->name, ptr->dir_name->name,
+				   ptr->fs_type->name, ptr->flags))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
-
-/***** SAKURA Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(working copy)
@@ -11,14 +11,21 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** TOMOYO Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/tomoyo.h>
+#include <linux/realpath.h>
 #include <linux/highmem.h>
 #include <linux/binfmts.h>
 
-static char *DumpBprm(struct linux_binprm *bprm)
+/**
+ * ccs_dump_bprm -
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ *
+ * Returns the contents of @bprm on success, NULL otherwise.
+ */
+static char *ccs_dump_bprm(struct linux_binprm *bprm)
 {
 	static const int buffer_len = PAGE_SIZE * 2;
 	char *buffer = ccs_alloc(buffer_len);
@@ -29,20 +36,25 @@
 	int argv_count = bprm->argc;
 	int envp_count = bprm->envc;
 	bool truncated = false;
-	if (!buffer) return NULL;
-	len = snprintf(buffer, buffer_len - 1, "argc=%d envc=%d argv[]={ ", argv_count, envp_count);
+	if (!buffer)
+		return NULL;
+	len = snprintf(buffer, buffer_len - 1,
+		       "argc=%d envc=%d argv[]={ ", argv_count, envp_count);
 	cp = buffer + len;
 	if (!argv_count) {
 		memmove(cp, "} envp[]={ ", 11);
 		cp += 11;
 	}
-	if (!envp_count) *cp++ = '}';
+	if (!envp_count)
+		*cp++ = '}';
 	last_start = cp;
 	while (argv_count || envp_count) {
 		struct page *page;
 		const char *kaddr;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
-		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0) goto out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
+		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page,
+				   NULL) <= 0)
+			goto out;
 		pos += PAGE_SIZE - offset;
 #else
 		page = bprm->page[i];
@@ -50,7 +62,7 @@
 		/* Map */
 		kaddr = kmap(page);
 		if (!kaddr) { /* Mapping failed. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 			put_page(page);
 #endif
 			goto out;
@@ -58,7 +70,8 @@
 		/* Read. */
 		while (offset < PAGE_SIZE) {
 			const unsigned char c = kaddr[offset++];
-			if (cp == last_start) *cp++ = '"';
+			if (cp == last_start)
+				*cp++ = '"';
 			if (cp >= buffer + buffer_len - 32) {
 				/* Preserve some room for "..." string. */
 				truncated = true;
@@ -77,7 +90,8 @@
 				*cp++ = ((c >> 3) & 7) + '0';
 				*cp++ = (c & 7) + '0';
 			}
-			if (c) continue;
+			if (c)
+				continue;
 			if (argv_count) {
 				if (--argv_count == 0) {
 					if (truncated) {
@@ -87,7 +101,8 @@
 					}
 					memmove(cp, "} envp[]={ ", 11);
 					cp += 11;
-					if (!envp_count) goto no_envp;
+					if (!envp_count)
+						goto no_envp;
 					last_start = cp;
 				}
 			} else if (envp_count) {
@@ -97,7 +112,7 @@
 						memmove(cp, "... ", 4);
 						cp += 4;
 					}
-				no_envp:
+ no_envp:
 					*cp++ = '}';
 					*cp++ = '\0';
 				}
@@ -107,7 +122,7 @@
 		}
 		/* Unmap. */
 		kunmap(page);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 		put_page(page);
 #endif
 		i++;
@@ -115,16 +130,18 @@
 	}
 	return buffer;
  out:
-	snprintf(buffer, buffer_len - 1, "argc=%d envc=%d argv[]={ ... } envp[]= { ... }", argv_count, envp_count);
+	snprintf(buffer, buffer_len - 1,
+		 "argc=%d envc=%d argv[]={ ... } envp[]= { ... }",
+		 argv_count, envp_count);
 	return buffer;
 }
 
-/*************************  AUDIT FUNCTIONS  *************************/
+/* Auditing functions. */
 
 static DECLARE_WAIT_QUEUE_HEAD(grant_log_wait);
 static DECLARE_WAIT_QUEUE_HEAD(reject_log_wait);
 
-static spinlock_t audit_log_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(audit_log_lock);
 
 struct log_entry {
 	struct list_head list;
@@ -134,11 +151,26 @@
 static LIST_HEAD(grant_log);
 static LIST_HEAD(reject_log);
 
-static int grant_log_count = 0, reject_log_count = 0;
+static int grant_log_count, reject_log_count;
 
-char *InitAuditLog(int *len, const u8 profile, const u8 mode, struct linux_binprm *bprm)
+/**
+ * ccs_init_audit_log -
+ *
+ * @len:     Required size.
+ * @profile: Profile number.
+ * @mode:    Access control mode.
+ * @bprm:    Pointer to "struct linux_binprm". May be NULL.
+ *
+ * Returns pointer to allocated memory.
+ *
+ * The @len is updated to add the header lines' size on success.
+ */
+char *ccs_init_audit_log(int *len, const u8 profile, const u8 mode,
+			 struct linux_binprm *bprm)
 {
-	static const char *mode_4[4] = { "disabled", "learning", "permissive", "enforcing" };
+	static const char *mode_4[4] = {
+		"disabled", "learning", "permissive", "enforcing"
+	};
 	char *buf;
 	char *bprm_info = "";
 	struct timeval tv;
@@ -148,79 +180,129 @@
 	do_gettimeofday(&tv);
 	*len += strlen(domainname) + 256;
 	if (bprm) {
-		bprm_info = DumpBprm(bprm);
-		if (!bprm_info) return NULL;
+		bprm_info = ccs_dump_bprm(bprm);
+		if (!bprm_info)
+			return NULL;
 		*len += strlen(bprm_info);
 	}
-	if ((buf = ccs_alloc(*len)) != NULL) snprintf(buf, (*len) - 1, "#timestamp=%lu profile=%u mode=%s pid=%d uid=%d gid=%d euid=%d egid=%d suid=%d sgid=%d fsuid=%d fsgid=%d state[0]=%u state[1]=%u state[2]=%u %s\n%s\n", tv.tv_sec, profile, mode_4[mode], task->pid, task->uid, task->gid, task->euid, task->egid, task->suid, task->sgid, task->fsuid, task->fsgid, (u8) (tomoyo_flags >> 24), (u8) (tomoyo_flags >> 16), (u8) (tomoyo_flags >> 8), bprm_info, domainname);
-	if (bprm) ccs_free(bprm_info);
+	buf = ccs_alloc(*len);
+	if (buf)
+		snprintf(buf, (*len) - 1,
+			 "#timestamp=%lu profile=%u mode=%s pid=%d uid=%d "
+			 "gid=%d euid=%d egid=%d suid=%d sgid=%d fsuid=%d "
+			 "fsgid=%d state[0]=%u state[1]=%u state[2]=%u %s\n"
+			 "%s\n", tv.tv_sec, profile, mode_4[mode], task->pid,
+			 task->uid, task->gid, task->euid, task->egid,
+			 task->suid, task->sgid, task->fsuid, task->fsgid,
+			 (u8) (tomoyo_flags >> 24), (u8) (tomoyo_flags >> 16),
+			 (u8) (tomoyo_flags >> 8), bprm_info, domainname);
+	if (bprm)
+		ccs_free(bprm_info);
 	return buf;
 }
 
-static unsigned int GetMaxGrantLog(void)
+/**
+ * get_max_grant_log -
+ *
+ * Returns max number of spoolable grant logs.
+ */
+static unsigned int get_max_grant_log(void)
 {
-	return CheckCCSFlags(CCS_TOMOYO_MAX_GRANT_LOG);
+	return ccs_check_flags(CCS_TOMOYO_MAX_GRANT_LOG);
 }
 
-static unsigned int GetMaxRejectLog(void)
+/**
+ * get_max_reject_log -
+ *
+ * Returns max number of spoolable reject logs.
+ */
+static unsigned int get_max_reject_log(void)
 {
-	return CheckCCSFlags(CCS_TOMOYO_MAX_REJECT_LOG);
+	return ccs_check_flags(CCS_TOMOYO_MAX_REJECT_LOG);
 }
 
-/*
- * Write audit log.
- * Caller must allocate buf with InitAuditLog().
+/**
+ * ccs_write_audit_log - Write audit log.
+ *
+ * @buf:        Pointer to audit log.
+ * @is_granted: True if this is a granted log.
+ *
+ * Returns 0 on success, -ENOMEM otherwise.
+ *
+ * Caller must allocate @buf with ccs_init_audit_log().
  */
-int WriteAuditLog(char *buf, const bool is_granted)
+int ccs_write_audit_log(char *buf, const bool is_granted)
 {
 	struct log_entry *new_entry = ccs_alloc(sizeof(*new_entry));
-	if (!new_entry) goto out;
+	if (!new_entry)
+		goto out;
 	INIT_LIST_HEAD(&new_entry->list);
 	new_entry->log = buf;
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&audit_log_lock);
 	if (is_granted) {
-		if (grant_log_count < GetMaxGrantLog()) {
+		if (grant_log_count < get_max_grant_log()) {
 			list_add_tail(&new_entry->list, &grant_log);
 			grant_log_count++;
 			buf = NULL;
-			UpdateCounter(CCS_UPDATES_COUNTER_GRANT_LOG);
+			ccs_update_counter(CCS_UPDATES_COUNTER_GRANT_LOG);
 		}
 	} else {
-		if (reject_log_count < GetMaxRejectLog()) {
+		if (reject_log_count < get_max_reject_log()) {
 			list_add_tail(&new_entry->list, &reject_log);
 			reject_log_count++;
 			buf = NULL;
-			UpdateCounter(CCS_UPDATES_COUNTER_REJECT_LOG);
+			ccs_update_counter(CCS_UPDATES_COUNTER_REJECT_LOG);
 		}
 	}
 	spin_unlock(&audit_log_lock);
 	/***** CRITICAL SECTION END *****/
-	if (is_granted) wake_up(&grant_log_wait);
-	else wake_up(&reject_log_wait);
-	if (!buf) return 0;
+	if (is_granted)
+		wake_up(&grant_log_wait);
+	else
+		wake_up(&reject_log_wait);
+	if (!buf)
+		return 0;
 	ccs_free(new_entry);
- out: ;
+ out:
 	ccs_free(buf);
 	return -ENOMEM;
 }
 
-int CanSaveAuditLog(const bool is_granted)
+/**
+ * ccs_can_save_audit_log -
+ *
+ * @is_granted: True if this is a granted log.
+ *
+ * Returns 0 if the kernel can save, -ENOMEM otherwise.
+ */
+int ccs_can_save_audit_log(const bool is_granted)
 {
 	if (is_granted) {
-		if (grant_log_count < GetMaxGrantLog()) return 0;
+		if (grant_log_count < get_max_grant_log())
+			return 0;
 	} else {
-		if (reject_log_count < GetMaxRejectLog()) return 0;
+		if (reject_log_count < get_max_reject_log())
+			return 0;
 	}
 	return -ENOMEM;
 }
 
-int ReadGrantLog(struct io_buffer *head)
+/**
+ * ccs_read_grant_log -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0.
+ */
+int ccs_read_grant_log(struct ccs_io_buffer *head)
 {
 	struct log_entry *ptr = NULL;
-	if (head->read_avail) return 0;
+	if (head->read_avail)
+		return 0;
 	if (head->read_buf) {
-		ccs_free(head->read_buf); head->read_buf = NULL;
+		ccs_free(head->read_buf);
+		head->read_buf = NULL;
 		head->readbuf_size = 0;
 	}
 	/***** CRITICAL SECTION START *****/
@@ -234,26 +316,46 @@
 	/***** CRITICAL SECTION END *****/
 	if (ptr) {
 		head->read_buf = ptr->log;
-		head->readbuf_size = head->read_avail = strlen(ptr->log) + 1;
+		head->read_avail = strlen(ptr->log) + 1;
+		head->readbuf_size = head->read_avail;
 		ccs_free(ptr);
 	}
 	return 0;
 }
 
-int PollGrantLog(struct file *file, poll_table *wait)
+/**
+ * ccs_poll_grant_log -
+ *
+ * @file: Pointer to "struct file".
+ * @wait: Pointer to "poll_table".
+ *
+ * Returns POLLIN | POLLRDNORM when ready to read a grant log.
+ */
+int ccs_poll_grant_log(struct file *file, poll_table *wait)
 {
-	if (grant_log_count) return POLLIN | POLLRDNORM;
+	if (grant_log_count)
+		return POLLIN | POLLRDNORM;
 	poll_wait(file, &grant_log_wait, wait);
-	if (grant_log_count) return POLLIN | POLLRDNORM;
+	if (grant_log_count)
+		return POLLIN | POLLRDNORM;
 	return 0;
 }
 
-int ReadRejectLog(struct io_buffer *head)
+/**
+ * ccs_read_reject_log -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0.
+ */
+int ccs_read_reject_log(struct ccs_io_buffer *head)
 {
 	struct log_entry *ptr = NULL;
-	if (head->read_avail) return 0;
+	if (head->read_avail)
+		return 0;
 	if (head->read_buf) {
-		ccs_free(head->read_buf); head->read_buf = NULL;
+		ccs_free(head->read_buf);
+		head->read_buf = NULL;
 		head->readbuf_size = 0;
 	}
 	/***** CRITICAL SECTION START *****/
@@ -267,18 +369,27 @@
 	/***** CRITICAL SECTION END *****/
 	if (ptr) {
 		head->read_buf = ptr->log;
-		head->readbuf_size = head->read_avail = strlen(ptr->log) + 1;
+		head->read_avail = strlen(ptr->log) + 1;
+		head->readbuf_size = head->read_avail;
 		ccs_free(ptr);
 	}
 	return 0;
 }
 
-int PollRejectLog(struct file *file, poll_table *wait)
+/**
+ * ccs_poll_reject_log -
+ *
+ * @file: Pointer to "struct file".
+ * @wait: Pointer to "poll_table".
+ *
+ * Returns POLLIN | POLLRDNORM when ready to read a reject log.
+ */
+int ccs_poll_reject_log(struct file *file, poll_table *wait)
 {
-	if (reject_log_count) return POLLIN | POLLRDNORM;
+	if (reject_log_count)
+		return POLLIN | POLLRDNORM;
 	poll_wait(file, &reject_log_wait, wait);
-	if (reject_log_count) return POLLIN | POLLRDNORM;
+	if (reject_log_count)
+		return POLLIN | POLLRDNORM;
 	return 0;
 }
-
-/***** TOMOYO Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/syaoran.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/syaoran.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/syaoran.c	(working copy)
@@ -70,7 +70,7 @@
  * Lookup the data. This is trivial - if the dentry didn't already
  * exist, we know it is negative.
  */
-static struct dentry * syaoran_lookup(struct inode *dir, struct dentry *dentry)
+static struct dentry *syaoran_lookup(struct inode *dir, struct dentry *dentry)
 {
 	if (dentry->d_name.len > NAME_MAX)
 		return ERR_PTR(-ENAMETOOLONG);
@@ -82,7 +82,7 @@
  * Read a page. Again trivial. If it didn't already exist
  * in the page cache, it is zero-filled.
  */
-static int syaoran_readpage(struct file *file, struct page * page)
+static int syaoran_readpage(struct file *file, struct page *page)
 {
 	if (!Page_Uptodate(page)) {
 		memset(kmap(page), 0, PAGE_CACHE_SIZE);
@@ -94,7 +94,8 @@
 	return 0;
 }
 
-static int syaoran_prepare_write(struct file *file, struct page *page, unsigned offset, unsigned to)
+static int syaoran_prepare_write(struct file *file, struct page *page,
+				 unsigned offset, unsigned to)
 {
 	void *addr = kmap(page);
 	if (!Page_Uptodate(page)) {
@@ -106,7 +107,8 @@
 	return 0;
 }
 
-static int syaoran_commit_write(struct file *file, struct page *page, unsigned offset, unsigned to)
+static int syaoran_commit_write(struct file *file, struct page *page,
+				unsigned offset, unsigned to)
 {
 	struct inode *inode = page->mapping->host;
 	loff_t pos = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;
@@ -117,9 +119,10 @@
 	return 0;
 }
 
-static struct inode *syaoran_get_inode(struct super_block *sb, int mode, int dev)
+static struct inode *syaoran_get_inode(struct super_block *sb, int mode,
+				       int dev)
 {
-	struct inode * inode = new_inode(sb);
+	struct inode *inode = new_inode(sb);
 
 	if (inode) {
 		inode->i_mode = mode;
@@ -129,12 +132,16 @@
 		inode->i_blocks = 0;
 		inode->i_rdev = NODEV;
 		inode->i_mapping->a_ops = &syaoran_aops;
-		inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+		inode->i_ctime = CURRENT_TIME;
+		inode->i_mtime = inode->i_ctime;
+		inode->i_atime = inode->i_mtime;
 		switch (mode & S_IFMT) {
 		default:
 			init_special_inode(inode, mode, dev);
-			if (S_ISBLK(mode)) inode->i_fop = &wrapped_def_blk_fops;
-			else if (S_ISCHR(mode)) inode->i_fop = &wrapped_def_chr_fops;
+			if (S_ISBLK(mode))
+				inode->i_fop = &wrapped_def_blk_fops;
+			else if (S_ISCHR(mode))
+				inode->i_fop = &wrapped_def_chr_fops;
 			inode->i_op = &syaoran_file_inode_operations;
 			break;
 		case S_IFREG:
@@ -156,12 +163,14 @@
 /*
  * File creation. Allocate an inode, and we're done..
  */
-static int syaoran_mknod(struct inode *dir, struct dentry *dentry, int mode, int dev)
+static int syaoran_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			 int dev)
 {
-	struct inode * inode;
+	struct inode *inode;
 	int error = -ENOSPC;
 
-	if (MayCreateNode(dentry, mode, dev) < 0) return -EPERM;
+	if (syaoran_may_create_node(dentry, mode, dev) < 0)
+		return -EPERM;
 	inode = syaoran_get_inode(dir->i_sb, mode, dev);
 	if (inode) {
 		if (dir->i_mode & S_ISGID) {
@@ -176,7 +185,7 @@
 	return error;
 }
 
-static int syaoran_mkdir(struct inode * dir, struct dentry * dentry, int mode)
+static int syaoran_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	return syaoran_mknod(dir, dentry, mode | S_IFDIR, 0);
 }
@@ -189,13 +198,15 @@
 /*
  * Link a file..
  */
-static int syaoran_link(struct dentry *old_dentry, struct inode * dir, struct dentry * dentry)
+static int syaoran_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *dentry)
 {
 	struct inode *inode = old_dentry->d_inode;
 
 	if (S_ISDIR(inode->i_mode))
 		return -EPERM;
-	if (MayCreateNode(dentry, inode->i_mode, inode->i_rdev) < 0) return -EPERM;
+	if (syaoran_may_create_node(dentry, inode->i_mode, inode->i_rdev) < 0)
+		return -EPERM;
 
 	inode->i_nlink++;
 	atomic_inc(&inode->i_count); /* New dentry reference */
@@ -221,6 +232,7 @@
 {
 	struct list_head *list;
 
+	/***** CRITICAL SECTION START *****/
 	spin_lock(&dcache_lock);
 	list = dentry->d_subdirs.next;
 
@@ -234,6 +246,7 @@
 		list = list->next;
 	}
 	spin_unlock(&dcache_lock);
+	/***** CRITICAL SECTION END *****/
 	return true;
 }
 
@@ -241,16 +254,18 @@
  * This works for both directories and regular files.
  * (non-directories will always have empty subdirs)
  */
-static int syaoran_unlink(struct inode * dir, struct dentry *dentry)
+static int syaoran_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int retval = -ENOTEMPTY;
-	if (MayModifyNode(dentry, MAY_DELETE) < 0) return -EPERM;
+	if (syaoran_may_modify_node(dentry, MAY_DELETE) < 0)
+		return -EPERM;
 
 	if (syaoran_empty(dentry)) {
 		struct inode *inode = dentry->d_inode;
 
 		inode->i_nlink--;
-		dput(dentry); /* Undo the count from "create" - this does all the work */
+		/* Undo the count from "create" - this does all the work */
+		dput(dentry);
 		retval = 0;
 	}
 	return retval;
@@ -264,11 +279,15 @@
  * it exists so that the VFS layer correctly free's it when it
  * gets overwritten.
  */
-static int syaoran_rename(struct inode * old_dir, struct dentry *old_dentry, struct inode * new_dir,struct dentry *new_dentry)
+static int syaoran_rename(struct inode *old_dir, struct dentry *old_dentry,
+			  struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error = -ENOTEMPTY;
 	struct inode *inode = old_dentry->d_inode;
-	if (!inode || MayModifyNode(old_dentry, MAY_DELETE) < 0 || MayCreateNode(new_dentry, inode->i_mode, inode->i_rdev) < 0) return -EPERM;
+	if (!inode || syaoran_may_modify_node(old_dentry, MAY_DELETE) < 0 ||
+	    syaoran_may_create_node(new_dentry, inode->i_mode,
+				    inode->i_rdev) < 0)
+		return -EPERM;
 
 	if (syaoran_empty(new_dentry)) {
 		struct inode *inode = new_dentry->d_inode;
@@ -281,10 +300,12 @@
 	return error;
 }
 
-static int syaoran_symlink(struct inode * dir, struct dentry *dentry, const char * symname)
+static int syaoran_symlink(struct inode *dir, struct dentry *dentry,
+			   const char *symname)
 {
 	int error;
-	if (MayCreateNode(dentry, S_IFLNK, 0) < 0) return -EPERM;
+	if (syaoran_may_create_node(dentry, S_IFLNK, 0) < 0)
+		return -EPERM;
 
 	error = syaoran_mknod(dir, dentry, S_IFLNK | S_IRWXUGO, 0);
 	if (!error) {
@@ -295,79 +316,86 @@
 	return error;
 }
 
-static int syaoran_sync_file(struct file * file, struct dentry *dentry, int datasync)
+static int syaoran_sync_file(struct file *file, struct dentry *dentry,
+			     int datasync)
 {
 	return 0;
 }
 
-static int syaoran_setattr(struct dentry * dentry, struct iattr * attr)
+static int syaoran_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct inode *inode = dentry->d_inode;
 	int error = inode_change_ok(inode, attr);
 	if (!error) {
 		unsigned int ia_valid = attr->ia_valid;
 		unsigned int flags = 0;
-		if (ia_valid & (ATTR_UID | ATTR_GID)) flags |= MAY_CHOWN;
-		if (ia_valid & ATTR_MODE) flags |= MAY_CHMOD;
-		if (MayModifyNode(dentry, flags) < 0) return -EPERM;
-		if (!error) error = inode_setattr(inode, attr);
+		if (ia_valid & (ATTR_UID | ATTR_GID))
+			flags |= MAY_CHOWN;
+		if (ia_valid & ATTR_MODE)
+			flags |= MAY_CHMOD;
+		if (syaoran_may_modify_node(dentry, flags) < 0)
+			return -EPERM;
+		if (!error)
+			error = inode_setattr(inode, attr);
 	}
 	return error;
 }
 
 static struct address_space_operations syaoran_aops = {
-	readpage:       syaoran_readpage,
-	writepage:      fail_writepage,
-	prepare_write:  syaoran_prepare_write,
-	commit_write:   syaoran_commit_write
+	.readpage      = syaoran_readpage,
+	.writepage     = fail_writepage,
+	.prepare_write = syaoran_prepare_write,
+	.commit_write  = syaoran_commit_write,
 };
 
 static struct file_operations syaoran_file_operations = {
-	read:       generic_file_read,
-	write:      generic_file_write,
-	mmap:       generic_file_mmap,
-	fsync:      syaoran_sync_file,
+	.read  = generic_file_read,
+	.write = generic_file_write,
+	.mmap  = generic_file_mmap,
+	.fsync = syaoran_sync_file,
 };
 
 static struct inode_operations syaoran_dir_inode_operations = {
-	create:     syaoran_create,
-	lookup:     syaoran_lookup,
-	link:       syaoran_link,
-	unlink:     syaoran_unlink,
-	symlink:    syaoran_symlink,
-	mkdir:      syaoran_mkdir,
-	rmdir:      syaoran_rmdir,
-	mknod:      syaoran_mknod,
-	rename:     syaoran_rename,
-	setattr:    syaoran_setattr,
+	.create  = syaoran_create,
+	.lookup  = syaoran_lookup,
+	.link    = syaoran_link,
+	.unlink  = syaoran_unlink,
+	.symlink = syaoran_symlink,
+	.mkdir   = syaoran_mkdir,
+	.rmdir   = syaoran_rmdir,
+	.mknod   = syaoran_mknod,
+	.rename  = syaoran_rename,
+	.setattr = syaoran_setattr,
 };
 
 static struct inode_operations syaoran_symlink_inode_operations = {
-	readlink:    page_readlink,
-	follow_link: page_follow_link,
-	setattr:     syaoran_setattr,
+	.readlink    = page_readlink,
+	.follow_link = page_follow_link,
+	.setattr     = syaoran_setattr,
 };
 
 static struct inode_operations syaoran_file_inode_operations = {
-	setattr: syaoran_setattr,
+	.setattr = syaoran_setattr,
 };
 
 static struct super_operations syaoran_ops = {
-	statfs:     syaoran_statfs,
-	put_inode:  force_delete,
-	put_super:  syaoran_put_super,
+	.statfs    = syaoran_statfs,
+	.put_inode = force_delete,
+	.put_super = syaoran_put_super,
 };
 
-static struct super_block *syaoran_read_super(struct super_block * sb, void * data, int silent)
+static struct super_block *syaoran_read_super(struct super_block *sb,
+					      void *data, int silent)
 {
-	struct inode * inode;
-	struct dentry * root;
+	struct inode *inode;
+	struct dentry *root;
 
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->s_magic = SYAORAN_MAGIC;
 	sb->s_op = &syaoran_ops;
-	if (Syaoran_Initialize(sb, data) < 0) return NULL;
+	if (syaoran_initialize(sb, data) < 0)
+		return NULL;
 	inode = syaoran_get_inode(sb, S_IFDIR | 0755, 0);
 	if (!inode)
 		return NULL;
@@ -378,11 +406,12 @@
 		return NULL;
 	}
 	sb->s_root = root;
-	MakeInitialNodes(sb);
+	syaoran_make_initial_nodes(sb);
 	return sb;
 }
 
-static DECLARE_FSTYPE(syaoran_fs_type, "syaoran", syaoran_read_super, FS_LITTER);
+static DECLARE_FSTYPE(syaoran_fs_type, "syaoran", syaoran_read_super,
+		      FS_LITTER);
 
 static int __init init_syaoran_fs(void)
 {
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(working copy)
@@ -11,24 +11,28 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** TOMOYO Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/tomoyo.h>
 #include <linux/realpath.h>
 #include <linux/highmem.h>
 #include <linux/binfmts.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+#include <linux/namei.h>
+#include <linux/mount.h>
+#endif
 
+/* For compatibility with older kernels. */
 #ifndef for_each_process
 #define for_each_process for_each_task
 #endif
 
-/*************************  VARIABLES  *************************/
+/* Variables definitions.*/
 
 /* The initial domain. */
 struct domain_info KERNEL_DOMAIN;
 
-/* List of domains. */
+/* The list for "struct domain_info". */
 LIST1_HEAD(domain_list);
 
 #ifdef CONFIG_TOMOYO
@@ -36,32 +40,32 @@
 /* Lock for appending domain's ACL. */
 DEFINE_MUTEX(domain_acl_lock);
 
-/*************************  UTILITY FUNCTIONS  *************************/
+/* Domain creation lock. */
+static DEFINE_MUTEX(new_domain_assign_lock);
 
-/***** The structure for program files to force domain reconstruction. *****/
-
+/*
+ * The structure for "initialize_domain" and "no_initialize_domain" directive.
+ */
 struct domain_initializer_entry {
 	struct list1_head list;
 	const struct path_info *domainname;    /* This may be NULL */
 	const struct path_info *program;
 	bool is_deleted;
-	bool is_not;
-	bool is_last_name;
+	bool is_not;       /* True if this entry is "no_initialize_domain".  */
+	bool is_last_name; /* True if the domainname is ccs_get_last_name(). */
 };
 
-/***** The structure for domains to not to transit domains. *****/
-
+/* The structure for "keep_domain" and "no_keep_domain" directive. */
 struct domain_keeper_entry {
 	struct list1_head list;
 	const struct path_info *domainname;
 	const struct path_info *program;       /* This may be NULL */
 	bool is_deleted;
-	bool is_not;
-	bool is_last_name;
+	bool is_not;       /* True if this entry is "no_keep_domain".        */
+	bool is_last_name; /* True if the domainname is ccs_get_last_name(). */
 };
 
-/***** The structure for program files that should be aggregated. *****/
-
+/* The structure for "aggregator" directive. */
 struct aggregator_entry {
 	struct list1_head list;
 	const struct path_info *original_name;
@@ -69,8 +73,7 @@
 	bool is_deleted;
 };
 
-/***** The structure for program files that should be aliased. *****/
-
+/* The structure for "alias" directive. */
 struct alias_entry {
 	struct list1_head list;
 	const struct path_info *original_name;
@@ -78,77 +81,205 @@
 	bool is_deleted;
 };
 
-/*************************  VARIABLES  *************************/
+/* Utility functions.*/
 
-/* Domain creation lock. */
-static DEFINE_MUTEX(new_domain_assign_lock);
-
-/*************************  UTILITY FUNCTIONS  *************************/
-
-void SetDomainFlag(struct domain_info *domain, const bool is_delete, const u8 flags)
+/**
+ * ccs_set_domain_flag - Set or clear domain's attribute flags.
+ *
+ * @domain:    Pointer to "struct domain_info".
+ * @is_delete: True if it is a delete request.
+ * @flags:     Flags to set or clear.
+ *
+ * Returns nothing.
+ */
+void ccs_set_domain_flag(struct domain_info *domain, const bool is_delete,
+			 const u8 flags)
 {
 	mutex_lock(&new_domain_assign_lock);
-	if (!is_delete) domain->flags |= flags;
-	else domain->flags &= ~flags;
+	if (!is_delete)
+		domain->flags |= flags;
+	else
+		domain->flags &= ~flags;
 	mutex_unlock(&new_domain_assign_lock);
 }
 
-const char *GetLastName(const struct domain_info *domain)
+/**
+ * ccs_get_last_name -
+ *
+ * @domain: Pointer to "struct domain_info".
+ *
+ * Returns the last component of the domainname.
+ */
+const char *ccs_get_last_name(const struct domain_info *domain)
 {
-	const char *cp0 = domain->domainname->name, *cp1;
-	if ((cp1 = strrchr(cp0, ' ')) != NULL) return cp1 + 1;
+	const char *cp0 = domain->domainname->name, *cp1 = strrchr(cp0, ' ');
+	if (cp1)
+		return cp1 + 1;
 	return cp0;
 }
 
-int AddDomainACL(struct domain_info *domain, struct acl_info *acl)
+/**
+ * ccs_add_domain_acl -
+ *
+ * @domain: Pointer to "struct domain_info".
+ * @acl:    Pointer to "struct acl_info".
+ *
+ * Returns 0.
+ */
+int ccs_add_domain_acl(struct domain_info *domain, struct acl_info *acl)
 {
-	if (domain) list1_add_tail_mb(&acl->list, &domain->acl_info_list);
-	else acl->type &= ~ACL_DELETED;
-	UpdateCounter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
+	if (domain)
+		list1_add_tail_mb(&acl->list, &domain->acl_info_list);
+	else
+		acl->type &= ~ACL_DELETED;
+	ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 	return 0;
 }
 
-int DelDomainACL(struct acl_info *acl)
+/**
+ * ccs_del_domain_acl -
+ *
+ * @acl: Pointer to "struct acl_info".
+ *
+ * Returns 0.
+ */
+int ccs_del_domain_acl(struct acl_info *acl)
 {
-	if (acl) acl->type |= ACL_DELETED;
-	UpdateCounter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
+	if (acl)
+		acl->type |= ACL_DELETED;
+	ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 	return 0;
 }
 
-/*************************  DOMAIN INITIALIZER HANDLER  *************************/
+/* Audit functions. */
 
+/**
+ * audit_execute_handler_log -
+ *
+ * @is_preferred: True if it is "preffered_execute_handler" log.
+ * @handler:      The realpath of the handler.
+ * @bprm:         Pointer to "struct linux_binprm".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int audit_execute_handler_log(const bool is_preferred,
+				     const char *handler,
+				     struct linux_binprm *bprm)
+{
+	char *buf;
+	int len;
+	int len2;
+	u8 profile;
+	u8 mode;
+	if (ccs_can_save_audit_log(true) < 0)
+		return -ENOMEM;
+	len = strlen(handler) + 32;
+	profile = current->domain_info->profile;
+	mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE);
+	buf = ccs_init_audit_log(&len, profile, mode, bprm);
+	if (!buf)
+		return -ENOMEM;
+	len2 = strlen(buf);
+	snprintf(buf + len2, len - len2 - 1, "%s %s\n",
+		 is_preferred ?
+		 KEYWORD_PREFERRED_EXECUTE_HANDLER :
+		 KEYWORD_DEFAULT_EXECUTE_HANDLER,
+		 handler);
+	return ccs_write_audit_log(buf, true);
+}
+
+/**
+ * audit_domain_creation_log -
+ *
+ * @domainname: The name of newly created domain.
+ * @mode:       Access control mode.
+ * @profile:    Profile number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int audit_domain_creation_log(const char *domainname, const u8 mode,
+				     const u8 profile)
+{
+	char *buf;
+	char *cp;
+	int len;
+	int len2;
+	if (ccs_can_save_audit_log(false) < 0)
+		return -ENOMEM;
+	len = strlen(domainname) + 32;
+	buf = ccs_init_audit_log(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
+	cp = strchr(buf, '\n');
+	if (!cp) {
+		ccs_free(buf);
+		return -ENOMEM;
+	}
+	*++cp = '\0';
+	len2 = strlen(buf);
+	snprintf(buf + len2, len - len2 - 1, "%s\nuse_profile %u\n",
+		 domainname, profile);
+	return ccs_write_audit_log(buf, false);
+}
+
+
+/* Domain transition initialization handler. */
+
+/* The list for "struct domain_initializer_entry". */
 static LIST1_HEAD(domain_initializer_list);
 
-static int AddDomainInitializerEntry(const char *domainname, const char *program, const bool is_not, const bool is_delete)
+/**
+ * update_domain_initializer_entry -
+ *
+ * @domainname: The name of domain. May be NULL.
+ * @program:    The name of program.
+ * @is_not:     True if it is "no_initialize_domain" entry.
+ * @is_delete:  True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_domain_initializer_entry(const char *domainname,
+					   const char *program,
+					   const bool is_not,
+					   const bool is_delete)
 {
 	struct domain_initializer_entry *new_entry, *ptr;
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_program, *saved_domainname = NULL;
 	int error = -ENOMEM;
 	bool is_last_name = false;
-	if (!IsCorrectPath(program, 1, -1, -1, __FUNCTION__)) return -EINVAL; /* No patterns allowed. */
+	if (!ccs_is_correct_path(program, 1, -1, -1, __func__))
+		return -EINVAL; /* No patterns allowed. */
 	if (domainname) {
-		if (!IsDomainDef(domainname) && IsCorrectPath(domainname, 1, -1, -1, __FUNCTION__)) {
+		if (!ccs_is_domain_def(domainname) &&
+		    ccs_is_correct_path(domainname, 1, -1, -1, __func__))
 			is_last_name = true;
-		} else if (!IsCorrectDomain(domainname, __FUNCTION__)) {
+		else if (!ccs_is_correct_domain(domainname, __func__))
 			return -EINVAL;
-		}
-		if ((saved_domainname = SaveName(domainname)) == NULL) return -ENOMEM;
+		saved_domainname = ccs_save_name(domainname);
+		if (!saved_domainname)
+			return -ENOMEM;
 	}
-	if ((saved_program = SaveName(program)) == NULL) return -ENOMEM;
+	saved_program = ccs_save_name(program);
+	if (!saved_program)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &domain_initializer_list, list) {
-		if (ptr->is_not == is_not && ptr->domainname == saved_domainname && ptr->program == saved_program) {
-			ptr->is_deleted = is_delete;
-			error = 0;
-			goto out;
-		}
+		if (ptr->is_not != is_not ||
+		    ptr->domainname != saved_domainname ||
+		    ptr->program != saved_program)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		goto out;
 	}
 	if (is_delete) {
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->domainname = saved_domainname;
 	new_entry->program = saved_program;
 	new_entry->is_not = is_not;
@@ -160,87 +291,157 @@
 	return error;
 }
 
-int ReadDomainInitializerPolicy(struct io_buffer *head)
+/**
+ * ccs_read_domain_initializer_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &domain_initializer_list) {
 		struct domain_initializer_entry *ptr;
 		ptr = list1_entry(pos, struct domain_initializer_entry, list);
-		if (ptr->is_deleted) continue;
+		if (ptr->is_deleted)
+			continue;
 		if (ptr->domainname) {
-			if (io_printf(head, "%s" KEYWORD_INITIALIZE_DOMAIN "%s from %s\n", ptr->is_not ? "no_" : "", ptr->program->name, ptr->domainname->name)) return -ENOMEM;
+			if (!ccs_io_printf(head, "%s" KEYWORD_INITIALIZE_DOMAIN
+					   "%s from %s\n",
+					   ptr->is_not ? "no_" : "",
+					   ptr->program->name,
+					   ptr->domainname->name))
+				goto out;
 		} else {
-			if (io_printf(head, "%s" KEYWORD_INITIALIZE_DOMAIN "%s\n", ptr->is_not ? "no_" : "", ptr->program->name)) return -ENOMEM;
+			if (!ccs_io_printf(head, "%s"
+					   KEYWORD_INITIALIZE_DOMAIN "%s\n",
+					   ptr->is_not ? "no_" : "",
+					   ptr->program->name))
+				goto out;
 		}
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
 
-int AddDomainInitializerPolicy(char *data, const bool is_not, const bool is_delete)
+/**
+ * ccs_write_domain_initializer_policy -
+ *
+ * @data:      String to parse.
+ * @is_not:    True if it is "no_initialize_domain" entry.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_domain_initializer_policy(char *data, const bool is_not,
+					const bool is_delete)
 {
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
-		return AddDomainInitializerEntry(cp + 6, data, is_not, is_delete);
+		return update_domain_initializer_entry(cp + 6, data, is_not,
+						       is_delete);
 	} else {
-		return AddDomainInitializerEntry(NULL, data, is_not, is_delete);
+		return update_domain_initializer_entry(NULL, data, is_not,
+						       is_delete);
 	}
 }
 
-static bool IsDomainInitializer(const struct path_info *domainname, const struct path_info *program, const struct path_info *last_name)
+/**
+ * is_domain_initializer -
+ *
+ * @domainname: The name of domain.
+ * @program:    The name of program.
+ * @last_name:  The last component of @domainname.
+ *
+ * Returns true if executing @program reinitializes domain transition,
+ * false otherwise.
+ */
+static bool is_domain_initializer(const struct path_info *domainname,
+				  const struct path_info *program,
+				  const struct path_info *last_name)
 {
 	struct domain_initializer_entry *ptr;
 	bool flag = false;
 	list1_for_each_entry(ptr,  &domain_initializer_list, list) {
-		if (ptr->is_deleted) continue;
+		if (ptr->is_deleted)
+			continue;
 		if (ptr->domainname) {
 			if (!ptr->is_last_name) {
-				if (ptr->domainname != domainname) continue;
+				if (ptr->domainname != domainname)
+					continue;
 			} else {
-				if (pathcmp(ptr->domainname, last_name)) continue;
+				if (ccs_pathcmp(ptr->domainname, last_name))
+					continue;
 			}
 		}
-		if (pathcmp(ptr->program, program)) continue;
-		if (ptr->is_not) return false;
+		if (ccs_pathcmp(ptr->program, program))
+			continue;
+		if (ptr->is_not)
+			return false;
 		flag = true;
 	}
 	return flag;
 }
 
-/*************************  DOMAIN KEEPER HANDLER  *************************/
+/* Domain transition suppress handler. */
 
+/* The list for "struct domain_keeper_entry". */
 static LIST1_HEAD(domain_keeper_list);
 
-static int AddDomainKeeperEntry(const char *domainname, const char *program, const bool is_not, const bool is_delete)
+/**
+ * update_domain_keeper_entry -
+ *
+ * @domainname: The name of domain.
+ * @program:    The name of program. May be NULL.
+ * @is_not:     True if it is "no_keep_domain" entry.
+ * @is_delete:  True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_domain_keeper_entry(const char *domainname,
+				      const char *program,
+				      const bool is_not, const bool is_delete)
 {
 	struct domain_keeper_entry *new_entry, *ptr;
 	const struct path_info *saved_domainname, *saved_program = NULL;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
 	bool is_last_name = false;
-	if (!IsDomainDef(domainname) && IsCorrectPath(domainname, 1, -1, -1, __FUNCTION__)) {
+	if (!ccs_is_domain_def(domainname) &&
+	    ccs_is_correct_path(domainname, 1, -1, -1, __func__))
 		is_last_name = true;
-	} else if (!IsCorrectDomain(domainname, __FUNCTION__)) {
+	else if (!ccs_is_correct_domain(domainname, __func__))
 		return -EINVAL;
-	}
 	if (program) {
-		if (!IsCorrectPath(program, 1, -1, -1, __FUNCTION__)) return -EINVAL;
-		if ((saved_program = SaveName(program)) == NULL) return -ENOMEM;
+		if (!ccs_is_correct_path(program, 1, -1, -1, __func__))
+			return -EINVAL;
+		saved_program = ccs_save_name(program);
+		if (!saved_program)
+			return -ENOMEM;
 	}
-	if ((saved_domainname = SaveName(domainname)) == NULL) return -ENOMEM;
+	saved_domainname = ccs_save_name(domainname);
+	if (!saved_domainname)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &domain_keeper_list, list) {
-		if (ptr->is_not == is_not && ptr->domainname == saved_domainname && ptr->program == saved_program) {
-			ptr->is_deleted = is_delete;
-			error = 0;
-			goto out;
-		}
+		if (ptr->is_not != is_not ||
+		    ptr->domainname != saved_domainname ||
+		    ptr->program != saved_program)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		goto out;
 	}
 	if (is_delete) {
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->domainname = saved_domainname;
 	new_entry->program = saved_program;
 	new_entry->is_not = is_not;
@@ -252,76 +453,144 @@
 	return error;
 }
 
-int AddDomainKeeperPolicy(char *data, const bool is_not, const bool is_delete)
+/**
+ * ccs_write_domain_keeper_policy -
+ *
+ * @data:      String to parse.
+ * @is_not:    True if it is "no_keep_domain" entry.
+ * @is_delete: True if it is a delete request.
+ *
+ */
+int ccs_write_domain_keeper_policy(char *data, const bool is_not,
+				   const bool is_delete)
 {
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
-		return AddDomainKeeperEntry(cp + 6, data, is_not, is_delete);
+		return update_domain_keeper_entry(cp + 6, data,
+						  is_not, is_delete);
 	} else {
-		return AddDomainKeeperEntry(data, NULL, is_not, is_delete);
+		return update_domain_keeper_entry(data, NULL,
+						  is_not, is_delete);
 	}
 }
 
-int ReadDomainKeeperPolicy(struct io_buffer *head)
+/**
+ * ccs_read_domain_keeper_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &domain_keeper_list) {
 		struct domain_keeper_entry *ptr;
+		const char *is_not;
 		ptr = list1_entry(pos, struct domain_keeper_entry, list);
-		if (ptr->is_deleted) continue;
+		if (ptr->is_deleted)
+			continue;
+		is_not = ptr->is_not ? "no_" : "";
 		if (ptr->program) {
-			if (io_printf(head, "%s" KEYWORD_KEEP_DOMAIN "%s from %s\n", ptr->is_not ? "no_" : "", ptr->program->name, ptr->domainname->name)) return -ENOMEM;
+			if (!ccs_io_printf(head,
+					   "%s" KEYWORD_KEEP_DOMAIN "%s "
+					   "from %s\n",
+					   is_not, ptr->program->name,
+					   ptr->domainname->name))
+				goto out;
 		} else {
-			if (io_printf(head, "%s" KEYWORD_KEEP_DOMAIN "%s\n", ptr->is_not ? "no_" : "", ptr->domainname->name)) return -ENOMEM;
+			if (!ccs_io_printf(head,
+					   "%s" KEYWORD_KEEP_DOMAIN "%s\n",
+					   is_not, ptr->domainname->name))
+				goto out;
 		}
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
 
-static bool IsDomainKeeper(const struct path_info *domainname, const struct path_info *program, const struct path_info *last_name)
+/**
+ * is_domain_keeper -
+ *
+ * @domainname: The name of domain.
+ * @program:    The name of program.
+ * @last_name:  The last component of @domainname.
+ *
+ * Returns true if executing @program supresses domain transition,
+ * false otherwise.
+ */
+static bool is_domain_keeper(const struct path_info *domainname,
+			     const struct path_info *program,
+			     const struct path_info *last_name)
 {
 	struct domain_keeper_entry *ptr;
 	bool flag = false;
 	list1_for_each_entry(ptr, &domain_keeper_list, list) {
-		if (ptr->is_deleted) continue;
+		if (ptr->is_deleted)
+			continue;
 		if (!ptr->is_last_name) {
-			if (ptr->domainname != domainname) continue;
+			if (ptr->domainname != domainname)
+				continue;
 		} else {
-			if (pathcmp(ptr->domainname, last_name)) continue;
+			if (ccs_pathcmp(ptr->domainname, last_name))
+				continue;
 		}
-		if (ptr->program && pathcmp(ptr->program, program)) continue;
-		if (ptr->is_not) return false;
+		if (ptr->program && ccs_pathcmp(ptr->program, program))
+			continue;
+		if (ptr->is_not)
+			return false;
 		flag = true;
 	}
 	return flag;
 }
 
-/*************************  SYMBOLIC LINKED PROGRAM HANDLER  *************************/
+/* Synbolic linked program handler.*/
 
+/* The list for "struct alias_entry". */
 static LIST1_HEAD(alias_list);
 
-static int AddAliasEntry(const char *original_name, const char *aliased_name, const bool is_delete)
+/**
+ * update_alias_entry -
+ *
+ * @original_name: The original program's real name.
+ * @aliased_name:  The symbolic program's symbolic link's name.
+ * @is_delete:     True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_alias_entry(const char *original_name,
+			      const char *aliased_name,
+			      const bool is_delete)
 {
 	struct alias_entry *new_entry, *ptr;
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_original_name, *saved_aliased_name;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(original_name, 1, -1, -1, __FUNCTION__) || !IsCorrectPath(aliased_name, 1, -1, -1, __FUNCTION__)) return -EINVAL; /* No patterns allowed. */
-	if ((saved_original_name = SaveName(original_name)) == NULL || (saved_aliased_name = SaveName(aliased_name)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(original_name, 1, -1, -1, __func__) ||
+	    !ccs_is_correct_path(aliased_name, 1, -1, -1, __func__))
+		return -EINVAL; /* No patterns allowed. */
+	saved_original_name = ccs_save_name(original_name);
+	saved_aliased_name = ccs_save_name(aliased_name);
+	if (!saved_original_name || !saved_aliased_name)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &alias_list, list) {
-		if (ptr->original_name == saved_original_name && ptr->aliased_name == saved_aliased_name) {
-			ptr->is_deleted = is_delete;
-			error = 0;
-			goto out;
-		}
+		if (ptr->original_name != saved_original_name ||
+		    ptr->aliased_name != saved_aliased_name)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		goto out;
 	}
 	if (is_delete) {
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->original_name = saved_original_name;
 	new_entry->aliased_name = saved_aliased_name;
 	list1_add_tail_mb(&new_entry->list, &alias_list);
@@ -331,51 +600,93 @@
 	return error;
 }
 
-int ReadAliasPolicy(struct io_buffer *head)
+/**
+ * ccs_read_alias_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_alias_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &alias_list) {
 		struct alias_entry *ptr;
 		ptr = list1_entry(pos, struct alias_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALIAS "%s %s\n", ptr->original_name->name, ptr->aliased_name->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, KEYWORD_ALIAS "%s %s\n",
+				   ptr->original_name->name,
+				   ptr->aliased_name->name))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
 
-int AddAliasPolicy(char *data, const bool is_delete)
+/**
+ * ccs_write_alias_policy -
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_alias_policy(char *data, const bool is_delete)
 {
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
-	return AddAliasEntry(data, cp, is_delete);
+	return update_alias_entry(data, cp, is_delete);
 }
 
-/*************************  DOMAIN AGGREGATOR HANDLER  *************************/
+/* Domain aggregator handler. */
 
+/* The list for "struct aggregator_entry". */
 static LIST1_HEAD(aggregator_list);
 
-static int AddAggregatorEntry(const char *original_name, const char *aggregated_name, const bool is_delete)
+/**
+ * update_aggregator_entry -
+ *
+ * @original_name:   The original program's name.
+ * @aggregated_name: The aggregated program's name.
+ * @is_delete:       True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_aggregator_entry(const char *original_name,
+				   const char *aggregated_name,
+				   const bool is_delete)
 {
 	struct aggregator_entry *new_entry, *ptr;
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_original_name, *saved_aggregated_name;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(original_name, 1, 0, -1, __FUNCTION__) || !IsCorrectPath(aggregated_name, 1, -1, -1, __FUNCTION__)) return -EINVAL;
-	if ((saved_original_name = SaveName(original_name)) == NULL || (saved_aggregated_name = SaveName(aggregated_name)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(original_name, 1, 0, -1, __func__) ||
+	    !ccs_is_correct_path(aggregated_name, 1, -1, -1, __func__))
+		return -EINVAL;
+	saved_original_name = ccs_save_name(original_name);
+	saved_aggregated_name = ccs_save_name(aggregated_name);
+	if (!saved_original_name || !saved_aggregated_name)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &aggregator_list, list) {
-		if (ptr->original_name == saved_original_name && ptr->aggregated_name == saved_aggregated_name) {
-			ptr->is_deleted = is_delete;
-			error = 0;
-			goto out;
-		}
+		if (ptr->original_name != saved_original_name ||
+		    ptr->aggregated_name != saved_aggregated_name)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		goto out;
 	}
 	if (is_delete) {
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->original_name = saved_original_name;
 	new_entry->aggregated_name = saved_aggregated_name;
 	list1_add_tail_mb(&new_entry->list, &aggregator_list);
@@ -385,61 +696,100 @@
 	return error;
 }
 
-int ReadAggregatorPolicy(struct io_buffer *head)
+/**
+ * ccs_read_aggregator_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_aggregator_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &aggregator_list) {
 		struct aggregator_entry *ptr;
 		ptr = list1_entry(pos, struct aggregator_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_AGGREGATOR "%s %s\n", ptr->original_name->name, ptr->aggregated_name->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, KEYWORD_AGGREGATOR "%s %s\n",
+				   ptr->original_name->name,
+				   ptr->aggregated_name->name))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
 
-int AddAggregatorPolicy(char *data, const bool is_delete)
+/**
+ * ccs_write_aggregator_policy -
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_aggregator_policy(char *data, const bool is_delete)
 {
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
-	return AddAggregatorEntry(data, cp, is_delete);
+	return update_aggregator_entry(data, cp, is_delete);
 }
 
-/*************************  DOMAIN DELETION HANDLER  *************************/
+/* Domain create/delete/undelete handler. */
 
 /* #define DEBUG_DOMAIN_UNDELETE */
 
-int DeleteDomain(char *domainname0)
+/**
+ * ccs_delete_domain - Delete a domain.
+ *
+ * @domainname: The name of domain.
+ *
+ * Returns 0.
+ */
+int ccs_delete_domain(char *domainname)
 {
 	struct domain_info *domain;
-	struct path_info domainname;
-	domainname.name = domainname0;
-	fill_path_info(&domainname);
+	struct path_info name;
+	name.name = domainname;
+	ccs_fill_path_info(&name);
 	mutex_lock(&new_domain_assign_lock);
 #ifdef DEBUG_DOMAIN_UNDELETE
-	printk("DeleteDomain %s\n", domainname0);
+	printk(KERN_DEBUG "ccs_delete_domain %s\n", domainname);
 	list1_for_each_entry(domain, &domain_list, list) {
-		if (pathcmp(domain->domainname, &domainname)) continue;
-		printk("List: %p %u\n", domain, domain->is_deleted);
+		if (ccs_pathcmp(domain->domainname, &name))
+			continue;
+		printk(KERN_DEBUG "List: %p %u\n", domain, domain->is_deleted);
 	}
 #endif
 	/* Is there an active domain? */
 	list1_for_each_entry(domain, &domain_list, list) {
 		struct domain_info *domain2;
 		/* Never delete KERNEL_DOMAIN */
-		if (domain == &KERNEL_DOMAIN || domain->is_deleted || pathcmp(domain->domainname, &domainname)) continue;
+		if (domain == &KERNEL_DOMAIN)
+			continue;
+		if (domain->is_deleted ||
+		    ccs_pathcmp(domain->domainname, &name))
+			continue;
 		/* Mark already deleted domains as non undeletable. */
 		list1_for_each_entry(domain2, &domain_list, list) {
-			if (!domain2->is_deleted || pathcmp(domain2->domainname, &domainname)) continue;
+			if (!domain2->is_deleted ||
+			    ccs_pathcmp(domain2->domainname, &name))
+				continue;
 #ifdef DEBUG_DOMAIN_UNDELETE
-			if (domain2->is_deleted != 255) printk("Marked %p as non undeletable\n", domain2);
+			if (domain2->is_deleted != 255)
+				printk(KERN_DEBUG
+				       "Marked %p as non undeletable\n",
+				       domain2);
 #endif
 			domain2->is_deleted = 255;
 		}
 		/* Delete and mark active domain as undeletable. */
 		domain->is_deleted = 1;
 #ifdef DEBUG_DOMAIN_UNDELETE
-		printk("Marked %p as undeletable\n", domain);
+		printk(KERN_DEBUG "Marked %p as undeletable\n", domain);
 #endif
 		break;
 	}
@@ -447,74 +797,110 @@
 	return 0;
 }
 
-struct domain_info *UndeleteDomain(const char *domainname0)
+/**
+ * ccs_undelete_domain - Undelete a domain.
+ *
+ * @domainname: The name of domain.
+ *
+ * Returns pointer to "struct domain_info" on success, NULL otherwise.
+ */
+struct domain_info *ccs_undelete_domain(const char *domainname)
 {
 	struct domain_info *domain, *candidate_domain = NULL;
-	struct path_info domainname;
-	domainname.name = domainname0;
-	fill_path_info(&domainname);
+	struct path_info name;
+	name.name = domainname;
+	ccs_fill_path_info(&name);
 	mutex_lock(&new_domain_assign_lock);
 #ifdef DEBUG_DOMAIN_UNDELETE
-	printk("UndeleteDomain %s\n", domainname0);
+	printk(KERN_DEBUG "ccs_undelete_domain %s\n", domainname);
 	list1_for_each_entry(domain, &domain_list, list) {
-		if (pathcmp(domain->domainname, &domainname)) continue;
-		printk("List: %p %u\n", domain, domain->is_deleted);
+		if (ccs_pathcmp(domain->domainname, &name))
+			continue;
+		printk(KERN_DEBUG "List: %p %u\n", domain, domain->is_deleted);
 	}
 #endif
 	list1_for_each_entry(domain, &domain_list, list) {
-		if (pathcmp(&domainname, domain->domainname)) continue;
+		if (ccs_pathcmp(&name, domain->domainname))
+			continue;
 		if (!domain->is_deleted) {
 			/* This domain is active. I can't undelete. */
 			candidate_domain = NULL;
 #ifdef DEBUG_DOMAIN_UNDELETE
-			printk("%p is active. I can't undelete.\n", domain);
+			printk(KERN_DEBUG "%p is active. I can't undelete.\n",
+			       domain);
 #endif
 			break;
 		}
 		/* Is this domain undeletable? */
-		if (domain->is_deleted == 1) candidate_domain = domain;
+		if (domain->is_deleted == 1)
+			candidate_domain = domain;
 	}
 	if (candidate_domain) {
 		candidate_domain->is_deleted = 0;
 #ifdef DEBUG_DOMAIN_UNDELETE
-		printk("%p was undeleted.\n", candidate_domain);
+		printk(KERN_DEBUG "%p was undeleted.\n", candidate_domain);
 #endif
 	}
 	mutex_unlock(&new_domain_assign_lock);
 	return candidate_domain;
 }
 
-/*************************  DOMAIN TRANSITION HANDLER  *************************/
+/* Domain transition handler. */
 
-struct domain_info *FindOrAssignNewDomain(const char *domainname, const u8 profile)
+/**
+ * ccs_find_or_assign_new_domain -
+ *
+ * @domainname: The name of domain.
+ * @profile:    Profile number to assign if the domain was newly created.
+ *
+ * Returns pointer to "struct domain_info" on success, NULL otherwise.
+ */
+struct domain_info *ccs_find_or_assign_new_domain(const char *domainname,
+						  const u8 profile)
 {
 	struct domain_info *domain = NULL;
 	const struct path_info *saved_domainname;
 	mutex_lock(&new_domain_assign_lock);
-	if ((domain = FindDomain(domainname)) != NULL) goto out;
-	if (!IsCorrectDomain(domainname, __FUNCTION__)) goto out;
-	if ((saved_domainname = SaveName(domainname)) == NULL) goto out;
+	domain = ccs_find_domain(domainname);
+	if (domain)
+		goto out;
+	if (!ccs_is_correct_domain(domainname, __func__))
+		goto out;
+	saved_domainname = ccs_save_name(domainname);
+	if (!saved_domainname)
+		goto out;
 	/* Can I reuse memory of deleted domain? */
 	list1_for_each_entry(domain, &domain_list, list) {
 		struct task_struct *p;
 		struct acl_info *ptr;
 		bool flag;
-		if (!domain->is_deleted || domain->domainname != saved_domainname) continue;
+		if (!domain->is_deleted ||
+		    domain->domainname != saved_domainname)
+			continue;
 		flag = false;
 		/***** CRITICAL SECTION START *****/
 		read_lock(&tasklist_lock);
 		for_each_process(p) {
-			if (p->domain_info == domain) { flag = true; break; }
+			if (p->domain_info == domain) {
+				flag = true;
+				break;
+			}
 		}
 		read_unlock(&tasklist_lock);
 		/***** CRITICAL SECTION END *****/
-		if (flag) continue;
+		if (flag)
+			continue;
 #ifdef DEBUG_DOMAIN_UNDELETE
-		printk("Reusing %p %s\n", domain, domain->domainname->name);
+		printk(KERN_DEBUG "Reusing %p %s\n", domain,
+		       domain->domainname->name);
 #endif
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 			ptr->type |= ACL_DELETED;
 		}
+		/*
+		 * Don't use ccs_set_domain_flag() because
+		 * new_domain_assign_lock is held.
+		 */
 		domain->flags = 0;
 		domain->profile = profile;
 		domain->quota_warned = false;
@@ -523,30 +909,43 @@
 		goto out;
 	}
 	/* No memory reusable. Create using new memory. */
-	if ((domain = alloc_element(sizeof(*domain))) != NULL) {
+	domain = ccs_alloc_element(sizeof(*domain));
+	if (domain) {
 		INIT_LIST1_HEAD(&domain->acl_info_list);
 		domain->domainname = saved_domainname;
 		domain->profile = profile;
 		list1_add_tail_mb(&domain->list, &domain_list);
 	}
- out: ;
+ out:
 	mutex_unlock(&new_domain_assign_lock);
 	return domain;
 }
 
+/**
+ * get_argv0 -
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ * @tmp:  Buffer for temporal use.
+ *
+ * Returns true on success, false otherwise.
+ */
 static bool get_argv0(struct linux_binprm *bprm, struct ccs_page_buffer *tmp)
 {
 	char *arg_ptr = tmp->buffer;
 	int arg_len = 0;
 	unsigned long pos = bprm->p;
-	int i = pos / PAGE_SIZE, offset = pos % PAGE_SIZE;
+	int i = pos / PAGE_SIZE;
+	int offset = pos % PAGE_SIZE;
 	bool done = false;
-	if (!bprm->argc) goto out;
+	if (!bprm->argc)
+		goto out;
 	while (1) {
 		struct page *page;
 		const char *kaddr;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
-		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0) goto out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
+		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page,
+				   NULL) <= 0)
+			goto out;
 		pos += PAGE_SIZE - offset;
 #else
 		page = bprm->page[i];
@@ -554,7 +953,7 @@
 		/* Map. */
 		kaddr = kmap(page);
 		if (!kaddr) { /* Mapping failed. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 			put_page(page);
 #endif
 			goto out;
@@ -573,7 +972,8 @@
 				} else {
 					arg_ptr[arg_len++] = '\\';
 					arg_ptr[arg_len++] = (c >> 6) + '0';
-					arg_ptr[arg_len++] = ((c >> 3) & 7) + '0';
+					arg_ptr[arg_len++]
+						= ((c >> 3) & 7) + '0';
 					arg_ptr[arg_len++] = (c & 7) + '0';
 				}
 			} else {
@@ -584,91 +984,128 @@
 		}
 		/* Unmap. */
 		kunmap(page);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 		put_page(page);
 #endif
 		i++;
 		offset = 0;
-		if (done) break;
+		if (done)
+			break;
 	}
 	return true;
  out:
 	return false;
 }
 
-static int FindNextDomain(struct linux_binprm *bprm, struct domain_info **next_domain, const struct path_info *path_to_verify, struct ccs_page_buffer *tmp)
+/**
+ * find_next_domain -
+ *
+ * @bprm:           Pointer to "struct linux_binprm".
+ * @next_domain:    Pointer to pointer to "struct domain_info".
+ * @path_to_verify: Pathname to verify. May be NULL.
+ * @tmp:            Buffer for temporal use.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int find_next_domain(struct linux_binprm *bprm,
+			    struct domain_info **next_domain,
+			    const struct path_info *path_to_verify,
+			    struct ccs_page_buffer *tmp)
 {
-	/* This function assumes that the size of buffer returned by realpath() = CCS_MAX_PATHNAME_LEN. */
-	struct domain_info *old_domain = current->domain_info, *domain = NULL;
+	/*
+	 * This function assumes that the size of buffer returned by
+	 * ccs_realpath() = CCS_MAX_PATHNAME_LEN.
+	 */
+	struct domain_info *old_domain = current->domain_info;
+	struct domain_info *domain = NULL;
 	const char *old_domain_name = old_domain->domainname->name;
 	const char *original_name = bprm->filename;
 	char *new_domain_name = NULL;
-	char *real_program_name = NULL, *symlink_program_name = NULL;
-	const bool is_enforce = (CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE) == 3);
+	char *real_program_name = NULL;
+	char *symlink_program_name = NULL;
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE);
+	const bool is_enforce = (mode == 3);
 	int retval;
 	struct path_info r, s, l;
 
 	{
 		/*
-		 * Built-in initializers. This is needed because policies are not loaded until starting /sbin/init .
+		 * Built-in initializers. This is needed because policies are
+		 * not loaded until starting /sbin/init .
 		 */
 		static bool first = true;
 		if (first) {
-			AddDomainInitializerEntry(NULL, "/sbin/hotplug", 0, 0);
-			AddDomainInitializerEntry(NULL, "/sbin/modprobe", 0, 0);
+			update_domain_initializer_entry(NULL, "/sbin/hotplug",
+							false, false);
+			update_domain_initializer_entry(NULL, "/sbin/modprobe",
+							false, false);
 			first = false;
 		}
 	}
 
-	/* Get realpath of program. */
-	retval = -ENOENT; /* I hope realpath() won't fail with -ENOMEM. */
-	if ((real_program_name = realpath(original_name)) == NULL) goto out;
-	/* Get realpath of symbolic link. */
-	if ((symlink_program_name = realpath_nofollow(original_name)) == NULL) goto out;
+	/* Get ccs_realpath of program. */
+	retval = -ENOENT; /* I hope ccs_realpath() won't fail with -ENOMEM. */
+	real_program_name = ccs_realpath(original_name);
+	if (!real_program_name)
+		goto out;
+	/* Get ccs_realpath of symbolic link. */
+	symlink_program_name = ccs_realpath_nofollow(original_name);
+	if (!symlink_program_name)
+		goto out;
 
 	r.name = real_program_name;
-	fill_path_info(&r);
+	ccs_fill_path_info(&r);
 	s.name = symlink_program_name;
-	fill_path_info(&s);
-	if ((l.name = strrchr(old_domain_name, ' ')) != NULL) l.name++;
-	else l.name = old_domain_name;
-	fill_path_info(&l);
+	ccs_fill_path_info(&s);
+	l.name = ccs_get_last_name(old_domain);
+	ccs_fill_path_info(&l);
 
 	if (path_to_verify) {
-		if (pathcmp(&r, path_to_verify)) {
+		if (ccs_pathcmp(&r, path_to_verify)) {
 			static u8 counter = 20;
 			if (counter) {
 				counter--;
-				printk("Failed to verify: %s\n", path_to_verify->name);
+				printk(KERN_WARNING "Failed to verify: %s\n",
+				       path_to_verify->name);
 			}
 			goto out;
 		}
-		goto ok;
+		goto calculate_domain;
 	}
 
 	/* Check 'alias' directive. */
-	if (pathcmp(&r, &s)) {
+	if (ccs_pathcmp(&r, &s)) {
 		struct alias_entry *ptr;
 		/* Is this program allowed to be called via symbolic links? */
 		list1_for_each_entry(ptr, &alias_list, list) {
-			if (ptr->is_deleted || pathcmp(&r, ptr->original_name) || pathcmp(&s, ptr->aliased_name)) continue;
+			if (ptr->is_deleted ||
+			    ccs_pathcmp(&r, ptr->original_name) ||
+			    ccs_pathcmp(&s, ptr->aliased_name))
+				continue;
 			memset(real_program_name, 0, CCS_MAX_PATHNAME_LEN);
-			strncpy(real_program_name, ptr->aliased_name->name, CCS_MAX_PATHNAME_LEN - 1);
-			fill_path_info(&r);
+			strncpy(real_program_name, ptr->aliased_name->name,
+				CCS_MAX_PATHNAME_LEN - 1);
+			ccs_fill_path_info(&r);
 			break;
 		}
 	}
 
 	/* Compare basename of real_program_name and argv[0] */
-	if (bprm->argc > 0 && CheckCCSFlags(CCS_TOMOYO_MAC_FOR_ARGV0)) {
+	if (bprm->argc > 0 && ccs_check_flags(CCS_TOMOYO_MAC_FOR_ARGV0)) {
 		char *base_argv0 = tmp->buffer;
 		const char *base_filename;
 		retval = -ENOMEM;
-		if (!get_argv0(bprm, tmp)) goto out;
-		if ((base_filename = strrchr(real_program_name, '/')) == NULL) base_filename = real_program_name; else base_filename++;
+		if (!get_argv0(bprm, tmp))
+			goto out;
+		base_filename = strrchr(real_program_name, '/');
+		if (!base_filename)
+			base_filename = real_program_name;
+		else
+			base_filename++;
 		if (strcmp(base_argv0, base_filename)) {
-			retval = CheckArgv0Perm(&r, base_argv0);
-			if (retval) goto out;
+			retval = ccs_check_argv0_perm(&r, base_argv0);
+			if (retval)
+				goto out;
 		}
 	}
 
@@ -677,74 +1114,103 @@
 		struct aggregator_entry *ptr;
 		/* Is this program allowed to be aggregated? */
 		list1_for_each_entry(ptr, &aggregator_list, list) {
-			if (ptr->is_deleted || !PathMatchesToPattern(&r, ptr->original_name)) continue;
+			if (ptr->is_deleted ||
+			    !ccs_path_matches_pattern(&r, ptr->original_name))
+				continue;
 			memset(real_program_name, 0, CCS_MAX_PATHNAME_LEN);
-			strncpy(real_program_name, ptr->aggregated_name->name, CCS_MAX_PATHNAME_LEN - 1);
-			fill_path_info(&r);
+			strncpy(real_program_name, ptr->aggregated_name->name,
+				CCS_MAX_PATHNAME_LEN - 1);
+			ccs_fill_path_info(&r);
 			break;
 		}
 	}
 
 	/* Check execute permission. */
-	if ((retval = CheckExecPerm(&r, bprm, tmp)) < 0) goto out;
+	retval = ccs_check_exec_perm(&r, bprm, tmp);
+	if (retval < 0)
+		goto out;
 
- ok: ;
+ calculate_domain:
 	new_domain_name = tmp->buffer;
-	if (IsDomainInitializer(old_domain->domainname, &r, &l)) {
+	if (is_domain_initializer(old_domain->domainname, &r, &l)) {
 		/* Transit to the child of KERNEL_DOMAIN domain. */
-		snprintf(new_domain_name, CCS_MAX_PATHNAME_LEN + 1, ROOT_NAME " " "%s", real_program_name);
+		snprintf(new_domain_name, CCS_MAX_PATHNAME_LEN + 1,
+			 ROOT_NAME " " "%s", real_program_name);
 	} else if (old_domain == &KERNEL_DOMAIN && !sbin_init_started) {
 		/*
-		 * Needn't to transit from kernel domain before starting /sbin/init .
-		 * But transit from kernel domain if executing initializers, for they might start before /sbin/init .
+		 * Needn't to transit from kernel domain before starting
+		 * /sbin/init . But transit from kernel domain if executing
+		 * initializers because they might start before /sbin/init .
 		 */
 		domain = old_domain;
-	} else if (IsDomainKeeper(old_domain->domainname, &r, &l)) {
+	} else if (is_domain_keeper(old_domain->domainname, &r, &l)) {
 		/* Keep current domain. */
 		domain = old_domain;
 	} else {
 		/* Normal domain transition. */
-		snprintf(new_domain_name, CCS_MAX_PATHNAME_LEN + 1, "%s %s", old_domain_name, real_program_name);
+		snprintf(new_domain_name, CCS_MAX_PATHNAME_LEN + 1,
+			 "%s %s", old_domain_name, real_program_name);
 	}
-	if (!domain && strlen(new_domain_name) < CCS_MAX_PATHNAME_LEN) {
-		if (is_enforce) {
-			domain = FindDomain(new_domain_name);
-			if (!domain) if (CheckSupervisor("#Need to create domain\n%s\n", new_domain_name) == 0) domain = FindOrAssignNewDomain(new_domain_name, current->domain_info->profile);
-		} else {
-			domain = FindOrAssignNewDomain(new_domain_name, current->domain_info->profile);
-		}
+	if (domain || strlen(new_domain_name) >= CCS_MAX_PATHNAME_LEN)
+		goto done;
+	domain = ccs_find_domain(new_domain_name);
+	if (domain)
+		goto done;
+	if (is_enforce) {
+		if (ccs_check_supervisor("#Need to create domain\n%s\n",
+					 new_domain_name))
+			goto done;
 	}
+	domain = ccs_find_or_assign_new_domain(new_domain_name,
+					       old_domain->profile);
+	if (domain)
+		audit_domain_creation_log(new_domain_name, mode,
+					  domain->profile);
+ done:
 	if (!domain) {
-		printk("TOMOYO-ERROR: Domain '%s' not defined.\n", new_domain_name);
-		if (is_enforce) retval = -EPERM;
+		printk(KERN_WARNING "TOMOYO-ERROR: Domain '%s' not defined.\n",
+		       new_domain_name);
+		if (is_enforce)
+			retval = -EPERM;
 	} else {
 		retval = 0;
 	}
- out: ;
+ out:
 	ccs_free(real_program_name);
 	ccs_free(symlink_program_name);
 	*next_domain = domain ? domain : old_domain;
 	return retval;
 }
 
-static int CheckEnviron(struct linux_binprm *bprm, struct ccs_page_buffer *tmp)
+/**
+ * check_environ -
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ * @tmp:  Buffer for temporal use.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int check_environ(struct linux_binprm *bprm, struct ccs_page_buffer *tmp)
 {
 	const u8 profile = current->domain_info->profile;
-	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_ENV);
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_ENV);
 	char *arg_ptr = tmp->buffer;
 	int arg_len = 0;
 	unsigned long pos = bprm->p;
 	int i = pos / PAGE_SIZE, offset = pos % PAGE_SIZE;
 	int argv_count = bprm->argc;
 	int envp_count = bprm->envc;
-	//printk("start %d %d\n", argv_count, envp_count);
+	/* printk(KERN_DEBUG "start %d %d\n", argv_count, envp_count); */
 	int error = -ENOMEM;
-	if (!mode || !envp_count) return 0;
+	if (!mode || !envp_count)
+		return 0;
 	while (error == -ENOMEM) {
 		struct page *page;
 		const char *kaddr;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
-		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0) goto out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
+		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page,
+				   NULL) <= 0)
+			goto out;
 		pos += PAGE_SIZE - offset;
 #else
 		page = bprm->page[i];
@@ -752,16 +1218,18 @@
 		/* Map. */
 		kaddr = kmap(page);
 		if (!kaddr) { /* Mapping failed. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 			put_page(page);
 #endif
 			goto out;
 		}
 		/* Read. */
 		while (argv_count && offset < PAGE_SIZE) {
-			if (!kaddr[offset++]) argv_count--;
+			if (!kaddr[offset++])
+				argv_count--;
 		}
-		if (argv_count) goto unmap_page;
+		if (argv_count)
+			goto unmap_page;
 		while (offset < PAGE_SIZE) {
 			const unsigned char c = kaddr[offset++];
 			if (c && arg_len < CCS_MAX_PATHNAME_LEN - 10) {
@@ -775,14 +1243,16 @@
 				} else {
 					arg_ptr[arg_len++] = '\\';
 					arg_ptr[arg_len++] = (c >> 6) + '0';
-					arg_ptr[arg_len++] = ((c >> 3) & 7) + '0';
+					arg_ptr[arg_len++]
+						= ((c >> 3) & 7) + '0';
 					arg_ptr[arg_len++] = (c & 7) + '0';
 				}
 			} else {
 				arg_ptr[arg_len] = '\0';
 			}
-			if (c) continue;
-			if (CheckEnvPerm(arg_ptr, profile, mode)) {
+			if (c)
+				continue;
+			if (ccs_check_env_perm(arg_ptr, profile, mode)) {
 				error = -EPERM;
 				break;
 			}
@@ -792,21 +1262,29 @@
 			}
 			arg_len = 0;
 		}
-	unmap_page:
+ unmap_page:
 		/* Unmap. */
 		kunmap(page);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 		put_page(page);
 #endif
 		i++;
 		offset = 0;
 	}
  out:
-	if (error && mode != 3) error = 0;
+	if (error && mode != 3)
+		error = 0;
 	return error;
 }
 
-static void UnEscape(unsigned char *dest)
+/**
+ * unescape -
+ *
+ * @dest: String to unescape.
+ *
+ * Returns nothing.
+ */
+static void unescape(unsigned char *dest)
 {
 	unsigned char *src = dest;
 	unsigned char c, d, e;
@@ -818,56 +1296,42 @@
 		c = *src++;
 		if (c == '\\') {
 			*dest++ = c;
-		} else if (c >= '0' && c <= '3' &&
-			   (d = *src++) >= '0' && d <= '7' &&
-			   (e = *src++) >= '0' && e <= '7') {
-			*dest++ = ((c - '0') << 6) | ((d - '0') << 3) | (e - '0');
-		} else {
+			continue;
+		}
+		if (c < '0' || c > '3')
 			break;
-		}
+		d = *src++;
+		if (d < '0' || d > '7')
+			break;
+		e = *src++;
+		if (e < '0' || e > '7')
+			break;
+		*dest++ = ((c - '0') << 6) + ((d - '0') << 3) + (e - '0');
 	}
 	*dest = '\0';
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-#include <linux/namei.h>
-#include <linux/mount.h>
-#endif
-
-/*
- * GetRootDepth - return the depth of root directory.
+/**
+ * root_depth -
+ *
+ * @dentry: Pointer to "struct dentry".
+ * @vfsmnt: Pointer to "struct vfsmount".
+ *
+ * Returns number of directories to strip.
  */
-static int GetRootDepth(void)
+static inline int root_depth(struct dentry *dentry, struct vfsmount *vfsmnt)
 {
 	int depth = 0;
-	struct dentry *dentry;
-	struct vfsmount *vfsmnt;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-	struct path root;
-#else
-	struct dentry *dentry0;
-	struct vfsmount *vfsmnt0;
-#endif
-	read_lock(&current->fs->lock);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-	root = current->fs->root;
-	path_get(&current->fs->root);
-	dentry = root.dentry;
-	vfsmnt = root.mnt;
-#else
-	dentry0 = dentry = dget(current->fs->root);
-	vfsmnt0 = vfsmnt = mntget(current->fs->rootmnt);
-#endif
-	read_unlock(&current->fs->lock);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&dcache_lock);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 	spin_lock(&vfsmount_lock);
 #endif
 	for (;;) {
 		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
 			/* Global root? */
-			if (vfsmnt->mnt_parent == vfsmnt) break;
+			if (vfsmnt->mnt_parent == vfsmnt)
+				break;
 			dentry = vfsmnt->mnt_mountpoint;
 			vfsmnt = vfsmnt->mnt_parent;
 			continue;
@@ -875,21 +1339,65 @@
 		dentry = dentry->d_parent;
 		depth++;
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 	spin_unlock(&vfsmount_lock);
 #endif
 	spin_unlock(&dcache_lock);
 	/***** CRITICAL SECTION END *****/
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+	return depth;
+}
+
+/**
+ * get_root_depth - return the depth of root directory.
+ *
+ * Returns number of directories to strip.
+ */
+static int get_root_depth(void)
+{
+	int depth;
+	struct dentry *dentry;
+	struct vfsmount *vfsmnt;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	struct path root;
+#endif
+	/***** CRITICAL SECTION START *****/
+	read_lock(&current->fs->lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	root = current->fs->root;
+	path_get(&current->fs->root);
+	dentry = root.dentry;
+	vfsmnt = root.mnt;
+#else
+	dentry = dget(current->fs->root);
+	vfsmnt = mntget(current->fs->rootmnt);
+#endif
+	read_unlock(&current->fs->lock);
+	/***** CRITICAL SECTION END *****/
+	depth = root_depth(dentry, vfsmnt);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 	path_put(&root);
 #else
-	dput(dentry0);
-	mntput(vfsmnt0);
+	dput(dentry);
+	mntput(vfsmnt);
 #endif
 	return depth;
 }
 
-static int try_alt_exec(struct linux_binprm *bprm, const struct path_info *filename, char **work, struct domain_info **next_domain, struct ccs_page_buffer *tmp)
+/**
+ * try_alt_exec -
+ *
+ * @bprm:        Pointer to "struct linux_binprm".
+ * @filename:    The name of requested program.
+ * @work:        Pointer to pointer to the name of execute handler.
+ * @next_domain: Pointer to pointer to "struct domain_info".
+ * @tmp:         Buffer for temporal use.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int try_alt_exec(struct linux_binprm *bprm,
+			const struct path_info *filename, char **work,
+			struct domain_info **next_domain,
+			struct ccs_page_buffer *tmp)
 {
 	/*
 	 * Contents of modified bprm.
@@ -936,9 +1444,11 @@
 	/* Allocate memory for execute handler's pathname. */
 	char *execute_handler = ccs_alloc(sizeof(struct ccs_page_buffer));
 	*work = execute_handler;
-	if (!execute_handler) return -ENOMEM;
-	strncpy(execute_handler, filename->name, sizeof(struct ccs_page_buffer) - 1);
-	UnEscape(execute_handler);
+	if (!execute_handler)
+		return -ENOMEM;
+	strncpy(execute_handler, filename->name,
+		sizeof(struct ccs_page_buffer) - 1);
+	unescape(execute_handler);
 
 	/* Close the requested program's dentry. */
 	allow_write_access(bprm->file);
@@ -946,12 +1456,14 @@
 	bprm->file = NULL;
 
 	{ /* Adjust root directory for open_exec(). */
-		int depth = GetRootDepth();
+		int depth = get_root_depth();
 		char *cp = execute_handler;
-		if (!*cp || *cp != '/') return -ENOENT;
+		if (!*cp || *cp != '/')
+			return -ENOENT;
 		while (depth) {
 			cp = strchr(cp + 1, '/');
-			if (!cp) return -ENOENT;
+			if (!cp)
+				return -ENOENT;
 			depth--;
 		}
 		memmove(execute_handler, cp, strlen(cp) + 1);
@@ -963,67 +1475,87 @@
 
 	/* Set argv[6] */
 	{
-		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "%d", original_envc);
+		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "%d",
+			 original_envc);
 		retval = copy_strings_kernel(1, &buffer, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
 	/* Set argv[5] */
 	{
-		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "%d", original_argc);
+		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "%d",
+			 original_argc);
 		retval = copy_strings_kernel(1, &buffer, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
 	/* Set argv[4] */
 	{
 		retval = copy_strings_kernel(1, &bprm->filename, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
 	/* Set argv[3] */
 	{
 		const u32 tomoyo_flags = task->tomoyo_flags;
-		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "pid=%d uid=%d gid=%d euid=%d egid=%d suid=%d sgid=%d fsuid=%d fsgid=%d state[0]=%u state[1]=%u state[2]=%u", task->pid, task->uid, task->gid, task->euid, task->egid, task->suid, task->sgid, task->fsuid, task->fsgid, (u8) (tomoyo_flags >> 24), (u8) (tomoyo_flags >> 16), (u8) (tomoyo_flags >> 8));
+		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1,
+			 "pid=%d uid=%d gid=%d euid=%d egid=%d suid=%d "
+			 "sgid=%d fsuid=%d fsgid=%d state[0]=%u "
+			 "state[1]=%u state[2]=%u",
+			 task->pid, task->uid, task->gid, task->euid,
+			 task->egid, task->suid, task->sgid, task->fsuid,
+			 task->fsgid, (u8) (tomoyo_flags >> 24),
+			 (u8) (tomoyo_flags >> 16), (u8) (tomoyo_flags >> 8));
 		retval = copy_strings_kernel(1, &buffer, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
 	/* Set argv[2] */
 	{
-		char *exe = (char *) GetEXE();
+		char *exe = (char *) ccs_get_exe();
 		if (exe) {
 			retval = copy_strings_kernel(1, &exe, bprm);
 			ccs_free(exe);
 		} else {
-			snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "<unknown>");
+			snprintf(buffer, sizeof(struct ccs_page_buffer) - 1,
+				 "<unknown>");
 			retval = copy_strings_kernel(1, &buffer, bprm);
 		}
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
 	/* Set argv[1] */
 	{
-		strncpy(buffer, task->domain_info->domainname->name, sizeof(struct ccs_page_buffer) - 1);
+		strncpy(buffer, task->domain_info->domainname->name,
+			sizeof(struct ccs_page_buffer) - 1);
 		retval = copy_strings_kernel(1, &buffer, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
 	/* Set argv[0] */
 	{
 		retval = copy_strings_kernel(1, &execute_handler, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
-#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,23) || LINUX_VERSION_CODE == KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
 	bprm->argv_len = bprm->exec - bprm->p;
 #endif
+#endif
 
 	/* OK, now restart the process with execute handler program's dentry. */
 	filp = open_exec(execute_handler);
@@ -1031,61 +1563,98 @@
 		retval = PTR_ERR(filp);
 		goto out;
 	}
-	bprm->file= filp;
+	bprm->file = filp;
 	bprm->filename = execute_handler;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 	bprm->interp = execute_handler;
 #endif
 	retval = prepare_binprm(bprm);
-	if (retval < 0) goto out;
+	if (retval < 0)
+		goto out;
 	task->tomoyo_flags |= CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
-	retval = FindNextDomain(bprm, next_domain, filename, tmp);
+	retval = find_next_domain(bprm, next_domain, filename, tmp);
 	task->tomoyo_flags &= ~CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
  out:
 	return retval;
 }
 
-static const struct path_info *FindExecuteHandler(bool is_preferred_handler)
+/**
+ * find_execute_handler -
+ *
+ * @type: Type of execute handler.
+ *
+ * Returns pointer to "struct path_info" if found, NULL otherwise.
+ */
+static const struct path_info *find_execute_handler(const u8 type)
 {
 	const struct domain_info *domain = current->domain_info;
 	struct acl_info *ptr;
-	const u8 type = is_preferred_handler ? TYPE_PREFERRED_EXECUTE_HANDLER : TYPE_DEFAULT_EXECUTE_HANDLER;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct execute_handler_record *acl;
-		if (ptr->type != type) continue;
+		if ((ptr->type & ~ACL_DELETED) != type)
+			continue;
 		acl = container_of(ptr, struct execute_handler_record, head);
 		return acl->handler;
 	}
 	return NULL;
 }
 
-int search_binary_handler_with_transition(struct linux_binprm *bprm, struct pt_regs *regs)
+/**
+ * search_binary_handler_with_transition -
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ * @regs: Pointer to "struct pt_regs".
+ *
+ * Returns result of search_binary_handler() on success,
+ * negative value otherwise.
+ */
+int search_binary_handler_with_transition(struct linux_binprm *bprm,
+					  struct pt_regs *regs)
 {
 	struct task_struct *task = current;
-	struct domain_info *next_domain = NULL, *prev_domain = task->domain_info;
+	struct domain_info *next_domain = NULL;
+	struct domain_info *prev_domain = task->domain_info;
 	const struct path_info *handler;
 	int retval;
-	char *work = NULL; /* Keep valid until search_binary_handler() finishes. */
+	/*
+	 * "work" holds path to program.
+	 * Thus, keep valid until search_binary_handler() finishes.
+	 */
+	char *work = NULL;
 	struct ccs_page_buffer *buf = ccs_alloc(sizeof(struct ccs_page_buffer));
-	CCS_LoadPolicy(bprm->filename);
-	if (!buf) return -ENOMEM;
-	//printk("rootdepth=%d\n", GetRootDepth());
-	handler = FindExecuteHandler(true);
+	ccs_load_policy(bprm->filename);
+	if (!buf)
+		return -ENOMEM;
+	/* printk(KERN_DEBUG "rootdepth=%d\n", get_root_depth()); */
+	handler = find_execute_handler(TYPE_PREFERRED_EXECUTE_HANDLER);
 	if (handler) {
 		retval = try_alt_exec(bprm, handler, &work, &next_domain, buf);
-	} else if ((retval = FindNextDomain(bprm, &next_domain, NULL, buf)) == -EPERM) {
-		handler = FindExecuteHandler(false);
-		if (handler) retval = try_alt_exec(bprm, handler, &work, &next_domain, buf);
+		if (!retval)
+			audit_execute_handler_log(true, work, bprm);
+		goto ok;
 	}
-	if (retval) goto out;
+	retval = find_next_domain(bprm, &next_domain, NULL, buf);
+	if (retval != -EPERM)
+		goto ok;
+	handler = find_execute_handler(TYPE_DEFAULT_EXECUTE_HANDLER);
+	if (handler) {
+		retval = try_alt_exec(bprm, handler, &work, &next_domain, buf);
+		if (!retval)
+			audit_execute_handler_log(false, work, bprm);
+	}
+ ok:
+	if (retval)
+		goto out;
 	task->domain_info = next_domain;
-	retval = CheckEnviron(bprm, buf);
-	if (retval) goto out;
+	retval = check_environ(bprm, buf);
+	if (retval)
+		goto out;
 	task->tomoyo_flags |= TOMOYO_CHECK_READ_FOR_OPEN_EXEC;
 	retval = search_binary_handler(bprm, regs);
 	task->tomoyo_flags &= ~TOMOYO_CHECK_READ_FOR_OPEN_EXEC;
  out:
-	if (retval < 0) task->domain_info = prev_domain;
+	if (retval < 0)
+		task->domain_info = prev_domain;
 	ccs_free(work);
 	ccs_free(buf);
 	return retval;
@@ -1093,14 +1662,21 @@
 
 #else
 
-int search_binary_handler_with_transition(struct linux_binprm *bprm, struct pt_regs *regs)
+/**
+ * search_binary_handler_with_transition -
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ * @regs: Pointer to "struct pt_regs".
+ *
+ * Returns the result of search_binary_handler().
+ */
+int search_binary_handler_with_transition(struct linux_binprm *bprm,
+					  struct pt_regs *regs)
 {
 #ifdef CONFIG_SAKURA
-	CCS_LoadPolicy(bprm->filename);
+	ccs_load_policy(bprm->filename);
 #endif
 	return search_binary_handler(bprm, regs);
 }
 
 #endif
-
-/***** TOMOYO Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/sakura_maymount.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_maymount.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/sakura_maymount.c	(working copy)
@@ -11,96 +11,136 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** SAKURA Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
 #include <linux/mount.h>
 #include <linux/mnt_namespace.h>
 #else
 #include <linux/namespace.h>
 #endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #endif
 
-/*************************  CONCEAL MOUNT PROTECTOR  *************************/
+/* Conceal mount protector. */
 
-int SAKURA_MayMount(struct nameidata *nd)
+/**
+ * check_conceal_mount - Check whether this mount request shadows existing
+ *                       mounts.
+ *
+ * @nd:     Pointer to "struct nameidata".
+ * @vfsmnt: Pointer to "struct vfsmount".
+ * @dentry: Pointer to "struct dentry".
+ *
+ * Returns true if @vfsmnt is parent directory compared to @nd, false otherwise.
+ */
+static bool check_conceal_mount(struct nameidata *nd, struct vfsmount *vfsmnt,
+				struct dentry *dentry)
 {
+	/***** CRITICAL SECTION START *****/
+	while (1) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+		if (nd->path.mnt->mnt_root == vfsmnt->mnt_root &&
+		    nd->path.dentry == dentry)
+			return true;
+#else
+		if (nd->mnt->mnt_root == vfsmnt->mnt_root &&
+		    nd->dentry == dentry)
+			return true;
+#endif
+		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
+			if (vfsmnt->mnt_parent == vfsmnt)
+				break;
+			dentry = vfsmnt->mnt_mountpoint;
+			vfsmnt = vfsmnt->mnt_parent;
+			continue;
+		}
+		dentry = dentry->d_parent;
+	}
+	return false;
+	/***** CRITICAL SECTION END *****/
+}
+
+/**
+ * print_error - Print error message.
+ *
+ * @nd:   Pointer to "struct nameidata".
+ * @mode: Access control mode.
+ *
+ * Returns 0 if @mode is not enforcing or permitted by the administrator's
+ * decision, negative value otherwise.
+ */
+static int print_error(struct nameidata *nd, const u8 mode)
+{
+	int error = -EPERM;
+	const bool is_enforce = (mode == 3);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	const char *dir = ccs_realpath_from_dentry(nd->path.dentry,
+						   nd->path.mnt);
+#else
+	const char *dir = ccs_realpath_from_dentry(nd->dentry, nd->mnt);
+#endif
+	const char *exename = ccs_get_exe();
+	printk(KERN_WARNING "SAKURA-%s: mount %s (pid=%d:exe=%s): "
+	       "Permission denied.\n", ccs_get_msg(is_enforce), dir,
+	       current->pid, exename);
+	if (is_enforce &&
+	    ccs_check_supervisor("# %s is requesting\n"
+				 "mount on %s\n", exename, dir) == 0)
+		error = 0;
+	ccs_free(exename);
+	ccs_free(dir);
+	if (!is_enforce)
+		error = 0;
+	return error;
+}
+
+/**
+ * ccs_may_mount - Check whether this mount request shadows existing mounts.
+ *
+ * @nd: Pointer to "struct nameidata".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_may_mount(struct nameidata *nd)
+{
+	struct list_head *p;
 	bool flag = false;
-	const u8 mode = CheckCCSFlags(CCS_SAKURA_DENY_CONCEAL_MOUNT);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+	const u8 mode = ccs_check_flags(CCS_SAKURA_DENY_CONCEAL_MOUNT);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 	struct namespace *namespace = current->namespace;
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
 	struct namespace *namespace = current->nsproxy->namespace;
 #else
 	struct mnt_namespace *namespace = current->nsproxy->mnt_ns;
 #endif
-	if (!mode) return 0;
-	if (namespace) {
-		struct list_head *p;
-		list_for_each(p, &namespace->list) {
-			struct vfsmount *vfsmnt = list_entry(p, struct vfsmount, mnt_list);
-			struct dentry *dentry = vfsmnt->mnt_root;
-			spin_lock(&dcache_lock);
-			if (IS_ROOT(dentry) || !d_unhashed(dentry)) {
-				while (1) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-					if (nd->path.mnt->mnt_root == vfsmnt->mnt_root && nd->path.dentry == dentry) {
-						flag = true;
-						break;
-					}
-#else
-					if (nd->mnt->mnt_root == vfsmnt->mnt_root && nd->dentry == dentry) {
-						flag = true;
-						break;
-					}
+	if (!mode)
+		return 0;
+	if (!namespace)
+		return 0;
+	list_for_each(p, &namespace->list) {
+		struct vfsmount *vfsmnt = list_entry(p, struct vfsmount,
+						     mnt_list);
+		struct dentry *dentry = vfsmnt->mnt_root;
+		/***** CRITICAL SECTION START *****/
+		spin_lock(&dcache_lock);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+		spin_lock(&vfsmount_lock);
 #endif
-					if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-						spin_lock(&vfsmount_lock);
+		if (IS_ROOT(dentry) || !d_unhashed(dentry))
+			flag = check_conceal_mount(nd, vfsmnt, dentry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+		spin_unlock(&vfsmount_lock);
 #endif
-						if (vfsmnt->mnt_parent == vfsmnt) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-							spin_unlock(&vfsmount_lock);
-#endif
-							break;
-						}
-						dentry = vfsmnt->mnt_mountpoint;
-						vfsmnt = vfsmnt->mnt_parent;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-						spin_unlock(&vfsmount_lock);
-#endif
-						continue;
-					}
-					dentry = dentry->d_parent;
-				}
-			}
-			spin_unlock(&dcache_lock);
-			if (flag) break;
-		}
+		spin_unlock(&dcache_lock);
+		/***** CRITICAL SECTION END *****/
+		if (flag)
+			break;
 	}
-	if (flag) {
-		int error = -EPERM;
-		const bool is_enforce = (mode == 3);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-		const char *dir = realpath_from_dentry(nd->path.dentry, nd->path.mnt);
-#else
-		const char *dir = realpath_from_dentry(nd->dentry, nd->mnt);
-#endif
-		if (dir) {
-			const char *exename = GetEXE();
-			printk("SAKURA-%s: mount %s (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), dir, current->pid, exename);
-			if (is_enforce && CheckSupervisor("# %s is requesting\nmount on %s\n", exename, dir) == 0) error = 0;
-			ccs_free(exename);
-		}
-		ccs_free(dir);
-		if (is_enforce) return error;
-	}
+	if (flag)
+		return print_error(nd, mode);
 	return 0;
 }
-
-/***** SAKURA Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/ccs_common.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/ccs_common.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/ccs_common.c	(working copy)
@@ -21,7 +21,7 @@
 #include <asm/uaccess.h>
 #include <stdarg.h>
 #include <linux/version.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #include <linux/mount.h>
 static const int lookup_flags = LOOKUP_FOLLOW;
@@ -32,42 +32,38 @@
 #include <linux/ccs_common.h>
 #include <linux/ccs_proc.h>
 #include <linux/tomoyo.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+
+/* To support PID namespace. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 #define find_task_by_pid find_task_by_vpid
 #endif
 
-#ifdef CONFIG_TOMOYO_MAX_ACCEPT_ENTRY
+/* Set default specified by the kernel config. */
 #define MAX_ACCEPT_ENTRY (CONFIG_TOMOYO_MAX_ACCEPT_ENTRY)
-#else
-#define MAX_ACCEPT_ENTRY 2048
-#endif
-#ifdef CONFIG_TOMOYO_MAX_GRANT_LOG
-#define MAX_GRANT_LOG (CONFIG_TOMOYO_MAX_GRANT_LOG)
-#else
-#define MAX_GRANT_LOG 1024
-#endif
-#ifdef CONFIG_TOMOYO_MAX_REJECT_LOG
-#define MAX_REJECT_LOG (CONFIG_TOMOYO_MAX_REJECT_LOG)
-#else
-#define MAX_REJECT_LOG 1024
-#endif
+#define MAX_GRANT_LOG    (CONFIG_TOMOYO_MAX_GRANT_LOG)
+#define MAX_REJECT_LOG   (CONFIG_TOMOYO_MAX_REJECT_LOG)
 
-/*************************  VARIABLES  *************************/
-
-/* /sbin/init started? */
+/* Has /sbin/init started? */
 bool sbin_init_started = false;
 
+/* Log level for SAKURA's printk(). */
 const char *ccs_log_level = KERN_DEBUG;
 
-static const char *mode_4[4] = { "disabled", "learning", "permissive", "enforcing" };
-static const char *mode_2[4] = { "disabled", "enabled", "enabled", "enabled" };
+/* String table for functionality that takes 4 modes. */
+static const char *mode_4[4] = {
+	"disabled", "learning", "permissive", "enforcing"
+};
+/* String table for functionality that takes 2 modes. */
+static const char *mode_2[4] = {
+	"disabled", "enabled", "enabled", "enabled"
+};
 
+/* Table for profile. */
 static struct {
 	const char *keyword;
 	unsigned int current_value;
 	const unsigned int max_value;
 } ccs_control_array[CCS_MAX_CONTROL_INDEX] = {
-	[CCS_PROFILE_COMMENT]            = { "COMMENT",             0, 0 }, /* Reserved for string. */
 	[CCS_TOMOYO_MAC_FOR_FILE]        = { "MAC_FOR_FILE",        0, 3 },
 	[CCS_TOMOYO_MAC_FOR_ARGV0]       = { "MAC_FOR_ARGV0",       0, 3 },
 	[CCS_TOMOYO_MAC_FOR_ENV]         = { "MAC_FOR_ENV",         0, 3 },
@@ -79,15 +75,20 @@
 	[CCS_SAKURA_RESTRICT_UNMOUNT]    = { "RESTRICT_UNMOUNT",    0, 3 },
 	[CCS_SAKURA_RESTRICT_PIVOT_ROOT] = { "RESTRICT_PIVOT_ROOT", 0, 3 },
 	[CCS_SAKURA_RESTRICT_AUTOBIND]   = { "RESTRICT_AUTOBIND",   0, 1 },
-	[CCS_TOMOYO_MAX_ACCEPT_ENTRY]    = { "MAX_ACCEPT_ENTRY",    MAX_ACCEPT_ENTRY, INT_MAX },
-	[CCS_TOMOYO_MAX_GRANT_LOG]       = { "MAX_GRANT_LOG",       MAX_GRANT_LOG, INT_MAX },
-	[CCS_TOMOYO_MAX_REJECT_LOG]      = { "MAX_REJECT_LOG",      MAX_REJECT_LOG, INT_MAX },
+	[CCS_TOMOYO_MAX_ACCEPT_ENTRY]
+	= { "MAX_ACCEPT_ENTRY",    MAX_ACCEPT_ENTRY, INT_MAX },
+	[CCS_TOMOYO_MAX_GRANT_LOG]
+	= { "MAX_GRANT_LOG",       MAX_GRANT_LOG, INT_MAX },
+	[CCS_TOMOYO_MAX_REJECT_LOG]
+	= { "MAX_REJECT_LOG",      MAX_REJECT_LOG, INT_MAX },
 	[CCS_TOMOYO_VERBOSE]             = { "TOMOYO_VERBOSE",      1, 1 },
 	[CCS_ALLOW_ENFORCE_GRACE]        = { "ALLOW_ENFORCE_GRACE", 0, 1 },
-	[CCS_SLEEP_PERIOD]               = { "SLEEP_PERIOD",        0, 3000 }, /* in 0.1 second */
+	[CCS_SLEEP_PERIOD]
+	= { "SLEEP_PERIOD",        0, 3000 }, /* in 0.1 second */
 };
 
 #ifdef CONFIG_TOMOYO
+/* Capability name used by domain policy. */
 const char *capability_control_keyword[TOMOYO_MAX_CAPABILITY_INDEX] = {
 	[TOMOYO_INET_STREAM_SOCKET_CREATE]  = "inet_tcp_create",
 	[TOMOYO_INET_STREAM_SOCKET_LISTEN]  = "inet_tcp_listen",
@@ -123,69 +124,178 @@
 };
 #endif
 
-struct profile {
+/* Profile table. Memory is allocated as needed. */
+static struct profile {
 	unsigned int value[CCS_MAX_CONTROL_INDEX];
 	const struct path_info *comment;
 #ifdef CONFIG_TOMOYO
 	unsigned char capability_value[TOMOYO_MAX_CAPABILITY_INDEX];
 #endif
-};
+} *profile_ptr[MAX_PROFILES];
 
-static struct profile *profile_ptr[MAX_PROFILES];
+/* Permit policy management by non-root user? */
 static bool manage_by_non_root = false;
 
-/*************************  UTILITY FUNCTIONS  *************************/
+/* Utility functions. */
 
 #ifdef CONFIG_TOMOYO
-static int __init TOMOYO_Quiet_Setup(char *str)
+/**
+ * tomoyo_quiet_setup - Set TOMOYO_VERBOSE=0 by default.
+ *
+ * @str: Unused.
+ *
+ * Returns 0.
+ */
+static int __init tomoyo_quiet_setup(char *str)
 {
 	ccs_control_array[CCS_TOMOYO_VERBOSE].current_value = 0;
 	return 0;
 }
 
-__setup("TOMOYO_QUIET", TOMOYO_Quiet_Setup);
+__setup("TOMOYO_QUIET", tomoyo_quiet_setup);
 #endif
 
-/*
- * Format string.
+/**
+ * is_byte_range - Check whether the string isa \ooo style octal value.
+ *
+ * @str: Pointer to the string.
+ *
+ * Returns true if @str is a \ooo style octal value, false otherwise.
+ */
+static bool is_byte_range(const char *str)
+{
+	return *str >= '0' && *str++ <= '3' &&
+		*str >= '0' && *str++ <= '7' &&
+		*str >= '0' && *str <= '7';
+}
+
+/**
+ * is_decimal - Check whether the character is a decimal character.
+ *
+ * @c: The character to check.
+ *
+ * Returns true if @c is a decimal character, false otherwise.
+ */
+static bool is_decimal(const char c)
+{
+	return (c >= '0' && c <= '9');
+}
+
+/**
+ * is_hexadecimal - Check whether the character is a hexadecimal character.
+ *
+ * @c: The character to check.
+ *
+ * Returns true if @c is a hexadecimal character, false otherwise.
+ */
+static bool is_hexadecimal(const char c)
+{
+	return ((c >= '0' && c <= '9') ||
+		(c >= 'A' && c <= 'F') ||
+		(c >= 'a' && c <= 'f'));
+}
+
+/**
+ * is_alphabet_char - Check whether the character is an alphabet.
+ *
+ * @c: The character to check.
+ *
+ * Returns true if @c is an alphabet character, false otherwise.
+ */
+static bool is_alphabet_char(const char c)
+{
+	return ((c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'));
+}
+
+/**
+ * str_starts - Check whether the given string starts with the given keyword.
+ *
+ * @src:  Pointer to pointer to the string.
+ * @find: Pointer to the keyword.
+ *
+ * Returns true if @src starts with @find, false otherwise.
+ *
+ * The @src is updated to point the first character after the @find
+ * if @src starts with @find .
+ */
+static bool str_starts(char **src, const char *find)
+{
+	const int len = strlen(find);
+	char *tmp = *src;
+	if (strncmp(tmp, find, len))
+		return false;
+	tmp += len;
+	*src = tmp;
+	return true;
+}
+
+/**
+ * normalize_line - Format string.
+ *
+ * @buffer: The line to normalize.
+ *
  * Leading and trailing whitespaces are removed.
  * Multiple whitespaces are packed into single space.
+ *
+ * Returns nothing.
  */
-static void NormalizeLine(unsigned char *buffer)
+static void normalize_line(unsigned char *buffer)
 {
 	unsigned char *sp = buffer, *dp = buffer;
 	bool first = true;
-	while (*sp && (*sp <= ' ' || *sp >= 127)) sp++;
+	while (*sp && (*sp <= ' ' || *sp >= 127))
+		sp++;
 	while (*sp) {
-		if (!first) *dp++ = ' ';
+		if (!first)
+			*dp++ = ' ';
 		first = false;
-		while (*sp > ' ' && *sp < 127) *dp++ = *sp++;
-		while (*sp && (*sp <= ' ' || *sp >= 127)) sp++;
+		while (*sp > ' ' && *sp < 127)
+			*dp++ = *sp++;
+		while (*sp && (*sp <= ' ' || *sp >= 127))
+			sp++;
 	}
 	*dp = '\0';
 }
 
-/*
- *  Check whether the given filename follows the naming rules.
- *  Returns true if follows, false otherwise.
+/**
+ *  ccs_is_correct_path - Check whether the given filename follows
+ *                        the naming rules.
+ *  @filename:     the pathname to check.
+ *  @start_type:   the pathname should start with '/'?
+ *                 1: must / -1:must not / 0:don't care
+ *  @pattern_type: the pathname may contain a wildcard?
+ *                 1: must / -1:must not / 0:don't care
+ *  @end_type:     the pathname should end with '/'?
+ *                 1: must / -1:must not / 0:don't care
+ *  @function:     the name of function calling me.
+ *
+ *  Returns true if @filename follows the naming rules, false otherwise.
  */
-bool IsCorrectPath(const char *filename, const s8 start_type, const s8 pattern_type, const s8 end_type, const char *function)
+bool ccs_is_correct_path(const char *filename, const s8 start_type,
+			 const s8 pattern_type, const s8 end_type,
+			 const char *function)
 {
 	bool contains_pattern = false;
-	char c, d, e;
+	unsigned char c, d, e;
 	const char *original_filename = filename;
-	if (!filename) goto out;
+	if (!filename)
+		goto out;
 	c = *filename;
 	if (start_type == 1) { /* Must start with '/' */
-		if (c != '/') goto out;
+		if (c != '/')
+			goto out;
 	} else if (start_type == -1) { /* Must not start with '/' */
-		if (c == '/') goto out;
+		if (c == '/')
+			goto out;
 	}
-	if (c) c = * (strchr(filename, '\0') - 1);
+	if (c)
+		c = *(strchr(filename, '\0') - 1);
 	if (end_type == 1) { /* Must end with '/' */
-		if (c != '/') goto out;
+		if (c != '/')
+			goto out;
 	} else if (end_type == -1) { /* Must not end with '/' */
-		if (c == '/') goto out;
+		if (c == '/')
+			goto out;
 	}
 	while ((c = *filename++) != '\0') {
 		if (c == '\\') {
@@ -202,20 +312,25 @@
 			case 'a':   /* "\a" */
 			case 'A':   /* "\A" */
 			case '-':   /* "\-" */
-				if (pattern_type == -1) break; /* Must not contain pattern */
+				if (pattern_type == -1)
+					break; /* Must not contain pattern */
 				contains_pattern = true;
 				continue;
 			case '0':   /* "\ooo" */
 			case '1':
 			case '2':
 			case '3':
-				if ((d = *filename++) >= '0' && d <= '7' && (e = *filename++) >= '0' && e <= '7') {
-					const unsigned char f =
-						(((unsigned char) (c - '0')) << 6) +
-						(((unsigned char) (d - '0')) << 3) +
-						(((unsigned char) (e - '0')));
-					if (f && (f <= ' ' || f >= 127)) continue; /* pattern is not \000 */
-				}
+				d = *filename++;
+				if (d < '0' || d > '7')
+					break;
+				e = *filename++;
+				if (e < '0' || e > '7')
+					break;
+				c = (((u8) (c - '0')) << 6)
+					+ (((u8) (d - '0')) << 3)
+					+ (((u8) (e - '0')));
+				if (c && (c <= ' ' || c >= 127))
+					continue; /* pattern is not \000 */
 			}
 			goto out;
 		} else if (c <= ' ' || c >= 127) {
@@ -223,45 +338,62 @@
 		}
 	}
 	if (pattern_type == 1) { /* Must contain pattern */
-		if (!contains_pattern) goto out;
+		if (!contains_pattern)
+			goto out;
 	}
 	return true;
  out:
-	printk(KERN_DEBUG "%s: Invalid pathname '%s'\n", function, original_filename);
+	printk(KERN_DEBUG "%s: Invalid pathname '%s'\n", function,
+	       original_filename);
 	return false;
 }
 
-/*
- *  Check whether the given domainname follows the naming rules.
- *  Returns true if follows, false otherwise.
+/**
+ *  ccs_is_correct_domain - Check whether the given domainname follows
+ *                          the naming rules.
+ *  @domainname:   the domainname to check.
+ *  @function:     the name of function calling me.
+ *
+ *  Returns true if @domainname follows the naming rules, false otherwise.
  */
-bool IsCorrectDomain(const unsigned char *domainname, const char *function)
+bool ccs_is_correct_domain(const unsigned char *domainname,
+			   const char *function)
 {
 	unsigned char c, d, e;
 	const char *org_domainname = domainname;
-	if (!domainname || strncmp(domainname, ROOT_NAME, ROOT_NAME_LEN)) goto out;
+	if (!domainname || strncmp(domainname, ROOT_NAME, ROOT_NAME_LEN))
+		goto out;
 	domainname += ROOT_NAME_LEN;
-	if (!*domainname) return true;
+	if (!*domainname)
+		return true;
 	do {
-		if (*domainname++ != ' ') goto out;
-		if (*domainname++ != '/') goto out;
+		if (*domainname++ != ' ')
+			goto out;
+		if (*domainname++ != '/')
+			goto out;
 		while ((c = *domainname) != '\0' && c != ' ') {
 			domainname++;
 			if (c == '\\') {
-				switch ((c = *domainname++)) {
+				c = *domainname++;
+				switch ((c)) {
 				case '\\':  /* "\\" */
 					continue;
 				case '0':   /* "\ooo" */
 				case '1':
 				case '2':
 				case '3':
-					if ((d = *domainname++) >= '0' && d <= '7' && (e = *domainname++) >= '0' && e <= '7') {
-						const unsigned char f =
-							(((unsigned char) (c - '0')) << 6) +
-							(((unsigned char) (d - '0')) << 3) +
-							(((unsigned char) (e - '0')));
-						if (f && (f <= ' ' || f >= 127)) continue; /* pattern is not \000 */
-					}
+					d = *domainname++;
+					if (d < '0' || d > '7')
+						break;
+					e = *domainname++;
+					if (e < '0' || e > '7')
+						break;
+					c = (((u8) (c - '0')) << 6)
+						+ (((u8) (d - '0')) << 3)
+						+ (((u8) (e - '0')));
+					if (c && (c <= ' ' || c >= 127))
+						/* pattern is not \000 */
+						continue;
 				}
 				goto out;
 			} else if (c < ' ' || c >= 127) {
@@ -271,64 +403,120 @@
 	} while (*domainname);
 	return true;
  out:
-	printk(KERN_DEBUG "%s: Invalid domainname '%s'\n", function, org_domainname);
+	printk(KERN_DEBUG "%s: Invalid domainname '%s'\n", function,
+	       org_domainname);
 	return false;
 }
 
-bool IsDomainDef(const unsigned char *buffer)
+/**
+ *  ccs_is_domain_def - Check whether the given token can be a domainname.
+ *
+ *  @buffer: The token to check.
+ *
+ *  Returns true if @buffer possibly be a domainname, false otherwise.
+ */
+bool ccs_is_domain_def(const unsigned char *buffer)
 {
-	/* while (*buffer && (*buffer <= ' ' || *buffer >= 127)) buffer++; */
-	return strncmp(buffer, ROOT_NAME, ROOT_NAME_LEN) == 0;
+	return !strncmp(buffer, ROOT_NAME, ROOT_NAME_LEN);
 }
 
-struct domain_info *FindDomain(const char *domainname0)
+/**
+ * ccs_find_domain - Find a domain by the given name.
+ *
+ * @domainname: the domainname to find.
+ *
+ * Returns pointer to "struct domain_info" if found, NULL otherwise.
+ */
+struct domain_info *ccs_find_domain(const char *domainname)
 {
 	struct domain_info *domain;
-	struct path_info domainname;
-	domainname.name = domainname0;
-	fill_path_info(&domainname);
+	struct path_info name;
+	name.name = domainname;
+	ccs_fill_path_info(&name);
 	list1_for_each_entry(domain, &domain_list, list) {
-		if (!domain->is_deleted && !pathcmp(&domainname, domain->domainname)) return domain;
+		if (!domain->is_deleted &&
+		    !ccs_pathcmp(&name, domain->domainname))
+			return domain;
 	}
 	return NULL;
 }
 
-static int PathDepth(const char *pathname)
+/**
+ * path_depth - Evaluate the number of '/' in a string.
+ *
+ * @pathname: The string to evaluate.
+ *
+ * Returns path depth of the string.
+ *
+ * I score 2 for each of the '/' in the @pathname
+ * and score 1 if the @pathname ends with '/'.
+ */
+static int path_depth(const char *pathname)
 {
 	int i = 0;
 	if (pathname) {
 		char *ep = strchr(pathname, '\0');
 		if (pathname < ep--) {
-			if (*ep != '/') i++;
-			while (pathname <= ep) if (*ep-- == '/') i += 2;
+			if (*ep != '/')
+				i++;
+			while (pathname <= ep)
+				if (*ep-- == '/')
+					i += 2;
 		}
 	}
 	return i;
 }
 
+/**
+ * const_part_length - Evaluate the initial length without a pattern
+ *                     in a token.
+ *
+ * @filename: The string to evaluate.
+ *
+ * Returns the initial length without a pattern in @filename .
+ */
 static int const_part_length(const char *filename)
 {
+	char c;
 	int len = 0;
-	if (filename) {
-		char c;
-		while ((c = *filename++) != '\0') {
-			if (c != '\\') { len++; continue; }
-			switch (c = *filename++) {
-			case '\\':  /* "\\" */
-				len += 2; continue;
-			case '0':   /* "\ooo" */
-			case '1':
-			case '2':
-			case '3':
-				if ((c = *filename++) >= '0' && c <= '7' && (c = *filename++) >= '0' && c <= '7') { len += 4; continue; }
-			}
-			break;
+	if (!filename)
+		return 0;
+	while ((c = *filename++) != '\0') {
+		if (c != '\\') {
+			len++;
+			continue;
 		}
+		c = *filename++;
+		switch (c) {
+		case '\\':  /* "\\" */
+			len += 2;
+			continue;
+		case '0':   /* "\ooo" */
+		case '1':
+		case '2':
+		case '3':
+			c = *filename++;
+			if (c < '0' || c > '7')
+				break;
+			c = *filename++;
+			if (c < '0' || c > '7')
+				break;
+			len += 4;
+			continue;
+		}
+		break;
 	}
 	return len;
 }
 
-void fill_path_info(struct path_info *ptr)
+/**
+ * ccs_fill_path_info - Fill in "struct path_info" members.
+ *
+ * @ptr: Pointer to "struct path_info" to fill in.
+ *
+ * The caller sets "struct path_info"->name.
+ */
+void ccs_fill_path_info(struct path_info *ptr)
 {
 	const char *name = ptr->name;
 	const int len = strlen(name);
@@ -337,118 +525,171 @@
 	ptr->is_dir = len && (name[len - 1] == '/');
 	ptr->is_patterned = (ptr->const_len < len);
 	ptr->hash = full_name_hash(name, len);
-	ptr->depth = PathDepth(name);
+	ptr->depth = path_depth(name);
 }
 
-static bool FileMatchesToPattern2(const char *filename, const char *filename_end, const char *pattern, const char *pattern_end)
+/**
+ * file_matches_to_pattern2 - Pattern matching without '/' character
+ * and "\-" pattern.
+ *
+ * @filename:     The start of string to check.
+ * @filename_end: The end of string to check.
+ * @pattern:      The start of pattern to compare.
+ * @pattern_end:  The end of pattern to compare.
+ *
+ * Returns true if @filename matches @pattern, false otherwise.
+ */
+static bool file_matches_to_pattern2(const char *filename,
+				     const char *filename_end,
+				     const char *pattern,
+				     const char *pattern_end)
 {
 	while (filename < filename_end && pattern < pattern_end) {
+		char c;
 		if (*pattern != '\\') {
-			if (*filename++ != *pattern++) return false;
-		} else {
-			char c = *filename;
-			pattern++;
-			switch (*pattern) {
-			case '?':
-				if (c == '/') {
+			if (*filename++ != *pattern++)
+				return false;
+			continue;
+		}
+		c = *filename;
+		pattern++;
+		switch (*pattern) {
+			int i, j;
+		case '?':
+			if (c == '/') {
+				return false;
+			} else if (c == '\\') {
+				if (filename[1] == '\\')
+					filename++;
+				else if (is_byte_range(filename + 1))
+					filename += 3;
+				else
 					return false;
-				} else if (c == '\\') {
-					if ((c = filename[1]) == '\\') {
-						filename++; /* safe because filename is \\ */
-					} else if (c >= '0' && c <= '3' && (c = filename[2]) >= '0' && c <= '7' && (c = filename[3]) >= '0' && c <= '7') {
-						filename += 3; /* safe because filename is \ooo */
-					} else {
-						return false;
-					}
-				}
+			}
+			break;
+		case '\\':
+			if (c != '\\')
+				return false;
+			if (*++filename != '\\')
+				return false;
+			break;
+		case '+':
+			if (!is_decimal(c))
+				return false;
+			break;
+		case 'x':
+			if (!is_hexadecimal(c))
+				return false;
+			break;
+		case 'a':
+			if (!is_alphabet_char(c))
+				return false;
+			break;
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+			if (c == '\\' && is_byte_range(filename + 1)
+			    && strncmp(filename + 1, pattern, 3) == 0) {
+				filename += 3;
+				pattern += 2;
 				break;
-			case '\\':
-				if (c != '\\') return false;
-				if (*++filename != '\\') return false; /* safe because *filename != '\0' */
-				break;
-			case '+':
-				if (c < '0' || c > '9') return false;
-				break;
-			case 'x':
-				if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) return false;
-				break;
-			case 'a':
-				if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))) return false;
-				break;
-			case '0':
-			case '1':
-			case '2':
-			case '3':
-				if (c == '\\' && (c = filename[1]) >= '0' && c <= '3' && c == *pattern
-					&& (c = filename[2]) >= '0' && c <= '7' && c == pattern[1]
-					&& (c = filename[3]) >= '0' && c <= '7' && c == pattern[2]) {
-					filename += 3; /* safe because filename is \ooo */
-					pattern += 2; /* safe because pattern is \ooo  */
+			}
+			return false; /* Not matched. */
+		case '*':
+		case '@':
+			for (i = 0; i <= filename_end - filename; i++) {
+				if (file_matches_to_pattern2(filename + i,
+							     filename_end,
+							     pattern + 1,
+							     pattern_end))
+					return true;
+				c = filename[i];
+				if (c == '.' && *pattern == '@')
 					break;
-				}
-				return false; /* Not matched. */
-			case '*':
-			case '@':
-				{
-					int i;
-					for (i = 0; i <= filename_end - filename; i++) {
-						if (FileMatchesToPattern2(filename + i, filename_end, pattern + 1, pattern_end)) return true;
-						if ((c = filename[i]) == '.' && *pattern == '@') break;
-						if (c == '\\') {
-							if ((c = filename[i + 1]) == '\\') {
-								i++; /* safe because filename is \\ */
-							} else if (c >= '0' && c <= '3' && (c = filename[i + 2]) >= '0' && c <= '7' && (c = filename[i + 3]) >= '0' && c <= '7') {
-								i += 3; /* safe because filename is \ooo */
-							} else {
-								break; /* Bad pattern. */
-							}
-						}
-					}
-					return false; /* Not matched. */
-				}
-			default:
-				{
-					int i, j = 0;
-					if ((c = *pattern) == '$') {
-						while ((c = filename[j]) >= '0' && c <= '9') j++;
-					} else if (c == 'X') {
-						while (((c = filename[j]) >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')) j++;
-					} else if (c == 'A') {
-						while (((c = filename[j]) >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) j++;
-					}
-					for (i = 1; i <= j; i++) {
-						if (FileMatchesToPattern2(filename + i, filename_end, pattern + 1, pattern_end)) return true;
-					}
-				}
-				return false; /* Not matched or bad pattern. */
+				if (c != '\\')
+					continue;
+				if (filename[i + 1] == '\\')
+					i++;
+				else if (is_byte_range(filename + i + 1))
+					i += 3;
+				else
+					break; /* Bad pattern. */
 			}
-			filename++; /* safe because *filename != '\0' */
-			pattern++; /* safe because *pattern != '\0' */
+			return false; /* Not matched. */
+		default:
+			j = 0;
+			c = *pattern;
+			if (c == '$') {
+				while (is_decimal(filename[j]))
+					j++;
+			} else if (c == 'X') {
+				while (is_hexadecimal(filename[j]))
+					j++;
+			} else if (c == 'A') {
+				while (is_alphabet_char(filename[j]))
+					j++;
+			}
+			for (i = 1; i <= j; i++) {
+				if (file_matches_to_pattern2(filename + i,
+							     filename_end,
+							     pattern + 1,
+							     pattern_end))
+					return true;
+			}
+			return false; /* Not matched or bad pattern. */
 		}
+		filename++;
+		pattern++;
 	}
-	while (*pattern == '\\' && (*(pattern + 1) == '*' || *(pattern + 1) == '@')) pattern += 2;
+	while (*pattern == '\\' &&
+	       (*(pattern + 1) == '*' || *(pattern + 1) == '@'))
+		pattern += 2;
 	return (filename == filename_end && pattern == pattern_end);
 }
 
-static bool FileMatchesToPattern(const char *filename, const char *filename_end, const char *pattern, const char *pattern_end)
+/**
+ * file_matches_to_pattern - Pattern matching without without '/' character.
+ *
+ * @filename:     The start of string to check.
+ * @filename_end: The end of string to check.
+ * @pattern:      The start of pattern to compare.
+ * @pattern_end:  The end of pattern to compare.
+ *
+ * Returns true if @filename matches @pattern, false otherwise.
+ */
+static bool file_matches_to_pattern(const char *filename,
+				    const char *filename_end,
+				    const char *pattern,
+				    const char *pattern_end)
 {
 	const char *pattern_start = pattern;
 	bool first = true;
 	bool result;
 	while (pattern < pattern_end - 1) {
-		if (*pattern++ != '\\' || *pattern++ != '-') continue;
-		result = FileMatchesToPattern2(filename, filename_end, pattern_start, pattern - 2);
-		if (first) result = !result;
-		if (result) return false;
+		/* Split at "\-" pattern. */
+		if (*pattern++ != '\\' || *pattern++ != '-')
+			continue;
+		result = file_matches_to_pattern2(filename, filename_end,
+						  pattern_start, pattern - 2);
+		if (first)
+			result = !result;
+		if (result)
+			return false;
 		first = false;
 		pattern_start = pattern;
 	}
-	result = FileMatchesToPattern2(filename, filename_end, pattern_start, pattern_end);
+	result = file_matches_to_pattern2(filename, filename_end,
+					  pattern_start, pattern_end);
 	return first ? result : !result;
 }
 
-/*
- *  Check whether the given pathname matches to the given pattern.
+/**
+ *  ccs_path_matches_pattern - Check whether the given filename matches
+ *                             the given pattern.
+ *  @filename: The filename to check.
+ *  @pattern:  The pattern to compare.
+ *
  *  Returns true if matches, false otherwise.
  *
  *  The following patterns are available.
@@ -465,60 +706,96 @@
  *    \a     1 alphabet character.
  *    \-     Subtraction operator.
  */
-
-bool PathMatchesToPattern(const struct path_info *pathname0, const struct path_info *pattern0)
+bool ccs_path_matches_pattern(const struct path_info *filename,
+			      const struct path_info *pattern)
 {
-	/* if (!pathname || !pattern) return false; */
-	const char *pathname = pathname0->name, *pattern = pattern0->name;
-	const int len = pattern0->const_len;
-	if (!pattern0->is_patterned) return !pathcmp(pathname0, pattern0);
-	if (pathname0->depth != pattern0->depth) return false;
-	if (strncmp(pathname, pattern, len)) return false;
-	pathname += len; pattern += len;
-	while (*pathname && *pattern) {
-		const char *pathname_delimiter = strchr(pathname, '/'), *pattern_delimiter = strchr(pattern, '/');
-		if (!pathname_delimiter) pathname_delimiter = strchr(pathname, '\0');
-		if (!pattern_delimiter) pattern_delimiter = strchr(pattern, '\0');
-		if (!FileMatchesToPattern(pathname, pathname_delimiter, pattern, pattern_delimiter)) return false;
-		pathname = *pathname_delimiter ? pathname_delimiter + 1 : pathname_delimiter;
-		pattern = *pattern_delimiter ? pattern_delimiter + 1 : pattern_delimiter;
+	/*
+	  if (!filename || !pattern)
+	  return false;
+	*/
+	const char *f = filename->name;
+	const char *p = pattern->name;
+	const int len = pattern->const_len;
+	/* If @pattern doesn't contain pattern, I can use strcmp(). */
+	if (!pattern->is_patterned)
+		return !ccs_pathcmp(filename, pattern);
+	/* Dont compare if the number of '/' differs. */
+	if (filename->depth != pattern->depth)
+		return false;
+	/* Compare the initial length without patterns. */
+	if (strncmp(f, p, len))
+		return false;
+	f += len;
+	p += len;
+	/* Main loop. Compare each directory component. */
+	while (*f && *p) {
+		const char *f_delimiter = strchr(f, '/');
+		const char *p_delimiter = strchr(p, '/');
+		if (!f_delimiter)
+			f_delimiter = strchr(f, '\0');
+		if (!p_delimiter)
+			p_delimiter = strchr(p, '\0');
+		if (!file_matches_to_pattern(f, f_delimiter, p, p_delimiter))
+			return false;
+		f = f_delimiter;
+		if (*f)
+			f++;
+		p = p_delimiter;
+		if (*p)
+			p++;
 	}
-	while (*pattern == '\\' && (*(pattern + 1) == '*' || *(pattern + 1) == '@')) pattern += 2;
-	return (!*pathname && !*pattern);
+	/* Ignore trailing "\*" and "\@" in @pattern. */
+	while (*p == '\\' &&
+	       (*(p + 1) == '*' || *(p + 1) == '@'))
+		p += 2;
+	return (!*f && !*p);
 }
 
-/*
- *  Transactional printf() to struct io_buffer structure.
- *  snprintf() will truncate, but io_printf() won't.
- *  Returns zero on success, nonzero otherwise.
+/**
+ *  ccs_io_printf - Transactional printf() to "struct ccs_io_buffer" structure.
+ *
+ *  @head: Pointer to "struct ccs_io_buffer".
+ *  @fmt:  The printf()'s format string, followed by parameters.
+ *
+ *  Returns true on success, false otherwise.
+ *
+ *  The snprintf() will truncate, but ccs_io_printf() won't.
  */
-int io_printf(struct io_buffer *head, const char *fmt, ...)
+bool ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
 {
 	va_list args;
 	int len, pos = head->read_avail, size = head->readbuf_size - pos;
-	if (size <= 0) return -ENOMEM;
+	if (size <= 0)
+		return false;
 	va_start(args, fmt);
 	len = vsnprintf(head->read_buf + pos, size, fmt, args);
 	va_end(args);
-	if (pos + len >= head->readbuf_size) return -ENOMEM;
+	if (pos + len >= head->readbuf_size)
+		return false;
 	head->read_avail += len;
-	return 0;
+	return true;
 }
 
-/*
- * Get realpath() of current process.
- * This function uses ccs_alloc(), so caller must ccs_free() if this function didn't return NULL.
+/**
+ * ccs_get_exe - Get ccs_realpath() of current process.
+ *
+ * Returns the ccs_realpath() of current process on success, NULL otherwise.
+ *
+ * This function uses ccs_alloc(), so the caller must ccs_free()
+ * if this function didn't return NULL.
  */
-const char *GetEXE(void)
+const char *ccs_get_exe(void)
 {
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
 	const char *cp = NULL;
-	if (!mm) return NULL;
+	if (!mm)
+		return NULL;
 	down_read(&mm->mmap_sem);
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
 		if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file) {
-			cp = realpath_from_dentry(vma->vm_file->f_dentry, vma->vm_file->f_vfsmnt);
+			cp = ccs_realpath_from_dentry(vma->vm_file->f_dentry,
+						      vma->vm_file->f_vfsmnt);
 			break;
 		}
 	}
@@ -526,51 +803,91 @@
 	return cp;
 }
 
-const char *GetMSG(const bool is_enforce)
+/**
+ * ccs_get_msg - Get warning message.
+ *
+ * @is_enforce: Is it enforcing mode?
+ *
+ * Returns "ERROR" or "WARNING".
+ */
+const char *ccs_get_msg(const bool is_enforce)
 {
-	if (is_enforce) return "ERROR"; else return "WARNING";
+	if (is_enforce)
+		return "ERROR";
+	else
+		return "WARNING";
 }
 
-/*************************  DOMAIN POLICY HANDLER  *************************/
-
-/* Check whether the given access control is enabled. */
-unsigned int CheckCCSFlags_NoSleepCheck(const u8 index)
+/**
+ * ccs_check_flags_no_sleep_check - Check mode for specified functionality.
+ *
+ * @index: The functionality to check mode.
+ *
+ * Returns the mode of specified functionality.
+ */
+unsigned int ccs_check_flags_no_sleep_check(const u8 index)
 {
 	const u8 profile = current->domain_info->profile;
 	return sbin_init_started && index < CCS_MAX_CONTROL_INDEX
 #if MAX_PROFILES != 256
 		&& profile < MAX_PROFILES
 #endif
-		&& profile_ptr[profile] ? profile_ptr[profile]->value[index] : 0;
+		&& profile_ptr[profile] ?
+		profile_ptr[profile]->value[index] : 0;
 }
 
+/**
+ * sleep_check - Check whether it is permitted to do operations that may sleep.
+ *
+ * Returns true if it is permitted to do operations that may sleep,
+ * false otherwise.
+ *
+ * TOMOYO Linux supports interactive enforcement that lets processes
+ * wait for the administrator's decision.
+ * All hooks but the one for ccs_may_autobind() are inserted where
+ * it is permitted to do operations that may sleep.
+ * Thus, this warning should not happen.
+ */
 static bool sleep_check(void)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if (unlikely(in_interrupt()))
+	static u8 count = 20;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (likely(!in_interrupt()))
+		return true;
 #else
-	if (unlikely(in_atomic()))
+	if (likely(!in_atomic()))
+		return true;
 #endif
-	{
-		static u8 count = 20;
-		if (count) {
-			count--;
-			printk(KERN_ERR "BUG: sleeping function called from invalid context.\n");
-			dump_stack();
-		}
-		return false;
+	if (count) {
+		count--;
+		printk(KERN_ERR "BUG: sleeping function called "
+		       "from invalid context.\n");
+		dump_stack();
 	}
-	return true;
+	return false;
 }
 
-unsigned int CheckCCSFlags(const u8 index)
+/**
+ * ccs_check_flags - Check mode for specified functionality.
+ *
+ * @index: The functionality to check mode.
+ *
+ * Returns the mode of specified functionality.
+ */
+unsigned int ccs_check_flags(const u8 index)
 {
-	return sleep_check() ? CheckCCSFlags_NoSleepCheck(index) : 0;
+	return sleep_check() ? ccs_check_flags_no_sleep_check(index) : 0;
 }
 
 #ifdef CONFIG_TOMOYO
-/* Check whether the given capability control is enabled. */
-u8 CheckCapabilityFlags(const u8 index)
+/**
+ * ccs_check_capability_flags - Check mode for specified capability.
+ *
+ * @index: The capability to check mode.
+ *
+ * Returns the mode of specified capability.
+ */
+u8 ccs_check_capability_flags(const u8 index)
 {
 	const u8 profile = current->domain_info->profile;
 	return sbin_init_started && index < TOMOYO_MAX_CAPABILITY_INDEX
@@ -578,56 +895,108 @@
 		&& profile < MAX_PROFILES
 #endif
 		&& sleep_check()
-		&& profile_ptr[profile] ? profile_ptr[profile]->capability_value[index] : 0;
+		&& profile_ptr[profile] ?
+		profile_ptr[profile]->capability_value[index] : 0;
 }
 
-const char *cap_operation2keyword(const u8 operation)
+/**
+ * ccs_cap2keyword - Convert capability operation to capability name.
+ *
+ * @operation: The capability index.
+ *
+ * Returns the name of the specified capability's name.
+ */
+const char *ccs_cap2keyword(const u8 operation)
 {
-	return operation < TOMOYO_MAX_CAPABILITY_INDEX ? capability_control_keyword[operation] : NULL;
+	return operation < TOMOYO_MAX_CAPABILITY_INDEX
+		? capability_control_keyword[operation] : NULL;
 }
 
 #endif
 
-bool TomoyoVerboseMode(void)
+/**
+ *  ccs_verbose_mode - Check whether TOMOYO is verbose mode.
+ *
+ *  Returns true if domain policy violation warning should be printed to
+ *  console.
+ */
+bool ccs_verbose_mode(void)
 {
-	return CheckCCSFlags(CCS_TOMOYO_VERBOSE) != 0;
+	return ccs_check_flags(CCS_TOMOYO_VERBOSE) != 0;
 }
 
-bool CheckDomainQuota(struct domain_info * const domain)
+/**
+ * ccs_check_domain_quota - Check for domain's quota.
+ *
+ * @domain: Pointer to "struct domain_info".
+ *
+ * Returns true if the domain is not exceeded quota, false otherwise.
+ */
+bool ccs_check_domain_quota(struct domain_info * const domain)
 {
 	unsigned int count = 0;
 	struct acl_info *ptr;
-	if (!domain) return true;
+	if (!domain)
+		return true;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-		if (!(ptr->type & ACL_DELETED)) count++;
+		if (!(ptr->type & ACL_DELETED))
+			count++;
 	}
-	if (count < CheckCCSFlags(CCS_TOMOYO_MAX_ACCEPT_ENTRY)) return true;
+	if (count < ccs_check_flags(CCS_TOMOYO_MAX_ACCEPT_ENTRY))
+		return true;
 	if (!domain->quota_warned) {
 		domain->quota_warned = true;
-		printk("TOMOYO-WARNING: Domain '%s' has so many ACLs to hold. Stopped learning mode.\n", domain->domainname->name);
+		printk(KERN_WARNING "TOMOYO-WARNING: "
+		       "Domain '%s' has so many ACLs to hold. "
+		       "Stopped learning mode.\n", domain->domainname->name);
 	}
 	return false;
 }
 
-static struct profile *FindOrAssignNewProfile(const unsigned int profile)
+/**
+ * ccs_find_or_assign_new_profile - Create a new profile.
+ *
+ * @profile: Profile number to create.
+ *
+ * Returns pointer to "struct profile" on success, NULL otherwise.
+ */
+static struct profile *ccs_find_or_assign_new_profile(const unsigned int
+						      profile)
 {
 	static DEFINE_MUTEX(profile_lock);
 	struct profile *ptr = NULL;
 	mutex_lock(&profile_lock);
-	if (profile < MAX_PROFILES && (ptr = profile_ptr[profile]) == NULL) {
-		if ((ptr = alloc_element(sizeof(*ptr))) != NULL) {
+	if (profile < MAX_PROFILES) {
+		ptr = profile_ptr[profile];
+		if (ptr)
+			goto ok;
+		ptr = ccs_alloc_element(sizeof(*ptr));
+		if (ptr) {
 			int i;
-			for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++) ptr->value[i] = ccs_control_array[i].current_value;
-			/* Needn't to initialize "ptr->capability_value" because they are always 0. */
+			for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++)
+				ptr->value[i]
+					= ccs_control_array[i].current_value;
+			/*
+			 * Needn't to initialize "ptr->capability_value"
+			 * because they are always 0.
+			 */
 			mb(); /* Avoid out-of-order execution. */
 			profile_ptr[profile] = ptr;
 		}
 	}
+ ok:
 	mutex_unlock(&profile_lock);
 	return ptr;
 }
 
-static int SetProfile(struct io_buffer *head)
+/**
+ * write_profile - Write profile table.
+ *
+ * @head: Pointer to "struct ccs_io_buffer"
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int write_profile(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
 	unsigned int i, value;
@@ -635,33 +1004,39 @@
 	struct profile *profile;
 	i = simple_strtoul(data, &cp, 10);
 	if (data != cp) {
-		if (*cp != '-') return -EINVAL;
-		data= cp + 1;
+		if (*cp != '-')
+			return -EINVAL;
+		data = cp + 1;
 	}
-	profile = FindOrAssignNewProfile(i);
-	if (!profile) return -EINVAL;
+	profile = ccs_find_or_assign_new_profile(i);
+	if (!profile)
+		return -EINVAL;
 	cp = strchr(data, '=');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp = '\0';
-	UpdateCounter(CCS_UPDATES_COUNTER_PROFILE);
-	if (strcmp(data, ccs_control_array[CCS_PROFILE_COMMENT].keyword) == 0) {
-		profile->comment = SaveName(cp + 1);
+	ccs_update_counter(CCS_UPDATES_COUNTER_PROFILE);
+	if (!strcmp(data, "COMMENT")) {
+		profile->comment = ccs_save_name(cp + 1);
 		return 0;
 	}
 #ifdef CONFIG_TOMOYO
-	if (strncmp(data, KEYWORD_MAC_FOR_CAPABILITY, KEYWORD_MAC_FOR_CAPABILITY_LEN) == 0) {
+	if (str_starts(&data, KEYWORD_MAC_FOR_CAPABILITY)) {
 		if (sscanf(cp + 1, "%u", &value) != 1) {
 			for (i = 0; i < 4; i++) {
-				if (strcmp(cp + 1, mode_4[i])) continue;
+				if (strcmp(cp + 1, mode_4[i]))
+					continue;
 				value = i;
 				break;
 			}
-			if (i == 4) return -EINVAL;
+			if (i == 4)
+				return -EINVAL;
 		}
-		if (value > 3) value = 3;
-		data += KEYWORD_MAC_FOR_CAPABILITY_LEN;
+		if (value > 3)
+			value = 3;
 		for (i = 0; i < TOMOYO_MAX_CAPABILITY_INDEX; i++) {
-			if (strcmp(data, capability_control_keyword[i])) continue;
+			if (strcmp(data, capability_control_keyword[i]))
+				continue;
 			profile->capability_value[i] = value;
 			return 0;
 		}
@@ -669,7 +1044,8 @@
 	}
 #endif
 	for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++) {
-		if (strcmp(data, ccs_control_array[i].keyword)) continue;
+		if (strcmp(data, ccs_control_array[i].keyword))
+			continue;
 		if (sscanf(cp + 1, "%u", &value) != 1) {
 			int j;
 			const char **modes;
@@ -684,18 +1060,21 @@
 				break;
 			}
 			for (j = 0; j < 4; j++) {
-				if (strcmp(cp + 1, modes[j])) continue;
+				if (strcmp(cp + 1, modes[j]))
+					continue;
 				value = j;
 				break;
 			}
-			if (j == 4) return -EINVAL;
+			if (j == 4)
+				return -EINVAL;
 		} else if (value > ccs_control_array[i].max_value) {
 			value = ccs_control_array[i].max_value;
 		}
 		switch (i) {
 		case CCS_SAKURA_DENY_CONCEAL_MOUNT:
 		case CCS_SAKURA_RESTRICT_UNMOUNT:
-			if (value == 1) value = 2; /* learning mode is not supported. */
+			if (value == 1)
+				value = 2; /* learning mode is not supported. */
 		}
 		profile->value[i] = value;
 		return 0;
@@ -703,17 +1082,29 @@
 	return -EINVAL;
 }
 
-static int ReadProfile(struct io_buffer *head)
+/**
+ * read_profile - Read profile table.
+ *
+ * @head: Pointer to "struct ccs_io_buffer"
+ *
+ * Returns 0.
+ */
+static int read_profile(struct ccs_io_buffer *head)
 {
+	static const int total
+		= CCS_MAX_CONTROL_INDEX + TOMOYO_MAX_CAPABILITY_INDEX + 1;
 	int step;
-	if (head->read_eof) return 0;
-	for (step = head->read_step; step < MAX_PROFILES * (CCS_MAX_CONTROL_INDEX + TOMOYO_MAX_CAPABILITY_INDEX); step++) {
-		const int i = step / (CCS_MAX_CONTROL_INDEX + TOMOYO_MAX_CAPABILITY_INDEX), j = step % (CCS_MAX_CONTROL_INDEX + TOMOYO_MAX_CAPABILITY_INDEX);
-		const struct profile *profile = profile_ptr[i];
+	if (head->read_eof)
+		return 0;
+	for (step = head->read_step; step < MAX_PROFILES * total; step++) {
+		const u8 index = step / total;
+		u8 type = step % total;
+		const struct profile *profile = profile_ptr[index];
 		head->read_step = step;
-		if (!profile) continue;
-		switch (j) {
-		case -1: /* Dummy */
+		if (!profile)
+			continue;
+#if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
+		switch (type) {
 #ifndef CONFIG_SAKURA
 		case CCS_SAKURA_DENY_CONCEAL_MOUNT:
 		case CCS_SAKURA_RESTRICT_CHROOT:
@@ -735,17 +1126,31 @@
 #endif
 			continue;
 		}
-		if (j == CCS_PROFILE_COMMENT) {
-			if (io_printf(head, "%u-%s=%s\n", i, ccs_control_array[CCS_PROFILE_COMMENT].keyword, profile->comment ? profile->comment->name : "")) break;
-		} else if (j >= CCS_MAX_CONTROL_INDEX) {
+#endif
+		if (!type) { /* Print profile' comment tag. */
+			if (!ccs_io_printf(head, "%u-COMMENT=%s\n",
+					   index, profile->comment ?
+					   profile->comment->name : ""))
+				break;
+			continue;
+		}
+		type--;
+		if (type >= CCS_MAX_CONTROL_INDEX) {
 #ifdef CONFIG_TOMOYO
-			const int k = j - CCS_MAX_CONTROL_INDEX;
-			if (io_printf(head, "%u-" KEYWORD_MAC_FOR_CAPABILITY "%s=%s\n", i, capability_control_keyword[k], mode_4[profile->capability_value[k]])) break;
+			const int i = type - CCS_MAX_CONTROL_INDEX;
+			const u8 value = profile->capability_value[i];
+			if (!ccs_io_printf(head,
+					   "%u-" KEYWORD_MAC_FOR_CAPABILITY
+					   "%s=%s\n", index,
+					   capability_control_keyword[i],
+					   mode_4[value]))
+				break;
 #endif
 		} else {
-			const unsigned int value = profile->value[j];
+			const unsigned int value = profile->value[type];
 			const char **modes = NULL;
-			switch (ccs_control_array[j].max_value) {
+			const char *keyword = ccs_control_array[type].keyword;
+			switch (ccs_control_array[type].max_value) {
 			case 3:
 				modes = mode_4;
 				break;
@@ -754,41 +1159,61 @@
 				break;
 			}
 			if (modes) {
-				if (io_printf(head, "%u-%s=%s\n", i, ccs_control_array[j].keyword, modes[value])) break;
+				if (!ccs_io_printf(head, "%u-%s=%s\n", index,
+						   keyword, modes[value]))
+					break;
 			} else {
-				if (io_printf(head, "%u-%s=%u\n", i, ccs_control_array[j].keyword, value)) break;
+				if (!ccs_io_printf(head, "%u-%s=%u\n", index,
+						   keyword, value))
+					break;
 			}
 		}
 	}
-	if (step == MAX_PROFILES * (CCS_MAX_CONTROL_INDEX + TOMOYO_MAX_CAPABILITY_INDEX)) head->read_eof = true;
+	if (step == MAX_PROFILES * total)
+		head->read_eof = true;
 	return 0;
 }
 
-/*************************  POLICY MANAGER HANDLER  *************************/
+/* Policy manager handler. */
 
+/* The structure for policy manager. */
 struct policy_manager_entry {
 	struct list1_head list;
+	/* A path to program or a domainname. */
 	const struct path_info *manager;
-	bool is_domain;
-	bool is_deleted;
+	bool is_domain;  /* True if manager is a domainname. */
+	bool is_deleted; /* True if this entry is deleted. */
 };
 
+/* The list for "struct policy_manager_entry". */
 static LIST1_HEAD(policy_manager_list);
 
-static int AddManagerEntry(const char *manager, const bool is_delete)
+/**
+ * update_manager_entry - Add a manager entry.
+ *
+ * @manager:   The path to manager or the domainnamme.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_manager_entry(const char *manager, const bool is_delete)
 {
 	struct policy_manager_entry *new_entry, *ptr;
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_manager;
 	int error = -ENOMEM;
 	bool is_domain = false;
-	if (IsDomainDef(manager)) {
-		if (!IsCorrectDomain(manager, __FUNCTION__)) return -EINVAL;
+	if (ccs_is_domain_def(manager)) {
+		if (!ccs_is_correct_domain(manager, __func__))
+			return -EINVAL;
 		is_domain = true;
 	} else {
-		if (!IsCorrectPath(manager, 1, -1, -1, __FUNCTION__)) return -EINVAL;
+		if (!ccs_is_correct_path(manager, 1, -1, -1, __func__))
+			return -EINVAL;
 	}
-	if ((saved_manager = SaveName(manager)) == NULL) return -ENOMEM;
+	saved_manager = ccs_save_name(manager);
+	if (!saved_manager)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &policy_manager_list, list) {
 		if (ptr->manager == saved_manager) {
@@ -801,71 +1226,100 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->manager = saved_manager;
 	new_entry->is_domain = is_domain;
 	list1_add_tail_mb(&new_entry->list, &policy_manager_list);
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	if (!error) UpdateCounter(CCS_UPDATES_COUNTER_MANAGER);
+	if (!error)
+		ccs_update_counter(CCS_UPDATES_COUNTER_MANAGER);
 	return error;
 }
 
-static int AddManagerPolicy(struct io_buffer *head)
+/**
+ * write_manager_policy - Write manager policy.
+ *
+ * @head: Pointer to "struct ccs_io_buffer"
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int write_manager_policy(struct ccs_io_buffer *head)
 {
-	const char *data = head->write_buf;
-	bool is_delete = false;
-	if (strncmp(data, KEYWORD_DELETE, KEYWORD_DELETE_LEN) == 0) {
-		data += KEYWORD_DELETE_LEN;
-		is_delete = true;
-	}
+	char *data = head->write_buf;
+	bool is_delete = str_starts(&data, KEYWORD_DELETE);
 	if (strcmp(data, "manage_by_non_root") == 0) {
 		manage_by_non_root = !is_delete;
 		return 0;
 	}
-	return AddManagerEntry(data, is_delete);
+	return update_manager_entry(data, is_delete);
 }
 
-static int ReadManagerPolicy(struct io_buffer *head)
+/**
+ * read_manager_policy - Read manager policy.
+ *
+ * @head: Pointer to "struct ccs_io_buffer"
+ *
+ * Returns 0.
+ */
+static int read_manager_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
-	if (head->read_eof) return 0;
+	if (head->read_eof)
+		return 0;
 	list1_for_each_cookie(pos, head->read_var2, &policy_manager_list) {
 		struct policy_manager_entry *ptr;
 		ptr = list1_entry(pos, struct policy_manager_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, "%s\n", ptr->manager->name)) return 0;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, "%s\n", ptr->manager->name))
+			return 0;
 	}
 	head->read_eof = true;
 	return 0;
 }
 
-/* Check whether the current process is a policy manager. */
-static bool IsPolicyManager(void)
+/**
+ * is_policy_manager - Check whether the current process is a policy manager.
+ *
+ * Returns true if the current process is permitted to modify policy
+ * via /proc/ccs/ interface.
+ */
+static bool is_policy_manager(void)
 {
 	struct policy_manager_entry *ptr;
 	const char *exe;
 	const struct task_struct *task = current;
 	const struct path_info *domainname = task->domain_info->domainname;
 	bool found = false;
-	if (!sbin_init_started) return true;
-	if (!manage_by_non_root && (task->uid || task->euid)) return false;
+	if (!sbin_init_started)
+		return true;
+	if (!manage_by_non_root && (task->uid || task->euid))
+		return false;
 	list1_for_each_entry(ptr, &policy_manager_list, list) {
-		if (!ptr->is_deleted && ptr->is_domain && !pathcmp(domainname, ptr->manager)) return true;
+		if (!ptr->is_deleted && ptr->is_domain
+		    && !ccs_pathcmp(domainname, ptr->manager))
+			return true;
 	}
-	if ((exe = GetEXE()) == NULL) return false;
+	exe = ccs_get_exe();
+	if (!exe)
+		return false;
 	list1_for_each_entry(ptr, &policy_manager_list, list) {
-		if (!ptr->is_deleted && !ptr->is_domain && !strcmp(exe, ptr->manager->name)) {
+		if (!ptr->is_deleted && !ptr->is_domain
+		    && !strcmp(exe, ptr->manager->name)) {
 			found = true;
 			break;
 		}
 	}
 	if (!found) { /* Reduce error messages. */
-		static pid_t last_pid = 0;
+		static pid_t last_pid;
 		const pid_t pid = current->pid;
 		if (last_pid != pid) {
-			printk("%s ( %s ) is not permitted to update policies.\n", domainname->name, exe);
+			printk(KERN_WARNING "%s ( %s ) is not permitted to "
+			       "update policies.\n", domainname->name, exe);
 			last_pid = pid;
 		}
 	}
@@ -875,21 +1329,38 @@
 
 #ifdef CONFIG_TOMOYO
 
-/*************************  DOMAIN POLICY HANDLER  *************************/
+/* Domain policy handler. */
 
-static char *FindConditionPart(char *data)
+/**
+ * ccs_find_condition_part - Find condition part from the statement.
+ *
+ * @data: String to parse.
+ *
+ * Returns pointer to the condition part if it was found in the statement,
+ * NULL otherwise.
+ */
+static char *ccs_find_condition_part(char *data)
 {
 	char *cp = strstr(data, " if "), *cp2;
 	if (cp) {
 		while ((cp2 = strstr(cp + 3, " if ")) != NULL) cp = cp2;
 		*cp++ = '\0';
-	} else if ((cp = strstr(data, " ; set ")) != NULL) {
-		*cp++ = '\0';
+	} else {
+		cp = strstr(data, " ; set ");
+		if (cp)
+			*cp++ = '\0';
 	}
 	return cp;
 }
 
-static int AddDomainPolicy(struct io_buffer *head)
+/**
+ * write_domain_policy - Write domain policy.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int write_domain_policy(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
 	struct domain_info *domain = head->write_var1;
@@ -897,79 +1368,105 @@
 	unsigned int profile;
 	const struct condition_list *cond = NULL;
 	char *cp;
-	if (strncmp(data, KEYWORD_DELETE, KEYWORD_DELETE_LEN) == 0) {
-		data += KEYWORD_DELETE_LEN;
+	if (str_starts(&data, KEYWORD_DELETE))
 		is_delete = true;
-	} else if (strncmp(data, KEYWORD_SELECT, KEYWORD_SELECT_LEN) == 0) {
-		data += KEYWORD_SELECT_LEN;
+	else if (str_starts(&data, KEYWORD_SELECT))
 		is_select = true;
-	} else if (strncmp(data, KEYWORD_UNDELETE, KEYWORD_UNDELETE_LEN) == 0) {
-		data += KEYWORD_UNDELETE_LEN;
+	else if (str_starts(&data, KEYWORD_UNDELETE))
 		is_undelete = true;
-	}
-	if (IsDomainDef(data)) {
+	if (ccs_is_domain_def(data)) {
 		if (is_delete) {
-			DeleteDomain(data);
+			ccs_delete_domain(data);
 			domain = NULL;
 		} else if (is_select) {
-			domain = FindDomain(data);
+			domain = ccs_find_domain(data);
 		} else if (is_undelete) {
-			domain = UndeleteDomain(data);
+			domain = ccs_undelete_domain(data);
 		} else {
-			domain = FindOrAssignNewDomain(data, 0);
+			domain = ccs_find_or_assign_new_domain(data, 0);
 		}
 		head->write_var1 = domain;
-		UpdateCounter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
+		ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 		return 0;
 	}
-	if (!domain) return -EINVAL;
+	if (!domain)
+		return -EINVAL;
 
-	if (sscanf(data, KEYWORD_USE_PROFILE "%u", &profile) == 1 && profile < MAX_PROFILES) {
-		if (profile_ptr[profile] || !sbin_init_started) domain->profile = (u8) profile;
+	if (sscanf(data, KEYWORD_USE_PROFILE "%u", &profile) == 1
+	    && profile < MAX_PROFILES) {
+		if (profile_ptr[profile] || !sbin_init_started)
+			domain->profile = (u8) profile;
 		return 0;
 	}
-	if (strcmp(data, KEYWORD_IGNORE_GLOBAL_ALLOW_READ) == 0) {
-		SetDomainFlag(domain, is_delete, DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ);
+	if (!strcmp(data, KEYWORD_IGNORE_GLOBAL_ALLOW_READ)) {
+		ccs_set_domain_flag(domain, is_delete,
+				    DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ);
 		return 0;
 	}
-	if (strcmp(data, KEYWORD_IGNORE_GLOBAL_ALLOW_ENV) == 0) {
-		SetDomainFlag(domain, is_delete, DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV);
+	if (!strcmp(data, KEYWORD_IGNORE_GLOBAL_ALLOW_ENV)) {
+		ccs_set_domain_flag(domain, is_delete,
+				    DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV);
 		return 0;
 	}
-	cp = FindConditionPart(data);
-	if (cp && (cond = FindOrAssignNewCondition(cp)) == NULL) return -EINVAL;
-	if (strncmp(data, KEYWORD_ALLOW_CAPABILITY, KEYWORD_ALLOW_CAPABILITY_LEN) == 0) {
-		return AddCapabilityPolicy(data + KEYWORD_ALLOW_CAPABILITY_LEN, domain, cond, is_delete);
-	} else if (strncmp(data, KEYWORD_ALLOW_NETWORK, KEYWORD_ALLOW_NETWORK_LEN) == 0) {
-		return AddNetworkPolicy(data + KEYWORD_ALLOW_NETWORK_LEN, domain, cond, is_delete);
-	} else if (strncmp(data, KEYWORD_ALLOW_SIGNAL, KEYWORD_ALLOW_SIGNAL_LEN) == 0) {
-		return AddSignalPolicy(data + KEYWORD_ALLOW_SIGNAL_LEN, domain, cond, is_delete);
-	} else if (strncmp(data, KEYWORD_ALLOW_ARGV0, KEYWORD_ALLOW_ARGV0_LEN) == 0) {
-		return AddArgv0Policy(data + KEYWORD_ALLOW_ARGV0_LEN, domain, cond, is_delete);
-	} else if (strncmp(data, KEYWORD_ALLOW_ENV, KEYWORD_ALLOW_ENV_LEN) == 0) {
-		return AddEnvPolicy(data + KEYWORD_ALLOW_ENV_LEN, domain, cond, is_delete);
-	} else {
-		return AddFilePolicy(data, domain, cond, is_delete);
+	cp = ccs_find_condition_part(data);
+	if (cp) {
+		cond = ccs_find_or_assign_new_condition(cp);
+		if (!cond)
+			return -EINVAL;
 	}
-	return -EINVAL;
+	if (str_starts(&data, KEYWORD_ALLOW_CAPABILITY))
+		return ccs_write_capability_policy(data, domain, cond,
+						   is_delete);
+	else if (str_starts(&data, KEYWORD_ALLOW_NETWORK))
+		return ccs_write_network_policy(data, domain, cond, is_delete);
+	else if (str_starts(&data, KEYWORD_ALLOW_SIGNAL))
+		return ccs_write_signal_policy(data, domain, cond, is_delete);
+	else if (str_starts(&data, KEYWORD_ALLOW_ARGV0))
+		return ccs_write_argv0_policy(data, domain, cond, is_delete);
+	else if (str_starts(&data, KEYWORD_ALLOW_ENV))
+		return ccs_write_env_policy(data, domain, cond, is_delete);
+	else
+		return ccs_write_file_policy(data, domain, cond, is_delete);
 }
 
-static bool print_single_path_acl(struct io_buffer *head, struct single_path_acl_record *ptr, const struct condition_list *cond)
+/**
+ * print_single_path_acl - Dump a single path ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct single_path_acl_record".
+ * @cond: Pointer to "struct condition_list *". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_single_path_acl(struct ccs_io_buffer *head,
+				  struct single_path_acl_record *ptr,
+				  const struct condition_list *cond)
 {
 	int pos;
 	u8 bit;
-	const bool b = ptr->u_is_group;
+	const char *atmark = "";
+	const char *filename;
 	const u16 perm = ptr->perm;
+	if (ptr->u_is_group) {
+		atmark = "@";
+		filename = ptr->u.group->group_name->name;
+	} else {
+		filename = ptr->u.filename->name;
+	}
 	for (bit = head->read_bit; bit < MAX_SINGLE_PATH_OPERATION; bit++) {
 		const char *msg;
-		if (!(perm & (1 << bit))) continue;
+		if (!(perm & (1 << bit)))
+			continue;
 		/* Print "read/write" instead of "read" and "write". */
-		if ((bit == TYPE_READ_ACL || bit == TYPE_WRITE_ACL) && (perm & (1 << TYPE_READ_WRITE_ACL))) continue;
-		msg = sp_operation2keyword(bit);
+		if ((bit == TYPE_READ_ACL || bit == TYPE_WRITE_ACL)
+		    && (perm & (1 << TYPE_READ_WRITE_ACL)))
+			continue;
+		msg = ccs_sp2keyword(bit);
 		pos = head->read_avail;
-		if (b && io_printf(head, "allow_%s @%s ", msg, ptr->u.group->group_name->name)) goto out;
-		if (!b && io_printf(head, "allow_%s %s ", msg, ptr->u.filename->name)) goto out;
-		if (DumpCondition(head, cond)) goto out;
+		if (!ccs_io_printf(head, "allow_%s %s%s ", msg,
+				   atmark, filename) ||
+		    !ccs_dump_condition(head, cond))
+			goto out;
 	}
 	head->read_bit = 0;
 	return true;
@@ -979,23 +1476,49 @@
 	return false;
 }
 
-static bool print_double_path_acl(struct io_buffer *head, struct double_path_acl_record *ptr, const struct condition_list *cond)
+/**
+ * print_double_path_acl - Dump a double path ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct double_path_acl_record".
+ * @cond: Pointer to "struct condition_list *". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_double_path_acl(struct ccs_io_buffer *head,
+				  struct double_path_acl_record *ptr,
+				  const struct condition_list *cond)
 {
 	int pos;
-	const bool b0 = ptr->u1_is_group, b1 = ptr->u2_is_group;
+	const char *atmark1 = "";
+	const char *atmark2 = "";
+	const char *filename1;
+	const char *filename2;
 	const u8 perm = ptr->perm;
 	u8 bit;
+	if (ptr->u1_is_group) {
+		atmark1 = "@";
+		filename1 = ptr->u1.group1->group_name->name;
+	} else {
+		filename1 = ptr->u1.filename1->name;
+	}
+	if (ptr->u2_is_group) {
+		atmark2 = "@";
+		filename2 = ptr->u2.group2->group_name->name;
+	} else {
+		filename2 = ptr->u2.filename2->name;
+	}
 	for (bit = head->read_bit; bit < MAX_DOUBLE_PATH_OPERATION; bit++) {
 		const char *msg;
-		if (!(perm & (1 << bit))) continue;
-		msg = dp_operation2keyword(bit);
+		if (!(perm & (1 << bit)))
+			continue;
+		msg = ccs_dp2keyword(bit);
 		pos = head->read_avail;
-		if (io_printf(head, "allow_%s ", msg)) goto out;
-		if (b0 && io_printf(head, "@%s ", ptr->u1.group1->group_name->name)) goto out;
-		if (!b0 && io_printf(head, "%s ", ptr->u1.filename1->name)) goto out;
-		if (b1 && io_printf(head, "@%s", ptr->u2.group2->group_name->name)) goto out;
-		if (!b1 && io_printf(head, "%s", ptr->u2.filename2->name)) goto out;
-		if (DumpCondition(head, cond)) goto out;
+		if (!ccs_io_printf(head, "allow_%s %s%s %s%s", msg,
+				   atmark1, filename1,
+				   atmark2, filename2) ||
+		    !ccs_dump_condition(head, cond))
+			goto out;
 	}
 	head->read_bit = 0;
 	return true;
@@ -1005,145 +1528,352 @@
 	return false;
 }
 
-static bool print_argv0_acl(struct io_buffer *head, struct argv0_acl_record *ptr, const struct condition_list *cond)
+/**
+ * print_argv0_acl - Dump an argv[0] ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct argv0_acl_record".
+ * @cond: Pointer to "struct condition_list *". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_argv0_acl(struct ccs_io_buffer *head,
+			    struct argv0_acl_record *ptr,
+			    const struct condition_list *cond)
 {
 	int pos = head->read_avail;
-	if (io_printf(head, KEYWORD_ALLOW_ARGV0 "%s %s",
-		      ptr->filename->name, ptr->argv0->name)) goto out;
-	if (DumpCondition(head, cond)) goto out;
+	if (!ccs_io_printf(head, KEYWORD_ALLOW_ARGV0 "%s %s",
+			   ptr->filename->name, ptr->argv0->name))
+		goto out;
+	if (!ccs_dump_condition(head, cond))
+		goto out;
 	return true;
  out:
 	head->read_avail = pos;
 	return false;
 }
 
-static bool print_env_acl(struct io_buffer *head, struct env_acl_record *ptr, const struct condition_list *cond)
+/**
+ * print_env_acl - Dump an evironment variable name's ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct env_acl_record".
+ * @cond: Pointer to "struct condition_list *". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_env_acl(struct ccs_io_buffer *head,
+			  struct env_acl_record *ptr,
+			  const struct condition_list *cond)
 {
 	int pos = head->read_avail;
-	if (io_printf(head, KEYWORD_ALLOW_ENV "%s", ptr->env->name)) goto out;
-	if (DumpCondition(head, cond)) goto out;
+	if (!ccs_io_printf(head, KEYWORD_ALLOW_ENV "%s", ptr->env->name))
+		goto out;
+	if (!ccs_dump_condition(head, cond))
+		goto out;
 	return true;
  out:
 	head->read_avail = pos;
 	return false;
 }
 
-static bool print_capability_acl(struct io_buffer *head, struct capability_acl_record *ptr, const struct condition_list *cond)
+/**
+ * print_capability_acl - Dump a capability ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct capability_acl_record".
+ * @cond: Pointer to "struct condition_list *". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_capability_acl(struct ccs_io_buffer *head,
+				 struct capability_acl_record *ptr,
+				 const struct condition_list *cond)
 {
 	int pos = head->read_avail;
-	if (io_printf(head, KEYWORD_ALLOW_CAPABILITY "%s", cap_operation2keyword(ptr->operation))) goto out;
-	if (DumpCondition(head, cond)) goto out;
+	if (!ccs_io_printf(head, KEYWORD_ALLOW_CAPABILITY "%s",
+			   ccs_cap2keyword(ptr->operation)))
+		goto out;
+	if (!ccs_dump_condition(head, cond))
+		goto out;
 	return true;
  out:
 	head->read_avail = pos;
 	return false;
 }
 
-static bool print_network_acl(struct io_buffer *head, struct ip_network_acl_record *ptr, const struct condition_list *cond)
+/**
+ * print_ipv4_entry - Dump IPv4 address of a network ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ip_network_acl_record".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_ipv4_entry(struct ccs_io_buffer *head,
+			     struct ip_network_acl_record *ptr)
 {
+	const u32 min_address = ptr->u.ipv4.min;
+	const u32 max_address = ptr->u.ipv4.max;
+	if (!ccs_io_printf(head, "%u.%u.%u.%u", HIPQUAD(min_address)))
+		return false;
+	if (min_address != max_address
+	    && !ccs_io_printf(head, "-%u.%u.%u.%u", HIPQUAD(max_address)))
+		return false;
+	return true;
+}
+
+/**
+ * print_ipv6_entry - Dump IPv6 address of a network ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ip_network_acl_record".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_ipv6_entry(struct ccs_io_buffer *head,
+			     struct ip_network_acl_record *ptr)
+{
+	char buf[64];
+	const struct in6_addr *min_address = ptr->u.ipv6.min;
+	const struct in6_addr *max_address = ptr->u.ipv6.max;
+	ccs_print_ipv6(buf, sizeof(buf), min_address);
+	if (!ccs_io_printf(head, "%s", buf))
+		return false;
+	if (min_address != max_address) {
+		ccs_print_ipv6(buf, sizeof(buf), max_address);
+		if (!ccs_io_printf(head, "-%s", buf))
+			return false;
+	}
+	return true;
+}
+
+/**
+ * print_port_entry - Dump port number of a network ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ip_network_acl_record".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_port_entry(struct ccs_io_buffer *head,
+			     struct ip_network_acl_record *ptr)
+{
+	const u16 min_port = ptr->min_port, max_port = ptr->max_port;
+	if (!ccs_io_printf(head, " %u", min_port))
+		return false;
+	if (min_port != max_port && !ccs_io_printf(head, "-%u", max_port))
+		return false;
+	return true;
+}
+
+/**
+ * print_network_acl - Dump a network ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ip_network_acl_record".
+ * @cond: Pointer to "struct condition_list *". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_network_acl(struct ccs_io_buffer *head,
+			      struct ip_network_acl_record *ptr,
+			      const struct condition_list *cond)
+{
 	int pos = head->read_avail;
-	if (io_printf(head, KEYWORD_ALLOW_NETWORK "%s ", net_operation2keyword(ptr->operation_type))) goto out;
+	if (!ccs_io_printf(head, KEYWORD_ALLOW_NETWORK "%s ",
+			   ccs_net2keyword(ptr->operation_type)))
+		goto out;
 	switch (ptr->record_type) {
 	case IP_RECORD_TYPE_ADDRESS_GROUP:
-		if (io_printf(head, "@%s", ptr->u.group->group_name->name)) goto out;
+		if (!ccs_io_printf(head, "@%s", ptr->u.group->group_name->name))
+			goto out;
 		break;
 	case IP_RECORD_TYPE_IPv4:
-		{
-			const u32 min_address = ptr->u.ipv4.min, max_address = ptr->u.ipv4.max;
-			if (io_printf(head, "%u.%u.%u.%u", HIPQUAD(min_address))) goto out;
-			if (min_address != max_address && io_printf(head, "-%u.%u.%u.%u", HIPQUAD(max_address))) goto out;
-		}
+		if (!print_ipv4_entry(head, ptr))
+			goto out;
 		break;
 	case IP_RECORD_TYPE_IPv6:
-		{
-			char buf[64];
-			const struct in6_addr *min_address = ptr->u.ipv6.min, *max_address = ptr->u.ipv6.max;
-			print_ipv6(buf, sizeof(buf), min_address);
-			if (io_printf(head, "%s", buf)) goto out;
-			if (min_address != max_address) {
-				print_ipv6(buf, sizeof(buf), max_address);
-				if (io_printf(head, "-%s", buf)) goto out;
-			}
-		}
+		if (!print_ipv6_entry(head, ptr))
+			goto out;
 		break;
 	}
-	{
-		const u16 min_port = ptr->min_port, max_port = ptr->max_port;
-		if (io_printf(head, " %u", min_port)) goto out;
-		if (min_port != max_port && io_printf(head, "-%u", max_port)) goto out;
-	}
-	if (DumpCondition(head, cond)) goto out;
+	if (!print_port_entry(head, ptr))
+		goto out;
+	if (!ccs_dump_condition(head, cond))
+		goto out;
 	return true;
  out:
 	head->read_avail = pos;
 	return false;
 }
 
-static bool print_signal_acl(struct io_buffer *head, struct signal_acl_record *ptr, const struct condition_list *cond)
+/**
+ * print_signal_acl - Dump a signal ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct signale_acl_record".
+ * @cond: Pointer to "struct condition_list *". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_signal_acl(struct ccs_io_buffer *head,
+			     struct signal_acl_record *ptr,
+			     const struct condition_list *cond)
 {
 	int pos = head->read_avail;
-	if (io_printf(head, KEYWORD_ALLOW_SIGNAL "%u %s", ptr->sig, ptr->domainname->name)) goto out;
-	if (DumpCondition(head, cond)) goto out;
+	if (!ccs_io_printf(head, KEYWORD_ALLOW_SIGNAL "%u %s",
+			   ptr->sig, ptr->domainname->name))
+		goto out;
+	if (!ccs_dump_condition(head, cond))
+		goto out;
 	return true;
  out:
 	head->read_avail = pos;
 	return false;
 }
 
-static bool print_execute_handler_record(struct io_buffer *head, const char *keyword, struct execute_handler_record *ptr)
+/**
+ * print_execute_handler_record - Dump an execute handler ACL entry.
+ *
+ * @head:    Pointer to "struct ccs_io_buffer".
+ * @keyword: Name of the keyword.
+ * @ptr:     Pointer to "struct execute_handler_record".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_execute_handler_record(struct ccs_io_buffer *head,
+					 const char *keyword,
+					 struct execute_handler_record *ptr)
 {
-	return io_printf(head, "%s %s\n", keyword, ptr->handler->name) == 0;
+	return ccs_io_printf(head, "%s %s\n", keyword, ptr->handler->name);
 }
 
-static int ReadDomainPolicy(struct io_buffer *head)
+/**
+ * print_entry - Dump an ACL entry.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to an ACL entry.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool print_entry(struct ccs_io_buffer *head, struct acl_info *ptr)
 {
+	const struct condition_list *cond = ccs_get_condition_part(ptr);
+	const u8 acl_type = ptr->type & ~ACL_WITH_CONDITION;
+	if (acl_type & ACL_DELETED)
+		return true;
+	if (acl_type == TYPE_SINGLE_PATH_ACL) {
+		struct single_path_acl_record *acl
+			= container_of(ptr, struct single_path_acl_record,
+				       head);
+		return print_single_path_acl(head, acl, cond);
+	}
+	if (acl_type == TYPE_DOUBLE_PATH_ACL) {
+		struct double_path_acl_record *acl
+			= container_of(ptr, struct double_path_acl_record,
+				       head);
+		return print_double_path_acl(head, acl, cond);
+	}
+	if (acl_type == TYPE_ARGV0_ACL) {
+		struct argv0_acl_record *acl
+			= container_of(ptr, struct argv0_acl_record, head);
+		return print_argv0_acl(head, acl, cond);
+	}
+	if (acl_type == TYPE_ENV_ACL) {
+		struct env_acl_record *acl
+			= container_of(ptr, struct env_acl_record, head);
+		return print_env_acl(head, acl, cond);
+	}
+	if (acl_type == TYPE_CAPABILITY_ACL) {
+		struct capability_acl_record *acl
+			= container_of(ptr, struct capability_acl_record, head);
+		return print_capability_acl(head, acl, cond);
+	}
+	if (acl_type == TYPE_IP_NETWORK_ACL) {
+		struct ip_network_acl_record *acl
+			= container_of(ptr, struct ip_network_acl_record, head);
+		return print_network_acl(head, acl, cond);
+	}
+	if (acl_type == TYPE_SIGNAL_ACL) {
+		struct signal_acl_record *acl
+			= container_of(ptr, struct signal_acl_record, head);
+		return print_signal_acl(head, acl, cond);
+	}
+	if (acl_type == TYPE_PREFERRED_EXECUTE_HANDLER) {
+		struct execute_handler_record *acl
+			= container_of(ptr, struct execute_handler_record,
+				       head);
+		const char *keyword = KEYWORD_PREFERRED_EXECUTE_HANDLER;
+		return print_execute_handler_record(head, keyword, acl);
+	}
+	if (acl_type == TYPE_DEFAULT_EXECUTE_HANDLER) {
+		struct execute_handler_record *acl
+			= container_of(ptr, struct execute_handler_record,
+				       head);
+		const char *keyword = KEYWORD_DEFAULT_EXECUTE_HANDLER;
+		return print_execute_handler_record(head, keyword, acl);
+	}
+	BUG(); /* This must not happen. */
+	return false;
+}
+
+/**
+ * read_domain_policy - Read domain policy.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0.
+ */
+static int read_domain_policy(struct ccs_io_buffer *head)
+{
 	struct list1_head *dpos;
 	struct list1_head *apos;
-	if (head->read_eof) return 0;
-	if (head->read_step == 0) head->read_step = 1;
+	if (head->read_eof)
+		return 0;
+	if (head->read_step == 0)
+		head->read_step = 1;
 	list1_for_each_cookie(dpos, head->read_var1, &domain_list) {
 		struct domain_info *domain;
+		const char *quota_exceeded = "";
+		const char *ignore_global_allow_read = "";
+		const char *ignore_global_allow_env = "";
 		domain = list1_entry(dpos, struct domain_info, list);
-		if (head->read_step != 1) goto acl_loop;
-		if (domain->is_deleted) continue;
-		if (io_printf(head, "%s\n" KEYWORD_USE_PROFILE "%u\n%s\n%s%s", domain->domainname->name, domain->profile, domain->quota_warned ? "quota_exceeded\n" : "", domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ ? KEYWORD_IGNORE_GLOBAL_ALLOW_READ "\n" : "", domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV ? KEYWORD_IGNORE_GLOBAL_ALLOW_ENV "\n" : "")) return 0;
+		if (head->read_step != 1)
+			goto acl_loop;
+		if (domain->is_deleted)
+			continue;
+		/* Dump domainname and flags. */
+		if (domain->quota_warned)
+			quota_exceeded = "quota_exceeded\n";
+		if (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ)
+			ignore_global_allow_read
+				= KEYWORD_IGNORE_GLOBAL_ALLOW_READ "\n";
+		if (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV)
+			ignore_global_allow_env
+				= KEYWORD_IGNORE_GLOBAL_ALLOW_ENV "\n";
+		if (!ccs_io_printf(head, "%s\n" KEYWORD_USE_PROFILE "%u\n"
+				   "%s%s%s\n", domain->domainname->name,
+				   domain->profile, quota_exceeded,
+				   ignore_global_allow_read,
+				   ignore_global_allow_env))
+			return 0;
 		head->read_step = 2;
-	acl_loop: ;
-		if (head->read_step == 3) goto tail_mark;
-		list1_for_each_cookie(apos, head->read_var2, &domain->acl_info_list) {
-			struct acl_info *ptr;
-			u8 acl_type;
-			const struct condition_list *cond;
-			ptr = list1_entry(apos, struct acl_info, list);
-			cond = GetConditionPart(ptr);
-			acl_type = ptr->type & ~ACL_WITH_CONDITION;
-			if (acl_type & ACL_DELETED) {
-				/* Deleted entry. */
-			} else if (acl_type == TYPE_SINGLE_PATH_ACL) {
-				if (!print_single_path_acl(head, container_of(ptr, struct single_path_acl_record, head), cond)) return 0;
-			} else if (acl_type == TYPE_DOUBLE_PATH_ACL) {
-				if (!print_double_path_acl(head, container_of(ptr, struct double_path_acl_record, head), cond)) return 0;
-			} else if (acl_type == TYPE_ARGV0_ACL) {
-				if (!print_argv0_acl(head, container_of(ptr, struct argv0_acl_record, head), cond)) return 0;
-			} else if (acl_type == TYPE_ENV_ACL) {
-				if (!print_env_acl(head, container_of(ptr, struct env_acl_record, head), cond)) return 0;
-			} else if (acl_type == TYPE_CAPABILITY_ACL) {
-				if (!print_capability_acl(head, container_of(ptr, struct capability_acl_record, head), cond)) return 0;
-			} else if (acl_type == TYPE_IP_NETWORK_ACL) {
-				if (!print_network_acl(head, container_of(ptr, struct ip_network_acl_record, head), cond)) return 0;
-			} else if (acl_type == TYPE_SIGNAL_ACL) {
-				if (!print_signal_acl(head, container_of(ptr, struct signal_acl_record, head), cond)) return 0;
-			} else if (acl_type == TYPE_PREFERRED_EXECUTE_HANDLER) {
-				if (!print_execute_handler_record(head, KEYWORD_PREFERRED_EXECUTE_HANDLER, container_of(ptr, struct execute_handler_record, head))) return 0;
-			} else if (acl_type == TYPE_DEFAULT_EXECUTE_HANDLER) {
-				if (!print_execute_handler_record(head, KEYWORD_DEFAULT_EXECUTE_HANDLER, container_of(ptr, struct execute_handler_record, head))) return 0;
-			} else {
-				BUG();
-			}
+ acl_loop:
+		if (head->read_step == 3)
+			goto tail_mark;
+		/* Dump ACL entries in the domain. */
+		list1_for_each_cookie(apos, head->read_var2,
+				      &domain->acl_info_list) {
+			struct acl_info *ptr
+				= list1_entry(apos, struct acl_info, list);
+			if (!print_entry(head, ptr))
+				return 0;
 		}
 		head->read_step = 3;
-	tail_mark: ;
-		if (io_printf(head, "\n")) return 0;
+ tail_mark:
+		if (!ccs_io_printf(head, "\n"))
+			return 0;
 		head->read_step = 1;
 	}
 	head->read_eof = true;
@@ -1152,43 +1882,91 @@
 
 #endif
 
-static int UpdateDomainProfile(struct io_buffer *head)
+/**
+ * write_domain_profile - Assign profile for specified domain.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, -EINVAL otherwise.
+ *
+ * This is equivalent to doing
+ *     ( echo "select " $domainname; echo "use_profile " $profile ) | \
+ *     /usr/lib/ccs/ccs-loadpolicy -d
+ */
+static int write_domain_profile(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
 	char *cp = strchr(data, ' ');
 	struct domain_info *domain;
 	unsigned int profile;
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp = '\0';
-	domain = FindDomain(cp + 1);
+	domain = ccs_find_domain(cp + 1);
 	profile = simple_strtoul(data, NULL, 10);
-	if (domain && profile < MAX_PROFILES && (profile_ptr[profile] || !sbin_init_started)) domain->profile = (u8) profile;
-	UpdateCounter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
+	if (domain && profile < MAX_PROFILES
+	    && (profile_ptr[profile] || !sbin_init_started))
+		domain->profile = (u8) profile;
+	ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 	return 0;
 }
 
-static int ReadDomainProfile(struct io_buffer *head)
+/**
+ * read_domain_profile - Read only domainname and profile.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns list of profile number and domainname pairs.
+ *
+ * This is equivalent to doing
+ *     grep -A 1 '^<kernel>' /proc/ccs/domain_policy | \
+ *     awk ' BEGIN { if ( domainname == "") domainname = $0; \
+ *     else if ( $1 = "use_profile" ) { print $2 " " domainname; \
+ *     domainname = ""; }; '
+ */
+static int read_domain_profile(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
-	if (head->read_eof) return 0;
+	if (head->read_eof)
+		return 0;
 	list1_for_each_cookie(pos, head->read_var1, &domain_list) {
 		struct domain_info *domain;
 		domain = list1_entry(pos, struct domain_info, list);
-		if (domain->is_deleted) continue;
-		if (io_printf(head, "%u %s\n", domain->profile, domain->domainname->name)) return 0;
+		if (domain->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, "%u %s\n", domain->profile,
+				   domain->domainname->name))
+			return 0;
 	}
 	head->read_eof = true;
 	return 0;
 }
 
-static int WritePID(struct io_buffer *head)
+/**
+ * write_pid: Specify PID to obtain domainname.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0.
+ */
+static int write_pid(struct ccs_io_buffer *head)
 {
 	head->read_step = (int) simple_strtoul(head->write_buf, NULL, 10);
 	head->read_eof = false;
 	return 0;
 }
 
-static int ReadPID(struct io_buffer *head)
+/**
+ * read_pid - Get domainname of the specified PID.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns the domainname which the specified PID is in on success,
+ * empty string otherwise.
+ * The PID is specified by write_pid() so that the user can obtain
+ * using read()/write() interface rather than sysctl() interface.
+ */
+static int read_pid(struct ccs_io_buffer *head)
 {
 	if (head->read_avail == 0 && !head->read_eof) {
 		const int pid = head->read_step;
@@ -1197,91 +1975,126 @@
 		/***** CRITICAL SECTION START *****/
 		read_lock(&tasklist_lock);
 		p = find_task_by_pid(pid);
-		if (p) domain = p->domain_info;
+		if (p)
+			domain = p->domain_info;
 		read_unlock(&tasklist_lock);
 		/***** CRITICAL SECTION END *****/
-		if (domain) io_printf(head, "%d %u %s", pid, domain->profile, domain->domainname->name);
+		if (domain)
+			ccs_io_printf(head, "%d %u %s", pid, domain->profile,
+				      domain->domainname->name);
 		head->read_eof = true;
 	}
 	return 0;
 }
 
-/*************************  EXCEPTION POLICY HANDLER  *************************/
-
 #ifdef CONFIG_TOMOYO
 
-static int AddExceptionPolicy(struct io_buffer *head)
+/* Exception policy handler. */
+
+/**
+ * write_exception_policy - Write exception policy.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int write_exception_policy(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
-	bool is_delete = false;
-	UpdateCounter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
-	if (strncmp(data, KEYWORD_DELETE, KEYWORD_DELETE_LEN) == 0) {
-		data += KEYWORD_DELETE_LEN;
-		is_delete = true;
-	}
-	if (strncmp(data, KEYWORD_KEEP_DOMAIN, KEYWORD_KEEP_DOMAIN_LEN) == 0) {
-		return AddDomainKeeperPolicy(data + KEYWORD_KEEP_DOMAIN_LEN, 0, is_delete);
-	} else if (strncmp(data, KEYWORD_NO_KEEP_DOMAIN, KEYWORD_NO_KEEP_DOMAIN_LEN) == 0) {
-		return AddDomainKeeperPolicy(data + KEYWORD_NO_KEEP_DOMAIN_LEN, 1, is_delete);
-	} else if (strncmp(data, KEYWORD_INITIALIZE_DOMAIN, KEYWORD_INITIALIZE_DOMAIN_LEN) == 0) {
-		return AddDomainInitializerPolicy(data + KEYWORD_INITIALIZE_DOMAIN_LEN, 0, is_delete);
-	} else if (strncmp(data, KEYWORD_NO_INITIALIZE_DOMAIN, KEYWORD_NO_INITIALIZE_DOMAIN_LEN) == 0) {
-		return AddDomainInitializerPolicy(data + KEYWORD_NO_INITIALIZE_DOMAIN_LEN, 1, is_delete);
-	} else if (strncmp(data, KEYWORD_ALIAS, KEYWORD_ALIAS_LEN) == 0) {
-		return AddAliasPolicy(data + KEYWORD_ALIAS_LEN, is_delete);
-	} else if (strncmp(data, KEYWORD_AGGREGATOR, KEYWORD_AGGREGATOR_LEN) == 0) {
-		return AddAggregatorPolicy(data + KEYWORD_AGGREGATOR_LEN, is_delete);
-	} else if (strncmp(data, KEYWORD_ALLOW_READ, KEYWORD_ALLOW_READ_LEN) == 0) {
-		return AddGloballyReadablePolicy(data + KEYWORD_ALLOW_READ_LEN, is_delete);
-	} else if (strncmp(data, KEYWORD_ALLOW_ENV, KEYWORD_ALLOW_ENV_LEN) == 0) {
-		return AddGloballyUsableEnvPolicy(data + KEYWORD_ALLOW_ENV_LEN, is_delete);
-	} else if (strncmp(data, KEYWORD_FILE_PATTERN, KEYWORD_FILE_PATTERN_LEN) == 0) {
-		return AddFilePatternPolicy(data + KEYWORD_FILE_PATTERN_LEN, is_delete);
-	} else if (strncmp(data, KEYWORD_PATH_GROUP, KEYWORD_PATH_GROUP_LEN) == 0) {
-		return AddPathGroupPolicy(data + KEYWORD_PATH_GROUP_LEN, is_delete);
-	} else if (strncmp(data, KEYWORD_DENY_REWRITE, KEYWORD_DENY_REWRITE_LEN) == 0) {
-		return AddNoRewritePolicy(data + KEYWORD_DENY_REWRITE_LEN, is_delete);
-	} else if (strncmp(data, KEYWORD_ADDRESS_GROUP, KEYWORD_ADDRESS_GROUP_LEN) == 0) {
-		return AddAddressGroupPolicy(data + KEYWORD_ADDRESS_GROUP_LEN, is_delete);
-	}
+	bool is_delete = str_starts(&data, KEYWORD_DELETE);
+	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
+	if (str_starts(&data, KEYWORD_KEEP_DOMAIN))
+		return ccs_write_domain_keeper_policy(data, false, is_delete);
+	if (str_starts(&data, KEYWORD_NO_KEEP_DOMAIN))
+		return ccs_write_domain_keeper_policy(data, true, is_delete);
+	if (str_starts(&data, KEYWORD_INITIALIZE_DOMAIN))
+		return ccs_write_domain_initializer_policy(data, false,
+							   is_delete);
+	if (str_starts(&data, KEYWORD_NO_INITIALIZE_DOMAIN))
+		return ccs_write_domain_initializer_policy(data, true,
+							   is_delete);
+	if (str_starts(&data, KEYWORD_ALIAS))
+		return ccs_write_alias_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_AGGREGATOR))
+		return ccs_write_aggregator_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_ALLOW_READ))
+		return ccs_write_globally_readable_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_ALLOW_ENV))
+		return ccs_write_globally_usable_env_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_FILE_PATTERN))
+		return ccs_write_pattern_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_PATH_GROUP))
+		return ccs_write_path_group_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_DENY_REWRITE))
+		return ccs_write_no_rewrite_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_ADDRESS_GROUP))
+		return ccs_write_address_group_policy(data, is_delete);
 	return -EINVAL;
 }
 
-static int ReadExceptionPolicy(struct io_buffer *head)
+/**
+ * read_exception_policy - Read exception policy.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, -EINVAL otherwise.
+ */
+static int read_exception_policy(struct ccs_io_buffer *head)
 {
 	if (!head->read_eof) {
 		switch (head->read_step) {
 		case 0:
-			head->read_var2 = NULL; head->read_step = 1;
+			head->read_var2 = NULL;
+			head->read_step = 1;
 		case 1:
-			if (ReadDomainKeeperPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 2;
+			if (!ccs_read_domain_keeper_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 2;
 		case 2:
-			if (ReadGloballyReadablePolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 3;
+			if (!ccs_read_globally_readable_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 3;
 		case 3:
-			if (ReadGloballyUsableEnvPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 4;
+			if (!ccs_read_globally_usable_env_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 4;
 		case 4:
-			if (ReadDomainInitializerPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 5;
+			if (!ccs_read_domain_initializer_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 5;
 		case 5:
-			if (ReadAliasPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 6;
+			if (!ccs_read_alias_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 6;
 		case 6:
-			if (ReadAggregatorPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 7;
+			if (!ccs_read_aggregator_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 7;
 		case 7:
-			if (ReadFilePatternPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 8;
+			if (!ccs_read_file_pattern(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 8;
 		case 8:
-			if (ReadNoRewritePolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 9;
+			if (!ccs_read_no_rewrite_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 9;
 		case 9:
-			if (ReadPathGroupPolicy(head)) break;
-			head->read_var1 = head->read_var2 = NULL; head->read_step = 10;
+			if (!ccs_read_path_group_policy(head))
+				break;
+			head->read_var1 = NULL;
+			head->read_var2 = NULL;
+			head->read_step = 10;
 		case 10:
-			if (ReadAddressGroupPolicy(head)) break;
+			if (!ccs_read_address_group_policy(head))
+				break;
 			head->read_eof = true;
 			break;
 		default:
@@ -1293,52 +2106,74 @@
 
 #endif
 
-/*************************  SYSTEM POLICY HANDLER  *************************/
-
 #ifdef CONFIG_SAKURA
 
-static int AddSystemPolicy(struct io_buffer *head)
+/* System policy handler. */
+
+/**
+ * write_system_policy - Write system policy.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int write_system_policy(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
 	bool is_delete = false;
-	UpdateCounter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
-	if (strncmp(data, KEYWORD_DELETE, KEYWORD_DELETE_LEN) == 0) {
-		data += KEYWORD_DELETE_LEN;
+	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
+	if (str_starts(&data, KEYWORD_DELETE))
 		is_delete = true;
-	}
-	if (strncmp(data, KEYWORD_ALLOW_MOUNT, KEYWORD_ALLOW_MOUNT_LEN) == 0)
-		return AddMountPolicy(data + KEYWORD_ALLOW_MOUNT_LEN, is_delete);
-	if (strncmp(data, KEYWORD_DENY_UNMOUNT, KEYWORD_DENY_UNMOUNT_LEN) == 0)
-		return AddNoUmountPolicy(data + KEYWORD_DENY_UNMOUNT_LEN, is_delete);
-	if (strncmp(data, KEYWORD_ALLOW_CHROOT, KEYWORD_ALLOW_CHROOT_LEN) == 0)
-		return AddChrootPolicy(data + KEYWORD_ALLOW_CHROOT_LEN, is_delete);
-	if (strncmp(data, KEYWORD_ALLOW_PIVOT_ROOT, KEYWORD_ALLOW_PIVOT_ROOT_LEN) == 0)
-		return AddPivotRootPolicy(data + KEYWORD_ALLOW_PIVOT_ROOT_LEN, is_delete);
-	if (strncmp(data, KEYWORD_DENY_AUTOBIND, KEYWORD_DENY_AUTOBIND_LEN) == 0)
-		return AddReservedPortPolicy(data + KEYWORD_DENY_AUTOBIND_LEN, is_delete);
+	if (str_starts(&data, KEYWORD_ALLOW_MOUNT))
+		return ccs_write_mount_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_DENY_UNMOUNT))
+		return ccs_write_no_umount_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_ALLOW_CHROOT))
+		return ccs_write_chroot_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_ALLOW_PIVOT_ROOT))
+		return ccs_write_pivot_root_policy(data, is_delete);
+	if (str_starts(&data, KEYWORD_DENY_AUTOBIND))
+		return ccs_write_reserved_port_policy(data, is_delete);
 	return -EINVAL;
 }
 
-static int ReadSystemPolicy(struct io_buffer *head)
+/**
+ * read_system_policy - Read system policy.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, -EINVAL otherwise.
+ */
+static int read_system_policy(struct ccs_io_buffer *head)
 {
 	if (!head->read_eof) {
 		switch (head->read_step) {
 		case 0:
-			head->read_var2 = NULL; head->read_step = 1;
+			head->read_var2 = NULL;
+			head->read_step = 1;
 		case 1:
-			if (ReadMountPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 2;
+			if (!ccs_read_mount_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 2;
 		case 2:
-			if (ReadNoUmountPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 3;
+			if (!ccs_read_no_umount_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 3;
 		case 3:
-			if (ReadChrootPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 4;
+			if (!ccs_read_chroot_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 4;
 		case 4:
-			if (ReadPivotRootPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 5;
+			if (!ccs_read_pivot_root_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 5;
 		case 5:
-			if (ReadReservedPortPolicy(head)) break;
+			if (!ccs_read_reserved_port_policy(head))
+				break;
 			head->read_eof = true;
 			break;
 		default:
@@ -1350,58 +2185,95 @@
 
 #endif
 
-/*************************  POLICY LOADER  *************************/
-
+/* Profile loaded by policy loader? */
 static bool profile_loaded = false;
 
-static const char *ccs_loader = NULL;
+/* Path to the policy loader. The default is /sbin/ccs-init . */
+static const char *ccs_loader;
 
-static int __init CCS_loader_Setup(char *str)
+/**
+ * loader_setup - Specify the policy loader to use.
+ *
+ * @str: Path to the policy loader.
+ *
+ * Returns 0.
+ */
+static int __init loader_setup(char *str)
 {
 	ccs_loader = str;
 	return 0;
 }
 
-__setup("CCS_loader=", CCS_loader_Setup);
+__setup("CCS_loader=", loader_setup);
 
-void CCS_LoadPolicy(const char *filename)
+/**
+ * policy_loader_exists - Check whether /sbin/ccs-init exists.
+ *
+ * Returns true if /sbin/ccs-init exists, false otherwise.
+ */
+static bool policy_loader_exists(void)
 {
-	if (sbin_init_started) return;
 	/*
-	 * Check filename is /sbin/init or /sbin/ccs-start .
-	 * /sbin/ccs-start is a dummy filename in case where /sbin/init can't be passed.
-	 * You can create /sbin/ccs-start by "ln -s /bin/true /sbin/ccs-start", for
-	 * only the pathname is needed to activate Mandatory Access Control.
+	 * Don't activate MAC if the path given by 'CCS_loader=' option doesn't
+	 * exist. If the initrd includes /sbin/init but real-root-dev has not
+	 * mounted on / yet, activating MAC will block the system since
+	 * policies are not loaded yet.
+	 * Thus, let do_execve() call this function everytime.
 	 */
-	if (strcmp(filename, "/sbin/init") != 0 && strcmp(filename, "/sbin/ccs-start") != 0) return;
+	struct nameidata nd;
+	if (!ccs_loader)
+		ccs_loader = "/sbin/ccs-init";
+	if (path_lookup(ccs_loader, lookup_flags, &nd)) {
+		printk(KERN_INFO "Not activating Mandatory Access Control now "
+		       "since %s doesn't exist.\n", ccs_loader);
+		return false;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	path_put(&nd.path);
+#else
+	path_release(&nd);
+#endif
+	return true;
+}
+
+/**
+ * ccs_load_policy - Run external policy loader to load policy.
+ *
+ * @filename: The program about to start.
+ *
+ * This function checks whether @filename is /sbin/init , and if so
+ * invoke /sbin/ccs-init and wait for the termination of /sbin/ccs-init
+ * and then continues invocation of /sbin/init .
+ * /sbin/ccs-init reads policy files in /etc/ccs/ directory and
+ * writes to /proc/ccs/ interfaces.
+ *
+ * Returns nothing.
+ */
+void ccs_load_policy(const char *filename)
+{
+	if (sbin_init_started)
+		return;
 	/*
-	 * Don't activate MAC if the path given by 'CCS_loader=' option doesn't exist.
-	 * If initrd.img includes /sbin/init but real-root-dev has not mounted on / yet,
-	 * activating MAC will block the system since policies are not loaded yet.
-	 * So let do_execve() call this function everytime.
+	 * Check filename is /sbin/init or /sbin/ccs-start .
+	 * /sbin/ccs-start is a dummy filename in case where /sbin/init can't
+	 * be passed.
+	 * You can create /sbin/ccs-start by "ln -s /bin/true /sbin/ccs-start".
 	 */
-	{
-		struct nameidata nd;
-		if (!ccs_loader) ccs_loader = "/sbin/ccs-init";
-		if (path_lookup(ccs_loader, lookup_flags, &nd)) {
-			printk("Not activating Mandatory Access Control now since %s doesn't exist.\n", ccs_loader);
-			return;
-		}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-		path_put(&nd.path);
-#else
-		path_release(&nd);
-#endif
-	}
+	if (strcmp(filename, "/sbin/init") &&
+	    strcmp(filename, "/sbin/ccs-start"))
+		return;
+	if (!policy_loader_exists())
+		return;
 	if (!profile_loaded) {
 		char *argv[2], *envp[3];
-		printk("Calling %s to load policy. Please wait.\n", ccs_loader);
+		printk(KERN_INFO "Calling %s to load policy. Please wait.\n",
+		       ccs_loader);
 		argv[0] = (char *) ccs_loader;
 		argv[1] = NULL;
 		envp[0] = "HOME=/";
 		envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
 		envp[2] = NULL;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 		call_usermodehelper(argv[0], argv, envp, 1);
 #else
 		call_usermodehelper(argv[0], argv, envp);
@@ -1412,29 +2284,35 @@
 		}
 	}
 #ifdef CONFIG_SAKURA
-	printk("SAKURA: 1.6.0-pre   2008/03/12\n");
+	printk(KERN_INFO "SAKURA: 1.6.0-pre   2008/03/12\n");
 #endif
 #ifdef CONFIG_TOMOYO
-	printk("TOMOYO: 1.6.0-pre   2008/03/12\n");
+	printk(KERN_INFO "TOMOYO: 1.6.0-pre   2008/03/12\n");
 #endif
-	printk("Mandatory Access Control activated.\n");
+	printk(KERN_INFO "Mandatory Access Control activated.\n");
 	sbin_init_started = true;
 	ccs_log_level = KERN_WARNING;
 	{ /* Check all profiles currently assigned to domains are defined. */
 		struct domain_info *domain;
 		list1_for_each_entry(domain, &domain_list, list) {
 			const u8 profile = domain->profile;
-			if (!profile_ptr[profile]) panic("Profile %u (used by '%s') not defined.\n", profile, domain->domainname->name);
+			if (profile_ptr[profile])
+				continue;
+			panic("Profile %u (used by '%s') not defined.\n",
+			      profile, domain->domainname->name);
 		}
 	}
 }
 
-/*************************  MAC Decision Delayer  *************************/
+/* Interactive enforcement handler. */
 
+/* Wait queue for query_list. */
 static DECLARE_WAIT_QUEUE_HEAD(query_wait);
 
-static spinlock_t query_lock = SPIN_LOCK_UNLOCKED;
+/* Lock for manipurating query_list. */
+static DEFINE_SPINLOCK(query_lock);
 
+/* The structure for query. */
 struct query_entry {
 	struct list_head list;
 	char *query;
@@ -1444,38 +2322,55 @@
 	int answer;
 };
 
+/* The list for "struct query_entry". */
 static LIST_HEAD(query_list);
+
+/* Number of "struct file" referring /proc/ccs/query interface. */
 static atomic_t queryd_watcher = ATOMIC_INIT(0);
 
-int CheckSupervisor(const char *fmt, ...)
+/**
+ * ccs_check_supervisor - Ask for the supervisor's decision.
+ *
+ * @fmt: The printf()'s format string, followed by parameters.
+ *
+ * Returns 0 if the supervisor decided to permit the access request which
+ * violated the policy in enforcing mode, -EPERM otherwise.
+ */
+int ccs_check_supervisor(const char *fmt, ...)
 {
 	va_list args;
 	int error = -EPERM;
 	int pos, len;
-	static unsigned int serial = 0;
+	static unsigned int serial;
 	struct query_entry *query_entry;
-	if (!CheckCCSFlags(CCS_ALLOW_ENFORCE_GRACE) || !atomic_read(&queryd_watcher)) {
-		if ((current->tomoyo_flags & CCS_DONT_SLEEP_ON_ENFORCE_ERROR) == 0) {
-			int i;
-			for (i = 0; i < CheckCCSFlags(CCS_SLEEP_PERIOD); i++) {
-				set_current_state(TASK_INTERRUPTIBLE);
-				schedule_timeout(HZ / 10);
-			}
+	if (!ccs_check_flags(CCS_ALLOW_ENFORCE_GRACE)
+	    || !atomic_read(&queryd_watcher)) {
+		int i;
+		if (current->tomoyo_flags & CCS_DONT_SLEEP_ON_ENFORCE_ERROR)
+			return -EPERM;
+		for (i = 0; i < ccs_check_flags(CCS_SLEEP_PERIOD); i++) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(HZ / 10);
 		}
 		return -EPERM;
 	}
 	va_start(args, fmt);
 	len = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 32;
 	va_end(args);
-	if ((query_entry = ccs_alloc(sizeof(*query_entry))) == NULL ||
-		(query_entry->query = ccs_alloc(len)) == NULL) goto out;
+	query_entry = ccs_alloc(sizeof(*query_entry));
+	if (!query_entry)
+		goto out;
+	query_entry->query = ccs_alloc(len);
+	if (!query_entry->query)
+		goto out;
 	INIT_LIST_HEAD(&query_entry->list);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&query_lock);
 	query_entry->serial = serial++;
 	spin_unlock(&query_lock);
 	/***** CRITICAL SECTION END *****/
-	pos = snprintf(query_entry->query, len - 1, "Q%u\n", query_entry->serial);
+	pos = snprintf(query_entry->query, len - 1, "Q%u\n",
+		       query_entry->serial);
 	va_start(args, fmt);
 	vsnprintf(query_entry->query + pos, len - 1 - pos, fmt, args);
 	query_entry->query_len = strlen(query_entry->query) + 1;
@@ -1485,15 +2380,18 @@
 	list_add_tail(&query_entry->list, &query_list);
 	spin_unlock(&query_lock);
 	/***** CRITICAL SECTION END *****/
-	UpdateCounter(CCS_UPDATES_COUNTER_QUERY);
+	ccs_update_counter(CCS_UPDATES_COUNTER_QUERY);
 	/* Give 10 seconds for supervisor's opinion. */
-	for (query_entry->timer = 0; atomic_read(&queryd_watcher) && CheckCCSFlags(CCS_ALLOW_ENFORCE_GRACE) && query_entry->timer < 100; query_entry->timer++) {
+	for (query_entry->timer = 0; atomic_read(&queryd_watcher)
+		     && ccs_check_flags(CCS_ALLOW_ENFORCE_GRACE)
+		     && query_entry->timer < 100; query_entry->timer++) {
 		wake_up(&query_wait);
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ / 10);
-		if (query_entry->answer) break;
+		if (query_entry->answer)
+			break;
 	}
-	UpdateCounter(CCS_UPDATES_COUNTER_QUERY);
+	ccs_update_counter(CCS_UPDATES_COUNTER_QUERY);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&query_lock);
 	list_del(&query_entry->list);
@@ -1511,13 +2409,24 @@
 		/* Rejected by administrator. */
 		break;
 	}
- out: ;
-	if (query_entry) ccs_free(query_entry->query);
+ out:
+	if (query_entry)
+		ccs_free(query_entry->query);
 	ccs_free(query_entry);
 	return error;
 }
 
-static int PollQuery(struct file *file, poll_table *wait)
+/**
+ * poll_query - poll() for /proc/ccs/query .
+ *
+ * @file: Pointer to "struct file".
+ * @wait: Pointer to "poll_table".
+ *
+ * Returns POLLIN | POLLRDNORM when ready to read, 0 otherwise.
+ *
+ * Waits for access requests which violated policy in enforcing mode.
+ */
+static int poll_query(struct file *file, poll_table *wait)
 {
 	bool found;
 	/***** CRITICAL SECTION START *****/
@@ -1525,31 +2434,43 @@
 	found = !list_empty(&query_list);
 	spin_unlock(&query_lock);
 	/***** CRITICAL SECTION END *****/
-	if (found) return POLLIN | POLLRDNORM;
+	if (found)
+		return POLLIN | POLLRDNORM;
 	poll_wait(file, &query_wait, wait);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&query_lock);
 	found = !list_empty(&query_list);
 	spin_unlock(&query_lock);
 	/***** CRITICAL SECTION END *****/
-	if (found) return POLLIN | POLLRDNORM;
+	if (found)
+		return POLLIN | POLLRDNORM;
 	return 0;
 }
 
-static int ReadQuery(struct io_buffer *head)
+/**
+ * read_query - Read access requests which violated policy in enforcing mode.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0.
+ */
+static int read_query(struct ccs_io_buffer *head)
 {
 	struct list_head *tmp;
 	int pos = 0, len = 0;
 	char *buf;
-	if (head->read_avail) return 0;
+	if (head->read_avail)
+		return 0;
 	if (head->read_buf) {
-		ccs_free(head->read_buf); head->read_buf = NULL;
+		ccs_free(head->read_buf);
+		head->read_buf = NULL;
 		head->readbuf_size = 0;
 	}
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&query_lock);
 	list_for_each(tmp, &query_list) {
-		struct query_entry *ptr = list_entry(tmp, struct query_entry, list);
+		struct query_entry *ptr
+			= list_entry(tmp, struct query_entry, list);
 		if (pos++ == head->read_step) {
 			len = ptr->query_len;
 			break;
@@ -1561,22 +2482,29 @@
 		head->read_step = 0;
 		return 0;
 	}
-	if ((buf = ccs_alloc(len)) != NULL) {
+	buf = ccs_alloc(len);
+	if (buf) {
 		pos = 0;
 		/***** CRITICAL SECTION START *****/
 		spin_lock(&query_lock);
 		list_for_each(tmp, &query_list) {
-			struct query_entry *ptr = list_entry(tmp, struct query_entry, list);
+			struct query_entry *ptr
+				= list_entry(tmp, struct query_entry, list);
 			if (pos++ == head->read_step) {
-				/* Some query can be skiipped since query_list can change, but I don't care. */
-				if (len == ptr->query_len) memmove(buf, ptr->query, len);
+				/*
+				 * Some query can be skipped because query_list
+				 * can change, but I don't care.
+				 */
+				if (len == ptr->query_len)
+					memmove(buf, ptr->query, len);
 				break;
 			}
 		}
 		spin_unlock(&query_lock);
 		/***** CRITICAL SECTION END *****/
 		if (buf[0]) {
-			head->readbuf_size = head->read_avail = len;
+			head->read_avail = len;
+			head->readbuf_size = head->read_avail;
 			head->read_buf = buf;
 			head->read_step++;
 		} else {
@@ -1586,7 +2514,14 @@
 	return 0;
 }
 
-static int WriteAnswer(struct io_buffer *head)
+/**
+ * write_answer - Write the supervisor's decision.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, -EINVAL otherwise.
+ */
+static int write_answer(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
 	struct list_head *tmp;
@@ -1594,18 +2529,23 @@
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&query_lock);
 	list_for_each(tmp, &query_list) {
-		struct query_entry *ptr = list_entry(tmp, struct query_entry, list);
+		struct query_entry *ptr
+			= list_entry(tmp, struct query_entry, list);
 		ptr->timer = 0;
 	}
 	spin_unlock(&query_lock);
 	/***** CRITICAL SECTION END *****/
-	if (sscanf(data, "A%u=%u", &serial, &answer) != 2) return -EINVAL;
+	if (sscanf(data, "A%u=%u", &serial, &answer) != 2)
+		return -EINVAL;
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&query_lock);
 	list_for_each(tmp, &query_list) {
-		struct query_entry *ptr = list_entry(tmp, struct query_entry, list);
-		if (ptr->serial != serial) continue;
-		if (!ptr->answer) ptr->answer = answer;
+		struct query_entry *ptr
+			= list_entry(tmp, struct query_entry, list);
+		if (ptr->serial != serial)
+			continue;
+		if (!ptr->answer)
+			ptr->answer = answer;
 		break;
 	}
 	spin_unlock(&query_lock);
@@ -1613,22 +2553,37 @@
 	return 0;
 }
 
-/*************************  /proc INTERFACE HANDLER  *************************/
-
 /* Policy updates counter. */
 static unsigned int updates_counter[MAX_CCS_UPDATES_COUNTER];
-static spinlock_t updates_counter_lock = SPIN_LOCK_UNLOCKED;
 
-void UpdateCounter(const unsigned char index)
+/* Policy updates counter lock. */
+static DEFINE_SPINLOCK(updates_counter_lock);
+
+/**
+ * ccs_update_counter - Increment policy change counter.
+ *
+ * @index: Type of policy.
+ *
+ * Returns nothing.
+ */
+void ccs_update_counter(const unsigned char index)
 {
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&updates_counter_lock);
-	if (index < MAX_CCS_UPDATES_COUNTER) updates_counter[index]++;
+	if (index < MAX_CCS_UPDATES_COUNTER)
+		updates_counter[index]++;
 	spin_unlock(&updates_counter_lock);
 	/***** CRITICAL SECTION END *****/
 }
 
-static int ReadUpdatesCounter(struct io_buffer *head)
+/**
+ * read_updates_counter - Check for policy change counter.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns how many times policy has changed since the previous check.
+ */
+static int read_updates_counter(struct ccs_io_buffer *head)
 {
 	if (!head->read_eof) {
 		unsigned int counter[MAX_CCS_UPDATES_COUNTER];
@@ -1638,187 +2593,292 @@
 		memset(updates_counter, 0, sizeof(updates_counter));
 		spin_unlock(&updates_counter_lock);
 		/***** CRITICAL SECTION END *****/
-		io_printf(head,
-				  "/proc/ccs/system_policy:    %10u\n"
-				  "/proc/ccs/domain_policy:    %10u\n"
-				  "/proc/ccs/exception_policy: %10u\n"
-				  "/proc/ccs/profile:          %10u\n"
-				  "/proc/ccs/query:            %10u\n"
-				  "/proc/ccs/manager:          %10u\n"
-				  "/proc/ccs/grant_log:        %10u\n"
-				  "/proc/ccs/reject_log:       %10u\n",
-				  counter[CCS_UPDATES_COUNTER_SYSTEM_POLICY],
-				  counter[CCS_UPDATES_COUNTER_DOMAIN_POLICY],
-				  counter[CCS_UPDATES_COUNTER_EXCEPTION_POLICY],
-				  counter[CCS_UPDATES_COUNTER_PROFILE],
-				  counter[CCS_UPDATES_COUNTER_QUERY],
-				  counter[CCS_UPDATES_COUNTER_MANAGER],
-				  counter[CCS_UPDATES_COUNTER_GRANT_LOG],
-				  counter[CCS_UPDATES_COUNTER_REJECT_LOG]);
+		ccs_io_printf(head,
+			      "/proc/ccs/system_policy:    %10u\n"
+			      "/proc/ccs/domain_policy:    %10u\n"
+			      "/proc/ccs/exception_policy: %10u\n"
+			      "/proc/ccs/profile:          %10u\n"
+			      "/proc/ccs/query:            %10u\n"
+			      "/proc/ccs/manager:          %10u\n"
+			      "/proc/ccs/grant_log:        %10u\n"
+			      "/proc/ccs/reject_log:       %10u\n",
+			      counter[CCS_UPDATES_COUNTER_SYSTEM_POLICY],
+			      counter[CCS_UPDATES_COUNTER_DOMAIN_POLICY],
+			      counter[CCS_UPDATES_COUNTER_EXCEPTION_POLICY],
+			      counter[CCS_UPDATES_COUNTER_PROFILE],
+			      counter[CCS_UPDATES_COUNTER_QUERY],
+			      counter[CCS_UPDATES_COUNTER_MANAGER],
+			      counter[CCS_UPDATES_COUNTER_GRANT_LOG],
+			      counter[CCS_UPDATES_COUNTER_REJECT_LOG]);
 		head->read_eof = true;
 	}
 	return 0;
 }
 
-static int ReadVersion(struct io_buffer *head)
+/**
+ * read_version: Get version.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns version information.
+ */
+static int read_version(struct ccs_io_buffer *head)
 {
 	if (!head->read_eof) {
-		if (io_printf(head, "1.6.0-pre") == 0) head->read_eof = true;
+		ccs_io_printf(head, "1.6.0-pre");
+		head->read_eof = true;
 	}
 	return 0;
 }
 
-static int ReadMemoryCounter(struct io_buffer *head)
+/**
+ * read_memory_counter - Check for memory usage.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns memory usage.
+ */
+static int read_memory_counter(struct ccs_io_buffer *head)
 {
 	if (!head->read_eof) {
-		const int shared = GetMemoryUsedForSaveName(), private = GetMemoryUsedForElements(), dynamic = GetMemoryUsedForDynamic();
-		if (io_printf(head, "Shared:  %10u\nPrivate: %10u\nDynamic: %10u\nTotal:   %10u\n", shared, private, dynamic, shared + private + dynamic) == 0) head->read_eof = true;
+		const int shared = ccs_get_memory_used_for_save_name(),
+			private = ccs_get_memory_used_for_elements(),
+			dynamic = ccs_get_memory_used_for_dynamic();
+		ccs_io_printf(head, "Shared:  %10u\nPrivate: %10u\n"
+			      "Dynamic: %10u\nTotal:   %10u\n",
+			      shared, private, dynamic,
+			      shared + private + dynamic);
+		head->read_eof = true;
 	}
 	return 0;
 }
 
-static int ReadSelfDomain(struct io_buffer *head)
+/**
+ * read_self_domain - Get the current process's domainname.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns the current process's domainname.
+ */
+static int read_self_domain(struct ccs_io_buffer *head)
 {
 	if (!head->read_eof) {
-		io_printf(head, "%s", current->domain_info->domainname->name);
+		/*
+		 * current->domain_info->domainname != NULL
+		 * because every process belongs to a domain and
+		 * the domain's name cannot be NULL.
+		 */
+		ccs_io_printf(head, "%s",
+			      current->domain_info->domainname->name);
 		head->read_eof = true;
 	}
 	return 0;
 }
 
-int CCS_OpenControl(const u8 type, struct file *file)
+/**
+ * ccs_open_control - open() for /proc/ccs/ interface.
+ *
+ * @type: Type of interface.
+ * @file: Pointer to "struct file".
+ *
+ * Associates policy handler and returns 0 on success, -ENOMEM otherwise.
+ */
+int ccs_open_control(const u8 type, struct file *file)
 {
-	struct io_buffer *head = ccs_alloc(sizeof(*head));
-	if (!head) return -ENOMEM;
+	struct ccs_io_buffer *head = ccs_alloc(sizeof(*head));
+	if (!head)
+		return -ENOMEM;
 	mutex_init(&head->read_sem);
 	mutex_init(&head->write_sem);
 	switch (type) {
 #ifdef CONFIG_SAKURA
-	case CCS_SYSTEMPOLICY:
-		head->write = AddSystemPolicy;
-		head->read = ReadSystemPolicy;
+	case CCS_SYSTEMPOLICY: /* /proc/ccs/system_policy */
+		head->write = write_system_policy;
+		head->read = read_system_policy;
 		break;
 #endif
 #ifdef CONFIG_TOMOYO
-	case CCS_DOMAINPOLICY:
-		head->write = AddDomainPolicy;
-		head->read = ReadDomainPolicy;
+	case CCS_DOMAINPOLICY: /* /proc/ccs/domain_policy */
+		head->write = write_domain_policy;
+		head->read = read_domain_policy;
 		break;
-	case CCS_EXCEPTIONPOLICY:
-		head->write = AddExceptionPolicy;
-		head->read = ReadExceptionPolicy;
+	case CCS_EXCEPTIONPOLICY: /* /proc/ccs/exception_policy */
+		head->write = write_exception_policy;
+		head->read = read_exception_policy;
 		break;
-	case CCS_GRANTLOG:
-		head->poll = PollGrantLog;
-		head->read = ReadGrantLog;
+	case CCS_GRANTLOG: /* /proc/ccs/grant_log */
+		head->poll = ccs_poll_grant_log;
+		head->read = ccs_read_grant_log;
 		break;
-	case CCS_REJECTLOG:
-		head->poll = PollRejectLog;
-		head->read = ReadRejectLog;
+	case CCS_REJECTLOG: /* /proc/ccs/reject_log */
+		head->poll = ccs_poll_reject_log;
+		head->read = ccs_read_reject_log;
 		break;
 #endif
-	case CCS_SELFDOMAIN:
-		head->read = ReadSelfDomain;
+	case CCS_SELFDOMAIN: /* /proc/ccs/self_domain */
+		head->read = read_self_domain;
 		break;
-	case CCS_DOMAIN_STATUS:
-		head->write = UpdateDomainProfile;
-		head->read = ReadDomainProfile;
+	case CCS_DOMAIN_STATUS: /* /proc/ccs/.domain_status */
+		head->write = write_domain_profile;
+		head->read = read_domain_profile;
 		break;
-	case CCS_PROCESS_STATUS:
-		head->write = WritePID;
-		head->read = ReadPID;
+	case CCS_PROCESS_STATUS: /* /proc/ccs/.process_status */
+		head->write = write_pid;
+		head->read = read_pid;
 		break;
-	case CCS_VERSION:
-		head->read = ReadVersion;
+	case CCS_VERSION: /* /proc/ccs/version */
+		head->read = read_version;
 		head->readbuf_size = 128;
 		break;
-	case CCS_MEMINFO:
-		head->read = ReadMemoryCounter;
+	case CCS_MEMINFO: /* /proc/ccs/meminfo */
+		head->read = read_memory_counter;
 		head->readbuf_size = 128;
 		break;
-	case CCS_PROFILE:
-		head->write = SetProfile;
-		head->read = ReadProfile;
+	case CCS_PROFILE: /* /proc/ccs/profile */
+		head->write = write_profile;
+		head->read = read_profile;
 		break;
-	case CCS_QUERY:
-		head->poll = PollQuery;
-		head->write = WriteAnswer;
-		head->read = ReadQuery;
+	case CCS_QUERY: /* /proc/ccs/query */
+		head->poll = poll_query;
+		head->write = write_answer;
+		head->read = read_query;
 		break;
-	case CCS_MANAGER:
-		head->write = AddManagerPolicy;
-		head->read = ReadManagerPolicy;
+	case CCS_MANAGER: /* /proc/ccs/manager */
+		head->write = write_manager_policy;
+		head->read = read_manager_policy;
 		break;
-	case CCS_UPDATESCOUNTER:
-		head->read = ReadUpdatesCounter;
+	case CCS_UPDATESCOUNTER: /* /proc/ccs/.updates_counter */
+		head->read = read_updates_counter;
 		break;
 	}
-	if (type != CCS_GRANTLOG && type != CCS_REJECTLOG && type != CCS_QUERY) {
-		if (!head->readbuf_size) head->readbuf_size = 4096 * 2;
-		if ((head->read_buf = ccs_alloc(head->readbuf_size)) == NULL) {
+	/*
+	 * Don't allocate buffer for reading if the file is one of
+	 * /proc/ccs/grant_log , /proc/ccs/reject_log , /proc/ccs/query .
+	 */
+	if (type != CCS_GRANTLOG && type != CCS_REJECTLOG
+	    && type != CCS_QUERY) {
+		if (!head->readbuf_size)
+			head->readbuf_size = 4096 * 2;
+		head->read_buf = ccs_alloc(head->readbuf_size);
+		if (!head->read_buf) {
 			ccs_free(head);
 			return -ENOMEM;
 		}
 	}
 	if (head->write) {
 		head->writebuf_size = 4096 * 2;
-		if ((head->write_buf = ccs_alloc(head->writebuf_size)) == NULL) {
+		head->write_buf = ccs_alloc(head->writebuf_size);
+		if (!head->write_buf) {
 			ccs_free(head->read_buf);
 			ccs_free(head);
 			return -ENOMEM;
 		}
 	}
 	file->private_data = head;
-	if (type == CCS_SELFDOMAIN) CCS_ReadControl(file, NULL, 0);
-	else if (head->write == WriteAnswer) atomic_inc(&queryd_watcher);
+	/*
+	 * Call the handler now if the file is /proc/ccs/self_domain
+	 * so that the user can use "cat < /proc/ccs/self_domain" to
+	 * know the current process's domainname.
+	 */
+	if (type == CCS_SELFDOMAIN)
+		ccs_read_control(file, NULL, 0);
+	/*
+	 * If the file is /proc/ccs/query , increment the monitor count.
+	 * The monitor count is used by ccs_check_supervisor() to see if
+	 * there is some process monitoring /proc/ccs/query .
+	 */
+	else if (head->write == write_answer)
+		atomic_inc(&queryd_watcher);
 	return 0;
 }
 
-static int CopyToUser(struct io_buffer *head, char __user * buffer, int buffer_len)
+/**
+ * ccs_poll_control - poll() for /proc/ccs/ interface.
+ *
+ * @file: Pointer to "struct file".
+ * @wait: Pointer to "poll_table".
+ *
+ * Waits for read readiness.
+ * /proc/ccs/query is handled by /usr/lib/ccs/ccs-queryd and
+ * /proc/ccs/grant_log and /proc/ccs/reject_log are handled by
+ * /usr/lib/ccs/ccs-auditd .
+ */
+int ccs_poll_control(struct file *file, poll_table *wait)
 {
-	int len = head->read_avail;
-	char *cp = head->read_buf;
-	if (len > buffer_len) len = buffer_len;
-	if (len) {
-		if (copy_to_user(buffer, cp, len)) return -EFAULT;
-		head->read_avail -= len;
-		memmove(cp, cp + len, head->read_avail);
-	}
-	return len;
-}
-
-int CCS_PollControl(struct file *file, poll_table *wait)
-{
-	struct io_buffer *head = file->private_data;
-	if (!head->poll) return -ENOSYS;
+	struct ccs_io_buffer *head = file->private_data;
+	if (!head->poll)
+		return -ENOSYS;
 	return head->poll(file, wait);
 }
 
-int CCS_ReadControl(struct file *file, char __user *buffer, const int buffer_len)
+/**
+ * ccs_read_control - read() for /proc/ccs/ interface.
+ *
+ * @file:       Pointer to "struct file".
+ * @buffer:     Poiner to buffer to write to.
+ * @buffer_len: Size of @buffer.
+ *
+ * Returns bytes read on success, negative value otherwise.
+ */
+int ccs_read_control(struct file *file, char __user *buffer,
+		     const int buffer_len)
 {
 	int len = 0;
-	struct io_buffer *head = file->private_data;
-	if (!head->read) return -ENOSYS;
-	if (!access_ok(VERIFY_WRITE, buffer, buffer_len)) return -EFAULT;
-	if (mutex_lock_interruptible(&head->read_sem)) return -EINTR;
+	struct ccs_io_buffer *head = file->private_data;
+	char * const cp = head->read_buf;
+	if (!head->read)
+		return -ENOSYS;
+	if (!access_ok(VERIFY_WRITE, buffer, buffer_len))
+		return -EFAULT;
+	if (mutex_lock_interruptible(&head->read_sem))
+		return -EINTR;
+	/* Call the policy handler. */
 	len = head->read(head);
-	if (len >= 0) len = CopyToUser(head, buffer, buffer_len);
+	if (len < 0)
+		goto out;
+	/* Write to buffer. */
+	len = head->read_avail;
+	if (len > buffer_len)
+		len = buffer_len;
+	if (!len)
+		goto out;
+	if (copy_to_user(buffer, cp, len)) {
+		len = -EFAULT;
+		goto out;
+	}
+	head->read_avail -= len;
+	memmove(cp, cp + len, head->read_avail);
+ out:
 	mutex_unlock(&head->read_sem);
 	return len;
 }
 
-int CCS_WriteControl(struct file *file, const char __user *buffer, const int buffer_len)
+/**
+ * ccs_write_control - write() for /proc/ccs/ interface.
+ *
+ * @file:       Pointer to "struct file".
+ * @buffer:     Pointer to buffer to read from.
+ * @buffer_len: Size of @buffer.
+ *
+ * Returns @buffer_len on success, negative value otherwise.
+ */
+int ccs_write_control(struct file *file, const char __user *buffer,
+		      const int buffer_len)
 {
-	struct io_buffer *head = file->private_data;
+	struct ccs_io_buffer *head = file->private_data;
 	int error = buffer_len;
 	int avail_len = buffer_len;
 	char *cp0 = head->write_buf;
-	if (!head->write) return -ENOSYS;
-	if (!access_ok(VERIFY_READ, buffer, buffer_len)) return -EFAULT;
-	if (head->write != WritePID && !IsPolicyManager()) {
-		return -EPERM; /* Forbid updating policies for non manager programs. */
-	}
-	if (mutex_lock_interruptible(&head->write_sem)) return -EINTR;
+	if (!head->write)
+		return -ENOSYS;
+	if (!access_ok(VERIFY_READ, buffer, buffer_len))
+		return -EFAULT;
+	/* Don't allow updating policies by non manager programs. */
+	if (head->write != write_pid && !is_policy_manager())
+		return -EPERM;
+	if (mutex_lock_interruptible(&head->write_sem))
+		return -EINTR;
+	/* Read a line and dispatch it to the policy handler. */
 	while (avail_len > 0) {
 		char c;
 		if (head->write_avail >= head->writebuf_size - 1) {
@@ -1828,32 +2888,69 @@
 			error = -EFAULT;
 			break;
 		}
-		buffer++; avail_len--;
+		buffer++;
+		avail_len--;
 		cp0[head->write_avail++] = c;
-		if (c != '\n') continue;
+		if (c != '\n')
+			continue;
 		cp0[head->write_avail - 1] = '\0';
 		head->write_avail = 0;
-		NormalizeLine(cp0);
+		normalize_line(cp0);
 		head->write(head);
 	}
 	mutex_unlock(&head->write_sem);
 	return error;
 }
 
-
-int CCS_CloseControl(struct file *file)
+/**
+ * ccs_close_control - close() for /proc/ccs/ interface.
+ *
+ * @file: Pointer to "struct file".
+ *
+ * Releases memory and returns 0.
+ */
+int ccs_close_control(struct file *file)
 {
-	struct io_buffer *head = file->private_data;
-	if (head->write == WriteAnswer) atomic_dec(&queryd_watcher);
-	else if (head->read == ReadMemoryCounter) profile_loaded = true;
-	ccs_free(head->read_buf); head->read_buf = NULL;
-	ccs_free(head->write_buf); head->write_buf = NULL;
-	ccs_free(head); head = NULL;
+	struct ccs_io_buffer *head = file->private_data;
+	/*
+	 * If the file is /proc/ccs/query , decrement the monitor count.
+	 */
+	if (head->write == write_answer)
+		atomic_dec(&queryd_watcher);
+	/*
+	 * If the file is /proc/ccs/meminfo , regard policy loading by
+	 * the policy loader executed from ccs_load_policy() has finished.
+	 * This hack is needed because 2.4 kernel's call_usermodehelper()
+	 * returns before the executed program terminates in some situations.
+	 * Thus, I'm using the close() request of /proc/ccs/meminfo as
+	 * the trigger rather than complicating the code to wait for
+	 * termination of the policy loader.
+	 * So, the policy loader must open and close /proc/ccs/meminfo
+	 * when loading policy has finished.
+	 */
+	else if (head->read == read_memory_counter)
+		profile_loaded = true;
+	/* Release memory used for policy I/O. */
+	ccs_free(head->read_buf);
+	head->read_buf = NULL;
+	ccs_free(head->write_buf);
+	head->write_buf = NULL;
+	ccs_free(head);
+	head = NULL;
 	file->private_data = NULL;
 	return 0;
 }
 
-void *alloc_acl_element(const u8 acl_type, const struct condition_list *condition)
+/**
+ * ccs_alloc_acl_element - Allocate permanent memory for ACL entry.
+ *
+ * @acl_type:  Type of ACL entry.
+ * @condition: Pointer to condition part of the ACL entry. May be NULL.
+ *
+ * Returns pointer to the ACL entry on success, NULL otherwise.
+ */
+void *ccs_alloc_acl_element(const u8 acl_type,
+			    const struct condition_list *condition)
 {
 	int len;
 	struct acl_info *ptr;
@@ -1886,20 +2983,40 @@
 	default:
 		return NULL;
 	}
-	if (!condition) len -= sizeof(ptr->cond);
-	ptr = alloc_element(len);
-	if (!ptr) return NULL;
+	/*
+	 * If the ACL doesn't have condition part, reduce memory usage
+	 * by eliminating sizeof(struct condition_list *) .
+	 */
+	if (!condition)
+		len -= sizeof(ptr->access_me_via_ccs_get_condition_part);
+	ptr = ccs_alloc_element(len);
+	if (!ptr)
+		return NULL;
 	if (condition) {
-		ptr->cond = condition;
+		ptr->access_me_via_ccs_get_condition_part = condition;
 		ptr->type = acl_type | ACL_WITH_CONDITION;
 		return ptr;
 	}
-	ptr = (void *) (((u8 *) ptr) - sizeof(ptr->cond));
+	/*
+	 * Substract sizeof(struct condition_list *) because I eliminated
+	 * sizeof(struct condition_list *) from "struct acl_info"
+	 * but I must return the start address of "struct acl_info".
+	 */
+	ptr = (void *) (((u8 *) ptr)
+			- sizeof(ptr->access_me_via_ccs_get_condition_part));
 	ptr->type = acl_type;
 	return ptr;
 }
 
-const struct condition_list *GetConditionPart(const struct acl_info *acl)
+/**
+ * ccs_get_condition_part - Get condition part of the given ACL entry.
+ *
+ * @acl: Pointer to "struct acl_info". Pointer to an ACL entry.
+ *
+ * Returns pointer to the condition part if the ACL has it, NULL otherwise.
+ */
+const struct condition_list *ccs_get_condition_part(const struct acl_info *acl)
 {
-	return (acl->type & ACL_WITH_CONDITION) ? acl->cond : NULL;
+	return (acl->type & ACL_WITH_CONDITION) ?
+		acl->access_me_via_ccs_get_condition_part : NULL;
 }
Index: trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(working copy)
@@ -23,47 +23,115 @@
 
 #if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,23)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 23)
+/**
+ * PDE - Get "struct proc_dir_entry".
+ *
+ * @inode: Pointer to "struct inode".
+ *
+ * Returns pointer to "struct proc_dir_entry"
+ *
+ * This is for compatibility with older kernels.
+ */
 static inline struct proc_dir_entry *PDE(const struct inode *inode)
 {
 	return (struct proc_dir_entry *) inode->u.generic_ip;
 }
 #endif
 
+/**
+ * ccs_open - open() for /proc/ccs/ interface.
+ *
+ * @inode: Pointer to "struct inode".
+ * @file:  Pointer to "struct file".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
 static int ccs_open(struct inode *inode, struct file *file)
 {
-	return CCS_OpenControl(((u8 *) PDE(inode)->data) - ((u8 *) NULL), file);
+	return ccs_open_control(((u8 *) PDE(inode)->data) - ((u8 *) NULL),
+				file);
 }
 
+/**
+ * ccs_release - close() for /proc/ccs/ interface.
+ *
+ * @inode: Pointer to "struct inode".
+ * @file:  Pointer to "struct file".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
 static int ccs_release(struct inode *inode, struct file *file)
 {
-	return CCS_CloseControl(file);
+	return ccs_close_control(file);
 }
 
+/**
+ * ccs_poll - poll() for /proc/ccs/ interface.
+ *
+ * @file:       Pointer to "struct file".
+ * @poll_table: Pointer to "poll_table".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
 static unsigned int ccs_poll(struct file *file, poll_table *wait)
 {
-	return CCS_PollControl(file, wait);
+	return ccs_poll_control(file, wait);
 }
 
-static ssize_t ccs_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+/**
+ * ccs_read - read() for /proc/ccs/ interface.
+ *
+ * @file:  Pointer to "struct file".
+ * @buf:   Pointer to buffer.
+ * @count: Size of @buf.
+ * @ppos:  Unused.
+ *
+ * Returns bytes read on success, negative value otherwise.
+ */
+static ssize_t ccs_read(struct file *file, char __user *buf, size_t count,
+			loff_t *ppos)
 {
-	return CCS_ReadControl(file, buf, count);
+	return ccs_read_control(file, buf, count);
 }
 
-static ssize_t ccs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+/**
+ * ccs_write - write() for /proc/ccs/ interface.
+ *
+ * @file:  Pointer to "struct file".
+ * @buf:   Pointer to buffer.
+ * @count: Size of @buf.
+ * @ppos:  Unused.
+ *
+ * Returns @count on success, negative value otherwise.
+ */
+static ssize_t ccs_write(struct file *file, const char __user *buf,
+			 size_t count, loff_t *ppos)
 {
-	return CCS_WriteControl(file, buf, count);
+	return ccs_write_control(file, buf, count);
 }
 
+/* Operations for /proc/ccs/interface. */
 static struct file_operations ccs_operations = {
-	open:    ccs_open,
-	release: ccs_release,
-	poll:    ccs_poll,
-	read:    ccs_read,
-	write:   ccs_write
+	.open    = ccs_open,
+	.release = ccs_release,
+	.poll    = ccs_poll,
+	.read    = ccs_read,
+	.write   = ccs_write,
 };
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+/**
+ * proc_notify_change - Update inode's attributes and reflect to the dentry.
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * The 2.4 kernels don't allow chmod()/chown() for files in /proc ,
+ * while the 2.6 kernels allow.
+ * To permit management of /proc/ccs/ interface by non-root user,
+ * I modified to allow chmod()/chown() of /proc/ccs/ interface like 2.6 kernels
+ * by adding "struct inode_operations"->setattr hook.
+ */
 static int proc_notify_change(struct dentry *dentry, struct iattr *iattr)
 {
 	struct inode *inode = dentry->d_inode;
@@ -77,60 +145,84 @@
 	error = inode_setattr(inode, iattr);
 	if (error)
 		goto out;
-	
+
 	de->uid = inode->i_uid;
 	de->gid = inode->i_gid;
 	de->mode = inode->i_mode;
-out:
+ out:
 	return error;
 }
 
+/* The inode operations for /proc/ccs/ directory. */
 static struct inode_operations ccs_dir_inode_operations;
+
+/* The inode operations for files under /proc/ccs/ directory. */
 static struct inode_operations ccs_file_inode_operations;
 #endif
 
-static __init void CreateEntry(const char *name, const mode_t mode, struct proc_dir_entry *parent, const u8 key)
+/**
+ * create_entry - Create interface files under /proc/ccs/ directory.
+ *
+ * @name:   The name of the interface file.
+ * @mode:   The permission of the interface file.
+ * @parent: The parent directory.
+ * @key:    Type of interface.
+ *
+ * Returns nothing.
+ */
+static __init void create_entry(const char *name, const mode_t mode,
+				struct proc_dir_entry *parent, const u8 key)
 {
 	struct proc_dir_entry *entry = create_proc_entry(name, mode, parent);
 	if (entry) {
 		entry->proc_fops = &ccs_operations;
 		entry->data = ((u8 *) NULL) + key;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		if (entry->proc_iops) ccs_file_inode_operations = *entry->proc_iops;
-		if (!ccs_file_inode_operations.setattr) ccs_file_inode_operations.setattr = proc_notify_change;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+		if (entry->proc_iops)
+			ccs_file_inode_operations = *entry->proc_iops;
+		if (!ccs_file_inode_operations.setattr)
+			ccs_file_inode_operations.setattr = proc_notify_change;
 		entry->proc_iops = &ccs_file_inode_operations;
 #endif
 	}
 }
 
+/**
+ * CCSProc_Init - Initialize /proc/ccs/ interface.
+ *
+ * Returns nothing.
+ */
 void __init CCSProc_Init(void)
 {
 	struct proc_dir_entry *ccs_dir = proc_mkdir("ccs", NULL);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if (ccs_dir->proc_iops) ccs_dir_inode_operations = *ccs_dir->proc_iops;
-	if (!ccs_dir_inode_operations.setattr) ccs_dir_inode_operations.setattr = proc_notify_change;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (ccs_dir->proc_iops)
+		ccs_dir_inode_operations = *ccs_dir->proc_iops;
+	if (!ccs_dir_inode_operations.setattr)
+		ccs_dir_inode_operations.setattr = proc_notify_change;
 	ccs_dir->proc_iops = &ccs_dir_inode_operations;
 #endif
-	realpath_Init();
-	CreateEntry("query",            0600, ccs_dir, CCS_QUERY);
+	ccs_realpath_init();
+	create_entry("query",            0600, ccs_dir, CCS_QUERY);
 #ifdef CONFIG_SAKURA
-	CreateEntry("system_policy",    0600, ccs_dir, CCS_SYSTEMPOLICY);
+	create_entry("system_policy",    0600, ccs_dir, CCS_SYSTEMPOLICY);
 #endif
 #ifdef CONFIG_TOMOYO
-	CreateEntry("domain_policy",    0600, ccs_dir, CCS_DOMAINPOLICY);
-	CreateEntry("exception_policy", 0600, ccs_dir, CCS_EXCEPTIONPOLICY);
-	CreateEntry("grant_log",        0400, ccs_dir, CCS_GRANTLOG);
-	CreateEntry("reject_log",       0400, ccs_dir, CCS_REJECTLOG);
+	create_entry("domain_policy",    0600, ccs_dir, CCS_DOMAINPOLICY);
+	create_entry("exception_policy", 0600, ccs_dir, CCS_EXCEPTIONPOLICY);
+	create_entry("grant_log",        0400, ccs_dir, CCS_GRANTLOG);
+	create_entry("reject_log",       0400, ccs_dir, CCS_REJECTLOG);
 #endif
-	CreateEntry("self_domain",      0400, ccs_dir, CCS_SELFDOMAIN);
-	CreateEntry(".domain_status",   0600, ccs_dir, CCS_DOMAIN_STATUS);
-	CreateEntry(".process_status",  0400, ccs_dir, CCS_PROCESS_STATUS);
-	CreateEntry("meminfo",          0400, ccs_dir, CCS_MEMINFO);
-	CreateEntry("profile",          0600, ccs_dir, CCS_PROFILE);
-	CreateEntry("manager",          0600, ccs_dir, CCS_MANAGER);
-	CreateEntry(".updates_counter", 0400, ccs_dir, CCS_UPDATESCOUNTER);
-	CreateEntry("version",          0400, ccs_dir, CCS_VERSION);
-	if (sizeof(struct ccs_page_buffer) <  CCS_MAX_PATHNAME_LEN - 16) panic("Bad size!");
+	create_entry("self_domain",      0400, ccs_dir, CCS_SELFDOMAIN);
+	create_entry(".domain_status",   0600, ccs_dir, CCS_DOMAIN_STATUS);
+	create_entry(".process_status",  0400, ccs_dir, CCS_PROCESS_STATUS);
+	create_entry("meminfo",          0400, ccs_dir, CCS_MEMINFO);
+	create_entry("profile",          0600, ccs_dir, CCS_PROFILE);
+	create_entry("manager",          0600, ccs_dir, CCS_MANAGER);
+	create_entry(".updates_counter", 0400, ccs_dir, CCS_UPDATESCOUNTER);
+	create_entry("version",          0400, ccs_dir, CCS_VERSION);
+	if (sizeof(struct ccs_page_buffer) <  CCS_MAX_PATHNAME_LEN - 16)
+		panic("Bad size!");
 }
 
 #else
Index: trunk/1.6.x/ccs-patch/fs/sakura_bind.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_bind.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/sakura_bind.c	(working copy)
@@ -11,26 +11,32 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** SAKURA Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
 
-/***** The structure for reserved ports. *****/
-
 struct reserved_entry {
 	struct list1_head list;
-	bool is_deleted;             /* Delete flag.                          */
-	u16 min_port;                /* Start of port number range.           */
-	u16 max_port;                /* End of port number range.             */
+	bool is_deleted;             /* Delete flag.                         */
+	u16 min_port;                /* Start of port number range.          */
+	u16 max_port;                /* End of port number range.            */
 };
 
-/*************************  NETWORK RESERVED ACL HANDLER  *************************/
-
+/* The list for "struct reserved_entry". */
 static LIST1_HEAD(reservedport_list);
 
-static int AddReservedEntry(const u16 min_port, const u16 max_port, const bool is_delete)
+/**
+ * update_reserved_entry -
+ *
+ * @min_port: Start of port number range.
+ * @max_port: End of port number range.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_reserved_entry(const u16 min_port, const u16 max_port,
+				 const bool is_delete)
 {
 	struct reserved_entry *new_entry, *ptr;
 	static DEFINE_MUTEX(lock);
@@ -47,7 +53,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->min_port = min_port;
 	new_entry->max_port = max_port;
 	list1_add_tail_mb(&new_entry->list, &reservedport_list);
@@ -57,46 +65,85 @@
 	return error;
 }
 
-int SAKURA_MayAutobind(const u16 port)
+/**
+ * ccs_may_autobind -
+ *
+ * @port: Port number.
+ *
+ * Returns 0 on success, -EPERM otherwise.
+ */
+int ccs_may_autobind(const u16 port)
 {
-	/* Must not sleep, for called inside spin_lock. */
+	/***** CRITICAL SECTION START *****/
 	struct reserved_entry *ptr;
-	if (!CheckCCSFlags_NoSleepCheck(CCS_SAKURA_RESTRICT_AUTOBIND)) return 0;
+	if (!ccs_check_flags_no_sleep_check(CCS_SAKURA_RESTRICT_AUTOBIND))
+		return 0;
 	list1_for_each_entry(ptr, &reservedport_list, list) {
-		if (ptr->min_port <= port && port <= ptr->max_port && !ptr->is_deleted) return -EPERM;
+		if (ptr->min_port <= port && port <= ptr->max_port &&
+		    !ptr->is_deleted)
+			return -EPERM;
 	}
 	return 0;
+	/***** CRITICAL SECTION END *****/
 }
-EXPORT_SYMBOL(SAKURA_MayAutobind);
+/* I need to export this for net/ipv4/ and net/ipv6/ */
+EXPORT_SYMBOL(ccs_may_autobind);
 
-int AddReservedPortPolicy(char *data, const bool is_delete)
+/**
+ * ccs_write_reserved_port_policy -
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_reserved_port_policy(char *data, const bool is_delete)
 {
 	unsigned int from, to;
-	if (strchr(data, ' ')) goto out;
+	if (strchr(data, ' '))
+		goto out;
 	if (sscanf(data, "%u-%u", &from, &to) == 2) {
-		if (from <= to && to < 65536) return AddReservedEntry(from, to, is_delete);
+		if (from <= to && to < 65536)
+			return update_reserved_entry(from, to, is_delete);
 	} else if (sscanf(data, "%u", &from) == 1) {
-		if (from < 65536) return AddReservedEntry(from, from, is_delete);
+		if (from < 65536)
+			return update_reserved_entry(from, from, is_delete);
 	}
  out:
-	printk("%s: ERROR: Invalid port range '%s'\n", __FUNCTION__, data);
+	printk(KERN_WARNING "%s: ERROR: Invalid port range '%s'\n",
+	       __func__, data);
 	return -EINVAL;
 }
 
-int ReadReservedPortPolicy(struct io_buffer *head)
+/**
+ * ccs_read_reserved_port_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
+	char buffer[16];
+	memset(buffer, 0, sizeof(buffer));
 	list1_for_each_cookie(pos, head->read_var2, &reservedport_list) {
+		u16 min_port, max_port;
 		struct reserved_entry *ptr;
 		ptr = list1_entry(pos, struct reserved_entry, list);
-		if (ptr->is_deleted) continue;
-		if (ptr->min_port != ptr->max_port) {
-			if (io_printf(head, KEYWORD_DENY_AUTOBIND "%u-%u\n", ptr->min_port, ptr->max_port)) return -ENOMEM;
-		} else {
-			if (io_printf(head, KEYWORD_DENY_AUTOBIND "%u\n", ptr->min_port)) return -ENOMEM;
-		}
+		if (ptr->is_deleted)
+			continue;
+		min_port = ptr->min_port;
+		max_port = ptr->max_port;
+		if (min_port != max_port)
+			snprintf(buffer, sizeof(buffer) - 1,
+				 "%u-%u", min_port, max_port);
+		else
+			snprintf(buffer, sizeof(buffer) - 1, "%u", min_port);
+		if (!ccs_io_printf(head, KEYWORD_DENY_AUTOBIND "%s\n", buffer))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
-
-/***** SAKURA Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c	(working copy)
@@ -11,73 +11,130 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** TOMOYO Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/tomoyo.h>
 #include <linux/realpath.h>
 #include <linux/version.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+
+/* To support PID namespace. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 #define find_task_by_pid find_task_by_vpid
 #endif
 
-/*************************  AUDIT FUNCTIONS  *************************/
+/* Auditing functions. */
 
-static int AuditSignalLog(const int signal, const struct path_info *dest_domain, const bool is_granted, const u8 profile, const u8 mode)
+/**
+ * audit_signal_log -
+ *
+ * @signal:      Signal number.
+ * @dest_domain: Destination domainname.
+ * @is_granted:  True if this is a granted log.
+ * @profile:     Profile number.
+ * @mode:        Access control mode.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int audit_signal_log(const int signal,
+			    const struct path_info *dest_domain,
+			    const bool is_granted, const u8 profile,
+			    const u8 mode)
 {
 	char *buf;
 	int len;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
+	if (ccs_can_save_audit_log(is_granted) < 0)
+		return -ENOMEM;
 	len = dest_domain->total_len;
-	if ((buf = InitAuditLog(&len, profile, mode, NULL)) == NULL) return -ENOMEM;
-	snprintf(buf + strlen(buf), len - strlen(buf) - 1, KEYWORD_ALLOW_SIGNAL "%d %s\n", signal, dest_domain->name);
-	return WriteAuditLog(buf, is_granted);
+	buf = ccs_init_audit_log(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
+	snprintf(buf + strlen(buf), len - strlen(buf) - 1,
+		 KEYWORD_ALLOW_SIGNAL "%d %s\n", signal, dest_domain->name);
+	return ccs_write_audit_log(buf, is_granted);
 }
 
-/*************************  SIGNAL ACL HANDLER  *************************/
+/* Signal ACL handler. */
 
-static int AddSignalEntry(const int sig, const char *dest_pattern, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * update_signal_acl -
+ *
+ * @sig:          Signal number.
+ * @dest_pattern: Destination domainname.
+ * @domain:       Pointer to "struct domain_info".
+ * @condition:    Pointer to "struct condition_list". May be NULL.
+ * @is_delete:    True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_signal_acl(const int sig, const char *dest_pattern,
+			     struct domain_info *domain,
+			     const struct condition_list *condition,
+			     const bool is_delete)
 {
 	struct acl_info *ptr;
 	struct signal_acl_record *acl;
 	const struct path_info *saved_dest_pattern;
 	const u16 hash = sig;
 	int error = -ENOMEM;
-	if (!domain) return -EINVAL;
-	if (!dest_pattern || !IsCorrectDomain(dest_pattern, __FUNCTION__)) return -EINVAL;
-	if ((saved_dest_pattern = SaveName(dest_pattern)) == NULL) return -ENOMEM;
+	if (!domain)
+		return -EINVAL;
+	if (!dest_pattern || !ccs_is_correct_domain(dest_pattern, __func__))
+		return -EINVAL;
+	saved_dest_pattern = ccs_save_name(dest_pattern);
+	if (!saved_dest_pattern)
+		return -ENOMEM;
 	mutex_lock(&domain_acl_lock);
-	if (!is_delete) {
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_SIGNAL_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct signal_acl_record, head);
-			if (acl->sig != hash || pathcmp(acl->domainname, saved_dest_pattern)) continue;
-			error = AddDomainACL(NULL, ptr);
-			goto out;
-		}
-		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_SIGNAL_ACL, condition)) == NULL) goto out;
-		acl->sig = hash;
-		acl->domainname = saved_dest_pattern;
-		error = AddDomainACL(domain, &acl->head);
-	} else {
-		error = -ENOENT;
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SIGNAL_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct signal_acl_record, head);
-			if (acl->sig != hash || pathcmp(acl->domainname, saved_dest_pattern)) continue;
-			error = DelDomainACL(ptr);
-			break;
-		}
+	if (is_delete)
+		goto delete;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION))
+		    != TYPE_SIGNAL_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct signal_acl_record, head);
+		if (acl->sig != hash ||
+		    ccs_pathcmp(acl->domainname, saved_dest_pattern))
+			continue;
+		error = ccs_add_domain_acl(NULL, ptr);
+		goto out;
 	}
- out: ;
+	/* Not found. Append it to the tail. */
+	acl = ccs_alloc_acl_element(TYPE_SIGNAL_ACL, condition);
+	if (!acl)
+		goto out;
+	acl->sig = hash;
+	acl->domainname = saved_dest_pattern;
+	error = ccs_add_domain_acl(domain, &acl->head);
+	goto out;
+ delete:
+	error = -ENOENT;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SIGNAL_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct signal_acl_record, head);
+		if (acl->sig != hash ||
+		    ccs_pathcmp(acl->domainname, saved_dest_pattern))
+			continue;
+		error = ccs_del_domain_acl(ptr);
+		break;
+	}
+ out:
 	mutex_unlock(&domain_acl_lock);
 	return error;
 }
 
-int CheckSignalACL(const int sig, const int pid)
+/**
+ * ccs_check_signal_acl -
+ *
+ * @sig: Signal number.
+ * @pid: Target's PID.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_signal_acl(const int sig, const int pid)
 {
 	struct domain_info *domain = current->domain_info;
 	struct domain_info *dest = NULL;
@@ -85,62 +142,92 @@
 	struct acl_info *ptr;
 	const u16 hash = sig;
 	const u8 profile = current->domain_info->profile;
-	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_SIGNAL);
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_SIGNAL);
 	const bool is_enforce = (mode == 3);
 	bool found = false;
-	if (!mode) return 0;
-	if (!sig) return 0;                               /* No check for NULL signal. */
+	if (!mode)
+		return 0;
+	if (!sig)
+		return 0;                /* No check for NULL signal. */
 	if (current->pid == pid) {
-		AuditSignalLog(sig, domain->domainname, 1, profile, mode);
+		audit_signal_log(sig, domain->domainname, 1, profile, mode);
 		return 0;                /* No check for self. */
 	}
 	{ /* Simplified checking. */
 		struct task_struct *p = NULL;
 		read_lock(&tasklist_lock);
-		if (pid > 0) p = find_task_by_pid((pid_t) pid);
-		else if (pid == 0) p = current;
-		else if (pid == -1) dest = &KERNEL_DOMAIN;
-		else p = find_task_by_pid((pid_t) -pid);
-		if (p) dest = p->domain_info;
+		if (pid > 0)
+			p = find_task_by_pid((pid_t) pid);
+		else if (pid == 0)
+			p = current;
+		else if (pid == -1)
+			dest = &KERNEL_DOMAIN;
+		else
+			p = find_task_by_pid((pid_t) -pid);
+		if (p)
+			dest = p->domain_info;
 		read_unlock(&tasklist_lock);
-		if (!dest) return 0; /* I can't find destinatioin. */
+		if (!dest)
+			return 0; /* I can't find destinatioin. */
 	}
 	if (domain == dest) {
-		AuditSignalLog(sig, dest->domainname, 1, profile, mode);
+		audit_signal_log(sig, dest->domainname, 1, profile, mode);
 		return 0;
 	}
 	dest_pattern = dest->domainname->name;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct signal_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SIGNAL_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SIGNAL_ACL)
+			continue;
 		acl = container_of(ptr, struct signal_acl_record, head);
-		if (acl->sig == hash && CheckCondition(ptr, NULL)) {
+		if (acl->sig == hash && ccs_check_condition(ptr, NULL)) {
 			const int len = acl->domainname->total_len;
-			if (strncmp(acl->domainname->name, dest_pattern, len)) continue;
-			if (dest_pattern[len] != ' ' && dest_pattern[len] != '\0') continue;
-			UpdateCondition(ptr);
+			if (strncmp(acl->domainname->name, dest_pattern, len))
+				continue;
+			if (dest_pattern[len] != ' ' &&
+			    dest_pattern[len] != '\0')
+				continue;
+			ccs_update_condition(ptr);
 			found = true;
 			break;
 		}
 	}
-	AuditSignalLog(sig, dest->domainname, found, profile, mode);
-	if (found) return 0;
-	if (TomoyoVerboseMode()) {
-		printk("TOMOYO-%s: Signal %d to %s denied for %s\n", GetMSG(is_enforce), sig, GetLastName(dest), GetLastName(domain));
-	}
-	if (is_enforce) return CheckSupervisor("%s\n" KEYWORD_ALLOW_SIGNAL "%d %s\n", domain->domainname->name, sig, dest_pattern);
-	else if (mode == 1 && CheckDomainQuota(domain)) AddSignalEntry(sig, dest_pattern, domain, NULL, 0);
+	audit_signal_log(sig, dest->domainname, found, profile, mode);
+	if (found)
+		return 0;
+	if (ccs_verbose_mode())
+		printk(KERN_WARNING "TOMOYO-%s: Signal %d "
+		       "to %s denied for %s\n", ccs_get_msg(is_enforce), sig,
+		       ccs_get_last_name(dest), ccs_get_last_name(domain));
+	if (is_enforce)
+		return ccs_check_supervisor("%s\n"
+					    KEYWORD_ALLOW_SIGNAL "%d %s\n",
+					    domain->domainname->name,
+					    sig, dest_pattern);
+	else if (mode == 1 && ccs_check_domain_quota(domain))
+		update_signal_acl(sig, dest_pattern, domain, NULL, 0);
 	return 0;
 }
 
-int AddSignalPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * ccs_write_signal_policy -
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_signal_policy(char *data, struct domain_info *domain,
+			    const struct condition_list *condition,
+			    const bool is_delete)
 {
 	int sig;
 	char *domainname = strchr(data, ' ');
-	if (sscanf(data, "%d", &sig) == 1 && domainname && IsDomainDef(domainname + 1)) {
-		return AddSignalEntry(sig, domainname + 1, domain, condition, is_delete);
-	}
+	if (sscanf(data, "%d", &sig) == 1 && domainname &&
+	    ccs_is_domain_def(domainname + 1))
+		return update_signal_acl(sig, domainname + 1, domain, condition,
+					 is_delete);
 	return -EINVAL;
 }
-
-/***** TOMOYO Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_file.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(working copy)
@@ -11,7 +11,6 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** TOMOYO Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/tomoyo.h>
@@ -19,41 +18,37 @@
 #include <linux/binfmts.h>
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
 
-/*************************  VARIABLES  *************************/
+/* Variables. */
 
-/***** The structure for globally readable files. *****/
-
+/* The structure for "allow_read" entry. */
 struct globally_readable_file_entry {
 	struct list1_head list;
 	const struct path_info *filename;
 	bool is_deleted;
 };
 
-/***** The structure for filename patterns. *****/
-
+/* The structure for "file_pattern" entry. */
 struct pattern_entry {
 	struct list1_head list;
 	const struct path_info *pattern;
 	bool is_deleted;
 };
 
-/***** The structure for non-rewritable-by-default file patterns. *****/
-
+/* The structure for "deny_rewrite" entry. */
 struct no_rewrite_entry {
 	struct list1_head list;
 	const struct path_info *pattern;
 	bool is_deleted;
 };
 
-/***** Keyword array for single path operations. *****/
-
+/* Keyword array for single path operations. */
 static const char *sp_keyword[MAX_SINGLE_PATH_OPERATION] = {
 	[TYPE_READ_WRITE_ACL] = "read/write",
 	[TYPE_EXECUTE_ACL]    = "execute",
 	[TYPE_READ_ACL]       = "read",
 	[TYPE_WRITE_ACL]      = "write",
 	[TYPE_CREATE_ACL]     = "create",
-	[TYPE_UNLINK_ACL]     = "unlink" ,
+	[TYPE_UNLINK_ACL]     = "unlink",
 	[TYPE_MKDIR_ACL]      = "mkdir",
 	[TYPE_RMDIR_ACL]      = "rmdir",
 	[TYPE_MKFIFO_ACL]     = "mkfifo",
@@ -65,81 +60,160 @@
 	[TYPE_REWRITE_ACL]    = "rewrite",
 };
 
-/***** Keyword array for double path operations. *****/
-
+/* Keyword array for double path operations. */
 static const char *dp_keyword[MAX_DOUBLE_PATH_OPERATION] = {
 	[TYPE_LINK_ACL]    = "link",
 	[TYPE_RENAME_ACL]  = "rename",
 };
 
-/*************************  UTILITY FUNCTIONS  *************************/
+/* Utility functions. */
 
-const char *sp_operation2keyword(const u8 operation)
+/**
+ * ccs_sp2keyword - Get the name of single path operation.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of single path operation.
+ */
+const char *ccs_sp2keyword(const u8 operation)
 {
 	return (operation < MAX_SINGLE_PATH_OPERATION)
 		? sp_keyword[operation] : NULL;
 }
 
-const char *dp_operation2keyword(const u8 operation)
+/**
+ * ccs_dp2keyword - Get the name of double path operation.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of double path operation.
+ */
+const char *ccs_dp2keyword(const u8 operation)
 {
 	return (operation < MAX_DOUBLE_PATH_OPERATION)
 		? dp_keyword[operation] : NULL;
 }
 
+/**
+ * strendswith - Check whether the token ends with the given token.
+ *
+ * @name: The token to check.
+ * @tail: The token to find.
+ *
+ * Returns true if @name ends with @tail, false otherwise.
+ */
 static bool strendswith(const char *name, const char *tail)
 {
 	int len;
-	if (!name || !tail) return 0;
+	if (!name || !tail)
+		return 0;
 	len = strlen(name) - strlen(tail);
-	return len >= 0 && strcmp(name + len, tail) == 0;
+	return len >= 0 && !strcmp(name + len, tail);
 }
 
-static struct path_info *GetPath(struct dentry *dentry, struct vfsmount *mnt)
+/**
+ * ccs_get_path - Get realpath.
+ *
+ * @dentry: Pointer to "struct dentry".
+ * @mnt:    Pointer to "struct vfsmount".
+ *
+ * Returns pointer to "struct path_info" on success, NULL otherwise.
+ */
+static struct path_info *ccs_get_path(struct dentry *dentry,
+				      struct vfsmount *mnt)
 {
-	struct path_info_with_data *buf = ccs_alloc(sizeof(struct ccs_page_buffer));
-	if (buf) {
-		int error;
-		if ((error = realpath_from_dentry2(dentry, mnt, buf->body, sizeof(buf->body) - 1)) == 0) {
-			buf->head.name = buf->body;
-			fill_path_info(&buf->head);
-			return &buf->head;
-		}
-		ccs_free(buf); buf = NULL;
-		printk("realpath_from_dentry = %d\n", error);
+	int error;
+	/*
+	 * This assignment is OK because
+	 *   sizeof(struct path_info_with_data)
+	 *   <= sizeof(struct ccs_page_buffer))
+	 * is checked at boot time.
+	 */
+	struct path_info_with_data *buf
+		= ccs_alloc(sizeof(struct ccs_page_buffer));
+	if (!buf)
+		return NULL;
+	error = ccs_realpath_from_dentry2(dentry, mnt, buf->body,
+					  sizeof(buf->body) - 1);
+	if (!error) {
+		buf->head.name = buf->body;
+		ccs_fill_path_info(&buf->head);
+		return &buf->head;
 	}
+	ccs_free(buf);
+	printk(KERN_DEBUG "ccs_realpath_from_dentry = %d\n", error);
 	return NULL;
 }
 
-/*************************  PROTOTYPES  *************************/
+/* Prototypes. */
+static int update_double_path_acl(const u8 type, const char *filename1,
+				  const char *filename2,
+				  struct domain_info * const domain,
+				  const struct condition_list *condition,
+				  const bool is_delete);
+static int update_single_path_acl(const u8 type, const char *filename,
+				  struct domain_info * const domain,
+				  const struct condition_list *condition,
+				  const bool is_delete);
 
-static int AddDoublePathACL(const u8 type, const char *filename1, const char *filename2, struct domain_info * const domain, const struct condition_list *condition, const bool is_delete);
-static int AddSinglePathACL(const u8 type, const char *filename, struct domain_info * const domain, const struct condition_list *condition, const bool is_delete);
-
-/*************************  AUDIT FUNCTIONS  *************************/
-
-static int AuditFileLog(const char *operation, const struct path_info *filename1, const struct path_info *filename2, const bool is_granted, const u8 profile, const u8 mode, struct linux_binprm *bprm)
+/**
+ * audit_file_log - Audit file related request log.
+ *
+ * @operation:  The name of operation.
+ * @filename1:  First pathname.
+ * @filename2:  Second pathname. May be NULL.
+ * @is_granted: True if this is a granted log.
+ * @profile:    The mode for this request.
+ * @mode:       Access control mode for this request.
+ * @bprm:       Pointer to "struct linux_binprm". May be NULL.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int audit_file_log(const char *operation,
+			  const struct path_info *filename1,
+			  const struct path_info *filename2,
+			  const bool is_granted, const u8 profile,
+			  const u8 mode, struct linux_binprm *bprm)
 {
 	char *buf;
 	int len;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
-	len = strlen(operation) + filename1->total_len + (filename2 ? filename2->total_len : 0) + 16;
-	if ((buf = InitAuditLog(&len, profile, mode, bprm)) == NULL) return -ENOMEM;
-	snprintf(buf + strlen(buf), len - strlen(buf) - 1, "allow_%s %s %s\n", operation, filename1->name, filename2 ? filename2->name : "");
-	return WriteAuditLog(buf, is_granted);
+	if (ccs_can_save_audit_log(is_granted) < 0)
+		return -ENOMEM;
+	len = strlen(operation) + filename1->total_len + 16;
+	if (filename2)
+		len += filename2->total_len;
+	buf = ccs_init_audit_log(&len, profile, mode, bprm);
+	if (!buf)
+		return -ENOMEM;
+	snprintf(buf + strlen(buf), len - strlen(buf) - 1, "allow_%s %s %s\n",
+		 operation, filename1->name, filename2 ? filename2->name : "");
+	return ccs_write_audit_log(buf, is_granted);
 }
 
-/*************************  GLOBALLY READABLE FILE HANDLER  *************************/
-
+/* The list for "struct globally_readable_file_entry". */
 static LIST1_HEAD(globally_readable_list);
 
-static int AddGloballyReadableEntry(const char *filename, const bool is_delete)
+/**
+ * update_globally_readable_entry - Update "struct globally_readable_file_entry"
+ *                                  policy.
+ *
+ * @filename:  Filename unconditionally permitted to open() for reading.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_globally_readable_entry(const char *filename,
+					  const bool is_delete)
 {
 	struct globally_readable_file_entry *new_entry, *ptr;
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_filename;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(filename, 1, -1, -1, __FUNCTION__)) return -EINVAL; /* No patterns allowed. */
-	if ((saved_filename = SaveName(filename)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(filename, 1, -1, -1, __func__))
+		return -EINVAL; /* No patterns allowed. */
+	saved_filename = ccs_save_name(filename);
+	if (!saved_filename)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &globally_readable_list, list) {
 		if (ptr->filename == saved_filename) {
@@ -149,48 +223,95 @@
 		}
 	}
 	if (is_delete) {
-		error = -ENOENT; goto out;
+		error = -ENOENT;
+		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->filename = saved_filename;
 	list1_add_tail_mb(&new_entry->list, &globally_readable_list);
 	error = 0;
- out: ;
+ out:
 	mutex_unlock(&lock);
 	return error;
 }
 
-static bool IsGloballyReadableFile(const struct path_info *filename)
+/**
+ * is_globally_readable_file - Check if the file is unconditionnaly permitted
+ *                             to be open()ed for reading.
+ *
+ * @filename: The filename to check.
+ *
+ * Returns true if any domain can open @filename for reading, false otherwise.
+ */
+static bool is_globally_readable_file(const struct path_info *filename)
 {
 	struct globally_readable_file_entry *ptr;
 	list1_for_each_entry(ptr, &globally_readable_list, list) {
-		if (!ptr->is_deleted && !pathcmp(filename, ptr->filename)) return true;
+		if (!ptr->is_deleted && !ccs_pathcmp(filename, ptr->filename))
+			return true;
 	}
 	return false;
 }
 
-int AddGloballyReadablePolicy(char *filename, const bool is_delete)
+/**
+ * ccs_write_globally_readable_policy - Write "struct
+ *                                      globally_readable_file_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_globally_readable_policy(char *data, const bool is_delete)
 {
-	return AddGloballyReadableEntry(filename, is_delete);
+	return update_globally_readable_entry(data, is_delete);
 }
 
-int ReadGloballyReadablePolicy(struct io_buffer *head)
+/**
+ * ccs_read_globally_readable_policy - Dump "struct
+ *                                     globally_readable_file_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &globally_readable_list) {
 		struct globally_readable_file_entry *ptr;
-		ptr = list1_entry(pos, struct globally_readable_file_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALLOW_READ "%s\n", ptr->filename->name)) return -ENOMEM;
+		ptr = list1_entry(pos, struct globally_readable_file_entry,
+				  list);
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, KEYWORD_ALLOW_READ "%s\n",
+				   ptr->filename->name))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
 
-/*************************  FILE GROUP HANDLER  *************************/
+/* "path_group" handler. */
 
+/* The list for "struct path_group_entry". */
 static LIST1_HEAD(path_group_list);
 
-static int AddPathGroupEntry(const char *group_name, const char *member_name, const bool is_delete)
+/**
+ * update_path_group_entry -
+ *
+ * @group_name:  The name of group.
+ * @member_name: The name of group's member.
+ * @is_delete:   True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_path_group_entry(const char *group_name,
+				   const char *member_name,
+				   const bool is_delete)
 {
 	static DEFINE_MUTEX(lock);
 	struct path_group_entry *new_group, *group;
@@ -198,14 +319,21 @@
 	const struct path_info *saved_group_name, *saved_member_name;
 	int error = -ENOMEM;
 	bool found = false;
-	if (!IsCorrectPath(group_name, 0, 0, 0, __FUNCTION__) || !group_name[0] ||
-		!IsCorrectPath(member_name, 0, 0, 0, __FUNCTION__) || !member_name[0]) return -EINVAL;
-	if ((saved_group_name = SaveName(group_name)) == NULL ||
-		(saved_member_name = SaveName(member_name)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0, __func__) ||
+	    !group_name[0] ||
+	    !ccs_is_correct_path(member_name, 0, 0, 0, __func__) ||
+	    !member_name[0])
+		return -EINVAL;
+	saved_group_name = ccs_save_name(group_name);
+	saved_member_name = ccs_save_name(member_name);
+	if (!saved_group_name || !saved_member_name)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(group, &path_group_list, list) {
-		if (saved_group_name != group->group_name) continue;
-		list1_for_each_entry(member, &group->path_group_member_list, list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		list1_for_each_entry(member, &group->path_group_member_list,
+				     list) {
 			if (member->member_name == saved_member_name) {
 				member->is_deleted = is_delete;
 				error = 0;
@@ -220,13 +348,17 @@
 		goto out;
 	}
 	if (!found) {
-		if ((new_group = alloc_element(sizeof(*new_group))) == NULL) goto out;
+		new_group = ccs_alloc_element(sizeof(*new_group));
+		if (!new_group)
+			goto out;
 		INIT_LIST1_HEAD(&new_group->path_group_member_list);
 		new_group->group_name = saved_group_name;
 		list1_add_tail_mb(&new_group->list, &path_group_list);
 		group = new_group;
 	}
-	if ((new_member = alloc_element(sizeof(*new_member))) == NULL) goto out;
+	new_member = ccs_alloc_element(sizeof(*new_member));
+	if (!new_member)
+		goto out;
 	new_member->member_name = saved_member_name;
 	list1_add_tail_mb(&new_member->list, &group->path_group_member_list);
 	error = 0;
@@ -235,73 +367,131 @@
 	return error;
 }
 
-int AddPathGroupPolicy(char *data, const bool is_delete)
+/**
+ * ccs_write_path_group_policy -
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, nagative value otherwise.
+ */
+int ccs_write_path_group_policy(char *data, const bool is_delete)
 {
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
-	return AddPathGroupEntry(data, cp, is_delete);
+	return update_path_group_entry(data, cp, is_delete);
 }
 
-static struct path_group_entry *FindOrAssignNewPathGroup(const char *group_name)
+/**
+ * find_or_assign_new_path_group -
+ *
+ * @group_name: The name of group.
+ *
+ * Returns pointer to "struct path_group_entry" if found, NULL otherwise.
+ */
+static struct path_group_entry *
+find_or_assign_new_path_group(const char *group_name)
 {
 	u8 i;
 	struct path_group_entry *group;
 	for (i = 0; i <= 1; i++) {
 		list1_for_each_entry(group, &path_group_list, list) {
-			if (strcmp(group_name, group->group_name->name) == 0) return group;
+			if (!strcmp(group_name, group->group_name->name))
+				return group;
 		}
 		if (i == 0) {
-			AddPathGroupEntry(group_name, "/", 0);
-			AddPathGroupEntry(group_name, "/", 1);
+			update_path_group_entry(group_name, "/", false);
+			update_path_group_entry(group_name, "/", true);
 		}
 	}
 	return NULL;
 }
 
-static bool PathMatchesToGroup(const struct path_info *pathname, const struct path_group_entry *group, const bool may_use_pattern)
+/**
+ * path_matches_group -
+ *
+ * @pathname:        The name of pathname.
+ * @group:           Pointer to "struct path_group_entry".
+ * @may_use_pattern: True if wild card is permitted.
+ *
+ * Returns true if @pathname matches pathnames in @group, false otherwise.
+ */
+static bool path_matches_group(const struct path_info *pathname,
+			       const struct path_group_entry *group,
+			       const bool may_use_pattern)
 {
 	struct path_group_member *member;
 	list1_for_each_entry(member, &group->path_group_member_list, list) {
-		if (member->is_deleted) continue;
+		if (member->is_deleted)
+			continue;
 		if (!member->member_name->is_patterned) {
-			if (!pathcmp(pathname, member->member_name)) return true;
+			if (!ccs_pathcmp(pathname, member->member_name))
+				return true;
 		} else if (may_use_pattern) {
-			if (PathMatchesToPattern(pathname, member->member_name)) return true;
+			if (ccs_path_matches_pattern(pathname,
+						     member->member_name))
+				return true;
 		}
 	}
 	return false;
 }
 
-int ReadPathGroupPolicy(struct io_buffer *head)
+/**
+ * ccs_read_path_group_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_path_group_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *gpos;
 	struct list1_head *mpos;
 	list1_for_each_cookie(gpos, head->read_var1, &path_group_list) {
 		struct path_group_entry *group;
 		group = list1_entry(gpos, struct path_group_entry, list);
-		list1_for_each_cookie(mpos, head->read_var2, &group->path_group_member_list) {
+		list1_for_each_cookie(mpos, head->read_var2,
+				      &group->path_group_member_list) {
 			struct path_group_member *member;
-			member = list1_entry(mpos, struct path_group_member, list);
-			if (member->is_deleted) continue;
-			if (io_printf(head, KEYWORD_PATH_GROUP "%s %s\n", group->group_name->name, member->member_name->name)) return -ENOMEM;
+			member = list1_entry(mpos, struct path_group_member,
+					     list);
+			if (member->is_deleted)
+				continue;
+			if (!ccs_io_printf(head, KEYWORD_PATH_GROUP "%s %s\n",
+					   group->group_name->name,
+					   member->member_name->name))
+				goto out;
 		}
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
 
-/*************************  FILE PATTERN HANDLER  *************************/
-
+/* The list for "struct pattern_entry". */
 static LIST1_HEAD(pattern_list);
 
-static int AddFilePatternEntry(const char *pattern, const bool is_delete)
+/**
+ * update_file_pattern_entry - Update "struct pattern_entry" list.
+ *
+ * @pattern:   Pathname pattern.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_file_pattern_entry(const char *pattern, const bool is_delete)
 {
 	struct pattern_entry *new_entry, *ptr;
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_pattern;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(pattern, 0, 1, 0, __FUNCTION__)) return -EINVAL;
-	if ((saved_pattern = SaveName(pattern)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(pattern, 0, 1, 0, __func__))
+		return -EINVAL;
+	saved_pattern = ccs_save_name(pattern);
+	if (!saved_pattern)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &pattern_list, list) {
 		if (saved_pattern == ptr->pattern) {
@@ -314,7 +504,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->pattern = saved_pattern;
 	list1_add_tail_mb(&new_entry->list, &pattern_list);
 	error = 0;
@@ -323,13 +515,23 @@
 	return error;
 }
 
-static const struct path_info *GetFilePattern(const struct path_info *filename)
+/**
+ * get_file_pattern - Get patterned pathname.
+ *
+ * @filename: The filename to find patterned pathname.
+ *
+ * Returns pointer to pathname pattern if matched, @filename otherwise.
+ */
+static const struct path_info *
+get_file_pattern(const struct path_info *filename)
 {
 	struct pattern_entry *ptr;
 	const struct path_info *pattern = NULL;
 	list1_for_each_entry(ptr, &pattern_list, list) {
-		if (ptr->is_deleted) continue;
-		if (!PathMatchesToPattern(filename, ptr->pattern)) continue;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_path_matches_pattern(filename, ptr->pattern))
+			continue;
 		pattern = ptr->pattern;
 		if (strendswith(pattern->name, "/\\*")) {
 			/* Do nothing. Try to find the better match. */
@@ -338,39 +540,70 @@
 			break;
 		}
 	}
-	if (pattern) filename = pattern;
+	if (pattern)
+		filename = pattern;
 	return filename;
 }
 
-int AddFilePatternPolicy(char *pattern, const bool is_delete)
+/**
+ * ccs_write_pattern_policy - Write "struct pattern_entry" policy.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_pattern_policy(char *data, const bool is_delete)
 {
-	return AddFilePatternEntry(pattern, is_delete);
+	return update_file_pattern_entry(data, is_delete);
 }
 
-int ReadFilePatternPolicy(struct io_buffer *head)
+/**
+ * ccs_read_file_pattern - Dump "struct pattern_entry" policy.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_file_pattern(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &pattern_list) {
 		struct pattern_entry *ptr;
 		ptr = list1_entry(pos, struct pattern_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_FILE_PATTERN "%s\n", ptr->pattern->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, KEYWORD_FILE_PATTERN "%s\n",
+				   ptr->pattern->name))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
 
-/*************************  NON REWRITABLE FILE HANDLER  *************************/
-
+/* The list for "struct no_rewrite_entry". */
 static LIST1_HEAD(no_rewrite_list);
 
-static int AddNoRewriteEntry(const char *pattern, const bool is_delete)
+/**
+ * update_no_rewrite_entry - Update "struct no_rewrite_entry" list.
+ *
+ * @pattern:   Pathname pattern that are not rewritable by default.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_no_rewrite_entry(const char *pattern, const bool is_delete)
 {
 	struct no_rewrite_entry *new_entry, *ptr;
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_pattern;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(pattern, 0, 0, 0, __FUNCTION__)) return -EINVAL;
-	if ((saved_pattern = SaveName(pattern)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(pattern, 0, 0, 0, __func__))
+		return -EINVAL;
+	saved_pattern = ccs_save_name(pattern);
+	if (!saved_pattern)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &no_rewrite_list, list) {
 		if (ptr->pattern == saved_pattern) {
@@ -383,7 +616,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->pattern = saved_pattern;
 	list1_add_tail_mb(&new_entry->list, &no_rewrite_list);
 	error = 0;
@@ -392,187 +627,379 @@
 	return error;
 }
 
-static bool IsNoRewriteFile(const struct path_info *filename)
+/**
+ * is_no_rewrite_file - Check if the given pathname is not permitted to
+ *                      be rewrited.
+ *
+ * @filename: Filename to check.
+ *
+ * Returns true if @filename is specified by "deny_rewrite" directive,
+ * false otherwise.
+ */
+static bool is_no_rewrite_file(const struct path_info *filename)
 {
 	struct no_rewrite_entry *ptr;
 	list1_for_each_entry(ptr, &no_rewrite_list, list) {
-		if (ptr->is_deleted) continue;
-		if (!PathMatchesToPattern(filename, ptr->pattern)) continue;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_path_matches_pattern(filename, ptr->pattern))
+			continue;
 		return true;
 	}
 	return false;
 }
 
-int AddNoRewritePolicy(char *pattern, const bool is_delete)
+/**
+ * ccs_write_no_rewrite_policy - Write "struct no_rewrite_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_no_rewrite_policy(char *data, const bool is_delete)
 {
-	return AddNoRewriteEntry(pattern, is_delete);
+	return update_no_rewrite_entry(data, is_delete);
 }
 
-int ReadNoRewritePolicy(struct io_buffer *head)
+/**
+ * ccs_read_no_rewrite_policy - Dump "struct no_rewrite_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &no_rewrite_list) {
 		struct no_rewrite_entry *ptr;
 		ptr = list1_entry(pos, struct no_rewrite_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_DENY_REWRITE "%s\n", ptr->pattern->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, KEYWORD_DENY_REWRITE "%s\n",
+				   ptr->pattern->name))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
 
-/*************************  FILE ACL HANDLER  *************************/
+/* File ACL handler. */
 
-static int AddFileACL(const char *filename, u8 perm, struct domain_info * const domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * update_file_acl -
+ *
+ * @filename:  Filename.
+ * @perm:      Permission (between 1 to 7).
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * This is legacy support interface for older policy syntax.
+ * Current policy syntax uses "allow_read/write" instead of "6",
+ * "allow_read" instead of "4", "allow_write" instead of "2",
+ * "allow_execute" instead of "1".
+ */
+static int update_file_acl(const char *filename, u8 perm,
+			   struct domain_info * const domain,
+			   const struct condition_list *condition,
+			   const bool is_delete)
 {
 	if (perm > 7 || !perm) {
-		printk(KERN_DEBUG "%s: Invalid permission '%d %s'\n", __FUNCTION__, perm, filename);
+		printk(KERN_DEBUG "%s: Invalid permission '%d %s'\n",
+		       __func__, perm, filename);
 		return -EINVAL;
 	}
-	if (filename[0] != '@' && strendswith(filename, "/")) {
-		return 0; /* Valid permissions for directory are only 'allow_mkdir' and 'allow_rmdir'. */
-	}
-	if (perm & 4) AddSinglePathACL(TYPE_READ_ACL, filename, domain, condition, is_delete);
-	if (perm & 2) AddSinglePathACL(TYPE_WRITE_ACL, filename, domain, condition, is_delete);
-	if (perm & 1) AddSinglePathACL(TYPE_EXECUTE_ACL, filename, domain, condition, is_delete);
+	if (filename[0] != '@' && strendswith(filename, "/"))
+		/*
+		 * Only 'allow_mkdir' and 'allow_rmdir' are valid for
+		 * directory permissions.
+		 */
+		return 0;
+	if (perm & 4)
+		update_single_path_acl(TYPE_READ_ACL, filename, domain,
+				       condition, is_delete);
+	if (perm & 2)
+		update_single_path_acl(TYPE_WRITE_ACL, filename, domain,
+				       condition, is_delete);
+	if (perm & 1)
+		update_single_path_acl(TYPE_EXECUTE_ACL, filename, domain,
+				       condition, is_delete);
 	return 0;
 }
 
-static int CheckSinglePathACL2(const struct path_info *filename, const u16 perm, struct obj_info *obj, const bool may_use_pattern)
+/**
+ * check_single_path_acl2 -
+ *
+ * @filename:        Filename to check.
+ * @obj:             Pointer to "struct obj_info".
+ * @may_use_pattern: True if patterned ACL is permitted.
+ *
+ * Returns 0 on success, -EPERM otherwise.
+ */
+static int check_single_path_acl2(const struct path_info *filename,
+				  const u16 perm, struct obj_info *obj,
+				  const bool may_use_pattern)
 {
 	const struct domain_info *domain = current->domain_info;
 	struct acl_info *ptr;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct single_path_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SINGLE_PATH_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SINGLE_PATH_ACL)
+			continue;
 		acl = container_of(ptr, struct single_path_acl_record, head);
-		if (!(acl->perm & perm) || !CheckCondition(ptr, obj)) continue;
+		if (!(acl->perm & perm) || !ccs_check_condition(ptr, obj))
+			continue;
 		if (acl->u_is_group) {
-			if (!PathMatchesToGroup(filename, acl->u.group, may_use_pattern)) continue;
+			if (!path_matches_group(filename, acl->u.group,
+						may_use_pattern))
+				continue;
 		} else if (may_use_pattern || !acl->u.filename->is_patterned) {
-			if (!PathMatchesToPattern(filename, acl->u.filename)) continue;
+			if (!ccs_path_matches_pattern(filename,
+						      acl->u.filename))
+				continue;
 		} else {
 			continue;
 		}
-		UpdateCondition(ptr);
+		ccs_update_condition(ptr);
 		return 0;
 	}
 	return -EPERM;
 }
 
-static int CheckFileACL(const struct path_info *filename, const u8 operation, struct obj_info *obj)
+/**
+ * check_file_acl - Check permission for opening files.
+ *
+ * @filename:  Filename to check.
+ * @operation: Mode (read or write or read/write or execute).
+ * @obj:       Pointer to "struct obj_info".
+ *
+ * Returns 0 on success, -EPERM otherwise.
+ */
+static int check_file_acl(const struct path_info *filename, const u8 operation,
+			  struct obj_info *obj)
 {
 	u16 perm = 0;
-	if (!CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE)) return 0;
-	if (operation == 6) perm = 1 << TYPE_READ_WRITE_ACL;
-	else if (operation == 4) perm = 1 << TYPE_READ_ACL;
-	else if (operation == 2) perm = 1 << TYPE_WRITE_ACL;
-	else if (operation == 1) perm = 1 << TYPE_EXECUTE_ACL;
-	else BUG();
-	return CheckSinglePathACL2(filename, perm, obj, operation != 1);
+	if (!ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE))
+		return 0;
+	if (operation == 6)
+		perm = 1 << TYPE_READ_WRITE_ACL;
+	else if (operation == 4)
+		perm = 1 << TYPE_READ_ACL;
+	else if (operation == 2)
+		perm = 1 << TYPE_WRITE_ACL;
+	else if (operation == 1)
+		perm = 1 << TYPE_EXECUTE_ACL;
+	else
+		BUG();
+	return check_single_path_acl2(filename, perm, obj, operation != 1);
 }
 
-static int CheckFilePerm2(const struct path_info *filename, const u8 perm, const char *operation, struct obj_info *obj, const u8 profile, const u8 mode)
+/**
+ * check_file_perm2 - Check permission for opening files.
+ *
+ * @filename:  Filename to check.
+ * @perm:      Mode (read or write or read/write or execute).
+ * @operation: Operation name passed used for verbose mode.
+ * @obj:       Pointer to "struct obj_info". May be NULL.
+ * @profile:   Profile number passed to audit logs.
+ * @mode:      Access control mode.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int check_file_perm2(const struct path_info *filename, const u8 perm,
+			    const char *operation, struct obj_info *obj,
+			    const u8 profile, const u8 mode)
 {
 	struct domain_info * const domain = current->domain_info;
 	const bool is_enforce = (mode == 3);
 	const char *msg = "<unknown>";
 	int error = 0;
-	if (!filename) return 0;
-	error = CheckFileACL(filename, perm, obj);
-	if (error && perm == 4 && (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ) == 0 && IsGloballyReadableFile(filename)) error = 0;
-	if (perm == 6) msg = sp_operation2keyword(TYPE_READ_WRITE_ACL);
-	else if (perm == 4) msg = sp_operation2keyword(TYPE_READ_ACL);
-	else if (perm == 2) msg = sp_operation2keyword(TYPE_WRITE_ACL);
-	else if (perm == 1) msg = sp_operation2keyword(TYPE_EXECUTE_ACL);
-	else BUG();
-	AuditFileLog(msg, filename, NULL, !error, profile, mode, obj ? obj->bprm : NULL);
-	if (!error) return 0;
-	if (TomoyoVerboseMode()) {
-		printk("TOMOYO-%s: Access '%s(%s) %s' denied for %s\n", GetMSG(is_enforce), msg, operation, filename->name, GetLastName(domain));
-	}
-	if (is_enforce) return CheckSupervisor("%s\nallow_%s %s\n", domain->domainname->name, msg, filename->name);
-	else if (mode == 1 && CheckDomainQuota(domain)) {
+	if (!filename)
+		return 0;
+	error = check_file_acl(filename, perm, obj);
+	if (error && perm == 4 &&
+	    (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ) == 0 &&
+	    is_globally_readable_file(filename))
+		error = 0;
+	if (perm == 6)
+		msg = ccs_sp2keyword(TYPE_READ_WRITE_ACL);
+	else if (perm == 4)
+		msg = ccs_sp2keyword(TYPE_READ_ACL);
+	else if (perm == 2)
+		msg = ccs_sp2keyword(TYPE_WRITE_ACL);
+	else if (perm == 1)
+		msg = ccs_sp2keyword(TYPE_EXECUTE_ACL);
+	else
+		BUG();
+	audit_file_log(msg, filename, NULL, !error, profile, mode,
+		       obj ? obj->bprm : NULL);
+	if (!error)
+		return 0;
+	if (ccs_verbose_mode())
+		printk(KERN_WARNING "TOMOYO-%s: Access '%s(%s) %s' denied "
+		       "for %s\n", ccs_get_msg(is_enforce), msg, operation,
+		       filename->name, ccs_get_last_name(domain));
+	if (is_enforce)
+		return ccs_check_supervisor("%s\nallow_%s %s\n",
+					    domain->domainname->name,
+					    msg, filename->name);
+	else if (mode == 1 && ccs_check_domain_quota(domain)) {
 		/* Don't use patterns for execute permission. */
-		const struct path_info *patterned_file = (perm != 1) ? GetFilePattern(filename) : filename;
-		AddFileACL(patterned_file->name, perm, domain, NULL, 0);
+		const struct path_info *patterned_file = (perm != 1) ?
+			get_file_pattern(filename) : filename;
+		update_file_acl(patterned_file->name, perm,
+				domain, NULL, false);
 	}
 	return 0;
 }
 
-static int AddExecuteHandler(const bool is_preferred, const char *filename, struct domain_info * const domain, const bool is_delete)
+/**
+ * update_execute_handler - Update "struct execute_handler_record" policy.
+ *
+ * @type:      Type of execute handler.
+ * @filename:  Pathname to the execute handler.
+ * @domain:    Pointer to "struct domain_info".
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_execute_handler(const u8 type, const char *filename,
+				  struct domain_info * const domain,
+				  const bool is_delete)
 {
 	const struct path_info *saved_filename;
 	struct acl_info *ptr;
 	struct execute_handler_record *acl;
-	const u8 type = is_preferred ? TYPE_PREFERRED_EXECUTE_HANDLER : TYPE_DEFAULT_EXECUTE_HANDLER;
 	int error = -ENOMEM;
-	if (!domain) return -EINVAL;
-	if (!IsCorrectPath(filename, 1, -1, -1, __FUNCTION__)) return -EINVAL;
-	if ((saved_filename = SaveName(filename)) == NULL) return -ENOMEM;
+	if (!domain)
+		return -EINVAL;
+	if (!ccs_is_correct_path(filename, 1, -1, -1, __func__))
+		return -EINVAL;
+	saved_filename = ccs_save_name(filename);
+	if (!saved_filename)
+		return -ENOMEM;
 	mutex_lock(&domain_acl_lock);
-	if (!is_delete) {
+	if (is_delete)
+		goto delete;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		/* Condition not supported. */
+		if ((ptr->type & ~ACL_DELETED) != type)
+			continue;
+		acl = container_of(ptr, struct execute_handler_record, head);
+		if (acl->handler != saved_filename)
+			continue;
+		/* Only one entry can exist in a domain. */
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_DELETED) != type) continue;
-			acl = container_of(ptr, struct execute_handler_record, head);
-			acl->handler = saved_filename;
-			error = AddDomainACL(NULL, ptr);
-			goto out;
+			if (ptr->type == type)
+				ptr->type |= ACL_DELETED;
 		}
-		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(type, NULL)) == NULL) goto out;
-		acl->handler = saved_filename;
-		error = AddDomainACL(domain, &acl->head);
-	} else {
-		error = -ENOENT;
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_DELETED) != type) continue;
-			acl = container_of(ptr, struct execute_handler_record, head);
-			if (acl->handler != saved_filename) continue;
-			error = DelDomainACL(ptr);
-			goto out;
-		}
+		error = ccs_add_domain_acl(NULL, ptr);
+		goto out;
 	}
- out: ;
+	/* Not found. Append it to the tail. */
+	acl = ccs_alloc_acl_element(type, NULL);
+	if (!acl)
+		goto out;
+	acl->handler = saved_filename;
+	/* Only one entry can exist in a domain. */
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if (ptr->type == type)
+			ptr->type |= ACL_DELETED;
+	}
+	error = ccs_add_domain_acl(domain, &acl->head);
+	goto out;
+ delete:
+	error = -ENOENT;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~ACL_DELETED) != type)
+			continue;
+		acl = container_of(ptr, struct execute_handler_record, head);
+		if (acl->handler != saved_filename)
+			continue;
+		error = ccs_del_domain_acl(ptr);
+		break;
+	}
+ out:
 	mutex_unlock(&domain_acl_lock);
 	return error;
 }
 
-int AddFilePolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * ccs_write_file_policy - Update file related policy.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_file_policy(char *data, struct domain_info *domain,
+			  const struct condition_list *condition,
+			  const bool is_delete)
 {
 	char *filename = strchr(data, ' ');
 	char *filename2;
 	unsigned int perm;
 	u8 type;
-	if (!filename) return -EINVAL;
+	if (!filename)
+		return -EINVAL;
 	*filename++ = '\0';
-	if (sscanf(data, "%u", &perm) == 1) {
-		return AddFileACL(filename, (u8) perm, domain, condition, is_delete);
-	}
+	if (sscanf(data, "%u", &perm) == 1)
+		return update_file_acl(filename, (u8) perm, domain, condition,
+				       is_delete);
 	if (strncmp(data, "allow_", 6)) {
-		if (strcmp(data, KEYWORD_PREFERRED_EXECUTE_HANDLER) == 0) {
-			return AddExecuteHandler(true, filename, domain, is_delete);
-		} else if (strcmp(data, KEYWORD_DEFAULT_EXECUTE_HANDLER) == 0) {
-			return AddExecuteHandler(false, filename, domain, is_delete);
-		}
-		goto out;
+		u8 type;
+		if (!strcmp(data, KEYWORD_PREFERRED_EXECUTE_HANDLER))
+			type = TYPE_PREFERRED_EXECUTE_HANDLER;
+		else if (!strcmp(data, KEYWORD_DEFAULT_EXECUTE_HANDLER))
+			type = TYPE_DEFAULT_EXECUTE_HANDLER;
+		else
+			goto out;
+		return update_execute_handler(type, filename,
+					      domain, is_delete);
 	}
 	data += 6;
 	for (type = 0; type < MAX_SINGLE_PATH_OPERATION; type++) {
-		if (strcmp(data, sp_keyword[type])) continue;
-		return AddSinglePathACL(type, filename, domain, condition, is_delete);
+		if (strcmp(data, sp_keyword[type]))
+			continue;
+		return update_single_path_acl(type, filename, domain, condition,
+					      is_delete);
 	}
 	filename2 = strchr(filename, ' ');
-	if (!filename2) goto out;
+	if (!filename2)
+		goto out;
 	*filename2++ = '\0';
 	for (type = 0; type < MAX_DOUBLE_PATH_OPERATION; type++) {
-		if (strcmp(data, dp_keyword[type])) continue;
-		return AddDoublePathACL(type, filename, filename2, domain, condition, is_delete);
+		if (strcmp(data, dp_keyword[type]))
+			continue;
+		return update_double_path_acl(type, filename, filename2, domain,
+					      condition, is_delete);
 	}
  out:
 	return -EINVAL;
 }
 
-static int AddSinglePathACL(const u8 type, const char *filename, struct domain_info * const domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * update_single_path_acl - Update "struct single_path_acl_record" policy.
+ *
+ * @type:      Type of operation.
+ * @filename:  Filename.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_single_path_acl(const u8 type, const char *filename,
+				  struct domain_info * const domain,
+				  const struct condition_list *condition,
+				  const bool is_delete)
 {
 	static const u16 rw_mask = (1 << TYPE_READ_ACL) | (1 << TYPE_WRITE_ACL);
 	const struct path_info *saved_filename;
@@ -581,55 +1008,93 @@
 	int error = -ENOMEM;
 	bool is_group = false;
 	const u16 perm = 1 << type;
-	if (!domain) return -EINVAL;
-	if (!IsCorrectPath(filename, 0, 0, 0, __FUNCTION__)) return -EINVAL;
+	if (!domain)
+		return -EINVAL;
+	if (!ccs_is_correct_path(filename, 0, 0, 0, __func__))
+		return -EINVAL;
 	if (filename[0] == '@') {
-		/* This cast is OK because I don't dereference in this function. */
-		if ((saved_filename = (struct path_info *) FindOrAssignNewPathGroup(filename + 1)) == NULL) return -ENOMEM;
+		/*
+		 * This cast is OK because I don't dereference in this function.
+		 */
+		saved_filename = (struct path_info *)
+			find_or_assign_new_path_group(filename + 1);
 		is_group = true;
 	} else {
-		if ((saved_filename = SaveName(filename)) == NULL) return -ENOMEM;
+		saved_filename = ccs_save_name(filename);
 	}
+	if (!saved_filename)
+		return -ENOMEM;
 	mutex_lock(&domain_acl_lock);
-	if (!is_delete) {
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_SINGLE_PATH_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct single_path_acl_record, head);
-			if (acl->u.filename != saved_filename) continue;
-			if (ptr->type & ACL_DELETED) acl->perm = 0;
-			acl->perm |= perm;
-			if ((acl->perm & rw_mask) == rw_mask) acl->perm |= 1 << TYPE_READ_WRITE_ACL;
-			else if (acl->perm & (1 << TYPE_READ_WRITE_ACL)) acl->perm |= rw_mask;
-			error = AddDomainACL(NULL, ptr);
-			goto out;
-		}
-		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_SINGLE_PATH_ACL, condition)) == NULL) goto out;
-		acl->perm = perm;
-		acl->u_is_group = is_group;
-		acl->u.filename = saved_filename;
-		error = AddDomainACL(domain, &acl->head);
-	} else {
-		error = -ENOENT;
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SINGLE_PATH_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct single_path_acl_record, head);
-			if (acl->u.filename != saved_filename) continue;
-			acl->perm &= ~perm;
-			if ((acl->perm & rw_mask) != rw_mask) acl->perm &= ~(1 << TYPE_READ_WRITE_ACL);
-			else if (!(acl->perm & (1 << TYPE_READ_WRITE_ACL))) acl->perm &= ~rw_mask;
-			error = DelDomainACL(acl->perm ? NULL : ptr);
-			goto out;
-		}
+	if (is_delete)
+		goto delete;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION))
+		    != TYPE_SINGLE_PATH_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct single_path_acl_record, head);
+		if (acl->u.filename != saved_filename)
+			continue;
+		if (ptr->type & ACL_DELETED)
+			acl->perm = 0;
+		acl->perm |= perm;
+		if ((acl->perm & rw_mask) == rw_mask)
+			acl->perm |= 1 << TYPE_READ_WRITE_ACL;
+		else if (acl->perm & (1 << TYPE_READ_WRITE_ACL))
+			acl->perm |= rw_mask;
+		error = ccs_add_domain_acl(NULL, ptr);
+		goto out;
 	}
- out: ;
+	/* Not found. Append it to the tail. */
+	acl = ccs_alloc_acl_element(TYPE_SINGLE_PATH_ACL, condition);
+	if (!acl)
+		goto out;
+	acl->perm = perm;
+	acl->u_is_group = is_group;
+	acl->u.filename = saved_filename;
+	error = ccs_add_domain_acl(domain, &acl->head);
+	goto out;
+ delete:
+	error = -ENOENT;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SINGLE_PATH_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct single_path_acl_record, head);
+		if (acl->u.filename != saved_filename)
+			continue;
+		acl->perm &= ~perm;
+		if ((acl->perm & rw_mask) != rw_mask)
+			acl->perm &= ~(1 << TYPE_READ_WRITE_ACL);
+		else if (!(acl->perm & (1 << TYPE_READ_WRITE_ACL)))
+			acl->perm &= ~rw_mask;
+		error = ccs_del_domain_acl(acl->perm ? NULL : ptr);
+		break;
+	}
+ out:
 	mutex_unlock(&domain_acl_lock);
 	return error;
 }
 
-static int AddDoublePathACL(const u8 type, const char *filename1, const char *filename2, struct domain_info * const domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * update_double_path_acl - Update "struct double_path_acl_record" policy.
+ *
+ * @type:      Type of operation.
+ * @filename1: First filename.
+ * @filename2: Second filename.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_double_path_acl(const u8 type, const char *filename1,
+				  const char *filename2,
+				  struct domain_info * const domain,
+				  const struct condition_list *condition,
+				  const bool is_delete)
 {
 	const struct path_info *saved_filename1, *saved_filename2;
 	struct acl_info *ptr;
@@ -637,276 +1102,459 @@
 	int error = -ENOMEM;
 	bool is_group1 = false, is_group2 = false;
 	const u8 perm = 1 << type;
-	if (!domain) return -EINVAL;
-	if (!IsCorrectPath(filename1, 0, 0, 0, __FUNCTION__) || !IsCorrectPath(filename2, 0, 0, 0, __FUNCTION__)) return -EINVAL;
+	if (!domain)
+		return -EINVAL;
+	if (!ccs_is_correct_path(filename1, 0, 0, 0, __func__) ||
+	    !ccs_is_correct_path(filename2, 0, 0, 0, __func__))
+		return -EINVAL;
 	if (filename1[0] == '@') {
-		/* This cast is OK because I don't dereference in this function. */
-		if ((saved_filename1 = (struct path_info *) FindOrAssignNewPathGroup(filename1 + 1)) == NULL) return -ENOMEM;
+		/*
+		 * This cast is OK because I don't dereference
+		 * in this function.
+		 */
+		saved_filename1 = (struct path_info *)
+			find_or_assign_new_path_group(filename1 + 1);
 		is_group1 = true;
 	} else {
-		if ((saved_filename1 = SaveName(filename1)) == NULL) return -ENOMEM;
+		saved_filename1 = ccs_save_name(filename1);
 	}
 	if (filename2[0] == '@') {
-		/* This cast is OK because I don't dereference in this function. */
-		if ((saved_filename2 = (struct path_info *) FindOrAssignNewPathGroup(filename2 + 1)) == NULL) return -ENOMEM;
+		/*
+		 * This cast is OK because I don't dereference
+		 * in this function.
+		 */
+		saved_filename2 = (struct path_info *)
+			find_or_assign_new_path_group(filename2 + 1);
 		is_group2 = true;
 	} else {
-		if ((saved_filename2 = SaveName(filename2)) == NULL) return -ENOMEM;
+		saved_filename2 = ccs_save_name(filename2);
 	}
+	if (!saved_filename1 || !saved_filename2)
+		return -ENOMEM;
 	mutex_lock(&domain_acl_lock);
-	if (!is_delete) {
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_DOUBLE_PATH_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct double_path_acl_record, head);
-			if (acl->u1.filename1 != saved_filename1 || acl->u2.filename2 != saved_filename2) continue;
-			if (ptr->type & ACL_DELETED) acl->perm = 0;
-			acl->perm |= perm;
-			error = AddDomainACL(NULL, ptr);
-			goto out;
-		}
-		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_DOUBLE_PATH_ACL, condition)) == NULL) goto out;
-		acl->perm = perm;
-		acl->u1_is_group = is_group1;
-		acl->u2_is_group = is_group2;
-		acl->u1.filename1 = saved_filename1;
-		acl->u2.filename2 = saved_filename2;
-		error = AddDomainACL(domain, &acl->head);
-	} else {
-		error = -ENOENT;
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_DOUBLE_PATH_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct double_path_acl_record, head);
-			if (acl->u1.filename1 != saved_filename1 || acl->u2.filename2 != saved_filename2) continue;
-			acl->perm &= ~perm;
-			error = DelDomainACL(acl->perm ? NULL : ptr);
-			break;
-		}
+	if (is_delete)
+		goto delete;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION))
+		    != TYPE_DOUBLE_PATH_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct double_path_acl_record, head);
+		if (acl->u1.filename1 != saved_filename1 ||
+		    acl->u2.filename2 != saved_filename2)
+			continue;
+		if (ptr->type & ACL_DELETED)
+			acl->perm = 0;
+		acl->perm |= perm;
+		error = ccs_add_domain_acl(NULL, ptr);
+		goto out;
 	}
- out: ;
+	/* Not found. Append it to the tail. */
+	acl = ccs_alloc_acl_element(TYPE_DOUBLE_PATH_ACL, condition);
+	if (!acl)
+		goto out;
+	acl->perm = perm;
+	acl->u1_is_group = is_group1;
+	acl->u2_is_group = is_group2;
+	acl->u1.filename1 = saved_filename1;
+	acl->u2.filename2 = saved_filename2;
+	error = ccs_add_domain_acl(domain, &acl->head);
+	goto out;
+ delete:
+	error = -ENOENT;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_DOUBLE_PATH_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct double_path_acl_record, head);
+		if (acl->u1.filename1 != saved_filename1 ||
+		    acl->u2.filename2 != saved_filename2)
+			continue;
+		acl->perm &= ~perm;
+		error = ccs_del_domain_acl(acl->perm ? NULL : ptr);
+		break;
+	}
+ out:
 	mutex_unlock(&domain_acl_lock);
 	return error;
 }
 
-static int CheckSinglePathACL(const u8 type, const struct path_info *filename, struct obj_info *obj)
+/**
+ * check_single_path_acl - Check permission for single path operation.
+ *
+ * @type:     Type of operation.
+ * @filename: Filename to check.
+ * @obj:      Pointer to "struct obj_info".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int check_single_path_acl(const u8 type,
+				 const struct path_info *filename,
+				 struct obj_info *obj)
 {
-	if (!CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE)) return 0;
-	return CheckSinglePathACL2(filename, 1 << type, obj, 1);
+	if (!ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE))
+		return 0;
+	return check_single_path_acl2(filename, 1 << type, obj, 1);
 }
 
-static int CheckDoublePathACL(const u8 type, const struct path_info *filename1, const struct path_info *filename2, struct obj_info *obj)
+/**
+ * check_double_path_acl - Check permission for double path operation.
+ *
+ * @type:      Type of operation.
+ * @filename1: First filename to check.
+ * @filename2: Second filename to check.
+ * @obj:       Pointer to "struct obj_info".
+ *
+ * Returns 0 on success, -EPERM otherwise.
+ */
+static int check_double_path_acl(const u8 type,
+				 const struct path_info *filename1,
+				 const struct path_info *filename2,
+				 struct obj_info *obj)
 {
 	const struct domain_info *domain = current->domain_info;
 	struct acl_info *ptr;
 	const u8 perm = 1 << type;
-	if (!CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE)) return 0;
+	if (!ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE))
+		return 0;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct double_path_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_DOUBLE_PATH_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_DOUBLE_PATH_ACL)
+			continue;
 		acl = container_of(ptr, struct double_path_acl_record, head);
-		if (!(acl->perm & perm) || !CheckCondition(ptr, obj)) continue;
+		if (!(acl->perm & perm) || !ccs_check_condition(ptr, obj))
+			continue;
 		if (acl->u1_is_group) {
-			if (!PathMatchesToGroup(filename1, acl->u1.group1, 1)) continue;
+			if (!path_matches_group(filename1, acl->u1.group1,
+						true))
+				continue;
 		} else {
-			if (!PathMatchesToPattern(filename1, acl->u1.filename1)) continue;
+			if (!ccs_path_matches_pattern(filename1,
+						      acl->u1.filename1))
+				continue;
 		}
 		if (acl->u2_is_group) {
-			if (!PathMatchesToGroup(filename2, acl->u2.group2, 1)) continue;
+			if (!path_matches_group(filename2,
+						acl->u2.group2, true))
+				continue;
 		} else {
-			if (!PathMatchesToPattern(filename2, acl->u2.filename2)) continue;
+			if (!ccs_path_matches_pattern(filename2,
+						      acl->u2.filename2))
+				continue;
 		}
-		UpdateCondition(ptr);
+		ccs_update_condition(ptr);
 		return 0;
 	}
 	return -EPERM;
 }
 
-static int CheckSinglePathPermission2(const u8 operation, const struct path_info *filename, struct obj_info *obj, const u8 profile, const u8 mode)
+/**
+ * check_single_path_permission2 - Check permission for single path operation.
+ *
+ * @operation: Type of operation.
+ * @filename:  Filename to check.
+ * @obj:       Pointer to "struct obj_info".
+ * @profile:   Profile number passed to audit logs.
+ * @mode:      Access control mode.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int check_single_path_permission2(const u8 operation,
+					 const struct path_info *filename,
+					 struct obj_info *obj,
+					 const u8 profile, const u8 mode)
 {
 	const char *msg;
 	int error;
 	struct domain_info * const domain = current->domain_info;
 	const bool is_enforce = (mode == 3);
-	if (!mode) return 0;
-	error = CheckSinglePathACL(operation, filename, obj);
-	msg = sp_operation2keyword(operation);
-	AuditFileLog(msg, filename, NULL, !error, profile, mode, NULL);
-	if (!error) goto next;
-	if (TomoyoVerboseMode()) {
-		printk("TOMOYO-%s: Access '%s %s' denied for %s\n", GetMSG(is_enforce), msg, filename->name, GetLastName(domain));
-	}
-	if (is_enforce) error = CheckSupervisor("%s\nallow_%s %s\n", domain->domainname->name, msg, filename->name);
-	else if (mode == 1 && CheckDomainQuota(domain)) AddSinglePathACL(operation, GetFilePattern(filename)->name, domain, NULL, 0);
-	if (!is_enforce) error = 0;
- next:
-	if (!error && operation == TYPE_TRUNCATE_ACL && IsNoRewriteFile(filename)) {
-		error = CheckSinglePathPermission2(TYPE_REWRITE_ACL, filename, obj, profile, mode);
-	}
+	if (!mode)
+		return 0;
+	error = check_single_path_acl(operation, filename, obj);
+	msg = ccs_sp2keyword(operation);
+	audit_file_log(msg, filename, NULL, !error, profile, mode, NULL);
+	if (!error)
+		goto out;
+	if (ccs_verbose_mode())
+		printk(KERN_WARNING "TOMOYO-%s: Access '%s %s' denied for %s\n",
+		       ccs_get_msg(is_enforce), msg, filename->name,
+		       ccs_get_last_name(domain));
+	if (is_enforce)
+		error = ccs_check_supervisor("%s\nallow_%s %s\n",
+					     domain->domainname->name,
+					     msg, filename->name);
+	else if (mode == 1 && ccs_check_domain_quota(domain))
+		update_single_path_acl(operation,
+				       get_file_pattern(filename)->name,
+				       domain, NULL, false);
+	if (!is_enforce)
+		error = 0;
+ out:
+	if (!error && operation == TYPE_TRUNCATE_ACL &&
+	    is_no_rewrite_file(filename))
+		error = check_single_path_permission2(TYPE_REWRITE_ACL,
+						      filename, obj, profile,
+						      mode);
 	return error;
 }
 
-int CheckFilePerm(const char *filename0, const u8 perm, const char *operation)
+/**
+ * ccs_check_file_perm - Check permission for sysctl()'s "read" and "write".
+ *
+ * @filename:  Filename to check.
+ * @perm:      Mode (read or write or read/write).
+ * @operation: Always "sysctl".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_file_perm(const char *filename, const u8 perm,
+			const char *operation)
 {
-	struct path_info filename;
+	struct path_info name;
 	const u8 profile = current->domain_info->profile;
-	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
-	if (!mode) return 0;
-	filename.name = filename0;
-	fill_path_info(&filename);
-	return CheckFilePerm2(&filename, perm, operation, NULL, profile, mode);
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE);
+	if (!mode)
+		return 0;
+	name.name = filename;
+	ccs_fill_path_info(&name);
+	return check_file_perm2(&name, perm, operation, NULL, profile, mode);
 }
 
-int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm, struct ccs_page_buffer *tmp)
+/**
+ * ccs_check_exec_perm -
+ *
+ * @filename: Check permission for "execute".
+ * @bprm:     Pointer to "struct linux_binprm".
+ * @tmp:      Buffer for temporal use.
+ *
+ * Returns 0 on success, negativevalue otherwise.
+ */
+int ccs_check_exec_perm(const struct path_info *filename,
+			struct linux_binprm *bprm, struct ccs_page_buffer *tmp)
 {
 	struct obj_info obj;
 	const u8 profile = current->domain_info->profile;
-	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
-	if (!mode) return 0;
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE);
+	if (!mode)
+		return 0;
 	memset(&obj, 0, sizeof(obj));
 	obj.path1_dentry = bprm->file->f_dentry;
 	obj.path1_vfsmnt = bprm->file->f_vfsmnt;
 	obj.bprm = bprm;
 	obj.tmp = tmp;
-	return CheckFilePerm2(filename, 1, "do_execve", &obj, profile, mode);
+	return check_file_perm2(filename, 1, "do_execve", &obj, profile, mode);
 }
 
-int CheckOpenPermission(struct dentry *dentry, struct vfsmount *mnt, const int flag)
+/**
+ * ccs_check_open_permission - Check permission for "read" and "write".
+ *
+ * @dentry: Pointer to "struct dentry".
+ * @mnt:    Pointer to "struct vfsmount".
+ * @flag:   Flags for open().
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_open_permission(struct dentry *dentry, struct vfsmount *mnt,
+			      const int flag)
 {
+	struct obj_info obj;
 	const u8 acc_mode = ACC_MODE(flag);
 	int error = -ENOMEM;
 	struct path_info *buf;
 	const u8 profile = current->domain_info->profile;
-	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE);
 	const bool is_enforce = (mode == 3);
-	if (!mode) return 0;
-	if (acc_mode == 0) return 0;
-	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode)) {
-		/* I don't check directories here because mkdir() and rmdir() don't call me. */
+	if (!mode)
 		return 0;
+	if (acc_mode == 0)
+		return 0;
+	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode))
+		/*
+		 * I don't check directories here because mkdir() and rmdir()
+		 * don't call me.
+		 */
+		return 0;
+	buf = ccs_get_path(dentry, mnt);
+	if (!buf)
+		goto out;
+	memset(&obj, 0, sizeof(obj));
+	obj.path1_dentry = dentry;
+	obj.path1_vfsmnt = mnt;
+	error = 0;
+	if ((acc_mode & MAY_WRITE) &&
+	    ((flag & O_TRUNC) || !(flag & O_APPEND))) {
+		if (is_no_rewrite_file(buf))
+			error = check_single_path_permission2(TYPE_REWRITE_ACL,
+							      buf, &obj,
+							      profile, mode);
 	}
-	buf = GetPath(dentry, mnt);
-	if (buf) {
-		struct obj_info obj;
-		memset(&obj, 0, sizeof(obj));
-		obj.path1_dentry = dentry;
-		obj.path1_vfsmnt = mnt;
+	if (!error)
+		error = check_file_perm2(buf, acc_mode, "open", &obj, profile,
+					 mode);
+	if (!error && (flag & O_TRUNC))
+		error = check_single_path_permission2(TYPE_TRUNCATE_ACL, buf,
+						      &obj, profile, mode);
+ out:
+	ccs_free(buf);
+	if (!is_enforce)
 		error = 0;
-		if ((acc_mode & MAY_WRITE)) {
-			if ((flag & O_TRUNC) || !(flag & O_APPEND)) {
-				if (IsNoRewriteFile(buf)) {
-					error = CheckSinglePathPermission2(TYPE_REWRITE_ACL, buf, &obj, profile, mode);
-				}
-			}
-		}
-		if (error == 0) error = CheckFilePerm2(buf, acc_mode, "open", &obj, profile, mode);
-		if (error == 0 && (flag & O_TRUNC)) error = CheckSinglePathPermission2(TYPE_TRUNCATE_ACL, buf, &obj, profile, mode);
-		ccs_free(buf);
-	}
-	if (!is_enforce) error = 0;
 	return error;
 }
 
-int CheckSinglePathPermission(const u8 operation, struct dentry *dentry, struct vfsmount *mnt)
+/**
+ * ccs_check_single_path_permission - Check permission for "create", "unlink",
+ *                                    "mkdir", "rmdir", "mkfifo", "mksock",
+ *                                    "mkblock", "mkchar", "truncate" and
+ *                                    "symlink".
+ *
+ * @operation: Type of operation.
+ * @dentry:    Pointer to "struct dentry".
+ * @mnt:       Pointer to "struct vfsmount".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_single_path_permission(const u8 operation, struct dentry *dentry,
+				     struct vfsmount *mnt)
 {
+	struct obj_info obj;
 	int error = -ENOMEM;
 	struct path_info *buf;
 	const u8 profile = current->domain_info->profile;
-	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE);
 	const bool is_enforce = (mode == 3);
-	if (!mode) return 0;
-	buf = GetPath(dentry, mnt);
-	if (buf) {
-		struct obj_info obj;
-		switch (operation) {
-		case TYPE_MKDIR_ACL:
-		case TYPE_RMDIR_ACL:
-			if (!buf->is_dir) {
-				strcat((char *) buf->name, "/");
-				fill_path_info(buf);
-			}
+	if (!mode)
+		return 0;
+	buf = ccs_get_path(dentry, mnt);
+	if (!buf)
+		goto out;
+	switch (operation) {
+	case TYPE_MKDIR_ACL:
+	case TYPE_RMDIR_ACL:
+		if (!buf->is_dir) {
+			strcat((char *) buf->name, "/");
+			ccs_fill_path_info(buf);
 		}
-		memset(&obj, 0, sizeof(obj));
-		obj.path1_dentry = dentry;
-		obj.path1_vfsmnt = mnt;
-		error = CheckSinglePathPermission2(operation, buf, &obj, profile, mode);
-		ccs_free(buf);
 	}
-	if (!is_enforce) error = 0;
+	memset(&obj, 0, sizeof(obj));
+	obj.path1_dentry = dentry;
+	obj.path1_vfsmnt = mnt;
+	error = check_single_path_permission2(operation, buf, &obj, profile,
+					      mode);
+ out:
+	ccs_free(buf);
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
-EXPORT_SYMBOL(CheckSinglePathPermission);
+/* I need to export this for net/unix/af_unix.c  */
+EXPORT_SYMBOL(ccs_check_single_path_permission);
 
-int CheckReWritePermission(struct file *filp)
+/**
+ * ccs_check_rewrite_permission - Check permission for "rewrite".
+ *
+ * @filp: Pointer to "struct file".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_rewrite_permission(struct file *filp)
 {
+	struct obj_info obj;
 	int error = -ENOMEM;
 	const u8 profile = current->domain_info->profile;
-	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE);
 	const bool is_enforce = (mode == 3);
-	struct path_info *buf = GetPath(filp->f_dentry, filp->f_vfsmnt);
-	if (buf) {
-		if (IsNoRewriteFile(buf)) {
-			struct obj_info obj;
-			memset(&obj, 0, sizeof(obj));
-			obj.path1_dentry = filp->f_dentry;
-			obj.path1_vfsmnt = filp->f_vfsmnt;
-			error = CheckSinglePathPermission2(TYPE_REWRITE_ACL, buf, &obj, profile, mode);
-		} else {
-			error = 0;
-		}
-		ccs_free(buf);
+	struct path_info *buf = ccs_get_path(filp->f_dentry, filp->f_vfsmnt);
+	if (!buf)
+		goto out;
+	if (!is_no_rewrite_file(buf)) {
+		error = 0;
+		goto out;
 	}
-	if (!is_enforce) error = 0;
+	memset(&obj, 0, sizeof(obj));
+	obj.path1_dentry = filp->f_dentry;
+	obj.path1_vfsmnt = filp->f_vfsmnt;
+	error = check_single_path_permission2(TYPE_REWRITE_ACL, buf, &obj,
+					      profile, mode);
+ out:
+	ccs_free(buf);
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
 
-int CheckDoublePathPermission(const u8 operation, struct dentry *dentry1, struct vfsmount *mnt1, struct dentry *dentry2, struct vfsmount *mnt2)
+/**
+ * ccs_check_double_path_permission - Check permission for "rename" and "link".
+ *
+ * @operation: Type of operation.
+ * @dentry1:   Pointer to "struct dentry".
+ * @mnt1:      Pointer to "struct vfsmount".
+ * @dentry2:   Pointer to "struct dentry".
+ * @mnt2:      Pointer to "struct vfsmount".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_double_path_permission(const u8 operation,
+				     struct dentry *dentry1,
+				     struct vfsmount *mnt1,
+				     struct dentry *dentry2,
+				     struct vfsmount *mnt2)
 {
 	int error = -ENOMEM;
 	struct path_info *buf1, *buf2;
 	struct domain_info * const domain = current->domain_info;
 	const u8 profile = current->domain_info->profile;
-	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_FILE);
 	const bool is_enforce = (mode == 3);
-	if (!mode) return 0;
-	buf1 = GetPath(dentry1, mnt1);
-	buf2 = GetPath(dentry2, mnt2);
-	if (buf1 && buf2) {
-		const char *msg;
-		struct obj_info obj;
-		if (operation == TYPE_RENAME_ACL) { /* TYPE_LINK_ACL can't reach here for directory. */
-			if (dentry1->d_inode && S_ISDIR(dentry1->d_inode->i_mode)) {
-				if (!buf1->is_dir) {
-					strcat((char *) buf1->name, "/");
-					fill_path_info(buf1);
-				}
-				if (!buf2->is_dir) {
-					strcat((char *) buf2->name, "/");
-					fill_path_info(buf2);
-				}
+	const char *msg;
+	struct obj_info obj;
+	if (!mode)
+		return 0;
+	buf1 = ccs_get_path(dentry1, mnt1);
+	buf2 = ccs_get_path(dentry2, mnt2);
+	if (!buf1 || !buf2)
+		goto out;
+	if (operation == TYPE_RENAME_ACL) {
+		/* TYPE_LINK_ACL can't reach here for directory. */
+		if (dentry1->d_inode && S_ISDIR(dentry1->d_inode->i_mode)) {
+			if (!buf1->is_dir) {
+				strcat((char *) buf1->name, "/");
+				ccs_fill_path_info(buf1);
 			}
-		}
-		memset(&obj, 0, sizeof(obj));
-		obj.path1_dentry = dentry1;
-		obj.path1_vfsmnt = mnt1;
-		obj.path2_dentry = dentry2;
-		obj.path2_vfsmnt = mnt2;
-		error = CheckDoublePathACL(operation, buf1, buf2, &obj);
-		msg = dp_operation2keyword(operation);
-		AuditFileLog(msg, buf1, buf2, !error, profile, mode, NULL);
-		if (error) {
-			if (TomoyoVerboseMode()) {
-				printk("TOMOYO-%s: Access '%s %s %s' denied for %s\n", GetMSG(is_enforce), msg, buf1->name, buf2->name, GetLastName(domain));
+			if (!buf2->is_dir) {
+				strcat((char *) buf2->name, "/");
+				ccs_fill_path_info(buf2);
 			}
-			if (is_enforce) error = CheckSupervisor("%s\nallow_%s %s %s\n", domain->domainname->name, msg, buf1->name, buf2->name);
-			else if (mode == 1 && CheckDomainQuota(domain)) AddDoublePathACL(operation, GetFilePattern(buf1)->name, GetFilePattern(buf2)->name, domain, NULL, 0);
 		}
 	}
+	memset(&obj, 0, sizeof(obj));
+	obj.path1_dentry = dentry1;
+	obj.path1_vfsmnt = mnt1;
+	obj.path2_dentry = dentry2;
+	obj.path2_vfsmnt = mnt2;
+	error = check_double_path_acl(operation, buf1, buf2, &obj);
+	msg = ccs_dp2keyword(operation);
+	audit_file_log(msg, buf1, buf2, !error, profile, mode, NULL);
+	if (!error)
+		goto out;
+	if (ccs_verbose_mode())
+		printk(KERN_WARNING "TOMOYO-%s: Access '%s %s %s' "
+		       "denied for %s\n", ccs_get_msg(is_enforce),
+		       msg, buf1->name, buf2->name, ccs_get_last_name(domain));
+	if (is_enforce)
+		error = ccs_check_supervisor("%s\nallow_%s %s %s\n",
+					     domain->domainname->name,
+					     msg, buf1->name, buf2->name);
+	else if (mode == 1 && ccs_check_domain_quota(domain))
+		update_double_path_acl(operation,
+				       get_file_pattern(buf1)->name,
+				       get_file_pattern(buf2)->name,
+				       domain, NULL, false);
+ out:
 	ccs_free(buf1);
 	ccs_free(buf2);
-	if (!is_enforce) error = 0;
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
-
-/***** TOMOYO Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c	(working copy)
@@ -11,22 +11,33 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** TOMOYO Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/tomoyo.h>
 #include <linux/realpath.h>
 
-/*************************  UTILITY FUNCTIONS  *************************/
+/* Utility functions. */
 
+/**
+ * cap_operation2name -
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of capability.
+ */
 static const char *cap_operation2name(const u8 operation)
 {
 	static const char *capability_name[TOMOYO_MAX_CAPABILITY_INDEX] = {
-		[TOMOYO_INET_STREAM_SOCKET_CREATE]  = "socket(PF_INET, SOCK_STREAM)",
-		[TOMOYO_INET_STREAM_SOCKET_LISTEN]  = "listen(PF_INET, SOCK_STREAM)",
-		[TOMOYO_INET_STREAM_SOCKET_CONNECT] = "connect(PF_INET, SOCK_STREAM)",
-		[TOMOYO_USE_INET_DGRAM_SOCKET]      = "socket(PF_INET, SOCK_DGRAM)",
-		[TOMOYO_USE_INET_RAW_SOCKET]        = "socket(PF_INET, SOCK_RAW)",
+		[TOMOYO_INET_STREAM_SOCKET_CREATE]  =
+		"socket(PF_INET, SOCK_STREAM)",
+		[TOMOYO_INET_STREAM_SOCKET_LISTEN]  =
+		"listen(PF_INET, SOCK_STREAM)",
+		[TOMOYO_INET_STREAM_SOCKET_CONNECT] =
+		"connect(PF_INET, SOCK_STREAM)",
+		[TOMOYO_USE_INET_DGRAM_SOCKET]      =
+		"socket(PF_INET, SOCK_DGRAM)",
+		[TOMOYO_USE_INET_RAW_SOCKET]        =
+		"socket(PF_INET, SOCK_RAW)",
 		[TOMOYO_USE_ROUTE_SOCKET]           = "socket(PF_ROUTE)",
 		[TOMOYO_USE_PACKET_SOCKET]          = "socket(PF_PACKET)",
 		[TOMOYO_SYS_MOUNT]                  = "sys_mount()",
@@ -54,96 +65,170 @@
 		[TOMOYO_SYS_PIVOT_ROOT]             = "sys_pivot_root()",
 		[TOMOYO_SYS_PTRACE]                 = "sys_ptrace()",
 	};
-	return operation < TOMOYO_MAX_CAPABILITY_INDEX ? capability_name[operation] : NULL;
+	if (operation < TOMOYO_MAX_CAPABILITY_INDEX)
+		return capability_name[operation];
+	return NULL;
 }
 
-/*************************  AUDIT FUNCTIONS  *************************/
+/* Auditing functions. */
 
-static int AuditCapabilityLog(const u8 operation, const bool is_granted, const u8 profile, const u8 mode)
+/**
+ * audit_capability_log -
+ *
+ * @operation:  Type of operation.
+ * @is_granted: True if this is a granted log.
+ * @profile:    Profile number.
+ * @mode:       Access control mode.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int audit_capability_log(const u8 operation, const bool is_granted,
+				const u8 profile, const u8 mode)
 {
 	char *buf;
 	int len = 64;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
-	if ((buf = InitAuditLog(&len, profile, mode, NULL)) == NULL) return -ENOMEM;
-	snprintf(buf + strlen(buf), len - strlen(buf) - 1, KEYWORD_ALLOW_CAPABILITY "%s\n", cap_operation2keyword(operation));
-	return WriteAuditLog(buf, is_granted);
+	int len2;
+	if (ccs_can_save_audit_log(is_granted) < 0)
+		return -ENOMEM;
+	buf = ccs_init_audit_log(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
+	len2 = strlen(buf);
+	snprintf(buf + len2, len - len2 - 1, KEYWORD_ALLOW_CAPABILITY "%s\n",
+		 ccs_cap2keyword(operation));
+	return ccs_write_audit_log(buf, is_granted);
 }
 
-/*************************  CAPABILITY ACL HANDLER  *************************/
+/* "allow_capability" handler. */
 
-static int AddCapabilityACL(const u8 operation, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * update_capability_acl -
+ *
+ * @operation: Type of operation.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_capability_acl(const u8 operation, struct domain_info *domain,
+				 const struct condition_list *condition,
+				 const bool is_delete)
 {
 	struct acl_info *ptr;
 	struct capability_acl_record *acl;
 	int error = -ENOMEM;
-	if (!domain) return -EINVAL;
+	if (!domain)
+		return -EINVAL;
 	mutex_lock(&domain_acl_lock);
-	if (!is_delete) {
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_CAPABILITY_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct capability_acl_record, head);
-			if (acl->operation != operation) continue;
-			error = AddDomainACL(NULL, ptr);
-			goto out;
-		}
-		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_CAPABILITY_ACL, condition)) == NULL) goto out;
-		acl->operation = operation;
-		error = AddDomainACL(domain, &acl->head);
-	} else {
-		error = -ENOENT;
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_CAPABILITY_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct capability_acl_record, head);
-			if (acl->operation != operation) continue;
-			error = DelDomainACL(ptr);
-			break;
-		}
+	if (is_delete)
+		goto delete;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION))
+		    != TYPE_CAPABILITY_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct capability_acl_record, head);
+		if (acl->operation != operation)
+			continue;
+		error = ccs_add_domain_acl(NULL, ptr);
+		goto out;
 	}
- out: ;
+	/* Not found. Append it to the tail. */
+	acl = ccs_alloc_acl_element(TYPE_CAPABILITY_ACL, condition);
+	if (!acl)
+		goto out;
+	acl->operation = operation;
+	error = ccs_add_domain_acl(domain, &acl->head);
+	goto out;
+ delete:
+	error = -ENOENT;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_CAPABILITY_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct capability_acl_record, head);
+		if (acl->operation != operation)
+			continue;
+		error = ccs_del_domain_acl(ptr);
+		break;
+	}
+ out:
 	mutex_unlock(&domain_acl_lock);
 	return error;
 }
 
-int CheckCapabilityACL(const u8 operation)
+/**
+ * ccs_capable - Check permission for capability.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_capable(const u8 operation)
 {
 	struct domain_info * const domain = current->domain_info;
 	struct acl_info *ptr;
 	const u8 profile = current->domain_info->profile;
-	const u8 mode = CheckCapabilityFlags(operation);
+	const u8 mode = ccs_check_capability_flags(operation);
 	const bool is_enforce = (mode == 3);
 	bool found = false;
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct capability_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_CAPABILITY_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_CAPABILITY_ACL)
+			continue;
 		acl = container_of(ptr, struct capability_acl_record, head);
-		if (acl->operation != operation || !CheckCondition(ptr, NULL)) continue;
-		UpdateCondition(ptr);
+		if (acl->operation != operation ||
+		    !ccs_check_condition(ptr, NULL))
+			continue;
+		ccs_update_condition(ptr);
 		found = true;
 		break;
 	}
-	AuditCapabilityLog(operation, found, profile, mode);
-	if (found) return 0;
-	if (TomoyoVerboseMode()) {
-		printk("TOMOYO-%s: %s denied for %s\n", GetMSG(is_enforce), cap_operation2name(operation), GetLastName(domain));
-	}
-	if (is_enforce) return CheckSupervisor("%s\n" KEYWORD_ALLOW_CAPABILITY "%s\n", domain->domainname->name, cap_operation2keyword(operation));
-	else if (mode == 1 && CheckDomainQuota(domain)) AddCapabilityACL(operation, domain, NULL, 0);
+	audit_capability_log(operation, found, profile, mode);
+	if (found)
+		return 0;
+	if (ccs_verbose_mode())
+		printk(KERN_WARNING "TOMOYO-%s: %s denied for %s\n",
+		       ccs_get_msg(is_enforce), cap_operation2name(operation),
+		       ccs_get_last_name(domain));
+	if (is_enforce)
+		return ccs_check_supervisor("%s\n"
+					    KEYWORD_ALLOW_CAPABILITY "%s\n",
+					    domain->domainname->name,
+					    ccs_cap2keyword(operation));
+	else if (mode == 1 && ccs_check_domain_quota(domain))
+		update_capability_acl(operation, domain, NULL, false);
 	return 0;
 }
-EXPORT_SYMBOL(CheckCapabilityACL);
+/* I need to export this for net/unix/af_unix.c */
+EXPORT_SYMBOL(ccs_capable);
 
-int AddCapabilityPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * ccs_write_capability_policy -
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_capability_policy(char *data, struct domain_info *domain,
+				const struct condition_list *condition,
+				const bool is_delete)
 {
 	u8 capability;
-	for (capability = 0; capability < TOMOYO_MAX_CAPABILITY_INDEX; capability++) {
-		if (strcmp(data, cap_operation2keyword(capability))) continue;
-		return AddCapabilityACL(capability, domain, condition, is_delete);
+	for (capability = 0; capability < TOMOYO_MAX_CAPABILITY_INDEX;
+	     capability++) {
+		if (strcmp(data, ccs_cap2keyword(capability)))
+			continue;
+		return update_capability_acl(capability, domain, condition,
+					     is_delete);
 	}
 	return -EINVAL;
 }
-
-/***** TOMOYO Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(working copy)
@@ -11,7 +11,6 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** TOMOYO Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/realpath.h>
@@ -21,18 +20,129 @@
 #include <linux/highmem.h>
 #include <linux/binfmts.h>
 
-static bool ScanBprm(struct linux_binprm *bprm, const bool is_argv, unsigned long index, const struct path_info *name, const struct path_info *value, bool *failed, struct ccs_page_buffer *tmp)
+struct argv_entry {
+	unsigned int index;
+	const struct path_info *value;
+	bool is_not;
+};
+
+struct envp_entry {
+	const struct path_info *name;
+	const struct path_info *value;
+	bool is_not;
+};
+
+/**
+ * check_argv - Check argv[] in "struct linux_binbrm".
+ *
+ * @index:   Index number of @arg_ptr .
+ * @arg_ptr: Contents of argv[@index] .
+ * @argc:    Length of @argv .
+ * @argv:    Pointer to "struct argv_entry".
+ * @checked: Set to true if @argv[@index] was found.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool check_argv(const unsigned int index, const char *arg_ptr,
+		       const int argc, const struct argv_entry *argv,
+		       u8 *checked)
 {
+	int i;
+	struct path_info arg;
+	arg.name = arg_ptr;
+	for (i = 0; i < argc; argv++, checked++, i++) {
+		bool result;
+		if (index != argv->index)
+			continue;
+		*checked = 1;
+		ccs_fill_path_info(&arg);
+		result = ccs_path_matches_pattern(&arg, argv->value);
+		if (argv->is_not)
+			result = !result;
+		if (!result)
+			return false;
+	}
+	return true;
+}
+
+/**
+ * check_envp - Check envp[] in "struct linux_binbrm".
+ *
+ * @env_name:  The name of environment variable.
+ * @env_value: The value of environment variable.
+ * @envc:      Length of @envp .
+ * @envp:      Pointer to "struct envp_entry".
+ * @checked:   Set to true if @envp[@env_name] was found.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool check_envp(const char *env_name, const char *env_value,
+		       const int envc, const struct envp_entry *envp,
+		       u8 *checked)
+{
+	int i;
+	struct path_info name;
+	struct path_info value;
+	name.name = env_name;
+	ccs_fill_path_info(&name);
+	value.name = env_value;
+	ccs_fill_path_info(&value);
+	for (i = 0; i < envc; envp++, checked++, i++) {
+		bool result;
+		if (!ccs_path_matches_pattern(&name, envp->name))
+			continue;
+		*checked = 1;
+		if (envp->value) {
+			result = ccs_path_matches_pattern(&value, envp->value);
+			if (envp->is_not)
+				result = !result;
+		} else {
+			result = true;
+			if (!envp->is_not)
+				result = !result;
+		}
+		if (!result)
+			return false;
+	}
+	return true;
+}
+
+/**
+ * scan_bprm - Scan "struct linux_binprm".
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ * @argc: Length of @argc .
+ * @argv: Pointer to "struct argv_entry".
+ * @envc: Length of @envp .
+ * @envp: Poiner to "struct envp_entry".
+ * @tmp:  Buffer for temporal use.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool scan_bprm(const struct linux_binprm *bprm,
+		      const u16 argc, const struct argv_entry *argv,
+		      const u16 envc, const struct envp_entry *envp,
+		      struct ccs_page_buffer *tmp)
+{
 	/*
-	  if exec.argc=3                  // if (argc == 3)
-	  if exec.argv[1]="-c"            // if (argc >= 2 && strcmp(argv[1], "-c") == 0)
-	  if exec.argv[1]!="-c"           // if (argc < 2 || strcmp(argv[1], "-c"))
-	  if exec.envc=10-20              // if (envc >= 10 && envc <= 20)
-	  if exec.envc!=10-20             // if (envc < 10 || envc > 20)
-	  if exec.envp["HOME"]!=NULL      // if (getenv("HOME"))
-	  if exec.envp["HOME"]=NULL       // if (!getenv("HOME"))
-	  if exec.envp["HOME"]="/"        // if (getenv("HOME") && strcmp(getenv("HOME"), "/") == 0)
-	  if exec.envp["HOME"]!="/"       // if (!getenv("HOME") || strcmp(getenv("HOME", "/"))
+	  if exec.argc=3
+	  if (argc == 3)
+	  if exec.argv[1]="-c"
+	  if (argc >= 2 && !strcmp(argv[1], "-c"))
+	  if exec.argv[1]!="-c"
+	  if (argc < 2 || strcmp(argv[1], "-c"))
+	  if exec.envc=10-20
+	  if (envc >= 10 && envc <= 20)
+	  if exec.envc!=10-20
+	  if (envc < 10 || envc > 20)
+	  if exec.envp["HOME"]!=NULL
+	  if (getenv("HOME"))
+	  if exec.envp["HOME"]=NULL
+	  if (!getenv("HOME"))
+	  if exec.envp["HOME"]="/"
+	  if (getenv("HOME") && !strcmp(getenv("HOME"), "/"))
+	  if exec.envp["HOME"]!="/"
+	  if (!getenv("HOME") || strcmp(getenv("HOME", "/"))
 	*/
 	char *arg_ptr = tmp->buffer;
 	int arg_len = 0;
@@ -40,14 +150,25 @@
 	int i = pos / PAGE_SIZE, offset = pos % PAGE_SIZE;
 	int argv_count = bprm->argc;
 	int envp_count = bprm->envc;
-	bool result = false;
+	bool result = true;
+	u8 local_checked[32];
+	u8 *checked;
+	if (argc + envc <= sizeof(local_checked)) {
+		checked = local_checked;
+		memset(local_checked, 0, sizeof(local_checked));
+	} else {
+		checked = ccs_alloc(argc + envc);
+		if (!checked)
+			return false;
+	}
 	while (argv_count || envp_count) {
 		struct page *page;
 		const char *kaddr;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
-		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0) {
-			*failed = true;
-			printk("get_user_pages() failed\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
+		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page,
+				   NULL) <= 0) {
+			printk(KERN_DEBUG "get_user_pages() failed\n");
+			result = false;
 			goto out;
 		}
 		pos += PAGE_SIZE - offset;
@@ -57,11 +178,11 @@
 		/* Map. */
 		kaddr = kmap(page);
 		if (!kaddr) { /* Mapping failed. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 			put_page(page);
 #endif
-			*failed = true;
-			printk("kmap() failed\n");
+			printk(KERN_DEBUG "kmap() failed\n");
+			result = false;
 			goto out;
 		}
 		while (offset < PAGE_SIZE) {
@@ -78,45 +199,36 @@
 				} else {
 					arg_ptr[arg_len++] = '\\';
 					arg_ptr[arg_len++] = (c >> 6) + '0';
-					arg_ptr[arg_len++] = ((c >> 3) & 7) + '0';
+					arg_ptr[arg_len++] =
+						((c >> 3) & 7) + '0';
 					arg_ptr[arg_len++] = (c & 7) + '0';
 				}
 			} else {
 				arg_ptr[arg_len] = '\0';
 			}
-			if (c) continue;
+			if (c)
+				continue;
 			/* Check. */
 			if (argv_count) {
-				if (is_argv && bprm->argc - argv_count == index) {
-					fill_path_info(&arg);
-					result = PathMatchesToPattern(&arg, value);
-					argv_count = envp_count = 0;
+				if (!check_argv(bprm->argc - argv_count,
+						arg_ptr, argc, argv,
+						checked)) {
+					result = false;
 					break;
 				}
-				if (--argv_count == 0 && is_argv) {
-					envp_count = 0;
-					break;
-				}
+				argv_count--;
 			} else if (envp_count) {
 				char *cp = strchr(arg_ptr, '=');
 				if (cp) {
 					*cp = '\0';
-					fill_path_info(&arg);
-					if (PathMatchesToPattern(&arg, name)) {
-						if (value) {
-							arg.name = cp + 1;
-							fill_path_info(&arg);
-							if (PathMatchesToPattern(&arg, value)) result = true;
-						} else {
-							result = true;
-						}
-						if (result) {
-							envp_count = 0;
-							break;
-						}
+					if (!check_envp(arg_ptr, cp + 1,
+							envc, envp,
+							checked + argc)) {
+						result = false;
+						break;
 					}
 				}
-				if (--envp_count == 0) break;
+				envp_count--;
 			} else {
 				break;
 			}
@@ -124,63 +236,237 @@
 		}
 		/* Unmap. */
 		kunmap(page);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 		put_page(page);
 #endif
 		i++;
 		offset = 0;
+		if (!result)
+			break;
 	}
  out:
+	if (result) {
+		/* Check not-yet-checked entries. */
+		for (i = 0; i < argc; i++) {
+			if (checked[i])
+				continue;
+			/*
+			 * Return true only if all unchecked indexes in
+			 * bprm->argv[] are not matched.
+			 */
+			if (argv[i].is_not)
+				continue;
+			result = false;
+			break;
+		}
+		for (i = 0; i < envc; envp++, i++) {
+			if (checked[argc + i])
+				continue;
+			/*
+			 * Return true only if all unchecked environ variables
+			 * in bprm->envp[] are either undefined or not matched.
+			 */
+			if ((!envp->value && !envp->is_not) ||
+			    (envp->value && envp->is_not))
+				continue;
+			result = false;
+			break;
+		}
+	}
+	if (checked != local_checked)
+		ccs_free(checked);
 	return result;
 }
 
+/* Value type definition. */
 #define VALUE_TYPE_DECIMAL     1
 #define VALUE_TYPE_OCTAL       2
 #define VALUE_TYPE_HEXADECIMAL 3
 
-/* Don't use u8 because we use "<< 8". */
-static u16 parse_ulong(unsigned long *result, char **str)
+/**
+ * parse_ulong - Parse an "unsigned long" value.
+ *
+ * @result: Pointer to "unsigned long".
+ * @str:    Pointer to string to parse.
+ *
+ * Returns value type on success, 0 otherwise.
+ *
+ * The @src is updated to point the first character after the value
+ * on success.
+ */
+static u8 parse_ulong(unsigned long *result, char **str)
 {
 	const char *cp = *str;
 	char *ep;
 	int base = 10;
 	if (*cp == '0') {
-		char c = * (cp + 1);
+		char c = *(cp + 1);
 		if (c == 'x' || c == 'X') {
-			base = 16; cp += 2;
+			base = 16;
+			cp += 2;
 		} else if (c >= '0' && c <= '7') {
-			base = 8; cp++;
+			base = 8;
+			cp++;
 		}
 	}
 	*result = simple_strtoul(cp, &ep, base);
-	if (cp == ep) return 0;
+	if (cp == ep)
+		return 0;
 	*str = ep;
-	return (base == 16 ? VALUE_TYPE_HEXADECIMAL : (base == 8 ? VALUE_TYPE_OCTAL : VALUE_TYPE_DECIMAL));
+	switch (base) {
+	case 16:
+		return VALUE_TYPE_HEXADECIMAL;
+	case 8:
+		return VALUE_TYPE_OCTAL;
+	default:
+		return VALUE_TYPE_DECIMAL;
+	}
 }
 
-static void print_ulong(char *buffer, const int buffer_len, const unsigned long value, const int type)
+
+/**
+ * print_ulong - Dump an "unsigned long" value.
+ *
+ * @buffer:     Pointer to buffer.
+ * @buffer_len: Size of @buffer .
+ * @value:      An "unsigned long" value.
+ * @type:       Type of @value .
+ *
+ * Returns nothing.
+ */
+static void print_ulong(char *buffer, const int buffer_len,
+			const unsigned long value, const int type)
 {
-	if (type == VALUE_TYPE_DECIMAL) {
+	if (type == VALUE_TYPE_DECIMAL)
 		snprintf(buffer, buffer_len, "%lu", value);
-	} else if (type == VALUE_TYPE_OCTAL) {
+	else if (type == VALUE_TYPE_OCTAL)
 		snprintf(buffer, buffer_len, "0%lo", value);
-	} else {
+	else
 		snprintf(buffer, buffer_len, "0x%lX", value);
-	}
 }
 
-union element {
-	const struct path_info *string;
-	unsigned long value;
-};
-
 struct condition_list {
 	struct list1_head list;
-	u32 length;
+	u16 condc;
+	u16 argc;
+	u16 envc;
 	u8 post_state[4];
-	/* "union element condition[length]" comes here.*/
+	/* "unsigned long condition[condc]" follows here. */
+	/* "struct argv_entry argv[argc]" follows here. */
+	/* "struct envp_entry envp[envc]" follows here. */
 };
 
+/**
+ * parse_argv - Parse an argv[] condition part.
+ *
+ * @start: String to parse.
+ * @argv:  Pointer to "struct argv_entry".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool parse_argv(char *start, struct argv_entry *argv)
+{
+	unsigned long index;
+	const struct path_info *value;
+	bool is_not;
+	char c;
+	char *cp;
+	start += 10;
+	if (parse_ulong(&index, &start) != VALUE_TYPE_DECIMAL)
+		goto out;
+	if (*start++ != ']')
+		goto out;
+	c = *start++;
+	if (c == '=')
+		is_not = false;
+	else if (c == '!' && *start++ == '=')
+		is_not = true;
+	else
+		goto out;
+	if (*start++ != '"')
+		goto out;
+	cp = strchr(start, '\0') - 1;
+	if (cp <= start || *cp != '"')
+		goto out;
+	*cp = '\0';
+	if (!ccs_is_correct_path(start, 0, 0, 0, __func__))
+		goto out;
+	value = ccs_save_name(start);
+	if (!value)
+		goto out;
+	argv->index = index;
+	argv->is_not = is_not;
+	argv->value = value;
+	return true;
+ out:
+	return false;
+}
+
+/**
+ * parse_envp - Parse an envp[] condition part.
+ *
+ * @start: String to parse.
+ * @envp:  Pointer to "struct envp_entry".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool parse_envp(char *start, struct envp_entry *envp)
+{
+	const struct path_info *name;
+	const struct path_info *value;
+	bool is_not;
+	char *cp;
+	start += 11;
+	cp = start;
+	/*
+	 * Since environment variable names don't
+	 * contain '=', I can treat '"]=' and '"]!='
+	 * sequences as delimiters.
+	 */
+	while (1) {
+		if (!strncmp(start, "\"]=", 3)) {
+			is_not = false;
+			*start = '\0';
+			start += 3;
+			break;
+		} else if (!strncmp(start, "\"]!=", 4)) {
+			is_not = true;
+			*start = '\0';
+			start += 4;
+			break;
+		} else if (!*start++) {
+			goto out;
+		}
+	}
+	if (!*cp || !ccs_is_correct_path(cp, 0, 0, 0, __func__))
+		goto out;
+	name = ccs_save_name(cp);
+	if (!name)
+		goto out;
+	if (!strcmp(start, "NULL")) {
+		value = NULL;
+	} else {
+		if (*start++ != '"')
+			goto out;
+		cp = strchr(start, '\0') - 1;
+		if (cp <= start || *cp != '"')
+			goto out;
+		*cp = '\0';
+		if (!ccs_is_correct_path(start, 0, 0, 0, __func__))
+			goto out;
+		value = ccs_save_name(start);
+		if (!value)
+			goto out;
+	}
+	envp->name = name;
+	envp->is_not = is_not;
+	envp->value = value;
+	return true;
+ out:
+	return false;
+}
+
+/* The list for "struct condition_list". */
 static LIST1_HEAD(condition_list);
 
 #define TASK_UID          0
@@ -204,12 +490,10 @@
 #define PATH2_PARENT_INO 18
 #define EXEC_ARGC        19
 #define EXEC_ENVC        20
-#define EXEC_ARGV        21
-#define EXEC_ENVP        22
-#define TASK_STATE_0     23
-#define TASK_STATE_1     24
-#define TASK_STATE_2     25
-#define MAX_KEYWORD      26
+#define TASK_STATE_0     21
+#define TASK_STATE_1     22
+#define TASK_STATE_2     23
+#define MAX_KEYWORD      24
 
 static struct {
 	const char *keyword;
@@ -236,292 +520,360 @@
 	[PATH2_PARENT_INO] = { "path2.parent.ino",  16 },
 	[EXEC_ARGC]        = { "exec.argc",          9 },
 	[EXEC_ENVC]        = { "exec.envc",          9 },
-	[EXEC_ARGV]        = { "exec.argv[",        10 },
-	[EXEC_ENVP]        = { "exec.envp[\"",      11 },
 	[TASK_STATE_0]     = { "task.state[0]",     13 },
 	[TASK_STATE_1]     = { "task.state[1]",     13 },
 	[TASK_STATE_2]     = { "task.state[2]",     13 },
 };
 
-const struct condition_list *FindOrAssignNewCondition(char *condition)
+/**
+ * parse_post_condition - Parse post-condition part.
+ *
+ * @condition:  String to parse.
+ * @post_state: Buffer to store post-condition part.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool parse_post_condition(char * const condition, u8 post_state[4])
 {
+	char *start = strstr(condition, "; set ");
+	if (!start)
+		return true;
+	*start = '\0';
+	start += 6;
+	while (1) {
+		int i;
+		unsigned long value;
+		while (*start == ' ')
+			start++;
+		if (!*start)
+			break;
+		if (!strncmp(start, "task.state[0]=", 14))
+			i = 0;
+		else if (!strncmp(start, "task.state[1]=", 14))
+			i = 1;
+		else if (!strncmp(start, "task.state[2]=", 14))
+			i = 2;
+		else
+			goto out;
+		start += 14;
+		if (post_state[3] & (1 << i))
+			goto out;
+		post_state[3] |= 1 << i;
+		if (!parse_ulong(&value, &start) || value > 255)
+			goto out;
+		post_state[i] = (u8) value;
+	}
+	return true;
+ out:
+	return false;
+}
+
+/**
+ * find_same_condition - Search for same condition list.
+ *
+ * @new_ptr: Pointer to "struct condition_list".
+ * @size:    Size of @new_ptr .
+ *
+ * Returns existing pointer to "struct condition_list" if the same entry was
+ * found, NULL if memory allocation failed, @new_ptr otherwise.
+ */
+static struct condition_list *
+find_same_condition(struct condition_list *new_ptr, const u32 size)
+{
+	static DEFINE_MUTEX(lock);
+	struct condition_list *ptr;
+	mutex_lock(&lock);
+	list1_for_each_entry(ptr, &condition_list, list) {
+		/* Don't compare if size differs. */
+		if (ptr->condc != new_ptr->condc ||
+		    ptr->argc != new_ptr->argc ||
+		    ptr->envc != new_ptr->envc)
+			continue;
+		/*
+		 * Compare ptr and new_ptr
+		 * except ptr->list and new_ptr->list .
+		 */
+		if (memcmp(((u8 *) ptr) + sizeof(ptr->list),
+			   ((u8 *) new_ptr) + sizeof(new_ptr->list),
+			   size - sizeof(ptr->list)))
+			continue;
+		/* Same entry found. Share this entry. */
+		ccs_free(new_ptr);
+		new_ptr = ptr;
+		goto ok;
+	}
+	/* Same entry not found. Save this entry. */
+	ptr = ccs_alloc_element(size);
+	if (ptr) {
+		memmove(ptr, new_ptr, size);
+		/* Append to chain. */
+		list1_add_tail_mb(&ptr->list, &condition_list);
+	}
+	ccs_free(new_ptr);
+	new_ptr = ptr;
+ ok:
+	mutex_unlock(&lock);
+	return new_ptr;
+}
+
+/**
+ * ccs_find_or_assign_new_condition - Parse condition part.
+ *
+ * @condition: Pointer to string to parse.
+ *
+ * Returns pointer to "struct condition_list" on success, NULL otherwise.
+ */
+const struct condition_list *
+ccs_find_or_assign_new_condition(char * const condition)
+{
 	char *start = condition;
-	struct condition_list *new_ptr;
-	union element *ptr2;
-	u32 counter = 0, size;
+	struct condition_list *new_ptr = NULL;
+	unsigned long *ptr;
+	struct argv_entry *argv;
+	struct envp_entry *envp;
+	u32 size;
 	u8 left, right, i;
-	unsigned long left_min = 0, left_max = 0, right_min = 0, right_max = 0;
-	const struct path_info *left_name = NULL, *right_name = NULL;
+	unsigned long left_min = 0;
+	unsigned long left_max = 0;
+	unsigned long right_min = 0;
+	unsigned long right_max = 0;
+	u16 condc = 0;
+	u16 argc = 0;
+	u16 envc = 0;
 	u8 post_state[4] = { 0, 0, 0, 0 };
-	if ((condition = strstr(condition, "; set ")) != NULL) {
-		*condition = '\0';
-		condition += 6;
-		while (1) {
-			while (*condition == ' ') condition++;
-			if (!*condition) break;
-			if (strncmp(condition, "task.state[0]=", 14) == 0) i = 0;
-			else if (strncmp(condition, "task.state[1]=", 14) == 0) i = 1;
-			else if (strncmp(condition, "task.state[2]=", 14) == 0) i = 2;
-			else goto out;
-			condition += 14;
-			if (post_state[3] & (1 << i)) goto out;
-			post_state[3] |= 1 << i;
-			if (!parse_ulong(&right_min, &condition) || right_min > 255) goto out;
-			post_state[i] = (u8) right_min;
-		}
-	}
-	condition = start;
-	if (strncmp(condition, "if ", 3) == 0) condition += 3;
-	else if (*condition) return NULL;
+	if (!parse_post_condition(start, post_state))
+		goto out;
 	start = condition;
+	if (!strncmp(start, "if ", 3))
+		start += 3;
+	else if (*start)
+		return NULL;
 	while (1) {
-		while (*condition == ' ') condition++;
-		if (!*condition) break;
-		for (left = 0; left < MAX_KEYWORD; left++) {
-			if (strncmp(condition, condition_control_keyword[left].keyword, condition_control_keyword[left].keyword_len) == 0) {
-				condition += condition_control_keyword[left].keyword_len;
+		while (*start == ' ')
+			start++;
+		if (!*start)
+			break;
+		if (!strncmp(start, "exec.argv[", 10)) {
+			argc++;
+			start = strchr(start + 10, ' ');
+			if (!start)
 				break;
-			}
+			continue;
+		} else if (!strncmp(start, "exec.envp[\"", 11)) {
+			envc++;
+			start = strchr(start + 11, ' ');
+			if (!start)
+				break;
+			continue;
 		}
-		if (left == EXEC_ARGV) {
-			if (!parse_ulong(&left_min, &condition)) goto out;
-			if (*condition++ != ']') goto out;
-			counter++; /* body */
-		} else if (left == EXEC_ENVP) {
-			char *tmp = condition;
-			while (1) {
-				const char c = *condition;
-				/*
-				 * Since environment variable names don't contain '=',
-				 * I can treat '"]=' and '"]!=' sequences as delimiters.
-				 */
-				if (strncmp(condition, "\"]=", 3) == 0 || strncmp(condition, "\"]!=", 4) == 0) break;
-				if (!c || c == ' ') goto out;
-				condition++;
-			}
-			*condition = '\0';
-			if (!SaveName(tmp)) goto out;
-			counter++; /* body */
-			*condition = '"';
-			condition += 2;
-		} else if (left == MAX_KEYWORD) {
-			if (!parse_ulong(&left_min, &condition)) goto out;
-			counter++; /* body */
-			if (*condition == '-') {
-				condition++;
-				if (!parse_ulong(&left_max, &condition) || left_min > left_max) goto out;
-				counter++; /* body */
-			}
+		for (left = 0; left < MAX_KEYWORD; left++) {
+			const int len =
+				condition_control_keyword[left].keyword_len;
+			if (strncmp(start,
+				    condition_control_keyword[left].keyword,
+				    len))
+				continue;
+			start += len;
+			break;
 		}
-		if (strncmp(condition, "!=", 2) == 0) condition += 2;
-		else if (*condition == '=') condition++;
-		else goto out;
-		counter++; /* header */
-		if (left == EXEC_ENVP && strncmp(condition, "NULL", 4) == 0) {
-			char c;
-			condition += 4;
-			c = *condition;
-			counter++; /* body */
-			if (!c || c == ' ') continue;
+		if (left < MAX_KEYWORD)
+			goto check_operator_1;
+		if (!parse_ulong(&left_min, &start))
 			goto out;
-		} else if (left == EXEC_ARGV || left == EXEC_ENVP) {
-			char c;
-			char *tmp;
-			if (*condition++ != '"') goto out;
-			tmp = condition;
-			while (1) {
-				c = *condition++;
-				if (!c || c == ' ') goto out;
-				if (c != '"') continue;
-				c = *condition;
-				if (!c || c == ' ') break;
-			}
-			c = *--condition;
-			*condition = '\0';
-			if (!SaveName(tmp)) goto out;
-			counter++; /* body */
-			*condition = c;
-			condition++;
-			continue;
-		}
+		condc++; /* body */
+		if (*start != '-')
+			goto check_operator_1;
+		start++;
+		if (!parse_ulong(&left_max, &start) || left_min > left_max)
+			goto out;
+		condc++; /* body */
+ check_operator_1:
+		if (strncmp(start, "!=", 2) == 0)
+			start += 2;
+		else if (*start == '=')
+			start++;
+		else
+			goto out;
+		condc++; /* header */
 		for (right = 0; right < MAX_KEYWORD; right++) {
-			if (strncmp(condition, condition_control_keyword[right].keyword, condition_control_keyword[right].keyword_len) == 0) {
-				condition += condition_control_keyword[right].keyword_len;
-				break;
-			}
+			const int len =
+				condition_control_keyword[right].keyword_len;
+			if (strncmp(start,
+				    condition_control_keyword[right].keyword,
+				    len))
+				continue;
+			start += len;
+			break;
 		}
-		if (right == MAX_KEYWORD) {
-			if (!parse_ulong(&right_min, &condition)) goto out;
-			counter++; /* body */
-			if (*condition == '-') {
-				condition++;
-				if (!parse_ulong(&right_max, &condition) || right_min > right_max) goto out;
-				counter++; /* body */
-			}
-		}
+		if (right < MAX_KEYWORD)
+			continue;
+		if (!parse_ulong(&right_min, &start))
+			goto out;
+		condc++; /* body */
+		if (*start != '-')
+			continue;
+		start++;
+		if (!parse_ulong(&right_max, &start) || right_min > right_max)
+			goto out;
+		condc++; /* body */
 	}
-	size = sizeof(*new_ptr) + counter * sizeof(union element);
+	size = sizeof(*new_ptr)
+		+ condc * sizeof(unsigned long)
+		+ argc * sizeof(struct argv_entry)
+		+ envc * sizeof(struct envp_entry);
 	new_ptr = ccs_alloc(size);
-	if (!new_ptr) return NULL;
-	new_ptr->length = counter;
-	for (i = 0; i < 4; i++) new_ptr->post_state[i] = post_state[i];
-	ptr2 = (union element *) (((u8 *) new_ptr) + sizeof(*new_ptr));
-	condition = start;
+	if (!new_ptr)
+		return NULL;
+	for (i = 0; i < 4; i++)
+		new_ptr->post_state[i] = post_state[i];
+	new_ptr->condc = condc;
+	new_ptr->argc = argc;
+	new_ptr->envc = envc;
+	ptr = (unsigned long *) (new_ptr + 1);
+	argv = (struct argv_entry *) (ptr + condc);
+	envp = (struct envp_entry *) (argv + argc);
+	start = condition;
+	if (!strncmp(start, "if ", 3))
+		start += 3;
+	else if (*start)
+		goto out;
 	while (1) {
-		unsigned int match = 0;
-		while (*condition == ' ') condition++;
-		if (!*condition) break;
-		for (left = 0; left < MAX_KEYWORD; left++) {
-			if (strncmp(condition, condition_control_keyword[left].keyword, condition_control_keyword[left].keyword_len) == 0) {
-				condition += condition_control_keyword[left].keyword_len;
+		u8 match = 0;
+		u8 left_1_type = 0;
+		u8 left_2_type = 0;
+		u8 right_1_type = 0;
+		u8 right_2_type = 0;
+		while (*start == ' ')
+			start++;
+		if (!*start)
+			break;
+		if (!strncmp(start, "exec.argv[", 10)) {
+			char *cp = strchr(start + 10, ' ');
+			if (!parse_argv(start, argv))
+				goto out;
+			argv++;
+			argc--;
+			if (!cp)
 				break;
-			}
+			start = cp;
+			continue;
+		} else if (!strncmp(start, "exec.envp[\"", 11)) {
+			char *cp = strchr(start + 11, ' ');
+			if (!parse_envp(start, envp))
+				goto out;
+			envp++;
+			envc--;
+			if (!cp)
+				break;
+			start = cp;
+			continue;
 		}
-		if (left == EXEC_ARGV) {
-			if (!parse_ulong(&left_min, &condition)) goto out;
-			if (*condition++ != ']') goto out;
-			counter--; /* body */
-		} else if (left == EXEC_ENVP) {
-			char *tmp = condition;
-			while (1) {
-				char c = *condition;
-				/*
-				 * Since environment variable names don't contain '=',
-				 * I can treat "\"]=" and "\"]!=" sequences as delimiters.
-				 */
-				if (strncmp(condition, "\"]=", 3) == 0 || strncmp(condition, "\"]!=", 4) == 0) break;
-				if (!c || c == ' ') goto out;
-				condition++;
-			}
-			*condition = '\0';
-			left_name = SaveName(tmp);
-			BUG_ON(!left_name);
-			counter--; /* body */
-			*condition = '\"';
-			condition += 2;
-		} else if (left == MAX_KEYWORD) {
-			match |= parse_ulong(&left_min, &condition) << 2;
-			counter--; /* body */
-			if (*condition == '-') {
-				condition++;
-				match |= parse_ulong(&left_max, &condition) << 4;
-				counter--; /* body */
-				left++;
-			}
+		for (left = 0; left < MAX_KEYWORD; left++) {
+			const int len =
+				condition_control_keyword[left].keyword_len;
+			if (strncmp(start,
+				    condition_control_keyword[left].keyword,
+				    len))
+				continue;
+			start += len;
+			break;
 		}
-		if (strncmp(condition, "!=", 2) == 0) {
-			condition += 2;
-		} else if (*condition == '=') {
-			match |= 1; condition++;
+		if (left < MAX_KEYWORD)
+			goto check_operator_2;
+		left_1_type = parse_ulong(&left_min, &start);
+		condc--; /* body */
+		if (*start != '-')
+			goto check_operator_2;
+		start++;
+		left_2_type = parse_ulong(&left_max, &start);
+		condc--; /* body */
+		left++;
+ check_operator_2:
+		if (!strncmp(start, "!=", 2)) {
+			start += 2;
+		} else if (*start == '=') {
+			match |= 1;
+			start++;
 		} else {
-			goto out2;
+			break; /* This shouldn't happen. */
 		}
-		counter--; /* header */
-		if (left == EXEC_ENVP && strncmp(condition, "NULL", 4) == 0) {
-			char c;
-			condition += 4;
-			right_name = NULL;
-			counter--; /* body */
-			c = *condition;
-			if (c && c != ' ') goto out;
-			right = 0;
-			goto skip_right;
-		} else if (left == EXEC_ARGV || left == EXEC_ENVP) {
-			char c;
-			char *tmp;
-			if (*condition++ != '"') goto out;
-			tmp = condition;
-			while (1) {
-				c = *condition++;
-				if (!c || c == ' ') goto out;
-				if (c != '"') continue;
-				c = *condition;
-				if (!c || c == ' ') break;
-			}
-			c = *--condition;
-			*condition = '\0';
-			right_name = SaveName(tmp);
-			BUG_ON(!right_name);
-			counter--; /* body */
-			*condition = c;
-			condition++;
-			right = 0;
-			goto skip_right;
-		}
+		condc--; /* header */
 		for (right = 0; right < MAX_KEYWORD; right++) {
-			if (strncmp(condition, condition_control_keyword[right].keyword, condition_control_keyword[right].keyword_len) == 0) {
-				condition += condition_control_keyword[right].keyword_len;
-				break;
-			}
+			const int len =
+				condition_control_keyword[right].keyword_len;
+			if (strncmp(start,
+				    condition_control_keyword[right].keyword,
+				    len))
+				continue;
+			start += len;
+			break;
 		}
-		if (right == MAX_KEYWORD) {
-			match |= parse_ulong(&right_min, &condition) << 6;
-			counter--; /* body */
-			if (*condition == '-') {
-				condition++;
-				match |= parse_ulong(&right_max, &condition) << 8;
-				counter--; /* body */
-				right++;
-			}
+		if (right < MAX_KEYWORD)
+			goto store_value;
+		right_1_type = parse_ulong(&right_min, &start);
+		condc--; /* body */
+		if (*start != '-')
+			goto store_value;
+		start++;
+		right_2_type = parse_ulong(&right_max, &start);
+		condc--; /* body */
+		right++;
+ store_value:
+		*ptr = (((u32) match) << 16) |
+			(((u32) left_1_type) << 18) |
+			(((u32) left_2_type) << 20) |
+			(((u32) right_1_type) << 22) |
+			(((u32) right_2_type) << 24) |
+			(((u32) left) << 8) |
+			((u32) right);
+		ptr++;
+		if (left >= MAX_KEYWORD) {
+			*ptr = left_min;
+			ptr++;
 		}
-skip_right:
-		if (counter < 0) {
-			WARN_ON(counter < 0);
-			goto out2;
+		if (left == MAX_KEYWORD + 1) {
+			*ptr = left_max;
+			ptr++;
 		}
-		ptr2->value = (match << 16) | (left << 8) | right;
-		ptr2++;
-		if (left == EXEC_ARGV) { ptr2->value = left_min; ptr2++; }
-		if (left == EXEC_ENVP) { ptr2->string = left_name; ptr2++; }
-		if (left == EXEC_ARGV || left == EXEC_ENVP) { ptr2->string = right_name; ptr2++; }
-		if (left >= MAX_KEYWORD) { ptr2->value = left_min; ptr2++; }
-		if (left == MAX_KEYWORD + 1) { ptr2->value = left_max; ptr2++; }
-		if (right >= MAX_KEYWORD) { ptr2->value = right_min; ptr2++; }
-		if (right == MAX_KEYWORD + 1) { ptr2->value = right_max; ptr2++; }
-	}
-	WARN_ON(counter);
-	{
-		static DEFINE_MUTEX(lock);
-		struct condition_list *ptr;
-		mutex_lock(&lock);
-		list1_for_each_entry(ptr, &condition_list, list) {
-			/* Don't compare if size differs. */
-			if (ptr->length != new_ptr->length) continue;
-			/* Compare ptr and new_ptr except ptr->list and new_ptr->list . */
-			if (memcmp(((u8 *) ptr) + sizeof(ptr->list), ((u8 *) new_ptr) + sizeof(new_ptr->list), size - sizeof(ptr->list))) continue;
-			/* Same entry found. Share this entry. */
-			ccs_free(new_ptr);
-			new_ptr = ptr;
-			goto ok;
+		if (right >= MAX_KEYWORD) {
+			*ptr = right_min;
+			ptr++;
 		}
-		/* Same entry not found. Save this entry. */
-		ptr = alloc_element(size);
-		if (ptr) {
-			memmove(ptr, new_ptr, size);
-			/* Append to chain. */
-			list1_add_tail_mb(&ptr->list, &condition_list);
+		if (right == MAX_KEYWORD + 1) {
+			*ptr = right_max;
+			ptr++;
 		}
-		ccs_free(new_ptr);
-		new_ptr = ptr;
-	ok:
-		mutex_unlock(&lock);
 	}
-	return new_ptr;
- out2:
+	/*
+	  printk(KERN_DEBUG "argc=%u envc=%u condc=%u\n", argc, envc, condc);
+	*/
+	BUG_ON(argc);
+	BUG_ON(envc);
+	BUG_ON(condc);
+	return find_same_condition(new_ptr, size);
+ out:
 	ccs_free(new_ptr);
- out:
 	return NULL;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-static void GetAttributes(struct obj_info *obj)
+/**
+ * get_attributes - Revalidate "struct inode".
+ *
+ * @obj: Pointer to "struct obj_info".
+ *
+ * Returns nothing.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+static void get_attributes(struct obj_info *obj)
 {
 	struct dentry *dentry;
 	struct inode *inode;
 
 	dentry = obj->path1_dentry;
-	if ((inode = dentry->d_inode) != NULL) {
-		if (inode->i_op && inode->i_op->revalidate && inode->i_op->revalidate(dentry)) {
+	inode = dentry->d_inode;
+	if (inode) {
+		if (inode->i_op && inode->i_op->revalidate &&
+		    inode->i_op->revalidate(dentry)) {
 			/* Nothing to do. */
 		} else {
 			obj->path1_stat.uid = inode->i_uid;
@@ -531,12 +883,15 @@
 		}
 	}
 
+	/***** CRITICAL SECTION START *****/
 	spin_lock(&dcache_lock);
 	dentry = dget(obj->path1_dentry->d_parent);
 	spin_unlock(&dcache_lock);
+	/***** CRITICAL SECTION END *****/
 	inode = dentry->d_inode;
 	if (inode) {
-		if (inode->i_op && inode->i_op->revalidate && inode->i_op->revalidate(dentry)) {
+		if (inode->i_op && inode->i_op->revalidate &&
+		    inode->i_op->revalidate(dentry)) {
 			/* Nothing to do. */
 		} else {
 			obj->path1_parent_stat.uid = inode->i_uid;
@@ -548,12 +903,15 @@
 	dput(dentry);
 
 	if (obj->path2_vfsmnt) {
+		/***** CRITICAL SECTION START *****/
 		spin_lock(&dcache_lock);
 		dentry = dget(obj->path2_dentry->d_parent);
 		spin_unlock(&dcache_lock);
+		/***** CRITICAL SECTION END *****/
 		inode = dentry->d_inode;
 		if (inode) {
-			if (inode->i_op && inode->i_op->revalidate && inode->i_op->revalidate(dentry)) {
+			if (inode->i_op && inode->i_op->revalidate &&
+			    inode->i_op->revalidate(dentry)) {
 				/* Nothing to do. */
 			} else {
 				obj->path2_parent_stat.uid = inode->i_uid;
@@ -566,7 +924,7 @@
 	}
 }
 #else
-static void GetAttributes(struct obj_info *obj)
+static void get_attributes(struct obj_info *obj)
 {
 	struct vfsmount *mnt;
 	struct dentry *dentry;
@@ -601,7 +959,8 @@
 	}
 	dput(dentry);
 
-	if ((mnt = obj->path2_vfsmnt) != NULL) {
+	mnt = obj->path2_vfsmnt;
+	if (mnt) {
 		dentry = dget_parent(obj->path2_dentry);
 		inode = dentry->d_inode;
 		if (inode) {
@@ -619,251 +978,455 @@
 }
 #endif
 
-bool CheckCondition(const struct acl_info *acl, struct obj_info *obj)
+/**
+ * ccs_check_condition - Check condition part.
+ *
+ * @acl: Pointer to "struct acl_info".
+ * @obj: Pointer to "struct obj_info". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_check_condition(const struct acl_info *acl, struct obj_info *obj)
 {
-	struct task_struct *task = current;
+	const struct task_struct *task = current;
 	u32 i;
-	unsigned long left_min = 0, left_max = 0, right_min = 0, right_max = 0;
-	const union element *ptr2;
-	const struct condition_list *ptr = GetConditionPart(acl);
-	struct linux_binprm *bprm;
-	bool failed = false;
-	if (!ptr) return true;
-	bprm = obj->bprm;
-	ptr2 = (union element *) (((u8 *) ptr) + sizeof(*ptr));
-	for (i = 0; i < ptr->length; i++) {
-		const bool match = ((ptr2->value) >> 16) & 1;
-		const u8 left = (ptr2->value) >> 8, right = ptr2->value;
-		ptr2++;
-		if (left == EXEC_ARGV) {
-			bool result;
-			unsigned long index;
-			const struct path_info *value;
-			index = ptr2->value; ptr2++; i++;
-			value = ptr2->string; ptr2++; i++;
-			if (!bprm) goto out;
-			result = ScanBprm(bprm, true, index, NULL, value, &failed, obj->tmp);
-			if (failed) goto out;
-			if (!match) result = !result;
-			if (result) continue;
-			goto out;
-		} else if (left == EXEC_ENVP) {
-			bool result;
-			const struct path_info *name, *value;
-			name = ptr2->string; ptr2++; i++;
-			value = ptr2->string; ptr2++; i++;
-			if (!bprm) goto out;
-			result = ScanBprm(bprm, false, 0, name, value, &failed, obj->tmp);
-			if (failed) goto out;
-			if (value) {
-				if (!match) result = !result;
-			} else {
-				if (match) result = !result;
-			}
-			if (result) continue;
-			goto out;
-		}
-		if ((left >= PATH1_UID && left < MAX_KEYWORD) || (right >= PATH1_UID && right < MAX_KEYWORD)) {
-			if (!obj) goto out;
+	unsigned long left_min = 0;
+	unsigned long left_max = 0;
+	unsigned long right_min = 0;
+	unsigned long right_max = 0;
+	const unsigned long *ptr;
+	const struct argv_entry *argv;
+	const struct envp_entry *envp;
+	u16 condc;
+	u16 argc;
+	u16 envc;
+	const struct condition_list *cond = ccs_get_condition_part(acl);
+	const struct linux_binprm *bprm;
+	if (!cond)
+		return true;
+	condc = cond->condc;
+	argc = cond->argc;
+	envc = cond->envc;
+	bprm = obj ? obj->bprm : NULL;
+	if (!bprm && (argc || envc))
+		return false;
+	ptr = (unsigned long *) (cond + 1);
+	argv = (const struct argv_entry *) (ptr + condc);
+	envp = (const struct envp_entry *) (argv + argc);
+	for (i = 0; i < condc; i++) {
+		const u32 header = *ptr;
+		const bool match = (header >> 16) & 1;
+		const u8 left = header >> 8, right = header;
+		ptr++;
+		if ((left >= PATH1_UID && left < MAX_KEYWORD) ||
+		    (right >= PATH1_UID && right < MAX_KEYWORD)) {
+			if (!obj)
+				goto out;
 			if (!obj->validate_done) {
-				GetAttributes(obj);
+				get_attributes(obj);
 				obj->validate_done = true;
 			}
 		}
 		switch (left) {
-		case TASK_UID:   left_min = left_max = task->uid; break;
-		case TASK_EUID:  left_min = left_max = task->euid; break;
-		case TASK_SUID:  left_min = left_max = task->suid; break;
-		case TASK_FSUID: left_min = left_max = task->fsuid; break;
-		case TASK_GID:   left_min = left_max = task->gid; break;
-		case TASK_EGID:  left_min = left_max = task->egid; break;
-		case TASK_SGID:  left_min = left_max = task->sgid; break;
-		case TASK_FSGID: left_min = left_max = task->fsgid; break;
-		case TASK_PID:   left_min = left_max = task->pid; break;
-		case TASK_PPID:  left_min = left_max = sys_getppid(); break;
+		case TASK_UID:
+			left_max = task->uid;
+			break;
+		case TASK_EUID:
+			left_max = task->euid;
+			break;
+		case TASK_SUID:
+			left_max = task->suid;
+			break;
+		case TASK_FSUID:
+			left_max = task->fsuid;
+			break;
+		case TASK_GID:
+			left_max = task->gid;
+			break;
+		case TASK_EGID:
+			left_max = task->egid;
+			break;
+		case TASK_SGID:
+			left_max = task->sgid;
+			break;
+		case TASK_FSGID:
+			left_max = task->fsgid;
+			break;
+		case TASK_PID:
+			left_max = task->pid;
+			break;
+		case TASK_PPID:
+			left_max = sys_getppid();
+			break;
 		case PATH1_UID:
-			if (!obj->path1_valid) goto out;
-			left_min = left_max = obj->path1_stat.uid; break;
+			if (!obj->path1_valid)
+				goto out;
+			left_max = obj->path1_stat.uid;
+			break;
 		case PATH1_GID:
-			if (!obj->path1_valid) goto out;
-			left_min = left_max = obj->path1_stat.gid; break;
+			if (!obj->path1_valid)
+				goto out;
+			left_max = obj->path1_stat.gid;
+			break;
 		case PATH1_INO:
-			if (!obj->path1_valid) goto out;
-			left_min = left_max = obj->path1_stat.ino; break;
+			if (!obj->path1_valid)
+				goto out;
+			left_max = obj->path1_stat.ino;
+			break;
 		case PATH1_PARENT_UID:
-			if (!obj->path1_parent_valid) goto out;
-			left_min = left_max = obj->path1_parent_stat.uid; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			left_max = obj->path1_parent_stat.uid;
+			break;
 		case PATH1_PARENT_GID:
-			if (!obj->path1_parent_valid) goto out;
-			left_min = left_max = obj->path1_parent_stat.gid; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			left_max = obj->path1_parent_stat.gid;
+			break;
 		case PATH1_PARENT_INO:
-			if (!obj->path1_parent_valid) goto out;
-			left_min = left_max = obj->path1_parent_stat.ino; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			left_max = obj->path1_parent_stat.ino;
+			break;
 		case PATH2_PARENT_UID:
-			if (!obj->path2_parent_valid) goto out;
-			left_min = left_max = obj->path2_parent_stat.uid; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			left_max = obj->path2_parent_stat.uid;
+			break;
 		case PATH2_PARENT_GID:
-			if (!obj->path2_parent_valid) goto out;
-			left_min = left_max = obj->path2_parent_stat.gid; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			left_max = obj->path2_parent_stat.gid;
+			break;
 		case PATH2_PARENT_INO:
-			if (!obj->path2_parent_valid) goto out;
-			left_min = left_max = obj->path2_parent_stat.ino; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			left_max = obj->path2_parent_stat.ino;
+			break;
 		case EXEC_ARGC:
-			if (!bprm) goto out;
-			left_min = left_max = bprm->argc; i++; break;
+			if (!bprm)
+				goto out;
+			left_max = bprm->argc;
+			i++;
+			break;
 		case EXEC_ENVC:
-			if (!bprm) goto out;
-			left_min = left_max = bprm->envc; i++; break;
-		case TASK_STATE_0: left_min = left_max = (u8) (task->tomoyo_flags >> 24); break;
-		case TASK_STATE_1: left_min = left_max = (u8) (task->tomoyo_flags >> 16); break;
-		case TASK_STATE_2: left_min = left_max = (u8) (task->tomoyo_flags >> 8); break;
-		case MAX_KEYWORD:     left_min = left_max = ptr2->value; ptr2++; i++; break;
-		case MAX_KEYWORD + 1: left_min = ptr2->value; ptr2++; left_max = ptr2->value; ptr2++; i += 2; break;
+			if (!bprm)
+				goto out;
+			left_max = bprm->envc;
+			i++;
+			break;
+		case TASK_STATE_0:
+			left_max = (u8) (task->tomoyo_flags >> 24);
+			break;
+		case TASK_STATE_1:
+			left_max = (u8) (task->tomoyo_flags >> 16);
+			break;
+		case TASK_STATE_2:
+			left_max = (u8) (task->tomoyo_flags >> 8);
+			break;
+		case MAX_KEYWORD:
+			left_max = *ptr;
+			ptr++;
+			i++;
+			break;
+		case MAX_KEYWORD + 1:
+			left_min = *ptr;
+			ptr++;
+			left_max = *ptr;
+			ptr++;
+			i += 2;
+			break;
 		}
+		if (left != MAX_KEYWORD + 1)
+			left_min = left_max;
 		switch (right) {
-		case TASK_UID:   right_min = right_max = task->uid; break;
-		case TASK_EUID:  right_min = right_max = task->euid; break;
-		case TASK_SUID:  right_min = right_max = task->suid; break;
-		case TASK_FSUID: right_min = right_max = task->fsuid; break;
-		case TASK_GID:   right_min = right_max = task->gid; break;
-		case TASK_EGID:  right_min = right_max = task->egid; break;
-		case TASK_SGID:  right_min = right_max = task->sgid; break;
-		case TASK_FSGID: right_min = right_max = task->fsgid; break;
-		case TASK_PID:   right_min = right_max = task->pid; break;
-		case TASK_PPID:  right_min = right_max = sys_getppid(); break;
+		case TASK_UID:
+			right_max = task->uid;
+			break;
+		case TASK_EUID:
+			right_max = task->euid;
+			break;
+		case TASK_SUID:
+			right_max = task->suid;
+			break;
+		case TASK_FSUID:
+			right_max = task->fsuid;
+			break;
+		case TASK_GID:
+			right_max = task->gid;
+			break;
+		case TASK_EGID:
+			right_max = task->egid;
+			break;
+		case TASK_SGID:
+			right_max = task->sgid;
+			break;
+		case TASK_FSGID:
+			right_max = task->fsgid;
+			break;
+		case TASK_PID:
+			right_max = task->pid;
+			break;
+		case TASK_PPID:
+			right_max = sys_getppid();
+			break;
 		case PATH1_UID:
-			if (!obj->path1_valid) goto out;
-			right_min = right_max = obj->path1_stat.uid; break;
+			if (!obj->path1_valid)
+				goto out;
+			right_max = obj->path1_stat.uid;
+			break;
 		case PATH1_GID:
-			if (!obj->path1_valid) goto out;
-			right_min = right_max = obj->path1_stat.gid; break;
+			if (!obj->path1_valid)
+				goto out;
+			right_max = obj->path1_stat.gid;
+			break;
 		case PATH1_INO:
-			if (!obj->path1_valid) goto out;
-			right_min = right_max = obj->path1_stat.ino; break;
+			if (!obj->path1_valid)
+				goto out;
+			right_max = obj->path1_stat.ino;
+			break;
 		case PATH1_PARENT_UID:
-			if (!obj->path1_parent_valid) goto out;
-			right_min = right_max = obj->path1_parent_stat.uid; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			right_max = obj->path1_parent_stat.uid;
+			break;
 		case PATH1_PARENT_GID:
-			if (!obj->path1_parent_valid) goto out;
-			right_min = right_max = obj->path1_parent_stat.gid; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			right_max = obj->path1_parent_stat.gid;
+			break;
 		case PATH1_PARENT_INO:
-			if (!obj->path1_parent_valid) goto out;
-			right_min = right_max = obj->path1_parent_stat.ino; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			right_max = obj->path1_parent_stat.ino;
+			break;
 		case PATH2_PARENT_UID:
-			if (!obj->path2_parent_valid) goto out;
-			right_min = right_max = obj->path2_parent_stat.uid; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			right_max = obj->path2_parent_stat.uid;
+			break;
 		case PATH2_PARENT_GID:
-			if (!obj->path2_parent_valid) goto out;
-			right_min = right_max = obj->path2_parent_stat.gid; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			right_max = obj->path2_parent_stat.gid;
+			break;
 		case PATH2_PARENT_INO:
-			if (!obj->path2_parent_valid) goto out;
-			right_min = right_max = obj->path2_parent_stat.ino; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			right_max = obj->path2_parent_stat.ino;
+			break;
 		case EXEC_ARGC:
-			if (!bprm) goto out;
-			right_min = right_max = bprm->argc; i++; break;
+			if (!bprm)
+				goto out;
+			right_max = bprm->argc;
+			i++;
+			break;
 		case EXEC_ENVC:
-			if (!bprm) goto out;
-			right_min = right_max = bprm->envc; i++; break;
-		case TASK_STATE_0: right_min = right_max = (u8) (task->tomoyo_flags >> 24); break;
-		case TASK_STATE_1: right_min = right_max = (u8) (task->tomoyo_flags >> 16); break;
-		case TASK_STATE_2: right_min = right_max = (u8) (task->tomoyo_flags >> 8); break;
-		case MAX_KEYWORD:     right_min = right_max = ptr2->value; ptr2++; i++; break;
-		case MAX_KEYWORD + 1: right_min = ptr2->value; ptr2++; right_max = ptr2->value; ptr2++; i += 2; break;
+			if (!bprm)
+				goto out;
+			right_max = bprm->envc;
+			i++;
+			break;
+		case TASK_STATE_0:
+			right_max = (u8) (task->tomoyo_flags >> 24);
+			break;
+		case TASK_STATE_1:
+			right_max = (u8) (task->tomoyo_flags >> 16);
+			break;
+		case TASK_STATE_2:
+			right_max = (u8) (task->tomoyo_flags >> 8);
+			break;
+		case MAX_KEYWORD:
+			right_max = *ptr;
+			ptr++;
+			i++;
+			break;
+		case MAX_KEYWORD + 1:
+			right_min = *ptr;
+			ptr++;
+			right_max = *ptr;
+			ptr++;
+			i += 2;
+			break;
 		}
+		if (right != MAX_KEYWORD + 1)
+			right_min = right_max;
 		if (match) {
-			if (left_min <= right_max && left_max >= right_min) continue;
+			if (left_min <= right_max && left_max >= right_min)
+				continue;
 		} else {
-			if (left_min > right_max || left_max < right_min) continue;
+			if (left_min > right_max || left_max < right_min)
+				continue;
 		}
-	out:
+ out:
 		return false;
 	}
+	if (bprm && (argc || envc))
+		return scan_bprm(bprm, argc, argv, envc, envp, obj->tmp);
 	return true;
 }
 
-void UpdateCondition(const struct acl_info *acl)
+/**
+ * ccs_update_condition - Update the current process's condition.
+ *
+ * @acl: Pointer to "struct acl_info".
+ *
+ * Returns nothing.
+ */
+void ccs_update_condition(const struct acl_info *acl)
 {
-	/* Don't change lower bits because TOMOYO_CHECK_READ_FOR_OPEN_EXEC
-	   and CCS_DONT_SLEEP_ON_ENFORCE_ERROR needs them. */
-	const struct condition_list *ptr = GetConditionPart(acl);
+	/*
+	 * Don't change lower bits because TOMOYO_CHECK_READ_FOR_OPEN_EXEC
+	 * and CCS_DONT_SLEEP_ON_ENFORCE_ERROR needs them.
+	 */
+	const struct condition_list *ptr = ccs_get_condition_part(acl);
 	struct task_struct *task;
 	u32 tomoyo_flags = current->tomoyo_flags;
 	const u8 flags = ptr ? ptr->post_state[3] : 0;
-	if (!flags) return;
+	if (!flags)
+		return;
 	task = current;
 	tomoyo_flags = task->tomoyo_flags;
-	if (flags & 1) { tomoyo_flags &= ~0xFF000000; tomoyo_flags |= ptr->post_state[0] << 24; }
-	if (flags & 2) { tomoyo_flags &= ~0x00FF0000; tomoyo_flags |= ptr->post_state[1] << 16; }
-	if (flags & 4) { tomoyo_flags &= ~0x0000FF00; tomoyo_flags |= ptr->post_state[2] << 8; }
+	if (flags & 1) {
+		tomoyo_flags &= ~0xFF000000;
+		tomoyo_flags |= ptr->post_state[0] << 24;
+	}
+	if (flags & 2) {
+		tomoyo_flags &= ~0x00FF0000;
+		tomoyo_flags |= ptr->post_state[1] << 16;
+	}
+	if (flags & 4) {
+		tomoyo_flags &= ~0x0000FF00;
+		tomoyo_flags |= ptr->post_state[2] << 8;
+	}
 	task->tomoyo_flags = tomoyo_flags;
 }
 
-int DumpCondition(struct io_buffer *head, const struct condition_list *ptr)
+/**
+ * ccs_dump_condition - Dump condition part.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @cond: Pointer to "struct condition_list". May be NULL.
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_dump_condition(struct ccs_io_buffer *head,
+			const struct condition_list *cond)
 {
-	if (ptr) {
-		u32 i;
-		const union element *ptr2 = (union element *) (((u8 *) ptr) + sizeof(*ptr));
-		char buffer[32];
-		memset(buffer, 0, sizeof(buffer));
-		for (i = 0; i < ptr->length; i++) {
-			const u16 match = (ptr2->value) >> 16;
-			const u8 left = (ptr2->value) >> 8, right = ptr2->value;
-			ptr2++;
-			if (io_printf(head, "%s", i ? " " : " if ")) break;
-			if (left == EXEC_ARGV) {
-				unsigned long index = ptr2->value; ptr2++;
-				if (io_printf(head, "%s%lu]", condition_control_keyword[left].keyword, index)) break;
-				i++;
-			} else if (left == EXEC_ENVP) {
-				const struct path_info *name = ptr2->string; ptr2++;
-				if (io_printf(head, "%s%s\"]", condition_control_keyword[left].keyword, name->name)) break;
-				i++;
-			} else if (left < MAX_KEYWORD) {
-				if (io_printf(head, "%s", condition_control_keyword[left].keyword)) break;
-			} else {
-				print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 2) & 3); ptr2++;
-				if (io_printf(head, "%s", buffer)) break;
-				i++;
-				if (left == MAX_KEYWORD + 1) {
-					print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 4) & 3); ptr2++;
-					if (io_printf(head, "-%s", buffer)) break;
-					i++;
-				}
-			}
-			if (io_printf(head, "%s", (match & 1) ? "=" : "!=")) break;
-			if (left == EXEC_ARGV || left == EXEC_ENVP) {
-				const struct path_info *name = ptr2->string; ptr2++;
-				if (name) {
-					if (io_printf(head, "\"%s\"", name->name)) break;
-				} else {
-					if (io_printf(head, "NULL")) break;
-				}
-				i++;
-			} else if (right < MAX_KEYWORD) {
-				if (io_printf(head, "%s", condition_control_keyword[right].keyword)) break;
-			} else {
-				print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 6) & 3); ptr2++;
-				if (io_printf(head, "%s", buffer)) break;
-				i++;
-				if (right == MAX_KEYWORD + 1) {
-					print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 8) & 3); ptr2++;
-					if (io_printf(head, "-%s", buffer)) break;
-					i++;
-				}
-			}
+	const unsigned long *ptr;
+	const struct argv_entry *argv;
+	const struct envp_entry *envp;
+	u16 condc;
+	u16 argc;
+	u16 envc;
+	u16 i;
+	u16 j;
+	char buffer[32];
+	if (!cond)
+		goto no_condition;
+	condc = cond->condc;
+	argc = cond->argc;
+	envc = cond->envc;
+	ptr = (const unsigned long *) (cond + 1);
+	argv = (const struct argv_entry *) (ptr + condc);
+	envp = (const struct envp_entry *) (argv + argc);
+	memset(buffer, 0, sizeof(buffer));
+	for (i = 0; i < condc; i++) {
+		const u32 header = *ptr;
+		const u8 match = (header >> 16) & 1;
+		const u8 left_1_type = (header >> 18) & 3;
+		const u8 left_2_type = (header >> 20) & 3;
+		const u8 right_1_type = (header >> 22) & 3;
+		const u8 right_2_type = (header >> 24) & 3;
+		const u8 left = header >> 8;
+		const u8 right = header;
+		ptr++;
+		if (!ccs_io_printf(head, "%s", i ? " " : " if "))
+			goto out;
+		if (left < MAX_KEYWORD) {
+			const char *keyword
+				= condition_control_keyword[left].keyword;
+			if (!ccs_io_printf(head, "%s", keyword))
+				goto out;
+			goto print_operator;
 		}
-		if (i < ptr->length) return -ENOMEM;
-		if ((i = ptr->post_state[3]) != 0) {
-			unsigned int j;
-			if (io_printf(head, " ; set")) return -ENOMEM;
-			for (j = 0; j < 3; j++) {
-				if (i & (1 << j)) {
-					if (io_printf(head, " task.state[%u]=%u", j, ptr->post_state[j])) return -ENOMEM;
-				}
-			}
+		print_ulong(buffer, sizeof(buffer) - 1, *ptr, left_1_type);
+		ptr++;
+		if (!ccs_io_printf(head, "%s", buffer))
+			goto out;
+		i++;
+		if (left == MAX_KEYWORD)
+			goto print_operator;
+		print_ulong(buffer, sizeof(buffer) - 1, *ptr, left_2_type);
+		ptr++;
+		if (!ccs_io_printf(head, "-%s", buffer))
+			goto out;
+		i++;
+ print_operator:
+		if (!ccs_io_printf(head, "%s", match ? "=" : "!="))
+			goto out;
+		if (right < MAX_KEYWORD) {
+			const char *keyword
+				= condition_control_keyword[right].keyword;
+			if (!ccs_io_printf(head, "%s", keyword))
+				goto out;
+			continue;
 		}
+		print_ulong(buffer, sizeof(buffer) - 1, *ptr, right_1_type);
+		ptr++;
+		if (!ccs_io_printf(head, "%s", buffer))
+			goto out;
+		i++;
+		if (right == MAX_KEYWORD)
+			continue;
+		print_ulong(buffer, sizeof(buffer) - 1, *ptr, right_2_type);
+		ptr++;
+		if (!ccs_io_printf(head, "-%s", buffer))
+			goto out;
+		i++;
 	}
-	return io_printf(head, "\n") ? -ENOMEM : 0;
+
+	if (!argc && !envc)
+		goto post_condition;
+	if (!condc && !ccs_io_printf(head, " if"))
+		goto out;
+	for (i = 0; i < argc; argv++, i++) {
+		const char *op = argv->is_not ? "!=" : "=";
+		if (!ccs_io_printf(head, " exec.argv[%u]%s\"%s\"", argv->index,
+				   op, argv->value->name))
+			goto out;
+	}
+	buffer[1] = '\0';
+	for (i = 0; i < envc; envp++, i++) {
+		const char *op = envp->is_not ? "!=" : "=";
+		const char *value = envp->value ? envp->value->name : NULL;
+		if (!ccs_io_printf(head, " exec.envp[\"%s\"]%s",
+				   envp->name->name, op))
+			goto out;
+		if (value) {
+			if (!ccs_io_printf(head, "\"%s\"", value))
+				goto out;
+		} else {
+			if (!ccs_io_printf(head, "NULL"))
+				goto out;
+		}
+	}
+ post_condition:
+	i = cond->post_state[3];
+	if (!i)
+		goto no_condition;
+	if (!ccs_io_printf(head, " ; set"))
+		goto out;
+	for (j = 0; j < 3; j++) {
+		if (!(i & (1 << j)))
+			continue;
+		if (!ccs_io_printf(head, " task.state[%u]=%u", j,
+				   cond->post_state[j]))
+			goto out;
+	}
+ no_condition:
+	if (ccs_io_printf(head, "\n"))
+		return true;
+ out:
+	return false;
 }
-
-/***** TOMOYO Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c	(working copy)
@@ -11,113 +11,199 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** TOMOYO Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/tomoyo.h>
 #include <linux/realpath.h>
 
-/*************************  AUDIT FUNCTIONS  *************************/
+/* Auditing functions. */
 
-static int AuditArgv0Log(const struct path_info *filename, const char *argv0, const bool is_granted, const u8 profile, const u8 mode)
+/**
+ * audit_argv0_log -
+ *
+ * @filename:   The fullpath of program.
+ * @argv0:      The basename of argv[0].
+ * @is_granted: True if this is a granted log.
+ * @profile:    Profile number.
+ * @mode:       Access control mode.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int audit_argv0_log(const struct path_info *filename, const char *argv0,
+			   const bool is_granted, const u8 profile,
+			   const u8 mode)
 {
 	char *buf;
-	int len;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
+	int len, len2;
+	if (ccs_can_save_audit_log(is_granted) < 0)
+		return -ENOMEM;
 	len = filename->total_len + strlen(argv0) + 8;
-	if ((buf = InitAuditLog(&len, profile, mode, NULL)) == NULL) return -ENOMEM;
-	snprintf(buf + strlen(buf), len - strlen(buf) - 1, KEYWORD_ALLOW_ARGV0 "%s %s\n", filename->name, argv0);
-	return WriteAuditLog(buf, is_granted);
+	buf = ccs_init_audit_log(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
+	len2 = strlen(buf);
+	snprintf(buf + len2, len - len2 - 1,
+		 KEYWORD_ALLOW_ARGV0 "%s %s\n", filename->name, argv0);
+	return ccs_write_audit_log(buf, is_granted);
 }
 
-/*************************  ARGV0 MISMATCH HANDLER  *************************/
+/* argv[0] mismatch handler. */
 
-static int AddArgv0Entry(const char *filename, const char *argv0, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * update_argv0_entry -
+ *
+ * @filename:  The fullpath of the program.
+ * @argv0:     The basename of argv[0].
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_argv0_entry(const char *filename, const char *argv0,
+			      struct domain_info *domain,
+			      const struct condition_list *condition,
+			      const bool is_delete)
 {
 	struct acl_info *ptr;
 	struct argv0_acl_record *acl;
 	const struct path_info *saved_filename, *saved_argv0;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(filename, 1, 0, -1, __FUNCTION__) || !IsCorrectPath(argv0, -1, 0, -1, __FUNCTION__) || strchr(argv0, '/')) return -EINVAL;
-	if ((saved_filename = SaveName(filename)) == NULL || (saved_argv0 = SaveName(argv0)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(filename, 1, 0, -1, __func__) ||
+	    !ccs_is_correct_path(argv0, -1, 0, -1, __func__) ||
+	    strchr(argv0, '/'))
+		return -EINVAL;
+	saved_filename = ccs_save_name(filename);
+	saved_argv0 = ccs_save_name(argv0);
+	if (!saved_filename || !saved_argv0)
+		return -ENOMEM;
 	mutex_lock(&domain_acl_lock);
-	if (!is_delete) {
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_ARGV0_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct argv0_acl_record, head);
-			if (acl->filename != saved_filename || acl->argv0 != saved_argv0) continue;
-			error = AddDomainACL(NULL, ptr);
-			goto out;
-		}
-		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_ARGV0_ACL, condition)) == NULL) goto out;
-		acl->filename = saved_filename;
-		acl->argv0 = saved_argv0;
-		error = AddDomainACL(domain, &acl->head);
-	} else {
-		error = -ENOENT;
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ARGV0_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
-			acl = container_of(ptr, struct argv0_acl_record, head);
-			if (acl->filename != saved_filename || acl->argv0 != saved_argv0) continue;
-			error = DelDomainACL(ptr);
-			break;
-		}
+	if (is_delete)
+		goto delete;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION))
+		    != TYPE_ARGV0_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct argv0_acl_record, head);
+		if (acl->filename != saved_filename ||
+		    acl->argv0 != saved_argv0)
+			continue;
+		error = ccs_add_domain_acl(NULL, ptr);
+		goto out;
 	}
- out: ;
+	/* Not found. Append it to the tail. */
+	acl = ccs_alloc_acl_element(TYPE_ARGV0_ACL, condition);
+	if (!acl)
+		goto out;
+	acl->filename = saved_filename;
+	acl->argv0 = saved_argv0;
+	error = ccs_add_domain_acl(domain, &acl->head);
+	goto out;
+ delete:
+	error = -ENOENT;
+	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ARGV0_ACL)
+			continue;
+		if (ccs_get_condition_part(ptr) != condition)
+			continue;
+		acl = container_of(ptr, struct argv0_acl_record, head);
+		if (acl->filename != saved_filename ||
+		    acl->argv0 != saved_argv0)
+			continue;
+		error = ccs_del_domain_acl(ptr);
+		break;
+	}
+ out:
 	mutex_unlock(&domain_acl_lock);
 	return error;
 }
 
-static int CheckArgv0ACL(const struct path_info *filename, const char *argv0_)
+/**
+ * check_argv0_acl -
+ *
+ * @filename: The fullpath of the program.
+ * @argv0:    The basename of argv[0].
+ *
+ * Returns 0 on success, -EPERM otherwise.
+ */
+static int check_argv0_acl(const struct path_info *filename, const char *argv0)
 {
 	const struct domain_info *domain = current->domain_info;
 	int error = -EPERM;
 	struct acl_info *ptr;
-	struct path_info argv0;
-	argv0.name = argv0_;
-	fill_path_info(&argv0);
+	struct path_info argv_0;
+	argv_0.name = argv0;
+	ccs_fill_path_info(&argv_0);
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct argv0_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ARGV0_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ARGV0_ACL)
+			continue;
 		acl = container_of(ptr, struct argv0_acl_record, head);
-		if (!CheckCondition(ptr, NULL) ||
-		    !PathMatchesToPattern(filename, acl->filename) ||
-		    !PathMatchesToPattern(&argv0, acl->argv0)) continue;
-		UpdateCondition(ptr);
+		if (!ccs_check_condition(ptr, NULL) ||
+		    !ccs_path_matches_pattern(filename, acl->filename) ||
+		    !ccs_path_matches_pattern(&argv_0, acl->argv0))
+			continue;
+		ccs_update_condition(ptr);
 		error = 0;
 		break;
 	}
 	return error;
 }
 
-int CheckArgv0Perm(const struct path_info *filename, const char *argv0)
+/**
+ * ccs_check_argv0_perm -
+ *
+ * @filename: The fullpath of the program.
+ * @argv0:    The basename of argv[0].
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_check_argv0_perm(const struct path_info *filename, const char *argv0)
 {
 	int error = 0;
 	struct domain_info * const domain = current->domain_info;
 	const u8 profile = domain->profile;
-	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_ARGV0);
+	const u8 mode = ccs_check_flags(CCS_TOMOYO_MAC_FOR_ARGV0);
 	const bool is_enforce = (mode == 3);
-	if (!filename || !argv0 || !*argv0) return 0;
-	error = CheckArgv0ACL(filename, argv0);
-	AuditArgv0Log(filename, argv0, !error, profile, mode);
-	if (!error) return 0;
-	if (TomoyoVerboseMode()) {
-		printk("TOMOYO-%s: Run %s as %s denied for %s\n", GetMSG(is_enforce), filename->name, argv0, GetLastName(domain));
-	}
-	if (is_enforce) return CheckSupervisor("%s\n" KEYWORD_ALLOW_ARGV0 "%s %s\n", domain->domainname->name, filename->name, argv0);
-	else if (mode == 1 && CheckDomainQuota(domain)) AddArgv0Entry(filename->name, argv0, domain, NULL, 0);
+	if (!filename || !argv0 || !*argv0)
+		return 0;
+	error = check_argv0_acl(filename, argv0);
+	audit_argv0_log(filename, argv0, !error, profile, mode);
+	if (!error)
+		return 0;
+	if (ccs_verbose_mode())
+		printk(KERN_WARNING "TOMOYO-%s: Run %s as %s denied for %s\n",
+		       ccs_get_msg(is_enforce), filename->name, argv0,
+		       ccs_get_last_name(domain));
+	if (is_enforce)
+		return ccs_check_supervisor("%s\n"
+					    KEYWORD_ALLOW_ARGV0 "%s %s\n",
+					    domain->domainname->name,
+					    filename->name, argv0);
+	else if (mode == 1 && ccs_check_domain_quota(domain))
+		update_argv0_entry(filename->name, argv0, domain, NULL, false);
 	return 0;
 }
 
-int AddArgv0Policy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
+/**
+ * ccs_write_argv0_policy -
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct domain_info".
+ * @condition: Pointer to "struct condition_list". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_write_argv0_policy(char *data, struct domain_info *domain,
+			   const struct condition_list *condition,
+			   const bool is_delete)
 {
 	char *argv0 = strchr(data, ' ');
-	if (!argv0) return -EINVAL;
+	if (!argv0)
+		return -EINVAL;
 	*argv0++ = '\0';
-	return AddArgv0Entry(data, argv0, domain, condition, is_delete);
+	return update_argv0_entry(data, argv0, domain, condition, is_delete);
 }
-
-/***** TOMOYO Linux end. *****/
Index: trunk/1.6.x/ccs-patch/fs/sakura_umount.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_umount.c	(revision 1045)
+++ trunk/1.6.x/ccs-patch/fs/sakura_umount.c	(working copy)
@@ -11,18 +11,17 @@
  * See README.ccs for ChangeLog.
  *
  */
-/***** SAKURA Linux start. *****/
 
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
 #include <linux/mount.h>
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namespace.h>
 #endif
 
-/***** The structure for unmount restrictions. *****/
+/* The structure for unmount restrictions. */
 
 struct no_umount_entry {
 	struct list1_head list;
@@ -30,18 +29,29 @@
 	bool is_deleted;
 };
 
-/*************************  UMOUNT RESTRICTION HANDLER  *************************/
+/* Unmount restriction handler. */
 
 static LIST1_HEAD(no_umount_list);
 
-static int AddNoUmountACL(const char *dir, const bool is_delete)
+/**
+ * update_no_umount_acl -
+ *
+ * @dir:       The name of directrory.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int update_no_umount_acl(const char *dir, const bool is_delete)
 {
 	struct no_umount_entry *new_entry, *ptr;
 	const struct path_info *saved_dir;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
-	if (!IsCorrectPath(dir, 1, 0, 1, __FUNCTION__)) return -EINVAL;
-	if ((saved_dir = SaveName(dir)) == NULL) return -ENOMEM;
+	if (!ccs_is_correct_path(dir, 1, 0, 1, __func__))
+		return -EINVAL;
+	saved_dir = ccs_save_name(dir);
+	if (!saved_dir)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &no_umount_list, list) {
 		if (ptr->dir == saved_dir) {
@@ -54,66 +64,104 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = ccs_alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->dir = saved_dir;
 	list1_add_tail_mb(&new_entry->list, &no_umount_list);
 	error = 0;
-	printk("%sDon't allow umount %s\n", ccs_log_level, dir);
+	printk(KERN_CONT "%sDon't allow umount %s\n", ccs_log_level, dir);
  out:
 	mutex_unlock(&lock);
 	return error;
 }
 
-int SAKURA_MayUmount(struct vfsmount *mnt)
+/**
+ * ccs_may_umount -
+ *
+ * @mnt: Pointer to "struct vfsmount".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int ccs_may_umount(struct vfsmount *mnt)
 {
 	int error = -EPERM;
 	const char *dir0;
-	const u8 mode = CheckCCSFlags(CCS_SAKURA_RESTRICT_UNMOUNT);
+	const u8 mode = ccs_check_flags(CCS_SAKURA_RESTRICT_UNMOUNT);
 	const bool is_enforce = (mode == 3);
-	if (!mode) return 0;
-	dir0 = realpath_from_dentry(mnt->mnt_root, mnt);
+	if (!mode)
+		return 0;
+	dir0 = ccs_realpath_from_dentry(mnt->mnt_root, mnt);
 	if (dir0) {
 		struct no_umount_entry *ptr;
 		struct path_info dir;
 		bool found = false;
 		dir.name = dir0;
-		fill_path_info(&dir);
+		ccs_fill_path_info(&dir);
 		list1_for_each_entry(ptr, &no_umount_list, list) {
-			if (ptr->is_deleted) continue;
-			if (PathMatchesToPattern(&dir, ptr->dir)) {
+			if (ptr->is_deleted)
+				continue;
+			if (ccs_path_matches_pattern(&dir, ptr->dir)) {
 				found = true;
 				break;
 			}
 		}
 		if (found) {
-			const char *exename = GetEXE();
-			printk("SAKURA-%s: umount %s (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), dir0, current->pid, exename);
-			if (is_enforce && CheckSupervisor("# %s is requesting\nunmount %s\n", exename, dir0) == 0) error = 0;
+			const char *exename = ccs_get_exe();
+			printk(KERN_WARNING "SAKURA-%s: umount %s "
+			       "(pid=%d:exe=%s): Permission denied.\n",
+			       ccs_get_msg(is_enforce), dir0, current->pid,
+			       exename);
+			if (!is_enforce)
+				goto not_enforcing;
+			error = ccs_check_supervisor("# %s is requesting\n"
+						     "unmount %s\n",
+						     exename, dir0);
+ not_enforcing:
 			ccs_free(exename);
 		} else {
 			error = 0;
 		}
 		ccs_free(dir0);
 	}
-	if (!is_enforce) error = 0;
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
 
-int AddNoUmountPolicy(char *data, const bool is_delete)
+/**
+ * ccs_write_no_umount_policy -
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on sucess, negative value otherwise.
+ */
+int ccs_write_no_umount_policy(char *data, const bool is_delete)
 {
-	return AddNoUmountACL(data, is_delete);
+	return update_no_umount_acl(data, is_delete);
 }
 
-int ReadNoUmountPolicy(struct io_buffer *head)
+/**
+ * ccs_read_no_umount_policy -
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ */
+bool ccs_read_no_umount_policy(struct ccs_io_buffer *head)
 {
 	struct list1_head *pos;
 	list1_for_each_cookie(pos, head->read_var2, &no_umount_list) {
 		struct no_umount_entry *ptr;
 		ptr = list1_entry(pos, struct no_umount_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_DENY_UNMOUNT "%s\n", ptr->dir->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (!ccs_io_printf(head, KEYWORD_DENY_UNMOUNT "%s\n",
+				   ptr->dir->name))
+			goto out;
 	}
-	return 0;
+	return true;
+ out:
+	return false;
 }
-
-/***** SAKURA Linux end. *****/
