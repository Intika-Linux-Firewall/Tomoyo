Index: trunk/1.6.x/ccs-patch/include/linux/ccs_common.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(revision 1029)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(working copy)
@@ -168,6 +168,10 @@
 
 #endif
 
+struct ccs_page_buffer {
+	char buffer[4096];
+};
+
 struct mini_stat {
 	uid_t uid;
 	gid_t gid;
@@ -189,6 +193,7 @@
 	struct mini_stat path1_parent_stat;
 	struct mini_stat path2_parent_stat;
 	struct linux_binprm *bprm;
+	struct ccs_page_buffer *buf;
 };
 
 struct path_info {
Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(revision 1029)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(working copy)
@@ -40,6 +40,7 @@
 struct inode;
 struct linux_binprm;
 struct pt_regs;
+struct ccs_page_buffer;
 
 #define CheckSingleWritePermission CheckSinglePathPermission
 #define CheckDoubleWritePermission CheckDoublePathPermission
@@ -47,7 +48,7 @@
 #if defined(CONFIG_TOMOYO)
 
 int CheckFilePerm(const char *filename, const u8 perm, const char *operation);
-int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm);
+int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm, struct ccs_page_buffer *buf);
 int CheckOpenPermission(struct dentry *dentry, struct vfsmount *mnt, const int flag);
 int CheckSinglePathPermission(const u8 operation, struct dentry *dentry, struct vfsmount *mnt);
 int CheckDoublePathPermission(const u8 operation, struct dentry *dentry1, struct vfsmount *mnt1, struct dentry *dentry2, struct vfsmount *mnt2);
@@ -76,7 +77,7 @@
 #else
 
 static inline int CheckFilePerm(const char *filename, const u8 perm, const char *operation) { return 0; }
-static inline int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm)  { return 0; }
+static inline int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm, struct ccs_page_buffer *buf)  { return 0; }
 static inline int CheckOpenPermission(struct dentry *dentry, struct vfsmount *mnt, const int flag) { return 0; }
 static inline int CheckSinglePathPermission(const u8 operation, struct dentry *dentry, struct vfsmount *mnt) { return 0; }
 static inline int CheckDoublePathPermission(const u8 operation, struct dentry *dentry1, struct vfsmount *mnt1, struct dentry *dentry2, struct vfsmount *mnt2) { return 0; }
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(revision 1029)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(working copy)
@@ -534,83 +534,71 @@
 	return domain;
 }
 
-static int Escape(char *dest, const char *src, int dest_len)
+static bool get_argv0(struct linux_binprm *bprm, struct ccs_page_buffer *buf)
 {
-	while (*src) {
-		const unsigned char c = * (const unsigned char *) src;
-		if (c == '\\') {
-			dest_len -= 2;
-			if (dest_len <= 0) goto out;
-			*dest++ = '\\';
-			*dest++ = '\\';
-		} else if (c > ' ' && c < 127) {
-			if (--dest_len <= 0) goto out;
-			*dest++ = c;
-		} else {
-			dest_len -= 4;
-			if (dest_len <= 0) goto out;
-			*dest++ = '\\';
-			*dest++ = (c >> 6) + '0';
-			*dest++ = ((c >> 3) & 7) + '0';
-			*dest++ = (c & 7) + '0';
-		}
-		src++;
-	}
-	if (--dest_len <= 0) goto out;
-	*dest = '\0';
-	return 0;
- out:
-	return -ENOMEM;
-}
-
-static char *get_argv0(struct linux_binprm *bprm)
-{
-	char *arg_ptr = ccs_alloc(PAGE_SIZE); /* Initial buffer. */
+	char *arg_ptr = buf->buffer;
 	int arg_len = 0;
 	unsigned long pos = bprm->p;
 	int i = pos / PAGE_SIZE, offset = pos % PAGE_SIZE;
-	if (!bprm->argc || !arg_ptr) goto out;
+	bool done = false;
+	if (!bprm->argc) goto out;
+	memset(arg_ptr, 0, sizeof(struct ccs_page_buffer));
 	while (1) {
 		struct page *page;
+		const char *kaddr;
+			
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
 		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0) goto out;
+		pos += PAGE_SIZE - offset;
 #else
 		page = bprm->page[i];
 #endif
-		{ /* Map and copy to kernel buffer and unmap. */
-			const char *kaddr = kmap(page);
-			if (!kaddr) { /* Mapping failed. */
+		/* Map. */
+		kaddr = kmap(page);
+		if (!kaddr) { /* Mapping failed. */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
-				put_page(page);
+			put_page(page);
 #endif
-				goto out;
+			goto out;
+		}
+		/* Read. */
+		while (offset < PAGE_SIZE) {
+			const unsigned char c = kaddr[offset++];
+			if (c && arg_len < CCS_MAX_PATHNAME_LEN - 10) {
+				if (c == '\\') {
+					arg_ptr[arg_len++] = '\\';
+					arg_ptr[arg_len++] = '\\';
+				} else if (c == '/') {
+					arg_len = 0;
+				} else if (c > ' ' && c < 127) {
+					arg_ptr[arg_len++] = c;
+				} else {
+					arg_ptr[arg_len++] = '\\';
+					arg_ptr[arg_len++] = (c >> 6) + '0';
+					arg_ptr[arg_len++] = ((c >> 3) & 7) + '0';
+					arg_ptr[arg_len++] = (c & 7) + '0';
+				}
+			} else {
+				arg_ptr[arg_len] = '\0';
+				done = true;
+				break;
 			}
-			memmove(arg_ptr + arg_len, kaddr + offset, PAGE_SIZE - offset);
-			kunmap(page);
 		}
+		/* Unmap. */
+		kunmap(page);
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
 		put_page(page);
-		pos += PAGE_SIZE - offset;
 #endif
-		arg_len += PAGE_SIZE - offset;
-		if (memchr(arg_ptr, '\0', arg_len)) break;
-		{ /* Initial buffer was too small for argv[0]. Retry after expanding buffer. */
-			char *tmp_arg_ptr = ccs_alloc(arg_len + PAGE_SIZE);
-			if (!tmp_arg_ptr) goto out;
-			memmove(tmp_arg_ptr, arg_ptr, arg_len);
-			ccs_free(arg_ptr);
-			arg_ptr = tmp_arg_ptr;
-		}
 		i++;
 		offset = 0;
+		if (done) break;
 	}
-	return arg_ptr;
- out: /* Release initial buffer. */
-	ccs_free(arg_ptr);
-	return NULL;
+	return true;
+ out:
+	return false;
 }
 
-static int FindNextDomain(struct linux_binprm *bprm, struct domain_info **next_domain, const struct path_info *path_to_verify)
+static int FindNextDomain(struct linux_binprm *bprm, struct domain_info **next_domain, const struct path_info *path_to_verify, struct ccs_page_buffer *buf)
 {
 	/* This function assumes that the size of buffer returned by realpath() = CCS_MAX_PATHNAME_LEN. */
 	struct domain_info *old_domain = current->domain_info, *domain = NULL;
@@ -675,22 +663,15 @@
 	
 	/* Compare basename of real_program_name and argv[0] */
 	if (bprm->argc > 0 && CheckCCSFlags(CCS_TOMOYO_MAC_FOR_ARGV0)) {
-		char *org_argv0 = get_argv0(bprm);
+		char *base_argv0 = buf->buffer;
+		const char *base_filename;
 		retval = -ENOMEM;
-		if (org_argv0) {
-			const int len = strlen(org_argv0);
-			char *printable_argv0 = ccs_alloc(len * 4 + 8);
-			if (printable_argv0 && Escape(printable_argv0, org_argv0, len * 4 + 8) == 0) {
-				const char *base_argv0, *base_filename;
-				if ((base_argv0 = strrchr(printable_argv0, '/')) == NULL) base_argv0 = printable_argv0; else base_argv0++;
-				if ((base_filename = strrchr(real_program_name, '/')) == NULL) base_filename = real_program_name; else base_filename++;
-				if (strcmp(base_argv0, base_filename)) retval = CheckArgv0Perm(&r, base_argv0);
-				else retval = 0;
-			}
-			ccs_free(printable_argv0);
-			ccs_free(org_argv0);
+		if (!get_argv0(bprm, buf)) goto out;
+		if ((base_filename = strrchr(real_program_name, '/')) == NULL) base_filename = real_program_name; else base_filename++;
+		if (strcmp(base_argv0, base_filename)) {
+			retval = CheckArgv0Perm(&r, base_argv0);
+			if (retval) goto out;
 		}
-		if (retval) goto out;
 	}
 	
 	/* Check 'aggregator' directive. */
@@ -707,13 +688,10 @@
 	}
 
 	/* Check execute permission. */
-	if ((retval = CheckExecPerm(&r, bprm)) < 0) goto out;
+	if ((retval = CheckExecPerm(&r, bprm, buf)) < 0) goto out;
 
  ok: ;
-	/* Allocate memory for calcurating domain name. */
-	retval = -ENOMEM;
-	if ((new_domain_name = ccs_alloc(CCS_MAX_PATHNAME_LEN + 16)) == NULL) goto out;
-	
+	new_domain_name = buf->buffer;
 	if (IsDomainInitializer(old_domain->domainname, &r, &l)) {
 		/* Transit to the child of KERNEL_DOMAIN domain. */
 		snprintf(new_domain_name, CCS_MAX_PATHNAME_LEN + 1, ROOT_NAME " " "%s", real_program_name);
@@ -745,18 +723,17 @@
 		retval = 0;
 	}
  out: ;
-	ccs_free(new_domain_name);
 	ccs_free(real_program_name);
 	ccs_free(symlink_program_name);
 	*next_domain = domain ? domain : old_domain;
 	return retval;
 }
 
-static int CheckEnviron(struct linux_binprm *bprm)
+static int CheckEnviron(struct linux_binprm *bprm, struct ccs_page_buffer *buf)
 {
 	const u8 profile = current->domain_info->profile;
 	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_ENV);
-	char *arg_ptr;
+	char *arg_ptr = buf->buffer;
 	int arg_len = 0;
 	unsigned long pos = bprm->p;
 	int i = pos / PAGE_SIZE, offset = pos % PAGE_SIZE;
@@ -765,8 +742,6 @@
 	//printk("start %d %d\n", argv_count, envp_count);
 	int error = -ENOMEM;
 	if (!mode || !envp_count) return 0;
-	arg_ptr = ccs_alloc(CCS_MAX_PATHNAME_LEN);
-	if (!arg_ptr) goto out;
 	while (error == -ENOMEM) {
 		struct page *page;
 		const char *kaddr;
@@ -776,7 +751,7 @@
 #else
 		page = bprm->page[i];
 #endif
-		/* Map */
+		/* Map. */
 		kaddr = kmap(page);
 		if (!kaddr) { /* Mapping failed. */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
@@ -829,7 +804,6 @@
 		offset = 0;
 	}
  out:
-	ccs_free(arg_ptr);
 	if (error && mode != 3) error = 0;
 	return error;
 }
@@ -914,7 +888,7 @@
 	return depth;
 }
 
-static int try_alt_exec(struct linux_binprm *bprm, const struct path_info *filename, char **work, struct domain_info **next_domain)
+static int try_alt_exec(struct linux_binprm *bprm, const struct path_info *filename, char **work, struct domain_info **next_domain, struct ccs_page_buffer *buf)
 {
 	/*
 	 * Contents of modified bprm.
@@ -985,10 +959,8 @@
 		memmove(execute_handler, cp, strlen(cp) + 1);
 	}
 
-	/* Allocate buffer. */
-	buffer = ccs_alloc(buffer_len);
-	if (!buffer) return -ENOMEM;
-
+	buffer = buf->buffer;
+	
 	/* Move envp[] to argv[] */
 	bprm->argc += bprm->envc;
 	bprm->envc = 0;
@@ -1071,11 +1043,9 @@
 	retval = prepare_binprm(bprm);
 	if (retval < 0) goto out;
 	task->tomoyo_flags |= CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
-	retval = FindNextDomain(bprm, next_domain, filename);
+	retval = FindNextDomain(bprm, next_domain, filename, buf);
 	task->tomoyo_flags &= ~CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
  out:
-	/* Free buffer. */
-	ccs_free(buffer);
 	return retval;
 }
 
@@ -1100,18 +1070,20 @@
 	const struct path_info *handler;
  	int retval;
 	char *work = NULL; /* Keep valid until search_binary_handler() finishes. */
+	struct ccs_page_buffer *buf = ccs_alloc(sizeof(struct ccs_page_buffer));
 	CCS_LoadPolicy(bprm->filename);
+	if (!buf) return -ENOMEM;
 	//printk("rootdepth=%d\n", GetRootDepth());
 	handler = FindExecuteHandler(true);
 	if (handler) {
-		retval = try_alt_exec(bprm, handler, &work, &next_domain);
-	} else if ((retval = FindNextDomain(bprm, &next_domain, NULL)) == -EPERM) {
+		retval = try_alt_exec(bprm, handler, &work, &next_domain, buf);
+	} else if ((retval = FindNextDomain(bprm, &next_domain, NULL, buf)) == -EPERM) {
 		handler = FindExecuteHandler(false);
-		if (handler) retval = try_alt_exec(bprm, handler, &work, &next_domain);
+		if (handler) retval = try_alt_exec(bprm, handler, &work, &next_domain, buf);
 	}
 	if (retval) goto out;
 	task->domain_info = next_domain;
-	retval = CheckEnviron(bprm);
+	retval = CheckEnviron(bprm, buf);
 	if (retval) goto out;
 	task->tomoyo_flags |= TOMOYO_CHECK_READ_FOR_OPEN_EXEC;
 	retval = search_binary_handler(bprm, regs);
@@ -1119,6 +1091,7 @@
  out:
 	if (retval < 0) task->domain_info = prev_domain;
 	ccs_free(work);
+	ccs_free(buf);
 	return retval;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(revision 1029)
+++ trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(working copy)
@@ -94,6 +94,7 @@
 	CreateEntry("manager",          0600, ccs_dir, CCS_MANAGER);
 	CreateEntry(".updates_counter", 0400, ccs_dir, CCS_UPDATESCOUNTER);
 	CreateEntry("version",          0400, ccs_dir, CCS_VERSION);
+	if (sizeof(struct ccs_page_buffer) <  CCS_MAX_PATHNAME_LEN - 16) panic("Bad size!");
 }
 
 #else
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_file.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(revision 1029)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(working copy)
@@ -763,7 +763,7 @@
 	return CheckFilePerm2(&filename, perm, operation, NULL, profile, mode);
 }
 
-int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm)
+int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm, struct ccs_page_buffer *buf)
 {
 	struct obj_info obj;
 	const u8 profile = current->domain_info->profile;
@@ -773,6 +773,7 @@
 	obj.path1_dentry = bprm->file->f_dentry;
 	obj.path1_vfsmnt = bprm->file->f_vfsmnt;
 	obj.bprm = bprm;
+	obj.buf = buf;
 	return CheckFilePerm2(filename, 1, "do_execve", &obj, profile, mode);
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(revision 1029)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(working copy)
@@ -21,7 +21,7 @@
 #include <linux/highmem.h>
 #include <linux/binfmts.h>
 
-static bool ScanBprm(struct linux_binprm *bprm, const bool is_argv, unsigned long index, const struct path_info *name, const struct path_info *value, bool *failed)
+static bool ScanBprm(struct linux_binprm *bprm, const bool is_argv, unsigned long index, const struct path_info *name, const struct path_info *value, bool *failed, struct ccs_page_buffer *buf)
 {
 	/*
 	  if exec.argc=3                  // if (argc == 3)
@@ -34,19 +34,13 @@
 	  if exec.envp["HOME"]="/"        // if (getenv("HOME") && strcmp(getenv("HOME"), "/") == 0)
 	  if exec.envp["HOME"]!="/"       // if (!getenv("HOME") || strcmp(getenv("HOME", "/")) 
 	*/
-	char *arg_ptr;
+	char *arg_ptr = buf->buffer;
 	int arg_len = 0;
 	unsigned long pos = bprm->p;
 	int i = pos / PAGE_SIZE, offset = pos % PAGE_SIZE;
 	int argv_count = bprm->argc;
 	int envp_count = bprm->envc;
 	bool result = false;
-	arg_ptr = ccs_alloc(CCS_MAX_PATHNAME_LEN);
-	if (!arg_ptr) {
-		*failed = true;
-		printk("ccs_alloc() failed\n");
-		return false;
-	}
 	while (argv_count || envp_count) {
 		struct page *page;
 		const char *kaddr;
@@ -60,7 +54,7 @@
 #else
 		page = bprm->page[i];
 #endif
-		/* Map */
+		/* Map. */
 		kaddr = kmap(page);
 		if (!kaddr) { /* Mapping failed. */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
@@ -137,7 +131,6 @@
 		offset = 0;
 	}
  out:
-	ccs_free(arg_ptr);
 	return result;
 }
 
@@ -649,7 +642,7 @@
 			index = ptr2->value; ptr2++; i++;
 			value = ptr2->string; ptr2++; i++;
 			if (!bprm) goto out;
-			result = ScanBprm(bprm, true, index, NULL, value, &failed);
+			result = ScanBprm(bprm, true, index, NULL, value, &failed, obj->buf);
 			if (failed) goto out;
 			if (!match) result = !result;
 			if (result) continue;
@@ -660,7 +653,7 @@
 			name = ptr2->string; ptr2++; i++;
 			value = ptr2->string; ptr2++; i++;
 			if (!bprm) goto out;
-			result = ScanBprm(bprm, false, 0, name, value, &failed);
+			result = ScanBprm(bprm, false, 0, name, value, &failed, obj->buf);
 			if (failed) goto out;
 			if (value) {
 				if (!match) result = !result;
