Index: ccstools.src/ccstools.h
===================================================================
--- ccstools.src/ccstools.h	(リビジョン 1537)
+++ ccstools.src/ccstools.h	(作業コピー)
@@ -5,7 +5,7 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.2   2008/06/25
+ * Version: 1.6.4+   2008/09/07
  *
  */
 
@@ -14,6 +14,7 @@
 #define _FILE_OFFSET_BITS 64
 #define _LARGEFILE_SOURCE
 #define _LARGEFILE64_SOURCE
+#define s8 __s8
 #define u8 __u8
 #define u16 __u16
 #define u32 __u32
@@ -39,6 +40,10 @@
 #include <time.h>
 #include <unistd.h>
 
+#define bool _Bool
+#define true     1
+#define false    0
+
 #define SYSTEM_POLICY_FILE    "system_policy"
 #define EXCEPTION_POLICY_FILE "exception_policy"
 #define DOMAIN_POLICY_FILE    "domain_policy"
@@ -100,7 +105,8 @@
 #define KEYWORD_FILE_PATTERN             "file_pattern "
 #define KEYWORD_FILE_PATTERN_LEN         (sizeof(KEYWORD_FILE_PATTERN) - 1)
 #define KEYWORD_MAC_FOR_CAPABILITY       "MAC_FOR_CAPABILITY::"
-#define KEYWORD_MAC_FOR_CAPABILITY_LEN   (sizeof(KEYWORD_MAC_FOR_CAPABILITY) - 1)
+#define KEYWORD_MAC_FOR_CAPABILITY_LEN   \
+	(sizeof(KEYWORD_MAC_FOR_CAPABILITY) - 1)
 #define KEYWORD_SELECT                   "select "
 #define KEYWORD_SELECT_LEN               (sizeof(KEYWORD_SELECT) - 1)
 #define KEYWORD_UNDELETE                 "undelete "
@@ -116,10 +122,15 @@
 #define KEYWORD_ADDRESS_GROUP            "address_group "
 #define KEYWORD_ADDRESS_GROUP_LEN        (sizeof(KEYWORD_ADDRESS_GROUP) - 1)
 #define KEYWORD_NO_INITIALIZE_DOMAIN     "no_" KEYWORD_INITIALIZE_DOMAIN
-#define KEYWORD_NO_INITIALIZE_DOMAIN_LEN (sizeof(KEYWORD_NO_INITIALIZE_DOMAIN) - 1)
+#define KEYWORD_NO_INITIALIZE_DOMAIN_LEN \
+	(sizeof(KEYWORD_NO_INITIALIZE_DOMAIN) - 1)
 #define KEYWORD_NO_KEEP_DOMAIN           "no_" KEYWORD_KEEP_DOMAIN
 #define KEYWORD_NO_KEEP_DOMAIN_LEN       (sizeof(KEYWORD_NO_KEEP_DOMAIN) - 1)
 
+#define KEYWORD_EXECUTE_HANDLER          "execute_handler "
+#define KEYWORD_DENIED_EXECUTE_HANDLER   "denied_execute_handler "
+#define KEYWORD_ALLOW_EXECUTE            "allow_executer "
+
 #define CCS_AUDITD_MAX_FILES             2
 #define SAVENAME_MAX_HASH                256
 #define PAGE_SIZE                        4096
@@ -195,17 +206,19 @@
 
 struct domain_info {
 	const struct path_info *domainname;
-	const struct domain_initializer_entry *domain_initializer; /* This may be NULL */
-	const struct domain_keeper_entry *domain_keeper;           /* This may be NULL */
+	/* This may be NULL */
+	const struct domain_initializer_entry *domain_initializer;
+	/* This may be NULL */
+	const struct domain_keeper_entry *domain_keeper;
 	const struct path_info **string_ptr;
 	int string_count;
-	int number; /* domain number (-1 if is_domain_initializer_source or is_domain_deleted) */ 
+	int number; /* domain number (-1 if is_dis or is_dd) */
 	u8 profile;
-	unsigned char is_domain_initializer_source:1;
-	unsigned char is_domain_initializer_target:1;
-	unsigned char is_domain_keeper:1;
-	unsigned char is_domain_unreachable:1;
-	unsigned char is_domain_deleted:1;
+	unsigned char is_dis:1; /* domain initializer source */
+	unsigned char is_dit:1; /* domain initializer target */
+	unsigned char is_dk:1;  /* domain keeper */
+	unsigned char is_du:1;  /* unreachable domain */
+	unsigned char is_dd:1;  /* deleted domain */
 };
 
 struct task_entry {
@@ -218,41 +231,73 @@
 
 /***** PROTOTYPES DEFINITION START *****/
 
-void OutOfMemory(void);
-void NormalizeLine(unsigned char *line);
-int IsDomainDef(const unsigned char *domainname);
-int IsCorrectDomain(const unsigned char *domainname);
+void out_of_memory(void);
+void normalize_line(unsigned char *line);
+bool is_domain_def(const unsigned char *domainname);
+bool is_correct_domain(const unsigned char *domainname);
 void fprintf_encoded(FILE *fp, const char *pathname);
 int decode(const char *ascii, char *bin);
-void RemoveHeader(char *line, const int len);
-int IsCorrectPath(const char *filename, const int start_type, const int pattern_type, const int end_type);
-int FileMatchesToPattern(const char *filename, const char *filename_end, const char *pattern, const char *pattern_end);
+void remove_header(char *line, const int len);
+bool is_correct_path(const char *filename, const s8 start_type,
+		     const s8 pattern_type, const s8 end_type);
+bool file_matches_pattern(const char *filename, const char *filename_end,
+			  const char *pattern, const char *pattern_end);
 int string_compare(const void *a, const void *b);
 int pathcmp(const struct path_info *a, const struct path_info *b);
 void fill_path_info(struct path_info *ptr);
-const struct path_info *SaveName(const char *name);
+const struct path_info *savename(const char *name);
+bool str_starts(char *str, const const char *begin);
+bool path_matches_pattern(const struct path_info *pathname0,
+			  const struct path_info *pattern0);
 
-extern char *shared_buffer;
+int sortpolicy_main(int argc, char *argv[]);
+int setprofile_main(int argc, char *argv[]);
+int setlevel_main(int argc, char *argv[]);
+int diffpolicy_main(int argc, char *argv[]);
+int savepolicy_main(int argc, char *argv[]);
+int pathmatch_main(int argc, char *argv[]);
+int loadpolicy_main(int argc, char *argv[]);
+int ldwatch_main(int argc, char *argv[]);
+int findtemp_main(int argc, char *argv[]);
+int editpolicy_main(int argc, char *argv[]);
+int checkpolicy_main(int argc, char *argv[]);
+int ccstree_main(int argc, char *argv[]);
+int ccsqueryd_main(int argc, char *argv[]);
+int ccsauditd_main(int argc, char *argv[]);
+int patternize_main(int argc, char *argv[]);
+
+char *shared_buffer;
 void get(void);
 void put(void);
-int freadline(FILE *fp);
+bool freadline(FILE *fp);
 
-char *simple_readline(const int start_y, const int start_x, const char *prompt, const char *history[], const int history_count, const int max_length, const int scroll_width);
-int simple_add_history(const char *buffer, const char **history, const int history_count, const int max_history);
+char *simple_readline(const int start_y, const int start_x, const char *prompt,
+		      const char *history[], const int history_count,
+		      const int max_length, const int scroll_width);
+int simple_add_history(const char *buffer, const char **history,
+		       const int history_count, const int max_history);
 int getch2(void);
 
-extern const char *proc_policy_dir,
+int query_fd;
+char *initial_readline_data;
+
+const char *proc_policy_dir,
 	*disk_policy_dir,
 	*proc_policy_domain_policy,
 	*disk_policy_domain_policy,
+	*base_policy_domain_policy,
 	*proc_policy_exception_policy,
 	*disk_policy_exception_policy,
+	*base_policy_exception_policy,
 	*proc_policy_system_policy,
 	*disk_policy_system_policy,
+	*base_policy_system_policy,
 	*proc_policy_profile,
 	*disk_policy_profile,
+	*base_policy_profile,
 	*proc_policy_manager,
 	*disk_policy_manager,
+	*base_policy_manager,
 	*proc_policy_query,
 	*proc_policy_grant_log,
 	*proc_policy_reject_log,
Index: ccstools.src/ccs-queryd.c
===================================================================
--- ccstools.src/ccs-queryd.c	(リビジョン 1537)
+++ ccstools.src/ccs-queryd.c	(作業コピー)
@@ -5,12 +5,13 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.2   2008/06/25
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
 
-static void do_check_update(FILE *fp_out) {
+static void do_check_update(FILE *fp_out)
+{
 	FILE *fp_in = fopen(proc_policy_exception_policy, "r");
 	char **pathnames = NULL;
 	int pathnames_len = 0;
@@ -22,14 +23,20 @@
 	}
 	while (fgets(buffer, sizeof(buffer) - 1, fp_in)) {
 		char *cp = strchr(buffer, '\n');
-		if (!cp) break;
+		if (!cp)
+			break;
 		*cp = '\0';
-		if (strncmp(buffer, KEYWORD_ALLOW_READ, KEYWORD_ALLOW_READ_LEN)) continue;
-		if (!decode(buffer + KEYWORD_ALLOW_READ_LEN, buffer)) continue;
-		pathnames = (char **) realloc(pathnames, sizeof(char *) * (pathnames_len + 1));
-		if (!pathnames) return;
+		if (!str_starts(buffer, KEYWORD_ALLOW_READ))
+			continue;
+		if (!decode(buffer, buffer))
+			continue;
+		pathnames = realloc(pathnames, sizeof(char *) *
+				    (pathnames_len + 1));
+		if (!pathnames)
+			return;
 		pathnames[pathnames_len] = strdup(buffer);
-		if (!pathnames[pathnames_len]) return;
+		if (!pathnames[pathnames_len])
+			return;
 		pathnames_len++;
 	}
 	fclose(fp_in);
@@ -42,38 +49,53 @@
 		sleep(1);
 		for (i = 0; i < pathnames_len; i++) {
 			int j;
-			if (stat64(pathnames[i], &buf) == 0) continue;
+			if (!stat64(pathnames[i], &buf))
+				continue;
 			fprintf(fp_out, "-");
 			fprintf_encoded(fp_out, pathnames[i]);
 			fprintf(fp_out, "\n");
 			free(pathnames[i]);
 			pathnames_len--;
-			for (j = i; j < pathnames_len; j++) pathnames[j] = pathnames[j + 1];
+			for (j = i; j < pathnames_len; j++)
+				pathnames[j] = pathnames[j + 1];
 			i--;
 		}
-		if (stat64("/etc/ld.so.cache", &buf) || buf.st_mtime == last_modified) continue;
+		if (stat64("/etc/ld.so.cache", &buf) ||
+		    buf.st_mtime == last_modified)
+			continue;
 		fp_in = popen("/sbin/ldconfig -NXp", "r");
-		if (!fp_in) continue;
+		if (!fp_in)
+			continue;
 		last_modified = buf.st_mtime;
 		memset(buffer, 0, sizeof(buffer));
 		while (fgets(buffer, sizeof(buffer) - 1, fp_in)) {
 			char *cp = strchr(buffer, '\n');
 			char *real_pathname;
-			if (!cp) break;
+			if (!cp)
+				break;
 			*cp = '\0';
 			cp = strrchr(buffer, ' ');
-			if (!cp || *++cp != '/') continue;
-			if (stat64(cp, &buf)) continue;
-			if ((real_pathname = realpath(cp, NULL)) == NULL) continue;
+			if (!cp || *++cp != '/')
+				continue;
+			if (stat64(cp, &buf))
+				continue;
+			real_pathname = realpath(cp, NULL);
+			if (!real_pathname)
+				continue;
 			for (i = 0; i < pathnames_len; i++) {
-				if (!strcmp(real_pathname, pathnames[i])) break;
+				if (!strcmp(real_pathname, pathnames[i]))
+					break;
 			}
 			if (i == pathnames_len) {
-				pathnames = (char **) realloc(pathnames, sizeof(char *) * (pathnames_len + 1));
-				if (!pathnames) return;
-				pathnames[pathnames_len] = strdup(real_pathname);
-				if (!pathnames[pathnames_len]) return;
-				pathnames_len++;
+				char *cp;
+				pathnames = realloc(pathnames, sizeof(char *) *
+						    (pathnames_len + 1));
+				if (!pathnames)
+					return;
+				cp = strdup(real_pathname);
+				if (!cp)
+					return;
+				pathnames[pathnames_len++] = cp;
 				fprintf(fp_out, "+");
 				fprintf_encoded(fp_out, pathnames[i]);
 				fprintf(fp_out, "\n");
@@ -84,55 +106,276 @@
 	}
 }
 
-extern int query_fd;
-extern char *initial_readline_data;
-
 #define GLOBALLY_READABLE_FILES_UPDATE_NONE 0
 #define GLOBALLY_READABLE_FILES_UPDATE_ASK  1
 #define GLOBALLY_READABLE_FILES_UPDATE_AUTO 2
 
 static int check_update = GLOBALLY_READABLE_FILES_UPDATE_AUTO;
 
-static void handle_update(const int fd) {
+static void handle_update(const int fd)
+{
 	static FILE *fp = NULL;
 	static char pathname[8192];
 	static int pathname_len = 0;
 	int c;
-	if (!fp) fp = fopen(proc_policy_exception_policy, "w");
-	if (!pathname_len) memset(pathname, 0, sizeof(pathname));
-	while (read(fd, pathname + pathname_len, 1) == 1 && pathname[pathname_len] != '\n' && pathname_len < sizeof(pathname) - 1) pathname_len++;
-	pathname[pathname_len] = '\0'; pathname_len = 0;
+	if (!fp)
+		fp = fopen(proc_policy_exception_policy, "w");
+	if (!pathname_len)
+		memset(pathname, 0, sizeof(pathname));
+	while (read(fd, pathname + pathname_len, 1) == 1 &&
+	       pathname[pathname_len] != '\n' &&
+	       pathname_len < sizeof(pathname) - 1)
+		pathname_len++;
+	pathname[pathname_len] = '\0';
+	pathname_len = 0;
 	if (check_update == GLOBALLY_READABLE_FILES_UPDATE_AUTO) {
-		if (pathname[0] == '-') fprintf(fp, KEYWORD_DELETE);
+		if (pathname[0] == '-')
+			fprintf(fp, KEYWORD_DELETE);
 		fprintf(fp, KEYWORD_ALLOW_READ "%s\n", pathname + 1);
 		fflush(fp);
-		printw("The pathname %s was %s globally readable file.\n\n", pathname + 1, (pathname[0] == '-') ? "deleted. Deleted from" : "created. Appended to");
+		printw("The pathname %s was %s globally readable file.\n\n",
+		       pathname + 1, (pathname[0] == '-') ?
+		       "deleted. Deleted from" : "created. Appended to");
 		refresh();
 		return;
 	}
-	printw("The pathname %s was %s globally readable file? ('Y'es/'N'o):", pathname + 1, (pathname[0] == '-') ? "deleted. Delete from" : "created. Append to");
+	printw("The pathname %s was %s globally readable file? ('Y'es/'N'o):",
+	       pathname + 1, (pathname[0] == '-') ?
+	       "deleted. Delete from" : "created. Append to");
 	refresh();
 	while (1) {
 		c = getch2();
-		if (c == 'Y' || c == 'y' || c == 'N' || c == 'n') break;
+		if (c == 'Y' || c == 'y' || c == 'N' || c == 'n')
+			break;
 		write(query_fd, "\n", 1);
 	}
-	printw("%c\n", c); refresh();
+	printw("%c\n", c);
+	refresh();
 	if (c == 'Y' || c == 'y') {
-		if (pathname[0] == '-') fprintf(fp, KEYWORD_DELETE);
+		if (pathname[0] == '-')
+			fprintf(fp, KEYWORD_DELETE);
 		fprintf(fp, KEYWORD_ALLOW_READ "%s\n", pathname + 1);
 		fflush(fp);
 	}
+	printw("\n");
+	refresh();
+}
+
+static int domain_policy_fd = EOF;
+static const int max_readline_history = 20;
+static const char **readline_history = NULL;
+static int readline_history_count = 0;
+static const int buffer_len = 32768;
+static char *buffer = NULL;
+
+static bool handle_query_new_format(unsigned int serial)
+{
+	int c = 0;
+	int y;
+	int x;
+	char *line = NULL;
+	static unsigned int prev_pid = 0;
+	unsigned int pid;
+	time_t stamp;
+	char *cp = strstr(buffer, " pid=");
+	if (!cp || sscanf(cp + 5, "%u", &pid) != 1) {
+		printw("ERROR: Unsupported query.\n");
+		return false;
+	}
+	cp = strchr(buffer, '\0');
+	if (*(cp - 1) != '\n') {
+		printw("ERROR: Unsupported query.\n");
+		return false;
+	}
+	*(cp - 1) = '\0';
+	if (pid != prev_pid) {
+		if (prev_pid)
+			printw("----------------------------------------\n");
+		prev_pid = pid;
+	}
+	if (sscanf(buffer, "#timestamp=%lu", &stamp) == 1) {
+		cp = strchr(buffer, ' ');
+		if (!cp) {
+			struct tm *tm = localtime(&stamp);
+			printw("#%04d-%02d-%02d %02d:%02d:%02d#",
+			       tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
+			       tm->tm_hour, tm->tm_min, tm->tm_sec);
+			memmove(buffer, cp, strlen(cp) + 1);
+		}
+	}
+	printw("%s\n", buffer);
+	/* Is this domain query? */
+	if (strstr(buffer, "\n#"))
+		goto not_domain_query;
+	printw("Allow? ('Y'es/Yes and 'A'ppend to policy/'N'o):");
+	refresh();
+	while (1) {
+		c = getch2();
+		if (c == 'Y' || c == 'y' || c == 'N' || c == 'n' ||
+		    c == 'A' || c == 'a')
+			break;
+		write(query_fd, "\n", 1);
+	}
+	printw("%c\n", c);
+	refresh();
+
+	/* Append to domain policy. */
+	if (c != 'A' || c != 'a')
+		goto not_append;
+	getyx(stdscr, y, x);
+	cp = strrchr(buffer, '\n');
+	if (!cp)
+		return false;
+	*cp++ = '\0';
+	initial_readline_data = cp;
+	readline_history_count = simple_add_history(cp, readline_history,
+						    readline_history_count,
+						    max_readline_history);
+	line = simple_readline(y, 0, "Enter new entry> ", readline_history,
+			       readline_history_count, 4000, 8);
+	scrollok(stdscr, 1);
+	printw("\n");
+	refresh();
+	if (!line || !*line) {
+		printw("None added.\n");
+		goto not_append;
+	}
+	readline_history_count = simple_add_history(line, readline_history,
+						    readline_history_count,
+						    max_readline_history);
+	write(domain_policy_fd, buffer, strlen(buffer));
+	write(domain_policy_fd, "\n", 1);
+	write(domain_policy_fd, line, strlen(line));
+	write(domain_policy_fd, "\n", 1);
+	printw("Added '%s'.\n", line);
+not_append:
+	refresh();
+	free(line);
+write_answer:
+	/* Write answer. */
+	snprintf(buffer, buffer_len - 1, "A%u=%u\n", serial,
+		 c == 'Y' || c == 'y' || c == 'A' || c == 'a' ? 1 : 2);
+	write(query_fd, buffer, strlen(buffer));
+	printw("\n");
+	refresh();
+	return true;
+not_domain_query:
+	printw("Allow? ('Y'es/'N'o):");
+	refresh();
+	while (1) {
+		c = getch2();
+		if (c == 'Y' || c == 'y' || c == 'N' || c == 'n')
+			break;
+		write(query_fd, "\n", 1);
+	}
+	printw("%c\n", c);
+	refresh();
+	goto write_answer;
+}
+
+static bool handle_query_old_format(unsigned int serial)
+{
+	int c = 0;
+	int y;
+	int x;
+	char *cp;
+	char *line = NULL;
+	static char *prev_buffer = NULL;
+	if (!prev_buffer) {
+		prev_buffer = malloc(buffer_len);
+		if (!prev_buffer)
+			return false;
+		memset(prev_buffer, 0, buffer_len);
+	}
+	/* Is this domain query? */
+	if (strncmp(buffer, "<kernel>", 8))
+		goto not_domain_query;
+	if (buffer[8] != '\0' && buffer[8] != ' ')
+		goto not_domain_query;
+	cp = strchr(buffer, '\n');
+	if (!cp)
+		goto not_domain_query;
+
+	/* Check for same domain. */
+	*cp++ = '\0';
+	if (strcmp(buffer, prev_buffer)) {
+		printw("----------------------------------------\n");
+		memmove(prev_buffer, buffer, strlen(buffer) + 1);
+	}
+	printw("%s\n", buffer);
+	printw("%s", cp);
+	printw("Allow? ('Y'es/Yes and 'A'ppend to policy/'N'o):");
+	refresh();
+	while (1) {
+		c = getch2();
+		if (c == 'Y' || c == 'y' || c == 'N' || c == 'n' ||
+		    c == 'A' || c == 'a')
+			break;
+		write(query_fd, "\n", 1);
+	}
+	printw("%c\n", c);
+	refresh();
+
+	/* Append to domain policy. */
+	if (c != 'A' && c != 'a')
+		goto not_append;
+
+	getyx(stdscr, y, x);
+	line = strchr(cp, '\n');
+	if (!line)
+		*line = '\0';
+	initial_readline_data = cp;
+	readline_history_count = simple_add_history(cp, readline_history,
+						    readline_history_count,
+						    max_readline_history);
+	line = simple_readline(y, 0, "Enter new entry> ", readline_history,
+			       readline_history_count, 4000, 8);
+	scrollok(stdscr, 1);
 	printw("\n"); refresh();
+	if (!line || !*line) {
+		printw("None added.\n");
+		goto not_append;
+	}
+	readline_history_count = simple_add_history(line, readline_history,
+						    readline_history_count,
+						    max_readline_history);
+	write(domain_policy_fd, buffer, strlen(buffer));
+	write(domain_policy_fd, "\n", 1);
+	write(domain_policy_fd, line, strlen(line));
+	write(domain_policy_fd, "\n", 1);
+	printw("Added '%s'.\n", line);
+not_append:
+	free(line);
+write_answer:
+	refresh();
+	printw("\n");
+	/* Write answer. */
+	snprintf(buffer, buffer_len - 1, "A%u=%u\n", serial,
+		 c == 'Y' || c == 'y' || c == 'A' || c == 'a' ? 1 : 2);
+	write(query_fd, buffer, strlen(buffer));
+	return true;
+not_domain_query:
+	printw("----------------------------------------\n");
+	prev_buffer[0] = '\0';
+	printw("%s", buffer);
+	printw("Allow? ('Y'es/'N'o):");
+	refresh();
+	while (1) {
+		c = getch2();
+		if (c == 'Y' || c == 'y' || c == 'N' || c == 'n')
+			break;
+		write(query_fd, "\n", 1);
+	}
+	printw("%c\n", c);
+	goto write_answer;
 }
 
-int ccsqueryd_main(int argc, char *argv[]) {
-	const int domain_policy_fd = open(proc_policy_domain_policy, O_WRONLY);
-	static const int max_readline_history = 20;
-	static const char **readline_history = NULL;
-	static int readline_history_count = 0;
+int ccsqueryd_main(int argc, char *argv[])
+{
+	domain_policy_fd = open(proc_policy_domain_policy, O_WRONLY);
 	int pipe_fd[2] = { EOF, EOF };
-	if (argc == 1) goto ok;
+	if (argc == 1)
+		goto ok;
 	if (!strcmp(argv[1], "--no-update")) {
 		check_update = GLOBALLY_READABLE_FILES_UPDATE_NONE;
 		goto ok;
@@ -143,18 +386,24 @@
 	}
 	printf("Usage: %s [--no-update|--ask-update]\n\n", argv[0]);
 	printf("This program is used for granting access requests manually.\n");
-	printf("This program shows access requests that are about to rejected by the kernel's decision.\n");
-	printf("If you answer before the kernel's decision taken effect, your decision will take effect.\n");
-	printf("You can use this program to respond to accidental access requests triggered by non-routine tasks (such as restarting daemons after updating).\n");
+	printf("This program shows access requests that are about to rejected "
+	       "by the kernel's decision.\n");
+	printf("If you answer before the kernel's decision taken effect, your "
+	       "decision will take effect.\n");
+	printf("You can use this program to respond to accidental access "
+	       "requests triggered by non-routine tasks (such as restarting "
+	       "daemons after updating).\n");
 	printf("To terminate this program, use 'Ctrl-C'.\n");
 	return 0;
  ok:
 	query_fd = open(proc_policy_query, O_RDWR);
 	if (query_fd == EOF) {
-		fprintf(stderr, "You can't run this utility for this kernel.\n");
+		fprintf(stderr,
+			"You can't run this utility for this kernel.\n");
 		return 1;
 	} else if (write(query_fd, "", 0) != 0) {
-		fprintf(stderr, "You need to register this program to %s to run this program.\n", proc_policy_manager);
+		fprintf(stderr, "You need to register this program to %s to "
+			"run this program.\n", proc_policy_manager);
 		return 1;
 	}
 	if (check_update) {
@@ -170,7 +419,8 @@
 			fprintf(stderr, "Can't fork().\n");
 			return 1;
 		}
-		close(pipe_fd[1]); pipe_fd[1] = EOF;
+		close(pipe_fd[1]);
+		pipe_fd[1] = EOF;
 	}
 	readline_history = malloc(max_readline_history * sizeof(const char *));
 	write(query_fd, "\n", 1);
@@ -180,35 +430,46 @@
 	nonl();
 	intrflush(stdscr, FALSE);
 	keypad(stdscr, TRUE);
-	clear(); refresh();
+	clear();
+	refresh();
 	scrollok(stdscr, 1);
 	while (1) {
 		static int first = 1;
 		static unsigned int prev_serial = 0;
-		static const int buffer_len = 32768;
-		static char *buffer = NULL, *prev_buffer = NULL;
 		fd_set rfds;
 		unsigned int serial;
 		char *cp;
-		if (!buffer && (buffer = malloc(buffer_len)) == NULL) break;
-		// Wait for query.
+		if (!buffer) {
+			buffer = malloc(buffer_len);
+			if (!buffer)
+				break;
+		}
+		/* Wait for query. */
 		FD_ZERO(&rfds);
 		FD_SET(query_fd, &rfds);
-		if (pipe_fd[0] != EOF) FD_SET(pipe_fd[0], &rfds);
-		select(query_fd > pipe_fd[0] ? query_fd + 1 : pipe_fd[0] + 1, &rfds, NULL, NULL, NULL);
-		if (pipe_fd[0] != EOF && FD_ISSET(pipe_fd[0], &rfds)) handle_update(pipe_fd[0]);
-		if (!FD_ISSET(query_fd, &rfds)) continue;
-		
-		// Read query.
+		if (pipe_fd[0] != EOF)
+			FD_SET(pipe_fd[0], &rfds);
+		select(query_fd > pipe_fd[0] ? query_fd + 1 : pipe_fd[0] + 1,
+		       &rfds, NULL, NULL, NULL);
+		if (pipe_fd[0] != EOF && FD_ISSET(pipe_fd[0], &rfds))
+			handle_update(pipe_fd[0]);
+		if (!FD_ISSET(query_fd, &rfds))
+			continue;
+
+		/* Read query. */
 		memset(buffer, 0, buffer_len);
-		if (read(query_fd, buffer, buffer_len - 1) <= 0) continue;
-		if ((cp = strchr(buffer, '\n')) == NULL) continue;
+		if (read(query_fd, buffer, buffer_len - 1) <= 0)
+			continue;
+		cp = strchr(buffer, '\n');
+		if (!cp)
+			continue;
 		*cp = '\0';
-		
-		// Get query number.
-		if (sscanf(buffer, "Q%u", &serial) != 1) continue;
+
+		/* Get query number. */
+		if (sscanf(buffer, "Q%u", &serial) != 1)
+			continue;
 		memmove(buffer, cp + 1, strlen(cp + 1) + 1);
-		
+
 		if (!first && prev_serial == serial) {
 			sleep(1);
 			write(query_fd, "\n", 1);
@@ -217,161 +478,14 @@
 		first = 0;
 		prev_serial = serial;
 		timeout(1000);
-		if (strncmp(buffer, "#timestamp=", 11) == 0) {
-			/* New format. */
-			static unsigned int prev_pid = 0;
-			unsigned int pid;
-			time_t stamp;
-			char *cp = strstr(buffer, " pid=");
-			if (!cp || sscanf(cp + 5, "%u", &pid) != 1) {
-				printw("ERROR: Unsupported query.\n");
-				break;
-			}
-			cp = strchr(buffer, '\0');
-			if (*(cp - 1) != '\n') {
-				printw("ERROR: Unsupported query.\n");
-				break;
-			}
-			*(cp - 1) = '\0';
-			if (pid != prev_pid) {
-				if (prev_pid) printw("----------------------------------------\n");
-				prev_pid = pid;
-			}
-			if (sscanf(buffer, "#timestamp=%lu", &stamp) == 1 && (cp = strchr(buffer, ' ')) != NULL) {
-				struct tm *tm = localtime(&stamp);
-				printw("#%04d-%02d-%02d %02d:%02d:%02d#", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-				memmove(buffer, cp, strlen(cp) + 1);
-			}
-			printw("%s\n", buffer);
-			// Is this domain query?
-			if (!strstr(buffer, "\n#")) {
-				int c = 0;
-				printw("Allow? ('Y'es/Yes and 'A'ppend to policy/'N'o):"); refresh();
-				while (1) {
-					c = getch2();
-					if (c == 'Y' || c == 'y' || c == 'N' || c == 'n' || c == 'A' || c == 'a') break;
-					write(query_fd, "\n", 1);
-				}
-				printw("%c\n", c); refresh();
-				
-				// Append to domain policy.
-				if (c == 'A' || c == 'a') {
-					int y, x;
-					char *line;
-					getyx(stdscr, y, x);
-					cp = strrchr(buffer, '\n');
-					if (!cp)
-						break;
-					*cp++ = '\0';
-					initial_readline_data = cp;
-					readline_history_count = simple_add_history(cp, readline_history, readline_history_count, max_readline_history);
-					line = simple_readline(y, 0, "Enter new entry> ", readline_history, readline_history_count, 4000, 8);
-					scrollok(stdscr, 1);
-					printw("\n"); refresh();
-					if (line && *line) {
-						readline_history_count = simple_add_history(line, readline_history, readline_history_count, max_readline_history);
-						write(domain_policy_fd, buffer, strlen(buffer));
-						write(domain_policy_fd, "\n", 1);
-						write(domain_policy_fd, line, strlen(line));
-						write(domain_policy_fd, "\n", 1);
-						printw("Added '%s'.\n", line);
-					} else {
-						printw("None added.\n", line);
-					}
-					refresh();
-					free(line);
-				}
-
-				// Write answer.
-				snprintf(buffer, buffer_len - 1, "A%u=%u\n", serial, c == 'Y' || c == 'y' || c == 'A' || c == 'a' ? 1 : 2);
-				write(query_fd, buffer, strlen(buffer));
-			} else {
-				int c;
-				printw("Allow? ('Y'es/'N'o):"); refresh();
-				while (1) {
-					c = getch2();
-					if (c == 'Y' || c == 'y' || c == 'N' || c == 'n') break;
-					write(query_fd, "\n", 1);
-				}
-				printw("%c\n", c); refresh();
-				
-				// Write answer.
-				snprintf(buffer, buffer_len - 1, "A%u=%u\n", serial, c == 'Y' || c == 'y' ? 1 : 2);
-				write(query_fd, buffer, strlen(buffer));
-			}
-			printw("\n"); refresh();
-			continue;
-		}
-		
-		if (!prev_buffer) {
-			if ((prev_buffer = malloc(buffer_len)) == NULL) break;
-			memset(prev_buffer, 0, buffer_len);
-		}
-		// Is this domain query?
-		if (strncmp(buffer, "<kernel>", 8) == 0 && (buffer[8] == '\0' || buffer[8] == ' ') && (cp = strchr(buffer, '\n')) != NULL) {
-			int c = 0;
-			// Check for same domain.
-			*cp++ = '\0';
-			if (strcmp(buffer, prev_buffer)) {
-				printw("----------------------------------------\n");
-				memmove(prev_buffer, buffer, strlen(buffer) + 1);
-			}
-			printw("%s\n", buffer);
-			printw("%s", cp);
-			printw("Allow? ('Y'es/Yes and 'A'ppend to policy/'N'o):"); refresh();
-			while (1) {
-				c = getch2();
-				if (c == 'Y' || c == 'y' || c == 'N' || c == 'n' || c == 'A' || c == 'a') break;
-				write(query_fd, "\n", 1);
-			}
-			printw("%c\n", c); refresh();
-			
-			// Append to domain policy.
-			if (c == 'A' || c == 'a') {
-				int y, x;
-				char *line;
-				getyx(stdscr, y, x);
-				if ((line = strchr(cp, '\n')) != NULL) *line = '\0';
-				initial_readline_data = cp;
-				readline_history_count = simple_add_history(cp, readline_history, readline_history_count, max_readline_history);
-				line = simple_readline(y, 0, "Enter new entry> ", readline_history, readline_history_count, 4000, 8);
-				scrollok(stdscr, 1);
-				printw("\n"); refresh();
-				if (line && *line) {
-					readline_history_count = simple_add_history(line, readline_history, readline_history_count, max_readline_history);
-					write(domain_policy_fd, buffer, strlen(buffer));
-					write(domain_policy_fd, "\n", 1);
-					write(domain_policy_fd, line, strlen(line));
-					write(domain_policy_fd, "\n", 1);
-					printw("Added '%s'.\n", line);
-				} else {
-					printw("None added.\n", line);
-				}
-				refresh();
-				free(line);
-			}
-
-			// Write answer.
-			snprintf(buffer, buffer_len - 1, "A%u=%u\n", serial, c == 'Y' || c == 'y' || c == 'A' || c == 'a' ? 1 : 2);
-			write(query_fd, buffer, strlen(buffer));
+		if (!strncmp(buffer, "#timestamp=", 11)) {
+			if (handle_query_new_format(serial))
+				continue;
 		} else {
-			int c;
-			printw("----------------------------------------\n");
-			prev_buffer[0] = '\0';
-			printw("%s", buffer);
-			printw("Allow? ('Y'es/'N'o):"); refresh();
-			while (1) {
-				c = getch2();
-				if (c == 'Y' || c == 'y' || c == 'N' || c == 'n') break;
-				write(query_fd, "\n", 1);
-			}
-			printw("%c\n", c); refresh();
-			
-			// Write answer.
-			snprintf(buffer, buffer_len - 1, "A%u=%u\n", serial, c == 'Y' || c == 'y' ? 1 : 2);
-			write(query_fd, buffer, strlen(buffer));
+			if (handle_query_old_format(serial))
+				continue;
 		}
-		printw("\n"); refresh();
+		break;
 	}
 	endwin();
 	return 0;
Index: ccstools.src/ld-watch.c
===================================================================
--- ccstools.src/ld-watch.c	(リビジョン 1537)
+++ ccstools.src/ld-watch.c	(作業コピー)
@@ -3,102 +3,124 @@
  *
  * TOMOYO Linux's utilities.
  *
- * Copyright (C) 2005-2007  NTT DATA CORPORATION
+ * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.5.0   2007/09/20
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
 
-int ldwatch_main(int argc, char *argv[]) {
-	struct dll_pathname_entry *entry_list = NULL;
-	int entry_list_count = 0;
+static struct dll_pathname_entry *entry_list = NULL;
+static int entry_list_count = 0;
+
+static void update_ld_list(int argc, char *argv[], FILE *fp_policy)
+{
+	struct stat64 buf;
+	static time_t last_modified = 0;
+	int i;
+	char buffer[16384];
+	FILE *fp_ldconfig;
+	if (stat64("/etc/ld.so.cache", &buf) || buf.st_mtime == last_modified)
+		return;
+	fp_ldconfig = popen("/sbin/ldconfig -NXp", "r");
+	if (!fp_ldconfig)
+		goto out;
+	last_modified = buf.st_mtime;
+	while (memset(buffer, 0, sizeof(buffer)),
+	       fgets(buffer, sizeof(buffer) - 1, fp_ldconfig)) {
+		char *cp;
+		char *pathname;
+		char *real_pathname;
+		cp = strchr(buffer, '\n');
+		if (!cp)
+			continue;
+		*cp = '\0';
+		cp = strrchr(buffer, ' ');
+		if (!cp || *++cp != '/')
+			continue;
+		/* Check for duplicated entries. */
+		real_pathname = realpath(cp, NULL);
+		if (!real_pathname)
+			continue;
+		for (i = 0; i < entry_list_count; i++) {
+			if (!strcmp(entry_list[i].real_pathname, real_pathname))
+				break;
+		}
+		if (i < entry_list_count) {
+			free(real_pathname);
+			continue;
+		}
+		/* Exclude if listed by command line. */
+		for (i = 1; i < argc; i++) {
+			if (!strcmp(argv[i], real_pathname) ||
+			    !strcmp(argv[i], cp))
+				break;
+		}
+		if (i < argc) {
+			printf("Skipped %s : %s\n", cp, real_pathname);
+			free(real_pathname);
+			continue;
+		}
+		/* Add an entry. */
+		pathname = strdup(cp);
+		entry_list = realloc(entry_list, (entry_list_count + 1) *
+				     sizeof(struct dll_pathname_entry));
+		entry_list[entry_list_count].pathname = pathname;
+		entry_list[entry_list_count++].real_pathname = real_pathname;
+		printf("Added %s : %s\n", pathname, real_pathname);
+		fprintf(fp_policy, KEYWORD_ALLOW_READ);
+		fprintf_encoded(fp_policy, real_pathname);
+		fprintf(fp_policy, "\n");
+		fflush(fp_policy);
+	}
+	pclose(fp_ldconfig);
+out:
+	printf("Monitoring %d files.\n", entry_list_count);
+}
+
+int ldwatch_main(int argc, char *argv[])
+{
 	FILE *fp_policy;
-	if (argc > 1 && strcmp(argv[1], "--help") == 0) {
-		printf("Usage: %s file_to_exclude1 [file_to_exclude2 [...]]\n\n", argv[0]);
-		printf("This program automatically registers files shown by 'ldconfig -NXp' as globally readable files.\n");
-		printf("This program registers all files shown by 'ldconfig -NXp' by default, but you can specify files that you don't want to register by command line.\n");
-		printf("For example, if you invoke\n");
-		printf("  %s /lib/libcustom-1.0.0.so /lib/libcustom.so.1\n", argv[0]);
-		printf("then, /lib/libcustom-1.0.0.so and /lib/libcustom.so.1 will be excluded from the result of 'ldconfig -NXp'.\n\n");
-		printf("Start this program in one window, then update packages in another window.\n");
-		printf("After you finished updating, wait for several seconds and terminate this program with 'Ctrl-C'.\n");
-		return 0;
-	}
+	if (argc > 1 && !strcmp(argv[1], "--help"))
+		goto usage;
 	{
 		const int fd = open(proc_policy_exception_policy, O_RDWR);
 		if (fd == EOF) {
-			fprintf(stderr, "You can't run this daemon for this kernel.\n");
+			fprintf(stderr, "You can't run this daemon "
+				"for this kernel.\n");
 			return 1;
 		} else if (write(fd, "", 0) != 0) {
-			fprintf(stderr, "You need to register this program to %s to run this program.\n", proc_policy_manager);
+			fprintf(stderr, "You need to register this program to "
+				"%s to run this program.\n",
+				proc_policy_manager);
 			return 1;
 		}
 		close(fd);
 	}
-	if ((fp_policy = fopen(proc_policy_exception_policy, "w")) == NULL) {
+	fp_policy = fopen(proc_policy_exception_policy, "w");
+	if (!fp_policy) {
 		fprintf(stderr, "Can't open policy file.\n");
 		exit(1);
 	}
 	while (1) {
-		struct stat64 buf;
-		static time_t last_modified = 0;
 		int i;
-		if (stat64("/etc/ld.so.cache", &buf) == 0 && buf.st_mtime != last_modified) {
-			FILE *fp_ldconfig;
-			if ((fp_ldconfig = popen("/sbin/ldconfig -NXp", "r")) != NULL) {
-				char buffer[16384];
-				last_modified = buf.st_mtime;
-				while (memset(buffer, 0, sizeof(buffer)), fgets(buffer, sizeof(buffer) - 1, fp_ldconfig)) {
-					char *cp, *pathname, *real_pathname;
-					if ((cp = strchr(buffer, '\n')) == NULL) continue;
-					*cp = '\0';
-					cp = strrchr(buffer, ' ');
-					if (!cp || *++cp != '/') continue;
-					// Check for duplicated entries.
-					if ((real_pathname = realpath(cp, NULL)) == NULL) continue;
-					for (i = 0; i < entry_list_count; i++) {
-						if (strcmp(entry_list[i].real_pathname, real_pathname) == 0) break;
-					}
-					if (i < entry_list_count) {
-						free(real_pathname);
-						continue;
-					}
-					// Exclude if listed by command line.
-					for (i = 1; i < argc; i++) {
-						if (strcmp(argv[i], real_pathname) == 0 || strcmp(argv[i], cp) == 0) break;
-					}
-					if (i < argc) {
-						printf("Skipped %s : %s\n", cp, real_pathname);
-						free(real_pathname);
-						continue;
-					}
-					// Add an entry.
-					pathname = strdup(cp);
-					entry_list = (struct dll_pathname_entry *) realloc(entry_list, (entry_list_count + 1) * sizeof(struct dll_pathname_entry));
-					entry_list[entry_list_count].pathname = pathname;
-					entry_list[entry_list_count++].real_pathname = real_pathname;
-					printf("Added %s : %s\n", pathname, real_pathname);
-					fprintf(fp_policy, KEYWORD_ALLOW_READ);
-					fprintf_encoded(fp_policy, real_pathname);
-					fprintf(fp_policy, "\n");
-					fflush(fp_policy);
-				}
-				pclose(fp_ldconfig);
-			}
-			printf("Monitoring %d files.\n", entry_list_count);
-		}
-		// Check entries for update.
+		update_ld_list(argc, argv, fp_policy);
+		/* Check entries for update. */
 		for (i = 0; i < entry_list_count; i++) {
 			struct dll_pathname_entry *ptr = &entry_list[i];
 			char *real_pathname = realpath(ptr->pathname, NULL);
-			if (real_pathname && strcmp(ptr->real_pathname, real_pathname)) {
-				printf("Changed %s : %s -> %s\n", ptr->pathname, ptr->real_pathname, real_pathname);
+			if (real_pathname &&
+			    strcmp(ptr->real_pathname, real_pathname)) {
+				printf("Changed %s : %s -> %s\n",
+				       ptr->pathname, ptr->real_pathname,
+				       real_pathname);
 				fprintf(fp_policy, KEYWORD_ALLOW_READ);
 				fprintf_encoded(fp_policy, real_pathname);
 				fprintf(fp_policy, "\n");
 				fflush(fp_policy);
-				free(ptr->real_pathname); ptr->real_pathname = real_pathname; real_pathname = NULL;
+				free(ptr->real_pathname);
+				ptr->real_pathname = real_pathname;
+				real_pathname = NULL;
 			}
 			free(real_pathname);
 		}
@@ -106,4 +128,21 @@
 	}
 	fclose(fp_policy);
 	return 0;
+usage:
+	printf("Usage: %s file_to_exclude1 [file_to_exclude2 [...]]\n\n",
+	       argv[0]);
+	printf("This program automatically registers files shown by "
+	       "'ldconfig -NXp' as globally readable files.\n");
+	printf("This program registers all files shown by 'ldconfig -NXp' "
+	       "by default, but you can specify files that you don't want to "
+	       "register by command line.\n");
+	printf("For example, if you invoke\n");
+	printf("  %s /lib/libcustom-1.0.0.so /lib/libcustom.so.1\n", argv[0]);
+	printf("then, /lib/libcustom-1.0.0.so and /lib/libcustom.so.1 will be "
+	       "excluded from the result of 'ldconfig -NXp'.\n\n");
+	printf("Start this program in one window, then update packages in "
+	       "another window.\n");
+	printf("After you finished updating, wait for several seconds and "
+	       "terminate this program with 'Ctrl-C'.\n");
+	return 0;
 }
Index: ccstools.src/readline.c
===================================================================
--- ccstools.src/readline.c	(リビジョン 1537)
+++ ccstools.src/readline.c	(作業コピー)
@@ -5,33 +5,62 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.3   2008/07/15
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
 
-static int getch0(void) {
+static int getch0(void)
+{
 	static int enter_key = EOF;
 	int c;
 again:
 	c = getch();
-	if (c == 127 || c == 8) c = KEY_BACKSPACE;
-	//syslog(LOG_INFO, "getch0='%c' (%d)\n", c, c);
+	if (c == 127 || c == 8)
+		c = KEY_BACKSPACE;
+	/* syslog(LOG_INFO, "getch0='%c' (%d)\n", c, c); */
 	if (c == '\r' || c == '\n') {
-		if (enter_key == EOF) enter_key = c;
-		else if (c != enter_key) goto again;
+		if (enter_key == EOF)
+			enter_key = c;
+		else if (c != enter_key)
+			goto again;
 	}
 	return c;
 }
 
-int getch2(void) {
-	static int c0 = 0, c1 = 0, c2 = 0, c3 = 0, len = 0;
-	if (len > 0) { c0 = c1; c1 = c2; c2 = c3; len--; return c0; }
-	c0 = getch0(); if (c0 != 0x1B) return c0;
-	c1 = getch0(); if (c1 != '[') { len = 1; return c0; }
-	c2 = getch0(); if (c2 < '1' || c2 > '6') { len = 2; return c0; }
-	c3 = getch0(); if (c3 != '~') { len = 3; return c0; }
-	//syslog(LOG_INFO, "getch2='%c'\n", c2);
+int getch2(void)
+{
+	static int c0 = 0;
+	static int c1 = 0;
+	static int c2 = 0;
+	static int c3 = 0;
+	static int len = 0;
+	if (len > 0) {
+		c0 = c1;
+		c1 = c2;
+		c2 = c3;
+		len--;
+		return c0;
+	}
+	c0 = getch0();
+	if (c0 != 0x1B)
+		return c0;
+	c1 = getch0();
+	if (c1 != '[') {
+		len = 1;
+		return c0;
+	}
+	c2 = getch0();
+	if (c2 < '1' || c2 > '6') {
+		len = 2;
+		return c0;
+	}
+	c3 = getch0();
+	if (c3 != '~') {
+		len = 3;
+		return c0;
+	}
+	/* syslog(LOG_INFO, "getch2='%c'\n", c2); */
 	switch (c2) {
 	case '1':
 		return KEY_HOME;
@@ -49,10 +78,13 @@
 	return 0;
 }
 
-int simple_add_history(const char *buffer, const char **history, const int history_count, const int max_history) {
+int simple_add_history(const char *buffer, const char **history,
+		       const int history_count, const int max_history)
+{
 	char *cp = buffer ? strdup(buffer) : NULL;
-	if (!cp) return history_count;
-	if (history_count && strcmp(history[history_count - 1], cp) == 0) {
+	if (!cp)
+		return history_count;
+	if (history_count && !strcmp(history[history_count - 1], cp)) {
 		free(cp);
 		return history_count;
 	}
@@ -62,7 +94,8 @@
 	} else if (max_history) {
 		int i;
 		free((char *) history[0]);
-		for (i = 0; i < history_count - 1; i++) history[i] = history[i + 1];
+		for (i = 0; i < history_count - 1; i++)
+			history[i] = history[i + 1];
 		history[history_count - 1] = cp;
 		return history_count;
 	}
@@ -72,21 +105,33 @@
 int query_fd = EOF;
 char *initial_readline_data = NULL;
 
-char *simple_readline(const int start_y, const int start_x, const char *prompt, const char *history[], const int history_count, const int max_length, const int scroll_width) {
+char *simple_readline(const int start_y, const int start_x, const char *prompt,
+		      const char *history[], const int history_count,
+		      const int max_length, const int scroll_width)
+{
 	const int prompt_len = prompt && *prompt ? strlen(prompt) : 0;
-	int buffer_len = 0, line_pos = 0, cur_pos = 0, history_pos = 0, tmp_saved = 0;
-	static char *buffer = NULL, *tmp_buffer = NULL;
+	int buffer_len = 0;
+	int line_pos = 0;
+	int cur_pos = 0;
+	int history_pos = 0;
+	int tmp_saved = 0;
+	static char *buffer = NULL;
+	static char *tmp_buffer = NULL;
 	{
 		int i;
-		for (i = 0; i < history_count; i++) if (!history[i]) return NULL;
+		for (i = 0; i < history_count; i++)
+			if (!history[i])
+				return NULL;
 	}
 	{
 		char *tmp;
 		tmp = realloc(buffer, max_length);
-		if (!tmp) return NULL;
+		if (!tmp)
+			return NULL;
 		buffer = tmp;
 		tmp = realloc(tmp_buffer, max_length);
-		if (!tmp) return NULL;
+		if (!tmp)
+			return NULL;
 		tmp_buffer = tmp;
 		memset(buffer, 0, max_length);
 		memset(tmp_buffer, 0, max_length);
@@ -99,8 +144,12 @@
 		ungetch(KEY_END);
 	}
 	while (1) {
-		int window_width, window_height;
-		int c, x, y, i;
+		int window_width;
+		int window_height;
+		int c;
+		int x;
+		int y;
+		int i;
 		getmaxyx(stdscr, window_height, window_width);
 		window_width -= prompt_len;
 		getyx(stdscr, y, x);
@@ -109,47 +158,64 @@
 			cur_pos--;
 			line_pos++;
 		}
-		if (prompt_len) printw("%s", prompt);
+		if (prompt_len)
+			printw("%s", prompt);
 		for (i = line_pos; i < line_pos + window_width; i++) {
-			if (i < buffer_len) addch(buffer[i]);
-			else break;
+			if (i < buffer_len)
+				addch(buffer[i]);
+			else
+				break;
 		}
 		clrtoeol();
 		move(y, cur_pos + prompt_len);
 		refresh();
 		c = getch2();
-		if (query_fd != EOF) write(query_fd, "\n", 1);
+		if (query_fd != EOF)
+			write(query_fd, "\n", 1);
 		if (c == 4) { /* Ctrl-D */
-			if (!buffer_len) buffer_len = -1;
+			if (!buffer_len)
+				buffer_len = -1;
 			break;
 		} else if (c == KEY_IC) {
 			scrollok(stdscr, 1);
 			printw("\n");
-			for (i = 0; i < history_count; i++) {
+			for (i = 0; i < history_count; i++)
 				printw("%d: '%s'\n", i, history[i]);
-			}
 			scrollok(stdscr, 0);
-		} else if (c >= 0x20 && c <= 0x7E && buffer_len < max_length - 1) {
-			for (i = buffer_len - 1; i >= line_pos + cur_pos; i--) buffer[i + 1] = buffer[i];
+		} else if (c >= 0x20 && c <= 0x7E &&
+			   buffer_len < max_length - 1) {
+			for (i = buffer_len - 1; i >= line_pos + cur_pos; i--)
+				buffer[i + 1] = buffer[i];
 			buffer[line_pos + cur_pos] = c;
 			buffer[++buffer_len] = '\0';
-			if (cur_pos < window_width - 1) cur_pos++;
-			else line_pos++;
+			if (cur_pos < window_width - 1)
+				cur_pos++;
+			else
+				line_pos++;
 		} else if (c == '\r' || c == '\n') {
 			break;
 		} else if (c == KEY_BACKSPACE) {
 			if (line_pos + cur_pos) {
 				buffer_len--;
-				for (i = line_pos + cur_pos - 1; i < buffer_len; i++) buffer[i] = buffer[i + 1];
+				for (i = line_pos + cur_pos - 1;
+				     i < buffer_len; i++)
+					buffer[i] = buffer[i + 1];
 				buffer[buffer_len] = '\0';
-				if (line_pos >= scroll_width && cur_pos == 0) { line_pos -= scroll_width; cur_pos += scroll_width - 1; }
-				else if (cur_pos) cur_pos--;
-				else if (line_pos) line_pos--;
+				if (line_pos >= scroll_width && cur_pos == 0) {
+					line_pos -= scroll_width;
+					cur_pos += scroll_width - 1;
+				} else if (cur_pos) {
+					cur_pos--;
+				} else if (line_pos) {
+					line_pos--;
+				}
 			}
 		} else if (c == KEY_DC) {
 			if (line_pos + cur_pos < buffer_len) {
 				buffer_len--;
-				for (i = line_pos + cur_pos; i < buffer_len; i++) buffer[i] = buffer[i + 1];
+				for (i = line_pos + cur_pos; i < buffer_len;
+				     i++)
+					buffer[i] = buffer[i + 1];
 				buffer[buffer_len] = '\0';
 			}
 		} else if (c == KEY_UP) {
@@ -159,14 +225,16 @@
 					strncpy(tmp_buffer, buffer, max_length);
 				}
 				history_pos--;
-				strncpy(buffer, history[history_pos], max_length);
+				strncpy(buffer, history[history_pos],
+					max_length);
 				buffer_len = strlen(buffer);
 				goto end_key;
 			}
 		} else if (c == KEY_DOWN) {
 			if (history_pos < history_count - 1) {
 				history_pos++;
-				strncpy(buffer, history[history_pos], max_length);
+				strncpy(buffer, history[history_pos],
+					max_length);
 				buffer_len = strlen(buffer);
 				goto end_key;
 			} else if (tmp_saved) {
@@ -180,26 +248,41 @@
 			cur_pos = 0;
 			line_pos = 0;
 		} else if (c == KEY_END) {
-		end_key: ;
-			cur_pos = buffer_len;
-			line_pos = 0;
-			if (cur_pos > window_width - 1) {
-				line_pos = buffer_len - (window_width - 1);
-				cur_pos = window_width - 1;
+			goto end_key;
+		} else if (c == KEY_LEFT) {
+			if (line_pos >= scroll_width && cur_pos == 0) {
+				line_pos -= scroll_width;
+				cur_pos += scroll_width - 1;
+			} else if (cur_pos) {
+				cur_pos--;
+			} else if (line_pos) {
+				line_pos--;
 			}
-		} else if (c == KEY_LEFT) {
-			if (line_pos >= scroll_width && cur_pos == 0) { line_pos -= scroll_width; cur_pos += scroll_width - 1; }
-			else if (cur_pos) cur_pos--;
-			else if (line_pos) line_pos--;
 		} else if (c == KEY_RIGHT) {
 			if (line_pos + cur_pos < buffer_len) {
-				if (cur_pos < window_width - 1) cur_pos++;
-				else if (line_pos + cur_pos < buffer_len - scroll_width && cur_pos >= scroll_width - 1) { cur_pos -= scroll_width - 1; line_pos += scroll_width; }
-				else line_pos++;
+				if (cur_pos < window_width - 1)
+					cur_pos++;
+				else if (line_pos + cur_pos <
+					 buffer_len - scroll_width &&
+					 cur_pos >= scroll_width - 1) {
+					cur_pos -= scroll_width - 1;
+					line_pos += scroll_width;
+				} else {
+					line_pos++;
+				}
 			}
 		}
+		continue;
+end_key:
+		cur_pos = buffer_len;
+		line_pos = 0;
+		if (cur_pos > window_width - 1) {
+			line_pos = buffer_len - (window_width - 1);
+			cur_pos = window_width - 1;
+		}
 	}
-	if (buffer_len == -1) return NULL;
-	NormalizeLine(buffer);
+	if (buffer_len == -1)
+		return NULL;
+	normalize_line(buffer);
 	return strdup(buffer);
 }
Index: ccstools.src/setlevel.c
===================================================================
--- ccstools.src/setlevel.c	(リビジョン 1537)
+++ ccstools.src/setlevel.c	(作業コピー)
@@ -3,31 +3,37 @@
  *
  * TOMOYO Linux's utilities.
  *
- * Copyright (C) 2005-2007  NTT DATA CORPORATION
+ * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.5.1   2007/10/19
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
 
-int setlevel_main(int argc, char *argv[]) {
+int setlevel_main(int argc, char *argv[])
+{
 	const char *policy_file = proc_policy_profile;
-	int i, fd;
+	int i;
+	int fd;
 	char c;
 	if (access(proc_policy_dir, F_OK)) {
-		fprintf(stderr, "You can't use this command for this kernel.\n");
+		fprintf(stderr, "You can't use this command for this "
+			"kernel.\n");
 		return 1;
 	}
-	if ((fd = open(policy_file, O_RDWR)) == EOF) {
+	fd = open(policy_file, O_RDWR);
+	if (fd == EOF) {
 		fprintf(stderr, "Can't open %s\n", policy_file);
 		return 1;
 	} else if (write(fd, "", 0) != 0) {
-		fprintf(stderr, "You need to register this program to %s to run this program.\n", proc_policy_manager);
+		fprintf(stderr, "You need to register this program to %s to "
+			"run this program.\n", proc_policy_manager);
 		return 1;
 	}
 	if (argc == 1) {
 		printf("<<< Access Control Status >>>\n");
-		while (read(fd, &c, 1) == 1) putchar(c);
+		while (read(fd, &c, 1) == 1)
+			putchar(c);
 	} else {
 		FILE *fp = fdopen(fd, "r+");
 		if (!fp) {
@@ -38,13 +44,16 @@
 		for (i = 1; i < argc; i++) {
 			char *cp = strchr(argv[i], '=');
 			fprintf(fp, "%s\n", argv[i]);
-			if (cp) *(cp + 1) = '\0';
+			if (cp)
+				*(cp + 1) = '\0';
 		}
 		fflush(fp);
 		get();
 		while (freadline(fp)) {
 			for (i = 1; i < argc; i++) {
-				if (strncmp(shared_buffer, argv[i], strlen(argv[i]))) continue;
+				if (strncmp(shared_buffer, argv[i],
+					    strlen(argv[i])))
+					continue;
 				printf("%s\n", shared_buffer);
 				break;
 			}
Index: ccstools.src/editpolicy.c
===================================================================
--- ccstools.src/editpolicy.c	(リビジョン 1537)
+++ ccstools.src/editpolicy.c	(作業コピー)
@@ -5,63 +5,76 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.4+   2008/09/04
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
 
-/// add color start
+/* add color start */
 #ifdef COLOR_ON
 #define OFF 0
-#define ON !OFF
+#define ON  1
 
 enum color_pair {
-	NORMAL,
-	DOMAIN_HEAD, DOMAIN_CURSOR,
-	SYSTEM_HEAD, SYSTEM_CURSOR,
-	EXCEPTION_HEAD, EXCEPTION_CURSOR,
-	ACL_HEAD, ACL_CURSOR,
-	DISP_ERR
-}; 
-	
-static void ColorInit(void){
+	NORMAL, DOMAIN_HEAD, DOMAIN_CURSOR, SYSTEM_HEAD, SYSTEM_CURSOR,
+	EXCEPTION_HEAD, EXCEPTION_CURSOR, ACL_HEAD, ACL_CURSOR, DISP_ERR
+};
+
+static void editpolicy_color_init(void)
+{
 	static struct color_env_t {
 		enum color_pair	tag;
-		short		fore;
-		short		back;
-		char		*name;
+		short int fore;
+		short int back;
+		const char *name;
 	} color_env[] = {
-		{DOMAIN_HEAD,      COLOR_BLACK, COLOR_GREEN,  "DOMAIN_HEAD"},
-		{DOMAIN_CURSOR,    COLOR_BLACK, COLOR_GREEN,  "DOMAIN_CURSOR"},
-		{SYSTEM_HEAD,      COLOR_WHITE, COLOR_BLUE,   "SYSTEM_HEAD"},
-		{SYSTEM_CURSOR,    COLOR_WHITE, COLOR_BLUE,   "SYSTEM_CURSOR"},
-		{EXCEPTION_HEAD,   COLOR_BLACK, COLOR_CYAN,   "EXCEPTION_HEAD"},
-		{EXCEPTION_CURSOR, COLOR_BLACK, COLOR_CYAN,   "EXCEPTION_CURSOR"},
-		{ACL_HEAD,         COLOR_BLACK, COLOR_YELLOW, "ACL_HEAD"},
-		{ACL_CURSOR,       COLOR_BLACK, COLOR_YELLOW, "ACL_CURSOR"},
-		{NORMAL,           COLOR_WHITE, COLOR_BLACK,  NULL}
+		{ DOMAIN_HEAD,      COLOR_BLACK,
+		  COLOR_GREEN,      "DOMAIN_HEAD" },
+		{ DOMAIN_CURSOR,    COLOR_BLACK,
+		  COLOR_GREEN,      "DOMAIN_CURSOR" },
+		{ SYSTEM_HEAD,      COLOR_WHITE,
+		  COLOR_BLUE,       "SYSTEM_HEAD" },
+		{ SYSTEM_CURSOR,    COLOR_WHITE,
+		  COLOR_BLUE,       "SYSTEM_CURSOR" },
+		{ EXCEPTION_HEAD,   COLOR_BLACK,
+		  COLOR_CYAN,       "EXCEPTION_HEAD" },
+		{ EXCEPTION_CURSOR, COLOR_BLACK,
+		  COLOR_CYAN,       "EXCEPTION_CURSOR" },
+		{ ACL_HEAD,         COLOR_BLACK,
+		  COLOR_YELLOW,     "ACL_HEAD" },
+		{ ACL_CURSOR,       COLOR_BLACK,
+		  COLOR_YELLOW,     "ACL_CURSOR" },
+		{ NORMAL,           COLOR_WHITE,
+		  COLOR_BLACK,      NULL }
 	};
-	FILE *fp;
+	FILE *fp = fopen(CCSTOOLS_CONFIG_FILE, "r");
 	int i;
-	if ((fp = fopen(CCSTOOLS_CONFIG_FILE, "r")) == NULL) goto use_default;
+	if (!fp)
+		goto use_default;
 	get();
 	while (freadline(fp)) {
 		char *cp;
-		if (strncmp(shared_buffer, "editpolicy.line_color ", 22)) continue;
-		memmove(shared_buffer, shared_buffer + 22, strlen(shared_buffer + 22) + 1);
-		if ((cp = strchr(shared_buffer, '=')) == NULL) continue;
+		if (!str_starts(shared_buffer, "editpolicy.line_color "))
+			continue;
+		cp = strchr(shared_buffer, '=');
+		if (!cp)
+			continue;
 		*cp++ = '\0';
-		NormalizeLine(shared_buffer);
-		NormalizeLine(cp);
-		if (!*shared_buffer || !*cp) continue;
-		for (i = 0; color_env[i].name != NULL; i++) {
-			short fore, back;
-			if (strcmp(shared_buffer, color_env[i].name)) continue;
-			if (strlen(cp) != 2) break;
-			fore = (*cp++) - '0';		// foreground color
-			back = (*cp) - '0';		// background color
-			if (fore < 0 || fore > 7 ||
-			    back < 0 || back > 7) break;
+		normalize_line(shared_buffer);
+		normalize_line(cp);
+		if (!*shared_buffer || !*cp)
+			continue;
+		for (i = 0; color_env[i].name; i++) {
+			short int fore;
+			short int back;
+			if (strcmp(shared_buffer, color_env[i].name))
+				continue;
+			if (strlen(cp) != 2)
+				break;
+			fore = (*cp++) - '0'; /* foreground color */
+			back = (*cp) - '0';   /* background color */
+			if (fore < 0 || fore > 7 || back < 0 || back > 7)
+				break;
 			color_env[i].fore = fore;
 			color_env[i].back = back;
 			break;
@@ -69,16 +82,17 @@
 	}
 	put();
 	fclose(fp);
- use_default:
+use_default:
 	start_color();
-	for (i = 0; color_env[i].name != NULL; i++) {
+	for (i = 0; color_env[i].name; i++) {
 		struct color_env_t *colorp = &color_env[i];
 		init_pair(colorp->tag, colorp->fore, colorp->back);
 	}
-	init_pair(DISP_ERR, COLOR_RED, COLOR_BLACK);	// error massage
+	init_pair(DISP_ERR, COLOR_RED, COLOR_BLACK); /* error massage */
 }
 
-static void ColorSave(int flg) {
+static void editpolicy_color_save(const int flg)
+{
 	static int save_color = NORMAL;
 	if (flg == ON)
 		save_color = getattrs(stdscr);
@@ -86,49 +100,80 @@
 		attrset(save_color);
 }
 
-#define colorChange(attr, flg)	{flg ? attron(COLOR_PAIR(attr)) : attroff(COLOR_PAIR(attr));}
-#define attrChange(attr, flg)	{flg ? attron(attr) : attroff(attr);}
+static inline void editpolicy_color_change(const attr_t attr, const int flg)
+{
+	if (flg)
+		attron(COLOR_PAIR(attr));
+	else
+		attroff(COLOR_PAIR(attr));
+}
 
-#define sttrSave()		ColorSave(ON)
-#define sttrRestore()	ColorSave(OFF)
+static inline void editpolicy_attr_change(const attr_t attr, const int flg)
+{
+	if (flg)
+		attron(attr);
+	else
+		attroff(attr);
+}
 
-#define colorHead()	( \
-	(current_screen == SCREEN_DOMAIN_LIST) ? DOMAIN_HEAD \
-			: (current_screen == SCREEN_SYSTEM_LIST) ? SYSTEM_HEAD \
-			: (current_screen == SCREEN_EXCEPTION_LIST) ? EXCEPTION_HEAD \
-			: ACL_HEAD )
+static inline void editpolicy_sttr_save(void)
+{
+	editpolicy_color_save(ON);
+}
 
-#define colorCursor()	( \
-	(current_screen == SCREEN_DOMAIN_LIST) ? DOMAIN_CURSOR \
-			: (current_screen == SCREEN_SYSTEM_LIST) ? SYSTEM_CURSOR \
-			: (current_screen == SCREEN_EXCEPTION_LIST) ? EXCEPTION_CURSOR \
-			: ACL_CURSOR )
+static inline void editpolicy_sttr_restore(void)
+{
+	editpolicy_color_save(OFF);
+}
 
+static inline int editpolicy_color_head(const int screen)
+{
+	if (screen == SCREEN_DOMAIN_LIST)
+		return DOMAIN_HEAD;
+	if (screen == SCREEN_SYSTEM_LIST)
+		return SYSTEM_HEAD;
+	if (screen == SCREEN_EXCEPTION_LIST)
+		return EXCEPTION_HEAD;
+	return ACL_HEAD;
+}
 
+static inline int editpolicy_color_cursor(const int screen)
+{
+	if (screen == SCREEN_DOMAIN_LIST)
+		return DOMAIN_CURSOR;
+	if (screen == SCREEN_SYSTEM_LIST)
+		return SYSTEM_CURSOR;
+	if (screen == SCREEN_EXCEPTION_LIST)
+		return EXCEPTION_CURSOR;
+	return ACL_CURSOR;
+}
 
-#else	// no color
+#else /* no color */
 
-#define ColorInit()
-#define colorChange(attr, flg)
-#define attrChange(attr, flg)
-#define sttrSave()
-#define sttrRestore()
-#define colorHead()
-#define colorCursor()
+#define editpolicy_color_init()
+#define editpolicy_color_change(attr, flg)
+#define editpolicy_attr_change(attr, flg)
+#define editpolicy_sttr_save()
+#define editpolicy_sttr_restore()
+#define editpolicy_color_head()
+#define editpolicy_color_cursor()
 
 #endif
-/// add color end
+/* add color end */
 
 static struct path_group_entry *path_group_list = NULL;
 static int path_group_list_len = 0;
 static struct address_group_entry *address_group_list = NULL;
 static int address_group_list_len = 0;
 
-static struct domain_info *domain_list = NULL, *shadow_domain_list = NULL;
-static int domain_list_count = 0, shadow_domain_list_count = 0;
+static struct domain_info *domain_list = NULL;
+static struct domain_info *shadow_domain_list = NULL;
+static int domain_list_count = 0;
+static int shadow_domain_list_count = 0;
 static unsigned char *domain_list_selected = NULL;
 
-static void SwapDomainList(void) {
+static void swap_domain_list(void)
+{
 	struct domain_info *tmp_list = domain_list;
 	int tmp_list_count = domain_list_count;
 	domain_list = shadow_domain_list;
@@ -137,70 +182,91 @@
 	shadow_domain_list_count = tmp_list_count;
 }
 
-static const char *DomainName(const int index) {
+static const char *domain_name(const int index)
+{
 	return domain_list[index].domainname->name;
 }
 
-static const char *GetLastName(const int index) {
-	const char *cp0 = DomainName(index), *cp1;
-	if ((cp1 = strrchr(cp0, ' ')) != NULL) return cp1 + 1;
+static const char *get_last_name(const int index)
+{
+	const char *cp0 = domain_name(index);
+	const char *cp1 = strrchr(cp0, ' ');
+	if (cp1)
+		return cp1 + 1;
 	return cp0;
 }
 
-static int AddStringEntry(const char *entry, const int index) {
+static int add_string_entry(const char *entry, const int index)
+{
 	const struct path_info **acl_ptr;
 	int acl_count;
 	const struct path_info *cp;
 	int i;
 	if (index < 0 || index >= domain_list_count) {
-		fprintf(stderr, "AddStringEntry: ERROR: domain is out of range.\n");
+		fprintf(stderr, "%s: ERROR: domain is out of range.\n",
+			__func__);
 		return -EINVAL;
 	}
-	if (!entry || !*entry) return -EINVAL;
-	if ((cp = SaveName(entry)) == NULL) OutOfMemory();
+	if (!entry || !*entry)
+		return -EINVAL;
+	cp = savename(entry);
+	if (!cp)
+		out_of_memory();
 
 	acl_ptr = domain_list[index].string_ptr;
 	acl_count = domain_list[index].string_count;
 
-	// Check for the same entry.
+	/* Check for the same entry. */
 	for (i = 0; i < acl_count; i++) {
-		// Faster comparison, for they are SaveName'd.
-		if (cp == acl_ptr[i]) return 0;
+		/* Faster comparison, for they are savename'd. */
+		if (cp == acl_ptr[i])
+			return 0;
 	}
 
-	if ((acl_ptr = (const struct path_info **) realloc(acl_ptr, (acl_count + 1) * sizeof(const struct path_info *))) == NULL) OutOfMemory();
+	acl_ptr = realloc(acl_ptr, (acl_count + 1)
+			  * sizeof(const struct path_info *));
+	if (!acl_ptr)
+		out_of_memory();
 	acl_ptr[acl_count++] = cp;
 	domain_list[index].string_ptr = acl_ptr;
 	domain_list[index].string_count = acl_count;
 	return 0;
 }
 
-static int DelStringEntry(const char *entry, const int index) {
+static int del_string_entry(const char *entry, const int index)
+{
 	const struct path_info **acl_ptr;
 	int acl_count;
 	const struct path_info *cp;
 	int i;
 	if (index < 0 || index >= domain_list_count) {
-		fprintf(stderr, "DelStringEntry: ERROR: domain is out of range.\n");
+		fprintf(stderr, "%s: ERROR: domain is out of range.\n",
+			__func__);
 		return -EINVAL;
 	}
-	if (!entry || !*entry) return -EINVAL;
-	if ((cp = SaveName(entry)) == NULL) OutOfMemory();
+	if (!entry || !*entry)
+		return -EINVAL;
+	cp = savename(entry);
+	if (!cp)
+		out_of_memory();
 
 	acl_ptr = domain_list[index].string_ptr;
 	acl_count = domain_list[index].string_count;
 
 	for (i = 0; i < acl_count; i++) {
-		// Faster comparison, for they are SaveName'd.
-		if (cp != acl_ptr[i]) continue;
+		/* Faster comparison, for they are savename'd. */
+		if (cp != acl_ptr[i])
+			continue;
 		domain_list[index].string_count--;
-		for (; i < acl_count - 1; i++) acl_ptr[i] = acl_ptr[i + 1];
+		for (; i < acl_count - 1; i++)
+			acl_ptr[i] = acl_ptr[i + 1];
 		return 0;
 	}
 	return -ENOENT;
 }
 
-static void ClearDomainPolicy(void) {
+static void clear_domain_policy(void)
+{
 	int index;
 	for (index = 0; index < domain_list_count; index++) {
 		free(domain_list[index].string_ptr);
@@ -212,70 +278,97 @@
 	domain_list_count = 0;
 }
 
-static int FindDomain(const char *domainname0, const int is_domain_initializer_source, const int is_domain_deleted) {
+static int find_domain(const char *domainname0, const int is_dis,
+		       const int is_dd)
+{
 	int i;
 	struct path_info domainname;
 	domainname.name = domainname0;
 	fill_path_info(&domainname);
 	for (i = 0; i < domain_list_count; i++) {
-		if (domain_list[i].is_domain_initializer_source == is_domain_initializer_source && domain_list[i].is_domain_deleted == is_domain_deleted && !pathcmp(&domainname, domain_list[i].domainname)) return i;
+		if (domain_list[i].is_dis == is_dis &&
+		    domain_list[i].is_dd == is_dd &&
+		    !pathcmp(&domainname, domain_list[i].domainname))
+			return i;
 	}
 	return EOF;
 }
 
-static int FindOrAssignNewDomain(const char *domainname, const int is_domain_initializer_source, const int is_domain_deleted) {
+static int find_or_assign_new_domain(const char *domainname, const int is_dis,
+				     const int is_dd)
+{
 	const struct path_info *saved_domainname;
-	int index;
-	if ((index = FindDomain(domainname, is_domain_initializer_source, is_domain_deleted)) == EOF) {
-		if (IsCorrectDomain(domainname)) {
-			if ((domain_list = (struct domain_info *) realloc(domain_list, (domain_list_count + 1) * sizeof(struct domain_info))) == NULL) OutOfMemory();
-			memset(&domain_list[domain_list_count], 0, sizeof(struct domain_info));
-			if ((saved_domainname = SaveName(domainname)) == NULL) OutOfMemory();
-			domain_list[domain_list_count].domainname = saved_domainname;
-			domain_list[domain_list_count].is_domain_initializer_source = is_domain_initializer_source;
-			domain_list[domain_list_count].is_domain_deleted = is_domain_deleted;
-			index = domain_list_count++;
-		} else {
-			fprintf(stderr, "FindOrAssignNewDomain: Invalid domainname '%s'\n", domainname);
-		}
+	int index = find_domain(domainname, is_dis, is_dd);
+	if (index >= 0)
+		goto found;
+	if (!is_correct_domain(domainname)) {
+		fprintf(stderr, "%s: Invalid domainname '%s'\n",
+			__func__, domainname);
+		return EOF;
 	}
+	domain_list = realloc(domain_list, (domain_list_count + 1) *
+			      sizeof(struct domain_info));
+	if (!domain_list)
+		out_of_memory();
+	memset(&domain_list[domain_list_count], 0, sizeof(struct domain_info));
+	saved_domainname = savename(domainname);
+	if (!saved_domainname)
+		out_of_memory();
+	domain_list[domain_list_count].domainname = saved_domainname;
+	domain_list[domain_list_count].is_dis = is_dis;
+	domain_list[domain_list_count].is_dd = is_dd;
+	index = domain_list_count++;
+found:
 	return index;
 }
 
-static void DeleteDomain(const int index) {
+static void delete_domain(const int index)
+{
 	if (index > 0 && index < domain_list_count) {
 		int i;
 		free(domain_list[index].string_ptr);
-		for (i = index; i < domain_list_count - 1; i++) domain_list[i] = domain_list[i + 1];
+		for (i = index; i < domain_list_count - 1; i++)
+			domain_list[i] = domain_list[i + 1];
 		domain_list_count--;
 	}
 }
 
-static int domainname_compare(const void *a, const void *b) {
-	return strcmp(((struct domain_info *) a)->domainname->name, ((struct domain_info *) b)->domainname->name);
+static int domainname_compare(const void *a, const void *b)
+{
+	return strcmp(((struct domain_info *) a)->domainname->name,
+		      ((struct domain_info *) b)->domainname->name);
 }
 
-static int path_info_compare(const void *a, const void *b) {
-	const char *a0 = (* (struct path_info **) a)->name;
-	const char *b0 = (* (struct path_info **) b)->name;
+static int path_info_compare(const void *a, const void *b)
+{
+	const char *a0 = (*(struct path_info **) a)->name;
+	const char *b0 = (*(struct path_info **) b)->name;
 	return strcmp(a0, b0);
 }
 
-static void SortPolicy(void) {
+static void sort_domain_policy(void)
+{
 	int i;
-	qsort(domain_list, domain_list_count, sizeof(struct domain_info), domainname_compare);
-	for (i = 0; i < domain_list_count; i++) qsort(domain_list[i].string_ptr, domain_list[i].string_count, sizeof(struct path_info *), path_info_compare);
+	qsort(domain_list, domain_list_count, sizeof(struct domain_info),
+	      domainname_compare);
+	for (i = 0; i < domain_list_count; i++)
+		qsort(domain_list[i].string_ptr, domain_list[i].string_count,
+		      sizeof(struct path_info *), path_info_compare);
 }
 
-static int WriteDomainPolicy(const int fd) {
-	int i, j;
+static int write_domain_policy(const int fd)
+{
+	int i;
+	int j;
 	for (i = 0; i < domain_list_count; i++) {
 		const struct path_info **string_ptr = domain_list[i].string_ptr;
 		const int string_count = domain_list[i].string_count;
-		write(fd, domain_list[i].domainname->name, domain_list[i].domainname->total_len);
+		write(fd, domain_list[i].domainname->name,
+		      domain_list[i].domainname->total_len);
 		write(fd, "\n\n", 2);
 		for (j = 0; j < string_count; j++) {
-			write(fd, string_ptr[j]->name, string_ptr[j]->total_len);
+			write(fd, string_ptr[j]->name,
+			      string_ptr[j]->total_len);
 			write(fd, "\n", 1);
 		}
 		write(fd, "\n", 1);
@@ -283,31 +376,38 @@
 	return 0;
 }
 
-static int IsKeeperDomain(const int index) {
-	return domain_list[index].is_domain_keeper;
+static int is_keeper_domain(const int index)
+{
+	return domain_list[index].is_dk;
 }
 
-static int IsInitializerSource(const int index) {
-	return domain_list[index].is_domain_initializer_source;
+static int is_initializer_source(const int index)
+{
+	return domain_list[index].is_dis;
 }
 
-static int IsInitializerTarget(const int index) {
-	return domain_list[index].is_domain_initializer_target;
+static int is_initializer_target(const int index)
+{
+	return domain_list[index].is_dit;
 }
 
-static int IsDomainUnreachable(const int index) {
-	return domain_list[index].is_domain_unreachable;
+static int is_domain_unreachable(const int index)
+{
+	return domain_list[index].is_du;
 }
 
-static int IsDeletedDomain(const int index) {
-	return domain_list[index].is_domain_deleted;
+static int is_deleted_domain(const int index)
+{
+	return domain_list[index].is_dd;
 }
 
-static void ReadDomainPolicy(const char *filename) {
+static void read_domain_policy(const char *filename)
+{
 	FILE *fp = stdin;
 	int index;
 	if (filename) {
-		if ((fp = fopen(filename, "r")) == NULL) {
+		fp = fopen(filename, "r");
+		if (!fp) {
 			fprintf(stderr, "Can't open %s\n", filename);
 			return;
 		}
@@ -315,82 +415,299 @@
 	index = EOF;
 	get();
 	while (freadline(fp)) {
-		if (IsDomainDef(shared_buffer)) {
-			index = FindOrAssignNewDomain(shared_buffer, 0, 0);
-		} else if (index >= 0 && shared_buffer[0]) {
-			AddStringEntry(shared_buffer, index);
-		}
+		if (is_domain_def(shared_buffer))
+			index = find_or_assign_new_domain(shared_buffer, 0, 0);
+		else if (index >= 0 && shared_buffer[0])
+			add_string_entry(shared_buffer, index);
 	}
 	put();
-	if (fp != stdin) fclose(fp);
-	SortPolicy();
+	if (fp != stdin)
+		fclose(fp);
+	sort_domain_policy();
 }
 
 /***** sortpolicy start *****/
 
-int sortpolicy_main(int argc, char *argv[]) {
-	ReadDomainPolicy(NULL);
-	WriteDomainPolicy(1);
+int sortpolicy_main(int argc, char *argv[])
+{
+	read_domain_policy(NULL);
+	write_domain_policy(1);
 	return 0;
 }
 
 /***** sortpolicy end *****/
 
+/***** diffpolicy start *****/
+
+static int find_domain_by_ptr(const struct path_info *domainname)
+{
+	int i;
+	for (i = 0; i < domain_list_count; i++) {
+		if (domain_list[i].domainname == domainname)
+			return i;
+	}
+	return EOF;
+}
+
+static int save_domain_policy_with_diff(const char *proc, const char *base,
+					const char *diff)
+{
+	const struct path_info **proc_string_ptr;
+	const struct path_info **base_string_ptr;
+	int proc_string_count;
+	int base_string_count;
+	int proc_index;
+	int base_index;
+	const struct path_info *domainname;
+	int i;
+	int j;
+	FILE *diff_fp = stdout;
+	if (diff) {
+		diff_fp = fopen(diff, "w");
+		if (!diff_fp) {
+			fprintf(stderr, "Can't open %s\n", diff);
+			return 0;
+		}
+	}
+	read_domain_policy(proc);
+	swap_domain_list();
+	read_domain_policy(base);
+	swap_domain_list();
+
+	swap_domain_list();
+	for (base_index = 0; base_index < domain_list_count; base_index++) {
+		domainname = domain_list[base_index].domainname;
+		swap_domain_list();
+		proc_index = find_domain_by_ptr(domainname);
+		swap_domain_list();
+		if (proc_index >= 0)
+			continue;
+		/* This domain was deleted by diff policy. */
+		fprintf(diff_fp, "delete %s\n\n", domainname->name);
+	}
+	swap_domain_list();
+
+	for (proc_index = 0; proc_index < domain_list_count; proc_index++) {
+		domainname = domain_list[proc_index].domainname;
+		swap_domain_list();
+		base_index = find_domain_by_ptr(domainname);
+		swap_domain_list();
+		if (base_index >= 0)
+			continue;
+		/* This domain was added by diff policy. */
+		fprintf(diff_fp, "%s\n\n", domainname->name);
+		proc_string_ptr = domain_list[proc_index].string_ptr;
+		proc_string_count = domain_list[proc_index].string_count;
+		for (i = 0; i < proc_string_count; i++)
+			fprintf(diff_fp, "%s\n", proc_string_ptr[i]->name);
+		fprintf(diff_fp, "\n");
+	}
+
+	for (proc_index = 0; proc_index < domain_list_count; proc_index++) {
+		int first = 1;
+		domainname = domain_list[proc_index].domainname;
+		swap_domain_list();
+		base_index = find_domain_by_ptr(domainname);
+		swap_domain_list();
+		if (base_index == EOF)
+			continue;
+		/* This domain exists in both base policy and proc policy. */
+		proc_string_ptr = domain_list[proc_index].string_ptr;
+		proc_string_count = domain_list[proc_index].string_count;
+		base_string_ptr = shadow_domain_list[base_index].string_ptr;
+		base_string_count = shadow_domain_list[base_index].string_count;
+		for (i = 0; i < proc_string_count; i++) {
+			for (j = 0; j < base_string_count; j++) {
+				if (proc_string_ptr[i] != base_string_ptr[j])
+					continue;
+				proc_string_ptr[i] = NULL;
+				base_string_ptr[j] = NULL;
+			}
+		}
+
+		for (i = 0; i < base_string_count; i++) {
+			if (!base_string_ptr[i])
+				continue;
+			if (first)
+				fprintf(diff_fp, "%s\n\n", domainname->name);
+			first = 0;
+			fprintf(diff_fp, "delete %s\n",
+				base_string_ptr[i]->name);
+		}
+		for (i = 0; i < proc_string_count; i++) {
+			if (!proc_string_ptr[i])
+				continue;
+			if (first)
+				fprintf(diff_fp, "%s\n\n", domainname->name);
+			first = 0;
+			fprintf(diff_fp, "%s\n", proc_string_ptr[i]->name);
+		}
+		if (!first)
+			fprintf(diff_fp, "\n");
+	}
+
+	if (diff_fp != stdout)
+		fclose(diff_fp);
+	return 1;
+}
+
+int diffpolicy_main(int argc, char *argv[])
+{
+	const char *original = argc > 1 ? argv[1] : proc_policy_domain_policy;
+	const char *base = argc > 2 ? argv[2] : base_policy_domain_policy;
+	const char *diff = argc > 3 ? argv[3] : NULL;
+	if (access(original, R_OK)) {
+		fprintf(stderr, "%s not found.\n", original);
+		return 1;
+	}
+	if (base == argv[2] && access(base, R_OK)) {
+		fprintf(stderr, "%s not found.\n", base);
+		return 1;
+	}
+	return !save_domain_policy_with_diff(original, base, diff);
+}
+
+/***** diffpolicy end *****/
+
 /***** savepolicy start *****/
 
-static int MoveProcToFile(const char *src, const char *dest) {
-	FILE *proc_fp, *file_fp;
-	int first = 1;
-	int is_domain_policy = 0;
-	if ((proc_fp = fopen(src, "r")) == NULL) {
-		fprintf(stderr, "Can't open %s\n", src);
+static int cat_file(const char *path)
+{
+	FILE *fp = fopen(path, "r");
+	int c;
+	if (!fp) {
+		fprintf(stderr, "Can't open %s\n", path);
 		return 0;
 	}
-	if ((file_fp = dest ? fopen(dest, "w") : stdout) == NULL) {
-		fprintf(stderr, "Can't open %s\n", dest);
-		fclose(proc_fp);
+	while ((c = fgetc(fp)) != EOF)
+		putchar(c);
+	fclose(fp);
+	return 1;
+}
+
+static int move_proc_to_file(const char *src, const char *base,
+			     const char *dest)
+{
+	FILE *proc_fp;
+	FILE *base_fp;
+	FILE *file_fp = stdout;
+	char **original_list = NULL;
+	char **base_list = NULL;
+	int original_list_len = 0;
+	int base_list_len = 0;
+	int i;
+	proc_fp = fopen(src, "r");
+	if (!proc_fp) {
+		fprintf(stderr, "Can't open %s\n", src);
 		return 0;
 	}
+	if (dest) {
+		file_fp = fopen(dest, "w");
+		if (!file_fp) {
+			fprintf(stderr, "Can't open %s\n", dest);
+			fclose(proc_fp);
+			return 0;
+		}
+	}
 	get();
-	while (freadline(proc_fp)) {
-		if (first) {
-			first = 0;
-			if (strncmp(shared_buffer, "<kernel>", 8) == 0) is_domain_policy = 1;
-		} else if (is_domain_policy && strncmp(shared_buffer, "<kernel>", 8) == 0) {
-			fprintf(file_fp, "\n");
+	base_fp = fopen(base, "r");
+	if (base_fp) {
+		while (freadline(base_fp)) {
+			char *cp;
+			if (!shared_buffer[0])
+				continue;
+			base_list = realloc(base_list, sizeof(char *) *
+					    (base_list_len + 1));
+			if (!base_list)
+				out_of_memory();
+			cp = strdup(shared_buffer);
+			if (!cp)
+				out_of_memory();
+			base_list[base_list_len++] = cp;
 		}
-		if (shared_buffer[0]) fprintf(file_fp, "%s\n", shared_buffer);
-		if (is_domain_policy && strncmp(shared_buffer, "use_profile ", 12) == 0) fprintf(file_fp, "\n");
+		fclose(base_fp);
 	}
+	while (freadline(proc_fp)) {
+		char *cp;
+		if (!shared_buffer[0])
+			continue;
+		original_list = realloc(original_list, sizeof(char *) *
+					(original_list_len + 1));
+		if (!original_list)
+			out_of_memory();
+		cp = strdup(shared_buffer);
+		if (!cp)
+			out_of_memory();
+		original_list[original_list_len++] = cp;
+	}
 	put();
 	fclose(proc_fp);
-	if (file_fp != stdout) fclose(file_fp);
+
+	for (i = 0; i < original_list_len; i++) {
+		int j;
+		for (j = 0; j < base_list_len; j++) {
+			if (!original_list[i] || !base_list[j] ||
+			    strcmp(original_list[i], base_list[j]))
+				continue;
+			free(original_list[i]);
+			original_list[i] = NULL;
+			free(base_list[j]);
+			base_list[j] = NULL;
+			break;
+		}
+	}
+	for (i = 0; i < base_list_len; i++) {
+		if (base_list[i])
+			fprintf(file_fp, "delete %s\n", base_list[i]);
+	}
+	for (i = 0; i < original_list_len; i++) {
+		if (original_list[i])
+			fprintf(file_fp, "%s\n", original_list[i]);
+	}
+
+	if (file_fp != stdout)
+		fclose(file_fp);
+	while (original_list_len)
+		free(original_list[--original_list_len]);
+	free(original_list);
+	while (base_list_len)
+		free(base_list[--base_list_len]);
+	free(base_list);
 	return 1;
 }
 
-static int IsIdenticalFile(const char *file1, const char *file2) {
-	char buffer1[4096], buffer2[4096];
-	struct stat sb1, sb2;
-	const int fd1 = open(file1, O_RDONLY), fd2 = open(file2, O_RDONLY);
-	int len1, len2;
+static int is_identical_file(const char *file1, const char *file2)
+{
+	char buffer1[4096];
+	char buffer2[4096];
+	struct stat sb1;
+	struct stat sb2;
+	const int fd1 = open(file1, O_RDONLY);
+	const int fd2 = open(file2, O_RDONLY);
+	int len1;
+	int len2;
 	/* Don't compare if file1 is a symlink to file2. */
-	if (fstat(fd1, &sb1) || fstat(fd2, &sb2) || sb1.st_ino == sb2.st_ino) goto out;
+	if (fstat(fd1, &sb1) || fstat(fd2, &sb2) || sb1.st_ino == sb2.st_ino)
+		goto out;
 	do {
 		len1 = read(fd1, buffer1, sizeof(buffer1));
 		len2 = read(fd2, buffer2, sizeof(buffer2));
-		if (len1 < 0 || len1 != len2) goto out;
-		if (memcmp(buffer1, buffer2, len1)) goto out;
+		if (len1 < 0 || len1 != len2)
+			goto out;
+		if (memcmp(buffer1, buffer2, len1))
+			goto out;
 	} while (len1);
 	close(fd1);
 	close(fd2);
 	return 1;
- out:
+out:
 	close(fd1);
 	close(fd2);
 	return 0;
 }
 
-int savepolicy_main(int argc, char *argv[]) {
+int savepolicy_main(int argc, char *argv[])
+{
 	int remount_root = 0;
 	char filename[1024];
 	int write_to_stdout = 0;
@@ -403,13 +720,18 @@
 	time_t now = time(NULL);
 	struct tm *tm = localtime(&now);
 	memset(filename, 0, sizeof(filename));
-	if (access("/proc/self/", F_OK)) mount("/proc", "/proc", "proc", 0, NULL);
+	if (access("/proc/self/", F_OK))
+		mount("/proc", "/proc", "proc", 0, NULL);
 	if (access(proc_policy_dir, F_OK)) {
-		fprintf(stderr, "You can't run this program for this kernel.\n");
+		fprintf(stderr,
+			"You can't run this program for this kernel.\n");
 		return 0;
 	}
 	if (argc == 1) {
-		force_save = save_system_policy = save_exception_policy = save_domain_policy = 1;
+		force_save = 1;
+		save_system_policy = 1;
+		save_exception_policy = 1;
+		save_domain_policy = 1;
 	} else {
 		int i;
 		for (i = 1; i < argc; i++) {
@@ -422,27 +744,26 @@
 			char *p = strchr(ptr, 'p');
 			char *m = strchr(ptr, 'm');
 			char *i = strchr(ptr, '-');
-			if (s || a) save_system_policy = 1;
-			if (e || a) save_exception_policy = 1;
-			if (d || a) save_domain_policy = 1;
-			if (p) save_profile = 1;
-			if (m) save_manager = 1;
-			if (f) force_save = 1;
-			if (i) write_to_stdout = 1;
-			if (strcspn(ptr, "sedafpm-") ||
-			    (write_to_stdout && save_system_policy + save_exception_policy + save_domain_policy + save_profile + save_manager != 1)) {
-				printf("%s [s][e][d][a][f][p][m][-]\n"
-				       "s : Save system_policy.\n"
-				       "e : Save exception_policy.\n"
-				       "d : Save domain_policy.\n"
-				       "a : Save system_policy,exception_policy,domain_policy.\n"
-				       "p : Save profile.\n"
-				       "m : Save manager.\n"
-				       "- : Write policy to stdout. (Only one of 'sedpm' is possible when using '-'.)\n"
-				       "f : Save even if on-disk policy and on-memory policy are the same. (Valid for 'sed'.)\n\n"
-				       "If no options given, this program assumes 'a' and 'f' are given.\n", argv[0]);
-				return 0;
-			}
+			if (s || a)
+				save_system_policy = 1;
+			if (e || a)
+				save_exception_policy = 1;
+			if (d || a)
+				save_domain_policy = 1;
+			if (p)
+				save_profile = 1;
+			if (m)
+				save_manager = 1;
+			if (f)
+				force_save = 1;
+			if (i)
+				write_to_stdout = 1;
+			if (strcspn(ptr, "sedafpm-"))
+				goto usage;
+			if (write_to_stdout && save_system_policy +
+			    save_exception_policy + save_domain_policy +
+			    save_profile + save_manager != 1)
+				goto usage;
 		}
 	}
 	if (chdir(disk_policy_dir)) {
@@ -450,26 +771,53 @@
 		return 1;
 	}
 	if (access(".", W_OK) == EOF) {
-		if (errno != EROFS || mount("/", "/", "rootfs", MS_REMOUNT, NULL) == EOF) {
-			printf("Can't remount for read-write. (%s)\n", strerror(errno));
+		if (errno != EROFS ||
+		    mount("/", "/", "rootfs", MS_REMOUNT, NULL) == EOF) {
+			printf("Can't remount for read-write. (%s)\n",
+			       strerror(errno));
 			return 1;
 		}
 		remount_root = 1;
 	}
-	
+
 	/* Exclude nonexistent policy. */
-	if (access(proc_policy_system_policy, R_OK)) save_system_policy = 0;
-	if (access(proc_policy_exception_policy, R_OK)) save_exception_policy = 0;
-	if (access(proc_policy_domain_policy, R_OK)) save_domain_policy = 0;
-	
-	if (save_profile) MoveProcToFile(proc_policy_profile, write_to_stdout ? NULL : disk_policy_profile);
-	
-	if (save_manager) MoveProcToFile(proc_policy_manager, write_to_stdout ? NULL : disk_policy_manager);
-	
+	if (access(proc_policy_system_policy, R_OK))
+		save_system_policy = 0;
+	if (access(proc_policy_exception_policy, R_OK))
+		save_exception_policy = 0;
+	if (access(proc_policy_domain_policy, R_OK))
+		save_domain_policy = 0;
+
+	if (write_to_stdout) {
+		if (save_profile)
+			cat_file(proc_policy_profile);
+		else if (save_manager)
+			cat_file(proc_policy_manager);
+		else if (save_system_policy)
+			cat_file(proc_policy_system_policy);
+		else if (save_exception_policy)
+			cat_file(proc_policy_exception_policy);
+		else if (save_domain_policy)
+			cat_file(proc_policy_domain_policy);
+		goto done;
+	}
+	if (save_profile)
+		move_proc_to_file(proc_policy_profile, base_policy_profile,
+				  disk_policy_profile);
+	if (save_manager)
+		move_proc_to_file(proc_policy_manager, base_policy_manager,
+				  disk_policy_manager);
+
 	if (save_system_policy) {
-		snprintf(filename, sizeof(filename) - 1, "system_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if (MoveProcToFile(proc_policy_system_policy, write_to_stdout ? NULL : filename) && !write_to_stdout) {
-			if (!force_save && IsIdenticalFile("system_policy.conf", filename)) {
+		snprintf(filename, sizeof(filename) - 1,
+			 "system_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		if (move_proc_to_file(proc_policy_system_policy,
+				      base_policy_system_policy, filename)
+		    && !write_to_stdout) {
+			if (!force_save &&
+			    is_identical_file("system_policy.conf", filename)) {
 				unlink(filename);
 			} else {
 				unlink("system_policy.conf");
@@ -477,11 +825,18 @@
 			}
 		}
 	}
-	
+
 	if (save_exception_policy) {
-		snprintf(filename, sizeof(filename) - 1, "exception_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if (MoveProcToFile(proc_policy_exception_policy, write_to_stdout ? NULL : filename) && !write_to_stdout) {
-			if (!force_save && IsIdenticalFile("exception_policy.conf", filename)) {
+		snprintf(filename, sizeof(filename) - 1,
+			 "exception_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		if (move_proc_to_file(proc_policy_exception_policy,
+				      base_policy_exception_policy, filename)
+		    && !write_to_stdout) {
+			if (!force_save &&
+			    is_identical_file("exception_policy.conf",
+					      filename)) {
 				unlink(filename);
 			} else {
 				unlink("exception_policy.conf");
@@ -489,11 +844,18 @@
 			}
 		}
 	}
-	
+
 	if (save_domain_policy) {
-		snprintf(filename, sizeof(filename) - 1, "domain_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if (MoveProcToFile(proc_policy_domain_policy, write_to_stdout ? NULL : filename) && !write_to_stdout) {
-			if (!force_save && IsIdenticalFile("domain_policy.conf", filename)) {
+		snprintf(filename, sizeof(filename) - 1,
+			 "domain_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		if (save_domain_policy_with_diff(proc_policy_domain_policy,
+						 base_policy_domain_policy,
+						 filename)
+		    && !write_to_stdout) {
+			if (!force_save &&
+			    is_identical_file("domain_policy.conf", filename)) {
 				unlink(filename);
 			} else {
 				unlink("domain_policy.conf");
@@ -501,54 +863,93 @@
 			}
 		}
 	}
-	
-	if (remount_root) mount("/", "/", "rootfs", MS_REMOUNT | MS_RDONLY, NULL);
+done:
+	if (remount_root)
+		mount("/", "/", "rootfs", MS_REMOUNT | MS_RDONLY, NULL);
 	return 0;
+usage:
+	printf("%s [s][e][d][a][f][p][m][-]\n"
+	       "s : Save system_policy.\n"
+	       "e : Save exception_policy.\n"
+	       "d : Save domain_policy.\n"
+	       "a : Save system_policy,exception_policy,domain_policy.\n"
+	       "p : Save profile.\n"
+	       "m : Save manager.\n"
+	       "- : Write policy to stdout. "
+	       "(Only one of 'sedpm' is possible when using '-'.)\n"
+	       "f : Save even if on-disk policy and on-memory policy "
+	       "are the same. (Valid for 'sed'.)\n\n"
+	       "If no options given, this program assumes 'a' and 'f' "
+	       "are given.\n", argv[0]);
+	return 0;
 }
 
 /***** savepolicy end *****/
 
 /***** loadpolicy start *****/
 
-static void MoveFileToProc(const char *src, const char *dest) {
-	FILE *file_fp, *proc_fp;
-	if ((proc_fp = fopen(dest, "w")) == NULL) {
+static void move_file_to_proc(const char *base, const char *src,
+			      const char *dest)
+{
+	FILE *file_fp = stdin;
+	FILE *base_fp;
+	FILE *proc_fp = fopen(dest, "w");
+	if (!proc_fp) {
 		fprintf(stderr, "Can't open %s\n", dest);
 		return;
 	}
-	if ((file_fp = src ? fopen(src, "r") : stdin) == NULL) {
-		fprintf(stderr, "Can't open %s\n", src);
-		fclose(proc_fp);
-		return;
+	if (src) {
+		file_fp = fopen(src, "r");
+		if (!file_fp) {
+			fprintf(stderr, "Can't open %s\n", src);
+			fclose(proc_fp);
+			return;
+		}
 	}
 	get();
+	base_fp = fopen(base, "r");
+	if (base_fp) {
+		while (freadline(base_fp)) {
+			if (shared_buffer[0])
+				fprintf(proc_fp, "%s\n", shared_buffer);
+		}
+		fclose(base_fp);
+	}
 	while (freadline(file_fp)) {
-		if (shared_buffer[0]) fprintf(proc_fp, "%s\n", shared_buffer);
+		if (shared_buffer[0])
+			fprintf(proc_fp, "%s\n", shared_buffer);
 	}
 	put();
 	fclose(proc_fp);
-	if (file_fp != stdin) fclose(file_fp);
+	if (file_fp != stdin)
+		fclose(file_fp);
 }
 
-static void DeleteProcPolicy(const char *name) {
+static void delete_proc_policy(const char *name)
+{
 	FILE *proc_write_fp = fopen(name, "w");
 	FILE *proc_read_fp = fopen(name, "r");
 	if (!proc_write_fp || !proc_read_fp) {
 		fprintf(stderr, "Can't open %s\n", name);
-		if (proc_write_fp) fclose(proc_write_fp);
-		if (proc_read_fp) fclose(proc_read_fp);
+		if (proc_write_fp)
+			fclose(proc_write_fp);
+		if (proc_read_fp)
+			fclose(proc_read_fp);
 		return;
 	}
 	get();
 	while (freadline(proc_read_fp)) {
-		if (shared_buffer[0]) fprintf(proc_write_fp, "delete %s\n", shared_buffer);
+		if (shared_buffer[0])
+			fprintf(proc_write_fp, "delete %s\n", shared_buffer);
 	}
 	put();
 	fclose(proc_read_fp);
 	fclose(proc_write_fp);
 }
 
-static void LoadDomainPolicy(const char *src, const char *dest) {
+static void update_domain_policy(const char *base, const char *src,
+				 const char *dest)
+{
 	int new_index;
 	int old_index;
 	struct path_info reserved;
@@ -559,42 +960,61 @@
 	}
 	reserved.name = "";
 	fill_path_info(&reserved);
-	ReadDomainPolicy(src);
-	SwapDomainList();
-	ReadDomainPolicy(dest);
-	SwapDomainList();
+	read_domain_policy(base);
+	read_domain_policy(src);
+	swap_domain_list();
+	read_domain_policy(dest);
+	swap_domain_list();
 	for (new_index = 0; new_index < domain_list_count; new_index++) {
 		int i;
-		const char *domainname = DomainName(new_index);
-		const struct path_info **new_string_ptr = domain_list[new_index].string_ptr;
-		const int new_string_count = domain_list[new_index].string_count;
-		SwapDomainList(); old_index = FindDomain(domainname, 0, 0); SwapDomainList();
+		int j;
+		const char *domainname = domain_name(new_index);
+		const struct path_info **new_string_ptr
+			= domain_list[new_index].string_ptr;
+		const int new_string_count
+			= domain_list[new_index].string_count;
+		const struct path_info **old_string_ptr;
+		int old_string_count;
+		swap_domain_list();
+		old_index = find_domain(domainname, 0, 0);
+		swap_domain_list();
 		fprintf(proc_fp, "%s\n", domainname);
-		if (old_index >= 0) {
-			int j;
-			/* Old policy for this domain found. */
-			const struct path_info **old_string_ptr = shadow_domain_list[old_index].string_ptr;
-			const int old_string_count = shadow_domain_list[old_index].string_count;
-			shadow_domain_list[old_index].domainname = &reserved; /* Don't delete this domain later. */
-			for (j = 0; j < old_string_count; j++) {
-				for (i = 0; i < new_string_count; i++) {
-					if (new_string_ptr[i] == old_string_ptr[j]) break;
-				}
-				/* Delete this entry from old policy if not found in new policy. */
-				if (i == new_string_count) fprintf(proc_fp, "delete %s\n", old_string_ptr[j]->name);
+		if (old_index == EOF)
+			goto not_found;
+
+		/* Old policy for this domain found. */
+		old_string_ptr = shadow_domain_list[old_index].string_ptr;
+		old_string_count = shadow_domain_list[old_index].string_count;
+		/* Don't delete this domain later. */
+		shadow_domain_list[old_index].domainname = &reserved;
+		for (j = 0; j < old_string_count; j++) {
+			for (i = 0; i < new_string_count; i++) {
+				if (new_string_ptr[i] == old_string_ptr[j])
+					break;
 			}
+			/* Delete this entry from old policy if not found
+			   in new policy. */
+			if (i == new_string_count)
+				fprintf(proc_fp, "delete %s\n",
+					old_string_ptr[j]->name);
 		}
+not_found:
 		/* Append entries defined in new policy. */
-		for (i = 0; i < new_string_count; i++) fprintf(proc_fp, "%s\n", new_string_ptr[i]->name);
+		for (i = 0; i < new_string_count; i++)
+			fprintf(proc_fp, "%s\n", new_string_ptr[i]->name);
 	}
 	/* Delete all domains that are not defined in new policy. */
 	for (old_index = 0; old_index < shadow_domain_list_count; old_index++) {
-		if (shadow_domain_list[old_index].domainname != &reserved) fprintf(proc_fp, "delete %s\n", shadow_domain_list[old_index].domainname->name);
+		if (shadow_domain_list[old_index].domainname == &reserved)
+			continue;
+		fprintf(proc_fp, "delete %s\n",
+			shadow_domain_list[old_index].domainname->name);
 	}
 	fclose(proc_fp);
 }
 
-int loadpolicy_main(int argc, char *argv[]) {
+int loadpolicy_main(int argc, char *argv[])
+{
 	int read_from_stdin = 0;
 	int load_profile = 0;
 	int load_manager = 0;
@@ -603,7 +1023,8 @@
 	int load_domain_policy = 0;
 	int refresh_policy = 0;
 	if (access(proc_policy_dir, F_OK)) {
-		fprintf(stderr, "You can't run this program for this kernel.\n");
+		fprintf(stderr,
+			"You can't run this program for this kernel.\n");
 		return 0;
 	}
 	if (argc == 1) {
@@ -620,27 +1041,26 @@
 			char *p = strchr(ptr, 'p');
 			char *m = strchr(ptr, 'm');
 			char *i = strchr(ptr, '-');
-			if (s || a) load_system_policy = 1;
-			if (e || a) load_exception_policy = 1;
-			if (d || a) load_domain_policy = 1;
-			if (p) load_profile = 1;
-			if (m) load_manager = 1;
-			if (f) refresh_policy = 1;
-			if (i) read_from_stdin = 1;
-			if (strcspn(ptr, "sedafpm-") ||
-			    (read_from_stdin && load_system_policy + load_exception_policy + load_domain_policy + load_profile + load_manager != 1)) {
-			usage: ;
-				printf("%s [s][e][d][a][f][p][m][-]\n"
-				       "s : Load system_policy.\n"
-				       "e : Load exception_policy.\n"
-				       "d : Load domain_policy.\n"
-				       "a : Load system_policy,exception_policy,domain_policy.\n"
-				       "p : Load profile.\n"
-				       "m : Load manager.\n"
-				       "- : Read policy from stdin. (Only one of 'sedpm' is possible when using '-'.)\n"
-				       "f : Delete on-memory policy before loading on-disk policy. (Valid for 'sed'.)\n\n", argv[0]);
-				return 0;
-			}
+			if (s || a)
+				load_system_policy = 1;
+			if (e || a)
+				load_exception_policy = 1;
+			if (d || a)
+				load_domain_policy = 1;
+			if (p)
+				load_profile = 1;
+			if (m)
+				load_manager = 1;
+			if (f)
+				refresh_policy = 1;
+			if (i)
+				read_from_stdin = 1;
+			if (strcspn(ptr, "sedafpm-"))
+				goto usage;
+			if (read_from_stdin && load_system_policy +
+			    load_exception_policy + load_domain_policy +
+			    load_profile + load_manager != 1)
+				goto usage;
 		}
 	}
 	if (chdir(disk_policy_dir)) {
@@ -648,106 +1068,318 @@
 		return 1;
 	}
 
-	if (load_profile) MoveFileToProc(read_from_stdin ? NULL : disk_policy_profile, proc_policy_profile);
-	
-	if (load_manager) MoveFileToProc(read_from_stdin ? NULL : disk_policy_manager, proc_policy_manager);
-	
+	if (load_profile) {
+		if (read_from_stdin)
+			move_file_to_proc(NULL, NULL, proc_policy_profile);
+		else
+			move_file_to_proc(base_policy_profile,
+					  disk_policy_profile,
+					  proc_policy_profile);
+	}
+
+	if (load_manager) {
+		if (read_from_stdin)
+			move_file_to_proc(NULL, NULL, proc_policy_manager);
+		else
+			move_file_to_proc(base_policy_manager,
+					  disk_policy_manager,
+					  proc_policy_manager);
+	}
+
 	if (load_system_policy) {
-		if (refresh_policy) DeleteProcPolicy(proc_policy_system_policy);
-		MoveFileToProc(read_from_stdin ? NULL : disk_policy_system_policy, proc_policy_system_policy);
+		if (refresh_policy)
+			delete_proc_policy(proc_policy_system_policy);
+		if (read_from_stdin)
+			move_file_to_proc(NULL, NULL,
+					  proc_policy_system_policy);
+		else
+			move_file_to_proc(base_policy_system_policy,
+					  disk_policy_system_policy,
+					  proc_policy_system_policy);
 	}
-	
+
 	if (load_exception_policy) {
-		if (refresh_policy) DeleteProcPolicy(proc_policy_exception_policy);
-		MoveFileToProc(read_from_stdin ? NULL : disk_policy_exception_policy, proc_policy_exception_policy);
+		if (refresh_policy)
+			delete_proc_policy(proc_policy_exception_policy);
+		if (read_from_stdin)
+			move_file_to_proc(NULL, NULL,
+					  proc_policy_exception_policy);
+		else
+			move_file_to_proc(base_policy_exception_policy,
+					  disk_policy_exception_policy,
+					  proc_policy_exception_policy);
 	}
 
 	if (load_domain_policy) {
 		if (refresh_policy) {
-			LoadDomainPolicy(read_from_stdin ? NULL : disk_policy_domain_policy, proc_policy_domain_policy);
+			if (read_from_stdin)
+				update_domain_policy(NULL, NULL,
+						     proc_policy_domain_policy);
+			else
+				update_domain_policy(base_policy_domain_policy,
+						     disk_policy_domain_policy,
+						     proc_policy_domain_policy);
 		} else {
-			MoveFileToProc(read_from_stdin ? NULL : disk_policy_domain_policy, proc_policy_domain_policy);
+			if (read_from_stdin)
+				move_file_to_proc(NULL, NULL,
+						  proc_policy_domain_policy);
+			else
+				move_file_to_proc(base_policy_domain_policy,
+						  disk_policy_domain_policy,
+						  proc_policy_domain_policy);
 		}
 	}
 	return 0;
+usage:
+	printf("%s [s][e][d][a][f][p][m][-]\n"
+	       "s : Load system_policy.\n"
+	       "e : Load exception_policy.\n"
+	       "d : Load domain_policy.\n"
+	       "a : Load system_policy,exception_policy,domain_policy.\n"
+	       "p : Load profile.\n"
+	       "m : Load manager.\n"
+	       "- : Read policy from stdin. "
+	       "(Only one of 'sedpm' is possible when using '-'.)\n"
+	       "f : Delete on-memory policy before loading on-disk policy. "
+	       "(Valid for 'sed'.)\n\n", argv[0]);
+	return 0;
 }
 
 /***** loadpolicy end *****/
 
 /***** editpolicy start *****/
 
+#define DIRECTIVE_1                                 0
+#define DIRECTIVE_2                                 1
+#define DIRECTIVE_3                                 2
+#define DIRECTIVE_4                                 3
+#define DIRECTIVE_5                                 4
+#define DIRECTIVE_6                                 5
+#define DIRECTIVE_7                                 6
+#define DIRECTIVE_ALLOW_EXECUTE                     7
+#define DIRECTIVE_ALLOW_READ                        8
+#define DIRECTIVE_ALLOW_WRITE                       9
+#define DIRECTIVE_ALLOW_READ_WRITE                 10
+#define DIRECTIVE_ALLOW_CREATE                     11
+#define DIRECTIVE_ALLOW_UNLINK                     12
+#define DIRECTIVE_ALLOW_MKDIR                      13
+#define DIRECTIVE_ALLOW_RMDIR                      14
+#define DIRECTIVE_ALLOW_MKFIFO                     15
+#define DIRECTIVE_ALLOW_MKSOCK                     16
+#define DIRECTIVE_ALLOW_MKBLOCK                    17
+#define DIRECTIVE_ALLOW_MKCHAR                     18
+#define DIRECTIVE_ALLOW_TRUNCATE                   19
+#define DIRECTIVE_ALLOW_SYMLINK                    20
+#define DIRECTIVE_ALLOW_LINK                       21
+#define DIRECTIVE_ALLOW_RENAME                     22
+#define DIRECTIVE_ALLOW_REWRITE                    23
+#define DIRECTIVE_ALLOW_ARGV0                      24
+#define DIRECTIVE_ALLOW_SIGNAL                     25
+#define DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_BIND    26
+#define DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_CONNECT 27
+#define DIRECTIVE_ALLOW_NETWORK_TCP_BIND           28
+#define DIRECTIVE_ALLOW_NETWORK_TCP_LISTEN         29
+#define DIRECTIVE_ALLOW_NETWORK_TCP_CONNECT        30
+#define DIRECTIVE_ALLOW_NETWORK_TCP_ACCEPT         31
+#define DIRECTIVE_ALLOW_NETWORK_RAW_BIND           32
+#define DIRECTIVE_ALLOW_NETWORK_RAW_CONNECT        33
+#define DIRECTIVE_ALLOW_ENV                        34
+#define DIRECTIVE_ADDRESS_GROUP                    35
+#define DIRECTIVE_AGGREGATOR                       36
+#define DIRECTIVE_ALIAS                            37
+#define DIRECTIVE_ALLOW_CAPABILITY                 38
+#define DIRECTIVE_ALLOW_CHROOT                     39
+#define DIRECTIVE_ALLOW_MOUNT                      40
+#define DIRECTIVE_ALLOW_PIVOT_ROOT                 41
+#define DIRECTIVE_DENY_AUTOBIND                    42
+#define DIRECTIVE_DENY_REWRITE                     43
+#define DIRECTIVE_DENY_UNMOUNT                     44
+#define DIRECTIVE_FILE_PATTERN                     45
+#define DIRECTIVE_EXECUTE_HANDLER                  46
+#define DIRECTIVE_DENIED_EXECUTE_HANDLER           47
+#define DIRECTIVE_IGNORE_GLOBAL_ALLOW_ENV          48
+#define DIRECTIVE_IGNORE_GLOBAL_ALLOW_READ         49
+#define DIRECTIVE_INITIALIZE_DOMAIN                50
+#define DIRECTIVE_KEEP_DOMAIN                      51
+#define DIRECTIVE_NO_INITIALIZE_DOMAIN             52
+#define DIRECTIVE_NO_KEEP_DOMAIN                   53
+#define DIRECTIVE_PATH_GROUP                       54
+#define DIRECTIVE_QUOTA_EXCEEDED                   55
+#define DIRECTIVE_USE_PROFILE                      56
+#define MAX_DIRECTIVE_INDEX                        57
+
+static struct {
+	const char *original;
+	const char *alias;
+	int original_len;
+	int alias_len;
+} directives[MAX_DIRECTIVE_INDEX] = {
+	[DIRECTIVE_1]  = { "1", NULL, 0, 0 },
+	[DIRECTIVE_2]  = { "2", NULL, 0, 0 },
+	[DIRECTIVE_3]  = { "3", NULL, 0, 0 },
+	[DIRECTIVE_4]  = { "4", NULL, 0, 0 },
+	[DIRECTIVE_5]  = { "5", NULL, 0, 0 },
+	[DIRECTIVE_6]  = { "6", NULL, 0, 0 },
+	[DIRECTIVE_7]  = { "7", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_EXECUTE]    = { "allow_execute", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_READ]       = { "allow_read", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_WRITE]      = { "allow_write", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_READ_WRITE] = { "allow_read/write", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_CREATE]     = { "allow_create", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_UNLINK]     = { "allow_unlink", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MKDIR]      = { "allow_mkdir", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_RMDIR]      = { "allow_rmdir", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MKFIFO]     = { "allow_mkfifo", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MKSOCK]     = { "allow_mksock", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MKBLOCK]    = { "allow_mkblock", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MKCHAR]     = { "allow_mkchar", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_TRUNCATE]   = { "allow_truncate", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_SYMLINK]    = { "allow_symlink", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_LINK]       = { "allow_link", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_RENAME]     = { "allow_rename", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_REWRITE]    = { "allow_rewrite", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_ARGV0]      = { "allow_argv0", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_SIGNAL]     = { "allow_signal", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_BIND] = {
+		"allow_network UDP bind", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_CONNECT] = {
+		"allow_network UDP connect", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_TCP_BIND] = {
+		"allow_network TCP bind", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_TCP_LISTEN] = {
+		"allow_network TCP listen", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_TCP_CONNECT] = {
+		"allow_network TCP connect", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_TCP_ACCEPT] = {
+		"allow_network TCP accept", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_RAW_BIND] = {
+		"allow_network RAW bind", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_RAW_CONNECT] = {
+		"allow_network RAW connect", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_ENV]        = { "allow_env", NULL, 0, 0 },
+	[DIRECTIVE_ADDRESS_GROUP]    = { "address_group", NULL, 0, 0 },
+	[DIRECTIVE_AGGREGATOR]       = { "aggregator", NULL, 0, 0 },
+	[DIRECTIVE_ALIAS]            = { "alias", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_CAPABILITY] = { "allow_capability", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_CHROOT]     = { "allow_chroot", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MOUNT]      = { "allow_mount", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_PIVOT_ROOT] = { "allow_pivot_root", NULL, 0, 0 },
+	[DIRECTIVE_DENY_AUTOBIND]    = { "deny_autobind", NULL, 0, 0 },
+	[DIRECTIVE_DENY_REWRITE]     = { "deny_rewrite", NULL, 0, 0 },
+	[DIRECTIVE_DENY_UNMOUNT]     = { "deny_unmount", NULL, 0, 0 },
+	[DIRECTIVE_FILE_PATTERN]     = { "file_pattern", NULL, 0, 0 },
+	[DIRECTIVE_EXECUTE_HANDLER]  = { "execute_handler", NULL, 0, 0 },
+	[DIRECTIVE_DENIED_EXECUTE_HANDLER] = {
+		"denied_execute_handler", NULL, 0, 0 },
+	[DIRECTIVE_IGNORE_GLOBAL_ALLOW_ENV] = {
+		"ignore_global_allow_env", NULL, 0, 0 },
+	[DIRECTIVE_IGNORE_GLOBAL_ALLOW_READ] = {
+		"ignore_global_allow_read", NULL, 0, 0 },
+	[DIRECTIVE_INITIALIZE_DOMAIN]    = { "initialize_domain", NULL, 0, 0 },
+	[DIRECTIVE_KEEP_DOMAIN]          = { "keep_domain", NULL, 0, 0 },
+	[DIRECTIVE_NO_INITIALIZE_DOMAIN] = {
+		"no_initialize_domain", NULL, 0, 0 },
+	[DIRECTIVE_NO_KEEP_DOMAIN]       = { "no_keep_domain", NULL, 0, 0 },
+	[DIRECTIVE_PATH_GROUP]       = { "path_group", NULL, 0, 0 },
+	[DIRECTIVE_QUOTA_EXCEEDED]   = { "quota_exceeded", NULL, 0, 0 },
+	[DIRECTIVE_USE_PROFILE]      = { "use_profile", NULL, 0, 0 },
+};
+
 static const char *policy_file = DOMAIN_POLICY_FILE;
 static const char *list_caption = NULL;
 static char *current_domain = NULL;
 
 static int current_screen = SCREEN_DOMAIN_LIST;
 
-// List for generic policy.
-static char **generic_acl_list = NULL;
+/* List for generic policy. */
+static struct generic_acl {
+	u8 directive;
+	u8 selected;
+	const char *operand;
+} *generic_acl_list = NULL;
 static int generic_acl_list_count = 0;
-static unsigned char *generic_acl_list_selected = NULL;
 
 static struct domain_keeper_entry *domain_keeper_list = NULL;
 static int domain_keeper_list_len = 0;
 static struct domain_initializer_entry *domain_initializer_list = NULL;
 static int domain_initializer_list_len = 0;
 
-///////////////////////////  ACL HANDLER  //////////////////////////////
+/* ACL HANDLER  */
 
-static const struct domain_keeper_entry *IsDomainKeeper(const struct path_info *domainname, const char *program) {
+static const struct domain_keeper_entry *
+is_domain_keeper(const struct path_info *domainname, const char *program)
+{
 	int i;
 	const struct domain_keeper_entry *flag = NULL;
 	struct path_info last_name;
-	if ((last_name.name = strrchr(domainname->name, ' ')) != NULL) last_name.name++;
-	else last_name.name = domainname->name;
+	last_name.name = strrchr(domainname->name, ' ');
+	if (last_name.name)
+		last_name.name++;
+	else
+		last_name.name = domainname->name;
 	fill_path_info(&last_name);
 	for (i = 0; i < domain_keeper_list_len; i++) {
 		struct domain_keeper_entry *ptr = &domain_keeper_list[i];
 		if (!ptr->is_last_name) {
-			if (pathcmp(ptr->domainname, domainname)) continue;
+			if (pathcmp(ptr->domainname, domainname))
+				continue;
 		} else {
-			if (pathcmp(ptr->domainname, &last_name)) continue;
+			if (pathcmp(ptr->domainname, &last_name))
+				continue;
 		}
-		if (ptr->program && strcmp(ptr->program->name, program)) continue;
-		if (ptr->is_not) return NULL;
+		if (ptr->program && strcmp(ptr->program->name, program))
+			continue;
+		if (ptr->is_not)
+			return NULL;
 		flag = ptr;
 	}
 	return flag;
 }
 
-static const struct domain_initializer_entry *IsDomainInitializer(const struct path_info *domainname, const char *program) {
+static const struct domain_initializer_entry *
+is_domain_initializer(const struct path_info *domainname, const char *program)
+{
 	int i;
 	const struct domain_initializer_entry *flag = NULL;
 	struct path_info last_name;
-	if ((last_name.name = strrchr(domainname->name, ' ')) != NULL) last_name.name++;
-	else last_name.name = domainname->name;
+	last_name.name = strrchr(domainname->name, ' ');
+	if (last_name.name)
+		last_name.name++;
+	else
+		last_name.name = domainname->name;
 	fill_path_info(&last_name);
 	for (i = 0; i < domain_initializer_list_len; i++) {
-		struct domain_initializer_entry *ptr = &domain_initializer_list[i];
+		struct domain_initializer_entry *ptr
+			= &domain_initializer_list[i];
 		if (ptr->domainname) {
 			if (!ptr->is_last_name) {
-				if (pathcmp(ptr->domainname, domainname)) continue;
+				if (pathcmp(ptr->domainname, domainname))
+					continue;
 			} else {
-				if (pathcmp(ptr->domainname, &last_name)) continue;
+				if (pathcmp(ptr->domainname, &last_name))
+					continue;
 			}
 		}
-		if (strcmp(ptr->program->name, program)) continue;
-		if (ptr->is_not) return NULL;
+		if (strcmp(ptr->program->name, program))
+			continue;
+		if (ptr->is_not)
+			return NULL;
 		flag = ptr;
 	}
 	return flag;
 }
 
-///////////////////////////  UTILITY FUNCTIONS  //////////////////////////////
+/* UTILITY FUNCTIONS */
 
 static int offline_mode = 0;
 static int persistent_fd = EOF;
 
-static void SendFD(char *data, int *fd) {
+static void send_fd(char *data, int *fd)
+{
 	struct msghdr msg;
 	struct iovec iov = { data, strlen(data) };
 	char cmsg_buf[CMSG_SPACE(sizeof(int))];
-	struct cmsghdr *cmsg = (struct cmsghdr *) cmsg_buf; 
+	struct cmsghdr *cmsg = (struct cmsghdr *) cmsg_buf;
 	memset(&msg, 0, sizeof(msg));
 	msg.msg_iov = &iov;
 	msg.msg_iovlen = 1;
@@ -755,13 +1387,15 @@
 	msg.msg_controllen = sizeof(cmsg_buf);
 	cmsg->cmsg_level = SOL_SOCKET;
 	cmsg->cmsg_type = SCM_RIGHTS;
-	msg.msg_controllen = cmsg->cmsg_len = CMSG_LEN(sizeof(int));
+	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
+	msg.msg_controllen = cmsg->cmsg_len;
 	memmove(CMSG_DATA(cmsg), fd, sizeof(int));
 	sendmsg(persistent_fd, &msg, 0);
 	close(*fd);
 }
 
-static FILE *open_read(const char *filename) {
+static FILE *open_read(const char *filename)
+{
 	if (offline_mode) {
 		char request[1024];
 		int fd[2];
@@ -770,20 +1404,26 @@
 			fprintf(stderr, "socketpair()\n");
 			exit(1);
 		}
-		if (shutdown(fd[0], SHUT_WR) || (fp = fdopen(fd[0], "r")) == NULL) {
-			close(fd[1]); close(fd[0]);
-			exit(1);
-		}
+		if (shutdown(fd[0], SHUT_WR))
+			goto out;
+		fp = fdopen(fd[0], "r");
+		if (!fp)
+			goto out;
 		memset(request, 0, sizeof(request));
 		snprintf(request, sizeof(request) - 1, "GET %s", filename);
-		SendFD(request, &fd[1]);
+		send_fd(request, &fd[1]);
 		return fp;
+out:
+		close(fd[1]);
+		close(fd[0]);
+		exit(1);
 	} else {
 		return fopen(filename, "r");
 	}
 }
 
-static FILE *open_write(const char *filename) {
+static FILE *open_write(const char *filename)
+{
 	if (offline_mode) {
 		char request[1024];
 		int fd[2];
@@ -791,172 +1431,245 @@
 			fprintf(stderr, "socketpair()\n");
 			exit(1);
 		}
-		if (shutdown(fd[0], SHUT_RD)) {
-			close(fd[1]); close(fd[0]);
-			exit(1);
-		}
+		if (shutdown(fd[0], SHUT_RD))
+			goto out;
 		memset(request, 0, sizeof(request));
 		snprintf(request, sizeof(request) - 1, "POST %s", filename);
-		SendFD(request, &fd[1]);
+		send_fd(request, &fd[1]);
 		return fdopen(fd[0], "w");
+out:
+		close(fd[1]);
+		close(fd[0]);
+		exit(1);
 	} else {
 		return fdopen(open(filename, O_WRONLY), "w");
 	}
 }
 
-static char *map_perm_keyword(const u8 forward, const char *line);
-static int string_acl_compare(const void *a, const void *b);
+static u8 find_directive(const u8 forward, char *line);
+static int generic_acl_compare(const void *a, const void *b);
 
-static void ReadGenericPolicy(void) {
+static void read_generic_policy(void)
+{
 	FILE *fp;
-	while (generic_acl_list_count) free(generic_acl_list[--generic_acl_list_count]);
-	if ((fp = open_read(policy_file)) != NULL) {
+	int flag = 0;
+	while (generic_acl_list_count)
+		free((void *)
+		     generic_acl_list[--generic_acl_list_count].operand);
+	fp = open_read(policy_file);
+	if (!fp)
+		return;
+	get();
+	while (freadline(fp)) {
+		u8 directive;
+		char *cp;
 		if (current_screen == SCREEN_ACL_LIST) {
-			int flag = 0;
-			get();
-			while (freadline(fp)) {
-				if (IsDomainDef(shared_buffer)) {
-					flag = strcmp(shared_buffer, current_domain) == 0 ? 1 : 0;
-				} else if (flag && shared_buffer[0] && strncmp(shared_buffer, KEYWORD_USE_PROFILE, KEYWORD_USE_PROFILE_LEN)) {
-					if ((generic_acl_list = (char **) realloc(generic_acl_list, (generic_acl_list_count + 1) * sizeof(char *))) == NULL
-					    || (generic_acl_list[generic_acl_list_count++] = strdup(map_perm_keyword(1, shared_buffer))) == NULL) OutOfMemory();
-				}
+			if (is_domain_def(shared_buffer)) {
+				flag = !strcmp(shared_buffer, current_domain);
+				continue;
 			}
-			put();
-			qsort(generic_acl_list, generic_acl_list_count, sizeof(char *), string_acl_compare);
+			if (!flag || !shared_buffer[0] ||
+			    !strncmp(shared_buffer, KEYWORD_USE_PROFILE,
+				     KEYWORD_USE_PROFILE_LEN))
+				continue;
 		} else {
-			get();
-			while (freadline(fp)) {
-				if (!shared_buffer[0]) continue;
-				if ((generic_acl_list = (char **) realloc(generic_acl_list, (generic_acl_list_count + 1) * sizeof(char *))) == NULL
-					|| (generic_acl_list[generic_acl_list_count++] = strdup(map_perm_keyword(1, shared_buffer))) == NULL) OutOfMemory();
-			}
-			put();
-			qsort(generic_acl_list, generic_acl_list_count, sizeof(char *), string_compare);
+			if (!shared_buffer[0])
+				continue;
 		}
-		fclose(fp);
+		directive = find_directive(1, shared_buffer);
+		if (directive == (u8) EOF)
+			continue;
+		generic_acl_list = realloc(generic_acl_list,
+					   (generic_acl_list_count + 1) *
+					   sizeof(struct generic_acl));
+		if (!generic_acl_list)
+			out_of_memory();
+		cp = strdup(shared_buffer);
+		if (!cp)
+			out_of_memory();
+		generic_acl_list[generic_acl_list_count].directive = directive;
+		generic_acl_list[generic_acl_list_count].selected = 0;
+		generic_acl_list[generic_acl_list_count++].operand = cp;
 	}
-	generic_acl_list_selected = realloc(generic_acl_list_selected, generic_acl_list_count);
-	if (generic_acl_list_count && !generic_acl_list_selected) OutOfMemory();
-	memset(generic_acl_list_selected, 0, generic_acl_list_count);
+	put();
+	qsort(generic_acl_list, generic_acl_list_count,
+	      sizeof(struct generic_acl), generic_acl_compare);
+	fclose(fp);
 }
 
-static int AddDomainInitializerEntry(const char *domainname, const char *program, const int is_not) {
+static int add_domain_initializer_entry(const char *domainname,
+					const char *program, const int is_not)
+{
+	void *vp;
 	struct domain_initializer_entry *ptr;
 	int is_last_name = 0;
-	if (!IsCorrectPath(program, 1, 0, -1)) return -EINVAL;
+	if (!is_correct_path(program, 1, 0, -1))
+		return -EINVAL;
 	if (domainname) {
-		if (IsCorrectPath(domainname, 1, -1, -1)) {
+		if (is_correct_path(domainname, 1, -1, -1))
 			is_last_name = 1;
-		} else if (!IsCorrectDomain(domainname)) {
+		else if (!is_correct_domain(domainname))
 			return -EINVAL;
-		}
 	}
-	if ((domain_initializer_list = (struct domain_initializer_entry *) realloc(domain_initializer_list, (domain_initializer_list_len + 1) * sizeof(struct domain_initializer_entry))) == NULL) OutOfMemory();
+	vp = realloc(domain_initializer_list,
+		     (domain_initializer_list_len + 1) *
+		     sizeof(struct domain_initializer_entry));
+	if (!vp)
+		out_of_memory();
+	domain_initializer_list = vp;
 	ptr = &domain_initializer_list[domain_initializer_list_len++];
 	memset(ptr, 0, sizeof(struct domain_initializer_entry));
-	if ((ptr->program = SaveName(program)) == NULL) OutOfMemory();
-	if (domainname && (ptr->domainname = SaveName(domainname)) == NULL) OutOfMemory();
+	ptr->program = savename(program);
+	if (!ptr->program)
+		out_of_memory();
+	if (domainname) {
+		ptr->domainname = savename(domainname);
+		if (!ptr->domainname)
+			out_of_memory();
+	}
 	ptr->is_not = is_not;
 	ptr->is_last_name = is_last_name;
 	return 0;
 }
 
-static int AddDomainInitializerPolicy(char *data, const int is_not) {
+static int add_domain_initializer_policy(char *data, const int is_not)
+{
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
-		return AddDomainInitializerEntry(cp + 6, data, is_not);
+		return add_domain_initializer_entry(cp + 6, data, is_not);
 	} else {
-		return AddDomainInitializerEntry(NULL, data, is_not);
+		return add_domain_initializer_entry(NULL, data, is_not);
 	}
 }
 
-static int AddDomainKeeperEntry(const char *domainname, const char *program, const int is_not) {
+static int add_domain_keeper_entry(const char *domainname, const char *program,
+				   const int is_not)
+{
 	struct domain_keeper_entry *ptr;
 	int is_last_name = 0;
-	if (IsCorrectPath(domainname, 1, -1, -1)) {
+	if (is_correct_path(domainname, 1, -1, -1))
 		is_last_name = 1;
-	} else if (!IsCorrectDomain(domainname)) {
+	else if (!is_correct_domain(domainname))
 		return -EINVAL;
-	}
-	if (program && !IsCorrectPath(program, 1, 0, -1)) return -EINVAL;
-	if ((domain_keeper_list = (struct domain_keeper_entry *) realloc(domain_keeper_list, (domain_keeper_list_len + 1) * sizeof(struct domain_keeper_entry))) == NULL) OutOfMemory();
+	if (program && !is_correct_path(program, 1, 0, -1))
+		return -EINVAL;
+	domain_keeper_list = realloc(domain_keeper_list,
+				     (domain_keeper_list_len + 1) *
+				     sizeof(struct domain_keeper_entry));
+	if (!domain_keeper_list)
+		out_of_memory();
 	ptr = &domain_keeper_list[domain_keeper_list_len++];
 	memset(ptr, 0, sizeof(struct domain_keeper_entry));
-	if ((ptr->domainname = SaveName(domainname)) == NULL) OutOfMemory();
-	if (program && (ptr->program = SaveName(program)) == NULL) OutOfMemory();
+	ptr->domainname = savename(domainname);
+	if (!ptr->domainname)
+		out_of_memory();
+	if (program) {
+		ptr->program = savename(program);
+		if (!ptr->program)
+			out_of_memory();
+	}
 	ptr->is_not = is_not;
 	ptr->is_last_name = is_last_name;
 	return 0;
 }
 
-static int AddDomainKeeperPolicy(char *data, const int is_not) {
+static int add_domain_keeper_policy(char *data, const int is_not)
+{
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
-		return AddDomainKeeperEntry(cp + 6, data, is_not);
+		return add_domain_keeper_entry(cp + 6, data, is_not);
 	} else {
-		return AddDomainKeeperEntry(data, NULL, is_not);
+		return add_domain_keeper_entry(data, NULL, is_not);
 	}
 }
 
-static int AddPathGroupEntry(const char *group_name, const char *member_name, const int is_delete) {
-	const struct path_info *saved_group_name, *saved_member_name;
-	int i, j;
+static int add_path_group_entry(const char *group_name, const char *member_name,
+				const int is_delete)
+{
+	const struct path_info *saved_group_name;
+	const struct path_info *saved_member_name;
+	int i;
+	int j;
 	struct path_group_entry *group = NULL;
-	if (!IsCorrectPath(group_name, 0, 0, 0) ||
-		!IsCorrectPath(member_name, 0, 0, 0)) return -EINVAL;
-	if ((saved_group_name = SaveName(group_name)) == NULL ||
-		(saved_member_name = SaveName(member_name)) == NULL) return -ENOMEM;
+	if (!is_correct_path(group_name, 0, 0, 0) ||
+	    !is_correct_path(member_name, 0, 0, 0))
+		return -EINVAL;
+	saved_group_name = savename(group_name);
+	saved_member_name = savename(member_name);
+	if (!saved_group_name || !saved_member_name)
+		return -ENOMEM;
 	for (i = 0; i < path_group_list_len; i++) {
 		group = &path_group_list[i];
-		if (saved_group_name != group->group_name) continue;
+		if (saved_group_name != group->group_name)
+			continue;
 		for (j = 0; j < group->member_name_len; j++) {
-			if (group->member_name[j] == saved_member_name) {
-				if (is_delete) {
-					while (j < group->member_name_len - 1) group->member_name[j] = group->member_name[j + 1];
-					group->member_name_len--;
-				} else {
-					return 0;
-				}
-			}
+			if (group->member_name[j] != saved_member_name)
+				continue;
+			if (!is_delete)
+				return 0;
+			while (j < group->member_name_len - 1)
+				group->member_name[j] =
+					group->member_name[j + 1];
+			group->member_name_len--;
+			return 0;
 		}
 		break;
 	}
-	if (is_delete) return -ENOENT;
+	if (is_delete)
+		return -ENOENT;
 	if (i == path_group_list_len) {
-		if ((path_group_list = (struct path_group_entry *) realloc(path_group_list, (path_group_list_len + 1) * sizeof(struct path_group_entry))) == NULL) OutOfMemory();
+		path_group_list = realloc(path_group_list,
+					  (path_group_list_len + 1) *
+					  sizeof(struct path_group_entry));
+		if (!path_group_list)
+			out_of_memory();
 		group = &path_group_list[path_group_list_len++];
 		memset(group, 0, sizeof(struct path_group_entry));
 		group->group_name = saved_group_name;
 	}
-	if ((group->member_name = (const struct path_info **) realloc(group->member_name, (group->member_name_len + 1) * sizeof(const struct path_info *))) == NULL) OutOfMemory();
+	group->member_name = realloc(group->member_name,
+				     (group->member_name_len + 1)
+				     * sizeof(const struct path_info *));
+	if (!group->member_name)
+		out_of_memory();
 	group->member_name[group->member_name_len++] = saved_member_name;
 	return 0;
 }
 
-static int AddPathGroupPolicy(char *data, const int is_delete) {
+static int add_path_group_policy(char *data, const int is_delete)
+{
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
-	return AddPathGroupEntry(data, cp, is_delete);
+	return add_path_group_entry(data, cp, is_delete);
 }
 
-static struct path_group_entry *FindPathGroup(const char *group_name) {
+static struct path_group_entry *find_path_group(const char *group_name)
+{
 	int i;
 	for (i = 0; i < path_group_list_len; i++) {
-		if (strcmp(group_name, path_group_list[i].group_name->name) == 0) return &path_group_list[i];
+		if (!strcmp(group_name, path_group_list[i].group_name->name))
+			return &path_group_list[i];
 	}
 	return NULL;
 }
 
-static int parse_ip(const char *address, struct ip_address_entry *entry) {
-	unsigned int min[8], max[8];
-	int i, j;
+static int parse_ip(const char *address, struct ip_address_entry *entry)
+{
+	unsigned int min[8];
+	unsigned int max[8];
+	int i;
+	int j;
 	memset(entry, 0, sizeof(*entry));
-	i = sscanf(address, "%u.%u.%u.%u-%u.%u.%u.%u", &min[0], &min[1], &min[2], &min[3], &max[0], &max[1], &max[2], &max[3]);
-	if (i == 4) for (j = 0; j < 4; j++) max[j] = min[j]; 
+	i = sscanf(address, "%u.%u.%u.%u-%u.%u.%u.%u",
+		   &min[0], &min[1], &min[2], &min[3],
+		   &max[0], &max[1], &max[2], &max[3]);
+	if (i == 4)
+		for (j = 0; j < 4; j++)
+			max[j] = min[j];
 	if (i == 4 || i == 8) {
 		for (j = 0; j < 4; j++) {
 			entry->min[j] = (u8) min[j];
@@ -965,13 +1678,19 @@
 		return 0;
 	}
 	i = sscanf(address, "%X:%X:%X:%X:%X:%X:%X:%X-%X:%X:%X:%X:%X:%X:%X:%X",
-		   &min[0], &min[1], &min[2], &min[3], &min[4], &min[5], &min[6], &min[7],
-		   &max[0], &max[1], &max[2], &max[3], &max[4], &max[5], &max[6], &max[7]);
-	if (i == 8) for (j = 0; j < 8; j++) max[j] = min[j]; 
+		   &min[0], &min[1], &min[2], &min[3],
+		   &min[4], &min[5], &min[6], &min[7],
+		   &max[0], &max[1], &max[2], &max[3],
+		   &max[4], &max[5], &max[6], &max[7]);
+	if (i == 8)
+		for (j = 0; j < 8; j++)
+			max[j] = min[j];
 	if (i == 8 || i == 16) {
 		for (j = 0; j < 8; j++) {
-			entry->min[j * 2] = (u8) (min[j] >> 8); entry->min[j * 2 + 1] = (u8) min[j]; 
-			entry->max[j * 2] = (u8) (max[j] >> 8); entry->max[j * 2 + 1] = (u8) max[j]; 
+			entry->min[j * 2] = (u8) (min[j] >> 8);
+			entry->min[j * 2 + 1] = (u8) min[j];
+			entry->max[j * 2] = (u8) (max[j] >> 8);
+			entry->max[j * 2 + 1] = (u8) max[j];
 		}
 		entry->is_ipv6 = 1;
 		return 0;
@@ -979,233 +1698,330 @@
 	return -EINVAL;
 }
 
-static int AddAddressGroupEntry(const char *group_name, const char *member_name, const int is_delete) {
+static int add_address_group_entry(const char *group_name,
+				   const char *member_name, const int is_delete)
+{
 	const struct path_info *saved_group_name;
-	int i, j;
+	int i;
+	int j;
 	struct ip_address_entry entry;
 	struct address_group_entry *group = NULL;
-	if (parse_ip(member_name, &entry)) return -EINVAL;
-	if (!IsCorrectPath(group_name, 0, 0, 0)) return -EINVAL;
-	if ((saved_group_name = SaveName(group_name)) == NULL) return -ENOMEM;
+	if (parse_ip(member_name, &entry))
+		return -EINVAL;
+	if (!is_correct_path(group_name, 0, 0, 0))
+		return -EINVAL;
+	saved_group_name = savename(group_name);
+	if (!saved_group_name)
+		return -ENOMEM;
 	for (i = 0; i < address_group_list_len; i++) {
 		group = &address_group_list[i];
-		if (saved_group_name != group->group_name) continue;
+		if (saved_group_name != group->group_name)
+			continue;
 		for (j = 0; j < group->member_name_len; j++) {
-			if (memcmp(&group->member_name[j], &entry, sizeof(entry)) == 0) {
-				if (is_delete) {
-					while (j < group->member_name_len - 1) group->member_name[j] = group->member_name[j + 1];
-					group->member_name_len--;
-				} else {
-					return 0;
-				}
-			}
+			if (memcmp(&group->member_name[j], &entry,
+				   sizeof(entry)))
+				continue;
+			if (!is_delete)
+				return 0;
+			while (j < group->member_name_len - 1)
+				group->member_name[j]
+					= group->member_name[j + 1];
+			group->member_name_len--;
+			return 0;
 		}
 		break;
 	}
-	if (is_delete) return -ENOENT;
+	if (is_delete)
+		return -ENOENT;
 	if (i == address_group_list_len) {
-		if ((address_group_list = (struct address_group_entry *) realloc(address_group_list, (address_group_list_len + 1) * sizeof(struct address_group_entry))) == NULL) OutOfMemory();
+		void *vp;
+		vp = realloc(address_group_list,
+			     (address_group_list_len + 1) *
+			     sizeof(struct address_group_entry));
+		if (!vp)
+			out_of_memory();
+		address_group_list = vp;
 		group = &address_group_list[address_group_list_len++];
 		memset(group, 0, sizeof(struct address_group_entry));
 		group->group_name = saved_group_name;
 	}
-	if ((group->member_name = (struct ip_address_entry *) realloc(group->member_name, (group->member_name_len + 1) * sizeof(const struct ip_address_entry))) == NULL) OutOfMemory();
+	group->member_name = realloc(group->member_name,
+				     (group->member_name_len + 1) *
+				     sizeof(const struct ip_address_entry));
+	if (!group->member_name)
+		out_of_memory();
 	group->member_name[group->member_name_len++] = entry;
 	return 0;
 }
 
-static int AddAddressGroupPolicy(char *data, const int is_delete) {
+static int add_address_group_policy(char *data, const int is_delete)
+{
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
-	return AddAddressGroupEntry(data, cp, is_delete);
+	return add_address_group_entry(data, cp, is_delete);
 }
 
-static struct address_group_entry *FindAddressGroup(const char *group_name) {
+static struct address_group_entry *find_address_group(const char *group_name)
+{
 	int i;
 	for (i = 0; i < address_group_list_len; i++) {
-		if (strcmp(group_name, address_group_list[i].group_name->name) == 0) return &address_group_list[i];
+		if (!strcmp(group_name, address_group_list[i].group_name->name))
+			return &address_group_list[i];
 	}
 	return NULL;
 }
 
-static void AssignDomainInitializerSource(const struct path_info *domainname, const char *program) {
-	if (IsDomainInitializer(domainname, program)) {
+static void assign_domain_initializer_source(const struct path_info *domainname,
+					     const char *program)
+{
+	if (is_domain_initializer(domainname, program)) {
 		get();
 		memset(shared_buffer, 0, shared_buffer_len);
-		snprintf(shared_buffer, shared_buffer_len - 1, "%s %s", domainname->name, program);
-		NormalizeLine(shared_buffer);
-		if (FindOrAssignNewDomain(shared_buffer, 1, 0) == EOF) OutOfMemory();
+		snprintf(shared_buffer, shared_buffer_len - 1, "%s %s",
+			 domainname->name, program);
+		normalize_line(shared_buffer);
+		if (find_or_assign_new_domain(shared_buffer, 1, 0) == EOF)
+			out_of_memory();
 		put();
 	}
 }
 
-static int domainname_attribute_compare(const void *a, const void *b) {
-	const int k = strcmp(((struct domain_info *) a)->domainname->name, ((struct domain_info *) b)->domainname->name);
-	if (k > 0 || (k == 0 && ((struct domain_info *) a)->is_domain_initializer_source < ((struct domain_info *) b)->is_domain_initializer_source)) return 1;
+static int domainname_attribute_compare(const void *a, const void *b)
+{
+	const struct domain_info *a0 = a;
+	const struct domain_info *b0 = b;
+	const int k = strcmp(a0->domainname->name, b0->domainname->name);
+	if ((k > 0) || (!k && a0->is_dis < b0->is_dis))
+		return 1;
 	return k;
 }
 
 static int unnumbered_domain_count = 0;
 
-static void ReadDomainAndExceptionPolicy(void) {
+static void read_domain_and_exception_policy(void)
+{
 	FILE *fp;
-	int i, j;
-	ClearDomainPolicy();
+	int i;
+	int j;
+	int index;
+	int max_index;
+	clear_domain_policy();
 	domain_keeper_list_len = 0;
 	domain_initializer_list_len = 0;
-	while (path_group_list_len) free(path_group_list[--path_group_list_len].member_name);
-	//while (address_group_list_len) free(address_group_list[--address_group_list_len].member_name);
+	while (path_group_list_len)
+		free(path_group_list[--path_group_list_len].member_name);
+	/*
+	while (address_group_list_len)
+		free(address_group_list[--address_group_list_len].member_name);
+	*/
 	address_group_list_len = 0;
-	FindOrAssignNewDomain(ROOT_NAME, 0, 0);
+	find_or_assign_new_domain(ROOT_NAME, 0, 0);
 
-	// Load domain_initializer list, domain_keeper list.
-	if ((fp = open_read(EXCEPTION_POLICY_FILE)) != NULL) {
-		get();
-		while (freadline(fp)) {
-			if (strncmp(shared_buffer, KEYWORD_INITIALIZE_DOMAIN, KEYWORD_INITIALIZE_DOMAIN_LEN) == 0) {
-				AddDomainInitializerPolicy(shared_buffer + KEYWORD_INITIALIZE_DOMAIN_LEN, 0);
-			} else if (strncmp(shared_buffer, KEYWORD_NO_INITIALIZE_DOMAIN, KEYWORD_NO_INITIALIZE_DOMAIN_LEN) == 0) {
-				AddDomainInitializerPolicy(shared_buffer + KEYWORD_NO_INITIALIZE_DOMAIN_LEN, 1);
-			} else if (strncmp(shared_buffer, KEYWORD_KEEP_DOMAIN, KEYWORD_KEEP_DOMAIN_LEN) == 0) {
-				AddDomainKeeperPolicy(shared_buffer + KEYWORD_KEEP_DOMAIN_LEN, 0);
-			} else if (strncmp(shared_buffer, KEYWORD_NO_KEEP_DOMAIN, KEYWORD_NO_KEEP_DOMAIN_LEN) == 0) {
-				AddDomainKeeperPolicy(shared_buffer + KEYWORD_NO_KEEP_DOMAIN_LEN, 1);
-			} else if (strncmp(shared_buffer, KEYWORD_PATH_GROUP, KEYWORD_PATH_GROUP_LEN) == 0) {
-				AddPathGroupPolicy(shared_buffer + KEYWORD_PATH_GROUP_LEN, 0);
-			} else if (strncmp(shared_buffer, KEYWORD_ADDRESS_GROUP, KEYWORD_ADDRESS_GROUP_LEN) == 0) {
-				AddAddressGroupPolicy(shared_buffer + KEYWORD_ADDRESS_GROUP_LEN, 0);
-			}
+	/* Load domain_initializer list, domain_keeper list. */
+	fp = open_read(EXCEPTION_POLICY_FILE);
+	if (!fp)
+		goto no_exception;
+	get();
+	while (freadline(fp)) {
+		if (str_starts(shared_buffer, KEYWORD_INITIALIZE_DOMAIN))
+			add_domain_initializer_policy(shared_buffer, 0);
+		else if (str_starts(shared_buffer,
+				    KEYWORD_NO_INITIALIZE_DOMAIN))
+			add_domain_initializer_policy(shared_buffer, 1);
+		else if (str_starts(shared_buffer, KEYWORD_KEEP_DOMAIN))
+			add_domain_keeper_policy(shared_buffer, 0);
+		else if (str_starts(shared_buffer, KEYWORD_NO_KEEP_DOMAIN))
+			add_domain_keeper_policy(shared_buffer, 1);
+		else if (str_starts(shared_buffer, KEYWORD_PATH_GROUP))
+			add_path_group_policy(shared_buffer, 0);
+		else if (str_starts(shared_buffer, KEYWORD_ADDRESS_GROUP))
+			add_address_group_policy(shared_buffer, 0);
+	}
+	put();
+	fclose(fp);
+ no_exception:
+
+	/* Load all domain list. */
+	fp = open_read(DOMAIN_POLICY_FILE);
+	if (!fp)
+		goto no_domain;
+	index = EOF;
+	get();
+	while (freadline(fp)) {
+		char *cp;
+		char *cp2;
+		unsigned int profile;
+		if (is_domain_def(shared_buffer)) {
+			index = find_or_assign_new_domain(shared_buffer, 0, 0);
+			continue;
+		} else if (index == EOF) {
+			continue;
 		}
-		put();
-		fclose(fp);
+		if (str_starts(shared_buffer, KEYWORD_EXECUTE_HANDLER)) {
+			add_string_entry(shared_buffer, index);
+		} else if (str_starts(shared_buffer,
+				      KEYWORD_DENIED_EXECUTE_HANDLER)) {
+			add_string_entry(shared_buffer, index);
+		} else if (str_starts(shared_buffer, "1 ") ||
+			   str_starts(shared_buffer, "3 ") ||
+			   str_starts(shared_buffer, "5 ") ||
+			   str_starts(shared_buffer, "7 ") ||
+			   str_starts(shared_buffer, KEYWORD_ALLOW_EXECUTE)) {
+			cp = shared_buffer;
+			cp2 = strchr(cp, ' ');
+			if (cp2)
+				*cp2 = '\0';
+			if (*cp == '@' || is_correct_path(cp, 1, 0, -1))
+				add_string_entry(cp, index);
+		} else if (sscanf(shared_buffer,
+				  KEYWORD_USE_PROFILE "%u", &profile) == 1) {
+			domain_list[index].profile = (unsigned char) profile;
+		}
 	}
+	put();
+	fclose(fp);
+no_domain:
 
-	// Load all domain list.
-	if ((fp = open_read(DOMAIN_POLICY_FILE)) != NULL) {
-		int index = EOF;
+	max_index = domain_list_count;
+
+	/* Find unreachable domains. */
+	for (index = 0; index < max_index; index++) {
+		char *cp;
 		get();
-		while (freadline(fp)) {
-			char *cp, *cp2;
-			unsigned int profile;
-			if (IsDomainDef(shared_buffer)) {
-				index = FindOrAssignNewDomain(shared_buffer, 0, 0);
-			} else if (index >= 0 && strncmp(shared_buffer, "execute_handler ", 16) == 0) {
-				AddStringEntry(shared_buffer + 16, index);
-			} else if (index >= 0 && strncmp(shared_buffer, "denied_execute_handler ", 23) == 0) {
-				AddStringEntry(shared_buffer + 23, index);
-			} else if (index >= 0 && ((atoi(shared_buffer) & 1) == 1 || strncmp(shared_buffer, "allow_execute ", 14) == 0) && (cp = strchr(shared_buffer, ' ')) != NULL) {
-				cp++;
-				if ((cp2 = strchr(cp, ' ')) != NULL) *cp2 = '\0';
-				if (*cp == '@' || IsCorrectPath(cp, 1, 0, -1)) AddStringEntry(cp, index);
-			} else if (index >= 0 && sscanf(shared_buffer, "use_profile %u", &profile) == 1) {
-				domain_list[index].profile = (unsigned char) profile;
+		memset(shared_buffer, 0, shared_buffer_len);
+		snprintf(shared_buffer, shared_buffer_len - 1, "%s",
+			 domain_name(index));
+		while ((cp = strrchr(shared_buffer, ' ')) != NULL) {
+			const struct domain_initializer_entry
+				*domain_initializer;
+			const struct domain_keeper_entry *domain_keeper;
+			struct path_info parent;
+			*cp++ = '\0';
+			parent.name = shared_buffer;
+			fill_path_info(&parent);
+			domain_initializer = is_domain_initializer(&parent, cp);
+			if (domain_initializer) {
+				/* Initializer under <kernel> is reachable. */
+				if (parent.total_len == ROOT_NAME_LEN)
+					break;
+				domain_list[index].domain_initializer
+					= domain_initializer;
+				domain_list[index].domain_keeper = NULL;
+				continue;
 			}
+			domain_keeper = is_domain_keeper(&parent, cp);
+			if (domain_keeper) {
+				domain_list[index].domain_initializer = NULL;
+				domain_list[index].domain_keeper
+					= domain_keeper;
+			}
 		}
 		put();
-		fclose(fp);
+		if (domain_list[index].domain_initializer ||
+		    domain_list[index].domain_keeper)
+			domain_list[index].is_du = 1;
 	}
-	
-	{
-		int index, max_index = domain_list_count;
-		
-		// Find unreachable domains.
-		for (index = 0; index < max_index; index++) {
-			char *cp;
-			get();
-			memset(shared_buffer, 0, shared_buffer_len);
-			snprintf(shared_buffer, shared_buffer_len - 1, "%s", DomainName(index));
-			while ((cp = strrchr(shared_buffer, ' ')) != NULL) {
-				const struct domain_initializer_entry *domain_initializer;
-				const struct domain_keeper_entry *domain_keeper;
-				struct path_info parent;
-				*cp++ = '\0';
-				parent.name = shared_buffer;
-				fill_path_info(&parent);
-				if ((domain_initializer = IsDomainInitializer(&parent, cp)) != NULL) {
-					if (parent.total_len == ROOT_NAME_LEN) break; /* Initializer under <kernel> is reachable. */
-					domain_list[index].domain_initializer = domain_initializer;
-					domain_list[index].domain_keeper = NULL;
-				} else if ((domain_keeper = IsDomainKeeper(&parent, cp)) != NULL) {
-					domain_list[index].domain_initializer = NULL;
-					domain_list[index].domain_keeper = domain_keeper;
-				}
-			}
-			put();
-			if (domain_list[index].domain_initializer || domain_list[index].domain_keeper) domain_list[index].is_domain_unreachable = 1;
+
+	/* Find domain initializer target domains. */
+	for (index = 0; index < max_index; index++) {
+		char *cp = strchr(domain_name(index), ' ');
+		if (!cp || strchr(cp + 1, ' '))
+			continue;
+		for (i = 0; i < domain_initializer_list_len; i++) {
+			struct domain_initializer_entry *ptr
+				= &domain_initializer_list[i];
+			if (ptr->is_not)
+				continue;
+			if (strcmp(ptr->program->name, cp + 1))
+				continue;
+			domain_list[index].is_dit = 1;
 		}
-		
-		// Find domain initializer target domains.
-		for (index = 0; index < max_index; index++) {
+	}
+
+	/* Find domain keeper domains. */
+	for (index = 0; index < max_index; index++) {
+		for (i = 0; i < domain_keeper_list_len; i++) {
+			struct domain_keeper_entry *ptr
+				= &domain_keeper_list[i];
 			char *cp;
-			if ((cp = strchr(DomainName(index), ' ')) != NULL && strchr(cp + 1, ' ') == NULL) {
-				for (i = 0; i < domain_initializer_list_len; i++) {
-					struct domain_initializer_entry *ptr = &domain_initializer_list[i];
-					if (ptr->is_not) continue;
-					if (strcmp(ptr->program->name, cp + 1)) continue;
-					domain_list[index].is_domain_initializer_target = 1;
-				}
+			if (ptr->is_not)
+				continue;
+			if (!ptr->is_last_name) {
+				if (pathcmp(ptr->domainname,
+					    domain_list[index].domainname))
+					continue;
+				domain_list[index].is_dk = 1;
+				continue;
 			}
+			cp = strrchr(domain_list[index].domainname->name, ' ');
+			if (!cp || strcmp(ptr->domainname->name, cp + 1))
+				continue;
+			domain_list[index].is_dk = 1;
 		}
+	}
 
-		// Find domain keeper domains.
-		for (index = 0; index < max_index; index++) {
-			for (i = 0; i < domain_keeper_list_len; i++) {
-				struct domain_keeper_entry *ptr = &domain_keeper_list[i];
-				if (ptr->is_not) continue;
-				if (!ptr->is_last_name) {
-					if (pathcmp(ptr->domainname, domain_list[index].domainname)) continue;
-				} else {
-					char *cp = strrchr(domain_list[index].domainname->name, ' ');
-					if (!cp || strcmp(ptr->domainname->name, cp + 1)) continue;
-				}
-				domain_list[index].is_domain_keeper = 1;
+	/* Create domain initializer source domains. */
+	for (index = 0; index < max_index; index++) {
+		const struct path_info *domainname
+			= domain_list[index].domainname;
+		const struct path_info **string_ptr
+			= domain_list[index].string_ptr;
+		const int max_count = domain_list[index].string_count;
+		/* Don't create source domain under <kernel> because
+		   they will become target domains. */
+		if (domainname->total_len == ROOT_NAME_LEN)
+			continue;
+		for (i = 0; i < max_count; i++) {
+			const struct path_info *cp = string_ptr[i];
+			struct path_group_entry *group;
+			if (cp->name[0] != '@') {
+				assign_domain_initializer_source(domainname,
+								 cp->name);
+				continue;
 			}
-		}
-
-		// Create domain initializer source domains.
-		for (index = 0; index < max_index; index++) {
-			const struct path_info *domainname = domain_list[index].domainname;
-			const struct path_info **string_ptr = domain_list[index].string_ptr;
-			const int max_count = domain_list[index].string_count;
-			if (domainname->total_len == ROOT_NAME_LEN) continue; // Don't create source domain under <kernel> because they will become target domains. 
-			for (i = 0; i < max_count; i++) {
-				const struct path_info *cp = string_ptr[i];
-				if (cp->name[0] == '@') {
-					struct path_group_entry *group = FindPathGroup(cp->name + 1);
-					if (group) {
-						for (j = 0; j < group->member_name_len; j++) AssignDomainInitializerSource(domainname, group->member_name[j]->name);
-					}
-				} else {
-					AssignDomainInitializerSource(domainname, cp->name);
-				}
+			group = find_path_group(cp->name + 1);
+			if (!group)
+				continue;
+			for (j = 0; j < group->member_name_len; j++) {
+				cp = group->member_name[j];
+				assign_domain_initializer_source(domainname,
+								 cp->name);
 			}
 		}
+	}
 
-		// Create missing parent domains.
-		for (index = 0; index < max_index; index++) {
-			char *cp;
-			get();
-			memset(shared_buffer, 0, shared_buffer_len);
-			snprintf(shared_buffer, shared_buffer_len - 1, "%s", DomainName(index));
-			while ((cp = strrchr(shared_buffer, ' ')) != NULL) {
-				*cp = '\0';
-				if (FindDomain(shared_buffer, 0, 0) != EOF) continue;
-				if (FindOrAssignNewDomain(shared_buffer, 0, 1) == EOF) OutOfMemory();
-			}
-			put();
+	/* Create missing parent domains. */
+	for (index = 0; index < max_index; index++) {
+		char *cp;
+		get();
+		memset(shared_buffer, 0, shared_buffer_len);
+		snprintf(shared_buffer, shared_buffer_len - 1, "%s",
+			 domain_name(index));
+		while ((cp = strrchr(shared_buffer, ' ')) != NULL) {
+			*cp = '\0';
+			if (find_domain(shared_buffer, 0, 0) != EOF)
+				continue;
+			if (find_or_assign_new_domain(shared_buffer, 0, 1)
+			    == EOF)
+				out_of_memory();
 		}
-
+		put();
 	}
-	// Sort by domain name.
-	qsort(domain_list, domain_list_count, sizeof(struct domain_info), domainname_attribute_compare);
 
-	// Assign domain numbers.
+	/* Sort by domain name. */
+	qsort(domain_list, domain_list_count, sizeof(struct domain_info),
+	      domainname_attribute_compare);
+
+	/* Assign domain numbers. */
 	{
-		int number = 0, index;
-		unnumbered_domain_count= 0;
+		int number = 0;
+		int index;
+		unnumbered_domain_count = 0;
 		for (index = 0; index < domain_list_count; index++) {
-			if (IsDeletedDomain(index) || IsInitializerSource(index)) {
+			if (is_deleted_domain(index) ||
+			    is_initializer_source(index)) {
 				domain_list[index].number = -1;
 				unnumbered_domain_count++;
 			} else {
@@ -1215,14 +2031,18 @@
 	}
 
 	domain_list_selected = realloc(domain_list_selected, domain_list_count);
-	if (domain_list_count && !domain_list_selected) OutOfMemory();
+	if (domain_list_count && !domain_list_selected)
+		out_of_memory();
 	memset(domain_list_selected, 0, domain_list_count);
 }
 
-static void ShowCurrent(void);
+static void show_current(void);
 
-static int window_width = 0, window_height = 0;
-static int current_y[MAXSCREEN], current_item_index[MAXSCREEN], list_item_count[MAXSCREEN];
+static int window_width = 0;
+static int window_height = 0;
+static int current_y[MAXSCREEN];
+static int current_item_index[MAXSCREEN];
+static int list_item_count[MAXSCREEN];
 
 static const int header_lines = 3;
 static int body_lines = 0;
@@ -1230,516 +2050,729 @@
 static int max_eat_col[MAXSCREEN];
 static int eat_col = 0;
 static int max_col = 0;
+static int list_indent = 0;
 
-static const char *eat(const char *str) {
+static const char *eat(const char *str)
+{
 	while (*str && eat_col) {
-		str++; eat_col--;
+		str++;
+		eat_col--;
 	}
 	return str;
 }
- 
-static void ShowList(void) {
+
+static int show_domain_line(int i, int index)
+{
+	int tmp_col = 0;
+	const struct domain_initializer_entry *domain_initializer;
+	const struct domain_keeper_entry *domain_keeper;
+	const char *sp;
+	const char *cp;
+	const int number = domain_list[index].number;
+	int redirect_index;
+	if (number >= 0)
+		mvprintw(header_lines + i, 0,
+			 "%c%4d:%3u %c%c%c ",
+			 domain_list_selected[index] ? '&' : ' ',
+			 number, domain_list[index].profile,
+			 is_keeper_domain(index) ? '#' : ' ',
+			 is_initializer_target(index) ? '*' : ' ',
+			 is_domain_unreachable(index) ? '!' : ' ');
+	else
+		mvprintw(header_lines + i, 0, "              ");
+	tmp_col += 14;
+	sp = domain_name(index);
+	while ((cp = strchr(sp, ' ')) != NULL) {
+		printw("%s", eat("    "));
+		tmp_col += 4;
+		sp = cp + 1;
+	}
+	if (is_deleted_domain(index)) {
+		printw("%s", eat("( "));
+		tmp_col += 2;
+	}
+	printw("%s", eat(sp));
+	tmp_col += strlen(sp);
+	if (is_deleted_domain(index)) {
+		printw("%s", eat(" )"));
+		tmp_col += 2;
+	}
+	domain_initializer = domain_list[index].domain_initializer;
+	if (!domain_initializer)
+		goto not_domain_initializer;
+	get();
+	memset(shared_buffer, 0, shared_buffer_len);
+	if (domain_initializer->domainname)
+		snprintf(shared_buffer, shared_buffer_len - 1,
+			 " ( " KEYWORD_INITIALIZE_DOMAIN "%s from %s )",
+			 domain_initializer->program->name,
+			 domain_initializer->domainname->name);
+	else
+		snprintf(shared_buffer, shared_buffer_len - 1,
+			 " ( " KEYWORD_INITIALIZE_DOMAIN "%s )",
+			 domain_initializer->program->name);
+	printw("%s", eat(shared_buffer));
+	tmp_col += strlen(shared_buffer);
+	put();
+	goto done;
+not_domain_initializer:
+	domain_keeper = domain_list[index].domain_keeper;
+	if (!domain_keeper)
+		goto not_domain_keeper;
+	get();
+	memset(shared_buffer, 0, shared_buffer_len);
+	if (domain_keeper->program)
+		snprintf(shared_buffer, shared_buffer_len - 1,
+			 " ( " KEYWORD_KEEP_DOMAIN "%s from %s )",
+			 domain_keeper->program->name,
+			 domain_keeper->domainname->name);
+	else
+		snprintf(shared_buffer, shared_buffer_len - 1,
+			 " ( " KEYWORD_KEEP_DOMAIN "%s )",
+			 domain_keeper->domainname->name);
+	printw("%s", eat(shared_buffer));
+	tmp_col += strlen(shared_buffer);
+	put();
+	goto done;
+not_domain_keeper:
+	if (!is_initializer_source(index))
+		goto done;
+	get();
+	memset(shared_buffer, 0, shared_buffer_len);
+	snprintf(shared_buffer, shared_buffer_len - 1, ROOT_NAME "%s",
+		 strrchr(domain_name(index), ' '));
+	redirect_index = find_domain(shared_buffer, 0, 0);
+	if (redirect_index >= 0)
+		snprintf(shared_buffer, shared_buffer_len - 1, " ( -> %d )",
+			 domain_list[redirect_index].number);
+	else
+		snprintf(shared_buffer, shared_buffer_len - 1,
+			 " ( -> Not Found )");
+	printw("%s", eat(shared_buffer));
+	tmp_col += strlen(shared_buffer);
+	put();
+done:
+	return tmp_col;
+}
+
+static int show_acl_line(int i, int index, int list_indent)
+{
+	u8 directive = generic_acl_list[index].directive;
+	const char *cp1 = directives[directive].alias;
+	const char *cp2 = generic_acl_list[index].operand;
+	int len = list_indent - directives[directive].alias_len;
+	mvprintw(header_lines + i, 0, "%c%4d: %s ",
+		 generic_acl_list[index].selected ? '&' : ' ',
+		 index, eat(cp1));
+	while (len-- > 0)
+		printw("%s", eat(" "));
+	printw("%s", eat(cp2));
+	return strlen(cp1) + strlen(cp2) + 8 + list_indent;
+}
+
+static void show_list(void)
+{
 	const int offset = current_item_index[current_screen];
-	int i, tmp_col;
-	if (current_screen == SCREEN_DOMAIN_LIST) list_item_count[SCREEN_DOMAIN_LIST] = domain_list_count;
-	else list_item_count[current_screen] = generic_acl_list_count;
+	int i;
+	int tmp_col;
+	if (current_screen == SCREEN_DOMAIN_LIST)
+		list_item_count[SCREEN_DOMAIN_LIST] = domain_list_count;
+	else
+		list_item_count[current_screen] = generic_acl_list_count;
 	clear();
 	if (window_height < header_lines + 1) {
-		mvprintw(0, 0, "Please resize window. This program needs at least %d lines.\n", header_lines + 1);
+		mvprintw(0, 0, "Please resize window. "
+			 "This program needs at least %d lines.\n",
+			 header_lines + 1);
 		refresh();
 		return;
 	}
-	colorChange(colorHead(), ON);  // add color
-	if (current_screen == SCREEN_DOMAIN_LIST) mvprintw(0, 0, "<<< Domain Transition Editor >>>      %d domain%c    '?' for help", list_item_count[SCREEN_DOMAIN_LIST] - unnumbered_domain_count, list_item_count[SCREEN_DOMAIN_LIST] - unnumbered_domain_count > 1 ? 's' : ' ');
-	else mvprintw(0, 0, "<<< %s Editor >>>      %d entr%s    '?' for help", list_caption, list_item_count[current_screen], list_item_count[current_screen] > 1 ? "ies" : "y");
-	colorChange(colorHead(), OFF);  // add color
+	/* add color */
+	editpolicy_color_change(editpolicy_color_head(current_screen), ON);
+	if (current_screen == SCREEN_DOMAIN_LIST) {
+		i = list_item_count[SCREEN_DOMAIN_LIST]
+			- unnumbered_domain_count;
+		mvprintw(0, 0, "<<< Domain Transition Editor >>>"
+			 "      %d domain%c    '?' for help",
+			 i, i > 1 ? 's' : ' ');
+	} else {
+		i = list_item_count[current_screen];
+		mvprintw(0, 0, "<<< %s Editor >>>"
+			 "      %d entr%s    '?' for help", list_caption,
+			 i, i > 1 ? "ies" : "y");
+	}
+	/* add color */
+	editpolicy_color_change(editpolicy_color_head(current_screen), OFF);
 	eat_col = max_eat_col[current_screen];
 	max_col = 0;
 	if (current_screen == SCREEN_ACL_LIST) {
 		get();
 		memset(shared_buffer, 0, shared_buffer_len);
-		snprintf(shared_buffer, shared_buffer_len - 1, "%s", eat(current_domain));
-		attrChange(A_REVERSE, ON);  // add color --- 2007/11/27 changed
+		snprintf(shared_buffer, shared_buffer_len - 1, "%s",
+			 eat(current_domain));
+		editpolicy_attr_change(A_REVERSE, ON); /* add color */
 		mvprintw(2, 0, "%s", shared_buffer);
-		attrChange(A_REVERSE, OFF); // add color --- 2007/11/27 changed
+		editpolicy_attr_change(A_REVERSE, OFF); /* add color */
 		put();
 	}
+	if (current_screen != SCREEN_DOMAIN_LIST) {
+		list_indent = 0;
+		for (i = 0; i < list_item_count[current_screen]; i++) {
+			const u8 directive = generic_acl_list[i].directive;
+			const int len = directives[directive].alias_len;
+			if (len > list_indent)
+				list_indent = len;
+		}
+	}
 	for (i = 0; i < body_lines; i++) {
 		const int index = offset + i;
 		eat_col = max_eat_col[current_screen];
-		tmp_col = 0;
-		if (index >= list_item_count[current_screen]) break;
-		if (current_screen == SCREEN_DOMAIN_LIST) {
-			const struct domain_initializer_entry *domain_initializer;
-			const struct domain_keeper_entry *domain_keeper;
-			const char *sp, *cp;
-			const int number = domain_list[index].number;
-			if (number >= 0) mvprintw(header_lines + i, 0, "%c%4d:%3u %c%c%c ", domain_list_selected[index] ? '&' : ' ', number, domain_list[index].profile, IsKeeperDomain(index) ? '#' : ' ', IsInitializerTarget(index) ? '*' : ' ', IsDomainUnreachable(index) ? '!' : ' ');
-			else mvprintw(header_lines + i, 0, "              ");
-			tmp_col += 14;
-			sp = DomainName(index);
-			while ((cp = strchr(sp, ' ')) != NULL) { printw("%s", eat("    ")); tmp_col += 4; sp = cp + 1; }
-			if (IsDeletedDomain(index)) { printw("%s", eat("( ")); tmp_col += 2; }
-			printw("%s", eat(sp)); tmp_col += strlen(sp);
-			if (IsDeletedDomain(index)) { printw("%s", eat(" )")); tmp_col += 2; }
-			if ((domain_initializer = domain_list[index].domain_initializer) != NULL) {
-				get();
-				memset(shared_buffer, 0, shared_buffer_len);
-				if (domain_initializer->domainname) snprintf(shared_buffer, shared_buffer_len - 1, " ( " KEYWORD_INITIALIZE_DOMAIN "%s from %s )", domain_initializer->program->name, domain_initializer->domainname->name);
-				else snprintf(shared_buffer, shared_buffer_len - 1, " ( " KEYWORD_INITIALIZE_DOMAIN "%s )", domain_initializer->program->name);
-				printw("%s", eat(shared_buffer)); tmp_col += strlen(shared_buffer);
-				put();
-			} else if ((domain_keeper = domain_list[index].domain_keeper) != NULL) {
-				get();
-				memset(shared_buffer, 0, shared_buffer_len);
-				if (domain_keeper->program) snprintf(shared_buffer, shared_buffer_len - 1, " ( " KEYWORD_KEEP_DOMAIN "%s from %s )", domain_keeper->program->name, domain_keeper->domainname->name);
-				else snprintf(shared_buffer, shared_buffer_len - 1, " ( " KEYWORD_KEEP_DOMAIN "%s )", domain_keeper->domainname->name);
-				printw("%s", eat(shared_buffer)); tmp_col += strlen(shared_buffer);
-				put();
-			} else if (IsInitializerSource(index)) {
-				int redirect_index;
-				get();
-				memset(shared_buffer, 0, shared_buffer_len);
-				snprintf(shared_buffer, shared_buffer_len - 1, ROOT_NAME "%s", strrchr(DomainName(index), ' '));
-				redirect_index = FindDomain(shared_buffer, 0, 0);
-				if (redirect_index >= 0) snprintf(shared_buffer, shared_buffer_len - 1, " ( -> %d )", domain_list[redirect_index].number);
-				else snprintf(shared_buffer, shared_buffer_len - 1, " ( -> Not Found )");
-				printw("%s", eat(shared_buffer)); tmp_col += strlen(shared_buffer);
-				put();
-			}
-		} else {
-			const char *cp = generic_acl_list[index];
-			mvprintw(header_lines + i, 0, "%c%4d: %s", generic_acl_list_selected[index] ? '&' : ' ', index, eat(cp)); tmp_col += strlen(cp) + 7;
-		}
+		if (index >= list_item_count[current_screen])
+			break;
+		if (current_screen == SCREEN_DOMAIN_LIST)
+			tmp_col = show_domain_line(i, index);
+		else
+			tmp_col = show_acl_line(i, index, list_indent);
 		clrtoeol();
 		tmp_col -= window_width;
-		if (tmp_col  > max_col) max_col = tmp_col;
+		if (tmp_col > max_col)
+			max_col = tmp_col;
 	}
-	ShowCurrent();
+	show_current();
 }
 
-static void ResizeWindow(void) {
+static void resize_window(void)
+{
 	getmaxyx(stdscr, window_height, window_width);
 	body_lines = window_height - header_lines;
-	if (body_lines <= current_y[current_screen]) current_y[current_screen] = body_lines - 1;
-	if (current_y[current_screen] < 0) current_y[current_screen] = 0;
+	if (body_lines <= current_y[current_screen])
+		current_y[current_screen] = body_lines - 1;
+	if (current_y[current_screen] < 0)
+		current_y[current_screen] = 0;
 }
 
-static void UpArrowKey(void) {
+static void up_arrow_key(void)
+{
 	if (current_y[current_screen] > 0) {
 		current_y[current_screen]--;
-		ShowCurrent();
+		show_current();
 	} else if (current_item_index[current_screen] > 0) {
 		current_item_index[current_screen]--;
-		ShowList();
+		show_list();
 	}
 }
 
-static void DownArrowKey(void) {
+static void down_arrow_key(void)
+{
 	if (current_y[current_screen] < body_lines - 1) {
-		if (current_item_index[current_screen] + current_y[current_screen] < list_item_count[current_screen] - 1) {
+		if (current_item_index[current_screen]
+		    + current_y[current_screen]
+		    < list_item_count[current_screen] - 1) {
 			current_y[current_screen]++;
-			ShowCurrent();
+			show_current();
 		}
-	} else if (current_item_index[current_screen] + current_y[current_screen] < list_item_count[current_screen] - 1) {
+	} else if (current_item_index[current_screen]
+		   + current_y[current_screen]
+		   < list_item_count[current_screen] - 1) {
 		current_item_index[current_screen]++;
-		ShowList();
+		show_list();
 	}
 }
 
-static void PageUpKey(void) {
-	if (current_item_index[current_screen] + current_y[current_screen] > body_lines) {
+static void page_up_key(void)
+{
+	if (current_item_index[current_screen] + current_y[current_screen]
+	    > body_lines) {
 		current_item_index[current_screen] -= body_lines;
-		if (current_item_index[current_screen] < 0) current_item_index[current_screen] = 0;
-		ShowList();
-	} else if (current_item_index[current_screen] + current_y[current_screen] > 0) {
+		if (current_item_index[current_screen] < 0)
+			current_item_index[current_screen] = 0;
+		show_list();
+	} else if (current_item_index[current_screen]
+		   + current_y[current_screen] > 0) {
 		current_item_index[current_screen] = 0;
 		current_y[current_screen] = 0;
-		ShowList();
+		show_list();
 	}
 }
 
-static void PageDownKey(void) {
-	if (list_item_count[current_screen] - current_item_index[current_screen] > body_lines) {
+static void page_down_key(void)
+{
+	if (list_item_count[current_screen] - current_item_index[current_screen]
+	    > body_lines) {
 		current_item_index[current_screen] += body_lines;
-		if (current_item_index[current_screen] + current_y[current_screen] > list_item_count[current_screen] - 1) current_y[current_screen] = list_item_count[current_screen] - 1 - current_item_index[current_screen];
-		ShowList();
-	} else if (current_item_index[current_screen] + current_y[current_screen] < list_item_count[current_screen] - 1) {
-		current_y[current_screen] = list_item_count[current_screen] - current_item_index[current_screen] - 1;
-		ShowCurrent();
+		if (current_item_index[current_screen]
+		    + current_y[current_screen]
+		    > list_item_count[current_screen] - 1)
+			current_y[current_screen]
+				= list_item_count[current_screen] - 1
+				- current_item_index[current_screen];
+		show_list();
+	} else if (current_item_index[current_screen]
+		   + current_y[current_screen]
+		   < list_item_count[current_screen] - 1) {
+		current_y[current_screen]
+			= list_item_count[current_screen]
+			- current_item_index[current_screen] - 1;
+		show_current();
 	}
 }
 
-static int GetCurrent(void) {
-	if (list_item_count[current_screen] == 0) return EOF;
-	if (current_item_index[current_screen] + current_y[current_screen] < 0 || current_item_index[current_screen] + current_y[current_screen] >= list_item_count[current_screen]) {
-		fprintf(stderr, "ERROR: current_item_index=%d current_y=%d\n", current_item_index[current_screen], current_y[current_screen]);
+static int get_current(void)
+{
+	if (list_item_count[current_screen] == 0)
+		return EOF;
+	if (current_item_index[current_screen] + current_y[current_screen] < 0
+	    || current_item_index[current_screen] + current_y[current_screen]
+	    >= list_item_count[current_screen]) {
+		fprintf(stderr, "ERROR: current_item_index=%d current_y=%d\n",
+			current_item_index[current_screen],
+			current_y[current_screen]);
 		exit(127);
 	}
 	return current_item_index[current_screen] + current_y[current_screen];
 }
 
-/// add color start
+/* add color start */
 #ifdef COLOR_ON
-static int before_current[MAXSCREEN] = {-1, -1, -1, -1};
-static int before_y[MAXSCREEN] = {-1, -1, -1, -1};
+static int before_current[MAXSCREEN] = { -1, -1, -1, -1 };
+static int before_y[MAXSCREEN]       = { -1, -1, -1, -1 };
 
-static void LineDraw(void) {
-	int current = GetCurrent();
+static void editpolicy_line_draw(void)
+{
+	int current = get_current();
 	int y, x;
 
-	if (current == EOF) return;
+	if (current == EOF)
+		return;
 
 	getyx(stdscr, y, x);
-	if (-1 < before_current[current_screen] && current != before_current[current_screen]){
+	if (-1 < before_current[current_screen] &&
+	    current != before_current[current_screen]){
 		move(header_lines + before_y[current_screen], 0);
 		chgat(-1, A_NORMAL, NORMAL, NULL);
 	}
 
 	move(y, x);
-	chgat(-1, A_NORMAL, colorCursor(), NULL);
+	chgat(-1, A_NORMAL, editpolicy_color_cursor(current_screen), NULL);
 	touchwin(stdscr);
 
 	before_current[current_screen] = current;
 	before_y[current_screen] = current_y[current_screen];
 }
 #else
-#define LineDraw()
+#define editpolicy_line_draw()
 #endif
-/// add color end
+/* add color end */
 
-static void ShowCurrent(void) {
+static void show_current(void)
+{
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		get();
 		memset(shared_buffer, 0, shared_buffer_len);
 		eat_col = max_eat_col[current_screen];
-		snprintf(shared_buffer, shared_buffer_len - 1, "%s", eat(DomainName(GetCurrent())));
-		if (window_width < shared_buffer_len) shared_buffer[window_width] = '\0';
+		snprintf(shared_buffer, shared_buffer_len - 1, "%s",
+			 eat(domain_name(get_current())));
+		if (window_width < shared_buffer_len)
+			shared_buffer[window_width] = '\0';
 		move(2, 0);
 		clrtoeol();
-		attrChange(A_REVERSE, ON);  // add color
+		editpolicy_attr_change(A_REVERSE, ON); /* add color */
 		printw("%s", shared_buffer);
-		attrChange(A_REVERSE, OFF);  // add color
+		editpolicy_attr_change(A_REVERSE, OFF); /* add color */
 		put();
 	}
 	move(header_lines + current_y[current_screen], 0);
-	LineDraw();     // add color
+	editpolicy_line_draw();     /* add color */
 	refresh();
 }
 
-static void AdjustCursorPos(const int item_count) {
+static void adjust_cursor_pos(const int item_count)
+{
 	if (item_count == 0) {
-		current_item_index[current_screen] = current_y[current_screen] = 0;
+		current_item_index[current_screen] = 0;
+		current_y[current_screen] = 0;
 	} else {
-		while (current_item_index[current_screen] + current_y[current_screen] >= item_count) {
-			if (current_y[current_screen] > 0) current_y[current_screen]--;
-			else if (current_item_index[current_screen] > 0) current_item_index[current_screen]--;
+		while (current_item_index[current_screen]
+		       + current_y[current_screen] >= item_count) {
+			if (current_y[current_screen] > 0)
+				current_y[current_screen]--;
+			else if (current_item_index[current_screen] > 0)
+				current_item_index[current_screen]--;
 		}
 	}
 }
 
-static void SetCursorPos(const int index) {
-	while (index < current_y[current_screen] + current_item_index[current_screen]) {
-		if (current_y[current_screen] > 0) current_y[current_screen]--;
-		else current_item_index[current_screen]--;
+static void set_cursor_pos(const int index)
+{
+	while (index < current_y[current_screen]
+	       + current_item_index[current_screen]) {
+		if (current_y[current_screen] > 0)
+			current_y[current_screen]--;
+		else
+			current_item_index[current_screen]--;
 	}
-	while (index > current_y[current_screen] + current_item_index[current_screen]) {
-		if (current_y[current_screen] < body_lines - 1) current_y[current_screen]++;
-		else current_item_index[current_screen]++;
+	while (index > current_y[current_screen]
+	       + current_item_index[current_screen]) {
+		if (current_y[current_screen] < body_lines - 1)
+			current_y[current_screen]++;
+		else
+			current_item_index[current_screen]++;
 	}
 }
 
-static int count(const unsigned char *array, const int len) {
-	int i, c = 0;
-	for (i = 0; i < len; i++) if (array[i]) c++;
+static int count(const unsigned char *array, const int len)
+{
+	int i;
+	int c = 0;
+	for (i = 0; i < len; i++)
+		if (array[i])
+			c++;
 	return c;
 }
 
-static int SelectItem(const int current) {
+static int count2(const struct generic_acl *array, int len)
+{
+	int i;
+	int c = 0;
+	for (i = 0; i < len; i++)
+		if (array[i].selected)
+			c++;
+	return c;
+}
+
+static int select_item(const int current)
+{
 	if (current >= 0) {
-		int x, y;
+		int x;
+		int y;
 		if (current_screen == SCREEN_DOMAIN_LIST) {
-			if (IsDeletedDomain(current) || IsInitializerSource(current)) return 0;
+			if (is_deleted_domain(current) ||
+			    is_initializer_source(current))
+				return 0;
 			domain_list_selected[current] ^= 1;
 		} else {
-			generic_acl_list_selected[current] ^= 1;
+			generic_acl_list[current].selected ^= 1;
 		}
 		getyx(stdscr, y, x);
-		sttrSave();		// add color
-		ShowList();
-		sttrRestore();	// add color
+		editpolicy_sttr_save();    /* add color */
+		show_list();
+		editpolicy_sttr_restore(); /* add color */
 		move(y, x);
 		return 1;
 	}
 	return 0;
 }
 
-static int PathMatchesToPattern(const struct path_info *pathname0, const struct path_info *pattern0) {
-	//if (!pathname || !pattern) return 0;
-	const char *pathname = pathname0->name, *pattern = pattern0->name;
-	const int len = pattern0->const_len;
-	if (!pattern0->is_patterned) return !pathcmp(pathname0, pattern0);
-	if (pathname0->depth != pattern0->depth) return 0;
-	if (strncmp(pathname, pattern, len)) return 0;
-	pathname += len; pattern += len;
-	while (*pathname && *pattern) {
-		const char *pathname_delimiter = strchr(pathname, '/'), *pattern_delimiter = strchr(pattern, '/');
-		if (!pathname_delimiter) pathname_delimiter = strchr(pathname, '\0');
-		if (!pattern_delimiter) pattern_delimiter = strchr(pattern, '\0');
-		if (!FileMatchesToPattern(pathname, pathname_delimiter, pattern, pattern_delimiter)) return 0;
-		pathname = *pathname_delimiter ? pathname_delimiter + 1 : pathname_delimiter;
-		pattern = *pattern_delimiter ? pattern_delimiter + 1 : pattern_delimiter;
-	}
-	while (*pattern == '\\' && (*(pattern + 1) == '*' || *(pattern + 1) == '@')) pattern += 2;
-	return (!*pathname && !*pattern);
-}
-
-static void split_acl(char *data, struct path_info *arg1, struct path_info *arg2, struct path_info *arg3) {
-	/* data = word[0] word[1] ... word[n-1] word[n] if cond[0] cond[1] ... cond[m] ; set ... */
-	/*                                                 */
-	/* arg1 = word[0]                                  */
-	/* arg2 = word[1] ... word[n-1] word[n]            */
-	/* arg3 = if cond[0] cond[1] ... cond[m] ; set ... */
+static void split_acl(char *data, struct path_info *arg1,
+		      struct path_info *arg2, struct path_info *arg3)
+{
+	/* data = w[0] w[1] ... w[n-1] w[n] if c[0] c[1] ... c[m] ; set ... */
+	/*                                                                  */
+	/* arg1 = w[0]                                                      */
+	/* arg2 = w[1] ... w[n-1] w[n]                                      */
+	/* arg3 = if c[0] c[1] ... c[m] ; set ...                           */
 	char *cp;
 	arg1->name = data;
 	cp = strstr(data, " if ");
 	if (cp) {
 		char *cp2;
-		while ((cp2 = strstr(cp + 3, " if ")) != NULL) cp = cp2;
+		while ((cp2 = strstr(cp + 3, " if ")) != NULL)
+			cp = cp2;
 		*cp++ = '\0';
-	} else if ((cp = strstr(data, " ; set ")) != NULL) {
+		goto ok;
+	}
+	cp = strstr(data, " ; set ");
+	if (cp)
 		*cp++ = '\0';
-	} else {
+	else
 		cp = "";
-	}
+ok:
 	arg3->name = cp;
 	cp = strchr(data, ' ');
-	if (cp) *cp++ = '\0';
-	else cp = "";
+	if (cp)
+		*cp++ = '\0';
+	else
+		cp = "";
 	arg2->name = cp;
 	fill_path_info(arg1);
 	fill_path_info(arg2);
 	fill_path_info(arg3);
 }
 
-#define max_optimize_directive_index 35
-static const char *directive_list[max_optimize_directive_index] = {
-	[0]  = "1 ",
-	[1]  = "2 ",
-	[2]  = "3 ",
-	[3]  = "4 ",
-	[4]  = "5 ",
-	[5]  = "6 ",
-	[6]  = "7 ",
-	[7]  = "allow_execute ",
-	[8]  = "allow_read ",
-	[9]  = "allow_write ",
-	[10] = "allow_read/write ",
-	[11] = "allow_create ",
-	[12] = "allow_unlink ",
-	[13] = "allow_mkdir ",
-	[14] = "allow_rmdir ",
-	[15] = "allow_mkfifo ",
-	[16] = "allow_mksock ",
-	[17] = "allow_mkblock ",
-	[18] = "allow_mkchar ",
-	[19] = "allow_truncate ",
-	[20] = "allow_symlink ",
-	[21] = "allow_link ",
-	[22] = "allow_rename ",
-	[23] = "allow_rewrite ",
-	[24] = "allow_argv0 ",
-	[25] = "allow_signal ",
-	[26] = "allow_network UDP bind ",
-	[27] = "allow_network UDP connect ",
-	[28] = "allow_network TCP bind ",
-	[29] = "allow_network TCP listen ",
-	[30] = "allow_network TCP connect ",
-	[31] = "allow_network TCP accept ",
-	[32] = "allow_network RAW bind ",
-	[33] = "allow_network RAW connect ",
-	[34] = "allow_env ",
-};
-static int directive_list_len[max_optimize_directive_index];
 static int sort_type = 1;
 
-static int string_acl_compare(const void *a, const void *b) {
-	const char *a0 = * (char **) a;
-	const char *b0 = * (char **) b;
+static int generic_acl_compare(const void *a, const void *b)
+{
+	const struct generic_acl *a0 = (struct generic_acl *) a;
+	const struct generic_acl *b0 = (struct generic_acl *) b;
+	const char *a1 = directives[a0->directive].alias;
+	const char *b1 = directives[b0->directive].alias;
+	const char *a2 = a0->operand;
+	const char *b2 = b0->operand;
+	if (sort_type == 0) {
+		const int ret = strcmp(a1, b1);
+		if (ret)
+			return ret;
+		return strcmp(a2, b2);
+	} else {
+		const int ret = strcmp(a2, b2);
+		if (ret)
+			return ret;
+		return strcmp(a1, b1);
+	}
+}
+
+static _Bool compare_path(struct path_info *sarg, struct path_info *darg,
+			  u8 directive)
+{
 	int i;
-	if (sort_type == 0) return strcmp(a0, b0);
-	for (i = 0; i < max_optimize_directive_index; i++) {
-		if (strncmp(a0, directive_list[i], directive_list_len[i])) continue;
-		a0 += directive_list_len[i];
-		break;
+	struct path_group_entry *group;
+	u8 may_use_pattern = !darg->is_patterned
+		&& (directive != DIRECTIVE_1)
+		&& (directive != DIRECTIVE_3)
+		&& (directive != DIRECTIVE_5)
+		&& (directive != DIRECTIVE_7)
+		&& (directive != DIRECTIVE_ALLOW_EXECUTE);
+	if (!pathcmp(sarg, darg))
+		return 1;
+	if (darg->name[0] == '@')
+		return 0;
+	if (sarg->name[0] != '@') {
+		/* Pathname component. */
+		return may_use_pattern && path_matches_pattern(darg, sarg);
 	}
-	for (i = 0; i < max_optimize_directive_index; i++) {
-		if (strncmp(b0, directive_list[i], directive_list_len[i])) continue;
-		b0 += directive_list_len[i];
-		break;
+	/* path_group component. */
+	group = find_path_group(sarg->name + 1);
+	if (!group)
+		return 0;
+	for (i = 0; i < group->member_name_len; i++) {
+		const struct path_info *member_name;
+		member_name = group->member_name[i];
+		if (!pathcmp(member_name, darg))
+			return 1;
+		if (may_use_pattern && path_matches_pattern(darg, member_name))
+			return 1;
 	}
-	i = strcmp(a0, b0);
-	if (i == 0) i = strcmp(* (char **) a, * (char **) b);
-	return i;
+	return 0;
 }
 
-static void try_optimize(const int current) {
-	char *cp;
-	const char *directive;
-	int directive_index, directive_len, index;
-	struct path_info sarg1, sarg2, sarg3;
-	struct path_info darg1, darg2, darg3;
-	if (current < 0) return;
-	cp = generic_acl_list[current];
-	for (directive_index = 0; directive_index < max_optimize_directive_index; directive_index++) {
-		if (strncmp(cp, directive_list[directive_index], directive_list_len[directive_index]) == 0) break;
+static _Bool compare_address(struct path_info *sarg, struct path_info *darg)
+{
+	int i;
+	struct ip_address_entry sentry;
+	struct ip_address_entry dentry;
+	struct address_group_entry *group;
+	if (parse_ip(darg->name, &dentry))
+		return 0;
+	if (sarg->name[0] != '@') {
+		/* IP address component. */
+		if (parse_ip(sarg->name, &sentry))
+			return 0;
+		if (sentry.is_ipv6 != dentry.is_ipv6 ||
+		    memcmp(dentry.min, sentry.min, 16) < 0 ||
+		    memcmp(sentry.max, dentry.max, 16) < 0)
+			return 0;
 	}
-	if (directive_index == max_optimize_directive_index) return;
-	cp = strdup(cp);
-	if (!cp) return;
-	
-	directive = directive_list[directive_index];
-	directive_len = directive_list_len[directive_index];
+	/* IP address group component. */
+	group = find_address_group(sarg->name + 1);
+	if (!group)
+		return 0;
+	for (i = 0; i < group->member_name_len; i++) {
+		struct ip_address_entry *sentry = &group->member_name[i];
+		if (sentry->is_ipv6 == dentry.is_ipv6
+		    && memcmp(sentry->min, dentry.min, 16) <= 0
+		    && memcmp(dentry.max, sentry->max, 16) <= 0)
+			return 1;
+	}
+	return 0;
+}
 
-	split_acl(cp + directive_len, &sarg1, &sarg2, &sarg3);
-	
+static void try_optimize(const int current)
+{
+	char *cp;
+	u8 s_index;
+	int index;
+	struct path_info sarg1;
+	struct path_info sarg2;
+	struct path_info sarg3;
+	struct path_info darg1;
+	struct path_info darg2;
+	struct path_info darg3;
+	if (current < 0)
+		return;
+	s_index = generic_acl_list[current].directive;
+	if (s_index == (u8) EOF)
+		return;
+	cp = strdup(generic_acl_list[current].operand);
+	if (!cp)
+		return;
+
+	split_acl(cp, &sarg1, &sarg2, &sarg3);
+
 	get();
 	for (index = 0; index < list_item_count[current_screen]; index++) {
-		const char *cp = generic_acl_list[index];
-		int d_len;
-		if (index == current) continue;
-		if (generic_acl_list_selected[index]) continue;
-		if (directive_index == 5 || directive_index == 10) {
+		const u8 d_index = generic_acl_list[index].directive;
+		if (index == current)
+			continue;
+		if (generic_acl_list[index].selected)
+			continue;
+		if (s_index == DIRECTIVE_6 ||
+		    s_index == DIRECTIVE_ALLOW_READ_WRITE) {
 			/* Source starts with "6 " or "allow_read/write " */
-			if (!strncmp(cp, directive_list[5], directive_list_len[5])) {
-				d_len = directive_list_len[5]; /* Dest starts with "6 " */
-			} else if (!strncmp(cp, directive_list[10], directive_list_len[10])) {
-				d_len = directive_list_len[10]; /* Dest starts with "allow_read/write " */
-			} else if (!strncmp(cp, directive_list[1], directive_list_len[1])) {
-				d_len = directive_list_len[1]; /* Dest starts with "2 " */
-			} else if (!strncmp(cp, directive_list[3], directive_list_len[3])) {
-				d_len = directive_list_len[3]; /* Dest starts with "4 " */
-			} else if (!strncmp(cp, directive_list[8], directive_list_len[8])) {
-				d_len = directive_list_len[8]; /* Dest starts with "allow_read " */
-			} else if (!strncmp(cp, directive_list[9], directive_list_len[9])) {
-				d_len = directive_list_len[9]; /* Dest starts with "allow_write " */
+			if (d_index == DIRECTIVE_6) {
+				/* Dest starts with "6 " */
+			} else if (d_index == DIRECTIVE_ALLOW_READ_WRITE) {
+				/* Dest starts with "allow_read/write " */
+			} else if (d_index == DIRECTIVE_2) {
+				/* Dest starts with "2 " */
+			} else if (d_index == DIRECTIVE_4) {
+				/* Dest starts with "4 " */
+			} else if (d_index == DIRECTIVE_ALLOW_READ) {
+				/* Dest starts with "allow_read " */
+			} else if (d_index == DIRECTIVE_ALLOW_WRITE) {
+				/* Dest starts with "allow_write " */
 			} else {
-				continue; /* Source and dest start with same directive. */
+				/* Source and dest start with same directive. */
+				continue;
 			}
-		} else if (directive_index == 1 && !strncmp(cp, directive_list[9], directive_list_len[9])) {
-			d_len = directive_list_len[9]; /* Source starts with "2 " and dest starts with "allow_write " */
-		} else if (directive_index == 3 && !strncmp(cp, directive_list[8], directive_list_len[8])) {
-			d_len = directive_list_len[8]; /* Source starts with "4 " and dest starts with "allow_read " */
-		} else if (directive_index == 9 && !strncmp(cp, directive_list[1], directive_list_len[1])) {
-			d_len = directive_list_len[1]; /* Source starts with "allow_write " and dest starts with "2 " */
-		} else if (directive_index == 8 && !strncmp(cp, directive_list[3], directive_list_len[3])) {
-			d_len = directive_list_len[3]; /* Source starts with "allow_read " and dest starts with "4 " */
-		} else if (!strncmp(cp, directive, directive_len)) {
-			d_len = directive_len; /* Source and dest start with same directive. */
+		} else if (s_index == DIRECTIVE_2 &&
+			   d_index == DIRECTIVE_ALLOW_WRITE) {
+			/* Source starts with "2 " and dest starts with
+			   "allow_write " */
+		} else if (s_index == DIRECTIVE_4 &&
+			   d_index == DIRECTIVE_ALLOW_READ) {
+			/* Source starts with "4 " and dest starts with
+			   "allow_read " */
+		} else if (s_index == DIRECTIVE_ALLOW_WRITE &&
+			   d_index == DIRECTIVE_2) {
+			/* Source starts with "allow_write " and dest starts
+			   with "2 " */
+		} else if (s_index == DIRECTIVE_ALLOW_READ &&
+			   d_index == DIRECTIVE_4) {
+			/* Source starts with "allow_read " and dest starts
+			   with "4 " */
+		} else if (s_index == d_index) {
+			/* Source and dest start with same directive. */
 		} else {
-			continue; /* Source and dest start with different directive. */
+			/* Source and dest start with different directive. */
+			continue;
 		}
-		strncpy(shared_buffer, cp, shared_buffer_len);
-		if (!memchr(shared_buffer, '\0', shared_buffer_len)) continue; /* Line too long. */
-		
-		split_acl(shared_buffer + d_len, &darg1, &darg2, &darg3);
-	
+		strncpy(shared_buffer, generic_acl_list[index].operand,
+			shared_buffer_len);
+		if (!memchr(shared_buffer, '\0', shared_buffer_len))
+			continue; /* Line too long. */
+
+		split_acl(shared_buffer, &darg1, &darg2, &darg3);
+
 		/* Compare condition part. */
-		if (pathcmp(&sarg3, &darg3)) continue;
-		
+		if (pathcmp(&sarg3, &darg3))
+			continue;
+
 		/* Compare first word. */
-		if (directive_index < 24) {
-			if (pathcmp(&sarg1, &darg1)) {
-				const int may_use_pattern = !darg1.is_patterned
-					&& (directive_index != 0) && (directive_index != 2) && (directive_index != 4) && (directive_index != 6) && (directive_index != 7);
-				if (darg1.name[0] == '@') continue;
-				if (sarg1.name[0] == '@') {
-					/* path_group component. */
-					int i;
-					struct path_group_entry *group = FindPathGroup(sarg1.name + 1);
-					if (!group) continue;
-					for (i = 0; i < group->member_name_len; i++) {
-						const struct path_info *member_name = group->member_name[i];
-						if (!pathcmp(member_name, &darg1)) break;
-						if (may_use_pattern && PathMatchesToPattern(&darg1, member_name)) break;
-					}
-					if (i == group->member_name_len) continue;
-				} else {
-					/* Pathname component. */
-					if (!may_use_pattern || !PathMatchesToPattern(&darg1, &sarg1)) continue;
-				}
-			}
-		} else if (directive_index == 24) {
+		switch (d_index) {
+		case DIRECTIVE_1:
+		case DIRECTIVE_2:
+		case DIRECTIVE_3:
+		case DIRECTIVE_4:
+		case DIRECTIVE_5:
+		case DIRECTIVE_6:
+		case DIRECTIVE_7:
+		case DIRECTIVE_ALLOW_EXECUTE:
+		case DIRECTIVE_ALLOW_READ:
+		case DIRECTIVE_ALLOW_WRITE:
+		case DIRECTIVE_ALLOW_READ_WRITE:
+		case DIRECTIVE_ALLOW_CREATE:
+		case DIRECTIVE_ALLOW_UNLINK:
+		case DIRECTIVE_ALLOW_MKDIR:
+		case DIRECTIVE_ALLOW_RMDIR:
+		case DIRECTIVE_ALLOW_MKFIFO:
+		case DIRECTIVE_ALLOW_MKSOCK:
+		case DIRECTIVE_ALLOW_MKBLOCK:
+		case DIRECTIVE_ALLOW_MKCHAR:
+		case DIRECTIVE_ALLOW_TRUNCATE:
+		case DIRECTIVE_ALLOW_SYMLINK:
+		case DIRECTIVE_ALLOW_LINK:
+		case DIRECTIVE_ALLOW_RENAME:
+		case DIRECTIVE_ALLOW_REWRITE:
+			if (!compare_path(&sarg1, &darg1, d_index))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_ARGV0:
 			/* Pathname component. */
-			if (pathcmp(&sarg1, &darg1)) {
-				/* allow_argv0 doesn't support path_group. */
-				if (darg1.name[0] == '@' || darg1.is_patterned || !PathMatchesToPattern(&darg1, &sarg1)) continue;
-			}
-		} else if (directive_index == 25) {
+			if (!pathcmp(&sarg1, &darg1))
+				break;
+			/* allow_argv0 doesn't support path_group. */
+			if (darg1.name[0] == '@' || darg1.is_patterned ||
+			    !path_matches_pattern(&darg1, &sarg1))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_SIGNAL:
 			/* Signal number component. */
-			if (strcmp(sarg1.name, darg1.name)) continue;
-		} else if (directive_index < 34) {
-			struct ip_address_entry dentry;
-			if (parse_ip(darg1.name, &dentry)) continue;
-			if (sarg1.name[0] == '@') {
-				/* IP address group component. */
-				int i;
-				struct address_group_entry *group = FindAddressGroup(sarg1.name + 1);
-				if (!group) continue;
-				for (i = 0; i < group->member_name_len; i++) {
-					struct ip_address_entry *sentry = &group->member_name[i];
-					if (sentry->is_ipv6 == dentry.is_ipv6 && memcmp(sentry->min, dentry.min, 16) <= 0 && memcmp(dentry.max, sentry->max, 16) <= 0) break;
-				}
-				if (i == group->member_name_len) continue;
-			} else {
-				/* IP address component. */
-				struct ip_address_entry sentry;
-				if (parse_ip(sarg1.name, &sentry)) continue;
-				if (sentry.is_ipv6 != dentry.is_ipv6 || memcmp(dentry.min, sentry.min, 16) < 0 || memcmp(sentry.max, dentry.max, 16) < 0) continue;
-			}
-		} else {
+			if (strcmp(sarg1.name, darg1.name))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_CONNECT:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_LISTEN:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_CONNECT:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_ACCEPT:
+		case DIRECTIVE_ALLOW_NETWORK_RAW_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_RAW_CONNECT:
+			if (!compare_address(&sarg1, &darg1))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_ENV:
 			/* An environemnt variable name component. */
-			if (pathcmp(&sarg1, &darg1)) {
-				/* allow_env doesn't interpret leading @ as path_group. */
-				if (darg1.is_patterned || !PathMatchesToPattern(&darg1, &sarg1)) continue;
-			}
+			if (!pathcmp(&sarg1, &darg1))
+				break;
+			/* allow_env doesn't interpret leading @ as
+			   path_group. */
+			if (darg1.is_patterned ||
+			    !path_matches_pattern(&darg1, &sarg1))
+				continue;
+			break;
+		default:
+			continue;
 		}
 
 		/* Compare rest words. */
-		if (directive_index == 21 || directive_index == 22) {
-			if (pathcmp(&sarg2, &darg2)) {
-				const int may_use_pattern = !darg2.is_patterned;
-				if (darg2.name[0] == '@') continue;
-				if (sarg2.name[0] == '@') {
-					/* path_group component. */
-					int i;
-					struct path_group_entry *group = FindPathGroup(sarg2.name + 1);
-					if (!group) continue;
-					for (i = 0; i < group->member_name_len; i++) {
-						const struct path_info *member_name = group->member_name[i];
-						if (!pathcmp(member_name, &darg2)) break;
-						if (may_use_pattern && PathMatchesToPattern(&darg2, member_name)) break;
-					}
-					if (i == group->member_name_len) continue;
-				} else {
-					/* Pathname component. */
-					if (!may_use_pattern || !PathMatchesToPattern(&darg2, &sarg2)) continue;
-				}
-			}
-		} else if (directive_index == 24) {
+		switch (d_index) {
+			char c;
+			unsigned int smin;
+			unsigned int smax;
+			unsigned int dmin;
+			unsigned int dmax;
+		case DIRECTIVE_ALLOW_LINK:
+		case DIRECTIVE_ALLOW_RENAME:
+			if (!compare_path(&sarg2, &darg2, d_index))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_ARGV0:
 			/* Basename component. */
-			if (pathcmp(&sarg2, &darg2)) {
-				if (darg2.is_patterned || !PathMatchesToPattern(&darg2, &sarg2)) continue;
-			}
-		} else if (directive_index == 25) {
+			if (!pathcmp(&sarg2, &darg2))
+				break;
+			if (darg2.is_patterned ||
+			    !path_matches_pattern(&darg2, &sarg2))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_SIGNAL:
 			/* Domainname component. */
-			char c;
-			if (strncmp(sarg2.name, darg2.name, sarg2.total_len)) continue;
+			if (strncmp(sarg2.name, darg2.name, sarg2.total_len))
+				continue;
 			c = darg2.name[sarg2.total_len];
-			if (c && c != ' ') continue;
-		} else if (directive_index >= 26 && directive_index < 34) {
+			if (c && c != ' ')
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_CONNECT:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_LISTEN:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_CONNECT:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_ACCEPT:
+		case DIRECTIVE_ALLOW_NETWORK_RAW_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_RAW_CONNECT:
 			/* Port number component. */
-			unsigned int smin, smax, dmin, dmax;
 			switch (sscanf(sarg2.name, "%u-%u", &smin, &smax)) {
 			case 1:
 				smax = smin;
@@ -1756,32 +2789,279 @@
 			default:
 				continue;
 			}
-			if (smin > dmin || smax < dmax) continue;
-		} else {
+			if (smin > dmin || smax < dmax)
+				continue;
+			break;
+		default:
 			/* This must be empty. */
-			if (sarg2.total_len || darg2.total_len) continue;
+			if (sarg2.total_len || darg2.total_len)
+				continue;
 		}
-		generic_acl_list_selected[index] = 1;
+		generic_acl_list[index].selected = 1;
 	}
 	put();
 	free(cp);
-	ShowList();
+	show_list();
 }
 
-static int GenericListLoop(void) {
-	static char *last_error = NULL;
-	static const int max_readline_history = 20;
-	static const char **readline_history = NULL;
-	static int readline_history_count = 0;
-	static char *search_buffer[MAXSCREEN];
+static void delete_entry(int current)
+{
+	int c;
+	move(1, 0);
+	editpolicy_color_change(DISP_ERR, ON);	/* add color */
+	if (current_screen == SCREEN_DOMAIN_LIST) {
+		c = count(domain_list_selected, domain_list_count);
+		if (!c)
+			c = select_item(current);
+		if (!c)
+			printw("Select domain using Space key first.");
+		else
+			printw("Delete selected domain%s? ('Y'es/'N'o)",
+			       c > 1 ? "s" : "");
+	} else {
+		c = count2(generic_acl_list, generic_acl_list_count);
+		if (!c)
+			c = select_item(current);
+		if (!c)
+			printw("Select entry using Space key first.");
+		else
+			printw("Delete selected entr%s? ('Y'es/'N'o)",
+			       c > 1 ? "ies" : "y");
+	}
+	editpolicy_color_change(DISP_ERR, OFF);	/* add color */
+	clrtoeol();
+	refresh();
+	if (!c)
+		return;
+	do {
+		c = getch2();
+	} while (!(c == 'Y' || c == 'y' || c == 'N' || c == 'n' || c == EOF));
+	resize_window();
+	if (c != 'Y' && c != 'y') {
+		show_list();
+		return;
+	}
+	if (current_screen == SCREEN_DOMAIN_LIST) {
+		int index;
+		FILE *fp = open_write(DOMAIN_POLICY_FILE);
+		if (!fp)
+			return;
+		for (index = 1; index < domain_list_count; index++) {
+			if (!domain_list_selected[index])
+				continue;
+			fprintf(fp, "delete %s\n", domain_name(index));
+		}
+		fclose(fp);
+	} else {
+		int index;
+		FILE *fp = open_write(policy_file);
+		if (!fp)
+			return;
+		if (current_screen == SCREEN_ACL_LIST)
+			fprintf(fp, "select %s\n", current_domain);
+		for (index = 0; index < generic_acl_list_count; index++) {
+			u8 directive;
+			if (!generic_acl_list[index].selected)
+				continue;
+			directive = generic_acl_list[index].directive;
+			fprintf(fp, "delete %s %s\n",
+				directives[directive].original,
+				generic_acl_list[index].operand);
+		}
+		fclose(fp);
+	}
+}
+
+struct readline_data {
+	const char **history;
+	int count;
+	int max;
+	char *last_error;
+	char *search_buffer[MAXSCREEN];
+};
+
+static void add_entry(struct readline_data *rl)
+{
+	char *line;
+	editpolicy_attr_change(A_BOLD, ON);  /* add color */
+	line = simple_readline(window_height - 1, 0, "Enter new entry> ",
+			       rl->history, rl->count,
+			       8192, 8);
+	editpolicy_attr_change(A_BOLD, OFF); /* add color */
+	if (!line || !*line)
+		goto out;
+	rl->count = simple_add_history(line, rl->history, rl->count, rl->max);
+	if (current_screen == SCREEN_DOMAIN_LIST && !is_correct_domain(line)) {
+		const int len = strlen(line) + 128;
+		rl->last_error = realloc(rl->last_error, len);
+		if (!rl->last_error)
+			out_of_memory();
+		memset(rl->last_error, 0, len);
+		snprintf(rl->last_error, len - 1,
+			 "%s is an invalid domainname.", line);
+	} else {
+		u8 directive;
+		FILE *fp = open_write(policy_file);
+		if (!fp)
+			goto out;
+		if (current_screen == SCREEN_ACL_LIST)
+			fprintf(fp, "select %s\n", current_domain);
+		directive = find_directive(0, line);
+		if (directive != (u8) EOF)
+			fprintf(fp, "%s ", directives[directive].original);
+		fprintf(fp, "%s\n", line);
+		fclose(fp);
+	}
+ out:
+	free(line);
+}
+
+static void find_entry(int input, int forward, int current,
+		       struct readline_data *rl)
+{
+	int index;
+	char *line;
+	if (current == EOF)
+		return;
+	if (!input)
+		goto start_search;
+	editpolicy_attr_change(A_BOLD, ON);  /* add color */
+	line = simple_readline(window_height - 1, 0, "Search> ",
+			       rl->history, rl->count, 4000, 8);
+	editpolicy_attr_change(A_BOLD, OFF); /* add color */
+	if (!line || !*line)
+		goto out;
+	rl->count = simple_add_history(line, rl->history, rl->count, rl->max);
+	free(rl->search_buffer[current_screen]);
+	rl->search_buffer[current_screen] = line;
+	line = NULL;
+start_search:
+	if (!forward)
+		goto backward_search;
+	if (input)
+		index = 0;
+	else
+		index = current + 1;
+	for (; index < list_item_count[current_screen]; index++) {
+		const char *cp;
+		if (current_screen == SCREEN_DOMAIN_LIST)
+			cp = get_last_name(index);
+		else
+			cp = generic_acl_list[index].operand;
+		if (!strstr(cp, rl->search_buffer[current_screen]))
+			continue;
+		set_cursor_pos(index);
+		break;
+	}
+	goto out;
+ backward_search:
+	for (index = current - 1; index >= 0; index--) {
+		const char *cp;
+		if (current_screen == SCREEN_DOMAIN_LIST)
+			cp = get_last_name(index);
+		else
+			cp = generic_acl_list[index].operand;
+		if (!strstr(cp, rl->search_buffer[current_screen]))
+			continue;
+		set_cursor_pos(index);
+		break;
+	}
+ out:
+	free(line);
+	show_list();
+}
+
+static void set_profile(int current)
+{
+	int index;
+	FILE *fp;
+	char *line;
+	if (current_screen != SCREEN_DOMAIN_LIST)
+		return;
+	if (!count(domain_list_selected, domain_list_count) &&
+	    !select_item(current)) {
+		mvprintw(1, 0, "Select domain using Space key first.");
+		clrtoeol();
+		refresh();
+		return;
+	}
+	editpolicy_attr_change(A_BOLD, ON);  /* add color */
+	line = simple_readline(window_height - 1, 0, "Enter profile number> ",
+			       NULL, 0, 8, 1);
+	editpolicy_attr_change(A_BOLD, OFF); /* add color */
+	if (!line || !*line)
+		goto out;
+	fp = open_write(DOMAIN_POLICY_FILE);
+	if (!fp)
+		goto out;
+	for (index = 0; index < domain_list_count; index++) {
+		if (!domain_list_selected[index])
+			continue;
+		fprintf(fp, "select %s\n" KEYWORD_USE_PROFILE "%s\n",
+			domain_name(index), line);
+	}
+	fclose(fp);
+out:
+	free(line);
+}
+
+static void show_command_key(void)
+{
+	int c;
+	clear();
+	printw("Commands available for this screen are:\n\n"
+	       "Q/q        Quit this editor.\n"
+	       "R/r        Refresh to the latest information.\n"
+	       "F/f        Find first.\n"
+	       "N/n        Find next.\n"
+	       "P/p        Find previous.\n"
+	       "Tab        Switch to next screen.\n"
+	       "Insert     Copy an entry at the cursor position to history "
+	       "buffer.\n"
+	       "Space      Invert selection state of an entry at the cursor "
+	       "position.\n"
+	       "C/c        Copy selection state of an entry at the cursor "
+	       "position to all entries below the cursor position.\n");
+	if (current_screen != SCREEN_DOMAIN_LIST)
+		goto not_domain_list;
+	printw("A/a        Add a new domain.\n"
+	       "Enter      Edit ACLs of a domain at the cursor position.\n"
+	       "D/d        Delete selected domains.\n"
+	       "S/s        Set profile number of selected domains.\n");
+	goto wait_key;
+not_domain_list:
+	printw("A/a        Add a new entry.\n"
+	       "D/d        Delete selected entries.\n");
+	if (current_screen != SCREEN_ACL_LIST)
+		goto wait_key;
+	printw("O/o        Set selection state to other entries included in "
+	       "an entry at the cursor position.\n");
+	printw("@          Switch sort type.\n");
+wait_key:
+	printw("Arrow-keys and PageUp/PageDown/Home/End keys "
+	       "for scroll.\n\n"
+	       "Press '?' to escape from this help.\n");
+	refresh();
+	while (1) {
+		c = getch2();
+		if (c == '?' || c == EOF)
+			break;
+	}
+}
+
+static int generic_list_loop(void)
+{
+	static struct readline_data rl;
 	static int saved_current_y[MAXSCREEN];
 	static int saved_current_item_index[MAXSCREEN];
 	static int first = 1;
 	if (first) {
-		readline_history = malloc(max_readline_history * sizeof(const char *));
+		memset(&rl, 0, sizeof(rl));
+		rl.max = 20;
+		rl.history = malloc(rl.count * sizeof(const char *));
 		memset(saved_current_y, 0, sizeof(saved_current_y));
-		memset(saved_current_item_index, 0, sizeof(saved_current_item_index));
-		memset(search_buffer, 0, sizeof(search_buffer));
+		memset(saved_current_item_index, 0,
+		       sizeof(saved_current_item_index));
 		first = 0;
 	}
 	if (current_screen == SCREEN_SYSTEM_LIST) {
@@ -1795,252 +3075,168 @@
 		list_caption = "Domain Policy";
 	} else {
 		policy_file = DOMAIN_POLICY_FILE;
-		//list_caption = "Domain Transition";
+		/* list_caption = "Domain Transition"; */
 	}
-	current_item_index[current_screen] = saved_current_item_index[current_screen];
+	current_item_index[current_screen]
+		= saved_current_item_index[current_screen];
 	current_y[current_screen] = saved_current_y[current_screen];
- start:
+start:
 	if (current_screen == SCREEN_DOMAIN_LIST) {
-		ReadDomainAndExceptionPolicy();
-		AdjustCursorPos(domain_list_count);
+		read_domain_and_exception_policy();
+		adjust_cursor_pos(domain_list_count);
 	} else {
-		ReadGenericPolicy();
-		AdjustCursorPos(generic_acl_list_count);
+		read_generic_policy();
+		adjust_cursor_pos(generic_acl_list_count);
 	}
- start2:
-	ShowList();
-	if (last_error && current_screen == SCREEN_DOMAIN_LIST) {
-		mvprintw(1, 0, "ERROR: %s", last_error); clrtoeol(); refresh();
-		free(last_error); last_error = NULL;
-	}	
+start2:
+	show_list();
+	if (rl.last_error && current_screen == SCREEN_DOMAIN_LIST) {
+		mvprintw(1, 0, "ERROR: %s", rl.last_error);
+		clrtoeol();
+		refresh();
+		free(rl.last_error);
+		rl.last_error = NULL;
+	}
 	while (1) {
-		const int current = GetCurrent();
+		const int current = get_current();
 		const int c = getch2();
-		saved_current_item_index[current_screen] = current_item_index[current_screen];
+		saved_current_item_index[current_screen]
+			= current_item_index[current_screen];
 		saved_current_y[current_screen] = current_y[current_screen];
-		if (c == 'q' || c == 'Q') return MAXSCREEN;
-		if ((c == '\r' || c == '\n') && current_screen == SCREEN_ACL_LIST) return SCREEN_DOMAIN_LIST;
+		if (c == 'q' || c == 'Q')
+			return MAXSCREEN;
+		if ((c == '\r' || c == '\n') &&
+		    current_screen == SCREEN_ACL_LIST)
+			return SCREEN_DOMAIN_LIST;
 		if (c == '\t') {
-			if (current_screen == SCREEN_DOMAIN_LIST) return SCREEN_SYSTEM_LIST;
-			else if (current_screen == SCREEN_SYSTEM_LIST) return SCREEN_EXCEPTION_LIST;
-			else return SCREEN_DOMAIN_LIST;
+			if (current_screen == SCREEN_DOMAIN_LIST)
+				return SCREEN_SYSTEM_LIST;
+			else if (current_screen == SCREEN_SYSTEM_LIST)
+				return SCREEN_EXCEPTION_LIST;
+			else
+				return SCREEN_DOMAIN_LIST;
 		}
-		if (c == ERR) continue; // Ignore invalid key.
-		switch(c) {
+		if (c == ERR)
+			continue; /* Ignore invalid key. */
+		switch (c) {
+			int index;
+			const char *line;
 		case KEY_RESIZE:
-			ResizeWindow();
-			ShowList();
+			resize_window();
+			show_list();
 			break;
 		case KEY_UP:
-			UpArrowKey();
+			up_arrow_key();
 			break;
 		case KEY_DOWN:
-			DownArrowKey();
+			down_arrow_key();
 			break;
 		case KEY_PPAGE:
-			PageUpKey();
+			page_up_key();
 			break;
 		case KEY_NPAGE:
-			PageDownKey();
+			page_down_key();
 			break;
 		case ' ':
-			SelectItem(current);
+			select_item(current);
 			break;
 		case 'c':
 		case 'C':
-			if (current >= 0) {
-				int index;
-				if (current_screen == SCREEN_DOMAIN_LIST) {
-					if (IsDeletedDomain(current) || IsInitializerSource(current)) break;
-					for (index = current; index < domain_list_count; index++) {
-						if (IsDeletedDomain(index) || IsInitializerSource(index)) continue;
-						domain_list_selected[index] = domain_list_selected[current];
-					}
-				} else {
-					for (index = current; index < generic_acl_list_count; index++) {
-						generic_acl_list_selected[index] = generic_acl_list_selected[current];
-					}
+			if (current == EOF)
+				break;
+			if (current_screen == SCREEN_DOMAIN_LIST) {
+				const u8 selected
+					= domain_list_selected[current];
+				if (is_deleted_domain(current) ||
+				    is_initializer_source(current))
+					break;
+				for (index = current;
+				     index < domain_list_count; index++) {
+					if (is_deleted_domain(index) ||
+					    is_initializer_source(index))
+						continue;
+					domain_list_selected[index] = selected;
 				}
-				ShowList();
+			} else {
+				const u8 selected
+					= generic_acl_list[current].selected;
+				for (index = current;
+				     index < generic_acl_list_count; index++) {
+					generic_acl_list[index].selected
+						= selected;
+				}
 			}
+			show_list();
 			break;
 		case 'f':
 		case 'F':
-			if (current >= 0) {
-				int index;
-				char *line;
-			input_path:
-				attrChange(A_BOLD, ON);	// add color
-				line = simple_readline(window_height - 1, 0, "Search> ", readline_history, readline_history_count, 4000, 8);
-				attrChange(A_BOLD, OFF);	// add color
-				if (line && *line) {
-					readline_history_count = simple_add_history(line, readline_history, readline_history_count, max_readline_history);
-					free(search_buffer[current_screen]); search_buffer[current_screen] = line; line = NULL;
-					for (index = 0; index < list_item_count[current_screen]; index++) {
-						const char *cp = (current_screen == SCREEN_DOMAIN_LIST) ? GetLastName(index) : generic_acl_list[index];
-						if (!strstr(cp, search_buffer[current_screen])) continue;
-						SetCursorPos(index);
-						break;
-					}
-				}
-				free(line);
-				ShowList();
-			}
+			find_entry(1, 1, current, &rl);
 			break;
 		case 'p':
 		case 'P':
-			if (current >= 0) {
-				int index;
-				if (!search_buffer[current_screen]) goto input_path;
-				for (index = current - 1; index >= 0; index--) {
-					const char *cp = (current_screen == SCREEN_DOMAIN_LIST) ? GetLastName(index) : generic_acl_list[index];
-					if (!strstr(cp, search_buffer[current_screen])) continue;
-					SetCursorPos(index);
-					ShowList();
-					break;
-				}
-			}
+			if (!rl.search_buffer[current_screen])
+				find_entry(1, 0, current, &rl);
+			else
+				find_entry(0, 0, current, &rl);
 			break;
 		case 'n':
 		case 'N':
-			if (current >= 0) {
-				int index;
-				if (!search_buffer[current_screen]) goto input_path;
-				for (index = current + 1; index < list_item_count[current_screen]; index++) {
-					const char *cp = (current_screen == SCREEN_DOMAIN_LIST) ? GetLastName(index) : generic_acl_list[index];
-					if (!strstr(cp, search_buffer[current_screen])) continue;
-					SetCursorPos(index);
-					ShowList();
-					break;
-				}
-			}
+			if (!rl.search_buffer[current_screen])
+				find_entry(1, 1, current, &rl);
+			else
+				find_entry(0, 1, current, &rl);
 			break;
 		case 'd':
 		case 'D':
-			{
-				int c;
-				move(1, 0);
-				colorChange(DISP_ERR, ON);	// add color
-				if (current_screen == SCREEN_DOMAIN_LIST) {
-					if ((c = count(domain_list_selected, domain_list_count)) == 0 && (c = SelectItem(current)) == 0) printw("Select domain using Space key first.");
-					else printw("Delete selected domain%s? ('Y'es/'N'o)", c > 1 ? "s" : "");
-				} else {
-					if ((c = count(generic_acl_list_selected, generic_acl_list_count)) == 0 && (c = SelectItem(current)) == 0) printw("Select entry using Space key first.");
-					else printw("Delete selected entr%s? ('Y'es/'N'o)", c > 1 ? "ies" : "y");
-				}
-				colorChange(DISP_ERR, OFF);	// add color
-				clrtoeol();
-				refresh();
-				if (!c) break;
-				do {
-					c = getch2();
-				} while (!(c == 'Y' || c == 'y' || c == 'N' || c == 'n' || c == EOF));
-				ResizeWindow();
-				if (c == 'Y' || c == 'y') {
-					int index;
-					if (current_screen == SCREEN_DOMAIN_LIST) {
-						FILE *fp = open_write(DOMAIN_POLICY_FILE);
-						if (fp) {
-							for (index = 1; index < domain_list_count; index++) {
-								if (domain_list_selected[index]) fprintf(fp, "delete %s\n", DomainName(index));
-							}
-							fclose(fp);
-						}
-					} else {
-						FILE *fp = open_write(policy_file);
-						if (fp) {
-							if (current_screen == SCREEN_ACL_LIST) fprintf(fp, "select %s\n", current_domain);
-							for (index = 0; index < generic_acl_list_count; index++) {
-								if (generic_acl_list_selected[index]) fprintf(fp, "delete %s\n", map_perm_keyword(0, generic_acl_list[index]));
-							}
-							fclose(fp);
-						}
-					}
-					goto start;
-				}
-				ShowList();
-			}
-			break;
+			delete_entry(current);
+			goto start;
 		case 'a':
 		case 'A':
-			{
-				attrChange(A_BOLD, ON);	// add color
-				char *line = simple_readline(window_height - 1, 0, "Enter new entry> ", readline_history, readline_history_count, 8192, 8);
-				attrChange(A_BOLD, OFF);	// add color
-				if (line && *line) {
-					readline_history_count = simple_add_history(line, readline_history, readline_history_count, max_readline_history);
-					if (current_screen == SCREEN_DOMAIN_LIST && !IsCorrectDomain(line)) {
-						const int len = strlen(line) + 128;
-						if ((last_error = (char *) realloc(last_error, len)) == NULL) OutOfMemory();
-						memset(last_error, 0, len);
-						snprintf(last_error, len - 1, "%s is an invalid domainname.", line);
-					} else {
-						FILE *fp = open_write(policy_file);
-						if (fp) {
-							if (current_screen == SCREEN_ACL_LIST) fprintf(fp, "select %s\n", current_domain);
-							fprintf(fp, "%s\n", map_perm_keyword(0, line));
-							fclose(fp);
-						}
-					}
-				}
-				free(line);
-				goto start;
-			}
-			break;
+			add_entry(&rl);
+			goto start;
 		case '\r':
 		case '\n':
-			if (current_screen == SCREEN_DOMAIN_LIST) {
-				if (IsInitializerSource(current)) {
-					int redirect_index;
-					get();
-					memset(shared_buffer, 0, shared_buffer_len);
-					snprintf(shared_buffer, shared_buffer_len - 1, ROOT_NAME "%s", strrchr(DomainName(current), ' '));
-					redirect_index = FindDomain(shared_buffer, 0, 0);
-					put();
-					if (redirect_index != EOF) {
-						current_item_index[current_screen] = redirect_index - current_y[current_screen];
-						while (current_item_index[current_screen] < 0) {
-							current_item_index[current_screen]++; current_y[current_screen]--;
-						}
-						ShowList();
-					}
-				} else if (!IsDeletedDomain(current)) {
-					free(current_domain);
-					if ((current_domain = strdup(DomainName(current))) == NULL) OutOfMemory();
-					return SCREEN_ACL_LIST;
+			if (current_screen != SCREEN_DOMAIN_LIST)
+				break;
+			if (is_initializer_source(current)) {
+				int redirect_index;
+				get();
+				memset(shared_buffer, 0, shared_buffer_len);
+				snprintf(shared_buffer, shared_buffer_len - 1,
+					 ROOT_NAME "%s",
+					 strrchr(domain_name(current), ' '));
+				redirect_index = find_domain(shared_buffer, 0,
+							     0);
+				put();
+				if (redirect_index == EOF)
+					break;
+				current_item_index[current_screen]
+					= redirect_index
+					- current_y[current_screen];
+				while (current_item_index[current_screen] < 0) {
+					current_item_index[current_screen]++;
+					current_y[current_screen]--;
 				}
+				show_list();
+			} else if (!is_deleted_domain(current)) {
+				free(current_domain);
+				current_domain = strdup(domain_name(current));
+				if (!current_domain)
+					out_of_memory();
+				return SCREEN_ACL_LIST;
 			}
 			break;
 		case 's':
 		case 'S':
-			if (current_screen == SCREEN_DOMAIN_LIST) {
-				if (!count(domain_list_selected, domain_list_count) && !SelectItem(current)) {
-					mvprintw(1, 0, "Select domain using Space key first."); clrtoeol(); refresh();
-				} else {
-					attrChange(A_BOLD, ON);	// add color
-					char *line = simple_readline(window_height - 1, 0, "Enter profile number> ", NULL, 0, 8, 1);
-					attrChange(A_BOLD, OFF);	// add color
-					if (line && *line) {
-						FILE *fp = open_write(DOMAIN_POLICY_FILE);
-						if (fp) {
-							int index;
-							for (index = 0; index < domain_list_count; index++) {
-								if (domain_list_selected[index]) fprintf(fp, "select %s\nuse_profile %s\n", DomainName(index), line);
-							}
-							fclose(fp);
-						}
-					}
-					free(line);
-					goto start;
-				}
-			}
-			break;
+			set_profile(current);
+			goto start;
 		case 'r':
 		case 'R':
 			goto start;
 		case KEY_LEFT:
-			if (!max_eat_col[current_screen]) break;
-			max_eat_col[current_screen]--; 
+			if (!max_eat_col[current_screen])
+				break;
+			max_eat_col[current_screen]--;
 			goto start2;
 		case KEY_RIGHT:
 			max_eat_col[current_screen]++;
@@ -2052,63 +3248,49 @@
 			max_eat_col[current_screen] = max_col;
 			goto start2;
 		case KEY_IC:
-			if (current >= 0) readline_history_count = simple_add_history(current_screen == SCREEN_DOMAIN_LIST ? DomainName(current) : generic_acl_list[current], readline_history, readline_history_count, max_readline_history);
+			if (current == EOF)
+				break;
+			if (current_screen == SCREEN_DOMAIN_LIST)
+				line = domain_name(current);
+			else
+				line = generic_acl_list[current].operand;
+			rl.count = simple_add_history(line, rl.history,
+						      rl.count, rl.max);
 			break;
 		case 'o':
 		case 'O':
-			if (current_screen == SCREEN_ACL_LIST) try_optimize(current);
+			if (current_screen == SCREEN_ACL_LIST)
+				try_optimize(current);
 			break;
 		case '@':
-			if (current_screen != SCREEN_ACL_LIST) break;
+			if (current_screen != SCREEN_ACL_LIST)
+				break;
 			sort_type = (sort_type + 1) % 2;
 			goto start;
 		case '?':
-			{
-				int c;
-				clear();
-				printw("Commands available for this screen are:\n\n"
-					   "Q/q        Quit this editor.\n"
-					   "R/r        Refresh to the latest information.\n"
-					   "F/f        Find first.\n"
-					   "N/n        Find next.\n"
-					   "P/p        Find previous.\n"
-					   "Tab        Switch to next screen.\n"
-					   "Insert     Copy an entry at the cursor position to history buffer.\n"
-					   "Space      Invert selection state of an entry at the cursor position.\n"
-					   "C/c        Copy selection state of an entry at the cursor position to all entries below the cursor position.\n");
-				if (current_screen == SCREEN_DOMAIN_LIST) {
-					printw("A/a        Add a new domain.\n"
-						   "Enter      Edit ACLs of a domain at the cursor position.\n"
-						   "D/d        Delete selected domains.\n"
-						   "S/s        Set profile number of selected domains.\n");
-				} else {
-					printw("A/a        Add a new entry.\n"
-						   "D/d        Delete selected entries.\n");
-					if (current_screen == SCREEN_ACL_LIST) {
-						printw("O/o        Set selection state to other entries included in an entry at the cursor position.\n");
-						printw("@          Switch sort type.\n");
-					}
-				}
-				printw("Arrow-keys and PageUp/PageDown/Home/End keys for scroll.\n\n"
-					   "Press '?' to escape from this help.\n"); refresh();
-				while ((c = getch2()) != '?' && c != EOF);
-				goto start;
-			}
-			break;
+			show_command_key();
+			goto start;
 		}
 	}
 }
 
-static void policy_daemon(void) {
+static void policy_daemon(void)
+{
 	get();
-	FindOrAssignNewDomain(ROOT_NAME, 0, 0);
+	find_or_assign_new_domain(ROOT_NAME, 0, 0);
 	while (1) {
-		static const struct path_info **exception_list = NULL, **system_list = NULL;
-		static int exception_list_count = 0, system_list_count = 0;
+		static const struct path_info **exception_list = NULL;
+		static const struct path_info **system_list = NULL;
+		static int exception_list_count = 0;
+		static int system_list_count = 0;
 		FILE *fp;
+		int i;
+		int j;
+		int index;
 		{
 			struct msghdr msg;
-			struct iovec iov = { shared_buffer, shared_buffer_len - 1 };
+			struct iovec iov = { shared_buffer,
+					     shared_buffer_len - 1 };
 			char cmsg_buf[CMSG_SPACE(sizeof(int))];
 			struct cmsghdr *cmsg = (struct cmsghdr *) cmsg_buf;
 			memset(&msg, 0, sizeof(msg));
@@ -2123,8 +3305,9 @@
 				cmsg->cmsg_level == SOL_SOCKET &&
 				cmsg->cmsg_type == SCM_RIGHTS &&
 				cmsg->cmsg_len == CMSG_LEN(sizeof(int))) {
-				const int fd = * (int *) CMSG_DATA(cmsg);
-				if ((fp = fdopen(fd, "w+")) == NULL) {
+				const int fd = *(int *) CMSG_DATA(cmsg);
+				fp = fdopen(fd, "w+");
+				if (!fp) {
 					close(fd);
 					continue;
 				}
@@ -2132,98 +3315,144 @@
 				break;
 			}
 		}
-		if (strncmp(shared_buffer, "POST ", 5) == 0) {
-			if (strcmp(shared_buffer + 5, "domain_policy") == 0) {
-				int index = EOF;
-				while (freadline(fp)) {
-					int is_delete = 0, is_select = 0;
-					if (strncmp(shared_buffer, "delete ", 7) == 0) {
-						is_delete = 1;
-						RemoveHeader(shared_buffer, 7);
-					} else if (strncmp(shared_buffer, "select ", 7) == 0) {
-						is_select = 1;
-						RemoveHeader(shared_buffer, 7);
-					}
-					if (IsDomainDef(shared_buffer)) {
-						if (is_delete) {
-							index = FindDomain(shared_buffer, 0, 0);
-							if (index > 0) DeleteDomain(index);
-							index = EOF;
-						} else if (is_select) {
-							index = FindDomain(shared_buffer, 0, 0);
-						} else {
-							index = FindOrAssignNewDomain(shared_buffer, 0, 0);
-						}
-					} else if (index >= 0 && shared_buffer[0]) {
-						unsigned int profile;
-						if (sscanf(shared_buffer, "use_profile %u", &profile) == 1) {
-							domain_list[index].profile = (unsigned char) profile;
-						} else if (is_delete) {
-							DelStringEntry(shared_buffer, index);
-						} else {
-							AddStringEntry(shared_buffer, index);
-						}
-					}
-				}
-			} else if (strcmp(shared_buffer + 5, "exception_policy") == 0) {
-				while (freadline(fp)) {
-					if (!shared_buffer[0]) continue;
-					if (strncmp(shared_buffer, "delete ", 7) == 0) {
-						int i;
-						struct path_info path;
-						RemoveHeader(shared_buffer, 7);
-						path.name = shared_buffer;
-						fill_path_info(&path);
-						for (i = 0; i < exception_list_count; i++) {
-							if (pathcmp(exception_list[i], &path)) continue;
-							for (exception_list_count--; i < exception_list_count; i++) exception_list[i] = exception_list[i + 1];
-							break;
-						}
-					} else {
-						if ((exception_list = (const struct path_info **) realloc(exception_list, (exception_list_count + 1) * sizeof(const struct path_info *))) == NULL
-							|| (exception_list[exception_list_count++] = SaveName(shared_buffer)) == NULL) OutOfMemory();
-					}
-				}
-			} else if (strcmp(shared_buffer + 5, "system_policy") == 0) {
-				while (freadline(fp)) {
-					if (!shared_buffer[0]) continue;
-					if (strncmp(shared_buffer, "delete ", 7) == 0) {
-						int i;
-						struct path_info path;
-						RemoveHeader(shared_buffer, 7);
-						path.name = shared_buffer;
-						fill_path_info(&path);
-						for (i = 0; i < system_list_count; i++) {
-							if (pathcmp(system_list[i], &path)) continue;
-							for (system_list_count--; i < system_list_count; i++) system_list[i] = system_list[i + 1];
-							break;
-						}
-					} else {
-						if ((system_list = (const struct path_info **) realloc(system_list, (system_list_count + 1) * sizeof(struct path_info *))) == NULL
-							|| (system_list[system_list_count++] = SaveName(shared_buffer)) == NULL) OutOfMemory();
-					}
-				}
+		if (!str_starts(shared_buffer, "POST "))
+			goto not_post_method;
+		if (strcmp(shared_buffer, "domain_policy"))
+			goto not_domain_policy1;
+		index = EOF;
+		while (freadline(fp)) {
+			int is_delete = 0, is_select = 0;
+			unsigned int profile;
+			if (str_starts(shared_buffer, "delete "))
+				is_delete = 1;
+			else if (str_starts(shared_buffer, "select "))
+				is_select = 1;
+			if (!is_domain_def(shared_buffer))
+				goto not_domain_def;
+			if (is_delete) {
+				index = find_domain(shared_buffer, 0, 0);
+				if (index > 0)
+					delete_domain(index);
+				index = EOF;
+				continue;
 			}
-		} else if (strncmp(shared_buffer, "GET ", 4) == 0) {
-			if (strcmp(shared_buffer + 4, "domain_policy") == 0) {
-				int i, j;
-				for (i = 0; i < domain_list_count; i++) {
-					const struct path_info **string_ptr = domain_list[i].string_ptr;
-					const int string_count = domain_list[i].string_count;
-					fprintf(fp, "%s\nuse_profile %u\n\n", DomainName(i), domain_list[i].profile);
-					for (j = 0; j < string_count; j++) {
-						fprintf(fp, "%s\n", string_ptr[j]->name);
-					}
-					fprintf(fp, "\n");
-				}
-			} else if (strcmp(shared_buffer + 4, "exception_policy") == 0) {
-				int i;
-				for (i = 0; i < exception_list_count; i++) fprintf(fp, "%s\n", exception_list[i]->name);
-			} else if (strcmp(shared_buffer + 4, "system_policy") == 0) {
-				int i;
-				for (i = 0; i < system_list_count; i++) fprintf(fp, "%s\n", system_list[i]->name);
+			if (is_select) {
+				index = find_domain(shared_buffer, 0, 0);
+				continue;
 			}
+			index = find_or_assign_new_domain(shared_buffer, 0, 0);
+			continue;
+not_domain_def:
+			if (index == EOF || !shared_buffer[0])
+				continue;
+			if (sscanf(shared_buffer, KEYWORD_USE_PROFILE "%u",
+				   &profile) == 1)
+				domain_list[index].profile = (u8) profile;
+			else if (is_delete)
+				del_string_entry(shared_buffer, index);
+			else
+				add_string_entry(shared_buffer, index);
 		}
+		goto close_file;
+not_domain_policy1:
+		if (!strcmp(shared_buffer, "exception_policy"))
+			goto not_exception_policy1;
+		while (freadline(fp)) {
+			int i;
+			struct path_info path;
+			const struct path_info *cp;
+			void *vp;
+			if (!shared_buffer[0])
+				continue;
+			if (!str_starts(shared_buffer, "delete "))
+				goto not_delete_exception;
+			path.name = shared_buffer;
+			fill_path_info(&path);
+			for (i = 0; i < exception_list_count; i++) {
+				if (pathcmp(exception_list[i], &path))
+					continue;
+				for (exception_list_count--;
+				     i < exception_list_count; i++)
+					exception_list[i]
+						= exception_list[i + 1];
+				break;
+			}
+			continue;
+not_delete_exception:
+			vp = realloc(exception_list, (exception_list_count + 1)
+				     * sizeof(const struct path_info *));
+			if (!vp)
+				out_of_memory();
+			exception_list = vp;
+			cp = savename(shared_buffer);
+			if (!cp)
+				out_of_memory();
+			exception_list[exception_list_count++] = cp;
+		}
+		goto close_file;
+not_exception_policy1:
+		if (!strcmp(shared_buffer, "system_policy"))
+			goto close_file;
+		while (freadline(fp)) {
+			int i;
+			struct path_info path;
+			const struct path_info *cp;
+			void *vp;
+			if (!shared_buffer[0])
+				continue;
+			if (!str_starts(shared_buffer, "delete "))
+				goto not_delete_system;
+			path.name = shared_buffer;
+			fill_path_info(&path);
+			for (i = 0; i < system_list_count; i++) {
+				if (pathcmp(system_list[i], &path))
+					continue;
+				for (system_list_count--;
+				     i < system_list_count; i++)
+					system_list[i] = system_list[i + 1];
+				break;
+			}
+			continue;
+not_delete_system:
+			vp = realloc(system_list, (system_list_count + 1)
+				     * sizeof(struct path_info *));
+			if (!vp)
+				out_of_memory();
+			system_list = vp;
+			cp = savename(shared_buffer);
+			if (!cp)
+				out_of_memory();
+			system_list[system_list_count++] = cp;
+		}
+		goto close_file;
+not_post_method:
+		if (!str_starts(shared_buffer, "GET "))
+			goto close_file;
+		if (strcmp(shared_buffer, "domain_policy"))
+			goto not_domain_policy2;
+		for (i = 0; i < domain_list_count; i++) {
+			const struct path_info **string_ptr
+				= domain_list[i].string_ptr;
+			const int string_count = domain_list[i].string_count;
+			fprintf(fp, "%s\n" KEYWORD_USE_PROFILE "%u\n\n",
+				domain_name(i), domain_list[i].profile);
+			for (j = 0; j < string_count; j++)
+				fprintf(fp, "%s\n", string_ptr[j]->name);
+			fprintf(fp, "\n");
+		}
+		goto close_file;
+not_domain_policy2:
+		if (strcmp(shared_buffer, "exception_policy"))
+			goto not_exception_policy2;
+		for (i = 0; i < exception_list_count; i++)
+			fprintf(fp, "%s\n", exception_list[i]->name);
+		goto close_file;
+not_exception_policy2:
+		if (strcmp(shared_buffer, "system_policy"))
+			goto close_file;
+		for (i = 0; i < system_list_count; i++)
+			fprintf(fp, "%s\n", system_list[i]->name);
+close_file:
 		fclose(fp);
 	}
 	put();
@@ -2232,15 +3461,19 @@
 
 static void init_keyword_map(void);
 
-int editpolicy_main(int argc, char *argv[]) {
+int editpolicy_main(int argc, char *argv[])
+{
 	memset(current_y, 0, sizeof(current_y));
 	memset(current_item_index, 0, sizeof(current_item_index));
 	memset(list_item_count, 0, sizeof(list_item_count));
 	memset(max_eat_col, 0, sizeof(max_eat_col));
 	if (argc > 1) {
-		if (strcmp(argv[1], "s") == 0) current_screen = SCREEN_SYSTEM_LIST;
-		else if (strcmp(argv[1], "e") == 0) current_screen = SCREEN_EXCEPTION_LIST;
-		else if (strcmp(argv[1], "d") == 0) current_screen = SCREEN_DOMAIN_LIST;
+		if (!strcmp(argv[1], "s"))
+			current_screen = SCREEN_SYSTEM_LIST;
+		else if (!strcmp(argv[1], "e"))
+			current_screen = SCREEN_EXCEPTION_LIST;
+		else if (!strcmp(argv[1], "d"))
+			current_screen = SCREEN_DOMAIN_LIST;
 		else {
 			printf("Usage: %s [s|e|d]\n", argv[0]);
 			return 1;
@@ -2249,14 +3482,18 @@
 	init_keyword_map();
 	{
 		char *cp = strrchr(argv[0], '/');
-		if (!cp) cp = argv[0];
-		else cp++;
-		if (strstr(cp, "editpolicy_offline")) offline_mode = 1;
+		if (!cp)
+			cp = argv[0];
+		else
+			cp++;
+		if (strstr(cp, "editpolicy_offline"))
+			offline_mode = 1;
 	}
 	if (offline_mode) {
 		int fd[2];
 		if (chdir(disk_policy_dir)) {
-			printf("Directory %s doesn't exist.\n", disk_policy_dir);
+			printf("Directory %s doesn't exist.\n",
+			       disk_policy_dir);
 			return 1;
 		}
 		if (socketpair(PF_UNIX, SOCK_STREAM, 0, fd)) {
@@ -2276,42 +3513,65 @@
 		close(fd[1]);
 		persistent_fd = fd[0];
 		{
-			int fd, len;
+			int fd;
+			int len;
 			FILE *fp;
 			get();
-			if ((fd = open(disk_policy_system_policy, O_RDONLY)) != EOF) {
+			fd = open(disk_policy_system_policy, O_RDONLY);
+			if (fd != EOF) {
 				fp = open_write(SYSTEM_POLICY_FILE);
-				while ((len = read(fd, shared_buffer, shared_buffer_len)) > 0) fwrite(shared_buffer, len, 1, fp);
-				fclose(fp); close(fd);
+				while ((len = read(fd, shared_buffer,
+						   shared_buffer_len)) > 0)
+					fwrite(shared_buffer, len, 1, fp);
+				fclose(fp);
+				close(fd);
 			}
-			if ((fd = open(disk_policy_exception_policy, O_RDONLY)) != EOF) {
+			fd = open(disk_policy_exception_policy, O_RDONLY);
+			if (fd != EOF) {
 				fp = open_write(EXCEPTION_POLICY_FILE);
-				while ((len = read(fd, shared_buffer, shared_buffer_len)) > 0) fwrite(shared_buffer, len, 1, fp);
-				fclose(fp); close(fd);
+				while ((len = read(fd, shared_buffer,
+						   shared_buffer_len)) > 0)
+					fwrite(shared_buffer, len, 1, fp);
+				fclose(fp);
+				close(fd);
 			}
-			if ((fd = open(disk_policy_domain_policy, O_RDONLY)) != EOF) {
+			fd = open(disk_policy_domain_policy, O_RDONLY);
+			if (fd != EOF) {
 				fp = open_write(DOMAIN_POLICY_FILE);
-				while ((len = read(fd, shared_buffer, shared_buffer_len)) > 0) fwrite(shared_buffer, len, 1, fp);
-				fclose(fp); close(fd);
+				while ((len = read(fd, shared_buffer,
+						   shared_buffer_len)) > 0)
+					fwrite(shared_buffer, len, 1, fp);
+				fclose(fp);
+				close(fd);
 			}
 			put();
 		}
 	} else {
 		if (chdir(proc_policy_dir)) {
-			fprintf(stderr, "You can't use this editor for this kernel.\n");
+			fprintf(stderr,
+				"You can't use this editor for this kernel.\n");
 			return 1;
 		}
 		{
-			const int fd1 = open(SYSTEM_POLICY_FILE, O_RDWR), fd2 = open(EXCEPTION_POLICY_FILE, O_RDWR), fd3 = open(DOMAIN_POLICY_FILE, O_RDWR);
-			if ((fd1 != EOF && write(fd1, "", 0) != 0) || (fd2 != EOF && write(fd2, "", 0) != 0) || (fd3 != EOF && write(fd3, "", 0) != 0)) {
-				fprintf(stderr, "You need to register this program to %s to run this program.\n", proc_policy_manager);
+			const int fd1 = open(SYSTEM_POLICY_FILE, O_RDWR);
+			const int fd2 = open(EXCEPTION_POLICY_FILE, O_RDWR);
+			const int fd3 = open(DOMAIN_POLICY_FILE, O_RDWR);
+			if ((fd1 != EOF && write(fd1, "", 0) != 0) ||
+			    (fd2 != EOF && write(fd2, "", 0) != 0) ||
+			    (fd3 != EOF && write(fd3, "", 0) != 0)) {
+				fprintf(stderr,
+					"You need to register this program to "
+					"%s to run this program.\n",
+					proc_policy_manager);
 				return 1;
 			}
-			close(fd1); close(fd2); close(fd3);
+			close(fd1);
+			close(fd2);
+			close(fd3);
 		}
 	}
 	initscr();
-	ColorInit();	// add color
+	editpolicy_color_init();
 	cbreak();
 	noecho();
 	nonl();
@@ -2320,53 +3580,85 @@
 	getmaxyx(stdscr, window_height, window_width);
 	while (current_screen < MAXSCREEN) {
 		if (!offline_mode) {
-			if (current_screen == SCREEN_DOMAIN_LIST && access(DOMAIN_POLICY_FILE, F_OK)) current_screen = SCREEN_SYSTEM_LIST;
-			else if (current_screen == SCREEN_SYSTEM_LIST && access(SYSTEM_POLICY_FILE, F_OK)) current_screen = SCREEN_EXCEPTION_LIST;
-			else if (current_screen == SCREEN_EXCEPTION_LIST && access(EXCEPTION_POLICY_FILE, F_OK)) {
+			if (current_screen == SCREEN_DOMAIN_LIST &&
+			    access(DOMAIN_POLICY_FILE, F_OK))
+				current_screen = SCREEN_SYSTEM_LIST;
+			else if (current_screen == SCREEN_SYSTEM_LIST &&
+				 access(SYSTEM_POLICY_FILE, F_OK))
+				current_screen = SCREEN_EXCEPTION_LIST;
+			else if (current_screen == SCREEN_EXCEPTION_LIST &&
+				 access(EXCEPTION_POLICY_FILE, F_OK)) {
 				current_screen = SCREEN_DOMAIN_LIST;
-				if (access(DOMAIN_POLICY_FILE, F_OK)) current_screen = SCREEN_SYSTEM_LIST;
+				if (access(DOMAIN_POLICY_FILE, F_OK))
+					current_screen = SCREEN_SYSTEM_LIST;
 			}
 		}
-		ResizeWindow();
-		current_screen = GenericListLoop();
+		resize_window();
+		current_screen = generic_list_loop();
 	}
 	clear();
 	move(0, 0);
 	refresh();
 	endwin();
 	if (offline_mode) {
-		int fd, len;
+		int fd;
+		int len;
 		FILE *fp;
 		time_t now = time(NULL);
 		struct tm *tm = localtime(&now);
-		char filename[1024], buffer[1024];
+		char filename[1024];
+		char buffer[1024];
 		memset(filename, 0, sizeof(filename));
-		snprintf(filename, sizeof(filename) - 1, "system_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if ((fd = open(filename, O_WRONLY | O_CREAT, 0600)) != EOF) {
-			if ((fp = open_read(SYSTEM_POLICY_FILE)) != NULL) {
-				while ((len = fread(buffer, 1, sizeof(buffer), fp)) > 0) write(fd, buffer, len);
-				close(fd); fclose(fp);
+		snprintf(filename, sizeof(filename) - 1,
+			 "system_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		fd = open(filename, O_WRONLY | O_CREAT, 0600);
+		if (fd != EOF) {
+			fp = open_read(SYSTEM_POLICY_FILE);
+			if (fp) {
+				while ((len = fread(buffer, 1, sizeof(buffer),
+						    fp)) > 0)
+					write(fd, buffer, len);
+				fclose(fp);
 				unlink(disk_policy_system_policy);
 				symlink(filename, "system_policy.conf");
 			}
+			close(fd);
 		}
-		snprintf(filename, sizeof(filename) - 1, "exception_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if ((fd = open(filename, O_WRONLY | O_CREAT, 0600)) != EOF) {
-			if ((fp = open_read(EXCEPTION_POLICY_FILE)) != NULL) {
-				while ((len = fread(buffer, 1, sizeof(buffer), fp)) > 0) write(fd, buffer, len);
-				close(fd); fclose(fp);
+		snprintf(filename, sizeof(filename) - 1,
+			 "exception_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		fd = open(filename, O_WRONLY | O_CREAT, 0600);
+		if (fd != EOF) {
+			fp = open_read(EXCEPTION_POLICY_FILE);
+			if (fp) {
+				while ((len = fread(buffer, 1, sizeof(buffer),
+						    fp)) > 0)
+					write(fd, buffer, len);
+				fclose(fp);
 				unlink(disk_policy_exception_policy);
 				symlink(filename, "exception_policy.conf");
 			}
+			close(fd);
 		}
-		snprintf(filename, sizeof(filename) - 1, "domain_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if ((fd = open(filename, O_WRONLY | O_CREAT, 0600)) != EOF) {
-			if ((fp = open_read(DOMAIN_POLICY_FILE)) != NULL) {
-				while ((len = fread(buffer, 1, sizeof(buffer), fp)) > 0) write(fd, buffer, len);
-				close(fd); fclose(fp);
+		snprintf(filename, sizeof(filename) - 1,
+			 "domain_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		fd = open(filename, O_WRONLY | O_CREAT, 0600);
+		if (fd != EOF) {
+			fp = open_read(DOMAIN_POLICY_FILE);
+			if (fp) {
+				while ((len = fread(buffer, 1, sizeof(buffer),
+						    fp)) > 0)
+					write(fd, buffer, len);
+				fclose(fp);
 				unlink(disk_policy_domain_policy);
 				symlink(filename, "domain_policy.conf");
 			}
+			close(fd);
 		}
 	}
 	return 0;
@@ -2374,77 +3666,71 @@
 
 /* keyword mapping */
 
-static char *strdup2(const char *s) {
-	const int len = strlen(s);
-	char *cp = malloc(len + 2);
-	if (cp) {
-		memmove(cp, s, len);
-		cp[len] = ' ';
-		cp[len + 1] = '\0'; 
+static u8 find_directive(const u8 forward, char *line)
+{
+	u8 i;
+	for (i = 0; i < MAX_DIRECTIVE_INDEX; i++) {
+		if (forward) {
+			const int len = directives[i].original_len;
+			if (strncmp(line, directives[i].original, len) ||
+			    line[len] != ' ')
+				continue;
+			memmove(line, line + len + 1,
+				strlen(line + len + 1) + 1);
+			return i;
+		} else {
+			const int len = directives[i].alias_len;
+			if (strncmp(line, directives[i].alias, len) ||
+			    line[len] != ' ')
+				continue;
+			memmove(line, line + len + 1,
+				strlen(line + len + 1) + 1);
+			return i;
+		}
 	}
-	return cp;
+	return EOF;
 }
 
-static struct directive_alias_list {
-	char *keyword;
-	char *alias;
-} *directive_alias = NULL;
-static int directive_alias_len = 0;
-
-static char *map_perm_keyword(const u8 forward, const char *line) {
-	static char *buffer = NULL;
+static void init_keyword_map(void)
+{
+	FILE *fp = fopen(CCSTOOLS_CONFIG_FILE, "r");
 	int i;
-	for (i = 0; i < directive_alias_len; i++) {
-		char *cp;
-		int old_len, new_len, rest_len;
-		cp = forward ? directive_alias[i].keyword : directive_alias[i].alias;
-		old_len = strlen(cp);
-		if (strncmp(cp, line, old_len)) continue;
-		rest_len = strlen(line + old_len);
-		cp = forward ? directive_alias[i].alias : directive_alias[i].keyword;
-		new_len = strlen(cp);
-		buffer = realloc(buffer, new_len + rest_len + 4);
-		if (!buffer) OutOfMemory();
-		snprintf(buffer, new_len + rest_len + 3, "%s%s", cp, line + old_len);
-		return buffer;
-	}
-	free(buffer);
-	buffer = strdup(line);
-	if (!buffer) OutOfMemory();
-	return buffer;
-}
-
-static void init_keyword_map(void) {
-	FILE *fp;
-	int i;
-	if ((fp = fopen(CCSTOOLS_CONFIG_FILE, "r")) == NULL) return;
+	if (!fp)
+		goto use_default;
 	get();
 	while (freadline(fp)) {
-		char *cp;
-		if (strncmp(shared_buffer, "editpolicy.keyword_alias ", 25)) continue;
-		memmove(shared_buffer, shared_buffer + 25, strlen(shared_buffer + 25) + 1);
-		if ((cp = strchr(shared_buffer, '=')) == NULL) continue;
+		char *cp = shared_buffer + 25;
+		if (strncmp(shared_buffer, "editpolicy.keyword_alias ", 25))
+			continue;
+		memmove(shared_buffer, cp, strlen(cp) + 1);
+		cp = strchr(shared_buffer, '=');
+		if (!cp)
+			continue;
 		*cp++ = '\0';
-		NormalizeLine(shared_buffer);
-		NormalizeLine(cp);
-		if (!*shared_buffer || !*cp) continue;
-		if ((directive_alias = (struct directive_alias_list *) realloc(directive_alias, (directive_alias_len + 1) * sizeof(struct directive_alias_list))) == NULL) OutOfMemory();
-		if ((cp = strdup2(cp)) == NULL) OutOfMemory();
-		directive_alias[directive_alias_len].alias = cp;
-		if ((cp = strdup2(shared_buffer)) == NULL) OutOfMemory();
-		directive_alias[directive_alias_len].keyword = cp;
-		/* Modify keyword list for try_optimize(). */
-		for (i = 0; i < max_optimize_directive_index; i++) {
-			if (strcmp(cp, directive_list[i])) continue;
-			directive_list[i] = directive_alias[directive_alias_len].alias;
+		normalize_line(shared_buffer);
+		normalize_line(cp);
+		if (!*shared_buffer || !*cp)
+			continue;
+		for (i = 0; i < MAX_DIRECTIVE_INDEX; i++) {
+			if (strcmp(shared_buffer, directives[i].original))
+				continue;
+			free((void *) directives[i].alias);
+			cp = strdup(cp);
+			if (!cp)
+				out_of_memory();
+			directives[i].alias = cp;
+			directives[i].alias_len = strlen(cp);
 			break;
 		}
-		directive_alias_len++;
 	}
 	put();
 	fclose(fp);
-	for (i = 0; i < max_optimize_directive_index; i++) {
-		directive_list_len[i] = strlen(directive_list[i]);
+ use_default:
+	for (i = 0; i < MAX_DIRECTIVE_INDEX; i++) {
+		if (!directives[i].alias)
+			directives[i].alias = directives[i].original;
+		directives[i].original_len = strlen(directives[i].original);
+		directives[i].alias_len = strlen(directives[i].alias);
 	}
 }
 
Index: ccstools.src/patternize.c
===================================================================
--- ccstools.src/patternize.c	(リビジョン 1537)
+++ ccstools.src/patternize.c	(作業コピー)
@@ -3,9 +3,9 @@
  *
  * TOMOYO Linux's utilities.
  *
- * Copyright (C) 2005-2007  NTT DATA CORPORATION
+ * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.4.1   2007/06/05
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
@@ -14,20 +14,34 @@
  * Check whether the given filename is patterened.
  * Returns nonzero if patterned, zero otherwise.
  */
-static int PathContainsPattern(const char *filename) {
+static int path_contains_pattern(const char *filename)
+{
 	if (filename) {
-		char c, d, e;
-		while ((c = *filename++) != '\0') {
-			if (c != '\\') continue;
-			switch (c = *filename++) {
+		char c;
+		char d;
+		char e;
+		while (1) {
+			c = *filename++;
+			if (!c)
+				break;
+			if (c != '\\')
+				continue;
+			c = *filename++;
+			switch (c) {
 			case '\\':  /* "\\" */
 				continue;
 			case '0':   /* "\ooo" */
 			case '1':
 			case '2':
 			case '3':
-				if ((d = *filename++) >= '0' && d <= '7' && (e = *filename++) >= '0' && e <= '7'
-					&& (c != '0' || d != '0' || e != '0')) continue; /* pattern is not \000 */
+				d = *filename++;
+				if (d < '0' || d > '7')
+					break;
+				e = *filename++;
+				if (e < '0' || e > '7')
+					break;
+				if (c != '0' || d != '0' || e != '0')
+					continue; /* pattern is not \000 */
 			}
 			return 1;
 		}
@@ -35,77 +49,64 @@
 	return 0;
 }
 
-static int PathMatchesToPattern(const struct path_info *pathname0, const struct path_info *pattern0) {
-	//if (!pathname || !pattern) return 0;
-	const char *pathname = pathname0->name, *pattern = pattern0->name;
-	const int len = pattern0->const_len;
-	if (!pattern0->is_patterned) return !pathcmp(pathname0, pattern0);
-	if (pathname0->depth != pattern0->depth) return 0;
-	if (strncmp(pathname, pattern, len)) return 0;
-	pathname += len; pattern += len;
-	while (*pathname && *pattern) {
-		const char *pathname_delimiter = strchr(pathname, '/'), *pattern_delimiter = strchr(pattern, '/');
-		if (!pathname_delimiter) pathname_delimiter = strchr(pathname, '\0');
-		if (!pattern_delimiter) pattern_delimiter = strchr(pattern, '\0');
-		if (!FileMatchesToPattern(pathname, pathname_delimiter, pattern, pattern_delimiter)) return 0;
-		pathname = *pathname_delimiter ? pathname_delimiter + 1 : pathname_delimiter;
-		pattern = *pattern_delimiter ? pattern_delimiter + 1 : pattern_delimiter;
+static const char *patternize(const char *cp, int argc, char *argv[],
+			      struct path_info *pattern_list)
+{
+	int i;
+	struct path_info cp2;
+	cp2.name = cp;
+	fill_path_info(&cp2);
+	for (i = 1; i < argc; i++) {
+		if (path_matches_pattern(&cp2, &pattern_list[i]))
+			return argv[i];
 	}
-	while (*pattern == '\\' && (*(pattern + 1) == '*' || *(pattern + 1) == '@')) pattern += 2;
-	return (!*pathname && !*pattern);
+	return cp;
 }
 
-int patternize_main(int argc, char *argv[]) {
-	struct path_info *pattern_list = malloc(argc * sizeof(struct path_info));
-	if (!pattern_list) OutOfMemory();
+int patternize_main(int argc, char *argv[])
+{
 	int i;
+	struct path_info *pattern_list
+		= malloc(argc * sizeof(struct path_info));
+	if (!pattern_list)
+		out_of_memory();
 	for (i = 0; i < argc; i++) {
 		pattern_list[i].name = argv[i];
 		fill_path_info(&pattern_list[i]);
 	}
 	get();
 	while (freadline(stdin)) {
-		char *sp = shared_buffer, *cp;
-		int first = 1;
-		int check_second = 0;
-		int disabled = 0;
+		char *sp = shared_buffer;
+		const char *cp;
+		bool first = 1;
+		bool disabled = 0;
 		while ((cp = strsep(&sp, " ")) != NULL) {
-		check:
 			if (first) {
-				unsigned int perm;
-				if (sscanf(cp, "%u", &perm) == 1 && (perm & 1) == 1) {
-					/* Is this entry for a program? */
-					check_second = 1;
-				} else if (strcmp(cp, "<kernel>") == 0 || strcmp(cp, "use_profile") == 0
-						   || strcmp(cp, "allow_capability") == 0 || strcmp(cp, "allow_signal") == 0 ||
-						   strcmp(cp, "allow_network") == 0) {
-					/* This entry is not pathname related permission. I don't convert. */
+				if (!strcmp(cp, "allow_execute") ||
+				    !strcmp(cp, "1") || !strcmp(cp, "3") ||
+				    !strcmp(cp, "5") || !strcmp(cp, "7")) {
+					/* This entry is an execute permission.
+					   I don't convert. */
 					disabled = 1;
+				} else if (!strcmp(cp, "<kernel>") ||
+					   !strcmp(cp, "use_profile") ||
+					   !strcmp(cp, "allow_capability") ||
+					   !strcmp(cp, "allow_signal") ||
+					   !strcmp(cp, "allow_network")) {
+					/* This entry is not pathname related
+					   permission. I don't convert. */
+					disabled = 1;
 				}
 			} else if (disabled) {
-				// Nothing to do.
-			} else if (check_second) {
-				check_second = 0;
-				if (*cp == '/' && * (strchr(cp, '\0') - 1) != '/') { /* Don't convert @path_group . */
-					/* This entry is for a program. I don't convert. */
-					disabled = 1;
-				}
-				goto check;
-			} else if (strcmp(cp, "if") == 0) {
+				/* Nothing to do. */
+			} else if (!strcmp(cp, "if")) {
 				/* Don't convert after condition part. */
 				disabled = 1;
-			} else if (!PathContainsPattern(cp)) {
-				int i;
-				struct path_info cp2;
-				cp2.name = cp;
-				fill_path_info(&cp2);
-				for (i = 1; i < argc; i++) {
-					if (PathMatchesToPattern(&cp2, &pattern_list[i])) {
-						cp = argv[i]; break;
-					}
-				}
+			} else if (!path_contains_pattern(cp)) {
+				cp = patternize(cp, argc, argv, pattern_list);
 			}
-			if (!first) putchar(' ');
+			if (!first)
+				putchar(' ');
 			first = 0;
 			printf("%s", cp);
 		}
Index: ccstools.src/findtemp.c
===================================================================
--- ccstools.src/findtemp.c	(リビジョン 1537)
+++ ccstools.src/findtemp.c	(作業コピー)
@@ -5,40 +5,53 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.2   2008/06/25
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
 
-int findtemp_main(int argc, char *argv[]) {
+int findtemp_main(int argc, char *argv[])
+{
 	const char **pattern_list = NULL;
 	int pattern_list_count = 0;
 	int i;
-	char buffer[16384], buffer2[sizeof(buffer)];
+	char buffer[16384];
+	char buffer2[sizeof(buffer)];
 	if (argc > 1) {
 		if (strcmp(argv[1], "--all")) {
 			printf("%s < domain_policy\n\n", argv[0]);
 			return 0;
 		}
 	}
-	while (memset(buffer, 0, sizeof(buffer)), fscanf(stdin, "%16380s", buffer) == 1) {
-		if (buffer[0] != '/') continue;
+	while (memset(buffer, 0, sizeof(buffer)),
+	       fscanf(stdin, "%16380s", buffer) == 1) {
+		char *cp;
+		if (buffer[0] != '/')
+			continue;
 		{
 			struct stat64 buf;
-			if (!decode(buffer, buffer2)) continue;
-			if (lstat64(buffer2, &buf) == 0) continue;
+			if (!decode(buffer, buffer2))
+				continue;
+			if (lstat64(buffer2, &buf) == 0)
+				continue;
 		}
 		for (i = 0; i < pattern_list_count; i++) {
-			if (strcmp(pattern_list[i], buffer) == 0) break;
+			if (!strcmp(pattern_list[i], buffer))
+				break;
 		}
-		if (i < pattern_list_count) continue;
-		if ((pattern_list = (const char **) realloc(pattern_list, sizeof(const char *) * (pattern_list_count + 1))) == NULL ||
-			(pattern_list[pattern_list_count++] = strdup(buffer)) == NULL) {
-			fprintf(stderr, "Out of memory.\n");
-			exit(1);
-		}
+		if (i < pattern_list_count)
+			continue;
+		pattern_list = realloc(pattern_list, sizeof(const char *) *
+				       (pattern_list_count + 1));
+		if (!pattern_list)
+			out_of_memory();
+		cp = strdup(buffer);
+		if (!cp)
+			out_of_memory();
+		pattern_list[pattern_list_count++] = cp;
 	}
 	qsort(pattern_list, pattern_list_count, sizeof(char *), string_compare);
-	for (i = 0; i < pattern_list_count; i++) printf("%s\n", pattern_list[i]);
+	for (i = 0; i < pattern_list_count; i++)
+		printf("%s\n", pattern_list[i]);
 	return 0;
 }
Index: ccstools.src/ccstree.c
===================================================================
--- ccstools.src/ccstree.c	(リビジョン 1537)
+++ ccstools.src/ccstree.c	(作業コピー)
@@ -3,63 +3,76 @@
  *
  * TOMOYO Linux's utilities.
  *
- * Copyright (C) 2005-2007  NTT DATA CORPORATION
+ * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.5.0   2007/09/20
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
 
-static pid_t GetPPID(const pid_t pid) {
+static pid_t GetPPID(const pid_t pid)
+{
 	char buffer[1024];
 	FILE *fp;
 	pid_t ppid = 1;
 	memset(buffer, 0, sizeof(buffer));
 	snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
-	if ((fp = fopen(buffer, "r")) != NULL) {
-		while (memset(buffer, 0, sizeof(buffer)), fgets(buffer, sizeof(buffer) - 1, fp)) {
-			if (sscanf(buffer, "PPid: %u", &ppid) == 1) break;
+	fp = fopen(buffer, "r");
+	if (fp) {
+		while (memset(buffer, 0, sizeof(buffer)),
+		       fgets(buffer, sizeof(buffer) - 1, fp)) {
+			if (sscanf(buffer, "PPid: %u", &ppid) == 1)
+				break;
 		}
 		fclose(fp);
 	}
 	return ppid;
 }
 
-static char *GetName(const pid_t pid) {
+static char *GetName(const pid_t pid)
+{
 	char buffer[1024];
 	FILE *fp;
 	memset(buffer, 0, sizeof(buffer));
 	snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
-	if ((fp = fopen(buffer, "r")) != NULL) {
-		while (memset(buffer, 0, sizeof(buffer)), fgets(buffer, sizeof(buffer) - 1, fp)) {
-			if (strncmp(buffer, "Name:", 5) == 0) {
+	fp = fopen(buffer, "r");
+	if (fp) {
+		while (memset(buffer, 0, sizeof(buffer)),
+		       fgets(buffer, sizeof(buffer) - 1, fp)) {
+			if (!strncmp(buffer, "Name:", 5)) {
 				char *cp = buffer + 5;
-				while (*cp == ' ' || *cp == '\t') cp++;
+				while (*cp == ' ' || *cp == '\t')
+					cp++;
 				memmove(buffer, cp, strlen(cp) + 1);
-				if ((cp = strchr(buffer, '\n')) != NULL) *cp = '\0';
+				cp = strchr(buffer, '\n');
+				if (cp)
+					*cp = '\0';
 				break;
 			}
 		}
 		fclose(fp);
-		if (buffer[0]) return strdup(buffer);
+		if (buffer[0])
+			return strdup(buffer);
 	}
 	return NULL;
 }
 
 static int status_fd = EOF;
 
-static const char *ReadInfo(const pid_t pid, int *profile) {
+static const char *ReadInfo(const pid_t pid, int *profile)
+{
 	char *cp; /* caller must use get()/put(). */
 	memset(shared_buffer, 0, shared_buffer_len);
 	snprintf(shared_buffer, shared_buffer_len - 1, "%d\n", pid);
 	write(status_fd, shared_buffer, strlen(shared_buffer));
 	memset(shared_buffer, 0, shared_buffer_len);
 	read(status_fd, shared_buffer, shared_buffer_len - 1);
-	if ((cp = strchr(shared_buffer, ' ')) != NULL) {
+	cp = strchr(shared_buffer, ' ');
+	if (cp) {
 		*profile = atoi(cp + 1);
-		if ((cp = strchr(cp + 1, ' ')) != NULL) {
+		cp = strchr(cp + 1, ' ');
+		if (cp)
 			return cp + 1;
-		}
 	}
 	*profile = -1;
 	return "<UNKNOWN>";
@@ -68,38 +81,46 @@
 static struct task_entry *task_list = NULL;
 static int task_list_len = 0;
 
-static void Dump(const pid_t pid, const int depth) {
+static void Dump(const pid_t pid, const int depth)
+{
 	int i;
 	for (i = 0; i < task_list_len; i++) {
 		const char *info;
 		char *name;
-		int j, profile;
-		if (pid != task_list[i].pid) continue;
+		int j;
+		int profile;
+		if (pid != task_list[i].pid)
+			continue;
 		name = GetName(pid);
 		get();
 		info = ReadInfo(pid, &profile);
 		printf("%3d", profile);
-		for (j = 0; j < depth - 1; j++) printf("    ");
-		for (; j < depth; j++) printf("  +-");
+		for (j = 0; j < depth - 1; j++)
+			printf("    ");
+		for (; j < depth; j++)
+			printf("  +-");
 		printf(" %s (%u) %s\n", name, pid, info);
 		put();
 		free(name);
 		task_list[i].done = 1;
 	}
 	for (i = 0; i < task_list_len; i++) {
-		if (pid != task_list[i].ppid) continue;
+		if (pid != task_list[i].ppid)
+			continue;
 		Dump(task_list[i].pid, depth + 1);
 	}
 }
 
-static void DumpUnprocessed(void) {
+static void DumpUnprocessed(void)
+{
 	int i;
 	for (i = 0; i < task_list_len; i++) {
 		const char *info;
 		char *name;
 		int profile;
 		const pid_t pid = task_list[i].pid;
-		if (task_list[i].done) continue;
+		if (task_list[i].done)
+			continue;
 		name = GetName(task_list[i].pid);
 		get();
 		info = ReadInfo(pid, &profile);
@@ -110,11 +131,13 @@
 	}
 }
 
-int ccstree_main(int argc, char *argv[]) {
+int ccstree_main(int argc, char *argv[])
+{
 	const char *policy_file = proc_policy_process_status;
 	static int show_all = 0;
 	if (access(proc_policy_dir, F_OK)) {
-		fprintf(stderr, "You can't use this command for this kernel.\n");
+		fprintf(stderr, "You can't use this command "
+			"for this kernel.\n");
 		return 1;
 	}
 	if (argc > 1) {
@@ -125,30 +148,39 @@
 			return 0;
 		}
 	}
-	if ((status_fd = open(policy_file, O_RDWR)) == EOF) {
+	status_fd = open(policy_file, O_RDWR);
+	if (status_fd == EOF) {
 		fprintf(stderr, "Can't open %s\n", policy_file);
 		return 1;
 	}
 	{
 		struct dirent **namelist;
-		int i, n = scandir("/proc/", &namelist, 0, 0);
+		int i;
+		int n = scandir("/proc/", &namelist, 0, 0);
 		for (i = 0; i < n; i++) {
 			pid_t pid;
-			if (sscanf(namelist[i]->d_name, "%u", &pid) == 1) {
-				char buffer[128], test[16];
-				memset(buffer, 0, sizeof(buffer));
-				snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/exe", pid);
-				if (show_all || readlink(buffer, test, sizeof(test)) > 0) {
-					task_list = (struct task_entry *) realloc(task_list, (task_list_len + 1) * sizeof(struct task_entry));
-					task_list[task_list_len].pid = pid;
-					task_list[task_list_len].ppid = GetPPID(pid);
-					task_list[task_list_len].done = 0;
-					task_list_len++;
-				}
+			char buffer[128];
+			char test[16];
+			if (sscanf(namelist[i]->d_name, "%u", &pid) != 1)
+				goto skip;
+			memset(buffer, 0, sizeof(buffer));
+			snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/exe",
+				 pid);
+			if (show_all ||
+			    readlink(buffer, test, sizeof(test)) > 0) {
+				task_list = realloc(task_list,
+						    (task_list_len + 1) *
+						    sizeof(struct task_entry));
+				task_list[task_list_len].pid = pid;
+				task_list[task_list_len].ppid = GetPPID(pid);
+				task_list[task_list_len].done = 0;
+				task_list_len++;
 			}
+skip:
 			free((void *) namelist[i]);
 		}
-		if (n >= 0) free((void *) namelist);
+		if (n >= 0)
+			free((void *) namelist);
 	}
 	Dump(1, 0);
 	DumpUnprocessed();
Index: ccstools.src/ccstools.c
===================================================================
--- ccstools.src/ccstools.c	(リビジョン 1537)
+++ ccstools.src/ccstools.c	(作業コピー)
@@ -5,50 +5,102 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.4+   2008/09/04
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
 
 /***** UTILITY FUNCTIONS START *****/
 
-void OutOfMemory(void) {
+void out_of_memory(void)
+{
 	fprintf(stderr, "Out of memory. Aborted.\n");
 	exit(1);
 }
 
-void NormalizeLine(unsigned char *line) {
-	unsigned char *sp = line, *dp = line;
+bool str_starts(char *str, const const char *begin)
+{
+	const int len = strlen(begin);
+	if (strncmp(str, begin, len))
+		return 0;
+	memmove(str, str + len, strlen(str + len) + 1);
+	return 1;
+}
+
+static bool is_byte_range(const char *str)
+{
+	return *str >= '0' && *str++ <= '3' &&
+		*str >= '0' && *str++ <= '7' &&
+		*str >= '0' && *str <= '7';
+}
+
+static bool is_decimal(const char c)
+{
+	return c >= '0' && c <= '9';
+}
+
+static bool is_hexadecimal(const char c)
+{
+	return (c >= '0' && c <= '9') ||
+		(c >= 'A' && c <= 'F') ||
+		(c >= 'a' && c <= 'f');
+}
+
+static bool is_alphabet_char(const char c)
+{
+	return (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');
+}
+
+static u8 make_byte(const u8 c1, const u8 c2, const u8 c3)
+{
+	return ((c1 - '0') << 6) + ((c2 - '0') << 3) + (c3 - '0');
+}
+
+void normalize_line(unsigned char *line)
+{
+	unsigned char *sp = line;
+	unsigned char *dp = line;
 	int first = 1;
-	while (*sp && (*sp <= 32 || 127 <= *sp)) sp++;
+	while (*sp && (*sp <= 32 || 127 <= *sp))
+		sp++;
 	while (*sp) {
-		if (!first) *dp++ = ' ';
+		if (!first)
+			*dp++ = ' ';
 		first = 0;
-		while (32 < *sp && *sp < 127) *dp++ = *sp++;
-		while (*sp && (*sp <= 32 || 127 <= *sp)) sp++;
+		while (32 < *sp && *sp < 127)
+			*dp++ = *sp++;
+		while (*sp && (*sp <= 32 || 127 <= *sp))
+			sp++;
 	}
 	*dp = '\0';
 }
 
 /* Copied from kernel source. */
-static inline unsigned long partial_name_hash(unsigned long c, unsigned long prevhash) {
+static inline unsigned long partial_name_hash(unsigned long c,
+					      unsigned long prevhash) {
 	return (prevhash + (c << 4) + (c >> 4)) * 11;
 }
 
 /* Copied from kernel source. */
-static inline unsigned int full_name_hash(const unsigned char *name, unsigned int len) {
+static inline unsigned int full_name_hash(const unsigned char *name,
+					  unsigned int len) {
 	unsigned long hash = 0;
-	while (len--) hash = partial_name_hash(*name++, hash);
+	while (len--)
+		hash = partial_name_hash(*name++, hash);
 	return (unsigned int) hash;
 }
 
-static char *alloc_element(const unsigned int size) {
+static char *alloc_element(const unsigned int size)
+{
 	static char *buf = NULL;
 	static unsigned int buf_used_len = PAGE_SIZE;
 	char *ptr = NULL;
-	if (size > PAGE_SIZE) return NULL;
+	if (size > PAGE_SIZE)
+		return NULL;
 	if (buf_used_len + size > PAGE_SIZE) {
-		if ((ptr = malloc(PAGE_SIZE)) == NULL) OutOfMemory();
+		ptr = malloc(PAGE_SIZE);
+		if (!ptr)
+			out_of_memory();
 		buf = ptr;
 		memset(buf, 0, PAGE_SIZE);
 		buf_used_len = size;
@@ -57,37 +109,55 @@
 		int i;
 		ptr = buf + buf_used_len;
 		buf_used_len += size;
-		for (i = 0; i < size; i++) if (ptr[i]) OutOfMemory();
+		for (i = 0; i < size; i++)
+			if (ptr[i])
+				out_of_memory();
 	}
 	return ptr;
 }
 
-static int PathDepth(const char *pathname) {
+static int path_depth(const char *pathname)
+{
 	int i = 0;
 	if (pathname) {
 		char *ep = strchr(pathname, '\0');
 		if (pathname < ep--) {
-			if (*ep != '/') i++;
-			while (pathname <= ep) if (*ep-- == '/') i += 2;
+			if (*ep != '/')
+				i++;
+			while (pathname <= ep)
+				if (*ep-- == '/')
+					i += 2;
 		}
 	}
 	return i;
 }
 
-static int const_part_length(const char *filename) {
+static int const_part_length(const char *filename)
+{
 	int len = 0;
 	if (filename) {
 		char c;
 		while ((c = *filename++) != '\0') {
-			if (c != '\\') { len++; continue; }
+			if (c != '\\') {
+				len++;
+				continue;
+			}
 			switch (c = *filename++) {
 			case '\\':  /* "\\" */
-				len += 2; continue;
+				len += 2;
+				continue;
 			case '0':   /* "\ooo" */
 			case '1':
 			case '2':
 			case '3':
-				if ((c = *filename++) >= '0' && c <= '7' && (c = *filename++) >= '0' && c <= '7') { len += 4; continue; }
+				c = *filename++;
+				if (c < '0' || c > '7')
+					break;
+				c = *filename++;
+				if (c < '0' || c > '7')
+					break;
+				len += 4;
+				continue;
 			}
 			break;
 		}
@@ -95,35 +165,55 @@
 	return len;
 }
 
-int IsDomainDef(const unsigned char *domainname) {
-	return strncmp(domainname, ROOT_NAME, ROOT_NAME_LEN) == 0 && (domainname[ROOT_NAME_LEN] == '\0' || domainname[ROOT_NAME_LEN] == ' ');
+bool is_domain_def(const unsigned char *domainname)
+{
+	return strncmp(domainname, ROOT_NAME, ROOT_NAME_LEN) == 0 &&
+		(domainname[ROOT_NAME_LEN] == '\0'
+		 || domainname[ROOT_NAME_LEN] == ' ');
 }
 
-int IsCorrectDomain(const unsigned char *domainname) {
-	unsigned char c, d, e;
-	if (!domainname || strncmp(domainname, ROOT_NAME, ROOT_NAME_LEN)) goto out;
+bool is_correct_domain(const unsigned char *domainname)
+{
+	unsigned char c;
+	unsigned char d;
+	unsigned char e;
+	if (!domainname || strncmp(domainname, ROOT_NAME, ROOT_NAME_LEN))
+		goto out;
 	domainname += ROOT_NAME_LEN;
-	if (!*domainname) return 1;
+	if (!*domainname)
+		return 1;
 	do {
-		if (*domainname++ != ' ') goto out;
-		if (*domainname++ != '/') goto out;
-		while ((c = *domainname) != '\0' && c != ' ') {
+		if (*domainname++ != ' ')
+			goto out;
+		if (*domainname++ != '/')
+			goto out;
+		while (1) {
+			c = *domainname;
+			if (!c || c == ' ')
+				break;
 			domainname++;
 			if (c == '\\') {
-				switch ((c = *domainname++)) {
+				u8 f;
+				c = *domainname++;
+				switch (c) {
 				case '\\':  /* "\\" */
 					continue;
 				case '0':   /* "\ooo" */
 				case '1':
 				case '2':
 				case '3':
-					if ((d = *domainname++) >= '0' && d <= '7' && (e = *domainname++) >= '0' && e <= '7') {
-						const unsigned char f =
-							(((unsigned char) (c - '0')) << 6) +
-							(((unsigned char) (d - '0')) << 3) +
-							(((unsigned char) (e - '0')));
-						if (f && (f <= ' ' || f >= 127)) continue; /* pattern is not \000 */
-					}
+					d = *domainname++;
+					if (d < '0' || d > '7')
+						break;
+					e = *domainname++;
+					if (e < '0' || e > '7')
+						break;
+					f = (((u8) (c - '0')) << 6) +
+						(((u8) (d - '0')) << 3) +
+						(((u8) (e - '0')));
+					/* pattern is not \000 */
+					if (f && (f <= ' ' || f >= 127))
+						continue;
 				}
 				goto out;
 			} else if (c < ' ' || c >= 127) {
@@ -132,28 +222,41 @@
 		}
 	} while (*domainname);
 	return 1;
- out:
+out:
 	return 0;
 }
 
-void fprintf_encoded(FILE *fp, const char *pathname) {
+void fprintf_encoded(FILE *fp, const char *pathname)
+{
 	unsigned char c;
-	while ((c = * (const unsigned char *) pathname++) != 0) {
+	while (1) {
+		c = *(const unsigned char *) pathname++;
+		if (!c)
+			break;
 		if (c == '\\') {
 			fputc('\\', fp);
 			fputc('\\', fp);
 		} else if (c > 32 && c < 127) {
 			fputc(c, fp);
 		} else {
-			fprintf(fp, "\\%c%c%c", (c >> 6) + '0', ((c >> 3) & 7) + '0', (c & 7) + '0'); 
+			fprintf(fp, "\\%c%c%c", (c >> 6) + '0',
+				((c >> 3) & 7) + '0', (c & 7) + '0');
 		}
 	}
 }
 
-int decode(const char *ascii, char *bin) {
-	char c, d, e;
-	while ((c = *bin++ = *ascii++) != '\0') {
+int decode(const char *ascii, char *bin)
+{
+	char c;
+	char d;
+	char e;
+	while (1) {
+		c = *ascii++;
+		*bin++ = c;
+		if (!c)
+			break;
 		if (c == '\\') {
+			u8 f;
 			c = *ascii++;
 			switch (c) {
 			case '\\':      /* "\\" */
@@ -162,15 +265,18 @@
 			case '1':
 			case '2':
 			case '3':
-				if ((d = *ascii++) >= '0' && d <= '7' && (e = *ascii++) >= '0' && e <= '7') {
-					const unsigned char f =
-						(((unsigned char) (c - '0')) << 6) +
-						(((unsigned char) (d - '0')) << 3) +
-						(((unsigned char) (e - '0')));
-					if (f && (f <= ' ' || f >= 127)) {
-						*(bin - 1) = f;
-						continue; /* pattern is not \000 */
-					}
+				d = *ascii++;
+				if (d < '0' || d > '7')
+					break;
+				e = *ascii++;
+				if (e < '0' || e > '7')
+					break;
+				f = (u8) ((c - '0') << 6) +
+					(((u8) (d - '0')) << 3) +
+					(((u8) (e - '0')));
+				if (f && (f <= ' ' || f >= 127)) {
+					*(bin - 1) = f;
+					continue; /* pattern is not \000 */
 				}
 			}
 			return 0;
@@ -181,25 +287,36 @@
 	return 1;
 }
 
-void RemoveHeader(char *line, const int len) {
-	memmove(line, line + len, strlen(line + len) + 1); 
+void remove_header(char *line, const int len)
+{
+	memmove(line, line + len, strlen(line + len) + 1);
 }
 
-int IsCorrectPath(const char *filename, const int start_type, const int pattern_type, const int end_type) {
-	int contains_pattern = 0;
-	char c, d, e;
-	if (!filename) goto out;
+bool is_correct_path(const char *filename, const s8 start_type,
+		     const s8 pattern_type, const s8 end_type)
+{
+	bool contains_pattern = false;
+	unsigned char c;
+	unsigned char d;
+	unsigned char e;
+	if (!filename)
+		goto out;
 	c = *filename;
 	if (start_type == 1) { /* Must start with '/' */
-		if (c != '/') goto out;
+		if (c != '/')
+			goto out;
 	} else if (start_type == -1) { /* Must not start with '/' */
-		if (c == '/') goto out;
+		if (c == '/')
+			goto out;
 	}
-	if (c) c = * (strchr(filename, '\0') - 1);
+	if (c)
+		c = *(strchr(filename, '\0') - 1);
 	if (end_type == 1) { /* Must end with '/' */
-		if (c != '/') goto out;
+		if (c != '/')
+			goto out;
 	} else if (end_type == -1) { /* Must not end with '/' */
-		if (c == '/') goto out;
+		if (c == '/')
+			goto out;
 	}
 	while ((c = *filename++) != '\0') {
 		if (c == '\\') {
@@ -216,20 +333,23 @@
 			case 'a':   /* "\a" */
 			case 'A':   /* "\A" */
 			case '-':   /* "\-" */
-				if (pattern_type == -1) break; /* Must not contain pattern */
-				contains_pattern = 1;
+				if (pattern_type == -1)
+					break; /* Must not contain pattern */
+				contains_pattern = true;
 				continue;
 			case '0':   /* "\ooo" */
 			case '1':
 			case '2':
 			case '3':
-				if ((d = *filename++) >= '0' && d <= '7' && (e = *filename++) >= '0' && e <= '7') {
-					const unsigned char f =
-						(((unsigned char) (c - '0')) << 6) +
-						(((unsigned char) (d - '0')) << 3) +
-						(((unsigned char) (e - '0')));
-					if (f && (f <= ' ' || f >= 127)) continue; /* pattern is not \000 */
-				}
+				d = *filename++;
+				if (d < '0' || d > '7')
+					break;
+				e = *filename++;
+				if (e < '0' || e > '7')
+					break;
+				c = make_byte(c, d, e);
+				if (c && (c <= ' ' || c >= 127))
+					continue; /* pattern is not \000 */
 			}
 			goto out;
 		} else if (c <= ' ' || c >= 127) {
@@ -237,127 +357,207 @@
 		}
 	}
 	if (pattern_type == 1) { /* Must contain pattern */
-		if (!contains_pattern) goto out;
+		if (!contains_pattern)
+			goto out;
 	}
-	return 1;
+	return true;
  out:
-	return 0;
+	return false;
 }
 
-static int FileMatchesToPattern2(const char *filename, const char *filename_end, const char *pattern, const char *pattern_end) {
+static bool file_matches_pattern2(const char *filename,
+				  const char *filename_end,
+				  const char *pattern,
+				  const char *pattern_end)
+{
 	while (filename < filename_end && pattern < pattern_end) {
+		char c;
 		if (*pattern != '\\') {
-			if (*filename++ != *pattern++) return 0;
-		} else {
-			char c = *filename;
-			pattern++;
-			switch (*pattern) {
-			case '?':
-				if (c == '/') {
-					return 0;
-				} else if (c == '\\') {
-					if ((c = filename[1]) == '\\') {
-						filename++; /* safe because filename is \\ */
-					} else if (c >= '0' && c <= '3' && (c = filename[2]) >= '0' && c <= '7' && (c = filename[3]) >= '0' && c <= '7') {
-						filename += 3; /* safe because filename is \ooo */
-					} else {
-						return 0;
-					}
-				}
+			if (*filename++ != *pattern++)
+				return false;
+			continue;
+		}
+		c = *filename;
+		pattern++;
+		switch (*pattern) {
+			int i;
+			int j;
+		case '?':
+			if (c == '/') {
+				return false;
+			} else if (c == '\\') {
+				if (filename[1] == '\\')
+					filename++;
+				else if (is_byte_range(filename + 1))
+					filename += 3;
+				else
+					return false;
+			}
+			break;
+		case '\\':
+			if (c != '\\')
+				return false;
+			if (*++filename != '\\')
+				return false;
+			break;
+		case '+':
+			if (!is_decimal(c))
+				return false;
+			break;
+		case 'x':
+			if (!is_hexadecimal(c))
+				return false;
+			break;
+		case 'a':
+			if (!is_alphabet_char(c))
+				return false;
+			break;
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+			if (c == '\\' && is_byte_range(filename + 1)
+			    && strncmp(filename + 1, pattern, 3) == 0) {
+				filename += 3;
+				pattern += 2;
 				break;
-			case '\\':
-				if (c != '\\') return 0;
-				if (*++filename != '\\') return 0; /* safe because *filename != '\0' */
-				break;
-			case '+':
-				if (c < '0' || c > '9') return 0;
-				break;
-			case 'x':
-				if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) return 0;
-				break;
-			case 'a':
-				if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))) return 0;
-				break;
-			case '0':
-			case '1':
-			case '2':
-			case '3':
-				if (c == '\\' && (c = filename[1]) >= '0' && c <= '3' && c == *pattern
-					&& (c = filename[2]) >= '0' && c <= '7' && c == pattern[1]
-					&& (c = filename[3]) >= '0' && c <= '7' && c == pattern[2]) {
-					filename += 3; /* safe because filename is \ooo */
-					pattern += 2; /* safe because pattern is \ooo  */
+			}
+			return false; /* Not matched. */
+		case '*':
+		case '@':
+			for (i = 0; i <= filename_end - filename; i++) {
+				if (file_matches_pattern2(filename + i,
+							  filename_end,
+							  pattern + 1,
+							  pattern_end))
+					return true;
+				c = filename[i];
+				if (c == '.' && *pattern == '@')
 					break;
-				}
-				return 0; /* Not matched. */
-			case '*':
-			case '@':
-				{
-					int i;
-					for (i = 0; i <= filename_end - filename; i++) {
-						if (FileMatchesToPattern2(filename + i, filename_end, pattern + 1, pattern_end)) return 1;
-						if ((c = filename[i]) == '.' && *pattern == '@') break;
-						if (c == '\\') {
-							if ((c = filename[i + 1]) == '\\') {
-								i++; /* safe because filename is \\ */
-							} else if (c >= '0' && c <= '3' && (c = filename[i + 2]) >= '0' && c <= '7' && (c = filename[i + 3]) >= '0' && c <= '7') {
-								i += 3; /* safe because filename is \ooo */
-							} else {
-								break; /* Bad pattern. */
-							}
-						}
-					}
-					return 0; /* Not matched. */
-				}
-			default:
-				{
-					int i, j = 0;
-					if ((c = *pattern) == '$') {
-						while ((c = filename[j]) >= '0' && c <= '9') j++;
-					} else if (c == 'X') {
-						while (((c = filename[j]) >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')) j++;
-					} else if (c == 'A') {
-						while (((c = filename[j]) >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) j++;
-					}
-					for (i = 1; i <= j; i++) {
-						if (FileMatchesToPattern2(filename + i, filename_end, pattern + 1, pattern_end)) return 1;
-					}
-				}
-				return 0; /* Not matched or bad pattern. */
+				if (c != '\\')
+					continue;
+				if (filename[i + 1] == '\\')
+					i++;
+				else if (is_byte_range(filename + i + 1))
+					i += 3;
+				else
+					break; /* Bad pattern. */
 			}
-			filename++; /* safe because *filename != '\0' */
-			pattern++; /* safe because *pattern != '\0' */
+			return false; /* Not matched. */
+		default:
+			j = 0;
+			c = *pattern;
+			if (c == '$') {
+				while (is_decimal(filename[j]))
+					j++;
+			} else if (c == 'X') {
+				while (is_hexadecimal(filename[j]))
+					j++;
+			} else if (c == 'A') {
+				while (is_alphabet_char(filename[j]))
+					j++;
+			}
+			for (i = 1; i <= j; i++) {
+				if (file_matches_pattern2(filename + i,
+							  filename_end,
+							  pattern + 1,
+							  pattern_end))
+					return true;
+			}
+			return false; /* Not matched or bad pattern. */
 		}
+		filename++;
+		pattern++;
 	}
-	while (*pattern == '\\' && (*(pattern + 1) == '*' || *(pattern + 1) == '@')) pattern += 2;
-	return (filename == filename_end && pattern == pattern_end);
+	while (*pattern == '\\' &&
+	       (*(pattern + 1) == '*' || *(pattern + 1) == '@'))
+		pattern += 2;
+	return filename == filename_end && pattern == pattern_end;
 }
 
-int FileMatchesToPattern(const char *filename, const char *filename_end, const char *pattern, const char *pattern_end) {
+bool file_matches_pattern(const char *filename,
+			  const char *filename_end,
+			  const char *pattern,
+			  const char *pattern_end)
+{
 	const char *pattern_start = pattern;
-	int first = 1;
-	int result;
+	bool first = true;
+	bool result;
 	while (pattern < pattern_end - 1) {
-		if (*pattern++ != '\\' || *pattern++ != '-') continue;
-		result = FileMatchesToPattern2(filename, filename_end, pattern_start, pattern - 2);
-		if (first) result = !result;
-		if (result) return 0;
-		first = 0;
+		/* Split at "\-" pattern. */
+		if (*pattern++ != '\\' || *pattern++ != '-')
+			continue;
+		result = file_matches_pattern2(filename, filename_end,
+					       pattern_start, pattern - 2);
+		if (first)
+			result = !result;
+		if (result)
+			return false;
+		first = false;
 		pattern_start = pattern;
 	}
-	result = FileMatchesToPattern2(filename, filename_end, pattern_start, pattern_end);
+	result = file_matches_pattern2(filename, filename_end,
+				       pattern_start, pattern_end);
 	return first ? result : !result;
 }
 
-int string_compare(const void *a, const void *b) {
-	return strcmp(* (char **) a, * (char **) b);
+bool path_matches_pattern(const struct path_info *filename,
+			  const struct path_info *pattern)
+{
+	/*
+	  if (!filename || !pattern)
+	  return false;
+	*/
+	const char *f = filename->name;
+	const char *p = pattern->name;
+	const int len = pattern->const_len;
+	/* If @pattern doesn't contain pattern, I can use strcmp(). */
+	if (!pattern->is_patterned)
+		return !pathcmp(filename, pattern);
+	/* Dont compare if the number of '/' differs. */
+	if (filename->depth != pattern->depth)
+		return false;
+	/* Compare the initial length without patterns. */
+	if (strncmp(f, p, len))
+		return false;
+	f += len;
+	p += len;
+	/* Main loop. Compare each directory component. */
+	while (*f && *p) {
+		const char *f_delimiter = strchr(f, '/');
+		const char *p_delimiter = strchr(p, '/');
+		if (!f_delimiter)
+			f_delimiter = strchr(f, '\0');
+		if (!p_delimiter)
+			p_delimiter = strchr(p, '\0');
+		if (!file_matches_pattern(f, f_delimiter, p, p_delimiter))
+			return false;
+		f = f_delimiter;
+		if (*f)
+			f++;
+		p = p_delimiter;
+		if (*p)
+			p++;
+	}
+	/* Ignore trailing "\*" and "\@" in @pattern. */
+	while (*p == '\\' &&
+	       (*(p + 1) == '*' || *(p + 1) == '@'))
+		p += 2;
+	return !*f && !*p;
 }
 
-int pathcmp(const struct path_info *a, const struct path_info *b) {
+int string_compare(const void *a, const void *b)
+{
+	return strcmp(*(char **) a, *(char **) b);
+}
+
+int pathcmp(const struct path_info *a, const struct path_info *b)
+{
 	return a->hash != b->hash || strcmp(a->name, b->name);
 }
 
-void fill_path_info(struct path_info *ptr) {
+void fill_path_info(struct path_info *ptr)
+{
 	const char *name = ptr->name;
 	const int len = strlen(name);
 	ptr->total_len = len;
@@ -365,21 +565,25 @@
 	ptr->is_dir = len && (name[len - 1] == '/');
 	ptr->is_patterned = (ptr->const_len < len);
 	ptr->hash = full_name_hash(name, len);
-	ptr->depth = PathDepth(name);
+	ptr->depth = path_depth(name);
 }
 
-const struct path_info *SaveName(const char *name) {
+const struct path_info *savename(const char *name)
+{
 	static struct free_memory_block_list fmb_list = { NULL, NULL, 0 };
-	static struct savename_entry name_list[SAVENAME_MAX_HASH]; /* The list of names. */
-	struct savename_entry *ptr, *prev = NULL;
+	/* The list of names. */
+	static struct savename_entry name_list[SAVENAME_MAX_HASH];
+	struct savename_entry *ptr;
+	struct savename_entry *prev = NULL;
 	unsigned int hash;
 	struct free_memory_block_list *fmb = &fmb_list;
 	int len;
 	static int first_call = 1;
-	if (!name) return NULL;
+	if (!name)
+		return NULL;
 	len = strlen(name) + 1;
 	if (len > CCS_MAX_PATHNAME_LEN) {
-		fprintf(stderr, "ERROR: Name too long for SaveName().\n");
+		fprintf(stderr, "ERROR: Name too long for savename().\n");
 		return NULL;
 	}
 	hash = full_name_hash((const unsigned char *) name, len - 1);
@@ -391,26 +595,38 @@
 			name_list[i].entry.name = "/";
 			fill_path_info(&name_list[i].entry);
 		}
-		if (CCS_MAX_PATHNAME_LEN > PAGE_SIZE) abort();
+		if (CCS_MAX_PATHNAME_LEN > PAGE_SIZE)
+			abort();
 	}
 	ptr = &name_list[hash % SAVENAME_MAX_HASH];
 	while (ptr) {
-		if (hash == ptr->entry.hash && strcmp(name, ptr->entry.name) == 0) goto out;
-		prev = ptr; ptr = ptr->next;
+		if (hash == ptr->entry.hash && !strcmp(name, ptr->entry.name))
+			goto out;
+		prev = ptr;
+		ptr = ptr->next;
 	}
 	while (len > fmb->len) {
+		char *cp;
 		if (fmb->next) {
 			fmb = fmb->next;
-		} else {
-			char *cp;
-			if ((cp = (char *) malloc(PAGE_SIZE)) == NULL || (fmb->next = (struct free_memory_block_list *) alloc_element(sizeof(struct free_memory_block_list))) == NULL) OutOfMemory();
-			memset(cp, 0, PAGE_SIZE);
-			fmb = fmb->next;
-			fmb->ptr = cp;
-			fmb->len = PAGE_SIZE;
+			continue;
 		}
+		cp = malloc(PAGE_SIZE);
+		if (!cp)
+			out_of_memory();
+		fmb->next = (struct free_memory_block_list *)
+			alloc_element(sizeof(struct free_memory_block_list));
+		if (!fmb->next)
+			out_of_memory();
+		memset(cp, 0, PAGE_SIZE);
+		fmb = fmb->next;
+		fmb->ptr = cp;
+		fmb->len = PAGE_SIZE;
 	}
-	if ((ptr = (struct savename_entry *) alloc_element(sizeof(struct savename_entry))) == NULL) OutOfMemory();
+	ptr = (struct savename_entry *)
+		alloc_element(sizeof(struct savename_entry));
+	if (!ptr)
+		out_of_memory();
 	memset(ptr, 0, sizeof(struct savename_entry));
 	ptr->entry.name = fmb->ptr;
 	memmove(fmb->ptr, name, len);
@@ -420,137 +636,219 @@
 	prev->next = ptr; /* prev != NULL because name_list is not empty. */
 	if (fmb->len == 0) {
 		struct free_memory_block_list *ptr = &fmb_list;
-		while (ptr->next != fmb) ptr = ptr->next; ptr->next = fmb->next;
+		while (ptr->next != fmb)
+			ptr = ptr->next;
+		ptr->next = fmb->next;
 	}
- out:
+out:
 	return ptr ? &ptr->entry : NULL;
 }
 
 char *shared_buffer = NULL;
 static int buffer_lock = 0;
-void get(void) {
-	if (buffer_lock) OutOfMemory();
-	if (!shared_buffer && (shared_buffer = malloc(shared_buffer_len)) == NULL) OutOfMemory();
+
+void get(void)
+{
+	if (buffer_lock)
+		out_of_memory();
+	if (!shared_buffer) {
+		shared_buffer = malloc(shared_buffer_len);
+		if (!shared_buffer)
+			out_of_memory();
+	}
 	buffer_lock++;
 }
-void put(void) {
-	if (buffer_lock != 1) OutOfMemory();
+
+void put(void)
+{
+	if (buffer_lock != 1)
+		out_of_memory();
 	buffer_lock--;
 }
-int freadline(FILE *fp) {
+
+bool freadline(FILE *fp)
+{
 	char *cp;
 	memset(shared_buffer, 0, shared_buffer_len);
-	if (fgets(shared_buffer, shared_buffer_len - 1, fp) == NULL ||
-		(cp = strchr(shared_buffer, '\n')) == NULL) return 0;
+	if (!fgets(shared_buffer, shared_buffer_len - 1, fp))
+		return 0;
+	cp = strchr(shared_buffer, '\n');
+	if (!cp)
+		return 0;
 	*cp = '\0';
-	NormalizeLine(shared_buffer);
+	normalize_line(shared_buffer);
 	return 1;
 }
 
 /***** UTILITY FUNCTIONS END *****/
 
-extern int sortpolicy_main(int argc, char *argv[]);
-extern int setprofile_main(int argc, char *argv[]);
-extern int setlevel_main(int argc, char *argv[]);
-extern int savepolicy_main(int argc, char *argv[]);
-extern int pathmatch_main(int argc, char *argv[]);
-extern int loadpolicy_main(int argc, char *argv[]);
-extern int ldwatch_main(int argc, char *argv[]);
-extern int findtemp_main(int argc, char *argv[]);
-extern int editpolicy_main(int argc, char *argv[]);
-extern int checkpolicy_main(int argc, char *argv[]);
-extern int ccstree_main(int argc, char *argv[]);
-extern int ccsqueryd_main(int argc, char *argv[]);
-extern int ccsauditd_main(int argc, char *argv[]);
-extern int patternize_main(int argc, char *argv[]);
-
 const char *proc_policy_dir           = "/proc/ccs/",
 	*disk_policy_dir              = "/etc/ccs/",
 	*proc_policy_domain_policy    = "/proc/ccs/domain_policy",
 	*disk_policy_domain_policy    = "/etc/ccs/domain_policy.conf",
+	*base_policy_domain_policy    = "/etc/ccs/domain_policy.base",
 	*proc_policy_exception_policy = "/proc/ccs/exception_policy",
 	*disk_policy_exception_policy = "/etc/ccs/exception_policy.conf",
+	*base_policy_exception_policy = "/etc/ccs/exception_policy.base",
 	*proc_policy_system_policy    = "/proc/ccs/system_policy",
 	*disk_policy_system_policy    = "/etc/ccs/system_policy.conf",
+	*base_policy_system_policy    = "/etc/ccs/system_policy.base",
 	*proc_policy_profile          = "/proc/ccs/profile",
 	*disk_policy_profile          = "/etc/ccs/profile.conf",
+	*base_policy_profile          = "/etc/ccs/profile.base",
 	*proc_policy_manager          = "/proc/ccs/manager",
 	*disk_policy_manager          = "/etc/ccs/manager.conf",
+	*base_policy_manager          = "/etc/ccs/manager.base",
 	*proc_policy_query            = "/proc/ccs/query",
 	*proc_policy_grant_log        = "/proc/ccs/grant_log",
 	*proc_policy_reject_log       = "/proc/ccs/reject_log",
 	*proc_policy_domain_status    = "/proc/ccs/.domain_status",
 	*proc_policy_process_status   = "/proc/ccs/.process_status";
 
-int main(int argc, char *argv[]) {
+int main(int argc, char *argv[])
+{
 	const char *argv0 = argv[0];
 	if (!argv0) {
 		fprintf(stderr, "Function not specified.\n");
 		return 1;
 	}
 	if (access("/sys/kernel/security/tomoyo/", F_OK) == 0) {
-		proc_policy_dir              = "/sys/kernel/security/tomoyo/";
-		disk_policy_dir              = "/etc/tomoyo/";
-		proc_policy_domain_policy    = "/sys/kernel/security/tomoyo/domain_policy";
-		disk_policy_domain_policy    = "/etc/tomoyo/domain_policy.conf";
-		proc_policy_exception_policy = "/sys/kernel/security/tomoyo/exception_policy";
-		disk_policy_exception_policy = "/etc/tomoyo/exception_policy.conf";
-		proc_policy_system_policy    = "/sys/kernel/security/tomoyo/system_policy";
-		disk_policy_system_policy    = "/etc/tomoyo/system_policy.conf";
-		proc_policy_profile          = "/sys/kernel/security/tomoyo/profile";
-		disk_policy_profile          = "/etc/tomoyo/profile.conf";
-		proc_policy_manager          = "/sys/kernel/security/tomoyo/manager";
-		disk_policy_manager          = "/etc/tomoyo/manager.conf";
-		proc_policy_query            = "/sys/kernel/security/tomoyo/query";
-		proc_policy_grant_log        = "/sys/kernel/security/tomoyo/grant_log";
-		proc_policy_reject_log       = "/sys/kernel/security/tomoyo/reject_log";
-		proc_policy_domain_status    = "/sys/kernel/security/tomoyo/.domain_status";
-		proc_policy_process_status   = "/sys/kernel/security/tomoyo/.process_status";
+		proc_policy_dir
+			= "/sys/kernel/security/tomoyo/";
+		disk_policy_dir
+			= "/etc/tomoyo/";
+		proc_policy_domain_policy
+			= "/sys/kernel/security/tomoyo/domain_policy";
+		disk_policy_domain_policy
+			= "/etc/tomoyo/domain_policy.conf";
+		base_policy_domain_policy
+			= "/etc/tomoyo/domain_policy.base";
+		proc_policy_exception_policy
+			= "/sys/kernel/security/tomoyo/exception_policy";
+		disk_policy_exception_policy
+			= "/etc/tomoyo/exception_policy.conf";
+		base_policy_exception_policy
+			= "/etc/tomoyo/exception_policy.base";
+		proc_policy_system_policy
+			= "/sys/kernel/security/tomoyo/system_policy";
+		disk_policy_system_policy
+			= "/etc/tomoyo/system_policy.conf";
+		base_policy_system_policy
+			= "/etc/tomoyo/system_policy.base";
+		proc_policy_profile
+			= "/sys/kernel/security/tomoyo/profile";
+		disk_policy_profile
+			= "/etc/tomoyo/profile.conf";
+		base_policy_profile
+			= "/etc/tomoyo/profile.base";
+		proc_policy_manager
+			= "/sys/kernel/security/tomoyo/manager";
+		disk_policy_manager
+			= "/etc/tomoyo/manager.conf";
+		base_policy_manager
+			= "/etc/tomoyo/manager.base";
+		proc_policy_query
+			= "/sys/kernel/security/tomoyo/query";
+		proc_policy_grant_log
+			= "/sys/kernel/security/tomoyo/grant_log";
+		proc_policy_reject_log
+			= "/sys/kernel/security/tomoyo/reject_log";
+		proc_policy_domain_status
+			= "/sys/kernel/security/tomoyo/.domain_status";
+		proc_policy_process_status
+			= "/sys/kernel/security/tomoyo/.process_status";
 	} else if (access("/proc/tomoyo/", F_OK) == 0) {
-		proc_policy_dir              = "/proc/tomoyo/";
-		disk_policy_dir              = "/etc/tomoyo/";
-		proc_policy_domain_policy    = "/proc/tomoyo/domain_policy";
-		disk_policy_domain_policy    = "/etc/tomoyo/domain_policy.conf";
-		proc_policy_exception_policy = "/proc/tomoyo/exception_policy";
-		disk_policy_exception_policy = "/etc/tomoyo/exception_policy.conf";
-		proc_policy_system_policy    = "/proc/tomoyo/system_policy";
-		disk_policy_system_policy    = "/etc/tomoyo/system_policy.conf";
-		proc_policy_profile          = "/proc/tomoyo/profile";
-		disk_policy_profile          = "/etc/tomoyo/profile.conf";
-		proc_policy_manager          = "/proc/tomoyo/manager";
-		disk_policy_manager          = "/etc/tomoyo/manager.conf";
-		proc_policy_query            = "/proc/tomoyo/query";
-		proc_policy_grant_log        = "/proc/tomoyo/grant_log";
-		proc_policy_reject_log       = "/proc/tomoyo/reject_log";
-		proc_policy_domain_status    = "/proc/tomoyo/.domain_status";
-		proc_policy_process_status   = "/proc/tomoyo/.process_status";
+		proc_policy_dir
+			= "/proc/tomoyo/";
+		disk_policy_dir
+			= "/etc/tomoyo/";
+		proc_policy_domain_policy
+			= "/proc/tomoyo/domain_policy";
+		disk_policy_domain_policy
+			= "/etc/tomoyo/domain_policy.conf";
+		base_policy_domain_policy
+			= "/etc/tomoyo/domain_policy.base";
+		proc_policy_exception_policy
+			= "/proc/tomoyo/exception_policy";
+		disk_policy_exception_policy
+			= "/etc/tomoyo/exception_policy.conf";
+		base_policy_exception_policy
+			= "/etc/tomoyo/exception_policy.base";
+		proc_policy_system_policy
+			= "/proc/tomoyo/system_policy";
+		disk_policy_system_policy
+			= "/etc/tomoyo/system_policy.conf";
+		base_policy_system_policy
+			= "/etc/tomoyo/system_policy.base";
+		proc_policy_profile
+			= "/proc/tomoyo/profile";
+		disk_policy_profile
+			= "/etc/tomoyo/profile.conf";
+		base_policy_profile
+			= "/etc/tomoyo/profile.base";
+		proc_policy_manager
+			= "/proc/tomoyo/manager";
+		disk_policy_manager
+			= "/etc/tomoyo/manager.conf";
+		base_policy_manager
+			= "/etc/tomoyo/manager.base";
+		proc_policy_query
+			= "/proc/tomoyo/query";
+		proc_policy_grant_log
+			= "/proc/tomoyo/grant_log";
+		proc_policy_reject_log
+			= "/proc/tomoyo/reject_log";
+		proc_policy_domain_status
+			= "/proc/tomoyo/.domain_status";
+		proc_policy_process_status
+			= "/proc/tomoyo/.process_status";
 	}
-	if (strrchr(argv0, '/')) argv0 = strrchr(argv0, '/') + 1;
+	if (strrchr(argv0, '/'))
+		argv0 = strrchr(argv0, '/') + 1;
 retry:
-	if (strcmp(argv0, "sortpolicy") == 0) return sortpolicy_main(argc, argv);
-	if (strcmp(argv0, "setprofile") == 0) return setprofile_main(argc, argv);
-	if (strcmp(argv0, "setlevel") == 0) return setlevel_main(argc, argv);
-	if (strcmp(argv0, "savepolicy") == 0) return savepolicy_main(argc, argv);
-	if (strcmp(argv0, "pathmatch") == 0) return pathmatch_main(argc, argv);
-	if (strcmp(argv0, "loadpolicy") == 0) return loadpolicy_main(argc, argv);
-	if (strcmp(argv0, "ld-watch") == 0) return ldwatch_main(argc, argv);
-	if (strcmp(argv0, "findtemp") == 0) return findtemp_main(argc, argv);
-	if (strcmp(argv0, "editpolicy") == 0 || strcmp(argv0, "editpolicy_offline") == 0) return editpolicy_main(argc, argv);
-	if (strcmp(argv0, "checkpolicy") == 0) return checkpolicy_main(argc, argv);
-	if (strcmp(argv0, "ccstree") == 0) return ccstree_main(argc, argv);
-	if (strcmp(argv0, "ccs-queryd") == 0) return ccsqueryd_main(argc, argv);
-	if (strcmp(argv0, "ccs-auditd") == 0) return ccsauditd_main(argc, argv);
-	if (strcmp(argv0, "patternize") == 0) return patternize_main(argc, argv);
+	if (strcmp(argv0, "sortpolicy") == 0)
+		return sortpolicy_main(argc, argv);
+	if (strcmp(argv0, "setprofile") == 0)
+		return setprofile_main(argc, argv);
+	if (strcmp(argv0, "setlevel") == 0)
+		return setlevel_main(argc, argv);
+	if (strcmp(argv0, "diffpolicy") == 0)
+		return diffpolicy_main(argc, argv);
+	if (strcmp(argv0, "savepolicy") == 0)
+		return savepolicy_main(argc, argv);
+	if (strcmp(argv0, "pathmatch") == 0)
+		return pathmatch_main(argc, argv);
+	if (strcmp(argv0, "loadpolicy") == 0)
+		return loadpolicy_main(argc, argv);
+	if (strcmp(argv0, "ld-watch") == 0)
+		return ldwatch_main(argc, argv);
+	if (strcmp(argv0, "findtemp") == 0)
+		return findtemp_main(argc, argv);
+	if (strcmp(argv0, "editpolicy") == 0 ||
+	    strcmp(argv0, "editpolicy_offline") == 0)
+		return editpolicy_main(argc, argv);
+	if (strcmp(argv0, "checkpolicy") == 0)
+		return checkpolicy_main(argc, argv);
+	if (strcmp(argv0, "ccstree") == 0)
+		return ccstree_main(argc, argv);
+	if (strcmp(argv0, "ccs-queryd") == 0)
+		return ccsqueryd_main(argc, argv);
+	if (strcmp(argv0, "ccs-auditd") == 0)
+		return ccsauditd_main(argc, argv);
+	if (strcmp(argv0, "patternize") == 0)
+		return patternize_main(argc, argv);
 	if (strncmp(argv0, "ccs-", 4) == 0) {
 		argv0 += 4;
 		goto retry;
 	}
 	/*
-	 * Unlike busybox, I don't use argv[1] if argv[0] is the name of this program
-	 * because it is dangerous to allow updating policies via unchecked argv[1].
-	 * You should use either "symbolic links with 'alias' directive" or "hard links".
+	 * Unlike busybox, I don't use argv[1] if argv[0] is the name of this
+	 * program because it is dangerous to allow updating policies via
+	 * unchecked argv[1].
+	 * You should use either "symbolic links with 'alias' directive" or
+	 * "hard links".
 	 */
-	printf("ccstools version 1.6.4+ build 2008/09/04\n");
+	printf("ccstools version 1.6.4+ build 2008/09/06\n");
 	fprintf(stderr, "Function %s not implemented.\n", argv0);
 	return 1;
 }
Index: ccstools.src/pathmatch.c
===================================================================
--- ccstools.src/pathmatch.c	(リビジョン 1537)
+++ ccstools.src/pathmatch.c	(作業コピー)
@@ -46,7 +46,7 @@
 	}
 	*dp = '\0';
 	//printf("Compare: %s %s\n", buffer, scandir_filter_current_part);
-	if (FileMatchesToPattern(buffer, dp, scandir_filter_current_part, strchr(scandir_filter_current_part, '\0'))) return 1;
+	if (file_matches_pattern(buffer, dp, scandir_filter_current_part, strchr(scandir_filter_current_part, '\0'))) return 1;
 	return 0;
 }
 
@@ -67,7 +67,7 @@
 				if (type == DT_DIR) {
 					const int len = strlen(path) + strlen(cp) + 4;
 					char *child_path = malloc(len);
-					if (!child_path) OutOfMemory();
+					if (!child_path) out_of_memory();
 					snprintf(child_path, len - 1, "%s%s/", path, cp);
 					//printf("Check: %s\n", child_path);
 					ScanDir(child_path, depth + 1);
Index: ccstools.src/setprofile.c
===================================================================
--- ccstools.src/setprofile.c	(リビジョン 1537)
+++ ccstools.src/setprofile.c	(作業コピー)
@@ -5,39 +5,48 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.1   2008/05/10
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
 
-int setprofile_main(int argc, char *argv[]) {
-	FILE *fp_in, *fp_out;
+int setprofile_main(int argc, char *argv[])
+{
+	FILE *fp_in;
+	FILE *fp_out;
 	int profile = 0;
-	int recursive = 0;
-	int i, start = 2;
-	if (argc > 1 && strcmp(argv[1], "-r") == 0) {
+	bool recursive = 0;
+	int i;
+	int start = 2;
+	if (argc > 1 && !strcmp(argv[1], "-r")) {
 		recursive = 1;
 		start = 3;
 	}
 	if (argc <= start || sscanf(argv[start - 1], "%u", &profile) != 1) {
-		fprintf(stderr, "%s [-r] profile domainname [domainname ...]\n", argv[0]);
+		fprintf(stderr, "%s [-r] profile domainname [domainname ...]\n",
+			argv[0]);
 		return 0;
 	}
-	for (i = start; i < argc; i++) NormalizeLine(argv[i]);
+	for (i = start; i < argc; i++)
+		normalize_line(argv[i]);
 	{
 		const int fd = open(proc_policy_domain_status, O_RDWR);
 		if (fd == EOF) {
-			fprintf(stderr, "You can't run this command for this kernel.\n");
+			fprintf(stderr, "You can't run this command for this "
+				"kernel.\n");
 			return 1;
 		} else if (write(fd, "", 0) != 0) {
-			fprintf(stderr, "You need to register this program to %s to run this program.\n", proc_policy_manager);
+			fprintf(stderr, "You need to register this program to "
+				"%s to run this program.\n",
+				proc_policy_manager);
 			return 1;
 		}
 		close(fd);
 	}
 	{
 		int profile_found = 0;
-		if ((fp_in = fopen(proc_policy_profile, "r")) == NULL) {
+		fp_in = fopen(proc_policy_profile, "r");
+		if (!fp_in) {
 			fprintf(stderr, "Can't open policy file.\n");
 			exit(1);
 		}
@@ -55,28 +64,35 @@
 			exit(1);
 		}
 	}
-	if ((fp_in = fopen(proc_policy_domain_status, "r")) == NULL || (fp_out = fopen(proc_policy_domain_status, "w")) == NULL) {
+	fp_in = fopen(proc_policy_domain_status, "r");
+	fp_out = fopen(proc_policy_domain_status, "w");
+	if (!fp_in || !fp_out) {
 		fprintf(stderr, "Can't open policy file.\n");
 		exit(1);
 	}
 	get();
 	while (freadline(fp_in)) {
 		char *cp = strchr(shared_buffer, ' ');
-		if (!cp) break;
+		if (!cp)
+			break;
 		*cp++ = '\0';
 		for (i = start; i < argc; i++) {
 			const int len = strlen(argv[i]);
-			if (strncmp(cp, argv[i], len)) continue;
+			if (strncmp(cp, argv[i], len))
+				continue;
 			if (!recursive) {
-				if (cp[len]) continue;
+				if (cp[len])
+					continue;
 			} else {
-				if (cp[len] && cp[len] != ' ') continue;
+				if (cp[len] && cp[len] != ' ')
+					continue;
 			}
 			fprintf(fp_out, "%d %s\n", profile, cp);
 			printf("%d %s\n", profile, cp);
 		}
 	}
 	put();
-	fclose(fp_in); fclose(fp_out);
+	fclose(fp_in);
+	fclose(fp_out);
 	return 0;
 }
Index: ccstools.src/checkpolicy.c
===================================================================
--- ccstools.src/checkpolicy.c	(リビジョン 1537)
+++ ccstools.src/checkpolicy.c	(作業コピー)
@@ -5,54 +5,69 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.2   2008/06/25
+ * Version: 1.6.4+   2008/09/07
  *
  */
 #include "ccstools.h"
 
-static int strendswith(const char *name, const char *tail) {
+static int strendswith(const char *name, const char *tail)
+{
 	int len;
-	if (!name || !tail) return 0;
+	if (!name || !tail)
+		return 0;
 	len = strlen(name) - strlen(tail);
-	return len >= 0 && strcmp(name + len, tail) == 0;
+	return len >= 0 && !strcmp(name + len, tail);
 }
 
-static int parse_ulong(unsigned long *result, char **str) {
+static int parse_ulong(unsigned long *result, char **str)
+{
 	const char *cp = *str;
 	char *ep;
 	int base = 10;
 	if (*cp == '0') {
-		char c = * (cp + 1);
+		char c = *(cp + 1);
 		if (c == 'x' || c == 'X') {
-			base = 16; cp += 2;
+			base = 16;
+			cp += 2;
 		} else if (c >= '0' && c <= '7') {
-			base = 8; cp++;
+			base = 8;
+			cp++;
 		}
 	}
 	*result = strtoul(cp, &ep, base);
-	if (cp == ep) return 0;
+	if (cp == ep)
+		return 0;
 	*str = ep;
-	return (base == 16 ? VALUE_TYPE_HEXADECIMAL : (base == 8 ? VALUE_TYPE_OCTAL : VALUE_TYPE_DECIMAL));
+	return base == 16 ? VALUE_TYPE_HEXADECIMAL :
+		(base == 8 ? VALUE_TYPE_OCTAL : VALUE_TYPE_DECIMAL);
 }
 
-static char *FindConditionPart(char *data) {
-	char *cp = strstr(data, " if "), *cp2;
+static char *FindConditionPart(char *data)
+{
+	char *cp = strstr(data, " if ");
+	char *cp2;
 	if (cp) {
-		while ((cp2 = strstr(cp + 3, " if ")) != NULL) cp = cp2;
+		while ((cp2 = strstr(cp + 3, " if ")) != NULL)
+			cp = cp2;
 		*cp++ = '\0';
-	} else if ((cp = strstr(data, " ; set ")) != NULL) {
-		*cp++ = '\0';
+	} else {
+		cp = strstr(data, " ; set ");
+		if (cp)
+			*cp++ = '\0';
 	}
 	return cp;
 }
 
 static unsigned int line = 0, errors = 0, warnings = 0;
 
-static int CheckCondition(char *condition) {
-	enum { TASK_UID, TASK_EUID, TASK_SUID, TASK_FSUID, TASK_GID, TASK_EGID, TASK_SGID, TASK_FSGID,
-	       TASK_PID, TASK_PPID, PATH1_UID, PATH1_GID, PATH1_INO, PATH1_PARENT_UID, PATH1_PARENT_GID, PATH1_PARENT_INO,
-	       PATH2_PARENT_UID, PATH2_PARENT_GID, PATH2_PARENT_INO, EXEC_ARGC, EXEC_ENVC, EXEC_ARGV, EXEC_ENVP, TASK_STATE_0,
-	       TASK_STATE_1, TASK_STATE_2, MAX_KEYWORD };
+static int CheckCondition(char *condition)
+{
+	enum { TASK_UID, TASK_EUID, TASK_SUID, TASK_FSUID, TASK_GID, TASK_EGID,
+	       TASK_SGID, TASK_FSGID, TASK_PID, TASK_PPID, PATH1_UID,
+	       PATH1_GID, PATH1_INO, PATH1_PARENT_UID, PATH1_PARENT_GID,
+	       PATH1_PARENT_INO, PATH2_PARENT_UID, PATH2_PARENT_GID,
+	       PATH2_PARENT_INO, EXEC_ARGC, EXEC_ENVC, EXEC_ARGV, EXEC_ENVP,
+	       TASK_STATE_0, TASK_STATE_1, TASK_STATE_2, MAX_KEYWORD };
 	static struct {
 		const char *keyword;
 		const int keyword_len; /* strlen(keyword) */
@@ -85,223 +100,334 @@
 		[TASK_STATE_2]     = { "task.state[2]",     13 },
 	};
 	char *start = condition;
-	u8 left, right, i;
-	unsigned long left_min = 0, left_max = 0, right_min = 0, right_max = 0;
+	u8 left;
+	u8 right;
+	u8 i;
+	unsigned long left_min = 0;
+	unsigned long left_max = 0;
+	unsigned long right_min = 0;
+	unsigned long right_max = 0;
 	u8 post_state[4] = { 0, 0, 0, 0 };
-	if ((condition = strstr(condition, "; set ")) != NULL) {
+	condition = strstr(condition, "; set ");
+	if (condition) {
 		*condition = '\0';
 		condition += 6;
 		while (1) {
-			while (*condition == ' ') condition++;
-			if (!*condition) break;
-			if (strncmp(condition, "task.state[0]=", 14) == 0) i = 0;
-			else if (strncmp(condition, "task.state[1]=", 14) == 0) i = 1;
-			else if (strncmp(condition, "task.state[2]=", 14) == 0) i = 2;
-			else goto out;
+			while (*condition == ' ')
+				condition++;
+			if (!*condition)
+				break;
+			if (!strncmp(condition, "task.state[0]=", 14))
+				i = 0;
+			else if (!strncmp(condition, "task.state[1]=", 14))
+				i = 1;
+			else if (!strncmp(condition, "task.state[2]=", 14))
+				i = 2;
+			else
+				goto out;
 			condition += 14;
-			if (post_state[3] & (1 << i)) goto out;
+			if (post_state[3] & (1 << i))
+				goto out;
 			post_state[3] |= 1 << i;
-			if (!parse_ulong(&right_min, &condition) || right_min > 255) goto out;
+			if (!parse_ulong(&right_min, &condition) ||
+			    right_min > 255)
+				goto out;
 			post_state[i] = (u8) right_min;
 		}
 	}
 	condition = start;
-	if (strncmp(condition, "if ", 3) == 0) condition += 3;
-	else if (*condition) goto out;
+	if (!strncmp(condition, "if ", 3))
+		condition += 3;
+	else if (*condition)
+		goto out;
 	start = condition;
 	while (1) {
-		while (*condition == ' ') condition++;
-		if (!*condition) break;
+		while (*condition == ' ')
+			condition++;
+		if (!*condition)
+			break;
 		for (left = 0; left < MAX_KEYWORD; left++) {
-			if (strncmp(condition, condition_control_keyword[left].keyword, condition_control_keyword[left].keyword_len) == 0) {
-				condition += condition_control_keyword[left].keyword_len;
-				break;
-			}
+			int len = condition_control_keyword[left].keyword_len;
+			if (strncmp(condition,
+				    condition_control_keyword[left].keyword,
+				    len))
+				continue;
+			condition += len;
+			break;
 		}
 		if (left == EXEC_ARGV) {
-			if (!parse_ulong(&left_min, &condition)) goto out;
-			if (*condition++ != ']') goto out;
+			if (!parse_ulong(&left_min, &condition))
+				goto out;
+			if (*condition++ != ']')
+				goto out;
 		} else if (left == EXEC_ENVP) {
 			char *tmp = condition;
 			while (1) {
 				const char c = *condition;
 				/*
-				 * Since environment variable names don't contain '=',
-				 * I can treat '"]=' and '"]!=' sequences as delimiters.
+				 * Since environment variable names don't
+				 * contain '=', I can treat '"]=' and '"]!='
+				 * sequences as delimiters.
 				 */
-				if (strncmp(condition, "\"]=", 3) == 0 || strncmp(condition, "\"]!=", 4) == 0) break;
-				if (!c || c == ' ') goto out;
+				if (!strncmp(condition, "\"]=", 3) ||
+				    !strncmp(condition, "\"]!=", 4))
+					break;
+				if (!c || c == ' ')
+					goto out;
 				condition++;
 			}
 			*condition = '\0';
-			if (!SaveName(tmp)) goto out;
+			if (!savename(tmp))
+				goto out;
 			*condition = '"';
 			condition += 2;
 		} else if (left == MAX_KEYWORD) {
-			if (!parse_ulong(&left_min, &condition)) goto out;
+			if (!parse_ulong(&left_min, &condition))
+				goto out;
 			if (*condition == '-') {
 				condition++;
-				if (!parse_ulong(&left_max, &condition) || left_min > left_max) goto out;
+				if (!parse_ulong(&left_max, &condition) ||
+				    left_min > left_max)
+					goto out;
 			}
 		}
-		if (strncmp(condition, "!=", 2) == 0) condition += 2;
-		else if (*condition == '=') condition++;
-		else goto out;
-		if (left == EXEC_ENVP && strncmp(condition, "NULL", 4) == 0) {
+		if (strncmp(condition, "!=", 2) == 0)
+			condition += 2;
+		else if (*condition == '=')
+			condition++;
+		else
+			goto out;
+		if (left == EXEC_ENVP && !strncmp(condition, "NULL", 4)) {
 			char c;
 			condition += 4;
 			c = *condition;
-			if (!c || c == ' ') continue;
+			if (!c || c == ' ')
+				continue;
 			goto out;
 		} else if (left == EXEC_ARGV || left == EXEC_ENVP) {
 			char c;
 			char *tmp;
-			if (*condition++ != '"') goto out;
+			if (*condition++ != '"')
+				goto out;
 			tmp = condition;
 			while (1) {
 				c = *condition++;
-				if (!c || c == ' ') goto out;
-				if (c != '"') continue;
+				if (!c || c == ' ')
+					goto out;
+				if (c != '"')
+					continue;
 				c = *condition;
-				if (!c || c == ' ') break;
+				if (!c || c == ' ')
+					break;
 			}
 			c = *--condition;
 			*condition = '\0';
-			if (!SaveName(tmp)) goto out;
+			if (!savename(tmp))
+				goto out;
 			*condition = c;
 			condition++;
 			continue;
 		}
 		for (right = 0; right < MAX_KEYWORD; right++) {
-			if (strncmp(condition, condition_control_keyword[right].keyword, condition_control_keyword[right].keyword_len) == 0) {
-				condition += condition_control_keyword[right].keyword_len;
-				break;
-			}
+			int len = condition_control_keyword[right].keyword_len;
+			if (strncmp(condition,
+				    condition_control_keyword[right].keyword,
+				    len))
+				continue;
+			condition += len;
+			break;
 		}
 		if (right == MAX_KEYWORD) {
-			if (!parse_ulong(&right_min, &condition)) goto out;
+			if (!parse_ulong(&right_min, &condition))
+				goto out;
 			if (*condition == '-') {
 				condition++;
-				if (!parse_ulong(&right_max, &condition) || right_min > right_max) goto out;
+				if (!parse_ulong(&right_max, &condition) ||
+				    right_min > right_max)
+					goto out;
 			}
 		}
 	}
 	return 1;
- out:
-	printf("%u: ERROR: '%s' is a illegal condition.\n", line, start); errors++;
+out:
+	printf("%u: ERROR: '%s' is a illegal condition.\n", line, start);
+	errors++;
 	return 0;
 }
 
-static void CheckCapabilityPolicy(char *data) {
+static void CheckCapabilityPolicy(char *data)
+{
 	static const char *capability_keywords[] = {
-		"inet_tcp_create", "inet_tcp_listen", "inet_tcp_connect", "use_inet_udp", "use_inet_ip", "use_route", "use_packet",
-		"SYS_MOUNT", "SYS_UMOUNT", "SYS_REBOOT", "SYS_CHROOT", "SYS_KILL", "SYS_VHANGUP", "SYS_TIME", "SYS_NICE", "SYS_SETHOSTNAME",
-		"use_kernel_module", "create_fifo", "create_block_dev", "create_char_dev", "create_unix_socket",
-		"SYS_LINK", "SYS_SYMLINK", "SYS_RENAME", "SYS_UNLINK", "SYS_CHMOD", "SYS_CHOWN", "SYS_IOCTL", "SYS_KEXEC_LOAD", "SYS_PIVOT_ROOT",
-		"SYS_PTRACE", NULL
+		"inet_tcp_create", "inet_tcp_listen", "inet_tcp_connect",
+		"use_inet_udp", "use_inet_ip", "use_route", "use_packet",
+		"SYS_MOUNT", "SYS_UMOUNT", "SYS_REBOOT", "SYS_CHROOT",
+		"SYS_KILL", "SYS_VHANGUP", "SYS_TIME", "SYS_NICE",
+		"SYS_SETHOSTNAME", "use_kernel_module", "create_fifo",
+		"create_block_dev", "create_char_dev", "create_unix_socket",
+		"SYS_LINK", "SYS_SYMLINK", "SYS_RENAME", "SYS_UNLINK",
+		"SYS_CHMOD", "SYS_CHOWN", "SYS_IOCTL", "SYS_KEXEC_LOAD",
+		"SYS_PIVOT_ROOT", "SYS_PTRACE", NULL
 	};
 	int i;
 	for (i = 0; capability_keywords[i]; i++) {
-		if (strcmp(data, capability_keywords[i]) == 0) return;
+		if (!strcmp(data, capability_keywords[i]))
+			return;
 	}
-	printf("%u: ERROR: '%s' is a bad capability name.\n", line, data); errors++;
+	printf("%u: ERROR: '%s' is a bad capability name.\n", line, data);
+	errors++;
 }
 
-static void CheckSignalPolicy(char *data) {
+static void CheckSignalPolicy(char *data)
+{
 	int sig;
 	char *cp;
 	cp = strchr(data, ' ');
 	if (!cp) {
-		printf("%u: ERROR: Too few parameters.\n", line); errors++;
+		printf("%u: ERROR: Too few parameters.\n", line);
+		errors++;
 		return;
 	}
 	*cp++ = '\0';
 	if (sscanf(data, "%d", &sig) != 1) {
-		printf("%u: ERROR: '%s' is a bad signal number.\n", line, data); errors++;
+		printf("%u: ERROR: '%s' is a bad signal number.\n", line, data);
+		errors++;
 	}
-	if (!IsCorrectDomain(cp)) {
-		printf("%u: ERROR: '%s' is a bad domainname.\n", line, cp); errors++;
+	if (!is_correct_domain(cp)) {
+		printf("%u: ERROR: '%s' is a bad domainname.\n", line, cp);
+		errors++;
 	}
 }
 
-static void CheckArgv0Policy(char *data) {
+static void CheckArgv0Policy(char *data)
+{
 	char *argv0 = strchr(data, ' ');
 	if (!argv0) {
-		printf("%u: ERROR: Too few parameters.\n", line); errors++;
+		printf("%u: ERROR: Too few parameters.\n", line);
+		errors++;
 		return;
 	}
 	*argv0++ = '\0';
-	if (!IsCorrectPath(data, 1, 0, -1)) {
-		printf("%u: ERROR: '%s' is a bad pathname.\n", line, data); errors++;
+	if (!is_correct_path(data, 1, 0, -1)) {
+		printf("%u: ERROR: '%s' is a bad pathname.\n", line, data);
+		errors++;
 	}
-	if (!IsCorrectPath(argv0, -1, 0, -1) || strchr(argv0, '/')) {
-		printf("%u: ERROR: '%s' is a bad argv[0] name.\n", line, data); errors++;
+	if (!is_correct_path(argv0, -1, 0, -1) || strchr(argv0, '/')) {
+		printf("%u: ERROR: '%s' is a bad argv[0] name.\n", line, data);
+		errors++;
 	}
 }
 
-static void CheckEnvPolicy(char *data) {
-	if (!IsCorrectPath(data, 0, 0, 0)) {
-		printf("%u: ERROR: '%s' is a bad variable name.\n", line, data); errors++;
+static void CheckEnvPolicy(char *data)
+{
+	if (!is_correct_path(data, 0, 0, 0)) {
+		printf("%u: ERROR: '%s' is a bad variable name.\n", line, data);
+		errors++;
 	}
 }
 
-static void CheckNetworkPolicy(char *data) {
-	int sock_type, operation, is_ipv6;
-	u16 min_address[8], max_address[8];
-	unsigned int min_port, max_port;
+static void CheckNetworkPolicy(char *data)
+{
+	int sock_type;
+	int operation;
+	u16 min_address[8];
+	u16 max_address[8];
+	unsigned int min_port;
+	unsigned int max_port;
 	int count;
-	char *cp1 = NULL, *cp2 = NULL;
-	if ((cp1 = strchr(data, ' ')) == NULL) goto out; cp1++;
-	if (strncmp(data, "TCP ", 4) == 0) sock_type = SOCK_STREAM;
-	else if (strncmp(data, "UDP ", 4) == 0) sock_type = SOCK_DGRAM;
-	else if (strncmp(data, "RAW ", 4) == 0) sock_type = SOCK_RAW;
-	else goto out;
-	if ((cp2 = strchr(cp1, ' ')) == NULL) goto out; cp2++;
-	if (strncmp(cp1, "bind ", 5) == 0) {
-		operation = (sock_type == SOCK_STREAM) ? NETWORK_ACL_TCP_BIND : (sock_type == SOCK_DGRAM) ? NETWORK_ACL_UDP_BIND : NETWORK_ACL_RAW_BIND;
-	} else if (strncmp(cp1, "connect ", 8) == 0) {
-		operation = (sock_type == SOCK_STREAM) ? NETWORK_ACL_TCP_CONNECT : (sock_type == SOCK_DGRAM) ? NETWORK_ACL_UDP_CONNECT : NETWORK_ACL_RAW_CONNECT;
-	} else if (sock_type == SOCK_STREAM && strncmp(cp1, "listen ", 7) == 0) {
+	char *cp1 = NULL;
+	char *cp2 = NULL;
+	cp1 = strchr(data, ' ');
+	if (!cp1)
+		goto out;
+	cp1++;
+	if (!strncmp(data, "TCP ", 4))
+		sock_type = SOCK_STREAM;
+	else if (!strncmp(data, "UDP ", 4))
+		sock_type = SOCK_DGRAM;
+	else if (!strncmp(data, "RAW ", 4))
+		sock_type = SOCK_RAW;
+	else
+		goto out;
+	cp2 = strchr(cp1, ' ');
+	if (!cp2)
+		goto out;
+	cp2++;
+	if (!strncmp(cp1, "bind ", 5)) {
+		operation = (sock_type == SOCK_STREAM) ? NETWORK_ACL_TCP_BIND :
+			(sock_type == SOCK_DGRAM) ? NETWORK_ACL_UDP_BIND :
+			NETWORK_ACL_RAW_BIND;
+	} else if (!strncmp(cp1, "connect ", 8)) {
+		operation = (sock_type == SOCK_STREAM) ?
+			NETWORK_ACL_TCP_CONNECT : (sock_type == SOCK_DGRAM) ?
+			NETWORK_ACL_UDP_CONNECT : NETWORK_ACL_RAW_CONNECT;
+	} else if (sock_type == SOCK_STREAM && !strncmp(cp1, "listen ", 7)) {
 		operation = NETWORK_ACL_TCP_LISTEN;
-	} else if (sock_type == SOCK_STREAM && strncmp(cp1, "accept ", 7) == 0) {
+	} else if (sock_type == SOCK_STREAM && !strncmp(cp1, "accept ", 7)) {
 		operation = NETWORK_ACL_TCP_ACCEPT;
 	} else {
 		goto out;
 	}
-	if ((cp1 = strchr(cp2, ' ')) == NULL) goto out; cp1++;
-	if ((count = sscanf(cp2, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
-						&min_address[0], &min_address[1], &min_address[2], &min_address[3],
-						&min_address[4], &min_address[5], &min_address[6], &min_address[7],
-						&max_address[0], &max_address[1], &max_address[2], &max_address[3],
-						&max_address[4], &max_address[5], &max_address[6], &max_address[7])) == 8 || count == 16) {
+	cp1 = strchr(cp2, ' ');
+	if (!cp1)
+		goto out;
+	cp1++;
+	count = sscanf(cp2, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-"
+		       "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
+		       &min_address[0], &min_address[1], &min_address[2],
+		       &min_address[3], &min_address[4], &min_address[5],
+		       &min_address[6], &min_address[7], &max_address[0],
+		       &max_address[1], &max_address[2], &max_address[3],
+		       &max_address[4], &max_address[5], &max_address[6],
+		       &max_address[7]);
+	if (count == 8 || count == 16) {
 		int i;
 		for (i = 0; i < 8; i++) {
 			min_address[i] = htons(min_address[i]);
 			max_address[i] = htons(max_address[i]);
 		}
-		if (count == 8) memmove(max_address, min_address, sizeof(min_address));
-		is_ipv6 = 1;
-	} else if ((count = sscanf(cp2, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
-							   &min_address[0], &min_address[1], &min_address[2], &min_address[3],
- 							   &max_address[0], &max_address[1], &max_address[2], &max_address[3])) == 4 || count == 8) {
-		u32 ip = htonl((((u8) min_address[0]) << 24) + (((u8) min_address[1]) << 16) + (((u8) min_address[2]) << 8) + (u8) min_address[3]);
-		* (u32 *) (void *) min_address = ip;
-		if (count == 8) ip = htonl((((u8) max_address[0]) << 24) + (((u8) max_address[1]) << 16) + (((u8) max_address[2]) << 8) + (u8) max_address[3]);
-		* (u32 *) (void *) max_address = ip;
-		is_ipv6 = 0;
-	} else if (*cp2 != '@') { // Don't reject address_group.
+		if (count == 8)
+			memmove(max_address, min_address, sizeof(min_address));
+		goto next;
+	}
+	count = sscanf(cp2, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
+		       &min_address[0], &min_address[1], &min_address[2],
+		       &min_address[3], &max_address[0], &max_address[1],
+		       &max_address[2], &max_address[3]);
+	if (count == 4 || count == 8) {
+		u32 *p = (u32 *) min_address;
+		u32 ip = htonl((((u8) min_address[0]) << 24) +
+			       (((u8) min_address[1]) << 16) +
+			       (((u8) min_address[2]) << 8) +
+			       (u8) min_address[3]);
+		*p = ip;
+		p = (u32 *) max_address;
+		if (count == 8)
+			ip = htonl((((u8) max_address[0]) << 24) +
+				   (((u8) max_address[1]) << 16) +
+				   (((u8) max_address[2]) << 8) +
+				   (u8) max_address[3]);
+		*p = ip;
+		goto next;
+	}
+	if (*cp2 != '@') /* Don't reject address_group. */
 		goto out;
+next:
+	if (strchr(cp1, ' '))
+		goto out;
+	count = sscanf(cp1, "%u-%u", &min_port, &max_port);
+	if (count == 1 || count == 2) {
+		if (count == 1)
+			max_port = min_port;
+		if (min_port <= max_port && max_port < 65536)
+			return;
 	}
-	if (strchr(cp1, ' ')) goto out;
-	if ((count = sscanf(cp1, "%u-%u", &min_port, &max_port)) == 1 || count == 2) {
-		if (count == 1) max_port = min_port;
-		if (min_port <= max_port && max_port < 65536) return;
-	}
- out: ;
-	printf("%u: ERROR: Bad network address.\n", line); errors++;
+out:
+	printf("%u: ERROR: Bad network address.\n", line);
+	errors++;
 }
 
-static void CheckFilePolicy(char *data) {
+static void CheckFilePolicy(char *data)
+{
 	static const struct {
 		const char * const keyword;
 		const int paths;
@@ -329,100 +455,149 @@
 	char *cp;
 	unsigned int perm;
 	if (!filename) {
-		printf("%u: ERROR: Unknown command '%s'\n", line, data); errors++;
+		printf("%u: ERROR: Unknown command '%s'\n", line, data);
+		errors++;
 		return;
 	}
 	*filename++ = '\0';
 	if (sscanf(data, "%u", &perm) == 1 && perm > 0 && perm <= 7) {
-		if (filename[0] != '@' && strendswith(filename, "/")) { // Don't reject path_group.
-			printf("%u: WARNING: Only 'mkdir' and 'rmdir' are valid for directory '%s'.\n", line, filename); warnings++;
+		/* Don't reject path_group. */
+		if (filename[0] != '@' && strendswith(filename, "/")) {
+			printf("%u: WARNING: Only 'mkdir' and 'rmdir' are "
+			       "valid for directory '%s'.\n", line, filename);
+			warnings++;
 		}
-		if (!IsCorrectPath(filename, 0, 0, 0)) goto out;
+		if (!is_correct_path(filename, 0, 0, 0))
+			goto out1;
 		return;
 	}
-	if (strncmp(data, "allow_", 6) == 0) {
+	if (!strncmp(data, "allow_", 6)) {
 		int type;
 		for (type = 0; acl_type_array[type].keyword; type++) {
-			if (strcmp(data + 6, acl_type_array[type].keyword)) continue;
+			if (strcmp(data + 6, acl_type_array[type].keyword))
+				continue;
 			if (acl_type_array[type].paths == 2) {
 				cp = strchr(filename, ' ');
-				if (!cp || !IsCorrectPath(cp + 1, 0, 0, 0)) break;
+				if (!cp || !is_correct_path(cp + 1, 0, 0, 0))
+					break;
 				*cp = '\0';
 			}
-			if (!IsCorrectPath(filename, 0, 0, 0)) break;
+			if (!is_correct_path(filename, 0, 0, 0))
+				break;
 			return;
 		}
-		if (!acl_type_array[type].keyword) goto out2;
-	out:
-		printf("%u: ERROR: '%s' is a bad pathname.\n", line, filename); errors++;
+		if (!acl_type_array[type].keyword)
+			goto out2;
+out1:
+		printf("%u: ERROR: '%s' is a bad pathname.\n", line, filename);
+		errors++;
 		return;
 	}
- out2:
-	printf("%u: ERROR: Invalid permission '%s %s'\n", line, data, filename); errors++;
+out2:
+	printf("%u: ERROR: Invalid permission '%s %s'\n", line, data, filename);
+	errors++;
 }
 
-static void CheckMountPolicy(char *data) {
-	char *cp, *cp2;
-	const char *dev, *dir;
+static void CheckMountPolicy(char *data)
+{
+	char *cp;
+	char *cp2;
+	const char *dev;
+	const char *dir;
 	unsigned int flags;
-	cp2 = data; if ((cp = strchr(cp2, ' ')) == NULL) goto out; *cp = '\0'; dev = cp2;
-	cp2 = cp + 1; if ((cp = strchr(cp2, ' ')) == NULL) goto out; *cp = '\0'; dir = cp2;
+	cp2 = data;
+	cp = strchr(cp2, ' ');
+	if (!cp)
+		goto out;
+	*cp = '\0';
+	dev = cp2;
+	cp2 = cp + 1;
+	cp = strchr(cp2, ' ');
+	if (!cp)
+		goto out;
+	*cp = '\0';
+	dir = cp2;
 	cp2 = strchr(cp + 1, ' ');
-	if (!cp2) goto out;
-	if (!IsCorrectPath(dev, 0, 0, 0)) {
-		printf("%u: ERROR: '%s' is a bad device name.\n", line, dir); errors++;
+	if (!cp2)
+		goto out;
+	if (!is_correct_path(dev, 0, 0, 0)) {
+		printf("%u: ERROR: '%s' is a bad device name.\n", line, dir);
+		errors++;
 	}
-	if (!IsCorrectPath(dir, 0, 0, 0)) {
-		printf("%u: ERROR: '%s' is a bad mount point.\n", line, dir); errors++;
+	if (!is_correct_path(dir, 0, 0, 0)) {
+		printf("%u: ERROR: '%s' is a bad mount point.\n", line, dir);
+		errors++;
 	}
 	if (sscanf(cp2 + 1, "0x%X", &flags) != 1) {
-		printf("%u: ERROR: '%s' is a bad mount option.\n", line, cp2 + 1); errors++;
+		printf("%u: ERROR: '%s' is a bad mount option.\n",
+		       line, cp2 + 1);
+		errors++;
 	}
 	return;
  out:
-	printf("%u: ERROR: Too few parameters.\n", line); errors++;
+	printf("%u: ERROR: Too few parameters.\n", line);
+	errors++;
 }
 
-static void CheckPivotRootPolicy(char *data) {
-	char *cp;
-	if ((cp = strchr(data, ' ')) == NULL) goto out;
+static void CheckPivotRootPolicy(char *data)
+{
+	char *cp = strchr(data, ' ');
+	if (!cp)
+		goto out;
 	*cp++ = '\0';
-	if (!IsCorrectPath(data, 1, 0, 1)) {
-		printf("%u: ERROR: '%s' is a bad directory.\n", line, data); errors++;
+	if (!is_correct_path(data, 1, 0, 1)) {
+		printf("%u: ERROR: '%s' is a bad directory.\n", line, data);
+		errors++;
 	}
-	if (!IsCorrectPath(cp, 1, 0, 1)) {
-		printf("%u: ERROR: '%s' is a bad directory.\n", line, cp); errors++;
+	if (!is_correct_path(cp, 1, 0, 1)) {
+		printf("%u: ERROR: '%s' is a bad directory.\n", line, cp);
+		errors++;
 	}
 	return;
  out:
-	printf("%u: ERROR: Too few parameters.\n", line); errors++;
+	printf("%u: ERROR: Too few parameters.\n", line);
+	errors++;
 }
 
-static void CheckReservedPortPolicy(char *data) {
-	unsigned int from, to;
-	if (strchr(data, ' ')) goto out;
+static void CheckReservedPortPolicy(char *data)
+{
+	unsigned int from;
+	unsigned int to;
+	if (strchr(data, ' '))
+		goto out;
 	if (sscanf(data, "%u-%u", &from, &to) == 2) {
-		if (from <= to && to < 65536) return;
+		if (from <= to && to < 65536)
+			return;
 	} else if (sscanf(data, "%u", &from) == 1) {
-		if (from < 65536) return;
+		if (from < 65536)
+			return;
 	} else {
-		printf("%u: ERROR: Too few parameters.\n", line); errors++;
+		printf("%u: ERROR: Too few parameters.\n", line);
+		errors++;
 		return;
 	}
  out:
-	printf("%u: ERROR: '%s' is a bad port number.\n", line, data); errors++;
+	printf("%u: ERROR: '%s' is a bad port number.\n", line, data);
+	errors++;
 }
 
-static void CheckDomainInitializerEntry(const char *domainname, const char *program) {
-	if (!IsCorrectPath(program, 1, 0, -1)) {
-		printf("%u: ERROR: '%s' is a bad pathname.\n", line, program); errors++;
+static void CheckDomainInitializerEntry(const char *domainname,
+					const char *program)
+{
+	if (!is_correct_path(program, 1, 0, -1)) {
+		printf("%u: ERROR: '%s' is a bad pathname.\n", line, program);
+		errors++;
 	}
-	if (domainname && !IsCorrectPath(domainname, 1, -1, -1) && !IsCorrectDomain(domainname)) {
-		printf("%u: ERROR: '%s' is a bad domainname.\n", line, domainname); errors++;
+	if (domainname && !is_correct_path(domainname, 1, -1, -1) &&
+	    !is_correct_domain(domainname)) {
+		printf("%u: ERROR: '%s' is a bad domainname.\n",
+		       line, domainname);
+		errors++;
 	}
 }
 
-static void CheckDomainInitializerPolicy(char *data) {
+static void CheckDomainInitializerPolicy(char *data)
+{
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
@@ -432,16 +607,22 @@
 	}
 }
 
-static void CheckDomainKeeperEntry(const char *domainname, const char *program) {
-	if (!IsCorrectPath(domainname, 1, -1, -1) && !IsCorrectDomain(domainname)) {
-		printf("%u: ERROR: '%s' is a bad domainname.\n", line, domainname); errors++;
+static void CheckDomainKeeperEntry(const char *domainname, const char *program)
+{
+	if (!is_correct_path(domainname, 1, -1, -1) &&
+	    !is_correct_domain(domainname)) {
+		printf("%u: ERROR: '%s' is a bad domainname.\n",
+		       line, domainname);
+		errors++;
 	}
-	if (program && !IsCorrectPath(program, 1, 0, -1)) {
-		printf("%u: ERROR: '%s' is a bad pathname.\n", line, program); errors++;
+	if (program && !is_correct_path(program, 1, 0, -1)) {
+		printf("%u: ERROR: '%s' is a bad pathname.\n", line, program);
+		errors++;
 	}
 }
 
-static void CheckDomainKeeperPolicy(char *data) {
+static void CheckDomainKeeperPolicy(char *data)
+{
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
@@ -451,44 +632,251 @@
 	}
 }
 
-static void CheckGroupPolicy(char *data) {
+static void CheckGroupPolicy(char *data)
+{
 	char *cp = strchr(data, ' ');
 	if (!cp) {
-		printf("%u: ERROR: Too few parameters.\n", line); errors++;
+		printf("%u: ERROR: Too few parameters.\n", line);
+		errors++;
 		return;
 	}
 	*cp++ = '\0';
-	if (!IsCorrectPath(data, 0, 0, 0)) {
-		printf("%u: ERROR: '%s' is a bad group name.\n", line, data); errors++;
+	if (!is_correct_path(data, 0, 0, 0)) {
+		printf("%u: ERROR: '%s' is a bad group name.\n", line, data);
+		errors++;
 	}
-	if (!IsCorrectPath(cp, 0, 0, 0)) {
-		printf("%u: ERROR: '%s' is a bad pathname.\n", line, cp); errors++;
+	if (!is_correct_path(cp, 0, 0, 0)) {
+		printf("%u: ERROR: '%s' is a bad pathname.\n", line, cp);
+		errors++;
 	}
 }
 
-static void CheckAddressGroupPolicy(char *data) {
+static void CheckAddressGroupPolicy(char *data)
+{
 	char *cp = strchr(data, ' ');
-	u16 min_address[8], max_address[8];
+	u16 min_address[8];
+	u16 max_address[8];
 	int count;
 	if (!cp) {
-		printf("%u: ERROR: Too few parameters.\n", line); errors++;
+		printf("%u: ERROR: Too few parameters.\n", line);
+		errors++;
 		return;
 	}
 	*cp++ = '\0';
-	if ((count = sscanf(cp, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
-						&min_address[0], &min_address[1], &min_address[2], &min_address[3],
-						&min_address[4], &min_address[5], &min_address[6], &min_address[7],
-						&max_address[0], &max_address[1], &max_address[2], &max_address[3],
-						&max_address[4], &max_address[5], &max_address[6], &max_address[7])) == 8 || count == 16) {
-	} else if ((count = sscanf(cp, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
-							   &min_address[0], &min_address[1], &min_address[2], &min_address[3],
- 							   &max_address[0], &max_address[1], &max_address[2], &max_address[3])) == 4 || count == 8) {
+	count = sscanf(cp, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-"
+		       "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
+		       &min_address[0], &min_address[1], &min_address[2],
+		       &min_address[3], &min_address[4], &min_address[5],
+		       &min_address[6], &min_address[7], &max_address[0],
+		       &max_address[1], &max_address[2], &max_address[3],
+		       &max_address[4], &max_address[5], &max_address[6],
+		       &max_address[7]);
+	if (count == 8 || count == 16)
+		return;
+	count = sscanf(cp, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
+		       &min_address[0], &min_address[1], &min_address[2],
+		       &min_address[3], &max_address[0], &max_address[1],
+		       &max_address[2], &max_address[3]);
+	if (count == 4 || count == 8)
+		return;
+	printf("%u: ERROR: '%s' is a bad address.\n", line, cp);
+	errors++;
+}
+
+static void check_domain_policy(int *domain0)
+{
+	int domain = *domain0;
+	int is_delete = 0;
+	int is_select = 0;
+	int is_undelete = 0;
+	if (str_starts(shared_buffer, KEYWORD_DELETE))
+		is_delete = 1;
+	else if (str_starts(shared_buffer, KEYWORD_SELECT))
+		is_select = 1;
+	else if (str_starts(shared_buffer, KEYWORD_UNDELETE))
+		is_undelete = 1;
+	if (is_domain_def(shared_buffer)) {
+		if (!is_correct_domain(shared_buffer) ||
+		    strlen(shared_buffer) >= CCS_MAX_PATHNAME_LEN) {
+			printf("%u: ERROR: '%s' is a bad domainname.\n",
+			       line, shared_buffer);
+			errors++;
+		} else {
+			if (is_delete)
+				domain = EOF;
+			else
+				domain = 0;
+		}
+		*domain0 = domain;
+	} else if (is_select) {
+		printf("%u: ERROR: Command 'select' is valid for selecting "
+		       "domains only.\n", line);
+		errors++;
+	} else if (is_undelete) {
+		printf("%u: ERROR: Command 'undelete' is valid for undeleting "
+		       "domains only.\n", line);
+		errors++;
+	} else if (domain == EOF) {
+		printf("%u: WARNING: '%s' is unprocessed because domain is not "
+		       "selected.\n", line, shared_buffer);
+		warnings++;
+	} else if (str_starts(shared_buffer, KEYWORD_USE_PROFILE)) {
+		unsigned int profile;
+		if (sscanf(shared_buffer, "%u", &profile) != 1 ||
+		    profile >= 256) {
+			printf("%u: ERROR: '%s' is a bad profile.\n",
+			       line, shared_buffer);
+			errors++;
+		}
+	} else if (!strcmp(shared_buffer, "ignore_global_allow_read")) {
+		/* Nothing to do. */
+	} else if (!strcmp(shared_buffer, "ignore_global_allow_env")) {
+		/* Nothing to do. */
+	} else if (str_starts(shared_buffer, "execute_handler ")) {
+		if (!is_correct_path(shared_buffer, 1, -1, -1)) {
+			printf("%u: ERROR: '%s' is a bad pathname.\n",
+			       line, shared_buffer);
+			errors++;
+		}
+	} else if (str_starts(shared_buffer, "denied_execute_handler ")) {
+		if (!is_correct_path(shared_buffer, 1, -1, -1)) {
+			printf("%u: ERROR: '%s' is a bad pathname.\n",
+			       line, shared_buffer);
+			errors++;
+		}
+	} else if (!strcmp(shared_buffer, "quota_exceeded")) {
+		/* Nothing to do. */
 	} else {
-		printf("%u: ERROR: '%s' is a bad address.\n", line, cp); errors++;
+		char *cp = FindConditionPart(shared_buffer);
+		if (cp && !CheckCondition(cp))
+			return;
+		if (str_starts(shared_buffer, KEYWORD_ALLOW_CAPABILITY))
+			CheckCapabilityPolicy(shared_buffer);
+		else if (str_starts(shared_buffer, KEYWORD_ALLOW_NETWORK))
+			CheckNetworkPolicy(shared_buffer);
+		else if (str_starts(shared_buffer, KEYWORD_ALLOW_SIGNAL))
+			CheckSignalPolicy(shared_buffer);
+		else if (str_starts(shared_buffer, KEYWORD_ALLOW_ARGV0))
+			CheckArgv0Policy(shared_buffer);
+		else if (str_starts(shared_buffer, KEYWORD_ALLOW_ENV))
+			CheckEnvPolicy(shared_buffer);
+		else
+			CheckFilePolicy(shared_buffer);
 	}
 }
-		
-int checkpolicy_main(int argc, char *argv[]) {
+
+static void check_exception_policy(void)
+{
+	str_starts(shared_buffer, KEYWORD_DELETE);
+	if (str_starts(shared_buffer, KEYWORD_ALLOW_READ)) {
+		if (!is_correct_path(shared_buffer, 1, 0, -1)) {
+			printf("%u: ERROR: '%s' is a bad pathname.\n",
+			       line, shared_buffer);
+			errors++;
+		}
+	} else if (str_starts(shared_buffer, KEYWORD_INITIALIZE_DOMAIN)) {
+		CheckDomainInitializerPolicy(shared_buffer);
+	} else if (str_starts(shared_buffer, KEYWORD_NO_INITIALIZE_DOMAIN)) {
+		CheckDomainInitializerPolicy(shared_buffer);
+	} else if (str_starts(shared_buffer, KEYWORD_KEEP_DOMAIN)) {
+		CheckDomainKeeperPolicy(shared_buffer);
+	} else if (str_starts(shared_buffer, KEYWORD_NO_KEEP_DOMAIN)) {
+		CheckDomainKeeperPolicy(shared_buffer);
+	} else if (str_starts(shared_buffer, KEYWORD_PATH_GROUP)) {
+		CheckGroupPolicy(shared_buffer);
+	} else if (str_starts(shared_buffer, KEYWORD_ADDRESS_GROUP)) {
+		CheckAddressGroupPolicy(shared_buffer);
+	} else if (str_starts(shared_buffer, KEYWORD_ALIAS)) {
+		char *cp = strchr(shared_buffer, ' ');
+		if (!cp) {
+			printf("%u: ERROR: Too few parameters.\n", line);
+			errors++;
+		} else {
+			*cp++ = '\0';
+			if (!is_correct_path(shared_buffer, 1, -1, -1)) {
+				printf("%u: ERROR: '%s' is a bad pathname.\n",
+				       line, shared_buffer);
+				errors++;
+			}
+			if (!is_correct_path(cp, 1, -1, -1)) {
+				printf("%u: ERROR: '%s' is a bad pathname.\n",
+				       line, cp);
+				errors++;
+			}
+		}
+	} else if (str_starts(shared_buffer, KEYWORD_AGGREGATOR)) {
+		char *cp = strchr(shared_buffer, ' ');
+		if (!cp) {
+			printf("%u: ERROR: Too few parameters.\n", line);
+			errors++;
+		} else {
+			*cp++ = '\0';
+			if (!is_correct_path(shared_buffer, 1, 0, -1)) {
+				printf("%u: ERROR: '%s' is a bad pattern.\n",
+				       line, shared_buffer);
+				errors++;
+			}
+			if (!is_correct_path(cp, 1, -1, -1)) {
+				printf("%u: ERROR: '%s' is a bad pathname.\n",
+				       line, cp);
+				errors++;
+			}
+		}
+	} else if (str_starts(shared_buffer, KEYWORD_FILE_PATTERN)) {
+		if (!is_correct_path(shared_buffer, 0, 1, 0)) {
+			printf("%u: ERROR: '%s' is a bad pattern.\n",
+			       line, shared_buffer);
+			errors++;
+		}
+	} else if (str_starts(shared_buffer, KEYWORD_DENY_REWRITE)) {
+		if (!is_correct_path(shared_buffer, 0, 0, 0)) {
+			printf("%u: ERROR: '%s' is a bad pattern.\n",
+			       line, shared_buffer);
+			errors++;
+		}
+	} else if (str_starts(shared_buffer, KEYWORD_ALLOW_ENV)) {
+		if (!is_correct_path(shared_buffer, 0, 0, 0)) {
+			printf("%u: ERROR: '%s' is a bad variable name.\n",
+			       line, shared_buffer);
+			errors++;
+		}
+	} else {
+		printf("%u: ERROR: Unknown command '%s'.\n",
+		       line, shared_buffer);
+		errors++;
+	}
+}
+
+static void check_system_policy(void)
+{
+	str_starts(shared_buffer, KEYWORD_DELETE);
+	if (str_starts(shared_buffer, KEYWORD_ALLOW_MOUNT)) {
+		CheckMountPolicy(shared_buffer);
+	} else if (str_starts(shared_buffer, KEYWORD_DENY_UNMOUNT)) {
+		if (!is_correct_path(shared_buffer, 1, 0, 1)) {
+			printf("%u: ERROR: '%s' is a bad pattern.\n",
+			       line, shared_buffer);
+			errors++;
+		}
+	} else if (str_starts(shared_buffer, KEYWORD_ALLOW_CHROOT)) {
+		if (!is_correct_path(shared_buffer, 1, 0, 1)) {
+			printf("%u: ERROR: '%s' is a bad pattern.\n",
+			       line, shared_buffer);
+			errors++;
+		}
+	} else if (str_starts(shared_buffer, KEYWORD_ALLOW_PIVOT_ROOT)) {
+		CheckPivotRootPolicy(shared_buffer);
+	} else if (str_starts(shared_buffer, KEYWORD_DENY_AUTOBIND)) {
+		CheckReservedPortPolicy(shared_buffer);
+	} else {
+		printf("%u: ERROR: Unknown command '%s'.\n",
+		       line, shared_buffer);
+		errors++;
+	}
+}
+
+int checkpolicy_main(int argc, char *argv[])
+{
 	int policy_type = POLICY_TYPE_UNKNOWN;
 	if (argc > 1) {
 		switch (argv[1][0]) {
@@ -508,188 +896,49 @@
 		return 0;
 	}
 	get();
-	while (memset(shared_buffer, 0, shared_buffer_len), fgets(shared_buffer, shared_buffer_len - 1, stdin)) {
+	while (memset(shared_buffer, 0, shared_buffer_len),
+	       fgets(shared_buffer, shared_buffer_len - 1, stdin)) {
 		static int domain = EOF;
-		int is_select = 0, is_delete = 0, is_undelete = 0;
 		char *cp = strchr(shared_buffer, '\n');
 		line++;
 		if (!cp) {
-			printf("%u: ERROR: Line too long.\n", line); errors++;
+			printf("%u: ERROR: Line too long.\n", line);
+			errors++;
 			break;
 		}
 		*cp = '\0';
 		{
 			int c;
 			for (c = 1; c < 256; c++) {
-				if (c == '\t' || c == '\r' || (c >= ' ' && c < 127)) continue;
-				if (strchr(shared_buffer, c)) {
-					printf("%u: WARNING: Line contains illegal character (\\%03o).\n", line, c); warnings++;
-					break;
-				}
+				if (c == '\t' || c == '\r' ||
+				    (c >= ' ' && c < 127))
+					continue;
+				if (!strchr(shared_buffer, c))
+					continue;
+				printf("%u: WARNING: Line contains illegal "
+				       "character (\\%03o).\n", line, c);
+				warnings++;
+				break;
 			}
 		}
-		NormalizeLine(shared_buffer);
-		if (!shared_buffer[0]) continue;
+		normalize_line(shared_buffer);
+		if (!shared_buffer[0])
+			continue;
 		switch (policy_type) {
 		case POLICY_TYPE_DOMAIN_POLICY:
-			if (strncmp(shared_buffer, KEYWORD_DELETE, KEYWORD_DELETE_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_DELETE_LEN);
-				is_delete = 1;
-			} else if (strncmp(shared_buffer, KEYWORD_SELECT, KEYWORD_SELECT_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_SELECT_LEN);
-				is_select = 1;
-			} else if (strncmp(shared_buffer, KEYWORD_UNDELETE, KEYWORD_UNDELETE_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_UNDELETE_LEN);
-				is_undelete = 1;
-			}
-			if (IsDomainDef(shared_buffer)) {
-				if (!IsCorrectDomain(shared_buffer) || strlen(shared_buffer) >= CCS_MAX_PATHNAME_LEN) {
-					printf("%u: ERROR: '%s' is a bad domainname.\n", line, shared_buffer); errors++;
-				} else {
-					if (is_delete) domain = EOF;
-					else domain = 0;
-				}
-			} else if (is_select) {
-				printf("%u: ERROR: Command 'select' is valid for selecting domains only.\n", line); errors++;
-			} else if (is_undelete) {
-				printf("%u: ERROR: Command 'undelete' is valid for undeleting domains only.\n", line); errors++;
-			} else if (domain == EOF) {
-				printf("%u: WARNING: '%s' is unprocessed because domain is not selected.\n", line, shared_buffer); warnings++;
-			} else if (strncmp(shared_buffer, KEYWORD_USE_PROFILE, KEYWORD_USE_PROFILE_LEN) == 0) {
-				unsigned int profile;
-				RemoveHeader(shared_buffer, KEYWORD_USE_PROFILE_LEN);
-				if (sscanf(shared_buffer, "%u", &profile) != 1 || profile >= 256) {
-					printf("%u: ERROR: '%s' is a bad profile.\n", line, shared_buffer); errors++;
-				}
-			} else if (strcmp(shared_buffer, "ignore_global_allow_read") == 0) {
-				/* Nothing to do. */
-			} else if (strcmp(shared_buffer, "ignore_global_allow_env") == 0) {
-				/* Nothing to do. */
-			} else if (strncmp(shared_buffer, "execute_handler ", 16) == 0) {
-				RemoveHeader(shared_buffer, 16);
-				if (!IsCorrectPath(shared_buffer, 1, -1, -1)) {
-					printf("%u: ERROR: '%s' is a bad pathname.\n", line, shared_buffer); errors++;
-				}
-			} else if (strncmp(shared_buffer, "denied_execute_handler ", 23) == 0) {
-				RemoveHeader(shared_buffer, 23);
-				if (!IsCorrectPath(shared_buffer, 1, -1, -1)) {
-					printf("%u: ERROR: '%s' is a bad pathname.\n", line, shared_buffer); errors++;
-				}
-			} else if (strcmp(shared_buffer, "quota_exceeded") == 0) {
-				/* Nothing to do. */
-			} else {
-				char *cp;
-				if ((cp = FindConditionPart(shared_buffer)) != NULL && !CheckCondition(cp)) break;
-				if (strncmp(shared_buffer, KEYWORD_ALLOW_CAPABILITY, KEYWORD_ALLOW_CAPABILITY_LEN) == 0) {
-					CheckCapabilityPolicy(shared_buffer + KEYWORD_ALLOW_CAPABILITY_LEN);
-				} else if (strncmp(shared_buffer, KEYWORD_ALLOW_NETWORK, KEYWORD_ALLOW_NETWORK_LEN) == 0) {
-					CheckNetworkPolicy(shared_buffer + KEYWORD_ALLOW_NETWORK_LEN);
-				} else if (strncmp(shared_buffer, KEYWORD_ALLOW_SIGNAL, KEYWORD_ALLOW_SIGNAL_LEN) == 0) {
-					CheckSignalPolicy(shared_buffer + KEYWORD_ALLOW_SIGNAL_LEN);
-				} else if (strncmp(shared_buffer, KEYWORD_ALLOW_ARGV0, KEYWORD_ALLOW_ARGV0_LEN) == 0) {
-					CheckArgv0Policy(shared_buffer + KEYWORD_ALLOW_ARGV0_LEN);
-				} else if (strncmp(shared_buffer, KEYWORD_ALLOW_ENV, KEYWORD_ALLOW_ENV_LEN) == 0) {
-					CheckEnvPolicy(shared_buffer + KEYWORD_ALLOW_ENV_LEN);
-				} else {
-					CheckFilePolicy(shared_buffer);
-				}
-			}
+			check_domain_policy(&domain);
 			break;
 		case POLICY_TYPE_EXCEPTION_POLICY:
-			if (strncmp(shared_buffer, KEYWORD_DELETE, KEYWORD_DELETE_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_DELETE_LEN);
-			}
-			if (strncmp(shared_buffer, KEYWORD_ALLOW_READ, KEYWORD_ALLOW_READ_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_ALLOW_READ_LEN);
-				if (!IsCorrectPath(shared_buffer, 1, 0, -1)) {
-					printf("%u: ERROR: '%s' is a bad pathname.\n", line, shared_buffer); errors++;
-				}
-			} else if (strncmp(shared_buffer, KEYWORD_INITIALIZE_DOMAIN, KEYWORD_INITIALIZE_DOMAIN_LEN) == 0) {
-				CheckDomainInitializerPolicy(shared_buffer + KEYWORD_INITIALIZE_DOMAIN_LEN);
-			} else if (strncmp(shared_buffer, KEYWORD_NO_INITIALIZE_DOMAIN, KEYWORD_NO_INITIALIZE_DOMAIN_LEN) == 0) {
-				CheckDomainInitializerPolicy(shared_buffer + KEYWORD_NO_INITIALIZE_DOMAIN_LEN);
-			} else if (strncmp(shared_buffer, KEYWORD_KEEP_DOMAIN, KEYWORD_KEEP_DOMAIN_LEN) == 0) {
-				CheckDomainKeeperPolicy(shared_buffer + KEYWORD_KEEP_DOMAIN_LEN);
-			} else if (strncmp(shared_buffer, KEYWORD_NO_KEEP_DOMAIN, KEYWORD_NO_KEEP_DOMAIN_LEN) == 0) {
-				CheckDomainKeeperPolicy(shared_buffer + KEYWORD_NO_KEEP_DOMAIN_LEN);
-			} else if (strncmp(shared_buffer, KEYWORD_PATH_GROUP, KEYWORD_PATH_GROUP_LEN) == 0) {
-				CheckGroupPolicy(shared_buffer + KEYWORD_PATH_GROUP_LEN);
-			} else if (strncmp(shared_buffer, KEYWORD_ADDRESS_GROUP, KEYWORD_ADDRESS_GROUP_LEN) == 0) {
-				CheckAddressGroupPolicy(shared_buffer + KEYWORD_ADDRESS_GROUP_LEN);
-			} else if (strncmp(shared_buffer, KEYWORD_ALIAS, KEYWORD_ALIAS_LEN) == 0) {
-				char *cp;
-				RemoveHeader(shared_buffer, KEYWORD_ALIAS_LEN);
-				if ((cp = strchr(shared_buffer, ' ')) == NULL) {
-					printf("%u: ERROR: Too few parameters.\n", line); errors++;
-				} else {
-					*cp++ = '\0';
-					if (!IsCorrectPath(shared_buffer, 1, -1, -1)) {
-						printf("%u: ERROR: '%s' is a bad pathname.\n", line, shared_buffer); errors++;
-					}
-					if (!IsCorrectPath(cp, 1, -1, -1)) {
-						printf("%u: ERROR: '%s' is a bad pathname.\n", line, cp); errors++;
-					}
-				}
-			} else if (strncmp(shared_buffer, KEYWORD_AGGREGATOR, KEYWORD_AGGREGATOR_LEN) == 0) {
-				char *cp;
-				RemoveHeader(shared_buffer, KEYWORD_AGGREGATOR_LEN);
-				if ((cp = strchr(shared_buffer, ' ')) == NULL) {
-					printf("%u: ERROR: Too few parameters.\n", line); errors++;
-				} else {
-					*cp++ = '\0';
-					if (!IsCorrectPath(shared_buffer, 1, 0, -1)) {
-						printf("%u: ERROR: '%s' is a bad pattern.\n", line, shared_buffer); errors++;
-					}
-					if (!IsCorrectPath(cp, 1, -1, -1)) {
-						printf("%u: ERROR: '%s' is a bad pathname.\n", line, cp); errors++;
-					}
-				}
-			} else if (strncmp(shared_buffer, KEYWORD_FILE_PATTERN, KEYWORD_FILE_PATTERN_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_FILE_PATTERN_LEN);
-				if (!IsCorrectPath(shared_buffer, 0, 1, 0)) {
-					printf("%u: ERROR: '%s' is a bad pattern.\n", line, shared_buffer); errors++;
-				}
-			} else if (strncmp(shared_buffer, KEYWORD_DENY_REWRITE, KEYWORD_DENY_REWRITE_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_DENY_REWRITE_LEN);
-				if (!IsCorrectPath(shared_buffer, 0, 0, 0)) {
-					printf("%u: ERROR: '%s' is a bad pattern.\n", line, shared_buffer); errors++;
-				}
-			} else if (strncmp(shared_buffer, KEYWORD_ALLOW_ENV, KEYWORD_ALLOW_ENV_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_ALLOW_ENV_LEN);
-				if (!IsCorrectPath(shared_buffer, 0, 0, 0)) {
-					printf("%u: ERROR: '%s' is a bad variable name.\n", line, shared_buffer); errors++;
-				}
-			} else {
-				printf("%u: ERROR: Unknown command '%s'.\n", line, shared_buffer); errors++;
-			}
+			check_exception_policy();
 			break;
 		case POLICY_TYPE_SYSTEM_POLICY:
-			if (strncmp(shared_buffer, KEYWORD_DELETE, KEYWORD_DELETE_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_DELETE_LEN);
-			}
-			if (strncmp(shared_buffer, KEYWORD_ALLOW_MOUNT, KEYWORD_ALLOW_MOUNT_LEN) == 0) {
-				CheckMountPolicy(shared_buffer + KEYWORD_ALLOW_MOUNT_LEN);
-			} else if (strncmp(shared_buffer, KEYWORD_DENY_UNMOUNT, KEYWORD_DENY_UNMOUNT_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_DENY_UNMOUNT_LEN);
-				if (!IsCorrectPath(shared_buffer, 1, 0, 1)) {
-					printf("%u: ERROR: '%s' is a bad pattern.\n", line, shared_buffer); errors++;
-				}
-			} else if (strncmp(shared_buffer, KEYWORD_ALLOW_CHROOT, KEYWORD_ALLOW_CHROOT_LEN) == 0) {
-				RemoveHeader(shared_buffer, KEYWORD_ALLOW_CHROOT_LEN);
-				if (!IsCorrectPath(shared_buffer, 1, 0, 1)) {
-					printf("%u: ERROR: '%s' is a bad pattern.\n", line, shared_buffer); errors++;
-				}
-			} else if (strncmp(shared_buffer, KEYWORD_ALLOW_PIVOT_ROOT, KEYWORD_ALLOW_PIVOT_ROOT_LEN) == 0) {
-				CheckPivotRootPolicy(shared_buffer + KEYWORD_ALLOW_PIVOT_ROOT_LEN);
-			} else if (strncmp(shared_buffer, KEYWORD_DENY_AUTOBIND, KEYWORD_DENY_AUTOBIND_LEN) == 0) {
-				CheckReservedPortPolicy(shared_buffer + KEYWORD_DENY_AUTOBIND_LEN);
-			} else {
-				printf("%u: ERROR: Unknown command '%s'.\n", line, shared_buffer); errors++;
-			}
+			check_system_policy();
 			break;
 		}
 	}
 	put();
-	printf("Total:   %u Line%s   %u Error%s   %u Warning%s\n", line, line > 1 ? "s" : "", errors, errors > 1 ? "s" : "", warnings, warnings > 1 ? "s" : "");
-	return (errors ? 2 : (warnings ? 1 : 0));
+	printf("Total:   %u Line%s   %u Error%s   %u Warning%s\n",
+	       line, line > 1 ? "s" : "", errors, errors > 1 ? "s" : "",
+	       warnings, warnings > 1 ? "s" : "");
+	return errors ? 2 : (warnings ? 1 : 0);
 }
Index: ccs-init
===================================================================
--- ccs-init	(リビジョン 1537)
+++ ccs-init	(作業コピー)
@@ -111,10 +111,15 @@
 
 # Load policy.
 if [ $CHDIR_OK -eq 1 ]; then
+    [ -r manager.base ] && cat manager.base > /proc/ccs/manager
     [ -r manager.conf ] && cat manager.conf > /proc/ccs/manager
+    [ -r system_policy.base -a -w /proc/ccs/system_policy ] && cat system_policy.base > /proc/ccs/system_policy
     [ -r system_policy.conf -a -w /proc/ccs/system_policy ] && cat system_policy.conf > /proc/ccs/system_policy
+    [ -r exception_policy.base -a -w /proc/ccs/exception_policy ] && cat exception_policy.base > /proc/ccs/exception_policy
     [ -r exception_policy.conf -a -w /proc/ccs/exception_policy ] && cat exception_policy.conf > /proc/ccs/exception_policy
+    [ $TOMOYO_NOLOAD -eq 0 -a -r domain_policy.base -a -w /proc/ccs/domain_policy ] && cat domain_policy.base > /proc/ccs/domain_policy
     [ $TOMOYO_NOLOAD -eq 0 -a -r domain_policy.conf -a -w /proc/ccs/domain_policy ] && cat domain_policy.conf > /proc/ccs/domain_policy
+    [ -r profile.base ] && cat profile.base > /proc/ccs/profile
     if [ "x$PROFILE" = "xdefault" ]; then
 	[ -r profile.conf ] && cat profile.conf > /proc/ccs/profile
     elif [ "x$PROFILE" != "xdisable" ]; then
Index: tomoyo-init
===================================================================
--- tomoyo-init	(リビジョン 1537)
+++ tomoyo-init	(作業コピー)
@@ -131,10 +131,15 @@
 
 # Load policy.
 if [ $CHDIR_OK -eq 1 ]; then
+    [ -r manager.base ] && cat manager.base > $POLICY_DIR/manager
     [ -r manager.conf ] && cat manager.conf > $POLICY_DIR/manager
+    [ -r system_policy.base -a -w $POLICY_DIR/system_policy ] && cat system_policy.base > $POLICY_DIR/system_policy
     [ -r system_policy.conf -a -w $POLICY_DIR/system_policy ] && cat system_policy.conf > $POLICY_DIR/system_policy
+    [ -r exception_policy.base -a -w $POLICY_DIR/exception_policy ] && cat exception_policy.base > $POLICY_DIR/exception_policy
     [ -r exception_policy.conf -a -w $POLICY_DIR/exception_policy ] && cat exception_policy.conf > $POLICY_DIR/exception_policy
+    [ $TOMOYO_NOLOAD -eq 0 -a -r domain_policy.base -a -w $POLICY_DIR/domain_policy ] && cat domain_policy.base > $POLICY_DIR/domain_policy
     [ $TOMOYO_NOLOAD -eq 0 -a -r domain_policy.conf -a -w $POLICY_DIR/domain_policy ] && cat domain_policy.conf > $POLICY_DIR/domain_policy
+    [ -r profile.base ] && cat profile.base > $POLICY_DIR/profile
     if [ "x$PROFILE" = "xdefault" ]; then
 	[ -r profile.conf ] && cat profile.conf > $POLICY_DIR/profile
     elif [ "x$PROFILE" != "xdisable" ]; then
