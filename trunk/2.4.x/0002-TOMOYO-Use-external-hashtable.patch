TOMOYO: Use external hashtable for maintaining per task_struct variables.

Currently, TOMOYO's interactive enforcing mode cannot deal interpreter's
permission checks because variables the interactive enforcing mode wants to
read are stored in "struct linux_binprm"->"struct cred"->security but
"struct linux_binprm"->"struct cred"->security is not visible to other threads.

This patch changes TOMOYO to use external hashtable for maintaining security
context in order to make the interactive enforcing mode work.

By applying this patch, TOMOYO no longer requires "void *security" of various
kernel objects, making it easier to run multiple LSM modules in parallel.

diff --git a/security/tomoyo/common.c b/security/tomoyo/common.c
index 7556315..972a4a0 100644
--- a/security/tomoyo/common.c
+++ b/security/tomoyo/common.c
@@ -683,7 +683,8 @@ static bool tomoyo_manager(void)
 	struct tomoyo_manager *ptr;
 	const char *exe;
 	const struct task_struct *task = current;
-	const struct tomoyo_path_info *domainname = tomoyo_domain()->domainname;
+	const struct tomoyo_path_info *domainname =
+		tomoyo_current_domain()->domainname;
 	bool found = false;
 
 	if (!tomoyo_policy_loaded)
@@ -754,7 +755,7 @@ static bool tomoyo_select_one(struct tomoyo_io_buffer *head, const char *data)
 		else
 			p = find_task_by_vpid(pid);
 		if (p)
-			domain = tomoyo_real_domain(p);
+			domain = tomoyo_task_domain(p);
 		read_unlock(&tasklist_lock);
 		rcu_read_unlock();
 	} else if (!strncmp(data, "domain=", 7)) {
@@ -1188,7 +1189,7 @@ static void tomoyo_read_pid(struct tomoyo_io_buffer *head)
 	else
 		p = find_task_by_vpid(pid);
 	if (p)
-		domain = tomoyo_real_domain(p);
+		domain = tomoyo_task_domain(p);
 	read_unlock(&tasklist_lock);
 	rcu_read_unlock();
 	if (!domain)
@@ -1456,7 +1457,7 @@ static char *tomoyo_init_audit_log(int *len, struct tomoyo_request_info *r)
 	const char *header;
 	const char *domainname;
 	if (!r->domain)
-		r->domain = tomoyo_domain();
+		r->domain = tomoyo_current_domain();
 	domainname = r->domain->domainname->name;
 	header = tomoyo_print_header(r);
 	if (!header)
@@ -1537,7 +1538,7 @@ int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)
 		return 0;
 	}
 	if (!r->domain)
-		r->domain = tomoyo_domain();
+		r->domain = tomoyo_current_domain();
 	if (!atomic_read(&tomoyo_query_observers))
 		return -EPERM;
 	va_start(args, fmt);
@@ -1769,11 +1770,12 @@ static void tomoyo_read_self_domain(struct tomoyo_io_buffer *head)
 {
 	if (!head->r.eof) {
 		/*
-		 * tomoyo_domain()->domainname != NULL
+		 * tomoyo_current_domain()->domainname != NULL
 		 * because every process belongs to a domain and
 		 * the domain's name cannot be NULL.
 		 */
-		tomoyo_io_printf(head, "%s", tomoyo_domain()->domainname->name);
+		tomoyo_io_printf(head, "%s",
+				 tomoyo_current_domain()->domainname->name);
 		head->r.eof = true;
 	}
 }
diff --git a/security/tomoyo/common.h b/security/tomoyo/common.h
index 7c66bd8..05d25cb 100644
--- a/security/tomoyo/common.h
+++ b/security/tomoyo/common.h
@@ -395,10 +395,6 @@ struct tomoyo_acl_info {
  *      name of the domain to be created was too long or it could not allocate
  *      memory. If set to true, more than one process continued execve()
  *      without domain transition.
- *  (9) "users" is an atomic_t that holds how many "struct cred"->security
- *      are referring this "struct tomoyo_domain_info". If is_deleted == true
- *      and users == 0, this struct will be kfree()d upon next garbage
- *      collection.
  *
  * A domain's lifecycle is an analogy of files on / directory.
  * Multiple domains with the same domainname cannot be created (as with
@@ -417,7 +413,6 @@ struct tomoyo_domain_info {
 	bool quota_warned; /* Quota warnning flag.   */
 	bool ignore_global_allow_read; /* Ignore "allow_read" flag. */
 	bool transition_failed; /* Domain transition failed flag. */
-	atomic_t users; /* Number of referring credentials. */
 };
 
 /*
@@ -687,6 +682,90 @@ struct tomoyo_profile {
 	u8 config[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAX_MAC_CATEGORY_INDEX];
 };
 
+/*
+ * Structure for holding "struct tomoyo_domain_info *" and "u32 tomoyo_flags"
+ * for each "struct task_struct".
+ */
+struct tomoyo_security {
+	struct list_head list;
+	const struct task_struct *task;
+	struct tomoyo_domain_info *tomoyo_domain_info;
+	struct tomoyo_domain_info *previous_domain_info;
+	u32 tomoyo_flags;
+	struct rcu_head rcu;
+};
+
+#define TOMOYO_TASK_SECURITY_HASH_BITS 12
+#define TOMOYO_MAX_TASK_SECURITY_HASH (1u << TOMOYO_TASK_SECURITY_HASH_BITS)
+extern struct list_head
+tomoyo_task_security_list[TOMOYO_MAX_TASK_SECURITY_HASH];
+
+struct tomoyo_security *tomoyo_find_task_security
+(const struct task_struct *task);
+
+/**
+ * tomoyo_current_security - Get "struct tomoyo_security" for current thread.
+ *
+ * Returns pointer to "struct tomoyo_security" for current thread.
+ */
+static inline struct tomoyo_security *tomoyo_current_security(void)
+{
+	return tomoyo_find_task_security(current);
+}
+
+/**
+ * tomoyo_task_domain - Get "struct tomoyo_domain_info" for specified thread.
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns pointer to "struct tomoyo_security" for specified thread.
+ */
+static inline struct tomoyo_domain_info *tomoyo_task_domain
+(struct task_struct *task)
+{
+	struct tomoyo_domain_info *domain;
+	rcu_read_lock();
+	domain = tomoyo_find_task_security(task)->tomoyo_domain_info;
+	rcu_read_unlock();
+	return domain;
+}
+
+/**
+ * tomoyo_current_domain - Get "struct tomoyo_domain_info" for current thread.
+ *
+ * Returns pointer to "struct tomoyo_domain_info" for current thread.
+ */
+static inline struct tomoyo_domain_info *tomoyo_current_domain(void)
+{
+	return tomoyo_find_task_security(current)->tomoyo_domain_info;
+}
+
+/**
+ * tomoyo_task_flags - Get flags for specified thread.
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns flags for specified thread.
+ */
+static inline u32 tomoyo_task_flags(struct task_struct *task)
+{
+	u32 tomoyo_flags;
+	rcu_read_lock();
+	tomoyo_flags = tomoyo_find_task_security(task)->tomoyo_flags;
+	rcu_read_unlock();
+	return tomoyo_flags;
+}
+
+/**
+ * tomoyo_current_flags - Get flags for current thread.
+ *
+ * Returns flags for current thread.
+ */
+static inline u32 tomoyo_current_flags(void)
+{
+	return tomoyo_find_task_security(current)->tomoyo_flags;
+}
+
 /********** Function prototypes. **********/
 
 /* Check whether the given string starts with the given keyword. */
@@ -912,6 +991,8 @@ extern const char *tomoyo_path_number_keyword[TOMOYO_MAX_PATH_NUMBER_OPERATION];
 extern unsigned int tomoyo_quota_for_query;
 extern unsigned int tomoyo_query_memory_size;
 
+extern bool tomoyo_registered;
+
 /********** Inlined functions. **********/
 
 static inline int tomoyo_read_lock(void)
@@ -970,17 +1051,6 @@ static inline void tomoyo_put_group(struct tomoyo_group *group)
 		atomic_dec(&group->users);
 }
 
-static inline struct tomoyo_domain_info *tomoyo_domain(void)
-{
-	return current_cred()->security;
-}
-
-static inline struct tomoyo_domain_info *tomoyo_real_domain(struct task_struct
-							    *task)
-{
-	return task_cred_xxx(task, security);
-}
-
 static inline bool tomoyo_same_acl_head(const struct tomoyo_acl_info *p1,
 					   const struct tomoyo_acl_info *p2)
 {
diff --git a/security/tomoyo/domain.c b/security/tomoyo/domain.c
index 3538840..fad1d24 100644
--- a/security/tomoyo/domain.c
+++ b/security/tomoyo/domain.c
@@ -415,7 +415,8 @@ int tomoyo_find_next_domain(struct linux_binprm *bprm)
 {
 	struct tomoyo_request_info r;
 	char *tmp = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);
-	struct tomoyo_domain_info *old_domain = tomoyo_domain();
+	struct tomoyo_security *security = tomoyo_current_security();
+	struct tomoyo_domain_info *old_domain = tomoyo_current_domain();
 	struct tomoyo_domain_info *domain = NULL;
 	const char *original_name = bprm->filename;
 	u8 mode;
@@ -532,9 +533,22 @@ int tomoyo_find_next_domain(struct linux_binprm *bprm)
  out:
 	if (!domain)
 		domain = old_domain;
-	/* Update reference count on "struct tomoyo_domain_info". */
-	atomic_inc(&domain->users);
-	bprm->cred->security = domain;
+	if (retval)
+		goto out2;
+	security->previous_domain_info = old_domain;
+	/*
+	 * Make security->previous_domain_info visible to GC before changing
+	 * security->tomoyo_domain_info.
+	 */
+	smp_wmb();
+	/*
+	 * Proceed to the next domain in order to allow reaching via PID.
+	 * It will be reverted if execve() failed. Reverting is not good.
+	 * But it is better than being unable to reach via PID in interactive
+	 * enforcing mode.
+	 */
+	security->tomoyo_domain_info = domain;
+out2:
 	if (need_kfree)
 		kfree(rn.name);
 	kfree(tmp);
diff --git a/security/tomoyo/gc.c b/security/tomoyo/gc.c
index a877e4c..2035203 100644
--- a/security/tomoyo/gc.c
+++ b/security/tomoyo/gc.c
@@ -127,6 +127,39 @@ static void tomoyo_del_acl(struct list_head *element)
 	}
 }
 
+/**
+ * tomoyo_used_by_task - Check whether the given pointer is referenced by a task.
+ *
+ * @domain: Pointer to "struct tomoyo_domain_info".
+ *
+ * Returns true if @domain is in use, false otherwise.
+ */
+static bool tomoyo_used_by_task(struct tomoyo_domain_info *domain)
+{
+	bool in_use = false;
+	int idx;
+	rcu_read_lock();
+	for (idx = 0; idx < TOMOYO_MAX_TASK_SECURITY_HASH; idx++) {
+		struct tomoyo_security *ptr;
+		struct list_head *list = &tomoyo_task_security_list[idx];
+		list_for_each_entry_rcu(ptr, list, list) {
+			if (ptr->previous_domain_info == domain) {
+				in_use = true;
+				goto out;
+			}
+			/* Avoid race with tomoyo_find_task_security(). */
+			smp_rmb();
+			if (ptr->tomoyo_domain_info == domain) {
+				in_use = true;
+				goto out;
+			}
+		}
+	}
+out:
+	rcu_read_unlock();
+	return in_use;
+}
+
 static bool tomoyo_del_domain(struct list_head *element)
 {
 	struct tomoyo_domain_info *domain =
@@ -135,7 +168,7 @@ static bool tomoyo_del_domain(struct list_head *element)
 	struct tomoyo_acl_info *tmp;
 	/*
 	 * Since we don't protect whole execve() operation using SRCU,
-	 * we need to recheck domain->users at this point.
+	 * we need to recheck domain at this point.
 	 *
 	 * (1) Reader starts SRCU section upon execve().
 	 * (2) Reader traverses tomoyo_domain_list and finds this domain.
@@ -143,19 +176,19 @@ static bool tomoyo_del_domain(struct list_head *element)
 	 * (4) Garbage collector removes this domain from tomoyo_domain_list
 	 *     because this domain is marked as deleted and used by nobody.
 	 * (5) Reader saves reference to this domain into
-	 *     "struct linux_binprm"->cred->security .
+	 *     "struct tomoyo_security"->previous_domain_info .
 	 * (6) Reader finishes SRCU section, although execve() operation has
 	 *     not finished yet.
 	 * (7) Garbage collector waits for SRCU synchronization.
 	 * (8) Garbage collector kfree() this domain because this domain is
 	 *     used by nobody.
 	 * (9) Reader finishes execve() operation and restores this domain from
-	 *     "struct linux_binprm"->cred->security.
+	 *     "struct tomoyo_security"->previous_domain_info.
 	 *
-	 * By updating domain->users at (5), we can solve this race problem
-	 * by rechecking domain->users at (8).
+	 * By rechecking whether this domain is used by somebody or not at (8),
+	 * we can solve this race problem.
 	 */
-	if (atomic_read(&domain->users))
+	if (tomoyo_used_by_task(domain))
 		return false;
 	list_for_each_entry_safe(acl, tmp, &domain->acl_info_list, list) {
 		tomoyo_del_acl(&acl->list);
@@ -230,12 +263,12 @@ static void tomoyo_collect_entry(void)
 		list_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {
 			if (!tomoyo_collect_acl(domain))
 				goto unlock;
-			if (!domain->is_deleted || atomic_read(&domain->users))
+			if (!domain->is_deleted || tomoyo_used_by_task(domain))
 				continue;
 			/*
 			 * Nobody is referring this domain. But somebody may
 			 * refer this domain after successful execve().
-			 * We recheck domain->users after SRCU synchronization.
+			 * We recheck after SRCU synchronization.
 			 */
 			if (!tomoyo_add_to_gc(TOMOYO_ID_DOMAIN, &domain->list))
 				goto unlock;
diff --git a/security/tomoyo/memory.c b/security/tomoyo/memory.c
index 2976126..2c487a6 100644
--- a/security/tomoyo/memory.c
+++ b/security/tomoyo/memory.c
@@ -204,6 +204,8 @@ void __init tomoyo_mm_init(void)
 	for (idx = 0; idx < TOMOYO_MAX_HASH; idx++)
 		INIT_LIST_HEAD(&tomoyo_name_list[idx]);
 	INIT_LIST_HEAD(&tomoyo_kernel_domain.acl_info_list);
+	for (idx = 0; idx < TOMOYO_MAX_TASK_SECURITY_HASH; idx++)
+		INIT_LIST_HEAD(&tomoyo_task_security_list[idx]);
 	tomoyo_kernel_domain.domainname = tomoyo_get_name(TOMOYO_ROOT_NAME);
 	list_add_tail_rcu(&tomoyo_kernel_domain.list, &tomoyo_domain_list);
 	idx = tomoyo_read_lock();
diff --git a/security/tomoyo/securityfs_if.c b/security/tomoyo/securityfs_if.c
index e43d555..97bcda2 100644
--- a/security/tomoyo/securityfs_if.c
+++ b/security/tomoyo/securityfs_if.c
@@ -125,7 +125,7 @@ static int __init tomoyo_initerface_init(void)
 	struct dentry *tomoyo_dir;
 
 	/* Don't create securityfs entries unless registered. */
-	if (current_cred()->security != &tomoyo_kernel_domain)
+	if (!tomoyo_registered)
 		return 0;
 
 	tomoyo_dir = securityfs_create_dir("tomoyo", NULL);
diff --git a/security/tomoyo/tomoyo.c b/security/tomoyo/tomoyo.c
index 95d3f95..7f7d34f 100644
--- a/security/tomoyo/tomoyo.c
+++ b/security/tomoyo/tomoyo.c
@@ -8,90 +8,7 @@
 
 #include <linux/security.h>
 #include "common.h"
-
-static int tomoyo_cred_alloc_blank(struct cred *new, gfp_t gfp)
-{
-	new->security = NULL;
-	return 0;
-}
-
-static int tomoyo_cred_prepare(struct cred *new, const struct cred *old,
-			       gfp_t gfp)
-{
-	struct tomoyo_domain_info *domain = old->security;
-	new->security = domain;
-	if (domain)
-		atomic_inc(&domain->users);
-	return 0;
-}
-
-static void tomoyo_cred_transfer(struct cred *new, const struct cred *old)
-{
-	tomoyo_cred_prepare(new, old, 0);
-}
-
-static void tomoyo_cred_free(struct cred *cred)
-{
-	struct tomoyo_domain_info *domain = cred->security;
-	if (domain)
-		atomic_dec(&domain->users);
-}
-
-static int tomoyo_bprm_set_creds(struct linux_binprm *bprm)
-{
-	int rc;
-
-	rc = cap_bprm_set_creds(bprm);
-	if (rc)
-		return rc;
-
-	/*
-	 * Do only if this function is called for the first time of an execve
-	 * operation.
-	 */
-	if (bprm->cred_prepared)
-		return 0;
-	/*
-	 * Load policy if /sbin/tomoyo-init exists and /sbin/init is requested
-	 * for the first time.
-	 */
-	if (!tomoyo_policy_loaded)
-		tomoyo_load_policy(bprm->filename);
-	/*
-	 * Release reference to "struct tomoyo_domain_info" stored inside
-	 * "bprm->cred->security". New reference to "struct tomoyo_domain_info"
-	 * stored inside "bprm->cred->security" will be acquired later inside
-	 * tomoyo_find_next_domain().
-	 */
-	atomic_dec(&((struct tomoyo_domain_info *)
-		     bprm->cred->security)->users);
-	/*
-	 * Tell tomoyo_bprm_check_security() is called for the first time of an
-	 * execve operation.
-	 */
-	bprm->cred->security = NULL;
-	return 0;
-}
-
-static int tomoyo_bprm_check_security(struct linux_binprm *bprm)
-{
-	struct tomoyo_domain_info *domain = bprm->cred->security;
-
-	/*
-	 * Execute permission is checked against pathname passed to do_execve()
-	 * using current domain.
-	 */
-	if (!domain) {
-		const int idx = tomoyo_read_lock();
-		const int err = tomoyo_find_next_domain(bprm);
-		tomoyo_read_unlock(idx);
-		return err;
-	}
-	/*
-	 * Read permission is checked against interpreters using next domain.
-	 */
-	return tomoyo_check_open_permission(domain, &bprm->file->f_path, O_RDONLY);
-}
+#include <linux/hash.h>
 
 static int tomoyo_path_truncate(struct path *path)
 {
@@ -187,7 +104,8 @@ static int tomoyo_dentry_open(struct file *f, const struct cred *cred)
 	/* Don't check read permission here if called from do_execve(). */
 	if (current->in_execve)
 		return 0;
-	return tomoyo_check_open_permission(tomoyo_domain(), &f->f_path, flags);
+	return tomoyo_check_open_permission(tomoyo_current_domain(),
+					    &f->f_path, flags);
 }
 
 static int tomoyo_file_ioctl(struct file *file, unsigned int cmd,
@@ -236,17 +154,165 @@ static int tomoyo_sb_pivotroot(struct path *old_path, struct path *new_path)
 	return tomoyo_path2_perm(TOMOYO_TYPE_PIVOT_ROOT, new_path, old_path);
 }
 
+/* Dummy security context for kernel domain. */
+static struct tomoyo_security tomoyo_default_security = {
+	.tomoyo_domain_info = &tomoyo_kernel_domain
+};
+
+/* List of "struct tomoyo_security". */
+struct list_head tomoyo_task_security_list[TOMOYO_MAX_TASK_SECURITY_HASH];
+/* Lock for protecting tomoyo_task_security_list[]. */
+static DEFINE_SPINLOCK(tomoyo_task_security_list_lock);
+
+/**
+ * tomoyo_alloc_task_security - Allocate memory for new tasks.
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_alloc_task_security(struct task_struct *task)
+{
+	unsigned long flags;
+	struct tomoyo_security *old_security = tomoyo_current_security();
+	struct tomoyo_security *new_security = kzalloc(sizeof(*new_security),
+						       GFP_KERNEL);
+	struct list_head *list = &tomoyo_task_security_list
+		[hash_ptr((void *) task, TOMOYO_TASK_SECURITY_HASH_BITS)];
+	if (!new_security)
+		return -ENOMEM;
+	*new_security = *old_security;
+	new_security->task = task;
+	spin_lock_irqsave(&tomoyo_task_security_list_lock, flags);
+	list_add_rcu(&new_security->list, list);
+	spin_unlock_irqrestore(&tomoyo_task_security_list_lock, flags);
+	return 0;
+}
+
+/**
+ * tomoyo_find_task_security - Find "struct tomoyo_security" for given task.
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns pointer to "struct tomoyo_security" on success,
+ * &tomoyo_default_security otherwise.
+ */
+struct tomoyo_security *tomoyo_find_task_security
+(const struct task_struct *task)
+{
+	struct tomoyo_security *ptr;
+	struct list_head *list = &tomoyo_task_security_list
+		[hash_ptr((void *) task, TOMOYO_TASK_SECURITY_HASH_BITS)];
+	rcu_read_lock();
+	list_for_each_entry_rcu(ptr, list, list) {
+		if (ptr->task != task)
+			continue;
+		rcu_read_unlock();
+		if (ptr->previous_domain_info && task == current &&
+		    !task->in_execve) {
+			/* do_execve() failed. Revert to previous domain. */
+			ptr->tomoyo_domain_info =
+				ptr->previous_domain_info;
+			/* Make sure that GC sees valid domain. */
+			smp_wmb();
+			ptr->previous_domain_info = NULL;
+		}
+		return ptr;
+	}
+	rcu_read_unlock();
+	return &tomoyo_default_security;
+}
+
+/**
+ * tomoyo_rcu_free - RCU callback for releasing "struct tomoyo_security".
+ *
+ * @rcu: Pointer to "struct rcu_head".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_rcu_free(struct rcu_head *rcu)
+{
+	struct tomoyo_security *ptr = container_of(rcu, typeof(*ptr), rcu);
+	kfree(ptr);
+}
+
+/**
+ * tomoyo_free_task_security - Release memory associated with "struct task_struct".
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_free_task_security(struct task_struct *task)
+{
+	unsigned long flags;
+	struct tomoyo_security *ptr = tomoyo_find_task_security(task);
+	if (ptr == &tomoyo_default_security)
+		return;
+	spin_lock_irqsave(&tomoyo_task_security_list_lock, flags);
+	list_del_rcu(&ptr->list);
+	spin_unlock_irqrestore(&tomoyo_task_security_list_lock, flags);
+	call_rcu(&ptr->rcu, tomoyo_rcu_free);
+}
+
+/**
+ * tomoyo_bprm_committing_creds - A hook which is called when do_execve() succeeded.
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_bprm_committing_creds(struct linux_binprm *bprm)
+{
+	struct tomoyo_security *old_security;
+	old_security = tomoyo_current_security();
+	if (old_security == &tomoyo_default_security)
+		return;
+	/* do_execve() succeeded. Forget previous domain. */
+	old_security->previous_domain_info = NULL;
+}
+
+/**
+ * tomoyo_bprm_check_security - Check permission for execve().
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_bprm_check_security(struct linux_binprm *bprm)
+{
+	int rc;
+	struct tomoyo_security *security;
+	/*
+	 * Load policy if /sbin/tomoyo-init exists and /sbin/init is requested
+	 * for the first time.
+	 */
+	if (!tomoyo_policy_loaded)
+		tomoyo_load_policy(bprm->filename);
+	security = tomoyo_current_security();
+	if (security == &tomoyo_default_security)
+		return -ENOMEM;
+	if (!security->previous_domain_info) {
+		const int idx = tomoyo_read_lock();
+		rc = tomoyo_find_next_domain(bprm);
+		tomoyo_read_unlock(idx);
+	} else {
+		rc = tomoyo_check_open_permission(security->tomoyo_domain_info,
+						  &bprm->file->f_path,
+						  O_RDONLY);
+	}
+	return rc;
+}
+
 /*
  * tomoyo_security_ops is a "struct security_operations" which is used for
  * registering TOMOYO.
  */
 static struct security_operations tomoyo_security_ops = {
 	.name                = "tomoyo",
-	.cred_alloc_blank    = tomoyo_cred_alloc_blank,
-	.cred_prepare        = tomoyo_cred_prepare,
-	.cred_transfer	     = tomoyo_cred_transfer,
-	.cred_free           = tomoyo_cred_free,
-	.bprm_set_creds      = tomoyo_bprm_set_creds,
+	.task_alloc_security = tomoyo_alloc_task_security,
+	.task_free_security  = tomoyo_free_task_security,
+	.bprm_committing_creds = tomoyo_bprm_committing_creds,
 	.bprm_check_security = tomoyo_bprm_check_security,
 	.file_fcntl          = tomoyo_file_fcntl,
 	.dentry_open         = tomoyo_dentry_open,
@@ -270,10 +336,11 @@ static struct security_operations tomoyo_security_ops = {
 /* Lock for GC. */
 struct srcu_struct tomoyo_ss;
 
+/* TOMOYO registered by register_security()? */
+bool tomoyo_registered;
+
 static int __init tomoyo_init(void)
 {
-	struct cred *cred = (struct cred *) current_cred();
-
 	if (!security_module_enable(&tomoyo_security_ops))
 		return 0;
 	/* register ourselves with the security framework */
@@ -281,8 +348,8 @@ static int __init tomoyo_init(void)
 	    init_srcu_struct(&tomoyo_ss))
 		panic("Failure registering TOMOYO Linux");
 	printk(KERN_INFO "TOMOYO Linux initialized\n");
-	cred->security = &tomoyo_kernel_domain;
 	tomoyo_mm_init();
+	tomoyo_registered = true; 
 	return 0;
 }
 
diff --git a/security/tomoyo/util.c b/security/tomoyo/util.c
index 9bfc1ee..dea5d6f 100644
--- a/security/tomoyo/util.c
+++ b/security/tomoyo/util.c
@@ -817,7 +817,7 @@ int tomoyo_get_mode(const u8 profile, const u8 index)
  * tomoyo_init_request_info - Initialize "struct tomoyo_request_info" members.
  *
  * @r:      Pointer to "struct tomoyo_request_info" to initialize.
- * @domain: Pointer to "struct tomoyo_domain_info". NULL for tomoyo_domain().
+ * @domain: Pointer to "struct tomoyo_domain_info". NULL for tomoyo_current_domain().
  * @index:  Index number of functionality.
  *
  * Returns mode.
@@ -828,7 +828,7 @@ int tomoyo_init_request_info(struct tomoyo_request_info *r,
 	u8 profile;
 	memset(r, 0, sizeof(*r));
 	if (!domain)
-		domain = tomoyo_domain();
+		domain = tomoyo_current_domain();
 	r->domain = domain;
 	profile = domain->profile;
 	r->profile = profile;
