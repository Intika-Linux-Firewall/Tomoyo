Subject: TOMOYO: Use struct for passing execve() param.

Use structure for passing arguments and buffers for execve(), in preparation
for passing conditional parameters.

Since security_bprm_free() was revived, TOMOYO can now enclose the entire
do_execve() operation within an SRCU section, making the garbage collection
easier.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.h |   36 ++++++++---
 security/tomoyo/domain.c |  144 ++++++++++++++++++++++++++++++++---------------
 security/tomoyo/file.c   |    3 
 security/tomoyo/gc.c     |   33 ++--------
 security/tomoyo/tomoyo.c |   46 +++++++--------
 5 files changed, 158 insertions(+), 104 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -241,11 +241,14 @@ enum tomoyo_value_type {
 #define TOMOYO_TASK_SECURITY_HASH_BITS 12
 #define TOMOYO_MAX_TASK_SECURITY_HASH (1u << TOMOYO_TASK_SECURITY_HASH_BITS)
 
+
+/* Current thread is doing do_execve() ? */
+#define TOMOYO_TASK_IS_IN_EXECVE 1
 /*
  * Current thread is allowed to modify policy via /sys/kernel/security/tomoyo/
  * interface?
  */
-#define TOMOYO_TASK_IS_MANAGER 1
+#define TOMOYO_TASK_IS_MANAGER   2
 
 /* Structure definition for internal use. */
 
@@ -311,9 +314,16 @@ struct tomoyo_number_group {
 	struct tomoyo_number_union number;
 };
 
+struct tomoyo_execve;
+
 /* Structure for request info. */
 struct tomoyo_request_info {
 	/*
+	 * For holding parameters specific to execve() request.
+	 * NULL if not dealing do_execve().
+	 */
+	struct tomoyo_execve *ee;
+	/*
 	 * For holding parameters.
 	 * Pointers in this union are not NULL except path->matched_path.
 	 */
@@ -386,6 +396,16 @@ struct tomoyo_path_info {
 	bool is_patterned; /* = tomoyo_path_contains_pattern(name) */
 };
 
+/* Structure for execve() operation. */
+struct tomoyo_execve {
+	struct tomoyo_request_info r;
+	struct linux_binprm *bprm;
+	struct tomoyo_domain_info *previous_domain;
+	int reader_idx;
+	/* For temporary use. */
+	char *tmp; /* Size is TOMOYO_EXEC_TMPSIZE bytes */
+};
+
 /* Structure for domain information. */
 struct tomoyo_domain_info {
 	struct list_head list;
@@ -558,7 +578,8 @@ struct tomoyo_time {
 };
 
 /*
- * Structure for holding "struct tomoyo_domain_info *" for each
+ * Structure for holding "struct tomoyo_domain_info *" and
+ * "struct tomoyo_execve *" and "u32 tomoyo_flags" for each
  * "struct task_struct".
  */
 struct tomoyo_security {
@@ -571,12 +592,8 @@ struct tomoyo_security {
 	struct tomoyo_domain_info *tomoyo_domain_info;
 	/* Holds current thread's attributes. */
 	u32 tomoyo_flags;
-	/*
-	 * Holds previous tomoyo_domain_info during do_execve() in case
-	 * do_execve() failed, NULL otherwise. Only current thread can access
-	 * this member.
-	 */
-	struct tomoyo_domain_info *previous_domain_info;
+	/* Holds parameters used during do_execve(). */
+	struct tomoyo_execve *ee; /* Maybe NULL. */
 	struct rcu_head rcu;
 };
 
@@ -617,7 +634,6 @@ const struct tomoyo_path_info *tomoyo_pa
 (const struct tomoyo_path_info *pathname, const struct tomoyo_group *group);
 int tomoyo_check_open_permission(struct path *path, const int flag);
 int tomoyo_close_control(struct file *file);
-int tomoyo_find_next_domain(struct linux_binprm *bprm);
 int tomoyo_get_mode(const u8 profile, const u8 index);
 int tomoyo_init_request_info(struct tomoyo_request_info *r, const u8 index);
 int tomoyo_mkdev_perm(const u8 operation, struct path *path,
@@ -637,6 +653,7 @@ int tomoyo_poll_control(struct file *fil
 int tomoyo_poll_log(struct file *file, poll_table *wait);
 int tomoyo_read_control(struct file *file, char __user *buffer,
 			const int buffer_len);
+int tomoyo_start_execve(struct linux_binprm *bprm, struct tomoyo_execve **eep);
 int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)
 	__attribute__ ((format(printf, 2, 3)));
 int tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,
@@ -678,6 +695,7 @@ void tomoyo_check_acl(struct tomoyo_requ
 					   const struct tomoyo_acl_info *));
 void tomoyo_check_profile(void);
 void tomoyo_fill_path_info(struct tomoyo_path_info *ptr);
+void tomoyo_finish_execve(const bool succeeded);
 void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt, ...)
 	__attribute__ ((format(printf, 2, 3)));
 void tomoyo_load_policy(const char *filename);
--- security-testing-2.6.orig/security/tomoyo/domain.c
+++ security-testing-2.6/security/tomoyo/domain.c
@@ -448,34 +448,26 @@ struct tomoyo_domain_info *tomoyo_assign
 /**
  * tomoyo_find_next_domain - Find a domain.
  *
- * @bprm: Pointer to "struct linux_binprm".
+ * @ee: Pointer to "struct tomoyo_execve".
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds tomoyo_read_lock().
  */
-int tomoyo_find_next_domain(struct linux_binprm *bprm)
+static int tomoyo_find_next_domain(struct tomoyo_execve *ee)
 {
-	struct tomoyo_request_info r;
-	char *tmp = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);
-	struct tomoyo_security *security = tomoyo_current_security();
-	struct tomoyo_domain_info *old_domain = tomoyo_current_domain();
+	struct tomoyo_request_info *r = &ee->r;
 	struct tomoyo_domain_info *domain = NULL;
-	const char *original_name = bprm->filename;
-	u8 mode;
-	bool is_enforce;
-	int retval = -ENOMEM;
-	bool need_kfree = false;
+	struct tomoyo_domain_info *old_domain = tomoyo_current_domain();
+	struct linux_binprm *bprm = ee->bprm;
+	struct tomoyo_security *security = tomoyo_current_security();
 	struct tomoyo_path_info rn = { }; /* real name */
+	int retval;
+	bool need_kfree = false;
 
 	/* Clear manager flag. */
 	security->tomoyo_flags &= ~TOMOYO_TASK_IS_MANAGER;
 
-	mode = tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_EXECUTE);
-	is_enforce = (mode == TOMOYO_CONFIG_ENFORCING);
-	if (!tmp)
-		goto out;
-
  retry:
 	if (need_kfree) {
 		kfree(rn.name);
@@ -483,7 +475,7 @@ int tomoyo_find_next_domain(struct linux
 	}
 	/* Get symlink's pathname of program. */
 	retval = -ENOENT;
-	rn.name = tomoyo_realpath_nofollow(original_name);
+	rn.name = tomoyo_realpath_nofollow(bprm->filename);
 	if (!rn.name)
 		goto out;
 	tomoyo_fill_path_info(&rn);
@@ -507,7 +499,7 @@ int tomoyo_find_next_domain(struct linux
 	}
 
 	/* Check execute permission. */
-	retval = tomoyo_path_permission(&r, TOMOYO_TYPE_EXECUTE, &rn);
+	retval = tomoyo_path_permission(r, TOMOYO_TYPE_EXECUTE, &rn);
 	if (retval == TOMOYO_RETRY_REQUEST)
 		goto retry;
 	if (retval < 0)
@@ -518,19 +510,19 @@ int tomoyo_find_next_domain(struct linux
 	 * wildcard) rather than the pathname passed to execve()
 	 * (which never contains wildcard).
 	 */
-	if (r.param.path.matched_path) {
+	if (r->param.path.matched_path) {
 		if (need_kfree)
 			kfree(rn.name);
 		need_kfree = false;
 		/* This is OK because it is read only. */
-		rn = *r.param.path.matched_path;
+		rn = *r->param.path.matched_path;
 	}
 
 	/* Calculate domain to transit to. */
 	switch (tomoyo_transition_type(old_domain->domainname, &rn)) {
 	case TOMOYO_TRANSITION_CONTROL_INITIALIZE:
 		/* Transit to the child of tomoyo_kernel_domain domain. */
-		snprintf(tmp, TOMOYO_EXEC_TMPSIZE - 1, TOMOYO_ROOT_NAME " "
+		snprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, TOMOYO_ROOT_NAME " "
 			 "%s", rn.name);
 		break;
 	case TOMOYO_TRANSITION_CONTROL_KEEP:
@@ -549,44 +541,106 @@ int tomoyo_find_next_domain(struct linux
 			domain = old_domain;
 		} else {
 			/* Normal domain transition. */
-			snprintf(tmp, TOMOYO_EXEC_TMPSIZE - 1, "%s %s",
+			snprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, "%s %s",
 				 old_domain->domainname->name, rn.name);
 		}
 		break;
 	}
-	if (domain || strlen(tmp) >= TOMOYO_EXEC_TMPSIZE - 10)
-		goto done;
-	domain = tomoyo_find_domain(tmp);
-	if (!domain)
-		domain = tomoyo_assign_domain(tmp, old_domain->profile);
- done:
-	if (domain)
-		goto out;
-	printk(KERN_WARNING "TOMOYO-ERROR: Domain '%s' not defined.\n", tmp);
-	if (is_enforce)
-		retval = -EPERM;
-	else
-		old_domain->transition_failed = true;
- out:
-	if (!domain)
-		domain = old_domain;
-	if (retval)
-		goto out2;
-	security->previous_domain_info = old_domain;
 	/*
-	 * Make security->previous_domain_info visible to GC before changing
+	 * Tell GC that I started execve().
+	 * Also, tell open_exec() to check read permission.
+	 */
+	security->tomoyo_flags |= TOMOYO_TASK_IS_IN_EXECVE;
+	/*
+	 * Make security->tomoyo_flags visible to GC before changing
 	 * security->tomoyo_domain_info.
 	 */
 	smp_wmb();
+	if (!domain && strlen(ee->tmp) < TOMOYO_EXEC_TMPSIZE - 10)
+		domain = tomoyo_assign_domain(ee->tmp, old_domain->profile);
 	/*
 	 * Proceed to the next domain in order to allow checking permissions
 	 * for binary loader programs. Current thread will go back to the
 	 * previous domain if do_execve() failed.
 	 */
-	security->tomoyo_domain_info = domain;
-out2:
+	if (domain) {
+		retval = 0;
+		security->tomoyo_domain_info = domain;
+	} else if (r->mode == TOMOYO_CONFIG_ENFORCING)
+		retval = -ENOMEM;
+	else {
+		retval = 0;
+		printk(KERN_WARNING "TOMOYO-ERROR: Domain '%s' not defined.\n",
+		       ee->tmp);
+		old_domain->transition_failed = true;
+	}
+out:
 	if (need_kfree)
 		kfree(rn.name);
-	kfree(tmp);
 	return retval;
 }
+
+/**
+ * tomoyo_start_execve - Prepare for execve() operation.
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ * @eep:  Pointer to "struct tomoyo_execve *".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int tomoyo_start_execve(struct linux_binprm *bprm, struct tomoyo_execve **eep)
+{
+	struct tomoyo_security *security = tomoyo_current_security();
+	struct tomoyo_execve *ee;
+
+	*eep = NULL;
+	ee = kzalloc(sizeof(*ee), GFP_NOFS);
+	if (!ee)
+		return -ENOMEM;
+	ee->tmp = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);
+	if (!ee->tmp) {
+		kfree(ee);
+		return -ENOMEM;
+	}
+	ee->reader_idx = tomoyo_read_lock();
+	ee->previous_domain = security->tomoyo_domain_info;
+	/* Clear manager flag. */
+	security->tomoyo_flags &= ~TOMOYO_TASK_IS_MANAGER;
+	*eep = ee;
+	tomoyo_init_request_info(&ee->r, TOMOYO_MAC_FILE_EXECUTE);
+	ee->r.ee = ee;
+	ee->bprm = bprm;
+	return tomoyo_find_next_domain(ee);
+}
+
+/**
+ * tomoyo_finish_execve - Clean up execve() operation.
+ *
+ * @succeeded: True if do_execve() succeeded, false otherwise.
+ *
+ * Returns nothing.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+void tomoyo_finish_execve(const bool succeeded)
+{
+	struct tomoyo_security *security = tomoyo_current_security();
+	struct tomoyo_execve *ee = security->ee;
+
+	if (!ee)
+		return;
+	security->ee = NULL;
+	if (!succeeded) {
+		security->tomoyo_domain_info = ee->previous_domain;
+		/*
+		 * Make security->tomoyo_domain_info visible to GC before
+		 * changing security->tomoyo_flags.
+		 */
+		smp_wmb();
+	}
+	/* Tell GC that I finished execve(). */
+	security->tomoyo_flags &= ~TOMOYO_TASK_IS_IN_EXECVE;
+	tomoyo_read_unlock(ee->reader_idx);
+	kfree(ee->tmp);
+	kfree(ee);
+}
--- security-testing-2.6.orig/security/tomoyo/file.c
+++ security-testing-2.6/security/tomoyo/file.c
@@ -724,7 +724,8 @@ int tomoyo_check_open_permission(struct 
 	 * functions.
 	 */
 	if (current->in_execve &&
-	    !tomoyo_current_security()->previous_domain_info)
+	    !(tomoyo_current_security()->tomoyo_flags &
+	      TOMOYO_TASK_IS_IN_EXECVE))
 		return 0;
 	buf.name = NULL;
 	r.mode = TOMOYO_CONFIG_DISABLED;
--- security-testing-2.6.orig/security/tomoyo/gc.c
+++ security-testing-2.6/security/tomoyo/gc.c
@@ -167,10 +167,9 @@ static bool tomoyo_used_by_task(struct t
 	/*
 	 * Don't delete this domain if somebody is doing execve().
 	 *
-	 * Since tomoyo_find_task_security() first reverts tomoyo_domain_info
-	 * and then clears previous_domain_info, we need smp_rmb() to make sure
-	 * that GC first checks previous_domain_info and then checks
-	 * tomoyo_domain_info.
+	 * Since tomoyo_finish_execve() first reverts tomoyo_domain_info and
+	 * then updates tomoyo_flags, we need smp_rmb() to make sure that GC
+	 * first checks tomoyo_flags and then checks tomoyo_domain_info.
 	 */
 	int idx;
 	rcu_read_lock();
@@ -178,7 +177,7 @@ static bool tomoyo_used_by_task(struct t
 		struct tomoyo_security *ptr;
 		struct list_head *list = &tomoyo_task_security_list[idx];
 		list_for_each_entry_rcu(ptr, list, list) {
-			if (ptr->previous_domain_info != domain) {
+			if (!(ptr->tomoyo_flags & TOMOYO_TASK_IS_IN_EXECVE)) {
 				smp_rmb(); /* Avoid out of order execution. */
 				if (ptr->tomoyo_domain_info != domain)
 					continue;
@@ -206,26 +205,10 @@ static bool tomoyo_del_domain(struct lis
 	struct tomoyo_acl_info *acl;
 	struct tomoyo_acl_info *tmp;
 	/*
-	 * Since we don't protect whole execve() operation using SRCU,
-	 * we need to recheck domain at this point.
-	 *
-	 * (1) Reader starts SRCU section upon execve().
-	 * (2) Reader traverses tomoyo_domain_list and finds this domain.
-	 * (3) Writer marks this domain as deleted.
-	 * (4) Garbage collector removes this domain from tomoyo_domain_list
-	 *     because this domain is marked as deleted and used by nobody.
-	 * (5) Reader saves reference to this domain into
-	 *     "struct tomoyo_security"->previous_domain_info .
-	 * (6) Reader finishes SRCU section, although execve() operation has
-	 *     not finished yet.
-	 * (7) Garbage collector waits for SRCU synchronization.
-	 * (8) Garbage collector kfree() this domain because this domain is
-	 *     used by nobody.
-	 * (9) Reader finishes execve() operation and restores this domain from
-	 *     "struct tomoyo_security"->previous_domain_info.
-	 *
-	 * By rechecking whether this domain is used by somebody or not at (8),
-	 * we can solve this race problem.
+	 * Since we now protect whole execve() operation using SRCU, we no
+	 * longer need to worry about execve(). But we keep this check because
+	 * we will change GC not to wait for /sys/kernel/security/tomoyo/ users
+	 * to close().
 	 */
 	if (tomoyo_used_by_task(domain))
 		return false;
--- security-testing-2.6.orig/security/tomoyo/tomoyo.c
+++ security-testing-2.6/security/tomoyo/tomoyo.c
@@ -280,20 +280,31 @@ static void tomoyo_free_task_security(st
 }
 
 /**
- * tomoyo_bprm_committing_creds - A hook which is called when do_execve() succeeded.
+ * tomoyo_clear_execve - Release memory used by do_execve().
  *
- * @bprm: Pointer to "struct linux_binprm".
+ * @succeeded: True if do_execve() succeeded, false otherwise.
  *
  * Returns nothing.
  */
-static void tomoyo_bprm_committing_creds(struct linux_binprm *bprm)
+static void tomoyo_clear_execve(const bool succeeded)
 {
 	struct tomoyo_security *security = tomoyo_current_security();
 	if (security == &tomoyo_default_security ||
 	    security == &tomoyo_oom_security)
 		return;
-	/* do_execve() succeeded. Forget previous domain. */
-	security->previous_domain_info = NULL;
+	tomoyo_finish_execve(succeeded);
+}
+
+/**
+ * tomoyo_bprm_committing_creds - A hook which is called when do_execve() succeeded.
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_bprm_committing_creds(struct linux_binprm *bprm)
+{
+	tomoyo_clear_execve(true);
 }
 
 /**
@@ -305,21 +316,12 @@ static void tomoyo_bprm_committing_creds
  */
 static void tomoyo_bprm_free_security(struct linux_binprm *bprm)
 {
-	struct tomoyo_security *security = tomoyo_current_security();
-	if (security == &tomoyo_default_security ||
-	    security == &tomoyo_oom_security)
-		return;
 	/*
-	 * tomoyo_bprm_committing_creds() already cleared it if do_execve()
-	 * succeeded.
+	 * If do_execve() succeeded, tomoyo_clear_execve(true); is called
+	 * before calling below one.
+	 * Thus, below call becomes no-op if do_execve() succeeded.
 	 */
-	if (!security->previous_domain_info)
-		return;
-	/* do_execve() failed. Revert to previous domain. */
-	security->tomoyo_domain_info = security->previous_domain_info;
-	/* Make sure that GC sees valid domain. */
-	smp_wmb();
-	security->previous_domain_info = NULL;
+	tomoyo_clear_execve(false);
 }
 
 /**
@@ -342,12 +344,8 @@ static int tomoyo_bprm_check_security(st
 	if (security == &tomoyo_default_security ||
 	    security == &tomoyo_oom_security)
 		return -ENOMEM;
-	if (!security->previous_domain_info) {
-		const int idx = tomoyo_read_lock();
-		const int rc = tomoyo_find_next_domain(bprm);
-		tomoyo_read_unlock(idx);
-		return rc;
-	}
+	if (!security->ee)
+		return tomoyo_start_execve(bprm, &security->ee);
 	return 0;
 }
 
