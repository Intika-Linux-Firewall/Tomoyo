From 62ca784dd56967c44c77b9876bef0f1b38d0ebcc Mon Sep 17 00:00:00 2001
From: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date: Mon, 29 Aug 2011 23:19:36 +0900
Subject: [PATCH] Update TOMOYO testcases for Linux 3.1

Copied from from tomoyo-tools 2.4 and dropped some
programs which are not implemented as of Linux 3.1.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 testcases/kernel/security/tomoyo/README            |   11 +-
 testcases/kernel/security/tomoyo/include.h         |  469 +++++++++++++++-----
 testcases/kernel/security/tomoyo/newns.c           |   50 ++-
 testcases/kernel/security/tomoyo/testall.sh        |   46 ++-
 .../kernel/security/tomoyo/tomoyo_accept_test.c    |  101 ++---
 .../kernel/security/tomoyo/tomoyo_argv0_test.c     |  112 +++++
 .../kernel/security/tomoyo/tomoyo_bprm_test.c      |  192 ++++++++
 .../kernel/security/tomoyo/tomoyo_cond_test.c      |  443 ++++++++++++++++++
 .../kernel/security/tomoyo/tomoyo_file_test.c      |   93 +++--
 .../security/tomoyo/tomoyo_filesystem_test.c       |  155 ++++----
 .../kernel/security/tomoyo/tomoyo_new_file_test.c  |  295 +++++++------
 testcases/kernel/security/tomoyo/tomoyo_new_test.c |  389 +++++++----------
 .../kernel/security/tomoyo/tomoyo_policy_io_test.c |  205 +++++----
 .../security/tomoyo/tomoyo_policy_memory_test.c    |  306 +++++++------
 .../kernel/security/tomoyo/tomoyo_rewrite_test.c   |   86 +---
 15 files changed, 1927 insertions(+), 1026 deletions(-)
 mode change 100644 => 100755 testcases/kernel/security/tomoyo/testall.sh
 create mode 100644 testcases/kernel/security/tomoyo/tomoyo_argv0_test.c
 create mode 100644 testcases/kernel/security/tomoyo/tomoyo_bprm_test.c
 create mode 100644 testcases/kernel/security/tomoyo/tomoyo_cond_test.c

diff --git a/testcases/kernel/security/tomoyo/README b/testcases/kernel/security/tomoyo/README
index 0cb5388..ba892f1 100644
--- a/testcases/kernel/security/tomoyo/README
+++ b/testcases/kernel/security/tomoyo/README
@@ -1,5 +1,5 @@
 Always look here for latest version of these tests:
-http://sourceforge.jp/projects/tomoyo/svn/view/trunk/2.3.x/tomoyo-tools/kernel_test/?root=tomoyo
+http://sourceforge.jp/projects/tomoyo/svn/view/trunk/2.4.x/tomoyo-tools/kernel_test/?root=tomoyo
 
 These testcases test the TOMOYO Security Module. And they are not part of
 default LTP build/install/run.
@@ -11,7 +11,7 @@ Preparation steps are:
 
 1) Download tomoyo-tools package and extract and build and install.
 
-  # wget -O tomoyo-tools.tar.gz 'http://sourceforge.jp/projects/tomoyo/svn/view/trunk/2.3.x/tomoyo-tools.tar.gz?root=tomoyo&view=tar'
+  # wget -O tomoyo-tools.tar.gz 'http://sourceforge.jp/projects/tomoyo/svn/view/trunk/2.4.x/tomoyo-tools.tar.gz?root=tomoyo&view=tar'
   # tar -zxf tomoyo-tools.tar.gz
   # make -C tomoyo-tools/ install
 
@@ -23,11 +23,6 @@ Preparation steps are:
 
 2) Run /usr/lib/tomoyo/init_policy .
 
-   This will take several minutes.
-
-   Hiding kernel source directory by "mount -t tmpfs none /usr/src/linux/"
-   would save some time.
-
    Configuration files are saved in /etc/tomoyo/ directory.
    You can do "rm -fR /etc/tomoyo/" if you want to uninstall.
 
@@ -44,7 +39,7 @@ Preparation steps are:
    # cd testcases/kernel/security/tomoyo/
    # make
    # find `/bin/pwd` -type f -perm +100 >> /etc/tomoyo/manager.conf
-   # /usr/sbin/tomoyo-loadpolicy m
+   # /usr/sbin/tomoyo-loadpolicy -m < /etc/tomoyo/manager.conf
 
 Test steps are:
 
diff --git a/testcases/kernel/security/tomoyo/include.h b/testcases/kernel/security/tomoyo/include.h
index c99ac6b..05c3efd 100644
--- a/testcases/kernel/security/tomoyo/include.h
+++ b/testcases/kernel/security/tomoyo/include.h
@@ -1,37 +1,38 @@
-/******************************************************************************/
-/*                                                                            */
-/* Copyright (c) Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>, 2009      */
-/*                                                                            */
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    */
-/*                                                                            */
-/******************************************************************************/
 /*
  * include.h
  *
  * Common functions for testing TOMOYO Linux's kernel.
  *
- * Copyright (C) 2005-2010  NTT DATA CORPORATION
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
+ *
+ * Version: 2.4.0+   2011/08/20
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 #include <errno.h>
 #include <fcntl.h>
 #include <linux/kdev_t.h>
+struct module;
+#include <linux/reboot.h>
 #include <linux/unistd.h>
+#include <netinet/in.h>
 #include <pty.h>
+#include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/mount.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/syscall.h>
@@ -44,45 +45,66 @@
 #include <time.h>
 #include <unistd.h>
 #include <utime.h>
-#include "test.h"
-#include <sched.h>
-#include <stdarg.h>
-#include <sys/mount.h>
 #include <arpa/inet.h>
-#include <net/if.h>
+#include <asm/byteorder.h>
 #include <linux/ip.h>
-#include <err.h>
+#include <sched.h>
+#ifndef CLONE_NEWNS
+#include <linux/sched.h>
+#endif
+#include <sys/ptrace.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
+#include <stdarg.h>
 
-/* 
- * Some architectures like mips n32 don't have __NR_uselib defined in the
- * system headers.
- */
-#ifdef __NR_uselib
+#ifndef __NR_sys_kexec_load
+#ifdef __NR_kexec_load
+#define __NR_sys_kexec_load  __NR_kexec_load
+#endif
+#endif
+/* #define __NR_sys_kexec_load 283 */
+
+static inline pid_t gettid(void)
+{
+	return syscall(__NR_gettid);
+}
 static inline int uselib(const char *library)
 {
 	return syscall(__NR_uselib, library);
 }
-#else
-static inline int uselib(const char *library)
+static inline caddr_t create_module(const char *name, size_t size)
 {
-	errno = ENOSYS;
-	return -1;
+	return (caddr_t) syscall(__NR_create_module, name, size);
 }
-#endif
-
-/* Is there an architecture without __NR_pivot_root defined? */
-#ifdef __NR_pivot_root
 static inline int pivot_root(const char *new_root, const char *put_old)
 {
 	return syscall(__NR_pivot_root, new_root, put_old);
 }
-#else
-static inline int pivot_root(const char *new_root, const char *put_old)
+static inline int tkill(int tid, int sig)
+{
+	return syscall(__NR_tkill, tid, sig);
+}
+#ifdef __NR_tgkill
+static inline int tgkill(int tgid, int tid, int sig)
+{
+	return syscall(__NR_tgkill, tgid, tid, sig);
+}
+#endif
+#ifdef __NR_sys_kexec_load
+struct kexec_segment;
+static inline long sys_kexec_load(unsigned long entry,
+				  unsigned long nr_segments,
+				  struct kexec_segment *segments,
+				  unsigned long flags)
 {
-	errno = ENOSYS;
-	return -1;
+	return (long) syscall(__NR_sys_kexec_load, entry, nr_segments,
+			      segments, flags);
 }
 #endif
+/* reboot() in glibc takes just one argument. */
+int reboot(int cmd);
+int init_module(const char *name, struct module *image);
+int delete_module(const char *name);
 
 #define proc_policy_dir              "/sys/kernel/security/tomoyo/"
 #define proc_policy_domain_policy    "/sys/kernel/security/tomoyo/domain_policy"
@@ -90,9 +112,7 @@ static inline int pivot_root(const char *new_root, const char *put_old)
 #define proc_policy_profile          "/sys/kernel/security/tomoyo/profile"
 #define proc_policy_manager          "/sys/kernel/security/tomoyo/manager"
 #define proc_policy_query            "/sys/kernel/security/tomoyo/query"
-#define proc_policy_grant_log        "/sys/kernel/security/tomoyo/grant_log"
-#define proc_policy_reject_log       "/sys/kernel/security/tomoyo/reject_log"
-#define proc_policy_domain_status    "/sys/kernel/security/tomoyo/.domain_status"
+#define proc_policy_audit            "/sys/kernel/security/tomoyo/audit"
 #define proc_policy_process_status   "/sys/kernel/security/tomoyo/.process_status"
 #define proc_policy_self_domain      "/sys/kernel/security/tomoyo/self_domain"
 
@@ -100,22 +120,23 @@ static FILE *profile_fp = NULL;
 static FILE *domain_fp = NULL;
 static FILE *exception_fp = NULL;
 static char self_domain[4096] = "";
+static int is_kernel26 = 0;
 static pid_t pid = 0;
 
 static void clear_status(void)
 {
-	static const char *keywords[] = {
+	static const char * const keywords[] = {
 		"file::execute",
 		"file::open",
 		"file::create",
 		"file::unlink",
+		"file::getattr",
 		"file::mkdir",
 		"file::rmdir",
 		"file::mkfifo",
 		"file::mksock",
 		"file::truncate",
 		"file::symlink",
-		"file::rewrite",
 		"file::mkblock",
 		"file::mkchar",
 		"file::link",
@@ -126,8 +147,38 @@ static void clear_status(void)
 		"file::ioctl",
 		"file::chroot",
 		"file::mount",
-		"file::umount",
+		"file::unmount",
 		"file::pivot_root",
+		"misc::env",
+		"network::inet_stream_bind",
+		"network::inet_stream_listen",
+		"network::inet_stream_connect",
+		"network::inet_stream_accept",
+		"network::inet_dgram_bind",
+		"network::inet_dgram_send",
+		"network::inet_dgram_recv",
+		"network::inet_raw_bind",
+		"network::inet_raw_send",
+		"network::inet_raw_recv",
+		"network::unix_stream_bind",
+		"network::unix_stream_listen",
+		"network::unix_stream_connect",
+		"network::unix_dgram_bind",
+		"network::unix_dgram_send",
+		"network::unix_seqpacket_bind",
+		"network::unix_seqpacket_listen",
+		"network::unix_seqpacket_connect",
+		"ipc::signal",
+		"capability::use_route",
+		"capability::use_packet",
+		"capability::SYS_REBOOT",
+		"capability::SYS_VHANGUP",
+		"capability::SYS_TIME",
+		"capability::SYS_NICE",
+		"capability::SYS_SETHOSTNAME",
+		"capability::use_kernel_module",
+		"capability::SYS_KEXEC_LOAD",
+		"capability::SYS_PTRACE",
 		NULL
 	};
 	int i;
@@ -138,9 +189,8 @@ static void clear_status(void)
 		exit(1);
 	}
 	for (i = 0; keywords[i]; i++)
-		fprintf(profile_fp,
-			"255-CONFIG::%s={ mode=disabled }\n",
-			keywords[i]);
+		fprintf(profile_fp, "255-CONFIG::%s={ mode=disabled "
+			"grant_log=no reject_log=no }\n", keywords[i]);
 	while (memset(buffer, 0, sizeof(buffer)),
 	       fgets(buffer, sizeof(buffer) - 10, fp)) {
 		const char *mode;
@@ -159,19 +209,17 @@ static void clear_status(void)
 		if (!strcmp(cp, "COMMENT"))
 			mode = "Profile for kernel test\n";
 		else
-			mode = "{ mode=disabled verbose=no }\n";
+			mode = "{ mode=disabled grant_log=no reject_log=no }"
+				"\n";
 		fprintf(profile_fp, "255-%s=%s", cp, mode);
 	}
-	fprintf(profile_fp, "255-PREFERENCE::learning= verbose=no\n");
-	fprintf(profile_fp, "255-PREFERENCE::enforcing= verbose=no\n");
-	fprintf(profile_fp, "255-PREFERENCE::permissive= verbose=no\n");
-	fprintf(profile_fp, "255-PREFERENCE::disabled= verbose=no\n");
-	fprintf(profile_fp, "255-PREFERENCE::learning= max_entry=2048\n");
+	/* fprintf(profile_fp, "255-PREFERENCE={ enforcing_penalty=1 }\n"); */
+	fprintf(profile_fp, "255-PREFERENCE={ max_learning_entry=2048 }\n");
 	fflush(profile_fp);
 	fclose(fp);
 }
 
-static void tomoyo_test_init(void)
+static void ccs_test_init(void)
 {
 	pid = getpid();
 	if (access(proc_policy_dir, F_OK)) {
@@ -206,6 +254,18 @@ static void tomoyo_test_init(void)
 	}
 	clear_status();
 	{
+		FILE *fp = fopen("/proc/sys/kernel/osrelease", "r");
+		int version = 0;
+		if (!fp || (fscanf(fp, "2.%d.", &version) != 1 &&
+			    fscanf(fp, "%d.", &version) != 1) || fclose(fp)) {
+			fprintf(stderr, "Can't read /proc/sys/kernel/osrelease"
+				"\n");
+			exit(1);
+		}
+		if (version == 6 || version == 3)
+			is_kernel26 = 1;
+	}
+	{
 		FILE *fp = fopen(proc_policy_self_domain, "r");
 		memset(self_domain, 0, sizeof(self_domain));
 		if (!fp || !fgets(self_domain, sizeof(self_domain) - 1, fp) ||
@@ -217,12 +277,12 @@ static void tomoyo_test_init(void)
 	}
 	fprintf(domain_fp, "select pid=%u\n", pid);
 	fprintf(domain_fp, "use_profile 255\n");
-	fprintf(domain_fp, "allow_read/write /sys/kernel/security/tomoyo/domain_policy\n");
-	fprintf(domain_fp, "allow_truncate /sys/kernel/security/tomoyo/domain_policy\n");
-	fprintf(domain_fp, "allow_read/write /sys/kernel/security/tomoyo/exception_policy\n");
-	fprintf(domain_fp, "allow_truncate /sys/kernel/security/tomoyo/exception_policy\n");
-	fprintf(domain_fp, "allow_read/write /sys/kernel/security/tomoyo/profile\n");
-	fprintf(domain_fp, "allow_truncate /sys/kernel/security/tomoyo/profile\n");
+	fprintf(domain_fp, "file read/write/truncate/getattr "
+		"securityfs:/tomoyo/domain_policy\n");
+	fprintf(domain_fp, "file read/write/truncate/getattr "
+		"securityfs:/tomoyo/exception_policy\n");
+	fprintf(domain_fp, "file read/write/truncate/getattr "
+		"securityfs:/tomoyo/profile\n");
 }
 
 static void BUG(const char *fmt, ...)
@@ -241,79 +301,240 @@ static void BUG(const char *fmt, ...)
 		sleep(100);
 }
 
-int write_domain_policy(const char *policy, int is_delete)
+static char *ccs_freadline(FILE *fp)
 {
-	FILE *fp = fopen(proc_policy_domain_policy, "r");
-	char buffer[8192];
-	int domain_found = 0;
-	int policy_found = 0;
-	memset(buffer, 0, sizeof(buffer));
-	if (!fp) {
-		BUG("Can't read %s", proc_policy_domain_policy);
-		return 0;
+	static char *policy = NULL;
+	int pos = 0;
+	while (1) {
+		static int max_policy_len = 0;
+		const int c = fgetc(fp);
+		if (c == EOF)
+			return NULL;
+		if (pos == max_policy_len) {
+			char *cp;
+			max_policy_len += 4096;
+			cp = realloc(policy, max_policy_len);
+			if (!cp) {
+				BUG("Out of memory");
+				exit(1);
+			}
+			policy = cp;
+		}
+		policy[pos++] = (char) c;
+		if (c == '\n') {
+			policy[--pos] = '\0';
+			break;
+		}
 	}
-	if (is_delete)
-		fprintf(domain_fp, "delete ");
-	fprintf(domain_fp, "%s\n", policy);
-	while (fgets(buffer, sizeof(buffer) - 1, fp)) {
-		char *cp = strchr(buffer, '\n');
-		if (cp)
-			*cp = '\0';
-		if (!strncmp(buffer, "<kernel>", 8))
-			domain_found = !strcmp(self_domain, buffer);
-		if (!domain_found)
-			continue;
-		/* printf("<%s>\n", buffer); */
-		if (strcmp(buffer, policy))
-			continue;
-		policy_found = 1;
-		break;
+	return policy;
+}
+
+static char *ccs_freadline_unpack(FILE *fp)
+{
+	static char *previous_line = NULL;
+	static char *cached_line = NULL;
+	static int pack_start = 0;
+	static int pack_len = 0;
+	if (cached_line)
+		goto unpack;
+	if (!fp)
+		return NULL;
+	{
+		char *pos;
+		unsigned int offset;
+		unsigned int len;
+		char *line = ccs_freadline(fp);
+		if (!line)
+			return NULL;
+		if (sscanf(line, "acl_group %u", &offset) == 1 && offset < 256)
+			pos = strchr(line + 11, ' ');
+		else
+			pos = NULL;
+		if (pos++)
+			offset = pos - line;
+		else
+			offset = 0;
+		if (!strncmp(line + offset, "file ", 5)) {
+			char *cp = line + offset + 5;
+			char *cp2 = strchr(cp + 1, ' ');
+			len = cp2 - cp;
+			if (cp2 && memchr(cp, '/', len)) {
+				pack_start = cp - line;
+				goto prepare;
+			}
+		} else if (!strncmp(line + offset, "network ", 8)) {
+			char *cp = strchr(line + offset + 8, ' ');
+			char *cp2 = NULL;
+			if (cp)
+				cp = strchr(cp + 1, ' ');
+			if (cp)
+				cp2 = strchr(cp + 1, ' ');
+			cp++;
+			len = cp2 - cp;
+			if (cp2 && memchr(cp, '/', len)) {
+				pack_start = cp - line;
+				goto prepare;
+			}
+		}
+		return line;
+prepare:
+		pack_len = len;
+		cached_line = strdup(line);
+		if (!cached_line) {
+			BUG("Out of memory");
+			exit(1);
+		}
 	}
-	fclose(fp);
-	if (policy_found == is_delete) {
-		BUG("Can't %s %s", is_delete ? "delete" : "append",
-		    policy);
-		return 0;
+unpack:
+	{
+		char *line = NULL;
+		char *pos = cached_line + pack_start;
+		char *cp = memchr(pos, '/', pack_len);
+		unsigned int len = cp - pos;
+		free(previous_line);
+		previous_line = NULL;
+		if (!cp) {
+			previous_line = cached_line;
+			cached_line = NULL;
+			line = previous_line;
+		} else if (pack_len == 1) {
+			/* Ignore trailing empty word. */
+			free(cached_line);
+			cached_line = NULL;
+		} else {
+			/* Current string is "abc d/e/f ghi". */
+			line = strdup(cached_line);
+			if (!line) {
+				BUG("Out of memory");
+				exit(1);
+			}
+			previous_line = line;
+			/* Overwrite "abc d/e/f ghi" with "abc d ghi". */
+			memmove(line + pack_start + len, pos + pack_len,
+				strlen(pos + pack_len) + 1);
+			/* Overwrite "abc d/e/f ghi" with "abc e/f ghi". */
+			cp++;
+			memmove(pos, cp, strlen(cp) + 1);
+			/* Forget "d/" component. */
+			pack_len -= len + 1;
+			/* Ignore leading and middle empty word. */
+			if (!len)
+				goto unpack;
+		}
+		return line;
 	}
+}
+
+static int write_domain_policy(const char *policy, int is_delete)
+{
+	char *tmp_policy = strdup(policy);
+	if (!tmp_policy) {
+		BUG("Out of memory");
+		exit(1);
+	}
+	while (1) {
+		FILE *fp = fopen(proc_policy_domain_policy, "r");
+		_Bool domain_found = 0;
+		_Bool policy_found = 0;
+		if (!fp) {
+			BUG("Can't read %s", proc_policy_domain_policy);
+			return 0;
+		}
+		{
+			char *cp = strrchr(tmp_policy, '\t');
+			if (cp)
+				*cp++ = '\0';
+			else
+				cp = tmp_policy;
+			policy = cp;
+		}
+		if (is_delete)
+			fprintf(domain_fp, "delete ");
+		fprintf(domain_fp, "%s\n", policy);
+		while (1) {
+			char *line = ccs_freadline_unpack(fp);
+			if (!line)
+				break;
+			if (!strncmp(line, "<kernel>", 8))
+				domain_found = !strcmp(self_domain, line);
+			if (!domain_found)
+				continue;
+			/* printf("<%s>\n", buffer); */
+			if (strcmp(line, policy))
+				continue;
+			policy_found = 1;
+			while (ccs_freadline_unpack(NULL));
+			break;
+		}
+		fclose(fp);
+		if (policy_found == is_delete) {
+			BUG("Can't %s %s", is_delete ? "delete" : "append",
+			    policy);
+			return 0;
+		}
+		if (policy == tmp_policy)
+			break;
+	}
+	free(tmp_policy);
 	errno = 0;
 	return 1;
 
 }
 
-int write_exception_policy(const char *policy, int is_delete)
+static int write_exception_policy(const char *policy, int is_delete)
 {
-	FILE *fp = fopen(proc_policy_exception_policy, "r");
-	char buffer[8192];
-	int policy_found = 0;
-	memset(buffer, 0, sizeof(buffer));
-	if (!fp) {
-		BUG("Can't read %s", proc_policy_exception_policy);
-		return 0;
-	}
-	if (is_delete)
-		fprintf(exception_fp, "delete ");
-	fprintf(exception_fp, "%s\n", policy);
-	while (fgets(buffer, sizeof(buffer) - 1, fp)) {
-		char *cp = strchr(buffer, '\n');
-		if (cp)
-			*cp = '\0';
-		if (strcmp(buffer, policy))
-			continue;
-		policy_found = 1;
-		break;
+	char *tmp_policy = strdup(policy);
+	if (!tmp_policy) {
+		BUG("Out of memory");
+		exit(1);
 	}
-	fclose(fp);
-	if (policy_found == is_delete) {
-		BUG("Can't %s %s", is_delete ? "delete" : "append",
-		    policy);
-		return 0;
+	while (1) {
+		FILE *fp = fopen(proc_policy_exception_policy, "r");
+		_Bool policy_found = 0;
+		if (!fp) {
+			BUG("Can't read %s", proc_policy_exception_policy);
+			return 0;
+		}
+		{
+			char *cp = strrchr(tmp_policy, '\t');
+			if (cp)
+				*cp++ = '\0';
+			else
+				cp = tmp_policy;
+			policy = cp;
+		}
+		if (is_delete)
+			fprintf(exception_fp, "delete ");
+		fprintf(exception_fp, "%s\n", policy);
+		while (1) {
+			char *line = ccs_freadline_unpack(fp);
+			if (!line)
+				break;
+			if (!strncmp(line, "<kernel> ", 9))
+				line += 9;
+			/* printf("<%s>\n", buffer); */
+			if (strcmp(line, policy))
+				continue;
+			policy_found = 1;
+			while (ccs_freadline_unpack(NULL));
+			break;
+		}
+		fclose(fp);
+		if (policy_found == is_delete) {
+			BUG("Can't %s %s", is_delete ? "delete" : "append",
+			    policy);
+			return 0;
+		}
+		if (policy == tmp_policy)
+			break;
 	}
+	free(tmp_policy);
 	errno = 0;
 	return 1;
 
 }
 
-int set_profile(const int mode, const char *name)
+static int set_profile(const int mode, const char *name)
 {
 	static const char *modes[4] = { "disabled", "learning", "permissive",
 					"enforcing" };
@@ -325,12 +546,14 @@ int set_profile(const int mode, const char *name)
 		BUG("Can't read %s", proc_policy_profile);
 		return 0;
 	}
-	fprintf(profile_fp, "255-CONFIG::%s=%s\n", name, modes[mode]);
+	fprintf(profile_fp, "255-CONFIG::%s={ mode=%s }\n", name, modes[mode]);
 	while (memset(buffer, 0, sizeof(buffer)),
 	       fgets(buffer, sizeof(buffer) - 1, fp)) {
 		char *cp = strchr(buffer, '\n');
 		if (cp)
 			*cp = '\0';
+		if (!strncmp(buffer, "<kernel> ", 9))
+			memmove(buffer, buffer + 9, strlen(buffer + 9) + 1);
 		if (strncmp(buffer, "255-CONFIG::", 12) ||
 		    strncmp(buffer + 12, name, len) ||
 		    buffer[12 + len] != '=')
@@ -341,7 +564,7 @@ int set_profile(const int mode, const char *name)
 	}
 	fclose(fp);
 	if (!policy_found) {
-		BUG("Can't change profile to 255-CONFIG::%s=%s",
+		BUG("Can't change profile to 255-CONFIG::%s={ mode=%s }",
 		    name, modes[mode]);
 		return 0;
 	}
diff --git a/testcases/kernel/security/tomoyo/newns.c b/testcases/kernel/security/tomoyo/newns.c
index 5a74d64..f01c706 100644
--- a/testcases/kernel/security/tomoyo/newns.c
+++ b/testcases/kernel/security/tomoyo/newns.c
@@ -1,34 +1,34 @@
-/******************************************************************************/
-/*                                                                            */
-/* Copyright (c) Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>, 2009      */
-/*                                                                            */
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    */
-/*                                                                            */
-/******************************************************************************/
-
-#define _GNU_SOURCE
-
+/*
+ * newns.c
+ *
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
+ *
+ * Version: 2.4.0+   2011/08/20
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
 #include <stdio.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <sys/mount.h>
 #include <unistd.h>
 #include <sched.h>
+#ifndef CLONE_NEWNS
+#include <linux/sched.h>
+#endif
 #include <errno.h>
 #include <stdlib.h>
-#include "test.h"
 
 static int child(void *arg)
 {
@@ -42,7 +42,9 @@ static int child(void *arg)
 int main(int argc, char *argv[])
 {
 	char c = 0;
-	const pid_t pid = ltp_clone_quick(CLONE_NEWNS, child, (void *) argv);
+	char *stack = malloc(8192);
+	const pid_t pid = clone(child, stack + (8192 / 2), CLONE_NEWNS,
+				(void *) argv);
 	while (waitpid(pid, NULL, __WALL) == EOF && errno == EINTR)
 		c++; /* Dummy. */
 	return 0;
diff --git a/testcases/kernel/security/tomoyo/testall.sh b/testcases/kernel/security/tomoyo/testall.sh
old mode 100644
new mode 100755
index 325a8d5..1aa7065
--- a/testcases/kernel/security/tomoyo/testall.sh
+++ b/testcases/kernel/security/tomoyo/testall.sh
@@ -1,24 +1,24 @@
 #! /bin/sh
-################################################################################
-##                                                                            ##
-## Copyright (c) Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>, 2009      ##
-##                                                                            ##
-## This program is free software;  you can redistribute it and#or modify      ##
-## it under the terms of the GNU General Public License as published by       ##
-## the Free Software Foundation; either version 2 of the License, or          ##
-## (at your option) any later version.                                        ##
-##                                                                            ##
-## This program is distributed in the hope that it will be useful, but        ##
-## WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY ##
-## or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License   ##
-## for more details.                                                          ##
-##                                                                            ##
-## You should have received a copy of the GNU General Public License          ##
-## along with this program;  if not, write to the Free Software               ##
-## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    ##
-##                                                                            ##
-################################################################################
-
+#
+# testall.sh
+#
+# Copyright (C) 2005-2011  NTT DATA CORPORATION
+#
+# Version: 2.4.0   2011/08/06
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License v2 as published by the
+# Free Software Foundation.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc.,
+# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+#
 cd ${0%/*}
 export PATH=$PWD:${PATH}
 
@@ -27,6 +27,7 @@ newns tomoyo_accept_test
 newns tomoyo_filesystem_test
 newns tomoyo_file_test
 newns tomoyo_rewrite_test
+newns tomoyo_argv0_test
 newns tomoyo_new_file_test
 newns tomoyo_new_test
 echo
@@ -37,10 +38,15 @@ newns tomoyo_accept_test | grep -vF Done
 newns tomoyo_filesystem_test | grep -vF OK | grep -F '('
 newns tomoyo_file_test | grep -vF OK | grep -F '('
 newns tomoyo_rewrite_test | grep -vF OK | grep -F '('
+newns tomoyo_argv0_test | grep -vF OK | grep -F '('
 newns tomoyo_new_test | grep -vF OK
 echo
 echo
 echo
 echo "Testing policy I/O.  (Only ERRORS are reported)"
+newns tomoyo_bprm_test | grep -vF OK
+newns tomoyo_cond_test | grep -vF OK
 newns tomoyo_policy_io_test | grep -vF OK
 newns tomoyo_new_file_test | grep -vF OK
+dmesg -c
+uname -r
diff --git a/testcases/kernel/security/tomoyo/tomoyo_accept_test.c b/testcases/kernel/security/tomoyo/tomoyo_accept_test.c
index 55b8450..0f06c88 100644
--- a/testcases/kernel/security/tomoyo/tomoyo_accept_test.c
+++ b/testcases/kernel/security/tomoyo/tomoyo_accept_test.c
@@ -1,53 +1,50 @@
-/******************************************************************************/
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    */
-/*                                                                            */
-/******************************************************************************/
 /*
- * tomoyo_accept_test.c
+ * ccs_accept_test.c
  *
- * Testing program for security/tomoyo/
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Copyright (C) 2005-2010  NTT DATA CORPORATION
+ * Version: 2.4.0   2011/08/06
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 #include "include.h"
 
 static void set_level(const int i)
 {
-	set_profile(i, "file::execute");
-	set_profile(i, "file::open");
+	set_profile(i, "file::chgrp");
+	set_profile(i, "file::chmod");
+	set_profile(i, "file::chown");
+	set_profile(i, "file::chroot");
 	set_profile(i, "file::create");
-	set_profile(i, "file::unlink");
+	set_profile(i, "file::execute");
+	set_profile(i, "file::ioctl");
+	set_profile(i, "file::link");
+	set_profile(i, "file::mkblock");
+	set_profile(i, "file::mkchar");
 	set_profile(i, "file::mkdir");
-	set_profile(i, "file::rmdir");
 	set_profile(i, "file::mkfifo");
 	set_profile(i, "file::mksock");
-	set_profile(i, "file::truncate");
-	set_profile(i, "file::symlink");
-	set_profile(i, "file::rewrite");
-	set_profile(i, "file::mkblock");
-	set_profile(i, "file::mkchar");
-	set_profile(i, "file::link");
-	set_profile(i, "file::rename");
-	set_profile(i, "file::chmod");
-	set_profile(i, "file::chown");
-	set_profile(i, "file::chgrp");
-	set_profile(i, "file::ioctl");
-	set_profile(i, "file::chroot");
 	set_profile(i, "file::mount");
-	set_profile(i, "file::umount");
+	set_profile(i, "file::open");
 	set_profile(i, "file::pivot_root");
+	set_profile(i, "file::rename");
+	set_profile(i, "file::rmdir");
+	set_profile(i, "file::symlink");
+	set_profile(i, "file::truncate");
+	set_profile(i, "file::unmount");
+	set_profile(i, "file::unlink");
+	set_profile(i, "file::getattr");
 }
 
 static void test(int rw_loop, int truncate_loop, int append_loop,
@@ -60,17 +57,16 @@ static void test(int rw_loop, int truncate_loop, int append_loop,
 	static const int append_flags[2] = { 0, O_APPEND };
 	int level;
 	int flags;
-	int i;
 	int fd;
 	static char buffer[1024];
 	memset(buffer, 0, sizeof(buffer));
 	snprintf(buffer, sizeof(buffer) - 1, "/tmp/file:a=%d:t=%d:c=%d:m=%d",
 		 append_loop, truncate_loop, create_loop, rw_loop);
-	fprintf(exception_fp, "deny_rewrite %s\n", buffer);
 	flags = rw_flags[rw_loop] | truncate_flags[truncate_loop] |
 		append_flags[append_loop] | create_flags[create_loop];
-	for (i = 1; i < 8; i++)
-		fprintf(domain_fp, "delete %d %s\n", i, buffer);
+	fprintf(domain_fp,
+		"delete file read/write/append/execute/truncate %s\n", buffer);
+	fprintf(domain_fp, "delete file create %s 0644\n", buffer);
 	for (level = 0; level < 4; level++) {
 		set_level(0);
 		if (create_loop == 1)
@@ -99,11 +95,10 @@ static void test(int rw_loop, int truncate_loop, int append_loop,
 		  fprintf(stderr, "%d: open(%04o) failed\n", level, flags);
 		*/
 	}
-	for (i = 1; i < 8; i++)
-		fprintf(domain_fp, "delete %d %s\n", i, buffer);
-	fprintf(domain_fp, "delete allow_truncate %s\n", buffer);
-	fprintf(domain_fp, "delete allow_create %s 0644\n", buffer);
-	fprintf(domain_fp, "delete allow_rewrite %s\n", buffer);
+	fprintf(domain_fp,
+		"delete file read/write/append/execute/truncate/getattr %s\n",
+		buffer);
+	fprintf(domain_fp, "delete file create %s 0644\n", buffer);
 	fd = open(buffer, flags, 0644);
 	if (fd != EOF) {
 		close(fd);
@@ -113,13 +108,9 @@ static void test(int rw_loop, int truncate_loop, int append_loop,
 
 int main(int argc, char *argv[])
 {
-	tomoyo_test_init();
-	fprintf(profile_fp, "255-PREFERENCE::learning={ verbose=no }\n");
-	fprintf(profile_fp, "255-PREFERENCE::enforcing={ verbose=no }\n");
-	fprintf(profile_fp, "255-PREFERENCE::permissive={ verbose=no }\n");
-	fprintf(profile_fp, "255-PREFERENCE::disabled={ verbose=no }\n");
+	ccs_test_init();
 	set_profile(0, "file");
-	fprintf(profile_fp, "255-PREFERENCE::learning={ max_entry=2048 }\n");
+	fprintf(profile_fp, "255-PREFERENCE={ max_learning_entry=2048 }\n");
 	{
 		int append_loop;
 		for (append_loop = 0; append_loop < 2; append_loop++) {
@@ -138,8 +129,12 @@ int main(int argc, char *argv[])
 			}
 		}
 	}
-	fprintf(profile_fp, "255-CONFIG::file=disabled\n");
+	fprintf(profile_fp, "255-CONFIG::file={ mode=disabled }\n");
 	printf("Done\n");
 	clear_status();
+	if (0) { /* To suppress "defined but not used" warnings. */
+		write_domain_policy("", 0);
+		write_exception_policy("", 0);
+	}
 	return 0;
-}
\ No newline at end of file
+}
diff --git a/testcases/kernel/security/tomoyo/tomoyo_argv0_test.c b/testcases/kernel/security/tomoyo/tomoyo_argv0_test.c
new file mode 100644
index 0000000..dea46c7
--- /dev/null
+++ b/testcases/kernel/security/tomoyo/tomoyo_argv0_test.c
@@ -0,0 +1,112 @@
+/*
+ * ccs_argv0_test.c
+ *
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
+ *
+ * Version: 2.4.0   2011/08/06
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+#include "include.h"
+
+static int is_enforce = 0;
+
+static void show_prompt(const char *str)
+{
+	printf("Testing %40s: (%s) ", str,
+	       is_enforce ? "must fail" : "should success");
+	errno = 0;
+}
+
+static void show_result(int result)
+{
+	if (is_enforce) {
+		if (result == EOF) {
+			if (errno == EPERM)
+				printf("OK: Permission denied.\n");
+			else
+				printf("FAILED: %s\n", strerror(errno));
+		} else {
+			printf("BUG!\n");
+		}
+	} else {
+		if (result != EOF)
+			printf("OK\n");
+		else
+			printf("%s\n", strerror(errno));
+	}
+}
+
+static void stage_argv0_test(void)
+{
+	static char buffer[1024];
+	char *argv[2] = { "false", NULL };
+	int status = 0;
+	memset(buffer, 0, sizeof(buffer));
+	{
+		is_enforce = 0;
+		set_profile(2, "file::execute");
+		fflush(stdout);
+		if (fork() == 0) {
+			execv("/bin/true", argv);
+			_exit(errno);
+		}
+		snprintf(buffer, sizeof(buffer) - 1,
+			 "Executing /bin/true in permissive mode");
+		show_prompt(buffer);
+		wait(&status);
+		errno = WEXITSTATUS(status);
+		show_result(errno ? EOF : 0);
+
+		is_enforce = 1;
+		set_profile(3, "file::execute");
+		fflush(stdout);
+		if (fork() == 0) {
+			execv("/bin/true", argv);
+			_exit(errno);
+		}
+		snprintf(buffer, sizeof(buffer) - 1,
+			 "Executing /bin/true in enforce mode");
+		show_prompt(buffer);
+		wait(&status);
+		errno = WEXITSTATUS(status);
+		show_result(errno ? EOF : 0);
+
+		write_domain_policy("file execute /bin/true", 0);
+		is_enforce = 0;
+		fflush(stdout);
+		if (fork() == 0) {
+			argv[0] = "";
+			execv("/bin/true", argv);
+			_exit(errno);
+		}
+		snprintf(buffer, sizeof(buffer) - 1,
+			 "Executing /bin/true in enforce mode");
+		show_prompt(buffer);
+		wait(&status);
+		errno = WEXITSTATUS(status);
+		show_result(errno ? EOF : 0);
+		write_domain_policy("file execute /bin/true", 1);
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	ccs_test_init();
+	stage_argv0_test();
+	clear_status();
+	if (0) /* To suppress "defined but not used" warnings. */
+		write_exception_policy("", 0);
+	return 0;
+}
diff --git a/testcases/kernel/security/tomoyo/tomoyo_bprm_test.c b/testcases/kernel/security/tomoyo/tomoyo_bprm_test.c
new file mode 100644
index 0000000..2c3a0b6
--- /dev/null
+++ b/testcases/kernel/security/tomoyo/tomoyo_bprm_test.c
@@ -0,0 +1,192 @@
+/*
+ * ccs_bprm_test.c
+ *
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
+ *
+ * Version: 2.4.0   2011/08/06
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+#include "include.h"
+
+static void try_exec(const char *policy, char *argv[], char *envp[],
+		     const char should_success) {
+	FILE *fp;
+	char buffer[8192];
+	int domain_found = 0;
+	int policy_found = 0;
+	int err = 0;
+	int pipe_fd[2] = { EOF, EOF };
+	int ret_ignored;
+	set_profile(3, "file::open");
+	fp = fopen(proc_policy_domain_policy, "r");
+	set_profile(3, "file::open");
+	ret_ignored = pipe(pipe_fd);
+	printf("%s: ", policy);
+	fflush(stdout);
+	fprintf(domain_fp, "%s\n", policy);
+	if (!fp) {
+		printf("BUG: policy read failed\n");
+		return;
+	}
+	while (fgets(buffer, sizeof(buffer) - 1, fp)) {
+		char *cp = strchr(buffer, '\n');
+		if (cp)
+			*cp = '\0';
+		if (!strncmp(buffer, "<kernel>", 8))
+			domain_found = !strcmp(self_domain, buffer);
+		if (!domain_found)
+			continue;
+		/* printf("<%s>\n", buffer); */
+		if (!strcmp(buffer, policy)) {
+			policy_found = 1;
+			break;
+		}
+	}
+	fclose(fp);
+	if (!policy_found) {
+		printf("BUG: policy write failed\n");
+		return;
+	}
+	if (fork() == 0) {
+		execve("/bin/true", argv, envp);
+		err = errno;
+		ret_ignored = write(pipe_fd[1], &err, sizeof(err));
+		_exit(0);
+	}
+	close(pipe_fd[1]);
+	ret_ignored = read(pipe_fd[0], &err, sizeof(err));
+	close(pipe_fd[0]);
+	fprintf(domain_fp, "delete %s\n", policy);
+	if (should_success) {
+		if (!err)
+			printf("OK\n");
+		else
+			printf("BUG: failed (%d)\n", err);
+	} else {
+		if (err == EPERM)
+			printf("OK: Permission denied.\n");
+		else
+			printf("BUG: failed (%d)\n", err);
+	}
+}
+
+static void stage_exec_test(void)
+{
+	int i;
+	static char *argv[128];
+	static char *envp[128];
+	for (i = 0; i < 10; i++) {
+		memset(argv, 0, sizeof(argv));
+		memset(envp, 0, sizeof(envp));
+
+		argv[0] = "/bin/true";
+		try_exec("file execute /bin/true "
+			 "task.gid=0-100 exec.argc=1", argv, envp, 1);
+		argv[0] = NULL;
+		try_exec("file execute /bin/true "
+			 "task.gid=0-100 exec.argc=1", argv, envp, 0);
+
+		envp[0] = "";
+		try_exec("file execute /bin/true task.gid!=100 task.euid=0 "
+			 "path1.uid=0 path1.parent.uid=0 exec.envc=1", argv,
+			 envp, 1);
+		envp[0] = NULL;
+		try_exec("file execute /bin/true task.gid!=100 task.euid=0 "
+			 "path1.uid=0 path1.parent.uid=0 exec.envc=1", argv,
+			 envp, 0);
+
+		argv[0] = "/bin/true";
+		argv[1] = "--";
+		try_exec("file execute /bin/true 0=0 exec.argc=1-5", argv,
+			 envp, 1);
+		try_exec("file execute /bin/true 0=0 exec.argc!=1-5", argv,
+			 envp, 0);
+
+		envp[0] = "";
+		envp[1] = "";
+		try_exec("file execute /bin/true task.uid=0 "
+			 "task.gid!=1-100 path1.parent.uid!=1 path1.gid=0 "
+			 "exec.envc=1-5", argv, envp, 1);
+		try_exec("file execute /bin/true task.uid=0 "
+			 "task.gid!=1-100 path1.parent.uid!=1 path1.gid=0 "
+			 "exec.envc!=1-5", argv, envp, 0);
+
+		argv[0] = "/bin/true";
+		argv[1] = "--";
+		try_exec("file execute /bin/true task.uid=0 task.gid=0 "
+			 "path1.parent.uid=0 path1.uid=0 exec.argv[1]=\"--\"",
+			 argv, envp, 1);
+		try_exec("file execute /bin/true task.uid=0 task.gid=0 "
+			 "path1.parent.uid=0 path1.uid=0 exec.argv[1]!=\"--\"",
+			 argv, envp, 0);
+
+		argv[0] = "/bin/true";
+		argv[1] = "-";
+		try_exec("file execute /bin/true 1!=0 exec.argv[1]=\"--\"",
+			 argv, envp, 0);
+		try_exec("file execute /bin/true 1!=0 exec.argv[1]!=\"--\"",
+			 argv, envp, 1);
+
+		envp[0] = "HOME=/";
+		try_exec("file execute /bin/true task.euid=0 "
+			 "exec.envp[\"HOME\"]!=NULL", argv, envp, 1);
+		try_exec("file execute /bin/true task.euid=0 "
+			 "exec.envp[\"HOME\"]=NULL", argv, envp, 0);
+		try_exec("file execute /bin/true 0!=1 "
+			 "exec.envp[\"HOME\"]=\"/\"", argv, envp, 1);
+		try_exec("file execute /bin/true 0!=1 "
+			 "exec.envp[\"HOME\"]!=\"/\"", argv, envp, 0);
+
+		envp[0] = "HOME2=/";
+		try_exec("file execute /bin/true path1.uid=0 "
+			 "exec.envp[\"HOME\"]!=NULL", argv, envp, 0);
+		try_exec("file execute /bin/true path1.uid=0 "
+			 "exec.envp[\"HOME\"]=NULL", argv, envp, 1);
+		try_exec("file execute /bin/true 100=1-1000 "
+			 "exec.envp[\"HOME\"]=\"/\"", argv, envp, 0);
+		try_exec("file execute /bin/true 100=1-1000 "
+			 "exec.envp[\"HOME\"]!=\"/\"", argv, envp, 1);
+		try_exec("file execute /bin/true path1.parent.gid!=100 "
+			 "exec.envp[\"HOME\"]!=NULL exec.envp[\"HOME3\"]=NULL",
+			 argv, envp, 0);
+		try_exec("file execute /bin/true path1.parent.gid!=100 "
+			 "exec.envp[\"HOME\"]=NULL exec.envp[\"HOME3\"]=NULL",
+			 argv, envp, 1);
+		try_exec("file execute /bin/true path1.parent.gid=0 "
+			 "exec.envp[\"HOME\"]=\"/\" exec.envp[\"HOME3\"]=NULL",
+			 argv, envp, 0);
+		try_exec("file execute /bin/true path1.parent.gid=0 "
+			 "exec.envp[\"HOME\"]!=\"/\" exec.envp[\"HOME3\"]=NULL",
+			 argv, envp, 1);
+	}
+}
+
+int main(int argc, char *argv[])
+{
+	ccs_test_init();
+	fprintf(domain_fp, "%s /bin/true\n", self_domain);
+	fprintf(domain_fp, "use_profile 255\n");
+	fprintf(domain_fp, "select pid=%u\n", pid);
+	fprintf(domain_fp, "file read/write %s\n", proc_policy_domain_policy);
+	set_profile(3, "file::execute");
+	stage_exec_test();
+	set_profile(3, "file::execute");
+	clear_status();
+	if (0) { /* To suppress "defined but not used" warnings. */
+		write_domain_policy("", 0);
+		write_exception_policy("", 0);
+	}
+	return 0;
+}
diff --git a/testcases/kernel/security/tomoyo/tomoyo_cond_test.c b/testcases/kernel/security/tomoyo/tomoyo_cond_test.c
new file mode 100644
index 0000000..a391424
--- /dev/null
+++ b/testcases/kernel/security/tomoyo/tomoyo_cond_test.c
@@ -0,0 +1,443 @@
+/*
+ * ccs_cond_test.c
+ *
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
+ *
+ * Version: 2.4.0   2011/08/06
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+#include "include.h"
+
+static void try_open(const char *policy, const char *file, const int mode,
+		     const char should_success) {
+	FILE *fp;
+	char buffer[8192];
+	int domain_found = 0;
+	int policy_found = 0;
+	int err = 0;
+	memset(buffer, 0, sizeof(buffer));
+	set_profile(0, "file::open");
+	fp = fopen(proc_policy_domain_policy, "r+");
+	set_profile(3, "file::open");
+	printf("%s: ", policy);
+	fflush(stdout);
+	fprintf(domain_fp, "%s\n", policy);
+	if (!fp) {
+		printf("BUG: policy read failed\n");
+		return;
+	}
+	fprintf(fp, "select pid=%d\n", pid);
+	while (fgets(buffer, sizeof(buffer) - 1, fp)) {
+		char *cp = strchr(buffer, '\n');
+		if (cp)
+			*cp = '\0';
+		if (!strncmp(buffer, "<kernel>", 8))
+			domain_found = !strcmp(self_domain, buffer);
+		if (!domain_found)
+			continue;
+		/* printf("<%s>\n", buffer); */
+		if (!strcmp(buffer, policy)) {
+			policy_found = 1;
+			break;
+		}
+	}
+	fclose(fp);
+	if (!policy_found) {
+		if (!strstr(policy, "read/write")) {
+			printf("BUG: policy write failed\n");
+			return;
+		}
+	}
+	{
+		int fd;
+		errno = 0;
+		fd = open(file, mode, 0);
+		err = errno;
+		if (fd != EOF)
+			close(fd);
+	}
+	fprintf(domain_fp, "delete %s\n", policy);
+	if (should_success) {
+		if (!err)
+			printf("OK\n");
+		else
+			printf("BUG: failed (%d)\n", err);
+	} else {
+		if (err == EPERM)
+			printf("OK: Permission denied.\n");
+		else
+			printf("BUG: failed (%d)\n", err);
+	}
+}
+
+static void stage_open_test(void)
+{
+	const pid_t pid = getppid();
+	int i;
+	char buffer[128];
+	for (i = 0; i < 5; i++) {
+		memset(buffer, 0, sizeof(buffer));
+		snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/mounts", pid);
+		try_open("file read /etc/fstab", "/etc/fstab", O_RDONLY, 1);
+		try_open("file write /etc/fstab", "/etc/fstab", O_WRONLY, 1);
+		try_open("file write /etc/fstab", "/etc/fstab", O_RDONLY, 0);
+		try_open("file read /etc/fstab", "/etc/fstab", O_WRONLY, 0);
+		try_open("file read/write /etc/fstab", "/etc/fstab", O_RDWR,
+			 1);
+		try_open("file read/write /etc/fstab", "/etc/fstab", O_RDONLY,
+			 1);
+		try_open("file read/write /etc/fstab", "/etc/fstab", O_WRONLY,
+			 1);
+		try_open("file read /etc/fstab task.uid=0 task.euid=0",
+			 "/etc/fstab", O_RDONLY, 1);
+		try_open("file read /etc/fstab "
+			 "task.uid=0 task.euid=0-4294967295", "/etc/fstab",
+			 O_RDONLY, 1);
+		try_open("file read /etc/fstab "
+			 "task.uid=0 task.euid!=0-4294967295", "/etc/fstab",
+			 O_RDONLY, 0);
+		try_open("file read /etc/fstab task.uid=0 task.euid!=0",
+			 "/etc/fstab", O_RDONLY, 0);
+		try_open("file read /etc/fstab exec.argc=0", "/etc/fstab",
+			 O_RDONLY, 0);
+		try_open("file read /etc/fstab exec.envc=0", "/etc/fstab",
+			 O_RDONLY, 0);
+		try_open("file read /etc/fstab exec.argv[0]=\"\"",
+			 "/etc/fstab", O_RDONLY, 0);
+		try_open("file read /etc/fstab exec.argv[0]!=\"\"",
+			 "/etc/fstab", O_RDONLY, 0);
+		try_open("file read /etc/fstab exec.envp[\"HOME\"]=\"\"",
+			 "/etc/fstab", O_RDONLY, 0);
+		try_open("file read /etc/fstab exec.envp[\"HOME\"]!=\"\"",
+			 "/etc/fstab", O_RDONLY, 0);
+		try_open("file read /etc/fstab exec.envp[\"HOME\"]=NULL",
+			 "/etc/fstab", O_RDONLY, 0);
+		try_open("file read /etc/fstab exec.envp[\"HOME\"]!=NULL",
+			 "/etc/fstab", O_RDONLY, 0);
+
+		try_open("file read proc:/\\*/mounts", buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\@/mounts", buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\$/mounts", buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\X/mounts", buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\+/mounts", buffer, O_RDONLY,
+			 pid >= 0 && pid < 10);
+		try_open("file read proc:/\\+\\+/mounts", buffer, O_RDONLY,
+			 pid >= 10 && pid < 100);
+		try_open("file read proc:/\\+\\+\\+/mounts", buffer, O_RDONLY,
+			 pid >= 100 && pid < 1000);
+		try_open("file read proc:/\\+\\+\\+\\+/mounts", buffer,
+			 O_RDONLY, pid >= 1000 && pid < 10000);
+		try_open("file read proc:/\\+\\+\\+\\+\\+/mounts", buffer,
+			 O_RDONLY, pid >= 10000 && pid < 100000);
+		try_open("file read proc:/\\+\\+\\+\\+\\+\\+/mounts", buffer,
+			 O_RDONLY, pid >= 100000 && pid < 1000000);
+
+		try_open("file read proc:/\\x/mounts", buffer, O_RDONLY,
+			 pid < 10);
+		try_open("file read proc:/\\x\\x/mounts", buffer, O_RDONLY,
+			 pid >= 10 && pid < 100);
+		try_open("file read proc:/\\x\\x\\x/mounts", buffer, O_RDONLY,
+			 pid >= 100 && pid < 1000);
+		try_open("file read proc:/\\x\\x\\x\\x/mounts", buffer,
+			 O_RDONLY, pid >= 1000 && pid < 10000);
+		try_open("file read proc:/\\x\\x\\x\\x\\x/mounts", buffer,
+			 O_RDONLY, pid >= 10000 && pid < 100000);
+		try_open("file read proc:/\\x\\x\\x\\x\\x\\x/mounts", buffer,
+			 O_RDONLY, pid >= 100000 && pid < 1000000);
+
+		try_open("file read proc:/\\$\\*/mounts", buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\$\\@/mounts", buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\$\\*\\*/mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\$\\@\\@/mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\$\\*\\@/mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\$\\@\\*/mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\$\\*/mounts\\*", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\$\\@/mounts\\@", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\$\\*\\*/mounts\\*\\*", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\$\\@\\@/mounts\\@\\@", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\$\\*\\@/mounts\\*\\@", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\$\\@\\*/mounts\\@\\*", buffer,
+			 O_RDONLY, 1);
+
+		try_open("file read proc:/\\*\\$/mounts", buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\@\\$/mounts", buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\*\\*\\$/mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\@\\@\\$/mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\*\\@\\$/mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\@\\*\\$/mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\*\\$/\\*mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\@\\$/\\@mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\*\\*\\$/\\*\\*mounts", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\@\\@\\$/\\@\\@mounts", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\*\\@\\$/\\*\\@mounts", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\@\\*\\$/\\@\\*mounts", buffer,
+			 O_RDONLY, 1);
+
+		try_open("file read proc:/\\*\\$\\*/mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\@\\$\\@/mounts", buffer, O_RDONLY,
+			 1);
+		try_open("file read proc:/\\*\\*\\$\\*\\*/mounts", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\@\\@\\$\\@\\@/mounts", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\*\\@\\$\\*\\@/mounts", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\@\\*\\$\\@\\*/mounts", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\*\\$\\*/\\*mounts\\*", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\@\\$\\@/\\@mounts\\@", buffer,
+			 O_RDONLY, 1);
+		try_open("file read proc:/\\*\\*\\$\\*\\*/\\*\\*mounts\\*\\*",
+			 buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\@\\@\\$\\@\\@/\\@\\@mounts\\@\\@",
+			 buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\*\\@\\$\\*\\@/\\*\\@mounts\\*\\@",
+			 buffer, O_RDONLY, 1);
+		try_open("file read proc:/\\@\\*\\$\\@\\*/\\@\\*mounts\\@\\*",
+			 buffer, O_RDONLY, 1);
+	}
+}
+
+static int try_exec(void)
+{
+	int status = 0;
+	int pipe_fd[2] = { EOF, EOF };
+	int ret_ignored = pipe(pipe_fd);
+	switch (fork()) {
+	case 0:
+		errno = 0;
+		execl("/bin/true", "true", NULL);
+		/* Unreachable if execl() succeeded. */
+		status = errno;
+		ret_ignored = write(pipe_fd[1], &status, sizeof(status));
+		_exit(0);
+	case -1:
+		fprintf(stderr, "fork() failed.\n");
+		break;
+	default:
+		close(pipe_fd[1]);
+		ret_ignored = read(pipe_fd[0], &status, sizeof(status));
+		wait(NULL);
+		close(pipe_fd[0]);
+	}
+	return status ? EOF : 0;
+}
+
+static void stage_cond_test(void)
+{
+	int fd;
+	const char *policy;
+
+	/* open read */
+	policy = "file read /etc/fstab task.uid=path1.uid";
+	write_domain_policy(policy, 0);
+	fd = open("/etc/fstab", O_RDONLY);
+	if (fd != EOF)
+		close(fd);
+	printf("%s : %s\n", policy, fd != EOF ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* open read */
+	policy = "file read /etc/fstab task.uid!=path1.uid";
+	write_domain_policy(policy, 0);
+	fd = open("/etc/fstab", O_RDONLY);
+	if (fd != EOF)
+		close(fd);
+	printf("%s : %s\n", policy, fd == EOF ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* open write */
+	policy = "file write /etc/fstab task.uid=path1.uid";
+	write_domain_policy(policy, 0);
+	fd = open("/etc/fstab", O_WRONLY);
+	if (fd != EOF)
+		close(fd);
+	printf("%s : %s\n", policy, fd != EOF ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* open write */
+	policy = "file write /etc/fstab task.uid!=path1.uid";
+	write_domain_policy(policy, 0);
+	fd = open("/etc/fstab", O_WRONLY);
+	if (fd != EOF)
+		close(fd);
+	printf("%s : %s\n", policy, fd == EOF ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* single path and single number */
+	policy = "file mkdir /tmp/testdir/ 0755 task.uid!=path1.parent.uid";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy,
+	       mkdir("/tmp/testdir", 0755) == EOF ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+	
+	/* single path and single number */
+	policy = "file mkdir /tmp/testdir/ 0755 task.uid=path1.parent.uid";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy,
+	       mkdir("/tmp/testdir", 0755) == 0 ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* single path */
+	policy = "file rmdir /tmp/testdir/ task.uid!=path1.uid";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy,
+	       rmdir("/tmp/testdir") == EOF ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* single path */
+	policy = "file rmdir /tmp/testdir/ task.uid=path1.uid";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy,
+	       rmdir("/tmp/testdir") == 0 ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* single path and three numbers */
+	policy = "file mkchar /tmp/char-1-3 0600 1 3 "
+		"task.uid!=path1.parent.uid";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy,
+	       mknod("/tmp/char-1-3", S_IFCHR | 0600, MKDEV(1, 3)) == EOF ?
+	       "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* single path and three numbers */
+	policy = "file mkchar /tmp/char-1-3 0600 1 3 "
+		"task.uid=path1.parent.uid";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy,
+	       mknod("/tmp/char-1-3", S_IFCHR | 0600, MKDEV(1, 3)) == 0 ?
+	       "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* two paths */
+	policy = "file rename /tmp/char-1-3 /tmp/char-1-3.new "
+		"path1.parent.ino!=path2.parent.ino";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy,
+	       rename("/tmp/char-1-3", "/tmp/char-1-3.new") == EOF ?
+	       "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* two paths */
+	policy = "file rename /tmp/char-1-3 /tmp/char-1-3.new "
+		"path1.parent.ino=path2.parent.ino";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy,
+	       rename("/tmp/char-1-3", "/tmp/char-1-3.new") == 0 ?
+	       "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* open execute */
+	policy = "file execute /bin/true task.uid!=path1.uid";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy, try_exec() == EOF ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* open execute */
+	policy = "file execute /bin/true task.uid=path1.uid";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy, try_exec() == 0 ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* open execute */
+	policy = "file execute /bin/true exec.realpath!=\"/bin/true\"";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy, try_exec() == EOF ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+
+	/* open execute */
+	policy = "file execute /bin/true exec.realpath=\"/bin/true\"";
+	write_domain_policy(policy, 0);
+	printf("%s : %s\n", policy, try_exec() == 0 ? "OK" : "FAILED");
+	write_domain_policy(policy, 1);
+}
+
+int main(int argc, char *argv[])
+{
+	ccs_test_init();
+	fprintf(domain_fp, "ignore_global\n");
+	fprintf(domain_fp, "file read/write %s\n", proc_policy_domain_policy);
+	set_profile(3, "file::execute");
+	set_profile(3, "file::open");
+	set_profile(3, "file::create");
+	set_profile(3, "file::unlink");
+	set_profile(3, "file::mkdir");
+	set_profile(3, "file::rmdir");
+	set_profile(3, "file::mkfifo");
+	set_profile(3, "file::mksock");
+	set_profile(3, "file::truncate");
+	set_profile(3, "file::symlink");
+	set_profile(3, "file::mkblock");
+	set_profile(3, "file::mkchar");
+	set_profile(3, "file::link");
+	set_profile(3, "file::rename");
+	set_profile(3, "file::chmod");
+	set_profile(3, "file::chown");
+	set_profile(3, "file::chgrp");
+	set_profile(3, "file::ioctl");
+	set_profile(3, "file::chroot");
+	set_profile(3, "file::mount");
+	set_profile(3, "file::unmount");
+	set_profile(3, "file::pivot_root");
+	stage_open_test();
+	stage_cond_test();
+	set_profile(0, "file::execute");
+	set_profile(0, "file::open");
+	set_profile(0, "file::create");
+	set_profile(0, "file::unlink");
+	set_profile(0, "file::mkdir");
+	set_profile(0, "file::rmdir");
+	set_profile(0, "file::mkfifo");
+	set_profile(0, "file::mksock");
+	set_profile(0, "file::truncate");
+	set_profile(0, "file::symlink");
+	set_profile(0, "file::mkblock");
+	set_profile(0, "file::mkchar");
+	set_profile(0, "file::link");
+	set_profile(0, "file::rename");
+	set_profile(0, "file::chmod");
+	set_profile(0, "file::chown");
+	set_profile(0, "file::chgrp");
+	set_profile(0, "file::ioctl");
+	set_profile(0, "file::chroot");
+	set_profile(0, "file::mount");
+	set_profile(0, "file::unmount");
+	set_profile(0, "file::pivot_root");
+	clear_status();
+	if (0) /* To suppress "defined but not used" warnings. */
+		write_exception_policy("", 0);
+	return 0;
+}
diff --git a/testcases/kernel/security/tomoyo/tomoyo_file_test.c b/testcases/kernel/security/tomoyo/tomoyo_file_test.c
index 8952082..9a88adb 100644
--- a/testcases/kernel/security/tomoyo/tomoyo_file_test.c
+++ b/testcases/kernel/security/tomoyo/tomoyo_file_test.c
@@ -1,27 +1,50 @@
-/******************************************************************************/
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    */
-/*                                                                            */
-/******************************************************************************/
 /*
- * tomoyo_file_test.c
+ * ccs_file_test.c
  *
- * Testing program for security/tomoyo/
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Copyright (C) 2005-2010  NTT DATA CORPORATION
+ * Version: 2.4.0   2011/08/06
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 #include "include.h"
+#include <linux/elf.h>
+
+static void make_elf_lib(void)
+{
+	static const struct elf32_phdr eph = {
+		.p_type = PT_LOAD,
+		.p_offset = 4096,
+		.p_filesz = 1,
+	};
+	static const struct elf32_hdr eh = {
+		.e_ident = ELFMAG,
+		.e_type = ET_EXEC,
+		.e_machine = EM_386,
+		.e_phoff = sizeof(eh),
+		.e_phentsize = sizeof(eph),
+		.e_phnum = 1,
+	};
+	const int fd = open("/tmp/uselib", O_WRONLY | O_CREAT | O_TRUNC, 0755);
+	if (fd != EOF) {
+		write(fd, &eh, sizeof(eh));
+		write(fd, &eph, sizeof(eph));
+		lseek(fd, 4096, SEEK_SET);
+		write(fd, "", 1);
+		close(fd);
+	}
+}
 
 static int should_fail = 0;
 
@@ -87,28 +110,27 @@ static void stage_file_test(void)
 		show_result(sysctl(name, 3, 0, 0, buffer, size));
 	}
 
-	/* QUESTION: Is there a file which can be passed to uselib()? */
 	show_prompt("uselib()");
-	show_result(uselib("/bin/true"));
+	show_result(uselib("/tmp/uselib"));
 
 	{
 		int pipe_fd[2] = { EOF, EOF };
-		int error = 0;
+		int err = 0;
+		int ret_ignored;
 		fflush(stdout);
 		fflush(stderr);
-		if (pipe(pipe_fd) == -1)
-			err(1, "pipe");
+		ret_ignored = pipe(pipe_fd);
 		if (fork() == 0) {
 			execl("/bin/true", "/bin/true", NULL);
-			if (write(pipe_fd[1], &errno, sizeof(errno)) == -1)
-				err(1, "write");
+			err = errno;
+			ret_ignored = write(pipe_fd[1], &err, sizeof(err));
 			_exit(0);
 		}
 		close(pipe_fd[1]);
-		(void)read(pipe_fd[0], &error, sizeof(error));
+		ret_ignored = read(pipe_fd[0], &err, sizeof(err));
 		show_prompt("execve()");
-		errno = error;
-		show_result(error ? EOF : 0);
+		errno = err;
+		show_result(err ? EOF : 0);
 	}
 
 	show_prompt("open(O_RDONLY)");
@@ -242,7 +264,6 @@ static void set_file_enforce(int enforce)
 		set_profile(3, "file::mksock");
 		set_profile(3, "file::truncate");
 		set_profile(3, "file::symlink");
-		set_profile(3, "file::rewrite");
 		set_profile(3, "file::mkblock");
 		set_profile(3, "file::mkchar");
 		set_profile(3, "file::link");
@@ -253,7 +274,7 @@ static void set_file_enforce(int enforce)
 		set_profile(3, "file::ioctl");
 		set_profile(3, "file::chroot");
 		set_profile(3, "file::mount");
-		set_profile(3, "file::umount");
+		set_profile(3, "file::unmount");
 		set_profile(3, "file::pivot_root");
 	} else {
 		set_profile(0, "file::execute");
@@ -266,7 +287,6 @@ static void set_file_enforce(int enforce)
 		set_profile(0, "file::mksock");
 		set_profile(0, "file::truncate");
 		set_profile(0, "file::symlink");
-		set_profile(0, "file::rewrite");
 		set_profile(0, "file::mkblock");
 		set_profile(0, "file::mkchar");
 		set_profile(0, "file::link");
@@ -277,14 +297,15 @@ static void set_file_enforce(int enforce)
 		set_profile(0, "file::ioctl");
 		set_profile(0, "file::chroot");
 		set_profile(0, "file::mount");
-		set_profile(0, "file::umount");
+		set_profile(0, "file::unmount");
 		set_profile(0, "file::pivot_root");
 	}
 }
 
 int main(int argc, char *argv[])
 {
-	tomoyo_test_init();
+	ccs_test_init();
+	make_elf_lib();
 
 	printf("***** Testing file hooks in enforce mode. *****\n");
 	create_files();
@@ -303,5 +324,9 @@ int main(int argc, char *argv[])
 	creanup_files();
 
 	clear_status();
+	if (0) { /* To suppress "defined but not used" warnings. */
+		write_domain_policy("", 0);
+		write_exception_policy("", 0);
+	}
 	return 0;
 }
diff --git a/testcases/kernel/security/tomoyo/tomoyo_filesystem_test.c b/testcases/kernel/security/tomoyo/tomoyo_filesystem_test.c
index 96d48b0..9255a9c 100644
--- a/testcases/kernel/security/tomoyo/tomoyo_filesystem_test.c
+++ b/testcases/kernel/security/tomoyo/tomoyo_filesystem_test.c
@@ -1,25 +1,22 @@
-/******************************************************************************/
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    */
-/*                                                                            */
-/******************************************************************************/
 /*
- * tomoyo_filesystem_test.c
+ * ccs_filesystem_test.c
  *
- * Testing program for security/tomoyo/
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Copyright (C) 2005-2010  NTT DATA CORPORATION
+ * Version: 2.4.0   2011/08/06
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 #define _GNU_SOURCE
 #include "include.h"
@@ -35,12 +32,10 @@ static void show_prompt(const char *str, const int should_fail)
 #define MS_MOVE         8192
 #endif
 
-static const char *pivot_root_dir = "/sys/kernel/security/";
-
 static int child(void *arg)
 {
 	errno = 0;
-	pivot_root(pivot_root_dir, proc_policy_dir);
+	pivot_root("/sys/kernel/security/", "/sys/kernel/security/tomoyo/");
 	return errno;
 }
 
@@ -172,7 +167,7 @@ static const unsigned char compressed_ext2_image_sample[1350] = {
 int main(int argc, char *argv[])
 {
 	char c = 0;
-	tomoyo_test_init();
+	ccs_test_init();
 
 	/* Test mount(). */
 	{
@@ -203,7 +198,7 @@ int main(int argc, char *argv[])
 			printf("OK: No such device.\n");
 		else
 			printf("BUG: %s\n", strerror(errno));
-		fprintf(domain_fp, "delete allow_mount dev\\011name / "
+		fprintf(domain_fp, "delete file mount dev\\011name / "
 			"fs\\011name 0\n");
 		show_prompt("mount('dev\\011name', '/', 'fs\\011name') ", 1);
 		if (mount("dev\tname", "/", "fs\tname", 0, NULL) == EOF &&
@@ -230,14 +225,14 @@ int main(int argc, char *argv[])
 			printf("BUG: %s\n", strerror(errno));
 		else
 			printf("OK: Success\n");
-		fprintf(domain_fp, "delete allow_mount <NULL> / tmpfs 0\n");
-		fprintf(domain_fp, "allow_mount anydev / tmpfs 0\n");
+		fprintf(domain_fp, "delete file mount <NULL> / tmpfs 0\n");
+		fprintf(domain_fp, "file mount anydev / tmpfs 0\n");
 		show_prompt("mount(NULL, '/', 'tmpfs') ", 0);
 		if (mount(NULL, "/", "tmpfs", 0, NULL))
 			printf("BUG: %s\n", strerror(errno));
 		else
 			printf("OK: Success\n");
-		fprintf(domain_fp, "delete allow_mount anydev / tmpfs 0\n");
+		fprintf(domain_fp, "delete file mount anydev / tmpfs 0\n");
 		set_profile(2, "file::mount");
 		show_prompt("mount(NULL, NULL, 'tmpfs') ", 1);
 		if (mount(NULL, NULL, "tmpfs", 0, NULL))
@@ -285,16 +280,17 @@ int main(int argc, char *argv[])
 		{
 			struct stat sbuf;
 			FILE *fp = NULL;
+			int ret_ignored;
 			snprintf(buf, sizeof(buf) - 1, "zcat - > %s",
 				 dev_ram_path);
 			if (lstat(dev_ram_path, &sbuf) == 0 &&
 			    S_ISBLK(sbuf.st_mode) && MAJOR(sbuf.st_rdev) == 1)
 				fp = popen(buf, "w");
 			if (fp) {
-				if (fwrite(compressed_ext2_image_sample, 1,
-				    sizeof(compressed_ext2_image_sample), fp) !=
-				    sizeof(compressed_ext2_image_sample))
-					err(1, "fwrite");
+				ret_ignored =
+					fwrite(compressed_ext2_image_sample, 1,
+				       sizeof(compressed_ext2_image_sample),
+				       fp);
 				pclose(fp);
 			} else
 				fprintf(stderr, "Can't write to %s .\n",
@@ -331,7 +327,7 @@ int main(int argc, char *argv[])
 			printf("BUG: %s\n", strerror(errno));
 
 		/* Test standard case */
-		fprintf(domain_fp, "allow_mount none /tmp/mount/ tmpfs 0\n");
+		fprintf(domain_fp, "file mount none /tmp/mount/ tmpfs 0\n");
 		show_prompt("mount('none', '/tmp/mount/', 'tmpfs') for "
 			    "'/tmp/mount/'", 0);
 		if (mount("none", "/tmp/mount/", "tmpfs", 0, NULL) == 0)
@@ -339,10 +335,10 @@ int main(int argc, char *argv[])
 		else
 			printf("FAILED: %s\n", strerror(errno));
 		fprintf(domain_fp,
-			"delete allow_mount none /tmp/mount/ tmpfs 0\n");
+			"delete file mount none /tmp/mount/ tmpfs 0\n");
 
 		/* Test device_name with pattern */
-		fprintf(domain_fp, "allow_mount %s\\* /tmp/mount/ ext2 1\n",
+		fprintf(domain_fp, "file mount %s\\* /tmp/mount/ ext2 1\n",
 			dev_ram_path);
 		snprintf(buf, sizeof(buf) - 1, "mount('%s', '/tmp/mount/', "
 			 "'ext2') for '%s\\*'", dev_ram_path, dev_ram_path);
@@ -352,19 +348,19 @@ int main(int argc, char *argv[])
 			printf("OK\n");
 		else
 			printf("FAILED: %s\n", strerror(errno));
-		fprintf(domain_fp, "delete allow_mount %s\\* "
+		fprintf(domain_fp, "delete file mount %s\\* "
 			"/tmp/mount/ ext2 1\n", dev_ram_path);
 
 		/* Test dir_name with pattern */
 		fprintf(domain_fp,
-			"allow_mount none /tmp/\\?\\?\\?\\?\\?/ tmpfs 0\n");
+			"file mount none /tmp/\\?\\?\\?\\?\\?/ tmpfs 0\n");
 		show_prompt("mount('none', '/tmp/mount/', 'tmpfs') for "
 			    "'/tmp/\\?\\?\\?\\?\\?/'", 0);
 		if (mount("none", "/tmp/mount/", "tmpfs", 0, NULL) == 0)
 			printf("OK\n");
 		else
 			printf("FAILED: %s\n", strerror(errno));
-		fprintf(domain_fp, "delete allow_mount none "
+		fprintf(domain_fp, "delete file mount none "
 			"/tmp/\\?\\?\\?\\?\\?/ tmpfs 0\n");
 
 		set_profile(0, "file::mount");
@@ -390,14 +386,14 @@ int main(int argc, char *argv[])
 			printf("OK: Permission denied.\n");
 		else
 			printf("BUG: %s\n", strerror(errno));
-		fprintf(domain_fp, "allow_mount something /tmp/mount/ "
+		fprintf(domain_fp, "file mount something /tmp/mount/ "
 			"--remount 0\n");
 		show_prompt("mount('/tmp/mount/', MS_REMOUNT)", 0);
 		if (mount(NULL, "/tmp/mount/", NULL, MS_REMOUNT, NULL))
 			printf("BUG: %s\n", strerror(errno));
 		else
 			printf("OK: Success.\n");
-		fprintf(domain_fp, "delete allow_mount something /tmp/mount/ "
+		fprintf(domain_fp, "delete file mount something /tmp/mount/ "
 			"--remount 0\n");
 
 		/* Test bind case */
@@ -420,19 +416,19 @@ int main(int argc, char *argv[])
 
 		/* Test remount case */
 		fprintf(domain_fp,
-			"allow_mount any /tmp/mount/ --remount 0\n");
+			"file mount any /tmp/mount/ --remount 0\n");
 		show_prompt("mount('/tmp/mount/', MS_REMOUNT)", 0);
 		if (mount("none", "/tmp/mount/", "tmpfs", MS_REMOUNT, NULL)
 		    == 0)
 			printf("OK\n");
 		else
 			printf("FAILED: %s\n", strerror(errno));
-		fprintf(domain_fp, "delete allow_mount any /tmp/mount/ "
+		fprintf(domain_fp, "delete file mount any /tmp/mount/ "
 			"--remount 0\n");
 
 		/* Test bind case */
 		fprintf(domain_fp,
-			"allow_mount /tmp/mount/ /tmp/mount_bind/ --bind 0\n");
+			"file mount /tmp/mount/ /tmp/mount_bind/ --bind 0\n");
 		show_prompt("mount('/tmp/mount/', '/tmp/mount_bind', MS_BIND)",
 			    0);
 		if (mount("/tmp/mount/", "/tmp/mount_bind/", NULL, MS_BIND,
@@ -442,13 +438,13 @@ int main(int argc, char *argv[])
 			printf("FAILED: %s\n", strerror(errno));
 		set_profile(0, "file::mount");
 		umount("/tmp/mount_bind/");
-		fprintf(domain_fp, "delete allow_mount /tmp/mount/ "
+		fprintf(domain_fp, "delete file mount /tmp/mount/ "
 			"/tmp/mount_bind/ --bind 0\n");
 
 		/* Test move case */
 		set_profile(3, "file::mount");
-		fprintf(domain_fp, "allow_unmount /tmp/mount/\n");
-		fprintf(domain_fp, "allow_mount /tmp/mount/ /tmp/mount_move/ "
+		fprintf(domain_fp, "file unmount /tmp/mount/\n");
+		fprintf(domain_fp, "file mount /tmp/mount/ /tmp/mount_move/ "
 			"--move 0\n");
 		show_prompt("mount('/tmp/mount/', '/tmp/mount_move/', "
 			    "MS_MOVE)", 0);
@@ -459,8 +455,8 @@ int main(int argc, char *argv[])
 			printf("FAILED: %s\n", strerror(errno));
 		set_profile(0, "file::mount");
 		umount("/tmp/mount_move/");
-		fprintf(domain_fp, "delete allow_unmount /tmp/mount/\n");
-		fprintf(domain_fp, "delete allow_mount /tmp/mount/ "
+		fprintf(domain_fp, "delete file unmount /tmp/mount/\n");
+		fprintf(domain_fp, "delete file mount /tmp/mount/ "
 			"/tmp/mount_move/ --move 0\n");
 
 		while (umount("/tmp/mount/") == 0)
@@ -470,22 +466,22 @@ int main(int argc, char *argv[])
 	/* Test umount(). */
 	{
 		/* Test standard case */
-		fprintf(domain_fp, "allow_unmount /tmp/mount/\n");
+		fprintf(domain_fp, "file unmount /tmp/mount/\n");
 
-		set_profile(0, "file::umount");
+		set_profile(0, "file::unmount");
 		mount2("none", "/tmp/mount/", "tmpfs");
-		set_profile(3, "file::umount");
+		set_profile(3, "file::unmount");
 		show_prompt("umount('/tmp/mount/') for '/tmp/mount/'", 0);
 		if (umount("/tmp/mount/") == 0)
 			printf("OK\n");
 		else
 			printf("BUG: %s\n", strerror(errno));
-		fprintf(domain_fp, "delete allow_unmount /tmp/mount/\n");
+		fprintf(domain_fp, "delete file unmount /tmp/mount/\n");
 
-		set_profile(0, "file::umount");
+		set_profile(0, "file::unmount");
 
 		mount2("none", "/tmp/mount/", "tmpfs");
-		set_profile(3, "file::umount");
+		set_profile(3, "file::unmount");
 		show_prompt("umount('/tmp/mount/') for '/tmp/mount/'", 1);
 		if (umount("/tmp/mount/") == EOF && errno == EPERM)
 			printf("OK: Permission denied.\n");
@@ -493,10 +489,10 @@ int main(int argc, char *argv[])
 			printf("FAILED: %s\n", strerror(errno));
 
 		/* Test pattern */
-		fprintf(domain_fp, "allow_unmount /tmp/\\?\\?\\?\\?\\?/\n");
-		set_profile(0, "file::umount");
+		fprintf(domain_fp, "file unmount /tmp/\\?\\?\\?\\?\\?/\n");
+		set_profile(0, "file::unmount");
 		mount2("none", "/tmp/mount/", "tmpfs");
-		set_profile(3, "file::umount");
+		set_profile(3, "file::unmount");
 		show_prompt("umount('/tmp/mount/') for "
 			    "'/tmp/\\?\\?\\?\\?\\?/'", 1);
 		if (umount("/tmp/mount/") == 0)
@@ -504,9 +500,9 @@ int main(int argc, char *argv[])
 		else
 			printf("BUG: %s\n", strerror(errno));
 		fprintf(domain_fp,
-			"delete allow_unmount /tmp/\\?\\?\\?\\?\\?/\n");
+			"delete file unmount /tmp/\\?\\?\\?\\?\\?/\n");
 
-		set_profile(0, "file::umount");
+		set_profile(0, "file::unmount");
 		while (umount("/tmp/mount/") == 0)
 			c++; /* Dummy. */
 	}
@@ -516,7 +512,7 @@ int main(int argc, char *argv[])
 		set_profile(3, "file::chroot");
 
 		/* Test standard case */
-		fprintf(domain_fp, "allow_chroot /tmp/mount/\n");
+		fprintf(domain_fp, "file chroot /tmp/mount/\n");
 		show_prompt("chroot('/tmp/mount/') for '/tmp/mount/'", 0);
 		fflush(stdout);
 		if (fork() == 0) {
@@ -528,7 +524,7 @@ int main(int argc, char *argv[])
 			_exit(0);
 		}
 		wait(NULL);
-		fprintf(domain_fp, "delete allow_chroot /tmp/mount/\n");
+		fprintf(domain_fp, "delete file chroot /tmp/mount/\n");
 
 		show_prompt("chroot('/tmp/mount/') for '/tmp/mount/'", 1);
 		fflush(stdout);
@@ -543,7 +539,7 @@ int main(int argc, char *argv[])
 		wait(NULL);
 
 		/* Test pattern */
-		fprintf(domain_fp, "allow_chroot /tmp/\\?\\?\\?\\?\\?/\n");
+		fprintf(domain_fp, "file chroot /tmp/\\?\\?\\?\\?\\?/\n");
 		show_prompt("chroot('/tmp/mount/') for "
 			    "'/tmp/\\?\\?\\?\\?\\?/'", 0);
 		fflush(stdout);
@@ -557,7 +553,7 @@ int main(int argc, char *argv[])
 		}
 		wait(NULL);
 		fprintf(domain_fp,
-			"delete allow_chroot /tmp/\\?\\?\\?\\?\\?/\n");
+			"delete file chroot /tmp/\\?\\?\\?\\?\\?/\n");
 
 		set_profile(0, "file::chroot");
 	}
@@ -565,16 +561,14 @@ int main(int argc, char *argv[])
 	/* Test pivot_root(). */
 	{
 		int error;
-		static char stack[8192];
+		char *stack = malloc(8192);
 		set_profile(3, "file::pivot_root");
-		fprintf(domain_fp, "allow_pivot_root %s %s\n",
-			 pivot_root_dir, proc_policy_dir);
-		snprintf(stack, 8191, "pivot_root('%s', '%s')", pivot_root_dir,
-			 proc_policy_dir);
+		fprintf(domain_fp, "file pivot_root securityfs:/ securityfs:/tomoyo/\n");
+		snprintf(stack, 8191, "pivot_root('securityfs:/', 'securityfs:/tomoyo/')");
 		show_prompt(stack, 0);
 		{
-			const pid_t pid = ltp_clone_quick(CLONE_NEWNS, child,
-							  NULL);
+			const pid_t pid = clone(child, stack + (8192 / 2),
+						CLONE_NEWNS, NULL);
 			while (waitpid(pid, &error, __WALL) == EOF &&
 			       errno == EINTR)
 				c++; /* Dummy. */
@@ -585,14 +579,13 @@ int main(int argc, char *argv[])
 		else
 			printf("FAILED: %s\n", strerror(errno));
 
-		fprintf(domain_fp, "delete allow_pivot_root %s %s\n",
-			pivot_root_dir, proc_policy_dir);
-		snprintf(stack, 8191, "pivot_root('%s', '%s')", pivot_root_dir,
-			 proc_policy_dir);
+		fprintf(domain_fp,
+			"delete file pivot_root securityfs:/ securityfs:/tomoyo/\n");
+		snprintf(stack, 8191, "pivot_root('securityfs:/', 'securityfs:/tomoyo/')");
 		show_prompt(stack, 1);
 		{
-			const pid_t pid = ltp_clone_quick(CLONE_NEWNS, child,
-							  NULL);
+			const pid_t pid = clone(child, stack + (8192 / 2),
+						CLONE_NEWNS, NULL);
 			while (waitpid(pid, &error, __WALL) == EOF &&
 			       errno == EINTR)
 				c++; /* Dummy. */
@@ -604,12 +597,11 @@ int main(int argc, char *argv[])
 			printf("BUG: %s\n", strerror(errno));
 
 		set_profile(2, "file::pivot_root");
-		snprintf(stack, 8191, "pivot_root('%s', '%s')", pivot_root_dir,
-			 proc_policy_dir);
+		snprintf(stack, 8191, "pivot_root('securityfs:/', 'securityfs:/tomoyo/')");
 		show_prompt(stack, 0);
 		{
-			const pid_t pid = ltp_clone_quick(CLONE_NEWNS, child,
-							  NULL);
+			const pid_t pid = clone(child, stack + (8192 / 2),
+						CLONE_NEWNS, NULL);
 			while (waitpid(pid, &error, __WALL) == EOF &&
 			       errno == EINTR)
 				c++; /* Dummy. */
@@ -622,6 +614,7 @@ int main(int argc, char *argv[])
 
 		set_profile(0, "file::pivot_root");
 
+		free(stack);
 	}
 
 	rmdir("/tmp/mount_move/");
@@ -629,5 +622,9 @@ int main(int argc, char *argv[])
 	rmdir("/tmp/mount/");
 
 	clear_status();
+	if (0) { /* To suppress "defined but not used" warnings. */
+		write_domain_policy("", 0);
+		write_exception_policy("", 0);
+	}
 	return 0;
 }
diff --git a/testcases/kernel/security/tomoyo/tomoyo_new_file_test.c b/testcases/kernel/security/tomoyo/tomoyo_new_file_test.c
index 0d13fdd..9146dce 100644
--- a/testcases/kernel/security/tomoyo/tomoyo_new_file_test.c
+++ b/testcases/kernel/security/tomoyo/tomoyo_new_file_test.c
@@ -1,45 +1,68 @@
-/******************************************************************************/
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    */
-/*                                                                            */
-/******************************************************************************/
 /*
- * tomoyo_new_file_test.c
+ * ccs_new_file_test.c
  *
- * Testing program for security/tomoyo/
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Copyright (C) 2005-2010  NTT DATA CORPORATION
+ * Version: 2.4.0   2011/08/06
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 #include "include.h"
+#include <linux/elf.h>
+
+static void make_elf_lib(void)
+{
+	static const struct elf32_phdr eph = {
+		.p_type = PT_LOAD,
+		.p_offset = 4096,
+		.p_filesz = 1,
+	};
+	static const struct elf32_hdr eh = {
+		.e_ident = ELFMAG,
+		.e_type = ET_EXEC,
+		.e_machine = EM_386,
+		.e_phoff = sizeof(eh),
+		.e_phentsize = sizeof(eph),
+		.e_phnum = 1,
+	};
+	const int fd = open("/tmp/uselib", O_WRONLY | O_CREAT | O_TRUNC, 0755);
+	if (fd != EOF) {
+		write(fd, &eh, sizeof(eh));
+		write(fd, &eph, sizeof(eph));
+		lseek(fd, 4096, SEEK_SET);
+		write(fd, "", 1);
+		close(fd);
+	}
+}
 
 static const char *policy = "";
 
 static void show_result(int result, char should_success)
 {
-	int error = errno;
+	int err = errno;
 	printf("%s : ", policy);
 	if (should_success) {
 		if (result != EOF)
 			printf("OK\n");
 		else
-			printf("FAILED: %s\n", strerror(error));
+			printf("FAILED: %s\n", strerror(err));
 	} else {
 		if (result == EOF) {
-			if (error == EPERM)
+			if (err == EPERM)
 				printf("OK: Permission denied.\n");
 			else
-				printf("FAILED: %s\n", strerror(error));
+				printf("FAILED: %s\n", strerror(err));
 		} else {
 			printf("BUG: didn't fail.\n");
 		}
@@ -94,13 +117,14 @@ static void stage_file_test(void)
 	int buffer[2] = { 32768, 61000 };
 	size_t size = sizeof(buffer);
 	int pipe_fd[2] = { EOF, EOF };
-	int error = 0;
+	int err = 0;
 	int fd;
 	char pbuffer[1024];
 	struct stat sbuf;
 	struct sockaddr_un addr;
 	struct ifreq ifreq;
 	char *filename = "";
+	int ret_ignored;
 	set_profile(3, "file::execute");
 	set_profile(3, "file::open");
 	set_profile(3, "file::create");
@@ -111,7 +135,6 @@ static void stage_file_test(void)
 	set_profile(3, "file::mksock");
 	set_profile(3, "file::truncate");
 	set_profile(3, "file::symlink");
-	set_profile(3, "file::rewrite");
 	set_profile(3, "file::mkblock");
 	set_profile(3, "file::mkchar");
 	set_profile(3, "file::link");
@@ -122,70 +145,81 @@ static void stage_file_test(void)
 	set_profile(3, "file::ioctl");
 	set_profile(3, "file::chroot");
 	set_profile(3, "file::mount");
-	set_profile(3, "file::umount");
+	set_profile(3, "file::unmount");
 	set_profile(3, "file::pivot_root");
 
-	policy = "allow_read /proc/sys/net/ipv4/ip_local_port_range";
+	policy = "file read proc:/sys/net/ipv4/ip_local_port_range "
+		"task.uid=0 task.gid=0";
 	write_domain_policy(policy, 0);
 	show_result(sysctl(name, 3, buffer, &size, 0, 0), 1);
 	write_domain_policy(policy, 1);
 	show_result(sysctl(name, 3, buffer, &size, 0, 0), 0);
 
-	policy = "allow_write /proc/sys/net/ipv4/ip_local_port_range";
+	policy = "file write proc:/sys/net/ipv4/ip_local_port_range "
+		"task.euid=0 0=0 1-100=10-1000";
 	write_domain_policy(policy, 0);
 	show_result(sysctl(name, 3, 0, 0, buffer, size), 1);
 	write_domain_policy(policy, 1);
 	show_result(sysctl(name, 3, 0, 0, buffer, size), 0);
 
-	policy = "allow_read/write /proc/sys/net/ipv4/ip_local_port_range";
+	policy = "file read proc:/sys/net/ipv4/ip_local_port_range "
+		"1!=10-100";
+	write_domain_policy(policy, 0);
+	policy = "file write proc:/sys/net/ipv4/ip_local_port_range "
+		"1!=10-100";
 	write_domain_policy(policy, 0);
 	show_result(sysctl(name, 3, buffer, &size, buffer, size), 1);
+	policy = "file read proc:/sys/net/ipv4/ip_local_port_range "
+		"1!=10-100";
+	write_domain_policy(policy, 1);
+	policy = "file write proc:/sys/net/ipv4/ip_local_port_range "
+		"1!=10-100";
 	write_domain_policy(policy, 1);
 	show_result(sysctl(name, 3, buffer, &size, buffer, size), 0);
 
-	policy = "allow_read /bin/true";
+	policy = "file read /tmp/uselib "
+		"path1.uid=0 path1.parent.uid=0 10=10-100";
 	write_domain_policy(policy, 0);
-	show_result(uselib("/bin/true"), 1);
+	show_result(uselib("/tmp/uselib"), 1);
 	write_domain_policy(policy, 1);
-	show_result(uselib("/bin/true"), 0);
+	show_result(uselib("/tmp/uselib"), 0);
 
-	policy = "allow_execute /bin/true";
+	policy = "file execute /bin/true task.uid!=10 path1.parent.uid=0";
 	write_domain_policy(policy, 0);
 	fflush(stdout);
 	fflush(stderr);
-	if (pipe(pipe_fd) == -1)
-		err(1, "pipe");
+	ret_ignored = pipe(pipe_fd);
 	if (fork() == 0) {
 		execl("/bin/true", "/bin/true", NULL);
-		if (write(pipe_fd[1], &errno, sizeof(errno)) == -1)
-			err(1, "write");
-		exit(0);
+		err = errno;
+		ret_ignored = write(pipe_fd[1], &err, sizeof(err));
+		_exit(0);
 	}
 	close(pipe_fd[1]);
-	(void)read(pipe_fd[0], &error, sizeof(error));
+	ret_ignored = read(pipe_fd[0], &err, sizeof(err));
 	close(pipe_fd[0]);
 	wait(NULL);
-	errno = error;
-	show_result(error ? EOF : 0, 1);
+	errno = err;
+	show_result(err ? EOF : 0, 1);
 	write_domain_policy(policy, 1);
 	fflush(stdout);
 	fflush(stderr);
-	if (pipe(pipe_fd) == -1)
-		err(1, "pipe");
+	ret_ignored = pipe(pipe_fd);
 	if (fork() == 0) {
 		execl("/bin/true", "/bin/true", NULL);
-		if (write(pipe_fd[1], &errno, sizeof(errno)) == -1)
-			err(1, "write");
+		err = errno;
+		ret_ignored = write(pipe_fd[1], &err, sizeof(err));
 		_exit(0);
 	}
 	close(pipe_fd[1]);
-	(void)read(pipe_fd[0], &error, sizeof(error));
+	ret_ignored = read(pipe_fd[0], &err, sizeof(err));
 	close(pipe_fd[0]);
 	wait(NULL);
-	errno = error;
-	show_result(errno ? EOF : 0, 0);
+	errno = err;
+	show_result(err ? EOF : 0, 0);
 
-	policy = "allow_read /dev/null";
+	policy = "file read /dev/null path1.type=char path1.dev_major=1 "
+		"path1.dev_minor=3";
 	write_domain_policy(policy, 0);
 	fd = open("/dev/null", O_RDONLY);
 	show_result(fd, 1);
@@ -197,7 +231,7 @@ static void stage_file_test(void)
 	if (fd != EOF)
 		close(fd);
 
-	policy = "allow_read /dev/null";
+	policy = "file read /dev/null path1.perm=0666";
 	write_domain_policy(policy, 0);
 	fd = open("/dev/null", O_RDONLY);
 	show_result(fd, 1);
@@ -209,7 +243,7 @@ static void stage_file_test(void)
 	if (fd != EOF)
 		close(fd);
 
-	policy = "allow_read /dev/null";
+	policy = "file read /dev/null path1.perm!=0777";
 	write_domain_policy(policy, 0);
 	fd = open("/dev/null", O_RDONLY);
 	show_result(fd, 1);
@@ -221,7 +255,12 @@ static void stage_file_test(void)
 	if (fd != EOF)
 		close(fd);
 
-	policy = "allow_read /dev/null";
+	policy = "file read /dev/null path1.perm=owner_read "
+		"path1.perm=owner_write path1.perm!=owner_execute "
+		"path1.perm=group_read path1.perm=group_write "
+		"path1.perm!=group_execute path1.perm=others_read "
+		"path1.perm=others_write path1.perm!=others_execute "
+		"path1.perm!=setuid path1.perm!=setgid path1.perm!=sticky";
 	write_domain_policy(policy, 0);
 	fd = open("/dev/null", O_RDONLY);
 	show_result(fd, 1);
@@ -234,7 +273,9 @@ static void stage_file_test(void)
 		close(fd);
 
 	set_profile(3, "file::mkfifo");
-	policy = "allow_mkfifo /tmp/mknod_fifo_test 0644";
+	policy = "file mkfifo /tmp/mknod_fifo_test 0644 "
+		"path1.parent.perm=01777 path1.parent.perm=sticky "
+		"path1.parent.uid=0 path1.parent.gid=0";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/mknod_fifo_test";
 	show_result(mknod(filename, S_IFIFO | 0644, 0), 1);
@@ -247,7 +288,9 @@ static void stage_file_test(void)
 	filename = "/dev/null";
 	stat(filename, &sbuf);
 	snprintf(pbuffer, sizeof(pbuffer) - 1,
-		 "allow_write %s", filename);
+		 "file write %s path1.major=%u path1.minor=%u",
+		 filename, (unsigned int) MAJOR(sbuf.st_dev),
+		 (unsigned int) MINOR(sbuf.st_dev));
 	policy = pbuffer;
 	write_domain_policy(policy, 0);
 	fd = open(filename, O_WRONLY);
@@ -260,7 +303,8 @@ static void stage_file_test(void)
 	if (fd != EOF)
 		close(fd);
 
-	policy = "allow_read/write /tmp/fifo";
+	policy = "file read /tmp/fifo path1.type=fifo\t"
+		"file write /tmp/fifo path1.type=fifo";
 	mkfifo2("/tmp/fifo");
 	write_domain_policy(policy, 0);
 	fd = open("/tmp/fifo", O_RDWR);
@@ -273,7 +317,7 @@ static void stage_file_test(void)
 	if (fd != EOF)
 		close(fd);
 
-	policy = "allow_read /dev/null";
+	policy = "file read /dev/null path1.parent.ino=path1.parent.ino";
 	write_domain_policy(policy, 0);
 	fd = open("/dev/null", O_RDONLY);
 	show_result(fd, 1);
@@ -285,7 +329,7 @@ static void stage_file_test(void)
 	if (fd != EOF)
 		close(fd);
 
-	policy = "allow_write /dev/null";
+	policy = "file write /dev/null path1.uid=path1.gid";
 	write_domain_policy(policy, 0);
 	fd = open("/dev/null", O_WRONLY);
 	show_result(fd, 1);
@@ -297,7 +341,8 @@ static void stage_file_test(void)
 	if (fd != EOF)
 		close(fd);
 
-	policy = "allow_read/write /dev/null";
+	policy = "file read /dev/null task.uid=path1.parent.uid\t"
+		"file write /dev/null task.uid=path1.parent.uid";
 	write_domain_policy(policy, 0);
 	fd = open("/dev/null", O_RDWR);
 	show_result(fd, 1);
@@ -309,9 +354,10 @@ static void stage_file_test(void)
 	if (fd != EOF)
 		close(fd);
 
-	policy = "allow_create /tmp/open_test 0644";
+	policy = "file create /tmp/open_test 0644 "
+		"path1.parent.uid=task.uid";
 	write_domain_policy(policy, 0);
-	policy = "allow_write /tmp/open_test";
+	policy = "file write /tmp/open_test path1.parent.uid=0";
 	write_domain_policy(policy, 0);
 	fd = open("/tmp/open_test", O_WRONLY | O_CREAT | O_EXCL, 0644);
 	show_result(fd, 1);
@@ -325,12 +371,13 @@ static void stage_file_test(void)
 		close(fd);
 	unlink2("/tmp/open_test");
 
-	policy = "allow_create /tmp/open_test 0644";
+	policy = "file create /tmp/open_test 0644 "
+		"path1.parent.uid=task.uid";
 	write_domain_policy(policy, 1);
 
-	policy = "allow_write /tmp/open_test";
+	policy = "file write /tmp/open_test task.uid=0 path1.ino!=0";
 	write_domain_policy(policy, 0);
-	policy = "allow_create /tmp/open_test 0644";
+	policy = "file create /tmp/open_test 0644 0=0";
 	write_domain_policy(policy, 0);
 	fd = open("/tmp/open_test", O_WRONLY | O_CREAT | O_EXCL, 0644);
 	show_result(fd, 1);
@@ -343,15 +390,15 @@ static void stage_file_test(void)
 	if (fd != EOF)
 		close(fd);
 	unlink2("/tmp/open_test");
-	policy = "allow_write /tmp/open_test";
+	policy = "file write /tmp/open_test task.uid=0 path1.ino!=0";
 	write_domain_policy(policy, 1);
 
 	filename = "/tmp/truncate_test";
 	create2(filename);
 
-	policy = "allow_truncate /tmp/truncate_test";
+	policy = "file truncate /tmp/truncate_test task.uid=path1.uid";
 	write_domain_policy(policy, 0);
-	policy = "allow_write /tmp/truncate_test";
+	policy = "file write /tmp/truncate_test 1!=100-1000000";
 	write_domain_policy(policy, 0);
 	fd = open(filename, O_WRONLY | O_TRUNC);
 	show_result(fd, 1);
@@ -362,12 +409,13 @@ static void stage_file_test(void)
 	show_result(fd, 0);
 	if (fd != EOF)
 		close(fd);
-	policy = "allow_truncate /tmp/truncate_test";
+	policy = "file truncate /tmp/truncate_test "
+		"task.uid=path1.uid";
 	write_domain_policy(policy, 1);
 
-	policy = "allow_write /tmp/truncate_test";
+	policy = "file write /tmp/truncate_test";
 	write_domain_policy(policy, 0);
-	policy = "allow_truncate /tmp/truncate_test";
+	policy = "file truncate /tmp/truncate_test";
 	write_domain_policy(policy, 0);
 	fd = open(filename, O_WRONLY | O_TRUNC);
 	show_result(fd, 1);
@@ -378,16 +426,16 @@ static void stage_file_test(void)
 	show_result(fd, 0);
 	if (fd != EOF)
 		close(fd);
-	policy = "allow_write /tmp/truncate_test";
+	policy = "file write /tmp/truncate_test";
 	write_domain_policy(policy, 1);
 
-	policy = "allow_truncate /tmp/truncate_test";
+	policy = "file truncate /tmp/truncate_test";
 	write_domain_policy(policy, 0);
 	show_result(truncate(filename, 0), 1);
 	write_domain_policy(policy, 1);
 	show_result(truncate(filename, 0), 0);
 
-	policy = "allow_truncate /tmp/truncate_test";
+	policy = "file truncate /tmp/truncate_test";
 	write_domain_policy(policy, 0);
 	set_profile(0, "file::open");
 	fd = open(filename, O_WRONLY);
@@ -400,7 +448,7 @@ static void stage_file_test(void)
 
 	unlink2(filename);
 
-	policy = "allow_create /tmp/mknod_reg_test 0644";
+	policy = "file create /tmp/mknod_reg_test 0644";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/mknod_reg_test";
 	show_result(mknod(filename, S_IFREG | 0644, 0), 1);
@@ -408,7 +456,7 @@ static void stage_file_test(void)
 	unlink2(filename);
 	show_result(mknod(filename, S_IFREG | 0644, 0), 0);
 
-	policy = "allow_mkchar /tmp/mknod_chr_test 0644 1 3";
+	policy = "file mkchar /tmp/mknod_chr_test 0644 1 3";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/mknod_chr_test";
 	show_result(mknod(filename, S_IFCHR | 0644, MKDEV(1, 3)), 1);
@@ -416,7 +464,7 @@ static void stage_file_test(void)
 	unlink2(filename);
 	show_result(mknod(filename, S_IFCHR | 0644, MKDEV(1, 3)), 0);
 
-	policy = "allow_mkblock /tmp/mknod_blk_test 0644 1 0";
+	policy = "file mkblock /tmp/mknod_blk_test 0644 1 0";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/mknod_blk_test";
 	show_result(mknod(filename, S_IFBLK | 0644, MKDEV(1, 0)), 1);
@@ -424,7 +472,7 @@ static void stage_file_test(void)
 	unlink2(filename);
 	show_result(mknod(filename, S_IFBLK | 0644, MKDEV(1, 0)), 0);
 
-	policy = "allow_mkfifo /tmp/mknod_fifo_test 0644";
+	policy = "file mkfifo /tmp/mknod_fifo_test 0644";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/mknod_fifo_test";
 	show_result(mknod(filename, S_IFIFO | 0644, 0), 1);
@@ -432,7 +480,7 @@ static void stage_file_test(void)
 	unlink2(filename);
 	show_result(mknod(filename, S_IFIFO | 0644, 0), 0);
 
-	policy = "allow_mksock /tmp/mknod_sock_test 0644";
+	policy = "file mksock /tmp/mknod_sock_test 0644";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/mknod_sock_test";
 	show_result(mknod(filename, S_IFSOCK | 0644, 0), 1);
@@ -440,7 +488,7 @@ static void stage_file_test(void)
 	unlink2(filename);
 	show_result(mknod(filename, S_IFSOCK | 0644, 0), 0);
 
-	policy = "allow_mkdir /tmp/mkdir_test/ 0600";
+	policy = "file mkdir /tmp/mkdir_test/ 0600";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/mkdir_test";
 	show_result(mkdir(filename, 0600), 1);
@@ -448,7 +496,7 @@ static void stage_file_test(void)
 	rmdir2(filename);
 	show_result(mkdir(filename, 0600), 0);
 
-	policy = "allow_rmdir /tmp/rmdir_test/";
+	policy = "file rmdir /tmp/rmdir_test/";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/rmdir_test";
 	mkdir2(filename);
@@ -458,7 +506,7 @@ static void stage_file_test(void)
 	show_result(rmdir(filename), 0);
 	rmdir2(filename);
 
-	policy = "allow_unlink /tmp/unlink_test";
+	policy = "file unlink /tmp/unlink_test";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/unlink_test";
 	create2(filename);
@@ -468,7 +516,7 @@ static void stage_file_test(void)
 	show_result(unlink(filename), 0);
 	unlink2(filename);
 
-	policy = "allow_symlink /tmp/symlink_source_test";
+	policy = "file symlink /tmp/symlink_source_test";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/symlink_source_test";
 	show_result(symlink("/tmp/symlink_dest_test", filename), 1);
@@ -476,7 +524,8 @@ static void stage_file_test(void)
 	unlink2(filename);
 	show_result(symlink("/tmp/symlink_dest_test", filename), 0);
 
-	policy = "allow_symlink /tmp/symlink_source_test";
+	policy = "file symlink /tmp/symlink_source_test "
+		"symlink.target=\"/tmp/symlink_\\*_test\"";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/symlink_source_test";
 	show_result(symlink("/tmp/symlink_dest_test", filename), 1);
@@ -484,7 +533,8 @@ static void stage_file_test(void)
 	unlink2(filename);
 	show_result(symlink("/tmp/symlink_dest_test", filename), 0);
 
-	policy = "allow_symlink /tmp/symlink_source_test";
+	policy = "file symlink /tmp/symlink_source_test "
+		"task.uid=0 symlink.target=\"/tmp/symlink_\\*_test\"";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/symlink_source_test";
 	show_result(symlink("/tmp/symlink_dest_test", filename), 1);
@@ -492,7 +542,8 @@ static void stage_file_test(void)
 	unlink2(filename);
 	show_result(symlink("/tmp/symlink_dest_test", filename), 0);
 
-	policy = "allow_symlink /tmp/symlink_source_test";
+	policy = "file symlink /tmp/symlink_source_test "
+		"symlink.target!=\"\\*\"";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/symlink_source_test";
 	show_result(symlink("/tmp/symlink_dest_test", filename), 1);
@@ -500,15 +551,16 @@ static void stage_file_test(void)
 	unlink2(filename);
 	show_result(symlink("/tmp/symlink_dest_test", filename), 0);
 
-	policy = "allow_symlink /tmp/symlink_source_test";
+	policy = "file symlink /tmp/symlink_source_test "
+		"symlink.target!=\"/tmp/symlink_\\*_test\"";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/symlink_source_test";
-	show_result(symlink("/tmp/symlink_dest_test", filename), 1);
+	show_result(symlink("/tmp/symlink_dest_test", filename), 0);
 	write_domain_policy(policy, 1);
 	unlink2(filename);
 	show_result(symlink("/tmp/symlink_dest_test", filename), 0);
 
-	policy = "allow_link /tmp/link_source_test /tmp/link_dest_test";
+	policy = "file link /tmp/link_source_test /tmp/link_dest_test";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/link_source_test";
 	create2(filename);
@@ -518,7 +570,7 @@ static void stage_file_test(void)
 	show_result(link(filename, "/tmp/link_dest_test"), 0);
 	unlink2(filename);
 
-	policy = "allow_rename /tmp/rename_source_test /tmp/rename_dest_test";
+	policy = "file rename /tmp/rename_source_test /tmp/rename_dest_test";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/rename_source_test";
 	create2(filename);
@@ -529,7 +581,7 @@ static void stage_file_test(void)
 	show_result(rename(filename, "/tmp/rename_dest_test"), 0);
 	unlink2(filename);
 
-	policy = "allow_mksock /tmp/socket_test 0755";
+	policy = "file mksock /tmp/socket_test 0755";
 	write_domain_policy(policy, 0);
 	filename = "/tmp/socket_test";
 	memset(&addr, 0, sizeof(addr));
@@ -547,62 +599,10 @@ static void stage_file_test(void)
 		    0);
 	if (fd != EOF)
 		close(fd);
-
-	filename = "/tmp/rewrite_test";
-	create2(filename);
-	policy = "allow_read/write /tmp/rewrite_test";
-	write_domain_policy(policy, 0);
-	write_exception_policy("deny_rewrite /tmp/rewrite_test", 0);
-	policy = "allow_truncate /tmp/rewrite_test";
-	write_domain_policy(policy, 0);
-
-	fd = open(filename, O_RDONLY);
-	show_result(fd, 1);
-	if (fd != EOF)
-		close(fd);
-
-	fd = open(filename, O_WRONLY | O_APPEND);
-	show_result(fd, 1);
-	if (fd != EOF)
-		close(fd);
-
-	fd = open(filename, O_WRONLY);
-	show_result(fd, 0);
-	if (fd != EOF)
-		close(fd);
-
-	fd = open(filename, O_WRONLY | O_TRUNC);
-	show_result(fd, 0);
-	if (fd != EOF)
-		close(fd);
-
-	fd = open(filename, O_WRONLY | O_TRUNC | O_APPEND);
-	show_result(fd, 0);
-	if (fd != EOF)
-		close(fd);
-
-	show_result(truncate(filename, 0), 0);
-
-	set_profile(0, "file::open");
-	fd = open(filename, O_WRONLY | O_APPEND);
-	set_profile(3, "file::open");
-	show_result(ftruncate(fd, 0), 0);
-
-	show_result(fcntl(fd, F_SETFL,
-			  fcntl(fd, F_GETFL) & ~O_APPEND), 0);
-	if (fd != EOF)
-		close(fd);
-
-	write_domain_policy(policy, 1);
-
-	policy = "allow_read/write /tmp/rewrite_test";
-	write_domain_policy(policy, 1);
-	write_exception_policy("deny_rewrite /tmp/rewrite_test", 1);
-
 	unlink2(filename);
 
-	policy = "allow_ioctl socket:[family=2:type=2:protocol=17] "
-		"35122-35124";
+	policy = "file ioctl socket:[family=2:type=2:protocol=17] "
+		"35122-35124 task.uid=0";
 	write_domain_policy(policy, 0);
 	fd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);
 	memset(&ifreq, 0, sizeof(ifreq));
@@ -610,7 +610,7 @@ static void stage_file_test(void)
 		 "lo");
 	show_result(ioctl(fd, 35123, &ifreq), 1);
 	write_domain_policy(policy, 1);
-	policy = "allow_ioctl "
+	policy = "file ioctl "
 		"socket:[family=2:type=2:protocol=17] 0-35122";
 	write_domain_policy(policy, 0);
 	show_result(ioctl(fd, 35123, &ifreq), 0);
@@ -621,13 +621,16 @@ static void stage_file_test(void)
 
 int main(int argc, char *argv[])
 {
-	tomoyo_test_init();
+	ccs_test_init();
+	make_elf_lib();
 	fprintf(domain_fp, "%s /bin/true\n", self_domain);
 	fprintf(domain_fp, "use_profile 255\n");
 	fprintf(domain_fp, "select pid=%u\n", pid);
-	fprintf(profile_fp, "255-PREFERENCE::audit={ max_reject_log=1024 }\n");
+	fprintf(profile_fp, "255-PREFERENCE={ max_reject_log=1024 }\n");
 	stage_file_test();
 	fprintf(domain_fp, "use_profile 0\n");
 	clear_status();
+	if (0) /* To suppress "defined but not used" warnings. */
+		write_exception_policy("", 0);
 	return 0;
 }
diff --git a/testcases/kernel/security/tomoyo/tomoyo_new_test.c b/testcases/kernel/security/tomoyo/tomoyo_new_test.c
index a697b36..865c521 100644
--- a/testcases/kernel/security/tomoyo/tomoyo_new_test.c
+++ b/testcases/kernel/security/tomoyo/tomoyo_new_test.c
@@ -1,47 +1,44 @@
-/******************************************************************************/
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    */
-/*                                                                            */
-/******************************************************************************/
 /*
- * tomoyo_new_test.c
+ * ccs_new_test.c
  *
- * Testing program for security/tomoyo/
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Copyright (C) 2005-2010  NTT DATA CORPORATION
+ * Version: 2.4.0   2011/08/06
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 #include "include.h"
 
-static int result;
-static int error;
+static int result = 0;
+static int err = 0;
 
 static void show_result(const char *test, int should_success)
 {
-	error = errno;
+	err = errno;
 	printf("%s : ", test);
 	if (should_success) {
-		if (error == 0)
+		if (err == 0)
 			printf("OK (%d)\n", result);
 		else
-			printf("FAILED: %s\n", strerror(error));
+			printf("FAILED: %s\n", strerror(err));
 	} else {
-		if (error == 0)
+		if (err == 0)
 			printf("BUG: Didn't fail (%d)\n", result);
-		else if (error == EPERM)
+		else if (err == EPERM)
 			printf("OK: permission denied\n");
 		else
-			printf("FAILED: %s\n", strerror(error));
+			printf("FAILED: %s\n", strerror(err));
 	}
 }
 
@@ -100,25 +97,25 @@ static void test_execute_bin_true(void)
 	char *argv[] = { "/bin/true", NULL };
 	char *envp[] = { "HOME=/", NULL };
 	int pipe_fd[2] = { EOF, EOF };
-	if (pipe(pipe_fd) == -1)
-		err(1, "pipe");
+	int err = 0;
+	int ret_ignored;
+	ret_ignored = pipe(pipe_fd);
 	switch (fork()) {
 	case 0:
 		execve("/bin/true", argv, envp);
-		error = errno;
-		if (write(pipe_fd[1], &error, sizeof(error)) == -1)
-			err(1, "write");
+		err = errno;
+		ret_ignored = write(pipe_fd[1], &err, sizeof(err));
 		_exit(0);
 		break;
 	case -1:
-		error = ENOMEM;
+		err = -ENOMEM;
 		break;
 	}
 	close(pipe_fd[1]);
-	(void)read(pipe_fd[0], &error, sizeof(error));
+	ret_ignored = read(pipe_fd[0], &err, sizeof(err));
 	close(pipe_fd[0]);
-	result = error ? EOF : 0;
-	errno = error;
+	result = err ? EOF : 0;
+	errno = err;
 }
 
 static void test_chmod_dev_null(void)
@@ -141,9 +138,9 @@ static void test_ioctl_dev_null(void)
 	int fd = open("/dev/null", O_RDWR);
 	errno = 0;
 	result = ioctl(fd, 0x5451, NULL);
-	error = errno;
+	err = errno;
 	close(fd);
-	errno = error;
+	errno = err;
 }
 
 static void setup_chmod_group(void)
@@ -297,11 +294,6 @@ static void test_file_open_19(void)
 	result = open("/tmp/testfile19", O_TRUNC | O_CREAT | O_RDWR, 0600);
 }
 
-static void test_file_open_20(void)
-{
-	result = open("/tmp/testfile20", O_APPEND | O_RDWR, 0600);
-}
-
 static void test_file_open_21(void)
 {
 	result = open("/tmp/testfile21", O_APPEND | O_CREAT | O_RDWR, 0600);
@@ -326,16 +318,10 @@ static void setup_test_file(void)
 	for (i = 0; i < 24; i += 2) {
 		snprintf(buffer, sizeof(buffer) - 1, "/tmp/testfile%u", i);
 		close(open(buffer, O_WRONLY | O_CREAT, 0600));
+		close(open(buffer, O_APPEND | O_CREAT, 0600));
 	}
-	write_exception_policy("deny_rewrite /tmp/testfile\\$", 0);
 }
 
-static void setup_test_file_truncate(void)
-{
-	setup_test_file();
-	write_domain_policy("allow_truncate /tmp/testfile\\$", 0);
-	set_profile(3, "file::truncate");
-}
 
 static void setup_all_test_file(void)
 {
@@ -345,15 +331,8 @@ static void setup_all_test_file(void)
 	for (i = 0; i < 24; i++) {
 		snprintf(buffer, sizeof(buffer) - 1, "/tmp/testfile%u", i);
 		close(open(buffer, O_WRONLY | O_CREAT, 0600));
+		close(open(buffer, O_APPEND | O_CREAT, 0600));
 	}
-	write_exception_policy("deny_rewrite /tmp/testfile\\$", 0);
-}
-
-static void setup_all_test_file_truncate(void)
-{
-	setup_all_test_file();
-	write_domain_policy("allow_truncate /tmp/testfile\\$", 0);
-	set_profile(3, "file::truncate");
 }
 
 static void cleanup_test_file(void)
@@ -365,17 +344,9 @@ static void cleanup_test_file(void)
 		snprintf(buffer, sizeof(buffer) - 1, "/tmp/testfile%u", i);
 		unlink(buffer);
 	}
-	write_exception_policy("deny_rewrite /tmp/testfile\\$", 1);
 	cleanup_file_open();
 }
 
-static void cleanup_test_file_truncate(void)
-{
-	cleanup_test_file();
-	write_domain_policy("allow_truncate /tmp/testfile\\$", 1);
-	set_profile(0, "file::truncate");
-}
-
 static struct test_struct {
 	void (*do_setup) (void);
 	void (*do_test) (void);
@@ -384,267 +355,205 @@ static struct test_struct {
 	const char *policy;
 } tests[] = {
 	{ NULL, test_read_etc_fstab, cleanup_file_open, "file::open",
-	  "allow_read /etc/fstab" },
+	  "file read /etc/fstab" },
 	{ NULL, test_read_etc_fstab, cleanup_file_open, "file::open",
-	  "allow_read /etc/fstab" },
+	  "file read /etc/fstab task.uid=0" },
 	{ NULL, test_read_etc_fstab, cleanup_file_open, "file::open",
-	  "allow_read /etc/fstab" },
+	  "file read /etc/fstab path1.uid=0 path1.parent.uid=0" },
 	{ setup_open_group, test_read_etc_fstab, cleanup_open_group,
-	  "file::open", "allow_read @READABLE" },
+	  "file::open", "file read @READABLE path1.uid=@READABLE_IDS "
+	  "path1.parent.uid=0" },
 	{ NULL, test_write_dev_null, cleanup_file_open, "file::open",
-	  "allow_write /dev/null" },
+	  "file write /dev/null" },
 	{ NULL, test_write_dev_null, cleanup_file_open, "file::open",
-	  "allow_write /dev/null" },
+	  "file write /dev/null task.uid=0" },
 	{ NULL, test_write_dev_null, cleanup_file_open, "file::open",
-	  "allow_write /dev/null" },
+	  "file write /dev/null path1.type=char path1.dev_major=1 "
+	  "path1.dev_minor=3 path1.perm=0666" },
 	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir,
-	  "file::mkdir", "allow_mkdir /tmp/testdir/ 0755" },
+	  "file::mkdir", "file mkdir /tmp/testdir/ 0755" },
 	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir,
-	  "file::mkdir", "allow_mkdir /tmp/testdir/ 0755" },
+	  "file::mkdir", "file mkdir /tmp/testdir/ 0755 "
+	  "path1.parent.uid=0 path1.parent.perm=01777" },
 	{ cleanup_mkdir_testdir, test_mkdir_testdir, cleanup_mkdir_testdir,
-	  "file::mkdir", "allow_mkdir /tmp/testdir/ 0755" },
+	  "file::mkdir", "file mkdir /tmp/testdir/ 0755 "
+	  "task.uid=path1.parent.uid" },
 	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir,
-	  "file::rmdir", "allow_rmdir /tmp/testdir/" },
+	  "file::rmdir", "file rmdir /tmp/testdir/" },
 	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir,
-	  "file::rmdir", "allow_rmdir /tmp/testdir/" },
+	  "file::rmdir", "file rmdir /tmp/testdir/ path1.parent.uid=0 "
+	  "path1.parent.perm=01777" },
 	{ setup_mkdir_testdir, test_rmdir_testdir, cleanup_mkdir_testdir,
-	  "file::rmdir", "allow_rmdir /tmp/testdir/" },
+	  "file::rmdir", "file rmdir /tmp/testdir/ task.uid=0-100 "
+	  "task.gid=0x0-0xFF path1.uid=0" },
 	{ setup_execute_bin_true, test_execute_bin_true,
 	  cleanup_execute_bin_true, "file::execute",
-	  "allow_execute /bin/true" },
+	  "file execute /bin/true" },
 	{ setup_execute_bin_true, test_execute_bin_true,
-	  cleanup_execute_bin_true, "file::execute", "allow_execute /bin/true" },
+	  cleanup_execute_bin_true, "file::execute", "file execute /bin/true "
+	  "exec.argc=1 exec.argv[0]=\"/bin/true\"" },
 	{ setup_execute_bin_true, test_execute_bin_true,
-	  cleanup_execute_bin_true, "file::execute", "allow_execute /bin/true"
+	  cleanup_execute_bin_true, "file::execute", "file execute /bin/true "
+	  "exec.envc=1 exec.envp[\"HOME\"]=\"/\" exec.envp[\"PATH\"]=NULL"
 	},
 	{ NULL, test_chmod_dev_null, NULL, "file::chmod",
-	  "allow_chmod /dev/null 0666"
+	  "file chmod /dev/null 0666 path1.perm=00-07777 path1.type=char"
 	},
 	{ NULL, test_chown_dev_null, NULL, "file::chown",
-	  "allow_chown /dev/null 0" },
+	  "file chown /dev/null 0 task.gid=path1.gid path1.type!=block" },
 	{ NULL, test_chgrp_dev_null, NULL, "file::chgrp",
-	  "allow_chgrp /dev/null 0" },
+	  "file chgrp /dev/null 0 task.uid=path1.parent.uid" },
 	{ NULL, test_ioctl_dev_null, NULL, "file::ioctl",
-	  "allow_ioctl /dev/null 0x5451" },
+	  "file ioctl /dev/null 0x5451 0=0-1000" },
 	{ setup_chmod_group, test_chmod_dev_null, cleanup_chmod_group,
-	  "file::chmod", "allow_chmod @CHMOD_TARGET @CHMOD_MODES" },
+	  "file::chmod", "file chmod @CHMOD_TARGET @CHMOD_MODES" },
 	{ setup_chown_group, test_chown_dev_null, cleanup_chown_group,
-	  "file::chown", "allow_chown @CHOWN_TARGET @CHOWN_IDS" },
+	  "file::chown", "file chown @CHOWN_TARGET @CHOWN_IDS" },
 	{ setup_chown_group, test_chgrp_dev_null, cleanup_chown_group,
-	  "file::chgrp", "allow_chgrp @CHOWN_TARGET @CHOWN_IDS" },
+	  "file::chgrp", "file chgrp @CHOWN_TARGET @CHOWN_IDS" },
 	{ setup_ioctl_group, test_ioctl_dev_null, cleanup_ioctl_group,
-	  "file::ioctl", "allow_ioctl @IOCTL_TARGET @IOCTL_NUMBERS" },
+	  "file::ioctl", "file ioctl @IOCTL_TARGET @IOCTL_NUMBERS" },
 	{ setup_test_file, test_file_open_0, cleanup_test_file, "file::open",
-	  "allow_read /tmp/testfile0" },
+	  "file read /tmp/testfile0 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_1, cleanup_test_file, "file::open",
-	  "allow_read /tmp/testfile1" },
+	  "file read /tmp/testfile1 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_1, cleanup_test_file, "file::create",
-	  "allow_create /tmp/testfile1 0600" },
+	  "file create /tmp/testfile1 0600 task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_2, cleanup_test_file, "file::open",
-	  "allow_read /tmp/testfile2" },
+	  "file read /tmp/testfile2 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_2, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile2"
-	},
-	{ setup_test_file_truncate, test_file_open_2,
-	  cleanup_test_file_truncate, "file::rewrite",
-	  "allow_rewrite /tmp/testfile2" },
+	  "file::truncate", "file truncate /tmp/testfile2 "
+	  "task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_3, cleanup_test_file,
-	  "file::open", "allow_read /tmp/testfile3" },
+	  "file::open", "file read /tmp/testfile3 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_3, cleanup_test_file,
-	  "file::create", "allow_create /tmp/testfile3 0600"
-	},
+	  "file::create", "file create /tmp/testfile3 0600 "
+	  "task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_4, cleanup_test_file, "file::open",
-	  "allow_read /tmp/testfile4" },
+	  "file read /tmp/testfile4 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_5, cleanup_test_file, "file::open",
-	  "allow_read /tmp/testfile5" },
+	  "file read /tmp/testfile5 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_5, cleanup_test_file, "file::create",
-	  "allow_create /tmp/testfile5 0600" },
+	  "file create /tmp/testfile5 0600 task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_6, cleanup_test_file, "file::open",
-	  "allow_read /tmp/testfile6" },
+	  "file read /tmp/testfile6 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_6, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile6"
-	},
-	{ setup_test_file_truncate, test_file_open_6,
-	  cleanup_test_file_truncate, "file::rewrite",
-	  "allow_rewrite /tmp/testfile6" },
+	  "file::truncate", "file truncate /tmp/testfile6 "
+	  "task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_7, cleanup_test_file, "file::open",
-	  "allow_read /tmp/testfile7" },
+	  "file read /tmp/testfile7 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_7, cleanup_test_file, "file::create",
-	  "allow_create /tmp/testfile7 0600" },
+	  "file create /tmp/testfile7 0600 task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_8, cleanup_test_file, "file::open",
-	  "allow_write /tmp/testfile8" },
-	{ setup_test_file, test_file_open_8, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile8"
-	},
+	  "file write /tmp/testfile8 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_9, cleanup_test_file, "file::open",
-	  "allow_write /tmp/testfile9" },
+	  "file write /tmp/testfile9 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_9, cleanup_test_file, "file::create",
-	  "allow_create /tmp/testfile9 0600" },
-	{ setup_test_file, test_file_open_9, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile9"
-	},
+	  "file create /tmp/testfile9 0600 task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_10, cleanup_test_file, "file::open",
-	  "allow_write /tmp/testfile10" },
+	  "file write /tmp/testfile10 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_10, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile10"
-	},
-	{ setup_test_file, test_file_open_10, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile10"
-	},
+	  "file::truncate", "file truncate /tmp/testfile10 "
+	  "task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_11, cleanup_test_file, "file::open",
-	  "allow_write /tmp/testfile11" },
+	  "file write /tmp/testfile11 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_11, cleanup_test_file,
-	  "file::create", "allow_create /tmp/testfile11 0600"
-	},
-	{ setup_test_file, test_file_open_11, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile11"
-	},
+	  "file::create", "file create /tmp/testfile11 0600 "
+	  "task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_12, cleanup_test_file, "file::open",
-	  "allow_write /tmp/testfile12" },
+	  "file append /tmp/testfile12 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_13, cleanup_test_file, "file::open",
-	  "allow_write /tmp/testfile13" },
+	  "file append /tmp/testfile13 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_13, cleanup_test_file,
-	  "file::create", "allow_create /tmp/testfile13 0600"
-	},
+	  "file::create", "file create /tmp/testfile13 0600 "
+	  "task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_14, cleanup_test_file, "file::open",
-	  "allow_write /tmp/testfile14" },
+	  "file append /tmp/testfile14 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_14, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile14"
-	},
-	{ setup_test_file_truncate, test_file_open_14,
-	  cleanup_test_file_truncate, "file::rewrite",
-	  "allow_rewrite /tmp/testfile14" },
+	  "file::truncate", "file truncate /tmp/testfile14 "
+	  "task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_15, cleanup_test_file, "file::open",
-	  "allow_write /tmp/testfile15" },
+	  "file append /tmp/testfile15 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_15, cleanup_test_file,
-	  "file::create", "allow_create /tmp/testfile15 0600"
-	},
+	  "file::create", "file create /tmp/testfile15 0600 "
+	  "task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_16, cleanup_test_file, "file::open",
-	  "allow_read/write /tmp/testfile16" },
-	{ setup_test_file, test_file_open_16, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile16"
-	},
+	  "file read /tmp/testfile16 task.uid=path1.uid\t"
+	  "file write /tmp/testfile16 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_17, cleanup_test_file, "file::open",
-	  "allow_read/write /tmp/testfile17" },
+	  "file read /tmp/testfile17 task.uid=path1.uid\t"
+	  "file write /tmp/testfile17 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_17, cleanup_test_file,
-	  "file::create", "allow_create /tmp/testfile17 0600"
-	},
-	{ setup_test_file, test_file_open_17, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile17"
-	},
+	  "file::create", "file create /tmp/testfile17 0600 "
+	  "task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_18, cleanup_test_file, "file::open",
-	  "allow_read/write /tmp/testfile18" },
+	  "file read /tmp/testfile18 task.uid=path1.uid\t"
+	  "file write /tmp/testfile18 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_18, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile18"
-	},
-	{ setup_test_file, test_file_open_18, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile18"
-	},
+	  "file::truncate", "file truncate /tmp/testfile18 "
+	  "task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_19, cleanup_test_file, "file::open",
-	  "allow_read/write /tmp/testfile19" },
-	{ setup_test_file, test_file_open_19, cleanup_test_file,
-	  "file::create", "allow_create /tmp/testfile19 0600"
-	},
+	  "file read /tmp/testfile19 task.uid=path1.uid\t"
+	  "file write /tmp/testfile19 task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_19, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile19"
-	},
-	{ setup_test_file, test_file_open_20, cleanup_test_file, "file::open",
-	  "allow_read/write /tmp/testfile20" },
-	{ setup_test_file, test_file_open_21, cleanup_test_file, "file::open",
-	  "allow_read/write /tmp/testfile21" },
+	  "file::create", "file create /tmp/testfile19 0600 "
+	  "task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_21, cleanup_test_file,
-	  "file::create", "allow_create /tmp/testfile21 0600"
-	},
-	{ setup_test_file, test_file_open_22, cleanup_test_file, "file::open",
-	  "allow_read/write /tmp/testfile22" },
+	  "file::create", "file create /tmp/testfile21 0600 "
+	  "task.uid=path1.parent.uid" },
 	{ setup_test_file, test_file_open_22, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile22"
-	},
-	{ setup_test_file_truncate, test_file_open_22,
-	  cleanup_test_file_truncate, "file::rewrite",
-	  "allow_rewrite /tmp/testfile22" },
-	{ setup_test_file, test_file_open_23, cleanup_test_file, "file::open",
-	  "allow_read/write /tmp/testfile23" },
+	  "file::truncate", "file truncate /tmp/testfile22 "
+	  "task.uid=path1.uid" },
 	{ setup_test_file, test_file_open_23, cleanup_test_file,
-	  "file::create", "allow_create /tmp/testfile23 0600"
-	},
+	  "file::create", "file create /tmp/testfile23 0600 "
+	  "task.uid=path1.parent.uid" },
 	{ setup_all_test_file, test_file_open_0, cleanup_test_file,
-	  "file::open", "allow_read /tmp/testfile0" },
+	  "file::open", "file read /tmp/testfile0 task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_2, cleanup_test_file,
-	  "file::open", "allow_read /tmp/testfile2" },
+	  "file::open", "file read /tmp/testfile2 task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_2, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile2"
-	},
-	{ setup_all_test_file_truncate, test_file_open_2,
-	  cleanup_test_file_truncate, "file::rewrite",
-	  "allow_rewrite /tmp/testfile2" },
+	  "file::truncate", "file truncate /tmp/testfile2 "
+	  "task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_4, cleanup_test_file,
-	  "file::open", "allow_read /tmp/testfile4" },
+	  "file::open", "file read /tmp/testfile4 task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_6, cleanup_test_file,
-	  "file::open", "allow_read /tmp/testfile6" },
+	  "file::open", "file read /tmp/testfile6 task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_6, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile6"
-	},
-	{ setup_all_test_file_truncate, test_file_open_6,
-	  cleanup_test_file_truncate, "file::rewrite",
-	  "allow_rewrite /tmp/testfile6" },
+	  "file::truncate", "file truncate /tmp/testfile6 "
+	  "task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_8, cleanup_test_file,
-	  "file::open", "allow_write /tmp/testfile8" },
-	{ setup_all_test_file, test_file_open_8, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile8"
-	},
+	  "file::open", "file write /tmp/testfile8 task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_10, cleanup_test_file,
-	  "file::open", "allow_write /tmp/testfile10" },
-	{ setup_all_test_file, test_file_open_10, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile10"
-	},
+	  "file::open", "file write /tmp/testfile10 task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_10, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile10"
-	},
+	  "file::truncate", "file truncate /tmp/testfile10 "
+	  "task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_12, cleanup_test_file,
-	  "file::open", "allow_write /tmp/testfile12" },
+	  "file::open", "file append /tmp/testfile12 task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_14, cleanup_test_file,
-	  "file::open", "allow_write /tmp/testfile14" },
+	  "file::open", "file append /tmp/testfile14 task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_14, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile14"
-	},
-	{ setup_all_test_file_truncate, test_file_open_14,
-	  cleanup_test_file_truncate, "file::rewrite",
-	  "allow_rewrite /tmp/testfile14" },
-	{ setup_all_test_file, test_file_open_16, cleanup_test_file,
-	  "file::open", "allow_read/write /tmp/testfile16"
-	},
+	  "file::truncate", "file truncate /tmp/testfile14 "
+	  "task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_16, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile16"
-	},
+	  "file::open", "file read /tmp/testfile16 task.uid=path1.gid\t"
+	  "file write /tmp/testfile16 task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_18, cleanup_test_file,
-	  "file::open", "allow_read/write /tmp/testfile18"
-	},
+	  "file::open", "file read /tmp/testfile18 task.uid=path1.gid\t"
+	  "file write /tmp/testfile18 task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_18, cleanup_test_file,
-	  "file::truncate", "allow_truncate /tmp/testfile18"
-	},
-	{ setup_all_test_file, test_file_open_18, cleanup_test_file,
-	  "file::rewrite", "allow_rewrite /tmp/testfile18"
-	},
-	{ setup_all_test_file, test_file_open_20, cleanup_test_file,
-	  "file::open",
-	  "allow_read/write /tmp/testfile20" },
-	{ setup_all_test_file, test_file_open_22, cleanup_test_file,
-	  "file::open",
-	  "allow_read/write /tmp/testfile22" },
+	  "file::truncate", "file truncate /tmp/testfile18 "
+	  "task.uid=path1.gid" },
 	{ setup_all_test_file, test_file_open_22, cleanup_test_file,
 	  "file::truncate",
-	  "allow_truncate /tmp/testfile22" },
-	{ setup_all_test_file_truncate, test_file_open_22,
-	  cleanup_test_file_truncate, "file::rewrite",
-	  "allow_rewrite /tmp/testfile22" },
+	  "file truncate /tmp/testfile22 task.uid=path1.gid" },
 	{ NULL }
 };
 
 int main(int argc, char *argv[])
 {
 	int i;
-	tomoyo_test_init();
+	ccs_test_init();
 	for (i = 0; tests[i].do_test; i++) {
 		int trial;
 		for (trial = 0; trial < 2; trial++) {
diff --git a/testcases/kernel/security/tomoyo/tomoyo_policy_io_test.c b/testcases/kernel/security/tomoyo/tomoyo_policy_io_test.c
index d374a82..40e5845 100644
--- a/testcases/kernel/security/tomoyo/tomoyo_policy_io_test.c
+++ b/testcases/kernel/security/tomoyo/tomoyo_policy_io_test.c
@@ -1,25 +1,22 @@
-/******************************************************************************/
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    */
-/*                                                                            */
-/******************************************************************************/
 /*
- * tomoyo_policy_io_test.c
+ * ccs_policy_io_test.c
  *
- * Testing program for security/tomoyo/
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Copyright (C) 2005-2010  NTT DATA CORPORATION
+ * Version: 2.4.0   2011/08/06
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 #include "include.h"
 
@@ -42,6 +39,9 @@ static void try_io(const char *policy, const char should_success)
 		char *cp = strchr(buffer, '\n');
 		if (cp)
 			*cp = '\0';
+		if (!strcmp(policy_file, proc_policy_exception_policy) &&
+		    !strncmp(buffer, "<kernel> ", 9))
+			memmove(buffer, buffer + 9, strlen(buffer + 9) + 1);
 		if (!strcmp(buffer, policy)) {
 			policy_found = 1;
 			break;
@@ -68,62 +68,66 @@ static void stage_policy_io_test(void)
 	policy_file = proc_policy_domain_policy;
 	policy_fp = domain_fp;
 	for (i = 0; i < 3; i++) {
-		try_io("allow_chroot /", 1);
-		try_io("allow_chroot ", 0);
-		try_io("allow_chroot /mnt0/", 1);
-		try_io("allow_chroot /var1/chroot2/", 1);
-		try_io("allow_chroot /mnt0/", 1);
-		try_io("allow_chroot /mnt0/", 1);
-		try_io("allow_chroot /mnt0/", 1);
-		try_io("allow_chroot /mnt\\?\\*/", 1);
-		try_io("allow_chroot /mnt\\?\\*/", 1);
-		try_io("allow_unmount /", 1);
-		try_io("allow_unmount /sys1/", 1);
-		try_io("allow_unmount /initrd2/", 1);
-		try_io("allow_unmount /initrd/dev3/", 1);
-		try_io("allow_unmount /initrd/\\*\\+/", 1);
-		try_io("allow_unmount /initrd/\\@\\*/", 1);
-		try_io("allow_unmount /initrd2/", 1);
-		try_io("allow_pivot_root / /proc3/", 1);
-		try_io("allow_pivot_root /sys5/ /proc3/", 1);
-		try_io("allow_pivot_root /sys/", 0);
-		try_io("allow_pivot_root *", 0);
-		try_io("allow_pivot_root /sys5/ /proc3/", 1);
-		try_io("allow_mount / / --bind 0xD", 1);
-		try_io("allow_mount / / --move 0xF", 1);
-		try_io("allow_mount / --remount", 0);
-		try_io("allow_mount /", 0);
-		try_io("allow_mount none /tmp/ tmpfs 0x1", 1);
-		try_io("allow_mount none /tmp/ tmpfs", 0);
-		try_io("allow_mount none /tmp/ nonexistent 0x0", 1);
-		try_io("allow_mount none /proc/ proc 0x0", 1);
-		try_io("allow_mount none /selinux/ selinuxfs 0x0", 1);
-		try_io("allow_mount /proc/bus/usb /proc/bus/usb/ usbfs 0x0", 1);
-		try_io("allow_mount none /dev/pts/ devpts 0x0", 1);
-		try_io("allow_mount any / --remount 0xC00", 1);
-		try_io("allow_mount /dev/sda1 /boot/ ext3 0xC00", 1);
-		try_io("allow_mount none /dev/shm/ tmpfs 0x0", 1);
-		try_io("allow_mount none /proc/sys/fs/binfmt_misc/ binfmt_misc "
+		try_io("file chroot /", 1);
+		try_io("file chroot ", 0);
+		try_io("file chroot /mnt0/", 1);
+		try_io("file chroot /var1/chroot2/", 1);
+		try_io("file chroot /mnt0/", 1);
+		try_io("file chroot /mnt0/", 1);
+		try_io("file chroot /mnt0/", 1);
+		try_io("file chroot /mnt\\?\\*/", 1);
+		try_io("file chroot /mnt\\?\\*/", 1);
+		try_io("file unmount /", 1);
+		try_io("file unmount /sys1/", 1);
+		try_io("file unmount /initrd2/", 1);
+		try_io("file unmount /initrd/dev3/", 1);
+		try_io("file unmount /initrd/\\*\\+/", 1);
+		try_io("file unmount /initrd/\\@\\*/", 1);
+		try_io("file unmount /initrd2/", 1);
+		try_io("file pivot_root / /proc3/", 1);
+		try_io("file pivot_root /sys5/ /proc3/", 1);
+		try_io("file pivot_root /sys/", 0);
+		try_io("file pivot_root *", 0);
+		try_io("file pivot_root /sys5/ /proc3/", 1);
+		try_io("file mount / / --bind 0xD", 1);
+		try_io("file mount / / --move 0xF", 1);
+		try_io("file mount / --remount", 0);
+		try_io("file mount /", 0);
+		try_io("file mount none /tmp/ tmpfs 0x1", 1);
+		try_io("file mount none /tmp/ tmpfs", 0);
+		try_io("file mount none /tmp/ nonexistent 0x0", 1);
+		try_io("file mount none /proc/ proc 0x0", 1);
+		try_io("file mount none /selinux/ selinuxfs 0x0", 1);
+		try_io("file mount /proc/bus/usb proc:/bus/usb/ usbfs 0x0", 1);
+		try_io("file mount none /dev/pts/ devpts 0x0", 1);
+		try_io("file mount any / --remount 0xC00", 1);
+		try_io("file mount /dev/sda1 /boot/ ext3 0xC00", 1);
+		try_io("file mount none /dev/shm/ tmpfs 0x0", 1);
+		try_io("file mount none proc:/sys/fs/binfmt_misc/ binfmt_misc "
 		       "0x0", 1);
-		try_io("allow_mount none /proc/sys/fs/binfmt_misc/ binfmt_misc "
+		try_io("file mount none proc:/sys/fs/binfmt_misc/ binfmt_misc "
 		       "0x0 0x1", 0);
-		try_io("allow_mount none /proc/sys/fs/binfmt_misc/ tmpfs "
+		try_io("file mount none proc:/sys/fs/binfmt_misc/ tmpfs "
 		       "binfmt_misc 0x0", 0);
-		try_io("allow_mount /proc/bus/usb /proc/bus/usb/ usbfs 0x0", 1);
+		try_io("file mount /proc/bus/usb proc:/bus/usb/ usbfs 0x0", 1);
 	}
 	policy_file = proc_policy_exception_policy;
 	policy_fp = exception_fp;
 	for (i = 0; i < 3; i++) {
-		try_io("allow_read /tmp/abc", 1);
-		try_io("allow_read /tmp/abc\\*", 1);
-		try_io("allow_read abc", 1);
-		try_io("allow_read /tmp/abc/", 1);
-		try_io("allow_read", 0);
-		try_io("allow_read *", 1);
-		try_io("file_pattern /\\*\\*\\*", 1);
-		try_io("file_pattern /abc", 1);
-		try_io("file_pattern /abc /def", 0);
-		try_io("file_pattern abcdef", 1);
+		try_io("acl_group 0 file read /tmp/abc", 1);
+		try_io("acl_group 0 file read /tmp/abc\\*", 1);
+		try_io("acl_group 0 file read abc", 1);
+		try_io("acl_group 0 file read /tmp/abc/", 1);
+		try_io("acl_group 0 file read", 0);
+		try_io("acl_group 0 file read *", 1);
+		/*
+		try_io("acl_group 0 misc env FOO", 1);
+		try_io("acl_group 0 misc env FOO=", 0);
+		try_io("acl_group 0 misc env FOO=BAR", 0);
+		try_io("acl_group 0 misc env FOO BAR", 0);
+		try_io("acl_group 0 misc env FOO\\040BAR", 1);
+		try_io("acl_group 0 misc env FOO;BAR;BUZ", 1);
+		*/
 		try_io("path_group TEST /", 1);
 		try_io("path_group TEST /boo", 1);
 		try_io("path_group TEST /bar", 1);
@@ -140,46 +144,54 @@ static void stage_policy_io_test(void)
 		try_io("path_group TEST3 /bar", 1);
 		try_io("path_group TEST3 boo", 1);
 		try_io("path_group TEST3 boo/", 1);
-		try_io("deny_rewrite /", 1);
-		try_io("deny_rewrite /foo", 1);
-		try_io("deny_rewrite /\\*", 1);
-		try_io("deny_rewrite /\\:", 0);
-		try_io("deny_rewrite / /", 0);
-		try_io("deny_rewrite @/TEST", 1);
+		/*
+		try_io("address_group TEST 0.0.0.0", 1);
+		try_io("address_group TEST 0.0.0.0-1.2.3.4", 1);
+		try_io("address_group TEST ::ff", 1);
+		try_io("address_group TEST ::-ff:ff:ff:ff:ff:ff:ff:ff", 1);
+		try_io("address_group TEST "
+		       "fff0:fff1:fff2:fff3:fff4:fff5:fff6:fff7-"
+		       "fff8:fff9:fffa:fffb:fffc:fffd:fffe:ffff", 1);
+		try_io("address_group TEST2 ::ff", 1);
+		try_io("address_group TEST2 ::-ff:ff:ff:ff:ff:ff:ff:ff", 1);
+		try_io("address_group TEST2 "
+		       "fff0:fff1:fff2:fff3:fff4:fff5:fff6:fff7-"
+		       "fff8:fff9:fffa:fffb:fffc:fffd:fffe:ffff", 1);
+		*/
 		try_io("aggregator /boo/\\* /BOO", 1);
 		try_io("aggregator /boo/\\* /BOO\\*", 0);
 		try_io("aggregator /boo/\\*/ /BOO", 1);
 		try_io("aggregator /boo/\\* /BOO/", 1);
-		try_io("keep_domain <kernel>", 1);
-		try_io("keep_domain <kernel> /sbin/init", 1);
-		try_io("keep_domain <kernel> foo", 0);
-		try_io("keep_domain <kernel> \\*", 0);
-		try_io("keep_domain /ssh", 1);
-		try_io("keep_domain /ssh /foo", 0);
+		try_io("keep_domain any from <kernel>", 1);
+		try_io("keep_domain any from <kernel> /sbin/init", 1);
+		try_io("keep_domain any from <kernel> foo", 0);
+		try_io("keep_domain any from <kernel> \\*", 0);
+		try_io("keep_domain any from /ssh", 1);
+		try_io("keep_domain any from /ssh /foo", 0);
 		try_io("keep_domain /foo from <kernel>", 1);
 		try_io("keep_domain /foo from <kernel> /sbin/init", 1);
 		try_io("keep_domain from <kernel> /sbin/init", 0);
 		try_io("keep_domain \\* from <kernel> /sbin/init", 0);
-		try_io("no_keep_domain <kernel>", 1);
-		try_io("no_keep_domain <kernel> /sbin/init", 1);
-		try_io("no_keep_domain <kernel> foo", 0);
-		try_io("no_keep_domain <kernel> \\*", 0);
-		try_io("no_keep_domain /ssh", 1);
-		try_io("no_keep_domain /ssh /foo", 0);
+		try_io("no_keep_domain any from <kernel>", 1);
+		try_io("no_keep_domain any from <kernel> /sbin/init", 1);
+		try_io("no_keep_domain any from <kernel> foo", 0);
+		try_io("no_keep_domain any from <kernel> \\*", 0);
+		try_io("no_keep_domain any from /ssh", 1);
+		try_io("no_keep_domain any from /ssh /foo", 0);
 		try_io("no_keep_domain /foo from <kernel>", 1);
 		try_io("no_keep_domain /foo from <kernel> /sbin/init", 1);
 		try_io("no_keep_domain from <kernel> /sbin/init", 0);
 		try_io("no_keep_domain \\* from <kernel> /sbin/init", 0);
-		try_io("initialize_domain /foo", 1);
-		try_io("initialize_domain /\\*", 1);
-		try_io("initialize_domain /foo /bar", 0);
+		try_io("initialize_domain /foo from any", 1);
+		try_io("initialize_domain /\\* from any", 1);
+		try_io("initialize_domain /foo /bar from any", 0);
 		try_io("initialize_domain /foo from /bar", 1);
 		try_io("initialize_domain /foo from <kernel> /bar", 1);
 		try_io("initialize_domain /\\* from <kernel>", 1);
 		try_io("initialize_domain /foo from <kernel> \\*", 0);
-		try_io("no_initialize_domain /foo", 1);
-		try_io("no_initialize_domain /\\*", 1);
-		try_io("no_initialize_domain /foo /bar", 0);
+		try_io("no_initialize_domain /foo from any", 1);
+		try_io("no_initialize_domain /\\* from any", 1);
+		try_io("no_initialize_domain /foo /bar from any", 0);
 		try_io("no_initialize_domain /foo from /bar", 1);
 		try_io("no_initialize_domain /foo from <kernel> /bar", 1);
 		try_io("no_initialize_domain /\\* from <kernel>", 1);
@@ -189,7 +201,12 @@ static void stage_policy_io_test(void)
 
 int main(int argc, char *argv[])
 {
-	tomoyo_test_init();
+	ccs_test_init();
 	stage_policy_io_test();
+	if (0) { /* To suppress "defined but not used" warnings. */
+		write_domain_policy("", 0);
+		write_exception_policy("", 0);
+		set_profile(0, "");
+	}
 	return 0;
-}
\ No newline at end of file
+}
diff --git a/testcases/kernel/security/tomoyo/tomoyo_policy_memory_test.c b/testcases/kernel/security/tomoyo/tomoyo_policy_memory_test.c
index e92540f..0be6947 100644
--- a/testcases/kernel/security/tomoyo/tomoyo_policy_memory_test.c
+++ b/testcases/kernel/security/tomoyo/tomoyo_policy_memory_test.c
@@ -1,28 +1,24 @@
-/******************************************************************************/
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    */
-/*                                                                            */
-/******************************************************************************/
 /*
- * tomoyo_policy_memory_test.c
+ * ccs_policy_memory_test.c
  *
- * Testing program for security/tomoyo/
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
+ *
+ * Version: 2.4.0   2011/08/06
  *
- * Copyright (C) 2005-2010  NTT DATA CORPORATION
- */
-/*
  * Usage: Run this program using init= boot option.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 #include <stdio.h>
 #include <stdlib.h>
@@ -41,11 +37,21 @@ static void BUG(const char *msg)
 static const char *policy_file = NULL;
 static const char *policy = NULL;
 
+static _Bool ignore_ns = 0;
+
 static void get_meminfo(unsigned int *policy_memory)
 {
-	FILE *fp = fopen("/sys/kernel/security/tomoyo/meminfo", "r");
-	if (!fp || fscanf(fp, "Policy: %u", policy_memory) != 1 || fclose(fp))
-		BUG("BUG: Policy read error\n");
+	static char buf[1024];
+	FILE *fp = fopen("/sys/kernel/security/tomoyo/stat", "r+");
+	while (memset(buf, 0, sizeof(buf)),
+	       fp && fgets(buf, sizeof(buf) - 1, fp)) {
+		if (sscanf(buf,
+			   "Memory used by policy: %u", policy_memory) != 1)
+			continue;
+		fclose(fp);
+		return;
+	}
+	BUG("BUG: Policy read error\n");
 }
 
 static void check_policy_common(const int found_expected, const int id)
@@ -60,6 +66,8 @@ static void check_policy_common(const int found_expected, const int id)
 		char *cp = strchr(buffer, '\n');
 		if (cp)
 			*cp = '\0';
+		if (ignore_ns && !strncmp(buffer, "<kernel> ", 9))
+			memmove(buffer, buffer + 9, strlen(buffer + 9) + 1);
 		if (strcmp(buffer, policy))
 			continue;
 		policy_found = 1;
@@ -85,95 +93,107 @@ static inline void check_policy_deleted(FILE *fp, const int id)
 	check_policy_common(0, id);
 }
 
-static const char *domain_testcases[] = {
-	"allow_create /tmp/mknod_reg_test 0600",
-	"allow_create /tmp/open_test 0600",
-	"allow_create /tmp/open_test 0600",
-	"allow_create /tmp/open_test 0600",
-	"allow_execute /bin/true",
-	"allow_execute /bin/true",
-	"allow_execute /bin/true0",
-	"allow_execute /bin/true1",
-	"allow_execute /bin/true2",
-	"allow_execute /bin/true3",
-	"allow_execute /bin/true4",
-	"allow_execute /bin/true5",
-	"allow_execute /bin/true6",
-	"allow_execute /bin/true7",
-	"allow_execute /bin/true7",
-	"allow_execute /bin/true7",
-	"allow_execute /bin/true8",
-	"allow_ioctl socket:[family=2:type=2:protocol=17] 0-35122",
-	"allow_ioctl socket:[family=2:type=2:protocol=17] 35122-35124",
-	"allow_link /tmp/link_source_test /tmp/link_dest_test",
-	"allow_mkblock /tmp/mknod_blk_test 0600 1 0",
-	"allow_mkchar /tmp/mknod_chr_test 0600 1 3",
-	"allow_mkdir /tmp/mkdir_test/ 0755",
-	"allow_mkfifo /tmp/mknod_fifo_test 0600",
-	"allow_mkfifo /tmp/mknod_fifo_test 0600",
-	"allow_mksock /tmp/mknod_sock_test 0600",
-	"allow_mksock /tmp/socket_test 0600",
-	"allow_read /bin/true",
-	"allow_read /bin/true",
-	"allow_read /dev/null",
-	"allow_read /dev/null",
-	"allow_read /dev/null",
-	"allow_read /dev/null",
-	"allow_read /dev/null",
-	"allow_read /dev/null",
-	"allow_read /foo",
-	"allow_read /proc/sys/net/ipv4/ip_local_port_range",
-	"allow_read /proc/sys/net/ipv4/ip_local_port_range",
-	"allow_read/write /bar",
-	"allow_read/write /dev/null",
-	"allow_read/write /dev/null",
-	"allow_read/write /proc/sys/net/ipv4/ip_local_port_range",
-	"allow_read/write /proc/sys/net/ipv4/ip_local_port_range",
-	"allow_read/write /tmp/fifo",
-	"allow_read/write /tmp/fifo",
-	"allow_read/write /tmp/rewrite_test",
-	"allow_rename /tmp/rename_source_test /tmp/rename_dest_test",
-	"allow_rmdir /tmp/rmdir_test/",
-	"allow_symlink /symlink",
-	"allow_symlink /symlink",
-	"allow_symlink /symlink",
-	"allow_symlink /symlink",
-	"allow_symlink /tmp/symlink_source_test",
-	"allow_symlink /tmp/symlink_source_test",
-	"allow_symlink /tmp/symlink_source_test",
-	"allow_symlink /tmp/symlink_source_test",
-	"allow_symlink /tmp/symlink_source_test",
-	"allow_truncate /tmp/rewrite_test",
-	"allow_truncate /tmp/truncate_test",
-	"allow_truncate /tmp/truncate_test",
-	"allow_unlink /tmp/unlink_test",
-	"allow_write /123",
-	"allow_write /dev/null",
-	"allow_write /dev/null",
-	"allow_write /devfile",
-	"allow_write /devfile",
-	"allow_write /proc/sys/net/ipv4/ip_local_port_range",
-	"allow_write /proc/sys/net/ipv4/ip_local_port_range",
-	"allow_write /tmp/open_test",
-	"allow_write /tmp/open_test",
-	"allow_write /tmp/open_test",
-	"allow_write /tmp/truncate_test",
-	"allow_write /tmp/truncate_test",
-	"allow_rewrite /tmp/rewrite_test",
-	"allow_rewrite /tmp/rewrite_test",
-	"allow_mount /dev/sda1 /mnt/sda1/ ext3 0x123",
-	"allow_mount /dev/sda1 /mnt/sda1/ ext3 123",
-	"allow_mount /dev/sda1 /mnt/sda1/ ext3 0123",
-	"allow_mount /dev/sda1 /mnt/sda1/ ext3 0x123",
-	"allow_mount /dev/sda1 /mnt/sda1/ ext3 123",
-	"allow_mount /dev/sda1 /mnt/sda1/ ext3 0123",
-	"allow_chroot /",
-	"allow_chroot /",
-	"allow_chroot /mnt/",
-	"allow_pivot_root / /proc/",
-	"allow_pivot_root /mnt/ /proc/mnt/",
-	"allow_unmount /",
-	"allow_unmount /proc/",
+static const char * const domain_testcases[] = {
+	"file create /tmp/mknod_reg_test 0600",
+	"file create /tmp/open_test 0600 path1.parent.uid=task.uid",
+	"file create /tmp/open_test 0600 0=0",
+	"file create /tmp/open_test 0600",
+	"file execute /bin/true task.uid!=10 path1.parent.uid=0",
+	"file execute /bin/true",
+	"file execute /bin/true0 task.uid=0",
+	"file execute /bin/true1 task.uid=task.gid",
+	"file execute /bin/true2 0=0",
+	"file execute /bin/true3 0!=0",
+	"file execute /bin/true4 123-456=789",
+	"file execute /bin/true5 exec.realpath=\"/bin/true5\"",
+	"file execute /bin/true6 exec.argv[0]=\"true6\"",
+	"file execute /bin/true7 1-2=@bar",
+	"file execute /bin/true7 exec.realpath!=@foo",
+	"file execute /bin/true7 exec.realpath=@foo",
+	"file execute /bin/true8 "
+	"exec.argv[0]=\"test8\" exec.realpath=\"/bin/true8\"",
+	"file ioctl socket:[family=2:type=2:protocol=17] 0-35122",
+	"file ioctl socket:[family=2:type=2:protocol=17] 35122-35124 "
+	"task.uid=0",
+	"file link /tmp/link_source_test /tmp/link_dest_test",
+	"file mkblock /tmp/mknod_blk_test 0600 1 0",
+	"file mkchar /tmp/mknod_chr_test 0600 1 3",
+	"file mkdir /tmp/mkdir_test/ 0755",
+	"file mkfifo /tmp/mknod_fifo_test 0600 path1.parent.perm=01777 "
+	"path1.parent.perm=sticky path1.parent.uid=0 path1.parent.gid=0",
+	"file mkfifo /tmp/mknod_fifo_test 0600",
+	"file mksock /tmp/mknod_sock_test 0600",
+	"file mksock /tmp/socket_test 0600",
+	"file read /bin/true path1.uid=0 path1.parent.uid=0 10=10-100",
+	"file read /bin/true",
+	"file read /dev/null path1.parent.ino=path1.parent.ino",
+	"file read /dev/null path1.perm!=0777",
+	"file read /dev/null path1.perm=0666",
+	"file read /dev/null path1.perm=owner_read path1.perm=owner_write "
+	"path1.perm!=owner_execute path1.perm=group_read "
+	"path1.perm=group_write path1.perm!=group_execute "
+	"path1.perm=others_read path1.perm=others_write "
+	"path1.perm!=others_execute path1.perm!=setuid path1.perm!=setgid "
+	"path1.perm!=sticky",
+	"file read /dev/null "
+	"path1.type=char path1.dev_major=1 path1.dev_minor=3",
+	"file read /dev/null",
+	"file read /foo",
+	"file read proc:/sys/net/ipv4/ip_local_port_range "
+	"task.uid=0 task.gid=0",
+	"file read proc:/sys/net/ipv4/ip_local_port_range",
+	"file append /bar",
+	"file append /dev/null task.uid=path1.parent.uid",
+	"file append /dev/null",
+	"file read proc:/sys/net/ipv4/ip_local_port_range 1!=10-100",
+	"file read proc:/sys/net/ipv4/ip_local_port_range",
+	"file append /tmp/fifo path1.type=fifo",
+	"file append /tmp/fifo",
+	"file append /tmp/rewrite_test",
+	"file rename /tmp/rename_source_test /tmp/rename_dest_test",
+	"file rmdir /tmp/rmdir_test/",
+	"file symlink /symlink symlink.target!=@target",
+	"file symlink /symlink symlink.target!=\"target\"",
+	"file symlink /symlink symlink.target=@symlink_target",
+	"file symlink /symlink symlink.target=\"target\"",
+	"file symlink /tmp/symlink_source_test "
+	"symlink.target!=\"/tmp/symlink_\\*_test\"",
+	"file symlink /tmp/symlink_source_test symlink.target!=\"\\*\"",
+	"file symlink /tmp/symlink_source_test "
+	"symlink.target=\"/tmp/symlink_\\*_test\"",
+	"file symlink /tmp/symlink_source_test "
+	"task.uid=0 symlink.target=\"/tmp/symlink_\\*_test\"",
+	"file symlink /tmp/symlink_source_test",
+	"file truncate /tmp/rewrite_test",
+	"file truncate /tmp/truncate_test task.uid=path1.uid",
+	"file truncate /tmp/truncate_test",
+	"file unlink /tmp/unlink_test",
+	"file write /123",
+	"file write /dev/null path1.uid=path1.gid",
+	"file write /dev/null",
+	"file write /devfile path1.major=1024 path1.minor=1048576",
+	"file write /devfile",
+	"file write proc:/sys/net/ipv4/ip_local_port_range "
+	"task.euid=0 0=0 1-100=10-1000",
+	"file write proc:/sys/net/ipv4/ip_local_port_range",
+	"file write /tmp/open_test path1.parent.uid=0",
+	"file write /tmp/open_test task.uid=0 path1.ino!=0",
+	"file write /tmp/open_test",
+	"file write /tmp/truncate_test 1!=100-1000000",
+	"file write /tmp/truncate_test",
+	"file mount /dev/sda1 /mnt/sda1/ ext3 0x123",
+	"file mount /dev/sda1 /mnt/sda1/ ext3 123",
+	"file mount /dev/sda1 /mnt/sda1/ ext3 0123",
+	"file mount /dev/sda1 /mnt/sda1/ ext3 0x123 path1.uid=path2.uid",
+	"file mount /dev/sda1 /mnt/sda1/ ext3 123 path1.uid=task.uid",
+	"file mount /dev/sda1 /mnt/sda1/ ext3 0123 path1.uid=@uid",
+	"file chroot /",
+	"file chroot / task.uid=123-456",
+	"file chroot /mnt/ task.uid=123-456 path1.gid=0",
+	"file pivot_root / /proc/ path1.uid!=0",
+	"file pivot_root /mnt/ /proc/mnt/ path1.uid!=0 path2.gid=150",
+	"file unmount / path1.uid!=0",
+	"file unmount /proc/ path1.uid!=0",
 	NULL
 };
 
@@ -203,7 +223,7 @@ static void domain_policy_test(const unsigned int before)
 		fprintf(fp, "delete %s\n", policy);
 		check_policy_deleted(fp, 2);
 		fclose(fp);
-		for (i = 0; i < 30; i++) {
+		for (i = 0; i < 300; i++) {
 			usleep(100000);
 			get_meminfo(&after);
 			if (before == after)
@@ -214,6 +234,7 @@ static void domain_policy_test(const unsigned int before)
 			BUG("Policy read/write test: Fail\n");
 		}
 	}
+	printf("Processing all.\n");
 	for (j = 0; j < 10; j++) {
 		int i;
 		FILE *fp = fopen(policy_file, "w");
@@ -224,7 +245,7 @@ static void domain_policy_test(const unsigned int before)
 			fprintf(fp, "%s\n", domain_testcases[i]);
 		fprintf(fp, "delete <kernel> /sbin/init\n");
 		fclose(fp);
-		for (i = 0; i < 50; i++) {
+		for (i = 0; i < 500; i++) {
 			usleep(100000);
 			get_meminfo(&after);
 			if (before == after)
@@ -237,51 +258,44 @@ static void domain_policy_test(const unsigned int before)
 	}
 }
 
-static const char *exception_testcases[] = {
-	"allow_read /tmp/mknod_reg_test",
-	"allow_env HOME",
+static const char * const exception_testcases[] = {
+	"acl_group 0 file read /tmp/mknod_reg_test",
+	/*
+	"acl_group 0 misc env HOME",
+	*/
 	"path_group PG1 /",
 	"path_group PG2 /",
+	/*
 	"address_group AG3 0.0.0.0",
 	"address_group AG3 1.2.3.4-5.6.7.8",
 	"address_group AG3 f:ee:ddd:cccc:b:aa:999:8888",
 	"address_group AG4 0:1:2:3:4:5:6:7-8:90:a00:b000:c00:d0:e:f000",
+	*/
 	"number_group NG1 1000",
 	"number_group NG2 10-0x100000",
 	"number_group NG3 01234567-0xABCDEF89",
-	"deny_autobind 1024",
-	"deny_autobind 32668-65535",
-	"deny_autobind 0-1023",
-	"initialize_domain /usr/sbin/sshd",
-	"no_initialize_domain /usr/sbin/sshd",
+	"initialize_domain /usr/sbin/sshd from any",
+	"no_initialize_domain /usr/sbin/sshd from any",
 	"initialize_domain /usr/sbin/sshd from /bin/bash",
 	"no_initialize_domain /usr/sbin/sshd from /bin/bash",
 	"initialize_domain /usr/sbin/sshd from "
 	"<kernel> /bin/mingetty/bin/bash",
 	"no_initialize_domain /usr/sbin/sshd from "
 	"<kernel> /bin/mingetty/bin/bash",
-	"keep_domain <kernel> /usr/sbin/sshd /bin/bash",
-	"no_keep_domain <kernel> /usr/sbin/sshd /bin/bash",
+	"keep_domain any from <kernel> /usr/sbin/sshd /bin/bash",
+	"no_keep_domain any from <kernel> /usr/sbin/sshd /bin/bash",
 	"keep_domain /bin/pwd from <kernel> /usr/sbin/sshd /bin/bash",
 	"no_keep_domain /bin/pwd from <kernel> /usr/sbin/sshd /bin/bash",
 	"keep_domain /bin/pwd from /bin/bash",
 	"no_keep_domain /bin/pwd from /bin/bash",
-	"file_pattern /proc/\\$/task/\\$/environ",
-	"file_pattern /proc/\\$/task/\\$/auxv",
-	"allow_read /etc/ld.so.cache",
-	"allow_read /proc/meminfo",
-	"allow_read /proc/sys/kernel/version",
-	"allow_read /etc/localtime",
-	"allow_read /proc/self/task/\\$/attr/current",
-	"allow_read /proc/self/task/\\$/oom_score",
-	"allow_read /proc/self/wchan",
-	"allow_read /lib/ld-2.5.so",
-	"file_pattern pipe:[\\$]",
-	"file_pattern socket:[\\$]",
-	"file_pattern /var/cache/logwatch/logwatch.\\*/",
-	"file_pattern /var/cache/logwatch/logwatch.\\*/\\*",
-	"deny_rewrite /var/log/\\*",
-	"deny_rewrite /var/log/\\*/\\*",
+	"acl_group 0 file read /etc/ld.so.cache",
+	"acl_group 0 file read proc:/meminfo",
+	"acl_group 0 file read proc:/sys/kernel/version",
+	"acl_group 0 file read /etc/localtime",
+	"acl_group 0 file read proc:/self/task/\\$/attr/current",
+	"acl_group 0 file read proc:/self/task/\\$/oom_score",
+	"acl_group 0 file read proc:/self/wchan",
+	"acl_group 0 file read /lib/ld-2.5.so",
 	"aggregator /etc/rc.d/rc\\?.d/\\?\\+\\+smb /etc/rc.d/init.d/smb",
 	"aggregator /etc/rc.d/rc\\?.d/\\?\\+\\+crond /etc/rc.d/init.d/crond",
 	NULL
@@ -291,6 +305,7 @@ static void exception_policy_test(const unsigned int before)
 {
 	unsigned int after;
 	int j;
+	ignore_ns = 1;
 	policy_file = "/sys/kernel/security/tomoyo/exception_policy";
 	for (j = 0; exception_testcases[j]; j++) {
 		int i;
@@ -312,7 +327,7 @@ static void exception_policy_test(const unsigned int before)
 		fprintf(fp, "delete %s\n", policy);
 		check_policy_deleted(fp, 2);
 		fclose(fp);
-		for (i = 0; i < 30; i++) {
+		for (i = 0; i < 300; i++) {
 			usleep(100000);
 			get_meminfo(&after);
 			if (before == after)
@@ -323,6 +338,7 @@ static void exception_policy_test(const unsigned int before)
 			BUG("Policy read/write test: Fail\n");
 		}
 	}
+	printf("Processing all.\n");
 	for (j = 0; j < 10; j++) {
 		int i;
 		FILE *fp = fopen(policy_file, "w");
@@ -333,7 +349,7 @@ static void exception_policy_test(const unsigned int before)
 		for (i = 0; exception_testcases[i]; i++)
 			fprintf(fp, "delete %s\n", exception_testcases[i]);
 		fclose(fp);
-		for (i = 0; i < 50; i++) {
+		for (i = 0; i < 500; i++) {
 			usleep(100000);
 			get_meminfo(&after);
 			if (before == after)
@@ -350,9 +366,11 @@ int main(int argc, char *argv[])
 {
 	unsigned int before;
 	mount("/proc", "/proc/", "proc", 0, NULL);
+	printf("Waiting for stabilized.\n");
 	get_meminfo(&before);
+	sleep(3);
 	domain_policy_test(before);
 	exception_policy_test(before);
 	BUG("Policy read/write test: Success\n");
 	return 0;
-}
\ No newline at end of file
+}
diff --git a/testcases/kernel/security/tomoyo/tomoyo_rewrite_test.c b/testcases/kernel/security/tomoyo/tomoyo_rewrite_test.c
index bd9b904..9611fc8 100644
--- a/testcases/kernel/security/tomoyo/tomoyo_rewrite_test.c
+++ b/testcases/kernel/security/tomoyo/tomoyo_rewrite_test.c
@@ -1,25 +1,22 @@
-/******************************************************************************/
-/* This program is free software;  you can redistribute it and/or modify      */
-/* it under the terms of the GNU General Public License as published by       */
-/* the Free Software Foundation; either version 2 of the License, or          */
-/* (at your option) any later version.                                        */
-/*                                                                            */
-/* This program is distributed in the hope that it will be useful,            */
-/* but WITHOUT ANY WARRANTY;  without even the implied warranty of            */
-/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See                  */
-/* the GNU General Public License for more details.                           */
-/*                                                                            */
-/* You should have received a copy of the GNU General Public License          */
-/* along with this program;  if not, write to the Free Software               */
-/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA    */
-/*                                                                            */
-/******************************************************************************/
 /*
- * tomoyo_rewrite_test.c
+ * ccs_rewrite_test.c
  *
- * Testing program for security/tomoyo/
+ * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Copyright (C) 2005-2010  NTT DATA CORPORATION
+ * Version: 2.4.0   2011/08/06
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
  */
 #include "include.h"
 
@@ -58,15 +55,14 @@ static void stage_rewrite_test(void)
 	int fd;
 
 	/* Start up */
-	write_domain_policy("allow_read/write " REWRITE_PATH, 0);
-	write_domain_policy("allow_truncate " REWRITE_PATH, 0);
-	write_domain_policy("allow_create " REWRITE_PATH " 0600", 0);
-	write_domain_policy("allow_unlink " REWRITE_PATH, 0);
-	write_exception_policy("deny_rewrite " REWRITE_PATH, 0);
+	write_domain_policy("file read " REWRITE_PATH, 0);
+	write_domain_policy("file append " REWRITE_PATH, 0);
+	write_domain_policy("file truncate " REWRITE_PATH, 0);
+	write_domain_policy("file create " REWRITE_PATH " 0600", 0);
+	write_domain_policy("file unlink " REWRITE_PATH, 0);
 	set_profile(3, "file::open");
 	set_profile(3, "file::create");
 	set_profile(3, "file::truncate");
-	set_profile(3, "file::rewrite");
 	set_profile(3, "file::unlink");
 	close(open(REWRITE_PATH, O_WRONLY | O_APPEND | O_CREAT, 0600));
 
@@ -94,27 +90,10 @@ static void stage_rewrite_test(void)
 	show_result(fd);
 	close(fd);
 
-	show_prompt("open(O_WRONLY | O_TRUNC | O_APPEND)");
-	fd = open(REWRITE_PATH, O_WRONLY | O_TRUNC | O_APPEND);
-	show_result(fd);
-	close(fd);
-
-	show_prompt("truncate()");
-	show_result(truncate(REWRITE_PATH, 0));
-
-	fd = open(REWRITE_PATH, O_WRONLY | O_APPEND);
-	show_prompt("ftruncate()");
-	show_result(ftruncate(fd, 0));
-
-	show_prompt("fcntl(F_SETFL, ~O_APPEND)");
-	show_result(fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) & ~O_APPEND));
-	close(fd);
-
 	/* Permissive mode */
 	set_profile(2, "file::open");
 	set_profile(2, "file::create");
 	set_profile(2, "file::truncate");
-	set_profile(2, "file::rewrite");
 	set_profile(2, "file::unlink");
 	should_fail = 0;
 
@@ -138,32 +117,17 @@ static void stage_rewrite_test(void)
 	show_result(fd);
 	close(fd);
 
-	show_prompt("open(O_WRONLY | O_TRUNC | O_APPEND)");
-	fd = open(REWRITE_PATH, O_WRONLY | O_TRUNC | O_APPEND);
-	show_result(fd);
-	close(fd);
-
-	show_prompt("truncate()");
-	show_result(truncate(REWRITE_PATH, 0));
-
-	fd = open(REWRITE_PATH, O_WRONLY | O_APPEND);
-	show_prompt("ftruncate()");
-	show_result(ftruncate(fd, 0));
-
-	show_prompt("fcntl(F_SETFL, ~O_APPEND)");
-	show_result(fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) & ~O_APPEND));
-	close(fd);
-
 	/* Clean up */
 	unlink(REWRITE_PATH);
-	write_exception_policy("deny_rewrite " REWRITE_PATH, 0);
 	printf("\n\n");
 }
 
 int main(int argc, char *argv[])
 {
-	tomoyo_test_init();
+	ccs_test_init();
 	stage_rewrite_test();
 	clear_status();
+	if (0) /* To suppress "defined but not used" warnings. */
+		write_exception_policy("", 0);
 	return 0;
-}
\ No newline at end of file
+}
-- 
1.7.1

