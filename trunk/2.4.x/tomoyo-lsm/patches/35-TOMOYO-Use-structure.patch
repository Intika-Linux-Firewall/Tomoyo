Subject: TOMOYO: Use structure for keeping write variables.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.c |   14 +++++++-------
 security/tomoyo/common.h |    8 ++++----
 security/tomoyo/gc.c     |    2 +-
 3 files changed, 12 insertions(+), 12 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/common.c
+++ security-testing-2.6/security/tomoyo/common.c
@@ -804,7 +804,7 @@ static bool tomoyo_select_one(struct tom
 			domain = tomoyo_find_domain(data + 7);
 	} else
 		return false;
-	head->write_var1 = domain;
+	head->w.domain = domain;
 	/* Accessing read_buf is safe because head->io_sem is held. */
 	if (!head->read_buf)
 		return true; /* Do nothing if open(O_WRONLY). */
@@ -906,7 +906,7 @@ const char * const tomoyo_dif[TOMOYO_MAX
 static int tomoyo_write_domain(struct tomoyo_io_buffer *head)
 {
 	char *data = head->write_buf;
-	struct tomoyo_domain_info *domain = head->write_var1;
+	struct tomoyo_domain_info *domain = head->w.domain;
 	bool is_delete = false;
 	bool is_select = false;
 	unsigned int profile;
@@ -928,7 +928,7 @@ static int tomoyo_write_domain(struct to
 			domain = tomoyo_find_domain(data);
 		else
 			domain = tomoyo_assign_domain(data, 0, 0, false);
-		head->write_var1 = domain;
+		head->w.domain = domain;
 		return 0;
 	}
 	if (!domain)
@@ -2140,7 +2140,7 @@ ssize_t tomoyo_write_control(struct file
 	/* Read a line and dispatch it to the policy handler. */
 	while (avail_len > 0) {
 		char c;
-		if (head->write_avail >= head->writebuf_size - 1) {
+		if (head->w.avail >= head->writebuf_size - 1) {
 			error = -ENOMEM;
 			break;
 		} else if (get_user(c, buffer)) {
@@ -2149,11 +2149,11 @@ ssize_t tomoyo_write_control(struct file
 		}
 		buffer++;
 		avail_len--;
-		cp0[head->write_avail++] = c;
+		cp0[head->w.avail++] = c;
 		if (c != '\n')
 			continue;
-		cp0[head->write_avail - 1] = '\0';
-		head->write_avail = 0;
+		cp0[head->w.avail - 1] = '\0';
+		head->w.avail = 0;
 		tomoyo_normalize_line(cp0);
 		{
 			const int ret = head->write(head);
--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -568,16 +568,16 @@ struct tomoyo_io_buffer {
 		bool print_transition_related_only;
 		const char *w[TOMOYO_MAX_IO_READ_QUEUE];
 	} r;
-	/* The position currently writing to.   */
-	struct tomoyo_domain_info *write_var1;
+	struct {
+		struct tomoyo_domain_info *domain;
+		size_t avail;
+	} w;
 	/* Buffer for reading.                  */
 	char *read_buf;
 	/* Size of read buffer.                 */
 	size_t readbuf_size;
 	/* Buffer for writing.                  */
 	char *write_buf;
-	/* Bytes available for writing.         */
-	size_t write_avail;
 	/* Size of write buffer.                */
 	size_t writebuf_size;
 	/* Type of this interface.              */
--- security-testing-2.6.orig/security/tomoyo/gc.c
+++ security-testing-2.6/security/tomoyo/gc.c
@@ -63,7 +63,7 @@ static bool tomoyo_struct_used_by_io_buf
 		}
 		if (head->r.domain == element || head->r.group == element ||
 		    head->r.acl == element ||
-		    &head->write_var1->list == element)
+		    &head->w.domain->list == element)
 			in_use = true;
 		mutex_unlock(&head->io_sem);
 out:
