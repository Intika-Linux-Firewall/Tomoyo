Subject: TOMOYO: Update Kconfig

Allow changing default values for profiles and allow embedding policy files
into the kernel, which is useful for embedded devices such as Android.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/Kconfig       |  109 ++++++++++++++++++++++++++++++++++++++++++
 security/tomoyo/common.c      |   67 +++++++++++++++++++++++++
 security/tomoyo/common.h      |    3 +
 security/tomoyo/load_policy.c |   31 ++++++++++-
 security/tomoyo/memory.c      |   18 +++++-
 security/tomoyo/tomoyo.c      |    5 +
 6 files changed, 223 insertions(+), 10 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/Kconfig
+++ security-testing-2.6/security/tomoyo/Kconfig
@@ -9,3 +9,112 @@ config SECURITY_TOMOYO
 	  Required userspace tools and further information may be
 	  found at <http://tomoyo.sourceforge.jp/>.
 	  If you are unsure how to answer this question, answer N.
+
+config SECURITY_TOMOYO_MAX_ACCEPT_ENTRY
+	int "Default maximal count for learning mode"
+	default 2048
+	range 0 2147483647
+	depends on SECURITY_TOMOYO
+	help
+	  This is the default value for maximal ACL entries
+	  that are automatically appended into policy at "learning mode".
+	  Some programs access thousands of objects, so running
+	  such programs in "learning mode" dulls the system response
+	  and consumes much memory.
+	  This is the safeguard for such programs.
+
+config SECURITY_TOMOYO_MAX_AUDIT_LOG
+	int "Default maximal count for audit log"
+	default 1024
+	range 0 2147483647
+	depends on SECURITY_TOMOYO
+	help
+	  This is the default value for maximal entries for
+	  audit logs that the kernel can hold on memory.
+	  You can read the log via /sys/kernel/security/tomoyo/audit.
+	  If you don't need audit logs, you may set this value to 0.
+
+config SECURITY_TOMOYO_USE_BUILTIN_POLICY
+	bool "Use built-in policy"
+	default n
+	depends on SECURITY_TOMOYO
+	---help---
+	  Say Y here if you want to embed initial policy files into the kernel.
+	  This is a superset of "Built-in domain initializer programs".
+
+	  To use this option, you need to create a file named
+	  security/tomoyo/builtin-policy.h that contains the policy to be
+	  embedded.
+
+config SECURITY_TOMOYO_BUILTIN_INITIALIZERS
+	string "Built-in domain initializer programs"
+	default "/sbin/modprobe /sbin/hotplug"
+	depends on SECURITY_TOMOYO
+	depends on !SECURITY_TOMOYO_USE_BUILTIN_POLICY
+	---help---
+	  Some programs are executed from initrd/initramfs before /sbin/init
+	  starts.
+
+	  Since policy is loaded when /sbin/init starts, it is impossible to
+	  run such programs outside the <kernel> domain. Usually it is fine.
+
+	  But if such programs continue running when /sbin/init starts, such
+	  programs will reside in the <kernel> domain.
+	  If such programs executes /bin/sh , you will give the <kernel> domain
+	  permission to execute /bin/sh ; I think you don't want to do so.
+
+	  This option allows you to chase such programs away from the <kernel>
+	  domain so that you won't give the <kernel> domain permission to
+	  execute /bin/sh .
+
+config SECURITY_TOMOYO_ACTIVATE_FROM_THE_BEGINNING
+	bool "Activate immediately after loading built-in policy."
+	default n
+	depends on SECURITY_TOMOYO_USE_BUILTIN_POLICY
+	---help---
+	  Say Y here if you want to activate access control as soon as built-in
+	  policy was loaded. This option will be useful for systems where
+	  operations which can lead to the hijacking of the boot sequence are
+	  needed before loading the policy. For example, you can activate
+	  immediately after loading the fixed part of policy which will allow
+	  only operations needed for mounting a partition which contains the
+	  variant part of policy and verifying (e.g. running GPG check) and
+	  loading the variant part of policy. Since you can start using
+	  enforcing mode from the beginning, you can reduce the possibility of
+	  hijacking the boot sequence.
+
+	  If you say Y here, you may want to change "Default policy loader" to
+	  something like /bin/true because the role of policy loader is nothing
+	  but to activate. If you have nothing more to add to policy before
+	  activation, you may want to choose "Omit calling policy loader when
+	  /sbin/init starts." because you no longer need to call policy loader.
+
+config SECURITY_TOMOYO_OMIT_USERSPACE_LOADER
+	bool "Omit calling policy loader when /sbin/init starts."
+	default y
+	depends on SECURITY_TOMOYO_ACTIVATE_FROM_THE_BEGINNING
+	---help---
+	  Say Y here if you want to skip calling policy loader when /sbin/init
+	  starts. If you embedded policy using "Use built-in policy" and chose
+	  "Activate immediately after loading built-in policy.", you don't need
+	  to call policy loader.
+
+config SECURITY_TOMOYO_DEFAULT_LOADER
+	string "Default policy loader"
+	default "/sbin/tomoyo-init"
+	depends on SECURITY_TOMOYO
+	depends on !SECURITY_TOMOYO_OMIT_USERSPACE_LOADER
+	---help---
+	  This is the default pathname of policy loader which is called before
+	  activation. You can override using TOMOYO_loader= kernel command line
+	  option.
+
+config SECURITY_TOMOYO_ALTERNATIVE_TRIGGER
+	string "Alternative activation trigger"
+	default "/sbin/tomoyo-start"
+	depends on SECURITY_TOMOYO
+	depends on !SECURITY_TOMOYO_OMIT_USERSPACE_LOADER
+	---help---
+	  Some environments do not have /sbin/init . In such environments,
+	  we need to use different program's pathname (e.g. /init or /linuxrc )
+	  as activation trigger.
--- security-testing-2.6.orig/security/tomoyo/common.c
+++ security-testing-2.6/security/tomoyo/common.c
@@ -331,8 +331,10 @@ static struct tomoyo_profile *tomoyo_ass
 			TOMOYO_CONFIG_WANT_REJECT_LOG;
 		memset(ptr->config, TOMOYO_CONFIG_USE_DEFAULT,
 		       sizeof(ptr->config));
-		ptr->pref[TOMOYO_PREF_MAX_AUDIT_LOG] = 1024;
-		ptr->pref[TOMOYO_PREF_MAX_LEARNING_ENTRY] = 2048;
+		ptr->pref[TOMOYO_PREF_MAX_AUDIT_LOG] =
+			CONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG;
+		ptr->pref[TOMOYO_PREF_MAX_LEARNING_ENTRY] =
+			CONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY;
 		mb(); /* Avoid out-of-order execution. */
 		tomoyo_profile_ptr[profile] = ptr;
 		entry = NULL;
@@ -2237,3 +2239,64 @@ void tomoyo_check_profile(void)
 	printk(KERN_INFO "TOMOYO: 2.3.0\n");
 	printk(KERN_INFO "Mandatory Access Control activated.\n");
 }
+
+#ifdef CONFIG_SECURITY_TOMOYO_USE_BUILTIN_POLICY
+/**
+ * tomoyo_load_builtin_policy - Load built-in policy.
+ *
+ * Returns nothing.
+ */
+void __init tomoyo_load_builtin_policy(void)
+{
+	/*
+	 * This include file is manually created and contains built-in policy
+	 * named "tomoyo_builtin_profile", "tomoyo_builtin_exception_policy",
+	 * "tomoyo_builtin_domain_policy", "tomoyo_builtin_manager",
+	 * "tomoyo_builtin_stat" in the form of "static char [] __initdata".
+	 */
+#include "builtin-policy.h"
+	struct tomoyo_io_buffer head;
+	u8 i;
+	const int idx = tomoyo_read_lock();
+	for (i = 0; i < 5; i++) {
+		char *start = "";
+		memset(&head, 0, sizeof(head));
+		switch (i) {
+		case 0:
+			start = tomoyo_builtin_profile;
+			head.write = tomoyo_write_profile;
+			break;
+		case 1:
+			start = tomoyo_builtin_exception_policy;
+			head.write = tomoyo_write_exception;
+			break;
+		case 2:
+			start = tomoyo_builtin_domain_policy;
+			head.write = tomoyo_write_domain;
+			break;
+		case 3:
+			start = tomoyo_builtin_manager;
+			head.write = tomoyo_write_manager;
+			break;
+		case 4:
+			start = tomoyo_builtin_stat;
+			head.write = tomoyo_write_stat;
+			break;
+		}
+		while (1) {
+			char *end = strchr(start, '\n');
+			if (!end)
+				break;
+			*end = '\0';
+			tomoyo_normalize_line(start);
+			head.write_buf = start;
+			head.write(&head);
+			start = end + 1;
+		}
+	}
+	tomoyo_read_unlock(idx);
+#ifdef CONFIG_SECURITY_TOMOYO_ACTIVATE_FROM_THE_BEGINNING
+	tomoyo_check_profile();
+#endif
+}
+#endif
--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -717,6 +717,9 @@ struct tomoyo_profile *tomoyo_profile(co
 struct tomoyo_security *tomoyo_find_task_security(const struct task_struct *
 						  task);
 void *tomoyo_commit_ok(void *data, const unsigned int size);
+#ifdef CONFIG_SECURITY_TOMOYO_USE_BUILTIN_POLICY
+void __init tomoyo_load_builtin_policy(void);
+#endif
 void __init tomoyo_mm_init(void);
 void tomoyo_check_acl(struct tomoyo_request_info *r,
 		      bool (*check_entry) (struct tomoyo_request_info *,
--- security-testing-2.6.orig/security/tomoyo/load_policy.c
+++ security-testing-2.6/security/tomoyo/load_policy.c
@@ -8,8 +8,27 @@
 
 #include "common.h"
 
-/* path to policy loader */
-static const char *tomoyo_loader = "/sbin/tomoyo-init";
+#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER
+
+/*
+ * Path to the policy loader. (default = CONFIG_SECURITY_TOMOYO_DEFAULT_LOADER)
+ */
+static const char *tomoyo_loader;
+
+/**
+ * tomoyo_loader_setup - Specify the policy loader to use.
+ *
+ * @str: Path to the policy loader.
+ *
+ * Returns 0.
+ */
+static int __init tomoyo_loader_setup(char *str)
+{
+	tomoyo_loader = str;
+	return 0;
+}
+
+__setup("TOMOYO_loader=", tomoyo_loader_setup);
 
 /**
  * tomoyo_policy_loader_exists - Check whether /sbin/tomoyo-init exists.
@@ -27,9 +46,11 @@ static bool tomoyo_policy_loader_exists(
 	 */
 	struct path path;
 
+	if (!tomoyo_loader)
+		tomoyo_loader = CONFIG_SECURITY_TOMOYO_DEFAULT_LOADER;
 	if (kern_path(tomoyo_loader, LOOKUP_FOLLOW, &path)) {
-		printk(KERN_INFO "Not activating Mandatory Access Control now "
-		       "since %s doesn't exist.\n", tomoyo_loader);
+		printk(KERN_INFO "Not activating Mandatory Access Control "
+		       "as %s does not exist.\n", tomoyo_loader);
 		return false;
 	}
 	path_put(&path);
@@ -79,3 +100,5 @@ void tomoyo_load_policy(const char *file
 	call_usermodehelper(argv[0], argv, envp, 1);
 	tomoyo_check_profile();
 }
+
+#endif
--- security-testing-2.6.orig/security/tomoyo/memory.c
+++ security-testing-2.6/security/tomoyo/memory.c
@@ -218,12 +218,22 @@ void __init tomoyo_mm_init(void)
 	idx = tomoyo_read_lock();
 	if (tomoyo_find_domain(TOMOYO_ROOT_NAME) != &tomoyo_kernel_domain)
 		panic("Can't register tomoyo_kernel_domain");
+#ifdef CONFIG_SECURITY_TOMOYO_BUILTIN_INITIALIZERS
 	{
 		/* Load built-in policy. */
-		tomoyo_write_transition_control("/sbin/hotplug", false,
-					TOMOYO_TRANSITION_CONTROL_INITIALIZE);
-		tomoyo_write_transition_control("/sbin/modprobe", false,
-					TOMOYO_TRANSITION_CONTROL_INITIALIZE);
+		static char tomoyo_builtin_initializers[] __initdata
+			= CONFIG_SECURITY_TOMOYO_BUILTIN_INITIALIZERS;
+		char *cp = tomoyo_builtin_initializers;
+		tomoyo_normalize_line(cp);
+		while (cp && *cp) {
+			char *cp2 = strchr(cp, ' ');
+			if (cp2)
+				*cp2++ = '\0';
+			tomoyo_write_transition_control(cp, false,
+				     TOMOYO_TRANSITION_CONTROL_INITIALIZE);
+			cp = cp2;
+		}
 	}
+#endif
 	tomoyo_read_unlock(idx);
 }
--- security-testing-2.6.orig/security/tomoyo/tomoyo.c
+++ security-testing-2.6/security/tomoyo/tomoyo.c
@@ -306,12 +306,14 @@ static void tomoyo_bprm_free_security(st
 static int tomoyo_bprm_check_security(struct linux_binprm *bprm)
 {
 	struct tomoyo_security *security;
+#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER
 	/*
 	 * Load policy if /sbin/tomoyo-init exists and /sbin/init is requested
 	 * for the first time.
 	 */
 	if (!tomoyo_policy_loaded)
 		tomoyo_load_policy(bprm->filename);
+#endif
 	security = tomoyo_current_security();
 	if (!security->ee)
 		return tomoyo_start_execve(bprm, &security->ee);
@@ -373,6 +375,9 @@ static int __init tomoyo_init(void)
 				 &tomoyo_task_security_list
 				 [hash_ptr((void *) &init_task,
 					   TOMOYO_TASK_SECURITY_HASH_BITS)]);
+#ifdef CONFIG_SECURITY_TOMOYO_USE_BUILTIN_POLICY
+	tomoyo_load_builtin_policy();
+#endif
 	return 0;
 }
 
