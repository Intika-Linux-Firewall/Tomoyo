Subject: TOMOYO: Misc cleanup.

Update comments, sort symbols in security/tomoyo/common.h .

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.h | 1026 +++++++++++++++++++----------------------------
 1 file changed, 432 insertions(+), 594 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -23,98 +23,58 @@
 #include <linux/poll.h>
 struct linux_binprm;
 
-/********** Constants definitions. **********/
+/* Enumeration definition for internal use. */
 
-/*
- * TOMOYO uses this hash only when appending a string into the string
- * table. Frequency of appending strings is very low. So we don't need
- * large (e.g. 64k) hash size. 256 will be sufficient.
- */
-#define TOMOYO_HASH_BITS  8
-#define TOMOYO_MAX_HASH (1u<<TOMOYO_HASH_BITS)
-
-#define TOMOYO_EXEC_TMPSIZE     4096
-
-/* Profile number is an integer between 0 and 255. */
-#define TOMOYO_MAX_PROFILES 256
-
-/* Group number is an integer between 0 and 255. */
-#define TOMOYO_MAX_ACL_GROUPS 256
-
-/* Index numbers for operation mode. */
-enum tomoyo_mode_index {
-	TOMOYO_CONFIG_DISABLED,
-	TOMOYO_CONFIG_LEARNING,
-	TOMOYO_CONFIG_PERMISSIVE,
-	TOMOYO_CONFIG_ENFORCING,
-	TOMOYO_CONFIG_MAX_MODE,
-	TOMOYO_CONFIG_WANT_REJECT_LOG =  64,
-	TOMOYO_CONFIG_WANT_GRANT_LOG  = 128,
-	TOMOYO_CONFIG_USE_DEFAULT     = 255,
-};
-
-enum tomoyo_policy_id {
-	TOMOYO_ID_GROUP,
-	TOMOYO_ID_PATH_GROUP,
-	TOMOYO_ID_NUMBER_GROUP,
-	TOMOYO_ID_TRANSITION_CONTROL,
-	TOMOYO_ID_AGGREGATOR,
-	TOMOYO_ID_MANAGER,
-	TOMOYO_ID_NAME,
-	TOMOYO_ID_ACL,
-	TOMOYO_ID_DOMAIN,
-	TOMOYO_MAX_POLICY
+/* Index numbers for Access Controls. */
+enum tomoyo_acl_entry_type_index {
+	TOMOYO_TYPE_PATH_ACL,
+	TOMOYO_TYPE_PATH2_ACL,
+	TOMOYO_TYPE_PATH_NUMBER_ACL,
+	TOMOYO_TYPE_MKDEV_ACL,
+	TOMOYO_TYPE_MOUNT_ACL,
 };
 
+/* Index numbers for group entries. */
 enum tomoyo_group_id {
 	TOMOYO_PATH_GROUP,
 	TOMOYO_NUMBER_GROUP,
 	TOMOYO_MAX_GROUP
 };
 
-/* A domain definition starts with <kernel>. */
-#define TOMOYO_ROOT_NAME                         "<kernel>"
-#define TOMOYO_ROOT_NAME_LEN                     (sizeof(TOMOYO_ROOT_NAME) - 1)
-
-/* Value type definition. */
-#define TOMOYO_VALUE_TYPE_INVALID     0
-#define TOMOYO_VALUE_TYPE_DECIMAL     1
-#define TOMOYO_VALUE_TYPE_OCTAL       2
-#define TOMOYO_VALUE_TYPE_HEXADECIMAL 3
-
-enum tomoyo_transition_type {
-	/* Do not change this order, */
-	TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE,
-	TOMOYO_TRANSITION_CONTROL_INITIALIZE,
-	TOMOYO_TRANSITION_CONTROL_NO_KEEP,
-	TOMOYO_TRANSITION_CONTROL_KEEP,
-	TOMOYO_MAX_TRANSITION_TYPE
-};
-
-/* Index numbers for Access Controls. */
-enum tomoyo_acl_entry_type_index {
-	TOMOYO_TYPE_PATH_ACL,
-	TOMOYO_TYPE_PATH2_ACL,
-	TOMOYO_TYPE_PATH_NUMBER_ACL,
-	TOMOYO_TYPE_MKDEV_ACL,
-	TOMOYO_TYPE_MOUNT_ACL,
+/* Index numbers for category of functionality. */
+enum tomoyo_mac_category_index {
+	TOMOYO_MAC_CATEGORY_FILE,
+	TOMOYO_MAX_MAC_CATEGORY_INDEX
 };
 
-/* Index numbers for File Controls. */
-enum tomoyo_path_acl_index {
-	TOMOYO_TYPE_EXECUTE,
-	TOMOYO_TYPE_READ,
-	TOMOYO_TYPE_WRITE,
-	TOMOYO_TYPE_APPEND,
-	TOMOYO_TYPE_UNLINK,
-	TOMOYO_TYPE_RMDIR,
-	TOMOYO_TYPE_TRUNCATE,
-	TOMOYO_TYPE_SYMLINK,
-	TOMOYO_TYPE_CHROOT,
-	TOMOYO_TYPE_UMOUNT,
-	TOMOYO_MAX_PATH_OPERATION
+/* Index numbers for functionality. */
+enum tomoyo_mac_index {
+	TOMOYO_MAC_FILE_EXECUTE,
+	TOMOYO_MAC_FILE_OPEN,
+	TOMOYO_MAC_FILE_CREATE,
+	TOMOYO_MAC_FILE_UNLINK,
+	TOMOYO_MAC_FILE_MKDIR,
+	TOMOYO_MAC_FILE_RMDIR,
+	TOMOYO_MAC_FILE_MKFIFO,
+	TOMOYO_MAC_FILE_MKSOCK,
+	TOMOYO_MAC_FILE_TRUNCATE,
+	TOMOYO_MAC_FILE_SYMLINK,
+	TOMOYO_MAC_FILE_MKBLOCK,
+	TOMOYO_MAC_FILE_MKCHAR,
+	TOMOYO_MAC_FILE_LINK,
+	TOMOYO_MAC_FILE_RENAME,
+	TOMOYO_MAC_FILE_CHMOD,
+	TOMOYO_MAC_FILE_CHOWN,
+	TOMOYO_MAC_FILE_CHGRP,
+	TOMOYO_MAC_FILE_IOCTL,
+	TOMOYO_MAC_FILE_CHROOT,
+	TOMOYO_MAC_FILE_MOUNT,
+	TOMOYO_MAC_FILE_UMOUNT,
+	TOMOYO_MAC_FILE_PIVOT_ROOT,
+	TOMOYO_MAX_MAC_INDEX
 };
 
+/* Index numbers for /sys/kernel/security/tomoyo/meminfo interface. */
 enum tomoyo_memory_stat_type {
 	TOMOYO_MEMORY_POLICY,
 	TOMOYO_MEMORY_AUDIT,
@@ -122,12 +82,26 @@ enum tomoyo_memory_stat_type {
 	TOMOYO_MAX_MEMORY_STAT
 };
 
+/* Index numbers for access controls with one pathname and three numbers. */
 enum tomoyo_mkdev_acl_index {
 	TOMOYO_TYPE_MKBLOCK,
 	TOMOYO_TYPE_MKCHAR,
 	TOMOYO_MAX_MKDEV_OPERATION
 };
 
+/* Index numbers for operation mode. */
+enum tomoyo_mode_value {
+	TOMOYO_CONFIG_DISABLED,
+	TOMOYO_CONFIG_LEARNING,
+	TOMOYO_CONFIG_PERMISSIVE,
+	TOMOYO_CONFIG_ENFORCING,
+	TOMOYO_CONFIG_MAX_MODE,
+	TOMOYO_CONFIG_WANT_REJECT_LOG =  64,
+	TOMOYO_CONFIG_WANT_GRANT_LOG  = 128,
+	TOMOYO_CONFIG_USE_DEFAULT     = 255,
+};
+
+/* Index numbers for access controls with two pathnames. */
 enum tomoyo_path2_acl_index {
 	TOMOYO_TYPE_LINK,
 	TOMOYO_TYPE_RENAME,
@@ -135,6 +109,22 @@ enum tomoyo_path2_acl_index {
 	TOMOYO_MAX_PATH2_OPERATION
 };
 
+/* Index numbers for access controls with one pathname. */
+enum tomoyo_path_acl_index {
+	TOMOYO_TYPE_EXECUTE,
+	TOMOYO_TYPE_READ,
+	TOMOYO_TYPE_WRITE,
+	TOMOYO_TYPE_APPEND,
+	TOMOYO_TYPE_UNLINK,
+	TOMOYO_TYPE_RMDIR,
+	TOMOYO_TYPE_TRUNCATE,
+	TOMOYO_TYPE_SYMLINK,
+	TOMOYO_TYPE_CHROOT,
+	TOMOYO_TYPE_UMOUNT,
+	TOMOYO_MAX_PATH_OPERATION
+};
+
+/* Index numbers for access controls with one pathname and one number. */
 enum tomoyo_path_number_acl_index {
 	TOMOYO_TYPE_CREATE,
 	TOMOYO_TYPE_MKDIR,
@@ -147,6 +137,28 @@ enum tomoyo_path_number_acl_index {
 	TOMOYO_MAX_PATH_NUMBER_OPERATION
 };
 
+/* Index numbers for entry type. */
+enum tomoyo_policy_id {
+	TOMOYO_ID_GROUP,
+	TOMOYO_ID_PATH_GROUP,
+	TOMOYO_ID_NUMBER_GROUP,
+	TOMOYO_ID_TRANSITION_CONTROL,
+	TOMOYO_ID_AGGREGATOR,
+	TOMOYO_ID_MANAGER,
+	TOMOYO_ID_NAME,
+	TOMOYO_ID_ACL,
+	TOMOYO_ID_DOMAIN,
+	TOMOYO_MAX_POLICY
+};
+
+/* Index numbers for profile's PREFERENCE values. */
+enum tomoyo_pref_index {
+	TOMOYO_PREF_MAX_AUDIT_LOG,
+	TOMOYO_PREF_MAX_LEARNING_ENTRY,
+	TOMOYO_MAX_PREF
+};
+
+/* Index numbers for /sys/kernel/security/tomoyo/ interfaces. */
 enum tomoyo_securityfs_interface_index {
 	TOMOYO_DOMAINPOLICY,
 	TOMOYO_EXCEPTIONPOLICY,
@@ -173,57 +185,65 @@ enum tomoyo_special_mount {
 	TOMOYO_MAX_SPECIAL_MOUNT
 };
 
-enum tomoyo_mac_index {
-	TOMOYO_MAC_FILE_EXECUTE,
-	TOMOYO_MAC_FILE_OPEN,
-	TOMOYO_MAC_FILE_CREATE,
-	TOMOYO_MAC_FILE_UNLINK,
-	TOMOYO_MAC_FILE_MKDIR,
-	TOMOYO_MAC_FILE_RMDIR,
-	TOMOYO_MAC_FILE_MKFIFO,
-	TOMOYO_MAC_FILE_MKSOCK,
-	TOMOYO_MAC_FILE_TRUNCATE,
-	TOMOYO_MAC_FILE_SYMLINK,
-	TOMOYO_MAC_FILE_MKBLOCK,
-	TOMOYO_MAC_FILE_MKCHAR,
-	TOMOYO_MAC_FILE_LINK,
-	TOMOYO_MAC_FILE_RENAME,
-	TOMOYO_MAC_FILE_CHMOD,
-	TOMOYO_MAC_FILE_CHOWN,
-	TOMOYO_MAC_FILE_CHGRP,
-	TOMOYO_MAC_FILE_IOCTL,
-	TOMOYO_MAC_FILE_CHROOT,
-	TOMOYO_MAC_FILE_MOUNT,
-	TOMOYO_MAC_FILE_UMOUNT,
-	TOMOYO_MAC_FILE_PIVOT_ROOT,
-	TOMOYO_MAX_MAC_INDEX
+/* Index numbers for domain transition control keywords. */
+enum tomoyo_transition_type {
+	/* Do not change this order, */
+	TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE,
+	TOMOYO_TRANSITION_CONTROL_INITIALIZE,
+	TOMOYO_TRANSITION_CONTROL_NO_KEEP,
+	TOMOYO_TRANSITION_CONTROL_KEEP,
+	TOMOYO_MAX_TRANSITION_TYPE
 };
 
-enum tomoyo_mac_category_index {
-	TOMOYO_MAC_CATEGORY_FILE,
-	TOMOYO_MAX_MAC_CATEGORY_INDEX
+/* Value type definition. */
+enum tomoyo_value_type {
+	TOMOYO_VALUE_TYPE_INVALID,
+	TOMOYO_VALUE_TYPE_DECIMAL,
+	TOMOYO_VALUE_TYPE_OCTAL,
+	TOMOYO_VALUE_TYPE_HEXADECIMAL,
 };
 
-#define TOMOYO_RETRY_REQUEST 1 /* Retry this request. */
+/* Constants definition for internal use. */
 
-/* Index numbers for profile's PREFERENCE values. */
-enum tomoyo_pref_index {
-	TOMOYO_PREF_MAX_AUDIT_LOG,
-	TOMOYO_PREF_MAX_LEARNING_ENTRY,
-	TOMOYO_MAX_PREF
-};
+/*
+ * TOMOYO uses this hash only when appending a string into the string
+ * table. Frequency of appending strings is very low. So we don't need
+ * large (e.g. 64k) hash size. 256 will be sufficient.
+ */
+#define TOMOYO_HASH_BITS  8
+#define TOMOYO_MAX_HASH (1u<<TOMOYO_HASH_BITS)
+
+/* A domain definition starts with <kernel>. */
+#define TOMOYO_ROOT_NAME                         "<kernel>"
+#define TOMOYO_ROOT_NAME_LEN                     (sizeof(TOMOYO_ROOT_NAME) - 1)
 
-/********** Structure definitions. **********/
+/* Size of temporary buffer for execve() operation. */
+#define TOMOYO_EXEC_TMPSIZE     4096
+
+/* Profile number is an integer between 0 and 255. */
+#define TOMOYO_MAX_PROFILES 256
+
+/* Group number is an integer between 0 and 255. */
+#define TOMOYO_MAX_ACL_GROUPS 256
 
 /*
- * tomoyo_acl_head is a structure which is used for holding elements not in
- * domain policy.
- * It has following fields.
- *
- *  (1) "list" which is linked to tomoyo_policy_list[] .
- *  (2) "is_deleted" is a bool which is true if marked as deleted, false
- *      otherwise.
+ * Retry this request. Returned by tomoyo_supervisor() if policy violation has
+ * occurred in enforcing mode and the userspace daemon decided to retry.
+ *
+ * We must choose a positive value in order to distinguish "granted" (which is
+ * 0) and "rejected" (which is a negative value) and "retry".
  */
+#define TOMOYO_RETRY_REQUEST 1
+
+/* Size of read buffer for /sys/kernel/security/tomoyo/ interface. */
+#define TOMOYO_MAX_IO_READ_QUEUE 64
+
+#define TOMOYO_TASK_SECURITY_HASH_BITS 12
+#define TOMOYO_MAX_TASK_SECURITY_HASH (1u << TOMOYO_TASK_SECURITY_HASH_BITS)
+
+/* Structure definition for internal use. */
+
+/* Common header for holding ACL entries. */
 struct tomoyo_acl_head {
 	struct list_head list;
 	bool is_deleted;
@@ -235,6 +255,56 @@ struct tomoyo_shared_acl_head {
 	atomic_t users;
 } __packed;
 
+/* Common header for individual entries. */
+struct tomoyo_acl_info {
+	struct list_head list;
+	bool is_deleted;
+	u8 type; /* One of values in "enum tomoyo_acl_entry_type_index". */
+} __packed;
+
+/* Structure for holding a word. */
+struct tomoyo_name_union {
+	/* Either @filename or @group is NULL. */
+	const struct tomoyo_path_info *filename;
+	struct tomoyo_group *group;
+	/* True if @group != NULL, false if @filename != NULL. */
+	u8 is_group;
+};
+
+/* Structure for holding a number. */
+struct tomoyo_number_union {
+	unsigned long values[2]; /* Maybe NULL. */
+	struct tomoyo_group *group;
+	/* One of values in "enum tomoyo_value_type". */
+	u8 min_type;
+	u8 max_type;
+	/* True if @group != NULL, false otherwise. */
+	u8 is_group;
+};
+
+/* Structure for "path_group"/"number_group" directive. */
+struct tomoyo_group {
+	struct tomoyo_shared_acl_head head;
+	/* Name of group (without leading '@'). */
+	const struct tomoyo_path_info *group_name;
+	/*
+	 * List of "struct tomoyo_path_group" or "struct tomoyo_number_group".
+	 */
+	struct list_head member_list;
+};
+
+/* Structure for "path_group" directive. */
+struct tomoyo_path_group {
+	struct tomoyo_acl_head head;
+	const struct tomoyo_path_info *member_name;
+};
+
+/* Structure for "number_group" directive. */
+struct tomoyo_number_group {
+	struct tomoyo_acl_head head;
+	struct tomoyo_number_union number;
+};
+
 /* Structure for request info. */
 struct tomoyo_request_info {
 	/*
@@ -301,26 +371,7 @@ struct tomoyo_request_info {
 	u8 type;
 };
 
-/*
- * tomoyo_path_info is a structure which is used for holding a string data
- * used by TOMOYO.
- * This structure has several fields for supporting pattern matching.
- *
- * (1) "name" is the '\0' terminated string data.
- * (2) "hash" is full_name_hash(name, strlen(name)).
- *     This allows tomoyo_pathcmp() to compare by hash before actually compare
- *     using strcmp().
- * (3) "const_len" is the length of the initial segment of "name" which
- *     consists entirely of non wildcard characters. In other words, the length
- *     which we can compare two strings using strncmp().
- * (4) "is_dir" is a bool which is true if "name" ends with "/",
- *     false otherwise.
- *     TOMOYO distinguishes directory and non-directory. A directory ends with
- *     "/" and non-directory does not end with "/".
- * (5) "is_patterned" is a bool which is true if "name" contains wildcard
- *     characters, false otherwise. This allows TOMOYO to use "hash" and
- *     strcmp() for string comparison if "is_patterned" is false.
- */
+/* Structure for holding a token. */
 struct tomoyo_path_info {
 	const char *name;
 	u32 hash;          /* = full_name_hash(name, strlen(name)) */
@@ -329,95 +380,7 @@ struct tomoyo_path_info {
 	bool is_patterned; /* = tomoyo_path_contains_pattern(name) */
 };
 
-/*
- * tomoyo_name is a structure which is used for linking
- * "struct tomoyo_path_info" into tomoyo_name_list .
- */
-struct tomoyo_name {
-	struct tomoyo_shared_acl_head head;
-	struct tomoyo_path_info entry;
-};
-
-struct tomoyo_name_union {
-	const struct tomoyo_path_info *filename;
-	struct tomoyo_group *group;
-	u8 is_group;
-};
-
-struct tomoyo_number_union {
-	unsigned long values[2];
-	struct tomoyo_group *group;
-	u8 min_type;
-	u8 max_type;
-	u8 is_group;
-};
-
-/* Structure for "path_group"/"number_group" directive. */
-struct tomoyo_group {
-	struct tomoyo_shared_acl_head head;
-	const struct tomoyo_path_info *group_name;
-	struct list_head member_list;
-};
-
-/* Structure for "path_group" directive. */
-struct tomoyo_path_group {
-	struct tomoyo_acl_head head;
-	const struct tomoyo_path_info *member_name;
-};
-
-/* Structure for "number_group" directive. */
-struct tomoyo_number_group {
-	struct tomoyo_acl_head head;
-	struct tomoyo_number_union number;
-};
-
-/*
- * tomoyo_acl_info is a structure which is used for holding
- *
- *  (1) "list" which is linked to the ->acl_info_list of
- *      "struct tomoyo_domain_info"
- *  (2) "is_deleted" is a bool which is true if this domain is marked as
- *      "deleted", false otherwise.
- *  (3) "type" which tells type of the entry.
- *
- * Packing "struct tomoyo_acl_info" allows
- * "struct tomoyo_path_acl" to embed "u16" and "struct tomoyo_path2_acl"
- * "struct tomoyo_path_number_acl" "struct tomoyo_mkdev_acl" to embed
- * "u8" without enlarging their structure size.
- */
-struct tomoyo_acl_info {
-	struct list_head list;
-	bool is_deleted;
-	u8 type; /* = one of values in "enum tomoyo_acl_entry_type_index". */
-} __packed;
-
-/*
- * tomoyo_domain_info is a structure which is used for holding permissions
- * (e.g. "file read /lib/libc-2.5.so") given to each domain.
- * It has following fields.
- *
- *  (1) "list" which is linked to tomoyo_domain_list .
- *  (2) "acl_info_list" which is linked to "struct tomoyo_acl_info".
- *  (3) "domainname" which holds the name of the domain.
- *  (4) "profile" which remembers profile number assigned to this domain.
- *  (5) "group" which remembers group number assigned to this domain.
- *  (6) "is_deleted" is a bool which is true if this domain is marked as
- *      "deleted", false otherwise.
- *  (7) "quota_warned" is a bool which is used for suppressing warning message
- *      when learning mode learned too much entries.
- *  (8) "transition_failed" is a bool which is set to true when this domain was
- *      unable to create a new domain at tomoyo_find_next_domain() because the
- *      name of the domain to be created was too long or it could not allocate
- *      memory. If set to true, more than one process continued execve()
- *      without domain transition.
- *
- * A domain's lifecycle is an analogy of files on / directory.
- * Multiple domains with the same domainname cannot be created (as with
- * creating files with the same filename fails with -EEXIST).
- * If a process reached a domain, that process can reside in that domain after
- * that domain is marked as "deleted" (as with a process can access an already
- * open()ed file after that file was unlink()ed).
- */
+/* Structure for domain information. */
 struct tomoyo_domain_info {
 	struct list_head list;
 	struct list_head acl_info_list;
@@ -431,17 +394,38 @@ struct tomoyo_domain_info {
 };
 
 /*
- * tomoyo_path_acl is a structure which is used for holding an
- * entry with one pathname operation (e.g. open(), mkdir()).
- * It has following fields.
- *
- *  (1) "head" which is a "struct tomoyo_acl_info".
- *  (2) "perm" which is a bitmask of permitted operations.
- *  (3) "name" is the pathname.
- *
- * Directives held by this structure are "file execute", "file read",
- * "file write", "file append", "file unlink", "file rmdir",
- * "file truncate", "file symlink", "file chroot" and "file unmount".
+ * Structure for "initialize_domain"/"no_initialize_domain" and
+ * "keep_domain"/"no_keep_domain" keyword.
+ */
+struct tomoyo_transition_control {
+	struct tomoyo_acl_head head;
+	u8 type; /* One of values in "enum tomoyo_transition_type". */
+	/* True if the domainname is tomoyo_get_last_name(). */
+	bool is_last_name;
+	const struct tomoyo_path_info *domainname; /* Maybe NULL */
+	const struct tomoyo_path_info *program;    /* Maybe NULL */
+};
+
+
+/* Structure for "aggregator" keyword. */
+struct tomoyo_aggregator {
+	struct tomoyo_acl_head head;
+	const struct tomoyo_path_info *original_name;
+	const struct tomoyo_path_info *aggregated_name;
+};
+
+/* Structure for policy manager. */
+struct tomoyo_manager {
+	struct tomoyo_acl_head head;
+	bool is_domain; /* True if manager is a domainname. */
+	/* A path to program or a domainname. */
+	const struct tomoyo_path_info *manager;
+};
+
+/*
+ * Structure for "file execute", "file read", "file write", "file append",
+ * "file unlink", "file rmdir", "file truncate",
+ * "file symlink", "file chroot" and "file unmount" directive.
  */
 struct tomoyo_path_acl {
 	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_PATH_ACL */
@@ -450,19 +434,18 @@ struct tomoyo_path_acl {
 };
 
 /*
- * tomoyo_path_number_acl is a structure which is used for holding an
- * entry with one pathname and one number operation.
- * It has following fields.
- *
- *  (1) "head" which is a "struct tomoyo_acl_info".
- *  (2) "perm" which is a bitmask of permitted operations.
- *  (3) "name" is the pathname.
- *  (4) "number" is the numeric value.
- *
- * Directives held by this structure are "file create", "file mkdir",
- * "file ioctl", "file mkfifo", "file mksock", "file chmod", "file chown"
- * and "file chgrp".
- *
+ * Structure for "file rename", "file link" and "file pivot_root" directive.
+ */
+struct tomoyo_path2_acl {
+	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_PATH2_ACL */
+	u8 perm; /* Bitmask of values in "enum tomoyo_path2_acl_index". */
+	struct tomoyo_name_union name1;
+	struct tomoyo_name_union name2;
+};
+
+/*
+ * Structure for "file create", "file mkdir", "file mkfifo", "file mksock",
+ * "file ioctl", "file chmod", "file chown" and "file chgrp" directive.
  */
 struct tomoyo_path_number_acl {
 	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_PATH_NUMBER_ACL */
@@ -472,20 +455,7 @@ struct tomoyo_path_number_acl {
 	struct tomoyo_number_union number;
 };
 
-/*
- * tomoyo_mkdev_acl is a structure which is used for holding an
- * entry with one pathname and three numbers operation.
- * It has following fields.
- *
- *  (1) "head" which is a "struct tomoyo_acl_info".
- *  (2) "perm" which is a bitmask of permitted operations.
- *  (3) "mode" is the create mode.
- *  (4) "major" is the major number of device node.
- *  (5) "minor" is the minor number of device node.
- *
- * Directives held by this structure are "file mkchar", "file mkblock".
- *
- */
+/* Structure for "file mkblock" and "file mkchar" directive. */
 struct tomoyo_mkdev_acl {
 	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_MKDEV_ACL */
 	u8 perm; /* Bitmask of values in "enum tomoyo_mkdev_acl_index". */
@@ -495,39 +465,7 @@ struct tomoyo_mkdev_acl {
 	struct tomoyo_number_union minor;
 };
 
-/*
- * tomoyo_path2_acl is a structure which is used for holding an
- * entry with two pathnames operation (i.e. link(), rename() and pivot_root()).
- * It has following fields.
- *
- *  (1) "head" which is a "struct tomoyo_acl_info".
- *  (2) "perm" which is a bitmask of permitted operations.
- *  (3) "name1" is the source/old pathname.
- *  (4) "name2" is the destination/new pathname.
- *
- * Directives held by this structure are "file rename", "file link" and
- * "file pivot_root".
- */
-struct tomoyo_path2_acl {
-	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_PATH2_ACL */
-	u8 perm; /* Bitmask of values in "enum tomoyo_path2_acl_index". */
-	struct tomoyo_name_union name1;
-	struct tomoyo_name_union name2;
-};
-
-/*
- * tomoyo_mount_acl is a structure which is used for holding an
- * entry for mount operation.
- * It has following fields.
- *
- *  (1) "head" which is a "struct tomoyo_acl_info".
- *  (2) "dev_name" is the device name.
- *  (3) "dir_name" is the mount point.
- *  (4) "fs_type" is the filesystem type.
- *  (5) "flags" is the mount flags.
- *
- * Directive held by this structure is "file mount".
- */
+/* Structure for "file mount" directive. */
 struct tomoyo_mount_acl {
 	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_MOUNT_ACL */
 	struct tomoyo_name_union dev_name;
@@ -536,6 +474,12 @@ struct tomoyo_mount_acl {
 	struct tomoyo_number_union flags;
 };
 
+/* Structure for holding string data. */
+struct tomoyo_name {
+	struct tomoyo_shared_acl_head head;
+	struct tomoyo_path_info entry;
+};
+
 /* Structure for holding a line from /sys/kernel/security/tomoyo/ interface. */
 struct tomoyo_acl_param {
 	char *data;
@@ -543,10 +487,8 @@ struct tomoyo_acl_param {
 	bool is_delete;
 };
 
-#define TOMOYO_MAX_IO_READ_QUEUE 64
-
 /*
- * Structure for reading/writing policy via /sys/kernel/security/tomoyo
+ * Structure for reading/writing policy via /sys/kernel/security/tomoyo/
  * interfaces.
  */
 struct tomoyo_io_buffer {
@@ -591,62 +533,7 @@ struct tomoyo_io_buffer {
 	u8 type;
 };
 
-/*
- * tomoyo_transition_control is a structure which is used for holding
- * "initialize_domain"/"no_initialize_domain"/"keep_domain"/"no_keep_domain"
- * entries.
- * It has following fields.
- *
- *  (1) "head" is "struct tomoyo_acl_head".
- *  (2) "type" is type of this entry.
- *  (3) "is_last_name" is a bool which is true if "domainname" is "the last
- *      component of a domainname", false otherwise.
- *  (4) "domainname" which is "a domainname" or "the last component of a
- *      domainname".
- *  (5) "program" which is a program's pathname.
- */
-struct tomoyo_transition_control {
-	struct tomoyo_acl_head head;
-	u8 type; /* One of values in "enum tomoyo_transition_type".  */
-	/* True if the domainname is tomoyo_get_last_name(). */
-	bool is_last_name;
-	const struct tomoyo_path_info *domainname; /* Maybe NULL */
-	const struct tomoyo_path_info *program;    /* Maybe NULL */
-};
-
-/*
- * tomoyo_aggregator is a structure which is used for holding
- * "aggregator" entries.
- * It has following fields.
- *
- *  (1) "head" is "struct tomoyo_acl_head".
- *  (2) "original_name" which is originally requested name.
- *  (3) "aggregated_name" which is name to rewrite.
- */
-struct tomoyo_aggregator {
-	struct tomoyo_acl_head head;
-	const struct tomoyo_path_info *original_name;
-	const struct tomoyo_path_info *aggregated_name;
-};
-
-/*
- * tomoyo_manager is a structure which is used for holding list of
- * domainnames or programs which are permitted to modify configuration via
- * /sys/kernel/security/tomoyo/ interface.
- * It has following fields.
- *
- *  (1) "head" is "struct tomoyo_acl_head".
- *  (2) "is_domain" is a bool which is true if "manager" is a domainname, false
- *      otherwise.
- *  (3) "manager" is a domainname or a program's pathname.
- */
-struct tomoyo_manager {
-	struct tomoyo_acl_head head;
-	bool is_domain;  /* True if manager is a domainname. */
-	/* A path to program or a domainname. */
-	const struct tomoyo_path_info *manager;
-};
-
+/* Structure for /sys/kernel/security/tomoyo/profile interface. */
 struct tomoyo_profile {
 	const struct tomoyo_path_info *comment;
 	u8 default_config;
@@ -674,222 +561,76 @@ struct tomoyo_security {
 	/*
 	 * Holds current thread's domain. Only current thread can modify this
 	 * member but any threads can read this member under RCU.
-	 */
-	struct tomoyo_domain_info *tomoyo_domain_info;
-	/*
-	 * Holds previous tomoyo_domain_info during do_execve() in case
-	 * do_execve() failed, NULL otherwise. Only current thread can access
-	 * this member.
-	 */
-	struct tomoyo_domain_info *previous_domain_info;
-	struct rcu_head rcu;
-};
-
-#define TOMOYO_TASK_SECURITY_HASH_BITS 12
-#define TOMOYO_MAX_TASK_SECURITY_HASH (1u << TOMOYO_TASK_SECURITY_HASH_BITS)
-extern struct list_head
-tomoyo_task_security_list[TOMOYO_MAX_TASK_SECURITY_HASH];
-
-struct tomoyo_security *tomoyo_find_task_security
-(const struct task_struct *task);
-
-/**
- * tomoyo_current_security - Get "struct tomoyo_security" for current thread.
- *
- * Returns pointer to "struct tomoyo_security" for current thread.
- */
-static inline struct tomoyo_security *tomoyo_current_security(void)
-{
-	return tomoyo_find_task_security(current);
-}
-
-/**
- * tomoyo_task_domain - Get "struct tomoyo_domain_info" for specified thread.
- *
- * @task: Pointer to "struct task_struct".
- *
- * Returns pointer to "struct tomoyo_security" for specified thread.
- */
-static inline struct tomoyo_domain_info *tomoyo_task_domain
-(struct task_struct *task)
-{
-	struct tomoyo_domain_info *domain;
-	rcu_read_lock();
-	domain = tomoyo_find_task_security(task)->tomoyo_domain_info;
-	rcu_read_unlock();
-	return domain;
-}
-
-/**
- * tomoyo_current_domain - Get "struct tomoyo_domain_info" for current thread.
- *
- * Returns pointer to "struct tomoyo_domain_info" for current thread.
- */
-static inline struct tomoyo_domain_info *tomoyo_current_domain(void)
-{
-	return tomoyo_find_task_security(current)->tomoyo_domain_info;
-}
+	 */
+	struct tomoyo_domain_info *tomoyo_domain_info;
+	/*
+	 * Holds previous tomoyo_domain_info during do_execve() in case
+	 * do_execve() failed, NULL otherwise. Only current thread can access
+	 * this member.
+	 */
+	struct tomoyo_domain_info *previous_domain_info;
+	struct rcu_head rcu;
+};
 
-/********** Function prototypes. **********/
+/* Prototype definition for internal use. */
 
-/* Check whether the given string starts with the given keyword. */
-bool tomoyo_str_starts(char **src, const char *find);
-/* Get tomoyo_realpath() of current process. */
-const char *tomoyo_get_exe(void);
-/* Format string. */
-void tomoyo_normalize_line(unsigned char *buffer);
-/* Check all profiles currently assigned to domains are defined. */
-void tomoyo_check_profile(void);
-/* Open operation for /sys/kernel/security/tomoyo/ interface. */
-int tomoyo_open_control(const u8 type, struct file *file);
-/* Close /sys/kernel/security/tomoyo/ interface. */
-int tomoyo_close_control(struct file *file);
-/* Poll operation for /sys/kernel/security/tomoyo/ interface. */
-int tomoyo_poll_control(struct file *file, poll_table *wait);
-/* Read operation for /sys/kernel/security/tomoyo/ interface. */
-int tomoyo_read_control(struct file *file, char __user *buffer,
-			const int buffer_len);
-/* Write operation for /sys/kernel/security/tomoyo/ interface. */
-int tomoyo_write_control(struct file *file, const char __user *buffer,
-			 const int buffer_len);
-/* Check whether the domain has too many ACL entries to hold. */
-bool tomoyo_domain_quota_is_ok(struct tomoyo_request_info *r);
-/* Print out of memory warning message. */
-void tomoyo_warn_oom(const char *function);
-/* Check whether the given name matches the given name_union. */
-const struct tomoyo_path_info *
-tomoyo_compare_name_union(const struct tomoyo_path_info *name,
-			  const struct tomoyo_name_union *ptr);
-/* Check whether the given number matches the given number_union. */
 bool tomoyo_compare_number_union(const unsigned long value,
 				 const struct tomoyo_number_union *ptr);
-int tomoyo_get_mode(const u8 profile, const u8 index);
-void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt, ...)
-	__attribute__ ((format(printf, 2, 3)));
-/* Check whether the domainname is correct. */
 bool tomoyo_correct_domain(const unsigned char *domainname);
-/* Check whether the token is correct. */
 bool tomoyo_correct_path(const char *filename);
 bool tomoyo_correct_word(const char *string);
-/* Check whether the token can be a domainname. */
 bool tomoyo_domain_def(const unsigned char *buffer);
-bool tomoyo_parse_name_union(const char *filename,
-			     struct tomoyo_name_union *ptr);
-/* Check whether the given filename matches the given path_group. */
-const struct tomoyo_path_info *
-tomoyo_path_matches_group(const struct tomoyo_path_info *pathname,
-			  const struct tomoyo_group *group);
-/* Check whether the given value matches the given number_group. */
+bool tomoyo_domain_quota_is_ok(struct tomoyo_request_info *r);
+bool tomoyo_memory_ok(void *ptr);
 bool tomoyo_number_matches_group(const unsigned long min,
 				 const unsigned long max,
 				 const struct tomoyo_group *group);
-/* Check whether the given filename matches the given pattern. */
+bool tomoyo_parse_name_union(const char *filename,
+			     struct tomoyo_name_union *ptr);
+bool tomoyo_parse_number_union(char *data, struct tomoyo_number_union *num);
 bool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,
 				 const struct tomoyo_path_info *pattern);
-
-bool tomoyo_parse_number_union(char *data, struct tomoyo_number_union *num);
-/* Tokenize a line. */
+bool tomoyo_permstr(const char *string, const char *keyword);
+bool tomoyo_str_starts(char **src, const char *find);
 bool tomoyo_tokenize(char *buffer, char *w[], size_t size);
-/* Write domain policy violation warning message to console? */
 bool tomoyo_verbose_mode(const struct tomoyo_domain_info *domain);
-/* Fill "struct tomoyo_request_info". */
-int tomoyo_init_request_info(struct tomoyo_request_info *r, const u8 index);
-/* Check permission for mount operation. */
-int tomoyo_mount_permission(char *dev_name, struct path *path,
-			    const char *type, unsigned long flags,
-			    void *data_page);
-/* Create "aggregator" entry in exception policy. */
-int tomoyo_write_aggregator(char *data, const bool is_delete);
-int tomoyo_write_transition_control(char *data, const bool is_delete,
-				    const u8 type);
-/*
- * Create "file execute", "file read", "file write", "file append",
- * "file create", "file unlink", "file mkdir", "file rmdir",
- * "file mkfifo", "file mksock", "file mkblock", "file mkchar",
- * "file truncate", "file symlink", "file mount", "file rename" and
- * "file link" entry in domain policy.
- */
-int tomoyo_write_file(struct tomoyo_acl_param *param);
-/* Create "path_group"/"number_group" entry in exception policy. */
-int tomoyo_write_group(char *data, const bool is_delete, const u8 type);
-int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)
-     __attribute__ ((format(printf, 2, 3)));
-/* Find a domain by the given name. */
-struct tomoyo_domain_info *tomoyo_find_domain(const char *domainname);
-/* Find or create a domain by the given name. */
-struct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,
-						const u8 profile);
-struct tomoyo_profile *tomoyo_profile(const u8 profile);
-/*
- * Allocate memory for "struct tomoyo_path_group"/"struct tomoyo_number_group".
- */
-struct tomoyo_group *tomoyo_get_group(const char *group_name, const u8 type);
-
-/* Check mode for specified functionality. */
-unsigned int tomoyo_check_flags(const struct tomoyo_domain_info *domain,
-				const u8 index);
-/* Fill in "struct tomoyo_path_info" members. */
-void tomoyo_fill_path_info(struct tomoyo_path_info *ptr);
-/* Run policy loader when /sbin/init starts. */
-void tomoyo_load_policy(const char *filename);
-
-void tomoyo_put_number_union(struct tomoyo_number_union *ptr);
-
-/* Convert binary string to ascii string. */
 char *tomoyo_encode(const char *str);
-
-/*
- * Returns realpath(3) of the given pathname except that
- * ignores chroot'ed root and does not follow the final symlink.
- */
-char *tomoyo_realpath_nofollow(const char *pathname);
-/*
- * Returns realpath(3) of the given pathname except that
- * ignores chroot'ed root and the pathname is already solved.
- */
+char *tomoyo_init_log(struct tomoyo_request_info *r, int len, const char *fmt,
+		      va_list args);
+char *tomoyo_read_token(struct tomoyo_acl_param *param);
 char *tomoyo_realpath_from_path(struct path *path);
-
-/* Check memory quota. */
-bool tomoyo_memory_ok(void *ptr);
-void *tomoyo_commit_ok(void *data, const unsigned int size);
-
-/*
- * Keep the given name on the RAM.
- * The RAM is shared, so NEVER try to modify or kfree() the returned name.
- */
+char *tomoyo_realpath_nofollow(const char *pathname);
+const char *tomoyo_get_exe(void);
+const char *tomoyo_yesno(const unsigned int value);
+const struct tomoyo_path_info *tomoyo_compare_name_union
+(const struct tomoyo_path_info *name, const struct tomoyo_name_union *ptr);
 const struct tomoyo_path_info *tomoyo_get_name(const char *name);
-
-/* Check for memory usage. */
-void tomoyo_read_memory_counter(struct tomoyo_io_buffer *head);
-
-/* Set memory quota. */
-int tomoyo_write_memory_quota(struct tomoyo_io_buffer *head);
-
-/* Initialize mm related code. */
-void __init tomoyo_mm_init(void);
-int tomoyo_path_permission(struct tomoyo_request_info *r, u8 operation,
-			   const struct tomoyo_path_info *filename);
+const struct tomoyo_path_info *tomoyo_path_matches_group
+(const struct tomoyo_path_info *pathname, const struct tomoyo_group *group);
 int tomoyo_check_open_permission(struct path *path, const int flag);
-int tomoyo_path_number_perm(const u8 operation, struct path *path,
-			    unsigned long number);
+int tomoyo_close_control(struct file *file);
+int tomoyo_find_next_domain(struct linux_binprm *bprm);
+int tomoyo_get_mode(const u8 profile, const u8 index);
+int tomoyo_init_request_info(struct tomoyo_request_info *r, const u8 index);
 int tomoyo_mkdev_perm(const u8 operation, struct path *path,
 		      const unsigned int mode, unsigned int dev);
-int tomoyo_path_perm(const u8 operation, struct path *path);
+int tomoyo_mount_permission(char *dev_name, struct path *path,
+			    const char *type, unsigned long flags,
+			    void *data_page);
+int tomoyo_open_control(const u8 type, struct file *file);
 int tomoyo_path2_perm(const u8 operation, struct path *path1,
 		      struct path *path2);
-int tomoyo_find_next_domain(struct linux_binprm *bprm);
-
-void tomoyo_print_ulong(char *buffer, const int buffer_len,
-			const unsigned long value, const u8 type);
-
-/* Drop refcount on tomoyo_name_union. */
-void tomoyo_put_name_union(struct tomoyo_name_union *ptr);
-
-/* Run garbage collector. */
-void tomoyo_run_gc(void);
-
-void tomoyo_memory_free(void *ptr);
-
+int tomoyo_path_number_perm(const u8 operation, struct path *path,
+			    unsigned long number);
+int tomoyo_path_perm(const u8 operation, struct path *path);
+int tomoyo_path_permission(struct tomoyo_request_info *r, u8 operation,
+			   const struct tomoyo_path_info *filename);
+int tomoyo_poll_control(struct file *file, poll_table *wait);
+int tomoyo_poll_log(struct file *file, poll_table *wait);
+int tomoyo_read_control(struct file *file, char __user *buffer,
+			const int buffer_len);
+int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)
+	__attribute__ ((format(printf, 2, 3)));
 int tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,
 			 struct tomoyo_acl_param *param,
 			 bool (*check_duplicate) (const struct tomoyo_acl_info
@@ -905,72 +646,102 @@ int tomoyo_update_policy(struct tomoyo_a
 						  *,
 						  const struct tomoyo_acl_head
 						  *));
+int tomoyo_write_aggregator(char *data, const bool is_delete);
+int tomoyo_write_control(struct file *file, const char __user *buffer,
+			 const int buffer_len);
+int tomoyo_write_file(struct tomoyo_acl_param *param);
+int tomoyo_write_group(char *data, const bool is_delete, const u8 type);
+int tomoyo_write_memory_quota(struct tomoyo_io_buffer *head);
+int tomoyo_write_transition_control(char *data, const bool is_delete,
+				    const u8 type);
+struct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,
+						const u8 profile);
+struct tomoyo_domain_info *tomoyo_find_domain(const char *domainname);
+struct tomoyo_group *tomoyo_get_group(const char *group_name, const u8 type);
+struct tomoyo_profile *tomoyo_profile(const u8 profile);
+struct tomoyo_security *tomoyo_find_task_security(const struct task_struct *
+						  task);
+void *tomoyo_commit_ok(void *data, const unsigned int size);
+void __init tomoyo_mm_init(void);
 void tomoyo_check_acl(struct tomoyo_request_info *r,
 		      bool (*check_entry) (struct tomoyo_request_info *,
 					   const struct tomoyo_acl_info *));
-
-const char *tomoyo_yesno(const unsigned int value);
+void tomoyo_check_profile(void);
+void tomoyo_fill_path_info(struct tomoyo_path_info *ptr);
+void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt, ...)
+	__attribute__ ((format(printf, 2, 3)));
+void tomoyo_load_policy(const char *filename);
+void tomoyo_memory_free(void *ptr);
+void tomoyo_normalize_line(unsigned char *buffer);
+void tomoyo_print_ulong(char *buffer, const int buffer_len,
+			const unsigned long value, const u8 type);
+void tomoyo_put_name_union(struct tomoyo_name_union *ptr);
+void tomoyo_put_number_union(struct tomoyo_number_union *ptr);
+void tomoyo_read_log(struct tomoyo_io_buffer *head);
+void tomoyo_read_memory_counter(struct tomoyo_io_buffer *head);
+void tomoyo_run_gc(void);
+void tomoyo_warn_oom(const char *function);
 void tomoyo_write_log2(struct tomoyo_request_info *r, int len, const char *fmt,
 		       va_list args);
-void tomoyo_read_log(struct tomoyo_io_buffer *head);
-int tomoyo_poll_log(struct file *file, poll_table *wait);
-char *tomoyo_init_log(struct tomoyo_request_info *r, int len, const char *fmt,
-		      va_list args);
-
-char *tomoyo_read_token(struct tomoyo_acl_param *param);
-bool tomoyo_permstr(const char *string, const char *keyword);
 
-/********** External variable definitions. **********/
+/* Variable definition for internal use. */
 
-/* Lock for GC. */
-extern struct srcu_struct tomoyo_ss;
-
-/* The list for "struct tomoyo_domain_info". */
+extern bool tomoyo_policy_loaded;
+extern bool tomoyo_registered;
+extern const char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE];
+extern const char *tomoyo_mkdev_keyword[TOMOYO_MAX_MKDEV_OPERATION];
+extern const char *tomoyo_path2_keyword[TOMOYO_MAX_PATH2_OPERATION];
+extern const char *tomoyo_path_keyword[TOMOYO_MAX_PATH_OPERATION];
+extern const char *tomoyo_path_number_keyword
+[TOMOYO_MAX_PATH_NUMBER_OPERATION];
+extern const u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION];
+extern const u8 tomoyo_pnnn2mac[TOMOYO_MAX_MKDEV_OPERATION];
+extern const u8 tomoyo_pp2mac[TOMOYO_MAX_PATH2_OPERATION];
 extern struct list_head tomoyo_domain_list;
-
-extern struct list_head tomoyo_policy_list[TOMOYO_MAX_POLICY];
 extern struct list_head tomoyo_group_list[TOMOYO_MAX_GROUP];
 extern struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];
-
-/* Lock for protecting policy. */
+extern struct list_head tomoyo_policy_list[TOMOYO_MAX_POLICY];
+extern struct list_head tomoyo_task_security_list
+[TOMOYO_MAX_TASK_SECURITY_HASH];
 extern struct mutex tomoyo_policy_lock;
-
-/* Has /sbin/init started? */
-extern bool tomoyo_policy_loaded;
-
+extern struct srcu_struct tomoyo_ss;
 extern struct tomoyo_domain_info tomoyo_acl_group[TOMOYO_MAX_ACL_GROUPS];
-
-/* The kernel's domain. */
 extern struct tomoyo_domain_info tomoyo_kernel_domain;
-
-extern const char *tomoyo_path_keyword[TOMOYO_MAX_PATH_OPERATION];
-extern const char *tomoyo_mkdev_keyword[TOMOYO_MAX_MKDEV_OPERATION];
-extern const char *tomoyo_path2_keyword[TOMOYO_MAX_PATH2_OPERATION];
-extern const char *tomoyo_path_number_keyword[TOMOYO_MAX_PATH_NUMBER_OPERATION];
-extern const char * const tomoyo_mode[TOMOYO_CONFIG_MAX_MODE];
-
 extern unsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];
 extern unsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];
 
-extern const u8 tomoyo_pnnn2mac[TOMOYO_MAX_MKDEV_OPERATION];
-extern const u8 tomoyo_pp2mac[TOMOYO_MAX_PATH2_OPERATION];
-extern const u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION];
-
-extern bool tomoyo_registered;
-
-/********** Inlined functions. **********/
+/* Inlined functions for internal use. */
 
+/**
+ * tomoyo_read_lock - Take lock for protecting policy.
+ *
+ * Returns index number for tomoyo_read_unlock().
+ */
 static inline int tomoyo_read_lock(void)
 {
 	return srcu_read_lock(&tomoyo_ss);
 }
 
+/**
+ * tomoyo_read_unlock - Release lock for protecting policy.
+ *
+ * @idx: Index number returned by tomoyo_read_lock().
+ *
+ * Returns nothing.
+ */
 static inline void tomoyo_read_unlock(int idx)
 {
 	srcu_read_unlock(&tomoyo_ss, idx);
 }
 
-/* strcmp() for "struct tomoyo_path_info" structure. */
+/**
+ * tomoyo_pathcmp - strcmp() for "struct tomoyo_path_info" structure.
+ *
+ * @a: Pointer to "struct tomoyo_path_info".
+ * @b: Pointer to "struct tomoyo_path_info".
+ *
+ * Returns true if @a == @b, false otherwise.
+ */
 static inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,
 				  const struct tomoyo_path_info *b)
 {
@@ -1001,6 +772,13 @@ static inline bool tomoyo_invalid(const 
 	return c && (c <= ' ' || c >= 127);
 }
 
+/**
+ * tomoyo_put_name - Drop reference on "struct tomoyo_name".
+ *
+ * @name: Pointer to "struct tomoyo_path_info". Maybe NULL.
+ *
+ * Returns nothing.
+ */
 static inline void tomoyo_put_name(const struct tomoyo_path_info *name)
 {
 	if (name) {
@@ -1010,19 +788,42 @@ static inline void tomoyo_put_name(const
 	}
 }
 
+/**
+ * tomoyo_put_group - Drop reference on "struct tomoyo_group".
+ *
+ * @group: Pointer to "struct tomoyo_group". Maybe NULL.
+ *
+ * Returns nothing.
+ */
 static inline void tomoyo_put_group(struct tomoyo_group *group)
 {
 	if (group)
 		atomic_dec(&group->head.users);
 }
 
-static inline bool tomoyo_same_name_union
-(const struct tomoyo_name_union *p1, const struct tomoyo_name_union *p2)
+/**
+ * tomoyo_same_name_union - Check for duplicated "struct tomoyo_name_union" entry.
+ *
+ * @a: Pointer to "struct tomoyo_name_union".
+ * @b: Pointer to "struct tomoyo_name_union".
+ *
+ * Returns true if @a == @b, false otherwise.
+ */
+static inline bool tomoyo_same_name_union(const struct tomoyo_name_union *p1,
+					  const struct tomoyo_name_union *p2)
 {
 	return p1->filename == p2->filename && p1->group == p2->group &&
 		p1->is_group == p2->is_group;
 }
 
+/**
+ * tomoyo_same_number_union - Check for duplicated "struct tomoyo_number_union" entry.
+ *
+ * @a: Pointer to "struct tomoyo_number_union".
+ * @b: Pointer to "struct tomoyo_number_union".
+ *
+ * Returns true if @a == @b, false otherwise.
+ */
 static inline bool tomoyo_same_number_union
 (const struct tomoyo_number_union *p1, const struct tomoyo_number_union *p2)
 {
@@ -1076,6 +877,43 @@ static inline int tomoyo_round2(size_t s
 #endif
 
 /**
+ * tomoyo_current_security - Get "struct tomoyo_security" for current thread.
+ *
+ * Returns pointer to "struct tomoyo_security" for current thread.
+ */
+static inline struct tomoyo_security *tomoyo_current_security(void)
+{
+	return tomoyo_find_task_security(current);
+}
+
+/**
+ * tomoyo_task_domain - Get "struct tomoyo_domain_info" for specified thread.
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns pointer to "struct tomoyo_security" for specified thread.
+ */
+static inline struct tomoyo_domain_info *tomoyo_task_domain
+(struct task_struct *task)
+{
+	struct tomoyo_domain_info *domain;
+	rcu_read_lock();
+	domain = tomoyo_find_task_security(task)->tomoyo_domain_info;
+	rcu_read_unlock();
+	return domain;
+}
+
+/**
+ * tomoyo_current_domain - Get "struct tomoyo_domain_info" for current thread.
+ *
+ * Returns pointer to "struct tomoyo_domain_info" for current thread.
+ */
+static inline struct tomoyo_domain_info *tomoyo_current_domain(void)
+{
+	return tomoyo_find_task_security(current)->tomoyo_domain_info;
+}
+
+/**
  * list_for_each_cookie - iterate over a list with cookie.
  * @pos:        the &struct list_head to use as a loop cursor.
  * @head:       the head for your list.
