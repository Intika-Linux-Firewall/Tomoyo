TOMOYO: Enable socket permission checks.

Enable permission check for socket operations.

Permission check for post accept() is emulated using other security_socket_*()
LSM hook. Permission check for post recvmsg() is not implemented due to lack of
security_socket_post_recvmsg() LSM hook.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/tomoyo.c |  252 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 252 insertions(+)

--- security-testing-2.6.orig/security/tomoyo/tomoyo.c
+++ security-testing-2.6/security/tomoyo/tomoyo.c
@@ -245,6 +245,247 @@ static int tomoyo_sb_pivotroot(struct pa
 	return tomoyo_path2_perm(TOMOYO_TYPE_PIVOT_ROOT, new_path, old_path);
 }
 
+/**
+ * tomoyo_validate_socket - Check post accept() permission if needed.
+ *
+ * @sock: Pointer to "struct socket".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_validate_socket(struct socket *sock)
+{
+	struct inode *inode = SOCK_INODE(sock);
+	int ret = PTR_ERR(inode->i_security);
+	if (ret <= 0)
+		/*
+		 * This socket is not an accept()ed socket or this socket is
+		 * an accept()ed socket and post accept() permission is done.
+		 */
+		return ret;
+	/*
+	 * Check post accept() permission now.
+	 *
+	 * Strictly speaking, we need to pass both listen()ing socket and
+	 * accept()ed socket to __tomoyo_socket_post_accept_permission().
+	 * But since socket's family and type are same for both sockets,
+	 * passing the accept()ed socket in place for the listen()ing socket
+	 * will work.
+	 */
+	ret = tomoyo_socket_post_accept_permission(sock, sock);
+	/*
+	 * If permission was granted, we forget that this is an accept()ed
+	 * socket. Otherwise, we remember that this socket needs to return
+	 * error for subsequent socketcalls.
+	 */
+	inode->i_security = ERR_PTR(ret);
+	return ret;
+}
+
+/**
+ * tomoyo_socket_accept - Check permission for accept().
+ *
+ * @sock:    Pointer to "struct socket".
+ * @newsock: Pointer to "struct socket".
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * This hook is used for setting up environment for doing post accept()
+ * permission check. TOMOYO's permission check is "which thread accept()s the
+ * connection from which source". No LSM hook can do it because the thread
+ * that accept()s the connection is not known until sock->ops->accept() is
+ * called. Even security_socket_accept() is not usable for TOMOYO because
+ *
+ *  (1) There is a race window when multiple threads using the same listen()ing
+ *      socket attempt to accept() the connection because there is no way to
+ *      serialize accept() operation. By error accept()ing the second
+ *      connection in the queue from unwanted source due to successful
+ *      permission check on the first connection in the queue from wanted
+ *      source is no good.
+ *  (2) There is a time lag (which can be longer than hours and days) between
+ *      security_socket_accept() and sock->ops->accept() when the socket queue
+ *      is empty and the operation is blocking mode; meanwhile policy can
+ *      change but there is no way to recheck permission using updated policy.
+ *  (3) select() on listen()ing socket saying "You will be able to pick up a
+ *      connection without blocking" and accept() on the same socket saying
+ *      "You cannot pick up the connection" will result in either busy loop
+ *      (if the thread did not close() the listen()ing socket) or give up all
+ *      established connections (if the thread close()s the listen()ing
+ *      socket). select() triggering consuming 100% CPU time is no good. Also,
+ *      one connection from unwanted source can destroy all other connections
+ *      from wanted sources is also no good.
+ *
+ * Therefore, we do post accept() permission check upon next socket syscalls
+ * rather than pre accept() permission check. This means that if a socket was
+ * close()d before calling some socket syscalls, post accept() permission check
+ * will not be done.
+ */
+static int tomoyo_socket_accept(struct socket *sock, struct socket *newsock)
+{
+	int rc = tomoyo_validate_socket(sock);
+	if (rc < 0)
+		return rc;
+	/*
+	 * Subsequent LSM hooks will receive "newsock". Therefore, I mark
+	 * "newsock" as "an accept()ed socket but post accept() permission
+	 * check is not done yet" by assigning a magic value ERR_PTR(1).
+	 */
+	SOCK_INODE(newsock)->i_security = ERR_PTR(1);
+	return 0;
+}
+
+/**
+ * tomoyo_socket_listen - Check permission for listen().
+ *
+ * @sock:    Pointer to "struct socket".
+ * @backlog: Backlog parameter.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_socket_listen(struct socket *sock, int backlog)
+{
+	int rc = tomoyo_validate_socket(sock);
+	if (rc < 0)
+		return rc;
+	return tomoyo_socket_listen_permission(sock);
+}
+
+/**
+ * tomoyo_socket_connect - Check permission for connect().
+ *
+ * @sock:     Pointer to "struct socket".
+ * @addr:     Pointer to "struct sockaddr".
+ * @addr_len: Size of @addr.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_socket_connect(struct socket *sock, struct sockaddr *addr,
+				 int addr_len)
+{
+	int rc = tomoyo_validate_socket(sock);
+	if (rc < 0)
+		return rc;
+	return tomoyo_socket_connect_permission(sock, addr, addr_len);
+}
+
+/**
+ * tomoyo_socket_bind - Check permission for bind().
+ *
+ * @sock:     Pointer to "struct socket".
+ * @addr:     Pointer to "struct sockaddr".
+ * @addr_len: Size of @addr.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_socket_bind(struct socket *sock, struct sockaddr *addr,
+			      int addr_len)
+{
+	int rc = tomoyo_validate_socket(sock);
+	if (rc < 0)
+		return rc;
+	return tomoyo_socket_bind_permission(sock, addr, addr_len);
+}
+
+/**
+ * tomoyo_socket_sendmsg - Check permission for sendmsg().
+ *
+ * @sock: Pointer to "struct socket".
+ * @msg:  Pointer to "struct msghdr".
+ * @size: Size of message.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+				 int size)
+{
+	int rc = tomoyo_validate_socket(sock);
+	if (rc < 0)
+		return rc;
+	return tomoyo_socket_sendmsg_permission(sock, msg, size);
+}
+
+/**
+ * tomoyo_socket_recvmsg - Check permission for recvmsg().
+ *
+ * @sock:  Pointer to "struct socket".
+ * @msg:   Pointer to "struct msghdr".
+ * @size:  Size of message.
+ * @flags: Flags.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_socket_recvmsg(struct socket *sock, struct msghdr *msg,
+				 int size, int flags)
+{
+	return tomoyo_validate_socket(sock);
+}
+
+/**
+ * tomoyo_socket_getsockname - Check permission for getsockname().
+ *
+ * @sock: Pointer to "struct socket".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_socket_getsockname(struct socket *sock)
+{
+	return tomoyo_validate_socket(sock);
+}
+
+/**
+ * tomoyo_socket_getpeername - Check permission for getpeername().
+ *
+ * @sock: Pointer to "struct socket".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_socket_getpeername(struct socket *sock)
+{
+	return tomoyo_validate_socket(sock);
+}
+
+/**
+ * tomoyo_socket_getsockopt - Check permission for getsockopt().
+ *
+ * @sock:    Pointer to "struct socket".
+ * @level:   Level.
+ * @optname: Option's name,
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_socket_getsockopt(struct socket *sock, int level,
+				    int optname)
+{
+	return tomoyo_validate_socket(sock);
+}
+
+/**
+ * tomoyo_socket_setsockopt - Check permission for setsockopt().
+ *
+ * @sock:    Pointer to "struct socket".
+ * @level:   Level.
+ * @optname: Option's name,
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_socket_setsockopt(struct socket *sock, int level,
+				    int optname)
+{
+	return tomoyo_validate_socket(sock);
+}
+
+/**
+ * tomoyo_socket_shutdown - Check permission for shutdown().
+ *
+ * @sock: Pointer to "struct socket".
+ * @how:  Shutdown mode.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_socket_shutdown(struct socket *sock, int how)
+{
+	return tomoyo_validate_socket(sock);
+}
+
 /*
  * tomoyo_security_ops is a "struct security_operations" which is used for
  * registering TOMOYO.
@@ -275,6 +516,17 @@ static struct security_operations tomoyo
 	.sb_mount            = tomoyo_sb_mount,
 	.sb_umount           = tomoyo_sb_umount,
 	.sb_pivotroot        = tomoyo_sb_pivotroot,
+	.socket_bind         = tomoyo_socket_bind,
+	.socket_connect      = tomoyo_socket_connect,
+	.socket_listen       = tomoyo_socket_listen,
+	.socket_sendmsg      = tomoyo_socket_sendmsg,
+	.socket_recvmsg      = tomoyo_socket_recvmsg,
+	.socket_getsockname  = tomoyo_socket_getsockname,
+	.socket_getpeername  = tomoyo_socket_getpeername,
+	.socket_getsockopt   = tomoyo_socket_getsockopt,
+	.socket_setsockopt   = tomoyo_socket_setsockopt,
+	.socket_shutdown     = tomoyo_socket_shutdown,
+	.socket_accept       = tomoyo_socket_accept,
 };
 
 /* Lock for GC. */
