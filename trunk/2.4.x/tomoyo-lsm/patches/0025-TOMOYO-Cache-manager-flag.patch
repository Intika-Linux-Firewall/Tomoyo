Subject: TOMOYO: Cache manager flag into per "struct task_struct" variables.

Since it is a waste of time to test whether current thread is allowed to modify
policy via /sys/kernel/security/tomoyo/ interface by calculating pathname and
compare it, store it when it was authorized for the first time into per a
"struct task_struct" variables. It is cleared upon do_execve() request.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.c |   34 ++++++++++++++++------------------
 security/tomoyo/common.h |    8 ++++++++
 security/tomoyo/domain.c |    3 +++
 3 files changed, 27 insertions(+), 18 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/common.c
+++ security-testing-2.6/security/tomoyo/common.c
@@ -683,35 +683,33 @@ static bool tomoyo_manager(void)
 {
 	struct tomoyo_manager *ptr;
 	const char *exe;
-	const struct task_struct *task = current;
+	struct tomoyo_security *task = tomoyo_current_security();
 	const struct tomoyo_path_info *domainname
 		= tomoyo_current_domain()->domainname;
 	bool found = false;
 
 	if (!tomoyo_policy_loaded)
 		return true;
-	if (!tomoyo_manage_by_non_root && (task->cred->uid || task->cred->euid))
-		return false;
-	list_for_each_entry_rcu(ptr, &tomoyo_policy_list[TOMOYO_ID_MANAGER],
-				head.list) {
-		if (!ptr->head.is_deleted && ptr->is_domain
-		    && !tomoyo_pathcmp(domainname, ptr->manager)) {
-			found = true;
-			break;
-		}
-	}
-	if (found)
+	if (task->tomoyo_flags & TOMOYO_TASK_IS_MANAGER)
 		return true;
-	exe = tomoyo_get_exe();
-	if (!exe)
+	if (!tomoyo_manage_by_non_root && (current_uid() || current_gid()))
 		return false;
+	exe = tomoyo_get_exe();
 	list_for_each_entry_rcu(ptr, &tomoyo_policy_list[TOMOYO_ID_MANAGER],
 				head.list) {
-		if (!ptr->head.is_deleted && !ptr->is_domain
-		    && !strcmp(exe, ptr->manager->name)) {
-			found = true;
-			break;
+		if (ptr->head.is_deleted)
+			continue;
+		if (ptr->is_domain) {
+			if (tomoyo_pathcmp(domainname, ptr->manager))
+				continue;
+		} else {
+			if (!exe || strcmp(exe, ptr->manager->name))
+				continue;
 		}
+		/* Set manager flag. */
+		task->tomoyo_flags |= TOMOYO_TASK_IS_MANAGER;
+		found = true;
+		break;
 	}
 	if (!found) { /* Reduce error messages. */
 		static pid_t last_pid;
--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -241,6 +241,12 @@ enum tomoyo_value_type {
 #define TOMOYO_TASK_SECURITY_HASH_BITS 12
 #define TOMOYO_MAX_TASK_SECURITY_HASH (1u << TOMOYO_TASK_SECURITY_HASH_BITS)
 
+/*
+ * Current thread is allowed to modify policy via /sys/kernel/security/tomoyo/
+ * interface?
+ */
+#define TOMOYO_TASK_IS_MANAGER 1
+
 /* Structure definition for internal use. */
 
 /* Common header for holding ACL entries. */
@@ -563,6 +569,8 @@ struct tomoyo_security {
 	 * member but any threads can read this member under RCU.
 	 */
 	struct tomoyo_domain_info *tomoyo_domain_info;
+	/* Holds current thread's attributes. */
+	u32 tomoyo_flags;
 	/*
 	 * Holds previous tomoyo_domain_info during do_execve() in case
 	 * do_execve() failed, NULL otherwise. Only current thread can access
--- security-testing-2.6.orig/security/tomoyo/domain.c
+++ security-testing-2.6/security/tomoyo/domain.c
@@ -484,6 +484,9 @@ int tomoyo_find_next_domain(struct linux
 	bool need_kfree = false;
 	struct tomoyo_path_info rn = { }; /* real name */
 
+	/* Clear manager flag. */
+	security->tomoyo_flags &= ~TOMOYO_TASK_IS_MANAGER;
+
 	mode = tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_EXECUTE);
 	is_enforce = (mode == TOMOYO_CONFIG_ENFORCING);
 	if (!tmp)
