<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=shift_jis">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linux導入手順</title>
<link rel="stylesheet" href="tomoyo.css" media="all" type="text/css">
</head>
<body>
<h1>TOMOYO Linux導入手順</h1>
<p style="text-align:right;">Last modified: $Date$ UT</p>

<h1>目次</h1>

<ul>
<li><a href="#preparation">準備</a>
<li>　<a href="#install-kernel">カーネルのインストール</a>
<li>　<a href="#install-tool">ツールのインストール</a>
<li>　<a href="#boot-test">起動テスト</a>
<li>　<a href="#decide-control-range">制御範囲の決定</a>
<li>　<a href="#design-login-operation">ログインして行う操作の設計</a>
<li>　<a href="#protect-device">デバイスファイルの保護（任意）</a>
<li><a href="#policy-preparation">ポリシーの作成準備</a>
<li>　<a href="#example_policy">デフォルトポリシーについて</a>
<li>　<a href="#manager-programs">ポリシーの変更を許可するプログラムの指定</a>
<li>　<a href="#patch-shutdown">シャットダウン処理の修正</a>
<li>　<a href="#audit-logs">監査ログの取得準備</a>
<li>　<a href="#create-profiles">プロファイルの作成</a>
<li>　<a href="#create-exceptions">例外ポリシーの作成</a>
<li>　　<a href="#exception-logrotate">logrotate への対応</a>
<li>　　<a href="#exception-prelink">prelink への対応</a>
<li>　　<a href="#exception-anacron">anacron への対応</a>
<li>　　<a href="#exception-cron">cron への対応</a>
<li>　<a href="#exception-targeted-policy">Targeted Policy への対応</a>
<li><a href="#generate-policy">ポリシーの作成</a>
<li>　<a href="#accept-mode-1">学習モード</a>
<li>　　<a href="#accept-logrotate">logrotate への対応</a>
<li>　　<a href="#accept-anacron">anacron への対応</a>
<li>　<a href="#update-exception">例外ポリシーの更新</a>
<li>　<a href="#accept-mode-2">学習モード</a>
<li><a href="#tune-policy">ポリシーのチューニング</a>
<li>　<a href="#add-from-audit-logs">監査ログからの生成</a>
<li>　<a href="#make-pathname-patterns">アクセス許可のパターン化</a>
<li>　<a href="#make-network-patterns">ネットワークのパターン化</a>
<li>　<a href="#add-conditional-policy">アクセス許可条件の付与</a>
<li>　<a href="#permissive-mode">確認モード</a>
<li><a href="#production-state">ポリシーの利用</a>
<li>　<a href="#enforce-mode">強制モード</a>
</ul>
<hr>

<h1><a name="preparation">準備</a></h1>

<p>使用するディストリビューションの制限はありません。しかし、全てのディストリビューションで共通に使える手順書を作成することはできないため、この手順書では「RedHat Linux 9」「Fedora Core 3」「Debian Sarge」の３種類について記述します。</p>

<p>不要なアプリケーションは事前にアンインストールしておくことで、ポリシーのサイズを小さくすることができます。
どのアプリケーションが必要かを事前に把握しておくことを推奨します。</p>

<h2><a name="install-kernel">カーネルのインストール</a></h2>

<p>TOMOYO Linux では、いくつかのコンパイル済みのカーネルをパッケージにして提供しています。コンパイル済みのカーネルを利用する場合は、以下のファイルをダウンロードしてインストールしてください。</p>

<table border="1">
<tr><td>
RedHat Linux 9 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.4.20-46.9.legacy_tomoyo_1.2.i386.rpm
</td></tr><tr><td>
Fedora Core 3 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.12-2.3.legacy_FC3_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Fedora Core 4 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.17-1.2142_FC4_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Fedora Core 5 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.18-1.2200_FC5_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Fedora Core 6 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.18-1.2798_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
CentOS 4.4 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.9-42.0.3.EL_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Debian Sarge （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-image-2.4.27-10sarge4-ccs_1.2_i586.deb<br>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-image-2.6.8-16sarge5-ccs_1.2_i586.deb
</td></tr><tr><td>
OpenSUSE 10.1 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-default-2.6.16.21-0.25_tomoyo_1.2.i586.rpm
</td></tr>
</table>

<p>アーキテクチャが異なる場合やカスタマイズしたい場合には、カーネルをコンパイルする必要があります。カーネルをコンパイルする方法については、<a href="compile.html">TOMOYO Linuxカーネルの作成手順</a>を参照してください。</p>

<h2><a name="install-tool">ツールのインストール</a></h2>

<p>TOMOYO Linux では、いくつかのコンパイル済みのツールを提供しています。コンパイル済みのツールを利用する場合は、以下のファイルをダウンロードして /root/ ディレクトリの下に展開してください。</p>

<table border="1">
<tr><td>
RedHat Linux 9 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-RHL9.tar.gz
</td></tr><tr><td>
Fedora Core 3 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC3.tar.gz
</td></tr><tr><td>
Fedora Core 4 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC4.tar.gz
</td></tr><tr><td>
Fedora Core 5 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC5.tar.gz
</td></tr><tr><td>
Fedora Core 6 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC6.tar.gz
</td></tr><tr><td>
CentOS 4.4 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-CentOS4.4.tar.gz
</td></tr><tr><td>
Debian Sarge （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-Sarge.tar.gz
</td></tr><tr><td>
OpenSUSE 10.1 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-SUSE10.1.tar.gz
</td></tr>
</table>

<p>アーキテクチャが異なる場合には、ツールをコンパイルする必要があります。ツールをコンパイルするには、以下のコマンドを実行してください。</p>

<table border="1">
<tr><td>
# TOMOYO Linux ツールのソースをダウンロードする。<br>
wget http://osdn.dl.sourceforge.jp/tomoyo/21579/ccs-tools-1.2-20060903.tar.gz<br>
# 展開する。<br>
tar -zxf ccs-tools-1.2-20060903.tar.gz<br>
# コンパイルする。<br>
make -sC ccstools/
</td></tr>
</table>

<h2><a name="boot-test">起動テスト</a></h2>

<p>TOMOYO Linux カーネルで起動して、正常に動作できることを確認できたら、 /proc/ccs/status の内容を /root/security/status.txt というファイルに保存しておいてください。このファイルに含まれる項目が、このカーネルで制御できる項目になります。このファイルは、後述する手順でプロファイルを作成する際のヒントとして使用します。</p>

<table border="1">
<tr><td>
mkdir -p /root/security<br>
cat /proc/ccs/status &gt; /root/security/status.txt
</td></tr>
</table>

<h2><a name="decide-control-range">制御範囲の決定</a></h2>

<p>TOMOYO Linux のドメイン単位のアクセス制御機能（TOMOYO (Domain-Based Mandatory Access Control) support）は、 /sbin/init の開始時から電源が切れるまでの間に実行される全てのソフトウェアを対象に適用することが可能です。しかし、 http サーバや ssh サーバなど、特定のソフトウェアだけを対象に適用することも可能です。</p>
<p>以後、全てのソフトウェアを対象とするポリシーを Strict Policy 、特定のソフトウェアだけを対象とするポリシーを Targeted Policy と呼びます。</p>

<p>全てのソフトウェアを対象に適用する方がより安全ですが、特定のソフトウェアだけを対象に適用する方が簡単です。
この時点で、アクセス制御機能を適用する範囲を決定してください。</p>

<p>なお、 TOMOYO Linux のシステム全体のアクセス制御機能（SAKURA (Domain-Free Mandatory Access Control) support）および
デバイスファイルの改ざん防止機能（SYAORAN (Tamper-Proof Device Filesystem) support）は、全てのソフトウェアを対象に適用されます。</p>

<h2><a name="design-login-operation">ログインして行う操作の設計</a></h2>

<p>メンテナンスなどのために、サーバへ ssh でログインして作業を行うことがあると思います。そこで、このステップでは、ログインしてどのような操作を行うかを決定します。</p>

<table border="1">
<tr><td>
<h3>ログイン認証の強化（任意）</h3>

<p>ssh を使用してログインする際のセキュリティを向上させるのが目的です。この手順は任意ですが、簡単に実現できるので活用することを推奨します。</p>

<p>TOMOYO Linux では、 SELinux のように sshd を改造してバッファオーバーフロー対策などを行うことはできません。 そのため、 sshd または認証モジュールに脆弱性が存在した場合、 SELinux よりも簡単に侵入を許してしまいます。
しかし、脅威はバッファオーバーフローなどだけではありません。正規のユーザ名とパスワードを使用してログインされるという可能性も存在します。 ssh でログインする場合、パスワードまたは公開鍵認証を使用している場合が圧倒的に多いと思います。しかし、<a href="http://itpro.nikkeibp.co.jp/article/NEWS/20051107/224128/">ブルートフォース攻撃により侵入されてフィッシングなどに悪用される</a>などの被害が増えてきています。そのため、ログイン認証は突破されることを前提として、追加のログイン認証が行われるようにすることが大切です。 詳細については、論文「<a href="http://sourceforge.jp/projects/tomoyo/document/winf2005.pdf">セキュリティ強化OSによるログイン認証の強化手法</a>」を参照してください。</p>

<p>追加的な防御手段で使用するプログラムは、管理者が自由な仕様で作成することができます。 この段階でそのためのプログラムを作成して、意図したとおりの使い方ができることを確認しておいてください。</p>

<p>ログイン認証を複数回行えるようにすることで、資源の保護レベルに応じたアクセス制限も提供できるようになります。通常は下の図のようにログイン認証を通過しただけで、重要に保護する必要のある資源にもその必要が無い資源にもアクセスできてしまいます。</p>

<img src="Normal-Auth.png" width="611" height="456" alt="Normal Authentication">

<p>しかし、下の図のように /opt/bin/auth1 および /opt/bin/auth2 という認証を追加することにより、ログイン認証を通過しただけなら厳重に保護する必要の無い資源へのアクセスのみを許可し、全ての認証を通過した場合のみ厳重に保護しなければいけない資源へのアクセスも許可することが可能になります。</p>

<img src="Chained-Auth.png" width="611" height="456" alt="Chained Authentication">

</td></tr><tr><td>

<h3>管理者権限を必要とする業務の一部委託（任意）</h3>

<p>サーバ管理業務の一部だけを他人に委託したい場合に使用します。 例えば、 HTTP サーバのコンテンツの管理と httpd プロセスの再起動のみを委託したい場合に利用します。</p>

<p>管理者としてログインしてもらい、前述した「ログイン認証の強化」で使用したプログラムと組み合わせることで、委託された人だけがその業務をできるようにすることができます。この段階で、誰にどの業務を委託するかを決定し、どのようにドメインを分割するかを設計し、ドメインの分割点として使用するためのプログラムを決定します。 /bin/bash や /bin/tcsh をドメインの分割点として使用するためのプログラムとして利用することも可能ですが、無断で他人の担当業務用のドメインに遷移できてしまうので望ましくありません。 そのため、「ログイン認証の強化」で説明したのと同じ要領で認証機構を備えたプログラムを作成して、意図したとおりの使い方ができることを確認しておいてください。</p>

<p>例えば、システム上に SAKURA TOMOYO SYAORAN CERBERUS YUE というユーザが登録されており、それぞれが ssh でログインして作業を行う場合に、下の図のようにドメインを分割することによりユーザ単位のアクセス許可を登録できます。</p>

<img src="Embed-User.png" width="611" height="456" alt="Embedding User">

<p>同様に、例えばシステム上で manager webmaster auditor user anonymous というロールが必要であり、それぞれが ssh でログインして作業を行う場合に、下の図のようにドメインを分割することによりロール単位のアクセス許可を登録できます。</p>

<img src="Embed-Role.png" width="611" height="456" alt="Embedding Role">

</td></tr>
</table>

<h2><a name="protect-device">デバイスファイルの保護（任意）</a></h2>

<p>デバイスファイルの改ざん防止機能（SYAORAN (Tamper-Proof Device Filesystem) support）を利用する場合、この時点で設定を行います。</p>

<p>以下の操作を行い、/.syaoranというスクリプトを作成します。</p>

<table border="1">
<tr><td>
echo '#! /bin/sh' &gt; /.syaoran<br>
echo 'mount -n -t syaoran -o accept=/root/security/syaoran.conf none /dev' &gt;&gt; /.syaoran<br>
echo 'exec /sbin/init "$@"' &gt;&gt; /.syaoran<br>
chmod 700 /.syaoran
</td></tr>
</table>

<p>/sbin/init を起動する直前にマウントされるようにするために、 TOMOYO Linux カーネルの起動時に init=/.syaoran というパラメータを追加してください。毎回指定するのは面倒なので、ブートローダの設定ファイルで指定しておくことを推奨します。</p>

<p>以下の操作を行い、全てのエントリを含んだ初期状態の /root/security/syaoran.conf を作成します。</p>

<table border="1">
<tr><td>
/root/ccstools/makesyaoranconf &gt; /root/security/syaoran.conf<br>
</td></tr>
</table>

<p>udev を使用するディストリビューションの場合は、以下の操作も行ってください。</p>

<table border="1">
<tr><td>
echo DENY_CONCEAL_MOUNT=3 &gt; /root/security/profile0.txt
</td></tr>
</table>

<p>TOMOYO Linux カーネルで再起動してシステムを稼動させると、実際にオープンされたデバイスファイルだけが学習されていきます。学習結果はマウントポイント直下の .syaoran というファイルから取り出すことができます。</p>

<p>以下の２点に注意する必要があります。</p>

<p>スワップパーティション用のデバイスファイルはマウントされる際にオープンされないため、何らかの方法で明示的にオープンしないと .syaoran から除外されてしまい、スワップパーティションをマウントできなくなります。以下のコマンドを実行してスワップパーティションを明示的にオープンするようにしてください。（スワップパーティション用のデバイスファイルが /dev/sda3 の場合です。実際のスワップパーティション名にあわせて読み替えてください。）</p>

<table border="1">
<tr><td>
touch /dev/sda3
</td></tr>
</table>

<p>ssh ログインで pty の使用を許可したい場合は必ず一度ログインしてください。 ssh ログインをしないと /dev/ptmx がオープンされないため、 .syaoran から除外されてしまい、ssh ログインした際に pty を使うことができなくなります。</p>

<table border="1">
<tr><td>
ssh localhost
</td></tr>
</table>

<p>以下のコマンドを実行して、学習結果を /root/security/syaoran.conf に反映します。</p>

<table border="1">
<tr><td>
cat /dev/.syaoran &gt; /root/security/syaoran.conf
</td></tr>
</table>

<p>TOMOYO Linux カーネルで再起動し、必要なエントリが全て含まれていることを確認してください。
もし、システムが正常に動作しない場合は、必要なエントリが削除されてしまった可能性がありますので、初期状態の /root/security/syaoran.conf を作成するところからやり直してください。</p>

<p>/root/security/syaoran.conf に含まれているデッドリンクや不要なディレクトリは削除しても構いません。ただし、マウントポイント（通常は shm と pts ディレクトリ）を削除しないように注意してください。</p>

<h1><a name="policy-preparation">ポリシーの作成準備</a></h1>

<p>この章の作業は通常のカーネルで行うようにしてください。<br>
TOMOYO Linux カーネルで行うと、シャットダウン時に /root/ccstools/savepolicy が実行されるために /root/security/exception_policy.txt に加えた変更内容が失われてしまいます。</p>

<h2><a name="example_policy">デフォルトポリシーについて</a></h2>
<p>TOMOYO Linux には、ソフトウェアと一緒に配布されるデフォルトポリシーはありません。学習モードを使用して策定する必要があります。<br>
参考までに、<a href="http://tomoyo.sourceforge.jp/example_policy/">サンプルのポリシー</a>を置いてあります。参照は自由ですが、デフォルトポリシーとしての利用はしないでください。</p>

<h2><a name="manager-programs">ポリシーの変更を許可するプログラムの指定</a></h2>

<p>/root/security/manager.txt を作成し、その中にポリシーの変更を許可したいプログラムを指定します。<br>
具体的には、ポリシーを再読み込みする loadpolicy 、ポリシーを編集する editpolicy 、制御レベルを変更する setlevel 、無条件読み込み許可を更新する ld-watch 、対話的にアクセス要求を許可する ccs-queryd の５つを指定してください。</p>
<table border="1">
<tr><td>
cat &gt; /root/security/manager.txt &lt;&lt; EOF<br>
/root/ccstools/loadpolicy<br>
/root/ccstools/editpolicy<br>
/root/ccstools/setlevel<br>
/root/ccstools/ld-watch<br>
/root/ccstools/ccs-queryd<br>
EOF<br></td>
</tr>
</table>

<h2><a name="patch-shutdown">シャットダウン処理の修正</a></h2>

<p>電源が切れる直前にメモリ上のポリシーをディスク上に保存するために、シャットダウンスクリプトの中で /root/ccstools/savepolicy が実行されるように修正します。具体的な修正箇所はディストリビューション毎に異なります。多くの場合、 /etc/init.d/ ディレクトリ直下にあるシャットダウンを行うスクリプトの最後に実行されるプログラムが電源を切るためのプログラムなので、その直前で保存するように修正します。</p>

<p>RedHat Linux 9 および Fedora Core 3 の場合は以下のように修正してください。</p>

<table border="1">
<tr><td colspan="2">/etc/rc.d/init.d/halt</td></tr>
<tr><td>修正前</td><td>修正後</td></tr>
<tr><td>
<br>
exec $command $HALTARGS
</td><td>
/root/ccstools/savepolicy<br>
exec $command $HALTARGS
</td></tr>
</table>

<p>Debian Sarge の場合は以下のように修正してください。 savepolicy の前に halt/reboot を一度実行しているのは halt/reboot を実行するドメインを作成するためです。</p>

<table border="1">
<tr><td colspan="2">/etc/init.d/halt</td><td colspan="2">/etc/init.d/reboot</td></tr>
<tr><td>修正前</td><td>修正後</td><td>修正前</td><td>修正後</td></tr>
<tr><td>
<br>
<br>
halt -d -f -i $poweroff $hddown
</td><td>
halt --help 2&gt; /dev/null<br>
/root/ccstools/savepolicy<br>
halt -d -f -i $poweroff $hddown
</td><td>
<br>
<br>
reboot -d -f -i
</td><td>
reboot --help 2&gt; /dev/null<br>
/root/ccstools/savepolicy<br>
reboot -d -f -i
</td></tr>
</table>

<h2><a name="audit-logs">監査ログの取得準備</a></h2>

<p>ドメイン単位のアクセス制御機能に関して、アクセスが許可された要求のログ（アクセス許可ログ）とアクセスが拒否された要求のログ（アクセス拒否ログ）を取得することができます。
取得したログは、そのままドメイン用ポリシーとして追加可能な形式になっています。
アクセス拒否ログの内容を吟味して、許可すべきであればドメイン用ポリシーに追加します。</p>

<p>アクセス許可ログとアクセス拒否ログをカーネルから読み出してファイルに保存する為に、 ccs-auditd というデーモンプログラムを利用できます。以下のコマンドを /etc/rc.local 等から実行するようにしてください。</p>

<table border="1">
<tr><td>
/root/ccstools/ccs-auditd アクセス許可ログの保存場所 アクセス拒否ログの保存場所
</td></tr>
</table>

<p>アクセス許可ログを保存する必要が無い場合は、保存場所として /dev/null を指定することができます。 ccs-auditd にはフィルタリング機能がありませんので、アクセス許可ログを保存する場合はディスク容量に注意してください。</p>

<p>アクセス拒否ログを保存する必要が無い場合は、保存場所として /dev/null を指定することができます。</p>

<p>どちらも保存しない場合は ccs-auditd を実行する必要はありませんが、アクセス拒否ログは保存しておくことを推奨します。
この手順書では、アクセス拒否ログを /var/log/tomoyo/reject_log.txt に保存するものとします。</p>

<table border="1">
<tr><td>
/root/ccstools/ccs-auditd /dev/null /var/log/tomoyo/reject_log.txt
</td></tr>
</table>

<p>アクセスログを保存するディレクトリは予め作成しておいてください。</p>

<table border="1">
<tr><td>
mkdir -p /var/log/tomoyo
</td></tr>
</table>

<p>logrotate によるローテーションを行わせたい場合は、以下のような内容のファイルを /etc/logrotate.d/tomoyo に作成してください。</p>

<table border="1">
<tr><td>
/var/log/tomoyo/reject_log.txt {<br>
&nbsp;&nbsp;weekly<br>
&nbsp;&nbsp;rotate 9<br>
&nbsp;&nbsp;missingok<br>
&nbsp;&nbsp;notifempty<br>
&nbsp;&nbsp;nocreate<br>
}
</td></tr>
</table>

<h2><a name="create-profiles">プロファイルの作成</a></h2>

<p>TOMOYO Linuxでは、ファイル以外にもいくつかの項目について強制アクセス制御を行うことができますが、ポリシー管理の負担を減らすために、必要の無い機能を無効化できるようになっています。</p>

<p>有効にしたい機能とそのモードを記述した初期制御レベル定義ファイルを１つ以上作成し、カーネル起動時のコマンドラインから番号を指定することで切り替えができるようになっています。具体的には、カーネル起動時のコマンドラインで CCS=$INDEX （$INDEX は整数）というパラメータを指定すると、対応する /root/security/profile$INDEX.txt が読み込まれます。</p>

<p>以下の説明を参照しながら、用途毎のプロファイルを作成してください。 /root/security/status.txt に含まれる項目だけが指定可能です。 /root/security/status.txt に含まれる項目の数は、カーネルコンパイル時の設定により変化します。</p>

<table border="1">
<tr><td>項目</td><td>制御する内容</td><td>自動学習対応</td></tr>
<tr><td>MAC_FOR_FILE</td><td>ファイルの読み書き実行</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::inet_tcp_create</td><td>TCP ソケットの使用</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::inet_tcp_listen</td><td>TCP ソケットの listen</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::inet_tcp_connect</td><td>TCP ソケットの connect</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::use_inet_udp</td><td>UDP ソケットの使用</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::use_inet_ip</td><td>RAW ソケットの使用</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::use_route</td><td>ROUTE ソケットの使用</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::use_packet</td><td>PACKET ソケットの使用</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::use_kernel_module</td><td>カーネルモジュールの使用</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::create_fifo</td><td>FIFO の作成</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::create_block_dev</td><td>ブロック型デバイスの作成</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::create_char_dev</td><td>キャラクタ型デバイスの作成</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::create_unix_socket</td><td>UNIX ドメインソケットの作成</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_MOUNT</td><td>ファイルシステムのマウント</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_UMOUNT</td><td>ファイルシステムのアンマウント</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_REBOOT</td><td>システムの再起動</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_CHROOT</td><td>ルートディレクトリの変更</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_KILL</td><td>シグナルの送信</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_VHANGUP</td><td>vhangup の使用</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_TIME</td><td>システム時刻の変更</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_NICE</td><td>プロセスの優先度の変更</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_SETHOSTNAME</td><td>ホスト名・ドメイン名の変更</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_LINK</td><td>ハードリンクの作成</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_SYMLINK</td><td>シンボリックリンクの作成</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_RENAME</td><td>ファイル名の変更</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_UNLINK</td><td>ファイルの削除</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_CHMOD</td><td>ファイルのパーミッションの変更</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_CHOWN</td><td>ファイルの所有者・グループの変更</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_IOCTL</td><td>ioctl の使用</td><td>○</td></tr>
<tr><td>MAC_FOR_CAPABILITY::SYS_KEXEC_LOAD</td><td>新しいカーネルのロード</td><td>○</td></tr>
<tr><td>MAC_FOR_NETWORK</td><td>プログラムが使用できるＩＰアドレスとポート番号</td><td>○</td></tr>
<tr><td>MAC_FOR_BINDPORT</td><td>プログラムが使用できるローカルポート番号</td><td>○</td></tr>
<tr><td>MAC_FOR_CONNECTPORT</td><td>プログラムが使用できるリモートポート番号</td><td>○</td></tr>
<tr><td>MAC_FOR_SIGNAL</td><td>自分自身以外へのシグナルの送信</td><td>○</td></tr>
<tr><td>DENY_CONCEAL_MOUNT</td><td>既存のマウントを隠蔽するようなマウントの禁止</td><td>×</td></tr>
<tr><td>RESTRICT_CHROOT</td><td>chroot で移動可能なディレクトリ</td><td>○</td></tr>
<tr><td>RESTRICT_MOUNT</td><td>マウント可能な「デバイスファイルとマウントポイントとファイルシステム」の組み合わせ</td><td>○</td></tr>
<tr><td>RESTRICT_UNMOUNT</td><td>指定されたディレクトリのアンマウントの禁止</td><td>×</td></tr>
<tr><td>DENY_PIVOT_ROOT</td><td>pivot_root 呼び出しの禁止</td><td>×</td></tr>
<tr><td>RESTRICT_AUTOBIND</td><td>TCP/IP ネットワークで自動的に割り当てられるローカルポート</td><td>×</td></tr>
<tr><td>TRACE_READONLY</td><td>ファイルシステムが読み込み専用であることで失敗したファイル名を表示する。</td><td>−</td>
</tr>
<tr><td>MAX_ACCEPT_FILES</td><td>学習モードで自動的に追加されるアクセス許可の上限を指定する。</td><td>−</td></tr>
<tr><td>MAX_GRANT_LOG</td><td>メモリ上に保持するアクセス許可ログの上限を指定する。</td><td>−</td></tr>
<tr><td>MAX_REJECT_LOG</td><td>メモリ上に保持するアクセス拒否ログの上限を指定する。</td><td>−</td></tr>
<tr><td>TOMOYO_VERBOSE</td><td>ドメイン別ポリシーに対する違反を syslog に表示する。</td><td>−</td></tr>
<tr><td>MAX_ENFORCE_GRACE</td><td>強制モードでポリシー違反が発生した場合に、アクセス要求を拒否するまでの猶予時間を指定する。</td><td>−</td></tr>
</table>

<p>TRACE_READONLY および RESTRICT_AUTOBIND については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>0</td><td>無効。通常のカーネルと同様に動作する。</td></tr>
<tr><td>1</td><td>有効。</td></tr>
</table>

<p>MAX_ACCEPT_FILES については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>任意の整数</td><td>学習モードで自動的に追加されるアクセス許可の上限。デフォルトはカーネルのコンパイル時に指定。</td></tr>
</table>

<p>MAX_GRANT_LOG および MAX_REJECT_LOG については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>任意の整数</td><td>カーネル内に保持するアクセスログの件数。デフォルトはカーネルのコンパイル時に指定。ログが不要ならば 0 を指定する。</td></tr>
</table>

<p>TOMOYO_VERBOSE については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>0</td><td>ドメイン別ポリシーに対する違反を表示しない。</td></tr>
<tr><td>1</td><td>ドメイン別ポリシーに対する違反を表示する。</td></tr>
</table>

<p>MAX_ENFORCE_GRACE については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>任意の整数</td><td>強制モードで動作中にポリシー違反が発生してから、そのアクセス要求を拒否するまでの猶予期間を秒単位で指定する。この時間内に管理者がそのアクセス要求を許可するように指示した場合、そのアクセス要求は許可される。</td></tr>
</table>

<p>上記以外については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>0</td><td>無効。通常のカーネルと同様に動作する。</td></tr>
<tr><td>1</td><td>学習モード。ポリシーに違反しても警告をエラーにせず、ポリシーへの自動追加を行う。</td></tr>
<tr><td>2</td><td>許容モード。ポリシーに違反してもエラーにせず、ポリシーへの自動追加も行わない。</td></tr>
<tr><td>3</td><td>強制モード。ポリシーに違反したらエラーとする。</td></tr>
</table>

<p>udev を使用するディストリビューションで SYAORAN ファイルシステムを利用している場合は、 DENY_CONCEAL_MOUNT=3 を指定してください。</p>
<p>以下に例を示します。</p>
<table border="1">
<tr><td>/root/security/profile1.txt</td><td>/root/security/profile2.txt</td><td>/root/security/profile3.txt</td></tr>
<tr><td>
MAC_FOR_FILE=1
</td><td>
DENY_CONCEAL_MOUNT=3<br>
MAC_FOR_FILE=2<br>
TOMOYO_VERBOSE=1
</td><td>
DENY_CONCEAL_MOUNT=3<br>
MAC_FOR_FILE=3<br>
TOMOYO_VERBOSE=1
</td></tr>
</table>

<h2><a name="create-exceptions">例外ポリシーの作成</a></h2>

<p>全てのシステムに共通して存在している可能性が高いパス名のパターンを事前に登録しておきます。<br>
/root/security/exception_policy.txt に file_pattern というキーワードを使用してパス名のパターンを登録します。<br>
アクセス許可を学習する際に、要求されたパス名が file_pattern というキーワードを使用して登録されたパス名のパターンと一致した場合、パターン化されたパス名でアクセス許可が学習されます。<br>
目安としては以下のものが挙げられます。</p>

<ul>
<li>/proc/PID/ ディレクトリ以下に存在するファイルのパス名
<li>/sys/ ディレクトリ以下に存在するファイルのパス名（カーネル 2.6 系の場合のみ）
<li>/dev/ ディレクトリ以下の一部のパス名
<li>ポリシーファイルのパス名
<li>マニュアルページのパス名
<li>スプールディレクトリのパス名
<li>メールの送受信時に作成されるテンポラリファイルのパス名
<li>man コマンドが作成するテンポラリファイルのパス名
<li>mount コマンドが作成するテンポラリファイルのパス名
</ul>

<p>システムにインストールされているアプリケーションやその設定により、上記以外にもパターン化されたパス名が必要になります。不足しているパターンは実際にアクセス許可を学習させてから、適切にパターン化して追加します。</p>

<p>全てのプログラムへの読み込みアクセスを許可するファイルを登録しておきます。<br>
/root/security/exception_policy.txt に allow_read というキーワードを使用してパス名を登録します。パターンは使用できません。<br>
読み込みモードで要求されたパス名が allow_read というキーワードを使用して登録されたパス名と一致した場合、その場で読み込みアクセスが許可されます。<br>
目安としては以下のものが挙げられます。</p>

<ul>
<li>ldconfig に登録されている共有ライブラリ
<li>/proc/ ディレクトリ以下に存在するファイルの一部
<li>/usr/share/locale/ ディレクトリ以下に存在するロケールデータの一部
</ul>

<p>ドメイン遷移履歴をリセットするプログラムを登録しておきます。<br>
/root/security/exception_policy.txt に initializer というキーワードを使用してパス名を登録します。パターンは使用できません。<br>
initializer というキーワードを使用して登録されたパス名のプログラムが実行された場合、そのプログラムは &lt;kernel&gt; 直下のドメインで動作します。<br>
目安としては以下のものが挙げられます。</p>

<ul>
<li> /etc/init.d/ ディレクトリ以下にあるデーモンプログラム等を起動・終了させるためのスクリプト
<li>上記スクリプトから起動されるデーモンプログラムの内、ドメイン名を短くしたいもの（httpd や sshd など）
</ul>

<p>電源オフの処理に必要なアクセス許可を自動学習することはできないため、電源オフを行うためのドメインを信頼済みとして指定します。<br>
具体的な修正箇所はディストリビューション毎に異なります。多くの場合、 /etc/init.d/ ディレクトリ以下にあるシャットダウンを行うスクリプトの最後に実行されるプログラムが電源オフを行うためのプログラムです。</p>

<p>以上の操作を自動的に行うためのスクリプトが用意されています。 /root/ccstools/make_exception.sh を実行すると候補が表示されますので、それを元に /root/security/exception_policy.txt を作成してください。なお、自動生成された結果には不要なエントリや危険なエントリが含まれる場合があるので、必ず内容を吟味してください。</p>

<h3><a name="exception-logrotate">logrotate への対応</a></h3>

<P>コマンドラインから logrotate を起動して必要なアクセス許可を学習させるので、
/usr/sbin/logrotate を initializer として例外ポリシーに登録しておきます。</P>

<table border="1">
<tr><td>
initializer /usr/sbin/logrotate
</td></tr>
</table>

<h3><a name="exception-prelink">prelink への対応</a></h3>

<p>不特定多数のプログラムファイルを読み書きする cron ジョブは、 cron から除外することを検討してください。</p>

<p>例えば、 Fedora Core 3 以降に付属の cron で毎日実行するように設定されている /usr/sbin/prelink は非常に多数の実行可能ファイルを読み書きするため、ポリシーファイルの肥大化（消費メモリの増加）の原因になります。また、実行可能ファイルに対して書き込み許可を与えることは、望ましくありません。</p>

<p>cron を使って毎日 /usr/sbin/prelink を実行させなくても、「信頼済みドメイン」からパッケージのアップデートを行った後に /usr/sbin/prelink を実行すれば事足りると思いますので、以下のように cron ジョブから除外することをお勧めします。</p>

<table border="1">
<tr><td>
mv /etc/cron.daily/prelink /usr/sbin/prelink.cron
</td></tr>
</table>

<h3><a name="exception-anacron">anacron への対応</a></h3>

<P>コマンドラインから anacron を起動して必要なアクセス許可を学習させるので、
/usr/sbin/anacron を initializer として例外ポリシーに登録しておきます。</P>

<table border="1">
<tr><td>
initializer /usr/sbin/anacron
</td></tr>
</table>

<p>anacron は /usr/bin/run-parts を実行するので、
/usr/bin/run-parts を initializer として例外ポリシーに登録しておきます。</p>

<table border="1">
<tr><td>
initializer /usr/bin/run-parts
</td></tr>
</table>

<h3><a name="exception-cron">cron への対応</a></h3>

<p>cron は /usr/bin/run-parts を実行するので、
/usr/bin/run-parts を initializer として例外ポリシーに登録しておきます。</p>

<table border="1">
<tr><td>
initializer /usr/bin/run-parts
</td></tr>
</table>

<p>/etc/crontab を開き、以下のようにジョブの実行間隔を５分に変更します。
１分間隔だと前回のジョブが終了する前に次回のジョブが開始されてしまう可能性が高いので、
適当な時間を空ける必要があります。</p>

<table border="1">
<tr><td>変更前</td><td>変更後</td></tr>
<tr><td>
SHELL=/bin/bash<br>
PATH=/sbin:/bin:/usr/sbin:/usr/bin<br>
MAILTO=root<br>
HOME=/<br>
<br>
# run-parts<br>
01 * * * * root run-parts /etc/cron.hourly<br>
02 4 * * * root run-parts /etc/cron.daily<br>
22 4 * * 0 root run-parts /etc/cron.weekly<br>
42 4 1 * * root run-parts /etc/cron.monthly
</td><td>
SHELL=/bin/bash<br>
PATH=/sbin:/bin:/usr/sbin:/usr/bin<br>
MAILTO=root<br>
HOME=/<br>
<br>
# run-parts<br>
*/5 * * * * root run-parts /etc/cron.hourly<br>
*/5 * * * * root run-parts /etc/cron.daily<br>
*/5 * * * * root run-parts /etc/cron.weekly<br>
*/5 * * * * root run-parts /etc/cron.monthly
</td></tr>
</table>

<p>学習が終わったら元に戻すのを忘れないでください。</p>

<h2><a name="exception-targeted-policy">Targeted Policy への対応</a></h2>

<p>上記の手順により作成された /root/security/exception_policy.txt は Strict Policy として使用するためのものです。もし、 Targeted Policy に相当する方法で利用したい場合、 /root/security/exception_policy.txt を以下のように修正してください。</p>

<p>以下の３行を追加します。 /sbin/modprobe や /sbin/hotplug がシンボリックリンクの場合は、そのリンク先を指定してください。</p>

<table border="1">
<tr><td>
trust_domain &lt;kernel&gt; /sbin/init<br>
trust_domain &lt;kernel&gt; /sbin/modprobe<br>
trust_domain &lt;kernel&gt; /sbin/hotplug
</td></tr>
</table>

<p>initializer というキーワードで指定されているプログラムの内、強制アクセス制御対象から除外したいものを除外します。
例えば、 /usr/sbin/httpd と /usr/sbin/httpd から起動されるプログラムだけを強制アクセス制御の対象としたい場合、以下の３行を残してその他の initializer というキーワードで始まる行を除外します。</p>

<table border="1">
<tr><td>
initializer /usr/sbin/httpd<br>
initializer /sbin/modprobe<br>
initializer /sbin/hotplug
</td></tr>
</table>

<p>このようにすると、 /usr/sbin/httpd および /usr/sbin/httpd から起動されるプログラムは「&lt;kernel&gt; /usr/sbin/httpd」ドメインおよびその子孫ドメインに属することで強制アクセス制御が適用され、その他のプログラムは「&lt;kernel&gt; /sbin/init」「&lt;kernel&gt; /sbin/modprobe」「&lt;kernel&gt; /sbin/hotplug」ドメインの何れかに属することで強制アクセス制御が適用されない状態になります。</p>

<h1><a name="generate-policy">ポリシーの作成</a></h1>

<h2><a name="accept-mode-1">学習モード</a></h2>

<p>起動時のブートプロンプトで TOMOYO Linuxカーネルを選択し、学習モード用のプロファイル番号を CCS= に指定して起動します。１回目は TOMOYO_NOLOAD パラメータも指定してください。
TOMOYO_NOLOAD というパラメータを指定すると、ドメイン単位のポリシー（domain_policy.txt）をロードしないで再起動することができます。（つまり、起動時のブートプロンプトで TOMOYO Linuxカーネルを選択し、学習モード用のプロファイル番号を CCS= に指定するのに加えて、 TOMOYO_NOLOAD も指定して起動します。）</p>

<p>許可したい操作に必要なアクセス許可を学習させます。</p>

<p>１回で全てのアクセスパターンを学習できるとは限らないので、何度か繰り返します。<br>
また、起動時や終了時にのみ行われる操作も存在するため、再起動も何度か繰り返します。</p>

<p>学習モードで動作中には、以下のようなメッセージが表示される場合があります。</p>

<table border="1">
<tr><td>
TOMOYO-WARNING: Domain '&lt;kernel&gt; ...' has so many ACLs to hold. Stopped auto-append mode.
</td></tr>
</table>

<p>これは、特定のプログラムがあまりにも多くのファイルにアクセスしたものだから、メモリの浪費と応答速度の悪化を防ぐために安全装置が作動したことを知らせるメッセージです。安全装置が作動すると、このドメインに対してはファイルに対するアクセス許可がこれ以上自動的に追加されないようになります。</p>

<p>このメッセージに対処するには、手作業でアクセス許可を修正する必要があります。<br>
例えば、以下のメッセージが表示された場合、適切なパターンを利用してグループ化することで &lt;kernel&gt; /usr/sbin/hald というドメインに対するアクセス許可の数を減らす必要があります。</p>

<table border="1">
<tr><td>
TOMOYO-WARNING: Domain '&lt;kernel&gt; /usr/sbin/hald' has so many ACLs to hold. Stopped auto-append mode.
</td></tr>
</table>

<p>/root/ccstools/editpolicy を使用してポリシーの編集を行うことができます。</p>

<h3><a name="accept-logrotate">logrotate への対応</a></h3>

<P>コマンドラインから logrotate を起動し、必要なアクセス許可を学習させます。
現在のシステム時刻に関係なく logrotate のジョブを実行させるために、 -f オプションを指定してください。</P>

<table border="1">
<tr><td>
/usr/sbin/logrotate -f /etc/logrotate.conf
</td></tr>
</table>

<P>一度で全てのアクセス許可を学習できるとは限らないので、何度か繰り返します。</P>

<h3><a name="accept-anacron">anacron への対応</a></h3>

<P>コマンドラインから anacron を起動し、必要なアクセス許可を学習させます。
現在のシステム時刻に関係なく anacron のジョブを実行させるために、 -d -f -n オプションを指定してください。</P>

<table border="1">
<tr><td>
anacron -dfn
</td></tr>
</table>

<P>一度で全てのアクセス許可を学習できるとは限らないので、何度か繰り返します。</P>

<h2><a name="update-exception">例外ポリシーの更新</a></h2>

<p>通常のカーネルで再起動します。</p>

<p>以下のコマンドを実行すると、テンポラリであると思われるパス名が表示されます。適切にパターン化した上で /root/security/exception_policy.txt に file_pattern として追加します。</p>

<table border="1">
<tr><td>
/root/ccstools/findtemp &lt; /root/security/domain_policy.txt | sort | uniq
</td></tr>
</table>

<p>テンポラリの基準としては、「最後の６文字だけが異なるパス名が複数存在している」「パス名の中の数値部分だけが異なるパス名が複数存在している」等があります。<br>
パターン化する際の例を以下に示します。これらはインストールされているアプリケーションや設定により存在しなかったり違うディレクトリに存在していたりすることがあります。</p>
<ul>
<li>file_pattern /etc/.fstab.hal.\?</li>
<li>file_pattern /etc/blkid.tab-\?\?\?\?\?\?</li>
<li>file_pattern /etc/mrtg/mrtg.cfg_l_\$</li>
<li>file_pattern /root/.emacs.d/auto-save-list/.saves-\$-\*</li>
<li>file_pattern /root/Mail/inbox/\$</li>
<li>file_pattern /tmp/auto\?\?\?\?\?\?/</li>
<li>file_pattern /tmp/autofs.\?\?\?\?\?\?</li>
<li>file_pattern /tmp/logrotate.\?\?\?\?\?\?</li>
<li>file_pattern /tmp/logwatch.\*/</li>
<li>file_pattern /tmp/logwatch.\*/\*</li>
<li>file_pattern /tmp/makewhatis\?\?\?\?\?\?/</li>
<li>file_pattern /tmp/makewhatis\?\?\?\?\?\?/w</li>
<li>file_pattern /tmp/sh-thd-\$</li>
<li>file_pattern /tmp/spamassassin-\$/</li>
<li>file_pattern /tmp/spamassassin-\$/.spamassassin/</li>
<li>file_pattern /tmp/spamassassin-\$/.spamassassin/auto-whitelist\*</li>
<li>file_pattern /tmp/whatis.\?\?\?\?\?\?</li>
<li>file_pattern /var/lib/dhcp/dhcpd.leases.\$</li>
<li>file_pattern /var/lock/autofs.\$</li>
<li>file_pattern /var/lock/mrtg/mrtg_l_\$</li>
<li>file_pattern /var/log/ksymoops/\*</li>
<li>file_pattern /var/log/sa/sa\*</li>
<li>file_pattern /var/mailman/locks/gate_news.lock.\*</li>
<li>file_pattern /var/run/gpm\?\?\?\?\?\?</li>
</ul>

<p>initializer や allow_read で追加したいものがあれば追加します。</p>

<p>メンテナンス等のために特定のドメイン以下を信頼済みに設定したい場合は trust_domain を追加します。</p>

<h2><a name="accept-mode-2">学習モード</a></h2>

<p>パターンの洗い出しが完了したと判断したら、ドメイン別ポリシーを最初から学習しなおします。１回目は TOMOYO_NOLOAD パラメータも指定してください。</p>

<h1><a name="tune-policy">ポリシーのチューニング</a></h1>

<p>通常のカーネルで再起動します。</p>

<h2><a name="add-from-audit-logs">監査ログからの生成</a></h2>

<p>/var/log/tomoyo/reject_log.txt にはアクセスが拒否されたログが時系列で記録されています。
その中から、適当な範囲を切り抜き、以下のようにフィルタに通してください。このフィルタは、ドメイン単位にログを並べ替え、重複しているログを消します。（ドメイン単位でログの sort と uniq を行います。）</p>

<table border="1">
<tr><td>
/root/ccstools/sortpolicy &lt; /var/log/tomoyo/reject_log.txt
</td></tr>
</table>

<p>この結果から、追加すべきか否かを判断し、追加すべきであると判断した場合は /root/security/domain_policy.txt に追加します。</p>

<h2><a name="make-pathname-patterns">アクセス許可のパターン化</a></h2>

<p>WWW サーバがアクセスするコンテンツのように、自動学習では必ずしもアクセスされないファイルに対するアクセス許可を /root/security/domain_policy.txt に追加します。<br>
以下の例では、 /usr/sbin/httpd に対して /var/www/html/ 以下の読み込みを許可しています。</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/httpd<br>
4 /var/www/html/\*<br>
4 /var/www/html/\*/\*<br>
4 /var/www/html/\*/\*/\*<br>
4 /var/www/html/\*/\*/\*/\*<br>
4 /var/www/html/\*/\*/\*/\*/\*<br></td>
</tr>
</table>

<p>同様に、パターンを使用して手作業でのグループ化を行います。<br>
以下の例では、 /usr/sbin/smbd に対して全てのログファイルを同様に扱うように指示しています。</p>

<table border="1">
<tr><td>修正前</td><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
2 /var/log/samba/host1.log<br>
2 /var/log/samba/host2.log<br>
2 /var/log/samba/host3.log<br>
2 /var/log/samba/host4.log<br>
2 /var/log/samba/host5.log
</td><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
2 /var/log/samba/\*.log
</td></tr>
</table>

<h2><a name="make-network-patterns">ネットワークのパターン化</a></h2>

<p>portmap のように特権ポート（1024未満の番号を持つポート）をランダムに使用するアプリケーションが存在します。ランダムにネットワークポート番号を選択するアプリケーションに対しては、必要なポート番号を学習モードで学習させることはできません。何度か学習モードで実行することで１個ずつ学習させた後、学習結果からどのような範囲のポート番号を使用しているかを推測し、範囲を指定してポート番号の使用を許可してやる必要があります。<br>
例えば、以下のような範囲が考えられます。実際に許可する必要のある範囲はディストリビューションや設定により異なる可能性がありますので、以下の設定をそのままコピーしないようにしてください。</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /sbin/portmap<br>
allow_bind TCP/0<br>
allow_bind TCP/111<br>
allow_bind TCP/600-1023<br>
allow_bind UDP/0<br>
allow_bind UDP/111<br>
allow_bind UDP/600-1023<br>
allow_connect UDP/32768-65535<br>
allow_connect UDP/600-1023<br>
<br>
&lt;kernel&gt; /sbin/rpc.statd<br>
allow_bind TCP/0<br>
allow_bind TCP/600-1023<br>
allow_bind UDP/0<br>
allow_bind UDP/600-1023<br>
allow_connect UDP/111<br>
<br>
&lt;kernel&gt; /usr/sbin/rpc.mountd<br>
allow_bind TCP/0<br>
allow_bind TCP/600-1023<br>
allow_bind UDP/0<br>
allow_bind UDP/600-1023<br>
allow_connect UDP/111<br>
<br>
&lt;kernel&gt; /usr/sbin/rpc.nfsd<br>
allow_capability inet_tcp_create<br>
allow_capability use_inet_udp<br>
allow_connect UDP/111<br>
allow_connect UDP/32768-65535<br>
<br>
&lt;kernel&gt; /usr/sbin/rpc.rquotad<br>
allow_bind TCP/600-1023<br>
allow_bind UDP/600-1023<br>
allow_connect UDP/111<br>
<br>
&lt;kernel&gt; /usr/sbin/rpcinfo<br>
allow_bind UDP/600-1023<br>
allow_connect UDP/111<br>
allow_connect UDP/2049<br>
<br>
&lt;kernel&gt; /usr/sbin/xinetd<br>
allow_bind TCP/0<br>
allow_bind UDP/69<br>
allow_bind UDP/600-1023<br>
allow_connect UDP/111
</td></tr>
</table>

<p>なお、 NFS や NIS のように RPC を必要とするサービスを動作させないのであれば、無効にしておくことを推奨します。</p>

<p>同様に、 allow_network も適切にパターン化します。以下の設定をそのままコピーしないようにしてください。</a>

<table border="1">
<tr><td>修正前</td><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
allow_network TCP accept 0:0:0:0:0:0:0:1 43768<br>
allow_network TCP accept 0:0:0:0:0:ffff:a00:1 35086<br>
allow_network TCP accept 0:0:0:0:0:ffff:a00:a1 47590<br>
allow_network TCP accept 10.0.0.10 56709<br>
allow_network TCP accept 10.0.0.200 16384
</td><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
allow_network TCP accept 0:0:0:0:0:0:0:1 1024-65535<br>
allow_network TCP accept 0:0:0:0:0:ffff:a00:1-0:0:0:0:0:ffff:a00:ff 1024-65535<br>
allow_network TCP accept 10.0.0.1-10.0.0.255 1024-65535
</td></tr>
</table>

<h2><a name="add-conditional-policy">アクセス許可条件の付与</a></h2>

<p>TOMOYO Linux 1.2 では、個々のアクセス許可に対して必要に応じて条件を付けることができます。これにより、システムアカウントのユーザＩＤに基づくアクセス制御が可能です。</p>

<p>匿名ではない FTP サーバを保護する場合、以下のように条件を付けることで、当該ユーザのホームディレクトリ以外へのアクセスを禁止することができるようになります。ホームディレクトリ以下全部を FTP でアクセス可能にすることは、侵入された場合に被害が大きくなるため、自分のホームディレクトリにある ftp ディレクトリ以下だけのアクセスを認めます。 vsftpd を用いる場合、例えば以下のように許可を与えます。</p>

<table border="1">
<tr><td>修正前</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/vsftpd<br>
<br>
6 /home/\*/ftp/\*<br>
6 /home/\*/ftp/\*/\*<br>
6 /home/\*/ftp/\*/\*/\*<br>
6 /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_mkdir /home/\*/ftp/\*/<br>
allow_mkdir /home/\*/ftp/\*/\*/<br>
allow_mkdir /home/\*/ftp/\*/\*/\*/<br>
<br>
allow_rmdir /home/\*/ftp/\*/<br>
allow_rmdir /home/\*/ftp/\*/\*/<br>
allow_rmdir /home/\*/ftp/\*/\*/\*/<br>
<br>
allow_create /home/\*/ftp/\*<br>
allow_create /home/\*/ftp/\*/\*<br>
allow_create /home/\*/ftp/\*/\*/\*<br>
allow_create /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_truncate /home/\*/ftp/\*<br>
allow_truncate /home/\*/ftp/\*/\*<br>
allow_truncate /home/\*/ftp/\*/\*/\*<br>
allow_truncate /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_unlink /home/\*/ftp/\*<br>
allow_unlink /home/\*/ftp/\*/\*<br>
allow_unlink /home/\*/ftp/\*/\*/\*<br>
allow_unlink /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/ftp/\* /home/\*/ftp/\*<br>
allow_rename /home/\*/ftp/\*/\* /home/\*/ftp/\*/\*<br>
allow_rename /home/\*/ftp/\*/\*/\* /home/\*/ftp/\*/\*/\*<br>
allow_rename /home/\*/ftp/\*/\*/\*/\* /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/ftp/\*/ /home/\*/ftp/\*/<br>
allow_rename /home/\*/ftp/\*/\*/ /home/\*/ftp/\*/\*/<br>
allow_rename /home/\*/ftp/\*/\*/\*/ /home/\*/ftp/\*/\*/\*/<br>
</td></tr>
</table>


<table border="1">
<tr><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/vsftpd<br>
<br>
6 /home/\*/ftp/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_mkdir /home/\*/ftp/\*/ if task.uid=path1.parent.uid<br>
allow_mkdir /home/\*/ftp/\*/\*/ if task.uid=path1.parent.uid<br>
allow_mkdir /home/\*/ftp/\*/\*/\*/ if task.uid=path1.parent.uid<br>
<br>
allow_rmdir /home/\*/ftp/\*/ if task.uid=path1.uid<br>
allow_rmdir /home/\*/ftp/\*/\*/ if task.uid=path1.uid<br>
allow_rmdir /home/\*/ftp/\*/\*/\*/ if task.uid=path1.uid<br>
<br>
allow_create /home/\*/ftp/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\*/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.parent.uid<br>
<br>
allow_truncate /home/\*/ftp/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_unlink /home/\*/ftp/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_rename /home/\*/ftp/\* /home/\*/ftp/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\* /home/\*/ftp/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\* /home/\*/ftp/\*/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\*/\* /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
<br>
allow_rename /home/\*/ftp/\*/ /home/\*/ftp/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/ /home/\*/ftp/\*/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\*/ /home/\*/ftp/\*/\*/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
</td></tr>
</table>

<p>Samba サーバを保護する場合、以下のように条件を付けることで、当該ユーザのホームディレクトリ以外へのアクセスを禁止することができるようになります。ホームディレクトリ以下全部を Samba でアクセス可能にすることは、侵入された場合に被害が大きくなるため、自分のホームディレクトリにある samba ディレクトリ以下だけのアクセスを認めます。</p>

<table border="1">
<tr><td>修正前</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
<br>
6 /home/\*/samba/\*<br>
6 /home/\*/samba/\*/\*<br>
6 /home/\*/samba/\*/\*/\*<br>
6 /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_mkdir /home/\*/samba/\*/<br>
allow_mkdir /home/\*/samba/\*/\*/<br>
allow_mkdir /home/\*/samba/\*/\*/\*/<br>
<br>
allow_rmdir /home/\*/samba/\*/<br>
allow_rmdir /home/\*/samba/\*/\*/<br>
allow_rmdir /home/\*/samba/\*/\*/\*/<br>
<br>
allow_create /home/\*/samba/\*<br>
allow_create /home/\*/samba/\*/\*<br>
allow_create /home/\*/samba/\*/\*/\*<br>
allow_create /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_truncate /home/\*/samba/\*<br>
allow_truncate /home/\*/samba/\*/\*<br>
allow_truncate /home/\*/samba/\*/\*/\*<br>
allow_truncate /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_unlink /home/\*/samba/\*<br>
allow_unlink /home/\*/samba/\*/\*<br>
allow_unlink /home/\*/samba/\*/\*/\*<br>
allow_unlink /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/samba/\* /home/\*/samba/\*<br>
allow_rename /home/\*/samba/\*/\* /home/\*/samba/\*/\*<br>
allow_rename /home/\*/samba/\*/\*/\* /home/\*/samba/\*/\*/\*<br>
allow_rename /home/\*/samba/\*/\*/\*/\* /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/samba/\*/ /home/\*/samba/\*/<br>
allow_rename /home/\*/samba/\*/\*/ /home/\*/samba/\*/\*/<br>
allow_rename /home/\*/samba/\*/\*/\*/ /home/\*/samba/\*/\*/\*/
</td></tr>
</table>

<table border="1">
<tr><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
<br>
6 /home/\*/samba/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_mkdir /home/\*/samba/\*/ if task.euid=path1.parent.uid<br>
allow_mkdir /home/\*/samba/\*/\*/ if task.euid=path1.parent.uid<br>
allow_mkdir /home/\*/samba/\*/\*/\*/ if task.euid=path1.parent.uid<br>
<br>
allow_rmdir /home/\*/samba/\*/ if task.euid=path1.uid<br>
allow_rmdir /home/\*/samba/\*/\*/ if task.euid=path1.uid<br>
allow_rmdir /home/\*/samba/\*/\*/\*/ if task.euid=path1.uid<br>
<br>
allow_create /home/\*/samba/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\*/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\*/\*/\* if task.euid=path1.parent.uid<br>
<br>
allow_truncate /home/\*/samba/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_unlink /home/\*/samba/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_rename /home/\*/samba/\* /home/\*/samba/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\* /home/\*/samba/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\* /home/\*/samba/\*/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\*/\* /home/\*/samba/\*/\*/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
<br>
allow_rename /home/\*/samba/\*/ /home/\*/samba/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/ /home/\*/samba/\*/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\*/ /home/\*/samba/\*/\*/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid
</td></tr>
</table>

<p>SSH サーバを保護する場合、以下のように条件を付けることで、 root ユーザとしてログインすることを禁止できます。</p>

<table border="1">
<tr><td>修正前</td><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
<br>
1 /bin/bash
</td><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
<br>
1 /bin/bash if task.uid!=0 task.euid!=0
</td></tr>
</table>

<p>指定可能な条件については<a href="policy-reference.html#conditional_acl">条件付きアクセス許可</a>を参照してください。</p>

<h2><a name="permissive-mode">確認モード</a></h2>

<p>起動時のブートプロンプトで TOMOYO Linux カーネルを選択し、許容モード用のプロファイル番号を CCS= に指定して起動します。</p>
<p>許可したい操作を行ってもエラーメッセージが表示されないことを確認してください。</p>
<p>正常に動作すればポリシーの完成です。</p>

<h1><a name="production-state">ポリシーの利用</a></h1>

<h2><a name="enforce-mode">強制モード</a></h2>

<p>起動時のブートプロンプトで TOMOYO Linux カーネルを選択し、強制モード用のプロファイル番号を CCS= に指定して起動します。</p>
</body>
</html>
