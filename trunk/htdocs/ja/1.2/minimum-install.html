<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=shift_jis">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linux導入手順（簡易版）</title>
<link rel="stylesheet" href="tomoyo.css" media="all" type="text/css">
</head>
<body>
<h1>TOMOYO Linux導入手順（簡易版）</h1>
<p style="text-align:right;">Last modified: $Date$ UT</p>

<h1>目次</h1>

<ul>
<li><a href="#preparation">準備</a>
<li>　<a href="#install-kernel">カーネルのインストール</a>
<li>　<a href="#install-tool">ツールのインストール</a>
<li>　<a href="#boot-test">起動テスト</a>
<li><a href="#policy-preparation">ポリシーの作成準備</a>
<li>　<a href="#example_policy">デフォルトポリシーについて</a>
<li>　<a href="#manager-programs">ポリシーの変更を許可するプログラムの指定</a>
<li>　<a href="#patch-shutdown">シャットダウン処理の修正</a>
<li>　<a href="#create-profiles">プロファイルの作成</a>
<li>　<a href="#create-exceptions">例外ポリシーの作成</a>
<li>　　<a href="#exception-logrotate">logrotate への対応</a>
<li>　　<a href="#exception-prelink">prelink への対応</a>
<li>　　<a href="#exception-anacron">anacron への対応</a>
<li>　　<a href="#exception-cron">cron への対応</a>
<li>　<a href="#exception-targeted-policy">Targeted Policy への対応</a>
<li><a href="#generate-policy">ポリシーの作成</a>
<li>　<a href="#accept-mode-1">学習モード</a>
<li>　　<a href="#accept-logrotate">logrotate への対応</a>
<li>　　<a href="#accept-anacron">anacron への対応</a>
<li>　<a href="#update-exception">例外ポリシーの更新</a>
<li>　<a href="#accept-mode-2">学習モード</a>
<li><a href="#tune-policy">ポリシーのチューニング</a>
<li>　<a href="#make-pathname-patterns">アクセス許可のパターン化</a>
<li>　<a href="#add-conditional-policy">アクセス許可条件の付与</a>
<li>　<a href="#permissive-mode">確認モード</a>
<li><a href="#production-state">ポリシーの利用</a>
<li>　<a href="#enforce-mode">強制モード</a>
</ul>
<hr>

<h1><a name="preparation">準備</a></h1>

<p>使用するディストリビューションの制限はありません。しかし、全てのディストリビューションで共通に使える手順書を作成することはできないため、この手順書では「RedHat Linux 9」「Fedora Core 3」「Debian Sarge」の３種類について記述します。</p>

<p>不要なアプリケーションは事前にアンインストールしておくことで、ポリシーのサイズを小さくすることができます。
どのアプリケーションが必要かを事前に把握しておくことを推奨します。</p>

<h2><a name="install-kernel">カーネルのインストール</a></h2>

<p>TOMOYO Linux では、いくつかのコンパイル済みのカーネルをパッケージにして提供しています。コンパイル済みのカーネルを利用する場合は、以下のファイルをダウンロードしてインストールしてください。</p>

<table border="1">
<tr><td>
RedHat Linux 9 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.4.20-46.9.legacy_tomoyo_1.2.i386.rpm
</td></tr><tr><td>
Fedora Core 3 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.12-2.3.legacy_FC3_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Fedora Core 4 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.17-1.2142_FC4_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Fedora Core 5 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.18-1.2200_FC5_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Fedora Core 6 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.18-1.2798_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
CentOS 4.4 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.9-42.0.3.EL_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Debian Sarge （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-image-2.4.27-10sarge4-ccs_1.2_i586.deb<br>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-image-2.6.8-16sarge5-ccs_1.2_i586.deb
</td></tr><tr><td>
OpenSUSE 10.1 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-default-2.6.16.21-0.25_tomoyo_1.2.i586.rpm
</td></tr>
</table>

<p>アーキテクチャが異なる場合やカスタマイズしたい場合には、カーネルをコンパイルする必要があります。カーネルをコンパイルする方法については、<a href="compile.html">TOMOYO Linuxカーネルの作成手順</a>を参照してください。</p>

<h2><a name="install-tool">ツールのインストール</a></h2>

<p>TOMOYO Linux では、いくつかのコンパイル済みのツールを提供しています。コンパイル済みのツールを利用する場合は、以下のファイルをダウンロードして /root/ ディレクトリの下に展開してください。</p>

<table border="1">
<tr><td>
RedHat Linux 9 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-RHL9.tar.gz
</td></tr><tr><td>
Fedora Core 3 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC3.tar.gz
</td></tr><tr><td>
Fedora Core 4 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC4.tar.gz
</td></tr><tr><td>
Fedora Core 5 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC5.tar.gz
</td></tr><tr><td>
Fedora Core 6 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC6.tar.gz
</td></tr><tr><td>
CentOS 4.4 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-CentOS4.4.tar.gz
</td></tr><tr><td>
Debian Sarge （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-Sarge.tar.gz
</td></tr><tr><td>
OpenSUSE 10.1 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-SUSE10.1.tar.gz
</td></tr>
</table>

<p>アーキテクチャが異なる場合には、ツールをコンパイルする必要があります。ツールをコンパイルするには、以下のコマンドを実行してください。</p>

<table border="1">
<tr><td>
# TOMOYO Linux ツールのソースをダウンロードする。<br>
wget http://osdn.dl.sourceforge.jp/tomoyo/21579/ccs-tools-1.2-20060903.tar.gz<br>
# 展開する。<br>
tar -zxf ccs-tools-1.2-20060903.tar.gz<br>
# コンパイルする。<br>
make -sC ccstools/
</td></tr>
</table>

<h2><a name="boot-test">起動テスト</a></h2>

<p>TOMOYO Linux カーネルで起動して、正常に動作できることを確認できたら、 /proc/ccs/status の内容を /root/security/status.txt というファイルに保存しておいてください。このファイルに含まれる項目が、このカーネルで制御できる項目になります。このファイルは、後述する手順でプロファイルを作成する際のヒントとして使用します。</p>

<table border="1">
<tr><td>
mkdir -p /root/security<br>
cat /proc/ccs/status &gt; /root/security/status.txt
</td></tr>
</table>

<h1><a name="policy-preparation">ポリシーの作成準備</a></h1>

<p>この章の作業は通常のカーネルで行うようにしてください。<br>
TOMOYO Linux カーネルで行うと、シャットダウン時に /root/ccstools/savepolicy が実行されるために /root/security/exception_policy.txt に加えた変更内容が失われてしまいます。</p>

<h2><a name="example_policy">デフォルトポリシーについて</a></h2>
<p>TOMOYO Linux には、ソフトウェアと一緒に配布されるデフォルトポリシーはありません。学習モードを使用して策定する必要があります。<br>
参考までに、<a href="http://tomoyo.sourceforge.jp/example_policy/">サンプルのポリシー</a>を置いてあります。参照は自由ですが、デフォルトポリシーとしての利用はしないでください。</p>

<h2><a name="manager-programs">ポリシーの変更を許可するプログラムの指定</a></h2>

<p>/root/security/manager.txt を作成し、その中にポリシーの変更を許可したいプログラムを指定します。<br>
具体的には、ポリシーを再読み込みする loadpolicy 、ポリシーを編集する editpolicy 、制御レベルを変更する setlevel 、無条件読み込み許可を更新する ld-watch 、対話的にアクセス要求を許可する ccs-queryd の５つを指定してください。</p>
<table border="1">
<tr><td>
cat &gt; /root/security/manager.txt &lt;&lt; EOF<br>
/root/ccstools/loadpolicy<br>
/root/ccstools/editpolicy<br>
/root/ccstools/setlevel<br>
/root/ccstools/ld-watch<br>
/root/ccstools/ccs-queryd<br>
EOF<br></td>
</tr>
</table>

<h2><a name="patch-shutdown">シャットダウン処理の修正</a></h2>

<p>電源が切れる直前にメモリ上のポリシーをディスク上に保存するために、シャットダウンスクリプトの中で /root/ccstools/savepolicy が実行されるように修正します。具体的な修正箇所はディストリビューション毎に異なります。多くの場合、 /etc/init.d/ ディレクトリ直下にあるシャットダウンを行うスクリプトの最後に実行されるプログラムが電源を切るためのプログラムなので、その直前で保存するように修正します。</p>

<p>RedHat Linux 9 および Fedora Core 3 の場合は以下のように修正してください。</p>

<table border="1">
<tr><td colspan="2">/etc/rc.d/init.d/halt</td></tr>
<tr><td>修正前</td><td>修正後</td></tr>
<tr><td>
<br>
exec $command $HALTARGS
</td><td>
/root/ccstools/savepolicy<br>
exec $command $HALTARGS
</td></tr>
</table>

<p>Debian Sarge の場合は以下のように修正してください。 savepolicy の前に halt/reboot を一度実行しているのは halt/reboot を実行するドメインを作成するためです。</p>

<table border="1">
<tr><td colspan="2">/etc/init.d/halt</td><td colspan="2">/etc/init.d/reboot</td></tr>
<tr><td>修正前</td><td>修正後</td><td>修正前</td><td>修正後</td></tr>
<tr><td>
<br>
<br>
halt -d -f -i $poweroff $hddown
</td><td>
halt --help 2&gt; /dev/null<br>
/root/ccstools/savepolicy<br>
halt -d -f -i $poweroff $hddown
</td><td>
<br>
<br>
reboot -d -f -i
</td><td>
reboot --help 2&gt; /dev/null<br>
/root/ccstools/savepolicy<br>
reboot -d -f -i
</td></tr>
</table>

<h2><a name="create-profiles">プロファイルの作成</a></h2>

<p>TOMOYO Linuxでは、ファイル以外にもいくつかの項目について強制アクセス制御を行うことができますが、ポリシー管理の負担を減らすために、必要の無い機能を無効化できるようになっています。</p>

<p>有効にしたい機能とそのモードを記述した初期制御レベル定義ファイルを１つ以上作成し、カーネル起動時のコマンドラインから番号を指定することで切り替えができるようになっています。具体的には、カーネル起動時のコマンドラインで CCS=$INDEX （$INDEX は整数）というパラメータを指定すると、対応する /root/security/profile$INDEX.txt が読み込まれます。</p>

<p>以下の説明を参照しながら、用途毎のプロファイルを作成してください。 /root/security/status.txt に含まれる項目だけが指定可能です。 /root/security/status.txt に含まれる項目の数は、カーネルコンパイル時の設定により変化します。</p>

<table border="1">
<tr><td>項目</td><td>制御する内容</td><td>自動学習対応</td></tr>
<tr><td>MAC_FOR_FILE</td><td>ファイルの読み書き実行</td><td>○</td></tr>
<tr><td>MAX_ACCEPT_FILES</td><td>学習モードで自動的に追加されるアクセス許可の上限を指定する。</td><td>−</td></tr>
<tr><td>MAX_GRANT_LOG</td><td>メモリ上に保持するアクセス許可ログの上限を指定する。</td><td>−</td></tr>
<tr><td>MAX_REJECT_LOG</td><td>メモリ上に保持するアクセス拒否ログの上限を指定する。</td><td>−</td></tr>
<tr><td>TOMOYO_VERBOSE</td><td>ドメイン別ポリシーに対する違反を syslog に表示する。</td><td>−</td></tr>
<tr><td>MAX_ENFORCE_GRACE</td><td>強制モードでポリシー違反が発生した場合に、アクセス要求を拒否するまでの猶予時間を指定する。</td><td>−</td></tr>
</table>

<p>MAX_ACCEPT_FILES については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>任意の整数</td><td>学習モードで自動的に追加されるアクセス許可の上限。デフォルトはカーネルのコンパイル時に指定。</td></tr>
</table>

<p>MAX_GRANT_LOG および MAX_REJECT_LOG については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>任意の整数</td><td>カーネル内に保持するアクセスログの件数。デフォルトはカーネルのコンパイル時に指定。ログが不要ならば 0 を指定する。</td></tr>
</table>

<p>TOMOYO_VERBOSE については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>0</td><td>ドメイン別ポリシーに対する違反を表示しない。</td></tr>
<tr><td>1</td><td>ドメイン別ポリシーに対する違反を表示する。</td></tr>
</table>

<p>MAX_ENFORCE_GRACE については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>任意の整数</td><td>強制モードで動作中にポリシー違反が発生してから、そのアクセス要求を拒否するまでの猶予期間を秒単位で指定する。この時間内に管理者がそのアクセス要求を許可するように指示した場合、そのアクセス要求は許可される。</td></tr>
</table>

<p>上記以外については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>0</td><td>無効。通常のカーネルと同様に動作する。</td></tr>
<tr><td>1</td><td>学習モード。ポリシーに違反しても警告をエラーにせず、ポリシーへの自動追加を行う。</td></tr>
<tr><td>2</td><td>許容モード。ポリシーに違反してもエラーにせず、ポリシーへの自動追加も行わない。</td></tr>
<tr><td>3</td><td>強制モード。ポリシーに違反したらエラーとする。</td></tr>
</table>

<h2><a name="create-exceptions">例外ポリシーの作成</a></h2>

<p>全てのシステムに共通して存在している可能性が高いパス名のパターンを事前に登録しておきます。<br>
/root/security/exception_policy.txt に file_pattern というキーワードを使用してパス名のパターンを登録します。<br>
アクセス許可を学習する際に、要求されたパス名が file_pattern というキーワードを使用して登録されたパス名のパターンと一致した場合、パターン化されたパス名でアクセス許可が学習されます。<br>
目安としては以下のものが挙げられます。</p>

<ul>
<li>/proc/PID/ ディレクトリ以下に存在するファイルのパス名
<li>/sys/ ディレクトリ以下に存在するファイルのパス名（カーネル 2.6 系の場合のみ）
<li>/dev/ ディレクトリ以下の一部のパス名
<li>ポリシーファイルのパス名
<li>マニュアルページのパス名
<li>スプールディレクトリのパス名
<li>メールの送受信時に作成されるテンポラリファイルのパス名
<li>man コマンドが作成するテンポラリファイルのパス名
<li>mount コマンドが作成するテンポラリファイルのパス名
</ul>

<p>システムにインストールされているアプリケーションやその設定により、上記以外にもパターン化されたパス名が必要になります。不足しているパターンは実際にアクセス許可を学習させてから、適切にパターン化して追加します。</p>

<p>全てのプログラムへの読み込みアクセスを許可するファイルを登録しておきます。<br>
/root/security/exception_policy.txt に allow_read というキーワードを使用してパス名を登録します。パターンは使用できません。<br>
読み込みモードで要求されたパス名が allow_read というキーワードを使用して登録されたパス名と一致した場合、その場で読み込みアクセスが許可されます。<br>
目安としては以下のものが挙げられます。</p>

<ul>
<li>ldconfig に登録されている共有ライブラリ
<li>/proc/ ディレクトリ以下に存在するファイルの一部
<li>/usr/share/locale/ ディレクトリ以下に存在するロケールデータの一部
</ul>

<p>ドメイン遷移履歴をリセットするプログラムを登録しておきます。<br>
/root/security/exception_policy.txt に initializer というキーワードを使用してパス名を登録します。パターンは使用できません。<br>
initializer というキーワードを使用して登録されたパス名のプログラムが実行された場合、そのプログラムは &lt;kernel&gt; 直下のドメインで動作します。<br>
目安としては以下のものが挙げられます。</p>

<ul>
<li> /etc/init.d/ ディレクトリ以下にあるデーモンプログラム等を起動・終了させるためのスクリプト
<li>上記スクリプトから起動されるデーモンプログラムの内、ドメイン名を短くしたいもの（httpd や sshd など）
</ul>

<p>電源オフの処理に必要なアクセス許可を自動学習することはできないため、電源オフを行うためのドメインを信頼済みとして指定します。<br>
具体的な修正箇所はディストリビューション毎に異なります。多くの場合、 /etc/init.d/ ディレクトリ以下にあるシャットダウンを行うスクリプトの最後に実行されるプログラムが電源オフを行うためのプログラムです。</p>

<p>以上の操作を自動的に行うためのスクリプトが用意されています。 /root/ccstools/make_exception.sh を実行すると候補が表示されますので、それを元に /root/security/exception_policy.txt を作成してください。なお、自動生成された結果には不要なエントリや危険なエントリが含まれる場合があるので、必ず内容を吟味してください。</p>

<h3><a name="exception-logrotate">logrotate への対応</a></h3>

<P>コマンドラインから logrotate を起動して必要なアクセス許可を学習させるので、
/usr/sbin/logrotate を initializer として例外ポリシーに登録しておきます。</P>

<table border="1">
<tr><td>
initializer /usr/sbin/logrotate
</td></tr>
</table>

<h3><a name="exception-prelink">prelink への対応</a></h3>

<p>不特定多数のプログラムファイルを読み書きする cron ジョブは、 cron から除外することを検討してください。</p>

<p>例えば、 Fedora Core 3 以降に付属の cron で毎日実行するように設定されている /usr/sbin/prelink は非常に多数の実行可能ファイルを読み書きするため、ポリシーファイルの肥大化（消費メモリの増加）の原因になります。また、実行可能ファイルに対して書き込み許可を与えることは、望ましくありません。</p>

<p>cron を使って毎日 /usr/sbin/prelink を実行させなくても、「信頼済みドメイン」からパッケージのアップデートを行った後に /usr/sbin/prelink を実行すれば事足りると思いますので、以下のように cron ジョブから除外することをお勧めします。</p>

<table border="1">
<tr><td>
mv /etc/cron.daily/prelink /usr/sbin/prelink.cron
</td></tr>
</table>

<h3><a name="exception-anacron">anacron への対応</a></h3>

<P>コマンドラインから anacron を起動して必要なアクセス許可を学習させるので、
/usr/sbin/anacron を initializer として例外ポリシーに登録しておきます。</P>

<table border="1">
<tr><td>
initializer /usr/sbin/anacron
</td></tr>
</table>

<p>anacron は /usr/bin/run-parts を実行するので、
/usr/bin/run-parts を initializer として例外ポリシーに登録しておきます。</p>

<table border="1">
<tr><td>
initializer /usr/bin/run-parts
</td></tr>
</table>

<h3><a name="exception-cron">cron への対応</a></h3>

<p>cron は /usr/bin/run-parts を実行するので、
/usr/bin/run-parts を initializer として例外ポリシーに登録しておきます。</p>

<table border="1">
<tr><td>
initializer /usr/bin/run-parts
</td></tr>
</table>

<p>/etc/crontab を開き、以下のようにジョブの実行間隔を５分に変更します。
１分間隔だと前回のジョブが終了する前に次回のジョブが開始されてしまう可能性が高いので、
適当な時間を空ける必要があります。</p>

<table border="1">
<tr><td>変更前</td><td>変更後</td></tr>
<tr><td>
SHELL=/bin/bash<br>
PATH=/sbin:/bin:/usr/sbin:/usr/bin<br>
MAILTO=root<br>
HOME=/<br>
<br>
# run-parts<br>
01 * * * * root run-parts /etc/cron.hourly<br>
02 4 * * * root run-parts /etc/cron.daily<br>
22 4 * * 0 root run-parts /etc/cron.weekly<br>
42 4 1 * * root run-parts /etc/cron.monthly
</td><td>
SHELL=/bin/bash<br>
PATH=/sbin:/bin:/usr/sbin:/usr/bin<br>
MAILTO=root<br>
HOME=/<br>
<br>
# run-parts<br>
*/5 * * * * root run-parts /etc/cron.hourly<br>
*/5 * * * * root run-parts /etc/cron.daily<br>
*/5 * * * * root run-parts /etc/cron.weekly<br>
*/5 * * * * root run-parts /etc/cron.monthly
</td></tr>
</table>

<p>学習が終わったら元に戻すのを忘れないでください。</p>

<h2><a name="exception-targeted-policy">Targeted Policy への対応</a></h2>

<p>上記の手順により作成された /root/security/exception_policy.txt は Strict Policy として使用するためのものです。もし、 Targeted Policy に相当する方法で利用したい場合、 /root/security/exception_policy.txt を以下のように修正してください。</p>

<p>以下の３行を追加します。 /sbin/modprobe や /sbin/hotplug がシンボリックリンクの場合は、そのリンク先を指定してください。</p>

<table border="1">
<tr><td>
trust_domain &lt;kernel&gt; /sbin/init<br>
trust_domain &lt;kernel&gt; /sbin/modprobe<br>
trust_domain &lt;kernel&gt; /sbin/hotplug
</td></tr>
</table>

<p>initializer というキーワードで指定されているプログラムの内、強制アクセス制御対象から除外したいものを除外します。
例えば、 /usr/sbin/httpd と /usr/sbin/httpd から起動されるプログラムだけを強制アクセス制御の対象としたい場合、以下の３行を残してその他の initializer というキーワードで始まる行を除外します。</p>

<table border="1">
<tr><td>
initializer /usr/sbin/httpd<br>
initializer /sbin/modprobe<br>
initializer /sbin/hotplug
</td></tr>
</table>

<p>このようにすると、 /usr/sbin/httpd および /usr/sbin/httpd から起動されるプログラムは「&lt;kernel&gt; /usr/sbin/httpd」ドメインおよびその子孫ドメインに属することで強制アクセス制御が適用され、その他のプログラムは「&lt;kernel&gt; /sbin/init」「&lt;kernel&gt; /sbin/modprobe」「&lt;kernel&gt; /sbin/hotplug」ドメインの何れかに属することで強制アクセス制御が適用されない状態になります。</p>

<h1><a name="generate-policy">ポリシーの作成</a></h1>

<h2><a name="accept-mode-1">学習モード</a></h2>

<p>起動時のブートプロンプトで TOMOYO Linuxカーネルを選択し、学習モード用のプロファイル番号を CCS= に指定して起動します。１回目は TOMOYO_NOLOAD パラメータも指定してください。
TOMOYO_NOLOAD というパラメータを指定すると、ドメイン単位のポリシー（domain_policy.txt）をロードしないで再起動することができます。（つまり、起動時のブートプロンプトで TOMOYO Linuxカーネルを選択し、学習モード用のプロファイル番号を CCS= に指定するのに加えて、 TOMOYO_NOLOAD も指定して起動します。）</p>

<p>許可したい操作に必要なアクセス許可を学習させます。</p>

<p>１回で全てのアクセスパターンを学習できるとは限らないので、何度か繰り返します。<br>
また、起動時や終了時にのみ行われる操作も存在するため、再起動も何度か繰り返します。</p>

<p>学習モードで動作中には、以下のようなメッセージが表示される場合があります。</p>

<table border="1">
<tr><td>
TOMOYO-WARNING: Domain '&lt;kernel&gt; ...' has so many ACLs to hold. Stopped auto-append mode.
</td></tr>
</table>

<p>これは、特定のプログラムがあまりにも多くのファイルにアクセスしたものだから、メモリの浪費と応答速度の悪化を防ぐために安全装置が作動したことを知らせるメッセージです。安全装置が作動すると、このドメインに対してはファイルに対するアクセス許可がこれ以上自動的に追加されないようになります。</p>

<p>このメッセージに対処するには、手作業でアクセス許可を修正する必要があります。<br>
例えば、以下のメッセージが表示された場合、適切なパターンを利用してグループ化することで &lt;kernel&gt; /usr/sbin/hald というドメインに対するアクセス許可の数を減らす必要があります。</p>

<table border="1">
<tr><td>
TOMOYO-WARNING: Domain '&lt;kernel&gt; /usr/sbin/hald' has so many ACLs to hold. Stopped auto-append mode.
</td></tr>
</table>

<p>/root/ccstools/editpolicy を使用してポリシーの編集を行うことができます。</p>

<h3><a name="accept-logrotate">logrotate への対応</a></h3>

<P>コマンドラインから logrotate を起動し、必要なアクセス許可を学習させます。
現在のシステム時刻に関係なく logrotate のジョブを実行させるために、 -f オプションを指定してください。</P>

<table border="1">
<tr><td>
/usr/sbin/logrotate -f /etc/logrotate.conf
</td></tr>
</table>

<P>一度で全てのアクセス許可を学習できるとは限らないので、何度か繰り返します。</P>

<h3><a name="accept-anacron">anacron への対応</a></h3>

<P>コマンドラインから anacron を起動し、必要なアクセス許可を学習させます。
現在のシステム時刻に関係なく anacron のジョブを実行させるために、 -d -f -n オプションを指定してください。</P>

<table border="1">
<tr><td>
anacron -dfn
</td></tr>
</table>

<P>一度で全てのアクセス許可を学習できるとは限らないので、何度か繰り返します。</P>

<h2><a name="update-exception">例外ポリシーの更新</a></h2>

<p>通常のカーネルで再起動します。</p>

<p>以下のコマンドを実行すると、テンポラリであると思われるパス名が表示されます。適切にパターン化した上で /root/security/exception_policy.txt に file_pattern として追加します。</p>

<table border="1">
<tr><td>
/root/ccstools/findtemp &lt; /root/security/domain_policy.txt | sort | uniq
</td></tr>
</table>

<p>テンポラリの基準としては、「最後の６文字だけが異なるパス名が複数存在している」「パス名の中の数値部分だけが異なるパス名が複数存在している」等があります。<br>
パターン化する際の例を以下に示します。これらはインストールされているアプリケーションや設定により存在しなかったり違うディレクトリに存在していたりすることがあります。</p>
<ul>
<li>file_pattern /etc/.fstab.hal.\?</li>
<li>file_pattern /etc/blkid.tab-\?\?\?\?\?\?</li>
<li>file_pattern /etc/mrtg/mrtg.cfg_l_\$</li>
<li>file_pattern /root/.emacs.d/auto-save-list/.saves-\$-\*</li>
<li>file_pattern /root/Mail/inbox/\$</li>
<li>file_pattern /tmp/auto\?\?\?\?\?\?/</li>
<li>file_pattern /tmp/autofs.\?\?\?\?\?\?</li>
<li>file_pattern /tmp/logrotate.\?\?\?\?\?\?</li>
<li>file_pattern /tmp/logwatch.\*/</li>
<li>file_pattern /tmp/logwatch.\*/\*</li>
<li>file_pattern /tmp/makewhatis\?\?\?\?\?\?/</li>
<li>file_pattern /tmp/makewhatis\?\?\?\?\?\?/w</li>
<li>file_pattern /tmp/sh-thd-\$</li>
<li>file_pattern /tmp/spamassassin-\$/</li>
<li>file_pattern /tmp/spamassassin-\$/.spamassassin/</li>
<li>file_pattern /tmp/spamassassin-\$/.spamassassin/auto-whitelist\*</li>
<li>file_pattern /tmp/whatis.\?\?\?\?\?\?</li>
<li>file_pattern /var/lib/dhcp/dhcpd.leases.\$</li>
<li>file_pattern /var/lock/autofs.\$</li>
<li>file_pattern /var/lock/mrtg/mrtg_l_\$</li>
<li>file_pattern /var/log/ksymoops/\*</li>
<li>file_pattern /var/log/sa/sa\*</li>
<li>file_pattern /var/mailman/locks/gate_news.lock.\*</li>
<li>file_pattern /var/run/gpm\?\?\?\?\?\?</li>
</ul>

<p>initializer や allow_read で追加したいものがあれば追加します。</p>

<p>メンテナンス等のために特定のドメイン以下を信頼済みに設定したい場合は trust_domain を追加します。</p>

<h2><a name="accept-mode-2">学習モード</a></h2>

<p>パターンの洗い出しが完了したと判断したら、ドメイン別ポリシーを最初から学習しなおします。１回目は TOMOYO_NOLOAD パラメータも指定してください。</p>

<h1><a name="tune-policy">ポリシーのチューニング</a></h1>

<p>通常のカーネルで再起動します。</p>

<h2><a name="make-pathname-patterns">アクセス許可のパターン化</a></h2>

<p>WWW サーバがアクセスするコンテンツのように、自動学習では必ずしもアクセスされないファイルに対するアクセス許可を /root/security/domain_policy.txt に追加します。<br>
以下の例では、 /usr/sbin/httpd に対して /var/www/html/ 以下の読み込みを許可しています。</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/httpd<br>
4 /var/www/html/\*<br>
4 /var/www/html/\*/\*<br>
4 /var/www/html/\*/\*/\*<br>
4 /var/www/html/\*/\*/\*/\*<br>
4 /var/www/html/\*/\*/\*/\*/\*<br></td>
</tr>
</table>

<p>同様に、パターンを使用して手作業でのグループ化を行います。<br>
以下の例では、 /usr/sbin/smbd に対して全てのログファイルを同様に扱うように指示しています。</p>

<table border="1">
<tr><td>修正前</td><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
2 /var/log/samba/host1.log<br>
2 /var/log/samba/host2.log<br>
2 /var/log/samba/host3.log<br>
2 /var/log/samba/host4.log<br>
2 /var/log/samba/host5.log
</td><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
2 /var/log/samba/\*.log
</td></tr>
</table>

<h2><a name="add-conditional-policy">アクセス許可条件の付与</a></h2>

<p>TOMOYO Linux 1.2 では、個々のアクセス許可に対して必要に応じて条件を付けることができます。これにより、システムアカウントのユーザＩＤに基づくアクセス制御が可能です。</p>

<p>匿名ではない FTP サーバを保護する場合、以下のように条件を付けることで、当該ユーザのホームディレクトリ以外へのアクセスを禁止することができるようになります。ホームディレクトリ以下全部を FTP でアクセス可能にすることは、侵入された場合に被害が大きくなるため、自分のホームディレクトリにある ftp ディレクトリ以下だけのアクセスを認めます。 vsftpd を用いる場合、例えば以下のように許可を与えます。</p>

<table border="1">
<tr><td>修正前</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/vsftpd<br>
<br>
6 /home/\*/ftp/\*<br>
6 /home/\*/ftp/\*/\*<br>
6 /home/\*/ftp/\*/\*/\*<br>
6 /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_mkdir /home/\*/ftp/\*/<br>
allow_mkdir /home/\*/ftp/\*/\*/<br>
allow_mkdir /home/\*/ftp/\*/\*/\*/<br>
<br>
allow_rmdir /home/\*/ftp/\*/<br>
allow_rmdir /home/\*/ftp/\*/\*/<br>
allow_rmdir /home/\*/ftp/\*/\*/\*/<br>
<br>
allow_create /home/\*/ftp/\*<br>
allow_create /home/\*/ftp/\*/\*<br>
allow_create /home/\*/ftp/\*/\*/\*<br>
allow_create /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_truncate /home/\*/ftp/\*<br>
allow_truncate /home/\*/ftp/\*/\*<br>
allow_truncate /home/\*/ftp/\*/\*/\*<br>
allow_truncate /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_unlink /home/\*/ftp/\*<br>
allow_unlink /home/\*/ftp/\*/\*<br>
allow_unlink /home/\*/ftp/\*/\*/\*<br>
allow_unlink /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/ftp/\* /home/\*/ftp/\*<br>
allow_rename /home/\*/ftp/\*/\* /home/\*/ftp/\*/\*<br>
allow_rename /home/\*/ftp/\*/\*/\* /home/\*/ftp/\*/\*/\*<br>
allow_rename /home/\*/ftp/\*/\*/\*/\* /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/ftp/\*/ /home/\*/ftp/\*/<br>
allow_rename /home/\*/ftp/\*/\*/ /home/\*/ftp/\*/\*/<br>
allow_rename /home/\*/ftp/\*/\*/\*/ /home/\*/ftp/\*/\*/\*/<br>
</td></tr>
</table>


<table border="1">
<tr><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/vsftpd<br>
<br>
6 /home/\*/ftp/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_mkdir /home/\*/ftp/\*/ if task.uid=path1.parent.uid<br>
allow_mkdir /home/\*/ftp/\*/\*/ if task.uid=path1.parent.uid<br>
allow_mkdir /home/\*/ftp/\*/\*/\*/ if task.uid=path1.parent.uid<br>
<br>
allow_rmdir /home/\*/ftp/\*/ if task.uid=path1.uid<br>
allow_rmdir /home/\*/ftp/\*/\*/ if task.uid=path1.uid<br>
allow_rmdir /home/\*/ftp/\*/\*/\*/ if task.uid=path1.uid<br>
<br>
allow_create /home/\*/ftp/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\*/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.parent.uid<br>
<br>
allow_truncate /home/\*/ftp/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_unlink /home/\*/ftp/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_rename /home/\*/ftp/\* /home/\*/ftp/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\* /home/\*/ftp/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\* /home/\*/ftp/\*/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\*/\* /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
<br>
allow_rename /home/\*/ftp/\*/ /home/\*/ftp/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/ /home/\*/ftp/\*/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\*/ /home/\*/ftp/\*/\*/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
</td></tr>
</table>

<p>Samba サーバを保護する場合、以下のように条件を付けることで、当該ユーザのホームディレクトリ以外へのアクセスを禁止することができるようになります。ホームディレクトリ以下全部を Samba でアクセス可能にすることは、侵入された場合に被害が大きくなるため、自分のホームディレクトリにある samba ディレクトリ以下だけのアクセスを認めます。</p>

<table border="1">
<tr><td>修正前</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
<br>
6 /home/\*/samba/\*<br>
6 /home/\*/samba/\*/\*<br>
6 /home/\*/samba/\*/\*/\*<br>
6 /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_mkdir /home/\*/samba/\*/<br>
allow_mkdir /home/\*/samba/\*/\*/<br>
allow_mkdir /home/\*/samba/\*/\*/\*/<br>
<br>
allow_rmdir /home/\*/samba/\*/<br>
allow_rmdir /home/\*/samba/\*/\*/<br>
allow_rmdir /home/\*/samba/\*/\*/\*/<br>
<br>
allow_create /home/\*/samba/\*<br>
allow_create /home/\*/samba/\*/\*<br>
allow_create /home/\*/samba/\*/\*/\*<br>
allow_create /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_truncate /home/\*/samba/\*<br>
allow_truncate /home/\*/samba/\*/\*<br>
allow_truncate /home/\*/samba/\*/\*/\*<br>
allow_truncate /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_unlink /home/\*/samba/\*<br>
allow_unlink /home/\*/samba/\*/\*<br>
allow_unlink /home/\*/samba/\*/\*/\*<br>
allow_unlink /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/samba/\* /home/\*/samba/\*<br>
allow_rename /home/\*/samba/\*/\* /home/\*/samba/\*/\*<br>
allow_rename /home/\*/samba/\*/\*/\* /home/\*/samba/\*/\*/\*<br>
allow_rename /home/\*/samba/\*/\*/\*/\* /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/samba/\*/ /home/\*/samba/\*/<br>
allow_rename /home/\*/samba/\*/\*/ /home/\*/samba/\*/\*/<br>
allow_rename /home/\*/samba/\*/\*/\*/ /home/\*/samba/\*/\*/\*/
</td></tr>
</table>

<table border="1">
<tr><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
<br>
6 /home/\*/samba/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_mkdir /home/\*/samba/\*/ if task.euid=path1.parent.uid<br>
allow_mkdir /home/\*/samba/\*/\*/ if task.euid=path1.parent.uid<br>
allow_mkdir /home/\*/samba/\*/\*/\*/ if task.euid=path1.parent.uid<br>
<br>
allow_rmdir /home/\*/samba/\*/ if task.euid=path1.uid<br>
allow_rmdir /home/\*/samba/\*/\*/ if task.euid=path1.uid<br>
allow_rmdir /home/\*/samba/\*/\*/\*/ if task.euid=path1.uid<br>
<br>
allow_create /home/\*/samba/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\*/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\*/\*/\* if task.euid=path1.parent.uid<br>
<br>
allow_truncate /home/\*/samba/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_unlink /home/\*/samba/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_rename /home/\*/samba/\* /home/\*/samba/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\* /home/\*/samba/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\* /home/\*/samba/\*/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\*/\* /home/\*/samba/\*/\*/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
<br>
allow_rename /home/\*/samba/\*/ /home/\*/samba/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/ /home/\*/samba/\*/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\*/ /home/\*/samba/\*/\*/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid
</td></tr>
</table>

<p>SSH サーバを保護する場合、以下のように条件を付けることで、 root ユーザとしてログインすることを禁止できます。</p>

<table border="1">
<tr><td>修正前</td><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
<br>
1 /bin/bash
</td><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
<br>
1 /bin/bash if task.uid!=0 task.euid!=0
</td></tr>
</table>

<p>指定可能な条件については<a href="policy-reference.html#conditional_acl">条件付きアクセス許可</a>を参照してください。</p>

<h2><a name="permissive-mode">確認モード</a></h2>

<p>起動時のブートプロンプトで TOMOYO Linux カーネルを選択し、許容モード用のプロファイル番号を CCS= に指定して起動します。</p>
<p>許可したい操作を行ってもエラーメッセージが表示されないことを確認してください。</p>
<p>正常に動作すればポリシーの完成です。</p>

<h1><a name="production-state">ポリシーの利用</a></h1>

<h2><a name="enforce-mode">強制モード</a></h2>

<p>起動時のブートプロンプトで TOMOYO Linux カーネルを選択し、強制モード用のプロファイル番号を CCS= に指定して起動します。</p>
</body>
</html>
