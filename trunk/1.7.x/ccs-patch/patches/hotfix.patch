--- old/README.ccs
+++ new/README.ccs
@@ -2244,3 +2244,60 @@
       I added a check for PROFILE_VERSION= .
 
 Version 1.7.1   2009/11/11   Fourth anniversary release.
+
+Fix 2009/11/13
+
+    @ Don't use core_initcall() for initializing lock for GC.
+
+     Some kernels call TOMOYO's hooks before processing core_initcall().
+     Thus, I can't use core_initcall() for initializing lock for GC.
+
+Fix 2009/11/18
+
+    @ Don't check "allow_write" permission for open(O_RDONLY | O_TRUNC).
+
+      Since TOMOYO checks "allow_truncate" permission rather than "allow_write"
+      permission for O_TRUNC, I need to distinguish open(O_RDONLY | O_TRUNC)
+      and open(O_RDWR | O_TRUNC). But I made a mistake between TOMOYO 1.7.0 and
+      1.7.1 which made it impossible for TOMOYO for kernels 2.6.14 and earlier
+      to distinguish them.
+
+Fix 2009/11/27
+
+    @ Use newly created domain's name for domain creation audit log.
+
+      Since 1.7.0 , /proc/ccs/reject_log was by error using existing domain's
+      name when auditing newly created domain's "use_profile" line.
+
+Fix 2009/12/12
+
+    @ Use rcu_read_lock() for find_task_by_pid().
+
+      Since kernel 2.6.18 , caller of find_task_by_pid() needs to call
+      rcu_read_lock() rather than read_lock(&tasklist_lock) because find_pid()
+      uses RCU primitives but spinlock does not prevent RCU callback if
+      preemptive RCU ( CONFIG_PREEMPT_RCU or CONFIG_TREE_PREEMPT_RCU ) is
+      enabled.
+
+Fix 2009/12/17
+
+    @ Don't check read permission in ccs_try_alt_exec().
+
+      While I was trying to remove ccs_execve_list list for GC optimization
+      between TOMOYO 1.7.0 and 1.7.1 , I made a mistake which made TOMOYO to
+      check allow_read permission of the programs specified by execute_handler
+      and denied_execute_handler keywords.
+
+Fix 2009/12/19
+
+    @ Fix memory leak in ccs_environ().
+
+      When I fixed a bug that a permission like
+
+        allow_env PATH if exec.envp["PATH"]="/"
+
+      was not working (2009/11/02), I allocated two buffers but only one buffer
+      was released.
+
+      This bug will trigger OOM killer if environment variable checking is
+      enabled.
--- old/security/ccsecurity/domain.c
+++ new/security/ccsecurity/domain.c
@@ -658,7 +658,7 @@
 	}
 	domain = ccs_find_or_assign_new_domain(ee->tmp, r->profile);
 	if (domain)
-		ccs_audit_domain_creation_log(r->domain);
+		ccs_audit_domain_creation_log(domain);
  done:
 	if (!domain) {
 		printk(KERN_WARNING "ERROR: Domain '%s' not defined.\n",
@@ -757,6 +757,7 @@
 	if (r->mode != 3)
 		error = 0;
 	kfree(env_page.data);
+	kfree(arg_ptr);
 	return error;
 }
 
@@ -1180,13 +1181,6 @@
 	ee->previous_domain = task->ccs_domain_info;
 	/* Clear manager flag. */
 	task->ccs_flags &= ~CCS_TASK_IS_POLICY_MANAGER;
-	/* Tell GC that I started execve(). */
-	task->ccs_flags |= CCS_TASK_IS_IN_EXECVE;
-	/*
-	 * Make task->ccs_flags visible to GC before changing
-	 * task->ccs_domain_info .
-	 */
-	smp_mb();
 	*eep = ee;
 	ccs_init_request_info(&ee->r, NULL, CCS_MAC_FILE_EXECUTE);
 	ee->r.ee = ee;
@@ -1212,6 +1206,16 @@
 	if (retval < 0)
 		goto out;
 	/*
+	 * Tell GC that I started execve().
+	 * Also, tell open_exec() to check read permission.
+	 */
+	task->ccs_flags |= CCS_TASK_IS_IN_EXECVE;
+	/*
+	 * Make task->ccs_flags visible to GC before changing
+	 * task->ccs_domain_info .
+	 */
+	smp_mb();
+	/*
 	 * Proceed to the next domain in order to allow reaching via PID.
 	 * It will be reverted if execve() failed. Reverting is not good.
 	 * But it is better than being unable to reach via PID in interactive
--- old/security/ccsecurity/file.c
+++ new/security/ccsecurity/file.c
@@ -1240,11 +1240,17 @@
 {
 	if ((mode & 3) == 3)
 		current->ccs_flags |= CCS_OPEN_FOR_IOCTL_ONLY;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 14)
+	/* O_TRUNC passes MAY_WRITE to ccs_open_permission(). */
+	else if (!(mode & 3) && (mode & O_TRUNC))
+		current->ccs_flags |= CCS_OPEN_FOR_READ_TRUNCATE;
+#endif
 }
 
 void ccs_clear_open_mode(void)
 {
-	current->ccs_flags &= ~CCS_OPEN_FOR_IOCTL_ONLY;
+	current->ccs_flags &= ~(CCS_OPEN_FOR_IOCTL_ONLY |
+				CCS_OPEN_FOR_READ_TRUNCATE);
 }
 
 /**
@@ -1265,14 +1271,17 @@
 		.path1.mnt = mnt
 	};
 	struct task_struct * const task = current;
-	const u8 acc_mode = task->ccs_flags & CCS_OPEN_FOR_IOCTL_ONLY ?
-		0 : ACC_MODE(flag);
+	const u32 ccs_flags = task->ccs_flags;
+	const u8 acc_mode = (ccs_flags & CCS_OPEN_FOR_IOCTL_ONLY) ? 0 :
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 14)
+		(ccs_flags & CCS_OPEN_FOR_READ_TRUNCATE) ? 4 :
+#endif
+		ACC_MODE(flag);
 	int error = 0;
 	struct ccs_path_info buf;
 	int idx;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
-	if (task->in_execve &&
-	    !(task->ccs_flags & CCS_TASK_IS_IN_EXECVE))
+	if (task->in_execve && !(ccs_flags & CCS_TASK_IS_IN_EXECVE))
 		return 0;
 #endif
 	if (!mnt || (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode)))
--- old/security/ccsecurity/gc.c
+++ new/security/ccsecurity/gc.c
@@ -136,7 +136,7 @@
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 0)
 	struct task_struct *g;
 	struct task_struct *t;
-	read_lock(&tasklist_lock);
+	ccs_tasklist_lock();
 	do_each_thread(g, t) {
 		if (!(t->ccs_flags & CCS_TASK_IS_IN_EXECVE)) {
 			smp_mb(); /* Avoid out of order execution. */
@@ -147,10 +147,10 @@
 		goto out;
 	} while_each_thread(g, t);
  out:
-	read_unlock(&tasklist_lock);
+	ccs_tasklist_unlock();
 #else
 	struct task_struct *p;
-	read_lock(&tasklist_lock);
+	ccs_tasklist_lock();
 	for_each_process(p) {
 		if (!(p->ccs_flags & CCS_TASK_IS_IN_EXECVE)) {
 			smp_mb(); /* Avoid out of order execution. */
@@ -160,7 +160,7 @@
 		in_use = true;
 		break;
 	}
-	read_unlock(&tasklist_lock);
+	ccs_tasklist_unlock();
 #endif
 	return in_use;
 }
@@ -382,30 +382,23 @@
 	return ptr->size;
 }
 
-/*
- * 2.6.19 has SRCU support but it triggers general protection fault in my
- * environment. Thus, I use SRCU for 2.6.20 and later.
- */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
 
 /* Lock for GC. */
 static struct srcu_struct ccs_ss;
 
-/**
- * ccs_gc_init - Initialize garbage collector.
- *
- * Returns 0.
- */
-static int __init ccs_gc_init(void)
-{
-	if (init_srcu_struct(&ccs_ss))
-		panic("Out of memory.");
-	return 0;
-}
-core_initcall(ccs_gc_init);
-
 int ccs_read_lock(void)
 {
+	/*
+	 * Kernel might try to populate root fs before processing initcalls.
+	 * Thus, I can't use core_initcall() for initializing ccs_ss.
+	 */
+	if (!ccs_ss.per_cpu_ref) {
+		mutex_lock(&ccs_policy_lock);
+		if (!ccs_ss.per_cpu_ref && init_srcu_struct(&ccs_ss))
+			panic("Out of memory.");
+		mutex_unlock(&ccs_policy_lock);
+	}
 	return srcu_read_lock(&ccs_ss);
 }
 
--- old/security/ccsecurity/internal.h
+++ new/security/ccsecurity/internal.h
@@ -305,6 +305,7 @@
 #define CCS_CONFIG_WANT_GRANT_LOG  128
 #define CCS_CONFIG_USE_DEFAULT     255
 
+#define CCS_OPEN_FOR_READ_TRUNCATE        4
 #define CCS_OPEN_FOR_IOCTL_ONLY           8
 #define CCS_TASK_IS_IN_EXECVE            16
 #define CCS_DONT_SLEEP_ON_ENFORCE_ERROR  32
@@ -1075,6 +1076,30 @@
 
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 18)
+
+static inline void ccs_tasklist_lock(void)
+{
+	rcu_read_lock();
+}
+static inline void ccs_tasklist_unlock(void)
+{
+	rcu_read_unlock();
+}
+
+#else
+
+static inline void ccs_tasklist_lock(void)
+{
+	read_lock(&tasklist_lock);
+}
+static inline void ccs_tasklist_unlock(void)
+{
+	read_unlock(&tasklist_lock);
+}
+
+#endif
+	
 static inline struct ccs_domain_info *ccs_task_domain(struct task_struct *task)
 {
 	struct ccs_domain_info *domain = task->ccs_domain_info;
--- old/security/ccsecurity/policy_io.c
+++ new/security/ccsecurity/policy_io.c
@@ -846,7 +846,7 @@
 	if (sscanf(data, "pid=%u", &pid) == 1 ||
 	    (global_pid = true, sscanf(data, "global-pid=%u", &pid) == 1)) {
 		struct task_struct *p;
-		read_lock(&tasklist_lock);
+		ccs_tasklist_lock();
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 		if (global_pid)
 			p = find_task_by_pid_ns(pid, &init_pid_ns);
@@ -857,7 +857,7 @@
 #endif
 		if (p)
 			domain = ccs_task_domain(p);
-		read_unlock(&tasklist_lock);
+		ccs_tasklist_unlock();
 	} else if (!strncmp(data, "domain=", 7)) {
 		if (ccs_is_domain_def(data + 7))
 			domain = ccs_find_domain(data + 7);
@@ -1807,7 +1807,7 @@
 	if (ccs_str_starts(&buf, "global-pid "))
 		global_pid = true;
 	pid = (unsigned int) simple_strtoul(buf, NULL, 10);
-	read_lock(&tasklist_lock);
+	ccs_tasklist_lock();
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 	if (global_pid)
 		p = find_task_by_pid_ns(pid, &init_pid_ns);
@@ -1820,7 +1820,7 @@
 		domain = ccs_task_domain(p);
 		ccs_flags = p->ccs_flags;
 	}
-	read_unlock(&tasklist_lock);
+	ccs_tasklist_unlock();
 	if (!domain)
 		return;
 	if (!task_info)
--- old/security/ccsecurity/signal.c
+++ new/security/ccsecurity/signal.c
@@ -66,7 +66,7 @@
 	}
 	{ /* Simplified checking. */
 		struct task_struct *p = NULL;
-		read_lock(&tasklist_lock);
+		ccs_tasklist_lock();
 		if (pid > 0)
 			p = find_task_by_pid((pid_t) pid);
 		else if (pid == 0)
@@ -77,7 +77,7 @@
 			p = find_task_by_pid((pid_t) -pid);
 		if (p)
 			dest = ccs_task_domain(p);
-		read_unlock(&tasklist_lock);
+		ccs_tasklist_unlock();
 	}
 	if (!dest)
 		return 0; /* I can't find destinatioin. */
