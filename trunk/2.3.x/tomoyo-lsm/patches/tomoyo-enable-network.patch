diff --git a/security/tomoyo/Kconfig b/security/tomoyo/Kconfig
index c8f3857..40cb383 100644
--- a/security/tomoyo/Kconfig
+++ b/security/tomoyo/Kconfig
@@ -1,8 +1,10 @@
 config SECURITY_TOMOYO
 	bool "TOMOYO Linux Support"
 	depends on SECURITY
+	depends on NET
 	select SECURITYFS
 	select SECURITY_PATH
+	select SECURITY_NETWORK
 	default n
 	help
 	  This selects TOMOYO Linux, pathname-based access control.
diff --git a/security/tomoyo/Makefile b/security/tomoyo/Makefile
index 91640e9..da6a9d5 100644
--- a/security/tomoyo/Makefile
+++ b/security/tomoyo/Makefile
@@ -1 +1 @@
-obj-y = common.o domain.o file.o gc.o group.o load_policy.o memory.o mount.o realpath.o securityfs_if.o tomoyo.o util.o
+obj-y = common.o domain.o file.o gc.o group.o load_policy.o memory.o mount.o network.o realpath.o securityfs_if.o tomoyo.o util.o
diff --git a/security/tomoyo/common.c b/security/tomoyo/common.c
index bff6392..9574949 100644
--- a/security/tomoyo/common.c
+++ b/security/tomoyo/common.c
@@ -58,7 +58,16 @@ static const char *tomoyo_mac_keywords[TOMOYO_MAX_MAC_INDEX
 	[TOMOYO_MAC_FILE_MOUNT]      = "file::mount",
 	[TOMOYO_MAC_FILE_UMOUNT]     = "file::umount",
 	[TOMOYO_MAC_FILE_PIVOT_ROOT] = "file::pivot_root",
+	[TOMOYO_MAC_NETWORK_UDP_BIND]    = "network::inet_udp_bind",
+	[TOMOYO_MAC_NETWORK_UDP_CONNECT] = "network::inet_udp_connect",
+	[TOMOYO_MAC_NETWORK_TCP_BIND]    = "network::inet_tcp_bind",
+	[TOMOYO_MAC_NETWORK_TCP_LISTEN]  = "network::inet_tcp_listen",
+	[TOMOYO_MAC_NETWORK_TCP_CONNECT] = "network::inet_tcp_connect",
+	[TOMOYO_MAC_NETWORK_TCP_ACCEPT]  = "network::inet_tcp_accept",
+	[TOMOYO_MAC_NETWORK_RAW_BIND]    = "network::inet_raw_bind",
+	[TOMOYO_MAC_NETWORK_RAW_CONNECT] = "network::inet_raw_connect",
 	[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_FILE] = "file",
+	[TOMOYO_MAX_MAC_INDEX + TOMOYO_MAC_CATEGORY_NETWORK] = "network",
 };
 
 /* Permit policy management by non-root user? */
@@ -823,6 +832,8 @@ static int tomoyo_write_domain2(char *data, struct tomoyo_domain_info *domain,
 {
 	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_ALLOW_MOUNT))
 		return tomoyo_write_mount(data, domain, is_delete);
+	if (tomoyo_str_starts(&data, TOMOYO_KEYWORD_ALLOW_NETWORK))
+		return tomoyo_write_network(data, domain, is_delete);
 	return tomoyo_write_file(data, domain, is_delete);
 }
 
@@ -984,6 +995,34 @@ static bool tomoyo_print_entry(struct tomoyo_io_buffer *head,
 		tomoyo_print_name_union(head, &ptr->dir_name);
 		tomoyo_print_name_union(head, &ptr->fs_type);
 		tomoyo_print_number_union(head, &ptr->flags);
+	} else if (acl_type == TOMOYO_TYPE_IP_NETWORK_ACL) {
+		struct tomoyo_ip_network_acl *ptr =
+			container_of(acl, typeof(*ptr), head);
+		bit = tomoyo_fns(ptr->perm, bit);
+		if (bit >= TOMOYO_MAX_NETWORK_OPERATION)
+			goto done;
+		tomoyo_set_string(head, "allow_network ");
+		tomoyo_set_string(head, tomoyo_net_keyword[bit]);
+		tomoyo_set_space(head);
+		switch (ptr->address_type) {
+			char buf[128];
+		case TOMOYO_IP_ADDRESS_TYPE_ADDRESS_GROUP:
+			tomoyo_set_string(head, "@");
+			tomoyo_set_string(head,
+					  ptr->address.group->group_name->name);
+			break;
+		case TOMOYO_IP_ADDRESS_TYPE_IPv4:
+			tomoyo_print_ipv4(buf, sizeof(buf), ptr->address.ipv4
+					  .min, ptr->address.ipv4.max);
+			tomoyo_io_printf(head, "%s", buf);
+			break;
+		case TOMOYO_IP_ADDRESS_TYPE_IPv6:
+			tomoyo_print_ipv6(buf, sizeof(buf), ptr->address.ipv6
+					  .min, ptr->address.ipv6.max);
+			tomoyo_io_printf(head, "%s", buf);
+			break;
+		}
+		tomoyo_print_number_union(head, &ptr->port);
 	}
 	head->r.bit = bit + 1;
 	tomoyo_io_printf(head, "\n");
@@ -1206,7 +1245,8 @@ static const char *tomoyo_transition_type[TOMOYO_MAX_TRANSITION_TYPE] = {
 
 static const char *tomoyo_group_name[TOMOYO_MAX_GROUP] = {
 	[TOMOYO_PATH_GROUP] = TOMOYO_KEYWORD_PATH_GROUP,
-	[TOMOYO_NUMBER_GROUP] = TOMOYO_KEYWORD_NUMBER_GROUP
+	[TOMOYO_NUMBER_GROUP] = TOMOYO_KEYWORD_NUMBER_GROUP,
+	[TOMOYO_ADDRESS_GROUP] = TOMOYO_KEYWORD_ADDRESS_GROUP
 };
 
 /**
@@ -1280,7 +1320,22 @@ static bool tomoyo_read_group(struct tomoyo_io_buffer *head, const int idx)
 							  (ptr,
 						   struct tomoyo_number_group,
 							   head)->number);
+			} else if (idx == TOMOYO_ADDRESS_GROUP) {
+				char buffer[128];
+				struct tomoyo_address_group *member =
+					container_of(ptr, typeof(*member),
+						     head);
+				if (member->is_ipv6)
+					tomoyo_print_ipv6(buffer, sizeof(buffer),
+							  member->min.ipv6,
+							  member->max.ipv6);
+				else
+					tomoyo_print_ipv4(buffer, sizeof(buffer),
+							  member->min.ipv4,
+							  member->max.ipv4);
+				tomoyo_io_printf(head, " %s", buffer);
 			}
+
 			tomoyo_set_lf(head);
 		}
 		head->r.acl = NULL;
diff --git a/security/tomoyo/common.h b/security/tomoyo/common.h
index 2ffad61..c864f6d 100644
--- a/security/tomoyo/common.h
+++ b/security/tomoyo/common.h
@@ -21,6 +21,13 @@
 #include <linux/list.h>
 #include <linux/cred.h>
 #include <linux/poll.h>
+#include <linux/net.h>
+#include <linux/inet.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/udp.h>
 struct linux_binprm;
 
 /********** Constants definitions. **********/
@@ -50,6 +57,7 @@ enum tomoyo_policy_id {
 	TOMOYO_ID_GROUP,
 	TOMOYO_ID_PATH_GROUP,
 	TOMOYO_ID_NUMBER_GROUP,
+	TOMOYO_ID_ADDRESS_GROUP,
 	TOMOYO_ID_TRANSITION_CONTROL,
 	TOMOYO_ID_AGGREGATOR,
 	TOMOYO_ID_GLOBALLY_READABLE,
@@ -62,15 +70,22 @@ enum tomoyo_policy_id {
 	TOMOYO_MAX_POLICY
 };
 
+enum tomoyo_shared_acl_id {
+	TOMOYO_IPV6ADDRESS_LIST,
+	TOMOYO_MAX_LIST
+};
+
 enum tomoyo_group_id {
 	TOMOYO_PATH_GROUP,
 	TOMOYO_NUMBER_GROUP,
+	TOMOYO_ADDRESS_GROUP,
 	TOMOYO_MAX_GROUP
 };
 
 /* Keywords for ACLs. */
 #define TOMOYO_KEYWORD_AGGREGATOR                "aggregator "
 #define TOMOYO_KEYWORD_ALLOW_MOUNT               "allow_mount "
+#define TOMOYO_KEYWORD_ALLOW_NETWORK             "allow_network "
 #define TOMOYO_KEYWORD_ALLOW_READ                "allow_read "
 #define TOMOYO_KEYWORD_DELETE                    "delete "
 #define TOMOYO_KEYWORD_DENY_REWRITE              "deny_rewrite "
@@ -79,6 +94,7 @@ enum tomoyo_group_id {
 #define TOMOYO_KEYWORD_KEEP_DOMAIN               "keep_domain "
 #define TOMOYO_KEYWORD_NO_INITIALIZE_DOMAIN      "no_initialize_domain "
 #define TOMOYO_KEYWORD_NO_KEEP_DOMAIN            "no_keep_domain "
+#define TOMOYO_KEYWORD_ADDRESS_GROUP             "address_group "
 #define TOMOYO_KEYWORD_PATH_GROUP                "path_group "
 #define TOMOYO_KEYWORD_NUMBER_GROUP              "number_group "
 #define TOMOYO_KEYWORD_SELECT                    "select "
@@ -112,6 +128,7 @@ enum tomoyo_acl_entry_type_index {
 	TOMOYO_TYPE_PATH_NUMBER_ACL,
 	TOMOYO_TYPE_MKDEV_ACL,
 	TOMOYO_TYPE_MOUNT_ACL,
+	TOMOYO_TYPE_IP_NETWORK_ACL,
 };
 
 /* Index numbers for File Controls. */
@@ -169,6 +186,32 @@ enum tomoyo_path_number_acl_index {
 	TOMOYO_MAX_PATH_NUMBER_OPERATION
 };
 
+enum tomoyo_network_acl_index {
+	/* UDP's bind() operation. */
+	TOMOYO_NETWORK_UDP_BIND,
+	/* UDP's connect()/send()/recv() operation. */
+	TOMOYO_NETWORK_UDP_CONNECT,
+	/* TCP's bind() operation. */
+	TOMOYO_NETWORK_TCP_BIND,
+	/* TCP's listen() operation. */
+	TOMOYO_NETWORK_TCP_LISTEN,
+	/* TCP's connect() operation. */
+	TOMOYO_NETWORK_TCP_CONNECT,
+	/* TCP's accept() operation. */
+	TOMOYO_NETWORK_TCP_ACCEPT,
+	/* IP's bind() operation. */
+	TOMOYO_NETWORK_RAW_BIND,
+	/* IP's connect()/send()/recv() operation. */
+	TOMOYO_NETWORK_RAW_CONNECT,
+	TOMOYO_MAX_NETWORK_OPERATION
+};
+
+enum tomoyo_ip_address_type {
+	TOMOYO_IP_ADDRESS_TYPE_ADDRESS_GROUP,
+	TOMOYO_IP_ADDRESS_TYPE_IPv4,
+	TOMOYO_IP_ADDRESS_TYPE_IPv6
+};
+
 enum tomoyo_securityfs_interface_index {
 	TOMOYO_DOMAINPOLICY,
 	TOMOYO_EXCEPTIONPOLICY,
@@ -206,11 +249,20 @@ enum tomoyo_mac_index {
 	TOMOYO_MAC_FILE_MOUNT,
 	TOMOYO_MAC_FILE_UMOUNT,
 	TOMOYO_MAC_FILE_PIVOT_ROOT,
+	TOMOYO_MAC_NETWORK_UDP_BIND,
+	TOMOYO_MAC_NETWORK_UDP_CONNECT,
+	TOMOYO_MAC_NETWORK_TCP_BIND,
+	TOMOYO_MAC_NETWORK_TCP_LISTEN,
+	TOMOYO_MAC_NETWORK_TCP_CONNECT,
+	TOMOYO_MAC_NETWORK_TCP_ACCEPT,
+	TOMOYO_MAC_NETWORK_RAW_BIND,
+	TOMOYO_MAC_NETWORK_RAW_CONNECT,
 	TOMOYO_MAX_MAC_INDEX
 };
 
 enum tomoyo_mac_category_index {
 	TOMOYO_MAC_CATEGORY_FILE,
+	TOMOYO_MAC_CATEGORY_NETWORK,
 	TOMOYO_MAX_MAC_CATEGORY_INDEX
 };
 
@@ -232,6 +284,11 @@ struct tomoyo_acl_head {
 	bool is_deleted;
 } __packed;
 
+struct tomoyo_shared_acl_head {
+	struct list_head list;
+	atomic_t users;
+} __attribute__((__packed__));
+
 /*
  * tomoyo_request_info is a structure which is used for holding
  *
@@ -272,6 +329,13 @@ struct tomoyo_request_info {
 			unsigned long flags;
 			int need_dev;
 		} mount;
+		struct {
+			const u32 *address;
+			u32 ip;
+			u16 port;
+			u8 operation;
+			bool is_ipv6;
+		} network;
 	} param;
 	u8 param_type;
 	bool granted;
@@ -353,6 +417,16 @@ struct tomoyo_number_group {
 	struct tomoyo_number_union number;
 };
 
+/* Structure for "address_group" directive. */
+struct tomoyo_address_group {
+	struct tomoyo_acl_head head;
+	bool is_ipv6;
+	union {
+		u32 ipv4;                    /* Host byte order    */
+		const struct in6_addr *ipv6; /* Network byte order */
+	} min, max;
+};
+
 /*
  * tomoyo_acl_info is a structure which is used for holding
  *
@@ -524,6 +598,44 @@ struct tomoyo_mount_acl {
 	struct tomoyo_number_union flags;
 };
 
+struct tomoyo_ipv6addr {
+	struct tomoyo_shared_acl_head head;
+	struct in6_addr addr;
+};
+
+/* Structure for "network" directive. */
+struct tomoyo_ip_network_acl {
+	struct tomoyo_acl_info head; /* type = TOMOYO_TYPE_IP_NETWORK_ACL */
+	u8 perm; /* Bitmask of values in "enum tomoyo_network_acl_index" */
+	/*
+	 * address_type takes one of the following constants.
+	 *   TOMOYO_IP_ADDRESS_TYPE_ADDRESS_GROUP
+	 *                if address points to "address_group" directive.
+	 *   TOMOYO_IP_ADDRESS_TYPE_IPv4
+	 *                if address points to an IPv4 address.
+	 *   TOMOYO_IP_ADDRESS_TYPE_IPv6
+	 *                if address points to an IPv6 address.
+	 */
+	u8 address_type;
+	union {
+		struct {
+			/* Start of IPv4 address range. Host endian. */
+			u32 min;
+			/* End of IPv4 address range. Host endian.   */
+			u32 max;
+		} ipv4;
+		struct {
+			/* Start of IPv6 address range. Big endian.  */
+			const struct in6_addr *min;
+			/* End of IPv6 address range. Big endian.    */
+			const struct in6_addr *max;
+		} ipv6;
+		/* Pointer to address group. */
+		struct tomoyo_group *group;
+	} address;
+	struct tomoyo_number_union port;
+};
+
 #define TOMOYO_MAX_IO_READ_QUEUE 32
 
 /*
@@ -694,6 +806,7 @@ extern asmlinkage long sys_getppid(void);
 bool tomoyo_str_starts(char **src, const char *find);
 /* Get tomoyo_realpath() of current process. */
 const char *tomoyo_get_exe(void);
+const struct in6_addr *tomoyo_get_ipv6_address(const struct in6_addr *addr);
 /* Format string. */
 void tomoyo_normalize_line(unsigned char *buffer);
 /* Print warning or error message on console. */
@@ -703,6 +816,7 @@ void tomoyo_warn_log(struct tomoyo_request_info *r, const char *fmt, ...)
 void tomoyo_check_profile(void);
 /* Open operation for /sys/kernel/security/tomoyo/ interface. */
 int tomoyo_open_control(const u8 type, struct file *file);
+int tomoyo_parse_ip_address(char *address, u16 *min, u16 *max);
 /* Close /sys/kernel/security/tomoyo/ interface. */
 int tomoyo_close_control(struct file *file);
 /* Poll operation for /sys/kernel/security/tomoyo/ interface. */
@@ -726,6 +840,8 @@ bool tomoyo_compare_number_union(const unsigned long value,
 int tomoyo_get_mode(const u8 profile, const u8 index);
 void tomoyo_io_printf(struct tomoyo_io_buffer *head, const char *fmt, ...)
 	__attribute__ ((format(printf, 2, 3)));
+bool tomoyo_address_matches_group(const bool is_ipv6, const u32 *address,
+				  const struct tomoyo_group *group);
 /* Check whether the domainname is correct. */
 bool tomoyo_correct_domain(const unsigned char *domainname);
 /* Check whether the token is correct. */
@@ -776,6 +892,8 @@ int tomoyo_write_globally_readable(char *data, const bool is_delete);
 /* Create "allow_mount" entry in domain policy. */
 int tomoyo_write_mount(char *data, struct tomoyo_domain_info *domain,
 		       const bool is_delete);
+int tomoyo_write_network(char *data, struct tomoyo_domain_info *domain,
+		      const bool is_delete);
 /* Create "deny_rewrite" entry in exception policy. */
 int tomoyo_write_no_rewrite(char *data, const bool is_delete);
 /* Create "file_pattern" entry in exception policy. */
@@ -852,6 +970,21 @@ int tomoyo_path2_perm(const u8 operation, struct path *path1,
 		      struct path *path2);
 int tomoyo_find_next_domain(struct linux_binprm *bprm);
 
+int tomoyo_socket_listen_permission(struct socket *sock);
+int tomoyo_socket_connect_permission(struct socket *sock, struct sockaddr *addr,
+				     int addr_len);
+int tomoyo_socket_bind_permission(struct socket *sock, struct sockaddr *addr,
+				  int addr_len);
+int tomoyo_socket_accept_permission(struct socket *sock);
+int tomoyo_socket_sendmsg_permission(struct socket *sock, struct msghdr *msg,
+				     int size);
+int tomoyo_socket_recvmsg_permission(struct sock *sk, struct sk_buff *skb);
+
+void tomoyo_print_ipv4(char *buffer, const int buffer_len, const u32 min_ip,
+		       const u32 max_ip);
+void tomoyo_print_ipv6(char *buffer, const int buffer_len,
+		       const struct in6_addr *min_ip,
+		       const struct in6_addr *max_ip);
 void tomoyo_print_ulong(char *buffer, const int buffer_len,
 			const unsigned long value, const u8 type);
 
@@ -893,6 +1026,8 @@ extern struct list_head tomoyo_domain_list;
 extern struct list_head tomoyo_policy_list[TOMOYO_MAX_POLICY];
 extern struct list_head tomoyo_group_list[TOMOYO_MAX_GROUP];
 extern struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];
+extern struct list_head tomoyo_shared_list[TOMOYO_MAX_LIST];
+
 
 /* Lock for protecting policy. */
 extern struct mutex tomoyo_policy_lock;
@@ -905,6 +1040,7 @@ extern struct tomoyo_domain_info tomoyo_kernel_domain;
 
 extern const char *tomoyo_path_keyword[TOMOYO_MAX_PATH_OPERATION];
 extern const char *tomoyo_mkdev_keyword[TOMOYO_MAX_MKDEV_OPERATION];
+extern const char *tomoyo_net_keyword[TOMOYO_MAX_NETWORK_OPERATION];
 extern const char *tomoyo_path2_keyword[TOMOYO_MAX_PATH2_OPERATION];
 extern const char *tomoyo_path_number_keyword[TOMOYO_MAX_PATH_NUMBER_OPERATION];
 
@@ -969,6 +1105,13 @@ static inline void tomoyo_put_group(struct tomoyo_group *group)
 		atomic_dec(&group->users);
 }
 
+static inline void tomoyo_put_ipv6_address(const struct in6_addr *addr)
+{
+	if (addr)
+		atomic_dec(&container_of(addr, struct tomoyo_ipv6addr,
+					 addr)->head.users);
+}
+
 static inline struct tomoyo_domain_info *tomoyo_domain(void)
 {
 	return current_cred()->security;
diff --git a/security/tomoyo/domain.c b/security/tomoyo/domain.c
index 4e0101b..39d3282 100644
--- a/security/tomoyo/domain.c
+++ b/security/tomoyo/domain.c
@@ -132,6 +132,7 @@ LIST_HEAD(tomoyo_domain_list);
 
 struct list_head tomoyo_policy_list[TOMOYO_MAX_POLICY];
 struct list_head tomoyo_group_list[TOMOYO_MAX_GROUP];
+struct list_head tomoyo_shared_list[TOMOYO_MAX_LIST];
 
 /**
  * tomoyo_last_word - Get last component of a domainname.
diff --git a/security/tomoyo/gc.c b/security/tomoyo/gc.c
index a877e4c..818e38a 100644
--- a/security/tomoyo/gc.c
+++ b/security/tomoyo/gc.c
@@ -124,6 +124,24 @@ static void tomoyo_del_acl(struct list_head *element)
 			tomoyo_put_number_union(&entry->flags);
 		}
 		break;
+	case TOMOYO_TYPE_IP_NETWORK_ACL:
+		{
+			struct tomoyo_ip_network_acl *entry
+				= container_of(acl, typeof(*entry), head);
+			switch (entry->address_type) {
+			case TOMOYO_IP_ADDRESS_TYPE_ADDRESS_GROUP:
+				tomoyo_put_group(entry->address.group);
+				break;
+			case TOMOYO_IP_ADDRESS_TYPE_IPv6:
+				tomoyo_put_ipv6_address(entry->address.ipv6.
+							min);
+				tomoyo_put_ipv6_address(entry->address.ipv6.
+							max);
+				break;
+			}
+			tomoyo_put_number_union(&entry->port);
+		}
+		break;
 	}
 }
 
@@ -186,6 +204,16 @@ static void tomoyo_del_group(struct list_head *element)
 	tomoyo_put_name(group->group_name);
 }
 
+static void tomoyo_del_address_group(struct list_head *element)
+{
+	struct tomoyo_address_group *member =
+		container_of(element, typeof(*member), head.list);
+	if (member->is_ipv6) {
+		tomoyo_put_ipv6_address(member->min.ipv6);
+		tomoyo_put_ipv6_address(member->max.ipv6);
+	}
+}
+
 static void tomoyo_del_number_group(struct list_head *element)
 {
 	struct tomoyo_number_group *member =
@@ -241,6 +269,16 @@ static void tomoyo_collect_entry(void)
 				goto unlock;
 		}
 	}
+	for (i = 0; i < TOMOYO_MAX_LIST; i++) {
+		struct list_head *list = &tomoyo_shared_list[i];
+		struct tomoyo_shared_acl_head *ptr;
+		list_for_each_entry(ptr, list, list) {
+			if (atomic_read(&ptr->users))
+				continue;
+			if (!tomoyo_add_to_gc(i, &ptr->list))
+				goto unlock;
+		}
+	}
 	for (i = 0; i < TOMOYO_MAX_HASH; i++) {
 		struct tomoyo_name *ptr;
 		list_for_each_entry_rcu(ptr, &tomoyo_name_list[i], list) {
@@ -321,6 +359,9 @@ static void tomoyo_kfree_entry(void)
 		case TOMOYO_ID_NUMBER_GROUP:
 			tomoyo_del_number_group(element);
 			break;
+		case TOMOYO_ID_ADDRESS_GROUP:
+			tomoyo_del_address_group(element);
+			break;
 		}
 		tomoyo_memory_free(element);
 		list_del(&p->list);
diff --git a/security/tomoyo/group.c b/security/tomoyo/group.c
index 3f0a2ab..a65fab5 100644
--- a/security/tomoyo/group.c
+++ b/security/tomoyo/group.c
@@ -25,6 +25,18 @@ static bool tomoyo_same_number_group(const struct tomoyo_acl_head *a,
 			      ->number));
 }
 
+static bool tomoyo_same_address_group(const struct tomoyo_acl_head *a,
+				      const struct tomoyo_acl_head *b)
+{
+	const struct tomoyo_address_group *p1 = container_of(a, typeof(*p1),
+							  head);
+	const struct tomoyo_address_group *p2 = container_of(b, typeof(*p2),
+							  head);
+	return p1->is_ipv6 == p2->is_ipv6 &&
+		p1->min.ipv4 == p2->min.ipv4 && p1->min.ipv6 == p2->min.ipv6 &&
+		p1->max.ipv4 == p2->max.ipv4 && p1->max.ipv6 == p2->max.ipv6;
+}
+
 /**
  * tomoyo_write_group - Write "struct tomoyo_path_group"/"struct tomoyo_number_group" list.
  *
@@ -68,6 +80,35 @@ int tomoyo_write_group(char *data, const bool is_delete, const u8 type)
 		 * tomoyo_put_number_union() is not needed because
 		 * w[1][0] != '@'.
 		 */
+	} else {
+		struct tomoyo_address_group e = { };
+		u16 min_address[8];
+		u16 max_address[8];
+		switch (tomoyo_parse_ip_address(w[1], min_address,
+						max_address)) {
+		case TOMOYO_IP_ADDRESS_TYPE_IPv6:
+			e.is_ipv6 = true;
+			e.min.ipv6 = tomoyo_get_ipv6_address((struct in6_addr *)
+							     min_address);
+			e.max.ipv6 = tomoyo_get_ipv6_address((struct in6_addr *)
+							     max_address);
+			if (!e.min.ipv6 || !e.max.ipv6)
+				goto out_address;
+			break;
+		case TOMOYO_IP_ADDRESS_TYPE_IPv4:
+			e.min.ipv4 = ntohl(*(u32 *) min_address);
+			e.max.ipv4 = ntohl(*(u32 *) max_address);
+			break;
+		default:
+			goto out_address;
+		}
+		error = tomoyo_update_policy(&e.head, sizeof(e), is_delete,
+					     member, tomoyo_same_address_group);
+ out_address:
+		if (e.is_ipv6) {
+			tomoyo_put_ipv6_address(e.min.ipv6);
+			tomoyo_put_ipv6_address(e.max.ipv6);
+		}
 	}
  out:
 	tomoyo_put_group(group);
@@ -128,3 +169,41 @@ bool tomoyo_number_matches_group(const unsigned long min,
 	}
 	return matched;
 }
+
+/**
+ * tomoyo_address_matches_group - Check whether the given address matches members of the given address group.
+ *
+ * @is_ipv6: True if @address is an IPv6 address.
+ * @address: An IPv4 or IPv6 address.
+ * @group:   Pointer to "struct tomoyo_address_group".
+ *
+ * Returns true if @address matches addresses in @group group, false otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+bool tomoyo_address_matches_group(const bool is_ipv6, const u32 *address,
+				  const struct tomoyo_group *group)
+{
+	struct tomoyo_address_group *member;
+	const u32 ip = ntohl(*address);
+	bool matched = false;
+	list_for_each_entry_rcu(member, &group->member_list, head.list) {
+		if (member->head.is_deleted)
+			continue;
+		if (member->is_ipv6) {
+			if (is_ipv6 &&
+			    memcmp(member->min.ipv6, address, 16) <= 0 &&
+			    memcmp(address, member->max.ipv6, 16) <= 0) {
+				matched = true;
+				break;
+			}
+		} else {
+			if (!is_ipv6 &&
+			    member->min.ipv4 <= ip && ip <= member->max.ipv4) {
+				matched = true;
+				break;
+			}
+		}
+	}
+	return matched;
+}
diff --git a/security/tomoyo/memory.c b/security/tomoyo/memory.c
index 2976126..a12ebcd 100644
--- a/security/tomoyo/memory.c
+++ b/security/tomoyo/memory.c
@@ -133,6 +133,48 @@ struct tomoyo_group *tomoyo_get_group(const char *group_name, const u8 idx)
 	return found ? group : NULL;
 }
 
+/**
+ * tomoyo_get_ipv6_address - Keep the given IPv6 address on the RAM.
+ *
+ * @addr: Pointer to "struct in6_addr".
+ *
+ * Returns pointer to "struct in6_addr" on success, NULL otherwise.
+ *
+ * The RAM is shared, so NEVER try to modify or kfree() the returned address.
+ */
+const struct in6_addr *tomoyo_get_ipv6_address(const struct in6_addr *addr)
+{
+	struct tomoyo_ipv6addr *entry;
+	struct tomoyo_ipv6addr *ptr = NULL;
+	int error = -ENOMEM;
+	if (!addr)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_NOFS);
+	if (mutex_lock_interruptible(&tomoyo_policy_lock))
+		goto out;
+	list_for_each_entry(ptr, &tomoyo_shared_list[TOMOYO_IPV6ADDRESS_LIST],
+			    head.list) {
+		if (memcmp(&ptr->addr, addr, sizeof(*addr)))
+			continue;
+		atomic_inc(&ptr->head.users);
+		error = 0;
+		break;
+	}
+	if (error && tomoyo_memory_ok(entry)) {
+		ptr = entry;
+		ptr->addr = *addr;
+		atomic_set(&ptr->head.users, 1);
+		list_add_tail(&ptr->head.list,
+			      &tomoyo_shared_list[TOMOYO_IPV6ADDRESS_LIST]);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&tomoyo_policy_lock);
+ out:
+	kfree(entry);
+	return !error ? &ptr->addr : NULL;
+}
+
 /*
  * tomoyo_name_list is used for holding string data used by TOMOYO.
  * Since same string data is likely used for multiple times (e.g.
@@ -201,6 +243,8 @@ void __init tomoyo_mm_init(void)
 		INIT_LIST_HEAD(&tomoyo_policy_list[idx]);
 	for (idx = 0; idx < TOMOYO_MAX_GROUP; idx++)
 		INIT_LIST_HEAD(&tomoyo_group_list[idx]);
+	for (idx = 0; idx < TOMOYO_MAX_LIST; idx++)
+		INIT_LIST_HEAD(&tomoyo_shared_list[idx]);
 	for (idx = 0; idx < TOMOYO_MAX_HASH; idx++)
 		INIT_LIST_HEAD(&tomoyo_name_list[idx]);
 	INIT_LIST_HEAD(&tomoyo_kernel_domain.acl_info_list);
diff --git a/security/tomoyo/tomoyo.c b/security/tomoyo/tomoyo.c
index 95d3f95..7643352 100644
--- a/security/tomoyo/tomoyo.c
+++ b/security/tomoyo/tomoyo.c
@@ -236,6 +236,40 @@ static int tomoyo_sb_pivotroot(struct path *old_path, struct path *new_path)
 	return tomoyo_path2_perm(TOMOYO_TYPE_PIVOT_ROOT, new_path, old_path);
 }
 
+static int tomoyo_socket_listen(struct socket *sock, int backlog)
+{
+	return tomoyo_socket_listen_permission(sock);
+}
+
+static int tomoyo_socket_connect(struct socket *sock, struct sockaddr *addr,
+				 int addr_len)
+{
+	return tomoyo_socket_connect_permission(sock, addr, addr_len);
+}
+
+static int tomoyo_socket_bind(struct socket *sock, struct sockaddr *addr,
+			      int addr_len)
+{
+	return tomoyo_socket_bind_permission(sock, addr, addr_len);
+}
+
+static int tomoyo_socket_post_accept(struct socket *sock,
+				     struct socket *newsock)
+{
+	return tomoyo_socket_accept_permission(newsock);
+}
+
+static int tomoyo_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+				 int size)
+{
+	return tomoyo_socket_sendmsg_permission(sock, msg, size);
+}
+
+static int tomoyo_socket_post_recvmsg(struct sock *sk, struct sk_buff *skb)
+{
+	return tomoyo_socket_recvmsg_permission(sk, skb);
+}
+
 /*
  * tomoyo_security_ops is a "struct security_operations" which is used for
  * registering TOMOYO.
@@ -265,6 +299,12 @@ static struct security_operations tomoyo_security_ops = {
 	.sb_mount            = tomoyo_sb_mount,
 	.sb_umount           = tomoyo_sb_umount,
 	.sb_pivotroot        = tomoyo_sb_pivotroot,
+	.socket_bind         = tomoyo_socket_bind,
+	.socket_listen       = tomoyo_socket_listen,
+	.socket_connect      = tomoyo_socket_connect,
+	.socket_post_accept  = tomoyo_socket_post_accept,
+	.socket_sendmsg      = tomoyo_socket_sendmsg,
+	.socket_post_recvmsg = tomoyo_socket_post_recvmsg,
 };
 
 /* Lock for GC. */
