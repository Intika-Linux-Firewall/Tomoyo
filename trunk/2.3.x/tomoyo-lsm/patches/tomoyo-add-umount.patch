[TOMOYO] Add unmount restriction.

This patch handles "allow_unmount" directive.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/umount.c |  151 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 151 insertions(+)

--- /dev/null
+++ linux-2.6.32-rc1/security/tomoyo/umount.c
@@ -0,0 +1,151 @@
+/*
+ * security/tomoyo/umount.c
+ *
+ * Copyright (C) 2005-2009  NTT DATA CORPORATION
+ */
+#include "internal.h"
+#include <linux/mount.h>
+
+/**
+ * tomoyo_audit_umount_log - Audit unmount log.
+ *
+ * @r:          Pointer to "struct tomoyo_request_info".
+ * @dir:        Mount point.
+ * @is_granted: True if this is a granted log.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_audit_umount_log(struct tomoyo_request_info *r,
+				   const char *dir, const bool is_granted)
+{
+	if (!is_granted)
+		tomoyo_warn_log(r, "umount %s", dir);
+	return tomoyo_write_audit_log(is_granted, r,
+				      TOMOYO_KEYWORD_ALLOW_UNMOUNT "%s\n",
+				      dir);
+}
+
+/**
+ * tomoyo_may_umount2 - Check permission for unmount.
+ *
+ * @mnt: Pointer to "struct vfsmount".
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+static int tomoyo_may_umount2(struct vfsmount *mnt)
+{
+	struct tomoyo_request_info r;
+	int error;
+	const char *dir0;
+	struct tomoyo_path_info dir;
+	struct path path = { mnt, mnt->mnt_root };
+	struct tomoyo_obj_info obj = {
+		.path1.dentry = mnt->mnt_root,
+		.path1.mnt = mnt
+	};
+	if (!tomoyo_capable(TOMOYO_SYS_UMOUNT))
+		return -EPERM;
+	if (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_UMOUNT)
+	    == TOMOYO_CONFIG_DISABLED)
+		return 0;
+	r.obj = &obj;
+	error = -ENOMEM;
+	dir0 = tomoyo_realpath_from_path(&path);
+	if (!dir0)
+		goto out;
+	dir.name = dir0;
+	tomoyo_fill_path_info(&dir);
+	do {
+		struct tomoyo_acl_info *ptr;
+		error = -EPERM;
+		list_for_each_entry_rcu(ptr, &r.domain->acl_info_list, list) {
+			struct tomoyo_umount_acl *acl;
+			if (ptr->is_deleted ||
+			    ptr->type != TOMOYO_TYPE_UMOUNT_ACL)
+				continue;
+			acl = container_of(ptr, struct tomoyo_umount_acl,
+					   head);
+			if (!tomoyo_compare_name_union(&dir, &acl->dir) ||
+			    !tomoyo_condition(&r, ptr))
+				continue;
+			r.cond = ptr->cond;
+			error = 0;
+			break;
+		}
+		tomoyo_audit_umount_log(&r, dir0, !error);
+		if (!error)
+			break;
+		error = tomoyo_supervisor(&r, TOMOYO_KEYWORD_ALLOW_UNMOUNT
+					  "%s", tomoyo_file_pattern(&dir));
+	} while (error == 1);
+ out:
+	kfree(dir0);
+	if (r.mode != TOMOYO_CONFIG_ENFORCING)
+		error = 0;
+	return error;
+}
+
+/**
+ * tomoyo_umount_permission - Check permission for unmount.
+ *
+ * @mnt: Pointer to "struct vfsmount".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+int tomoyo_umount_permission(struct vfsmount *mnt)
+{
+	const int idx = tomoyo_read_lock();
+	const int error = tomoyo_may_umount2(mnt);
+	tomoyo_read_unlock(idx);
+	return error;
+}
+
+/**
+ * tomoyo_write_umount_policy - Write "struct tomoyo_umount_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct tomoyo_domain_info".
+ * @condition: Pointer to "struct tomoyo_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on sucess, negative value otherwise.
+ */
+int tomoyo_write_umount_policy(char *data, struct tomoyo_domain_info *domain,
+			       struct tomoyo_condition *condition,
+			       const bool is_delete)
+{
+	struct tomoyo_umount_acl *entry = NULL;
+	struct tomoyo_acl_info *ptr;
+	struct tomoyo_umount_acl e = { .head.type = TOMOYO_TYPE_UMOUNT_ACL,
+				       .head.cond = condition };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (data[0] != '@' && !tomoyo_is_correct_path(data, 1, 0, 1))
+		return -EINVAL;
+	if (!tomoyo_parse_name_union(data, &e.dir))
+		return error;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&tomoyo_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct tomoyo_umount_acl *acl =
+			container_of(ptr, struct tomoyo_umount_acl, head);
+		if (ptr->type != TOMOYO_TYPE_UMOUNT_ACL ||
+		    ptr->cond != condition || memcmp(&acl->dir, &e.dir,
+						     sizeof(e.dir)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && tomoyo_commit_ok(entry, &e, sizeof(e))) {
+		tomoyo_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&tomoyo_policy_lock);
+	tomoyo_put_name_union(&e.dir);
+	kfree(entry);
+	return error;
+}
