---
 security/tomoyo/lsm.c |  359 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 359 insertions(+)

--- /dev/null
+++ linux-2.6.31/security/tomoyo/lsm.c
@@ -0,0 +1,359 @@
+/*
+ * security/tomoyo/lsm.c
+ *
+ * LSM hooks for TOMOYO Linux.
+ *
+ * Copyright (C) 2005-2009  NTT DATA CORPORATION
+ */
+#include "internal.h"
+#include <linux/socket.h>
+
+static int tomoyo_cred_prepare(struct cred *new, const struct cred *old,
+			       gfp_t gfp)
+{
+	/* Get ref if "struct linux_binprm *bprm"->cred */
+	struct tomoyo_execve_entry *ee = old->security;
+	if (ee)
+		atomic_inc(&ee->cred_users);
+	new->security = ee;
+	return 0;
+}
+
+static void tomoyo_cred_free(struct cred *cred)
+{
+	struct tomoyo_execve_entry *ee = cred->security;
+	/* Put ref if "struct linux_binprm *bprm"->cred */
+	if (ee && atomic_dec_and_test(&ee->cred_users)) {
+		/*
+		 * Reaching here means execve() failed, for
+		 * "struct linux_binprm *bprm"->cred is not shared between
+		 * processes.
+		 * Release memory allocated by tomoyo_start_execve().
+		 */
+		tomoyo_finish_execve(cred->security, true);
+		cred->security = NULL;
+	}
+}
+
+static int tomoyo_bprm_check_security(struct linux_binprm *bprm)
+{
+	/*
+	 * Execute permission is checked against pathname passed to do_execve()
+	 * using current domain.
+	 */
+	if (!bprm->cred->security) {
+		int ret = tomoyo_start_execve(bprm);
+		struct tomoyo_execve_entry *ee = bprm->cred->security;
+		if (ee)
+			atomic_set(&ee->cred_users, 1);
+		return ret;
+	}
+	/*
+	 * Read permission is checked against interpreters using next domain.
+	 * '1' is the result of open_to_namei_flags(O_RDONLY).
+	 */
+	return tomoyo_open_permission(bprm->file->f_path.dentry,
+				      bprm->file->f_path.mnt, 1);
+}
+
+static void tomoyo_bprm_committing_creds(struct linux_binprm *bprm)
+{
+	/* Release memory allocated by tomoyo_start_execve(). */
+	tomoyo_finish_execve(bprm->cred->security, false);
+	bprm->cred->security = NULL;
+}
+
+#ifdef CONFIG_SYSCTL
+
+static int tomoyo_prepend(char **buffer, int *buflen, const char *str)
+{
+	int namelen = strlen(str);
+
+	if (*buflen < namelen)
+		return -ENOMEM;
+	*buflen -= namelen;
+	*buffer -= namelen;
+	memcpy(*buffer, str, namelen);
+	return 0;
+}
+
+/**
+ * tomoyo_sysctl_path - return the realpath of a ctl_table.
+ * @table: pointer to "struct ctl_table".
+ *
+ * Returns realpath(3) of the @table on success.
+ * Returns NULL on failure.
+ *
+ * This function uses kzalloc(), so the caller must call kfree()
+ * if this function didn't return NULL.
+ */
+static char *tomoyo_sysctl_path(struct ctl_table *table)
+{
+	int buflen = 4096;
+	char *cp = NULL;
+	char *buf = kmalloc(buflen, GFP_KERNEL);
+	char *end = buf + buflen;
+
+	if (!buf)
+		return NULL;
+
+	*--end = '\0';
+	buflen--;
+	while (table) {
+		char num[32];
+		const char *sp = table->procname;
+
+		if (!sp) {
+			memset(num, 0, sizeof(num));
+			snprintf(num, sizeof(num) - 1, "=%d=",
+				 table->ctl_name);
+			sp = num;
+		}
+		if (tomoyo_prepend(&end, &buflen, sp) ||
+		    tomoyo_prepend(&end, &buflen, "/"))
+			goto out;
+		table = table->parent;
+	}
+	if (tomoyo_prepend(&end, &buflen, "/proc/sys"))
+		goto out;
+	cp = tomoyo_encode(end);
+ out:
+	kfree(buf);
+	return cp;
+}
+
+static int tomoyo_sysctl(struct ctl_table *table, int op)
+{
+	int error = 0;
+	struct tomoyo_request_info r;
+	struct tomoyo_path_info buf;
+	int idx;
+
+	op &= MAY_READ | MAY_WRITE;
+	if (!op)
+		return 0;
+
+	idx = tomoyo_read_lock();
+	if (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_OPEN)
+	    == TOMOYO_CONFIG_DISABLED)
+		goto out;
+
+	buf.name = tomoyo_sysctl_path(table);
+	if (buf.name) {
+		tomoyo_fill_path_info(&buf);
+		error = tomoyo_file_perm(&r, &buf, op);
+		kfree(buf.name);
+	} else
+		error = -ENOMEM;
+ out:
+	tomoyo_read_unlock(idx);
+	return error;
+}
+
+#endif
+
+static int tomoyo_path_truncate(struct path *path, loff_t length,
+				unsigned int time_attrs)
+{
+	return tomoyo_truncate_permission(path->dentry, path->mnt,
+					  length, time_attrs);
+}
+
+static int tomoyo_path_unlink(struct path *parent, struct dentry *dentry)
+{
+	return tomoyo_unlink_permission(parent->dentry->d_inode, dentry,
+					parent->mnt);
+}
+
+static int tomoyo_path_mkdir(struct path *parent, struct dentry *dentry,
+			     int mode)
+{
+	return tomoyo_mkdir_permission(parent->dentry->d_inode, dentry,
+				       parent->mnt, mode);
+}
+
+static int tomoyo_path_rmdir(struct path *parent, struct dentry *dentry)
+{
+	return tomoyo_rmdir_permission(parent->dentry->d_inode, dentry,
+				       parent->mnt);
+}
+
+static int tomoyo_path_symlink(struct path *parent, struct dentry *dentry,
+			       const char *old_name)
+{
+	return tomoyo_symlink_permission(parent->dentry->d_inode, dentry,
+					 parent->mnt, old_name);
+}
+
+static int tomoyo_path_mknod(struct path *parent, struct dentry *dentry,
+			     int mode, unsigned int dev)
+{
+	return tomoyo_mknod_permission(parent->dentry->d_inode, dentry,
+				       parent->mnt, mode, dev);
+}
+
+static int tomoyo_path_link(struct dentry *old_dentry, struct path *new_dir,
+			    struct dentry *new_dentry)
+{
+	return tomoyo_link_permission(old_dentry, new_dir->dentry->d_inode,
+				      new_dentry, new_dir->mnt);
+}
+
+static int tomoyo_path_rename(struct path *old_parent,
+			      struct dentry *old_dentry,
+			      struct path *new_parent,
+			      struct dentry *new_dentry)
+{
+	return tomoyo_rename_permission(old_parent->dentry->d_inode,
+					old_dentry,
+					new_parent->dentry->d_inode,
+					new_dentry, old_parent->mnt);
+}
+
+static int tomoyo_path_chmod(struct dentry *dentry, struct vfsmount *mnt,
+			     mode_t mode)
+{
+	return tomoyo_chmod_permission(dentry, mnt, mode);
+}
+
+static int tomoyo_path_chown(struct path *path, uid_t uid, gid_t gid)
+{
+	return tomoyo_chown_permission(path->dentry, path->mnt, uid, gid);
+}
+
+static int tomoyo_path_chroot(struct path *path)
+{
+	return tomoyo_chroot_permission(path);
+}
+
+static int tomoyo_file_fcntl(struct file *file, unsigned int cmd,
+			     unsigned long arg)
+{
+	if (cmd == F_SETFL && ((arg ^ file->f_flags) & O_APPEND))
+		return tomoyo_rewrite_permission(file);
+	return 0;
+}
+
+static int tomoyo_dentry_open(struct file *f, const struct cred *cred)
+{
+	/* Don't check read permission here if called from do_execve(). */
+	if (current->in_execve)
+		return 0;
+	/*
+	 * TOMOYO does not check "allow_write" if
+	 * open(path, O_TRUNC | O_RDONLY) was requested because write() is not
+	 * permitted. Instead, TOMOYO checks "allow_truncate" if O_TRUNC is
+	 * passed.
+	 *
+	 * TOMOYO does not check "allow_read/write" if open(path, 3) was
+	 * requested because read()/write() are not permitted. Instead, TOMOYO
+	 * checks "allow_ioctl" when ioctl() is requested.
+	 */
+	return tomoyo_open_permission(f->f_path.dentry, f->f_path.mnt,
+				      f->f_flags + 1);
+}
+
+static int tomoyo_socket_create(int family, int type, int protocol, int kern)
+{
+	if (kern)
+		return 0;
+	return tomoyo_socket_create_permission(family, type, protocol);
+}
+
+static int tomoyo_socket_bind(struct socket *sock, struct sockaddr *address,
+			      int addrlen)
+{
+	return tomoyo_socket_bind_permission(sock, address, addrlen);
+}
+
+static int tomoyo_socket_connect(struct socket *sock, struct sockaddr *address,
+				 int addrlen)
+{
+	return tomoyo_socket_connect_permission(sock, address, addrlen);
+}
+
+static int tomoyo_socket_listen(struct socket *sock, int backlog)
+{
+	return tomoyo_socket_listen_permission(sock);
+}
+
+static int tomoyo_socket_sendmsg(struct socket *sock, struct msghdr *msg,
+				 int size)
+{
+	return tomoyo_socket_sendmsg_permission(sock, msg->msg_name,
+						msg->msg_namelen);
+}
+
+static int tomoyo_file_ioctl(struct file *file, unsigned int cmd,
+			     unsigned long arg)
+{
+	return tomoyo_ioctl_permission(file, cmd, arg);
+}
+
+static int tomoyo_sb_mount(char *dev_name, struct path *path,
+			   char *type, unsigned long flags, void *data)
+{
+	return tomoyo_mount_permission(dev_name, path, type, flags);
+}
+
+static int tomoyo_sb_umount(struct vfsmount *mnt, int flags)
+{
+	return tomoyo_umount_permission(mnt);
+}
+
+static int tomoyo_sb_pivotroot(struct path *old_path, struct path *new_path)
+{
+	return tomoyo_pivot_root_permission(old_path, new_path);
+}
+
+/*
+ * tomoyo_security_ops is a "struct security_operations" which is used for
+ * registering TOMOYO.
+ */
+static struct security_operations tomoyo_security_ops = {
+	.name                  = "tomoyo",
+	.cred_prepare          = tomoyo_cred_prepare,
+	.bprm_check_security   = tomoyo_bprm_check_security,
+	.bprm_committing_creds = tomoyo_bprm_committing_creds,
+	.cred_free             = tomoyo_cred_free,
+#ifdef CONFIG_SYSCTL
+	.sysctl                = tomoyo_sysctl,
+#endif
+	.file_fcntl            = tomoyo_file_fcntl,
+	.dentry_open           = tomoyo_dentry_open,
+	.path_truncate         = tomoyo_path_truncate,
+	.path_unlink           = tomoyo_path_unlink,
+	.path_mkdir            = tomoyo_path_mkdir,
+	.path_rmdir            = tomoyo_path_rmdir,
+	.path_symlink          = tomoyo_path_symlink,
+	.path_mknod            = tomoyo_path_mknod,
+	.path_link             = tomoyo_path_link,
+	.path_rename           = tomoyo_path_rename,
+	.path_chmod            = tomoyo_path_chmod,
+	.path_chown            = tomoyo_path_chown,
+	.path_chroot           = tomoyo_path_chroot,
+	.file_ioctl            = tomoyo_file_ioctl,
+	.sb_pivotroot          = tomoyo_sb_pivotroot,
+	.sb_mount              = tomoyo_sb_mount,
+	.sb_umount             = tomoyo_sb_umount,
+	.socket_create         = tomoyo_socket_create,
+	.socket_bind           = tomoyo_socket_bind,
+	.socket_connect        = tomoyo_socket_connect,
+	.socket_listen         = tomoyo_socket_listen,
+	.socket_sendmsg        = tomoyo_socket_sendmsg,
+};
+
+__initdata bool tomoyo_registered;
+static int __init tomoyo_init(void)
+{
+	if (!security_module_enable(&tomoyo_security_ops))
+		return 0;
+	/* register ourselves with the security framework */
+	if (register_security(&tomoyo_security_ops))
+		panic("Failure registering TOMOYO Linux");
+	printk(KERN_INFO "TOMOYO Linux initialized\n");
+	/* call tomoyo_securityfs_init() later. */
+	tomoyo_registered = true;
+	return 0;
+}
+security_initcall(tomoyo_init);
