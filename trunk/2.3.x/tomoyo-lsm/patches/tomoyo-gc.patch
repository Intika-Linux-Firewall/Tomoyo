[PATCH] TOMOYO: Avoid "void *" in garbage collector.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.h    |    2 
 security/tomoyo/condition.c |   72 ++++----
 security/tomoyo/gc.c        |  382 ++++++++++++++------------------------------
 security/tomoyo/memory.c    |   60 +++++-
 security/tomoyo/util.c      |   71 ++++----
 5 files changed, 251 insertions(+), 336 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -778,7 +778,7 @@ bool tomoyo_dump_page(struct linux_binpr
 		      struct tomoyo_page_dump *dump);
 u8 tomoyo_parse_ulong(unsigned long *result, char **str);
 struct tomoyo_condition *tomoyo_get_condition(char * const condition);
-void tomoyo_del_condition(struct tomoyo_condition *cond);
+void tomoyo_del_condition(struct list_head *element);
 /* Check whether the given string starts with the given keyword. */
 bool tomoyo_str_starts(char **src, const char *find);
 /* Get tomoyo_realpath() of current process. */
--- security-testing-2.6.orig/security/tomoyo/condition.c
+++ security-testing-2.6/security/tomoyo/condition.c
@@ -19,7 +19,7 @@
  * Returns true on success, false otherwise.
  */
 static bool tomoyo_argv(const unsigned int index, const char *arg_ptr,
-			const int argc, const struct tomoyo_argv_entry *argv,
+			const int argc, const struct tomoyo_argv *argv,
 			u8 *checked)
 {
 	int i;
@@ -52,7 +52,7 @@ static bool tomoyo_argv(const unsigned i
  * Returns true on success, false otherwise.
  */
 static bool tomoyo_envp(const char *env_name, const char *env_value,
-			const int envc, const struct tomoyo_envp_entry *envp,
+			const int envc, const struct tomoyo_envp *envp,
 			u8 *checked)
 {
 	int i;
@@ -93,10 +93,9 @@ static bool tomoyo_envp(const char *env_
  *
  * Returns true on success, false otherwise.
  */
-static bool tomoyo_scan_bprm(struct tomoyo_execve_entry *ee, const u16 argc,
-			     const struct tomoyo_argv_entry *argv,
-			     const u16 envc,
-			     const struct tomoyo_envp_entry *envp)
+static bool tomoyo_scan_bprm(struct tomoyo_execve *ee,
+			     const u16 argc, const struct tomoyo_argv *argv,
+			     const u16 envc, const struct tomoyo_envp *envp)
 {
 	struct linux_binprm *bprm = ee->bprm;
 	struct tomoyo_page_dump *dump = &ee->dump;
@@ -269,7 +268,7 @@ static const struct tomoyo_path_info *to
 		*(cp - 1) = '\0';
 		break;
 	}
-	if (!tomoyo_is_correct_word(start))
+	if (!tomoyo_correct_word(start))
 		return NULL;
 	return tomoyo_get_name(start);
 }
@@ -282,7 +281,7 @@ static const struct tomoyo_path_info *to
  *
  * Returns true on success, false otherwise.
  */
-static bool tomoyo_parse_argv(char *start, struct tomoyo_argv_entry *argv)
+static bool tomoyo_parse_argv(char *start, struct tomoyo_argv *argv)
 {
 	unsigned long index;
 	const struct tomoyo_path_info *value;
@@ -318,7 +317,7 @@ static bool tomoyo_parse_argv(char *star
  *
  * Returns true on success, false otherwise.
  */
-static bool tomoyo_parse_envp(char *start, struct tomoyo_envp_entry *envp)
+static bool tomoyo_parse_envp(char *start, struct tomoyo_envp *envp)
 {
 	const struct tomoyo_path_info *name;
 	const struct tomoyo_path_info *value;
@@ -344,7 +343,7 @@ static bool tomoyo_parse_envp(char *star
 			goto out;
 		}
 	}
-	if (!*cp || !tomoyo_is_correct_word(cp))
+	if (!*cp || !tomoyo_correct_word(cp))
 		goto out;
 	name = tomoyo_get_name(cp);
 	if (!name)
@@ -364,9 +363,6 @@ static bool tomoyo_parse_envp(char *star
 	return false;
 }
 
-/* The list for "struct tomoyo_condition". */
-LIST_HEAD(tomoyo_condition_list);
-
 const char *tomoyo_condition_keyword[TOMOYO_MAX_CONDITION_KEYWORD] = {
 	[TOMOYO_TASK_UID]             = "task.uid",
 	[TOMOYO_TASK_EUID]            = "task.euid",
@@ -383,6 +379,16 @@ const char *tomoyo_condition_keyword[TOM
 	[TOMOYO_EXEC_REALPATH]        = "exec.realpath",
 };
 
+static inline bool tomoyo_same_condition(const struct tomoyo_condition *p1,
+					 const struct tomoyo_condition *p2)
+{
+	return p1->size == p2->size && p1->condc == p2->condc &&
+		p1->numbers_count == p2->numbers_count &&
+		p1->names_count == p2->names_count &&
+		p1->argc == p2->argc && p1->envc == p2->envc &&
+		!memcmp(p1 + 1, p2 + 1, p1->size - sizeof(*p1));
+}
+
 /* #define DEBUG_CONDITION */
 
 #ifdef DEBUG_CONDITION
@@ -406,8 +412,8 @@ struct tomoyo_condition *tomoyo_get_cond
 	struct tomoyo_condition_element *condp;
 	struct tomoyo_number_union *numbers_p;
 	struct tomoyo_name_union *names_p;
-	struct tomoyo_argv_entry *argv;
-	struct tomoyo_envp_entry *envp;
+	struct tomoyo_argv *argv;
+	struct tomoyo_envp *envp;
 	u32 size;
 	bool found = false;
 	u16 condc = 0;
@@ -493,12 +499,12 @@ struct tomoyo_condition *tomoyo_get_cond
 		+ condc * sizeof(struct tomoyo_condition_element)
 		+ numbers_count * sizeof(struct tomoyo_number_union)
 		+ names_count * sizeof(struct tomoyo_name_union)
-		+ argc * sizeof(struct tomoyo_argv_entry)
-		+ envc * sizeof(struct tomoyo_envp_entry);
+		+ argc * sizeof(struct tomoyo_argv)
+		+ envc * sizeof(struct tomoyo_envp);
 	entry = kzalloc(size, GFP_NOFS);
 	if (!entry)
 		return NULL;
-	INIT_LIST_HEAD(&entry->list);
+	INIT_LIST_HEAD(&entry->head.list);
 	entry->condc = condc;
 	entry->numbers_count = numbers_count;
 	entry->names_count = names_count;
@@ -507,8 +513,8 @@ struct tomoyo_condition *tomoyo_get_cond
 	condp = (struct tomoyo_condition_element *) (entry + 1);
 	numbers_p = (struct tomoyo_number_union *) (condp + condc);
 	names_p = (struct tomoyo_name_union *) (numbers_p + numbers_count);
-	argv = (struct tomoyo_argv_entry *) (names_p + names_count);
-	envp = (struct tomoyo_envp_entry *) (argv + argc);
+	argv = (struct tomoyo_argv *) (names_p + names_count);
+	envp = (struct tomoyo_envp *) (argv + argc);
 	for (start = condition; start < end_of_string; start++)
 		if (!*start)
 			*start = ' ';
@@ -632,18 +638,20 @@ struct tomoyo_condition *tomoyo_get_cond
 	entry->size = size;
 	if (mutex_lock_interruptible(&tomoyo_policy_lock))
 		goto out;
-	list_for_each_entry_rcu(ptr, &tomoyo_condition_list, list) {
-		if (!tomoyo_is_same_condition(ptr, entry))
+	list_for_each_entry_rcu(ptr, &tomoyo_shared_list[TOMOYO_CONDITION_LIST],
+				head.list) {
+		if (!tomoyo_same_condition(ptr, entry))
 			continue;
 		/* Same entry found. Share this entry. */
-		atomic_inc(&ptr->users);
+		atomic_inc(&ptr->head.users);
 		found = true;
 		break;
 	}
 	if (!found) {
 		if (tomoyo_memory_ok(entry)) {
-			atomic_set(&entry->users, 1);
-			list_add_rcu(&entry->list, &tomoyo_condition_list);
+			atomic_set(&entry->head.users, 1);
+			list_add_rcu(&entry->head.list,
+				     &tomoyo_shared_list[TOMOYO_CONDITION_LIST]);
 		} else {
 			found = true;
 			ptr = NULL;
@@ -651,7 +659,7 @@ struct tomoyo_condition *tomoyo_get_cond
 	}
 	mutex_unlock(&tomoyo_policy_lock);
 	if (found) {
-		tomoyo_del_condition(entry);
+		tomoyo_del_condition(&entry->head.list);
 		kfree(entry);
 		entry = ptr;
 	}
@@ -659,7 +667,7 @@ struct tomoyo_condition *tomoyo_get_cond
  out:
 	dprintk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);
 	if (entry) {
-		tomoyo_del_condition(entry);
+		tomoyo_del_condition(&entry->head.list);
 		kfree(entry);
 	}
 	return NULL;
@@ -686,8 +694,8 @@ bool tomoyo_condition(struct tomoyo_requ
 	const struct tomoyo_condition_element *condp;
 	const struct tomoyo_number_union *numbers_p;
 	const struct tomoyo_name_union *names_p;
-	const struct tomoyo_argv_entry *argv;
-	const struct tomoyo_envp_entry *envp;
+	const struct tomoyo_argv *argv;
+	const struct tomoyo_envp *envp;
 	u16 condc;
 	u16 argc;
 	u16 envc;
@@ -706,8 +714,8 @@ bool tomoyo_condition(struct tomoyo_requ
 	numbers_p = (const struct tomoyo_number_union *) (condp + condc);
 	names_p = (const struct tomoyo_name_union *)
 		(numbers_p + cond->numbers_count);
-	argv = (const struct tomoyo_argv_entry *) (names_p + cond->names_count);
-	envp = (const struct tomoyo_envp_entry *) (argv + argc);
+	argv = (const struct tomoyo_argv *) (names_p + cond->names_count);
+	envp = (const struct tomoyo_envp *) (argv + argc);
 	for (i = 0; i < condc; i++) {
 		const bool match = condp->equals;
 		const u8 left = condp->left;
@@ -721,7 +729,7 @@ bool tomoyo_condition(struct tomoyo_requ
 		if (right == TOMOYO_NAME_UNION) {
 			const struct tomoyo_name_union *ptr = names_p++;
 			switch (left) {
-				struct tomoyo_execve_entry *ee;
+				struct tomoyo_execve *ee;
 				struct file *file;
 			case TOMOYO_EXEC_REALPATH:
 				ee = r->ee;
--- security-testing-2.6.orig/security/tomoyo/gc.c
+++ security-testing-2.6/security/tomoyo/gc.c
@@ -11,86 +11,83 @@
 #include <linux/kthread.h>
 #include <linux/slab.h>
 
-enum tomoyo_gc_id {
-	TOMOYO_ID_PATH_GROUP,
-	TOMOYO_ID_PATH_GROUP_MEMBER,
-	TOMOYO_ID_NUMBER_GROUP,
-	TOMOYO_ID_NUMBER_GROUP_MEMBER,
-	TOMOYO_ID_DOMAIN_INITIALIZER,
-	TOMOYO_ID_DOMAIN_KEEPER,
-	TOMOYO_ID_AGGREGATOR,
-	TOMOYO_ID_GLOBALLY_READABLE,
-	TOMOYO_ID_PATTERN,
-	TOMOYO_ID_NO_REWRITE,
-	TOMOYO_ID_MANAGER,
-	TOMOYO_ID_CONDITION,
-	TOMOYO_ID_NAME,
-	TOMOYO_ID_ACL,
-	TOMOYO_ID_DOMAIN
-};
-
-struct tomoyo_gc_entry {
+struct tomoyo_gc {
 	struct list_head list;
 	int type;
-	void *element;
+	struct list_head *element;
 };
 static LIST_HEAD(tomoyo_gc_queue);
 static DEFINE_MUTEX(tomoyo_gc_mutex);
 
 /* Caller holds tomoyo_policy_lock mutex. */
-static bool tomoyo_add_to_gc(const int type, void *element)
+static bool tomoyo_add_to_gc(const int type, struct list_head *element)
 {
-	struct tomoyo_gc_entry *entry = kzalloc(sizeof(*entry), GFP_ATOMIC);
+	struct tomoyo_gc *entry = kzalloc(sizeof(*entry), GFP_ATOMIC);
 	if (!entry)
 		return false;
 	entry->type = type;
 	entry->element = element;
 	list_add(&entry->list, &tomoyo_gc_queue);
+	list_del_rcu(element);
 	return true;
 }
 
-static void tomoyo_del_allow_read
-(struct tomoyo_globally_readable_file_entry *ptr)
+static void tomoyo_del_allow_read(struct list_head *element)
 {
+	struct tomoyo_globally_readable_file *ptr =
+		container_of(element, typeof(*ptr), head.list);
 	tomoyo_put_name(ptr->filename);
 }
 
-static void tomoyo_del_file_pattern(struct tomoyo_pattern_entry *ptr)
+static void tomoyo_del_file_pattern(struct list_head *element)
 {
+	struct tomoyo_pattern *ptr =
+		container_of(element, typeof(*ptr), head.list);
 	tomoyo_put_name(ptr->pattern);
 }
 
-static void tomoyo_del_no_rewrite(struct tomoyo_no_rewrite_entry *ptr)
+static void tomoyo_del_no_rewrite(struct list_head *element)
 {
+	struct tomoyo_no_rewrite *ptr =
+		container_of(element, typeof(*ptr), head.list);
 	tomoyo_put_name(ptr->pattern);
 }
 
-static void tomoyo_del_domain_initializer
-(struct tomoyo_domain_initializer_entry *ptr)
+static void tomoyo_del_domain_initializer(struct list_head *element)
 {
+	struct tomoyo_domain_initializer *ptr =
+		container_of(element, typeof(*ptr), head.list);
 	tomoyo_put_name(ptr->domainname);
 	tomoyo_put_name(ptr->program);
 }
 
-static void tomoyo_del_domain_keeper(struct tomoyo_domain_keeper_entry *ptr)
+static void tomoyo_del_domain_keeper(struct list_head *element)
 {
+	struct tomoyo_domain_keeper *ptr =
+		container_of(element, typeof(*ptr), head.list);
 	tomoyo_put_name(ptr->domainname);
 	tomoyo_put_name(ptr->program);
 }
 
-static void tomoyo_del_aggregator(struct tomoyo_aggregator_entry *ptr)
+static void tomoyo_del_aggregator(struct list_head *element)
 {
+	struct tomoyo_aggregator *ptr =
+		container_of(element, typeof(*ptr), head.list);
 	tomoyo_put_name(ptr->original_name);
 	tomoyo_put_name(ptr->aggregated_name);
 }
 
-static void tomoyo_del_manager(struct tomoyo_policy_manager_entry *ptr)
+static void tomoyo_del_manager(struct list_head *element)
 {
+	struct tomoyo_manager *ptr =
+		container_of(element, typeof(*ptr), head.list);
 	tomoyo_put_name(ptr->manager);
 }
 
-static void tomoyo_del_acl(struct tomoyo_acl_info *acl)
+static void tomoyo_del_acl(struct list_head *element)
 {
+	struct tomoyo_acl_info *acl =
+		container_of(element, typeof(*acl), list);
 	tomoyo_put_condition(acl->cond);
 	switch (acl->type) {
 	case TOMOYO_TYPE_PATH_ACL:
@@ -142,8 +139,10 @@ static void tomoyo_del_acl(struct tomoyo
 	}
 }
 
-static bool tomoyo_del_domain(struct tomoyo_domain_info *domain)
+static bool tomoyo_del_domain(struct list_head *element)
 {
+	struct tomoyo_domain_info *domain =
+		container_of(element, typeof(*domain), list);
 	struct tomoyo_acl_info *acl;
 	struct tomoyo_acl_info *tmp;
 	/*
@@ -171,7 +170,7 @@ static bool tomoyo_del_domain(struct tom
 	if (atomic_read(&domain->users))
 		return false;
 	list_for_each_entry_safe(acl, tmp, &domain->acl_info_list, list) {
-		tomoyo_del_acl(acl);
+		tomoyo_del_acl(&acl->list);
 		tomoyo_memory_free(acl);
 	}
 	tomoyo_put_name(domain->domainname);
@@ -181,10 +180,12 @@ static bool tomoyo_del_domain(struct tom
 /**
  * tomoyo_del_condition - Delete members in "struct tomoyo_condition".
  *
- * @cond: Pointer to "struct tomoyo_condition".
+ * @element: Pointer to "struct list_head".
  */
-void tomoyo_del_condition(struct tomoyo_condition *cond)
+void tomoyo_del_condition(struct list_head *element)
 {
+	struct tomoyo_condition *cond =
+		container_of(element, typeof(*cond), head.list);
 	const u16 condc = cond->condc;
 	const u16 numbers_count = cond->numbers_count;
 	const u16 names_count = cond->names_count;
@@ -197,10 +198,10 @@ void tomoyo_del_condition(struct tomoyo_
 		= (struct tomoyo_number_union *) (condp + condc);
 	struct tomoyo_name_union *names_p
 		= (struct tomoyo_name_union *) (numbers_p + numbers_count);
-	const struct tomoyo_argv_entry *argv
-		= (const struct tomoyo_argv_entry *) (names_p + names_count);
-	const struct tomoyo_envp_entry *envp
-		= (const struct tomoyo_envp_entry *) (argv + argc);
+	const struct tomoyo_argv *argv
+		= (const struct tomoyo_argv *) (names_p + names_count);
+	const struct tomoyo_envp *envp
+		= (const struct tomoyo_envp *) (argv + argc);
 	for (i = 0; i < numbers_count; i++)
 		tomoyo_put_number_union(numbers_p++);
 	for (i = 0; i < names_count; i++)
@@ -213,154 +214,70 @@ void tomoyo_del_condition(struct tomoyo_
 	}
 }
 
-static void tomoyo_del_name(const struct tomoyo_name_entry *ptr)
+static void tomoyo_del_name(struct list_head *element)
 {
+	const struct tomoyo_name *ptr =
+		container_of(element, typeof(*ptr), head.list);
 }
 
-static void tomoyo_del_path_group_member(struct tomoyo_path_group_member
-					 *member)
+static void tomoyo_del_group(struct list_head *element)
 {
+	struct tomoyo_group *group =
+		container_of(element, typeof(*group), head.list);
+	tomoyo_put_name(group->group_name);
+}
+
+static void tomoyo_del_path_group(struct list_head *element)
+{
+	struct tomoyo_path_group *member =
+		container_of(element, typeof(*member), head.list);
 	tomoyo_put_name(member->member_name);
 }
 
-static void tomoyo_del_path_group(struct tomoyo_path_group *group)
+static void tomoyo_del_number_group(struct list_head *element)
 {
-	tomoyo_put_name(group->group_name);
+	struct tomoyo_number_group *member =
+		container_of(element, typeof(*member), head.list);
 }
 
-static void tomoyo_del_number_group_member(struct tomoyo_number_group_member
-					   *member)
+static bool tomoyo_collect_member(struct list_head *member_list, int id)
 {
+	struct tomoyo_acl_head *member;
+	list_for_each_entry(member, member_list, list) {
+		if (!member->is_deleted)
+			continue;
+		if (!tomoyo_add_to_gc(id, &member->list))
+			return false;
+	}
+	return true;
 }
 
-static void tomoyo_del_number_group(struct tomoyo_number_group *group)
+static bool tomoyo_collect_acl(struct tomoyo_domain_info *domain)
 {
-	tomoyo_put_name(group->group_name);
+	struct tomoyo_acl_info *acl;
+	list_for_each_entry(acl, &domain->acl_info_list, list) {
+		if (!acl->is_deleted)
+			continue;
+		if (!tomoyo_add_to_gc(TOMOYO_ID_ACL, &acl->list))
+			return false;
+	}
+	return true;
 }
 
 static void tomoyo_collect_entry(void)
 {
+	u16 i;
 	if (mutex_lock_interruptible(&tomoyo_policy_lock))
 		return;
-	{
-		struct tomoyo_globally_readable_file_entry *ptr;
-		list_for_each_entry_rcu(ptr, &tomoyo_globally_readable_list,
-					list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (tomoyo_add_to_gc(TOMOYO_ID_GLOBALLY_READABLE, ptr))
-				list_del_rcu(&ptr->list);
-			else
-				break;
-		}
-	}
-	{
-		struct tomoyo_pattern_entry *ptr;
-		list_for_each_entry_rcu(ptr, &tomoyo_pattern_list, list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (tomoyo_add_to_gc(TOMOYO_ID_PATTERN, ptr))
-				list_del_rcu(&ptr->list);
-			else
-				break;
-		}
-	}
-	{
-		struct tomoyo_no_rewrite_entry *ptr;
-		list_for_each_entry_rcu(ptr, &tomoyo_no_rewrite_list, list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (tomoyo_add_to_gc(TOMOYO_ID_NO_REWRITE, ptr))
-				list_del_rcu(&ptr->list);
-			else
-				break;
-		}
-	}
-	{
-		struct tomoyo_domain_initializer_entry *ptr;
-		list_for_each_entry_rcu(ptr, &tomoyo_domain_initializer_list,
-					list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (tomoyo_add_to_gc(TOMOYO_ID_DOMAIN_INITIALIZER, ptr))
-				list_del_rcu(&ptr->list);
-			else
-				break;
-		}
-	}
-	{
-		struct tomoyo_domain_keeper_entry *ptr;
-		list_for_each_entry_rcu(ptr, &tomoyo_domain_keeper_list, list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (tomoyo_add_to_gc(TOMOYO_ID_DOMAIN_KEEPER, ptr))
-				list_del_rcu(&ptr->list);
-			else
-				break;
-		}
-	}
-	{
-		struct tomoyo_aggregator_entry *ptr;
-		list_for_each_entry_rcu(ptr, &tomoyo_aggregator_list, list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (tomoyo_add_to_gc(TOMOYO_ID_AGGREGATOR, ptr))
-				list_del_rcu(&ptr->list);
-			else
-				break;
-		}
-	}
-	{
-		struct tomoyo_policy_manager_entry *ptr;
-		list_for_each_entry_rcu(ptr, &tomoyo_policy_manager_list,
-					list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (tomoyo_add_to_gc(TOMOYO_ID_MANAGER, ptr))
-				list_del_rcu(&ptr->list);
-			else
-				break;
-		}
+	for (i = 0; i < TOMOYO_MAX_POLICY; i++) {
+		if (!tomoyo_collect_member(&tomoyo_policy_list[i], i))
+			goto unlock;
 	}
 	{
 		struct tomoyo_domain_info *domain;
-		list_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {
-			struct tomoyo_acl_info *acl;
-			list_for_each_entry_rcu(acl, &domain->acl_info_list,
-						list) {
-				switch (acl->type) {
-				case TOMOYO_TYPE_PATH_ACL:
-					if (container_of(acl,
-					 struct tomoyo_path_acl,
-							 head)->perm)
-						continue;
-					break;
-				case TOMOYO_TYPE_PATH2_ACL:
-					if (container_of(acl,
-					 struct tomoyo_path2_acl,
-							 head)->perm)
-						continue;
-					break;
-				case TOMOYO_TYPE_PATH_NUMBER_ACL:
-					if (container_of(acl,
-					 struct tomoyo_path_number_acl,
-							 head)->perm)
-						continue;
-					break;
-				case TOMOYO_TYPE_PATH_NUMBER3_ACL:
-					if (container_of(acl,
-					 struct tomoyo_path_number3_acl,
-							 head)->perm)
-						continue;
-					break;
-				default:
-					continue;
-				}
-				if (tomoyo_add_to_gc(TOMOYO_ID_ACL, acl))
-					list_del_rcu(&acl->list);
-				else
-					break;
-			}
+		list_for_each_entry(domain, &tomoyo_domain_list, list) {
+			if (!tomoyo_collect_acl(domain))
+				goto unlock;
 			if (!domain->is_deleted || atomic_read(&domain->users))
 				continue;
 			/*
@@ -368,149 +285,96 @@ static void tomoyo_collect_entry(void)
 			 * refer this domain after successful execve().
 			 * We recheck domain->users after SRCU synchronization.
 			 */
-			if (tomoyo_add_to_gc(TOMOYO_ID_DOMAIN, domain))
-				list_del_rcu(&domain->list);
-			else
-				break;
-		}
-	}
-	{
-		struct tomoyo_condition *ptr;
-		list_for_each_entry_rcu(ptr, &tomoyo_condition_list, list) {
-			if (atomic_read(&ptr->users))
-				continue;
-			if (tomoyo_add_to_gc(TOMOYO_ID_CONDITION, ptr))
-				list_del_rcu(&ptr->list);
-			else
-				break;
-		}
-	}
-	{
-		int i;
-		for (i = 0; i < TOMOYO_MAX_HASH; i++) {
-			struct tomoyo_name_entry *ptr;
-			list_for_each_entry_rcu(ptr, &tomoyo_name_list[i],
-						list) {
-				if (atomic_read(&ptr->users))
-					continue;
-				if (tomoyo_add_to_gc(TOMOYO_ID_NAME, ptr))
-					list_del_rcu(&ptr->list);
-				else {
-					i = TOMOYO_MAX_HASH;
-					break;
-				}
-			}
+			if (!tomoyo_add_to_gc(TOMOYO_ID_DOMAIN, &domain->list))
+				goto unlock;
 		}
 	}
-	{
-		struct tomoyo_path_group *group;
-		list_for_each_entry_rcu(group, &tomoyo_path_group_list, list) {
-			struct tomoyo_path_group_member *member;
-			list_for_each_entry_rcu(member, &group->member_list,
-						list) {
-				if (!member->is_deleted)
-					continue;
-				if (tomoyo_add_to_gc(TOMOYO_ID_PATH_GROUP_MEMBER,
-						     member))
-					list_del_rcu(&member->list);
-				else
-					break;
-			}
+	for (i = 0; i < TOMOYO_MAX_GROUP; i++) {
+		struct list_head *list = &tomoyo_group_list[i];
+		int id = i ? TOMOYO_ID_NUMBER_GROUP : TOMOYO_ID_PATH_GROUP;
+		struct tomoyo_group *group;
+		list_for_each_entry(group, list, head.list) {
+			if (!tomoyo_collect_member(&group->member_list, id))
+				goto unlock;
 			if (!list_empty(&group->member_list) ||
-			    atomic_read(&group->users))
+			    atomic_read(&group->head.users))
 				continue;
-			if (tomoyo_add_to_gc(TOMOYO_ID_PATH_GROUP, group))
-				list_del_rcu(&group->list);
-			else
-				break;
+			if (!tomoyo_add_to_gc(TOMOYO_ID_GROUP, &group->head.list))
+				goto unlock;
 		}
 	}
-	{
-		struct tomoyo_number_group *group;
-		list_for_each_entry_rcu(group, &tomoyo_number_group_list, list) {
-			struct tomoyo_number_group_member *member;
-			list_for_each_entry_rcu(member, &group->member_list,
-						list) {
-				if (!member->is_deleted)
-					continue;
-				if (tomoyo_add_to_gc(TOMOYO_ID_NUMBER_GROUP_MEMBER,
-						     member))
-					list_del_rcu(&member->list);
-				else
-					break;
-			}
-			if (!list_empty(&group->member_list) ||
-			    atomic_read(&group->users))
+	for (i = 0; i < TOMOYO_MAX_LIST + TOMOYO_MAX_HASH; i++) {
+		struct list_head *list = i < TOMOYO_MAX_LIST ?
+			&tomoyo_shared_list[i] : &tomoyo_name_list[i - TOMOYO_MAX_LIST];
+		int id = i ? TOMOYO_ID_NAME : TOMOYO_ID_CONDITION;
+		struct tomoyo_shared_acl_head *ptr;
+		list_for_each_entry(ptr, list, list) {
+			if (atomic_read(&ptr->users))
 				continue;
-			if (tomoyo_add_to_gc(TOMOYO_ID_NUMBER_GROUP, group))
-				list_del_rcu(&group->list);
-			else
-				break;
+			if (!tomoyo_add_to_gc(id, &ptr->list))
+				goto unlock;
 		}
 	}
+ unlock:
 	mutex_unlock(&tomoyo_policy_lock);
 }
 
 static void tomoyo_kfree_entry(void)
 {
-	struct tomoyo_gc_entry *p;
-	struct tomoyo_gc_entry *tmp;
+	struct tomoyo_gc *p;
+	struct tomoyo_gc *tmp;
 
 	list_for_each_entry_safe(p, tmp, &tomoyo_gc_queue, list) {
+		struct list_head * const element = p->element;
 		switch (p->type) {
 		case TOMOYO_ID_DOMAIN_INITIALIZER:
-			tomoyo_del_domain_initializer(p->element);
+			tomoyo_del_domain_initializer(element);
 			break;
 		case TOMOYO_ID_DOMAIN_KEEPER:
-			tomoyo_del_domain_keeper(p->element);
+			tomoyo_del_domain_keeper(element);
 			break;
 		case TOMOYO_ID_AGGREGATOR:
-			tomoyo_del_aggregator(p->element);
+			tomoyo_del_aggregator(element);
 			break;
 		case TOMOYO_ID_GLOBALLY_READABLE:
-			tomoyo_del_allow_read(p->element);
+			tomoyo_del_allow_read(element);
 			break;
 		case TOMOYO_ID_PATTERN:
-			tomoyo_del_file_pattern(p->element);
+			tomoyo_del_file_pattern(element);
 			break;
 		case TOMOYO_ID_NO_REWRITE:
-			tomoyo_del_no_rewrite(p->element);
+			tomoyo_del_no_rewrite(element);
 			break;
 		case TOMOYO_ID_MANAGER:
-			tomoyo_del_manager(p->element);
+			tomoyo_del_manager(element);
 			break;
 		case TOMOYO_ID_CONDITION:
-			tomoyo_del_condition(container_of(p->element, struct
-							  tomoyo_condition,
-							  list));
+			tomoyo_del_condition(element);
 			break;
 		case TOMOYO_ID_NAME:
-			tomoyo_del_name(p->element);
+			tomoyo_del_name(element);
 			break;
 		case TOMOYO_ID_ACL:
-			tomoyo_del_acl(p->element);
+			tomoyo_del_acl(element);
 			break;
 		case TOMOYO_ID_DOMAIN:
-			if (!tomoyo_del_domain(p->element))
+			if (!tomoyo_del_domain(element))
 				continue;
 			break;
-		case TOMOYO_ID_PATH_GROUP_MEMBER:
-			tomoyo_del_path_group_member(p->element);
+		case TOMOYO_ID_GROUP:
+			tomoyo_del_group(element);
 			break;
 		case TOMOYO_ID_PATH_GROUP:
-			tomoyo_del_path_group(p->element);
-			break;
-		case TOMOYO_ID_NUMBER_GROUP_MEMBER:
-			tomoyo_del_number_group_member(p->element);
+			tomoyo_del_path_group(element);
 			break;
 		case TOMOYO_ID_NUMBER_GROUP:
-			tomoyo_del_number_group(p->element);
+			tomoyo_del_number_group(element);
 			break;
 		default:
 			printk(KERN_WARNING "Unknown type\n");
 			break;
 		}
-		tomoyo_memory_free(p->element);
+		tomoyo_memory_free(element);
 		list_del(&p->list);
 		kfree(p);
 	}
--- security-testing-2.6.orig/security/tomoyo/memory.c
+++ security-testing-2.6/security/tomoyo/memory.c
@@ -87,6 +87,50 @@ void tomoyo_memory_free(void *ptr)
 	kfree(ptr);
 }
 
+/**
+ * tomoyo_get_group - Allocate memory for "struct tomoyo_path_group"/"struct tomoyo_number_group".
+ *
+ * @group_name: The name of address group.
+ * @idx:        Index number.
+ *
+ * Returns pointer to "struct tomoyo_group" on success, NULL otherwise.
+ */
+struct tomoyo_group *tomoyo_get_group(const char *group_name, const u8 idx)
+{
+	struct tomoyo_group e = { };
+	struct tomoyo_group *group = NULL;
+	bool found = false;
+	if (!tomoyo_correct_word(group_name) || idx >= TOMOYO_MAX_GROUP)
+		return NULL;
+	e.group_name = tomoyo_get_name(group_name);
+	if (!e.group_name)
+		return NULL;
+	if (mutex_lock_interruptible(&tomoyo_policy_lock))
+		goto out;
+	list_for_each_entry(group, &tomoyo_group_list[idx], head.list) {
+		if (e.group_name != group->group_name)
+			continue;
+		atomic_inc(&group->head.users);
+		found = true;
+		break;
+	}
+	if (!found) {
+		struct tomoyo_group *entry = tomoyo_commit_ok(&e, sizeof(e));
+		if (entry) {
+			INIT_LIST_HEAD(&entry->member_list);
+			atomic_set(&entry->head.users, 1);
+			list_add_tail_rcu(&entry->head.list,
+					  &tomoyo_group_list[idx]);
+			group = entry;
+			found = true;
+		}
+	}
+	mutex_unlock(&tomoyo_policy_lock);
+ out:
+	tomoyo_put_name(e.group_name);
+	return found ? group : NULL;
+}
+
 /*
  * tomoyo_name_list is used for holding string data used by TOMOYO.
  * Since same string data is likely used for multiple times (e.g.
@@ -104,7 +148,7 @@ struct list_head tomoyo_name_list[TOMOYO
  */
 const struct tomoyo_path_info *tomoyo_get_name(const char *name)
 {
-	struct tomoyo_name_entry *ptr;
+	struct tomoyo_name *ptr;
 	unsigned int hash;
 	int len;
 	int allocated_len;
@@ -117,10 +161,10 @@ const struct tomoyo_path_info *tomoyo_ge
 	head = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];
 	if (mutex_lock_interruptible(&tomoyo_policy_lock))
 		return NULL;
-	list_for_each_entry(ptr, head, list) {
+	list_for_each_entry(ptr, head, head.list) {
 		if (hash != ptr->entry.hash || strcmp(name, ptr->entry.name))
 			continue;
-		atomic_inc(&ptr->users);
+		atomic_inc(&ptr->head.users);
 		goto out;
 	}
 	ptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);
@@ -136,9 +180,9 @@ const struct tomoyo_path_info *tomoyo_ge
 	atomic_add(allocated_len, &tomoyo_policy_memory_size);
 	ptr->entry.name = ((char *) ptr) + sizeof(*ptr);
 	memmove((char *) ptr->entry.name, name, len);
-	atomic_set(&ptr->users, 1);
+	atomic_set(&ptr->head.users, 1);
 	tomoyo_fill_path_info(&ptr->entry);
-	list_add_tail(&ptr->list, head);
+	list_add_tail(&ptr->head.list, head);
  out:
 	mutex_unlock(&tomoyo_policy_lock);
 	return ptr ? &ptr->entry : NULL;
@@ -161,10 +205,8 @@ void __init tomoyo_mm_init(void)
 		panic("Can't register tomoyo_kernel_domain");
 	{
 		/* Load built-in policy. */
-		tomoyo_write_domain_initializer_policy("/sbin/hotplug",
-						       false, false);
-		tomoyo_write_domain_initializer_policy("/sbin/modprobe",
-						       false, false);
+		tomoyo_write_domain_initializer("/sbin/hotplug", false, false);
+		tomoyo_write_domain_initializer("/sbin/modprobe", false, false);
 	}
 	tomoyo_read_unlock(idx);
 }
--- security-testing-2.6.orig/security/tomoyo/util.c
+++ security-testing-2.6/security/tomoyo/util.c
@@ -89,10 +89,10 @@ void tomoyo_print_ulong(char *buffer, co
 bool tomoyo_parse_name_union(const char *filename,
 			     struct tomoyo_name_union *ptr)
 {
-	if (!tomoyo_is_correct_word(filename))
+	if (!tomoyo_correct_word(filename))
 		return false;
 	if (filename[0] == '@') {
-		ptr->group = tomoyo_get_path_group(filename + 1);
+		ptr->group = tomoyo_get_group(filename + 1, TOMOYO_PATH_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
@@ -115,9 +115,9 @@ bool tomoyo_parse_number_union(char *dat
 	unsigned long v;
 	memset(num, 0, sizeof(*num));
 	if (data[0] == '@') {
-		if (!tomoyo_is_correct_word(data))
+		if (!tomoyo_correct_word(data))
 			return false;
-		num->group = tomoyo_get_number_group(data + 1);
+		num->group = tomoyo_get_group(data + 1, TOMOYO_NUMBER_GROUP);
 		num->is_group = true;
 		return num->group != NULL;
 	}
@@ -142,7 +142,7 @@ bool tomoyo_parse_number_union(char *dat
 }
 
 /**
- * tomoyo_is_byte_range - Check whether the string is a \ooo style octal value.
+ * tomoyo_byte_range - Check whether the string is a \ooo style octal value.
  *
  * @str: Pointer to the string.
  *
@@ -151,7 +151,7 @@ bool tomoyo_parse_number_union(char *dat
  * TOMOYO uses \ooo style representation for 0x01 - 0x20 and 0x7F - 0xFF.
  * This function verifies that \ooo is in valid range.
  */
-static inline bool tomoyo_is_byte_range(const char *str)
+static inline bool tomoyo_byte_range(const char *str)
 {
 	return *str >= '0' && *str++ <= '3' &&
 		*str >= '0' && *str++ <= '7' &&
@@ -159,13 +159,13 @@ static inline bool tomoyo_is_byte_range(
 }
 
 /**
- * tomoyo_is_alphabet_char - Check whether the character is an alphabet.
+ * tomoyo_alphabet_char - Check whether the character is an alphabet.
  *
  * @c: The character to check.
  *
  * Returns true if @c is an alphabet character, false otherwise.
  */
-static inline bool tomoyo_is_alphabet_char(const char c)
+static inline bool tomoyo_alphabet_char(const char c)
 {
 	return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
 }
@@ -223,15 +223,15 @@ void tomoyo_normalize_line(unsigned char
 	unsigned char *dp = buffer;
 	bool first = true;
 
-	while (tomoyo_is_invalid(*sp))
+	while (tomoyo_invalid(*sp))
 		sp++;
 	while (*sp) {
 		if (!first)
 			*dp++ = ' ';
 		first = false;
-		while (tomoyo_is_valid(*sp))
+		while (tomoyo_valid(*sp))
 			*dp++ = *sp++;
-		while (tomoyo_is_invalid(*sp))
+		while (tomoyo_invalid(*sp))
 			sp++;
 	}
 	*dp = '\0';
@@ -265,7 +265,7 @@ bool tomoyo_tokenize(char *buffer, char 
 }
 
 /**
- * tomoyo_is_correct_word2 - Validate a string.
+ * tomoyo_correct_word2 - Validate a string.
  *
  * @string: The string to check. May be non-'\0'-terminated.
  * @len:    Length of @string.
@@ -273,7 +273,7 @@ bool tomoyo_tokenize(char *buffer, char 
  * Check whether the given string follows the naming rules.
  * Returns true if @string follows the naming rules, false otherwise.
  */
-static bool tomoyo_is_correct_word2(const char *string, size_t len)
+static bool tomoyo_correct_word2(const char *string, size_t len)
 {
 	const char *const start = string;
 	bool in_repetition = false;
@@ -325,13 +325,13 @@ static bool tomoyo_is_correct_word2(cons
 				if (d < '0' || d > '7' || e < '0' || e > '7')
 					break;
 				c = tomoyo_make_byte(c, d, e);
-				if (tomoyo_is_invalid(c))
+				if (tomoyo_invalid(c))
 					continue; /* pattern is not \000 */
 			}
 			goto out;
 		} else if (in_repetition && c == '/') {
 			goto out;
-		} else if (tomoyo_is_invalid(c)) {
+		} else if (tomoyo_invalid(c)) {
 			goto out;
 		}
 	}
@@ -343,39 +343,39 @@ static bool tomoyo_is_correct_word2(cons
 }
 
 /**
- * tomoyo_is_correct_word - Validate a string.
+ * tomoyo_correct_word - Validate a string.
  *
  * @string: The string to check.
  *
  * Check whether the given string follows the naming rules.
  * Returns true if @string follows the naming rules, false otherwise.
  */
-bool tomoyo_is_correct_word(const char *string)
+bool tomoyo_correct_word(const char *string)
 {
-	return tomoyo_is_correct_word2(string, strlen(string));
+	return tomoyo_correct_word2(string, strlen(string));
 }
 
 /**
- * tomoyo_is_correct_path - Validate a pathname.
+ * tomoyo_correct_path - Validate a pathname.
  *
  * @filename: The pathname to check.
  *
  * Check whether the given pathname follows the naming rules.
  * Returns true if @filename follows the naming rules, false otherwise.
  */
-bool tomoyo_is_correct_path(const char *filename)
+bool tomoyo_correct_path(const char *filename)
 {
-	return *filename == '/' && tomoyo_is_correct_word(filename);
+	return *filename == '/' && tomoyo_correct_word(filename);
 }
 
 /**
- * tomoyo_is_correct_domain - Check whether the given domainname follows the naming rules.
+ * tomoyo_correct_domain - Check whether the given domainname follows the naming rules.
  *
  * @domainname: The domainname to check.
  *
  * Returns true if @domainname follows the naming rules, false otherwise.
  */
-bool tomoyo_is_correct_domain(const unsigned char *domainname)
+bool tomoyo_correct_domain(const unsigned char *domainname)
 {
 	if (!domainname || strncmp(domainname, TOMOYO_ROOT_NAME,
 				   TOMOYO_ROOT_NAME_LEN))
@@ -390,23 +390,23 @@ bool tomoyo_is_correct_domain(const unsi
 		if (!cp)
 			break;
 		if (*domainname != '/' ||
-		    !tomoyo_is_correct_word2(domainname, cp - domainname - 1))
+		    !tomoyo_correct_word2(domainname, cp - domainname - 1))
 			goto out;
 		domainname = cp + 1;
 	}
-	return tomoyo_is_correct_path(domainname);
+	return tomoyo_correct_path(domainname);
  out:
 	return false;
 }
 
 /**
- * tomoyo_is_domain_def - Check whether the given token can be a domainname.
+ * tomoyo_domain_def - Check whether the given token can be a domainname.
  *
  * @buffer: The token to check.
  *
  * Returns true if @buffer possibly be a domainname, false otherwise.
  */
-bool tomoyo_is_domain_def(const unsigned char *buffer)
+bool tomoyo_domain_def(const unsigned char *buffer)
 {
 	return !strncmp(buffer, TOMOYO_ROOT_NAME, TOMOYO_ROOT_NAME_LEN);
 }
@@ -528,7 +528,7 @@ static bool tomoyo_file_matches_pattern2
 			} else if (c == '\\') {
 				if (filename[1] == '\\')
 					filename++;
-				else if (tomoyo_is_byte_range(filename + 1))
+				else if (tomoyo_byte_range(filename + 1))
 					filename += 3;
 				else
 					return false;
@@ -549,14 +549,14 @@ static bool tomoyo_file_matches_pattern2
 				return false;
 			break;
 		case 'a':
-			if (!tomoyo_is_alphabet_char(c))
+			if (!tomoyo_alphabet_char(c))
 				return false;
 			break;
 		case '0':
 		case '1':
 		case '2':
 		case '3':
-			if (c == '\\' && tomoyo_is_byte_range(filename + 1)
+			if (c == '\\' && tomoyo_byte_range(filename + 1)
 			    && strncmp(filename + 1, pattern, 3) == 0) {
 				filename += 3;
 				pattern += 2;
@@ -577,7 +577,7 @@ static bool tomoyo_file_matches_pattern2
 					continue;
 				if (filename[i + 1] == '\\')
 					i++;
-				else if (tomoyo_is_byte_range(filename + i + 1))
+				else if (tomoyo_byte_range(filename + i + 1))
 					i += 3;
 				else
 					break; /* Bad pattern. */
@@ -593,7 +593,7 @@ static bool tomoyo_file_matches_pattern2
 				while (isxdigit(filename[j]))
 					j++;
 			} else if (c == 'A') {
-				while (tomoyo_is_alphabet_char(filename[j]))
+				while (tomoyo_alphabet_char(filename[j]))
 					j++;
 			}
 			for (i = 1; i <= j; i++) {
@@ -911,6 +911,8 @@ bool tomoyo_domain_quota_is_ok(struct to
 	if (!domain)
 		return true;
 	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		if (ptr->is_deleted)
+			continue;
 		switch (ptr->type) {
 			u16 perm;
 			u8 i;
@@ -945,9 +947,8 @@ bool tomoyo_domain_quota_is_ok(struct to
 					count++;
 			break;
 		case TOMOYO_TYPE_MOUNT_ACL:
-			if (!container_of(ptr, struct tomoyo_mount_acl, head)->
-			    is_deleted)
-				count++;
+			count++;
+			break;
 		}
 	}
 	if (count < tomoyo_profile(domain->profile)->learning->
