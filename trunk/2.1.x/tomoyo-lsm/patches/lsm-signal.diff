Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>

---
 include/linux/security.h         |   39 ++++++++++
 security/dummy.c                 |   18 ++++
 security/tomoyo/Makefile         |    2 
 security/tomoyo/common.c         |   11 ++
 security/tomoyo/include/tomoyo.h |   36 +++++++--
 security/tomoyo/signal.c         |  147 +++++++++++++++++++++++++++++++++++++++
 security/tomoyo/tomoyo.c         |   18 ++++
 7 files changed, 261 insertions(+), 10 deletions(-)

Index: src/security/tomoyo/signal.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ src/security/tomoyo/signal.c	2007-08-09 18:49:25.000000000 +0900
@@ -0,0 +1,147 @@
+/*
+ * security/tomoyo/signal.c
+ *
+ * Signal access contol functions for TOMOYO Linux.
+ */
+
+#include "tomoyo.h"
+#include "realpath.h"
+
+/*************************  AUDIT FUNCTIONS  *************************/
+
+static int AuditSignalLog(const int signal,
+			  const struct path_info *dest_domain,
+			  const int is_granted,
+			  const int is_enforce)
+{
+	char *buf;
+	int len;
+
+	if (is_granted) {
+		if (!tmy_audit_grant())
+			return 0;
+	} else {
+		if (!tmy_audit_reject())
+			return 0;
+	}
+
+	len = dest_domain->total_len;
+	buf = tmy_init_audit_log(&len);
+
+	if (!buf)
+		return -ENOMEM;
+
+	snprintf(buf + strlen(buf),
+		 len - strlen(buf) - 1,
+		 "access=\"%s%d %s\"",
+		 TMY_ALLOW_SIGNAL, signal, dest_domain->name);
+
+	return tmy_write_audit_log(buf, is_granted, is_enforce);
+}
+
+/*************************  SIGNAL ACL HANDLER  *************************/
+
+static int AddSignalEntry(const int sig, const char *dest_pattern, struct domain_info *domain, const u8 is_add)
+{
+	struct acl_info *ptr;
+	const struct path_info *saved_dest_pattern;
+	const u16 hash = sig;
+	int error = -ENOMEM;
+	if (!domain) return -EINVAL;
+	if (!dest_pattern || !tmy_is_correct_domain(dest_pattern, __FUNCTION__)) return -EINVAL;
+	if ((saved_dest_pattern = tmy_save_name(dest_pattern)) == NULL) return -ENOMEM;
+	down(&domain_acl_lock);
+	if (is_add) {
+		if ((ptr = domain->first_acl_ptr) == NULL) goto first_entry;
+		while (1) {
+			struct signal_acl *new_ptr;
+			if (ptr->type == TMY_TYPE_SIGNAL_ACL && ptr->u.w == hash) {
+				if (!tmy_pathcmp(((struct signal_acl *) ptr)->domainname, saved_dest_pattern)) {
+					ptr->is_deleted = 0;
+					/* Found. Nothing to do. */
+					error = 0;
+					break;
+				}
+			}
+			if (ptr->next) {
+				ptr = ptr->next;
+				continue;
+			}
+		first_entry: ;
+			if (is_add == 1 && tmy_too_many_acl(domain)) break;
+			/* Not found. Append it to the tail. */
+			if ((new_ptr = tmy_alloc_element(sizeof(*new_ptr))) == NULL) break;
+			new_ptr->head.type = TMY_TYPE_SIGNAL_ACL;
+			new_ptr->head.u.w = hash;
+			new_ptr->domainname = saved_dest_pattern;
+			error = tmy_add_acl(ptr, domain, (struct acl_info *) new_ptr);
+			break;
+		}
+	} else {
+		error = -ENOENT;
+		for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
+			if (ptr->type != TMY_TYPE_SIGNAL_ACL || ptr->is_deleted || ptr->u.w != hash) continue;
+			if (tmy_pathcmp(((struct signal_acl *) ptr)->domainname, saved_dest_pattern)) continue;
+			error = tmy_del_acl(ptr);
+			break;
+		}
+	}
+	up(&domain_acl_lock);
+	return error;
+}
+
+int CheckSignalACL(const int sig, const int pid)
+{
+	struct domain_info *domain = TMY_SECURITY->domain;
+	struct domain_info *dest = NULL;
+	const char *dest_pattern;
+	struct acl_info *ptr;
+	const u16 hash = sig;
+	const int is_enforce = tmy_enforce(TMY_MAC_FOR_SIGNAL);
+	if (!tmy_flags(TMY_MAC_FOR_SIGNAL)) return 0;
+	if (!sig) return 0;                               /* No check for NULL signal. */
+	if (current->pid == pid) {
+		AuditSignalLog(sig, domain->domainname, 1, is_enforce);
+		return 0;                /* No check for self. */
+	}
+	{ /* Simplified checking. */
+		struct task_struct *p = NULL;
+		read_lock(&tasklist_lock);
+		if (pid > 0) p = find_task_by_pid((pid_t) pid);
+		else if (pid == 0) p = current;
+		else if (pid == -1) dest = &KERNEL_DOMAIN;
+		else p = find_task_by_pid((pid_t) -pid);
+		if (p) dest = ((struct tmy_security *) p->security)->domain;
+		read_unlock(&tasklist_lock);
+		if (!dest) return 0; /* I can't find destinatioin. */
+	}
+	if (domain == dest) {
+		AuditSignalLog(sig, dest->domainname, 1, is_enforce);
+		return 0;
+	}
+	dest_pattern = dest->domainname->name;
+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
+		if (ptr->type == TMY_TYPE_SIGNAL_ACL && ptr->is_deleted == 0 && ptr->u.w == hash) {
+			const int len = ((struct signal_acl *) ptr)->domainname->total_len;
+			if (strncmp(((struct signal_acl *) ptr)->domainname->name, dest_pattern, len) == 0 && (dest_pattern[len] == ' ' || dest_pattern[len] == '\0')) break;
+		}
+	}
+	if (ptr) {
+		AuditSignalLog(sig, dest->domainname, 1, is_enforce);
+		return 0;
+	}
+	AuditSignalLog(sig, dest->domainname, 0, is_enforce);
+	if (is_enforce) return tmy_supervisor("%s\n" TMY_ALLOW_SIGNAL "%d %s\n", domain->domainname->name, sig, dest_pattern);
+	if (tmy_accept(TMY_MAC_FOR_SIGNAL)) AddSignalEntry(sig, dest_pattern, domain, 1);
+	return 0;
+}
+
+int AddSignalPolicy(char *data, struct domain_info *domain, const int is_delete)
+{
+	int sig;
+	char *domainname = strchr(data, ' ');
+	if (sscanf(data, "%d", &sig) == 1 && domainname && tmy_is_domain_def(domainname + 1)) {
+		return AddSignalEntry(sig, domainname + 1, domain, is_delete ? 0 : -1);
+	}
+	return -EINVAL;
+}
Index: src/security/tomoyo/Makefile
===================================================================
--- src.orig/security/tomoyo/Makefile	2007-08-09 18:49:17.000000000 +0900
+++ src/security/tomoyo/Makefile	2007-08-09 18:49:25.000000000 +0900
@@ -1,3 +1,3 @@
 obj-$(CONFIG_SECURITY_TOMOYO) += tomoyo.o tomoyo_func.o
-tomoyo_func-objs := domain.o common.o realpath.o audit.o file.o exec.o net.o mount.o
+tomoyo_func-objs := domain.o common.o realpath.o audit.o file.o exec.o net.o mount.o signal.o
 EXTRA_CFLAGS += -Isecurity/tomoyo/include
Index: src/security/tomoyo/include/tomoyo.h
===================================================================
--- src.orig/security/tomoyo/include/tomoyo.h	2007-08-09 18:49:18.000000000 +0900
+++ src/security/tomoyo/include/tomoyo.h	2007-08-09 18:49:25.000000000 +0900
@@ -127,6 +127,13 @@
 	} u2;
 };
 
+struct signal_acl {
+	/* type = TYPE_SIGNAL_ACL, w = signal_number. */
+	struct acl_info head;
+	/* Pointer to destination pattern.            */
+	const struct path_info *domainname;
+};
+
 struct addr_group_member {
 	struct addr_group_member *next;
 	union {
@@ -219,21 +226,25 @@
 #define TMY_ALLOW_NETWORK       "allow_network "
 #define TMY_ALLOW_NETWORK_LEN   (sizeof(TMY_ALLOW_NETWORK) - 1)
 
+#define TMY_ALLOW_SIGNAL        "allow_signal "
+#define TMY_ALLOW_SIGNAL_LEN    (sizeof(TMY_ALLOW_SIGNAL) - 1)
+
 /********************  Index numbers for Access Controls.  ********************/
 
 #define TMY_COMMENT              0
 #define TMY_MAC_FOR_FILE         1
 #define TMY_MAC_FOR_ARGV0        2
 #define TMY_MAC_FOR_NETWORK      3
-#define TMY_RESTRICT_MOUNT       4
-#define TMY_RESTRICT_UMOUNT      5
-#define TMY_DENY_CONCEAL_MOUNT   6
-#define TMY_RESTRICT_PIVOT_ROOT  7
-#define TMY_MAX_ACCEPT_ENTRY     8
-#define TMY_AUDIT_GRANT          9
-#define TMY_AUDIT_REJECT        10
-#define TMY_ALLOW_ENFORCE_GRACE 11
-#define TMY_MAX_CONTROL_INDEX   12
+#define TMY_MAC_FOR_SIGNAL       4
+#define TMY_RESTRICT_MOUNT       5
+#define TMY_RESTRICT_UMOUNT      6
+#define TMY_DENY_CONCEAL_MOUNT   7
+#define TMY_RESTRICT_PIVOT_ROOT  8
+#define TMY_MAX_ACCEPT_ENTRY     9
+#define TMY_AUDIT_GRANT         10
+#define TMY_AUDIT_REJECT        11
+#define TMY_ALLOW_ENFORCE_GRACE 12
+#define TMY_MAX_CONTROL_INDEX   13
 
 #define TMY_NETWORK_ACL_UDP_BIND    0
 #define TMY_NETWORK_ACL_UDP_CONNECT 1
@@ -385,6 +396,12 @@
 			    const int sock_type,
 			    const u8 *address,
 			    const u16 port);
+
+int CheckSignalACL(int sig, int pid);
+int AddSignalPolicy(char *data,
+		    struct domain_info *domain,
+		    const int is_delete);
+
 char *tmy_init_audit_log(int *len);
 int tmy_write_audit_log(char *log, const int is_granted, const int is_enforce);
 int tmy_acltype2paths(const unsigned int acl_type);
@@ -452,6 +469,7 @@
 #define TMY_TYPE_FILE_ACL    	100
 #define TMY_TYPE_ARGV0_ACL      101
 #define TMY_TYPE_IP_NETWORK_ACL 103
+#define TMY_TYPE_SIGNAL_ACL     104
 
 struct linux_binprm;
 struct pt_regs;
Index: src/security/tomoyo/common.c
===================================================================
--- src.orig/security/tomoyo/common.c	2007-08-09 18:49:18.000000000 +0900
+++ src/security/tomoyo/common.c	2007-08-09 18:49:25.000000000 +0900
@@ -42,6 +42,7 @@
 	[TMY_MAC_FOR_FILE]        = { "MAC_FOR_FILE",        0, 3 },
 	[TMY_MAC_FOR_ARGV0]       = { "MAC_FOR_ARGV0",       0, 3 },
 	[TMY_MAC_FOR_NETWORK]     = { "MAC_FOR_NETWORK",     0, 3 },
+	[TMY_MAC_FOR_SIGNAL]      = { "MAC_FOR_SIGNAL",      0, 3 },
 	[TMY_RESTRICT_MOUNT]      = { "RESTRICT_MOUNT",      0, 3 },
 	[TMY_RESTRICT_UMOUNT]     = { "RESTRICT_UNMOUNT",    0, 3 },
 	[TMY_DENY_CONCEAL_MOUNT]  = { "DENY_CONCEAL_MOUNT",  0, 3 },
@@ -910,6 +911,12 @@
 		return tmy_add_argv0_policy(data +
 					    TMY_ALLOW_ARGV0_LEN,
 					    domain, is_delete);
+	} else if (strncmp(data,
+			   TMY_ALLOW_SIGNAL,
+			   TMY_ALLOW_SIGNAL_LEN) == 0) {
+		return AddSignalPolicy(data +
+				       TMY_ALLOW_SIGNAL_LEN,
+				       domain, is_delete);
 	} else {
 		return tmy_add_file_policy(data, domain, is_delete);
 	}
@@ -1012,6 +1019,10 @@
 					head->read_avail = pos;
 					break;
 				}
+			} else if (acl_type == TMY_TYPE_SIGNAL_ACL) {
+				if (tmy_io_printf(head, TMY_ALLOW_SIGNAL "%u %s\n", ptr->u.w, ((struct signal_acl *) ptr)->domainname->name)) {
+					head->read_avail = pos; break;
+				}
 			} else {
 				const char *keyword = tmy_acltype2keyword(acl_type);
 				if (keyword) {
Index: src/include/linux/security.h
===================================================================
--- src.orig/include/linux/security.h	2007-08-09 18:49:18.000000000 +0900
+++ src/include/linux/security.h	2007-08-09 18:49:25.000000000 +0900
@@ -628,6 +628,12 @@
  *	@sig contains the signal value.
  *	@secid contains the sid of the process where the signal originated
  *	Return 0 if permission is granted.
+ * @task_kill_unlocked:
+ *
+ * @task_tkill_unlocked:
+ *
+ * @task_tgkill_unlocked:
+ *
  * @task_wait:
  *	Check permission before allowing a process to reap a child process @p
  *	and collect its status information.
@@ -1290,6 +1296,9 @@
 	int (*task_movememory) (struct task_struct * p);
 	int (*task_kill) (struct task_struct * p,
 			  struct siginfo * info, int sig, u32 secid);
+	int (*task_kill_unlocked) (int pid, int sig);
+	int (*task_tkill_unlocked) (int pid, int sig);
+	int (*task_tgkill_unlocked) (int tgid, int pid, int sig);
 	int (*task_wait) (struct task_struct * p);
 	int (*task_prctl) (int option, unsigned long arg2,
 			   unsigned long arg3, unsigned long arg4,
@@ -1976,6 +1985,21 @@
 	return security_ops->task_kill (p, info, sig, secid);
 }
 
+static inline int security_task_kill_unlocked(int pid, int sig)
+{
+	return security_ops->task_kill_unlocked(pid, sig);
+}
+
+static inline int security_task_tkill_unlocked(int pid, int sig)
+{
+	return security_ops->task_tkill_unlocked(pid, sig);
+}
+
+static inline int security_task_tgkill_unlocked(int tgid, int pid, int sig)
+{
+	return security_ops->task_tgkill_unlocked(tgid, pid, sig);
+}
+
 static inline int security_task_wait (struct task_struct *p)
 {
 	return security_ops->task_wait (p);
@@ -2649,6 +2673,21 @@
 	return 0;
 }
 
+static inline int security_task_kill_unlocked(int pid, int sig)
+{
+	return 0;
+}
+
+static inline int security_task_tkill_unlocked(int pid, int sig)
+{
+	return 0;
+}
+
+static inline int security_task_tgkill_unlocked(int tgid, int pid, int sig)
+{
+	return 0;
+}
+
 static inline int security_task_wait (struct task_struct *p)
 {
 	return 0;
Index: src/security/dummy.c
===================================================================
--- src.orig/security/dummy.c	2007-08-09 18:49:18.000000000 +0900
+++ src/security/dummy.c	2007-08-09 18:49:25.000000000 +0900
@@ -564,6 +564,21 @@
 	return 0;
 }
 
+static int dummy_task_kill_unlocked(int pid, int sig)
+{
+	return 0;
+}
+
+static int dummy_task_tkill_unlocked(int pid, int sig)
+{
+	return 0;
+}
+
+static int dummy_task_tgkill_unlocked(int tgid, int pid, int sig)
+{
+	return 0;
+}
+
 static int dummy_task_prctl (int option, unsigned long arg2, unsigned long arg3,
 			     unsigned long arg4, unsigned long arg5)
 {
@@ -1059,6 +1074,9 @@
 	set_to_dummy_if_null(ops, task_movememory);
 	set_to_dummy_if_null(ops, task_wait);
 	set_to_dummy_if_null(ops, task_kill);
+	set_to_dummy_if_null(ops, task_kill_unlocked);
+	set_to_dummy_if_null(ops, task_tkill_unlocked);
+	set_to_dummy_if_null(ops, task_tgkill_unlocked);
 	set_to_dummy_if_null(ops, task_prctl);
 	set_to_dummy_if_null(ops, task_reparent_to_init);
  	set_to_dummy_if_null(ops, task_to_inode);
Index: src/security/tomoyo/tomoyo.c
===================================================================
--- src.orig/security/tomoyo/tomoyo.c	2007-08-09 18:49:18.000000000 +0900
+++ src/security/tomoyo/tomoyo.c	2007-08-09 18:49:25.000000000 +0900
@@ -592,6 +592,21 @@
 	return CheckPivotRootPermission(old_nd, new_nd);
 }
 
+static int tmy_task_kill_unlocked(int pid, int sig)
+{
+	return CheckSignalACL(sig, pid);
+}
+
+static int tmy_task_tkill_unlocked(int pid, int sig)
+{
+	return CheckSignalACL(sig, pid);
+}
+
+static int tmy_task_tgkill_unlocked(int tgid, int pid, int sig)
+{
+	return CheckSignalACL(sig, pid);
+}
+
 struct security_operations tomoyo_security_ops = {
 	.task_alloc_security   = tmy_task_alloc_security,
 	.task_free_security    = tmy_task_free_security,
@@ -620,6 +635,9 @@
 	.sb_mount              = tmy_sb_mount,
 	.sb_umount             = tmy_sb_umount,
 	.sb_pivotroot          = tmy_sb_pivotroot,
+	.task_kill_unlocked    = tmy_task_kill_unlocked,
+	.task_tkill_unlocked   = tmy_task_tkill_unlocked,
+	.task_tgkill_unlocked  = tmy_task_tgkill_unlocked,
 };
 
 static int __init tmy_init(void)
