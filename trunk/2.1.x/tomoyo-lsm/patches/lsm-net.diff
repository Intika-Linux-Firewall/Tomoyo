Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>

---
 include/linux/security.h |   43 ++++++++++++++++++++----
 net/socket.c             |   41 ++++++++++++++++++++---
 security/dummy.c         |   13 +++++--
 security/tomoyo/net.c    |   10 +++++
 security/tomoyo/tomoyo.c |   82 +++++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 173 insertions(+), 16 deletions(-)

Index: src/net/socket.c
===================================================================
--- src.orig/net/socket.c	2007-08-08 16:21:21.000000000 +0900
+++ src/net/socket.c	2007-08-08 16:21:53.000000000 +0900
@@ -635,7 +635,17 @@
 	if (err)
 		return err;
 
-	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
+	err = sock->ops->recvmsg(iocb, sock, msg, size, flags);
+
+	if (err >= 0) {
+		int ret;
+
+		ret = security_socket_post_recvmsg(sock, msg, size, flags);
+		if (ret)
+			err = ret;
+	}
+
+	return err;
 }
 
 int sock_recvmsg(struct socket *sock, struct msghdr *msg,
@@ -648,8 +658,18 @@
 	init_sync_kiocb(&iocb, NULL);
 	iocb.private = &siocb;
 	ret = __sock_recvmsg(&iocb, sock, msg, size, flags);
-	if (-EIOCBQUEUED == ret)
+	if (-EIOCBQUEUED == ret) {
 		ret = wait_on_sync_kiocb(&iocb);
+
+		if (ret >= 0) {
+			int err;
+
+			err = security_socket_post_recvmsg(sock, msg, size, flags);
+			if (err)
+				ret = err;
+		}
+	}
+
 	return ret;
 }
 
@@ -712,12 +732,14 @@
 	struct socket *sock = file->private_data;
 	size_t size = 0;
 	int i;
+	/* only for security_socket_post_recvmsg() */
+	char address[MAX_SOCK_ADDR];
 
 	for (i = 0; i < nr_segs; i++)
 		size += iov[i].iov_len;
 
-	msg->msg_name = NULL;
-	msg->msg_namelen = 0;
+	msg->msg_name = address;
+	msg->msg_namelen = sizeof(address);
 	msg->msg_control = NULL;
 	msg->msg_controllen = 0;
 	msg->msg_iov = (struct iovec *)iov;
@@ -1437,13 +1459,16 @@
 			goto out_fd;
 	}
 
+	/* Filter connections from unwanted peers like TCP Wrapper. */
+	err = security_socket_post_accept(sock, newsock);
+	if (err)
+		goto out_fd;
+
 	/* File flags are not inherited via accept() unlike another OSes. */
 
 	fd_install(newfd, newfile);
 	err = newfd;
 
-	security_socket_post_accept(sock, newsock);
-
 out_put:
 	fput_light(sock->file, fput_needed);
 out:
@@ -1937,6 +1962,10 @@
 		goto out_freeiov;
 	total_len = err;
 
+	/* only for security_socket_post_recvmsg() */
+	msg_sys.msg_name = addr;
+	msg_sys.msg_namelen = sizeof(addr);
+
 	cmsg_ptr = (unsigned long)msg_sys.msg_control;
 	msg_sys.msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);
 
Index: src/include/linux/security.h
===================================================================
--- src.orig/include/linux/security.h	2007-08-08 16:21:27.000000000 +0900
+++ src/include/linux/security.h	2007-08-09 18:11:39.000000000 +0900
@@ -749,8 +749,12 @@
  * @socket_post_accept:
  *	This hook allows a security module to copy security
  *	information into the newly created socket's inode.
+ *	This hook also allows a security module to filter connections
+ *	from unwanted peers.
+ *	The connection will be aborted if this hook returns nonzero.
  *	@sock contains the listening socket structure.
  *	@newsock contains the newly created server socket for connection.
+ *	Return 0 if permission is granted.
  * @socket_sendmsg:
  *	Check permission before transmitting a message to another socket.
  *	@sock contains the socket structure.
@@ -764,6 +768,14 @@
  *	@size contains the size of message structure.
  *	@flags contains the operational flags.
  *	Return 0 if permission is granted.  
+ * @socket_post_recvmsg:
+ *	Check peer's address after receiving a message from a socket.
+ *	This hook is intended for filtering messages from unwanted peers.
+ *	@sock contains the socket structure.
+ *	@msg contains the message structure.
+ *	@size contains the size of message structure.
+ *	@flags contains the operational flags.
+ *	Return 0 if permission is granted.
  * @socket_getsockname:
  *	Check permission before the local address (name) of the socket object
  *	@sock is retrieved.
@@ -1345,12 +1357,14 @@
 			       struct sockaddr * address, int addrlen);
 	int (*socket_listen) (struct socket * sock, int backlog);
 	int (*socket_accept) (struct socket * sock, struct socket * newsock);
-	void (*socket_post_accept) (struct socket * sock,
-				    struct socket * newsock);
+	int (*socket_post_accept) (struct socket *sock,
+				   struct socket *newsock);
 	int (*socket_sendmsg) (struct socket * sock,
 			       struct msghdr * msg, int size);
 	int (*socket_recvmsg) (struct socket * sock,
 			       struct msghdr * msg, int size, int flags);
+	int (*socket_post_recvmsg) (struct socket *sock, struct msghdr *msg,
+				    int size, int flags);
 	int (*socket_getsockname) (struct socket * sock);
 	int (*socket_getpeername) (struct socket * sock);
 	int (*socket_getsockopt) (struct socket * sock, int level, int optname);
@@ -2860,10 +2874,10 @@
 	return security_ops->socket_accept(sock, newsock);
 }
 
-static inline void security_socket_post_accept(struct socket * sock, 
-					       struct socket * newsock)
+static inline int security_socket_post_accept(struct socket *sock,
+					      struct socket *newsock)
 {
-	security_ops->socket_post_accept(sock, newsock);
+	return security_ops->socket_post_accept(sock, newsock);
 }
 
 static inline int security_socket_sendmsg(struct socket * sock, 
@@ -2879,6 +2893,13 @@
 	return security_ops->socket_recvmsg(sock, msg, size, flags);
 }
 
+static inline int security_socket_post_recvmsg(struct socket *sock,
+					       struct msghdr *msg,
+					       int size, int flags)
+{
+	return security_ops->socket_post_recvmsg(sock, msg, size, flags);
+}
+
 static inline int security_socket_getsockname(struct socket * sock)
 {
 	return security_ops->socket_getsockname(sock);
@@ -3023,9 +3044,10 @@
 	return 0;
 }
 
-static inline void security_socket_post_accept(struct socket * sock, 
-					       struct socket * newsock)
+static inline int security_socket_post_accept(struct socket *sock,
+					      struct socket *newsock)
 {
+	return 0;
 }
 
 static inline int security_socket_sendmsg(struct socket * sock, 
@@ -3041,6 +3063,13 @@
 	return 0;
 }
 
+static inline int security_socket_post_recvmsg(struct socket *sock,
+					       struct msghdr *msg,
+					       int size, int flags)
+{
+	return 0;
+}
+
 static inline int security_socket_getsockname(struct socket * sock)
 {
 	return 0;
Index: src/security/dummy.c
===================================================================
--- src.orig/security/dummy.c	2007-08-08 16:21:33.000000000 +0900
+++ src/security/dummy.c	2007-08-09 18:11:39.000000000 +0900
@@ -741,10 +741,10 @@
 	return 0;
 }
 
-static void dummy_socket_post_accept (struct socket *sock, 
-				      struct socket *newsock)
+static int dummy_socket_post_accept(struct socket *sock,
+				    struct socket *newsock)
 {
-	return;
+	return 0;
 }
 
 static int dummy_socket_sendmsg (struct socket *sock, struct msghdr *msg,
@@ -759,6 +759,12 @@
 	return 0;
 }
 
+static int dummy_socket_post_recvmsg(struct socket *sock, struct msghdr *msg,
+				     int size, int flags)
+{
+	return 0;
+}
+
 static int dummy_socket_getsockname (struct socket *sock)
 {
 	return 0;
@@ -1096,6 +1102,7 @@
 	set_to_dummy_if_null(ops, socket_post_accept);
 	set_to_dummy_if_null(ops, socket_sendmsg);
 	set_to_dummy_if_null(ops, socket_recvmsg);
+	set_to_dummy_if_null(ops, socket_post_recvmsg);
 	set_to_dummy_if_null(ops, socket_getsockname);
 	set_to_dummy_if_null(ops, socket_getpeername);
 	set_to_dummy_if_null(ops, socket_setsockopt);
Index: src/security/tomoyo/net.c
===================================================================
--- src.orig/security/tomoyo/net.c	2007-08-08 16:21:37.000000000 +0900
+++ src/security/tomoyo/net.c	2007-08-08 16:21:53.000000000 +0900
@@ -888,3 +888,13 @@
 	return tmy_network_entry(is_ipv6, type,
 				 (const u32 *) address, ntohs(port));
 }
+
+int tmy_network_accept_acl(const int is_ipv6, const u8 *address, const u16 port)
+{
+	return tmy_network_entry(is_ipv6, TMY_NETWORK_ACL_TCP_ACCEPT, (const u32 *) address, ntohs(port));
+}
+
+int tmy_network_recvmsg_acl(const int is_ipv6, const int sock_type, const u8 *address, const u16 port)
+{
+	return tmy_network_entry(is_ipv6, sock_type == SOCK_DGRAM ? TMY_NETWORK_ACL_UDP_CONNECT : TMY_NETWORK_ACL_RAW_CONNECT, (const u32 *) address, ntohs(port));
+}
Index: src/security/tomoyo/tomoyo.c
===================================================================
--- src.orig/security/tomoyo/tomoyo.c	2007-08-08 16:21:41.000000000 +0900
+++ src/security/tomoyo/tomoyo.c	2007-08-09 18:11:39.000000000 +0900
@@ -475,6 +475,86 @@
 	return error;
 }
 
+static int tmy_socket_post_accept(struct socket *sock, struct socket *newsock)
+{
+	int error = 0;
+	int addr_len;
+	char addr[MAX_SOCK_ADDR];
+	struct sockaddr *sockaddr = (struct sockaddr *) addr;
+
+	if ((newsock->sk->sk_family != PF_INET) &&
+	    (newsock->sk->sk_family != PF_INET6))
+		return error;
+
+	if (newsock->ops->getname(newsock, sockaddr, &addr_len, 2) == 0) {
+		switch (sockaddr->sa_family) {
+			struct sockaddr_in6 *in6;
+			struct sockaddr_in *in;
+
+		case AF_INET6:
+			in6 = (struct sockaddr_in6 *) addr;
+			error = tmy_network_accept_acl(1,
+						       in6->sin6_addr.s6_addr,
+						       in6->sin6_port);
+			break;
+
+		case AF_INET:
+			in = (struct sockaddr_in *) addr;
+			error = tmy_network_accept_acl(0, (u8 *) &in->sin_addr,
+						       in->sin_port);
+			break;
+		}
+	} else
+		error = -EPERM;
+
+	if (error)
+		return -ECONNABORTED;
+	return error;
+}
+
+static int tmy_socket_post_recvmsg(struct socket *sock, struct msghdr *msg,
+				   int size, int flags)
+{
+	int error = 0;
+	const unsigned int type = sock->type;
+	struct sockaddr *addr = (struct sockaddr *) msg->msg_name;
+	int addr_len = msg->msg_namelen;
+
+	if (!addr || (type != SOCK_DGRAM && type != SOCK_RAW))
+		return error;
+
+	switch (addr->sa_family) {
+		struct sockaddr_in6 *in6;
+		struct sockaddr_in *in;
+		u16 port;
+
+	case AF_INET6:
+		in6 = (struct sockaddr_in6 *) addr;
+		port = type == SOCK_DGRAM ?
+			in6->sin6_port : htons(sock->sk->sk_protocol);
+		if (addr_len >= SIN6_LEN_RFC2133)
+			error = tmy_network_recvmsg_acl(1, type,
+							in6->sin6_addr.s6_addr,
+							port);
+		break;
+
+	case AF_INET:
+		in = (struct sockaddr_in *) addr;
+		port = type == SOCK_DGRAM ?
+			in->sin_port : htons(sock->sk->sk_protocol);
+		if (addr_len >= sizeof(struct sockaddr_in))
+			error = tmy_network_recvmsg_acl(0, type,
+							(u8 *) &in->sin_addr,
+							port);
+		break;
+
+	}
+
+	if (error)
+		return -EAGAIN;
+	return error;
+}
+
 static int tmy_sb_mount(char *dev_name,
 			struct nameidata *nd,
 			char *type,
@@ -535,6 +615,8 @@
 	.socket_connect        = tmy_socket_connect,
 	.socket_bind 	       = tmy_socket_bind,
 	.socket_sendmsg        = tmy_socket_sendmsg,
+	.socket_post_accept    = tmy_socket_post_accept,
+	.socket_post_recvmsg   = tmy_socket_post_recvmsg,
 	.sb_mount              = tmy_sb_mount,
 	.sb_umount             = tmy_sb_umount,
 	.sb_pivotroot          = tmy_sb_pivotroot,
