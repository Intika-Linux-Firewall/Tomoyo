---
 security/tomoyo/signal.c |  149 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 149 insertions(+)

Index: src/security/tomoyo/signal.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ src/security/tomoyo/signal.c	2007-08-10 18:28:21.000000000 +0900
@@ -0,0 +1,149 @@
+/*
+ * security/tomoyo/signal.c
+ *
+ * Signal access contol functions for TOMOYO Linux.
+ */
+
+#include "tomoyo.h"
+#include "realpath.h"
+
+/*************************  AUDIT FUNCTIONS  *************************/
+
+static int AuditSignalLog(const int signal,
+			  const struct path_info *dest_domain,
+			  const int is_granted,
+			  const int is_enforce)
+{
+	char *buf;
+	int len;
+
+	if (is_granted) {
+		if (!tmy_audit_grant())
+			return 0;
+	} else {
+		if (!tmy_audit_reject())
+			return 0;
+	}
+
+	len = dest_domain->total_len;
+	buf = tmy_init_audit_log(&len);
+
+	if (!buf)
+		return -ENOMEM;
+
+	snprintf(buf + strlen(buf),
+		 len - strlen(buf) - 1,
+		 "%s%d %s",
+		 TMY_ALLOW_SIGNAL, signal, dest_domain->name);
+
+	return tmy_write_audit_log(buf, is_granted, is_enforce);
+}
+
+/*************************  SIGNAL ACL HANDLER  *************************/
+
+static int AddSignalEntry(const int sig, const char *dest_pattern, struct domain_info *domain, const u8 is_add)
+{
+	struct acl_info *ptr;
+	const struct path_info *saved_dest_pattern;
+	const u16 hash = sig;
+	int error = -ENOMEM;
+	if (!domain) return -EINVAL;
+	if (!dest_pattern || !tmy_is_correct_domain(dest_pattern, __FUNCTION__)) return -EINVAL;
+	if ((saved_dest_pattern = tmy_save_name(dest_pattern)) == NULL) return -ENOMEM;
+	down(&domain_acl_lock);
+	if (is_add) {
+		if ((ptr = domain->first_acl_ptr) == NULL) goto first_entry;
+		while (1) {
+			struct signal_acl *acl = (struct signal_acl *) ptr;
+			if (ptr->type == TMY_TYPE_SIGNAL_ACL && acl->sig == hash) {
+				if (!tmy_pathcmp(acl->domainname, saved_dest_pattern)) {
+					ptr->is_deleted = 0;
+					/* Found. Nothing to do. */
+					error = 0;
+					break;
+				}
+			}
+			if (ptr->next) {
+				ptr = ptr->next;
+				continue;
+			}
+		first_entry: ;
+			if (is_add == 1 && tmy_too_many_acl(domain)) break;
+			/* Not found. Append it to the tail. */
+			if ((acl = tmy_alloc_element(sizeof(*acl))) == NULL) break;
+			acl->head.type = TMY_TYPE_SIGNAL_ACL;
+			acl->sig = hash;
+			acl->domainname = saved_dest_pattern;
+			error = tmy_add_acl(ptr, domain, (struct acl_info *) acl);
+			break;
+		}
+	} else {
+		error = -ENOENT;
+		for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
+			struct signal_acl *acl = (struct signal_acl *) ptr;
+			if (ptr->type != TMY_TYPE_SIGNAL_ACL || ptr->is_deleted || acl->sig != hash) continue;
+			if (tmy_pathcmp(acl->domainname, saved_dest_pattern)) continue;
+			error = tmy_del_acl(ptr);
+			break;
+		}
+	}
+	up(&domain_acl_lock);
+	return error;
+}
+
+int CheckSignalACL(const int sig, const int pid)
+{
+	struct domain_info *domain = TMY_SECURITY->domain;
+	struct domain_info *dest = NULL;
+	const char *dest_pattern;
+	struct acl_info *ptr;
+	const u16 hash = sig;
+	const int is_enforce = tmy_enforce(TMY_MAC_FOR_SIGNAL);
+	if (!tmy_flags(TMY_MAC_FOR_SIGNAL)) return 0;
+	if (!sig) return 0;                               /* No check for NULL signal. */
+	if (current->pid == pid) {
+		AuditSignalLog(sig, domain->domainname, 1, is_enforce);
+		return 0;                /* No check for self. */
+	}
+	{ /* Simplified checking. */
+		struct task_struct *p = NULL;
+		read_lock(&tasklist_lock);
+		if (pid > 0) p = find_task_by_pid((pid_t) pid);
+		else if (pid == 0) p = current;
+		else if (pid == -1) dest = &KERNEL_DOMAIN;
+		else p = find_task_by_pid((pid_t) -pid);
+		if (p) dest = ((struct tmy_security *) p->security)->domain;
+		read_unlock(&tasklist_lock);
+		if (!dest) return 0; /* I can't find destinatioin. */
+	}
+	if (domain == dest) {
+		AuditSignalLog(sig, dest->domainname, 1, is_enforce);
+		return 0;
+	}
+	dest_pattern = dest->domainname->name;
+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
+		struct signal_acl *acl = (struct signal_acl *) ptr;
+		if (ptr->type == TMY_TYPE_SIGNAL_ACL && ptr->is_deleted == 0 && acl->sig == hash) {
+			const int len = acl->domainname->total_len;
+			if (strncmp(acl->domainname->name, dest_pattern, len) == 0 && (dest_pattern[len] == ' ' || dest_pattern[len] == '\0')) break;
+		}
+	}
+	if (ptr) {
+		AuditSignalLog(sig, dest->domainname, 1, is_enforce);
+		return 0;
+	}
+	AuditSignalLog(sig, dest->domainname, 0, is_enforce);
+	if (is_enforce) return tmy_supervisor("%s\n" TMY_ALLOW_SIGNAL "%d %s\n", domain->domainname->name, sig, dest_pattern);
+	if (tmy_accept(TMY_MAC_FOR_SIGNAL)) AddSignalEntry(sig, dest_pattern, domain, 1);
+	return 0;
+}
+
+int AddSignalPolicy(char *data, struct domain_info *domain, const int is_delete)
+{
+	int sig;
+	char *domainname = strchr(data, ' ');
+	if (sscanf(data, "%d", &sig) == 1 && domainname && tmy_is_domain_def(domainname + 1)) {
+		return AddSignalEntry(sig, domainname + 1, domain, is_delete ? 0 : -1);
+	}
+	return -EINVAL;
+}
