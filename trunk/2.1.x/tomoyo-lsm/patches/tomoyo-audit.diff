This patch makes access logs sent to wither auditing subsystem or
/sys/kernel/security/tomoyo/ interface.

TOMOYO Linux uses two channels when using auditing subsystem.
One is 'AUDIT_TMY_GRANTED', used for auditing accesses which are
granted in the TOMOYO Linux policy.
The other is 'AUDIT_TMY_REJECTED', used for auditing accesses which
are not granted in the TOMOYO Linux policy.

TOMOYO Linux uses two files when using /sys/kernel/security/tomoyo/ interface.
One is 'grant_log', used for auditing accesses which are
granted in the TOMOYO Linux policy.
The other is 'reject_log', used for auditing accesses which
are not granted in the TOMOYO Linux policy.
The userland daemon /usr/lib/ccs/ccs-auditd will save these logs.

Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 include/linux/audit.h   |    3 
 security/tomoyo/audit.c |  258 ++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 261 insertions(+)

Index: linux-2.6.23-tomoyo2.1/security/tomoyo/audit.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.23-tomoyo2.1/security/tomoyo/audit.c	2007-10-31 14:57:01.000000000 +0900
@@ -0,0 +1,258 @@
+/*
+ * security/tomoyo/audit.c
+ *
+ * Audit functions for TOMOYO Linux
+ */
+
+#include "tomoyo.h"
+
+#ifdef CONFIG_SECURITY_TOMOYO_USE_AUDITD
+
+#include <linux/audit.h>
+
+/**
+ * tmy_init_audit_log - allocate and initialize audit buffer.
+ * @len: pointer to length of requested size.
+ * @profile: profile number for this log.
+ * @mode: profile value for this log.
+ *
+ * Returns pointer to audit buffer on success. @len received allocated size.
+ * Returns NULL on failure.
+ *
+ * @len must not be a NULL.
+ */
+char *tmy_init_audit_log(int *len, const u8 profile, const unsigned int mode)
+{
+	char *buf;
+	struct task_struct *task = current;
+	const char *domainname = TMY_SECURITY->domain->domainname->name;
+
+	*len += strlen(domainname) + 256;
+	buf = tmy_alloc(*len);
+
+	if (!buf)
+		return NULL;
+
+	snprintf(buf, (*len) - 1, "profile=%u mode=%u "
+		 "pid=%d uid=%d gid=%d euid=%d egid=%d "
+		 "suid=%d sgid=%d fsuid=%d fsgid=%d : %s : ",
+		 profile, mode,
+		 task->pid, task->uid, task->gid, task->euid, task->egid,
+		 task->suid, task->sgid, task->fsuid, task->fsgid, domainname);
+
+	return buf;
+}
+
+/**
+ * tmy_write_audit_log - write audit log.
+ * @buf:        pointer to access log contents.
+ * @is_granted: is the access request granted?
+ *
+ * Returns zero on success.
+ * Returns nonzero on failure.
+ *
+ * Write audit log.
+ * Caller must allocate @buf with tmy_init_audit_log().
+ */
+int tmy_write_audit_log(char *buf, const bool is_granted)
+{
+	struct audit_buffer *ab;
+	int type = is_granted ? AUDIT_TMY_GRANTED : AUDIT_TMY_REJECTED;
+
+	ab = audit_log_start(current->audit_context, GFP_KERNEL, type);
+	if (ab) {
+		audit_log_format(ab, "TOMOYO: %s", buf);
+		audit_log_end(ab);
+	}
+
+	tmy_free(buf);
+	return ab ? 0 : -ENOMEM;
+}
+
+#else
+
+static DECLARE_WAIT_QUEUE_HEAD(grant_log_wait);
+static DECLARE_WAIT_QUEUE_HEAD(reject_log_wait);
+
+static DEFINE_SPINLOCK(audit_log_lock);
+
+struct log_entry {
+	struct list_head list;
+	char *log;
+};
+
+static LIST_HEAD(grant_log);
+static LIST_HEAD(reject_log);
+
+static int grant_log_count;
+static int reject_log_count;
+
+/**
+ * tmy_audit_grant - get flags of auditing grant logs.
+ *
+ * Returns current value of auditing grant log flags.
+ */
+bool tmy_audit_grant(void)
+{
+	return grant_log_count < tmy_flags(TMY_MAX_GRANT_LOG);
+}
+
+/**
+ * tmy_audit_reject - get flags of auditing reject logs.
+ *
+ * Returns current value of auditing reject log flags.
+ */
+bool tmy_audit_reject(void)
+{
+	return reject_log_count < tmy_flags(TMY_MAX_REJECT_LOG);
+}
+
+/**
+ * tmy_init_audit_log - allocate and initialize audit buffer.
+ * @len: pointer to length of requested size.
+ * @profile: profile number for this log.
+ * @mode: profile value for this log.
+ *
+ * Returns pointer to audit buffer on success. @len received allocated size.
+ * Returns NULL on failure.
+ *
+ * @len must not be a NULL.
+ */
+char *tmy_init_audit_log(int *len, const u8 profile, const unsigned int mode)
+{
+	char *buf;
+	struct timeval tv;
+	struct task_struct *task = current;
+	const char *domainname = TMY_SECURITY->domain->domainname->name;
+	do_gettimeofday(&tv);
+	*len += strlen(domainname) + 256;
+	buf = tmy_alloc(*len);
+	if (!buf)
+		return NULL;
+	snprintf(buf, (*len) - 1, "#timestamp=%lu profile=%u mode=%u "
+		 "pid=%d uid=%d gid=%d euid=%d egid=%d "
+		 "suid=%d sgid=%d fsuid=%d fsgid=%d \n%s\n",
+		 tv.tv_sec, profile, mode,
+		 task->pid, task->uid, task->gid, task->euid, task->egid,
+		 task->suid, task->sgid, task->fsuid, task->fsgid, domainname);
+	return buf;
+}
+
+/**
+ * tmy_write_audit_log - write audit log.
+ * @buf:        pointer to access log contents.
+ * @is_granted: is the access request granted?
+ *
+ * Returns zero on success.
+ * Returns nonzero on failure.
+ *
+ * Write audit log.
+ * Caller must allocate @buf with tmy_init_audit_log().
+ */
+int tmy_write_audit_log(char *buf, const bool is_granted)
+{
+	struct log_entry *new_entry;
+	new_entry = tmy_alloc(sizeof(*new_entry));
+	if (!new_entry) {
+		tmy_free(buf);
+		return -ENOMEM;
+	}
+	INIT_LIST_HEAD(&new_entry->list);
+	new_entry->log = buf;
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&audit_log_lock);
+	if (is_granted) {
+		list_add_tail(&new_entry->list, &grant_log);
+		grant_log_count++;
+		buf = NULL;
+		tmy_update_counter(TMY_UPDATE_GRANT_LOG);
+	} else {
+		list_add_tail(&new_entry->list, &reject_log);
+		reject_log_count++;
+		buf = NULL;
+		tmy_update_counter(TMY_UPDATE_REJECT_LOG);
+	}
+	spin_unlock(&audit_log_lock);
+	/***** CRITICAL SECTION END *****/
+	if (is_granted)
+		wake_up(&grant_log_wait);
+	else
+		wake_up(&reject_log_wait);
+	return 0;
+}
+
+int tmy_read_grant_log(struct io_buffer *head)
+{
+	struct log_entry *ptr = NULL;
+	if (head->read_avail) return 0;
+	if (head->read_buf) {
+		tmy_free(head->read_buf);
+		head->read_buf = NULL;
+		head->readbuf_size = 0;
+	}
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&audit_log_lock);
+	if (!list_empty(&grant_log)) {
+		ptr = list_entry(grant_log.next, struct log_entry, list);
+		list_del(&ptr->list);
+		grant_log_count--;
+	}
+	spin_unlock(&audit_log_lock);
+	/***** CRITICAL SECTION END *****/
+	if (ptr) {
+		head->read_buf = ptr->log;
+		head->read_avail = strlen(ptr->log) + 1;
+		head->readbuf_size = head->read_avail;
+		tmy_free(ptr);
+	}
+	return 0;
+}
+
+int tmy_poll_grant_log(struct file *file, poll_table *wait)
+{
+	if (grant_log_count)
+		return POLLIN | POLLRDNORM;
+	poll_wait(file, &grant_log_wait, wait);
+	if (grant_log_count)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+int tmy_read_reject_log(struct io_buffer *head)
+{
+	struct log_entry *ptr = NULL;
+	if (head->read_avail)
+		return 0;
+	if (head->read_buf) {
+		tmy_free(head->read_buf);
+		head->read_buf = NULL;
+		head->readbuf_size = 0;
+	}
+	/***** CRITICAL SECTION START *****/
+	spin_lock(&audit_log_lock);
+	if (!list_empty(&reject_log)) {
+		ptr = list_entry(reject_log.next, struct log_entry, list);
+		list_del(&ptr->list);
+		reject_log_count--;
+	}
+	spin_unlock(&audit_log_lock);
+	/***** CRITICAL SECTION END *****/
+	if (ptr) {
+		head->read_buf = ptr->log;
+		head->read_avail = strlen(ptr->log) + 1;
+		head->readbuf_size = head->read_avail;
+		tmy_free(ptr);
+	}
+	return 0;
+}
+
+int tmy_poll_reject_log(struct file *file, poll_table *wait)
+{
+	if (reject_log_count)
+		return POLLIN | POLLRDNORM;
+	poll_wait(file, &reject_log_wait, wait);
+	if (reject_log_count)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+#endif
Index: linux-2.6.23-tomoyo2.1/include/linux/audit.h
===================================================================
--- linux-2.6.23-tomoyo2.1.orig/include/linux/audit.h	2007-10-10 05:31:38.000000000 +0900
+++ linux-2.6.23-tomoyo2.1/include/linux/audit.h	2007-10-31 14:57:01.000000000 +0900
@@ -120,6 +120,9 @@
 
 #define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
 
+#define AUDIT_TMY_GRANTED  2001 /* TOMOYO Linux audit granted */
+#define AUDIT_TMY_REJECTED 2002 /* TOMOYO Linux audit rejected */
+
 /* Rule flags */
 #define AUDIT_FILTER_USER	0x00	/* Apply rule to user-generated messages */
 #define AUDIT_FILTER_TASK	0x01	/* Apply rule at task creation (not syscall) */
