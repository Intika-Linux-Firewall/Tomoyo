Capability access control functions for TOMOYO Linux.
TOMOYO Linux checks permission for non-POSIX capability
so that the number of capabilities won't be limited to 32 or 64.

Each permission can be automatically accumulated into
the policy of each domain using 'learning mode'.

Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 security/tomoyo/capability.c |  276 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 276 insertions(+)

--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.23/security/tomoyo/capability.c	2007-11-01 13:11:06.534299000 +0900
@@ -0,0 +1,276 @@
+/*
+ * security/tomoyo/capability.c
+ *
+ * Capability access control functions for TOMOYO Linux.
+ */
+#include "tomoyo.h"
+#include "realpath.h"
+#include <linux/hardirq.h>
+
+static struct {
+	const char *keyword;
+	unsigned int current_value;
+} capability_control_array[TMY_MAX_CAPABILITY_INDEX] = {
+	[TMY_INET_STREAM_SOCKET_CREATE]  = { "inet_tcp_create", 0 },    /* OK */
+	[TMY_INET_STREAM_SOCKET_LISTEN]  = { "inet_tcp_listen", 0 },    /* OK */
+	[TMY_INET_STREAM_SOCKET_CONNECT] = { "inet_tcp_connect", 0 },   /* OK */
+	[TMY_USE_INET_DGRAM_SOCKET]      = { "use_inet_udp", 0 },       /* OK */
+	[TMY_USE_INET_RAW_SOCKET]        = { "use_inet_ip", 0 },        /* OK */
+	[TMY_USE_ROUTE_SOCKET]           = { "use_route", 0 },          /* OK */
+	[TMY_USE_PACKET_SOCKET]          = { "use_packet", 0 },         /* OK */
+	[TMY_SYS_MOUNT]                  = { "SYS_MOUNT", 0 },          /* OK */
+	[TMY_SYS_UMOUNT]                 = { "SYS_UMOUNT", 0 },         /* OK */
+	[TMY_SYS_REBOOT]                 = { "SYS_REBOOT", 0 },       /* Over */
+	[TMY_SYS_CHROOT]                 = { "SYS_CHROOT", 0 },         /* OK */
+	[TMY_SYS_KILL]                   = { "SYS_KILL", 0 },         /* None */
+	[TMY_SYS_VHANGUP]                = { "SYS_VHANGUP", 0 },      /* Over */
+	[TMY_SYS_SETTIME]                = { "SYS_TIME", 0 },         /* Over */
+	[TMY_SYS_NICE]                   = { "SYS_NICE", 0 },           /* OK */
+	[TMY_SYS_SETHOSTNAME]            = { "SYS_SETHOSTNAME", 0 },  /* None */
+	[TMY_USE_KERNEL_MODULE]         = { "use_kernel_module", 0 }, /* Over */
+	[TMY_CREATE_FIFO]                = { "create_fifo", 0 },        /* OK */
+	[TMY_CREATE_BLOCK_DEV]           = { "create_block_dev", 0 },   /* OK */
+	[TMY_CREATE_CHAR_DEV]            = { "create_char_dev", 0 },    /* OK */
+	[TMY_CREATE_UNIX_SOCKET]         = { "create_unix_socket", 0 }, /* OK */
+	[TMY_SYS_LINK]                   = { "SYS_LINK", 0 },           /* OK */
+	[TMY_SYS_SYMLINK]                = { "SYS_SYMLINK", 0 },        /* OK */
+	[TMY_SYS_RENAME]                 = { "SYS_RENAME", 0 },         /* OK */
+	[TMY_SYS_UNLINK]                 = { "SYS_UNLINK", 0 },         /* OK */
+	[TMY_SYS_CHMOD]                  = { "SYS_CHMOD", 0 },          /* OK */
+	[TMY_SYS_CHOWN]                  = { "SYS_CHOWN", 0 },          /* OK */
+	[TMY_SYS_IOCTL]                  = { "SYS_IOCTL", 0 },        /* Over */
+	[TMY_SYS_KEXEC_LOAD]             = { "SYS_KEXEC_LOAD", 0 },   /* None */
+	[TMY_SYS_PIVOT_ROOT]             = { "SYS_PIVOT_ROOT", 0 },     /* OK */
+};
+
+struct profile {
+	unsigned char value[TMY_MAX_CAPABILITY_INDEX];
+};
+
+static struct profile *profile_ptr[TMY_MAX_PROFILES];
+
+/*************************  UTILITY FUNCTIONS  *************************/
+
+const char *tmy_capability2keyword(const unsigned int capability)
+{
+	return capability < TMY_MAX_CAPABILITY_INDEX ?
+		capability_control_array[capability].keyword : NULL;
+}
+
+/* Check whether the given capability control is enabled. */
+static unsigned int tmy_capability_flags(const unsigned int index)
+{
+	const u8 profile = TMY_SECURITY->domain->profile;
+	/* All operations might sleep. See tmy_supervisor(). */
+	might_sleep();
+	if (in_interrupt())
+		return 0;
+	return sbin_init_started && index < TMY_MAX_CAPABILITY_INDEX
+#if TMY_MAX_PROFILES != 256
+		&& profile < TMY_MAX_PROFILES
+#endif
+		&& profile_ptr[profile] ?
+		profile_ptr[profile]->value[index] : 0;
+}
+
+static struct profile *tmy_new_capability_profile(const unsigned int profile)
+{
+	static DEFINE_MUTEX(mutex);
+	struct profile *ptr;
+	int i;
+	if (profile >= TMY_MAX_PROFILES)
+		return NULL;
+	mutex_lock(&mutex);
+	ptr = profile_ptr[profile];
+	if (ptr)
+		goto ok;
+	ptr = tmy_alloc_element(sizeof(*ptr));
+	if (!ptr)
+		goto ok;
+	for (i = 0; i < TMY_MAX_CAPABILITY_INDEX; i++)
+		ptr->value[i] = capability_control_array[i].current_value;
+	mb(); /* Avoid out-of-order execution. */
+	profile_ptr[profile] = ptr;
+ok: ;
+	mutex_unlock(&mutex);
+	return ptr;
+}
+
+int tmy_set_capability_profile(const char *data, unsigned int value,
+			       const unsigned int profile)
+{
+	int i;
+	struct profile *ptr;
+	ptr = tmy_new_capability_profile(profile);
+	if (!ptr)
+		return -EINVAL;
+	for (i = 0; i < TMY_MAX_CAPABILITY_INDEX; i++) {
+		if (strcmp(data, capability_control_array[i].keyword)) continue;
+		if (value > 3) value = 3;
+		ptr->value[i] = value;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+int tmy_read_capability_profile(struct io_buffer *head)
+{
+	int step;
+	for (step = head->read_step;
+	     step < TMY_MAX_PROFILES * TMY_MAX_CAPABILITY_INDEX; step++) {
+		const int i = step / TMY_MAX_CAPABILITY_INDEX;
+		const int j = step % TMY_MAX_CAPABILITY_INDEX;
+		const struct profile *profile = profile_ptr[i];
+		head->read_step = step;
+		if (!profile)
+			continue;
+		if (tmy_io_printf(head, "%u-" TMY_MAC_FOR_CAPABILITY "%s=%u\n",
+				  i, capability_control_array[j].keyword,
+				  profile->value[j]))
+			break;
+	}
+	return step < TMY_MAX_PROFILES * TMY_MAX_CAPABILITY_INDEX ? -ENOMEM : 0;
+}
+
+/*************************  AUDIT FUNCTIONS  *************************/
+
+static int tmy_audit_capability_log(const unsigned int capability,
+				    const bool is_granted,
+				    const u8 profile, const unsigned int mode)
+{
+	char *buf;
+	int len = 64 ;
+
+	if (is_granted) {
+		if (!tmy_audit_grant())
+			return 0;
+	} else {
+		if (!tmy_audit_reject())
+			return 0;
+	}
+
+	buf = tmy_init_audit_log(&len, profile, mode);
+
+	if (!buf)
+		return -ENOMEM;
+
+	snprintf(buf + strlen(buf),
+		 len - strlen(buf) - 1,
+		 TMY_ALLOW_CAPABILITY "%s\n",
+		 tmy_capability2keyword(capability));
+
+	return tmy_write_audit_log(buf, is_granted);
+}
+
+/*************************  CAPABILITY ACL HANDLER  *************************/
+
+static int tmy_add_capability_acl(const unsigned int capability,
+				  struct domain_info *domain,
+				  const struct condition_list *condition,
+				  const bool is_delete)
+{
+	struct acl_info *ptr;
+	struct capability_acl *acl;
+	int error = -ENOMEM;
+	const u16 hash = capability;
+	if (!domain)
+		return -EINVAL;
+	mutex_lock(&domain_acl_lock);
+	if (is_delete)
+		goto remove;
+
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		acl = (struct capability_acl *) ptr;
+		if (ptr->type == TMY_TYPE_CAPABILITY_ACL
+		    && acl->capability == hash
+		    && ptr->cond == condition) {
+			ptr->is_deleted = 0;
+			/* Found. Nothing to do. */
+			error = 0;
+			tmy_update_counter(TMY_UPDATE_DOMAINPOLICY);
+			goto ok;
+		}
+	}
+	/* Not found. Append it to the tail. */
+	acl = tmy_alloc_element(sizeof(*acl));
+	if (!acl)
+		goto ok;
+	acl->head.type = TMY_TYPE_CAPABILITY_ACL;
+	acl->head.cond = condition;
+	acl->capability = hash;
+	error = tmy_add_acl(domain, (struct acl_info *) acl);
+	goto ok;
+remove: ;
+	error = -ENOENT;
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		acl = (struct capability_acl *) ptr;
+		if (ptr->type != TMY_TYPE_CAPABILITY_ACL || ptr->is_deleted ||
+		    acl->capability != hash || ptr->cond != condition) continue;
+		error = tmy_del_acl(ptr);
+		break;
+	}
+ok: ;
+	mutex_unlock(&domain_acl_lock);
+	return error;
+}
+
+/**
+ * tmy_capable - check permission for capability.
+ * @capability: capability index.
+ *
+ * Returns zero if permission granted.
+ * Returns nonzero if permission denied.
+ */
+int tmy_capable(const unsigned int capability)
+{
+	struct domain_info * const domain = TMY_SECURITY->domain;
+	struct acl_info *ptr;
+	const u8 profile = domain->profile;
+	const unsigned int mode = tmy_capability_flags(capability);
+	const bool is_enforce = (mode == 3);
+	const u16 hash = capability;
+	if (!mode)
+		return 0;
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct capability_acl *acl = (struct capability_acl *) ptr;
+		if (ptr->type != TMY_TYPE_CAPABILITY_ACL || ptr->is_deleted
+		    || acl->capability != hash
+		    || tmy_check_condition(ptr->cond, NULL))
+			continue;
+		tmy_audit_capability_log(capability, 1, profile, mode);
+		return 0;
+	}
+	tmy_audit_capability_log(capability, 0, profile, mode);
+	if (is_enforce)
+		return tmy_supervisor("%s\n" TMY_ALLOW_CAPABILITY "%s\n",
+				      domain->domainname->name,
+				      tmy_capability2keyword(capability));
+	if (mode == 1 && tmy_quota())
+		tmy_add_capability_acl(capability, domain, NULL, 0);
+	return 0;
+}
+
+/**
+ * tmy_add_capability_policy - add or delete capability policy.
+ * @data:      a line to parse.
+ * @domain:    pointer to "struct domain_info".
+ * @cond:      pointer to "struct condition_list". May be NULL.
+ * @is_delete: is this delete request?
+ *
+ * Returns zero on success.
+ * Returns nonzero on failure.
+ */
+int tmy_add_capability_policy(char *data, struct domain_info *domain,
+			      const struct condition_list *cond,
+			      const bool is_delete)
+{
+	unsigned int capability;
+	for (capability = 0; capability < TMY_MAX_CAPABILITY_INDEX;
+	     capability++) {
+		if (strcmp(data, capability_control_array[capability].keyword))
+			continue;
+		return tmy_add_capability_acl(capability, domain,
+					      cond, is_delete);
+	}
+	return -EINVAL;
+}
