Index: autobind.c
===================================================================
--- autobind.c	(revision 4969)
+++ autobind.c	(working copy)
@@ -43,39 +43,46 @@
 /**
  * ccs_update_reserved_entry - Update "struct ccs_reserved" list.
  *
- * @min_port:  Start of port number range.
- * @max_port:  End of port number range.
- * @is_delete: True if it is a delete request.
+ * @param:    Pointer to "struct ccs_element_param".
+ * @min_port: Start of port number range.
+ * @max_port: End of port number range.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_update_reserved_entry(const u16 min_port, const u16 max_port,
-				     const bool is_delete)
+static int ccs_update_reserved_entry(struct ccs_element_param *param,
+				     const u16 min_port, const u16 max_port)
 {
-	struct ccs_reserved *ptr;
 	struct ccs_reserved e = {
 		.min_port = min_port,
 		.max_port = max_port
 	};
-	const int error =
-		ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_RESERVEDPORT],
-				  ccs_same_reserved);
+	struct ccs_policy_namespace *ns = param->ns;
+	int error;
 	u8 *tmp;
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+	param->check_duplicate = ccs_same_reserved;
+	error = ccs_update_policy(param);
 	if (error)
 		return error;
 	tmp = kzalloc(sizeof(ccs_reserved_port_map), CCS_GFP_FLAGS);
 	if (!tmp)
 		return -ENOMEM;
-	list_for_each_entry_srcu(ptr, &ccs_policy_list[CCS_ID_RESERVEDPORT],
-				 head.list, &ccs_ss) {
-		unsigned int port;
-		if (ptr->head.is_deleted)
-			continue;
-		for (port = ptr->min_port; port <= ptr->max_port; port++)
-			tmp[port >> 3] |= 1 << (port & 7);
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		struct ccs_reserved *ptr;
+		struct list_head *list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
+			unsigned int port;
+			if (ptr->head.is_deleted)
+				continue;
+			for (port = ptr->min_port; port <= ptr->max_port;
+			     port++)
+				tmp[port >> 3] |= 1 << (port & 7);
+		}
 	}
 	memmove(ccs_reserved_port_map, tmp, sizeof(ccs_reserved_port_map));
 	kfree(tmp);
@@ -90,14 +97,14 @@
 /**
  * ccs_write_reserved_port - Write "struct ccs_reserved" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-int ccs_write_reserved_port(char *data, const bool is_delete)
+int ccs_write_reserved_port(struct ccs_element_param *param, char *data)
 {
 	unsigned int from;
 	unsigned int to;
@@ -109,8 +116,7 @@
 		/* fall through */
 	case 2:
 		if (from <= to && to < 65536)
-			return ccs_update_reserved_entry(from, to,
-							 is_delete);
+			return ccs_update_reserved_entry(param, from, to);
 		break;
 	}
 out:
Index: audit.c
===================================================================
--- audit.c	(revision 4969)
+++ audit.c	(working copy)
@@ -336,6 +336,7 @@
 {
 	const struct ccs_domain_info *domain;
 	char *buf;
+	const char *cp;
 	const struct ccs_acl_info *acl = r->matched_acl;
 	r->matched_acl = NULL;
 	if (!acl || !acl->cond || !acl->cond->transit)
@@ -349,8 +350,12 @@
 			return;
 	}
 	domain = ccs_current_domain();
-	snprintf(buf, CCS_EXEC_TMPSIZE - 1, "%s %s", domain->domainname->name,
-		 acl->cond->transit->name);
+	cp = acl->cond->transit->name;
+	if (*cp == '/')
+		snprintf(buf, CCS_EXEC_TMPSIZE - 1, "%s %s",
+			 domain->domainname->name, cp);
+	else
+		strncpy(buf, cp, CCS_EXEC_TMPSIZE - 1);
 	if (!ccs_assign_domain(buf, r->profile, domain->group, true))
 		ccs_transition_failed(buf);
 	kfree(buf);
Index: domain.c
===================================================================
--- domain.c	(revision 4969)
+++ domain.c	(working copy)
@@ -8,59 +8,37 @@
 
 #include "internal.h"
 
-/*
- * The global domains referred by "use_group" keyword.
- *
- * Although "use_group" needs only "struct list_head acl_info_list[2]",
- * we define structure for "use_group" as "struct ccs_domain_info" in order to
- * use common code.
- */
-struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
-
-/* The initial domain. */
-struct ccs_domain_info ccs_kernel_domain;
-
 /* The list for "struct ccs_domain_info". */
 LIST_HEAD(ccs_domain_list);
 
-/* List of policy. */
-struct list_head ccs_policy_list[CCS_MAX_POLICY];
-/* List of "struct ccs_group". */
-struct list_head ccs_group_list[CCS_MAX_GROUP];
 /* List of "struct ccs_condition" and "struct ccs_ipv6addr". */
 struct list_head ccs_shared_list[CCS_MAX_LIST];
 
 /**
  * ccs_update_policy - Update an entry for exception policy.
  *
- * @new_entry:       Pointer to "struct ccs_acl_info".
- * @size:            Size of @new_entry in bytes.
- * @is_delete:       True if it is a delete request.
- * @list:            Pointer to "struct list_head".
- * @check_duplicate: Callback function to find duplicated entry.
+ * @param: Pointer to "struct ccs_element_param".
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      bool is_delete, struct list_head *list,
-		      bool (*check_duplicate) (const struct ccs_acl_head *,
-					       const struct ccs_acl_head *))
+int ccs_update_policy(struct ccs_element_param *param)
 {
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	struct ccs_acl_head *entry;
+	struct list_head *list = param->list;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return -ENOMEM;
 	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
-		if (!check_duplicate(entry, new_entry))
+		if (!param->check_duplicate(entry, param->new_entry))
 			continue;
-		entry->is_deleted = is_delete;
+		entry->is_deleted = param->is_delete;
 		error = 0;
 		break;
 	}
-	if (error && !is_delete) {
-		entry = ccs_commit_ok(new_entry, size);
+	if (error && !param->is_delete) {
+		entry = ccs_commit_ok(param->new_entry, param->size);
 		if (entry) {
 			list_add_tail_rcu(&entry->list, list);
 			error = 0;
@@ -114,7 +92,7 @@
 		type == CCS_TYPE_DENIED_EXECUTE_HANDLER ||
 		type == CCS_TYPE_AUTO_TASK_ACL;
 	if (param->data[0]) {
-		new_entry->cond = ccs_get_condition(param->data);
+		new_entry->cond = ccs_get_condition(param->ns, param->data);
 		if (!new_entry->cond)
 			return -EINVAL;
 	}
@@ -183,7 +161,7 @@
 	}
 	if (!retried) {
 		retried = true;
-		domain = &ccs_acl_group[domain->group];
+		domain = &r->ns->acl_group[domain->group];
 		goto retry;
 	}
 	r->granted = false;
@@ -212,20 +190,20 @@
 /**
  * ccs_update_transition_control_entry - Update "struct ccs_transition_control" list.
  *
+ * @param:      Pointer to "struct ccs_element_param".
  * @domainname: The name of domain. Maybe NULL.
  * @program:    The name of program. Maybe NULL.
  * @type:       Type of transition.
- * @is_delete:  True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_transition_control_entry(const char *domainname,
+static int ccs_update_transition_control_entry(struct ccs_element_param *param,
+					       const char *domainname,
 					       const char *program,
-					       const u8 type,
-					       const bool is_delete)
+					       const u8 type)
 {
 	struct ccs_transition_control e = { .type = type };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	if (program && strcmp(program, "any")) {
 		if (!ccs_correct_path(program))
 			return -EINVAL;
@@ -243,9 +221,11 @@
 		if (!e.domainname)
 			goto out;
 	}
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_TRANSITION_CONTROL],
-				  ccs_same_transition_control);
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &param->ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+	param->check_duplicate = ccs_same_transition_control;
+	error = ccs_update_policy(param);
 out:
 	ccs_put_name(e.domainname);
 	ccs_put_name(e.program);
@@ -255,13 +235,13 @@
 /**
  * ccs_write_transition_control - Write "struct ccs_transition_control" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- * @type:      Type of this entry.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
+ * @type:  Type of this entry.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_transition_control(char *data, const bool is_delete,
+int ccs_write_transition_control(struct ccs_element_param *param, char *data,
 				 const u8 type)
 {
 	char *domainname = strstr(data, " from ");
@@ -273,8 +253,8 @@
 		domainname = data;
 		data = NULL;
 	}
-	return ccs_update_transition_control_entry(domainname, data, type,
-						   is_delete);
+	return ccs_update_transition_control_entry(param, domainname, data,
+						   type);
 }
 
 /**
@@ -295,6 +275,7 @@
 /**
  * ccs_transition_type - Get domain transition type.
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @domainname: The name of domain.
  * @program:    The name of program.
  *
@@ -304,17 +285,18 @@
  *
  * Caller holds ccs_read_lock().
  */
-static u8 ccs_transition_type(const struct ccs_path_info *domainname,
+static u8 ccs_transition_type(const struct ccs_policy_namespace *ns,
+			      const struct ccs_path_info *domainname,
 			      const struct ccs_path_info *program)
 {
 	const struct ccs_transition_control *ptr;
 	const char *last_name = ccs_last_word(domainname->name);
 	u8 type;
 	for (type = 0; type < CCS_MAX_TRANSITION_TYPE; type++) {
+		const struct list_head *list;
 next:
-		list_for_each_entry_srcu(ptr, &ccs_policy_list
-					 [CCS_ID_TRANSITION_CONTROL],
-					 head.list, &ccs_ss) {
+		list = &ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 			if (ptr->head.is_deleted || ptr->type != type)
 				continue;
 			if (ptr->domainname) {
@@ -333,6 +315,15 @@
 			}
 			if (ptr->program && ccs_pathcmp(ptr->program, program))
 				continue;
+			if (type ==
+			    CCS_TRANSITION_CONTROL_NO_INITIALIZE_NAMESPACE) {
+				/*
+				 * Do not check for initialize_namespace if
+				 * no_initialize_namespace matched.
+				 */
+				type = CCS_TRANSITION_CONTROL_NO_INITIALIZE;
+				goto next;
+			}
 			if (type == CCS_TRANSITION_CONTROL_NO_INITIALIZE) {
 				/*
 				 * Do not check for initialize_domain if
@@ -368,18 +359,18 @@
 /**
  * ccs_update_aggregator_entry - Update "struct ccs_aggregator" list.
  *
+ * @param:           Pointer to "struct ccs_element_param".
  * @original_name:   The original program's name.
  * @aggregated_name: The aggregated program's name.
- * @is_delete:       True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_aggregator_entry(const char *original_name,
-				       const char *aggregated_name,
-				       const bool is_delete)
+static int ccs_update_aggregator_entry(struct ccs_element_param *param,
+				       const char *original_name,
+				       const char *aggregated_name)
 {
 	struct ccs_aggregator e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_correct_word(original_name) ||
 	    !ccs_correct_path(aggregated_name))
 		return -EINVAL;
@@ -388,9 +379,11 @@
 	if (!e.original_name || !e.aggregated_name ||
 	    e.aggregated_name->is_patterned) /* No patterns allowed. */
 		goto out;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_AGGREGATOR],
-				  ccs_same_aggregator);
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &param->ns->policy_list[CCS_ID_AGGREGATOR];
+	param->check_duplicate = ccs_same_aggregator;
+	error = ccs_update_policy(param);
 out:
 	ccs_put_name(e.original_name);
 	ccs_put_name(e.aggregated_name);
@@ -400,24 +393,39 @@
 /**
  * ccs_write_aggregator - Write "struct ccs_aggregator" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_aggregator(char *data, const bool is_delete)
+int ccs_write_aggregator(struct ccs_element_param *param, char *data)
 {
 	char *w[2];
 	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
 		return -EINVAL;
-	return ccs_update_aggregator_entry(w[0], w[1], is_delete);
+	return ccs_update_aggregator_entry(param, w[0], w[1]);
 }
 
 /* Domain create handler. */
 
 /**
- * ccs_assign_domain - Create a domain.
+ * ccs_namespace_jump - Check for namespace jump.
  *
+ * @domainname: Name of domain.
+ *
+ * Returns true if namespace differs, false otherwise.
+ */
+static bool ccs_namespace_jump(const char *domainname)
+{
+	const char *namespace = ccs_current_namespace()->root.domainname->name;
+	const int len = strlen(namespace);
+	return strncmp(domainname, namespace, len) ||
+		(domainname[len] && domainname[len] != ' ');
+}
+
+/**
+ * ccs_assign_domain - Create a domain or a namespace.
+ *
  * @domainname: The name of domain.
  * @profile:    Profile number to assign if the domain was newly created.
  * @group:      Group number to assign if the domain was newly created.
@@ -432,13 +440,26 @@
 					  const bool transit)
 {
 	struct ccs_domain_info e = { };
-	struct ccs_domain_info *entry = ccs_find_domain(domainname);
+	struct ccs_domain_info *entry;
 	bool created = false;
-	if (entry)
-		goto out;
 	if (strlen(domainname) >= CCS_EXEC_TMPSIZE - 10 ||
 	    !ccs_correct_domain(domainname))
 		return NULL;
+	entry = ccs_find_domain(domainname);
+	if (entry)
+		goto out;
+	if (transit && ccs_namespace_jump(domainname))
+		/*
+		 * Namespace jump is requested but target domain was not found.
+		 * Don't create target domains upon namespace jump in order to
+		 * avoid inheriting "use_profile" and "use_group" information,
+		 * for definition of profiles and acl_groups may differ across
+		 * namespaces.
+		 */
+		return NULL;
+	e.ns = ccs_find_namespace(domainname);
+	if (!e.ns)
+		return NULL;
 	e.profile = profile;
 	e.group = group;
 	e.domainname = ccs_get_name(domainname);
@@ -519,10 +540,10 @@
 		}
 	} else {
 		struct ccs_aggregator *ptr;
+		struct list_head *list =
+			&r->ns->policy_list[CCS_ID_AGGREGATOR];
 		/* Check 'aggregator' directive. */
-		list_for_each_entry_srcu(ptr,
-					 &ccs_policy_list[CCS_ID_AGGREGATOR],
-					 head.list, &ccs_ss) {
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 			if (ptr->head.is_deleted ||
 			    !ccs_path_matches_pattern(&rn, ptr->original_name))
 				continue;
@@ -555,18 +576,23 @@
 	}
 
 	/* Calculate domain to transit to. */
-	switch (ccs_transition_type(old_domain->domainname, &rn)) {
+	switch (ccs_transition_type(r->ns, old_domain->domainname, &rn)) {
+	case CCS_TRANSITION_CONTROL_INITIALIZE_NAMESPACE:
+		/* Transit to the root of specified namespace. */
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "<%s>", rn.name);
+		break;
 	case CCS_TRANSITION_CONTROL_INITIALIZE:
-		/* Transit to the child of ccs_kernel_domain domain. */
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, CCS_ROOT_NAME " " "%s",
-			 rn.name);
+		/* Transit to the child of current namespace's root. */
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%s %s",
+			 r->ns->root.domainname->name, rn.name);
 		break;
 	case CCS_TRANSITION_CONTROL_KEEP:
 		/* Keep current domain. */
 		domain = old_domain;
 		break;
 	default:
-		if (old_domain == &ccs_kernel_domain && !ccs_policy_loaded) {
+		if (!ccs_policy_loaded &&
+		    old_domain == &ccs_default_namespace.root) {
 			/*
 			 * Needn't to transit from kernel domain before
 			 * starting /sbin/init. But transit from kernel domain
Index: memory.c
===================================================================
--- memory.c	(revision 4969)
+++ memory.c	(working copy)
@@ -109,15 +109,18 @@
 /**
  * ccs_get_group - Allocate memory for "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group".
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @group_name: The name of address group.
  * @idx:        Index number.
  *
  * Returns pointer to "struct ccs_group" on success, NULL otherwise.
  */
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx)
+struct ccs_group *ccs_get_group(struct ccs_policy_namespace *ns,
+				const char *group_name, const u8 idx)
 {
 	struct ccs_group e = { };
 	struct ccs_group *group = NULL;
+	struct list_head *list;
 	bool found = false;
 	if (!ccs_correct_word(group_name) || idx >= CCS_MAX_GROUP)
 		return NULL;
@@ -126,7 +129,8 @@
 		return NULL;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list_for_each_entry(group, &ccs_group_list[idx], head.list) {
+	list = &ns->group_list[idx];
+	list_for_each_entry(group, list, head.list) {
 		if (e.group_name != group->group_name)
 			continue;
 		atomic_inc(&group->head.users);
@@ -138,8 +142,7 @@
 		if (entry) {
 			INIT_LIST_HEAD(&entry->member_list);
 			atomic_set(&entry->head.users, 1);
-			list_add_tail_rcu(&entry->head.list,
-					  &ccs_group_list[idx]);
+			list_add_tail_rcu(&entry->head.list, list);
 			group = entry;
 			found = true;
 		}
@@ -247,12 +250,12 @@
 
 /* Dummy security context for avoiding NULL pointer dereference. */
 static struct ccs_security ccs_oom_security = {
-	.ccs_domain_info = &ccs_kernel_domain
+	.ccs_domain_info = &ccs_default_namespace.root
 };
 
 /* Dummy security context for avoiding NULL pointer dereference. */
 static struct ccs_security ccs_default_security = {
-	.ccs_domain_info = &ccs_kernel_domain
+	.ccs_domain_info = &ccs_default_namespace.root
 };
 
 /* List of "struct ccs_security". */
@@ -400,6 +403,30 @@
 
 #endif
 
+struct ccs_policy_namespace ccs_default_namespace;
+
+bool ccs_init_policy_namespace(struct ccs_policy_namespace *ns,
+			       const char *name)
+{
+	unsigned int idx;
+	ns->root.ns = ns;
+	INIT_LIST_HEAD(&ns->root.acl_info_list[0]);
+	INIT_LIST_HEAD(&ns->root.acl_info_list[1]);
+	for (idx = 0; idx < CCS_MAX_ACL_GROUPS; idx++) {
+		INIT_LIST_HEAD(&ns->acl_group[idx].acl_info_list[0]);
+		INIT_LIST_HEAD(&ns->acl_group[idx].acl_info_list[1]);
+	}
+	for (idx = 0; idx < CCS_MAX_GROUP; idx++)
+		INIT_LIST_HEAD(&ns->group_list[idx]);
+	for (idx = 0; idx < CCS_MAX_POLICY; idx++)
+		INIT_LIST_HEAD(&ns->policy_list[idx]);
+	ns->root.domainname = ccs_get_name(name);
+	if (!ns->root.domainname)
+		return false;
+	list_add_tail_rcu(&ns->root.list, &ccs_domain_list);
+	return true;
+};
+
 /**
  * ccs_mm_init - Initialize mm related code.
  *
@@ -408,14 +435,12 @@
 void __init ccs_mm_init(void)
 {
 	int idx;
+	for (idx = 0; idx < CCS_MAX_LIST; idx++)
+		INIT_LIST_HEAD(&ccs_shared_list[idx]);
 	for (idx = 0; idx < CCS_MAX_HASH; idx++)
 		INIT_LIST_HEAD(&ccs_name_list[idx]);
-	for (idx = 0; idx < CCS_MAX_ACL_GROUPS; idx++) {
-		INIT_LIST_HEAD(&ccs_acl_group[idx].acl_info_list[0]);
-		INIT_LIST_HEAD(&ccs_acl_group[idx].acl_info_list[1]);
-	}
-	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list[0]);
-	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list[1]);
+	ccs_init_policy_namespace(&ccs_default_namespace, "<kernel>");
+	list_add(&ccs_default_namespace.namespace_list, &ccs_namespace_list);
 #ifdef CONFIG_CCSECURITY_USE_EXTERNAL_TASK_SECURITY
 	for (idx = 0; idx < CCS_MAX_TASK_SECURITY_HASH; idx++)
 		INIT_LIST_HEAD(&ccs_task_security_list[idx]);
@@ -425,27 +450,25 @@
 	ccsecurity_ops.alloc_task_security = __ccs_alloc_task_security;
 	ccsecurity_ops.free_task_security = __ccs_free_task_security;
 #endif
-	ccs_kernel_domain.domainname = ccs_get_name(CCS_ROOT_NAME);
-	list_add_tail_rcu(&ccs_kernel_domain.list, &ccs_domain_list);
+#ifdef CONFIG_CCSECURITY_BUILTIN_INITIALIZERS
 	idx = ccs_read_lock();
-	if (ccs_find_domain(CCS_ROOT_NAME) != &ccs_kernel_domain)
-		panic("Can't register ccs_kernel_domain");
-#ifdef CONFIG_CCSECURITY_BUILTIN_INITIALIZERS
 	{
 		/* Load built-in policy. */
+		struct ccs_element_param param = { };
 		static char ccs_builtin_initializers[] __initdata
 			= CONFIG_CCSECURITY_BUILTIN_INITIALIZERS;
 		char *cp = ccs_builtin_initializers;
 		ccs_normalize_line(cp);
+		param.ns = &ccs_default_namespace;
 		while (cp && *cp) {
 			char *cp2 = strchr(cp, ' ');
 			if (cp2)
 				*cp2++ = '\0';
-			ccs_write_transition_control(cp, false,
+			ccs_write_transition_control(&param, cp,
 				     CCS_TRANSITION_CONTROL_INITIALIZE);
 			cp = cp2;
 		}
 	}
+	ccs_read_unlock(idx);
 #endif
-	ccs_read_unlock(idx);
 }
Index: signal.c
===================================================================
--- signal.c	(revision 4969)
+++ signal.c	(working copy)
@@ -89,7 +89,7 @@
 		else if (pid == 0)
 			p = current;
 		else if (pid == -1)
-			dest = &ccs_kernel_domain;
+			dest = &ccs_default_namespace.root;
 		else
 			p = find_task_by_pid((pid_t) -pid);
 		if (p)
Index: util.c
===================================================================
--- util.c	(revision 4969)
+++ util.c	(working copy)
@@ -247,17 +247,19 @@
 /**
  * ccs_parse_name_union - Parse a ccs_name_union.
  *
+ * @ns:       Pointer to "struct ccs_policy_namespace".
  * @filename: Name or name group.
  * @ptr:      Pointer to "struct ccs_name_union".
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr)
+bool ccs_parse_name_union(struct ccs_policy_namespace *ns,
+			  const char *filename, struct ccs_name_union *ptr)
 {
 	if (!ccs_correct_word(filename))
 		return false;
 	if (filename[0] == '@') {
-		ptr->group = ccs_get_group(filename + 1, CCS_PATH_GROUP);
+		ptr->group = ccs_get_group(ns, filename + 1, CCS_PATH_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
@@ -269,12 +271,14 @@
 /**
  * ccs_parse_number_union - Parse a ccs_number_union.
  *
+ * @ns:   Pointer to "struct ccs_policy_namespace".
  * @data: Number or number range or number group.
  * @ptr:  Pointer to "struct ccs_number_union".
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_parse_number_union(char *data, struct ccs_number_union *ptr)
+bool ccs_parse_number_union(struct ccs_policy_namespace *ns, char *data,
+			    struct ccs_number_union *ptr)
 {
 	u8 type;
 	unsigned long v;
@@ -284,7 +288,7 @@
 	if (data[0] == '@') {
 		if (!ccs_correct_word(data))
 			return false;
-		ptr->group = ccs_get_group(data + 1, CCS_NUMBER_GROUP);
+		ptr->group = ccs_get_group(ns, data + 1, CCS_NUMBER_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
@@ -562,26 +566,21 @@
  */
 bool ccs_correct_domain(const unsigned char *domainname)
 {
-	if (!domainname || strncmp(domainname, CCS_ROOT_NAME,
-				   CCS_ROOT_NAME_LEN))
-		goto out;
-	domainname += CCS_ROOT_NAME_LEN;
-	if (!*domainname)
+	if (!domainname || !ccs_domain_def(domainname))
+		return false;
+	domainname = strchr(domainname, ' ');
+	if (!domainname++)
 		return true;
-	if (*domainname++ != ' ')
-		goto out;
 	while (1) {
 		const unsigned char *cp = strchr(domainname, ' ');
 		if (!cp)
 			break;
 		if (*domainname != '/' ||
 		    !ccs_correct_word2(domainname, cp - domainname - 1))
-			goto out;
+			return false;
 		domainname = cp + 1;
 	}
 	return ccs_correct_path(domainname);
-out:
-	return false;
 }
 
 /**
@@ -593,7 +592,18 @@
  */
 bool ccs_domain_def(const unsigned char *buffer)
 {
-	return !strncmp(buffer, CCS_ROOT_NAME, CCS_ROOT_NAME_LEN);
+	const unsigned char *cp;
+	int len;
+	if (*buffer != '<')
+		return false;
+	cp = strchr(buffer, ' ');
+	if (!cp)
+		len = strlen(buffer);
+	else
+		len = cp - buffer;
+	if (buffer[len - 1] != '>' || !ccs_correct_word2(buffer + 1, len - 2))
+		return false;
+	return true;
 }
 
 /**
@@ -1028,6 +1038,7 @@
 		struct ccs_domain_info *domain = ccs_current_domain();
 		const u8 profile = domain->profile;
 		memset(r, 0, sizeof(*r));
+		r->ns = ccs_current_namespace();
 		r->profile = profile;
 		r->type = index;
 		r->mode = ccs_get_mode(profile, index);
Index: file.c
===================================================================
--- file.c	(revision 4969)
+++ file.c	(working copy)
@@ -393,7 +393,7 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name))
+	if (!ccs_parse_name_union(param->ns, ccs_read_token(param), &e.name))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -462,10 +462,11 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.mode) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.major) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.minor))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.name) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.mode) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.major) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.minor))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -535,8 +536,9 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name1) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.name2))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.name1) ||
+	    !ccs_parse_name_union(ns, ccs_read_token(param), &e.name2))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -579,10 +581,11 @@
 {
 	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL };
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.dev_name) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.dir_name) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.fs_type) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.flags))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.dev_name) ||
+	    !ccs_parse_name_union(ns, ccs_read_token(param), &e.dir_name) ||
+	    !ccs_parse_name_union(ns, ccs_read_token(param), &e.fs_type) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.flags))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -1001,8 +1004,9 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.number))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.name) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.number))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
Index: proc_if.c
===================================================================
--- proc_if.c	(revision 4969)
+++ proc_if.c	(working copy)
@@ -308,6 +308,7 @@
 		ccs_dir_inode_operations.setattr = proc_notify_change;
 	ccs_dir->proc_iops = &ccs_dir_inode_operations;
 #endif
+	ccs_create_entry("namespace",        0600, ccs_dir, CCS_NAMESPACE);
 	ccs_create_entry("query",            0600, ccs_dir, CCS_QUERY);
 	ccs_create_entry("domain_policy",    0600, ccs_dir, CCS_DOMAINPOLICY);
 	ccs_create_entry("exception_policy", 0600, ccs_dir,
@@ -337,13 +338,6 @@
  */
 static int __init ccs_init_module(void)
 {
-	int i;
-	for (i = 0; i < CCS_MAX_POLICY; i++)
-		INIT_LIST_HEAD(&ccs_policy_list[i]);
-	for (i = 0; i < CCS_MAX_GROUP; i++)
-		INIT_LIST_HEAD(&ccs_group_list[i]);
-	for (i = 0; i < CCS_MAX_LIST; i++)
-		INIT_LIST_HEAD(&ccs_shared_list[i]);
 	if (ccsecurity_ops.disabled)
 		return -EINVAL;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
@@ -353,7 +347,6 @@
 	if (init_srcu_struct(&ccs_ss))
 		panic("Out of memory.");
 #endif
-	ccs_proc_init();
 	ccs_mm_init();
 	ccs_capability_init();
 	ccs_file_init();
@@ -362,6 +355,7 @@
 	ccs_mount_init();
 	ccs_policy_io_init();
 	ccs_domain_init();
+	ccs_proc_init();
 #ifdef CONFIG_CCSECURITY_USE_BUILTIN_POLICY
 	ccs_load_builtin_policy();
 #endif
Index: internal.h
===================================================================
--- internal.h	(revision 4969)
+++ internal.h	(working copy)
@@ -672,6 +672,7 @@
 	CCS_PROFILE,
 	CCS_QUERY,
 	CCS_MANAGER,
+	CCS_NAMESPACE,
 	CCS_EXECUTE_HANDLER,
 };
 
@@ -697,6 +698,8 @@
 /* Index numbers for domain transition control keywords. */
 enum ccs_transition_type {
 	/* Do not change this order, */
+	CCS_TRANSITION_CONTROL_NO_INITIALIZE_NAMESPACE,
+	CCS_TRANSITION_CONTROL_INITIALIZE_NAMESPACE,
 	CCS_TRANSITION_CONTROL_NO_INITIALIZE,
 	CCS_TRANSITION_CONTROL_INITIALIZE,
 	CCS_TRANSITION_CONTROL_NO_KEEP,
@@ -728,10 +731,6 @@
  */
 #define CCS_SOCK_MAX 6
 
-/* A domain definition starts with <kernel>. */
-#define CCS_ROOT_NAME                         "<kernel>"
-#define CCS_ROOT_NAME_LEN                     (sizeof(CCS_ROOT_NAME) - 1)
-
 /* Size of temporary buffer for execve() operation. */
 #define CCS_EXEC_TMPSIZE     4096
 
@@ -934,6 +933,7 @@
 };
 
 struct ccs_execve;
+struct ccs_policy_namespace;
 
 /* Structure for request info. */
 struct ccs_request_info {
@@ -1027,6 +1027,7 @@
 			const struct ccs_path_info *domainname;
 		} task;
 	} param;
+	struct ccs_policy_namespace *ns;
 	u8 param_type; /* One of values in "enum ccs_acl_entry_type_index". */
 	bool granted; /* True if granted, false otherwise. */
 	/* True if current thread should not be carried sleep penalty. */
@@ -1095,6 +1096,8 @@
 	struct list_head acl_info_list[2];
 	/* Name of this domain. Never NULL.          */
 	const struct ccs_path_info *domainname;
+	/* Namespace for this domain. Never NULL. */
+	struct ccs_policy_namespace *ns;
 	u8 profile;        /* Profile number to use. */
 	u8 group;          /* Group number to use.   */
 	bool is_deleted;   /* Delete flag.           */
@@ -1102,7 +1105,8 @@
 };
 
 /*
- * Structure for "initialize_domain"/"no_initialize_domain" and
+ * Structure for "initialize_namespace"/"no_initialize_namespace" and
+ * "initialize_domain"/"no_initialize_domain" and
  * "keep_domain"/"no_keep_domain" keyword.
  */
 struct ccs_transition_control {
@@ -1312,9 +1316,27 @@
 struct ccs_acl_param {
 	char *data;
 	struct ccs_domain_info *domain;
+	struct ccs_policy_namespace *ns;
 	bool is_delete;
 };
 
+/* Structure for holding a line from /proc/ccs/ interface. */
+struct ccs_element_param {
+	/* Namespace to use. */
+	struct ccs_policy_namespace *ns;
+	/* Pointer to "struct ccs_acl_info". */
+	struct ccs_acl_head *new_entry;
+	/* Size of @new_entry in bytes. */
+	u8 size;
+	/* True if it is a delete request. */
+	bool is_delete;
+	/* Pointer to "struct list_head". */
+	struct list_head *list;
+	/* Callback function to find duplicated entry. */
+	bool (*check_duplicate) (const struct ccs_acl_head *,
+				 const struct ccs_acl_head *);
+};
+
 /* Structure for reading/writing policy via /proc/ccs/ interfaces. */
 struct ccs_io_buffer {
 	void (*read) (struct ccs_io_buffer *);
@@ -1325,6 +1347,7 @@
 	char __user *read_user_buf;
 	size_t read_user_buf_avail;
 	struct {
+		struct list_head *ns;
 		struct list_head *domain;
 		struct list_head *group;
 		struct list_head *acl;
@@ -1344,6 +1367,7 @@
 		const char *w[CCS_MAX_IO_READ_QUEUE];
 	} r;
 	struct {
+		struct ccs_policy_namespace *ns;
 		struct ccs_domain_info *domain;
 		size_t avail;
 	} w;
@@ -1381,6 +1405,31 @@
 	u8 sec;
 };
 
+/* Structure for policy namespace. */
+struct ccs_policy_namespace {
+	/* Profile table. Memory is allocated as needed. */
+	struct ccs_profile *profile_ptr[CCS_MAX_PROFILES];
+	/*
+	 * The root domain for this namespace.
+	 * This domain's name is like "<kernel>" and "</usr/sbin/httpd>".
+	 */
+	struct ccs_domain_info root;
+	/* List of "struct ccs_group". */
+	struct list_head group_list[CCS_MAX_GROUP];
+	/* List of policy. */
+	struct list_head policy_list[CCS_MAX_POLICY];
+	/*
+	 * The global domains referred by "use_group" keyword.
+	 *
+	 * Although "use_group" needs only "struct list_head acl_info_list[2]",
+	 * we define structure for "use_group" as "struct ccs_domain_info" in
+	 * order to use common code.
+	 */
+	struct ccs_domain_info acl_group[CCS_MAX_ACL_GROUPS];
+	/* List for connecting to ccs_namespace_list list. */
+	struct list_head namespace_list;
+};
+
 /* Prototype definition for "struct ccsecurity_operations". */
 
 void __init ccs_capability_init(void);
@@ -1407,11 +1456,15 @@
 bool ccs_domain_quota_ok(struct ccs_request_info *r);
 bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos,
 		   struct ccs_page_dump *dump);
+bool ccs_init_policy_namespace(struct ccs_policy_namespace *ns,
+			       const char *name);
 bool ccs_memory_ok(const void *ptr, const unsigned int size);
 bool ccs_number_matches_group(const unsigned long min, const unsigned long max,
 			      const struct ccs_group *group);
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr);
-bool ccs_parse_number_union(char *data, struct ccs_number_union *num);
+bool ccs_parse_name_union(struct ccs_policy_namespace *ns,
+			  const char *filename, struct ccs_name_union *ptr);
+bool ccs_parse_number_union(struct ccs_policy_namespace *ns, char *data,
+			    struct ccs_number_union *num);
 bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 			      const struct ccs_path_info *pattern);
 bool ccs_permstr(const char *string, const char *keyword);
@@ -1452,31 +1505,32 @@
 		      bool (*merge_duplicate) (struct ccs_acl_info *,
 					       struct ccs_acl_info *,
 					       const bool));
-int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      bool is_delete, struct list_head *list,
-		      bool (*check_duplicate) (const struct ccs_acl_head *,
-					       const struct ccs_acl_head *));
-int ccs_write_aggregator(char *data, const bool is_delete);
+int ccs_update_policy(struct ccs_element_param *param);
+int ccs_write_aggregator(struct ccs_element_param *param, char *data);
 int ccs_write_capability(struct ccs_acl_param *param);
 int ccs_write_file(struct ccs_acl_param *param);
-int ccs_write_group(char *data, const bool is_delete, const u8 type);
+int ccs_write_group(struct ccs_element_param *param, char *data,
+		    const u8 type);
 int ccs_write_inet_network(struct ccs_acl_param *param);
 int ccs_write_ipc(struct ccs_acl_param *param);
 int ccs_write_misc(struct ccs_acl_param *param);
-int ccs_write_reserved_port(char *data, const bool is_delete);
-int ccs_write_transition_control(char *data, const bool is_delete,
+int ccs_write_reserved_port(struct ccs_element_param *param, char *data);
+int ccs_write_transition_control(struct ccs_element_param *param, char *data,
 				 const u8 type);
 int ccs_write_unix_network(struct ccs_acl_param *param);
 ssize_t ccs_read_control(struct file *file, char __user *buffer,
 			 const size_t buffer_len);
 ssize_t ccs_write_control(struct file *file, const char __user *buffer,
 			  const size_t buffer_len);
-struct ccs_condition *ccs_get_condition(char *condition);
+struct ccs_condition *ccs_get_condition(struct ccs_policy_namespace *ns,
+					char *condition);
 struct ccs_domain_info *ccs_assign_domain(const char *domainname,
 					  const u8 profile, const u8 group,
 					  const bool transit);
 struct ccs_domain_info *ccs_find_domain(const char *domainname);
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx);
+struct ccs_group *ccs_get_group(struct ccs_policy_namespace *ns,
+				const char *group_name, const u8 idx);
+struct ccs_policy_namespace *ccs_find_namespace(const char *domainname);
 struct ccs_profile *ccs_profile(const u8 profile);
 u8 ccs_get_config(const u8 profile, const u8 index);
 u8 ccs_parse_ulong(unsigned long *result, char **str);
@@ -1528,12 +1582,10 @@
 extern const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION];
 extern const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION];
 extern const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION];
-extern struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
-extern struct ccs_domain_info ccs_kernel_domain;
+extern struct ccs_policy_namespace ccs_default_namespace;
 extern struct list_head ccs_domain_list;
-extern struct list_head ccs_group_list[CCS_MAX_GROUP];
 extern struct list_head ccs_name_list[CCS_MAX_HASH];
-extern struct list_head ccs_policy_list[CCS_MAX_POLICY];
+extern struct list_head ccs_namespace_list;
 extern struct list_head ccs_shared_list[CCS_MAX_LIST];
 extern struct mutex ccs_policy_lock;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
@@ -2036,7 +2088,7 @@
 static inline struct ccs_domain_info *ccs_task_domain(struct task_struct *task)
 {
 	struct ccs_domain_info *domain = task->ccs_domain_info;
-	return domain ? domain : &ccs_kernel_domain;
+	return domain ? domain : &ccs_default_namespace.root;
 }
 
 /**
@@ -2045,14 +2097,14 @@
  * Returns pointer to "struct ccs_domain_info" for current thread.
  *
  * If current thread does not belong to a domain (which is true for initial
- * init_task in order to hide ccs_kernel_domain from this module), current
- * thread enters into ccs_kernel_domain.
+ * init_task in order to hide ccs_default_namespace.root from this module),
+ * current thread enters into ccs_default_namespace.root.
  */
 static inline struct ccs_domain_info *ccs_current_domain(void)
 {
 	struct task_struct *task = current;
 	if (!task->ccs_domain_info)
-		task->ccs_domain_info = &ccs_kernel_domain;
+		task->ccs_domain_info = &ccs_default_namespace.root;
 	return task->ccs_domain_info;
 }
 
@@ -2080,4 +2132,9 @@
 
 #endif
 
+static inline struct ccs_policy_namespace *ccs_current_namespace(void)
+{
+	return ccs_current_domain()->ns;
+}
+
 #endif
Index: condition.c
===================================================================
--- condition.c	(revision 4969)
+++ condition.c	(working copy)
@@ -277,16 +277,18 @@
 /**
  * ccs_parse_name_union_quoted - Parse a quoted word.
  *
+ * @ns:       Pointer to "struct ccs_policy_namespace".
  * @filename: A line containing a quoted word.
  * @ptr:      Pointer to "struct ccs_name_union".
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_parse_name_union_quoted(char *filename,
+static bool ccs_parse_name_union_quoted(struct ccs_policy_namespace *ns,
+					char *filename,
 					struct ccs_name_union *ptr)
 {
 	if (*filename == '@')
-		return ccs_parse_name_union(filename, ptr);
+		return ccs_parse_name_union(ns, filename, ptr);
 	ptr->is_group = false;
 	ptr->filename = ccs_get_dqword(filename);
 	return ptr->filename != NULL;
@@ -482,11 +484,13 @@
 /**
  * ccs_get_condition - Parse condition part.
  *
+ * @ns:        Pointer to "struct ccs_policy_namespace".
  * @condition: Pointer to string to parse.
  *
  * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
  */
-struct ccs_condition *ccs_get_condition(char *condition)
+struct ccs_condition *ccs_get_condition(struct ccs_policy_namespace *ns,
+					char *condition)
 {
 	char *start;
 	struct ccs_condition *entry = NULL;
@@ -537,7 +541,8 @@
 					goto out;
 				entry->transit = ccs_get_dqword(word);
 				if (!entry->transit ||
-				    entry->transit->name[0] != '/')
+				    (entry->transit->name[0] != '/' &&
+				     !ccs_domain_def(entry->transit->name)))
 					goto out;
 			}
 			continue;
@@ -584,7 +589,8 @@
 			} else {
 				e.numbers_count--;
 				left = CCS_NUMBER_UNION;
-				if (!ccs_parse_number_union(word, numbers_p))
+				if (!ccs_parse_number_union(ns, word,
+							    numbers_p))
 					goto out;
 				if (numbers_p->is_group)
 					goto out;
@@ -605,7 +611,7 @@
 			} else {
 				e.names_count--;
 				right = CCS_NAME_UNION;
-				if (!ccs_parse_name_union_quoted(word,
+				if (!ccs_parse_name_union_quoted(ns, word,
 								 names_p++))
 					goto out;
 			}
@@ -618,7 +624,8 @@
 			} else {
 				e.numbers_count--;
 				right = CCS_NUMBER_UNION;
-				if (!ccs_parse_number_union(word, numbers_p++))
+				if (!ccs_parse_number_union(ns, word,
+							    numbers_p++))
 					goto out;
 			}
 		}
Index: policy_io.c
===================================================================
--- policy_io.c	(revision 4969)
+++ policy_io.c	(working copy)
@@ -8,6 +8,8 @@
 
 #include "internal.h"
 
+//#define PRINT_NS_ON_EACH_LINE
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 
 /**
@@ -83,9 +85,6 @@
 /* Profile version. Currently only 20100903 is defined. */
 static unsigned int ccs_profile_version;
 
-/* Profile table. Memory is allocated as needed. */
-static struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
-
 /* String table for operation mode. */
 const char * const ccs_mode[CCS_CONFIG_MAX_MODE] = {
 	[CCS_CONFIG_DISABLED]   = "disabled",
@@ -431,25 +430,46 @@
 }
 
 /**
+ * ccs_print_namespace - Print namespace header.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ */
+static void ccs_print_namespace(struct ccs_io_buffer *head)
+{
+#ifdef PRINT_NS_ON_EACH_LINE
+	ccs_set_string(head, "namespace ");
+	ccs_set_string(head,
+		       container_of(head->r.ns, struct ccs_policy_namespace,
+				    namespace_list)->root.domainname->
+		       name);
+	ccs_set_space(head);
+#endif
+}
+
+/**
  * ccs_assign_profile - Create a new profile.
  *
+ * @ns:      Pointer to "struct ccs_policy_namespace".
  * @profile: Profile number to create.
  *
  * Returns pointer to "struct ccs_profile" on success, NULL otherwise.
  */
-static struct ccs_profile *ccs_assign_profile(const unsigned int profile)
+static struct ccs_profile *ccs_assign_profile(struct ccs_policy_namespace *ns,
+					      const unsigned int profile)
 {
 	struct ccs_profile *ptr;
 	struct ccs_profile *entry;
 	if (profile >= CCS_MAX_PROFILES)
 		return NULL;
-	ptr = ccs_profile_ptr[profile];
+	ptr = ns->profile_ptr[profile];
 	if (ptr)
 		return ptr;
 	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	ptr = ccs_profile_ptr[profile];
+	ptr = ns->profile_ptr[profile];
 	if (!ptr && ccs_memory_ok(entry, sizeof(*entry))) {
 		ptr = entry;
 		ptr->default_config = CCS_CONFIG_DISABLED |
@@ -461,7 +481,7 @@
 		ptr->pref[CCS_PREF_MAX_LEARNING_ENTRY] =
 			CONFIG_CCSECURITY_MAX_ACCEPT_ENTRY;
 		mb(); /* Avoid out-of-order execution. */
-		ccs_profile_ptr[profile] = ptr;
+		ns->profile_ptr[profile] = ptr;
 		entry = NULL;
 	}
 	mutex_unlock(&ccs_policy_lock);
@@ -482,16 +502,15 @@
 	ccs_policy_loaded = true;
 	list_for_each_entry_srcu(domain, &ccs_domain_list, list, &ccs_ss) {
 		const u8 profile = domain->profile;
-		if (ccs_profile_ptr[profile])
+		if (domain->ns->profile_ptr[profile])
 			continue;
-		printk(KERN_ERR "Profile %u must be defined before using it.\n",
-		       profile);
+		printk(KERN_ERR "Profile %u must be defined before "
+		       "using it.\n", profile);
 		printk(KERN_ERR "Please see http://tomoyo.sourceforge.jp/1.8/ "
 		       "for more information.\n");
 		panic("Profile %u (used by '%s') not defined.\n",
 		      profile, domain->domainname->name);
 	}
-	ccs_read_unlock(idx);
 	if (ccs_profile_version != 20100903) {
 		printk(KERN_ERR "Userland tools must be installed for "
 		       "TOMOYO 1.8, and policy must be initialized.\n");
@@ -500,6 +519,7 @@
 		panic("Profile version %u is not supported.\n",
 		      ccs_profile_version);
 	}
+	ccs_read_unlock(idx);
 	printk(KERN_INFO "CCSecurity: 1.8.1+   2011/05/05\n");
 	printk(KERN_INFO "Mandatory Access Control activated.\n");
 }
@@ -514,7 +534,8 @@
 struct ccs_profile *ccs_profile(const u8 profile)
 {
 	static struct ccs_profile ccs_null_profile;
-	struct ccs_profile *ptr = ccs_profile_ptr[profile];
+	struct ccs_profile *ptr = ccs_current_namespace()->
+		profile_ptr[profile];
 	if (!ptr)
 		ptr = &ccs_null_profile;
 	return ptr;
@@ -654,7 +675,7 @@
 	if (*cp != '-')
 		return -EINVAL;
 	data = cp + 1;
-	profile = ccs_assign_profile(i);
+	profile = ccs_assign_profile(head->w.ns, i);
 	if (!profile)
 		return -EINVAL;
 	cp = strchr(data, '=');
@@ -711,31 +732,39 @@
 static void ccs_read_profile(struct ccs_io_buffer *head)
 {
 	u8 index;
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
 	const struct ccs_profile *profile;
+	if (head->r.eof)
+		return;
 next:
 	index = head->r.index;
-	profile = ccs_profile_ptr[index];
+	profile = ns->profile_ptr[index];
 	switch (head->r.step) {
 	case 0:
+		ccs_print_namespace(head);
 		ccs_io_printf(head, "PROFILE_VERSION=%u\n", 20100903);
 		head->r.step++;
 		break;
 	case 1:
-		for ( ; head->r.index < CCS_MAX_PROFILES;
-		      head->r.index++)
-			if (ccs_profile_ptr[head->r.index])
+		for ( ; head->r.index < CCS_MAX_PROFILES; head->r.index++)
+			if (ns->profile_ptr[head->r.index])
 				break;
-		if (head->r.index == CCS_MAX_PROFILES)
+		if (head->r.index == CCS_MAX_PROFILES) {
+			head->r.eof = true;
 			return;
+		}
 		head->r.step++;
 		break;
 	case 2:
 		{
 			u8 i;
 			const struct ccs_path_info *comment = profile->comment;
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-COMMENT=", index);
 			ccs_set_string(head, comment ? comment->name : "");
 			ccs_set_lf(head);
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-PREFERENCE={ ", index);
 			for (i = 0; i < CCS_MAX_PREF; i++)
 				ccs_io_printf(head, "%s=%u ",
@@ -747,6 +776,7 @@
 		break;
 	case 3:
 		{
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-%s", index, "CONFIG");
 			ccs_print_config(head, profile->default_config);
 			head->r.bit = 0;
@@ -760,6 +790,7 @@
 			const u8 config = profile->config[i];
 			if (config == CCS_CONFIG_USE_DEFAULT)
 				continue;
+			ccs_print_namespace(head);
 			if (i < CCS_MAX_MAC_INDEX)
 				ccs_io_printf(head, "%u-CONFIG::%s::%s", index,
 					      ccs_category_keywords
@@ -783,7 +814,102 @@
 		goto next;
 }
 
+LIST_HEAD(ccs_namespace_list);
+
 /**
+ * ccs_write_namespace - Write namespace list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_namespace(struct ccs_io_buffer *head)
+{
+	char *data = head->write_buf;
+	struct ccs_policy_namespace *new_entry;
+	struct ccs_policy_namespace *ns;
+	int error = -ENOMEM;
+	if (strchr(data, ' ') || !ccs_domain_def(data))
+		return -EINVAL;
+	new_entry = kzalloc(sizeof(*new_entry), CCS_GFP_FLAGS);
+	if (!new_entry)
+		return -ENOMEM;
+	if (!ccs_init_policy_namespace(new_entry, data) ||
+	    mutex_lock_interruptible(&ccs_policy_lock))
+		goto out;
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		if (strcmp(data, ns->root.domainname->name))
+			continue;
+		error = 0;
+		break;
+	}
+	if (error) {
+		list_add_tail_rcu(&new_entry->namespace_list,
+				  &ccs_namespace_list);
+		new_entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+out:
+	if (new_entry) {
+		ccs_put_name(new_entry->root.domainname);
+		kfree(new_entry);
+	}
+	return error;
+}
+
+/**
+ * ccs_read_namespace - Read namespace list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static void ccs_read_namespace(struct ccs_io_buffer *head)
+{
+	if (head->r.eof)
+		return;
+	list_for_each_cookie(head->r.acl, &ccs_namespace_list) {
+		struct ccs_policy_namespace *ptr =
+			list_entry(head->r.acl, typeof(*ptr), namespace_list);
+		if (!ccs_flush(head))
+			return;
+		ccs_set_string(head, ptr->root.domainname->name);
+		ccs_set_lf(head);
+	}
+	head->r.eof = true;
+}
+
+/**
+ * ccs_find_namespace - Find specified namespace.
+ *
+ * @domainname: Name of namespace to find.
+ *
+ * Returns pointer to "struct ccs_policy_namespace" if found, NULL otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+struct ccs_policy_namespace *ccs_find_namespace(const char *domainname)
+{
+	struct ccs_policy_namespace *ns;
+	const char *cp = domainname;
+	int len = 0;
+	while (*cp && *cp++ != ' ')
+		len++;
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		if (strncmp(domainname, ns->root.domainname->name, len) ||
+		    (domainname[len] && domainname[len] != ' '))
+			continue;
+		return ns;
+	}
+	return NULL;
+}
+
+/**
  * ccs_same_manager - Check for duplicated "struct ccs_manager" entry.
  *
  * @a: Pointer to "struct ccs_acl_head".
@@ -801,15 +927,16 @@
 /**
  * ccs_update_manager_entry - Add a manager entry.
  *
- * @manager:   The path to manager or the domainnamme.
- * @is_delete: True if it is a delete request.
+ * @param:   Pointer to "struct ccs_element_param".
+ * @manager: The path to manager or the domainnamme.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_manager_entry(const char *manager, const bool is_delete)
+static int ccs_update_manager_entry(struct ccs_element_param *param,
+				    const char *manager)
 {
 	struct ccs_manager e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	if (ccs_domain_def(manager)) {
 		if (!ccs_correct_domain(manager))
 			return -EINVAL;
@@ -821,9 +948,11 @@
 	e.manager = ccs_get_name(manager);
 	if (!e.manager)
 		return error;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_MANAGER],
-				  ccs_same_manager);
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &param->ns->policy_list[CCS_ID_MANAGER];
+	param->check_duplicate = ccs_same_manager;
+	error = ccs_update_policy(param);
 	ccs_put_name(e.manager);
 	return error;
 }
@@ -839,11 +968,15 @@
 {
 	char *data = head->write_buf;
 	bool is_delete = ccs_str_starts(&data, "delete ");
+	struct ccs_element_param param = {
+		.ns = head->w.ns,
+		.is_delete = is_delete,
+	};
 	if (!strcmp(data, "manage_by_non_root")) {
 		ccs_manage_by_non_root = !is_delete;
 		return 0;
 	}
-	return ccs_update_manager_entry(data, is_delete);
+	return ccs_update_manager_entry(&param, data);
 }
 
 /**
@@ -857,15 +990,20 @@
  */
 static void ccs_read_manager(struct ccs_io_buffer *head)
 {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
+	struct list_head *list;
 	if (head->r.eof)
 		return;
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[CCS_ID_MANAGER]) {
+	list = &ns->policy_list[CCS_ID_MANAGER];
+	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_manager *ptr =
 			list_entry(head->r.acl, typeof(*ptr), head.list);
 		if (ptr->head.is_deleted)
 			continue;
 		if (!ccs_flush(head))
 			return;
+		ccs_print_namespace(head);
 		ccs_set_string(head, ptr->manager->name);
 		ccs_set_lf(head);
 	}
@@ -888,6 +1026,7 @@
 	const struct ccs_path_info *domainname
 		= ccs_current_domain()->domainname;
 	bool found = false;
+	struct list_head *list;
 	if (!ccs_policy_loaded)
 		return true;
 	if (task->ccs_flags & CCS_TASK_IS_MANAGER)
@@ -895,8 +1034,8 @@
 	if (!ccs_manage_by_non_root && (current_uid() || current_euid()))
 		return false;
 	exe = ccs_get_exe();
-	list_for_each_entry_srcu(ptr, &ccs_policy_list[CCS_ID_MANAGER],
-				 head.list, &ccs_ss) {
+	list = &ccs_current_namespace()->policy_list[CCS_ID_MANAGER];
+	list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 		if (ptr->head.is_deleted)
 			continue;
 		if (ptr->is_domain) {
@@ -925,7 +1064,7 @@
 }
 
 /**
- * ccs_select_one - Parse select command.
+ * ccs_select_domain - Parse select command.
  *
  * @head: Pointer to "struct ccs_io_buffer".
  * @data: String to parse.
@@ -934,15 +1073,14 @@
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_select_one(struct ccs_io_buffer *head, const char *data)
+static bool ccs_select_domain(struct ccs_io_buffer *head, const char *data)
 {
 	unsigned int pid;
 	struct ccs_domain_info *domain = NULL;
 	bool global_pid = false;
-	if (!strcmp(data, "transition_only")) {
-		head->r.print_transition_related_only = true;
-		return true;
-	}
+	if (strncmp(data, "select ", 7))
+		return false;
+	data += 7;
 	if (sscanf(data, "pid=%u", &pid) == 1 ||
 	    (global_pid = true, sscanf(data, "global-pid=%u", &pid) == 1)) {
 		struct task_struct *p;
@@ -1068,20 +1206,23 @@
 /**
  * ccs_write_domain2 - Write domain policy.
  *
+ * @ns:        Pointer to "struct ccs_policy_namespace".
+ * @domain:    Pointer to "struct ccs_domain_info".
  * @data:      Policy to be interpreted.
- * @domain:    Pointer to "struct ccs_domain_info".
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_write_domain2(char *data, struct ccs_domain_info *domain,
+static int ccs_write_domain2(struct ccs_policy_namespace *ns,
+			     struct ccs_domain_info *domain, char *data,
 			     const bool is_delete)
 {
 	struct ccs_acl_param param = {
+		.ns = ns,
+		.domain = domain,
 		.data = data,
-		.domain = domain,
 		.is_delete = is_delete,
 	};
 	static const struct {
@@ -1108,11 +1249,12 @@
 /**
  * ccs_delete_domain - Delete a domain.
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @domainname: The name of domain.
  *
  * Returns 0.
  */
-static int ccs_delete_domain(char *domainname)
+static int ccs_delete_domain(struct ccs_policy_namespace *ns, char *domainname)
 {
 	struct ccs_domain_info *domain;
 	struct ccs_path_info name;
@@ -1122,8 +1264,8 @@
 		return 0;
 	/* Is there an active domain? */
 	list_for_each_entry_srcu(domain, &ccs_domain_list, list, &ccs_ss) {
-		/* Never delete ccs_kernel_domain. */
-		if (domain == &ccs_kernel_domain)
+		/* Never delete root of a namespace. */
+		if (domain == &domain->ns->root)
 			continue;
 		if (domain->is_deleted ||
 		    ccs_pathcmp(domain->domainname, &name))
@@ -1153,6 +1295,7 @@
 static int ccs_write_domain(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
+	struct ccs_policy_namespace *ns = head->w.ns;
 	struct ccs_domain_info *domain = head->w.domain;
 	bool is_delete = false;
 	bool is_select = false;
@@ -1161,15 +1304,10 @@
 		is_delete = true;
 	else if (ccs_str_starts(&data, "select "))
 		is_select = true;
-	if (is_select && ccs_select_one(head, data))
-		return -EAGAIN;
-	/* Don't allow updating policies by non manager programs. */
-	if (!ccs_manager())
-		return -EPERM;
 	if (ccs_domain_def(data)) {
 		domain = NULL;
 		if (is_delete)
-			ccs_delete_domain(data);
+			ccs_delete_domain(ns, data);
 		else if (is_select)
 			domain = ccs_find_domain(data);
 		else
@@ -1179,10 +1317,9 @@
 	}
 	if (!domain)
 		return -EINVAL;
-
 	if (sscanf(data, "use_profile %u\n", &profile) == 1
 	    && profile < CCS_MAX_PROFILES) {
-		if (!ccs_policy_loaded || ccs_profile_ptr[(u8) profile])
+		if (!ccs_policy_loaded || ns->profile_ptr[(u8) profile])
 			if (!is_delete)
 				domain->profile = (u8) profile;
 		return 0;
@@ -1200,7 +1337,7 @@
 		domain->flags[profile] = !is_delete;
 		return 0;
 	}
-	return ccs_write_domain2(data, domain, is_delete);
+	return ccs_write_domain2(ns, domain, data, is_delete);
 }
 
 /**
@@ -1426,8 +1563,10 @@
  */
 static void ccs_set_group(struct ccs_io_buffer *head, const char *category)
 {
-	if (head->type == CCS_EXCEPTIONPOLICY)
+	if (head->type == CCS_EXCEPTIONPOLICY) {
+		ccs_print_namespace(head);
 		ccs_io_printf(head, "acl_group %u ", head->r.acl_group_index);
+	}
 	ccs_set_string(head, category);
 }
 
@@ -1766,7 +1905,8 @@
 	if (profile >= CCS_MAX_PROFILES)
 		return -EINVAL;
 	domain = ccs_find_domain(cp + 1);
-	if (domain && (!ccs_policy_loaded || ccs_profile_ptr[(u8) profile]))
+	if (domain && (!ccs_policy_loaded ||
+		       head->w.ns->profile_ptr[(u8) profile]))
 		domain->profile = (u8) profile;
 	return 0;
 }
@@ -1881,10 +2021,15 @@
 
 /* String table for domain transition control keywords. */
 static const char * const ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
-	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
-	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
-	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
-	[CCS_TRANSITION_CONTROL_KEEP]          = "keep_domain ",
+	[CCS_TRANSITION_CONTROL_INITIALIZE_NAMESPACE]
+	= "initialize_namespace ",
+	[CCS_TRANSITION_CONTROL_NO_INITIALIZE_NAMESPACE]
+	= "no_initialize_namespace ",
+	[CCS_TRANSITION_CONTROL_INITIALIZE]        = "initialize_domain ",
+	[CCS_TRANSITION_CONTROL_NO_INITIALIZE]     = "no_initialize_domain ",
+	[CCS_TRANSITION_CONTROL_INITIALIZE]        = "initialize_domain ",
+	[CCS_TRANSITION_CONTROL_NO_KEEP]           = "no_keep_domain ",
+	[CCS_TRANSITION_CONTROL_KEEP]              = "keep_domain ",
 };
 
 /* String table for grouping keywords. */
@@ -1905,41 +2050,37 @@
 {
 	char *data = head->write_buf;
 	const bool is_delete = ccs_str_starts(&data, "delete ");
+	struct ccs_element_param param = {
+		.ns = head->w.ns,
+		.is_delete = is_delete,
+	};
 	u8 i;
 	static const struct {
 		const char *keyword;
-		int (*write) (char *, const bool);
+		int (*write) (struct ccs_element_param *, char *);
 	} ccs_callback[2] = {
 		{ "aggregator ",    ccs_write_aggregator },
 		{ "deny_autobind ", ccs_write_reserved_port },
 	};
-	if (!is_delete && ccs_str_starts(&data, "select ") &&
-	    !strcmp(data, "transition_only")) {
-		head->r.print_transition_related_only = true;
-		return -EAGAIN;
-	}
-	/* Don't allow updating policies by non manager programs. */
-	if (!ccs_manager())
-		return -EPERM;
 	for (i = 0; i < 2; i++)
 		if (ccs_str_starts(&data, ccs_callback[i].keyword))
-			return ccs_callback[i].write(data, is_delete);
+			return ccs_callback[i].write(&param, data);
 	for (i = 0; i < CCS_MAX_TRANSITION_TYPE; i++)
 		if (ccs_str_starts(&data, ccs_transition_type[i]))
-			return ccs_write_transition_control(data, is_delete,
-							    i);
+			return ccs_write_transition_control(&param, data, i);
 	for (i = 0; i < CCS_MAX_GROUP; i++)
 		if (ccs_str_starts(&data, ccs_group_name[i]))
-			return ccs_write_group(data, is_delete, i);
+			return ccs_write_group(&param, data, i);
 	if (ccs_str_starts(&data, "acl_group ")) {
 		unsigned int group;
 		if (sscanf(data, "%u", &group) == 1 &&
 		    group < CCS_MAX_ACL_GROUPS) {
 			data = strchr(data, ' ');
-			if (data)
-				return ccs_write_domain2(data + 1,
-							 &ccs_acl_group[group],
-							 is_delete);
+			if (data++)
+				return ccs_write_domain2(head->w.ns,
+							 &head->w.ns->
+							 acl_group[group],
+							 data, is_delete);
 		}
 	}
 	return -EINVAL;
@@ -1957,7 +2098,10 @@
  */
 static bool ccs_read_group(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.group, &ccs_group_list[idx]) {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
+	struct list_head *list = &ns->group_list[idx];
+	list_for_each_cookie(head->r.group, list) {
 		struct ccs_group *group =
 			list_entry(head->r.group, typeof(*group), head.list);
 		list_for_each_cookie(head->r.acl, &group->member_list) {
@@ -1967,6 +2111,7 @@
 				continue;
 			if (!ccs_flush(head))
 				return false;
+			ccs_print_namespace(head);
 			ccs_set_string(head, ccs_group_name[idx]);
 			ccs_set_string(head, group->group_name->name);
 			if (idx == CCS_PATH_GROUP) {
@@ -2013,7 +2158,10 @@
  */
 static bool ccs_read_policy(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[idx]) {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
+	struct list_head *list = &ns->policy_list[idx];
+	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_acl_head *acl =
 			container_of(head->r.acl, typeof(*acl), list);
 		if (acl->is_deleted)
@@ -2023,6 +2171,7 @@
 			continue;
 		if (!ccs_flush(head))
 			return false;
+		ccs_print_namespace(head);
 		switch (idx) {
 		case CCS_ID_TRANSITION_CONTROL:
 			{
@@ -2080,6 +2229,8 @@
  */
 static void ccs_read_exception(struct ccs_io_buffer *head)
 {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
 	if (head->r.eof)
 		return;
 	while (head->r.step < CCS_MAX_POLICY &&
@@ -2096,8 +2247,8 @@
 	       + CCS_MAX_ACL_GROUPS * 2) {
 		head->r.acl_group_index = (head->r.step - CCS_MAX_POLICY
 					   - CCS_MAX_GROUP) / 2;
-		if (!ccs_read_domain2(head,
-				      &ccs_acl_group[head->r.acl_group_index],
+		if (!ccs_read_domain2(head, &ns->
+				      acl_group[head->r.acl_group_index],
 				      head->r.step & 1))
 			return;
 		head->r.step++;
@@ -2201,7 +2352,8 @@
 	if (symlink)
 		ccs_addprintf(buffer, len, "%s", symlink);
 	ccs_normalize_line(buffer);
-	if (!ccs_write_domain2(buffer, ccs_current_domain(), false))
+	if (!ccs_write_domain2(ccs_current_namespace(), ccs_current_domain(),
+			       buffer, false))
 		ccs_update_stat(CCS_STAT_POLICY_UPDATES);
 	kfree(buffer);
 }
@@ -2577,6 +2729,7 @@
 	struct ccs_io_buffer *head = kzalloc(sizeof(*head), CCS_GFP_FLAGS);
 	if (!head)
 		return -ENOMEM;
+	head->w.ns = ccs_current_namespace();
 	mutex_init(&head->io_sem);
 	head->type = type;
 	switch (type) {
@@ -2629,6 +2782,10 @@
 		head->write = ccs_write_manager;
 		head->read = ccs_read_manager;
 		break;
+	case CCS_NAMESPACE: /* /proc/ccs/namespace */
+		head->write = ccs_write_namespace;
+		head->read = ccs_read_namespace;
+		break;
 	}
 	if (!(file->f_mode & FMODE_READ)) {
 		/*
@@ -2695,6 +2852,62 @@
 }
 
 /**
+ * ccs_move_namespace_cursor - Print namespace delimiter if needed.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ */
+static void ccs_move_namespace_cursor(struct ccs_io_buffer *head)
+{
+	struct list_head *ns;
+	switch (head->type) {
+	case CCS_EXCEPTIONPOLICY:
+	case CCS_PROFILE:
+	case CCS_MANAGER:
+		break;
+	default:
+		return;
+	}
+	/*
+	 * If this is the first read, or reading previous namespace finished
+	 * and has more namespaces to read, update the namespace cursor.
+	 */
+	ns = head->r.ns;
+	if (!ns || (head->r.eof && ns->next != &ccs_namespace_list)) {
+		memset(&head->r, 0, sizeof(head->r));
+		head->r.ns = ns ? ns->next : ccs_namespace_list.next;
+#ifndef PRINT_NS_ON_EACH_LINE
+		ccs_set_string(head, "namespace ");
+		ccs_set_string(head, container_of(head->r.ns,
+						  struct ccs_policy_namespace,
+						  namespace_list)->
+			       root.domainname->name);
+		ccs_set_lf(head);
+#endif
+	}
+}
+
+/**
+ * ccs_has_more_namespace - Check for unread namespaces.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true if we have more entries to print, false otehrwise.
+ */
+static bool ccs_has_more_namespace(struct ccs_io_buffer *head)
+{
+	switch (head->type) {
+	case CCS_EXCEPTIONPOLICY:
+	case CCS_PROFILE:
+	case CCS_MANAGER:
+		return head->r.eof && head->r.ns->next != &ccs_namespace_list;
+	default:
+		return false;
+	}
+}
+
+/**
  * ccs_read_control - read() for /proc/ccs/ interface.
  *
  * @file:       Pointer to "struct file".
@@ -2718,10 +2931,13 @@
 	head->read_user_buf = buffer;
 	head->read_user_buf_avail = buffer_len;
 	idx = ccs_read_lock();
-	if (ccs_flush(head))
-		/* Call the policy handler. */
-		head->read(head);
-	ccs_flush(head);
+	if (ccs_flush(head)) {
+		do {
+			ccs_move_namespace_cursor(head);
+			/* Call the policy handler. */
+			head->read(head);
+		} while (ccs_flush(head) && ccs_has_more_namespace(head));
+	}
 	ccs_read_unlock(idx);
 	len = head->read_user_buf - buffer;
 	mutex_unlock(&head->io_sem);
@@ -2752,13 +2968,6 @@
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
 	idx = ccs_read_lock();
-	/* Don't allow updating policies by non manager programs. */
-	if (head->write != ccs_write_pid && head->write != ccs_write_domain &&
-	    head->write != ccs_write_exception && !ccs_manager()) {
-		ccs_read_unlock(idx);
-		mutex_unlock(&head->io_sem);
-		return -EPERM;
-	}
 	/* Read a line and dispatch it to the policy handler. */
 	while (avail_len > 0) {
 		char c;
@@ -2787,15 +2996,93 @@
 		cp0[head->w.avail - 1] = '\0';
 		head->w.avail = 0;
 		ccs_normalize_line(cp0);
+		if (!strcmp(cp0, "reset")) {
+			head->w.ns = ccs_current_namespace();
+			head->w.domain = NULL;
+			memset(&head->r, 0, sizeof(head->r));
+			continue;
+		}
+#ifndef PRINT_NS_ON_EACH_LINE
+		switch (head->type) {
+		case CCS_EXCEPTIONPOLICY:
+		case CCS_PROFILE:
+		case CCS_MANAGER:
+			/* Selecting namespace to update. */
+			if (!strncmp(cp0, "namespace ", 10)) {
+				head->w.ns = ccs_find_namespace(cp0 + 10);
+				if (head->w.ns)
+					continue;
+			}
+			/* Don't allow updating if namespace is invalid. */
+			if (!head->w.ns) {
+				error = -ENOENT;
+				goto out;
+			}
+			break;
+		default:
+			break;
+		}
+#endif
+		/* Don't allow updating policies by non manager programs. */
+		switch (head->type) {
+		case CCS_PROCESS_STATUS:
+			/* This does not write anything. */
+			break;
+		case CCS_DOMAINPOLICY:
+			if (ccs_select_domain(head, cp0))
+				continue;
+			/* fall through */
+		case CCS_EXCEPTIONPOLICY:
+			if (!strcmp(cp0, "select transition_only")) {
+				head->r.print_transition_related_only = true;
+				continue;
+			}
+			/* fall through */
+		default:
+			if (!ccs_manager()) {
+				error = -EPERM;
+				goto out;
+			}
+		}
+#ifdef PRINT_NS_ON_EACH_LINE
+		switch (head->type) {
+		case CCS_EXCEPTIONPOLICY:
+		case CCS_PROFILE:
+		case CCS_MANAGER:
+			/* Selecting namespace to update. */
+			if (!strncmp(cp0, "namespace ", 10)) {
+				char *cp = strchr(cp0 + 10, ' ');
+				if (cp) {
+					*cp++ = '\0';
+					head->w.ns =
+						ccs_find_namespace(cp0 + 10);
+					memmove(cp0, cp, strlen(cp) + 1);
+				} else
+					head->w.ns = NULL;
+			} else
+				head->w.ns = ccs_current_namespace();
+			/* Don't allow updating if namespace is invalid. */
+			if (!head->w.ns) {
+				error = -ENOENT;
+				goto out;
+			}
+			break;
+		default:
+			break;
+		}
+#endif
 		{
+			/* Do the update. */
 			const int ret = head->write(head);
 			if (ret == -EPERM) {
 				error = -EPERM;
 				break;
 			}
+			/* Do not update statistics if not updated. */
 			if (ret)
 				continue;
 		}
+		/* Update statistics. */
 		switch (head->type) {
 		case CCS_DOMAINPOLICY:
 		case CCS_EXCEPTIONPOLICY:
@@ -2803,12 +3090,14 @@
 		case CCS_STAT:
 		case CCS_PROFILE:
 		case CCS_MANAGER:
+		case CCS_NAMESPACE:
 			ccs_update_stat(CCS_STAT_POLICY_UPDATES);
 			break;
 		default:
 			break;
 		}
 	}
+out:
 	ccs_read_unlock(idx);
 	mutex_unlock(&head->io_sem);
 	return error;
Index: gc.c
===================================================================
--- gc.c	(revision 4969)
+++ gc.c	(working copy)
@@ -773,16 +773,11 @@
 {
 	int i;
 	enum ccs_policy_id id;
+	struct ccs_policy_namespace *ns;
 	int idx;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return;
 	idx = ccs_read_lock();
-	for (id = 0; id < CCS_MAX_POLICY; id++)
-		if (!ccs_collect_member(id, &ccs_policy_list[id]))
-			goto unlock;
-	for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
-		if (!ccs_collect_acl(&ccs_acl_group[i]))
-			goto unlock;
 	{
 		struct ccs_domain_info *domain;
 		list_for_each_entry(domain, &ccs_domain_list, list) {
@@ -795,28 +790,39 @@
 				goto unlock;
 		}
 	}
-	for (i = 0; i < CCS_MAX_GROUP; i++) {
-		struct list_head *list = &ccs_group_list[i];
-		struct ccs_group *group;
-		switch (i) {
-		case 0:
-			id = CCS_ID_PATH_GROUP;
-			break;
-		case 1:
-			id = CCS_ID_NUMBER_GROUP;
-			break;
-		default:
-			id = CCS_ID_ADDRESS_GROUP;
-			break;
-		}
-		list_for_each_entry(group, list, head.list) {
-			if (!ccs_collect_member(id, &group->member_list))
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		for (id = 0; id < CCS_MAX_POLICY; id++)
+			if (!ccs_collect_member(id, &ns->policy_list[id]))
 				goto unlock;
-			if (!list_empty(&group->member_list) ||
-			    atomic_read(&group->head.users))
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_GROUP, &group->head.list))
+		for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
+			if (!ccs_collect_acl(&ns->acl_group[i]))
 				goto unlock;
+		for (i = 0; i < CCS_MAX_GROUP; i++) {
+			struct list_head *list = &ns->group_list[i];
+			struct ccs_group *group;
+			switch (i) {
+			case 0:
+				id = CCS_ID_PATH_GROUP;
+				break;
+			case 1:
+				id = CCS_ID_NUMBER_GROUP;
+				break;
+			default:
+				id = CCS_ID_ADDRESS_GROUP;
+				break;
+			}
+			list_for_each_entry(group, list, head.list) {
+				if (!ccs_collect_member(id,
+							&group->member_list))
+					goto unlock;
+				if (!list_empty(&group->member_list) ||
+				    atomic_read(&group->head.users))
+					continue;
+				if (!ccs_add_to_gc(CCS_ID_GROUP,
+						   &group->head.list))
+					goto unlock;
+			}
 		}
 	}
 	for (i = 0; i < CCS_MAX_LIST + CCS_MAX_HASH; i++) {
Index: network.c
===================================================================
--- network.c	(revision 4969)
+++ network.c	(working copy)
@@ -343,13 +343,13 @@
 		if (address[0] != '@')
 			return -EINVAL;
 		e.address_type = CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
-		e.address.group = ccs_get_group(address + 1,
+		e.address.group = ccs_get_group(param->ns, address + 1,
 						CCS_ADDRESS_GROUP);
 		if (!e.address.group)
 			return -ENOMEM;
 		break;
 	}
-	if (!ccs_parse_number_union(ccs_read_token(param), &e.port))
+	if (!ccs_parse_number_union(param->ns, ccs_read_token(param), &e.port))
 		goto out;
 	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_inet_acl,
 				  ccs_merge_inet_acl);
@@ -386,7 +386,7 @@
 			e.perm |= 1 << type;
 	if (e.protocol == CCS_SOCK_MAX || !e.perm)
 		return -EINVAL;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name))
+	if (!ccs_parse_name_union(param->ns, ccs_read_token(param), &e.name))
 		return -EINVAL;
 	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_unix_acl,
 				  ccs_merge_unix_acl);
Index: group.c
===================================================================
--- group.c	(revision 4969)
+++ group.c	(working copy)
@@ -63,13 +63,13 @@
 /**
  * ccs_write_group - Write "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- * @type:      Type of this group.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
+ * @type:  Type of this group.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_group(char *data, const bool is_delete, const u8 type)
+int ccs_write_group(struct ccs_element_param *param, char *data, const u8 type)
 {
 	struct ccs_group *group;
 	struct list_head *member;
@@ -77,10 +77,11 @@
 	int error = -EINVAL;
 	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
 		return -EINVAL;
-	group = ccs_get_group(w[0], type);
+	group = ccs_get_group(param->ns, w[0], type);
 	if (!group)
 		return -ENOMEM;
 	member = &group->member_list;
+	param->list = member;
 	if (type == CCS_PATH_GROUP) {
 		struct ccs_path_group e = { };
 		e.member_name = ccs_get_name(w[1]);
@@ -88,16 +89,21 @@
 			error = -ENOMEM;
 			goto out;
 		}
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_path_group);
+		param->new_entry = &e.head;
+		param->size = sizeof(e);
+		param->check_duplicate = ccs_same_path_group;
+		error = ccs_update_policy(param);
 		ccs_put_name(e.member_name);
 	} else if (type == CCS_NUMBER_GROUP) {
 		struct ccs_number_group e = { };
-		if (w[1][0] == '@' || !ccs_parse_number_union(w[1], &e.number)
+		if (w[1][0] == '@' || !ccs_parse_number_union(param->ns, w[1],
+							      &e.number)
 		    || e.number.values[0] > e.number.values[1])
 			goto out;
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_number_group);
+		param->new_entry = &e.head;
+		param->size = sizeof(e);
+		param->check_duplicate = ccs_same_number_group;
+		error = ccs_update_policy(param);
 		/*
 		 * ccs_put_number_union() is not needed because w[1][0] != '@'.
 		 */
@@ -122,8 +128,10 @@
 		default:
 			goto out_address;
 		}
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_address_group);
+		param->new_entry = &e.head;
+		param->size = sizeof(e);
+		param->check_duplicate = ccs_same_address_group;
+		error = ccs_update_policy(param);
 out_address:
 		if (e.is_ipv6) {
 			ccs_put_ipv6_address(e.min.ipv6);
