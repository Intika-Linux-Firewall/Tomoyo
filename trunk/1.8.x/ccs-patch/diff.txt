Index: security/ccsecurity/autobind.c
===================================================================
--- security/ccsecurity/autobind.c	(revision 5044)
+++ security/ccsecurity/autobind.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1   2011/04/01
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -37,45 +37,50 @@
 {
 	const struct ccs_reserved *p1 = container_of(a, typeof(*p1), head);
 	const struct ccs_reserved *p2 = container_of(b, typeof(*p2), head);
-	return p1->min_port == p2->min_port && p1->max_port == p2->max_port;
+	return ccs_same_number_union(&p1->port, &p2->port);
 }
 
 /**
- * ccs_update_reserved_entry - Update "struct ccs_reserved" list.
+ * ccs_write_reserved_port - Update "struct ccs_reserved" list.
  *
- * @min_port:  Start of port number range.
- * @max_port:  End of port number range.
- * @is_delete: True if it is a delete request.
+ * @param: Pointer to "struct ccs_acl_param".
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_update_reserved_entry(const u16 min_port, const u16 max_port,
-				     const bool is_delete)
+int ccs_write_reserved_port(struct ccs_acl_param *param)
 {
-	struct ccs_reserved *ptr;
-	struct ccs_reserved e = {
-		.min_port = min_port,
-		.max_port = max_port
-	};
-	const int error =
-		ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_RESERVEDPORT],
-				  ccs_same_reserved);
+	struct ccs_reserved e = { };
+	struct ccs_policy_namespace *ns = param->ns;
+	int error;
 	u8 *tmp;
+	if (param->data[0] == '@' || !ccs_parse_number_union(param, &e.port) ||
+	    e.port.values[1] > 65535 || param->data[0])
+		return -EINVAL;
+	param->list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+	error = ccs_update_policy(&e.head, sizeof(e), param,
+				  ccs_same_reserved);
+	/*
+	 * ccs_put_number_union() is not needed because param->data[0] != '@'.
+	 */
 	if (error)
 		return error;
 	tmp = kzalloc(sizeof(ccs_reserved_port_map), CCS_GFP_FLAGS);
 	if (!tmp)
 		return -ENOMEM;
-	list_for_each_entry_srcu(ptr, &ccs_policy_list[CCS_ID_RESERVEDPORT],
-				 head.list, &ccs_ss) {
-		unsigned int port;
-		if (ptr->head.is_deleted)
-			continue;
-		for (port = ptr->min_port; port <= ptr->max_port; port++)
-			tmp[port >> 3] |= 1 << (port & 7);
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		struct ccs_reserved *ptr;
+		struct list_head *list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
+			unsigned int port;
+			if (ptr->head.is_deleted)
+				continue;
+			for (port = ptr->port.values[0];
+			     port <= ptr->port.values[1]; port++)
+				tmp[port >> 3] |= 1 << (port & 7);
+		}
 	}
 	memmove(ccs_reserved_port_map, tmp, sizeof(ccs_reserved_port_map));
 	kfree(tmp);
@@ -86,33 +91,3 @@
 	ccsecurity_ops.lport_reserved = __ccs_lport_reserved;
 	return 0;
 }
-
-/**
- * ccs_write_reserved_port - Write "struct ccs_reserved" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-int ccs_write_reserved_port(char *data, const bool is_delete)
-{
-	unsigned int from;
-	unsigned int to;
-	if (strchr(data, ' '))
-		goto out;
-	switch (sscanf(data, "%u-%u", &from, &to)) {
-	case 1:
-		to = from;
-		/* fall through */
-	case 2:
-		if (from <= to && to < 65536)
-			return ccs_update_reserved_entry(from, to,
-							 is_delete);
-		break;
-	}
-out:
-	return -EINVAL;
-}
Index: security/ccsecurity/audit.c
===================================================================
--- security/ccsecurity/audit.c	(revision 5044)
+++ security/ccsecurity/audit.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1   2011/04/01
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -334,8 +334,8 @@
  */
 static void ccs_update_task_domain(struct ccs_request_info *r)
 {
-	const struct ccs_domain_info *domain;
 	char *buf;
+	const char *cp;
 	const struct ccs_acl_info *acl = r->matched_acl;
 	r->matched_acl = NULL;
 	if (!acl || !acl->cond || !acl->cond->transit)
@@ -348,10 +348,13 @@
 		if (fatal_signal_pending(current))
 			return;
 	}
-	domain = ccs_current_domain();
-	snprintf(buf, CCS_EXEC_TMPSIZE - 1, "%s %s", domain->domainname->name,
-		 acl->cond->transit->name);
-	if (!ccs_assign_domain(buf, r->profile, domain->group, true))
+	cp = acl->cond->transit->name;
+	if (*cp == '/')
+		snprintf(buf, CCS_EXEC_TMPSIZE - 1, "%s %s",
+			 ccs_current_domain()->domainname->name, cp);
+	else
+		strncpy(buf, cp, CCS_EXEC_TMPSIZE - 1);
+	if (!ccs_assign_domain(buf, true))
 		ccs_transition_failed(buf);
 	kfree(buf);
 }
Index: security/ccsecurity/domain.c
===================================================================
--- security/ccsecurity/domain.c	(revision 5044)
+++ security/ccsecurity/domain.c	(working copy)
@@ -3,30 +3,17 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1+   2011/05/05
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
 
-/*
- * The global domains referred by "use_group" keyword.
- *
- * Although "use_group" needs only "struct list_head acl_info_list[2]",
- * we define structure for "use_group" as "struct ccs_domain_info" in order to
- * use common code.
- */
-struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
-
 /* The initial domain. */
 struct ccs_domain_info ccs_kernel_domain;
 
 /* The list for "struct ccs_domain_info". */
 LIST_HEAD(ccs_domain_list);
 
-/* List of policy. */
-struct list_head ccs_policy_list[CCS_MAX_POLICY];
-/* List of "struct ccs_group". */
-struct list_head ccs_group_list[CCS_MAX_GROUP];
 /* List of "struct ccs_condition" and "struct ccs_ipv6addr". */
 struct list_head ccs_shared_list[CCS_MAX_LIST];
 
@@ -35,8 +22,7 @@
  *
  * @new_entry:       Pointer to "struct ccs_acl_info".
  * @size:            Size of @new_entry in bytes.
- * @is_delete:       True if it is a delete request.
- * @list:            Pointer to "struct list_head".
+ * @param:           Pointer to "struct ccs_acl_param".
  * @check_duplicate: Callback function to find duplicated entry.
  *
  * Returns 0 on success, negative value otherwise.
@@ -44,22 +30,23 @@
  * Caller holds ccs_read_lock().
  */
 int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      bool is_delete, struct list_head *list,
+		      struct ccs_acl_param *param,
 		      bool (*check_duplicate) (const struct ccs_acl_head *,
 					       const struct ccs_acl_head *))
 {
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	struct ccs_acl_head *entry;
+	struct list_head *list = param->list;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return -ENOMEM;
 	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
 		if (!check_duplicate(entry, new_entry))
 			continue;
-		entry->is_deleted = is_delete;
+		entry->is_deleted = param->is_delete;
 		error = 0;
 		break;
 	}
-	if (error && !is_delete) {
+	if (error && !param->is_delete) {
 		entry = ccs_commit_ok(new_entry, size);
 		if (entry) {
 			list_add_tail_rcu(&entry->list, list);
@@ -105,23 +92,22 @@
 					       struct ccs_acl_info *,
 					       const bool))
 {
-	struct ccs_domain_info * const domain = param->domain;
 	const bool is_delete = param->is_delete;
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	struct ccs_acl_info *entry;
 	const u8 type = new_entry->type;
-	const u8 i = type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
-		type == CCS_TYPE_DENIED_EXECUTE_HANDLER ||
-		type == CCS_TYPE_AUTO_TASK_ACL;
+	struct list_head * const list = &param->list
+		[type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
+		 type == CCS_TYPE_DENIED_EXECUTE_HANDLER ||
+		 type == CCS_TYPE_AUTO_TASK_ACL];
 	if (param->data[0]) {
-		new_entry->cond = ccs_get_condition(param->data);
+		new_entry->cond = ccs_get_condition(param);
 		if (!new_entry->cond)
 			return -EINVAL;
 	}
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list_for_each_entry_srcu(entry, &domain->acl_info_list[i], list,
-				 &ccs_ss) {
+	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
 		if (!ccs_same_acl_head(entry, new_entry) ||
 		    !check_duplicate(entry, new_entry))
 			continue;
@@ -136,8 +122,7 @@
 	if (error && !is_delete) {
 		entry = ccs_commit_ok(new_entry, size);
 		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &domain->acl_info_list[i]);
+			list_add_tail_rcu(&entry->list, list);
 			error = 0;
 		}
 	}
@@ -166,9 +151,9 @@
 	struct ccs_acl_info *ptr;
 	bool retried = false;
 	const u8 i = !check_entry;
+	const struct list_head *list = &domain->acl_info_list[i];
 retry:
-	list_for_each_entry_srcu(ptr, &domain->acl_info_list[i], list,
-				 &ccs_ss) {
+	list_for_each_entry_srcu(ptr, list, list, &ccs_ss) {
 		if (ptr->is_deleted)
 			continue;
 		if (ptr->type != r->param_type)
@@ -183,7 +168,7 @@
 	}
 	if (!retried) {
 		retried = true;
-		domain = &ccs_acl_group[domain->group];
+		list = &r->ns->acl_group[domain->group][i];
 		goto retry;
 	}
 	r->granted = false;
@@ -210,22 +195,27 @@
 }
 
 /**
- * ccs_update_transition_control_entry - Update "struct ccs_transition_control" list.
+ * ccs_write_transition_control - Write "struct ccs_transition_control" list.
  *
- * @domainname: The name of domain. Maybe NULL.
- * @program:    The name of program. Maybe NULL.
- * @type:       Type of transition.
- * @is_delete:  True if it is a delete request.
+ * @param: Pointer to "struct ccs_acl_param".
+ * @type:  Type of this entry.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_transition_control_entry(const char *domainname,
-					       const char *program,
-					       const u8 type,
-					       const bool is_delete)
+int ccs_write_transition_control(struct ccs_acl_param *param, const u8 type)
 {
 	struct ccs_transition_control e = { .type = type };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
+	char *program = param->data;
+	char *domainname = strstr(program, " from ");
+	if (domainname) {
+		*domainname = '\0';
+		domainname += 6;
+	} else if (type == CCS_TRANSITION_CONTROL_NO_KEEP ||
+		   type == CCS_TRANSITION_CONTROL_KEEP) {
+		domainname = program;
+		program = NULL;
+	}
 	if (program && strcmp(program, "any")) {
 		if (!ccs_correct_path(program))
 			return -EINVAL;
@@ -243,8 +233,8 @@
 		if (!e.domainname)
 			goto out;
 	}
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_TRANSITION_CONTROL],
+	param->list = &param->ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+	error = ccs_update_policy(&e.head, sizeof(e), param,
 				  ccs_same_transition_control);
 out:
 	ccs_put_name(e.domainname);
@@ -253,31 +243,6 @@
 }
 
 /**
- * ccs_write_transition_control - Write "struct ccs_transition_control" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- * @type:      Type of this entry.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_transition_control(char *data, const bool is_delete,
-				 const u8 type)
-{
-	char *domainname = strstr(data, " from ");
-	if (domainname) {
-		*domainname = '\0';
-		domainname += 6;
-	} else if (type == CCS_TRANSITION_CONTROL_NO_KEEP ||
-		   type == CCS_TRANSITION_CONTROL_KEEP) {
-		domainname = data;
-		data = NULL;
-	}
-	return ccs_update_transition_control_entry(domainname, data, type,
-						   is_delete);
-}
-
-/**
  * ccs_last_word - Get last component of a domainname.
  *
  * @name: Domainname to check.
@@ -295,6 +260,7 @@
 /**
  * ccs_transition_type - Get domain transition type.
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @domainname: The name of domain.
  * @program:    The name of program.
  *
@@ -304,17 +270,18 @@
  *
  * Caller holds ccs_read_lock().
  */
-static u8 ccs_transition_type(const struct ccs_path_info *domainname,
+static u8 ccs_transition_type(const struct ccs_policy_namespace *ns,
+			      const struct ccs_path_info *domainname,
 			      const struct ccs_path_info *program)
 {
 	const struct ccs_transition_control *ptr;
 	const char *last_name = ccs_last_word(domainname->name);
 	u8 type;
 	for (type = 0; type < CCS_MAX_TRANSITION_TYPE; type++) {
+		const struct list_head *list;
 next:
-		list_for_each_entry_srcu(ptr, &ccs_policy_list
-					 [CCS_ID_TRANSITION_CONTROL],
-					 head.list, &ccs_ss) {
+		list = &ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 			if (ptr->head.is_deleted || ptr->type != type)
 				continue;
 			if (ptr->domainname) {
@@ -333,6 +300,14 @@
 			}
 			if (ptr->program && ccs_pathcmp(ptr->program, program))
 				continue;
+			if (type == CCS_TRANSITION_CONTROL_NO_NAMESPACE) {
+				/*
+				 * Do not check for move_namespace if
+				 * no_move_namespace matched.
+				 */
+				type = CCS_TRANSITION_CONTROL_NO_INITIALIZE;
+				goto next;
+			}
 			if (type == CCS_TRANSITION_CONTROL_NO_INITIALIZE) {
 				/*
 				 * Do not check for initialize_domain if
@@ -366,20 +341,18 @@
 }
 
 /**
- * ccs_update_aggregator_entry - Update "struct ccs_aggregator" list.
+ * ccs_write_aggregator - Write "struct ccs_aggregator" list.
  *
- * @original_name:   The original program's name.
- * @aggregated_name: The aggregated program's name.
- * @is_delete:       True if it is a delete request.
+ * @param: Pointer to "struct ccs_acl_param".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_aggregator_entry(const char *original_name,
-				       const char *aggregated_name,
-				       const bool is_delete)
+int ccs_write_aggregator(struct ccs_acl_param *param)
 {
 	struct ccs_aggregator e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
+	const char *original_name = ccs_read_token(param);
+	const char *aggregated_name = ccs_read_token(param);
 	if (!ccs_correct_word(original_name) ||
 	    !ccs_correct_path(aggregated_name))
 		return -EINVAL;
@@ -388,8 +361,8 @@
 	if (!e.original_name || !e.aggregated_name ||
 	    e.aggregated_name->is_patterned) /* No patterns allowed. */
 		goto out;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_AGGREGATOR],
+	param->list = &param->ns->policy_list[CCS_ID_AGGREGATOR];
+	error = ccs_update_policy(&e.head, sizeof(e), param,
 				  ccs_same_aggregator);
 out:
 	ccs_put_name(e.original_name);
@@ -397,30 +370,95 @@
 	return error;
 }
 
+/* Domain create handler. */
+
 /**
- * ccs_write_aggregator - Write "struct ccs_aggregator" list.
+ * ccs_find_namespace - Find specified namespace.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
+ * @name: Name of namespace to find.
+ * @len:  Length of @name.
  *
- * Returns 0 on success, negative value otherwise.
+ * Returns pointer to "struct ccs_policy_namespace" if found, NULL otherwise.
+ *
+ * Caller holds ccs_read_lock().
  */
-int ccs_write_aggregator(char *data, const bool is_delete)
+static struct ccs_policy_namespace *ccs_find_namespace(const char *name,
+						       const unsigned int len)
 {
-	char *w[2];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	return ccs_update_aggregator_entry(w[0], w[1], is_delete);
+	struct ccs_policy_namespace *ns;
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		if (strncmp(name, ns->name, len) ||
+		    (name[len] && name[len] != ' '))
+			continue;
+		return ns;
+	}
+	return NULL;
 }
 
-/* Domain create handler. */
 
 /**
- * ccs_assign_domain - Create a domain.
+ * ccs_assign_namespace - Create a new namespace.
  *
+ * @domainname: Name of namespace to create.
+ *
+ * Returns pointer to "struct ccs_policy_namespace" on success, NULL otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+struct ccs_policy_namespace *ccs_assign_namespace(const char *domainname)
+{
+	struct ccs_policy_namespace *ptr;
+	struct ccs_policy_namespace *entry;
+	const char *cp = domainname;
+	unsigned int len = 0;
+	while (*cp && *cp++ != ' ')
+		len++;
+	ptr = ccs_find_namespace(domainname, len);
+	if (ptr)
+		return ptr;
+	if (len >= CCS_EXEC_TMPSIZE - 10 || !ccs_domain_def(domainname))
+		return NULL;
+	entry = kzalloc(sizeof(*entry) + len + 1, CCS_GFP_FLAGS);
+	if (!entry)
+		return NULL;
+	if (mutex_lock_interruptible(&ccs_policy_lock))
+		goto out;
+	ptr = ccs_find_namespace(domainname, len);
+	if (!ptr && ccs_memory_ok(entry, sizeof(*entry) + len + 1)) {
+		char *name = (char *) (entry + 1);
+		ptr = entry;
+		memmove(name, domainname, len);
+		name[len] = '\0';
+		entry->name = name;
+		ccs_init_policy_namespace(entry);
+		entry = NULL;
+	}
+	mutex_unlock(&ccs_policy_lock);
+out:
+	kfree(entry);
+	return entry;
+}
+
+/**
+ * ccs_namespace_jump - Check for namespace jump.
+ *
+ * @domainname: Name of domain.
+ *
+ * Returns true if namespace differs, false otherwise.
+ */
+static bool ccs_namespace_jump(const char *domainname)
+{
+	const char *namespace = ccs_current_namespace()->name;
+	const int len = strlen(namespace);
+	return strncmp(domainname, namespace, len) ||
+		(domainname[len] && domainname[len] != ' ');
+}
+
+/**
+ * ccs_assign_domain - Create a domain or a namespace.
+ *
  * @domainname: The name of domain.
- * @profile:    Profile number to assign if the domain was newly created.
- * @group:      Group number to assign if the domain was newly created.
  * @transit:    True if transit to domain found or created.
  *
  * Returns pointer to "struct ccs_domain_info" on success, NULL otherwise.
@@ -428,19 +466,51 @@
  * Caller holds ccs_read_lock().
  */
 struct ccs_domain_info *ccs_assign_domain(const char *domainname,
-					  const u8 profile, const u8 group,
 					  const bool transit)
 {
+	struct ccs_security *security = ccs_current_security();
 	struct ccs_domain_info e = { };
 	struct ccs_domain_info *entry = ccs_find_domain(domainname);
 	bool created = false;
-	if (entry)
-		goto out;
+	if (entry) {
+		if (transit) {
+			/*
+			 * Since namespace is created at runtime, profiles may
+			 * not be created by the moment the process transits to
+			 * that domain. Do not perform domain transition if
+			 * profile for that domain is not yet created.
+			 */
+			if (!entry->ns->profile_ptr[entry->profile])
+				return NULL;
+			security->ccs_domain_info = entry;
+		}
+		return entry;
+	}
+	/* Requested domain does not exist. */
+	/* Don't create requested domain if domainname is invalid. */
 	if (strlen(domainname) >= CCS_EXEC_TMPSIZE - 10 ||
 	    !ccs_correct_domain(domainname))
 		return NULL;
-	e.profile = profile;
-	e.group = group;
+	/*
+	 * Since definition of profiles and acl_groups may differ across
+	 * namespaces, do not inherit "use_profile" and "use_group" settings
+	 * by automatically creating requested domain upon domain transition.
+	 */
+	if (transit && ccs_namespace_jump(domainname))
+		return NULL;
+	e.ns = ccs_assign_namespace(domainname);
+	if (!e.ns)
+		return NULL;
+	/*
+	 * "use_profile" and "use_group" settings for automatically created
+	 * domains are inherited from current domain, 0 otherwise.
+	 */
+	if (transit) {
+		const struct ccs_domain_info *domain =
+			security->ccs_domain_info;
+		e.profile = domain->profile;
+		e.group = domain->group;
+	}
 	e.domainname = ccs_get_name(domainname);
 	if (!e.domainname)
 		return NULL;
@@ -460,13 +530,13 @@
 out:
 	ccs_put_name(e.domainname);
 	if (entry && transit) {
-		ccs_current_security()->ccs_domain_info = entry;
+		security->ccs_domain_info = entry;
 		if (created) {
 			struct ccs_request_info r;
 			ccs_init_request_info(&r, CCS_MAC_FILE_EXECUTE);
 			r.granted = false;
-			ccs_write_log(&r, "use_profile %u\n", profile);
-			ccs_write_log(&r, "use_group %u\n", group);
+			ccs_write_log(&r, "use_profile %u\n", entry->profile);
+			ccs_write_log(&r, "use_group %u\n", entry->group);
 			ccs_update_stat(CCS_STAT_POLICY_UPDATES);
 		}
 	}
@@ -519,10 +589,10 @@
 		}
 	} else {
 		struct ccs_aggregator *ptr;
+		struct list_head *list =
+			&r->ns->policy_list[CCS_ID_AGGREGATOR];
 		/* Check 'aggregator' directive. */
-		list_for_each_entry_srcu(ptr,
-					 &ccs_policy_list[CCS_ID_AGGREGATOR],
-					 head.list, &ccs_ss) {
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 			if (ptr->head.is_deleted ||
 			    !ccs_path_matches_pattern(&rn, ptr->original_name))
 				continue;
@@ -555,10 +625,14 @@
 	}
 
 	/* Calculate domain to transit to. */
-	switch (ccs_transition_type(old_domain->domainname, &rn)) {
+	switch (ccs_transition_type(r->ns, old_domain->domainname, &rn)) {
+	case CCS_TRANSITION_CONTROL_NAMESPACE:
+		/* Transit to the root of specified namespace. */
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "<%s>", rn.name);
+		break;
 	case CCS_TRANSITION_CONTROL_INITIALIZE:
-		/* Transit to the child of ccs_kernel_domain domain. */
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, CCS_ROOT_NAME " " "%s",
+		/* Transit to the child of current namespace's root. */
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%s %s", r->ns->name,
 			 rn.name);
 		break;
 	case CCS_TRANSITION_CONTROL_KEEP:
@@ -598,8 +672,7 @@
 	 * enforcing mode.
 	 */
 	if (!domain)
-		domain = ccs_assign_domain(ee->tmp, r->profile,
-					   old_domain->group, true);
+		domain = ccs_assign_domain(ee->tmp, true);
 	if (domain)
 		retval = 0;
 	else if (r->mode == CCS_CONFIG_ENFORCING)
Index: security/ccsecurity/memory.c
===================================================================
--- security/ccsecurity/memory.c	(revision 5044)
+++ security/ccsecurity/memory.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1   2011/04/01
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -109,15 +109,17 @@
 /**
  * ccs_get_group - Allocate memory for "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group".
  *
- * @group_name: The name of address group.
- * @idx:        Index number.
+ * @param: Pointer to "struct ccs_acl_param".
+ * @idx:   Index number.
  *
  * Returns pointer to "struct ccs_group" on success, NULL otherwise.
  */
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx)
+struct ccs_group *ccs_get_group(struct ccs_acl_param *param, const u8 idx)
 {
 	struct ccs_group e = { };
 	struct ccs_group *group = NULL;
+	struct list_head *list;
+	const char *group_name = ccs_read_token(param);
 	bool found = false;
 	if (!ccs_correct_word(group_name) || idx >= CCS_MAX_GROUP)
 		return NULL;
@@ -126,7 +128,8 @@
 		return NULL;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list_for_each_entry(group, &ccs_group_list[idx], head.list) {
+	list = &param->ns->group_list[idx];
+	list_for_each_entry(group, list, head.list) {
 		if (e.group_name != group->group_name)
 			continue;
 		atomic_inc(&group->head.users);
@@ -138,8 +141,7 @@
 		if (entry) {
 			INIT_LIST_HEAD(&entry->member_list);
 			atomic_set(&entry->head.users, 1);
-			list_add_tail_rcu(&entry->head.list,
-					  &ccs_group_list[idx]);
+			list_add_tail_rcu(&entry->head.list, list);
 			group = entry;
 			found = true;
 		}
@@ -400,6 +402,9 @@
 
 #endif
 
+/* Initial namespace.*/
+struct ccs_policy_namespace ccs_kernel_namespace;
+
 /**
  * ccs_mm_init - Initialize mm related code.
  *
@@ -410,10 +415,9 @@
 	int idx;
 	for (idx = 0; idx < CCS_MAX_HASH; idx++)
 		INIT_LIST_HEAD(&ccs_name_list[idx]);
-	for (idx = 0; idx < CCS_MAX_ACL_GROUPS; idx++) {
-		INIT_LIST_HEAD(&ccs_acl_group[idx].acl_info_list[0]);
-		INIT_LIST_HEAD(&ccs_acl_group[idx].acl_info_list[1]);
-	}
+	ccs_kernel_namespace.name = "<kernel>";
+	ccs_init_policy_namespace(&ccs_kernel_namespace);
+	ccs_kernel_domain.ns = &ccs_kernel_namespace;
 	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list[0]);
 	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list[1]);
 #ifdef CONFIG_CCSECURITY_USE_EXTERNAL_TASK_SECURITY
@@ -425,27 +429,28 @@
 	ccsecurity_ops.alloc_task_security = __ccs_alloc_task_security;
 	ccsecurity_ops.free_task_security = __ccs_free_task_security;
 #endif
-	ccs_kernel_domain.domainname = ccs_get_name(CCS_ROOT_NAME);
+	ccs_kernel_domain.domainname = ccs_get_name("<kernel>");
 	list_add_tail_rcu(&ccs_kernel_domain.list, &ccs_domain_list);
+#ifdef CONFIG_CCSECURITY_BUILTIN_INITIALIZERS
 	idx = ccs_read_lock();
-	if (ccs_find_domain(CCS_ROOT_NAME) != &ccs_kernel_domain)
-		panic("Can't register ccs_kernel_domain");
-#ifdef CONFIG_CCSECURITY_BUILTIN_INITIALIZERS
 	{
 		/* Load built-in policy. */
+		struct ccs_acl_param param = { };
 		static char ccs_builtin_initializers[] __initdata
 			= CONFIG_CCSECURITY_BUILTIN_INITIALIZERS;
 		char *cp = ccs_builtin_initializers;
 		ccs_normalize_line(cp);
+		param.ns = &ccs_kernel_namespace;
 		while (cp && *cp) {
 			char *cp2 = strchr(cp, ' ');
 			if (cp2)
 				*cp2++ = '\0';
-			ccs_write_transition_control(cp, false,
+			param.data = cp;
+			ccs_write_transition_control(&param,
 				     CCS_TRANSITION_CONTROL_INITIALIZE);
 			cp = cp2;
 		}
 	}
+	ccs_read_unlock(idx);
 #endif
-	ccs_read_unlock(idx);
 }
Index: security/ccsecurity/signal.c
===================================================================
--- security/ccsecurity/signal.c	(revision 5044)
+++ security/ccsecurity/signal.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1   2011/04/01
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -39,7 +39,7 @@
 {
 	const struct ccs_signal_acl *acl =
 		container_of(ptr, typeof(*acl), head);
-	if (acl->sig == r->param.signal.sig) {
+	if (ccs_compare_number_union(r->param.signal.sig, &acl->sig)) {
 		const int len = acl->domainname->total_len;
 		if (!strncmp(acl->domainname->name,
 			     r->param.signal.dest_pattern, len)) {
@@ -158,26 +158,23 @@
 {
 	const struct ccs_signal_acl *p1 = container_of(a, typeof(*p1), head);
 	const struct ccs_signal_acl *p2 = container_of(b, typeof(*p2), head);
-	return p1->sig == p2->sig && p1->domainname == p2->domainname;
+	return ccs_same_number_union(&p1->sig, &p2->sig) &&
+		p1->domainname == p2->domainname;
 }
 
 /**
- * ccs_write_signal - Write "struct ccs_signal_acl" list.
+ * ccs_write_ipc - Update "struct ccs_signal_acl" list.
  *
  * @param: Pointer to "struct ccs_acl_param".
  *
  * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
  */
-static int ccs_write_signal(struct ccs_acl_param *param)
+int ccs_write_ipc(struct ccs_acl_param *param)
 {
 	struct ccs_signal_acl e = { .head.type = CCS_TYPE_SIGNAL_ACL };
 	int error;
-	int sig;
-	if (sscanf(ccs_read_token(param), "%d", &sig) != 1)
+	if (!ccs_parse_number_union(param, &e.sig))
 		return -EINVAL;
-	e.sig = sig;
 	e.domainname = ccs_get_domainname(param);
 	if (!e.domainname)
 		error = -EINVAL;
@@ -185,24 +182,11 @@
 		error = ccs_update_domain(&e.head, sizeof(e), param,
 					  ccs_same_signal_acl, NULL);
 	ccs_put_name(e.domainname);
+	ccs_put_number_union(&e.sig);
 	return error;
 }
 
 /**
- * ccs_write_ipc - Update ipc related list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_ipc(struct ccs_acl_param *param)
-{
-	if (ccs_str_starts(&param->data, "signal "))
-		return ccs_write_signal(param);
-	return -EINVAL;
-}
-
-/**
  * ccs_file_init - Register ipc related hooks.
  *
  * Returns nothing.
Index: security/ccsecurity/util.c
===================================================================
--- security/ccsecurity/util.c	(revision 5044)
+++ security/ccsecurity/util.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1+   2011/05/11
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -247,20 +247,24 @@
 /**
  * ccs_parse_name_union - Parse a ccs_name_union.
  *
- * @filename: Name or name group.
- * @ptr:      Pointer to "struct ccs_name_union".
+ * @param: Pointer to "struct ccs_acl_param".
+ * @ptr:   Pointer to "struct ccs_name_union".
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr)
+bool ccs_parse_name_union(struct ccs_acl_param *param,
+			  struct ccs_name_union *ptr)
 {
-	if (!ccs_correct_word(filename))
-		return false;
-	if (filename[0] == '@') {
-		ptr->group = ccs_get_group(filename + 1, CCS_PATH_GROUP);
+	char *filename;
+	if (param->data[0] == '@') {
+		param->data++;
+		ptr->group = ccs_get_group(param, CCS_PATH_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
+	filename = ccs_read_token(param);
+	if (!ccs_correct_word(filename))
+		return false;
 	ptr->filename = ccs_get_name(filename);
 	ptr->is_group = false;
 	return ptr->filename != NULL;
@@ -269,25 +273,25 @@
 /**
  * ccs_parse_number_union - Parse a ccs_number_union.
  *
- * @data: Number or number range or number group.
- * @ptr:  Pointer to "struct ccs_number_union".
+ * @param: Pointer to "struct ccs_acl_param".
+ * @ptr:   Pointer to "struct ccs_number_union".
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_parse_number_union(char *data, struct ccs_number_union *ptr)
+bool ccs_parse_number_union(struct ccs_acl_param *param,
+			    struct ccs_number_union *ptr)
 {
+	char *data;
 	u8 type;
 	unsigned long v;
 	memset(ptr, 0, sizeof(*ptr));
-	if (!data[0])
-		return false;
-	if (data[0] == '@') {
-		if (!ccs_correct_word(data))
-			return false;
-		ptr->group = ccs_get_group(data + 1, CCS_NUMBER_GROUP);
+	if (param->data[0] == '@') {
+		param->data++;
+		ptr->group = ccs_get_group(param, CCS_NUMBER_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
+	data = ccs_read_token(param);
 	type = ccs_parse_ulong(&v, &data);
 	if (type == CCS_VALUE_TYPE_INVALID)
 		return false;
@@ -301,7 +305,7 @@
 	if (*data++ != '-')
 		return false;
 	type = ccs_parse_ulong(&v, &data);
-	if (type == CCS_VALUE_TYPE_INVALID || *data)
+	if (type == CCS_VALUE_TYPE_INVALID || *data || ptr->values[0] > v)
 		return false;
 	ptr->values[1] = v;
 	ptr->value_type[1] = type;
@@ -426,33 +430,6 @@
 }
 
 /**
- * ccs_tokenize - Tokenize string.
- *
- * @buffer: The line to tokenize.
- * @w:      Pointer to "char *".
- * @size:   Sizeof @w.
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_tokenize(char *buffer, char *w[], size_t size)
-{
-	int count = size / sizeof(char *);
-	int i;
-	for (i = 0; i < count; i++)
-		w[i] = "";
-	for (i = 0; i < count; i++) {
-		char *cp = strchr(buffer, ' ');
-		if (cp)
-			*cp = '\0';
-		w[i] = buffer;
-		if (!cp)
-			break;
-		buffer = cp + 1;
-	}
-	return i < count || !*buffer;
-}
-
-/**
  * ccs_correct_word2 - Check whether the given string follows the naming rules.
  *
  * @string: The byte sequence to check. Not '\0'-terminated.
@@ -562,26 +539,21 @@
  */
 bool ccs_correct_domain(const unsigned char *domainname)
 {
-	if (!domainname || strncmp(domainname, CCS_ROOT_NAME,
-				   CCS_ROOT_NAME_LEN))
-		goto out;
-	domainname += CCS_ROOT_NAME_LEN;
-	if (!*domainname)
+	if (!domainname || !ccs_domain_def(domainname))
+		return false;
+	domainname = strchr(domainname, ' ');
+	if (!domainname++)
 		return true;
-	if (*domainname++ != ' ')
-		goto out;
 	while (1) {
 		const unsigned char *cp = strchr(domainname, ' ');
 		if (!cp)
 			break;
 		if (*domainname != '/' ||
 		    !ccs_correct_word2(domainname, cp - domainname))
-			goto out;
+			return false;
 		domainname = cp + 1;
 	}
 	return ccs_correct_path(domainname);
-out:
-	return false;
 }
 
 /**
@@ -593,7 +565,18 @@
  */
 bool ccs_domain_def(const unsigned char *buffer)
 {
-	return !strncmp(buffer, CCS_ROOT_NAME, CCS_ROOT_NAME_LEN);
+	const unsigned char *cp;
+	int len;
+	if (*buffer != '<')
+		return false;
+	cp = strchr(buffer, ' ');
+	if (!cp)
+		len = strlen(buffer);
+	else
+		len = cp - buffer;
+	if (buffer[len - 1] != '>' || !ccs_correct_word2(buffer + 1, len - 2))
+		return false;
+	return true;
 }
 
 /**
@@ -1025,9 +1008,9 @@
 	u8 i;
 	const char *buf;
 	for (i = 0; i < 255; i++) {
-		struct ccs_domain_info *domain = ccs_current_domain();
-		const u8 profile = domain->profile;
+		const u8 profile = ccs_current_domain()->profile;
 		memset(r, 0, sizeof(*r));
+		r->ns = ccs_current_namespace();
 		r->profile = profile;
 		r->type = index;
 		r->mode = ccs_get_mode(profile, index);
@@ -1037,7 +1020,7 @@
 			return r->mode;
 		buf = container_of(r->matched_acl, typeof(struct ccs_task_acl),
 				   head)->domainname->name;
-		if (!ccs_assign_domain(buf, profile, domain->group, true))
+		if (!ccs_assign_domain(buf, true))
 			break;
 	}
 	ccs_transition_failed(buf);
Index: security/ccsecurity/file.c
===================================================================
--- security/ccsecurity/file.c	(revision 5044)
+++ security/ccsecurity/file.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1+   2011/04/11
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -88,7 +88,7 @@
 }
 
 /**
- * ccs_put_name_union - Drop reference on "struct ccs_number_union".
+ * ccs_put_number_union - Drop reference on "struct ccs_number_union".
  *
  * @ptr: Pointer to "struct ccs_number_union".
  *
@@ -393,7 +393,7 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name))
+	if (!ccs_parse_name_union(param, &e.name))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -462,10 +462,10 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.mode) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.major) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.minor))
+	if (!ccs_parse_name_union(param, &e.name) ||
+	    !ccs_parse_number_union(param, &e.mode) ||
+	    !ccs_parse_number_union(param, &e.major) ||
+	    !ccs_parse_number_union(param, &e.minor))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -535,8 +535,8 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name1) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.name2))
+	if (!ccs_parse_name_union(param, &e.name1) ||
+	    !ccs_parse_name_union(param, &e.name2))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -579,10 +579,10 @@
 {
 	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL };
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.dev_name) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.dir_name) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.fs_type) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.flags))
+	if (!ccs_parse_name_union(param, &e.dev_name) ||
+	    !ccs_parse_name_union(param, &e.dir_name) ||
+	    !ccs_parse_name_union(param, &e.fs_type) ||
+	    !ccs_parse_number_union(param, &e.flags))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -1001,8 +1001,8 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.number))
+	if (!ccs_parse_name_union(param, &e.name) ||
+	    !ccs_parse_number_union(param, &e.number))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
Index: security/ccsecurity/proc_if.c
===================================================================
--- security/ccsecurity/proc_if.c	(revision 5044)
+++ security/ccsecurity/proc_if.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1   2011/04/01
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -65,9 +65,7 @@
 		if (!r.granted)
 			error = -EPERM;
 		else
-			error = ccs_assign_domain(data, r.profile,
-						  ccs_current_domain()->group,
-						  true) ? 0 : -ENOENT;
+			error = ccs_assign_domain(data, true) ? 0 : -ENOENT;
 		ccs_read_unlock(idx);
 	} else
 		error = -EINVAL;
@@ -338,10 +336,6 @@
 static int __init ccs_init_module(void)
 {
 	int i;
-	for (i = 0; i < CCS_MAX_POLICY; i++)
-		INIT_LIST_HEAD(&ccs_policy_list[i]);
-	for (i = 0; i < CCS_MAX_GROUP; i++)
-		INIT_LIST_HEAD(&ccs_group_list[i]);
 	for (i = 0; i < CCS_MAX_LIST; i++)
 		INIT_LIST_HEAD(&ccs_shared_list[i]);
 	if (ccsecurity_ops.disabled)
@@ -353,7 +347,6 @@
 	if (init_srcu_struct(&ccs_ss))
 		panic("Out of memory.");
 #endif
-	ccs_proc_init();
 	ccs_mm_init();
 	ccs_capability_init();
 	ccs_file_init();
@@ -362,6 +355,7 @@
 	ccs_mount_init();
 	ccs_policy_io_init();
 	ccs_domain_init();
+	ccs_proc_init();
 #ifdef CONFIG_CCSECURITY_USE_BUILTIN_POLICY
 	ccs_load_builtin_policy();
 #endif
Index: security/ccsecurity/internal.h
===================================================================
--- security/ccsecurity/internal.h	(revision 5044)
+++ security/ccsecurity/internal.h	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1   2011/04/01
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #ifndef _SECURITY_CCSECURITY_INTERNAL_H
@@ -461,13 +461,6 @@
 	CCS_MAX_GROUP
 };
 
-/* Index numbers for type of IP address. */
-enum ccs_ip_address_type {
-	CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP,
-	CCS_IP_ADDRESS_TYPE_IPv4,
-	CCS_IP_ADDRESS_TYPE_IPv6,
-};
-
 /* Index numbers for category of functionality. */
 enum ccs_mac_category_index {
 	CCS_MAC_CATEGORY_FILE,
@@ -697,6 +690,8 @@
 /* Index numbers for domain transition control keywords. */
 enum ccs_transition_type {
 	/* Do not change this order, */
+	CCS_TRANSITION_CONTROL_NO_NAMESPACE,
+	CCS_TRANSITION_CONTROL_NAMESPACE,
 	CCS_TRANSITION_CONTROL_NO_INITIALIZE,
 	CCS_TRANSITION_CONTROL_INITIALIZE,
 	CCS_TRANSITION_CONTROL_NO_KEEP,
@@ -728,10 +723,6 @@
  */
 #define CCS_SOCK_MAX 6
 
-/* A domain definition starts with <kernel>. */
-#define CCS_ROOT_NAME                         "<kernel>"
-#define CCS_ROOT_NAME_LEN                     (sizeof(CCS_ROOT_NAME) - 1)
-
 /* Size of temporary buffer for execve() operation. */
 #define CCS_EXEC_TMPSIZE     4096
 
@@ -823,6 +814,24 @@
 	u8 is_group;
 };
 
+/* Structure for holding an IP address. */
+struct ccs_ipaddr_union {
+	struct {
+		/* Start of IPv4 address range. Host endian. */
+		u32 min;
+		/* End of IPv4 address range. Host endian.   */
+		u32 max;
+	} ipv4;
+	struct {
+		/* Start of IPv6 address range. Big endian.  */
+		const struct in6_addr *min;
+		/* End of IPv6 address range. Big endian.    */
+		const struct in6_addr *max;
+	} ipv6;
+	/* Pointer to address group. */
+	struct ccs_group *group;
+};
+
 /* Structure for "path_group"/"number_group"/"address_group" directive. */
 struct ccs_group {
 	struct ccs_shared_acl_head head;
@@ -850,11 +859,8 @@
 /* Structure for "address_group" directive. */
 struct ccs_address_group {
 	struct ccs_acl_head head;
-	bool is_ipv6; /* True if IPv6 address, false if IPv4 address. */
-	union {
-		u32 ipv4;                    /* Host byte order    */
-		const struct in6_addr *ipv6; /* Network byte order */
-	} min, max;
+	/* Structure for holding an IP address. */
+	struct ccs_ipaddr_union address;
 };
 
 /* Subset of "struct stat". Used by conditional ACL and audit logs. */
@@ -934,6 +940,7 @@
 };
 
 struct ccs_execve;
+struct ccs_policy_namespace;
 
 /* Structure for request info. */
 struct ccs_request_info {
@@ -1027,10 +1034,8 @@
 			const struct ccs_path_info *domainname;
 		} task;
 	} param;
-	u8 param_type; /* One of values in "enum ccs_acl_entry_type_index". */
-	bool granted; /* True if granted, false otherwise. */
-	/* True if current thread should not be carried sleep penalty. */
-	bool dont_sleep_on_enforce_error;
+	/* For holding namespace used for this request. */
+	struct ccs_policy_namespace *ns;
 	/*
 	 * For updating current->ccs_domain_info at ccs_update_task_domain().
 	 * Initialized to NULL at ccs_init_request_info().
@@ -1038,6 +1043,10 @@
 	 * granted. Re-initialized to NULL at ccs_update_task_domain().
 	 */
 	struct ccs_acl_info *matched_acl;
+	u8 param_type; /* One of values in "enum ccs_acl_entry_type_index". */
+	bool granted; /* True if granted, false otherwise. */
+	/* True if current thread should not be carried sleep penalty. */
+	bool dont_sleep_on_enforce_error;
 	/*
 	 * For counting number of retries made for this request.
 	 * This counter is incremented whenever ccs_supervisor() returned
@@ -1095,6 +1104,8 @@
 	struct list_head acl_info_list[2];
 	/* Name of this domain. Never NULL.          */
 	const struct ccs_path_info *domainname;
+	/* Namespace for this domain. Never NULL. */
+	struct ccs_policy_namespace *ns;
 	u8 profile;        /* Profile number to use. */
 	u8 group;          /* Group number to use.   */
 	bool is_deleted;   /* Delete flag.           */
@@ -1102,7 +1113,8 @@
 };
 
 /*
- * Structure for "initialize_domain"/"no_initialize_domain" and
+ * Structure for "move_namespace"/"no_move_namespace" and
+ * "initialize_domain"/"no_initialize_domain" and
  * "keep_domain"/"no_keep_domain" keyword.
  */
 struct ccs_transition_control {
@@ -1123,8 +1135,7 @@
 /* Structure for "deny_autobind" keyword. */
 struct ccs_reserved {
 	struct ccs_acl_head head;
-	u16 min_port;                /* Start of port number range.          */
-	u16 max_port;                /* End of port number range.            */
+	struct ccs_number_union port;
 };
 
 /* Structure for policy manager. */
@@ -1137,7 +1148,7 @@
 
 /* Structure for argv[]. */
 struct ccs_argv {
-	unsigned int index;
+	unsigned long index;
 	const struct ccs_path_info *value;
 	bool is_not;
 };
@@ -1248,7 +1259,7 @@
 /* Structure for "ipc signal" directive. */
 struct ccs_signal_acl {
 	struct ccs_acl_info head; /* type = CCS_TYPE_SIGNAL_ACL */
-	u16 sig;
+	struct ccs_number_union sig;
 	/* Pointer to destination pattern. */
 	const struct ccs_path_info *domainname;
 };
@@ -1264,32 +1275,7 @@
 	struct ccs_acl_info head; /* type = CCS_TYPE_INET_ACL */
 	u8 protocol;
 	u8 perm; /* Bitmask of values in "enum ccs_network_acl_index" */
-	/*
-	 * address_type takes one of the following constants.
-	 *   CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP
-	 *                if @address points to "address_group" directive.
-	 *   CCS_IP_ADDRESS_TYPE_IPv4
-	 *                if @address points to an IPv4 address.
-	 *   CCS_IP_ADDRESS_TYPE_IPv6
-	 *                if @address points to an IPv6 address.
-	 */
-	u8 address_type;
-	union {
-		struct {
-			/* Start of IPv4 address range. Host endian. */
-			u32 min;
-			/* End of IPv4 address range. Host endian.   */
-			u32 max;
-		} ipv4;
-		struct {
-			/* Start of IPv6 address range. Big endian.  */
-			const struct in6_addr *min;
-			/* End of IPv6 address range. Big endian.    */
-			const struct in6_addr *max;
-		} ipv6;
-		/* Pointer to address group. */
-		struct ccs_group *group;
-	} address;
+	struct ccs_ipaddr_union address;
 	struct ccs_number_union port;
 };
 
@@ -1310,8 +1296,13 @@
 
 /* Structure for holding a line from /proc/ccs/ interface. */
 struct ccs_acl_param {
+	/* Unprocessed data. */
 	char *data;
-	struct ccs_domain_info *domain;
+	/* Pointer to "struct list_head" or "struct list_head[2]" */
+	struct list_head *list;
+	/* Namespace to use. */
+	struct ccs_policy_namespace *ns;
+	/* True if it is a delete request. */
 	bool is_delete;
 };
 
@@ -1325,6 +1316,7 @@
 	char __user *read_user_buf;
 	size_t read_user_buf_avail;
 	struct {
+		struct list_head *ns;
 		struct list_head *domain;
 		struct list_head *group;
 		struct list_head *acl;
@@ -1344,8 +1336,10 @@
 		const char *w[CCS_MAX_IO_READ_QUEUE];
 	} r;
 	struct {
+		struct ccs_policy_namespace *ns;
 		struct ccs_domain_info *domain;
 		size_t avail;
+		bool is_delete;
 	} w;
 	/* Buffer for reading.                  */
 	char *read_buf;
@@ -1355,6 +1349,8 @@
 	char *write_buf;
 	/* Size of write buffer.                */
 	size_t writebuf_size;
+	/* Namespace as of open(). */
+	struct ccs_policy_namespace *original_ns;
 	/* Type of interface. */
 	enum ccs_proc_interface_index type;
 	/* Users counter protected by ccs_io_buffer_list_lock. */
@@ -1381,6 +1377,22 @@
 	u8 sec;
 };
 
+/* Structure for policy namespace. */
+struct ccs_policy_namespace {
+	/* Profile table. Memory is allocated as needed. */
+	struct ccs_profile *profile_ptr[CCS_MAX_PROFILES];
+	/* List of "struct ccs_group". */
+	struct list_head group_list[CCS_MAX_GROUP];
+	/* List of policy. */
+	struct list_head policy_list[CCS_MAX_POLICY];
+	/* The global ACL referred by "use_group" keyword. */
+	struct list_head acl_group[CCS_MAX_ACL_GROUPS][2];
+	/* List for connecting to ccs_namespace_list list. */
+	struct list_head namespace_list;
+	/* Name of this namespace (e.g. "<kernel>", "</usr/sbin/httpd>" ). */
+	const char *name;
+};
+
 /* Prototype definition for "struct ccsecurity_operations". */
 
 void __init ccs_capability_init(void);
@@ -1410,21 +1422,24 @@
 bool ccs_memory_ok(const void *ptr, const unsigned int size);
 bool ccs_number_matches_group(const unsigned long min, const unsigned long max,
 			      const struct ccs_group *group);
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr);
-bool ccs_parse_number_union(char *data, struct ccs_number_union *num);
+bool ccs_parse_ipaddr_union(struct ccs_acl_param *param,
+			    struct ccs_ipaddr_union *ptr);
+bool ccs_parse_name_union(struct ccs_acl_param *param,
+			  struct ccs_name_union *ptr);
+bool ccs_parse_number_union(struct ccs_acl_param *param,
+			    struct ccs_number_union *ptr);
 bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 			      const struct ccs_path_info *pattern);
 bool ccs_permstr(const char *string, const char *keyword);
 bool ccs_str_starts(char **src, const char *find);
-bool ccs_tokenize(char *buffer, char *w[], size_t size);
 char *ccs_encode(const char *str);
 char *ccs_encode2(const char *str, int str_len);
 char *ccs_init_log(struct ccs_request_info *r, int len, const char *fmt,
 		   va_list args);
 char *ccs_read_token(struct ccs_acl_param *param);
 char *ccs_realpath_from_path(struct path *path);
+const char *ccs_get_exe(void);
 const char *ccs_yesno(const unsigned int value);
-const char *ccs_get_exe(void);
 const struct ccs_path_info *ccs_compare_name_union
 (const struct ccs_path_info *name, const struct ccs_name_union *ptr);
 const struct ccs_path_info *ccs_get_domainname(struct ccs_acl_param *param);
@@ -1437,7 +1452,7 @@
 int ccs_get_path(const char *pathname, struct path *path);
 int ccs_init_request_info(struct ccs_request_info *r, const u8 index);
 int ccs_open_control(const u8 type, struct file *file);
-int ccs_parse_ip_address(char *address, u16 *min, u16 *max);
+int ccs_parse_ip_address(struct ccs_acl_param *param, u16 *min, u16 *max);
 int ccs_path_permission(struct ccs_request_info *r, u8 operation,
 			const struct ccs_path_info *filename);
 int ccs_poll_control(struct file *file, poll_table *wait);
@@ -1453,30 +1468,29 @@
 					       struct ccs_acl_info *,
 					       const bool));
 int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      bool is_delete, struct list_head *list,
+		      struct ccs_acl_param *param,
 		      bool (*check_duplicate) (const struct ccs_acl_head *,
 					       const struct ccs_acl_head *));
-int ccs_write_aggregator(char *data, const bool is_delete);
+int ccs_write_aggregator(struct ccs_acl_param *param);
 int ccs_write_capability(struct ccs_acl_param *param);
 int ccs_write_file(struct ccs_acl_param *param);
-int ccs_write_group(char *data, const bool is_delete, const u8 type);
+int ccs_write_group(struct ccs_acl_param *param, const u8 type);
 int ccs_write_inet_network(struct ccs_acl_param *param);
 int ccs_write_ipc(struct ccs_acl_param *param);
 int ccs_write_misc(struct ccs_acl_param *param);
-int ccs_write_reserved_port(char *data, const bool is_delete);
-int ccs_write_transition_control(char *data, const bool is_delete,
-				 const u8 type);
+int ccs_write_reserved_port(struct ccs_acl_param *param);
+int ccs_write_transition_control(struct ccs_acl_param *param, const u8 type);
 int ccs_write_unix_network(struct ccs_acl_param *param);
 ssize_t ccs_read_control(struct file *file, char __user *buffer,
 			 const size_t buffer_len);
 ssize_t ccs_write_control(struct file *file, const char __user *buffer,
 			  const size_t buffer_len);
-struct ccs_condition *ccs_get_condition(char *condition);
+struct ccs_condition *ccs_get_condition(struct ccs_acl_param *param);
 struct ccs_domain_info *ccs_assign_domain(const char *domainname,
-					  const u8 profile, const u8 group,
 					  const bool transit);
 struct ccs_domain_info *ccs_find_domain(const char *domainname);
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx);
+struct ccs_group *ccs_get_group(struct ccs_acl_param *param, const u8 idx);
+struct ccs_policy_namespace *ccs_assign_namespace(const char *domainname);
 struct ccs_profile *ccs_profile(const u8 profile);
 u8 ccs_get_config(const u8 profile, const u8 index);
 u8 ccs_parse_ulong(unsigned long *result, char **str);
@@ -1488,14 +1502,12 @@
 void ccs_del_condition(struct list_head *element);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
 void ccs_get_attributes(struct ccs_obj_info *obj);
+void ccs_init_policy_namespace(struct ccs_policy_namespace *ns);
 void ccs_memory_free(const void *ptr, size_t size);
 void ccs_normalize_line(unsigned char *buffer);
 void ccs_notify_gc(struct ccs_io_buffer *head, const bool is_register);
-void ccs_print_ipv4(char *buffer, const int buffer_len, const u32 min_ip,
-		    const u32 max_ip);
-void ccs_print_ipv6(char *buffer, const int buffer_len,
-		    const struct in6_addr *min_ip,
-		    const struct in6_addr *max_ip);
+void ccs_print_ip(char *buf, const unsigned int size,
+		  const struct ccs_ipaddr_union *ptr);
 void ccs_print_ulong(char *buffer, const int buffer_len,
 		     const unsigned long value, const u8 type);
 void ccs_put_name_union(struct ccs_name_union *ptr);
@@ -1528,12 +1540,12 @@
 extern const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION];
 extern const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION];
 extern const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION];
-extern struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
 extern struct ccs_domain_info ccs_kernel_domain;
+extern struct ccs_policy_namespace ccs_kernel_namespace;
 extern struct list_head ccs_domain_list;
-extern struct list_head ccs_group_list[CCS_MAX_GROUP];
+extern struct list_head ccs_manager_list;
 extern struct list_head ccs_name_list[CCS_MAX_HASH];
-extern struct list_head ccs_policy_list[CCS_MAX_POLICY];
+extern struct list_head ccs_namespace_list;
 extern struct list_head ccs_shared_list[CCS_MAX_LIST];
 extern struct mutex ccs_policy_lock;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
@@ -1591,6 +1603,22 @@
 		a->is_group == b->is_group;
 }
 
+/**
+ * ccs_same_ipaddr_union - Check for duplicated "struct ccs_ipaddr_union" entry.
+ *
+ * @a: Pointer to "struct ccs_ipaddr_union".
+ * @b: Pointer to "struct ccs_ipaddr_union".
+ *
+ * Returns true if @a == @b, false otherwise.
+ */
+static inline bool ccs_same_ipaddr_union(const struct ccs_ipaddr_union *a,
+					 const struct ccs_ipaddr_union *b)
+{
+	return a->ipv4.min == b->ipv4.min && a->ipv4.max == b->ipv4.max &&
+		a->ipv6.min == b->ipv6.min && a->ipv6.max == b->ipv6.max &&
+		a->group == b->group;
+}
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
 
 /**
@@ -2045,8 +2073,8 @@
  * Returns pointer to "struct ccs_domain_info" for current thread.
  *
  * If current thread does not belong to a domain (which is true for initial
- * init_task in order to hide ccs_kernel_domain from this module), current
- * thread enters into ccs_kernel_domain.
+ * init_task in order to hide ccs_kernel_domain from this module),
+ * current thread enters into ccs_kernel_domain.
  */
 static inline struct ccs_domain_info *ccs_current_domain(void)
 {
@@ -2080,4 +2108,9 @@
 
 #endif
 
+static inline struct ccs_policy_namespace *ccs_current_namespace(void)
+{
+	return ccs_current_domain()->ns;
+}
+
 #endif
Index: security/ccsecurity/condition.c
===================================================================
--- security/ccsecurity/condition.c	(revision 5044)
+++ security/ccsecurity/condition.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1   2011/04/01
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -277,16 +277,17 @@
 /**
  * ccs_parse_name_union_quoted - Parse a quoted word.
  *
- * @filename: A line containing a quoted word.
- * @ptr:      Pointer to "struct ccs_name_union".
+ * @param: Pointer to "struct ccs_acl_param".
+ * @ptr:   Pointer to "struct ccs_name_union".
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_parse_name_union_quoted(char *filename,
+static bool ccs_parse_name_union_quoted(struct ccs_acl_param *param,
 					struct ccs_name_union *ptr)
 {
+	char *filename = param->data;
 	if (*filename == '@')
-		return ccs_parse_name_union(filename, ptr);
+		return ccs_parse_name_union(param, ptr);
 	ptr->is_group = false;
 	ptr->filename = ccs_get_dqword(filename);
 	return ptr->filename != NULL;
@@ -295,89 +296,53 @@
 /**
  * ccs_parse_argv - Parse an argv[] condition part.
  *
- * @start: String to parse.
+ * @left:  Lefthand value.
+ * @right: Righthand value.
  * @argv:  Pointer to "struct ccs_argv".
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_parse_argv(char *start, struct ccs_argv *argv)
+static bool ccs_parse_argv(char *left, char *right, struct ccs_argv *argv)
 {
-	unsigned long index;
-	const struct ccs_path_info *value;
-	bool is_not;
-	char c;
-	if (ccs_parse_ulong(&index, &start) != CCS_VALUE_TYPE_DECIMAL)
-		goto out;
-	if (*start++ != ']')
-		goto out;
-	c = *start++;
-	if (c == '=')
-		is_not = false;
-	else if (c == '!' && *start++ == '=')
-		is_not = true;
-	else
-		goto out;
-	value = ccs_get_dqword(start);
-	if (!value)
-		goto out;
-	argv->index = index;
-	argv->is_not = is_not;
-	argv->value = value;
-	return true;
-out:
-	return false;
+	if (ccs_parse_ulong(&argv->index, &left) != CCS_VALUE_TYPE_DECIMAL ||
+	    *left++ != ']' || *left)
+		return false;
+	argv->value = ccs_get_dqword(right);
+	return argv->value != NULL;
 }
 
 /**
  * ccs_parse_envp - Parse an envp[] condition part.
  *
- * @start: String to parse.
+ * @left:  Lefthand value.
+ * @right: Righthand value.
  * @envp:  Pointer to "struct ccs_envp".
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_parse_envp(char *start, struct ccs_envp *envp)
+static bool ccs_parse_envp(char *left, char *right, struct ccs_envp *envp)
 {
 	const struct ccs_path_info *name;
 	const struct ccs_path_info *value;
-	bool is_not;
-	char *cp = start;
-	/*
-	 * Since environment variable names don't
-	 * contain '=', I can treat '"]=' and '"]!='
-	 * sequences as delimiters.
-	 */
-	while (1) {
-		if (!strncmp(start, "\"]=", 3)) {
-			is_not = false;
-			*start = '\0';
-			start += 3;
-			break;
-		} else if (!strncmp(start, "\"]!=", 4)) {
-			is_not = true;
-			*start = '\0';
-			start += 4;
-			break;
-		} else if (!*start++) {
-			goto out;
-		}
-	}
-	if (!ccs_correct_word(cp))
+	char *cp = left + strlen(left) - 1;
+	if (*cp-- != ']' || *cp != '"')
 		goto out;
-	name = ccs_get_name(cp);
+	*cp = '\0';
+	if (!ccs_correct_word(left))
+		goto out;
+	name = ccs_get_name(left);
 	if (!name)
 		goto out;
-	if (!strcmp(start, "NULL")) {
+	if (!strcmp(right, "NULL")) {
 		value = NULL;
 	} else {
-		value = ccs_get_dqword(start);
+		value = ccs_get_dqword(right);
 		if (!value) {
 			ccs_put_name(name);
 			goto out;
 		}
 	}
 	envp->name = name;
-	envp->is_not = is_not;
 	envp->value = value;
 	return true;
 out:
@@ -482,13 +447,12 @@
 /**
  * ccs_get_condition - Parse condition part.
  *
- * @condition: Pointer to string to parse.
+ * @param: Pointer to "struct ccs_acl_param".
  *
  * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
  */
-struct ccs_condition *ccs_get_condition(char *condition)
+struct ccs_condition *ccs_get_condition(struct ccs_acl_param *param)
 {
-	char *start;
 	struct ccs_condition *entry = NULL;
 	struct ccs_condition_element *condp = NULL;
 	struct ccs_number_union *numbers_p = NULL;
@@ -497,52 +461,80 @@
 	struct ccs_envp *envp = NULL;
 	struct ccs_condition e = { };
 	bool dry_run = true;
-	char *end_of_string = condition + strlen(condition);
+	char * const start_of_string = param->data;
+	char * const end_of_string = start_of_string + strlen(start_of_string);
+	char *pos;
 rerun:
-	start = condition;
+	pos = start_of_string;
 	while (1) {
 		u8 left = -1;
 		u8 right = -1;
-		char *word = start;
+		char *left_word = pos;
 		char *cp;
-		char *eq;
-		bool is_not = false;
-		if (!*word)
+		char *right_word;
+		bool is_not;
+		if (!*left_word)
 			break;
-		cp = strchr(start, ' ');
+		/*
+		 * Since left-hand condition does not allow use of "path_group"
+		 * or "number_group" and environment variable's names do not
+		 * accept '=', it is guaranteed that the original line consists
+		 * of one or more repetition of $left$operator$right blocks
+		 * where "$left is free from '=' and ' '" and "$operator is
+		 * either '=' or '!='" and "$right is free from ' '".
+		 * Therefore, we can reconstruct the original line at the end
+		 * of dry run even if we overwrite $operator with '\0'.
+		 */
+		cp = strchr(pos, ' ');
 		if (cp) {
-			*cp = '\0';
-			start = cp + 1;
+			*cp = '\0'; /* Will restore later. */
+			pos = cp + 1;
 		} else {
-			start = "";
+			pos = "";
 		}
-		dprintk(KERN_WARNING "%u: <%s>\n", __LINE__, word);
-		if (!strncmp(word, "grant_log=", 10)) {
+		right_word = strchr(left_word, '=');
+		if (!right_word || right_word == left_word)
+			goto out;
+		is_not = *(right_word - 1) == '!';
+		if (is_not)
+			*(right_word++ - 1) = '\0'; /* Will restore later. */
+		else
+			*right_word++ = '\0'; /* Will restore later. */
+		dprintk(KERN_WARNING "%u: <%s>%s=<%s>\n", __LINE__, left_word,
+			is_not ? "!" : "", right_word);
+		if (!strcmp(left_word, "grant_log")) {
 			if (!dry_run) {
-				word += 10;
 				if (entry->grant_log != CCS_GRANTLOG_AUTO)
 					goto out;
-				else if (!strcmp(word, "yes"))
+				else if (!strcmp(right_word, "yes"))
 					entry->grant_log = CCS_GRANTLOG_YES;
-				else if (!strcmp(word, "no"))
+				else if (!strcmp(right_word, "no"))
 					entry->grant_log = CCS_GRANTLOG_NO;
 				else
 					goto out;
 			}
 			continue;
-		} else if (!strncmp(word, "auto_domain_transition=", 23)) {
+		} else if (!strcmp(left_word, "auto_domain_transition")) {
 			if (!dry_run) {
-				word += 23;
-				if (entry->transit)
+				if (entry->transit || *right_word != '/')
 					goto out;
-				entry->transit = ccs_get_dqword(word);
-				if (!entry->transit ||
-				    entry->transit->name[0] != '/')
+				entry->transit = ccs_get_dqword(right_word);
+				if (!entry->transit)
 					goto out;
 			}
 			continue;
+		} else if (!strcmp(left_word, "auto_namespace_transition")) {
+			if (!dry_run) {
+				if (entry->transit ||
+				    !ccs_domain_def(right_word))
+					goto out;
+				entry->transit = ccs_get_dqword(right_word);
+				if (!entry->transit)
+					goto out;
+			}
+			continue;
 		}
-		if (!strncmp(word, "exec.argv[", 10)) {
+		if (!strncmp(left_word, "exec.argv[", 10)) {
 			if (dry_run) {
 				e.argc++;
 				e.condc++;
@@ -550,11 +542,14 @@
 				e.argc--;
 				e.condc--;
 				left = CCS_ARGV_ENTRY;
-				if (!ccs_parse_argv(word + 10, argv++))
+				argv->is_not = is_not;
+				if (!ccs_parse_argv(left_word + 10,
+						    right_word, argv++))
 					goto out;
+				
 			}
 			goto store_value;
-		} else if (!strncmp(word, "exec.envp[\"", 11)) {
+		} else if (!strncmp(left_word, "exec.envp[\"", 11)) {
 			if (dry_run) {
 				e.envc++;
 				e.condc++;
@@ -562,21 +557,15 @@
 				e.envc--;
 				e.condc--;
 				left = CCS_ENVP_ENTRY;
-				if (!ccs_parse_envp(word + 11, envp++))
+				envp->is_not = is_not;
+				if (!ccs_parse_envp(left_word + 11,
+						    right_word, envp++))
 					goto out;
 			}
 			goto store_value;
 		}
-		eq = strchr(word, '=');
-		if (!eq)
-			goto out;
-		if (eq > word && *(eq - 1) == '!') {
-			is_not = true;
-			eq--;
-		}
-		*eq = '\0';
-		left = ccs_condition_type(word);
-		dprintk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__, word,
+		left = ccs_condition_type(left_word);
+		dprintk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__, left_word,
 			left);
 		if (left == CCS_MAX_CONDITION_KEYWORD) {
 			if (dry_run) {
@@ -584,17 +573,13 @@
 			} else {
 				e.numbers_count--;
 				left = CCS_NUMBER_UNION;
-				if (!ccs_parse_number_union(word, numbers_p))
+				param->data = left_word;
+				if (*left_word == '@' ||
+				    !ccs_parse_number_union(param,
+							    numbers_p++))
 					goto out;
-				if (numbers_p->is_group)
-					goto out;
-				numbers_p++;
 			}
 		}
-		*eq = is_not ? '!' : '=';
-		word = eq + 1;
-		if (is_not)
-			word++;
 		if (dry_run)
 			e.condc++;
 		else
@@ -605,26 +590,32 @@
 			} else {
 				e.names_count--;
 				right = CCS_NAME_UNION;
-				if (!ccs_parse_name_union_quoted(word,
+				param->data = right_word;
+				if (!ccs_parse_name_union_quoted(param,
 								 names_p++))
 					goto out;
 			}
 			goto store_value;
 		}
-		right = ccs_condition_type(word);
+		right = ccs_condition_type(right_word);
 		if (right == CCS_MAX_CONDITION_KEYWORD) {
 			if (dry_run) {
 				e.numbers_count++;
 			} else {
 				e.numbers_count--;
 				right = CCS_NUMBER_UNION;
-				if (!ccs_parse_number_union(word, numbers_p++))
+				param->data = right_word;
+				if (!ccs_parse_number_union(param,
+							    numbers_p++))
 					goto out;
 			}
 		}
 store_value:
-		if (dry_run)
+		if (dry_run) {
+			dprintk(KERN_WARNING "%u: dry_run left=%u right=%u "
+				"match=%u\n", __LINE__, left, right, !is_not);
 			continue;
+		}
 		condp->left = left;
 		condp->right = right;
 		condp->equals = !is_not;
@@ -656,9 +647,20 @@
 	names_p = (struct ccs_name_union *) (numbers_p + e.numbers_count);
 	argv = (struct ccs_argv *) (names_p + e.names_count);
 	envp = (struct ccs_envp *) (argv + e.argc);
-	for (start = condition; start < end_of_string; start++)
-		if (!*start)
-			*start = ' ';
+	{
+		bool flag = false;
+		for (pos = start_of_string; pos < end_of_string; pos++) {
+			if (*pos)
+				continue;
+			if (flag) /* Restore " ". */
+				*pos = ' ';
+			else if (*(pos + 1) == '=') /* Restore "!=". */
+				*pos = '!';
+			else /* Restore "=". */
+				*pos = '=';
+			flag = !flag;
+		}
+	}
 	dry_run = false;
 	goto rerun;
 out:
Index: security/ccsecurity/policy_io.c
===================================================================
--- security/ccsecurity/policy_io.c	(revision 5044)
+++ security/ccsecurity/policy_io.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1+   2011/05/11
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -83,9 +83,6 @@
 /* Profile version. Currently only 20100903 is defined. */
 static unsigned int ccs_profile_version;
 
-/* Profile table. Memory is allocated as needed. */
-static struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
-
 /* String table for operation mode. */
 const char * const ccs_mode[CCS_CONFIG_MAX_MODE] = {
 	[CCS_CONFIG_DISABLED]   = "disabled",
@@ -430,26 +427,72 @@
 	ccs_set_string(head, "/");
 }
 
+/* List of namespaces. */
+LIST_HEAD(ccs_namespace_list);
+/* True if namespace other than ccs_kernel_namespace is defined. */
+static bool ccs_namespace_enabled;
+
 /**
+ * ccs_init_policy_namespace - Initialize namespace.
+ *
+ * @ns: Pointer to "struct ccs_policy_namespace".
+ *
+ * Returns nothing.
+ */
+void ccs_init_policy_namespace(struct ccs_policy_namespace *ns)
+{
+	unsigned int idx;
+	for (idx = 0; idx < CCS_MAX_ACL_GROUPS; idx++) {
+		INIT_LIST_HEAD(&ns->acl_group[idx][0]);
+		INIT_LIST_HEAD(&ns->acl_group[idx][1]);
+	}
+	for (idx = 0; idx < CCS_MAX_GROUP; idx++)
+		INIT_LIST_HEAD(&ns->group_list[idx]);
+	for (idx = 0; idx < CCS_MAX_POLICY; idx++)
+		INIT_LIST_HEAD(&ns->policy_list[idx]);
+	ccs_namespace_enabled = !list_empty(&ccs_namespace_list);
+	list_add_tail_rcu(&ns->namespace_list, &ccs_namespace_list);
+}
+
+/**
+ * ccs_print_namespace - Print namespace header.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ */
+static void ccs_print_namespace(struct ccs_io_buffer *head)
+{
+	if (!ccs_namespace_enabled)
+		return;
+	ccs_set_string(head,
+		       container_of(head->r.ns, struct ccs_policy_namespace,
+				    namespace_list)->name);
+	ccs_set_space(head);
+}
+
+/**
  * ccs_assign_profile - Create a new profile.
  *
+ * @ns:      Pointer to "struct ccs_policy_namespace".
  * @profile: Profile number to create.
  *
  * Returns pointer to "struct ccs_profile" on success, NULL otherwise.
  */
-static struct ccs_profile *ccs_assign_profile(const unsigned int profile)
+static struct ccs_profile *ccs_assign_profile(struct ccs_policy_namespace *ns,
+					      const unsigned int profile)
 {
 	struct ccs_profile *ptr;
 	struct ccs_profile *entry;
 	if (profile >= CCS_MAX_PROFILES)
 		return NULL;
-	ptr = ccs_profile_ptr[profile];
+	ptr = ns->profile_ptr[profile];
 	if (ptr)
 		return ptr;
 	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	ptr = ccs_profile_ptr[profile];
+	ptr = ns->profile_ptr[profile];
 	if (!ptr && ccs_memory_ok(entry, sizeof(*entry))) {
 		ptr = entry;
 		ptr->default_config = CCS_CONFIG_DISABLED |
@@ -461,7 +504,7 @@
 		ptr->pref[CCS_PREF_MAX_LEARNING_ENTRY] =
 			CONFIG_CCSECURITY_MAX_ACCEPT_ENTRY;
 		mb(); /* Avoid out-of-order execution. */
-		ccs_profile_ptr[profile] = ptr;
+		ns->profile_ptr[profile] = ptr;
 		entry = NULL;
 	}
 	mutex_unlock(&ccs_policy_lock);
@@ -482,7 +525,7 @@
 	ccs_policy_loaded = true;
 	list_for_each_entry_srcu(domain, &ccs_domain_list, list, &ccs_ss) {
 		const u8 profile = domain->profile;
-		if (ccs_profile_ptr[profile])
+		if (domain->ns->profile_ptr[profile])
 			continue;
 		printk(KERN_ERR "Profile %u must be defined before using it.\n",
 		       profile);
@@ -491,7 +534,6 @@
 		panic("Profile %u (used by '%s') not defined.\n",
 		      profile, domain->domainname->name);
 	}
-	ccs_read_unlock(idx);
 	if (ccs_profile_version != 20100903) {
 		printk(KERN_ERR "Userland tools must be installed for "
 		       "TOMOYO 1.8, and policy must be initialized.\n");
@@ -500,7 +542,8 @@
 		panic("Profile version %u is not supported.\n",
 		      ccs_profile_version);
 	}
-	printk(KERN_INFO "CCSecurity: 1.8.1+   2011/05/11\n");
+	ccs_read_unlock(idx);
+	printk(KERN_INFO "CCSecurity: 1.8.2-pre   2011/05/22\n");
 	printk(KERN_INFO "Mandatory Access Control activated.\n");
 }
 
@@ -514,7 +557,8 @@
 struct ccs_profile *ccs_profile(const u8 profile)
 {
 	static struct ccs_profile ccs_null_profile;
-	struct ccs_profile *ptr = ccs_profile_ptr[profile];
+	struct ccs_profile *ptr = ccs_current_namespace()->
+		profile_ptr[profile];
 	if (!ptr)
 		ptr = &ccs_null_profile;
 	return ptr;
@@ -654,7 +698,7 @@
 	if (*cp != '-')
 		return -EINVAL;
 	data = cp + 1;
-	profile = ccs_assign_profile(i);
+	profile = ccs_assign_profile(head->w.ns, i);
 	if (!profile)
 		return -EINVAL;
 	cp = strchr(data, '=');
@@ -711,31 +755,39 @@
 static void ccs_read_profile(struct ccs_io_buffer *head)
 {
 	u8 index;
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
 	const struct ccs_profile *profile;
+	if (head->r.eof)
+		return;
 next:
 	index = head->r.index;
-	profile = ccs_profile_ptr[index];
+	profile = ns->profile_ptr[index];
 	switch (head->r.step) {
 	case 0:
+		ccs_print_namespace(head);
 		ccs_io_printf(head, "PROFILE_VERSION=%u\n", 20100903);
 		head->r.step++;
 		break;
 	case 1:
-		for ( ; head->r.index < CCS_MAX_PROFILES;
-		      head->r.index++)
-			if (ccs_profile_ptr[head->r.index])
+		for ( ; head->r.index < CCS_MAX_PROFILES; head->r.index++)
+			if (ns->profile_ptr[head->r.index])
 				break;
-		if (head->r.index == CCS_MAX_PROFILES)
+		if (head->r.index == CCS_MAX_PROFILES) {
+			head->r.eof = true;
 			return;
+		}
 		head->r.step++;
 		break;
 	case 2:
 		{
 			u8 i;
 			const struct ccs_path_info *comment = profile->comment;
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-COMMENT=", index);
 			ccs_set_string(head, comment ? comment->name : "");
 			ccs_set_lf(head);
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-PREFERENCE={ ", index);
 			for (i = 0; i < CCS_MAX_PREF; i++)
 				ccs_io_printf(head, "%s=%u ",
@@ -747,6 +799,7 @@
 		break;
 	case 3:
 		{
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-%s", index, "CONFIG");
 			ccs_print_config(head, profile->default_config);
 			head->r.bit = 0;
@@ -760,6 +813,7 @@
 			const u8 config = profile->config[i];
 			if (config == CCS_CONFIG_USE_DEFAULT)
 				continue;
+			ccs_print_namespace(head);
 			if (i < CCS_MAX_MAC_INDEX)
 				ccs_io_printf(head, "%u-CONFIG::%s::%s", index,
 					      ccs_category_keywords
@@ -806,9 +860,15 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_manager_entry(const char *manager, const bool is_delete)
+static inline int ccs_update_manager_entry(const char *manager,
+					   const bool is_delete)
 {
 	struct ccs_manager e = { };
+	struct ccs_acl_param param = {
+		/* .ns = &ccs_kernel_namespace, */
+		.is_delete = is_delete,
+		.list = &ccs_kernel_namespace.policy_list[CCS_ID_MANAGER],
+	};
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (ccs_domain_def(manager)) {
 		if (!ccs_correct_domain(manager))
@@ -819,12 +879,11 @@
 			return -EINVAL;
 	}
 	e.manager = ccs_get_name(manager);
-	if (!e.manager)
-		return error;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_MANAGER],
-				  ccs_same_manager);
-	ccs_put_name(e.manager);
+	if (e.manager) {
+		error = ccs_update_policy(&e.head, sizeof(e), &param,
+					  ccs_same_manager);
+		ccs_put_name(e.manager);
+	}
 	return error;
 }
 
@@ -837,13 +896,12 @@
  */
 static int ccs_write_manager(struct ccs_io_buffer *head)
 {
-	char *data = head->write_buf;
-	bool is_delete = ccs_str_starts(&data, "delete ");
+	const char *data = head->write_buf;
 	if (!strcmp(data, "manage_by_non_root")) {
-		ccs_manage_by_non_root = !is_delete;
+		ccs_manage_by_non_root = !head->w.is_delete;
 		return 0;
 	}
-	return ccs_update_manager_entry(data, is_delete);
+	return ccs_update_manager_entry(data, head->w.is_delete);
 }
 
 /**
@@ -859,7 +917,8 @@
 {
 	if (head->r.eof)
 		return;
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[CCS_ID_MANAGER]) {
+	list_for_each_cookie(head->r.acl, &ccs_kernel_namespace.
+			     policy_list[CCS_ID_MANAGER]) {
 		struct ccs_manager *ptr =
 			list_entry(head->r.acl, typeof(*ptr), head.list);
 		if (ptr->head.is_deleted)
@@ -895,8 +954,9 @@
 	if (!ccs_manage_by_non_root && (current_uid() || current_euid()))
 		return false;
 	exe = ccs_get_exe();
-	list_for_each_entry_srcu(ptr, &ccs_policy_list[CCS_ID_MANAGER],
-				 head.list, &ccs_ss) {
+	list_for_each_entry_srcu(ptr, &ccs_kernel_namespace.
+				 policy_list[CCS_ID_MANAGER], head.list,
+				 &ccs_ss) {
 		if (ptr->head.is_deleted)
 			continue;
 		if (ptr->is_domain) {
@@ -925,7 +985,7 @@
 }
 
 /**
- * ccs_select_one - Parse select command.
+ * ccs_select_domain - Parse select command.
  *
  * @head: Pointer to "struct ccs_io_buffer".
  * @data: String to parse.
@@ -934,15 +994,14 @@
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_select_one(struct ccs_io_buffer *head, const char *data)
+static bool ccs_select_domain(struct ccs_io_buffer *head, const char *data)
 {
 	unsigned int pid;
 	struct ccs_domain_info *domain = NULL;
 	bool global_pid = false;
-	if (!strcmp(data, "transition_only")) {
-		head->r.print_transition_related_only = true;
-		return true;
-	}
+	if (strncmp(data, "select ", 7))
+		return false;
+	data += 7;
 	if (sscanf(data, "pid=%u", &pid) == 1 ||
 	    (global_pid = true, sscanf(data, "global-pid=%u", &pid) == 1)) {
 		struct task_struct *p;
@@ -960,7 +1019,7 @@
 			domain = ccs_task_domain(p);
 		ccs_tasklist_unlock();
 	} else if (!strncmp(data, "domain=", 7)) {
-		if (ccs_domain_def(data + 7))
+		if (*(data + 7) == '<')
 			domain = ccs_find_domain(data + 7);
 	} else
 		return false;
@@ -1068,20 +1127,23 @@
 /**
  * ccs_write_domain2 - Write domain policy.
  *
+ * @ns:        Pointer to "struct ccs_policy_namespace".
+ * @list:      Pointer to "struct list_head [2]".
  * @data:      Policy to be interpreted.
- * @domain:    Pointer to "struct ccs_domain_info".
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_write_domain2(char *data, struct ccs_domain_info *domain,
+static int ccs_write_domain2(struct ccs_policy_namespace *ns,
+			     struct list_head list[2], char *data,
 			     const bool is_delete)
 {
 	struct ccs_acl_param param = {
+		.ns = ns,
+		.list = list,
 		.data = data,
-		.domain = domain,
 		.is_delete = is_delete,
 	};
 	static const struct {
@@ -1093,7 +1155,7 @@
 		{ "network unix ", ccs_write_unix_network },
 		{ "misc ", ccs_write_misc },
 		{ "capability ", ccs_write_capability },
-		{ "ipc ", ccs_write_ipc },
+		{ "ipc signal ", ccs_write_ipc },
 		{ "task ", ccs_write_task },
 	};
 	u8 i;
@@ -1153,36 +1215,28 @@
 static int ccs_write_domain(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
+	struct ccs_policy_namespace *ns;
 	struct ccs_domain_info *domain = head->w.domain;
-	bool is_delete = false;
-	bool is_select = false;
+	const bool is_delete = head->w.is_delete;
+	const bool is_select = !is_delete && ccs_str_starts(&data, "select ");
 	unsigned int profile;
-	if (ccs_str_starts(&data, "delete "))
-		is_delete = true;
-	else if (ccs_str_starts(&data, "select "))
-		is_select = true;
-	if (is_select && ccs_select_one(head, data))
-		return -EAGAIN;
-	/* Don't allow updating policies by non manager programs. */
-	if (!ccs_manager())
-		return -EPERM;
-	if (ccs_domain_def(data)) {
+	if (*data == '<') {
 		domain = NULL;
 		if (is_delete)
 			ccs_delete_domain(data);
 		else if (is_select)
 			domain = ccs_find_domain(data);
 		else
-			domain = ccs_assign_domain(data, 0, 0, false);
+			domain = ccs_assign_domain(data, false);
 		head->w.domain = domain;
 		return 0;
 	}
 	if (!domain)
 		return -EINVAL;
-
+	ns = domain->ns;
 	if (sscanf(data, "use_profile %u\n", &profile) == 1
 	    && profile < CCS_MAX_PROFILES) {
-		if (!ccs_policy_loaded || ccs_profile_ptr[(u8) profile])
+		if (!ccs_policy_loaded || ns->profile_ptr[(u8) profile])
 			if (!is_delete)
 				domain->profile = (u8) profile;
 		return 0;
@@ -1200,7 +1254,7 @@
 		domain->flags[profile] = !is_delete;
 		return 0;
 	}
-	return ccs_write_domain2(data, domain, is_delete);
+	return ccs_write_domain2(ns, domain->acl_info_list, data, is_delete);
 }
 
 /**
@@ -1214,34 +1268,47 @@
 static void ccs_print_name_union(struct ccs_io_buffer *head,
 				 const struct ccs_name_union *ptr)
 {
-	const bool cond = head->r.print_cond_part;
-	if (!cond)
-		ccs_set_space(head);
+	ccs_set_space(head);
 	if (ptr->is_group) {
 		ccs_set_string(head, "@");
 		ccs_set_string(head, ptr->group->group_name->name);
 	} else {
-		if (cond)
-			ccs_set_string(head, "\"");
 		ccs_set_string(head, ptr->filename->name);
-		if (cond)
-			ccs_set_string(head, "\"");
 	}
 }
 
 /**
- * ccs_print_number_union - Print a ccs_number_union.
+ * ccs_print_name_union_quoted - Print a ccs_name_union with a quote.
  *
  * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ccs_name_union".
+ *
+ * Returns nothing.
+ */
+static void ccs_print_name_union_quoted(struct ccs_io_buffer *head,
+					const struct ccs_name_union *ptr)
+{
+	if (ptr->is_group) {
+		ccs_set_string(head, "@");
+		ccs_set_string(head, ptr->group->group_name->name);
+	} else {
+		ccs_set_string(head, "\"");
+		ccs_set_string(head, ptr->filename->name);
+		ccs_set_string(head, "\"");
+	}
+}
+
+/**
+ * ccs_print_number_union_nospace - Print a ccs_number_union without a space.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
  * @ptr:  Pointer to "struct ccs_number_union".
  *
  * Returns nothing.
  */
-static void ccs_print_number_union(struct ccs_io_buffer *head,
-				   const struct ccs_number_union *ptr)
+static void ccs_print_number_union_nospace(struct ccs_io_buffer *head,
+					   const struct ccs_number_union *ptr)
 {
-	if (!head->r.print_cond_part)
-		ccs_set_space(head);
 	if (ptr->is_group) {
 		ccs_set_string(head, "@");
 		ccs_set_string(head, ptr->group->group_name->name);
@@ -1279,6 +1346,21 @@
 }
 
 /**
+ * ccs_print_number_union - Print a ccs_number_union.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ccs_number_union".
+ *
+ * Returns nothing.
+ */
+static void ccs_print_number_union(struct ccs_io_buffer *head,
+				   const struct ccs_number_union *ptr)
+{
+	ccs_set_space(head);
+	ccs_print_number_union_nospace(head, ptr);
+}
+
+/**
  * ccs_print_condition - Print condition part.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -1345,19 +1427,19 @@
 				switch (left) {
 				case CCS_ARGV_ENTRY:
 					ccs_io_printf(head,
-						      "exec.argv[%u]%s\"%s\"",
+						      "exec.argv[%lu]%s=\"",
 						      argv->index,
-						      argv->is_not ?
-						      "!=" : "=",
-						      argv->value->name);
+						      argv->is_not ? "!" : "");
+					ccs_set_string(head,
+						       argv->value->name);
+					ccs_set_string(head, "\"");
 					argv++;
 					continue;
 				case CCS_ENVP_ENTRY:
-					ccs_io_printf(head,
-						      "exec.envp[\"%s\"]%s",
-						      envp->name->name,
-						      envp->is_not ?
-						      "!=" : "=");
+					ccs_set_string(head, "exec.envp[\"");
+					ccs_set_string(head, envp->name->name);
+					ccs_io_printf(head, "\"]%s=",
+						      envp->is_not ? "!" : "");
 					if (envp->value) {
 						ccs_set_string(head, "\"");
 						ccs_set_string(head, envp->
@@ -1369,8 +1451,8 @@
 					envp++;
 					continue;
 				case CCS_NUMBER_UNION:
-					ccs_print_number_union(head,
-							       numbers_p++);
+					ccs_print_number_union_nospace
+						(head, numbers_p++);
 					break;
 				default:
 					ccs_set_string(head,
@@ -1380,11 +1462,12 @@
 				ccs_set_string(head, match ? "=" : "!=");
 				switch (right) {
 				case CCS_NAME_UNION:
-					ccs_print_name_union(head, names_p++);
+					ccs_print_name_union_quoted
+						(head, names_p++);
 					break;
 				case CCS_NUMBER_UNION:
-					ccs_print_number_union(head,
-							       numbers_p++);
+					ccs_print_number_union_nospace
+						(head, numbers_p++);
 					break;
 				default:
 					ccs_set_string(head,
@@ -1406,8 +1489,11 @@
 				      ccs_yesno(cond->grant_log ==
 						CCS_GRANTLOG_YES));
 		if (cond->transit) {
-			ccs_set_string(head, " auto_domain_transition=\"");
-			ccs_set_string(head, cond->transit->name);
+			const char *name = cond->transit->name;
+			ccs_set_string(head, *name == '<' ?
+				       " auto_namespace_transition=\"" :
+				       " auto_domain_transition=\"");
+			ccs_set_string(head, name);
 			ccs_set_string(head, "\"");
 		}
 		ccs_set_lf(head);
@@ -1426,8 +1512,10 @@
  */
 static void ccs_set_group(struct ccs_io_buffer *head, const char *category)
 {
-	if (head->type == CCS_EXCEPTIONPOLICY)
+	if (head->type == CCS_EXCEPTIONPOLICY) {
+		ccs_print_namespace(head);
 		ccs_io_printf(head, "acl_group %u ", head->r.acl_group_index);
+	}
 	ccs_set_string(head, category);
 }
 
@@ -1588,23 +1676,14 @@
 		if (first)
 			return true;
 		ccs_set_space(head);
-		switch (ptr->address_type) {
-			char buf[128];
-		case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
+		if (ptr->address.group) {
 			ccs_set_string(head, "@");
 			ccs_set_string(head,
 				       ptr->address.group->group_name->name);
-			break;
-		case CCS_IP_ADDRESS_TYPE_IPv4:
-			ccs_print_ipv4(buf, sizeof(buf), ptr->address.ipv4.min,
-				       ptr->address.ipv4.max);
+		} else {
+			char buf[128];
+			ccs_print_ip(buf, sizeof(buf), &ptr->address);
 			ccs_io_printf(head, "%s", buf);
-			break;
-		case CCS_IP_ADDRESS_TYPE_IPv6:
-			ccs_print_ipv6(buf, sizeof(buf), ptr->address.ipv6.min,
-				       ptr->address.ipv6.max);
-			ccs_io_printf(head, "%s", buf);
-			break;
 		}
 		ccs_print_number_union(head, &ptr->port);
 	} else if (acl_type == CCS_TYPE_UNIX_ACL) {
@@ -1632,7 +1711,8 @@
 		struct ccs_signal_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
 		ccs_set_group(head, "ipc signal ");
-		ccs_io_printf(head, "%u ", ptr->sig);
+		ccs_print_number_union_nospace(head, &ptr->sig);
+		ccs_set_space(head);
 		ccs_set_string(head, ptr->domainname->name);
 	} else if (acl_type == CCS_TYPE_MOUNT_ACL) {
 		struct ccs_mount_acl *ptr =
@@ -1661,19 +1741,17 @@
 /**
  * ccs_read_domain2 - Read domain policy.
  *
- * @head:   Pointer to "struct ccs_io_buffer".
- * @domain: Pointer to "struct ccs_domain_info".
- * @index:  Index number.
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @list: Pointer to "struct list_head".
  *
  * Returns true on success, false otherwise.
  *
  * Caller holds ccs_read_lock().
  */
 static bool ccs_read_domain2(struct ccs_io_buffer *head,
-			     struct ccs_domain_info *domain,
-			     const u8 index)
+			     struct list_head *list)
 {
-	list_for_each_cookie(head->r.acl, &domain->acl_info_list[index]) {
+	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_acl_info *ptr =
 			list_entry(head->r.acl, typeof(*ptr), list);
 		if (!ccs_print_entry(head, ptr))
@@ -1718,12 +1796,12 @@
 			ccs_set_lf(head);
 			/* fall through */
 		case 1:
-			if (!ccs_read_domain2(head, domain, 0))
+			if (!ccs_read_domain2(head, &domain->acl_info_list[0]))
 				return;
 			head->r.step++;
 			/* fall through */
 		case 2:
-			if (!ccs_read_domain2(head, domain, 1))
+			if (!ccs_read_domain2(head, &domain->acl_info_list[1]))
 				return;
 			head->r.step++;
 			if (!ccs_set_lf(head))
@@ -1766,7 +1844,8 @@
 	if (profile >= CCS_MAX_PROFILES)
 		return -EINVAL;
 	domain = ccs_find_domain(cp + 1);
-	if (domain && (!ccs_policy_loaded || ccs_profile_ptr[(u8) profile]))
+	if (domain && (!ccs_policy_loaded ||
+		       head->w.ns->profile_ptr[(u8) profile]))
 		domain->profile = (u8) profile;
 	return 0;
 }
@@ -1881,6 +1960,9 @@
 
 /* String table for domain transition control keywords. */
 static const char * const ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
+	[CCS_TRANSITION_CONTROL_NAMESPACE]     = "move_namespace ",
+	[CCS_TRANSITION_CONTROL_NO_NAMESPACE]  = "no_move_namespace ",
+	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
 	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
 	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
 	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
@@ -1903,44 +1985,31 @@
  */
 static int ccs_write_exception(struct ccs_io_buffer *head)
 {
-	char *data = head->write_buf;
-	const bool is_delete = ccs_str_starts(&data, "delete ");
+	const bool is_delete = head->w.is_delete;
+	struct ccs_acl_param param = {
+		.ns = head->w.ns,
+		.is_delete = is_delete,
+		.data = head->write_buf,
+	};
 	u8 i;
-	static const struct {
-		const char *keyword;
-		int (*write) (char *, const bool);
-	} ccs_callback[2] = {
-		{ "aggregator ",    ccs_write_aggregator },
-		{ "deny_autobind ", ccs_write_reserved_port },
-	};
-	if (!is_delete && ccs_str_starts(&data, "select ") &&
-	    !strcmp(data, "transition_only")) {
-		head->r.print_transition_related_only = true;
-		return -EAGAIN;
-	}
-	/* Don't allow updating policies by non manager programs. */
-	if (!ccs_manager())
-		return -EPERM;
-	for (i = 0; i < 2; i++)
-		if (ccs_str_starts(&data, ccs_callback[i].keyword))
-			return ccs_callback[i].write(data, is_delete);
+	if (ccs_str_starts(&param.data, "aggregator "))
+		return ccs_write_aggregator(&param);
+	if (ccs_str_starts(&param.data, "deny_autobind "))
+		return ccs_write_reserved_port(&param);
 	for (i = 0; i < CCS_MAX_TRANSITION_TYPE; i++)
-		if (ccs_str_starts(&data, ccs_transition_type[i]))
-			return ccs_write_transition_control(data, is_delete,
-							    i);
+		if (ccs_str_starts(&param.data, ccs_transition_type[i]))
+			return ccs_write_transition_control(&param, i);
 	for (i = 0; i < CCS_MAX_GROUP; i++)
-		if (ccs_str_starts(&data, ccs_group_name[i]))
-			return ccs_write_group(data, is_delete, i);
-	if (ccs_str_starts(&data, "acl_group ")) {
+		if (ccs_str_starts(&param.data, ccs_group_name[i]))
+			return ccs_write_group(&param, i);
+	if (ccs_str_starts(&param.data, "acl_group ")) {
 		unsigned int group;
-		if (sscanf(data, "%u", &group) == 1 &&
-		    group < CCS_MAX_ACL_GROUPS) {
-			data = strchr(data, ' ');
-			if (data)
-				return ccs_write_domain2(data + 1,
-							 &ccs_acl_group[group],
-							 is_delete);
-		}
+		char *data;
+		group = simple_strtoul(param.data, &data, 10);
+		if (group < CCS_MAX_ACL_GROUPS && *data++ == ' ')
+			return ccs_write_domain2(head->w.ns,
+						 head->w.ns->acl_group[group],
+						 data, is_delete);
 	}
 	return -EINVAL;
 }
@@ -1957,7 +2026,10 @@
  */
 static bool ccs_read_group(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.group, &ccs_group_list[idx]) {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
+	struct list_head *list = &ns->group_list[idx];
+	list_for_each_cookie(head->r.group, list) {
 		struct ccs_group *group =
 			list_entry(head->r.group, typeof(*group), head.list);
 		list_for_each_cookie(head->r.acl, &group->member_list) {
@@ -1967,6 +2039,7 @@
 				continue;
 			if (!ccs_flush(head))
 				return false;
+			ccs_print_namespace(head);
 			ccs_set_string(head, ccs_group_name[idx]);
 			ccs_set_string(head, group->group_name->name);
 			if (idx == CCS_PATH_GROUP) {
@@ -1983,14 +2056,8 @@
 				struct ccs_address_group *member =
 					container_of(ptr, typeof(*member),
 						     head);
-				if (member->is_ipv6)
-					ccs_print_ipv6(buffer, sizeof(buffer),
-						       member->min.ipv6,
-						       member->max.ipv6);
-				else
-					ccs_print_ipv4(buffer, sizeof(buffer),
-						       member->min.ipv4,
-						       member->max.ipv4);
+				ccs_print_ip(buffer, sizeof(buffer),
+					     &member->address);
 				ccs_io_printf(head, " %s", buffer);
 			}
 			ccs_set_lf(head);
@@ -2013,7 +2080,10 @@
  */
 static bool ccs_read_policy(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[idx]) {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
+	struct list_head *list = &ns->policy_list[idx];
+	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_acl_head *acl =
 			container_of(head->r.acl, typeof(*acl), list);
 		if (acl->is_deleted)
@@ -2028,6 +2098,7 @@
 			{
 				struct ccs_transition_control *ptr =
 					container_of(acl, typeof(*ptr), head);
+				ccs_print_namespace(head);
 				ccs_set_string(head,
 					       ccs_transition_type[ptr->type]);
 				ccs_set_string(head, ptr->program ?
@@ -2041,6 +2112,7 @@
 			{
 				struct ccs_aggregator *ptr =
 					container_of(acl, typeof(*ptr), head);
+				ccs_print_namespace(head);
 				ccs_set_string(head, "aggregator ");
 				ccs_set_string(head, ptr->original_name->name);
 				ccs_set_space(head);
@@ -2052,12 +2124,10 @@
 			{
 				struct ccs_reserved *ptr =
 					container_of(acl, typeof(*ptr), head);
-				const u16 min_port = ptr->min_port;
-				const u16 max_port = ptr->max_port;
+				ccs_print_namespace(head);
 				ccs_set_string(head, "deny_autobind ");
-				ccs_io_printf(head, "%u", min_port);
-				if (min_port != max_port)
-					ccs_io_printf(head, "-%u", max_port);
+				ccs_print_number_union_nospace(head,
+							       &ptr->port);
 			}
 			break;
 		default:
@@ -2080,6 +2150,8 @@
  */
 static void ccs_read_exception(struct ccs_io_buffer *head)
 {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
 	if (head->r.eof)
 		return;
 	while (head->r.step < CCS_MAX_POLICY &&
@@ -2096,9 +2168,9 @@
 	       + CCS_MAX_ACL_GROUPS * 2) {
 		head->r.acl_group_index = (head->r.step - CCS_MAX_POLICY
 					   - CCS_MAX_GROUP) / 2;
-		if (!ccs_read_domain2(head,
-				      &ccs_acl_group[head->r.acl_group_index],
-				      head->r.step & 1))
+		if (!ccs_read_domain2(head, &ns->acl_group
+				      [head->r.acl_group_index]
+				      [head->r.step & 1]))
 			return;
 		head->r.step++;
 	}
@@ -2201,8 +2273,12 @@
 	if (symlink)
 		ccs_addprintf(buffer, len, "%s", symlink);
 	ccs_normalize_line(buffer);
-	if (!ccs_write_domain2(buffer, ccs_current_domain(), false))
-		ccs_update_stat(CCS_STAT_POLICY_UPDATES);
+	{
+		struct ccs_domain_info *domain = ccs_current_domain();
+		if (!ccs_write_domain2(domain->ns, domain->acl_info_list,
+				       buffer, false))
+			ccs_update_stat(CCS_STAT_POLICY_UPDATES);
+	}
 	kfree(buffer);
 }
 
@@ -2463,7 +2539,7 @@
 {
 	if (head->r.eof)
 		return;
-	ccs_set_string(head, "1.8.1");
+	ccs_set_string(head, "1.8.2-pre");
 	head->r.eof = true;
 }
 
@@ -2477,9 +2553,9 @@
 
 /* String table for /proc/ccs/stat interface. */
 static const char * const ccs_memory_headers[CCS_MAX_MEMORY_STAT] = {
-	[CCS_MEMORY_POLICY] = "policy:",
-	[CCS_MEMORY_AUDIT]  = "audit log:",
-	[CCS_MEMORY_QUERY]  = "query message:",
+	[CCS_MEMORY_POLICY]     = "policy:",
+	[CCS_MEMORY_AUDIT]      = "audit log:",
+	[CCS_MEMORY_QUERY]      = "query message:",
 };
 
 /* Timestamp counter for last updated. */
@@ -2560,7 +2636,8 @@
 	if (ccs_str_starts(&data, "Memory used by "))
 		for (i = 0; i < CCS_MAX_MEMORY_STAT; i++)
 			if (ccs_str_starts(&data, ccs_memory_headers[i]))
-				sscanf(data, "%u", &ccs_memory_quota[i]);
+				ccs_memory_quota[i] =
+					simple_strtoul(data, NULL, 10);
 	return 0;
 }
 
@@ -2577,6 +2654,7 @@
 	struct ccs_io_buffer *head = kzalloc(sizeof(*head), CCS_GFP_FLAGS);
 	if (!head)
 		return -ENOMEM;
+	head->original_ns = ccs_current_namespace();
 	mutex_init(&head->io_sem);
 	head->type = type;
 	switch (type) {
@@ -2695,6 +2773,44 @@
 }
 
 /**
+ * ccs_move_namespace_cursor - Print namespace delimiter if needed.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ */
+static inline void ccs_move_namespace_cursor(struct ccs_io_buffer *head)
+{
+	struct list_head *ns;
+	if (head->type != CCS_EXCEPTIONPOLICY && head->type != CCS_PROFILE)
+		return;
+	/*
+	 * If this is the first read, or reading previous namespace finished
+	 * and has more namespaces to read, update the namespace cursor.
+	 */
+	ns = head->r.ns;
+	if (!ns || (head->r.eof && ns->next != &ccs_namespace_list)) {
+		/* Clearing is OK because ccs_flush() returned true. */
+		memset(&head->r, 0, sizeof(head->r));
+		head->r.ns = ns ? ns->next : ccs_namespace_list.next;
+	}
+}
+
+/**
+ * ccs_has_more_namespace - Check for unread namespaces.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true if we have more entries to print, false otherwise.
+ */
+static inline bool ccs_has_more_namespace(struct ccs_io_buffer *head)
+{
+	return (head->type == CCS_EXCEPTIONPOLICY ||
+		head->type == CCS_PROFILE) && head->r.eof &&
+		head->r.ns->next != &ccs_namespace_list;
+}
+
+/**
  * ccs_read_control - read() for /proc/ccs/ interface.
  *
  * @file:       Pointer to "struct file".
@@ -2720,8 +2836,10 @@
 	idx = ccs_read_lock();
 	if (ccs_flush(head))
 		/* Call the policy handler. */
-		head->read(head);
-	ccs_flush(head);
+		do {
+			ccs_move_namespace_cursor(head);
+			head->read(head);
+		} while (ccs_flush(head) && ccs_has_more_namespace(head));
 	ccs_read_unlock(idx);
 	len = head->read_user_buf - buffer;
 	mutex_unlock(&head->io_sem);
@@ -2752,13 +2870,6 @@
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
 	idx = ccs_read_lock();
-	/* Don't allow updating policies by non manager programs. */
-	if (head->write != ccs_write_pid && head->write != ccs_write_domain &&
-	    head->write != ccs_write_exception && !ccs_manager()) {
-		ccs_read_unlock(idx);
-		mutex_unlock(&head->io_sem);
-		return -EPERM;
-	}
 	/* Read a line and dispatch it to the policy handler. */
 	while (avail_len > 0) {
 		char c;
@@ -2787,15 +2898,68 @@
 		cp0[head->w.avail - 1] = '\0';
 		head->w.avail = 0;
 		ccs_normalize_line(cp0);
+		if (!strcmp(cp0, "reset")) {
+			head->w.ns = head->original_ns;
+			head->w.domain = NULL;
+			memset(&head->r, 0, sizeof(head->r));
+			continue;
+		}
+		/* Don't allow updating policies by non manager programs. */
+		switch (head->type) {
+		case CCS_PROCESS_STATUS:
+			/* This does not write anything. */
+			break;
+		case CCS_DOMAINPOLICY:
+			if (ccs_select_domain(head, cp0))
+				continue;
+			/* fall through */
+		case CCS_EXCEPTIONPOLICY:
+			if (!strcmp(cp0, "select transition_only")) {
+				head->r.print_transition_related_only = true;
+				continue;
+			}
+			/* fall through */
+		default:
+			if (!ccs_manager()) {
+				error = -EPERM;
+				goto out;
+			}
+		}
+		/* Delete request? */
+		head->w.is_delete = !strncmp(cp0, "delete ", 7);
+		if (head->w.is_delete)
+			memmove(cp0, cp0 + 7, strlen(cp0 + 7) + 1);
+		/* Selecting namespace to update. */
+		if (head->type == CCS_EXCEPTIONPOLICY ||
+		    head->type == CCS_PROFILE) {
+			if (*cp0 == '<') {
+				char *cp = strchr(cp0, ' ');
+				if (cp) {
+					*cp++ = '\0';
+					head->w.ns = ccs_assign_namespace(cp0);
+					memmove(cp0, cp, strlen(cp) + 1);
+				} else
+					head->w.ns = NULL;
+			} else
+				head->w.ns = head->original_ns;
+			/* Don't allow updating if namespace is invalid. */
+			if (!head->w.ns) {
+				error = -ENOENT;
+				goto out;
+			}
+		}
 		{
+			/* Do the update. */
 			const int ret = head->write(head);
 			if (ret == -EPERM) {
 				error = -EPERM;
 				break;
 			}
+			/* Do not update statistics if not updated. */
 			if (ret)
 				continue;
 		}
+		/* Update statistics. */
 		switch (head->type) {
 		case CCS_DOMAINPOLICY:
 		case CCS_EXCEPTIONPOLICY:
@@ -2809,6 +2973,7 @@
 			break;
 		}
 	}
+out:
 	ccs_read_unlock(idx);
 	mutex_unlock(&head->io_sem);
 	return error;
Index: security/ccsecurity/gc.c
===================================================================
--- security/ccsecurity/gc.c	(revision 5044)
+++ security/ccsecurity/gc.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1   2011/04/01
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -417,15 +417,9 @@
 		{
 			struct ccs_inet_acl *entry =
 				container_of(acl, typeof(*entry), head);
-			switch (entry->address_type) {
-			case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
-				ccs_put_group(entry->address.group);
-				break;
-			case CCS_IP_ADDRESS_TYPE_IPv6:
-				ccs_put_ipv6_address(entry->address.ipv6.min);
-				ccs_put_ipv6_address(entry->address.ipv6.max);
-				break;
-			}
+			ccs_put_group(entry->address.group);
+			ccs_put_ipv6_address(entry->address.ipv6.min);
+			ccs_put_ipv6_address(entry->address.ipv6.max);
 			ccs_put_number_union(&entry->port);
 		}
 		break;
@@ -542,10 +536,8 @@
 {
 	struct ccs_address_group *member =
 		container_of(element, typeof(*member), head.list);
-	if (member->is_ipv6) {
-		ccs_put_ipv6_address(member->min.ipv6);
-		ccs_put_ipv6_address(member->max.ipv6);
-	}
+	ccs_put_ipv6_address(member->address.ipv6.min);
+	ccs_put_ipv6_address(member->address.ipv6.max);
 }
 
 /**
@@ -745,16 +737,16 @@
 /**
  * ccs_collect_acl - Delete elements in "struct ccs_domain_info".
  *
- * @domain: Pointer to "struct ccs_domain_info".
+ * @list: Pointer to "struct list_head[2]".
  *
  * Returns true if some elements are deleted, false otherwise.
  */
-static bool ccs_collect_acl(struct ccs_domain_info *domain)
+static bool ccs_collect_acl(struct list_head *list)
 {
 	struct ccs_acl_info *acl;
 	u8 i;
 	for (i = 0; i < 2; i++) {
-		list_for_each_entry(acl, &domain->acl_info_list[i], list) {
+		list_for_each_entry(acl, &list[i], list) {
 			if (!acl->is_deleted)
 				continue;
 			if (!ccs_add_to_gc(CCS_ID_ACL, &acl->list))
@@ -773,20 +765,15 @@
 {
 	int i;
 	enum ccs_policy_id id;
+	struct ccs_policy_namespace *ns;
 	int idx;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return;
 	idx = ccs_read_lock();
-	for (id = 0; id < CCS_MAX_POLICY; id++)
-		if (!ccs_collect_member(id, &ccs_policy_list[id]))
-			goto unlock;
-	for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
-		if (!ccs_collect_acl(&ccs_acl_group[i]))
-			goto unlock;
 	{
 		struct ccs_domain_info *domain;
 		list_for_each_entry(domain, &ccs_domain_list, list) {
-			if (!ccs_collect_acl(domain))
+			if (!ccs_collect_acl(domain->acl_info_list))
 				goto unlock;
 			if (!domain->is_deleted ||
 			    ccs_domain_used_by_task(domain))
@@ -795,28 +782,39 @@
 				goto unlock;
 		}
 	}
-	for (i = 0; i < CCS_MAX_GROUP; i++) {
-		struct list_head *list = &ccs_group_list[i];
-		struct ccs_group *group;
-		switch (i) {
-		case 0:
-			id = CCS_ID_PATH_GROUP;
-			break;
-		case 1:
-			id = CCS_ID_NUMBER_GROUP;
-			break;
-		default:
-			id = CCS_ID_ADDRESS_GROUP;
-			break;
-		}
-		list_for_each_entry(group, list, head.list) {
-			if (!ccs_collect_member(id, &group->member_list))
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		for (id = 0; id < CCS_MAX_POLICY; id++)
+			if (!ccs_collect_member(id, &ns->policy_list[id]))
 				goto unlock;
-			if (!list_empty(&group->member_list) ||
-			    atomic_read(&group->head.users))
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_GROUP, &group->head.list))
+		for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
+			if (!ccs_collect_acl(ns->acl_group[i]))
 				goto unlock;
+		for (i = 0; i < CCS_MAX_GROUP; i++) {
+			struct list_head *list = &ns->group_list[i];
+			struct ccs_group *group;
+			switch (i) {
+			case 0:
+				id = CCS_ID_PATH_GROUP;
+				break;
+			case 1:
+				id = CCS_ID_NUMBER_GROUP;
+				break;
+			default:
+				id = CCS_ID_ADDRESS_GROUP;
+				break;
+			}
+			list_for_each_entry(group, list, head.list) {
+				if (!ccs_collect_member(id,
+							&group->member_list))
+					goto unlock;
+				if (!list_empty(&group->member_list) ||
+				    atomic_read(&group->head.users))
+					continue;
+				if (!ccs_add_to_gc(CCS_ID_GROUP,
+						   &group->head.list))
+					goto unlock;
+			}
 		}
 	}
 	for (i = 0; i < CCS_MAX_LIST + CCS_MAX_HASH; i++) {
Index: security/ccsecurity/network.c
===================================================================
--- security/ccsecurity/network.c	(revision 5044)
+++ security/ccsecurity/network.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1   2011/04/01
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -50,18 +50,19 @@
 };
 
 /**
- * ccs_parse_ip_address - Parse an IP address.
+ * ccs_parse_ipaddr_union - Parse an IP address.
  *
- * @address: String to parse.
- * @min:     Pointer to store min address.
- * @max:     Pointer to store max address.
+ * @param: Pointer to "struct ccs_acl_param".
+ * @ptr:   Pointer to "struct ccs_ipaddr_union".
  *
- * Returns CCS_IP_ADDRESS_TYPE_IPv6 if @address is an IPv6,
- * CCS_IP_ADDRESS_TYPE_IPv4 if @address is an IPv4,
- * CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP otherwise.
+ * Returns true on success, false otherwise.
  */
-int ccs_parse_ip_address(char *address, u16 *min, u16 *max)
+bool ccs_parse_ipaddr_union(struct ccs_acl_param *param,
+			    struct ccs_ipaddr_union *ptr)
 {
+	u16 min[8];
+	u16 max[8];
+	char *address = ccs_read_token(param);
 	int count = sscanf(address, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx"
 			   "-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
 			   &min[0], &min[1], &min[2], &min[3],
@@ -70,29 +71,40 @@
 			   &max[4], &max[5], &max[6], &max[7]);
 	if (count == 8 || count == 16) {
 		u8 i;
+		const struct in6_addr *ip[2];
 		if (count == 8)
 			memmove(max, min, sizeof(u16) * 8);
 		for (i = 0; i < 8; i++) {
 			min[i] = htons(min[i]);
 			max[i] = htons(max[i]);
 		}
-		return CCS_IP_ADDRESS_TYPE_IPv6;
+		ip[0] = ccs_get_ipv6_address((struct in6_addr *) min);
+		ip[1] = ccs_get_ipv6_address((struct in6_addr *) max);
+		if (!ip[0] || !ip[1]) {
+			ccs_put_ipv6_address(ip[0]);
+			ccs_put_ipv6_address(ip[1]);
+			return false;
+		}
+		ptr->ipv6.min = ip[0];
+		ptr->ipv6.max = ip[1];
+		return true;
 	}
 	count = sscanf(address, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
 		       &min[0], &min[1], &min[2], &min[3],
 		       &max[0], &max[1], &max[2], &max[3]);
 	if (count == 4 || count == 8) {
-		u32 ip = htonl((((u8) min[0]) << 24) + (((u8) min[1]) << 16)
-			       + (((u8) min[2]) << 8) + (u8) min[3]);
-		memmove(min, &ip, sizeof(ip));
-		if (count == 8)
-			ip = htonl((((u8) max[0]) << 24)
-				   + (((u8) max[1]) << 16)
-				   + (((u8) max[2]) << 8) + (u8) max[3]);
-		memmove(max, &ip, sizeof(ip));
-		return CCS_IP_ADDRESS_TYPE_IPv4;
+		/* use host byte order to allow u32 comparison.*/
+		ptr->ipv4.min = (((u8) min[0]) << 24) + (((u8) min[1]) << 16)
+			+ (((u8) min[2]) << 8) + (u8) min[3];
+		if (count == 4)
+			ptr->ipv4.max = ptr->ipv4.min;
+		else
+			ptr->ipv4.max =
+				(((u8) max[0]) << 24) + (((u8) max[1]) << 16)
+				+ (((u8) max[2]) << 8) + (u8) max[3];
+		return true;
 	}
-	return CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
+	return false;
 }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
@@ -123,8 +135,8 @@
  *
  * Returns nothing.
  */
-void ccs_print_ipv4(char *buffer, const int buffer_len,
-		    const u32 min_ip, const u32 max_ip)
+static void ccs_print_ipv4(char *buffer, const unsigned int buffer_len,
+			   const u32 min_ip, const u32 max_ip)
 {
 	memset(buffer, 0, buffer_len);
 	snprintf(buffer, buffer_len - 1, "%u.%u.%u.%u%c%u.%u.%u.%u",
@@ -152,9 +164,9 @@
  *
  * Returns nothing.
  */
-void ccs_print_ipv6(char *buffer, const int buffer_len,
-		    const struct in6_addr *min_ip,
-		    const struct in6_addr *max_ip)
+static void ccs_print_ipv6(char *buffer, const unsigned int buffer_len,
+			   const struct in6_addr *min_ip,
+			   const struct in6_addr *max_ip)
 {
 	memset(buffer, 0, buffer_len);
 	snprintf(buffer, buffer_len - 1,
@@ -163,6 +175,24 @@
 		 NIP6(*max_ip));
 }
 
+/**
+ * ccs_print_ip - Print an IP address.
+ *
+ * @buf:  Buffer to write to.
+ * @size: Size of @buf.
+ * @ptr:  Pointer to "struct ipaddr_union".
+ *
+ * Returns nothing.
+ */
+void ccs_print_ip(char *buf, const unsigned int size,
+		  const struct ccs_ipaddr_union *ptr)
+{
+	if (ptr->ipv6.min)
+		ccs_print_ipv6(buf, size, ptr->ipv6.min, ptr->ipv6.max);
+	else
+		ccs_print_ipv4(buf, size, ptr->ipv4.min, ptr->ipv4.max);
+}
+
 /*
  * Mapping table from "enum ccs_network_acl_index" to "enum ccs_mac_index" for
  * inet domain socket.
@@ -224,12 +254,7 @@
 	const struct ccs_inet_acl *p1 = container_of(a, typeof(*p1), head);
 	const struct ccs_inet_acl *p2 = container_of(b, typeof(*p2), head);
 	return p1->protocol == p2->protocol &&
-		p1->address_type == p2->address_type &&
-		p1->address.ipv4.min == p2->address.ipv4.min &&
-		p1->address.ipv6.min == p2->address.ipv6.min &&
-		p1->address.ipv4.max == p2->address.ipv4.max &&
-		p1->address.ipv6.max == p2->address.ipv6.max &&
-		p1->address.group == p2->address.group &&
+		ccs_same_ipaddr_union(&p1->address, &p2->address) &&
 		ccs_same_number_union(&p1->port, &p2->port);
 }
 
@@ -308,13 +333,10 @@
 int ccs_write_inet_network(struct ccs_acl_param *param)
 {
 	struct ccs_inet_acl e = { .head.type = CCS_TYPE_INET_ACL };
-	u16 min_address[8];
-	u16 max_address[8];
 	int error = -EINVAL;
 	u8 type;
 	const char *protocol = ccs_read_token(param);
 	const char *operation = ccs_read_token(param);
-	char *address = ccs_read_token(param);
 	for (e.protocol = 0; e.protocol < CCS_SOCK_MAX; e.protocol++)
 		if (!strcmp(protocol, ccs_proto_keyword[e.protocol]))
 			break;
@@ -323,43 +345,24 @@
 			e.perm |= 1 << type;
 	if (e.protocol == CCS_SOCK_MAX || !e.perm)
 		return -EINVAL;
-	switch (ccs_parse_ip_address(address, min_address, max_address)) {
-	case CCS_IP_ADDRESS_TYPE_IPv6:
-		e.address_type = CCS_IP_ADDRESS_TYPE_IPv6;
-		e.address.ipv6.min = ccs_get_ipv6_address((struct in6_addr *)
-							    min_address);
-		e.address.ipv6.max = ccs_get_ipv6_address((struct in6_addr *)
-							    max_address);
-		if (!e.address.ipv6.min || !e.address.ipv6.max)
-			goto out;
-		break;
-	case CCS_IP_ADDRESS_TYPE_IPv4:
-		e.address_type = CCS_IP_ADDRESS_TYPE_IPv4;
-		/* use host byte order to allow u32 comparison.*/
-		e.address.ipv4.min = ntohl(*(u32 *) min_address);
-		e.address.ipv4.max = ntohl(*(u32 *) max_address);
-		break;
-	default:
-		if (address[0] != '@')
-			return -EINVAL;
-		e.address_type = CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
-		e.address.group = ccs_get_group(address + 1,
-						CCS_ADDRESS_GROUP);
+	if (param->data[0] == '@') {
+		param->data++;
+		e.address.group = ccs_get_group(param, CCS_ADDRESS_GROUP);
 		if (!e.address.group)
 			return -ENOMEM;
-		break;
+	} else {
+		if (!ccs_parse_ipaddr_union(param, &e.address))
+			goto out;
 	}
-	if (!ccs_parse_number_union(ccs_read_token(param), &e.port))
+	if (!ccs_parse_number_union(param, &e.port) ||
+	    e.port.values[1] > 65535)
 		goto out;
 	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_inet_acl,
 				  ccs_merge_inet_acl);
 out:
-	if (e.address_type == CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP)
-		ccs_put_group(e.address.group);
-	else if (e.address_type == CCS_IP_ADDRESS_TYPE_IPv6) {
-		ccs_put_ipv6_address(e.address.ipv6.min);
-		ccs_put_ipv6_address(e.address.ipv6.max);
-	}
+	ccs_put_group(e.address.group);
+	ccs_put_ipv6_address(e.address.ipv6.min);
+	ccs_put_ipv6_address(e.address.ipv6.max);
 	ccs_put_number_union(&e.port);
 	return error;
 }
@@ -386,7 +389,7 @@
 			e.perm |= 1 << type;
 	if (e.protocol == CCS_SOCK_MAX || !e.perm)
 		return -EINVAL;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name))
+	if (!ccs_parse_name_union(param, &e.name))
 		return -EINVAL;
 	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_unix_acl,
 				  ccs_merge_unix_acl);
@@ -478,30 +481,23 @@
 			       const struct ccs_acl_info *ptr)
 {
 	const struct ccs_inet_acl *acl = container_of(ptr, typeof(*acl), head);
-	bool ret;
 	if (!(acl->perm & (1 << r->param.inet_network.operation)) ||
 	    !ccs_compare_number_union(r->param.inet_network.port, &acl->port))
 		return false;
-	switch (acl->address_type) {
-	case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
-		ret = ccs_address_matches_group(r->param.inet_network.is_ipv6,
-						r->param.inet_network.address,
-						acl->address.group);
-		break;
-	case CCS_IP_ADDRESS_TYPE_IPv4:
-		ret = !r->param.inet_network.is_ipv6 &&
-			acl->address.ipv4.min <= r->param.inet_network.ip &&
-			r->param.inet_network.ip <= acl->address.ipv4.max;
-		break;
-	default:
-		ret = r->param.inet_network.is_ipv6 &&
+	if (acl->address.group)
+		return ccs_address_matches_group(r->param.inet_network.is_ipv6,
+						 r->param.inet_network.address,
+						 acl->address.group);
+	else if (acl->address.ipv6.min)
+		return r->param.inet_network.is_ipv6 &&
 			memcmp(acl->address.ipv6.min,
 			       r->param.inet_network.address, 16) <= 0 &&
 			memcmp(r->param.inet_network.address,
 			       acl->address.ipv6.max, 16) <= 0;
-		break;
-	}
-	return ret;
+	else
+		return !r->param.inet_network.is_ipv6 &&
+			acl->address.ipv4.min <= r->param.inet_network.ip &&
+			r->param.inet_network.ip <= acl->address.ipv4.max;
 }
 
 /**
Index: security/ccsecurity/group.c
===================================================================
--- security/ccsecurity/group.c	(revision 5044)
+++ security/ccsecurity/group.c	(working copy)
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 2005-2011  NTT DATA CORPORATION
  *
- * Version: 1.8.1   2011/04/01
+ * Version: 1.8.2-pre   2011/05/22
  */
 
 #include "internal.h"
@@ -55,80 +55,54 @@
 							  head);
 	const struct ccs_address_group *p2 = container_of(b, typeof(*p2),
 							  head);
-	return p1->is_ipv6 == p2->is_ipv6 &&
-		p1->min.ipv4 == p2->min.ipv4 && p1->min.ipv6 == p2->min.ipv6 &&
-		p1->max.ipv4 == p2->max.ipv4 && p1->max.ipv6 == p2->max.ipv6;
+	return ccs_same_ipaddr_union(&p1->address, &p2->address);
 }
 
 /**
  * ccs_write_group - Write "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- * @type:      Type of this group.
+ * @param: Pointer to "struct ccs_acl_param".
+ * @type:  Type of this group.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_group(char *data, const bool is_delete, const u8 type)
+int ccs_write_group(struct ccs_acl_param *param, const u8 type)
 {
-	struct ccs_group *group;
-	struct list_head *member;
-	char *w[2];
+	struct ccs_group *group = ccs_get_group(param, type);
 	int error = -EINVAL;
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	group = ccs_get_group(w[0], type);
 	if (!group)
 		return -ENOMEM;
-	member = &group->member_list;
+	param->list = &group->member_list;
 	if (type == CCS_PATH_GROUP) {
 		struct ccs_path_group e = { };
-		e.member_name = ccs_get_name(w[1]);
+		e.member_name = ccs_get_name(ccs_read_token(param));
 		if (!e.member_name) {
 			error = -ENOMEM;
 			goto out;
 		}
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_path_group);
+		error = ccs_update_policy(&e.head, sizeof(e), param,
+					  ccs_same_path_group);
 		ccs_put_name(e.member_name);
 	} else if (type == CCS_NUMBER_GROUP) {
 		struct ccs_number_group e = { };
-		if (w[1][0] == '@' || !ccs_parse_number_union(w[1], &e.number)
-		    || e.number.values[0] > e.number.values[1])
+		if (param->data[0] == '@' ||
+		    !ccs_parse_number_union(param, &e.number))
 			goto out;
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_number_group);
+		error = ccs_update_policy(&e.head, sizeof(e), param,
+					  ccs_same_number_group);
 		/*
-		 * ccs_put_number_union() is not needed because w[1][0] != '@'.
+		 * ccs_put_number_union() is not needed because
+		 * param->data[0] != '@'.
 		 */
 	} else {
 		struct ccs_address_group e = { };
-		u16 min_address[8];
-		u16 max_address[8];
-		switch (ccs_parse_ip_address(w[1], min_address, max_address)) {
-		case CCS_IP_ADDRESS_TYPE_IPv6:
-			e.is_ipv6 = true;
-			e.min.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
-							  min_address);
-			e.max.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
-							  max_address);
-			if (!e.min.ipv6 || !e.max.ipv6)
-				goto out_address;
-			break;
-		case CCS_IP_ADDRESS_TYPE_IPv4:
-			e.min.ipv4 = ntohl(*(u32 *) min_address);
-			e.max.ipv4 = ntohl(*(u32 *) max_address);
-			break;
-		default:
-			goto out_address;
-		}
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_address_group);
-out_address:
-		if (e.is_ipv6) {
-			ccs_put_ipv6_address(e.min.ipv6);
-			ccs_put_ipv6_address(e.max.ipv6);
-		}
+		if (param->data[0] == '@' ||
+		    !ccs_parse_ipaddr_union(param, &e.address))
+			goto out;
+		error = ccs_update_policy(&e.head, sizeof(e), param,
+					  ccs_same_address_group);
+		ccs_put_ipv6_address(e.address.ipv6.min);
+		ccs_put_ipv6_address(e.address.ipv6.max);
 	}
 out:
 	ccs_put_group(group);
@@ -211,16 +185,19 @@
 				 &ccs_ss) {
 		if (member->head.is_deleted)
 			continue;
-		if (member->is_ipv6) {
+		if (member->address.ipv6.min) {
 			if (is_ipv6 &&
-			    memcmp(member->min.ipv6, address, 16) <= 0 &&
-			    memcmp(address, member->max.ipv6, 16) <= 0) {
+			    memcmp(member->address.ipv6.min, address, 16)
+			    <= 0 &&
+			    memcmp(address, member->address.ipv6.max, 16)
+			    <= 0) {
 				matched = true;
 				break;
 			}
 		} else {
 			if (!is_ipv6 &&
-			    member->min.ipv4 <= ip && ip <= member->max.ipv4) {
+			    member->address.ipv4.min <= ip &&
+			    ip <= member->address.ipv4.max) {
 				matched = true;
 				break;
 			}
