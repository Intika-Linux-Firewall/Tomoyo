[PATCH] TOMOYO: Use per "struct task_struct" variables.

This patch removes distinction between subjective credentials
("struct task_struct"->cred) and objective credentials ("struct task_struct"->
real_cred) from TOMOYO. This is needed for fixing below bugs.

(1) Upon do_execve(), binary loader's permission cannot be checked because the
    proposed subjective credentials which will be used if do_execve() succeeds
    is not passed to security_dentry_open(). Fix this bug by allowing updating
    security context stored into a "struct task_struct" variable at
    security_bprm_check() before do_execve() succeeds, and reverting at
    security_bprm_free() if do_execve() failed.

(2) Interactive judgment functionality provided by /usr/sbin/tomoyo-queryd
    cannot be used for checking binary loader's permission and environment
    variable's permissions upon do_execve(), for /usr/sbin/tomoyo-queryd cannot
    see the proposed subjective credentials until do_execve() succeeds. Also,
    interactive judgment functionality cannot be used whenever the target
    thread is between override_creds() and revert_creds().

(3) Future patches that triggers domain transition cannot be proposed because
    domain transition cannot be done when the current thread is between
    override_creds() and revert_creds().

By applying this patch, TOMOYO no longer depends on "struct cred"->security.
This is correct for TOMOYO because TOMOYO's security context is defined as
what did each "struct task_struct" has requested by now. Overriding security
context of some other "struct task_struct" on behalf of that thread is wrong.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp> 
---
 security/tomoyo/audit.c         |   11 -
 security/tomoyo/common.c        |   28 +--
 security/tomoyo/common.h        |  106 ++++++++----
 security/tomoyo/domain.c        |   43 ++---
 security/tomoyo/file.c          |   19 --
 security/tomoyo/gc.c            |   54 +++++-
 security/tomoyo/memory.c        |    2 
 security/tomoyo/mount.c         |    2 
 security/tomoyo/network.c       |    4 
 security/tomoyo/securityfs_if.c |   28 ---
 security/tomoyo/tomoyo.c        |  340 +++++++++++++++++++++++-----------------
 security/tomoyo/util.c          |   22 --
 12 files changed, 385 insertions(+), 274 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/audit.c
+++ security-testing-2.6/security/tomoyo/audit.c
@@ -240,7 +240,7 @@ char *tomoyo_init_log(struct tomoyo_requ
 	char *realpath = NULL;
 	const char *symlink = NULL;
 	int pos;
-	const char *domainname = r->domain->domainname->name;
+	const char *domainname = tomoyo_current_domain()->domainname->name;
 	header = tomoyo_print_header(r);
 	if (!header)
 		return NULL;
@@ -304,15 +304,13 @@ static unsigned int tomoyo_log_count;
 /**
  * tomoyo_get_audit - Get audit mode.
  *
- * @ns:          Pointer to "struct tomoyo_policy_namespace".
  * @profile:     Profile number.
  * @index:       Index number of functionality.
  * @is_granted:  True if granted log, false otherwise.
  *
  * Returns true if this request should be audited, false otherwise.
  */
-static bool tomoyo_get_audit(const struct tomoyo_policy_namespace *ns,
-			     const u8 profile, const u8 index,
+static bool tomoyo_get_audit(const u8 profile, const u8 index,
 			     const struct tomoyo_acl_info *matched_acl,
 			     const bool is_granted)
 {
@@ -322,7 +320,7 @@ static bool tomoyo_get_audit(const struc
 	struct tomoyo_profile *p;
 	if (!tomoyo_policy_loaded)
 		return false;
-	p = tomoyo_profile(ns, profile);
+	p = tomoyo_profile(profile);
 	if (tomoyo_log_count >= p->pref[TOMOYO_PREF_MAX_AUDIT_LOG])
 		return false;
 	if (is_granted && matched_acl && matched_acl->cond &&
@@ -354,8 +352,7 @@ void tomoyo_write_log2(struct tomoyo_req
 	char *buf;
 	struct tomoyo_log *entry;
 	bool quota_exceeded = false;
-	if (!tomoyo_get_audit(r->domain->ns, r->profile, r->type,
-			      r->matched_acl, r->granted))
+	if (!tomoyo_get_audit(r->profile, r->type, r->matched_acl, r->granted))
 		goto out;
 	buf = tomoyo_init_log(r, len, fmt, args);
 	if (!buf)
--- security-testing-2.6.orig/security/tomoyo/common.c
+++ security-testing-2.6/security/tomoyo/common.c
@@ -519,16 +519,15 @@ static struct tomoyo_profile *tomoyo_ass
 /**
  * tomoyo_profile - Find a profile.
  *
- * @ns:      Pointer to "struct tomoyo_policy_namespace".
  * @profile: Profile number to find.
  *
  * Returns pointer to "struct tomoyo_profile".
  */
-struct tomoyo_profile *tomoyo_profile(const struct tomoyo_policy_namespace *ns,
-				      const u8 profile)
+struct tomoyo_profile *tomoyo_profile(const u8 profile)
 {
 	static struct tomoyo_profile tomoyo_null_profile;
-	struct tomoyo_profile *ptr = ns->profile_ptr[profile];
+	struct tomoyo_profile *ptr = tomoyo_current_namespace()->
+		profile_ptr[profile];
 	if (!ptr)
 		ptr = &tomoyo_null_profile;
 	return ptr;
@@ -925,7 +924,8 @@ static bool tomoyo_manager(void)
 	struct tomoyo_manager *ptr;
 	const char *exe;
 	const struct task_struct *task = current;
-	const struct tomoyo_path_info *domainname = tomoyo_domain()->domainname;
+	const struct tomoyo_path_info *domainname =
+		tomoyo_current_domain()->domainname;
 	bool found = false;
 
 	if (!tomoyo_policy_loaded)
@@ -994,7 +994,7 @@ static bool tomoyo_select_domain(struct 
 		else
 			p = find_task_by_vpid(pid);
 		if (p)
-			domain = tomoyo_real_domain(p);
+			domain = tomoyo_task_domain(p);
 		rcu_read_unlock();
 	} else if (!strncmp(data, "domain=", 7)) {
 		if (tomoyo_domain_def(data + 7))
@@ -1672,7 +1672,7 @@ static void tomoyo_read_pid(struct tomoy
 	else
 		p = find_task_by_vpid(pid);
 	if (p)
-		domain = tomoyo_real_domain(p);
+		domain = tomoyo_task_domain(p);
 	rcu_read_unlock();
 	if (!domain)
 		return;
@@ -1933,12 +1933,11 @@ static int tomoyo_truncate(char *str)
 /**
  * tomoyo_add_entry - Add an ACL to current thread's domain. Used by learning mode.
  *
- * @domain: Pointer to "struct tomoyo_domain_info".
  * @header: Lines containing ACL.
  *
  * Returns nothing.
  */
-static void tomoyo_add_entry(struct tomoyo_domain_info *domain, char *header)
+static void tomoyo_add_entry(char *header)
 {
 	char *buffer;
 	char *realpath = NULL;
@@ -1980,9 +1979,12 @@ static void tomoyo_add_entry(struct tomo
 	if (symlink)
 		tomoyo_addprintf(buffer, len, "%s", symlink);
 	tomoyo_normalize_line(buffer);
-	if (!tomoyo_write_domain2(domain->ns, &domain->acl_info_list, buffer,
-				  false))
-		tomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);
+	{
+		struct tomoyo_domain_info *domain = tomoyo_current_domain();
+		if (!tomoyo_write_domain2(domain->ns, &domain->acl_info_list,
+					  buffer, false))
+			tomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);
+	}
 	kfree(buffer);
 }
 
@@ -2040,7 +2042,7 @@ int tomoyo_supervisor(struct tomoyo_requ
 		goto out;
 	entry.query_len = strlen(entry.query) + 1;
 	if (!error) {
-		tomoyo_add_entry(r->domain, entry.query);
+		tomoyo_add_entry(entry.query);
 		goto out;
 	}
 	len = tomoyo_round2(entry.query_len);
--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -44,6 +44,9 @@
 #define TOMOYO_HASH_BITS  8
 #define TOMOYO_MAX_HASH (1u<<TOMOYO_HASH_BITS)
 
+#define TOMOYO_TASK_SECURITY_HASH_BITS 12
+#define TOMOYO_MAX_TASK_SECURITY_HASH (1u << TOMOYO_TASK_SECURITY_HASH_BITS)
+
 /*
  * TOMOYO checks only SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET.
  * Therefore, we don't need SOCK_MAX.
@@ -424,7 +427,6 @@ struct tomoyo_request_info {
 	 * NULL if not dealing do_execve().
 	 */
 	struct tomoyo_execve *ee;
-	struct tomoyo_domain_info *domain;
 	/* For holding parameters. */
 	union {
 		struct {
@@ -684,7 +686,6 @@ struct tomoyo_domain_info {
 	u8 group;          /* Group number to use.   */
 	bool is_deleted;   /* Delete flag.           */
 	bool flags[TOMOYO_MAX_DOMAIN_INFO_FLAGS];
-	atomic_t users; /* Number of referring credentials. */
 };
 
 /*
@@ -912,6 +913,27 @@ struct tomoyo_policy_namespace {
 	const char *name;
 };
 
+/*
+ * Structure for holding "struct tomoyo_domain_info *" for each
+ * "struct task_struct".
+ */
+struct tomoyo_security {
+	struct list_head list;
+	const struct task_struct *task; /* == current */
+	/*
+	 * Holds current thread's domain. Only current thread can modify this
+	 * member but any threads can read this member under RCU.
+	 */
+	struct tomoyo_domain_info *tomoyo_domain_info;
+	/*
+	 * Holds previous tomoyo_domain_info during do_execve() in case
+	 * do_execve() failed, NULL otherwise. Only current thread can access
+	 * this member.
+	 */
+	struct tomoyo_domain_info *previous_domain_info;
+	struct rcu_head rcu;
+};
+
 /********** Function prototypes. **********/
 
 bool tomoyo_address_matches_group(const bool is_ipv6, const __be32 *address,
@@ -957,18 +979,14 @@ const struct tomoyo_path_info *tomoyo_ge
 const struct tomoyo_path_info *tomoyo_get_name(const char *name);
 const struct tomoyo_path_info *tomoyo_path_matches_group
 (const struct tomoyo_path_info *pathname, const struct tomoyo_group *group);
-int tomoyo_check_open_permission(struct tomoyo_domain_info *domain,
-				 struct path *path, const int flag);
+int tomoyo_check_open_permission(struct path *path, const int flag);
 int tomoyo_close_control(struct tomoyo_io_buffer *head);
 int tomoyo_env_perm(struct tomoyo_request_info *r, const char *env);
 int tomoyo_execute_permission(struct tomoyo_request_info *r,
 			      const struct tomoyo_path_info *filename);
 int tomoyo_find_next_domain(struct linux_binprm *bprm);
-int tomoyo_get_mode(const struct tomoyo_policy_namespace *ns, const u8 profile,
-		    const u8 index);
-int tomoyo_init_request_info(struct tomoyo_request_info *r,
-			     struct tomoyo_domain_info *domain,
-			     const u8 index);
+int tomoyo_get_mode(const u8 profile, const u8 index);
+int tomoyo_init_request_info(struct tomoyo_request_info *r, const u8 index);
 int tomoyo_mkdev_perm(const u8 operation, struct path *path,
 		      const unsigned int mode, unsigned int dev);
 int tomoyo_mount_permission(char *dev_name, struct path *path,
@@ -1025,8 +1043,9 @@ struct tomoyo_group *tomoyo_get_group(st
 				      const u8 idx);
 struct tomoyo_policy_namespace *tomoyo_assign_namespace
 (const char *domainname);
-struct tomoyo_profile *tomoyo_profile(const struct tomoyo_policy_namespace *ns,
-				      const u8 profile);
+struct tomoyo_profile *tomoyo_profile(const u8 profile);
+struct tomoyo_security *tomoyo_find_task_security
+(const struct task_struct *task);
 unsigned int tomoyo_check_flags(const struct tomoyo_domain_info *domain,
 				const u8 index);
 u8 tomoyo_parse_ulong(unsigned long *result, char **str);
@@ -1062,6 +1081,7 @@ void tomoyo_write_log2(struct tomoyo_req
 /********** External variable definitions. **********/
 
 extern bool tomoyo_policy_loaded;
+extern bool tomoyo_registered;
 extern const char * const tomoyo_condition_keyword
 [TOMOYO_MAX_CONDITION_KEYWORD];
 extern const char * const tomoyo_dif[TOMOYO_MAX_DOMAIN_INFO_FLAGS];
@@ -1079,6 +1099,8 @@ extern struct list_head tomoyo_condition
 extern struct list_head tomoyo_domain_list;
 extern struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];
 extern struct list_head tomoyo_namespace_list;
+extern struct list_head
+tomoyo_task_security_list[TOMOYO_MAX_TASK_SECURITY_HASH];
 extern struct mutex tomoyo_policy_lock;
 extern struct srcu_struct tomoyo_ss;
 extern struct tomoyo_domain_info tomoyo_kernel_domain;
@@ -1197,29 +1219,6 @@ static inline void tomoyo_put_group(stru
 }
 
 /**
- * tomoyo_domain - Get "struct tomoyo_domain_info" for current thread.
- *
- * Returns pointer to "struct tomoyo_domain_info" for current thread.
- */
-static inline struct tomoyo_domain_info *tomoyo_domain(void)
-{
-	return current_cred()->security;
-}
-
-/**
- * tomoyo_real_domain - Get "struct tomoyo_domain_info" for specified thread.
- *
- * @task: Pointer to "struct task_struct".
- *
- * Returns pointer to "struct tomoyo_security" for specified thread.
- */
-static inline struct tomoyo_domain_info *tomoyo_real_domain(struct task_struct
-							    *task)
-{
-	return task_cred_xxx(task, security);
-}
-
-/**
  * tomoyo_same_name_union - Check for duplicated "struct tomoyo_name_union" entry.
  *
  * @a: Pointer to "struct tomoyo_name_union".
@@ -1265,13 +1264,50 @@ static inline bool tomoyo_same_ipaddr_un
 }
 
 /**
+ * tomoyo_current_security - Get "struct tomoyo_security" for current thread.
+ *
+ * Returns pointer to "struct tomoyo_security" for current thread.
+ */
+static inline struct tomoyo_security *tomoyo_current_security(void)
+{
+	return tomoyo_find_task_security(current);
+}
+
+/**
+ * tomoyo_task_domain - Get "struct tomoyo_domain_info" for specified thread.
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns pointer to "struct tomoyo_security" for specified thread.
+ */
+static inline struct tomoyo_domain_info *tomoyo_task_domain
+(struct task_struct *task)
+{
+	struct tomoyo_domain_info *domain;
+	rcu_read_lock();
+	domain = tomoyo_find_task_security(task)->tomoyo_domain_info;
+	rcu_read_unlock();
+	return domain;
+}
+
+/**
+ * tomoyo_current_domain - Get "struct tomoyo_domain_info" for current thread.
+ *
+ * Returns pointer to "struct tomoyo_domain_info" for current thread.
+ */
+static inline struct tomoyo_domain_info *tomoyo_current_domain(void)
+{
+	return tomoyo_find_task_security(current)->tomoyo_domain_info;
+}
+
+/**
  * tomoyo_current_namespace - Get "struct tomoyo_policy_namespace" for current thread.
  *
  * Returns pointer to "struct tomoyo_policy_namespace" for current thread.
  */
 static inline struct tomoyo_policy_namespace *tomoyo_current_namespace(void)
 {
-	return tomoyo_domain()->ns;
+	return tomoyo_current_domain()->ns;
 }
 
 #if defined(CONFIG_SLOB)
--- security-testing-2.6.orig/security/tomoyo/domain.c
+++ security-testing-2.6/security/tomoyo/domain.c
@@ -157,7 +157,7 @@ void tomoyo_check_acl(struct tomoyo_requ
 		      bool (*check_entry) (struct tomoyo_request_info *,
 					   const struct tomoyo_acl_info *))
 {
-	const struct tomoyo_domain_info *domain = r->domain;
+	const struct tomoyo_domain_info *domain = tomoyo_current_domain();
 	struct tomoyo_acl_info *ptr;
 	bool retried = false;
 	const struct list_head *list = &domain->acl_info_list;
@@ -504,6 +504,7 @@ static bool tomoyo_namespace_jump(const 
 struct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,
 						const bool transit)
 {
+	struct tomoyo_security *security = tomoyo_current_security();
 	struct tomoyo_domain_info e = { };
 	struct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);
 	bool created = false;
@@ -518,6 +519,7 @@ struct tomoyo_domain_info *tomoyo_assign
 			if (tomoyo_policy_loaded &&
 			    !entry->ns->profile_ptr[entry->profile])
 				return NULL;
+			security->tomoyo_domain_info = entry;
 		}
 		return entry;
 	}
@@ -542,7 +544,8 @@ struct tomoyo_domain_info *tomoyo_assign
 	 * created domains.
 	 */
 	if (transit) {
-		const struct tomoyo_domain_info *domain = tomoyo_domain();
+		const struct tomoyo_domain_info *domain =
+			tomoyo_current_domain();
 		e.profile = domain->profile;
 		e.group = domain->group;
 	}
@@ -564,10 +567,10 @@ struct tomoyo_domain_info *tomoyo_assign
 out:
 	tomoyo_put_name(e.domainname);
 	if (entry && transit) {
+		security->tomoyo_domain_info = entry;
 		if (created) {
 			struct tomoyo_request_info r;
-			tomoyo_init_request_info(&r, entry,
-						 TOMOYO_MAC_FILE_EXECUTE);
+			tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_EXECUTE);
 			r.granted = false;
 			tomoyo_write_log(&r, "use_profile %u\n",
 					 entry->profile);
@@ -600,9 +603,8 @@ static int tomoyo_environ(struct tomoyo_
 	int error = -ENOMEM;
 
 	ee->r.type = TOMOYO_MAC_ENVIRON;
-	ee->r.profile = r->domain->profile;
-	ee->r.mode = tomoyo_get_mode(r->domain->ns, ee->r.profile,
-				     TOMOYO_MAC_ENVIRON);
+	ee->r.profile = tomoyo_current_domain()->profile;
+	ee->r.mode = tomoyo_get_mode(ee->r.profile, TOMOYO_MAC_ENVIRON);
 	if (!r->mode || !envp_count)
 		return 0;
 	arg_ptr = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);
@@ -675,7 +677,8 @@ out:
  */
 int tomoyo_find_next_domain(struct linux_binprm *bprm)
 {
-	struct tomoyo_domain_info *old_domain = tomoyo_domain();
+	struct tomoyo_security *security = tomoyo_current_security();
+	struct tomoyo_domain_info *old_domain = tomoyo_current_domain();
 	struct tomoyo_domain_info *domain = NULL;
 	const char *original_name = bprm->filename;
 	int retval = -ENOMEM;
@@ -692,7 +695,7 @@ int tomoyo_find_next_domain(struct linux
 		return -ENOMEM;
 	}
 	/* ee->dump->data is allocated by tomoyo_dump_page(). */
-	tomoyo_init_request_info(&ee->r, NULL, TOMOYO_MAC_FILE_EXECUTE);
+	tomoyo_init_request_info(&ee->r, TOMOYO_MAC_FILE_EXECUTE);
 	ee->r.ee = ee;
 	ee->bprm = bprm;
 	ee->r.obj = &ee->obj;
@@ -814,6 +817,17 @@ force_child_domain:
 		break;
 	}
 force_jump_domain:
+	security->previous_domain_info = old_domain;
+	/*
+	 * Make security->previous_domain_info visible to GC before changing
+	 * security->tomoyo_domain_info.
+	 */
+	smp_wmb();
+	/*
+	 * Proceed to the next domain in order to allow checking permissions
+	 * for binary loader programs. Current thread will go back to the
+	 * previous domain if do_execve() failed.
+	 */
 	if (!domain)
 		domain = tomoyo_assign_domain(ee->tmp, true);
 	if (domain)
@@ -836,16 +850,9 @@ force_jump_domain:
 		}
 	}
  out:
-	if (!domain)
-		domain = old_domain;
-	/* Update reference count on "struct tomoyo_domain_info". */
-	atomic_inc(&domain->users);
-	bprm->cred->security = domain;
-	kfree(exename.name);
-	if (!retval) {
-		ee->r.domain = domain;
+	if (!retval)
 		retval = tomoyo_environ(ee);
-	}
+	kfree(exename.name);
 	kfree(ee->tmp);
 	kfree(ee->dump.data);
 	kfree(ee);
--- security-testing-2.6.orig/security/tomoyo/file.c
+++ security-testing-2.6/security/tomoyo/file.c
@@ -561,7 +561,7 @@ static int tomoyo_path_permission(struct
 	int error;
 
 	r->type = tomoyo_p2mac[operation];
-	r->mode = tomoyo_get_mode(r->domain->ns, r->profile, r->type);
+	r->mode = tomoyo_get_mode(r->profile, r->type);
 	if (r->mode == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	r->param_type = TOMOYO_TYPE_PATH_ACL;
@@ -593,7 +593,7 @@ int tomoyo_execute_permission(struct tom
 	 * preference.
 	 */
 	r->type = TOMOYO_MAC_FILE_EXECUTE;
-	r->mode = tomoyo_get_mode(r->domain->ns, r->profile, r->type);
+	r->mode = tomoyo_get_mode(r->profile, r->type);
 	r->param_type = TOMOYO_TYPE_PATH_ACL;
 	r->param.path.filename = filename;
 	r->param.path.operation = TOMOYO_TYPE_EXECUTE;
@@ -698,7 +698,7 @@ int tomoyo_path_number_perm(const u8 typ
 	struct tomoyo_path_info buf;
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])
+	if (tomoyo_init_request_info(&r, tomoyo_pn2mac[type])
 	    == TOMOYO_CONFIG_DISABLED || !path->dentry)
 		return 0;
 	idx = tomoyo_read_lock();
@@ -726,14 +726,12 @@ int tomoyo_path_number_perm(const u8 typ
 /**
  * tomoyo_check_open_permission - Check permission for "read" and "write".
  *
- * @domain: Pointer to "struct tomoyo_domain_info".
  * @path:   Pointer to "struct path".
  * @flag:   Flags for open().
  *
  * Returns 0 on success, negative value otherwise.
  */
-int tomoyo_check_open_permission(struct tomoyo_domain_info *domain,
-				 struct path *path, const int flag)
+int tomoyo_check_open_permission(struct path *path, const int flag)
 {
 	const u8 acc_mode = ACC_MODE(flag);
 	int error = 0;
@@ -747,8 +745,7 @@ int tomoyo_check_open_permission(struct 
 	buf.name = NULL;
 	r.mode = TOMOYO_CONFIG_DISABLED;
 	idx = tomoyo_read_lock();
-	if (acc_mode &&
-	    tomoyo_init_request_info(&r, domain, TOMOYO_MAC_FILE_OPEN)
+	if (acc_mode && tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_OPEN)
 	    != TOMOYO_CONFIG_DISABLED) {
 		if (!tomoyo_get_realpath(&buf, path)) {
 			error = -ENOMEM;
@@ -794,7 +791,7 @@ int tomoyo_path_perm(const u8 operation,
 	struct tomoyo_path_info symlink_target;
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])
+	if (tomoyo_init_request_info(&r, tomoyo_p2mac[operation])
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	is_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);
@@ -849,7 +846,7 @@ int tomoyo_mkdev_perm(const u8 operation
 	struct tomoyo_path_info buf;
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, tomoyo_pnnn2mac[operation])
+	if (tomoyo_init_request_info(&r, tomoyo_pnnn2mac[operation])
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	idx = tomoyo_read_lock();
@@ -895,7 +892,7 @@ int tomoyo_path2_perm(const u8 operation
 	};
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, tomoyo_pp2mac[operation])
+	if (tomoyo_init_request_info(&r, tomoyo_pp2mac[operation])
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	buf1.name = NULL;
--- security-testing-2.6.orig/security/tomoyo/gc.c
+++ security-testing-2.6/security/tomoyo/gc.c
@@ -232,6 +232,44 @@ static void tomoyo_del_acl(struct list_h
 }
 
 /**
+ * tomoyo_domain_used_by_task - Check whether the given pointer is referenced by a task.
+ *
+ * @domain: Pointer to "struct tomoyo_domain_info".
+ *
+ * Returns true if @domain is in use, false otherwise.
+ */
+static bool tomoyo_domain_used_by_task(struct tomoyo_domain_info *domain)
+{
+	bool in_use = false;
+	/*
+	 * Don't delete this domain if somebody is doing execve().
+	 *
+	 * Since tomoyo_find_task_security() first reverts tomoyo_domain_info
+	 * and then clears previous_domain_info, we need smp_rmb() to make sure
+	 * that GC first checks previous_domain_info and then checks
+	 * tomoyo_domain_info.
+	 */
+	int idx;
+	rcu_read_lock();
+	for (idx = 0; idx < TOMOYO_MAX_TASK_SECURITY_HASH; idx++) {
+		struct tomoyo_security *ptr;
+		struct list_head *list = &tomoyo_task_security_list[idx];
+		list_for_each_entry_rcu(ptr, list, list) {
+			if (ptr->previous_domain_info != domain) {
+				smp_rmb(); /* Avoid out of order execution. */
+				if (ptr->tomoyo_domain_info != domain)
+					continue;
+			}
+			in_use = true;
+			goto out;
+		}
+	}
+out:
+	rcu_read_unlock();
+	return in_use;
+}
+
+/**
  * tomoyo_del_domain - Delete members in "struct tomoyo_domain_info".
  *
  * @element: Pointer to "struct list_head".
@@ -248,7 +286,8 @@ static inline void tomoyo_del_domain(str
 	struct tomoyo_acl_info *tmp;
 	/*
 	 * Since this domain is referenced from neither
-	 * "struct tomoyo_io_buffer" nor "struct cred"->security, we can delete
+	 * "struct tomoyo_io_buffer" nor
+	 * "struct tooyo_security"->tomoyo_domain_info, we can delete
 	 * elements without checking for is_deleted flag.
 	 */
 	list_for_each_entry_safe(acl, tmp, &domain->acl_info_list, list) {
@@ -433,12 +472,12 @@ static void tomoyo_try_to_gc(const enum 
 		break;
 	case TOMOYO_ID_DOMAIN:
 		/*
-		 * Don't kfree() until all "struct cred"->security forget this
-		 * element.
+		 * Don't kfree() until all "struct tomoyo_security"->
+		 * tomoyo_domain_info forget this element.
 		 */
-		if (atomic_read(&container_of
-				(element, typeof(struct tomoyo_domain_info),
-				 list)->users))
+		if (tomoyo_domain_used_by_task
+		    (container_of(element, typeof(struct tomoyo_domain_info),
+				  list)))
 			goto reinject;
 		break;
 	case TOMOYO_MAX_POLICY:
@@ -519,7 +558,8 @@ static void tomoyo_collect_entry(void)
 		list_for_each_entry_safe(domain, tmp, &tomoyo_domain_list,
 					 list) {
 			tomoyo_collect_acl(&domain->acl_info_list);
-			if (!domain->is_deleted || atomic_read(&domain->users))
+			if (!domain->is_deleted ||
+			    tomoyo_domain_used_by_task(domain))
 				continue;
 			tomoyo_try_to_gc(TOMOYO_ID_DOMAIN, &domain->list);
 		}
--- security-testing-2.6.orig/security/tomoyo/memory.c
+++ security-testing-2.6/security/tomoyo/memory.c
@@ -192,6 +192,8 @@ void __init tomoyo_mm_init(void)
 	int idx;
 	for (idx = 0; idx < TOMOYO_MAX_HASH; idx++)
 		INIT_LIST_HEAD(&tomoyo_name_list[idx]);
+	for (idx = 0; idx < TOMOYO_MAX_TASK_SECURITY_HASH; idx++)
+                INIT_LIST_HEAD(&tomoyo_task_security_list[idx]);
 	tomoyo_kernel_namespace.name = "<kernel>";
 	tomoyo_init_policy_namespace(&tomoyo_kernel_namespace);
 	tomoyo_kernel_domain.ns = &tomoyo_kernel_namespace;
--- security-testing-2.6.orig/security/tomoyo/mount.c
+++ security-testing-2.6/security/tomoyo/mount.c
@@ -191,7 +191,7 @@ int tomoyo_mount_permission(char *dev_na
 	int error;
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_MOUNT)
+	if (tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_MOUNT)
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
--- security-testing-2.6.orig/security/tomoyo/network.c
+++ security-testing-2.6/security/tomoyo/network.c
@@ -470,7 +470,7 @@ static int tomoyo_inet_entry(const struc
 	int error = 0;
 	const u8 type = tomoyo_inet2mac[address->protocol][address->operation];
 
-	if (type && tomoyo_init_request_info(&r, NULL, type)
+	if (type && tomoyo_init_request_info(&r, type)
 	    != TOMOYO_CONFIG_DISABLED) {
 		r.param_type = TOMOYO_TYPE_INET_ACL;
 		r.param.inet_network.protocol = address->protocol;
@@ -545,7 +545,7 @@ static int tomoyo_unix_entry(const struc
 	int error = 0;
 	const u8 type = tomoyo_unix2mac[address->protocol][address->operation];
 
-	if (type && tomoyo_init_request_info(&r, NULL, type)
+	if (type && tomoyo_init_request_info(&r, type)
 	    != TOMOYO_CONFIG_DISABLED) {
 		char *buf = address->unix0.addr;
 		int len = address->unix0.addr_len - sizeof(sa_family_t);
--- security-testing-2.6.orig/security/tomoyo/securityfs_if.c
+++ security-testing-2.6/security/tomoyo/securityfs_if.c
@@ -58,32 +58,14 @@ static ssize_t tomoyo_write_self(struct 
 		name.name = data;
 		tomoyo_fill_path_info(&name);
 		/* Check "task manual_domain_transition" permission. */
-		tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_EXECUTE);
+		tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_EXECUTE);
 		r.param_type = TOMOYO_TYPE_MANUAL_TASK_ACL;
 		r.param.task.domainname = &name;
 		tomoyo_check_acl(&r, tomoyo_check_task_acl);
 		if (!r.granted)
 			error = -EPERM;
-		else {
-			struct tomoyo_domain_info *new_domain =
-				tomoyo_assign_domain(data, true);
-			if (!new_domain) {
-				error = -ENOENT;
-			} else {
-				struct cred *cred = prepare_creds();
-				if (!cred) {
-					error = -ENOMEM;
-				} else {
-					struct tomoyo_domain_info *old_domain =
-						cred->security;
-					cred->security = new_domain;
-					atomic_inc(&new_domain->users);
-					atomic_dec(&old_domain->users);
-					commit_creds(cred);
-					error = 0;
-				}
-			}
-		}
+		else
+			error = tomoyo_assign_domain(data, true) ? 0 : -ENOENT;
 		tomoyo_read_unlock(idx);
 	} else
 		error = -EINVAL;
@@ -105,7 +87,7 @@ out:
 static ssize_t tomoyo_read_self(struct file *file, char __user *buf,
 				size_t count, loff_t *ppos)
 {
-	const char *domain = tomoyo_domain()->domainname->name;
+	const char *domain = tomoyo_current_domain()->domainname->name;
 	loff_t len = strlen(domain);
 	loff_t pos = *ppos;
 	if (pos >= len || !count)
@@ -241,7 +223,7 @@ static int __init tomoyo_initerface_init
 	struct dentry *tomoyo_dir;
 
 	/* Don't create securityfs entries unless registered. */
-	if (current_cred()->security != &tomoyo_kernel_domain)
+	if (!tomoyo_registered)
 		return 0;
 
 	tomoyo_dir = securityfs_create_dir("tomoyo", NULL);
--- security-testing-2.6.orig/security/tomoyo/tomoyo.c
+++ security-testing-2.6/security/tomoyo/tomoyo.c
@@ -5,138 +5,10 @@
  */
 
 #include <linux/security.h>
+#include <linux/hash.h>
 #include "common.h"
 
 /**
- * tomoyo_cred_alloc_blank - Target for security_cred_alloc_blank().
- *
- * @new: Pointer to "struct cred".
- * @gfp: Memory allocation flags.
- *
- * Returns 0.
- */
-static int tomoyo_cred_alloc_blank(struct cred *new, gfp_t gfp)
-{
-	new->security = NULL;
-	return 0;
-}
-
-/**
- * tomoyo_cred_prepare - Target for security_prepare_creds().
- *
- * @new: Pointer to "struct cred".
- * @old: Pointer to "struct cred".
- * @gfp: Memory allocation flags.
- *
- * Returns 0.
- */
-static int tomoyo_cred_prepare(struct cred *new, const struct cred *old,
-			       gfp_t gfp)
-{
-	struct tomoyo_domain_info *domain = old->security;
-	new->security = domain;
-	if (domain)
-		atomic_inc(&domain->users);
-	return 0;
-}
-
-/**
- * tomoyo_cred_transfer - Target for security_transfer_creds().
- *
- * @new: Pointer to "struct cred".
- * @old: Pointer to "struct cred".
- */
-static void tomoyo_cred_transfer(struct cred *new, const struct cred *old)
-{
-	tomoyo_cred_prepare(new, old, 0);
-}
-
-/**
- * tomoyo_cred_free - Target for security_cred_free().
- *
- * @cred: Pointer to "struct cred".
- */
-static void tomoyo_cred_free(struct cred *cred)
-{
-	struct tomoyo_domain_info *domain = cred->security;
-	if (domain)
-		atomic_dec(&domain->users);
-}
-
-/**
- * tomoyo_bprm_set_creds - Target for security_bprm_set_creds().
- *
- * @bprm: Pointer to "struct linux_binprm".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int tomoyo_bprm_set_creds(struct linux_binprm *bprm)
-{
-	int rc;
-
-	rc = cap_bprm_set_creds(bprm);
-	if (rc)
-		return rc;
-
-	/*
-	 * Do only if this function is called for the first time of an execve
-	 * operation.
-	 */
-	if (bprm->cred_prepared)
-		return 0;
-#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER
-	/*
-	 * Load policy if /sbin/tomoyo-init exists and /sbin/init is requested
-	 * for the first time.
-	 */
-	if (!tomoyo_policy_loaded)
-		tomoyo_load_policy(bprm->filename);
-#endif
-	/*
-	 * Release reference to "struct tomoyo_domain_info" stored inside
-	 * "bprm->cred->security". New reference to "struct tomoyo_domain_info"
-	 * stored inside "bprm->cred->security" will be acquired later inside
-	 * tomoyo_find_next_domain().
-	 */
-	atomic_dec(&((struct tomoyo_domain_info *)
-		     bprm->cred->security)->users);
-	/*
-	 * Tell tomoyo_bprm_check_security() is called for the first time of an
-	 * execve operation.
-	 */
-	bprm->cred->security = NULL;
-	return 0;
-}
-
-/**
- * tomoyo_bprm_check_security - Target for security_bprm_check().
- *
- * @bprm: Pointer to "struct linux_binprm".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int tomoyo_bprm_check_security(struct linux_binprm *bprm)
-{
-	struct tomoyo_domain_info *domain = bprm->cred->security;
-
-	/*
-	 * Execute permission is checked against pathname passed to do_execve()
-	 * using current domain.
-	 */
-	if (!domain) {
-		const int idx = tomoyo_read_lock();
-		const int err = tomoyo_find_next_domain(bprm);
-		tomoyo_read_unlock(idx);
-		return err;
-	}
-	/*
-	 * Read permission is checked against interpreters using next domain.
-	 */
-	return tomoyo_check_open_permission(domain, &bprm->file->f_path,
-					    O_RDONLY);
-}
-
-/**
  * tomoyo_inode_getattr - Target for security_inode_getattr().
  *
  * @mnt:    Pointer to "struct vfsmount".
@@ -314,7 +186,7 @@ static int tomoyo_file_fcntl(struct file
 {
 	if (!(cmd == F_SETFL && ((arg ^ file->f_flags) & O_APPEND)))
 		return 0;
-	return tomoyo_check_open_permission(tomoyo_domain(), &file->f_path,
+	return tomoyo_check_open_permission(&file->f_path,
 					    O_WRONLY | (arg & O_APPEND));
 }
 
@@ -328,11 +200,15 @@ static int tomoyo_file_fcntl(struct file
  */
 static int tomoyo_dentry_open(struct file *f, const struct cred *cred)
 {
-	int flags = f->f_flags;
-	/* Don't check read permission here if called from do_execve(). */
-	if (current->in_execve)
+	/*
+	 * Don't check read permission here if called from do_execve().
+	 * But check read permission here if called from (e.g.)
+	 * load_elf_binary().
+	 */
+	if (current->in_execve &&
+	    !tomoyo_current_security()->previous_domain_info)
 		return 0;
-	return tomoyo_check_open_permission(tomoyo_domain(), &f->f_path, flags);
+	return tomoyo_check_open_permission(&f->f_path, f->f_flags);
 }
 
 /**
@@ -500,17 +376,192 @@ static int tomoyo_socket_sendmsg(struct 
 	return tomoyo_socket_sendmsg_permission(sock, msg, size);
 }
 
+/* Dummy security context for avoiding NULL pointer dereference. */
+static struct tomoyo_security tomoyo_null_security = {
+	.tomoyo_domain_info = &tomoyo_kernel_domain,
+};
+
+/* Security context for init_task task. */
+static struct tomoyo_security tomoyo_init_security = {
+	.task = &init_task,
+	.tomoyo_domain_info = &tomoyo_kernel_domain,
+};
+
+/* List of "struct tomoyo_security". */
+struct list_head tomoyo_task_security_list[TOMOYO_MAX_TASK_SECURITY_HASH];
+/* Lock for protecting tomoyo_task_security_list[]. */
+static DEFINE_SPINLOCK(tomoyo_task_security_list_lock);
+
+/**
+ * tomoyo_add_task_security - Add "struct tomoyo_security" to list.
+ *
+ * @ptr:  Pointer to "struct tomoyo_security".
+ * @list: Pointer to "struct list_head".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_add_task_security(struct tomoyo_security *ptr,
+				     struct list_head *list)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&tomoyo_task_security_list_lock, flags);
+	list_add_rcu(&ptr->list, list);
+	spin_unlock_irqrestore(&tomoyo_task_security_list_lock, flags);
+}
+
+/**
+ * tomoyo_alloc_task_security - Allocate memory for new tasks.
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_alloc_task_security(struct task_struct *task)
+{
+	struct tomoyo_security *old_security = tomoyo_current_security();
+	struct tomoyo_security *new_security = kzalloc(sizeof(*new_security),
+						       GFP_KERNEL);
+	struct list_head *list = &tomoyo_task_security_list
+		[hash_ptr((void *) task, TOMOYO_TASK_SECURITY_HASH_BITS)];
+	if (!new_security)
+		return -ENOMEM;
+	*new_security = *old_security;
+	new_security->task = task;
+	tomoyo_add_task_security(new_security, list);
+	return 0;
+}
+
+/**
+ * tomoyo_find_task_security - Find "struct tomoyo_security" for given task.
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns pointer to "struct tomoyo_security".
+ */
+struct tomoyo_security *tomoyo_find_task_security
+(const struct task_struct *task)
+{
+	struct tomoyo_security *ptr;
+	struct list_head *list = &tomoyo_task_security_list
+		[hash_ptr((void *) task, TOMOYO_TASK_SECURITY_HASH_BITS)];
+	rcu_read_lock();
+	list_for_each_entry_rcu(ptr, list, list) {
+		if (ptr->task != task)
+			continue;
+		rcu_read_unlock();
+		return ptr;
+	}
+	rcu_read_unlock();
+	return &tomoyo_null_security;
+}
+
+/**
+ * tomoyo_rcu_free - RCU callback for releasing "struct tomoyo_security".
+ *
+ * @rcu: Pointer to "struct rcu_head".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_rcu_free(struct rcu_head *rcu)
+{
+	struct tomoyo_security *ptr = container_of(rcu, typeof(*ptr), rcu);
+	kfree(ptr);
+}
+
+/**
+ * tomoyo_free_task_security - Release memory associated with "struct task_struct".
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_free_task_security(struct task_struct *task)
+{
+	unsigned long flags;
+	struct tomoyo_security *ptr = tomoyo_find_task_security(task);
+	if (ptr == &tomoyo_init_security || ptr == &tomoyo_null_security)
+		return;
+	spin_lock_irqsave(&tomoyo_task_security_list_lock, flags);
+	list_del_rcu(&ptr->list);
+	spin_unlock_irqrestore(&tomoyo_task_security_list_lock, flags);
+	call_rcu(&ptr->rcu, tomoyo_rcu_free);
+}
+
+/**
+ * tomoyo_bprm_committing_creds - A hook which is called when do_execve() succeeded.
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_bprm_committing_creds(struct linux_binprm *bprm)
+{
+	struct tomoyo_security *security = tomoyo_current_security();
+	/* do_execve() succeeded. Forget previous domain. */
+	security->previous_domain_info = NULL;
+}
+
+/**
+ * tomoyo_bprm_free_security - A hook which is called when do_execve() finished.
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_bprm_free_security(struct linux_binprm *bprm)
+{
+	struct tomoyo_security *security = tomoyo_current_security();
+	/*
+	 * tomoyo_bprm_committing_creds() already cleared it if do_execve()
+	 * succeeded.
+	 */
+	if (!security->previous_domain_info)
+		return;
+	/* do_execve() failed. Revert to previous domain. */
+	security->tomoyo_domain_info = security->previous_domain_info;
+	/* Make sure that GC sees valid domain. */
+	smp_wmb();
+	security->previous_domain_info = NULL;
+}
+
+/**
+ * tomoyo_bprm_check_security - Check permission for execve().
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_bprm_check_security(struct linux_binprm *bprm)
+{
+	struct tomoyo_security *security;
+#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER
+	/*
+	 * Load policy if /sbin/tomoyo-init exists and /sbin/init is requested
+	 * for the first time.
+	 */
+	if (!tomoyo_policy_loaded)
+		tomoyo_load_policy(bprm->filename);
+#endif
+	security = tomoyo_current_security();
+	if (!security->previous_domain_info) {
+		const int idx = tomoyo_read_lock();
+		const int rc = tomoyo_find_next_domain(bprm);
+		tomoyo_read_unlock(idx);
+		return rc;
+	}
+	return 0;
+}
+
 /*
  * tomoyo_security_ops is a "struct security_operations" which is used for
  * registering TOMOYO.
  */
 static struct security_operations tomoyo_security_ops = {
 	.name                = "tomoyo",
-	.cred_alloc_blank    = tomoyo_cred_alloc_blank,
-	.cred_prepare        = tomoyo_cred_prepare,
-	.cred_transfer	     = tomoyo_cred_transfer,
-	.cred_free           = tomoyo_cred_free,
-	.bprm_set_creds      = tomoyo_bprm_set_creds,
+	.task_alloc_security = tomoyo_alloc_task_security,
+	.task_free_security  = tomoyo_free_task_security,
+	.bprm_committing_creds = tomoyo_bprm_committing_creds,
+	.bprm_free_security  = tomoyo_bprm_free_security,
 	.bprm_check_security = tomoyo_bprm_check_security,
 	.file_fcntl          = tomoyo_file_fcntl,
 	.dentry_open         = tomoyo_dentry_open,
@@ -539,6 +590,9 @@ static struct security_operations tomoyo
 /* Lock for GC. */
 struct srcu_struct tomoyo_ss;
 
+/* TOMOYO registered by register_security()? */
+bool tomoyo_registered;
+
 /**
  * tomoyo_init - Register TOMOYO Linux as a LSM module.
  *
@@ -546,8 +600,6 @@ struct srcu_struct tomoyo_ss;
  */
 static int __init tomoyo_init(void)
 {
-	struct cred *cred = (struct cred *) current_cred();
-
 	if (!security_module_enable(&tomoyo_security_ops))
 		return 0;
 	/* register ourselves with the security framework */
@@ -555,8 +607,12 @@ static int __init tomoyo_init(void)
 	    init_srcu_struct(&tomoyo_ss))
 		panic("Failure registering TOMOYO Linux");
 	printk(KERN_INFO "TOMOYO Linux initialized\n");
-	cred->security = &tomoyo_kernel_domain;
+	tomoyo_registered = true;
 	tomoyo_mm_init();
+	tomoyo_add_task_security(&tomoyo_init_security,
+				 &tomoyo_task_security_list
+				 [hash_ptr((void *) &init_task,
+					   TOMOYO_TASK_SECURITY_HASH_BITS)]);
 	return 0;
 }
 
--- security-testing-2.6.orig/security/tomoyo/util.c
+++ security-testing-2.6/security/tomoyo/util.c
@@ -968,21 +968,19 @@ const char *tomoyo_get_exe(void)
 /**
  * tomoyo_get_mode - Get MAC mode.
  *
- * @ns:      Pointer to "struct tomoyo_policy_namespace".
  * @profile: Profile number.
  * @index:   Index number of functionality.
  *
  * Returns mode.
  */
-int tomoyo_get_mode(const struct tomoyo_policy_namespace *ns, const u8 profile,
-		    const u8 index)
+int tomoyo_get_mode(const u8 profile, const u8 index)
 {
 	u8 mode;
 	struct tomoyo_profile *p;
 
 	if (!tomoyo_policy_loaded)
 		return TOMOYO_CONFIG_DISABLED;
-	p = tomoyo_profile(ns, profile);
+	p = tomoyo_profile(profile);
 	mode = p->config[index];
 	if (mode == TOMOYO_CONFIG_USE_DEFAULT)
 		mode = p->config[tomoyo_index2category[index]
@@ -996,23 +994,17 @@ int tomoyo_get_mode(const struct tomoyo_
  * tomoyo_init_request_info - Initialize "struct tomoyo_request_info" members.
  *
  * @r:      Pointer to "struct tomoyo_request_info" to initialize.
- * @domain: Pointer to "struct tomoyo_domain_info". NULL for tomoyo_domain().
  * @index:  Index number of functionality.
  *
  * Returns mode.
  */
-int tomoyo_init_request_info(struct tomoyo_request_info *r,
-			     struct tomoyo_domain_info *domain, const u8 index)
+int tomoyo_init_request_info(struct tomoyo_request_info *r, const u8 index)
 {
-	u8 profile;
+	u8 profile = tomoyo_current_domain()->profile;
 	memset(r, 0, sizeof(*r));
-	if (!domain)
-		domain = tomoyo_domain();
-	r->domain = domain;
-	profile = domain->profile;
 	r->profile = profile;
 	r->type = index;
-	r->mode = tomoyo_get_mode(domain->ns, profile, index);
+	r->mode = tomoyo_get_mode(profile, index);
 	return r->mode;
 }
 
@@ -1028,7 +1020,7 @@ int tomoyo_init_request_info(struct tomo
 bool tomoyo_domain_quota_is_ok(struct tomoyo_request_info *r)
 {
 	unsigned int count = 0;
-	struct tomoyo_domain_info *domain = r->domain;
+	struct tomoyo_domain_info *domain = tomoyo_current_domain();
 	struct tomoyo_acl_info *ptr;
 
 	if (r->mode != TOMOYO_CONFIG_LEARNING)
@@ -1075,7 +1067,7 @@ bool tomoyo_domain_quota_is_ok(struct to
 			if (perm & (1 << i))
 				count++;
 	}
-	if (count < tomoyo_profile(domain->ns, domain->profile)->
+	if (count < tomoyo_profile(domain->profile)->
 	    pref[TOMOYO_PREF_MAX_LEARNING_ENTRY])
 		return true;
 	if (!domain->flags[TOMOYO_DIF_QUOTA_WARNED]) {
