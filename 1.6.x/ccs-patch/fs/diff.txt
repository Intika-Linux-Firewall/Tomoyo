Index: trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h	(revision 1034)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_proc.h	(working copy)
@@ -21,7 +21,7 @@
 
 extern void __init realpath_Init(void);
 
-/*************************  Indexes for /proc interfaces.  *************************/
+/**********************  Indexes for /proc interfaces.  **********************/
 
 #define CCS_DOMAINPOLICY          0
 #define CCS_EXCEPTIONPOLICY       1
Index: trunk/1.6.x/ccs-patch/include/linux/syaoran.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/syaoran.h	(revision 1034)
+++ trunk/1.6.x/ccs-patch/include/linux/syaoran.h	(working copy)
@@ -14,15 +14,20 @@
 /*
  * A brief description about SYAORAN:
  *
- *  SYAORAN stands for "Simple Yet All-important Object Realizing Abiding Nexus".
+ *  SYAORAN stands for "Simple Yet All-important Object Realizing Abiding
+ *  Nexus".
  *  SYAORAN is a filesystem for /dev with Mandatory Access Control.
  *
- *  /dev needs to be writable, but this means that files on /dev might be tampered with.
- *  SYAORAN can restrict combinations of (pathname, attribute) that the system can create.
+ *  /dev cannot be mounted for read-only mode, but this means that files on
+ *  /dev might be tampered with.
+ *  SYAORAN can restrict combinations of (pathname, attribute) that
+ *  the system can create.
  *  The attribute is one of directory, regular file, FIFO, UNIX domain socket,
- *  symbolic link, character or block device file with major/minor device numbers.
+ *  symbolic link, character or block device file with major/minor device
+ *  numbers.
  *
- *  You can use SYAORAN alone, but I recommend you to use with SAKURA and TOMOYO.
+ *  You can use SYAORAN alone, but I recommend you to use SYAORAN
+ *  with SAKURA and TOMOYO.
  */
 
 #ifndef _LINUX_SYAORAN_H
@@ -36,28 +41,30 @@
 
 #include <linux/version.h>
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #define s_fs_info u.generic_sbp
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 typedef _Bool bool;
 #endif
 
 #define false 0
 #define true 1
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
 static inline void *kzalloc(int size, int flags)
 {
 	void *p = kmalloc(size, flags);
-	if (p) memset(p, 0, size);
+	if (p)
+		memset(p, 0, size);
 	return p;
 }
 #endif
 
 #define list_for_each_cookie(pos, cookie, head) \
-	for (({if (!cookie) cookie = head;}), pos = (cookie)->next; \
+	for (({ if (!cookie) \
+		cookie = head; }), pos = (cookie)->next; \
 		prefetch(pos->next), pos != (head) || ((cookie) = NULL); \
 		(cookie) = pos, pos = pos->next)
 
@@ -65,7 +72,7 @@
 #define list_for_each_entry_safe(pos, n, head, member)                  \
 	for (pos = list_entry((head)->next, typeof(*pos), member),      \
 		n = list_entry(pos->member.next, typeof(*pos), member); \
-		&pos->member != (head);                                    \
+		&pos->member != (head);                                 \
 		pos = n, n = list_entry(n->member.next, typeof(*n), member))
 #endif
 
@@ -86,53 +93,60 @@
 static void MakeInitialNodes(struct super_block *sb);
 static int MayCreateNode(struct dentry *dentry, int mode, int dev);
 static int MayModifyNode(struct dentry *dentry, unsigned int flags);
-static int syaoran_create_tracelog(struct super_block *sb, const char *filename);
+static int syaoran_create_tracelog(struct super_block *sb,
+				   const char *filename);
 
 /* Wraps blkdev_open() to trace open operation for block devices. */
-static int (*org_blkdev_open) (struct inode * inode, struct file * filp) = NULL;
+static int (*org_blkdev_open) (struct inode *inode, struct file *filp);
 static struct file_operations wrapped_def_blk_fops;
 
-static int wrapped_blkdev_open(struct inode * inode, struct file * filp)
+static int wrapped_blkdev_open(struct inode *inode, struct file *filp)
 {
 	int error = org_blkdev_open(inode, filp);
-	if (error != -ENXIO) MayModifyNode(filp->f_dentry, DEVICE_USED);
+	if (error != -ENXIO)
+		MayModifyNode(filp->f_dentry, DEVICE_USED);
 	return error;
 }
 
 /* Wraps chrdev_open() to trace open operation for character devices. */
-static int (*org_chrdev_open) (struct inode * inode, struct file * filp) = NULL;
+static int (*org_chrdev_open) (struct inode *inode, struct file *filp);
 static struct file_operations wrapped_def_chr_fops;
 
-static int wrapped_chrdev_open(struct inode * inode, struct file * filp)
+static int wrapped_chrdev_open(struct inode *inode, struct file *filp)
 {
 	int error = org_chrdev_open(inode, filp);
-	if (error != -ENXIO) MayModifyNode(filp->f_dentry, DEVICE_USED);
+	if (error != -ENXIO)
+		MayModifyNode(filp->f_dentry, DEVICE_USED);
 	return error;
 }
 
 /* lookup_create() without nameidata. Called only while initialization. */
-static struct dentry *lookup_create2(const char *name, struct dentry *base, const u8 is_dir)
+static struct dentry *lookup_create2(const char *name, struct dentry *base,
+				     const bool is_dir)
 {
 	struct dentry *dentry;
 	const int len = name ? strlen(name) : 0;
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 	mutex_lock(&base->d_inode->i_mutex);
 #else
 	down(&base->d_inode->i_sem);
 #endif
 	dentry = lookup_one_len(name, base, len);
-	if (IS_ERR(dentry)) goto fail;
-	if (!is_dir && name[len] && !dentry->d_inode) goto enoent;
+	if (IS_ERR(dentry))
+		goto fail;
+	if (!is_dir && name[len] && !dentry->d_inode)
+		goto enoent;
 	return dentry;
- enoent:
+enoent:
 	dput(dentry);
 	dentry = ERR_PTR(-ENOENT);
- fail:
+fail:
 	return dentry;
 }
 
 /* mkdir(). Called only while initialization. */
-static int fs_mkdir(const char *pathname, struct dentry *base, int mode, uid_t user, gid_t group)
+static int fs_mkdir(const char *pathname, struct dentry *base, int mode,
+		    uid_t user, gid_t group)
 {
 	struct dentry *dentry = lookup_create2(pathname, base, 1);
 	int error = PTR_ERR(dentry);
@@ -146,7 +160,7 @@
 		}
 		dput(dentry);
 	}
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 	mutex_unlock(&base->d_inode->i_mutex);
 #else
 	up(&base->d_inode->i_sem);
@@ -155,12 +169,17 @@
 }
 
 /* mknod(). Called only while initialization. */
-static int fs_mknod(const char *filename, struct dentry *base, int mode, dev_t dev, uid_t user, gid_t group)
+static int fs_mknod(const char *filename, struct dentry *base, int mode,
+		    dev_t dev, uid_t user, gid_t group)
 {
 	struct dentry *dentry;
 	int error;
 	switch (mode & S_IFMT) {
-	case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK: case S_IFREG:
+	case S_IFCHR:
+	case S_IFBLK:
+	case S_IFIFO:
+	case S_IFSOCK:
+	case S_IFREG:
 		break;
 	default:
 		return -EPERM;
@@ -177,7 +196,7 @@
 		}
 		dput(dentry);
 	}
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 	mutex_unlock(&base->d_inode->i_mutex);
 #else
 	up(&base->d_inode->i_sem);
@@ -186,7 +205,8 @@
 }
 
 /* symlink(). Called only while initialization. */
-static int fs_symlink(const char *pathname, struct dentry *base, char *oldname, int mode, uid_t user, gid_t group)
+static int fs_symlink(const char *pathname, struct dentry *base, char *oldname,
+		      int mode, uid_t user, gid_t group)
 {
 	struct dentry *dentry = lookup_create2(pathname, base, 0);
 	int error = PTR_ERR(dentry);
@@ -205,7 +225,7 @@
 		}
 		dput(dentry);
 	}
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 	mutex_unlock(&base->d_inode->i_mutex);
 #else
 	up(&base->d_inode->i_sem);
@@ -222,12 +242,16 @@
 {
 	unsigned char *sp = buffer, *dp = buffer;
 	bool first = true;
-	while (*sp && (*sp <= ' ' || *sp >= 127)) sp++;
+	while (*sp && (*sp <= ' ' || *sp >= 127))
+		sp++;
 	while (*sp) {
-		if (!first) *dp++ = ' ';
+		if (!first)
+			*dp++ = ' ';
 		first = false;
-		while (*sp > ' ' && *sp < 127) *dp++ = *sp++;
-		while (*sp && (*sp <= ' ' || *sp >= 127)) sp++;
+		while (*sp > ' ' && *sp < 127)
+			*dp++ = *sp++;
+		while (*sp && (*sp <= ' ' || *sp >= 127))
+			sp++;
 	}
 	*dp = '\0';
 }
@@ -237,13 +261,15 @@
 {
 	char *cp = filename;
 	char c, d, e;
-	if (!cp) return;
+	if (!cp)
+		return;
 	while ((c = *filename++) != '\0') {
 		if (c != '\\') {
 			*cp++ = c;
 			continue;
 		}
-		if ((c = *filename++) == '\\') {
+		c = *filename++;
+		if (c == '\\') {
 			*cp++ = c;
 			continue;
 		}
@@ -252,26 +278,33 @@
 			(e = *filename++) < '0' || e > '7') {
 			break;
 		}
-		* (unsigned char *) cp++ = (unsigned char) (((unsigned char) (c - '0') << 6) + ((unsigned char) (d - '0') << 3) + (unsigned char) (e - '0'));
+		*(unsigned char *) cp++ = (unsigned char)
+			(((unsigned char) (c - '0') << 6)
+			 + ((unsigned char) (d - '0') << 3)
+			 + (unsigned char) (e - '0'));
 	}
 	*cp = '\0';
 }
 
 static char *strdup(const char *str)
 {
-	char *cp;
 	const int len = str ? strlen(str) + 1 : 0;
-	if ((cp = kzalloc(len, GFP_KERNEL)) != NULL) memmove(cp, str, len);
+	char *cp = kzalloc(len, GFP_KERNEL);
+	if (cp)
+		memmove(cp, str, len);
 	return cp;
 }
 
-static int syaoran_default_mode = -1; /* -1: Not specified, 0: Enforce by default, 1: Accept by default. */
+/* -1: Not specified, 0: Enforce by default, 1: Accept by default. */
+static int syaoran_default_mode = -1;
 
 #if !defined(MODULE)
 static int __init SYAORAN_Setup(char *str)
 {
-	if (strcmp(str, "accept") == 0) syaoran_default_mode = 1;
-	else if (strcmp(str, "enforce") == 0) syaoran_default_mode = 0;
+	if (strcmp(str, "accept") == 0)
+		syaoran_default_mode = 1;
+	else if (strcmp(str, "enforce") == 0)
+		syaoran_default_mode = 0;
 	return 0;
 }
 
@@ -280,21 +313,34 @@
 
 struct dev_entry {
 	struct list_head list;
-	char *name;                         /* Binary form of pathname under mount point. Never NULL.                */
-	mode_t mode;                        /* Mode and permissions. setuid/setgid/sticky bits are not supported.    */
+	/* Binary form of pathname under mount point. Never NULL. */
+	char *name;
+	/*
+	 * Mode and permissions.
+	 * setuid/setgid/sticky bits are not supported.
+	 */
+	mode_t mode;
 	uid_t uid;
 	gid_t gid;
 	dev_t kdev;
-	char *symlink_data;                 /* Binary form of initial contents for the symlink. NULL if not symlink. */
-	unsigned int flags;                 /* File access control flags.                                            */
-	const char *printable_name;         /* Text form of pathname under mount point. Never NULL.                  */
-	const char *printable_symlink_data; /* Text form of initial contents for the symlink. NULL if not symlink.   */
+	/*
+	 * Binary form of initial contents for the symlink. NULL if not symlink.
+	 */
+	char *symlink_data;
+	/* File access control flags. */
+	unsigned int flags;
+	/* Text form of pathname under mount point. Never NULL. */
+	const char *printable_name;
+	/*
+	 * Text form of initial contents for the symlink. NULL if not symlink.
+	 */
+	const char *printable_symlink_data;
 };
 
 struct syaoran_sb_info {
 	struct list_head list;
-	bool initialize_done;           /* False if initialization is in progress. */
-	bool is_permissive_mode;        /* True if permissive mode.                */
+	bool initialize_done;     /* False if initialization is in progress. */
+	bool is_permissive_mode;  /* True if permissive mode.                */
 };
 
 static int RegisterNodeInfo(char *buffer, struct super_block *sb)
@@ -315,33 +361,52 @@
 	int i;
 	int error = -EINVAL;
 	unsigned int perm, uid, gid, flags, major = 0, minor = 0;
-	struct syaoran_sb_info *info = (struct syaoran_sb_info *) sb->s_fs_info;
+	struct syaoran_sb_info *info =
+		(struct syaoran_sb_info *) sb->s_fs_info;
 	struct dev_entry *entry;
 	memset(args, 0, sizeof(args));
 	args[0] = buffer;
 	for (i = 1; i < MAX_ARG; i++) {
 		args[i] = strchr(args[i - 1] + 1, ' ');
-		if (!args[i]) break;
+		if (!args[i])
+			break;
 		*args[i]++ = '\0';
 	}
-	/* printk("<%s> <%s> <%s> <%s> <%s> <%s> <%s> <%s>\n", args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]); */
-	if (!args[ARG_FILENAME] || !args[ARG_PERMISSION] || !args[ARG_UID] || !args[ARG_GID] || !args[ARG_DEV_TYPE] || !args[ARG_FLAGS]) goto out;
-	if (sscanf(args[ARG_PERMISSION], "%o", &perm) != 1 || !(perm <= 0777) || sscanf(args[ARG_UID], "%u", &uid) != 1
-		|| sscanf(args[ARG_GID], "%u", &gid) != 1 || sscanf(args[ARG_FLAGS], "%u", &flags) != 1 || *(args[ARG_DEV_TYPE] + 1)) goto out;
+	/*
+	  printk(KERN_DEBUG "<%s> <%s> <%s> <%s> <%s> <%s> <%s> <%s>\n",
+	  args[0], args[1], args[2], args[3], args[4], args[5], args[6],
+	  args[7]);
+	*/
+	if (!args[ARG_FILENAME] || !args[ARG_PERMISSION] || !args[ARG_UID] ||
+	    !args[ARG_GID] || !args[ARG_DEV_TYPE] || !args[ARG_FLAGS])
+		goto out;
+	if (sscanf(args[ARG_PERMISSION], "%o", &perm) != 1 ||
+	    !(perm <= 0777) || sscanf(args[ARG_UID], "%u", &uid) != 1 ||
+	    sscanf(args[ARG_GID], "%u", &gid) != 1 ||
+	    sscanf(args[ARG_FLAGS], "%u", &flags) != 1 ||
+	    *(args[ARG_DEV_TYPE] + 1))
+		goto out;
 	switch (*args[ARG_DEV_TYPE]) {
 	case 'c':
 		perm |= S_IFCHR;
-		if (!args[ARG_DEV_MAJOR] || sscanf(args[ARG_DEV_MAJOR], "%u", &major) != 1
-			|| !args[ARG_DEV_MINOR] || sscanf(args[ARG_DEV_MINOR], "%u", &minor) != 1) goto out;
+		if (!args[ARG_DEV_MAJOR] ||
+		    sscanf(args[ARG_DEV_MAJOR], "%u", &major) != 1 ||
+		    !args[ARG_DEV_MINOR] ||
+		    sscanf(args[ARG_DEV_MINOR], "%u", &minor) != 1)
+			goto out;
 		break;
 	case 'b':
 		perm |= S_IFBLK;
-		if (!args[ARG_DEV_MAJOR] || sscanf(args[ARG_DEV_MAJOR], "%u", &major) != 1
-			|| !args[ARG_DEV_MINOR] || sscanf(args[ARG_DEV_MINOR], "%u", &minor) != 1) goto out;
+		if (!args[ARG_DEV_MAJOR] ||
+		    sscanf(args[ARG_DEV_MAJOR], "%u", &major) != 1 ||
+		    !args[ARG_DEV_MINOR] ||
+		    sscanf(args[ARG_DEV_MINOR], "%u", &minor) != 1)
+			goto out;
 		break;
 	case 'l':
 		perm |= S_IFLNK;
-		if (!args[ARG_SYMLINK_DATA]) goto out;
+		if (!args[ARG_SYMLINK_DATA])
+			goto out;
 		break;
 	case 'd':
 		perm |= S_IFDIR;
@@ -359,20 +424,35 @@
 		goto out;
 	}
 	error = -ENOMEM;
-	if ((entry = kzalloc(sizeof(*entry), GFP_KERNEL)) == NULL) goto out;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		goto out;
 	if (S_ISLNK(perm)) {
-		if ((entry->printable_symlink_data = strdup(args[ARG_SYMLINK_DATA])) == NULL) goto out_freemem;
+		entry->printable_symlink_data = strdup(args[ARG_SYMLINK_DATA]);
+		if (!entry->printable_symlink_data)
+			goto out_freemem;
 	}
-	if ((entry->printable_name = strdup(args[ARG_FILENAME])) == NULL) goto out_freemem;
+	entry->printable_name = strdup(args[ARG_FILENAME]);
+	if (!entry->printable_name)
+		goto out_freemem;
 	if (S_ISLNK(perm)) {
-		if ((entry->symlink_data = strdup(entry->printable_symlink_data)) == NULL) goto out_freemem;
+		entry->symlink_data = strdup(entry->printable_symlink_data);
+		if (!entry->symlink_data)
+			goto out_freemem;
 		UnEscape(entry->symlink_data);
 	}
-	if ((entry->name = strdup(entry->printable_name)) == NULL) goto out_freemem;
+	entry->name = strdup(entry->printable_name);
+	if (!entry->name)
+		goto out_freemem;
 	UnEscape(entry->name);
-	{   /* Drop trailing '/', for GetLocalAbsolutePath() doesn't append trailing '/'. */
+	{
+		/*
+		 * Drop trailing '/', for GetLocalAbsolutePath() doesn't append
+		 * trailing '/'.
+		 */
 		const int len = strlen(entry->name);
-		if (len && entry->name[len - 1] == '/') entry->name[len - 1] = '\0';
+		if (len && entry->name[len - 1] == '/')
+			entry->name[len - 1] = '\0';
 	}
 	entry->mode = perm;
 	entry->uid = uid;
@@ -380,7 +460,7 @@
 	entry->kdev = S_ISCHR(perm) || S_ISBLK(perm) ? MKDEV(major, minor) : 0;
 	entry->flags = flags;
 	list_add_tail(&entry->list, &info->list);
-	/* printk("Entry added.\n"); */
+	/* printk(KERN_DEBUG "Entry added.\n"); */
 	error = 0;
  out:
 	return error;
@@ -396,40 +476,46 @@
 {
 	struct syaoran_sb_info *info;
 	struct dev_entry *entry, *tmp;
-	if (!sb) return;
+	if (!sb)
+		return;
 	info = (struct syaoran_sb_info *) sb->s_fs_info;
-	if (!info) return;
+	if (!info)
+		return;
 	list_for_each_entry_safe(entry, tmp, &info->list, list) {
 		kfree(entry->name);
 		kfree(entry->symlink_data);
 		kfree(entry->printable_name);
 		kfree(entry->printable_symlink_data);
 		list_del(&entry->list);
-		/* printk("Entry removed.\n"); */
+		/* printk(KERN_DEBUG "Entry removed.\n"); */
 		kfree(entry);
 	}
 	kfree(info);
 	sb->s_fs_info = NULL;
-	printk("%s: Unused memory freed.\n", __FUNCTION__);
+	printk(KERN_INFO "%s: Unused memory freed.\n", __func__);
 }
 
 static int ReadConfigFile(struct file *file, struct super_block *sb)
 {
 	char *buffer;
+	int len;
+	char *cp;
+	unsigned long offset = 0;
 	int error = -ENOMEM;
-	if (!file) return -EINVAL;
-	if ((buffer = kzalloc(PAGE_SIZE, GFP_KERNEL)) != NULL) {
-		int len;
-		char *cp;
-		unsigned long offset = 0;
-		while ((len = kernel_read(file, offset, buffer, PAGE_SIZE)) > 0 && (cp = memchr(buffer, '\n', len)) != NULL) {
-			*cp = '\0';
-			offset += cp - buffer + 1;
-			NormalizeLine(buffer);
-			if (RegisterNodeInfo(buffer, sb) == -ENOMEM) goto out;
-		}
-		error = 0;
+	if (!file)
+		return -EINVAL;
+	buffer = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (!buffer)
+		goto out;
+	while ((len = kernel_read(file, offset, buffer, PAGE_SIZE)) > 0 &&
+	       (cp = memchr(buffer, '\n', len)) != NULL) {
+		*cp = '\0';
+		offset += cp - buffer + 1;
+		NormalizeLine(buffer);
+		if (RegisterNodeInfo(buffer, sb) == -ENOMEM)
+			goto out;
 	}
+	error = 0;
  out:
 	kfree(buffer);
 	return error;
@@ -445,12 +531,12 @@
 	const uid_t uid = entry->uid;
 	const gid_t gid = entry->gid;
 	goto start;
-	while ((c = * (unsigned char *) filename) != '\0') {
+	while ((c = *(unsigned char *) filename) != '\0') {
 		if (c == '/') {
 			struct dentry *new_base;
 			const int len = filename - name;
 			*filename = '\0';
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 			mutex_lock(&base->d_inode->i_mutex);
 			new_base = lookup_one_len(name, base, len);
 			mutex_unlock(&base->d_inode->i_mutex);
@@ -460,40 +546,43 @@
 			up(&base->d_inode->i_sem);
 #endif
 			dput(base);
-			/*
+			*filename++ = '/';
 			if (IS_ERR(new_base)) {
-				printk("'%s' = %ld\n", entry->name, PTR_ERR(new_base));
-			} else if (!new_base->d_inode || !S_ISDIR(new_base->d_inode->i_mode)) {
-				printk("Directory '%s' does not exist.\n", entry->name);
-			} else {
-				printk("Directory '%s' exists.\n", entry->name);
-			}
-			*/
-			*filename = '/';
-			filename++;
-			if (IS_ERR(new_base)) {
+				/*
+				printk(KERN_DEBUG "'%s' = %ld\n", entry->name,
+				       PTR_ERR(new_base));
+				*/
 				return;
-			} else if (!new_base->d_inode || !S_ISDIR(new_base->d_inode->i_mode)) {
+			} else if (!new_base->d_inode ||
+				   !S_ISDIR(new_base->d_inode->i_mode)) {
+				/*
+				printk(KERN_DEBUG
+				       "Directory '%s' does not exist.\n",
+				       entry->name);
+				*/
 				dput(new_base);
 				return;
 			}
+			/*
+			printk(KERN_DEBUG "Directory '%s' exists.\n",
+			       entry->name);
+			*/
 			base = new_base;
-		start:
+start:
 			name = filename;
 		} else {
 			filename++;
 		}
 	}
 	filename = (char *) name;
-	if (S_ISLNK(perm)) {
+	if (S_ISLNK(perm))
 		fs_symlink(filename, base, entry->symlink_data, perm, uid, gid);
-	} else if (S_ISDIR(perm)) {
+	else if (S_ISDIR(perm))
 		fs_mkdir(filename, base, perm ^ S_IFDIR, uid, gid);
-	} else if (S_ISSOCK(perm) || S_ISFIFO(perm) || S_ISREG(perm)) {
+	else if (S_ISSOCK(perm) || S_ISFIFO(perm) || S_ISREG(perm))
 		fs_mknod(filename, base, perm, 0, uid, gid);
-	} else if (S_ISCHR(perm) || S_ISBLK(perm)) {
+	else if (S_ISCHR(perm) || S_ISBLK(perm))
 		fs_mknod(filename, base, perm, entry->kdev, uid, gid);
-	}
 	dput(base);
 }
 
@@ -502,15 +591,18 @@
 {
 	struct syaoran_sb_info *info;
 	struct dev_entry *entry;
-	if (!sb) return;
+	if (!sb)
+		return;
 	info = (struct syaoran_sb_info *) sb->s_fs_info;
-	if (!info) return;
+	if (!info)
+		return;
 	if (info->is_permissive_mode) {
 		syaoran_create_tracelog(sb, ".syaoran");
 		syaoran_create_tracelog(sb, ".syaoran_all");
 	}
 	list_for_each_entry(entry, &info->list, list) {
-		if ((entry->flags & NO_CREATE_AT_MOUNT) == 0) MakeNode(entry, sb->s_root);
+		if ((entry->flags & NO_CREATE_AT_MOUNT) == 0)
+			MakeNode(entry, sb->s_root);
 	}
 	info->initialize_done = true;
 }
@@ -519,14 +611,18 @@
 static int Syaoran_Initialize(struct super_block *sb, void *data)
 {
 	int error = -EINVAL;
+	struct file *f;
+	char *filename = (char *) data;
+	bool is_permissive_mode = syaoran_default_mode;
 	static bool first = true;
 	if (first) {
 		first = false;
-		printk("SYAORAN: 1.6.0-pre   2008/03/04\n");
+		printk(KERN_INFO "SYAORAN: 1.6.0-pre   2008/03/04\n");
 	}
 	{
 		struct inode *inode = new_inode(sb);
-		if (!inode) return -EINVAL;
+		if (!inode)
+			return -EINVAL;
 		/* Create /dev/ram0 to get the value of blkdev_open(). */
 		init_special_inode(inode, S_IFBLK | 0666, MKDEV(1, 0));
 		wrapped_def_blk_fops = *inode->i_fop;
@@ -536,7 +632,8 @@
 	}
 	{
 		struct inode *inode = new_inode(sb);
-		if (!inode) return -EINVAL;
+		if (!inode)
+			return -EINVAL;
 		/* Create /dev/null to get the value of chrdev_open(). */
 		init_special_inode(inode, S_IFCHR | 0666, MKDEV(1, 3));
 		wrapped_def_chr_fops = *inode->i_fop;
@@ -544,40 +641,45 @@
 		org_chrdev_open = wrapped_def_chr_fops.open;
 		wrapped_def_chr_fops.open = wrapped_chrdev_open;
 	}
-	if (data) {
-		struct file *f;
-		char *filename = (char *) data;
-		bool is_permissive_mode = syaoran_default_mode;
-		/* If mode is given with mount operation, use it. */
-		if (strncmp(filename, "accept=", 7) == 0) {
-			filename += 7;
-			is_permissive_mode = true;
-		} else if (strncmp(filename, "enforce=", 8) == 0) {
-			filename += 8;
-			is_permissive_mode = false;
-		} else if (syaoran_default_mode == -1) {
-			/* If mode is not given with command line, abort mount. */
-			printk("SYAORAN: Missing 'accept=' or 'enforce='.\n");
-			return -EINVAL;
-		}
-		f = filp_open(filename, O_RDONLY, 0600);
-		if (!IS_ERR(f)) {
-			struct syaoran_sb_info *p;
-			if (!S_ISREG(f->f_dentry->d_inode->i_mode)) goto out;
-			if ((p = sb->s_fs_info = kzalloc(sizeof(*p), GFP_KERNEL)) == NULL) goto out;
-			p->is_permissive_mode = is_permissive_mode;
-			INIT_LIST_HEAD(&((struct syaoran_sb_info *) sb->s_fs_info)->list);
-			printk("SYAORAN: Reading '%s'\n", filename);
-			error = ReadConfigFile(f, sb);
-		out:
-			if (error) printk("SYAORAN: Can't read '%s'\n", filename);
-			filp_close(f, NULL);
-		} else {
-			printk("SYAORAN: Can't open '%s'\n", filename);
-		}
-	} else {
-		printk("SYAORAN: Missing config-file path.\n");
+	if (!filename) {
+		printk(KERN_WARNING "SYAORAN: Missing config-file path.\n");
+		return -EINVAL;
 	}
+	/* If mode is given with mount operation, use it. */
+	if (strncmp(filename, "accept=", 7) == 0) {
+		filename += 7;
+		is_permissive_mode = true;
+	} else if (strncmp(filename, "enforce=", 8) == 0) {
+		filename += 8;
+		is_permissive_mode = false;
+	} else if (syaoran_default_mode == -1) {
+		/*
+		 * If mode is not given with command line,
+		 * abort mount.
+		 */
+		printk(KERN_WARNING
+		       "SYAORAN: Missing 'accept=' or 'enforce='.\n");
+		return -EINVAL;
+	}
+	f = filp_open(filename, O_RDONLY, 0600);
+	if (IS_ERR(f)) {
+		printk(KERN_WARNING "SYAORAN: Can't open '%s'\n", filename);
+		return -EINVAL;
+	}
+	if (!S_ISREG(f->f_dentry->d_inode->i_mode))
+		goto out;
+	sb->s_fs_info = kzalloc(sizeof(struct syaoran_sb_info), GFP_KERNEL);
+	if (!sb->s_fs_info)
+		goto out;
+	((struct syaoran_sb_info *) sb->s_fs_info)->is_permissive_mode
+		= is_permissive_mode;
+	INIT_LIST_HEAD(&((struct syaoran_sb_info *) sb->s_fs_info)->list);
+	printk(KERN_INFO "SYAORAN: Reading '%s'\n", filename);
+	error = ReadConfigFile(f, sb);
+out:
+	if (error)
+		printk(KERN_WARNING "SYAORAN: Can't read '%s'\n", filename);
+	filp_close(f, NULL);
 	return error;
 }
 
@@ -588,40 +690,49 @@
 	char *end = buffer + buflen;
 	int namelen;
 
-	if (buflen < 256) goto out;
+	if (buflen < 256)
+		goto out;
 
 	*--end = '\0';
 	buflen--;
 	for (;;) {
 		struct dentry *parent;
-		if (IS_ROOT(dentry)) break;
+		if (IS_ROOT(dentry))
+			break;
 		parent = dentry->d_parent;
 		namelen = dentry->d_name.len;
 		buflen -= namelen + 1;
-		if (buflen < 0) goto out;
+		if (buflen < 0)
+			goto out;
 		end -= namelen;
 		memcpy(end, dentry->d_name.name, namelen);
 		*--end = '/';
 		dentry = parent;
 	}
-	if (*end == '/') { buflen++; end++; }
+	if (*end == '/') {
+		buflen++;
+		end++;
+	}
 	namelen = dentry->d_name.len;
 	buflen -= namelen;
-	if (buflen < 0) goto out;
+	if (buflen < 0)
+		goto out;
 	end -= namelen;
 	memcpy(end, dentry->d_name.name, namelen);
 	memmove(start, end, strlen(end) + 1);
 	return 0;
- out:
+out:
 	return -ENOMEM;
 }
 
 /* Get absolute pathname of the given dentry from mount point. */
-static int local_realpath_from_dentry(struct dentry *dentry, char *newname, int newname_len)
+static int local_realpath_from_dentry(struct dentry *dentry, char *newname,
+				      int newname_len)
 {
 	int error;
 	struct dentry *d_dentry;
-	if (!dentry || !newname || newname_len <= 0) return -EINVAL;
+	if (!dentry || !newname || newname_len <= 0)
+		return -EINVAL;
 	d_dentry = dget(dentry);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&dcache_lock);
@@ -632,33 +743,48 @@
 	return error;
 }
 
-static int CheckFlags(struct syaoran_sb_info *info, struct dentry *dentry, int mode, int dev, unsigned int flags)
+static int CheckFlags(struct syaoran_sb_info *info, struct dentry *dentry,
+		      int mode, int dev, unsigned int flags)
 {
-	int error = -EPERM;
-	/* I use static buffer, for local_realpath_from_dentry() needs dcache_lock. */
+	int error;
+	/*
+	 * I use static buffer, for local_realpath_from_dentry() needs
+	 * dcache_lock.
+	 */
 	static char filename[PAGE_SIZE];
+#ifdef DEFINE_SPINLOCK
+	static DEFINE_SPINLOCK(lock);
+#else
 	static spinlock_t lock = SPIN_LOCK_UNLOCKED;
+#endif
 	spin_lock(&lock);
 	memset(filename, 0, sizeof(filename));
-	if (local_realpath_from_dentry(dentry, filename, sizeof(filename) - 1) == 0) {
+	error = local_realpath_from_dentry(dentry, filename,
+					   sizeof(filename) - 1);
+	if (!error) {
 		struct dev_entry *entry;
+		error = -EPERM;
 		list_for_each_entry(entry, &info->list, list) {
-			if ((mode & S_IFMT) != (entry->mode & S_IFMT)) continue;
-			if ((S_ISBLK(mode) || S_ISCHR(mode)) && dev != entry->kdev) continue;
-			if (strcmp(entry->name, filename + 1)) continue;
+			if ((mode & S_IFMT) != (entry->mode & S_IFMT))
+				continue;
+			if ((S_ISBLK(mode) || S_ISCHR(mode)) &&
+			    dev != entry->kdev)
+				continue;
+			if (strcmp(entry->name, filename + 1))
+				continue;
 			if (info->is_permissive_mode) {
 				entry->flags |= flags;
 				error = 0;
-			} else {
-				if ((entry->flags & flags) == flags) error = 0;
-			}
+			} else if ((entry->flags & flags) == flags)
+				error = 0;
 			break;
 		}
 	}
 	if (error && strlen(filename) < (sizeof(filename) / 4) - 16) {
 		const char *name;
-		const uid_t uid = current->fsuid;
-		const gid_t gid = current->fsgid;
+		struct task_struct *task = current;
+		const uid_t uid = task->fsuid;
+		const gid_t gid = task->fsgid;
 		const mode_t perm = mode & 0777;
 		flags &= ~DEVICE_USED;
 		{
@@ -682,25 +808,41 @@
 		}
 		switch (mode & S_IFMT) {
 		case S_IFCHR:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %3u %3u\n", name, perm, uid, gid, flags, 'c', MAJOR(dev), MINOR(dev));
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %3u %3u\n",
+			       name, perm, uid, gid, flags, 'c',
+			       MAJOR(dev), MINOR(dev));
 			break;
 		case S_IFBLK:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %3u %3u\n", name, perm, uid, gid, flags, 'b', MAJOR(dev), MINOR(dev));
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %3u %3u\n",
+			       name, perm, uid, gid, flags, 'b',
+			       MAJOR(dev), MINOR(dev));
 			break;
 		case S_IFIFO:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'p');
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name,
+			       perm, uid, gid, flags, 'p');
 			break;
 		case S_IFSOCK:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 's');
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name,
+			       perm, uid, gid, flags, 's');
 			break;
 		case S_IFDIR:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'd');
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name,
+			       perm, uid, gid, flags, 'd');
 			break;
 		case S_IFLNK:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %s\n", name, perm, uid, gid, flags, 'l', "unknown");
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c %s\n",
+			       name, perm, uid, gid, flags, 'l', "unknown");
 			break;
 		case S_IFREG:
-			printk(KERN_DEBUG "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'f');
+			printk(KERN_DEBUG
+			       "SYAORAN-ERROR: %s %3o %3u %3u %2u %c\n", name,
+			       perm, uid, gid, flags, 'f');
 			break;
 		}
 	}
@@ -711,30 +853,39 @@
 /* Check whether the given dentry is allowed to mknod. */
 static int MayCreateNode(struct dentry *dentry, int mode, int dev)
 {
-	struct syaoran_sb_info *info = (struct syaoran_sb_info *) dentry->d_sb->s_fs_info;
+	struct syaoran_sb_info *info
+		= (struct syaoran_sb_info *) dentry->d_sb->s_fs_info;
 	if (!info) {
-		printk("%s: dentry->d_sb->s_fs_info == NULL\n", __FUNCTION__);
+		printk(KERN_WARNING "%s: dentry->d_sb->s_fs_info == NULL\n",
+		       __func__);
 		return -EPERM;
 	}
-	if (!info->initialize_done) return 0;
+	if (!info->initialize_done)
+		return 0;
 	return CheckFlags(info, dentry, mode, dev, MAY_CREATE);
 }
 
 /* Check whether the given dentry is allowed to chmod/chown/unlink. */
 static int MayModifyNode(struct dentry *dentry, unsigned int flags)
 {
-	struct syaoran_sb_info *info = (struct syaoran_sb_info *) dentry->d_sb->s_fs_info;
+	struct syaoran_sb_info *info
+		= (struct syaoran_sb_info *) dentry->d_sb->s_fs_info;
 	if (!info) {
-		printk("%s: dentry->d_sb->s_fs_info == NULL\n", __FUNCTION__);
+		printk(KERN_WARNING "%s: dentry->d_sb->s_fs_info == NULL\n",
+		       __func__);
 		return -EPERM;
 	}
-	if (flags == DEVICE_USED && !info->is_permissive_mode) return 0;
-	if (!dentry->d_inode) return -ENOENT;
-	return CheckFlags(info, dentry, dentry->d_inode->i_mode, dentry->d_inode->i_rdev, flags);
+	if (flags == DEVICE_USED && !info->is_permissive_mode)
+		return 0;
+	if (!dentry->d_inode)
+		return -ENOENT;
+	return CheckFlags(info, dentry, dentry->d_inode->i_mode,
+			  dentry->d_inode->i_rdev, flags);
 }
 
 /*
- * The following structure and codes are used for transferring data to interfaces files.
+ * The following structure and codes are used for transferring data
+ * to interfaces files.
  */
 
 struct syaoran_read_struct {
@@ -752,11 +903,15 @@
 	struct syaoran_sb_info *info = (struct syaoran_sb_info *) sb->s_fs_info;
 	struct list_head *pos;
 	const bool read_all = head->read_all;
-	if (!info) return;
-	if (!head->pos) return;
+	if (!info)
+		return;
+	if (!head->pos)
+		return;
 	list_for_each_cookie(pos, head->pos, &info->list) {
-		struct dev_entry *entry = list_entry(pos, struct dev_entry, list);
-		const unsigned int flags = read_all ? entry->flags : entry->flags & ~DEVICE_USED;
+		struct dev_entry *entry
+			= list_entry(pos, struct dev_entry, list);
+		const unsigned int flags
+			= read_all ? entry->flags : entry->flags & ~DEVICE_USED;
 		const char *name = entry->printable_name;
 		const uid_t uid = entry->uid;
 		const gid_t gid = entry->gid;
@@ -764,30 +919,46 @@
 		int len = 0;
 		switch (entry->mode & S_IFMT) {
 		case S_IFCHR:
-			if (!head->read_all && !(entry->flags & DEVICE_USED)) break;
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c %3u %3u\n", name, perm, uid, gid, flags, 'c', MAJOR(entry->kdev), MINOR(entry->kdev));
+			if (!head->read_all && !(entry->flags & DEVICE_USED))
+				break;
+			len = snprintf(buf, count,
+				       "%-20s %3o %3u %3u %2u %c %3u %3u\n",
+				       name, perm, uid, gid, flags, 'c',
+				       MAJOR(entry->kdev), MINOR(entry->kdev));
 			break;
 		case S_IFBLK:
-			if (!head->read_all && !(entry->flags & DEVICE_USED)) break;
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c %3u %3u\n", name, perm, uid, gid, flags, 'b', MAJOR(entry->kdev), MINOR(entry->kdev));
+			if (!head->read_all && !(entry->flags & DEVICE_USED))
+				break;
+			len = snprintf(buf, count,
+				       "%-20s %3o %3u %3u %2u %c %3u %3u\n",
+				       name, perm, uid, gid, flags, 'b',
+				       MAJOR(entry->kdev), MINOR(entry->kdev));
 			break;
 		case S_IFIFO:
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'p');
+			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n",
+				       name, perm, uid, gid, flags, 'p');
 			break;
 		case S_IFSOCK:
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 's');
+			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n",
+				       name, perm, uid, gid, flags, 's');
 			break;
 		case S_IFDIR:
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'd');
+			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n",
+				       name, perm, uid, gid, flags, 'd');
 			break;
 		case S_IFLNK:
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c %s\n", name, perm, uid, gid, flags, 'l', entry->printable_symlink_data);
+			len = snprintf(buf, count,
+				       "%-20s %3o %3u %3u %2u %c %s\n", name,
+				       perm, uid, gid, flags, 'l',
+				       entry->printable_symlink_data);
 			break;
 		case S_IFREG:
-			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n", name, perm, uid, gid, flags, 'f');
+			len = snprintf(buf, count, "%-20s %3o %3u %3u %2u %c\n",
+				       name, perm, uid, gid, flags, 'f');
 			break;
 		}
-		if (len < 0 || count <= len) break;
+		if (len < 0 || count <= len)
+			break;
 		count -= len;
 		buf += len;
 		head->avail += len;
@@ -796,12 +967,15 @@
 
 static int syaoran_trace_open(struct inode *inode, struct file *file)
 {
-	struct syaoran_read_struct *head;
-	if ((head = kzalloc(sizeof(*head), GFP_KERNEL)) == NULL) return -ENOMEM;
+	struct syaoran_read_struct *head = kzalloc(sizeof(*head), GFP_KERNEL);
+	if (!head)
+		return -ENOMEM;
 	head->sb = inode->i_sb;
-	head->read_all = (strcmp(file->f_dentry->d_name.name, ".syaoran_all") == 0);
+	head->read_all
+		= (strcmp(file->f_dentry->d_name.name, ".syaoran_all") == 0);
 	head->pos = &((struct syaoran_sb_info *) head->sb->s_fs_info)->list;
-	if ((head->buf = kzalloc(PAGE_SIZE * 2, GFP_KERNEL)) == NULL) {
+	head->buf = kzalloc(PAGE_SIZE * 2, GFP_KERNEL);
+	if (!head->buf) {
 		kfree(head);
 		return -ENOMEM;
 	}
@@ -818,17 +992,22 @@
 	return 0;
 }
 
-static ssize_t syaoran_trace_read(struct file *file, char __user *buf, size_t count, loff_t * ppos)
+static ssize_t syaoran_trace_read(struct file *file, char __user *buf,
+				  size_t count, loff_t *ppos)
 {
-	struct syaoran_read_struct *head = (struct syaoran_read_struct *) file->private_data;
+	struct syaoran_read_struct *head
+		= (struct syaoran_read_struct *) file->private_data;
 	int len = head->avail;
 	char *cp = head->buf;
-	if (!access_ok(VERIFY_WRITE, buf, count)) return -EFAULT;
+	if (!access_ok(VERIFY_WRITE, buf, count))
+		return -EFAULT;
 	ReadTable(head, cp + len, PAGE_SIZE * 2 - len);
 	len = head->avail;
-	if (len > count) len = count;
+	if (len > count)
+		len = count;
 	if (len > 0) {
-		if (copy_to_user(buf, cp, len)) return -EFAULT;
+		if (copy_to_user(buf, cp, len))
+			return -EFAULT;
 		head->avail -= len;
 		memmove(cp, cp + len, head->avail);
 	}
@@ -836,9 +1015,9 @@
 }
 
 static struct file_operations syaoran_trace_operations = {
-	open:    syaoran_trace_open,
-	release: syaoran_trace_release,
-	read:    syaoran_trace_read,
+	.open    = syaoran_trace_open,
+	.release = syaoran_trace_release,
+	.read    = syaoran_trace_read,
 };
 
 /* Create interface files for reading status. */
@@ -858,13 +1037,16 @@
 #endif
 			inode->i_blocks = 0;
 			inode->i_mapping->a_ops = &syaoran_aops;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-			inode->i_mapping->backing_dev_info = &syaoran_backing_dev_info;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+			inode->i_mapping->backing_dev_info
+				= &syaoran_backing_dev_info;
 			inode->i_op = &syaoran_file_inode_operations;
 #else
 			inode->i_rdev = NODEV;
 #endif
-			inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+			inode->i_ctime = CURRENT_TIME;
+			inode->i_mtime = inode->i_ctime;
+			inode->i_atime = inode->i_mtime;
 			inode->i_fop = &syaoran_trace_operations;
 			d_instantiate(dentry, inode);
 			dget(dentry); /* Extra count - pin the dentry in core */
@@ -872,7 +1054,7 @@
 		}
 		dput(dentry);
 	}
-#if LINUX_VERSION_CODE  >= KERNEL_VERSION(2,6,16)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 16)
 	mutex_unlock(&base->d_inode->i_mutex);
 #else
 	up(&base->d_inode->i_sem);
Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo_socket.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo_socket.h	(revision 1034)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo_socket.h	(working copy)
@@ -25,7 +25,7 @@
 #include <asm/uaccess.h>
 
 #include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #define sk_family family
 #define sk_protocol protocol
 #define sk_type type
@@ -34,26 +34,28 @@
 
 #define MAX_SOCK_ADDR 128 /* net/socket.c */
 
-static inline int CheckSocketCreatePermission(int family, int type, int protocol)
+static inline int CheckSocketCreatePermission(int family, int type,
+					      int protocol)
 {
 	int error = 0;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-	if (family == PF_INET || family == PF_INET6) {
-		switch (type) {
-		case SOCK_STREAM:
-			error = CheckCapabilityACL(TOMOYO_INET_STREAM_SOCKET_CREATE);
-			break;
-		case SOCK_DGRAM:
-			error = CheckCapabilityACL(TOMOYO_USE_INET_DGRAM_SOCKET);
-			break;
-		case SOCK_RAW:
-			error = CheckCapabilityACL(TOMOYO_USE_INET_RAW_SOCKET);
-			break;
-		}
-	} else if (family == PF_PACKET) {
-		error = CheckCapabilityACL(TOMOYO_USE_PACKET_SOCKET);
-	} else if (family == PF_ROUTE) {
-		error = CheckCapabilityACL(TOMOYO_USE_ROUTE_SOCKET);
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	if (family == PF_PACKET)
+		return CheckCapabilityACL(TOMOYO_USE_PACKET_SOCKET);
+	if (family == PF_ROUTE)
+		return CheckCapabilityACL(TOMOYO_USE_ROUTE_SOCKET);
+	if (family != PF_INET && family != PF_INET6)
+		return 0;
+	switch (type) {
+	case SOCK_STREAM:
+		error = CheckCapabilityACL(TOMOYO_INET_STREAM_SOCKET_CREATE);
+		break;
+	case SOCK_DGRAM:
+		error = CheckCapabilityACL(TOMOYO_USE_INET_DGRAM_SOCKET);
+		break;
+	case SOCK_RAW:
+		error = CheckCapabilityACL(TOMOYO_USE_INET_RAW_SOCKET);
+		break;
 	}
 	return error;
 }
@@ -61,149 +63,216 @@
 static inline int CheckSocketListenPermission(struct socket *sock)
 {
 	int error = 0;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-	if (sock->type == SOCK_STREAM) {
-		switch (sock->sk->sk_family) {
-		case PF_INET:
-		case PF_INET6:
-			error = CheckCapabilityACL(TOMOYO_INET_STREAM_SOCKET_LISTEN);
-			if (!error) {
-				char addr[MAX_SOCK_ADDR];
-				int addr_len;
-				if (sock->ops->getname(sock, (struct sockaddr *) addr, &addr_len, 0) == 0) {
-					switch (((struct sockaddr *) addr)->sa_family) {
-					case AF_INET6:
-						error = CheckNetworkListenACL(1, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, ((struct sockaddr_in6 *) addr)->sin6_port);
-						break;
-					case AF_INET:
-						error = CheckNetworkListenACL(0, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, ((struct sockaddr_in *) addr)->sin_port);
-						break;
-					}
-				} else {
-					error = -EPERM;
-				}
-			}
-			break;
-		}
+	char addr[MAX_SOCK_ADDR];
+	int addr_len;
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	if (sock->type != SOCK_STREAM)
+		return 0;
+	switch (sock->sk->sk_family) {
+	case PF_INET:
+	case PF_INET6:
+		break;
+	default:
+		return 0;
 	}
+	error = CheckCapabilityACL(TOMOYO_INET_STREAM_SOCKET_LISTEN);
+	if (error)
+		return error;
+	if (sock->ops->getname(sock, (struct sockaddr *) addr, &addr_len, 0))
+		return -EPERM;
+	switch (((struct sockaddr *) addr)->sa_family) {
+		struct sockaddr_in6 *addr6;
+		struct sockaddr_in *addr4;
+	case AF_INET6:
+		addr6 = (struct sockaddr_in6 *) addr;
+		error = CheckNetworkListenACL(1, addr6->sin6_addr.s6_addr,
+					      addr6->sin6_port);
+		break;
+	case AF_INET:
+		addr4 = (struct sockaddr_in *) addr;
+		error = CheckNetworkListenACL(0, (u8 *) &addr4->sin_addr,
+					      addr4->sin_port);
+		break;
+	}
 	return error;
 }
 
-static inline int CheckSocketConnectPermission(struct socket *sock, struct sockaddr *addr, int addr_len)
+static inline int CheckSocketConnectPermission(struct socket *sock,
+					       struct sockaddr *addr,
+					       int addr_len)
 {
 	int error = 0;
 	const unsigned int type = sock->type;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-	if (type == SOCK_STREAM || type == SOCK_DGRAM || type == SOCK_RAW) {
-		switch (addr->sa_family) {
-		case AF_INET6:
-			if (addr_len >= SIN6_LEN_RFC2133) {
-				if (type != SOCK_RAW) {
-					error = CheckNetworkConnectACL(1, type, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, ((struct sockaddr_in6 *) addr)->sin6_port);
-				} else {
-					error = CheckNetworkConnectACL(1, SOCK_RAW, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, htons(sock->sk->sk_protocol));
-				}
-			}
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	switch (type) {
+	case SOCK_STREAM:
+	case SOCK_DGRAM:
+	case SOCK_RAW:
+		break;
+	default:
+		return 0;
+	}
+	switch (addr->sa_family) {
+		struct sockaddr_in6 *addr6;
+		struct sockaddr_in *addr4;
+		u16 port;
+	case AF_INET6:
+		if (addr_len < SIN6_LEN_RFC2133)
 			break;
-		case AF_INET:
-			if (addr_len >= sizeof(struct sockaddr_in)) {
-				if (type != SOCK_RAW) {
-					error = CheckNetworkConnectACL(0, type, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, ((struct sockaddr_in *) addr)->sin_port);
-				} else {
-					error = CheckNetworkConnectACL(0, SOCK_RAW, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, htons(sock->sk->sk_protocol));
-				}
-			}
+		addr6 = (struct sockaddr_in6 *) addr;
+		if (type != SOCK_RAW)
+			port = addr6->sin6_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = CheckNetworkConnectACL(1, type,
+					       addr6->sin6_addr.s6_addr, port);
+		break;
+	case AF_INET:
+		if (addr_len < sizeof(struct sockaddr_in))
 			break;
-		}
+		addr4 = (struct sockaddr_in *) addr;
+		if (type != SOCK_RAW)
+			port = addr4->sin_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = CheckNetworkConnectACL(0, type,
+					       (u8 *) &addr4->sin_addr, port);
+		break;
 	}
-	if (type == SOCK_STREAM) {
-		switch (sock->sk->sk_family) {
-		case PF_INET:
-		case PF_INET6:
-			error = CheckCapabilityACL(TOMOYO_INET_STREAM_SOCKET_CONNECT) ? -EPERM : error;
-			break;
-		}
+	if (type != SOCK_STREAM)
+		return error;
+	switch (sock->sk->sk_family) {
+	case PF_INET:
+	case PF_INET6:
+		if (CheckCapabilityACL(TOMOYO_INET_STREAM_SOCKET_CONNECT))
+			error = -EPERM;
+		break;
 	}
 	return error;
 }
 
-static inline int CheckSocketBindPermission(struct socket *sock, struct sockaddr *addr, int addr_len)
+static inline int CheckSocketBindPermission(struct socket *sock,
+					    struct sockaddr *addr, int addr_len)
 {
 	int error = 0;
 	const unsigned int type = sock->type;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-	if (type == SOCK_STREAM || type == SOCK_DGRAM || type == SOCK_RAW) {
-		switch (addr->sa_family) {
-		case AF_INET6:
-			if (addr_len >= SIN6_LEN_RFC2133) {
-				if (type != SOCK_RAW) {
-					error = CheckNetworkBindACL(1, type, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, ((struct sockaddr_in6 *) addr)->sin6_port);
-				} else {
-					error = CheckNetworkBindACL(1, SOCK_RAW, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, htons(sock->sk->sk_protocol));
-				}
-			}
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	switch (type) {
+	case SOCK_STREAM:
+	case SOCK_DGRAM:
+	case SOCK_RAW:
+		break;
+	default:
+		return 0;
+	}
+	switch (addr->sa_family) {
+		struct sockaddr_in6 *addr6;
+		struct sockaddr_in *addr4;
+		u16 port;
+	case AF_INET6:
+		if (addr_len < SIN6_LEN_RFC2133)
 			break;
-		case AF_INET:
-			if (addr_len >= sizeof(struct sockaddr_in)) {
-				if (type != SOCK_RAW) {
-					error = CheckNetworkBindACL(0, type, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, ((struct sockaddr_in *) addr)->sin_port);
-				} else {
-					error = CheckNetworkBindACL(0, SOCK_RAW, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, htons(sock->sk->sk_protocol));
-				}
-			}
+		addr6 = (struct sockaddr_in6 *) addr;
+		if (type != SOCK_RAW)
+			port = addr6->sin6_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = CheckNetworkBindACL(1, type,
+					    addr6->sin6_addr.s6_addr, port);
+		break;
+	case AF_INET:
+		if (addr_len < sizeof(struct sockaddr_in))
 			break;
-		}
+		addr4 = (struct sockaddr_in *) addr;
+		if (type != SOCK_RAW)
+			port = addr4->sin_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = CheckNetworkBindACL(0, type, (u8 *) &addr4->sin_addr,
+					    port);
+		break;
 	}
 	return error;
 }
 
-static inline int CheckSocketAcceptPermission(struct socket *sock, struct sockaddr *addr)
+static inline int CheckSocketAcceptPermission(struct socket *sock,
+					      struct sockaddr *addr)
 {
 	int error = 0;
 	int addr_len;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
 	switch (sock->sk->sk_family) {
 	case PF_INET:
 	case PF_INET6:
-		if (sock->ops->getname(sock, addr, &addr_len, 2) == 0) {
-			switch (addr->sa_family) {
-			case AF_INET6:
-				error = CheckNetworkAcceptACL(1, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, ((struct sockaddr_in6 *) addr)->sin6_port);
-				break;
-			case AF_INET:
-				error = CheckNetworkAcceptACL(0, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, ((struct sockaddr_in *) addr)->sin_port);
-				break;
-			}
-		} else {
-			error = -EPERM;
-		}
+		break;
+	default:
+		return 0;
 	}
+	error = sock->ops->getname(sock, addr, &addr_len, 2);
+	if (error)
+		return error;
+	switch (addr->sa_family) {
+		struct sockaddr_in6 *addr6;
+		struct sockaddr_in *addr4;
+	case AF_INET6:
+		addr6 = (struct sockaddr_in6 *) addr;
+		error = CheckNetworkAcceptACL(1, addr6->sin6_addr.s6_addr,
+					      addr6->sin6_port);
+		break;
+	case AF_INET:
+		addr4 = (struct sockaddr_in *) addr;
+		error = CheckNetworkAcceptACL(0, (u8 *) &addr4->sin_addr,
+					      addr4->sin_port);
+		break;
+	}
 	return error;
 }
 
-static inline int CheckSocketSendMsgPermission(struct socket *sock, struct sockaddr *addr, int addr_len)
+static inline int CheckSocketSendMsgPermission(struct socket *sock,
+					       struct sockaddr *addr,
+					       int addr_len)
 {
 	int error = 0;
 	const int type = sock->type;
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
-	if (addr && (type == SOCK_DGRAM || type == SOCK_RAW)) {
-		switch (addr->sa_family) {
-		case AF_INET6:
-			if (addr_len >= SIN6_LEN_RFC2133) {
-				error = CheckNetworkSendMsgACL(1, type, ((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr, type == SOCK_DGRAM ? ((struct sockaddr_in6 *) addr)->sin6_port : htons(sock->sk->sk_protocol));
-			}
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
+	if (!addr || (type != SOCK_DGRAM && type != SOCK_RAW))
+		return 0;
+	switch (addr->sa_family) {
+		struct sockaddr_in6 *addr6;
+		struct sockaddr_in *addr4;
+		u16 port;
+	case AF_INET6:
+		if (addr_len < SIN6_LEN_RFC2133)
 			break;
-		case AF_INET:
-			if (addr_len >= sizeof(struct sockaddr_in)) {
-				error = CheckNetworkSendMsgACL(0, type, (u8 *) &((struct sockaddr_in *) addr)->sin_addr, type == SOCK_DGRAM ? ((struct sockaddr_in *) addr)->sin_port : htons(sock->sk->sk_protocol));
-			}
+		addr6 = (struct sockaddr_in6 *) addr;
+		if (type == SOCK_DGRAM)
+			port = addr6->sin6_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = CheckNetworkSendMsgACL(1, type,
+					       addr6->sin6_addr.s6_addr, port);
+		break;
+	case AF_INET:
+		if (addr_len < sizeof(struct sockaddr_in))
 			break;
-		}
+		addr4 = (struct sockaddr_in *) addr;
+		if (type == SOCK_DGRAM)
+			port = addr4->sin_port;
+		else
+			port = htons(sock->sk->sk_protocol);
+		error = CheckNetworkSendMsgACL(0, type,
+					       (u8 *) &addr4->sin_addr, port);
+		break;
 	}
 	return error;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 22)
 
 static inline struct iphdr *ip_hdr(const struct sk_buff *skb)
 {
@@ -222,31 +291,39 @@
 
 #endif
 
-static inline int CheckSocketRecvDatagramPermission(struct sock *sk, struct sk_buff *skb, const unsigned int flags)
+static inline int CheckSocketRecvDatagramPermission(struct sock *sk,
+						    struct sk_buff *skb,
+						    const unsigned int flags)
 {
 	int error = 0;
 	const unsigned int type = sk->sk_type;
-	struct in6_addr sin6;
-	struct in_addr sin;
-	u16 port;
 
-	if (!skb) return 0;
+	if (!skb)
+		return 0;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if (in_interrupt()) return 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (in_interrupt())
+		return 0;
 #else
-	if (in_atomic()) return 0;
+	if (in_atomic())
+		return 0;
 #endif
 
-	if (segment_eq(get_fs(), KERNEL_DS)) return 0;
+	if (segment_eq(get_fs(), KERNEL_DS))
+		return 0;
 
-	if (type != SOCK_DGRAM && type != SOCK_RAW) return 0;
+	if (type != SOCK_DGRAM && type != SOCK_RAW)
+		return 0;
 
 	switch (sk->sk_family) {
+		struct in6_addr sin6;
+		struct in_addr sin;
+		u16 port;
 	case PF_INET6:
 		if (type == SOCK_DGRAM) { /* UDP IPv6 */
 			if (skb->protocol == htons(ETH_P_IP)) {
-				ipv6_addr_set(&sin6, 0, 0, htonl(0xffff), ip_hdr(skb)->saddr);
+				ipv6_addr_set(&sin6, 0, 0, htonl(0xffff),
+					      ip_hdr(skb)->saddr);
 			} else {
 				ipv6_addr_copy(&sin6, &ipv6_hdr(skb)->saddr);
 			}
@@ -268,45 +345,75 @@
 		error = CheckNetworkRecvMsgACL(0, type, (u8 *) &sin, port);
 		break;
 	}
-	if (error) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-		lock_sock(sk);
+	if (!error)
+		return 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	lock_sock(sk);
 #endif
-		/*
-		 * Remove from queue if MSG_PEEK is used so that
-		 * the head message from unwanted source in receive queue will not
-		 * prevent the caller from picking up next message from wanted source
-		 * when the caller is using MSG_PEEK flag for picking up.
-		 */
-		if (flags & MSG_PEEK) {
-			unsigned long cpu_flags;
-			spin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);
-			if (skb == skb_peek(&sk->sk_receive_queue)) {
-				__skb_unlink(skb, &sk->sk_receive_queue);
-				atomic_dec(&skb->users);
-			}
-			spin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);
+	/*
+	 * Remove from queue if MSG_PEEK is used so that
+	 * the head message from unwanted source in receive queue will not
+	 * prevent the caller from picking up next message from wanted source
+	 * when the caller is using MSG_PEEK flag for picking up.
+	 */
+	if (flags & MSG_PEEK) {
+		unsigned long cpu_flags;
+		spin_lock_irqsave(&sk->sk_receive_queue.lock, cpu_flags);
+		if (skb == skb_peek(&sk->sk_receive_queue)) {
+			__skb_unlink(skb, &sk->sk_receive_queue);
+			atomic_dec(&skb->users);
 		}
-		/* Drop reference count. */
-		skb_free_datagram(sk, skb);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
-		release_sock(sk);
+		spin_unlock_irqrestore(&sk->sk_receive_queue.lock, cpu_flags);
+	}
+	/* Drop reference count. */
+	skb_free_datagram(sk, skb);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
+	release_sock(sk);
 #endif
-		/* Hope less harmful than -EPERM. */
-		error = -EAGAIN;
-	}
-	return error;
+	/* Hope less harmful than -EPERM. */
+	return -EAGAIN;
 }
 
 #else
 
-static inline int CheckSocketCreatePermission(int family, int type, int protocol) { return 0; }
-static inline int CheckSocketListenPermission(struct socket *sock) { return 0; }
-static inline int CheckSocketConnectPermission(struct socket *sock, struct sockaddr *addr, int addr_len) { return 0; }
-static inline int CheckSocketBindPermission(struct socket *sock, struct sockaddr *addr, int addr_len) { return 0; }
-static inline int CheckSocketAcceptPermission(struct socket *sock, struct sockaddr *addr) { return 0; }
-static inline int CheckSocketSendMsgPermission(struct socket *sock, struct sockaddr *addr, int addr_len) { return 0; }
-static inline int CheckSocketRecvDatagramPermission(struct sock *sk, struct sk_buff *skb, const unsigned int flags) { return 0; }
+static inline int CheckSocketCreatePermission(int family, int type,
+					      int protocol)
+{
+	return 0;
+}
+static inline int CheckSocketListenPermission(struct socket *sock)
+{
+	return 0;
+}
+static inline int CheckSocketConnectPermission(struct socket *sock,
+					       struct sockaddr *addr,
+					       int addr_len)
+{
+	return 0;
+}
+static inline int CheckSocketBindPermission(struct socket *sock,
+					    struct sockaddr *addr,
+					    int addr_len)
+{
+	return 0;
+}
+static inline int CheckSocketAcceptPermission(struct socket *sock,
+					      struct sockaddr *addr)
+{
+	return 0;
+}
+static inline int CheckSocketSendMsgPermission(struct socket *sock,
+					       struct sockaddr *addr,
+					       int addr_len)
+{
+	return 0;
+}
+static inline int CheckSocketRecvDatagramPermission(struct sock *sk,
+						    struct sk_buff *skb,
+						    const unsigned int flags)
+{
+	return 0;
+}
 
 #endif
 
Index: trunk/1.6.x/ccs-patch/include/linux/ccs_common.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(revision 1034)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(working copy)
@@ -28,7 +28,7 @@
 #include <stdarg.h>
 #include <linux/delay.h>
 #include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #include <linux/kmod.h>
 #include <asm/hardirq.h>
 #else
@@ -43,7 +43,11 @@
 #define WARN_ON(x) do { } while (0)
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#ifndef DEFINE_SPINLOCK
+#define DEFINE_SPINLOCK(x) spinlock_t x = SPIN_LOCK_UNLOCKED
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 typedef _Bool bool;
 #endif
 
@@ -59,10 +63,10 @@
 #define DEFINE_MUTEX(mutexname) DECLARE_MUTEX(mutexname)
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #define container_of(ptr, type, member) ({                      \
-	const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
-		(type *)( (char *)__mptr - offsetof(type,member) );})
+	const typeof(((type *)0)->member) *__mptr = (ptr);    \
+		(type *)((char *)__mptr - offsetof(type, member)); })
 #endif
 
 #if 0
@@ -75,7 +79,8 @@
 #define list1_for_each list_for_each
 #define list1_for_each_entry list_for_each_entry
 #define list1_for_each_cookie(pos, cookie, head) \
-	for (({if (!cookie) cookie = head;}), pos = (cookie)->next; \
+	for (({ if (!cookie) \
+		cookie = head; }), pos = (cookie)->next; \
 		prefetch(pos->next), pos != (head) || ((cookie) = NULL); \
 		(cookie) = pos, pos = pos->next)
 static inline void list1_add_tail_mb(struct list1_head *new,
@@ -90,7 +95,7 @@
 	prev->next = new;
 }
 
-#else /////////////////////////////////////////////////////////////////////////
+#else
 
 struct list1_head {
 	struct list1_head *next;
@@ -142,7 +147,8 @@
  * so that we can continue iteration.
  */
 #define list1_for_each_cookie(pos, cookie, head) \
-	for (({if (!cookie) cookie = head;}), pos = (cookie)->next; \
+	for (({ if (!cookie) \
+		cookie = head; }), pos = (cookie)->next; \
 		prefetch(pos->next), pos != (head) || ((cookie) = NULL); \
 		(cookie) = pos, pos = pos->next)
 
@@ -198,12 +204,12 @@
 
 struct path_info {
 	const char *name;
-	u32 hash;        /* = full_name_hash(name, strlen(name)) */
-	u16 total_len;   /* = strlen(name)                       */
-	u16 const_len;   /* = const_part_length(name)            */
+	u32 hash;          /* = full_name_hash(name, strlen(name)) */
+	u16 total_len;     /* = strlen(name)                       */
+	u16 const_len;     /* = const_part_length(name)            */
 	bool is_dir;       /* = strendswith(name, "/")             */
 	bool is_patterned; /* = PathContainsPattern(name)          */
-	u16 depth;       /* = PathDepth(name)                    */
+	u16 depth;         /* = PathDepth(name)                    */
 };
 
 #define CCS_MAX_PATHNAME_LEN 4000
@@ -238,25 +244,28 @@
 };
 
 struct path_info_with_data {
-	struct path_info head; /* Keep this first, for this pointer is passed to ccs_free(). */
+	/* Keep "head" first, for this pointer is passed to ccs_free(). */
+	struct path_info head;
 	char bariier1[16];
 	char body[CCS_MAX_PATHNAME_LEN];
 	char barrier2[16];
 };
 
 /*
- *  TOMOYO uses the following structures.
- *  Memory allocated for these structures are never kfree()ed.
- *  Since no locks are used for reading, assignment must be performed atomically.
+ * TOMOYO uses the following structures.
+ * Memory allocated for these structures are never kfree()ed.
+ * Since no locks are used for reading, assignment must be
+ * performed atomically.
  */
 
-/*************************  The structure for domains.  *************************/
+/***********************  The structure for domains.  ***********************/
 
 #define ACL_DELETED        0x80
 #define ACL_WITH_CONDITION 0x40
 
 struct acl_info {
-	const struct condition_list *cond; /* Use GetConditionPart() to read me. */
+	/* Keep "cond" first. Use GetConditionPart() to access "cond". */
+	const struct condition_list *cond;
 	struct list1_head list;
 	u8 type; /* MSB is is_deleted flag. Next bit is with_condition flag. */
 } __attribute__((__packed__));
@@ -264,57 +273,66 @@
 struct domain_info {
 	struct list1_head list;
 	struct list1_head acl_info_list;
-	const struct path_info *domainname; /* Name of this domain. Never NULL.      */
-	u8 profile;                         /* Profile to use.                       */
-	u8 is_deleted;                      /* Delete flag.                          */
-	bool quota_warned;                  /* Quota warnning done flag.             */
-	u8 flags;                           /* Ignore default?                       */
+	/* Name of this domain. Never NULL. */
+	const struct path_info *domainname;
+	u8 profile;        /* Profile to use. */
+	u8 is_deleted;     /* Delete flag. */
+	bool quota_warned; /* Quota warnning done flag. */
+	u8 flags; /* DOMAIN_FLAGS_IGNORE_* */
 };
 
 #define MAX_PROFILES 256
 
-#define DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ 1 /* Ignore "allow_read" in exception_policy */
-#define DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV  2 /* Ignore "allow_env" in exception_policy  */
+/* Ignore "allow_read" in exception_policy */
+#define DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ 1
+/* Ignore "allow_env" in exception_policy  */
+#define DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV  2
 
 struct execute_handler_record {
-	struct acl_info head;                         /* type = TYPE_*_EXECUTE_HANDLER */
-	const struct path_info *handler;              /* Pointer to single pathname.   */
+	struct acl_info head;            /* type = TYPE_*_EXECUTE_HANDLER */
+	const struct path_info *handler; /* Pointer to single pathname.   */
 };
 
 struct single_path_acl_record {
-	struct acl_info head;                         /* type = TYPE_SINGLE_PATH_ACL */
+	struct acl_info head; /* type = TYPE_SINGLE_PATH_ACL */
 	bool u_is_group;
 	u16 perm;
 	union {
-		const struct path_info *filename;     /* Pointer to single pathname. */
-		const struct path_group_entry *group; /* Pointer to pathname group.  */
+		/* Pointer to single pathname. */
+		const struct path_info *filename;
+		/* Pointer to pathname group. */
+		const struct path_group_entry *group;
 	} u;
 };
 
 struct double_path_acl_record {
-	struct acl_info head;                          /* type = TYPE_DOUBLE_PATH_ACL */
+	struct acl_info head; /* type = TYPE_DOUBLE_PATH_ACL */
 	u8 perm;
 	bool u1_is_group;
 	bool u2_is_group;
 	union {
-		const struct path_info *filename1;     /* Pointer to single pathname. */
-		const struct path_group_entry *group1; /* Pointer to pathname group.  */
+		/* Pointer to single pathname. */
+		const struct path_info *filename1;
+		/* Pointer to pathname group. */
+		const struct path_group_entry *group1;
 	} u1;
 	union {
-		const struct path_info *filename2;     /* Pointer to single pathname. */
-		const struct path_group_entry *group2; /* Pointer to pathname group.  */
+		/* Pointer to single pathname. */
+		const struct path_info *filename2;
+		/* Pointer to pathname group. */
+		const struct path_group_entry *group2;
 	} u2;
 };
 
 struct argv0_acl_record {
 	struct acl_info head;             /* type = TYPE_ARGV0_ACL       */
 	const struct path_info *filename; /* Pointer to single pathname. */
-	const struct path_info *argv0;    /* strrchr(argv[0], '/') + 1   */
+	const struct path_info *argv0;    /* = strrchr(argv[0], '/') + 1 */
 };
 
 struct env_acl_record {
-	struct acl_info head;           /* type = TYPE_ENV_ACL  */
-	const struct path_info *env;    /* environment variable */
+	struct acl_info head;        /* type = TYPE_ENV_ACL  */
+	const struct path_info *env; /* environment variable */
 };
 
 struct capability_acl_record {
@@ -323,9 +341,10 @@
 };
 
 struct signal_acl_record {
-	struct acl_info head;               /* type = TYPE_SIGNAL_ACL          */
+	struct acl_info head; /* type = TYPE_SIGNAL_ACL */
 	u16 sig;
-	const struct path_info *domainname; /* Pointer to destination pattern. */
+	/* Pointer to destination pattern. */
+	const struct path_info *domainname;
 };
 
 #define IP_RECORD_TYPE_ADDRESS_GROUP 0
@@ -333,21 +352,28 @@
 #define IP_RECORD_TYPE_IPv6          2
 
 struct ip_network_acl_record {
-	struct acl_info head;   /* type = TYPE_IP_NETWORK_ACL */
+	struct acl_info head; /* type = TYPE_IP_NETWORK_ACL */
 	u8 operation_type;
-	u8 record_type;         /* IP_RECORD_TYPE_*           */
-	u16 min_port;           /* Start of port number range.                   */
-	u16 max_port;           /* End of port number range.                     */
+	u8 record_type; /* = IP_RECORD_TYPE_* */
+	/* Start of port number range. */
+	u16 min_port;
+	/* End of port number range. */
+	u16 max_port;
 	union {
 		struct {
-			u32 min; /* Start of IPv4 address range. Host endian. */
-			u32 max; /* End of IPv4 address range. Host endian.   */
+			/* Start of IPv4 address range. Host endian. */
+			u32 min;
+			/* End of IPv4 address range. Host endian. */
+			u32 max;
 		} ipv4;
 		struct {
-			const struct in6_addr *min; /* Start of IPv6 address range. Big endian.      */
-			const struct in6_addr *max; /* End of IPv6 address range. Big endian.        */
+			/* Start of IPv6 address range. Big endian. */
+			const struct in6_addr *min;
+			/* End of IPv6 address range. Big endian. */
+			const struct in6_addr *max;
 		} ipv6;
-		const struct address_group_entry *group; /* Pointer to address group. */
+		/* Pointer to address group. */
+		const struct address_group_entry *group;
 	} u;
 };
 
@@ -388,11 +414,13 @@
 #define KEYWORD_FILE_PATTERN             "file_pattern "
 #define KEYWORD_FILE_PATTERN_LEN         (sizeof(KEYWORD_FILE_PATTERN) - 1)
 #define KEYWORD_INITIALIZE_DOMAIN        "initialize_domain "
-#define KEYWORD_INITIALIZE_DOMAIN_LEN    (sizeof(KEYWORD_INITIALIZE_DOMAIN) - 1)
+#define KEYWORD_INITIALIZE_DOMAIN_LEN    \
+	(sizeof(KEYWORD_INITIALIZE_DOMAIN) - 1)
 #define KEYWORD_KEEP_DOMAIN              "keep_domain "
 #define KEYWORD_KEEP_DOMAIN_LEN          (sizeof(KEYWORD_KEEP_DOMAIN) - 1)
 #define KEYWORD_NO_INITIALIZE_DOMAIN     "no_initialize_domain "
-#define KEYWORD_NO_INITIALIZE_DOMAIN_LEN (sizeof(KEYWORD_NO_INITIALIZE_DOMAIN) - 1)
+#define KEYWORD_NO_INITIALIZE_DOMAIN_LEN \
+	(sizeof(KEYWORD_NO_INITIALIZE_DOMAIN) - 1)
 #define KEYWORD_NO_KEEP_DOMAIN           "no_keep_domain "
 #define KEYWORD_NO_KEEP_DOMAIN_LEN       (sizeof(KEYWORD_NO_KEEP_DOMAIN) - 1)
 #define KEYWORD_PATH_GROUP               "path_group "
@@ -408,35 +436,36 @@
 #define KEYWORD_PREFERRED_EXECUTE_HANDLER "preferred_execute_handler"
 #define KEYWORD_DEFAULT_EXECUTE_HANDLER   "default_execute_handler"
 
-#define KEYWORD_MAC_FOR_CAPABILITY       "MAC_FOR_CAPABILITY::"
-#define KEYWORD_MAC_FOR_CAPABILITY_LEN   (sizeof(KEYWORD_MAC_FOR_CAPABILITY) - 1)
+#define KEYWORD_MAC_FOR_CAPABILITY     "MAC_FOR_CAPABILITY::"
+#define KEYWORD_MAC_FOR_CAPABILITY_LEN (sizeof(KEYWORD_MAC_FOR_CAPABILITY) - 1)
 
-#define ROOT_NAME "<kernel>"             /* A domain definition starts with <kernel> . */
+/* A domain definition starts with <kernel> . */
+#define ROOT_NAME "<kernel>"
 #define ROOT_NAME_LEN (sizeof(ROOT_NAME) - 1)
 
-/*************************  Index numbers for Access Controls.  *************************/
+/*******************  Index numbers for Access Controls.  ********************/
 
-#define CCS_PROFILE_COMMENT                      0  /* profile.conf            */
-#define CCS_TOMOYO_MAC_FOR_FILE                  1  /* domain_policy.conf      */
-#define CCS_TOMOYO_MAC_FOR_ARGV0                 2  /* domain_policy.conf      */
-#define CCS_TOMOYO_MAC_FOR_ENV                   3  /* domain_policy.conf      */
-#define CCS_TOMOYO_MAC_FOR_NETWORK               4  /* domain_policy.conf      */
-#define CCS_TOMOYO_MAC_FOR_SIGNAL                5  /* domain_policy.conf      */
+#define CCS_PROFILE_COMMENT                      0  /* profile.conf       */
+#define CCS_TOMOYO_MAC_FOR_FILE                  1  /* domain_policy.conf */
+#define CCS_TOMOYO_MAC_FOR_ARGV0                 2  /* domain_policy.conf */
+#define CCS_TOMOYO_MAC_FOR_ENV                   3  /* domain_policy.conf */
+#define CCS_TOMOYO_MAC_FOR_NETWORK               4  /* domain_policy.conf */
+#define CCS_TOMOYO_MAC_FOR_SIGNAL                5  /* domain_policy.conf */
 #define CCS_SAKURA_DENY_CONCEAL_MOUNT            6
-#define CCS_SAKURA_RESTRICT_CHROOT               7  /* system_policy.conf      */
-#define CCS_SAKURA_RESTRICT_MOUNT                8  /* system_policy.conf      */
-#define CCS_SAKURA_RESTRICT_UNMOUNT              9  /* system_policy.conf      */
-#define CCS_SAKURA_RESTRICT_PIVOT_ROOT          10  /* system_policy.conf      */
-#define CCS_SAKURA_RESTRICT_AUTOBIND            11  /* system_policy.conf      */
+#define CCS_SAKURA_RESTRICT_CHROOT               7  /* system_policy.conf */
+#define CCS_SAKURA_RESTRICT_MOUNT                8  /* system_policy.conf */
+#define CCS_SAKURA_RESTRICT_UNMOUNT              9  /* system_policy.conf */
+#define CCS_SAKURA_RESTRICT_PIVOT_ROOT          10  /* system_policy.conf */
+#define CCS_SAKURA_RESTRICT_AUTOBIND            11  /* system_policy.conf */
 #define CCS_TOMOYO_MAX_ACCEPT_ENTRY             12
 #define CCS_TOMOYO_MAX_GRANT_LOG                13
 #define CCS_TOMOYO_MAX_REJECT_LOG               14
 #define CCS_TOMOYO_VERBOSE                      15
 #define CCS_ALLOW_ENFORCE_GRACE                 16
-#define CCS_SLEEP_PERIOD                        17  /* profile.conf            */
+#define CCS_SLEEP_PERIOD                        17  /* profile.conf       */
 #define CCS_MAX_CONTROL_INDEX                   18
 
-/*************************  Index numbers for updates counter.  *************************/
+/*******************  Index numbers for updates counter.  ********************/
 
 #define CCS_UPDATES_COUNTER_SYSTEM_POLICY    0
 #define CCS_UPDATES_COUNTER_DOMAIN_POLICY    1
@@ -448,80 +477,115 @@
 #define CCS_UPDATES_COUNTER_REJECT_LOG       7
 #define MAX_CCS_UPDATES_COUNTER              8
 
-/*************************  The structure for /proc interfaces.  *************************/
+/*******************  The structure for /proc interfaces.  *******************/
 
 struct io_buffer {
 	int (*read) (struct io_buffer *);
+	/* lock for read_buf */
 	struct mutex read_sem;
 	int (*write) (struct io_buffer *);
+	/* lock for write_buf */
 	struct mutex write_sem;
 	int (*poll) (struct file *file, poll_table *wait);
-	struct list1_head *read_var1;     /* The position currently reading from. */
-	struct list1_head *read_var2;     /* Extra variables for reading.         */
-	struct domain_info *write_var1;   /* The position currently writing to.   */
-	int read_step;                    /* The step for reading.                */
-	char *read_buf;                   /* Buffer for reading.                  */
-	bool read_eof;                    /* EOF flag for reading.                */
-	u8 read_bit;                      /* Extra variable for reading.          */
-	int read_avail;                   /* Bytes available for reading.         */
-	int readbuf_size;                 /* Size of read buffer.                 */
-	char *write_buf;                  /* Buffer for writing.                  */
-	int write_avail;                  /* Bytes available for writing.         */
-	int writebuf_size;                /* Size of write buffer.                */
+	/* The position currently reading from. */
+	struct list1_head *read_var1;
+	/* Extra variables for reading. */
+	struct list1_head *read_var2;
+	/* The position currently writing to. */
+	struct domain_info *write_var1;
+	/* The step for reading. */
+	int read_step;
+	/* Buffer for reading. */
+	char *read_buf;
+	/* EOF flag for reading. */
+	bool read_eof;
+	/* Extra variable for reading. */
+	u8 read_bit;
+	/* Bytes available for reading. */
+	int read_avail;
+	/* Size of read buffer. */
+	int readbuf_size;
+	/* Buffer for writing. */
+	char *write_buf;
+	/* Bytes available for writing. */
+	int write_avail;
+	/* Size of write buffer. */
+	int writebuf_size;
 };
 
 /*************************  PROTOTYPES  *************************/
 
 struct condition_list;
 
-char *InitAuditLog(int *len, const u8 profile, const u8 mode, struct linux_binprm *bprm);
-void *ccs_alloc(const size_t size);
+bool CheckCCSQuota(struct domain_info * const domain);
+bool CheckCondition(const struct acl_info *acl, struct obj_info *obj_info);
+bool CheckDomainQuota(struct domain_info * const domain);
+bool IsCorrectDomain(const unsigned char *domainname, const char *function);
+bool IsCorrectPath(const char *filename, const s8 start_type,
+		   const s8 pattern_type, const s8 end_type,
+		   const char *function);
+bool IsDomainDef(const unsigned char *buffer);
+bool PathMatchesToPattern(const struct path_info *pathname0,
+			  const struct path_info *pattern0);
+bool TomoyoVerboseMode(void);
+char *InitAuditLog(int *len, const u8 profile, const u8 mode,
+		   struct linux_binprm *bprm);
 char *print_ipv6(char *buffer, const int buffer_len, const struct in6_addr *ip);
 const char *GetEXE(void);
 const char *GetLastName(const struct domain_info *domain);
 const char *GetMSG(const bool is_enforce);
 const char *cap_operation2keyword(const u8 operation);
 const char *dp_operation2keyword(const u8 operation);
+const char *net_operation2keyword(const u8 operation);
 const char *sp_operation2keyword(const u8 operation);
-const char *net_operation2keyword(const u8 operation);
 const struct condition_list *FindOrAssignNewCondition(char *condition);
+const struct condition_list *GetConditionPart(const struct acl_info *acl);
 int AddAddressGroupPolicy(char *data, const bool is_delete);
 int AddAggregatorPolicy(char *data, const bool is_delete);
 int AddAliasPolicy(char *data, const bool is_delete);
-int AddArgv0Policy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
-int AddCapabilityPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
+int AddArgv0Policy(char *data, struct domain_info *domain,
+		   const struct condition_list *condition,
+		   const bool is_delete);
+int AddCapabilityPolicy(char *data, struct domain_info *domain,
+			const struct condition_list *condition,
+			const bool is_delete);
 int AddChrootPolicy(char *data, const bool is_delete);
 int AddDomainACL(struct domain_info *domain, struct acl_info *acl);
-int AddDomainInitializerPolicy(char *data, const bool is_not, const bool is_delete);
+int AddDomainInitializerPolicy(char *data, const bool is_not,
+			       const bool is_delete);
 int AddDomainKeeperPolicy(char *data, const bool is_not, const bool is_delete);
-int AddEnvPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
-int AddFilePolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
+int AddEnvPolicy(char *data, struct domain_info *domain,
+		 const struct condition_list *condition, const bool is_delete);
+int AddFilePatternPolicy(char *data, const bool is_delete);
+int AddFilePolicy(char *data, struct domain_info *domain,
+		  const struct condition_list *condition, const bool is_delete);
 int AddGloballyReadablePolicy(char *data, const bool is_delete);
 int AddGloballyUsableEnvPolicy(char *env, const bool is_delete);
-int AddFilePatternPolicy(char *data, const bool is_delete);
 int AddMountPolicy(char *data, const bool is_delete);
-int AddNetworkPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
+int AddNetworkPolicy(char *data, struct domain_info *domain,
+		     const struct condition_list *condition,
+		     const bool is_delete);
 int AddNoRewritePolicy(char *pattern, const bool is_delete);
 int AddNoUmountPolicy(char *data, const bool is_delete);
 int AddPathGroupPolicy(char *data, const bool is_delete);
 int AddPivotRootPolicy(char *data, const bool is_delete);
 int AddReservedPortPolicy(char *data, const bool is_delete);
-int AddSignalPolicy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete);
+int AddSignalPolicy(char *data, struct domain_info *domain,
+		    const struct condition_list *condition,
+		    const bool is_delete);
 int CCS_CloseControl(struct file *file);
 int CCS_OpenControl(const u8 type, struct file *file);
 int CCS_PollControl(struct file *file, poll_table *wait);
-int CCS_ReadControl(struct file *file, char __user *buffer, const int buffer_len);
-int CCS_WriteControl(struct file *file, const char __user *buffer, const int buffer_len);
+int CCS_ReadControl(struct file *file, char __user *buffer,
+		    const int buffer_len);
+int CCS_WriteControl(struct file *file, const char __user *buffer,
+		     const int buffer_len);
 int CanSaveAuditLog(const bool is_granted);
-int CheckSupervisor(const char *fmt, ...) __attribute__ ((format(printf, 1, 2)));
+int CheckSupervisor(const char *fmt, ...)
+	__attribute__ ((format(printf, 1, 2)));
 int DelDomainACL(struct acl_info *acl);
 int DeleteDomain(char *data);
 int DumpCondition(struct io_buffer *head, const struct condition_list *ptr);
-bool CheckCondition(const struct acl_info *acl, struct obj_info *obj_info);
-bool IsCorrectDomain(const unsigned char *domainname, const char *function);
-bool IsCorrectPath(const char *filename, const s8 start_type, const s8 pattern_type, const s8 end_type, const char *function);
-bool IsDomainDef(const unsigned char *buffer);
-bool PathMatchesToPattern(const struct path_info *pathname0, const struct path_info *pattern0);
 int PollGrantLog(struct file *file, poll_table *wait);
 int PollRejectLog(struct file *file, poll_table *wait);
 int ReadAddressGroupPolicy(struct io_buffer *head);
@@ -530,10 +594,10 @@
 int ReadChrootPolicy(struct io_buffer *head);
 int ReadDomainInitializerPolicy(struct io_buffer *head);
 int ReadDomainKeeperPolicy(struct io_buffer *head);
+int ReadFilePatternPolicy(struct io_buffer *head);
 int ReadGloballyReadablePolicy(struct io_buffer *head);
 int ReadGloballyUsableEnvPolicy(struct io_buffer *head);
 int ReadGrantLog(struct io_buffer *head);
-int ReadFilePatternPolicy(struct io_buffer *head);
 int ReadMountPolicy(struct io_buffer *head);
 int ReadNoRewritePolicy(struct io_buffer *head);
 int ReadNoUmountPolicy(struct io_buffer *head);
@@ -542,24 +606,25 @@
 int ReadRejectLog(struct io_buffer *head);
 int ReadReservedPortPolicy(struct io_buffer *head);
 int WriteAuditLog(char *log, const bool is_granted);
-int io_printf(struct io_buffer *head, const char *fmt, ...) __attribute__ ((format(printf, 2, 3)));
+int io_printf(struct io_buffer *head, const char *fmt, ...)
+	__attribute__ ((format(printf, 2, 3)));
 struct domain_info *FindDomain(const char *domainname);
-struct domain_info *FindOrAssignNewDomain(const char *domainname, const u8 profile);
+struct domain_info *FindOrAssignNewDomain(const char *domainname,
+					  const u8 profile);
 struct domain_info *UndeleteDomain(const char *domainname0);
-bool CheckCCSQuota(struct domain_info * const domain);
+u8 CheckCapabilityFlags(const u8 index);
 unsigned int CheckCCSFlags(const u8 index);
 unsigned int CheckCCSFlags_NoSleepCheck(const u8 index);
-u8 CheckCapabilityFlags(const u8 index);
-bool CheckDomainQuota(struct domain_info * const domain);
-bool TomoyoVerboseMode(void);
-void *alloc_acl_element(const u8 acl_type, const struct condition_list *condition);
-const struct condition_list *GetConditionPart(const struct acl_info *acl);
+void *alloc_acl_element(const u8 acl_type,
+			const struct condition_list *condition);
+void *ccs_alloc(const size_t size);
 void CCS_LoadPolicy(const char *filename);
+void SetDomainFlag(struct domain_info *domain, const bool is_delete,
+		   const u8 flags);
+void UpdateCondition(const struct acl_info *acl);
 void UpdateCounter(const unsigned char index);
 void ccs_free(const void *p);
 void fill_path_info(struct path_info *ptr);
-void UpdateCondition(const struct acl_info *acl);
-void SetDomainFlag(struct domain_info *domain, const bool is_delete, const u8 flags);
 
 static inline bool pathcmp(const struct path_info *a, const struct path_info *b)
 {
@@ -573,11 +638,12 @@
 extern struct domain_info KERNEL_DOMAIN;
 extern struct mutex domain_acl_lock;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
 static inline void *kzalloc(int size, int flags)
 {
 	void *p = kmalloc(size, flags);
-	if (p) memset(p, 0, size);
+	if (p)
+		memset(p, 0, size);
 	return p;
 }
 #endif
Index: trunk/1.6.x/ccs-patch/include/linux/realpath.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/realpath.h	(revision 1034)
+++ trunk/1.6.x/ccs-patch/include/linux/realpath.h	(working copy)
@@ -18,21 +18,31 @@
 struct path_info;
 
 /* Returns realpath(3) of the given pathname but ignores chroot'ed root. */
-int realpath_from_dentry2(struct dentry *dentry, struct vfsmount *mnt, char *newname, int newname_len);
+int realpath_from_dentry2(struct dentry *dentry, struct vfsmount *mnt,
+			  char *newname, int newname_len);
 
-/* Returns realpath(3) of the given pathname but ignores chroot'ed root. */
-/* These functions use ccs_alloc(), so caller must ccs_free() if these functions didn't return NULL. */
+/*
+ * Returns realpath(3) of the given pathname but ignores chroot'ed root.
+ * These functions use ccs_alloc(), so caller must ccs_free()
+ * if these functions didn't return NULL.
+ */
 char *realpath(const char *pathname);
 char *realpath_nofollow(const char *pathname);
 char *realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt);
 
-/* Allocate memory for structures. The RAM is chunked, so NEVER try to kfree() the returned pointer. */
+/*
+ * Allocate memory for structures.
+ * The RAM is chunked, so NEVER try to kfree() the returned pointer.
+ */
 void *alloc_element(const unsigned int size);
 
 /* Get used RAM size for alloc_elements(). */
 unsigned int GetMemoryUsedForElements(void);
 
-/* Keep the given name on the RAM. The RAM is shared, so NEVER try to modify or kfree() the returned name. */
+/*
+ * Keep the given name on the RAM.
+ * The RAM is shared, so NEVER try to modify or kfree() the returned name.
+ */
 const struct path_info *SaveName(const char *name);
 
 /* Get used RAM size for SaveName(). */
Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo_vfs.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo_vfs.h	(revision 1034)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo_vfs.h	(working copy)
@@ -18,14 +18,15 @@
 /***** TOMOYO Linux start. *****/
 
 #include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 
 static inline int pre_vfs_create(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	down(&dir->i_zombie);
 	error = may_create(dir, dentry);
-	if (!error && (!dir->i_op || !dir->i_op->create)) error = -EPERM; /* -ENOSYS ? */
+	if (!error && (!dir->i_op || !dir->i_op->create))
+		error = -EPERM; /* -ENOSYS ? */
 	up(&dir->i_zombie);
 	return error;
 }
@@ -35,7 +36,8 @@
 	int error;
 	down(&dir->i_zombie);
 	error = may_create(dir, dentry);
-	if (!error && (!dir->i_op || !dir->i_op->mknod)) error = -EPERM; /* -ENOSYS ? */
+	if (!error && (!dir->i_op || !dir->i_op->mknod))
+		error = -EPERM; /* -ENOSYS ? */
 	up(&dir->i_zombie);
 	return error;
 }
@@ -46,7 +48,8 @@
 	int error;
 	down(&dir->i_zombie);
 	error = may_create(dir, dentry);
-	if (!error && (!dir->i_op || !dir->i_op->mkdir)) error = -EPERM;
+	if (!error && (!dir->i_op || !dir->i_op->mkdir))
+		error = -EPERM;
 	up(&dir->i_zombie);
 	return error;
 }
@@ -54,7 +57,8 @@
 static inline int pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = may_delete(dir, dentry, 1);
-	if (!error && (!dir->i_op || !dir->i_op->rmdir)) error = -EPERM;
+	if (!error && (!dir->i_op || !dir->i_op->rmdir))
+		error = -EPERM;
 	return error;
 }
 
@@ -63,28 +67,35 @@
 	int error;
 	down(&dir->i_zombie);
 	error = may_delete(dir, dentry, 0);
-	if (!error && (!dir->i_op || !dir->i_op->unlink)) error = -EPERM;
+	if (!error && (!dir->i_op || !dir->i_op->unlink))
+		error = -EPERM;
 	up(&dir->i_zombie);
 	return error;
 }
 
-static inline int pre_vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
+static inline int pre_vfs_link(struct dentry *old_dentry, struct inode *dir,
+			       struct dentry *new_dentry)
 {
 	struct inode *inode;
 	int error;
 	down(&dir->i_zombie);
 	error = -ENOENT;
 	inode = old_dentry->d_inode;
-	if (!inode) goto exit_lock;
+	if (!inode)
+		goto exit_lock;
 	error = may_create(dir, new_dentry);
-	if (error) goto exit_lock;
+	if (error)
+		goto exit_lock;
 	error = -EXDEV;
-	if (dir->i_dev != inode->i_dev) goto exit_lock;
+	if (dir->i_dev != inode->i_dev)
+		goto exit_lock;
 	error = -EPERM;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode)) goto exit_lock;
-	if (!dir->i_op || !dir->i_op->link) goto exit_lock;
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		goto exit_lock;
+	if (!dir->i_op || !dir->i_op->link)
+		goto exit_lock;
 	error = 0;
- exit_lock:
+exit_lock:
 	up(&dir->i_zombie);
 	return error;
 }
@@ -94,48 +105,78 @@
 	int error;
 	down(&dir->i_zombie);
 	error = may_create(dir, dentry);
-	if (error) goto exit_lock;
-	if (!dir->i_op || !dir->i_op->symlink) error = -EPERM;
- exit_lock:
+	if (error)
+		goto exit_lock;
+	if (!dir->i_op || !dir->i_op->symlink)
+		error = -EPERM;
+exit_lock:
 	up(&dir->i_zombie);
 	return error;
 }
 
-static inline int pre_vfs_rename_dir(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
+static inline int pre_vfs_rename_dir(struct inode *old_dir,
+				     struct dentry *old_dentry,
+				     struct inode *new_dir,
+				     struct dentry *new_dentry)
 {
 	int error;
-	if (old_dentry->d_inode == new_dentry->d_inode) return 0;
+	if (old_dentry->d_inode == new_dentry->d_inode)
+		return 0;
 	error = may_delete(old_dir, old_dentry, 1);
-	if (error) return error;
-	if (new_dir->i_dev != old_dir->i_dev) return -EXDEV;
-	if (!new_dentry->d_inode) error = may_create(new_dir, new_dentry);
-	else error = may_delete(new_dir, new_dentry, 1);
-	if (error) return error;
-	if (!old_dir->i_op || !old_dir->i_op->rename) return -EPERM;
-	if (new_dir != old_dir) error = permission(old_dentry->d_inode, MAY_WRITE);
+	if (error)
+		return error;
+	if (new_dir->i_dev != old_dir->i_dev)
+		return -EXDEV;
+	if (!new_dentry->d_inode)
+		error = may_create(new_dir, new_dentry);
+	else
+		error = may_delete(new_dir, new_dentry, 1);
+	if (error)
+		return error;
+	if (!old_dir->i_op || !old_dir->i_op->rename)
+		return -EPERM;
+	if (new_dir != old_dir)
+		error = permission(old_dentry->d_inode, MAY_WRITE);
 	return error;
 }
 
-static inline int pre_vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
+static inline int pre_vfs_rename_other(struct inode *old_dir,
+				       struct dentry *old_dentry,
+				       struct inode *new_dir,
+				       struct dentry *new_dentry)
 {
 	int error;
-	if (old_dentry->d_inode == new_dentry->d_inode) return 0;
+	if (old_dentry->d_inode == new_dentry->d_inode)
+		return 0;
 	error = may_delete(old_dir, old_dentry, 0);
-	if (error) return error;
-	if (new_dir->i_dev != old_dir->i_dev) return -EXDEV;
-	if (!new_dentry->d_inode) error = may_create(new_dir, new_dentry);
-	else error = may_delete(new_dir, new_dentry, 0);
-	if (error) return error;
-	if (!old_dir->i_op || !old_dir->i_op->rename) return -EPERM;
+	if (error)
+		return error;
+	if (new_dir->i_dev != old_dir->i_dev)
+		return -EXDEV;
+	if (!new_dentry->d_inode)
+		error = may_create(new_dir, new_dentry);
+	else
+		error = may_delete(new_dir, new_dentry, 0);
+	if (error)
+		return error;
+	if (!old_dir->i_op || !old_dir->i_op->rename)
+		return -EPERM;
 	return 0;
 }
 
-static inline int pre_vfs_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
+static inline int pre_vfs_rename(struct inode *old_dir,
+				 struct dentry *old_dentry,
+				 struct inode *new_dir,
+				 struct dentry *new_dentry)
 {
 	int error;
 	lock_kernel();
-	if (S_ISDIR(old_dentry->d_inode->i_mode)) error = pre_vfs_rename_dir(old_dir,old_dentry,new_dir,new_dentry);
-	else error = pre_vfs_rename_other(old_dir,old_dentry,new_dir,new_dentry);
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		error = pre_vfs_rename_dir(old_dir, old_dentry,
+					   new_dir, new_dentry);
+	else
+		error = pre_vfs_rename_other(old_dir, old_dentry,
+					     new_dir, new_dentry);
 	unlock_kernel();
 	return error;
 }
@@ -145,9 +186,12 @@
 int pre_vfs_mknod(struct inode *dir, struct dentry *dentry, int mode)
 {
 	int error = may_create(dir, dentry, NULL);
-	if (error) return error;
-	if ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD)) return -EPERM;
-	if (!dir->i_op || !dir->i_op->mknod) return -EPERM;
+	if (error)
+		return error;
+	if ((S_ISCHR(mode) || S_ISBLK(mode)) && !capable(CAP_MKNOD))
+		return -EPERM;
+	if (!dir->i_op || !dir->i_op->mknod)
+		return -EPERM;
 	return 0;
 }
 EXPORT_SYMBOL(pre_vfs_mknod);
@@ -155,54 +199,73 @@
 static inline int pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = may_create(dir, dentry, NULL);
-	if (error) return error;
-	if (!dir->i_op || !dir->i_op->mkdir) return -EPERM;
+	if (error)
+		return error;
+	if (!dir->i_op || !dir->i_op->mkdir)
+		return -EPERM;
 	return 0;
 }
 
 static inline int pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = may_delete(dir, dentry, 1);
-	if (error) return error;
-	if (!dir->i_op || !dir->i_op->rmdir) return -EPERM;
+	if (error)
+		return error;
+	if (!dir->i_op || !dir->i_op->rmdir)
+		return -EPERM;
 	return 0;
 }
 
 static inline int pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int error = may_delete(dir, dentry, 0);
-	if (error) return error;
-	if (!dir->i_op || !dir->i_op->unlink) return -EPERM;
+	if (error)
+		return error;
+	if (!dir->i_op || !dir->i_op->unlink)
+		return -EPERM;
 	return 0;
 }
 
-static inline int pre_vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry)
+static inline int pre_vfs_link(struct dentry *old_dentry, struct inode *dir,
+			       struct dentry *new_dentry)
 {
 	struct inode *inode = old_dentry->d_inode;
 	int error;
-	if (!inode) return -ENOENT;
+	if (!inode)
+		return -ENOENT;
 	error = may_create(dir, new_dentry, NULL);
-	if (error) return error;
-	if (dir->i_sb != inode->i_sb) return -EXDEV;
-	if (IS_APPEND(inode) || IS_IMMUTABLE(inode)) return -EPERM;
-	if (!dir->i_op || !dir->i_op->link) return -EPERM;
-	if (S_ISDIR(old_dentry->d_inode->i_mode)) return -EPERM;
+	if (error)
+		return error;
+	if (dir->i_sb != inode->i_sb)
+		return -EXDEV;
+	if (IS_APPEND(inode) || IS_IMMUTABLE(inode))
+		return -EPERM;
+	if (!dir->i_op || !dir->i_op->link)
+		return -EPERM;
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		return -EPERM;
 	return 0;
 }
 
 static inline int pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
 {
 	int error = may_create(dir, dentry, NULL);
-	if (error) return error;
-	if (!dir->i_op || !dir->i_op->symlink) return -EPERM;
+	if (error)
+		return error;
+	if (!dir->i_op || !dir->i_op->symlink)
+		return -EPERM;
 	return 0;
 }
 
-static inline int pre_vfs_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
+static inline int pre_vfs_rename(struct inode *old_dir,
+				 struct dentry *old_dentry,
+				 struct inode *new_dir,
+				 struct dentry *new_dentry)
 {
 	int error = 0;
 	lock_kernel();
-	if (S_ISDIR(old_dentry->d_inode->i_mode) && new_dir != old_dir) error = permission(old_dentry->d_inode, MAY_WRITE, NULL);
+	if (S_ISDIR(old_dentry->d_inode->i_mode) && new_dir != old_dir)
+		error = permission(old_dentry->d_inode, MAY_WRITE, NULL);
 	unlock_kernel();
 	return error;
 }
Index: trunk/1.6.x/ccs-patch/include/linux/sakura.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/sakura.h	(revision 1034)
+++ trunk/1.6.x/ccs-patch/include/linux/sakura.h	(working copy)
@@ -15,8 +15,8 @@
  * A brief description about SAKURA:
  *
  *  SAKURA stands for "Security Advancement Know-how Upon Read-only Approach".
- *  As the name shows, SAKURA was originally a methodology to make root fs read-only
- *  to avoid tampering the system files.
+ *  As the name shows, SAKURA was originally a methodology to make root fs
+ *  read-only to avoid tampering the system files.
  *  But now, SAKURA is not only a methodology but also a kernel patch
  *  that improves the system security with less effort.
  *
@@ -38,10 +38,12 @@
 int CheckChRootPermission(struct nameidata *nd);
 
 /* Check whether the mount operation with the given parameters is allowed. */
-int CheckMountPermission(char *dev_name, char *dir_name, char *type, const unsigned long *flags);
+int CheckMountPermission(char *dev_name, char *dir_name, char *type,
+			 const unsigned long *flags);
 
 /* Check whether the current process is allowed to pivot_root. */
-int CheckPivotRootPermission(struct nameidata *old_nd, struct nameidata *new_nd);
+int CheckPivotRootPermission(struct nameidata *old_nd,
+			     struct nameidata *new_nd);
 
 /* Check whether the given mount operation hides an mounted partition. */
 int SAKURA_MayMount(struct nameidata *nd);
@@ -54,12 +56,32 @@
 
 #else
 
-static inline int CheckChRootPermission(struct nameidata *nd) { return 0; }
-static inline int CheckMountPermission(char *dev_name, char *dir_name, char *type, const unsigned long *flags) { return 0; }
-static inline int CheckPivotRootPermission(struct nameidata *old_nd, struct nameidata *new_nd) { return 0; }
-static inline int SAKURA_MayMount(struct nameidata *nd) { return 0; }
-static inline int SAKURA_MayUmount(struct vfsmount *mnt) { return 0; }
-static inline int SAKURA_MayAutobind(const u16 port) { return 0; }
+static inline int CheckChRootPermission(struct nameidata *nd)
+{
+	return 0;
+}
+static inline int CheckMountPermission(char *dev_name, char *dir_name,
+				       char *type, const unsigned long *flags)
+{
+	return 0;
+}
+static inline int CheckPivotRootPermission(struct nameidata *old_nd,
+					   struct nameidata *new_nd)
+{
+	return 0;
+}
+static inline int SAKURA_MayMount(struct nameidata *nd)
+{
+	return 0;
+}
+static inline int SAKURA_MayUmount(struct vfsmount *mnt)
+{
+	return 0;
+}
+static inline int SAKURA_MayAutobind(const u16 port)
+{
+	return 0;
+}
 
 #endif
 
Index: trunk/1.6.x/ccs-patch/include/linux/tomoyo.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(revision 1034)
+++ trunk/1.6.x/ccs-patch/include/linux/tomoyo.h	(working copy)
@@ -22,7 +22,8 @@
  *  and dramatically reduces the policy definition labors.
  *
  *  TOMOYO is applicable to figuring out the system's behavior, for
- *  TOMOYO uses the canonicalized absolute pathnames and TreeView style domain transitions.
+ *  TOMOYO uses the canonicalized absolute pathnames and
+ *  TreeView style domain transitions.
  */
 
 #ifndef _LINUX_TOMOYO_H
@@ -48,10 +49,15 @@
 #if defined(CONFIG_TOMOYO)
 
 int CheckFilePerm(const char *filename, const u8 perm, const char *operation);
-int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm, struct ccs_page_buffer *buf);
-int CheckOpenPermission(struct dentry *dentry, struct vfsmount *mnt, const int flag);
-int CheckSinglePathPermission(const u8 operation, struct dentry *dentry, struct vfsmount *mnt);
-int CheckDoublePathPermission(const u8 operation, struct dentry *dentry1, struct vfsmount *mnt1, struct dentry *dentry2, struct vfsmount *mnt2);
+int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm,
+		  struct ccs_page_buffer *buf);
+int CheckOpenPermission(struct dentry *dentry, struct vfsmount *mnt,
+			const int flag);
+int CheckSinglePathPermission(const u8 operation,
+			      struct dentry *dentry, struct vfsmount *mnt);
+int CheckDoublePathPermission(const u8 operation,
+			      struct dentry *dentry1, struct vfsmount *mnt1,
+			      struct dentry *dentry2, struct vfsmount *mnt2);
 int CheckReWritePermission(struct file *filp);
 
 /* Check whether the basename of program and argv0 is allowed to differ. */
@@ -61,12 +67,18 @@
 int CheckEnvPerm(const char *env, const u8 profile, const u8 mode);
 
 /* Check whether the given IP address and port number are allowed to use. */
-int CheckNetworkListenACL(const _Bool is_ipv6, const u8 *address, const u16 port);
-int CheckNetworkConnectACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port);
-int CheckNetworkBindACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port);
-int CheckNetworkAcceptACL(const _Bool is_ipv6, const u8 *address, const u16 port);
-int CheckNetworkSendMsgACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port);
-int CheckNetworkRecvMsgACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port);
+int CheckNetworkListenACL(const _Bool is_ipv6, const u8 *address,
+			  const u16 port);
+int CheckNetworkConnectACL(const _Bool is_ipv6, const int sock_type,
+			   const u8 *address, const u16 port);
+int CheckNetworkBindACL(const _Bool is_ipv6, const int sock_type,
+			const u8 *address, const u16 port);
+int CheckNetworkAcceptACL(const _Bool is_ipv6, const u8 *address,
+			  const u16 port);
+int CheckNetworkSendMsgACL(const _Bool is_ipv6, const int sock_type,
+			   const u8 *address, const u16 port);
+int CheckNetworkRecvMsgACL(const _Bool is_ipv6, const int sock_type,
+			   const u8 *address, const u16 port);
 
 /* Check whether the given signal is allowed to use. */
 int CheckSignalACL(const int sig, const int pid);
@@ -76,37 +88,106 @@
 
 #else
 
-static inline int CheckFilePerm(const char *filename, const u8 perm, const char *operation) { return 0; }
-static inline int CheckExecPerm(const struct path_info *filename, struct linux_binprm *bprm, struct ccs_page_buffer *buf)  { return 0; }
-static inline int CheckOpenPermission(struct dentry *dentry, struct vfsmount *mnt, const int flag) { return 0; }
-static inline int CheckSinglePathPermission(const u8 operation, struct dentry *dentry, struct vfsmount *mnt) { return 0; }
-static inline int CheckDoublePathPermission(const u8 operation, struct dentry *dentry1, struct vfsmount *mnt1, struct dentry *dentry2, struct vfsmount *mnt2) { return 0; }
-static inline int CheckReWritePermission(struct file *filp) { return 0; }
-static inline int CheckArgv0Perm(const struct path_info *filename, const char *argv0) { return 0; }
-static inline int CheckEnvPerm(const char *env, const u8 profile, const u8 mode) { return 0; }
-static inline int CheckNetworkListenACL(const _Bool is_ipv6, const u8 *address, const u16 port) { return 0; }
-static inline int CheckNetworkConnectACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port) { return 0; }
-static inline int CheckNetworkBindACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port) { return 0; }
-static inline int CheckNetworkAcceptACL(const _Bool is_ipv6, const u8 *address, const u16 port) { return 0; }
-static inline int CheckNetworkSendMsgACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port) { return 0; }
-static inline int CheckNetworkRecvMsgACL(const _Bool is_ipv6, const int sock_type, const u8 *address, const u16 port) { return 0; }
-static inline int CheckSignalACL(const int sig, const int pid) { return 0; }
-static inline int CheckCapabilityACL(const u8 operation) { return 0; }
+static inline int CheckFilePerm(const char *filename, const u8 perm,
+				const char *operation)
+{
+	return 0;
+}
+static inline int CheckExecPerm(const struct path_info *filename,
+				struct linux_binprm *bprm,
+				struct ccs_page_buffer *buf)
+{
+	return 0;
+}
+static inline int CheckOpenPermission(struct dentry *dentry,
+				      struct vfsmount *mnt, const int flag)
+{
+	return 0;
+}
+static inline int CheckSinglePathPermission(const u8 operation,
+					    struct dentry *dentry,
+					    struct vfsmount *mnt)
+{
+	return 0;
+}
+static inline int CheckDoublePathPermission(const u8 operation,
+					    struct dentry *dentry1,
+					    struct vfsmount *mnt1,
+					    struct dentry *dentry2,
+					    struct vfsmount *mnt2)
+{
+	return 0;
+}
+static inline int CheckReWritePermission(struct file *filp)
+{
+	return 0;
+}
+static inline int CheckArgv0Perm(const struct path_info *filename,
+				 const char *argv0)
+{
+	return 0;
+}
+static inline int CheckEnvPerm(const char *env, const u8 profile, const u8 mode)
+{
+	return 0;
+}
+static inline int CheckNetworkListenACL(const _Bool is_ipv6, const u8 *address,
+					const u16 port)
+{
+	return 0;
+}
+static inline int CheckNetworkConnectACL(const _Bool is_ipv6,
+					 const int sock_type, const u8 *address,
+					 const u16 port)
+{
+	return 0;
+}
+static inline int CheckNetworkBindACL(const _Bool is_ipv6, const int sock_type,
+				      const u8 *address, const u16 port)
+{
+	return 0;
+}
+static inline int CheckNetworkAcceptACL(const _Bool is_ipv6, const u8 *address,
+					const u16 port)
+{
+	return 0;
+}
+static inline int CheckNetworkSendMsgACL(const _Bool is_ipv6,
+					 const int sock_type, const u8 *address,
+					 const u16 port)
+{
+	return 0;
+}
+static inline int CheckNetworkRecvMsgACL(const _Bool is_ipv6,
+					 const int sock_type, const u8 *address,
+					 const u16 port)
+{
+	return 0;
+}
+static inline int CheckSignalACL(const int sig, const int pid)
+{
+	return 0;
+}
+static inline int CheckCapabilityACL(const u8 operation)
+{
+	return 0;
+}
 
 #endif
 
 #include <linux/version.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 int pre_vfs_mknod(struct inode *dir, struct dentry *dentry);
 #else
 int pre_vfs_mknod(struct inode *dir, struct dentry *dentry, int mode);
 #endif
 
-int search_binary_handler_with_transition(struct linux_binprm *bprm, struct pt_regs *regs);
+int search_binary_handler_with_transition(struct linux_binprm *bprm,
+					  struct pt_regs *regs);
 #define TOMOYO_CHECK_READ_FOR_OPEN_EXEC 1
 #define CCS_DONT_SLEEP_ON_ENFORCE_ERROR 2
 
-/*************************  Index numbers for Access Controls.  *************************/
+/********************  Index numbers for Access Controls.  ********************/
 
 #define TYPE_SINGLE_PATH_ACL                 0
 #define TYPE_DOUBLE_PATH_ACL                 1
@@ -118,7 +199,7 @@
 #define TYPE_PREFERRED_EXECUTE_HANDLER       7
 #define TYPE_DEFAULT_EXECUTE_HANDLER         8
 
-/*************************  Index numbers for File Controls.  *************************/
+/*********************  Index numbers for File Controls.  *********************/
 
 /*
  * TYPE_READ_WRITE_ACL is special. TYPE_READ_WRITE_ACL is automatically set
@@ -150,42 +231,73 @@
 #define TYPE_RENAME_ACL           1
 #define MAX_DOUBLE_PATH_OPERATION 2
 
-/*************************  Index numbers for Capability Controls.  *************************/
+/******************  Index numbers for Capability Controls.  ******************/
 
-#define TOMOYO_INET_STREAM_SOCKET_CREATE         0  /* socket(PF_INET or PF_INET6, SOCK_STREAM, *)                 */
-#define TOMOYO_INET_STREAM_SOCKET_LISTEN         1  /* listen() for PF_INET or PF_INET6, SOCK_STREAM               */
-#define TOMOYO_INET_STREAM_SOCKET_CONNECT        2  /* connect() for PF_INET or PF_INET6, SOCK_STREAM              */
-#define TOMOYO_USE_INET_DGRAM_SOCKET             3  /* socket(PF_INET or PF_INET6, SOCK_DGRAM, *)                  */
-#define TOMOYO_USE_INET_RAW_SOCKET               4  /* socket(PF_INET or PF_INET6, SOCK_RAW, *)                    */
-#define TOMOYO_USE_ROUTE_SOCKET                  5  /* socket(PF_ROUTE, *, *)                                      */
-#define TOMOYO_USE_PACKET_SOCKET                 6  /* socket(PF_PACKET, *, *)                                     */
-#define TOMOYO_SYS_MOUNT                         7  /* sys_mount()                                                 */
-#define TOMOYO_SYS_UMOUNT                        8  /* sys_umount()                                                */
-#define TOMOYO_SYS_REBOOT                        9  /* sys_reboot()                                                */
-#define TOMOYO_SYS_CHROOT                       10  /* sys_chroot()                                                */
-#define TOMOYO_SYS_KILL                         11  /* sys_kill(), sys_tkill(), sys_tgkill()                       */
-#define TOMOYO_SYS_VHANGUP                      12  /* sys_vhangup()                                               */
-#define TOMOYO_SYS_SETTIME                      13  /* do_settimeofday(), sys_adjtimex()                           */
-#define TOMOYO_SYS_NICE                         14  /* sys_nice(), sys_setpriority()                               */
-#define TOMOYO_SYS_SETHOSTNAME                  15  /* sys_sethostname(), sys_setdomainname()                      */
-#define TOMOYO_USE_KERNEL_MODULE                16  /* sys_create_module(), sys_init_module(), sys_delete_module() */
-#define TOMOYO_CREATE_FIFO                      17  /* sys_mknod(S_IFIFO)                                          */
-#define TOMOYO_CREATE_BLOCK_DEV                 18  /* sys_mknod(S_IFBLK)                                          */
-#define TOMOYO_CREATE_CHAR_DEV                  19  /* sys_mknod(S_IFCHR)                                          */
-#define TOMOYO_CREATE_UNIX_SOCKET               20  /* sys_mknod(S_IFSOCK)                                         */
-#define TOMOYO_SYS_LINK                         21  /* sys_link()                                                  */
-#define TOMOYO_SYS_SYMLINK                      22  /* sys_symlink()                                               */
-#define TOMOYO_SYS_RENAME                       23  /* sys_rename()                                                */
-#define TOMOYO_SYS_UNLINK                       24  /* sys_unlink()                                                */
-#define TOMOYO_SYS_CHMOD                        25  /* sys_chmod(), sys_fchmod()                                   */
-#define TOMOYO_SYS_CHOWN                        26  /* sys_chown(), sys_fchown(), sys_lchown()                     */
-#define TOMOYO_SYS_IOCTL                        27  /* sys_ioctl(), compat_sys_ioctl()                             */
-#define TOMOYO_SYS_KEXEC_LOAD                   28  /* sys_kexec_load()                                            */
-#define TOMOYO_SYS_PIVOT_ROOT                   29  /* sys_pivot_root()                                            */
-#define TOMOYO_SYS_PTRACE                       30  /* sys_ptrace()                                                */
+/* socket(PF_INET or PF_INET6, SOCK_STREAM, *)                 */
+#define TOMOYO_INET_STREAM_SOCKET_CREATE         0
+/* listen() for PF_INET or PF_INET6, SOCK_STREAM               */
+#define TOMOYO_INET_STREAM_SOCKET_LISTEN         1
+/* connect() for PF_INET or PF_INET6, SOCK_STREAM              */
+#define TOMOYO_INET_STREAM_SOCKET_CONNECT        2
+/* socket(PF_INET or PF_INET6, SOCK_DGRAM, *)                  */
+#define TOMOYO_USE_INET_DGRAM_SOCKET             3
+/* socket(PF_INET or PF_INET6, SOCK_RAW, *)                    */
+#define TOMOYO_USE_INET_RAW_SOCKET               4
+/* socket(PF_ROUTE, *, *)                                      */
+#define TOMOYO_USE_ROUTE_SOCKET                  5
+/* socket(PF_PACKET, *, *)                                     */
+#define TOMOYO_USE_PACKET_SOCKET                 6
+/* sys_mount()                                                 */
+#define TOMOYO_SYS_MOUNT                         7
+/* sys_umount()                                                */
+#define TOMOYO_SYS_UMOUNT                        8
+/* sys_reboot()                                                */
+#define TOMOYO_SYS_REBOOT                        9
+/* sys_chroot()                                                */
+#define TOMOYO_SYS_CHROOT                       10
+/* sys_kill(), sys_tkill(), sys_tgkill()                       */
+#define TOMOYO_SYS_KILL                         11
+/* sys_vhangup()                                               */
+#define TOMOYO_SYS_VHANGUP                      12
+/* do_settimeofday(), sys_adjtimex()                           */
+#define TOMOYO_SYS_SETTIME                      13
+/* sys_nice(), sys_setpriority()                               */
+#define TOMOYO_SYS_NICE                         14
+/* sys_sethostname(), sys_setdomainname()                      */
+#define TOMOYO_SYS_SETHOSTNAME                  15
+/* sys_create_module(), sys_init_module(), sys_delete_module() */
+#define TOMOYO_USE_KERNEL_MODULE                16
+/* sys_mknod(S_IFIFO)                                          */
+#define TOMOYO_CREATE_FIFO                      17
+/* sys_mknod(S_IFBLK)                                          */
+#define TOMOYO_CREATE_BLOCK_DEV                 18
+/* sys_mknod(S_IFCHR)                                          */
+#define TOMOYO_CREATE_CHAR_DEV                  19
+/* sys_mknod(S_IFSOCK)                                         */
+#define TOMOYO_CREATE_UNIX_SOCKET               20
+/* sys_link()                                                  */
+#define TOMOYO_SYS_LINK                         21
+/* sys_symlink()                                               */
+#define TOMOYO_SYS_SYMLINK                      22
+/* sys_rename()                                                */
+#define TOMOYO_SYS_RENAME                       23
+/* sys_unlink()                                                */
+#define TOMOYO_SYS_UNLINK                       24
+/* sys_chmod(), sys_fchmod()                                   */
+#define TOMOYO_SYS_CHMOD                        25
+/* sys_chown(), sys_fchown(), sys_lchown()                     */
+#define TOMOYO_SYS_CHOWN                        26
+/* sys_ioctl(), compat_sys_ioctl()                             */
+#define TOMOYO_SYS_IOCTL                        27
+/* sys_kexec_load()                                            */
+#define TOMOYO_SYS_KEXEC_LOAD                   28
+/* sys_pivot_root()                                            */
+#define TOMOYO_SYS_PIVOT_ROOT                   29
+/* sys_ptrace()                                                */
+#define TOMOYO_SYS_PTRACE                       30
 #define TOMOYO_MAX_CAPABILITY_INDEX             31
 
-/*************************  Index numbers for Network Controls.  *************************/
+/*******************  Index numbers for Network Controls.  *******************/
 
 #define NETWORK_ACL_UDP_BIND    0
 #define NETWORK_ACL_UDP_CONNECT 1
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_env.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_env.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_env.c	(working copy)
@@ -23,9 +23,12 @@
 {
 	char *buf;
 	int len;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
+	if (CanSaveAuditLog(is_granted) < 0)
+		return -ENOMEM;
 	len = strlen(env) + 8;
-	if ((buf = InitAuditLog(&len, profile, mode, NULL)) == NULL) return -ENOMEM;
+	buf = InitAuditLog(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
 	snprintf(buf + strlen(buf), len - strlen(buf) - 1, KEYWORD_ALLOW_ENV "%s\n", env);
 	return WriteAuditLog(buf, is_granted);
 }
@@ -48,8 +51,11 @@
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_env;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(env, 0, 0, 0, __FUNCTION__)) return -EINVAL;
-	if ((saved_env = SaveName(env)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(env, 0, 0, 0, __func__))
+		return -EINVAL;
+	saved_env = SaveName(env);
+	if (!saved_env)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &globally_usable_env_list, list) {
 		if (ptr->env == saved_env) {
@@ -59,9 +65,12 @@
 		}
 	}
 	if (is_delete) {
-		error = -ENOENT; goto out;
+		error = -ENOENT;
+		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->env = saved_env;
 	list1_add_tail_mb(&new_entry->list, &globally_usable_env_list);
 	error = 0;
@@ -74,7 +83,8 @@
 {
 	struct globally_usable_env_entry *ptr;
 	list1_for_each_entry(ptr, &globally_usable_env_list, list) {
-		if (!ptr->is_deleted && PathMatchesToPattern(env, ptr->env)) return true;
+		if (!ptr->is_deleted && PathMatchesToPattern(env, ptr->env))
+			return true;
 	}
 	return false;
 }
@@ -90,8 +100,10 @@
 	list1_for_each_cookie(pos, head->read_var2, &globally_usable_env_list) {
 		struct globally_usable_env_entry *ptr;
 		ptr = list1_entry(pos, struct globally_usable_env_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALLOW_ENV "%s\n", ptr->env->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, KEYWORD_ALLOW_ENV "%s\n", ptr->env->name))
+			return -ENOMEM;
 	}
 	return 0;
 }
@@ -104,30 +116,41 @@
 	struct env_acl_record *acl;
 	const struct path_info *saved_env;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(env, 0, 0, 0, __FUNCTION__)) return -EINVAL;
-	if ((saved_env = SaveName(env)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(env, 0, 0, 0, __func__))
+		return -EINVAL;
+	saved_env = SaveName(env);
+	if (!saved_env)
+		return -ENOMEM;
 
 	mutex_lock(&domain_acl_lock);
 	if (!is_delete) {
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_ENV_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_ENV_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct env_acl_record, head);
-			if (acl->env != saved_env) continue;
+			if (acl->env != saved_env)
+				continue;
 			error = AddDomainACL(NULL, ptr);
 			goto out;
 		}
 		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_ENV_ACL, condition)) == NULL) goto out;
+		acl = alloc_acl_element(TYPE_ENV_ACL, condition);
+		if (!acl)
+			goto out;
 		acl->env = saved_env;
 		error = AddDomainACL(domain, &acl->head);
 	} else {
 		error = -ENOENT;
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ENV_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ENV_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct env_acl_record, head);
-			if (acl->env != saved_env) continue;
+			if (acl->env != saved_env)
+				continue;
 			error = DelDomainACL(ptr);
 			break;
 		}
@@ -148,15 +171,18 @@
 
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct env_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ENV_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ENV_ACL)
+			continue;
 		acl = container_of(ptr, struct env_acl_record, head);
 		if (!CheckCondition(ptr, NULL) ||
-		    !PathMatchesToPattern(&env, acl->env)) continue;
+		    !PathMatchesToPattern(&env, acl->env))
+			continue;
 		UpdateCondition(ptr);
 		error = 0;
 		break;
 	}
-	if (error && (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV) == 0 && IsGloballyUsableEnv(&env)) error = 0;
+	if (error && (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV) == 0 && IsGloballyUsableEnv(&env))
+		error = 0;
 	return error;
 }
 
@@ -165,15 +191,19 @@
 	int error = 0;
 	struct domain_info * const domain = current->domain_info;
 	const bool is_enforce = (mode == 3);
-	if (!env || !*env) return 0;
+	if (!env || !*env)
+		return 0;
 	error = CheckEnvACL(env);
 	AuditEnvLog(env, !error, profile, mode);
-	if (!error) return 0;
+	if (!error)
+		return 0;
 	if (TomoyoVerboseMode()) {
 		printk("TOMOYO-%s: Environ %s denied for %s\n", GetMSG(is_enforce), env, GetLastName(domain));
 	}
-	if (is_enforce) return CheckSupervisor("%s\n" KEYWORD_ALLOW_ENV "%s\n", domain->domainname->name, env);
-	else if (mode == 1 && CheckDomainQuota(domain)) AddEnvEntry(env, domain, NULL, 0);
+	if (is_enforce)
+		return CheckSupervisor("%s\n" KEYWORD_ALLOW_ENV "%s\n", domain->domainname->name, env);
+	else if (mode == 1 && CheckDomainQuota(domain))
+		AddEnvEntry(env, domain, NULL, 0);
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_network.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_network.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_network.c	(working copy)
@@ -24,8 +24,11 @@
 {
 	char *buf;
 	int len = 256;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
-	if ((buf = InitAuditLog(&len, profile, mode, NULL)) == NULL) return -ENOMEM;
+	if (CanSaveAuditLog(is_granted) < 0)
+		return -ENOMEM;
+	buf = InitAuditLog(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
 	snprintf(buf + strlen(buf), len - strlen(buf) - 1, KEYWORD_ALLOW_NETWORK "%s ", operation);
 	if (is_ipv6) {
 		print_ipv6(buf + strlen(buf), len - strlen(buf), (const struct in6_addr *) address);
@@ -52,17 +55,21 @@
 	struct addr_list *ptr;
 	static DEFINE_MUTEX(lock);
 	u8 i = block_size;
-	if (!addr) return NULL;
+	if (!addr)
+		return NULL;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &address_list, list) {
 		for (i = 0; i < ptr->in_use_count; i++) {
-			if (memcmp(&ptr->addr[i], addr, sizeof(*addr)) == 0) goto ok;
+			if (memcmp(&ptr->addr[i], addr, sizeof(*addr)) == 0)
+				goto ok;
 		}
-		if (i < block_size) break;
+		if (i < block_size)
+			break;
 	}
 	if (i == block_size) {
 		ptr = alloc_element(sizeof(*ptr));
-		if (!ptr) goto ok;
+		if (!ptr)
+			goto ok;
 		list1_add_tail_mb(&ptr->list, &address_list);
 		i = 0;
 	}
@@ -85,21 +92,30 @@
 	const struct in6_addr *saved_min_address = NULL, *saved_max_address = NULL;
 	int error = -ENOMEM;
 	bool found = false;
-	if (!IsCorrectPath(group_name, 0, 0, 0, __FUNCTION__) || !group_name[0]) return -EINVAL;
-	if ((saved_group_name = SaveName(group_name)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(group_name, 0, 0, 0, __func__) || !group_name[0])
+		return -EINVAL;
+	saved_group_name = SaveName(group_name);
+	if (!saved_group_name)
+		return -ENOMEM;
 	if (is_ipv6) {
-		if ((saved_min_address = SaveIPv6Address((struct in6_addr *) min_address)) == NULL
-		    || (saved_max_address = SaveIPv6Address((struct in6_addr *) max_address)) == NULL) return -ENOMEM;
+		saved_min_address = SaveIPv6Address((struct in6_addr *) min_address);
+		saved_max_address = SaveIPv6Address((struct in6_addr *) max_address);
+		if (!saved_min_address || !saved_max_address)
+			return -ENOMEM;
 	}
 	mutex_lock(&lock);
 	list1_for_each_entry(group, &address_group_list, list) {
-		if (saved_group_name != group->group_name) continue;
+		if (saved_group_name != group->group_name)
+			continue;
 		list1_for_each_entry(member, &group->address_group_member_list, list) {
-			if (member->is_ipv6 != is_ipv6) continue;
+			if (member->is_ipv6 != is_ipv6)
+				continue;
 			if (is_ipv6) {
-				if (member->min.ipv6 != saved_min_address || member->max.ipv6 != saved_max_address) continue;
+				if (member->min.ipv6 != saved_min_address || member->max.ipv6 != saved_max_address)
+					continue;
 			} else {
-				if (member->min.ipv4 != * (u32 *) min_address || member->max.ipv4 != * (u32 *) max_address) continue;
+				if (member->min.ipv4 != *(u32 *) min_address || member->max.ipv4 != *(u32 *) max_address)
+					continue;
 			}
 			member->is_deleted = is_delete;
 			error = 0;
@@ -113,20 +129,24 @@
 		goto out;
 	}
 	if (!found) {
-		if ((new_group = alloc_element(sizeof(*new_group))) == NULL) goto out;
+		new_group = alloc_element(sizeof(*new_group));
+		if (!new_group)
+			goto out;
 		INIT_LIST1_HEAD(&new_group->address_group_member_list);
 		new_group->group_name = saved_group_name;
 		list1_add_tail_mb(&new_group->list, &address_group_list);
 		group = new_group;
 	}
-	if ((new_member = alloc_element(sizeof(*new_member))) == NULL) goto out;
+	new_member = alloc_element(sizeof(*new_member));
+	if (!new_member)
+		goto out;
 	new_member->is_ipv6 = is_ipv6;
 	if (is_ipv6) {
 		new_member->min.ipv6 = saved_min_address;
 		new_member->max.ipv6 = saved_max_address;
 	} else {
-		new_member->min.ipv4 = * (u32 *) min_address;
-		new_member->max.ipv4 = * (u32 *) max_address;
+		new_member->min.ipv4 = *(u32 *) min_address;
+		new_member->max.ipv4 = *(u32 *) max_address;
 	}
 	list1_add_tail_mb(&new_member->list, &group->address_group_member_list);
 	error = 0;
@@ -141,31 +161,39 @@
 	bool is_ipv6;
 	u16 min_address[8], max_address[8];
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
-	if ((count = sscanf(cp, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
-			    &min_address[0], &min_address[1], &min_address[2], &min_address[3],
-			    &min_address[4], &min_address[5], &min_address[6], &min_address[7],
-			    &max_address[0], &max_address[1], &max_address[2], &max_address[3],
-			    &max_address[4], &max_address[5], &max_address[6], &max_address[7])) == 8 || count == 16) {
+	count = sscanf(cp, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
+		       &min_address[0], &min_address[1], &min_address[2], &min_address[3],
+		       &min_address[4], &min_address[5], &min_address[6], &min_address[7],
+		       &max_address[0], &max_address[1], &max_address[2], &max_address[3],
+		       &max_address[4], &max_address[5], &max_address[6], &max_address[7]);
+	if (count == 8 || count == 16) {
 		u8 i;
 		for (i = 0; i < 8; i++) {
 			min_address[i] = htons(min_address[i]);
 			max_address[i] = htons(max_address[i]);
 		}
-		if (count == 8) memmove(max_address, min_address, sizeof(min_address));
+		if (count == 8)
+			memmove(max_address, min_address, sizeof(min_address));
 		is_ipv6 = true;
-	} else if ((count = sscanf(cp, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
-				   &min_address[0], &min_address[1], &min_address[2], &min_address[3],
-				   &max_address[0], &max_address[1], &max_address[2], &max_address[3])) == 4 || count == 8) {
+		goto ok;
+	}
+	count = sscanf(cp, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
+		       &min_address[0], &min_address[1], &min_address[2], &min_address[3],
+		       &max_address[0], &max_address[1], &max_address[2], &max_address[3]);
+	if (count == 4 || count == 8) {
 		u32 ip = ((((u8) min_address[0]) << 24) + (((u8) min_address[1]) << 16) + (((u8) min_address[2]) << 8) + (u8) min_address[3]);
-		* (u32 *) min_address = ip;
-		if (count == 8) ip = ((((u8) max_address[0]) << 24) + (((u8) max_address[1]) << 16) + (((u8) max_address[2]) << 8) + (u8) max_address[3]);
-		* (u32 *) max_address = ip;
+		*(u32 *) min_address = ip;
+		if (count == 8)
+			ip = ((((u8) max_address[0]) << 24) + (((u8) max_address[1]) << 16) + (((u8) max_address[2]) << 8) + (u8) max_address[3]);
+		*(u32 *) max_address = ip;
 		is_ipv6 = false;
 	} else {
 		return -EINVAL;
 	}
+ok:
 	return AddAddressGroupEntry(data, is_ipv6, min_address, max_address, is_delete);
 }
 
@@ -175,7 +203,8 @@
 	struct address_group_entry *group;
 	for (i = 0; i <= 1; i++) {
 		list1_for_each_entry(group, &address_group_list, list) {
-			if (strcmp(group_name, group->group_name->name) == 0) return group;
+			if (strcmp(group_name, group->group_name->name) == 0)
+				return group;
 		}
 		if (i == 0) {
 			const u16 dummy[2] = { 0, 0 };
@@ -191,11 +220,14 @@
 	struct address_group_member *member;
 	const u32 ip = ntohl(*address);
 	list1_for_each_entry(member, &group->address_group_member_list, list) {
-		if (member->is_deleted) continue;
+		if (member->is_deleted)
+			continue;
 		if (member->is_ipv6) {
-			if (is_ipv6 && memcmp(member->min.ipv6, address, 16) <= 0 && memcmp(address, member->max.ipv6, 16) <= 0) return true;
+			if (is_ipv6 && memcmp(member->min.ipv6, address, 16) <= 0 && memcmp(address, member->max.ipv6, 16) <= 0)
+				return true;
 		} else {
-			if (!is_ipv6 && member->min.ipv4 <= ip && ip <= member->max.ipv4) return true;
+			if (!is_ipv6 && member->min.ipv4 <= ip && ip <= member->max.ipv4)
+				return true;
 		}
 	}
 	return false;
@@ -212,7 +244,8 @@
 			char buf[128];
 			struct address_group_member *member;
 			member = list1_entry(mpos, struct address_group_member, list);
-			if (member->is_deleted) continue;
+			if (member->is_deleted)
+				continue;
 			if (member->is_ipv6) {
 				const struct in6_addr *min_address = member->min.ipv6, *max_address = member->max.ipv6;
 				print_ipv6(buf, sizeof(buf), min_address);
@@ -230,7 +263,8 @@
 					snprintf(buf + len, sizeof(buf) - 1 - len, "-%u.%u.%u.%u", HIPQUAD(max_address));
 				}
 			}
-			if (io_printf(head, KEYWORD_ADDRESS_GROUP "%s %s\n", group->group_name->name, buf)) return -ENOMEM;
+			if (io_printf(head, KEYWORD_ADDRESS_GROUP "%s %s\n", group->group_name->name, buf))
+				return -ENOMEM;
 		}
 	}
 	return 0;
@@ -296,30 +330,41 @@
 	int error = -ENOMEM;
 	const u32 min_ip = ntohl(*min_address), max_ip = ntohl(*max_address); /* using host byte order to allow u32 comparison than memcmp().*/
 	const struct in6_addr *saved_min_address = NULL, *saved_max_address = NULL;
-	if (!domain) return -EINVAL;
+	if (!domain)
+		return -EINVAL;
 	if (record_type == IP_RECORD_TYPE_IPv6) {
-		if ((saved_min_address = SaveIPv6Address((struct in6_addr *) min_address)) == NULL
-		    || (saved_max_address = SaveIPv6Address((struct in6_addr *) max_address)) == NULL) return -ENOMEM;
+		saved_min_address = SaveIPv6Address((struct in6_addr *) min_address);
+		saved_max_address = SaveIPv6Address((struct in6_addr *) max_address);
+		if (!saved_min_address || !saved_max_address)
+			return -ENOMEM;
 	}
 	mutex_lock(&domain_acl_lock);
 	if (!is_delete) {
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_IP_NETWORK_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_IP_NETWORK_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct ip_network_acl_record, head);
-			if (acl->operation_type != operation || acl->record_type != record_type || acl->min_port != min_port || max_port != acl->max_port) continue;
+			if (acl->operation_type != operation || acl->record_type != record_type || acl->min_port != min_port || max_port != acl->max_port)
+				continue;
 			if (record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
-				if (acl->u.group != group) continue;
+				if (acl->u.group != group)
+					continue;
 			} else if (record_type == IP_RECORD_TYPE_IPv4) {
-				if (acl->u.ipv4.min != min_ip || max_ip != acl->u.ipv4.max) continue;
+				if (acl->u.ipv4.min != min_ip || max_ip != acl->u.ipv4.max)
+					continue;
 			} else if (record_type == IP_RECORD_TYPE_IPv6) {
-				if (acl->u.ipv6.min != saved_min_address || saved_max_address != acl->u.ipv6.max) continue;
+				if (acl->u.ipv6.min != saved_min_address || saved_max_address != acl->u.ipv6.max)
+					continue;
 			}
 			error = AddDomainACL(NULL, ptr);
 			goto out;
 		}
 		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_IP_NETWORK_ACL, condition)) == NULL) goto out;
+		acl = alloc_acl_element(TYPE_IP_NETWORK_ACL, condition);
+		if (!acl)
+			goto out;
 		acl->operation_type = operation;
 		acl->record_type = record_type;
 		if (record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
@@ -337,16 +382,22 @@
 	} else {
 		error = -ENOENT;
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_IP_NETWORK_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_IP_NETWORK_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct ip_network_acl_record, head);
-			if (acl->operation_type != operation || acl->record_type != record_type || acl->min_port != min_port || max_port != acl->max_port) continue;
+			if (acl->operation_type != operation || acl->record_type != record_type || acl->min_port != min_port || max_port != acl->max_port)
+				continue;
 			if (record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
-				if (acl->u.group != group) continue;
+				if (acl->u.group != group)
+					continue;
 			} else if (record_type == IP_RECORD_TYPE_IPv4) {
-				if (acl->u.ipv4.min != min_ip || max_ip != acl->u.ipv4.max) continue;
+				if (acl->u.ipv4.min != min_ip || max_ip != acl->u.ipv4.max)
+					continue;
 			} else if (record_type == IP_RECORD_TYPE_IPv6) {
-				if (acl->u.ipv6.min != saved_min_address || saved_max_address != acl->u.ipv6.max) continue;
+				if (acl->u.ipv6.min != saved_min_address || saved_max_address != acl->u.ipv6.max)
+					continue;
 			}
 			error = DelDomainACL(ptr);
 			break;
@@ -367,25 +418,32 @@
 	const bool is_enforce = (mode == 3);
 	const u32 ip = ntohl(*address); /* using host byte order to allow u32 comparison than memcmp().*/
 	bool found = false;
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct ip_network_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_IP_NETWORK_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_IP_NETWORK_ACL)
+			continue;
 		acl = container_of(ptr, struct ip_network_acl_record, head);
-		if (acl->operation_type != operation || port < acl->min_port || acl->max_port < port || !CheckCondition(ptr, NULL)) continue;
+		if (acl->operation_type != operation || port < acl->min_port || acl->max_port < port || !CheckCondition(ptr, NULL))
+			continue;
 		if (acl->record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
-			if (!AddressMatchesToGroup(is_ipv6, address, acl->u.group)) continue;
+			if (!AddressMatchesToGroup(is_ipv6, address, acl->u.group))
+				continue;
 		} else if (acl->record_type == IP_RECORD_TYPE_IPv4) {
-			if (is_ipv6 || ip < acl->u.ipv4.min || acl->u.ipv4.max < ip) continue;
+			if (is_ipv6 || ip < acl->u.ipv4.min || acl->u.ipv4.max < ip)
+				continue;
 		} else {
-			if (!is_ipv6 || memcmp(acl->u.ipv6.min, address, 16) > 0 || memcmp(address, acl->u.ipv6.max, 16) > 0) continue;
+			if (!is_ipv6 || memcmp(acl->u.ipv6.min, address, 16) > 0 || memcmp(address, acl->u.ipv6.max, 16) > 0)
+				continue;
 		}
 		UpdateCondition(ptr);
 		found = true;
 		break;
 	}
 	AuditNetworkLog(is_ipv6, keyword, address, port, found, profile, mode);
-	if (found) return 0;
+	if (found)
+		return 0;
 	if (TomoyoVerboseMode()) {
 		if (is_ipv6) {
 			char buf[64];
@@ -402,8 +460,8 @@
 			return CheckSupervisor("%s\n" KEYWORD_ALLOW_NETWORK "%s %s %u\n", domain->domainname->name, keyword, buf, port);
 		}
 		return CheckSupervisor("%s\n" KEYWORD_ALLOW_NETWORK "%s %u.%u.%u.%u %u\n", domain->domainname->name, keyword, HIPQUAD(ip), port);
-	}
-	else if (mode == 1 && CheckDomainQuota(domain)) AddNetworkEntry(operation, is_ipv6 ? IP_RECORD_TYPE_IPv6 : IP_RECORD_TYPE_IPv4, NULL, address, address, port, port, domain, NULL, 0);
+	} else if (mode == 1 && CheckDomainQuota(domain))
+		AddNetworkEntry(operation, is_ipv6 ? IP_RECORD_TYPE_IPv6 : IP_RECORD_TYPE_IPv4, NULL, address, address, port, port, domain, NULL, 0);
 	return 0;
 }
 
@@ -415,12 +473,22 @@
 	u16 min_port, max_port;
 	u8 count;
 	char *cp1 = NULL, *cp2 = NULL;
-	if ((cp1 = strchr(data, ' ')) == NULL) goto out; cp1++;
-	if (strncmp(data, "TCP ", 4) == 0) sock_type = SOCK_STREAM;
-	else if (strncmp(data, "UDP ", 4) == 0) sock_type = SOCK_DGRAM;
-	else if (strncmp(data, "RAW ", 4) == 0) sock_type = SOCK_RAW;
-	else goto out;
-	if ((cp2 = strchr(cp1, ' ')) == NULL) goto out; cp2++;
+	cp1 = strchr(data, ' ');
+	if (!cp1)
+		goto out;
+	cp1++;
+	if (strncmp(data, "TCP ", 4) == 0)
+		sock_type = SOCK_STREAM;
+	else if (strncmp(data, "UDP ", 4) == 0)
+		sock_type = SOCK_DGRAM;
+	else if (strncmp(data, "RAW ", 4) == 0)
+		sock_type = SOCK_RAW;
+	else
+		goto out;
+	cp2 = strchr(cp1, ' ');
+	if (!cp2)
+		goto out;
+	cp2++;
 	if (strncmp(cp1, "bind ", 5) == 0) {
 		operation = (sock_type == SOCK_STREAM) ? NETWORK_ACL_TCP_BIND : (sock_type == SOCK_DGRAM) ? NETWORK_ACL_UDP_BIND : NETWORK_ACL_RAW_BIND;
 	} else if (strncmp(cp1, "connect ", 8) == 0) {
@@ -432,36 +500,51 @@
 	} else {
 		goto out;
 	}
-	if ((cp1 = strchr(cp2, ' ')) == NULL) goto out; *cp1++ = '\0';
-	if ((count = sscanf(cp2, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
-			    &min_address[0], &min_address[1], &min_address[2], &min_address[3],
-			    &min_address[4], &min_address[5], &min_address[6], &min_address[7],
-			    &max_address[0], &max_address[1], &max_address[2], &max_address[3],
-			    &max_address[4], &max_address[5], &max_address[6], &max_address[7])) == 8 || count == 16) {
+	cp1 = strchr(cp2, ' ');
+	if (!cp1)
+		goto out;
+	*cp1++ = '\0';
+	count = sscanf(cp2, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
+		       &min_address[0], &min_address[1], &min_address[2], &min_address[3],
+		       &min_address[4], &min_address[5], &min_address[6], &min_address[7],
+		       &max_address[0], &max_address[1], &max_address[2], &max_address[3],
+		       &max_address[4], &max_address[5], &max_address[6], &max_address[7]);
+	if (count == 8 || count == 16) {
 		u8 i;
 		for (i = 0; i < 8; i++) {
 			min_address[i] = htons(min_address[i]);
 			max_address[i] = htons(max_address[i]);
 		}
-		if (count == 8) memmove(max_address, min_address, sizeof(min_address));
+		if (count == 8)
+			memmove(max_address, min_address, sizeof(min_address));
 		record_type = IP_RECORD_TYPE_IPv6;
-	} else if ((count = sscanf(cp2, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
-				   &min_address[0], &min_address[1], &min_address[2], &min_address[3],
-				   &max_address[0], &max_address[1], &max_address[2], &max_address[3])) == 4 || count == 8) {
+		goto ok;
+	}
+	count = sscanf(cp2, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
+		       &min_address[0], &min_address[1], &min_address[2], &min_address[3],
+		       &max_address[0], &max_address[1], &max_address[2], &max_address[3]);
+	if (count == 4 || count == 8) {
 		u32 ip = htonl((((u8) min_address[0]) << 24) + (((u8) min_address[1]) << 16) + (((u8) min_address[2]) << 8) + (u8) min_address[3]);
-		* (u32 *) min_address = ip;
-		if (count == 8) ip = htonl((((u8) max_address[0]) << 24) + (((u8) max_address[1]) << 16) + (((u8) max_address[2]) << 8) + (u8) max_address[3]);
-		* (u32 *) max_address = ip;
+		*(u32 *) min_address = ip;
+		if (count == 8)
+			ip = htonl((((u8) max_address[0]) << 24) + (((u8) max_address[1]) << 16) + (((u8) max_address[2]) << 8) + (u8) max_address[3]);
+		*(u32 *) max_address = ip;
 		record_type = IP_RECORD_TYPE_IPv4;
 	} else if (*cp2 == '@') {
-		if ((group = FindOrAssignNewAddressGroup(cp2 + 1)) == NULL) return -ENOMEM;
+		group = FindOrAssignNewAddressGroup(cp2 + 1);
+		if (!group)
+			return -ENOMEM;
 		record_type = IP_RECORD_TYPE_ADDRESS_GROUP;
 	} else {
 		goto out;
 	}
-	if (strchr(cp1, ' ')) goto out;
-	if ((count = sscanf(cp1, "%hu-%hu", &min_port, &max_port)) == 1 || count == 2) {
-		if (count == 1) max_port = min_port;
+ ok:
+	if (strchr(cp1, ' '))
+		goto out;
+	count = sscanf(cp1, "%hu-%hu", &min_port, &max_port);
+	if (count == 1 || count == 2) {
+		if (count == 1)
+			max_port = min_port;
 		return AddNetworkEntry(operation, record_type, group, (u32 *) min_address, (u32 *) max_address, min_port, max_port, domain, condition, is_delete);
 	}
  out: ;
Index: trunk/1.6.x/ccs-patch/fs/realpath.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/realpath.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/realpath.c	(working copy)
@@ -21,7 +21,7 @@
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 #include <linux/version.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #include <linux/mount.h>
 static const int lookup_flags = LOOKUP_FOLLOW;
@@ -54,7 +54,8 @@
 	char *end = buffer + buflen;
 	bool is_dir = (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode));
 
-	if (buflen < 256) goto out;
+	if (buflen < 256)
+		goto out;
 
 	*--end = '\0';
 	buflen--;
@@ -64,18 +65,18 @@
 
 		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
 			/* Global root? */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 			spin_lock(&vfsmount_lock);
 #endif
 			if (vfsmnt->mnt_parent == vfsmnt) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 				spin_unlock(&vfsmount_lock);
 #endif
 				break;
 			}
 			dentry = vfsmnt->mnt_mountpoint;
 			vfsmnt = vfsmnt->mnt_parent;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 			spin_unlock(&vfsmount_lock);
 #endif
 			continue;
@@ -93,26 +94,35 @@
 			if (IS_ROOT(parent) && *sp > '0' && *sp <= '9' && parent->d_sb && parent->d_sb->s_magic == PROC_SUPER_MAGIC) {
 				char *ep;
 				const pid_t pid = (pid_t) simple_strtoul(sp, &ep, 10);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-				if (!*ep && pid == current->tgid) { sp = "self"; cp = sp + 3; }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+				if (!*ep && pid == current->tgid) {
+					sp = "self";
+					cp = sp + 3;
+				}
 #else
-				if (!*ep && pid == current->pid) { sp = "self"; cp = sp + 3; }
+				if (!*ep && pid == current->pid) {
+					sp = "self";
+					cp = sp + 3;
+				}
 #endif
 			}
 
 			while (sp <= cp) {
-				c = * (unsigned char *) cp;
+				c = *(unsigned char *) cp;
 				if (c == '\\') {
 					buflen -= 2;
-					if (buflen < 0) goto out;
+					if (buflen < 0)
+						goto out;
 					*--end = '\\';
 					*--end = '\\';
 				} else if (c > ' ' && c < 127) {
-					if (--buflen < 0) goto out;
+					if (--buflen < 0)
+						goto out;
 					*--end = (char) c;
 				} else {
 					buflen -= 4;
-					if (buflen < 0) goto out;
+					if (buflen < 0)
+						goto out;
 					*--end = (c & 7) + '0';
 					*--end = ((c >> 3) & 7) + '0';
 					*--end = (c >> 6) + '0';
@@ -120,29 +130,36 @@
 				}
 				cp--;
 			}
-			if (--buflen < 0) goto out;
+			if (--buflen < 0)
+				goto out;
 			*--end = '/';
 		}
 		dentry = parent;
 	}
-	if (*end == '/') { buflen++; end++; }
+	if (*end == '/') {
+		buflen++;
+		end++;
+	}
 	{
 		const char *sp = dentry->d_name.name;
 		const char *cp = sp + dentry->d_name.len - 1;
 		unsigned char c;
 		while (sp <= cp) {
-			c = * (unsigned char *) cp;
+			c = *(unsigned char *) cp;
 			if (c == '\\') {
 				buflen -= 2;
-				if (buflen < 0) goto out;
+				if (buflen < 0)
+					goto out;
 				*--end = '\\';
 				*--end = '\\';
 			} else if (c > ' ' && c < 127) {
-				if (--buflen < 0) goto out;
+				if (--buflen < 0)
+					goto out;
 				*--end = (char) c;
 			} else {
 				buflen -= 4;
-				if (buflen < 0) goto out;
+				if (buflen < 0)
+					goto out;
 				*--end = (c & 7) + '0';
 				*--end = ((c >> 3) & 7) + '0';
 				*--end = (c >> 6) + '0';
@@ -164,7 +181,8 @@
 	int error;
 	struct dentry *d_dentry;
 	struct vfsmount *d_mnt;
-	if (!dentry || !mnt || !newname || newname_len <= 0) return -EINVAL;
+	if (!dentry || !mnt || !newname || newname_len <= 0)
+		return -EINVAL;
 	d_dentry = dget(dentry);
 	d_mnt = mntget(mnt);
 	/***** CRITICAL SECTION START *****/
@@ -182,7 +200,8 @@
 char *realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt)
 {
 	char *buf = ccs_alloc(sizeof(struct ccs_page_buffer));
-	if (buf && realpath_from_dentry2(dentry, mnt, buf, CCS_MAX_PATHNAME_LEN - 1) == 0) return buf;
+	if (buf && realpath_from_dentry2(dentry, mnt, buf, CCS_MAX_PATHNAME_LEN - 1) == 0)
+		return buf;
 	ccs_free(buf);
 	return NULL;
 }
@@ -191,7 +210,7 @@
 {
 	struct nameidata nd;
 	if (pathname && path_lookup(pathname, lookup_flags, &nd) == 0) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 		char *buf = realpath_from_dentry(nd.path.dentry, nd.path.mnt);
 		path_put(&nd.path);
 #else
@@ -207,7 +226,7 @@
 {
 	struct nameidata nd;
 	if (pathname && path_lookup(pathname, lookup_flags ^ LOOKUP_FOLLOW, &nd) == 0) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 		char *buf = realpath_from_dentry(nd.path.dentry, nd.path.mnt);
 		path_put(&nd.path);
 #else
@@ -225,7 +244,8 @@
  * Round up an integer so that the returned pointers are appropriately aligned.
  * FIXME: Are there more requirements that is needed for assigning value atomically?
  */
-static inline unsigned int ROUNDUP(const unsigned int size) {
+static inline unsigned int ROUNDUP(const unsigned int size)
+{
 	if (sizeof(void *) >= sizeof(long)) {
 		return ((size + sizeof(void *) - 1) / sizeof(void *)) * sizeof(void *);
 	} else {
@@ -233,7 +253,7 @@
 	}
 }
 
-static unsigned int allocated_memory_for_elements = 0;
+static unsigned int allocated_memory_for_elements;
 
 unsigned int GetMemoryUsedForElements(void)
 {
@@ -244,16 +264,19 @@
 void *alloc_element(const unsigned int size)
 {
 	static DEFINE_MUTEX(lock);
-	static char *buf = NULL;
+	static char *buf;
 	static unsigned int buf_used_len = PAGE_SIZE;
 	char *ptr = NULL;
 	const unsigned int word_aligned_size = ROUNDUP(size);
-	if (word_aligned_size > PAGE_SIZE) return NULL;
+	if (word_aligned_size > PAGE_SIZE)
+		return NULL;
 	mutex_lock(&lock);
 	if (buf_used_len + word_aligned_size > PAGE_SIZE) {
-		if ((ptr = kzalloc(PAGE_SIZE, GFP_KERNEL)) == NULL) {
+		ptr = kzalloc(PAGE_SIZE, GFP_KERNEL);
+		if (!ptr) {
 			printk("ERROR: Out of memory for alloc_element().\n");
-			if (!sbin_init_started) panic("MAC Initialization failed.\n");
+			if (!sbin_init_started)
+				panic("MAC Initialization failed.\n");
 		} else {
 			buf = ptr;
 			allocated_memory_for_elements += PAGE_SIZE;
@@ -277,8 +300,8 @@
 
 /***** Shared memory allocator. *****/
 
-static unsigned int allocated_memory_for_savename = 0;
-static unsigned int allocated_memory_for_pool = 0;
+static unsigned int allocated_memory_for_savename;
+static unsigned int allocated_memory_for_pool;
 
 unsigned int GetMemoryUsedForSaveName(void)
 {
@@ -310,7 +333,8 @@
 	struct free_memory_block_list *fmb;
 	int len;
 	char *cp;
-	if (!name) return NULL;
+	if (!name)
+		return NULL;
 	len = strlen(name) + 1;
 	if (len > CCS_MAX_PATHNAME_LEN) {
 		printk("ERROR: Name too long for SaveName().\n");
@@ -319,10 +343,12 @@
 	hash = full_name_hash((const unsigned char *) name, len - 1);
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &name_list[hash % MAX_HASH], list) {
-		if (hash == ptr->entry.hash && strcmp(name, ptr->entry.name) == 0) goto out;
+		if (hash == ptr->entry.hash && strcmp(name, ptr->entry.name) == 0)
+			goto out;
 	}
 	list_for_each_entry(fmb, &fmb_list, list) {
-		if (len <= fmb->len) goto ready;
+		if (len <= fmb->len)
+			goto ready;
 	}
 	cp = kzalloc(PAGE_SIZE, GFP_KERNEL);
 	fmb = kzalloc(sizeof(*fmb), GFP_KERNEL);
@@ -330,7 +356,8 @@
 		kfree(cp);
 		kfree(fmb);
 		printk("ERROR: Out of memory for SaveName().\n");
-		if (!sbin_init_started) panic("MAC Initialization failed.\n");
+		if (!sbin_init_started)
+			panic("MAC Initialization failed.\n");
 		ptr = NULL;
 		goto out;
 	}
@@ -340,7 +367,8 @@
 	fmb->len = PAGE_SIZE;
  ready:
 	ptr = alloc_element(sizeof(*ptr));
-	if (!ptr) goto out;
+	if (!ptr)
+		goto out;
 	ptr->entry.name = fmb->ptr;
 	memmove(fmb->ptr, name, len);
 	fill_path_info(&ptr->entry);
@@ -364,10 +392,10 @@
 	int size;
 };
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-static struct kmem_cache *ccs_cachep = NULL;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
+static struct kmem_cache *ccs_cachep;
 #else
-static kmem_cache_t *ccs_cachep = NULL;
+static kmem_cache_t *ccs_cachep;
 #endif
 
 #ifdef CCS_MAX_RESERVED_PAGES
@@ -382,35 +410,39 @@
 void __init realpath_Init(void)
 {
 	int i;
-	if (CCS_MAX_PATHNAME_LEN > PAGE_SIZE) panic("Bad size.");
-	if (sizeof(struct path_info_with_data) > sizeof(struct ccs_page_buffer)) panic("Bad size.");
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)
+	if (CCS_MAX_PATHNAME_LEN > PAGE_SIZE)
+		panic("Bad size.");
+	if (sizeof(struct path_info_with_data) > sizeof(struct ccs_page_buffer))
+		panic("Bad size.");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
 	ccs_cachep = kmem_cache_create("ccs_cache", sizeof(struct cache_entry), 0, 0, NULL);
 #else
 	ccs_cachep = kmem_cache_create("ccs_cache", sizeof(struct cache_entry), 0, 0, NULL, NULL);
 #endif
-	if (!ccs_cachep) panic("Can't create cache.\n");
+	if (!ccs_cachep)
+		panic("Can't create cache.\n");
 	for (i = 0; i < MAX_HASH; i++) {
 		INIT_LIST1_HEAD(&name_list[i]);
 	}
 	INIT_LIST1_HEAD(&KERNEL_DOMAIN.acl_info_list);
 	KERNEL_DOMAIN.domainname = SaveName(ROOT_NAME);
 	list1_add_tail_mb(&KERNEL_DOMAIN.list, &domain_list);
-	if (FindDomain(ROOT_NAME) != &KERNEL_DOMAIN) panic("Can't register KERNEL_DOMAIN");
+	if (FindDomain(ROOT_NAME) != &KERNEL_DOMAIN)
+		panic("Can't register KERNEL_DOMAIN");
 	memset(ccs_page_buffer_pool, 0, sizeof(ccs_page_buffer_pool));
 	for (i = 0; i < MAX_CCS_PAGE_BUFFER_POOL; i++) ccs_page_buffer_pool_in_use[i] = false;
 }
 
 static LIST_HEAD(cache_list);
-static spinlock_t cache_list_lock = SPIN_LOCK_UNLOCKED;
-static unsigned int dynamic_memory_size = 0;
+static DEFINE_SPINLOCK(cache_list_lock);
+static unsigned int dynamic_memory_size;
 
 unsigned int GetMemoryUsedForDynamic(void)
 {
 	return dynamic_memory_size;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 static int round2(size_t size)
 {
 #if PAGE_SIZE == 4096
@@ -423,17 +455,19 @@
 }
 #endif
 
-static spinlock_t ccs_page_buffer_pool_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(ccs_page_buffer_pool_lock);
 
 void *ccs_alloc(const size_t size)
 {
 	int i;
 	void *ret;
 	struct cache_entry *new_entry;
-	if (size != sizeof(struct ccs_page_buffer)) goto normal;
+	if (size != sizeof(struct ccs_page_buffer))
+		goto normal;
 	for (i = 0; i < MAX_CCS_PAGE_BUFFER_POOL; i++) {
 		struct ccs_page_buffer *ptr;
-		if (ccs_page_buffer_pool_in_use[i]) continue;
+		if (ccs_page_buffer_pool_in_use[i])
+			continue;
 		spin_lock(&ccs_page_buffer_pool_lock);
 		if (ccs_page_buffer_pool_in_use[i]) {
 			spin_unlock(&ccs_page_buffer_pool_lock);
@@ -446,7 +480,7 @@
 			ptr = kmalloc(sizeof(struct ccs_page_buffer), GFP_KERNEL);
 			spin_lock(&ccs_page_buffer_pool_lock);
 			if (ptr) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 				allocated_memory_for_pool += ksize(ptr);
 #else
 				allocated_memory_for_pool += round2(sizeof(struct ccs_page_buffer));
@@ -455,7 +489,8 @@
 				ccs_page_buffer_pool_in_use[i] = false;
 			}
 			spin_unlock(&ccs_page_buffer_pool_lock);
-			if (!ptr) goto normal;
+			if (!ptr)
+				goto normal;
 			ccs_page_buffer_pool[i] = ptr;
 			printk(KERN_DEBUG "Allocated permanent buffer %d/%d\n", i, MAX_CCS_PAGE_BUFFER_POOL);
 		}
@@ -464,7 +499,8 @@
 	}
  normal:
 	ret = kzalloc(size, GFP_KERNEL);
-	if (!ret) goto out;
+	if (!ret)
+		goto out;
 	new_entry = kmem_cache_alloc(ccs_cachep, GFP_KERNEL);
 	if (!new_entry) {
 		kfree(ret); ret = NULL;
@@ -472,7 +508,7 @@
 	}
 	INIT_LIST_HEAD(&new_entry->list);
 	new_entry->ptr = ret;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 	new_entry->size = ksize(ret);
 #else
 	new_entry->size = round2(size);
@@ -490,15 +526,19 @@
 	int i;
 	struct list_head *v;
 	struct cache_entry *entry = NULL;
-	if (!p) return;
+	if (!p)
+		return;
 	for (i = 0; i < MAX_CCS_PAGE_BUFFER_POOL; i++) {
 		bool done;
-		if (p != ccs_page_buffer_pool[i]) continue;
+		if (p != ccs_page_buffer_pool[i])
+			continue;
 		spin_lock(&ccs_page_buffer_pool_lock);
 		done = ccs_page_buffer_pool_in_use[i];
-		if (done) ccs_page_buffer_pool_in_use[i] = false;
+		if (done)
+			ccs_page_buffer_pool_in_use[i] = false;
 		spin_unlock(&ccs_page_buffer_pool_lock);
-		if (done) return;
+		if (done)
+			return;
 	}
 	spin_lock(&cache_list_lock);
 	list_for_each(v, &cache_list) {
Index: trunk/1.6.x/ccs-patch/fs/syaoran_2.6.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/syaoran_2.6.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/syaoran_2.6.c	(working copy)
@@ -61,11 +61,11 @@
 static struct file_operations syaoran_file_operations;
 
 static struct backing_dev_info syaoran_backing_dev_info = {
-	.ra_pages = 0,        /* No readahead */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
-	.memory_backed  = 1,    /* Does not contribute to dirty memory */
+	.ra_pages      = 0,    /* No readahead */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 12)
+	.memory_backed = 1,    /* Does not contribute to dirty memory */
 #else
-	.capabilities = BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_WRITEBACK |
+	.capabilities  = BDI_CAP_NO_ACCT_DIRTY | BDI_CAP_NO_WRITEBACK |
 					BDI_CAP_MAP_DIRECT | BDI_CAP_MAP_COPY |
 					BDI_CAP_READ_MAP | BDI_CAP_WRITE_MAP | BDI_CAP_EXEC_MAP,
 #endif
@@ -75,7 +75,7 @@
 
 static struct inode *syaoran_get_inode(struct super_block *sb, int mode, dev_t dev)
 {
-	struct inode * inode = new_inode(sb);
+	struct inode *inode = new_inode(sb);
 
 	if (inode) {
 		inode->i_mode = mode;
@@ -91,8 +91,10 @@
 		switch (mode & S_IFMT) {
 		default:
 			init_special_inode(inode, mode, dev);
-			if (S_ISBLK(mode)) inode->i_fop = &wrapped_def_blk_fops;
-			else if (S_ISCHR(mode)) inode->i_fop = &wrapped_def_chr_fops;
+			if (S_ISBLK(mode))
+				inode->i_fop = &wrapped_def_blk_fops;
+			else if (S_ISCHR(mode))
+				inode->i_fop = &wrapped_def_chr_fops;
 			inode->i_op = &syaoran_file_inode_operations;
 			break;
 		case S_IFREG:
@@ -120,9 +122,10 @@
 /* SMP-safe */
 static int syaoran_mknod(struct inode *dir, struct dentry *dentry, int mode, dev_t dev)
 {
-	struct inode * inode;
+	struct inode *inode;
 	int error = -ENOSPC;
-	if (MayCreateNode(dentry, mode, dev) < 0) return -EPERM;
+	if (MayCreateNode(dentry, mode, dev) < 0)
+		return -EPERM;
 	inode = syaoran_get_inode(dir->i_sb, mode, dev);
 	if (inode) {
 		if (dir->i_mode & S_ISGID) {
@@ -137,7 +140,7 @@
 	return error;
 }
 
-static int syaoran_mkdir(struct inode * dir, struct dentry * dentry, int mode)
+static int syaoran_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	int retval = syaoran_mknod(dir, dentry, mode | S_IFDIR, 0);
 	if (!retval)
@@ -150,11 +153,12 @@
 	return syaoran_mknod(dir, dentry, mode | S_IFREG, 0);
 }
 
-static int syaoran_symlink(struct inode * dir, struct dentry *dentry, const char * symname)
+static int syaoran_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
 {
 	struct inode *inode;
 	int error = -ENOSPC;
-	if (MayCreateNode(dentry, S_IFLNK, 0) < 0) return -EPERM;
+	if (MayCreateNode(dentry, S_IFLNK, 0) < 0)
+		return -EPERM;
 	inode = syaoran_get_inode(dir->i_sb, S_IFLNK|S_IRWXUGO, 0);
 	if (inode) {
 		int l = strlen(symname)+1;
@@ -173,45 +177,53 @@
 static int syaoran_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
 {
 	struct inode *inode = old_dentry->d_inode;
-	if (!inode || MayCreateNode(dentry, inode->i_mode, inode->i_rdev) < 0) return -EPERM;
+	if (!inode || MayCreateNode(dentry, inode->i_mode, inode->i_rdev) < 0)
+		return -EPERM;
 	return simple_link(old_dentry, dir, dentry);
 }
 
-static int syaoran_unlink(struct inode * dir, struct dentry *dentry)
+static int syaoran_unlink(struct inode *dir, struct dentry *dentry)
 {
-	if (MayModifyNode(dentry, MAY_DELETE) < 0) return -EPERM;
+	if (MayModifyNode(dentry, MAY_DELETE) < 0)
+		return -EPERM;
 	return simple_unlink(dir, dentry);
 }
 
-static int syaoran_rename(struct inode * old_dir, struct dentry *old_dentry, struct inode * new_dir,struct dentry *new_dentry)
+static int syaoran_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
 {
 	struct inode *inode = old_dentry->d_inode;
-	if (!inode || MayModifyNode(old_dentry, MAY_DELETE) < 0 || MayCreateNode(new_dentry, inode->i_mode, inode->i_rdev) < 0) return -EPERM;
+	if (!inode || MayModifyNode(old_dentry, MAY_DELETE) < 0 || MayCreateNode(new_dentry, inode->i_mode, inode->i_rdev) < 0)
+		return -EPERM;
 	return simple_rename(old_dir, old_dentry, new_dir, new_dentry);
 }
 
 static int syaoran_rmdir(struct inode *dir, struct dentry *dentry)
 {
-	if (MayModifyNode(dentry, MAY_DELETE) < 0) return -EPERM;
+	if (MayModifyNode(dentry, MAY_DELETE) < 0)
+		return -EPERM;
 	return simple_rmdir(dir, dentry);
 }
 
-static int syaoran_setattr(struct dentry * dentry, struct iattr * attr)
+static int syaoran_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct inode *inode = dentry->d_inode;
 	int error = inode_change_ok(inode, attr);
 	if (!error) {
 		unsigned int ia_valid = attr->ia_valid;
 		unsigned int flags = 0;
-		if (ia_valid & (ATTR_UID | ATTR_GID)) flags |= MAY_CHOWN;
-		if (ia_valid & ATTR_MODE) flags |= MAY_CHMOD;
-		if (MayModifyNode(dentry, flags) < 0) return -EPERM;
-		if (!error) error = inode_setattr(inode, attr);
+		if (ia_valid & (ATTR_UID | ATTR_GID))
+			flags |= MAY_CHOWN;
+		if (ia_valid & ATTR_MODE)
+			flags |= MAY_CHMOD;
+		if (MayModifyNode(dentry, flags) < 0)
+			return -EPERM;
+		if (!error)
+			error = inode_setattr(inode, attr);
 	}
 	return error;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 static struct address_space_operations syaoran_aops = {
 	.readpage       = simple_readpage,
 	.prepare_write  = simple_prepare_write,
@@ -233,23 +245,23 @@
 #endif
 
 static struct file_operations syaoran_file_operations = {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
-	.read       = generic_file_read,
-	.write      = generic_file_write,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+	.read        = generic_file_read,
+	.write       = generic_file_write,
 #else
-	.aio_read   = generic_file_aio_read,
-	.read       = do_sync_read,
-	.aio_write  = generic_file_aio_write,
-	.write      = do_sync_write,
+	.aio_read    = generic_file_aio_read,
+	.read        = do_sync_read,
+	.aio_write   = generic_file_aio_write,
+	.write       = do_sync_write,
 #endif
-	.mmap       = generic_file_mmap,
-	.fsync      = simple_sync_file,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
-	.sendfile   = generic_file_sendfile,
+	.mmap        = generic_file_mmap,
+	.fsync       = simple_sync_file,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+	.sendfile    = generic_file_sendfile,
 #else
-	.splice_read    = generic_file_splice_read,
+	.splice_read = generic_file_splice_read,
 #endif
-	.llseek     = generic_file_llseek,
+	.llseek      = generic_file_llseek,
 };
 
 static struct inode_operations syaoran_file_inode_operations = {
@@ -283,22 +295,23 @@
 	.put_super  = syaoran_put_super,
 };
 
-static int syaoran_fill_super(struct super_block * sb, void * data, int silent)
+static int syaoran_fill_super(struct super_block *sb, void *data, int silent)
 {
-	struct inode * inode;
-	struct dentry * root;
+	struct inode *inode;
+	struct dentry *root;
 
 	sb->s_maxbytes = MAX_LFS_FILESIZE;
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->s_magic = SYAORAN_MAGIC;
 	sb->s_op = &syaoran_ops;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,9)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 9)
 	sb->s_time_gran = 1;
 #endif
 	{
-		int error;
-		if ((error = Syaoran_Initialize(sb, data)) < 0) return error;
+		int error = Syaoran_Initialize(sb, data);
+		if (error < 0)
+			return error;
 	}
 	inode = syaoran_get_inode(sb, S_IFDIR | 0755, 0);
 	if (!inode)
@@ -314,7 +327,7 @@
 	return 0;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
 static struct super_block *syaoran_get_sb(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {
Index: trunk/1.6.x/ccs-patch/fs/sakura_chroot.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_chroot.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/sakura_chroot.c	(working copy)
@@ -16,7 +16,7 @@
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #else
 #include <linux/fs.h>
@@ -40,8 +40,11 @@
 	const struct path_info *saved_dir;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
-	if (!IsCorrectPath(dir, 1, 0, 1, __FUNCTION__)) return -EINVAL;
-	if ((saved_dir = SaveName(dir)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(dir, 1, 0, 1, __func__))
+		return -EINVAL;
+	saved_dir = SaveName(dir);
+	if (!saved_dir)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &chroot_list, list) {
 		if (ptr->dir == saved_dir) {
@@ -54,7 +57,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->dir = saved_dir;
 	list1_add_tail_mb(&new_entry->list, &chroot_list);
 	error = 0;
@@ -69,8 +74,9 @@
 	int error = -EPERM;
 	char *root_name;
 	const u8 mode = CheckCCSFlags(CCS_SAKURA_RESTRICT_CHROOT);
-	if (!mode) return 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+	if (!mode)
+ return 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 	root_name = realpath_from_dentry(nd->path.dentry, nd->path.mnt);
 #else
 	root_name = realpath_from_dentry(nd->dentry, nd->mnt);
@@ -82,7 +88,8 @@
 		if (dir.is_dir) {
 			struct chroot_entry *ptr;
 			list1_for_each_entry(ptr, &chroot_list, list) {
-				if (ptr->is_deleted) continue;
+				if (ptr->is_deleted)
+					continue;
 				if (PathMatchesToPattern(&dir, ptr->dir)) {
 					error = 0;
 					break;
@@ -94,13 +101,16 @@
 		const bool is_enforce = (mode == 3);
 		const char *exename = GetEXE();
 		printk("SAKURA-%s: chroot %s (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), root_name, current->pid, exename);
-		if (is_enforce && CheckSupervisor("# %s is requesting\nchroot %s\n", exename, root_name) == 0) error = 0;
-		if (exename) ccs_free(exename);
+		if (is_enforce && CheckSupervisor("# %s is requesting\nchroot %s\n", exename, root_name) == 0)
+			error = 0;
+		if (exename)
+			ccs_free(exename);
 		if (mode == 1 && root_name) {
 			AddChrootACL(root_name, 0);
 			UpdateCounter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 		}
-		if (!is_enforce) error = 0;
+		if (!is_enforce)
+			error = 0;
 	}
 	ccs_free(root_name);
 	return error;
@@ -117,8 +127,10 @@
 	list1_for_each_cookie(pos, head->read_var2, &chroot_list) {
 		struct chroot_entry *ptr;
 		ptr = list1_entry(pos, struct chroot_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALLOW_CHROOT "%s\n", ptr->dir->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, KEYWORD_ALLOW_CHROOT "%s\n", ptr->dir->name))
+			return -ENOMEM;
 	}
 	return 0;
 }
Index: trunk/1.6.x/ccs-patch/fs/sakura_pivot.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_pivot.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/sakura_pivot.c	(working copy)
@@ -16,7 +16,7 @@
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #else
 #include <linux/fs.h>
@@ -41,8 +41,12 @@
 	const struct path_info *saved_old_root, *saved_new_root;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
-	if (!IsCorrectPath(old_root, 1, 0, 1, __FUNCTION__) || !IsCorrectPath(new_root, 1, 0, 1, __FUNCTION__)) return -EINVAL;
-	if ((saved_old_root = SaveName(old_root)) == NULL || (saved_new_root = SaveName(new_root)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(old_root, 1, 0, 1, __func__) || !IsCorrectPath(new_root, 1, 0, 1, __func__))
+		return -EINVAL;
+	saved_old_root = SaveName(old_root);
+	saved_new_root = SaveName(new_root);
+	if (!saved_old_root || !saved_new_root)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &pivot_root_list, list) {
 		if (ptr->old_root == saved_old_root && ptr->new_root == saved_new_root) {
@@ -55,7 +59,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->old_root = saved_old_root;
 	new_entry->new_root = saved_new_root;
 	list1_add_tail_mb(&new_entry->list, &pivot_root_list);
@@ -71,8 +77,9 @@
 	int error = -EPERM;
 	char *old_root, *new_root;
 	const u8 mode = CheckCCSFlags(CCS_SAKURA_RESTRICT_PIVOT_ROOT);
-	if (!mode) return 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+	if (!mode)
+		return 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 	old_root = realpath_from_dentry(old_nd->path.dentry, old_nd->path.mnt);
 	new_root = realpath_from_dentry(new_nd->path.dentry, new_nd->path.mnt);
 #else
@@ -88,7 +95,8 @@
 		if (old_root_dir.is_dir && new_root_dir.is_dir) {
 			struct pivot_root_entry *ptr;
 			list1_for_each_entry(ptr, &pivot_root_list, list) {
-				if (ptr->is_deleted) continue;
+				if (ptr->is_deleted)
+					continue;
 				if (PathMatchesToPattern(&old_root_dir, ptr->old_root) && PathMatchesToPattern(&new_root_dir, ptr->new_root)) {
 					error = 0;
 					break;
@@ -100,13 +108,16 @@
 		const bool is_enforce = (mode == 3);
 		const char *exename = GetEXE();
 		printk("SAKURA-%s: pivot_root %s %s (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), new_root, old_root, current->pid, exename);
-		if (is_enforce && CheckSupervisor("# %s is requesting\npivot_root %s %s\n", exename, new_root, old_root) == 0) error = 0;
-		if (exename) ccs_free(exename);
+		if (is_enforce && CheckSupervisor("# %s is requesting\npivot_root %s %s\n", exename, new_root, old_root) == 0)
+			error = 0;
+		if (exename)
+			ccs_free(exename);
 		if (mode == 1 && old_root && new_root) {
 			AddPivotRootACL(old_root, new_root, 0);
 			UpdateCounter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 		}
-		if (!is_enforce) error = 0;
+		if (!is_enforce)
+			error = 0;
 	}
 	ccs_free(old_root);
 	ccs_free(new_root);
@@ -116,7 +127,8 @@
 int AddPivotRootPolicy(char *data, const bool is_delete)
 {
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
 	return AddPivotRootACL(cp, data, is_delete);
 }
@@ -127,8 +139,10 @@
 	list1_for_each_cookie(pos, head->read_var2, &pivot_root_list) {
 		struct pivot_root_entry *ptr;
 		ptr = list1_entry(pos, struct pivot_root_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALLOW_PIVOT_ROOT "%s %s\n", ptr->new_root->name, ptr->old_root->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, KEYWORD_ALLOW_PIVOT_ROOT "%s %s\n", ptr->new_root->name, ptr->old_root->name))
+			return -ENOMEM;
 	}
 	return 0;
 }
Index: trunk/1.6.x/ccs-patch/fs/sakura_mount.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_mount.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/sakura_mount.c	(working copy)
@@ -16,23 +16,24 @@
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
 #include <linux/namespace.h>
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 15)
 #define MS_UNBINDABLE	(1<<17)	/* change to unbindable */
 #define MS_PRIVATE	(1<<18)	/* change to private */
 #define MS_SLAVE	(1<<19)	/* change to slave */
 #define MS_SHARED	(1<<20)	/* change to shared */
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #else
 static inline void module_put(struct module *module)
 {
-	if (module) __MOD_DEC_USE_COUNT(module);
+	if (module)
+		__MOD_DEC_USE_COUNT(module);
 }
 #endif
 
@@ -59,7 +60,7 @@
 
 /*************************  MOUNT RESTRICTION HANDLER  *************************/
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 static void put_filesystem(struct file_system_type *fs)
 {
 	module_put(fs->owner);
@@ -74,18 +75,28 @@
 	const struct path_info *fs, *dev, *dir;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
-	if ((fs = SaveName(fs_type)) == NULL) return -EINVAL;
-	if (!dev_name) dev_name = "<NULL>"; /* Map dev_name to "<NULL>" for if no dev_name given. */
-	if (strcmp(fs->name, MOUNT_REMOUNT_KEYWORD) == 0) dev_name = "any"; /* Fix dev_name to "any" for remount permission. */
+	fs = SaveName(fs_type);
+	if (!fs)
+		return -EINVAL;
+	if (!dev_name)
+		dev_name = "<NULL>"; /* Map dev_name to "<NULL>" for if no dev_name given. */
+	if (strcmp(fs->name, MOUNT_REMOUNT_KEYWORD) == 0)
+		dev_name = "any"; /* Fix dev_name to "any" for remount permission. */
 	if (strcmp(fs->name, MOUNT_MAKE_UNBINDABLE_KEYWORD) == 0 ||
 		strcmp(fs->name, MOUNT_MAKE_PRIVATE_KEYWORD) == 0 ||
 		strcmp(fs->name, MOUNT_MAKE_SLAVE_KEYWORD) == 0 ||
-		strcmp(fs->name, MOUNT_MAKE_SHARED_KEYWORD) == 0) dev_name = "any";
-	if (!IsCorrectPath(dev_name, 0, 0, 0, __FUNCTION__) || !IsCorrectPath(dir_name, 0, 0, 0, __FUNCTION__)) return -EINVAL;
-	if ((dev = SaveName(dev_name)) == NULL || (dir = SaveName(dir_name)) == NULL) return -ENOMEM;
+		strcmp(fs->name, MOUNT_MAKE_SHARED_KEYWORD) == 0)
+		dev_name = "any";
+	if (!IsCorrectPath(dev_name, 0, 0, 0, __func__) || !IsCorrectPath(dir_name, 0, 0, 0, __func__))
+		return -EINVAL;
+	dev = SaveName(dev_name);
+	dir = SaveName(dir_name);
+	if (!dev || !dir)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &mount_list, list) {
-		if (ptr->flags != flags || pathcmp(ptr->dev_name, dev) || pathcmp(ptr->dir_name, dir) || pathcmp(ptr->fs_type, fs)) continue;
+		if (ptr->flags != flags || pathcmp(ptr->dev_name, dev) || pathcmp(ptr->dir_name, dir) || pathcmp(ptr->fs_type, fs))
+			continue;
 		error = 0;
 		if (is_delete) {
 			ptr->is_deleted = true;
@@ -102,7 +113,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->dev_name = dev;
 	new_entry->dir_name = dir;
 	new_entry->fs_type = fs;
@@ -122,12 +135,16 @@
 				   strcmp(fs->name, MOUNT_MAKE_SLAVE_KEYWORD) == 0 ||
 				   strcmp(fs->name, MOUNT_MAKE_SHARED_KEYWORD) == 0) {
 			printk("%sAllow mount %s %s with options 0x%lX.\n", ccs_log_level, fs->name, dir->name, ptr->flags);
-		} else if ((type = get_fs_type(fs->name)) != NULL && (type->fs_flags & FS_REQUIRES_DEV) != 0) {
-			printk("%sAllow mount -t %s %s %s with options 0x%lX.\n", ccs_log_level, fs->name, dev->name, dir->name, ptr->flags);
 		} else {
-			printk("%sAllow mount %s on %s with options 0x%lX.\n", ccs_log_level, fs->name, dir->name, ptr->flags);
+			type = get_fs_type(fs->name);
+			if (type && (type->fs_flags & FS_REQUIRES_DEV) != 0) {
+				printk("%sAllow mount -t %s %s %s with options 0x%lX.\n", ccs_log_level, fs->name, dev->name, dir->name, ptr->flags);
+			} else {
+				printk("%sAllow mount %s on %s with options 0x%lX.\n", ccs_log_level, fs->name, dir->name, ptr->flags);
+			}
 		}
-		if (type) put_filesystem(type);
+		if (type)
+			put_filesystem(type);
 	}
  out:
 	mutex_unlock(&lock);
@@ -139,9 +156,12 @@
 	const u8 mode = CheckCCSFlags(CCS_SAKURA_RESTRICT_MOUNT);
 	const bool is_enforce = (mode == 3);
 	int error = -EPERM;
-	if (!mode) return 0;
-	if (!type) type = "<NULL>";
-	if ((flags & MS_MGC_MSK) == MS_MGC_VAL) flags &= ~MS_MGC_MSK;
+	if (!mode)
+		return 0;
+	if (!type)
+		type = "<NULL>";
+	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
+		flags &= ~MS_MGC_MSK;
 	switch (flags & (MS_REMOUNT | MS_MOVE | MS_BIND)) {
 	case MS_REMOUNT:
 	case MS_MOVE:
@@ -192,7 +212,8 @@
 		struct path_info rdev, rdir;
 		int need_dev = 0;
 
-		if ((requested_dir_name = realpath(dir_name)) == NULL) {
+		requested_dir_name = realpath(dir_name);
+		if (!requested_dir_name) {
 			error = -ENOENT;
 			goto cleanup;
 		}
@@ -208,41 +229,51 @@
 			   strcmp(type, MOUNT_MAKE_SHARED_KEYWORD) == 0) {
 			/* Needn't to resolve dev_name */
 		} else if (strcmp(type, MOUNT_BIND_KEYWORD) == 0 || strcmp(type, MOUNT_MOVE_KEYWORD) == 0) {
-			if ((requested_dev_name = realpath(dev_name)) == NULL) {
+			requested_dev_name = realpath(dev_name);
+			if (!requested_dev_name) {
 				error = -ENOENT;
 				goto cleanup;
 			}
 			rdev.name = requested_dev_name;
 			fill_path_info(&rdev);
 			need_dev = -1; /* dev_name is a directory */
-		} else if ((fstype = get_fs_type(type)) != NULL) {
-			if (fstype->fs_flags & FS_REQUIRES_DEV) {
-				if ((requested_dev_name = realpath(dev_name)) == NULL) {
-					error = -ENOENT;
-					goto cleanup;
+		} else {
+			fstype = get_fs_type(type);
+			if (fstype) {
+				if (fstype->fs_flags & FS_REQUIRES_DEV) {
+					requested_dev_name = realpath(dev_name);
+					if (!requested_dev_name) {
+						error = -ENOENT;
+						goto cleanup;
+					}
+					rdev.name = requested_dev_name;
+					fill_path_info(&rdev);
+					need_dev = 1; /* dev_name is a block device file */
 				}
-				rdev.name = requested_dev_name;
-				fill_path_info(&rdev);
-				need_dev = 1; /* dev_name is a block device file */
+			} else {
+				error = -ENODEV;
+				goto cleanup;
 			}
-		} else {
-			error = -ENODEV;
-			goto cleanup;
 		}
 		list1_for_each_entry(ptr, &mount_list, list) {
-			if (ptr->is_deleted) continue;
+			if (ptr->is_deleted)
+				continue;
 
 			/* Compare options */
-			if (ptr->flags != flags) continue;
+			if (ptr->flags != flags)
+				continue;
 
 			/* Compare fs name. */
-			if (strcmp(type, ptr->fs_type->name)) continue;
+			if (strcmp(type, ptr->fs_type->name))
+				continue;
 
 			/* Compare mount point. */
-			if (PathMatchesToPattern(&rdir, ptr->dir_name) == 0) continue;
+			if (PathMatchesToPattern(&rdir, ptr->dir_name) == 0)
+				continue;
 
 			/* Compare device name. */
-			if (requested_dev_name && PathMatchesToPattern(&rdev, ptr->dev_name) == 0) continue;
+			if (requested_dev_name && PathMatchesToPattern(&rdev, ptr->dev_name) == 0)
+				continue;
 
 			/* OK. */
 			error = 0;
@@ -267,19 +298,23 @@
 			const char *realname1 = realpath(dev_name), *realname2 = realpath(dir_name), *exename = GetEXE();
 			if (strcmp(type, MOUNT_REMOUNT_KEYWORD) == 0) {
 				printk("SAKURA-%s: mount -o remount %s 0x%lX (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), realname2 ? realname2 : dir_name, flags, current->pid, exename);
-				if (is_enforce && CheckSupervisor("# %s is requesting\nmount -o remount %s 0x%lX\n", exename, realname2 ? realname2 : dir_name, flags) == 0) error = 0;
+				if (is_enforce && CheckSupervisor("# %s is requesting\nmount -o remount %s 0x%lX\n", exename, realname2 ? realname2 : dir_name, flags) == 0)
+					error = 0;
 			} else if (strcmp(type, MOUNT_BIND_KEYWORD) == 0 || strcmp(type, MOUNT_MOVE_KEYWORD) == 0) {
 				printk("SAKURA-%s: mount %s %s %s 0x%lX (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), type, realname1 ? realname1 : dev_name, realname2 ? realname2 : dir_name, flags, current->pid, exename);
-				if (is_enforce && CheckSupervisor("# %s is requesting\nmount %s %s %s 0x%lX\n", exename, type, realname1 ? realname1 : dev_name, realname2 ? realname2 : dir_name, flags) == 0) error = 0;
+				if (is_enforce && CheckSupervisor("# %s is requesting\nmount %s %s %s 0x%lX\n", exename, type, realname1 ? realname1 : dev_name, realname2 ? realname2 : dir_name, flags) == 0)
+					error = 0;
 			} else if (strcmp(type, MOUNT_MAKE_UNBINDABLE_KEYWORD) == 0 ||
 				   strcmp(type, MOUNT_MAKE_PRIVATE_KEYWORD) == 0 ||
 				   strcmp(type, MOUNT_MAKE_SLAVE_KEYWORD) == 0 ||
 				   strcmp(type, MOUNT_MAKE_SHARED_KEYWORD) == 0) {
 				printk("SAKURA-%s: mount %s %s 0x%lX (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), type, realname2 ? realname2 : dir_name, flags, current->pid, exename);
-				if (is_enforce && CheckSupervisor("# %s is requesting\nmount %s %s 0x%lX", exename, type, realname2 ? realname2 : dir_name, flags) == 0) error = 0;
+				if (is_enforce && CheckSupervisor("# %s is requesting\nmount %s %s 0x%lX", exename, type, realname2 ? realname2 : dir_name, flags) == 0)
+					error = 0;
 			} else {
 				printk("SAKURA-%s: mount -t %s %s %s 0x%lX (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), type, realname1 ? realname1 : dev_name, realname2 ? realname2 : dir_name, flags, current->pid, exename);
-				if (is_enforce && CheckSupervisor("# %s is requesting\nmount -t %s %s %s 0x%lX\n", exename, type, realname1 ? realname1 : dev_name, realname2 ? realname2 : dir_name, flags) == 0) error = 0;
+				if (is_enforce && CheckSupervisor("# %s is requesting\nmount -t %s %s %s 0x%lX\n", exename, type, realname1 ? realname1 : dev_name, realname2 ? realname2 : dir_name, flags) == 0)
+					error = 0;
 			}
 			ccs_free(exename);
 			ccs_free(realname2);
@@ -289,12 +324,14 @@
 			AddMountACL(need_dev ? requested_dev_name : dev_name, requested_dir_name, type, flags, 0);
 			UpdateCounter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 		}
-	cleanup:
+cleanup:
 		ccs_free(requested_dev_name);
 		ccs_free(requested_dir_name);
-		if (fstype) put_filesystem(fstype);
+		if (fstype)
+			put_filesystem(fstype);
 	}
-	if (!is_enforce) error = 0;
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
 
@@ -309,9 +346,24 @@
 	char *cp, *cp2;
 	const char *fs, *dev, *dir;
 	unsigned long flags = 0;
-	cp2 = data; if ((cp = strchr(cp2, ' ')) == NULL) return -EINVAL; *cp = '\0'; dev = cp2;
-	cp2 = cp + 1; if ((cp = strchr(cp2, ' ')) == NULL) return -EINVAL; *cp = '\0'; dir = cp2;
-	cp2 = cp + 1; if ((cp = strchr(cp2, ' ')) == NULL) return -EINVAL; *cp = '\0'; fs = cp2;
+	cp2 = data;
+	cp = strchr(cp2, ' ');
+	if (!cp)
+		return -EINVAL;
+	*cp = '\0';
+	dev = cp2;
+	cp2 = cp + 1;
+	cp = strchr(cp2, ' ');
+	if (!cp)
+		return -EINVAL;
+	*cp = '\0';
+	dir = cp2;
+	cp2 = cp + 1;
+	cp = strchr(cp2, ' ');
+	if (!cp)
+		return -EINVAL;
+	*cp = '\0';
+	fs = cp2;
 	flags = simple_strtoul(cp + 1, NULL, 0);
 	return AddMountACL(dev, dir, fs, flags, is_delete);
 }
@@ -322,8 +374,10 @@
 	list1_for_each_cookie(pos, head->read_var2, &mount_list) {
 		struct mount_entry *ptr;
 		ptr = list1_entry(pos, struct mount_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALLOW_MOUNT "%s %s %s 0x%lX\n", ptr->dev_name->name, ptr->dir_name->name, ptr->fs_type->name, ptr->flags)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, KEYWORD_ALLOW_MOUNT "%s %s %s 0x%lX\n", ptr->dev_name->name, ptr->dir_name->name, ptr->fs_type->name, ptr->flags))
+			return -ENOMEM;
 	}
 	return 0;
 }
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(working copy)
@@ -29,20 +29,23 @@
 	int argv_count = bprm->argc;
 	int envp_count = bprm->envc;
 	bool truncated = false;
-	if (!buffer) return NULL;
+	if (!buffer)
+		return NULL;
 	len = snprintf(buffer, buffer_len - 1, "argc=%d envc=%d argv[]={ ", argv_count, envp_count);
 	cp = buffer + len;
 	if (!argv_count) {
 		memmove(cp, "} envp[]={ ", 11);
 		cp += 11;
 	}
-	if (!envp_count) *cp++ = '}';
+	if (!envp_count)
+		*cp++ = '}';
 	last_start = cp;
 	while (argv_count || envp_count) {
 		struct page *page;
 		const char *kaddr;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
-		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0) goto out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
+		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0)
+			goto out;
 		pos += PAGE_SIZE - offset;
 #else
 		page = bprm->page[i];
@@ -50,7 +53,7 @@
 		/* Map */
 		kaddr = kmap(page);
 		if (!kaddr) { /* Mapping failed. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 			put_page(page);
 #endif
 			goto out;
@@ -58,7 +61,8 @@
 		/* Read. */
 		while (offset < PAGE_SIZE) {
 			const unsigned char c = kaddr[offset++];
-			if (cp == last_start) *cp++ = '"';
+			if (cp == last_start)
+				*cp++ = '"';
 			if (cp >= buffer + buffer_len - 32) {
 				/* Preserve some room for "..." string. */
 				truncated = true;
@@ -77,7 +81,8 @@
 				*cp++ = ((c >> 3) & 7) + '0';
 				*cp++ = (c & 7) + '0';
 			}
-			if (c) continue;
+			if (c)
+				continue;
 			if (argv_count) {
 				if (--argv_count == 0) {
 					if (truncated) {
@@ -87,7 +92,8 @@
 					}
 					memmove(cp, "} envp[]={ ", 11);
 					cp += 11;
-					if (!envp_count) goto no_envp;
+					if (!envp_count)
+						goto no_envp;
 					last_start = cp;
 				}
 			} else if (envp_count) {
@@ -97,7 +103,7 @@
 						memmove(cp, "... ", 4);
 						cp += 4;
 					}
-				no_envp:
+no_envp:
 					*cp++ = '}';
 					*cp++ = '\0';
 				}
@@ -107,14 +113,14 @@
 		}
 		/* Unmap. */
 		kunmap(page);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 		put_page(page);
 #endif
 		i++;
 		offset = 0;
 	}
 	return buffer;
- out:
+out:
 	snprintf(buffer, buffer_len - 1, "argc=%d envc=%d argv[]={ ... } envp[]= { ... }", argv_count, envp_count);
 	return buffer;
 }
@@ -124,7 +130,7 @@
 static DECLARE_WAIT_QUEUE_HEAD(grant_log_wait);
 static DECLARE_WAIT_QUEUE_HEAD(reject_log_wait);
 
-static spinlock_t audit_log_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(audit_log_lock);
 
 struct log_entry {
 	struct list_head list;
@@ -134,7 +140,7 @@
 static LIST_HEAD(grant_log);
 static LIST_HEAD(reject_log);
 
-static int grant_log_count = 0, reject_log_count = 0;
+static int grant_log_count, reject_log_count;
 
 char *InitAuditLog(int *len, const u8 profile, const u8 mode, struct linux_binprm *bprm)
 {
@@ -149,11 +155,15 @@
 	*len += strlen(domainname) + 256;
 	if (bprm) {
 		bprm_info = DumpBprm(bprm);
-		if (!bprm_info) return NULL;
+		if (!bprm_info)
+			return NULL;
 		*len += strlen(bprm_info);
 	}
-	if ((buf = ccs_alloc(*len)) != NULL) snprintf(buf, (*len) - 1, "#timestamp=%lu profile=%u mode=%s pid=%d uid=%d gid=%d euid=%d egid=%d suid=%d sgid=%d fsuid=%d fsgid=%d state[0]=%u state[1]=%u state[2]=%u %s\n%s\n", tv.tv_sec, profile, mode_4[mode], task->pid, task->uid, task->gid, task->euid, task->egid, task->suid, task->sgid, task->fsuid, task->fsgid, (u8) (tomoyo_flags >> 24), (u8) (tomoyo_flags >> 16), (u8) (tomoyo_flags >> 8), bprm_info, domainname);
-	if (bprm) ccs_free(bprm_info);
+	buf = ccs_alloc(*len);
+	if (buf)
+		snprintf(buf, (*len) - 1, "#timestamp=%lu profile=%u mode=%s pid=%d uid=%d gid=%d euid=%d egid=%d suid=%d sgid=%d fsuid=%d fsgid=%d state[0]=%u state[1]=%u state[2]=%u %s\n%s\n", tv.tv_sec, profile, mode_4[mode], task->pid, task->uid, task->gid, task->euid, task->egid, task->suid, task->sgid, task->fsuid, task->fsgid, (u8) (tomoyo_flags >> 24), (u8) (tomoyo_flags >> 16), (u8) (tomoyo_flags >> 8), bprm_info, domainname);
+	if (bprm)
+		ccs_free(bprm_info);
 	return buf;
 }
 
@@ -174,7 +184,8 @@
 int WriteAuditLog(char *buf, const bool is_granted)
 {
 	struct log_entry *new_entry = ccs_alloc(sizeof(*new_entry));
-	if (!new_entry) goto out;
+	if (!new_entry)
+		goto out;
 	INIT_LIST_HEAD(&new_entry->list);
 	new_entry->log = buf;
 	/***** CRITICAL SECTION START *****/
@@ -196,9 +207,12 @@
 	}
 	spin_unlock(&audit_log_lock);
 	/***** CRITICAL SECTION END *****/
-	if (is_granted) wake_up(&grant_log_wait);
-	else wake_up(&reject_log_wait);
-	if (!buf) return 0;
+	if (is_granted)
+		wake_up(&grant_log_wait);
+	else
+		wake_up(&reject_log_wait);
+	if (!buf)
+		return 0;
 	ccs_free(new_entry);
  out: ;
 	ccs_free(buf);
@@ -208,9 +222,11 @@
 int CanSaveAuditLog(const bool is_granted)
 {
 	if (is_granted) {
-		if (grant_log_count < GetMaxGrantLog()) return 0;
+		if (grant_log_count < GetMaxGrantLog())
+			return 0;
 	} else {
-		if (reject_log_count < GetMaxRejectLog()) return 0;
+		if (reject_log_count < GetMaxRejectLog())
+			return 0;
 	}
 	return -ENOMEM;
 }
@@ -218,7 +234,8 @@
 int ReadGrantLog(struct io_buffer *head)
 {
 	struct log_entry *ptr = NULL;
-	if (head->read_avail) return 0;
+	if (head->read_avail)
+		return 0;
 	if (head->read_buf) {
 		ccs_free(head->read_buf); head->read_buf = NULL;
 		head->readbuf_size = 0;
@@ -242,16 +259,19 @@
 
 int PollGrantLog(struct file *file, poll_table *wait)
 {
-	if (grant_log_count) return POLLIN | POLLRDNORM;
+	if (grant_log_count)
+		return POLLIN | POLLRDNORM;
 	poll_wait(file, &grant_log_wait, wait);
-	if (grant_log_count) return POLLIN | POLLRDNORM;
+	if (grant_log_count)
+		return POLLIN | POLLRDNORM;
 	return 0;
 }
 
 int ReadRejectLog(struct io_buffer *head)
 {
 	struct log_entry *ptr = NULL;
-	if (head->read_avail) return 0;
+	if (head->read_avail)
+		return 0;
 	if (head->read_buf) {
 		ccs_free(head->read_buf); head->read_buf = NULL;
 		head->readbuf_size = 0;
@@ -275,9 +295,11 @@
 
 int PollRejectLog(struct file *file, poll_table *wait)
 {
-	if (reject_log_count) return POLLIN | POLLRDNORM;
+	if (reject_log_count)
+		return POLLIN | POLLRDNORM;
 	poll_wait(file, &reject_log_wait, wait);
-	if (reject_log_count) return POLLIN | POLLRDNORM;
+	if (reject_log_count)
+		return POLLIN | POLLRDNORM;
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/syaoran.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/syaoran.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/syaoran.c	(working copy)
@@ -70,7 +70,7 @@
  * Lookup the data. This is trivial - if the dentry didn't already
  * exist, we know it is negative.
  */
-static struct dentry * syaoran_lookup(struct inode *dir, struct dentry *dentry)
+static struct dentry *syaoran_lookup(struct inode *dir, struct dentry *dentry)
 {
 	if (dentry->d_name.len > NAME_MAX)
 		return ERR_PTR(-ENAMETOOLONG);
@@ -82,7 +82,7 @@
  * Read a page. Again trivial. If it didn't already exist
  * in the page cache, it is zero-filled.
  */
-static int syaoran_readpage(struct file *file, struct page * page)
+static int syaoran_readpage(struct file *file, struct page *page)
 {
 	if (!Page_Uptodate(page)) {
 		memset(kmap(page), 0, PAGE_CACHE_SIZE);
@@ -119,7 +119,7 @@
 
 static struct inode *syaoran_get_inode(struct super_block *sb, int mode, int dev)
 {
-	struct inode * inode = new_inode(sb);
+	struct inode *inode = new_inode(sb);
 
 	if (inode) {
 		inode->i_mode = mode;
@@ -133,8 +133,10 @@
 		switch (mode & S_IFMT) {
 		default:
 			init_special_inode(inode, mode, dev);
-			if (S_ISBLK(mode)) inode->i_fop = &wrapped_def_blk_fops;
-			else if (S_ISCHR(mode)) inode->i_fop = &wrapped_def_chr_fops;
+			if (S_ISBLK(mode))
+				inode->i_fop = &wrapped_def_blk_fops;
+			else if (S_ISCHR(mode))
+				inode->i_fop = &wrapped_def_chr_fops;
 			inode->i_op = &syaoran_file_inode_operations;
 			break;
 		case S_IFREG:
@@ -158,10 +160,11 @@
  */
 static int syaoran_mknod(struct inode *dir, struct dentry *dentry, int mode, int dev)
 {
-	struct inode * inode;
+	struct inode *inode;
 	int error = -ENOSPC;
 
-	if (MayCreateNode(dentry, mode, dev) < 0) return -EPERM;
+	if (MayCreateNode(dentry, mode, dev) < 0)
+		return -EPERM;
 	inode = syaoran_get_inode(dir->i_sb, mode, dev);
 	if (inode) {
 		if (dir->i_mode & S_ISGID) {
@@ -176,7 +179,7 @@
 	return error;
 }
 
-static int syaoran_mkdir(struct inode * dir, struct dentry * dentry, int mode)
+static int syaoran_mkdir(struct inode *dir, struct dentry *dentry, int mode)
 {
 	return syaoran_mknod(dir, dentry, mode | S_IFDIR, 0);
 }
@@ -189,13 +192,14 @@
 /*
  * Link a file..
  */
-static int syaoran_link(struct dentry *old_dentry, struct inode * dir, struct dentry * dentry)
+static int syaoran_link(struct dentry *old_dentry, struct inode *dir, struct dentry *dentry)
 {
 	struct inode *inode = old_dentry->d_inode;
 
 	if (S_ISDIR(inode->i_mode))
 		return -EPERM;
-	if (MayCreateNode(dentry, inode->i_mode, inode->i_rdev) < 0) return -EPERM;
+	if (MayCreateNode(dentry, inode->i_mode, inode->i_rdev) < 0)
+		return -EPERM;
 
 	inode->i_nlink++;
 	atomic_inc(&inode->i_count); /* New dentry reference */
@@ -241,10 +245,11 @@
  * This works for both directories and regular files.
  * (non-directories will always have empty subdirs)
  */
-static int syaoran_unlink(struct inode * dir, struct dentry *dentry)
+static int syaoran_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int retval = -ENOTEMPTY;
-	if (MayModifyNode(dentry, MAY_DELETE) < 0) return -EPERM;
+	if (MayModifyNode(dentry, MAY_DELETE) < 0)
+		return -EPERM;
 
 	if (syaoran_empty(dentry)) {
 		struct inode *inode = dentry->d_inode;
@@ -264,11 +269,12 @@
  * it exists so that the VFS layer correctly free's it when it
  * gets overwritten.
  */
-static int syaoran_rename(struct inode * old_dir, struct dentry *old_dentry, struct inode * new_dir,struct dentry *new_dentry)
+static int syaoran_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error = -ENOTEMPTY;
 	struct inode *inode = old_dentry->d_inode;
-	if (!inode || MayModifyNode(old_dentry, MAY_DELETE) < 0 || MayCreateNode(new_dentry, inode->i_mode, inode->i_rdev) < 0) return -EPERM;
+	if (!inode || MayModifyNode(old_dentry, MAY_DELETE) < 0 || MayCreateNode(new_dentry, inode->i_mode, inode->i_rdev) < 0)
+		return -EPERM;
 
 	if (syaoran_empty(new_dentry)) {
 		struct inode *inode = new_dentry->d_inode;
@@ -281,10 +287,11 @@
 	return error;
 }
 
-static int syaoran_symlink(struct inode * dir, struct dentry *dentry, const char * symname)
+static int syaoran_symlink(struct inode *dir, struct dentry *dentry, const char *symname)
 {
 	int error;
-	if (MayCreateNode(dentry, S_IFLNK, 0) < 0) return -EPERM;
+	if (MayCreateNode(dentry, S_IFLNK, 0) < 0)
+		return -EPERM;
 
 	error = syaoran_mknod(dir, dentry, S_IFLNK | S_IRWXUGO, 0);
 	if (!error) {
@@ -295,79 +302,84 @@
 	return error;
 }
 
-static int syaoran_sync_file(struct file * file, struct dentry *dentry, int datasync)
+static int syaoran_sync_file(struct file *file, struct dentry *dentry, int datasync)
 {
 	return 0;
 }
 
-static int syaoran_setattr(struct dentry * dentry, struct iattr * attr)
+static int syaoran_setattr(struct dentry *dentry, struct iattr *attr)
 {
 	struct inode *inode = dentry->d_inode;
 	int error = inode_change_ok(inode, attr);
 	if (!error) {
 		unsigned int ia_valid = attr->ia_valid;
 		unsigned int flags = 0;
-		if (ia_valid & (ATTR_UID | ATTR_GID)) flags |= MAY_CHOWN;
-		if (ia_valid & ATTR_MODE) flags |= MAY_CHMOD;
-		if (MayModifyNode(dentry, flags) < 0) return -EPERM;
-		if (!error) error = inode_setattr(inode, attr);
+		if (ia_valid & (ATTR_UID | ATTR_GID))
+			flags |= MAY_CHOWN;
+		if (ia_valid & ATTR_MODE)
+			flags |= MAY_CHMOD;
+		if (MayModifyNode(dentry, flags) < 0)
+			return -EPERM;
+		if (!error)
+			error = inode_setattr(inode, attr);
 	}
 	return error;
 }
 
 static struct address_space_operations syaoran_aops = {
-	readpage:       syaoran_readpage,
-	writepage:      fail_writepage,
-	prepare_write:  syaoran_prepare_write,
-	commit_write:   syaoran_commit_write
+	.readpage      = syaoran_readpage,
+	.writepage     = fail_writepage,
+	.prepare_write = syaoran_prepare_write,
+	.commit_write  = syaoran_commit_write,
 };
 
 static struct file_operations syaoran_file_operations = {
-	read:       generic_file_read,
-	write:      generic_file_write,
-	mmap:       generic_file_mmap,
-	fsync:      syaoran_sync_file,
+	.read  = generic_file_read,
+	.write = generic_file_write,
+	.mmap  = generic_file_mmap,
+	.fsync = syaoran_sync_file,
 };
 
 static struct inode_operations syaoran_dir_inode_operations = {
-	create:     syaoran_create,
-	lookup:     syaoran_lookup,
-	link:       syaoran_link,
-	unlink:     syaoran_unlink,
-	symlink:    syaoran_symlink,
-	mkdir:      syaoran_mkdir,
-	rmdir:      syaoran_rmdir,
-	mknod:      syaoran_mknod,
-	rename:     syaoran_rename,
-	setattr:    syaoran_setattr,
+	.create  = syaoran_create,
+	.lookup  = syaoran_lookup,
+	.link    = syaoran_link,
+	.unlink  = syaoran_unlink,
+	.symlink = syaoran_symlink,
+	.mkdir   = syaoran_mkdir,
+	.rmdir   = syaoran_rmdir,
+	.mknod   = syaoran_mknod,
+	.rename  = syaoran_rename,
+	.setattr = syaoran_setattr,
 };
 
 static struct inode_operations syaoran_symlink_inode_operations = {
-	readlink:    page_readlink,
-	follow_link: page_follow_link,
-	setattr:     syaoran_setattr,
+	.readlink    = page_readlink,
+	.follow_link = page_follow_link,
+	.setattr     = syaoran_setattr,
 };
 
 static struct inode_operations syaoran_file_inode_operations = {
-	setattr: syaoran_setattr,
+	.setattr = syaoran_setattr,
 };
 
 static struct super_operations syaoran_ops = {
-	statfs:     syaoran_statfs,
-	put_inode:  force_delete,
-	put_super:  syaoran_put_super,
+	.statfs    = syaoran_statfs,
+	.put_inode = force_delete,
+	.put_super = syaoran_put_super,
 };
 
-static struct super_block *syaoran_read_super(struct super_block * sb, void * data, int silent)
+static struct super_block *syaoran_read_super(struct super_block *sb, void *data, int silent)
 {
-	struct inode * inode;
-	struct dentry * root;
+	struct inode *inode;
+	struct dentry *root;
 
 	sb->s_blocksize = PAGE_CACHE_SIZE;
 	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
 	sb->s_magic = SYAORAN_MAGIC;
 	sb->s_op = &syaoran_ops;
-	if (Syaoran_Initialize(sb, data) < 0) return NULL;
+	if (Syaoran_Initialize(sb, data) < 0)
+		return NULL;
 	inode = syaoran_get_inode(sb, S_IFDIR | 0755, 0);
 	if (!inode)
 		return NULL;
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(working copy)
@@ -88,29 +88,35 @@
 void SetDomainFlag(struct domain_info *domain, const bool is_delete, const u8 flags)
 {
 	mutex_lock(&new_domain_assign_lock);
-	if (!is_delete) domain->flags |= flags;
-	else domain->flags &= ~flags;
+	if (!is_delete)
+		domain->flags |= flags;
+	else
+		domain->flags &= ~flags;
 	mutex_unlock(&new_domain_assign_lock);
 }
 
 const char *GetLastName(const struct domain_info *domain)
 {
-	const char *cp0 = domain->domainname->name, *cp1;
-	if ((cp1 = strrchr(cp0, ' ')) != NULL) return cp1 + 1;
+	const char *cp0 = domain->domainname->name, *cp1 = strrchr(cp0, ' ');
+	if (cp1)
+		return cp1 + 1;
 	return cp0;
 }
 
 int AddDomainACL(struct domain_info *domain, struct acl_info *acl)
 {
-	if (domain) list1_add_tail_mb(&acl->list, &domain->acl_info_list);
-	else acl->type &= ~ACL_DELETED;
+	if (domain)
+		list1_add_tail_mb(&acl->list, &domain->acl_info_list);
+	else
+		acl->type &= ~ACL_DELETED;
 	UpdateCounter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 	return 0;
 }
 
 int DelDomainACL(struct acl_info *acl)
 {
-	if (acl) acl->type |= ACL_DELETED;
+	if (acl)
+		acl->type |= ACL_DELETED;
 	UpdateCounter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 	return 0;
 }
@@ -126,16 +132,21 @@
 	const struct path_info *saved_program, *saved_domainname = NULL;
 	int error = -ENOMEM;
 	bool is_last_name = false;
-	if (!IsCorrectPath(program, 1, -1, -1, __FUNCTION__)) return -EINVAL; /* No patterns allowed. */
+	if (!IsCorrectPath(program, 1, -1, -1, __func__))
+		return -EINVAL; /* No patterns allowed. */
 	if (domainname) {
-		if (!IsDomainDef(domainname) && IsCorrectPath(domainname, 1, -1, -1, __FUNCTION__)) {
+		if (!IsDomainDef(domainname) && IsCorrectPath(domainname, 1, -1, -1, __func__)) {
 			is_last_name = true;
-		} else if (!IsCorrectDomain(domainname, __FUNCTION__)) {
+		} else if (!IsCorrectDomain(domainname, __func__)) {
 			return -EINVAL;
 		}
-		if ((saved_domainname = SaveName(domainname)) == NULL) return -ENOMEM;
+		saved_domainname = SaveName(domainname);
+		if (!saved_domainname)
+			return -ENOMEM;
 	}
-	if ((saved_program = SaveName(program)) == NULL) return -ENOMEM;
+	saved_program = SaveName(program);
+	if (!saved_program)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &domain_initializer_list, list) {
 		if (ptr->is_not == is_not && ptr->domainname == saved_domainname && ptr->program == saved_program) {
@@ -148,7 +159,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->domainname = saved_domainname;
 	new_entry->program = saved_program;
 	new_entry->is_not = is_not;
@@ -166,11 +179,14 @@
 	list1_for_each_cookie(pos, head->read_var2, &domain_initializer_list) {
 		struct domain_initializer_entry *ptr;
 		ptr = list1_entry(pos, struct domain_initializer_entry, list);
-		if (ptr->is_deleted) continue;
+		if (ptr->is_deleted)
+			continue;
 		if (ptr->domainname) {
-			if (io_printf(head, "%s" KEYWORD_INITIALIZE_DOMAIN "%s from %s\n", ptr->is_not ? "no_" : "", ptr->program->name, ptr->domainname->name)) return -ENOMEM;
+			if (io_printf(head, "%s" KEYWORD_INITIALIZE_DOMAIN "%s from %s\n", ptr->is_not ? "no_" : "", ptr->program->name, ptr->domainname->name))
+				return -ENOMEM;
 		} else {
-			if (io_printf(head, "%s" KEYWORD_INITIALIZE_DOMAIN "%s\n", ptr->is_not ? "no_" : "", ptr->program->name)) return -ENOMEM;
+			if (io_printf(head, "%s" KEYWORD_INITIALIZE_DOMAIN "%s\n", ptr->is_not ? "no_" : "", ptr->program->name))
+				return -ENOMEM;
 		}
 	}
 	return 0;
@@ -192,16 +208,21 @@
 	struct domain_initializer_entry *ptr;
 	bool flag = false;
 	list1_for_each_entry(ptr,  &domain_initializer_list, list) {
-		if (ptr->is_deleted) continue;
+		if (ptr->is_deleted)
+			continue;
 		if (ptr->domainname) {
 			if (!ptr->is_last_name) {
-				if (ptr->domainname != domainname) continue;
+				if (ptr->domainname != domainname)
+					continue;
 			} else {
-				if (pathcmp(ptr->domainname, last_name)) continue;
+				if (pathcmp(ptr->domainname, last_name))
+					continue;
 			}
 		}
-		if (pathcmp(ptr->program, program)) continue;
-		if (ptr->is_not) return false;
+		if (pathcmp(ptr->program, program))
+			continue;
+		if (ptr->is_not)
+			return false;
 		flag = true;
 	}
 	return flag;
@@ -218,16 +239,21 @@
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
 	bool is_last_name = false;
-	if (!IsDomainDef(domainname) && IsCorrectPath(domainname, 1, -1, -1, __FUNCTION__)) {
+	if (!IsDomainDef(domainname) && IsCorrectPath(domainname, 1, -1, -1, __func__)) {
 		is_last_name = true;
-	} else if (!IsCorrectDomain(domainname, __FUNCTION__)) {
+	} else if (!IsCorrectDomain(domainname, __func__)) {
 		return -EINVAL;
 	}
 	if (program) {
-		if (!IsCorrectPath(program, 1, -1, -1, __FUNCTION__)) return -EINVAL;
-		if ((saved_program = SaveName(program)) == NULL) return -ENOMEM;
+		if (!IsCorrectPath(program, 1, -1, -1, __func__))
+			return -EINVAL;
+		saved_program = SaveName(program);
+		if (!saved_program)
+			return -ENOMEM;
 	}
-	if ((saved_domainname = SaveName(domainname)) == NULL) return -ENOMEM;
+	saved_domainname = SaveName(domainname);
+	if (!saved_domainname)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &domain_keeper_list, list) {
 		if (ptr->is_not == is_not && ptr->domainname == saved_domainname && ptr->program == saved_program) {
@@ -240,7 +266,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->domainname = saved_domainname;
 	new_entry->program = saved_program;
 	new_entry->is_not = is_not;
@@ -269,11 +297,14 @@
 	list1_for_each_cookie(pos, head->read_var2, &domain_keeper_list) {
 		struct domain_keeper_entry *ptr;
 		ptr = list1_entry(pos, struct domain_keeper_entry, list);
-		if (ptr->is_deleted) continue;
+		if (ptr->is_deleted)
+			continue;
 		if (ptr->program) {
-			if (io_printf(head, "%s" KEYWORD_KEEP_DOMAIN "%s from %s\n", ptr->is_not ? "no_" : "", ptr->program->name, ptr->domainname->name)) return -ENOMEM;
+			if (io_printf(head, "%s" KEYWORD_KEEP_DOMAIN "%s from %s\n", ptr->is_not ? "no_" : "", ptr->program->name, ptr->domainname->name))
+				return -ENOMEM;
 		} else {
-			if (io_printf(head, "%s" KEYWORD_KEEP_DOMAIN "%s\n", ptr->is_not ? "no_" : "", ptr->domainname->name)) return -ENOMEM;
+			if (io_printf(head, "%s" KEYWORD_KEEP_DOMAIN "%s\n", ptr->is_not ? "no_" : "", ptr->domainname->name))
+				return -ENOMEM;
 		}
 	}
 	return 0;
@@ -284,14 +315,19 @@
 	struct domain_keeper_entry *ptr;
 	bool flag = false;
 	list1_for_each_entry(ptr, &domain_keeper_list, list) {
-		if (ptr->is_deleted) continue;
+		if (ptr->is_deleted)
+			continue;
 		if (!ptr->is_last_name) {
-			if (ptr->domainname != domainname) continue;
+			if (ptr->domainname != domainname)
+				continue;
 		} else {
-			if (pathcmp(ptr->domainname, last_name)) continue;
+			if (pathcmp(ptr->domainname, last_name))
+				continue;
 		}
-		if (ptr->program && pathcmp(ptr->program, program)) continue;
-		if (ptr->is_not) return false;
+		if (ptr->program && pathcmp(ptr->program, program))
+			continue;
+		if (ptr->is_not)
+			return false;
 		flag = true;
 	}
 	return flag;
@@ -307,8 +343,12 @@
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_original_name, *saved_aliased_name;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(original_name, 1, -1, -1, __FUNCTION__) || !IsCorrectPath(aliased_name, 1, -1, -1, __FUNCTION__)) return -EINVAL; /* No patterns allowed. */
-	if ((saved_original_name = SaveName(original_name)) == NULL || (saved_aliased_name = SaveName(aliased_name)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(original_name, 1, -1, -1, __func__) || !IsCorrectPath(aliased_name, 1, -1, -1, __func__))
+		return -EINVAL; /* No patterns allowed. */
+	saved_original_name = SaveName(original_name);
+	saved_aliased_name = SaveName(aliased_name);
+	if (!saved_original_name || !saved_aliased_name)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &alias_list, list) {
 		if (ptr->original_name == saved_original_name && ptr->aliased_name == saved_aliased_name) {
@@ -321,7 +361,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->original_name = saved_original_name;
 	new_entry->aliased_name = saved_aliased_name;
 	list1_add_tail_mb(&new_entry->list, &alias_list);
@@ -337,8 +379,10 @@
 	list1_for_each_cookie(pos, head->read_var2, &alias_list) {
 		struct alias_entry *ptr;
 		ptr = list1_entry(pos, struct alias_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALIAS "%s %s\n", ptr->original_name->name, ptr->aliased_name->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, KEYWORD_ALIAS "%s %s\n", ptr->original_name->name, ptr->aliased_name->name))
+			return -ENOMEM;
 	}
 	return 0;
 }
@@ -346,7 +390,8 @@
 int AddAliasPolicy(char *data, const bool is_delete)
 {
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
 	return AddAliasEntry(data, cp, is_delete);
 }
@@ -361,8 +406,12 @@
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_original_name, *saved_aggregated_name;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(original_name, 1, 0, -1, __FUNCTION__) || !IsCorrectPath(aggregated_name, 1, -1, -1, __FUNCTION__)) return -EINVAL;
-	if ((saved_original_name = SaveName(original_name)) == NULL || (saved_aggregated_name = SaveName(aggregated_name)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(original_name, 1, 0, -1, __func__) || !IsCorrectPath(aggregated_name, 1, -1, -1, __func__))
+		return -EINVAL;
+	saved_original_name = SaveName(original_name);
+	saved_aggregated_name = SaveName(aggregated_name);
+	if (!saved_original_name || !saved_aggregated_name)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &aggregator_list, list) {
 		if (ptr->original_name == saved_original_name && ptr->aggregated_name == saved_aggregated_name) {
@@ -375,7 +424,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->original_name = saved_original_name;
 	new_entry->aggregated_name = saved_aggregated_name;
 	list1_add_tail_mb(&new_entry->list, &aggregator_list);
@@ -391,8 +442,10 @@
 	list1_for_each_cookie(pos, head->read_var2, &aggregator_list) {
 		struct aggregator_entry *ptr;
 		ptr = list1_entry(pos, struct aggregator_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_AGGREGATOR "%s %s\n", ptr->original_name->name, ptr->aggregated_name->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, KEYWORD_AGGREGATOR "%s %s\n", ptr->original_name->name, ptr->aggregated_name->name))
+			return -ENOMEM;
 	}
 	return 0;
 }
@@ -400,7 +453,8 @@
 int AddAggregatorPolicy(char *data, const bool is_delete)
 {
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
 	return AddAggregatorEntry(data, cp, is_delete);
 }
@@ -417,29 +471,33 @@
 	fill_path_info(&domainname);
 	mutex_lock(&new_domain_assign_lock);
 #ifdef DEBUG_DOMAIN_UNDELETE
-	printk("DeleteDomain %s\n", domainname0);
+	printk(KERN_DEBUG "DeleteDomain %s\n", domainname0);
 	list1_for_each_entry(domain, &domain_list, list) {
-		if (pathcmp(domain->domainname, &domainname)) continue;
-		printk("List: %p %u\n", domain, domain->is_deleted);
+		if (pathcmp(domain->domainname, &domainname))
+			continue;
+		printk(KERN_DEBUG "List: %p %u\n", domain, domain->is_deleted);
 	}
 #endif
 	/* Is there an active domain? */
 	list1_for_each_entry(domain, &domain_list, list) {
 		struct domain_info *domain2;
 		/* Never delete KERNEL_DOMAIN */
-		if (domain == &KERNEL_DOMAIN || domain->is_deleted || pathcmp(domain->domainname, &domainname)) continue;
+		if (domain == &KERNEL_DOMAIN || domain->is_deleted || pathcmp(domain->domainname, &domainname))
+			continue;
 		/* Mark already deleted domains as non undeletable. */
 		list1_for_each_entry(domain2, &domain_list, list) {
-			if (!domain2->is_deleted || pathcmp(domain2->domainname, &domainname)) continue;
+			if (!domain2->is_deleted || pathcmp(domain2->domainname, &domainname))
+				continue;
 #ifdef DEBUG_DOMAIN_UNDELETE
-			if (domain2->is_deleted != 255) printk("Marked %p as non undeletable\n", domain2);
+			if (domain2->is_deleted != 255)
+				printk(KERN_DEBUG "Marked %p as non undeletable\n", domain2);
 #endif
 			domain2->is_deleted = 255;
 		}
 		/* Delete and mark active domain as undeletable. */
 		domain->is_deleted = 1;
 #ifdef DEBUG_DOMAIN_UNDELETE
-		printk("Marked %p as undeletable\n", domain);
+		printk(KERN_DEBUG "Marked %p as undeletable\n", domain);
 #endif
 		break;
 	}
@@ -455,29 +513,32 @@
 	fill_path_info(&domainname);
 	mutex_lock(&new_domain_assign_lock);
 #ifdef DEBUG_DOMAIN_UNDELETE
-	printk("UndeleteDomain %s\n", domainname0);
+	printk(KERN_DEBUG "UndeleteDomain %s\n", domainname0);
 	list1_for_each_entry(domain, &domain_list, list) {
-		if (pathcmp(domain->domainname, &domainname)) continue;
-		printk("List: %p %u\n", domain, domain->is_deleted);
+		if (pathcmp(domain->domainname, &domainname))
+			continue;
+		printk(KERN_DEBUG "List: %p %u\n", domain, domain->is_deleted);
 	}
 #endif
 	list1_for_each_entry(domain, &domain_list, list) {
-		if (pathcmp(&domainname, domain->domainname)) continue;
+		if (pathcmp(&domainname, domain->domainname))
+			continue;
 		if (!domain->is_deleted) {
 			/* This domain is active. I can't undelete. */
 			candidate_domain = NULL;
 #ifdef DEBUG_DOMAIN_UNDELETE
-			printk("%p is active. I can't undelete.\n", domain);
+			printk(KERN_DEBUG "%p is active. I can't undelete.\n", domain);
 #endif
 			break;
 		}
 		/* Is this domain undeletable? */
-		if (domain->is_deleted == 1) candidate_domain = domain;
+		if (domain->is_deleted == 1)
+			candidate_domain = domain;
 	}
 	if (candidate_domain) {
 		candidate_domain->is_deleted = 0;
 #ifdef DEBUG_DOMAIN_UNDELETE
-		printk("%p was undeleted.\n", candidate_domain);
+		printk(KERN_DEBUG "%p was undeleted.\n", candidate_domain);
 #endif
 	}
 	mutex_unlock(&new_domain_assign_lock);
@@ -491,26 +552,36 @@
 	struct domain_info *domain = NULL;
 	const struct path_info *saved_domainname;
 	mutex_lock(&new_domain_assign_lock);
-	if ((domain = FindDomain(domainname)) != NULL) goto out;
-	if (!IsCorrectDomain(domainname, __FUNCTION__)) goto out;
-	if ((saved_domainname = SaveName(domainname)) == NULL) goto out;
+	domain = FindDomain(domainname);
+	if (domain)
+		goto out;
+	if (!IsCorrectDomain(domainname, __func__))
+		goto out;
+	saved_domainname = SaveName(domainname);
+	if (!saved_domainname)
+		goto out;
 	/* Can I reuse memory of deleted domain? */
 	list1_for_each_entry(domain, &domain_list, list) {
 		struct task_struct *p;
 		struct acl_info *ptr;
 		bool flag;
-		if (!domain->is_deleted || domain->domainname != saved_domainname) continue;
+		if (!domain->is_deleted || domain->domainname != saved_domainname)
+			continue;
 		flag = false;
 		/***** CRITICAL SECTION START *****/
 		read_lock(&tasklist_lock);
 		for_each_process(p) {
-			if (p->domain_info == domain) { flag = true; break; }
+			if (p->domain_info == domain) {
+				flag = true;
+				break;
+			}
 		}
 		read_unlock(&tasklist_lock);
 		/***** CRITICAL SECTION END *****/
-		if (flag) continue;
+		if (flag)
+			continue;
 #ifdef DEBUG_DOMAIN_UNDELETE
-		printk("Reusing %p %s\n", domain, domain->domainname->name);
+		printk(KERN_DEBUG "Reusing %p %s\n", domain, domain->domainname->name);
 #endif
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 			ptr->type |= ACL_DELETED;
@@ -523,7 +594,8 @@
 		goto out;
 	}
 	/* No memory reusable. Create using new memory. */
-	if ((domain = alloc_element(sizeof(*domain))) != NULL) {
+	domain = alloc_element(sizeof(*domain));
+	if (domain) {
 		INIT_LIST1_HEAD(&domain->acl_info_list);
 		domain->domainname = saved_domainname;
 		domain->profile = profile;
@@ -541,12 +613,14 @@
 	unsigned long pos = bprm->p;
 	int i = pos / PAGE_SIZE, offset = pos % PAGE_SIZE;
 	bool done = false;
-	if (!bprm->argc) goto out;
+	if (!bprm->argc)
+		goto out;
 	while (1) {
 		struct page *page;
 		const char *kaddr;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
-		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0) goto out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
+		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0)
+			goto out;
 		pos += PAGE_SIZE - offset;
 #else
 		page = bprm->page[i];
@@ -554,7 +628,7 @@
 		/* Map. */
 		kaddr = kmap(page);
 		if (!kaddr) { /* Mapping failed. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 			put_page(page);
 #endif
 			goto out;
@@ -584,12 +658,13 @@
 		}
 		/* Unmap. */
 		kunmap(page);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 		put_page(page);
 #endif
 		i++;
 		offset = 0;
-		if (done) break;
+		if (done)
+			break;
 	}
 	return true;
  out:
@@ -622,16 +697,23 @@
 
 	/* Get realpath of program. */
 	retval = -ENOENT; /* I hope realpath() won't fail with -ENOMEM. */
-	if ((real_program_name = realpath(original_name)) == NULL) goto out;
+	real_program_name = realpath(original_name);
+	if (!real_program_name)
+		goto out;
 	/* Get realpath of symbolic link. */
-	if ((symlink_program_name = realpath_nofollow(original_name)) == NULL) goto out;
+	symlink_program_name = realpath_nofollow(original_name);
+	if (!symlink_program_name)
+		goto out;
 
 	r.name = real_program_name;
 	fill_path_info(&r);
 	s.name = symlink_program_name;
 	fill_path_info(&s);
-	if ((l.name = strrchr(old_domain_name, ' ')) != NULL) l.name++;
-	else l.name = old_domain_name;
+	l.name = strrchr(old_domain_name, ' ');
+	if (l.name)
+		l.name++;
+	else
+		l.name = old_domain_name;
 	fill_path_info(&l);
 
 	if (path_to_verify) {
@@ -639,7 +721,7 @@
 			static u8 counter = 20;
 			if (counter) {
 				counter--;
-				printk("Failed to verify: %s\n", path_to_verify->name);
+				printk(KERN_WARNING "Failed to verify: %s\n", path_to_verify->name);
 			}
 			goto out;
 		}
@@ -651,7 +733,8 @@
 		struct alias_entry *ptr;
 		/* Is this program allowed to be called via symbolic links? */
 		list1_for_each_entry(ptr, &alias_list, list) {
-			if (ptr->is_deleted || pathcmp(&r, ptr->original_name) || pathcmp(&s, ptr->aliased_name)) continue;
+			if (ptr->is_deleted || pathcmp(&r, ptr->original_name) || pathcmp(&s, ptr->aliased_name))
+				continue;
 			memset(real_program_name, 0, CCS_MAX_PATHNAME_LEN);
 			strncpy(real_program_name, ptr->aliased_name->name, CCS_MAX_PATHNAME_LEN - 1);
 			fill_path_info(&r);
@@ -664,11 +747,17 @@
 		char *base_argv0 = tmp->buffer;
 		const char *base_filename;
 		retval = -ENOMEM;
-		if (!get_argv0(bprm, tmp)) goto out;
-		if ((base_filename = strrchr(real_program_name, '/')) == NULL) base_filename = real_program_name; else base_filename++;
+		if (!get_argv0(bprm, tmp))
+			goto out;
+		base_filename = strrchr(real_program_name, '/');
+		if (!base_filename)
+			base_filename = real_program_name;
+		else
+			base_filename++;
 		if (strcmp(base_argv0, base_filename)) {
 			retval = CheckArgv0Perm(&r, base_argv0);
-			if (retval) goto out;
+			if (retval)
+				goto out;
 		}
 	}
 
@@ -677,7 +766,8 @@
 		struct aggregator_entry *ptr;
 		/* Is this program allowed to be aggregated? */
 		list1_for_each_entry(ptr, &aggregator_list, list) {
-			if (ptr->is_deleted || !PathMatchesToPattern(&r, ptr->original_name)) continue;
+			if (ptr->is_deleted || !PathMatchesToPattern(&r, ptr->original_name))
+				continue;
 			memset(real_program_name, 0, CCS_MAX_PATHNAME_LEN);
 			strncpy(real_program_name, ptr->aggregated_name->name, CCS_MAX_PATHNAME_LEN - 1);
 			fill_path_info(&r);
@@ -686,7 +776,9 @@
 	}
 
 	/* Check execute permission. */
-	if ((retval = CheckExecPerm(&r, bprm, tmp)) < 0) goto out;
+	retval = CheckExecPerm(&r, bprm, tmp);
+	if (retval < 0)
+		goto out;
 
  ok: ;
 	new_domain_name = tmp->buffer;
@@ -709,14 +801,16 @@
 	if (!domain && strlen(new_domain_name) < CCS_MAX_PATHNAME_LEN) {
 		if (is_enforce) {
 			domain = FindDomain(new_domain_name);
-			if (!domain) if (CheckSupervisor("#Need to create domain\n%s\n", new_domain_name) == 0) domain = FindOrAssignNewDomain(new_domain_name, current->domain_info->profile);
+			if (!domain && CheckSupervisor("#Need to create domain\n%s\n", new_domain_name) == 0)
+				domain = FindOrAssignNewDomain(new_domain_name, current->domain_info->profile);
 		} else {
 			domain = FindOrAssignNewDomain(new_domain_name, current->domain_info->profile);
 		}
 	}
 	if (!domain) {
-		printk("TOMOYO-ERROR: Domain '%s' not defined.\n", new_domain_name);
-		if (is_enforce) retval = -EPERM;
+		printk(KERN_WARNING "TOMOYO-ERROR: Domain '%s' not defined.\n", new_domain_name);
+		if (is_enforce)
+			retval = -EPERM;
 	} else {
 		retval = 0;
 	}
@@ -737,14 +831,16 @@
 	int i = pos / PAGE_SIZE, offset = pos % PAGE_SIZE;
 	int argv_count = bprm->argc;
 	int envp_count = bprm->envc;
-	//printk("start %d %d\n", argv_count, envp_count);
+	/* printk(KERN_DEBUG "start %d %d\n", argv_count, envp_count); */
 	int error = -ENOMEM;
-	if (!mode || !envp_count) return 0;
+	if (!mode || !envp_count)
+		return 0;
 	while (error == -ENOMEM) {
 		struct page *page;
 		const char *kaddr;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
-		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0) goto out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
+		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0)
+			goto out;
 		pos += PAGE_SIZE - offset;
 #else
 		page = bprm->page[i];
@@ -752,16 +848,18 @@
 		/* Map. */
 		kaddr = kmap(page);
 		if (!kaddr) { /* Mapping failed. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 			put_page(page);
 #endif
 			goto out;
 		}
 		/* Read. */
 		while (argv_count && offset < PAGE_SIZE) {
-			if (!kaddr[offset++]) argv_count--;
+			if (!kaddr[offset++])
+				argv_count--;
 		}
-		if (argv_count) goto unmap_page;
+		if (argv_count)
+			goto unmap_page;
 		while (offset < PAGE_SIZE) {
 			const unsigned char c = kaddr[offset++];
 			if (c && arg_len < CCS_MAX_PATHNAME_LEN - 10) {
@@ -781,7 +879,8 @@
 			} else {
 				arg_ptr[arg_len] = '\0';
 			}
-			if (c) continue;
+			if (c)
+				continue;
 			if (CheckEnvPerm(arg_ptr, profile, mode)) {
 				error = -EPERM;
 				break;
@@ -792,17 +891,18 @@
 			}
 			arg_len = 0;
 		}
-	unmap_page:
+unmap_page:
 		/* Unmap. */
 		kunmap(page);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 		put_page(page);
 #endif
 		i++;
 		offset = 0;
 	}
- out:
-	if (error && mode != 3) error = 0;
+out:
+	if (error && mode != 3)
+		error = 0;
 	return error;
 }
 
@@ -829,7 +929,7 @@
 	*dest = '\0';
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #include <linux/mount.h>
 #endif
@@ -842,14 +942,14 @@
 	int depth = 0;
 	struct dentry *dentry;
 	struct vfsmount *vfsmnt;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 	struct path root;
 #else
 	struct dentry *dentry0;
 	struct vfsmount *vfsmnt0;
 #endif
 	read_lock(&current->fs->lock);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 	root = current->fs->root;
 	path_get(&current->fs->root);
 	dentry = root.dentry;
@@ -861,13 +961,14 @@
 	read_unlock(&current->fs->lock);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&dcache_lock);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 	spin_lock(&vfsmount_lock);
 #endif
 	for (;;) {
 		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
 			/* Global root? */
-			if (vfsmnt->mnt_parent == vfsmnt) break;
+			if (vfsmnt->mnt_parent == vfsmnt)
+				break;
 			dentry = vfsmnt->mnt_mountpoint;
 			vfsmnt = vfsmnt->mnt_parent;
 			continue;
@@ -875,12 +976,12 @@
 		dentry = dentry->d_parent;
 		depth++;
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 	spin_unlock(&vfsmount_lock);
 #endif
 	spin_unlock(&dcache_lock);
 	/***** CRITICAL SECTION END *****/
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 	path_put(&root);
 #else
 	dput(dentry0);
@@ -936,7 +1037,8 @@
 	/* Allocate memory for execute handler's pathname. */
 	char *execute_handler = ccs_alloc(sizeof(struct ccs_page_buffer));
 	*work = execute_handler;
-	if (!execute_handler) return -ENOMEM;
+	if (!execute_handler)
+		return -ENOMEM;
 	strncpy(execute_handler, filename->name, sizeof(struct ccs_page_buffer) - 1);
 	UnEscape(execute_handler);
 
@@ -948,10 +1050,12 @@
 	{ /* Adjust root directory for open_exec(). */
 		int depth = GetRootDepth();
 		char *cp = execute_handler;
-		if (!*cp || *cp != '/') return -ENOENT;
+		if (!*cp || *cp != '/')
+			return -ENOENT;
 		while (depth) {
 			cp = strchr(cp + 1, '/');
-			if (!cp) return -ENOENT;
+			if (!cp)
+				return -ENOENT;
 			depth--;
 		}
 		memmove(execute_handler, cp, strlen(cp) + 1);
@@ -965,7 +1069,8 @@
 	{
 		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "%d", original_envc);
 		retval = copy_strings_kernel(1, &buffer, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
@@ -973,14 +1078,16 @@
 	{
 		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "%d", original_argc);
 		retval = copy_strings_kernel(1, &buffer, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
 	/* Set argv[4] */
 	{
 		retval = copy_strings_kernel(1, &bprm->filename, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
@@ -989,7 +1096,8 @@
 		const u32 tomoyo_flags = task->tomoyo_flags;
 		snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "pid=%d uid=%d gid=%d euid=%d egid=%d suid=%d sgid=%d fsuid=%d fsgid=%d state[0]=%u state[1]=%u state[2]=%u", task->pid, task->uid, task->gid, task->euid, task->egid, task->suid, task->sgid, task->fsuid, task->fsgid, (u8) (tomoyo_flags >> 24), (u8) (tomoyo_flags >> 16), (u8) (tomoyo_flags >> 8));
 		retval = copy_strings_kernel(1, &buffer, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
@@ -1003,7 +1111,8 @@
 			snprintf(buffer, sizeof(struct ccs_page_buffer) - 1, "<unknown>");
 			retval = copy_strings_kernel(1, &buffer, bprm);
 		}
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
@@ -1011,17 +1120,19 @@
 	{
 		strncpy(buffer, task->domain_info->domainname->name, sizeof(struct ccs_page_buffer) - 1);
 		retval = copy_strings_kernel(1, &buffer, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
 
 	/* Set argv[0] */
 	{
 		retval = copy_strings_kernel(1, &execute_handler, bprm);
-		if (retval < 0) goto out;
+		if (retval < 0)
+			goto out;
 		bprm->argc++;
 	}
-#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,23) || LINUX_VERSION_CODE == KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 23) || LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 24)
 	bprm->argv_len = bprm->exec - bprm->p;
 #endif
 
@@ -1031,13 +1142,14 @@
 		retval = PTR_ERR(filp);
 		goto out;
 	}
-	bprm->file= filp;
+	bprm->file = filp;
 	bprm->filename = execute_handler;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 	bprm->interp = execute_handler;
 #endif
 	retval = prepare_binprm(bprm);
-	if (retval < 0) goto out;
+	if (retval < 0)
+		goto out;
 	task->tomoyo_flags |= CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
 	retval = FindNextDomain(bprm, next_domain, filename, tmp);
 	task->tomoyo_flags &= ~CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
@@ -1052,7 +1164,8 @@
 	const u8 type = is_preferred_handler ? TYPE_PREFERRED_EXECUTE_HANDLER : TYPE_DEFAULT_EXECUTE_HANDLER;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct execute_handler_record *acl;
-		if (ptr->type != type) continue;
+		if (ptr->type != type)
+			continue;
 		acl = container_of(ptr, struct execute_handler_record, head);
 		return acl->handler;
 	}
@@ -1068,24 +1181,32 @@
 	char *work = NULL; /* Keep valid until search_binary_handler() finishes. */
 	struct ccs_page_buffer *buf = ccs_alloc(sizeof(struct ccs_page_buffer));
 	CCS_LoadPolicy(bprm->filename);
-	if (!buf) return -ENOMEM;
-	//printk("rootdepth=%d\n", GetRootDepth());
+	if (!buf)
+		return -ENOMEM;
+	/* printk(KERN_DEBUG "rootdepth=%d\n", GetRootDepth()); */
 	handler = FindExecuteHandler(true);
 	if (handler) {
 		retval = try_alt_exec(bprm, handler, &work, &next_domain, buf);
-	} else if ((retval = FindNextDomain(bprm, &next_domain, NULL, buf)) == -EPERM) {
-		handler = FindExecuteHandler(false);
-		if (handler) retval = try_alt_exec(bprm, handler, &work, &next_domain, buf);
+	} else {
+		retval = FindNextDomain(bprm, &next_domain, NULL, buf);
+		if (retval == -EPERM) {
+			handler = FindExecuteHandler(false);
+			if (handler)
+				retval = try_alt_exec(bprm, handler, &work, &next_domain, buf);
+		}
 	}
-	if (retval) goto out;
+	if (retval)
+		goto out;
 	task->domain_info = next_domain;
 	retval = CheckEnviron(bprm, buf);
-	if (retval) goto out;
+	if (retval)
+		goto out;
 	task->tomoyo_flags |= TOMOYO_CHECK_READ_FOR_OPEN_EXEC;
 	retval = search_binary_handler(bprm, regs);
 	task->tomoyo_flags &= ~TOMOYO_CHECK_READ_FOR_OPEN_EXEC;
  out:
-	if (retval < 0) task->domain_info = prev_domain;
+	if (retval < 0)
+		task->domain_info = prev_domain;
 	ccs_free(work);
 	ccs_free(buf);
 	return retval;
Index: trunk/1.6.x/ccs-patch/fs/sakura_maymount.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_maymount.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/sakura_maymount.c	(working copy)
@@ -16,13 +16,13 @@
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
 #include <linux/mount.h>
 #include <linux/mnt_namespace.h>
 #else
 #include <linux/namespace.h>
 #endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #endif
 
@@ -32,14 +32,15 @@
 {
 	bool flag = false;
 	const u8 mode = CheckCCSFlags(CCS_SAKURA_DENY_CONCEAL_MOUNT);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 	struct namespace *namespace = current->namespace;
-#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
 	struct namespace *namespace = current->nsproxy->namespace;
 #else
 	struct mnt_namespace *namespace = current->nsproxy->mnt_ns;
 #endif
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	if (namespace) {
 		struct list_head *p;
 		list_for_each(p, &namespace->list) {
@@ -48,7 +49,7 @@
 			spin_lock(&dcache_lock);
 			if (IS_ROOT(dentry) || !d_unhashed(dentry)) {
 				while (1) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 					if (nd->path.mnt->mnt_root == vfsmnt->mnt_root && nd->path.dentry == dentry) {
 						flag = true;
 						break;
@@ -60,18 +61,18 @@
 					}
 #endif
 					if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 						spin_lock(&vfsmount_lock);
 #endif
 						if (vfsmnt->mnt_parent == vfsmnt) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 							spin_unlock(&vfsmount_lock);
 #endif
 							break;
 						}
 						dentry = vfsmnt->mnt_mountpoint;
 						vfsmnt = vfsmnt->mnt_parent;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 						spin_unlock(&vfsmount_lock);
 #endif
 						continue;
@@ -80,13 +81,14 @@
 				}
 			}
 			spin_unlock(&dcache_lock);
-			if (flag) break;
+			if (flag)
+				break;
 		}
 	}
 	if (flag) {
 		int error = -EPERM;
 		const bool is_enforce = (mode == 3);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 		const char *dir = realpath_from_dentry(nd->path.dentry, nd->path.mnt);
 #else
 		const char *dir = realpath_from_dentry(nd->dentry, nd->mnt);
@@ -94,11 +96,13 @@
 		if (dir) {
 			const char *exename = GetEXE();
 			printk("SAKURA-%s: mount %s (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), dir, current->pid, exename);
-			if (is_enforce && CheckSupervisor("# %s is requesting\nmount on %s\n", exename, dir) == 0) error = 0;
+			if (is_enforce && CheckSupervisor("# %s is requesting\nmount on %s\n", exename, dir) == 0)
+				error = 0;
 			ccs_free(exename);
 		}
 		ccs_free(dir);
-		if (is_enforce) return error;
+		if (is_enforce)
+			return error;
 	}
 	return 0;
 }
Index: trunk/1.6.x/ccs-patch/fs/ccs_common.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/ccs_common.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/ccs_common.c	(working copy)
@@ -21,7 +21,7 @@
 #include <asm/uaccess.h>
 #include <stdarg.h>
 #include <linux/version.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namei.h>
 #include <linux/mount.h>
 static const int lookup_flags = LOOKUP_FOLLOW;
@@ -32,7 +32,7 @@
 #include <linux/ccs_common.h>
 #include <linux/ccs_proc.h>
 #include <linux/tomoyo.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 #define find_task_by_pid find_task_by_vpid
 #endif
 
@@ -146,6 +146,13 @@
 __setup("TOMOYO_QUIET", TOMOYO_Quiet_Setup);
 #endif
 
+static bool is_byte_range(const char *str)
+{
+	return *str >= '0' && *str++ <= '3' &&
+		*str >= '0' && *str++ <= '7' &&
+		*str >= '0' && *str <= '7';
+}
+
 /*
  * Format string.
  * Leading and trailing whitespaces are removed.
@@ -155,12 +162,16 @@
 {
 	unsigned char *sp = buffer, *dp = buffer;
 	bool first = true;
-	while (*sp && (*sp <= ' ' || *sp >= 127)) sp++;
+	while (*sp && (*sp <= ' ' || *sp >= 127))
+		sp++;
 	while (*sp) {
-		if (!first) *dp++ = ' ';
+		if (!first)
+			*dp++ = ' ';
 		first = false;
-		while (*sp > ' ' && *sp < 127) *dp++ = *sp++;
-		while (*sp && (*sp <= ' ' || *sp >= 127)) sp++;
+		while (*sp > ' ' && *sp < 127)
+			*dp++ = *sp++;
+		while (*sp && (*sp <= ' ' || *sp >= 127))
+			sp++;
 	}
 	*dp = '\0';
 }
@@ -172,20 +183,26 @@
 bool IsCorrectPath(const char *filename, const s8 start_type, const s8 pattern_type, const s8 end_type, const char *function)
 {
 	bool contains_pattern = false;
-	char c, d, e;
+	unsigned char c, d, e;
 	const char *original_filename = filename;
-	if (!filename) goto out;
+	if (!filename)
+		goto out;
 	c = *filename;
 	if (start_type == 1) { /* Must start with '/' */
-		if (c != '/') goto out;
+		if (c != '/')
+			goto out;
 	} else if (start_type == -1) { /* Must not start with '/' */
-		if (c == '/') goto out;
+		if (c == '/')
+			goto out;
 	}
-	if (c) c = * (strchr(filename, '\0') - 1);
+	if (c)
+		c = *(strchr(filename, '\0') - 1);
 	if (end_type == 1) { /* Must end with '/' */
-		if (c != '/') goto out;
+		if (c != '/')
+			goto out;
 	} else if (end_type == -1) { /* Must not end with '/' */
-		if (c == '/') goto out;
+		if (c == '/')
+			goto out;
 	}
 	while ((c = *filename++) != '\0') {
 		if (c == '\\') {
@@ -202,20 +219,25 @@
 			case 'a':   /* "\a" */
 			case 'A':   /* "\A" */
 			case '-':   /* "\-" */
-				if (pattern_type == -1) break; /* Must not contain pattern */
+				if (pattern_type == -1)
+					break; /* Must not contain pattern */
 				contains_pattern = true;
 				continue;
 			case '0':   /* "\ooo" */
 			case '1':
 			case '2':
 			case '3':
-				if ((d = *filename++) >= '0' && d <= '7' && (e = *filename++) >= '0' && e <= '7') {
-					const unsigned char f =
-						(((unsigned char) (c - '0')) << 6) +
-						(((unsigned char) (d - '0')) << 3) +
-						(((unsigned char) (e - '0')));
-					if (f && (f <= ' ' || f >= 127)) continue; /* pattern is not \000 */
-				}
+				d = *filename++;
+				if (d < '0' || d > '7')
+					break;
+				e = *filename++;
+				if (e < '0' || e > '7')
+					break;
+				c = (((unsigned char) (c - '0')) << 6)
+					+ (((unsigned char) (d - '0')) << 3)
+					+ (((unsigned char) (e - '0')));
+				if (c && (c <= ' ' || c >= 127))
+					continue; /* pattern is not \000 */
 			}
 			goto out;
 		} else if (c <= ' ' || c >= 127) {
@@ -223,7 +245,8 @@
 		}
 	}
 	if (pattern_type == 1) { /* Must contain pattern */
-		if (!contains_pattern) goto out;
+		if (!contains_pattern)
+			goto out;
 	}
 	return true;
  out:
@@ -239,29 +262,38 @@
 {
 	unsigned char c, d, e;
 	const char *org_domainname = domainname;
-	if (!domainname || strncmp(domainname, ROOT_NAME, ROOT_NAME_LEN)) goto out;
+	if (!domainname || strncmp(domainname, ROOT_NAME, ROOT_NAME_LEN))
+		goto out;
 	domainname += ROOT_NAME_LEN;
-	if (!*domainname) return true;
+	if (!*domainname)
+		return true;
 	do {
-		if (*domainname++ != ' ') goto out;
-		if (*domainname++ != '/') goto out;
+		if (*domainname++ != ' ')
+			goto out;
+		if (*domainname++ != '/')
+			goto out;
 		while ((c = *domainname) != '\0' && c != ' ') {
 			domainname++;
 			if (c == '\\') {
-				switch ((c = *domainname++)) {
+				c = *domainname++;
+				switch ((c)) {
 				case '\\':  /* "\\" */
 					continue;
 				case '0':   /* "\ooo" */
 				case '1':
 				case '2':
 				case '3':
-					if ((d = *domainname++) >= '0' && d <= '7' && (e = *domainname++) >= '0' && e <= '7') {
-						const unsigned char f =
-							(((unsigned char) (c - '0')) << 6) +
-							(((unsigned char) (d - '0')) << 3) +
-							(((unsigned char) (e - '0')));
-						if (f && (f <= ' ' || f >= 127)) continue; /* pattern is not \000 */
-					}
+					d = *domainname++;
+					if (d < '0' || d > '7')
+						break;
+					e = *domainname++;
+					if (e < '0' || e > '7')
+						break;
+					c = (((unsigned char) (c - '0')) << 6)
+						+ (((unsigned char) (d - '0')) << 3)
+						+ (((unsigned char) (e - '0')));
+					if (c && (c <= ' ' || c >= 127))
+						continue; /* pattern is not \000 */
 				}
 				goto out;
 			} else if (c < ' ' || c >= 127) {
@@ -288,7 +320,8 @@
 	domainname.name = domainname0;
 	fill_path_info(&domainname);
 	list1_for_each_entry(domain, &domain_list, list) {
-		if (!domain->is_deleted && !pathcmp(&domainname, domain->domainname)) return domain;
+		if (!domain->is_deleted && !pathcmp(&domainname, domain->domainname))
+			return domain;
 	}
 	return NULL;
 }
@@ -299,8 +332,11 @@
 	if (pathname) {
 		char *ep = strchr(pathname, '\0');
 		if (pathname < ep--) {
-			if (*ep != '/') i++;
-			while (pathname <= ep) if (*ep-- == '/') i += 2;
+			if (*ep != '/')
+				i++;
+			while (pathname <= ep)
+				if (*ep-- == '/')
+					i += 2;
 		}
 	}
 	return i;
@@ -308,22 +344,34 @@
 
 static int const_part_length(const char *filename)
 {
+	char c;
 	int len = 0;
-	if (filename) {
-		char c;
-		while ((c = *filename++) != '\0') {
-			if (c != '\\') { len++; continue; }
-			switch (c = *filename++) {
-			case '\\':  /* "\\" */
-				len += 2; continue;
-			case '0':   /* "\ooo" */
-			case '1':
-			case '2':
-			case '3':
-				if ((c = *filename++) >= '0' && c <= '7' && (c = *filename++) >= '0' && c <= '7') { len += 4; continue; }
-			}
-			break;
+	if (!filename)
+		return 0;
+	while ((c = *filename++) != '\0') {
+		if (c != '\\') {
+			len++;
+			continue;
 		}
+		c = *filename++;
+		switch (c) {
+		case '\\':  /* "\\" */
+			len += 2;
+			continue;
+		case '0':   /* "\ooo" */
+		case '1':
+		case '2':
+		case '3':
+			c = *filename++;
+			if (c < '0' || c > '7')
+				break;
+			c = *filename++;
+			if (c < '0' || c > '7')
+				break;
+			len += 4;
+			continue;
+		}
+		break;
 	}
 	return len;
 }
@@ -344,7 +392,8 @@
 {
 	while (filename < filename_end && pattern < pattern_end) {
 		if (*pattern != '\\') {
-			if (*filename++ != *pattern++) return false;
+			if (*filename++ != *pattern++)
+				return false;
 		} else {
 			char c = *filename;
 			pattern++;
@@ -353,9 +402,9 @@
 				if (c == '/') {
 					return false;
 				} else if (c == '\\') {
-					if ((c = filename[1]) == '\\') {
+					if (filename[1] == '\\') {
 						filename++; /* safe because filename is \\ */
-					} else if (c >= '0' && c <= '3' && (c = filename[2]) >= '0' && c <= '7' && (c = filename[3]) >= '0' && c <= '7') {
+					} else if (is_byte_range(filename + 1)) {
 						filename += 3; /* safe because filename is \ooo */
 					} else {
 						return false;
@@ -363,25 +412,28 @@
 				}
 				break;
 			case '\\':
-				if (c != '\\') return false;
-				if (*++filename != '\\') return false; /* safe because *filename != '\0' */
+				if (c != '\\')
+					return false;
+				if (*++filename != '\\')
+					return false; /* safe because *filename != '\0' */
 				break;
 			case '+':
-				if (c < '0' || c > '9') return false;
+				if (c < '0' || c > '9')
+					return false;
 				break;
 			case 'x':
-				if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))) return false;
+				if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')))
+					return false;
 				break;
 			case 'a':
-				if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))) return false;
+				if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')))
+					return false;
 				break;
 			case '0':
 			case '1':
 			case '2':
 			case '3':
-				if (c == '\\' && (c = filename[1]) >= '0' && c <= '3' && c == *pattern
-					&& (c = filename[2]) >= '0' && c <= '7' && c == pattern[1]
-					&& (c = filename[3]) >= '0' && c <= '7' && c == pattern[2]) {
+				if (c == '\\' && is_byte_range(filename + 1) && strncmp(filename + 1, pattern, 3) == 0) {
 					filename += 3; /* safe because filename is \ooo */
 					pattern += 2; /* safe because pattern is \ooo  */
 					break;
@@ -392,12 +444,15 @@
 				{
 					int i;
 					for (i = 0; i <= filename_end - filename; i++) {
-						if (FileMatchesToPattern2(filename + i, filename_end, pattern + 1, pattern_end)) return true;
-						if ((c = filename[i]) == '.' && *pattern == '@') break;
+						if (FileMatchesToPattern2(filename + i, filename_end, pattern + 1, pattern_end))
+							return true;
+						c = filename[i];
+						if (c == '.' && *pattern == '@')
+							break;
 						if (c == '\\') {
-							if ((c = filename[i + 1]) == '\\') {
+							if (filename[i + 1] == '\\') {
 								i++; /* safe because filename is \\ */
-							} else if (c >= '0' && c <= '3' && (c = filename[i + 2]) >= '0' && c <= '7' && (c = filename[i + 3]) >= '0' && c <= '7') {
+							} else if (is_byte_range(filename + i + 1)) {
 								i += 3; /* safe because filename is \ooo */
 							} else {
 								break; /* Bad pattern. */
@@ -409,15 +464,20 @@
 			default:
 				{
 					int i, j = 0;
-					if ((c = *pattern) == '$') {
-						while ((c = filename[j]) >= '0' && c <= '9') j++;
+					c = *pattern;
+					if (c == '$') {
+						while ((c = filename[j]) >= '0' && c <= '9')
+							j++;
 					} else if (c == 'X') {
-						while (((c = filename[j]) >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f')) j++;
+						while (((c = filename[j]) >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))
+							j++;
 					} else if (c == 'A') {
-						while (((c = filename[j]) >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) j++;
+						while (((c = filename[j]) >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
+							j++;
 					}
 					for (i = 1; i <= j; i++) {
-						if (FileMatchesToPattern2(filename + i, filename_end, pattern + 1, pattern_end)) return true;
+						if (FileMatchesToPattern2(filename + i, filename_end, pattern + 1, pattern_end))
+							return true;
 					}
 				}
 				return false; /* Not matched or bad pattern. */
@@ -436,10 +496,13 @@
 	bool first = true;
 	bool result;
 	while (pattern < pattern_end - 1) {
-		if (*pattern++ != '\\' || *pattern++ != '-') continue;
+		if (*pattern++ != '\\' || *pattern++ != '-')
+			continue;
 		result = FileMatchesToPattern2(filename, filename_end, pattern_start, pattern - 2);
-		if (first) result = !result;
-		if (result) return false;
+		if (first)
+			result = !result;
+		if (result)
+			return false;
 		first = false;
 		pattern_start = pattern;
 	}
@@ -468,18 +531,28 @@
 
 bool PathMatchesToPattern(const struct path_info *pathname0, const struct path_info *pattern0)
 {
-	/* if (!pathname || !pattern) return false; */
+	/*
+	if (!pathname || !pattern)
+		return false;
+	*/
 	const char *pathname = pathname0->name, *pattern = pattern0->name;
 	const int len = pattern0->const_len;
-	if (!pattern0->is_patterned) return !pathcmp(pathname0, pattern0);
-	if (pathname0->depth != pattern0->depth) return false;
-	if (strncmp(pathname, pattern, len)) return false;
-	pathname += len; pattern += len;
+	if (!pattern0->is_patterned)
+		return !pathcmp(pathname0, pattern0);
+	if (pathname0->depth != pattern0->depth)
+		return false;
+	if (strncmp(pathname, pattern, len))
+		return false;
+	pathname += len;
+	pattern += len;
 	while (*pathname && *pattern) {
 		const char *pathname_delimiter = strchr(pathname, '/'), *pattern_delimiter = strchr(pattern, '/');
-		if (!pathname_delimiter) pathname_delimiter = strchr(pathname, '\0');
-		if (!pattern_delimiter) pattern_delimiter = strchr(pattern, '\0');
-		if (!FileMatchesToPattern(pathname, pathname_delimiter, pattern, pattern_delimiter)) return false;
+		if (!pathname_delimiter)
+			pathname_delimiter = strchr(pathname, '\0');
+		if (!pattern_delimiter)
+			pattern_delimiter = strchr(pattern, '\0');
+		if (!FileMatchesToPattern(pathname, pathname_delimiter, pattern, pattern_delimiter))
+			return false;
 		pathname = *pathname_delimiter ? pathname_delimiter + 1 : pathname_delimiter;
 		pattern = *pattern_delimiter ? pattern_delimiter + 1 : pattern_delimiter;
 	}
@@ -496,11 +569,13 @@
 {
 	va_list args;
 	int len, pos = head->read_avail, size = head->readbuf_size - pos;
-	if (size <= 0) return -ENOMEM;
+	if (size <= 0)
+		return -ENOMEM;
 	va_start(args, fmt);
 	len = vsnprintf(head->read_buf + pos, size, fmt, args);
 	va_end(args);
-	if (pos + len >= head->readbuf_size) return -ENOMEM;
+	if (pos + len >= head->readbuf_size)
+		return -ENOMEM;
 	head->read_avail += len;
 	return 0;
 }
@@ -514,7 +589,8 @@
 	struct mm_struct *mm = current->mm;
 	struct vm_area_struct *vma;
 	const char *cp = NULL;
-	if (!mm) return NULL;
+	if (!mm)
+		return NULL;
 	down_read(&mm->mmap_sem);
 	for (vma = mm->mmap; vma; vma = vma->vm_next) {
 		if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file) {
@@ -528,7 +604,10 @@
 
 const char *GetMSG(const bool is_enforce)
 {
-	if (is_enforce) return "ERROR"; else return "WARNING";
+	if (is_enforce)
+		return "ERROR";
+	else
+		return "WARNING";
 }
 
 /*************************  DOMAIN POLICY HANDLER  *************************/
@@ -546,21 +625,20 @@
 
 static bool sleep_check(void)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if (unlikely(in_interrupt()))
+	static u8 count = 20;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (likely(!in_interrupt()))
+		return true;
 #else
-	if (unlikely(in_atomic()))
+	if (likely(!in_atomic()))
+		return true;
 #endif
-	{
-		static u8 count = 20;
-		if (count) {
-			count--;
-			printk(KERN_ERR "BUG: sleeping function called from invalid context.\n");
-			dump_stack();
-		}
-		return false;
+	if (count) {
+		count--;
+		printk(KERN_ERR "BUG: sleeping function called from invalid context.\n");
+		dump_stack();
 	}
-	return true;
+	return false;
 }
 
 unsigned int CheckCCSFlags(const u8 index)
@@ -597,11 +675,14 @@
 {
 	unsigned int count = 0;
 	struct acl_info *ptr;
-	if (!domain) return true;
+	if (!domain)
+		return true;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-		if (!(ptr->type & ACL_DELETED)) count++;
+		if (!(ptr->type & ACL_DELETED))
+			count++;
 	}
-	if (count < CheckCCSFlags(CCS_TOMOYO_MAX_ACCEPT_ENTRY)) return true;
+	if (count < CheckCCSFlags(CCS_TOMOYO_MAX_ACCEPT_ENTRY))
+		return true;
 	if (!domain->quota_warned) {
 		domain->quota_warned = true;
 		printk("TOMOYO-WARNING: Domain '%s' has so many ACLs to hold. Stopped learning mode.\n", domain->domainname->name);
@@ -614,15 +695,21 @@
 	static DEFINE_MUTEX(profile_lock);
 	struct profile *ptr = NULL;
 	mutex_lock(&profile_lock);
-	if (profile < MAX_PROFILES && (ptr = profile_ptr[profile]) == NULL) {
-		if ((ptr = alloc_element(sizeof(*ptr))) != NULL) {
+	if (profile < MAX_PROFILES) {
+		ptr = profile_ptr[profile];
+		if (ptr)
+			goto ok;
+		ptr = alloc_element(sizeof(*ptr));
+		if (ptr) {
 			int i;
-			for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++) ptr->value[i] = ccs_control_array[i].current_value;
+			for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++)
+				ptr->value[i] = ccs_control_array[i].current_value;
 			/* Needn't to initialize "ptr->capability_value" because they are always 0. */
 			mb(); /* Avoid out-of-order execution. */
 			profile_ptr[profile] = ptr;
 		}
 	}
+ok:
 	mutex_unlock(&profile_lock);
 	return ptr;
 }
@@ -635,13 +722,16 @@
 	struct profile *profile;
 	i = simple_strtoul(data, &cp, 10);
 	if (data != cp) {
-		if (*cp != '-') return -EINVAL;
-		data= cp + 1;
+		if (*cp != '-')
+			return -EINVAL;
+		data = cp + 1;
 	}
 	profile = FindOrAssignNewProfile(i);
-	if (!profile) return -EINVAL;
+	if (!profile)
+		return -EINVAL;
 	cp = strchr(data, '=');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp = '\0';
 	UpdateCounter(CCS_UPDATES_COUNTER_PROFILE);
 	if (strcmp(data, ccs_control_array[CCS_PROFILE_COMMENT].keyword) == 0) {
@@ -652,16 +742,20 @@
 	if (strncmp(data, KEYWORD_MAC_FOR_CAPABILITY, KEYWORD_MAC_FOR_CAPABILITY_LEN) == 0) {
 		if (sscanf(cp + 1, "%u", &value) != 1) {
 			for (i = 0; i < 4; i++) {
-				if (strcmp(cp + 1, mode_4[i])) continue;
+				if (strcmp(cp + 1, mode_4[i]))
+					continue;
 				value = i;
 				break;
 			}
-			if (i == 4) return -EINVAL;
+			if (i == 4)
+				return -EINVAL;
 		}
-		if (value > 3) value = 3;
+		if (value > 3)
+			value = 3;
 		data += KEYWORD_MAC_FOR_CAPABILITY_LEN;
 		for (i = 0; i < TOMOYO_MAX_CAPABILITY_INDEX; i++) {
-			if (strcmp(data, capability_control_keyword[i])) continue;
+			if (strcmp(data, capability_control_keyword[i]))
+				continue;
 			profile->capability_value[i] = value;
 			return 0;
 		}
@@ -669,7 +763,8 @@
 	}
 #endif
 	for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++) {
-		if (strcmp(data, ccs_control_array[i].keyword)) continue;
+		if (strcmp(data, ccs_control_array[i].keyword))
+			continue;
 		if (sscanf(cp + 1, "%u", &value) != 1) {
 			int j;
 			const char **modes;
@@ -684,18 +779,21 @@
 				break;
 			}
 			for (j = 0; j < 4; j++) {
-				if (strcmp(cp + 1, modes[j])) continue;
+				if (strcmp(cp + 1, modes[j]))
+					continue;
 				value = j;
 				break;
 			}
-			if (j == 4) return -EINVAL;
+			if (j == 4)
+				return -EINVAL;
 		} else if (value > ccs_control_array[i].max_value) {
 			value = ccs_control_array[i].max_value;
 		}
 		switch (i) {
 		case CCS_SAKURA_DENY_CONCEAL_MOUNT:
 		case CCS_SAKURA_RESTRICT_UNMOUNT:
-			if (value == 1) value = 2; /* learning mode is not supported. */
+			if (value == 1)
+				value = 2; /* learning mode is not supported. */
 		}
 		profile->value[i] = value;
 		return 0;
@@ -706,12 +804,14 @@
 static int ReadProfile(struct io_buffer *head)
 {
 	int step;
-	if (head->read_eof) return 0;
+	if (head->read_eof)
+		return 0;
 	for (step = head->read_step; step < MAX_PROFILES * (CCS_MAX_CONTROL_INDEX + TOMOYO_MAX_CAPABILITY_INDEX); step++) {
 		const int i = step / (CCS_MAX_CONTROL_INDEX + TOMOYO_MAX_CAPABILITY_INDEX), j = step % (CCS_MAX_CONTROL_INDEX + TOMOYO_MAX_CAPABILITY_INDEX);
 		const struct profile *profile = profile_ptr[i];
 		head->read_step = step;
-		if (!profile) continue;
+		if (!profile)
+			continue;
 		switch (j) {
 		case -1: /* Dummy */
 #ifndef CONFIG_SAKURA
@@ -736,11 +836,13 @@
 			continue;
 		}
 		if (j == CCS_PROFILE_COMMENT) {
-			if (io_printf(head, "%u-%s=%s\n", i, ccs_control_array[CCS_PROFILE_COMMENT].keyword, profile->comment ? profile->comment->name : "")) break;
+			if (io_printf(head, "%u-%s=%s\n", i, ccs_control_array[CCS_PROFILE_COMMENT].keyword, profile->comment ? profile->comment->name : ""))
+				break;
 		} else if (j >= CCS_MAX_CONTROL_INDEX) {
 #ifdef CONFIG_TOMOYO
 			const int k = j - CCS_MAX_CONTROL_INDEX;
-			if (io_printf(head, "%u-" KEYWORD_MAC_FOR_CAPABILITY "%s=%s\n", i, capability_control_keyword[k], mode_4[profile->capability_value[k]])) break;
+			if (io_printf(head, "%u-" KEYWORD_MAC_FOR_CAPABILITY "%s=%s\n", i, capability_control_keyword[k], mode_4[profile->capability_value[k]]))
+				break;
 #endif
 		} else {
 			const unsigned int value = profile->value[j];
@@ -754,13 +856,16 @@
 				break;
 			}
 			if (modes) {
-				if (io_printf(head, "%u-%s=%s\n", i, ccs_control_array[j].keyword, modes[value])) break;
+				if (io_printf(head, "%u-%s=%s\n", i, ccs_control_array[j].keyword, modes[value]))
+					break;
 			} else {
-				if (io_printf(head, "%u-%s=%u\n", i, ccs_control_array[j].keyword, value)) break;
+				if (io_printf(head, "%u-%s=%u\n", i, ccs_control_array[j].keyword, value))
+					break;
 			}
 		}
 	}
-	if (step == MAX_PROFILES * (CCS_MAX_CONTROL_INDEX + TOMOYO_MAX_CAPABILITY_INDEX)) head->read_eof = true;
+	if (step == MAX_PROFILES * (CCS_MAX_CONTROL_INDEX + TOMOYO_MAX_CAPABILITY_INDEX))
+		head->read_eof = true;
 	return 0;
 }
 
@@ -783,12 +888,16 @@
 	int error = -ENOMEM;
 	bool is_domain = false;
 	if (IsDomainDef(manager)) {
-		if (!IsCorrectDomain(manager, __FUNCTION__)) return -EINVAL;
+		if (!IsCorrectDomain(manager, __func__))
+			return -EINVAL;
 		is_domain = true;
 	} else {
-		if (!IsCorrectPath(manager, 1, -1, -1, __FUNCTION__)) return -EINVAL;
+		if (!IsCorrectPath(manager, 1, -1, -1, __func__))
+			return -EINVAL;
 	}
-	if ((saved_manager = SaveName(manager)) == NULL) return -ENOMEM;
+	saved_manager = SaveName(manager);
+	if (!saved_manager)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &policy_manager_list, list) {
 		if (ptr->manager == saved_manager) {
@@ -801,14 +910,17 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->manager = saved_manager;
 	new_entry->is_domain = is_domain;
 	list1_add_tail_mb(&new_entry->list, &policy_manager_list);
 	error = 0;
  out:
 	mutex_unlock(&lock);
-	if (!error) UpdateCounter(CCS_UPDATES_COUNTER_MANAGER);
+	if (!error)
+		UpdateCounter(CCS_UPDATES_COUNTER_MANAGER);
 	return error;
 }
 
@@ -830,12 +942,15 @@
 static int ReadManagerPolicy(struct io_buffer *head)
 {
 	struct list1_head *pos;
-	if (head->read_eof) return 0;
+	if (head->read_eof)
+		return 0;
 	list1_for_each_cookie(pos, head->read_var2, &policy_manager_list) {
 		struct policy_manager_entry *ptr;
 		ptr = list1_entry(pos, struct policy_manager_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, "%s\n", ptr->manager->name)) return 0;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, "%s\n", ptr->manager->name))
+			return 0;
 	}
 	head->read_eof = true;
 	return 0;
@@ -849,12 +964,17 @@
 	const struct task_struct *task = current;
 	const struct path_info *domainname = task->domain_info->domainname;
 	bool found = false;
-	if (!sbin_init_started) return true;
-	if (!manage_by_non_root && (task->uid || task->euid)) return false;
+	if (!sbin_init_started)
+		return true;
+	if (!manage_by_non_root && (task->uid || task->euid))
+		return false;
 	list1_for_each_entry(ptr, &policy_manager_list, list) {
-		if (!ptr->is_deleted && ptr->is_domain && !pathcmp(domainname, ptr->manager)) return true;
+		if (!ptr->is_deleted && ptr->is_domain && !pathcmp(domainname, ptr->manager))
+			return true;
 	}
-	if ((exe = GetEXE()) == NULL) return false;
+	exe = GetEXE();
+	if (!exe)
+		return false;
 	list1_for_each_entry(ptr, &policy_manager_list, list) {
 		if (!ptr->is_deleted && !ptr->is_domain && !strcmp(exe, ptr->manager->name)) {
 			found = true;
@@ -862,7 +982,7 @@
 		}
 	}
 	if (!found) { /* Reduce error messages. */
-		static pid_t last_pid = 0;
+		static pid_t last_pid;
 		const pid_t pid = current->pid;
 		if (last_pid != pid) {
 			printk("%s ( %s ) is not permitted to update policies.\n", domainname->name, exe);
@@ -883,8 +1003,10 @@
 	if (cp) {
 		while ((cp2 = strstr(cp + 3, " if ")) != NULL) cp = cp2;
 		*cp++ = '\0';
-	} else if ((cp = strstr(data, " ; set ")) != NULL) {
-		*cp++ = '\0';
+	} else {
+		cp = strstr(data, " ; set ");
+		if (cp)
+			*cp++ = '\0';
 	}
 	return cp;
 }
@@ -922,10 +1044,12 @@
 		UpdateCounter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 		return 0;
 	}
-	if (!domain) return -EINVAL;
+	if (!domain)
+		return -EINVAL;
 
 	if (sscanf(data, KEYWORD_USE_PROFILE "%u", &profile) == 1 && profile < MAX_PROFILES) {
-		if (profile_ptr[profile] || !sbin_init_started) domain->profile = (u8) profile;
+		if (profile_ptr[profile] || !sbin_init_started)
+			domain->profile = (u8) profile;
 		return 0;
 	}
 	if (strcmp(data, KEYWORD_IGNORE_GLOBAL_ALLOW_READ) == 0) {
@@ -937,7 +1061,11 @@
 		return 0;
 	}
 	cp = FindConditionPart(data);
-	if (cp && (cond = FindOrAssignNewCondition(cp)) == NULL) return -EINVAL;
+	if (cp) {
+		cond = FindOrAssignNewCondition(cp);
+		if (!cond)
+			return -EINVAL;
+	}
 	if (strncmp(data, KEYWORD_ALLOW_CAPABILITY, KEYWORD_ALLOW_CAPABILITY_LEN) == 0) {
 		return AddCapabilityPolicy(data + KEYWORD_ALLOW_CAPABILITY_LEN, domain, cond, is_delete);
 	} else if (strncmp(data, KEYWORD_ALLOW_NETWORK, KEYWORD_ALLOW_NETWORK_LEN) == 0) {
@@ -962,14 +1090,19 @@
 	const u16 perm = ptr->perm;
 	for (bit = head->read_bit; bit < MAX_SINGLE_PATH_OPERATION; bit++) {
 		const char *msg;
-		if (!(perm & (1 << bit))) continue;
+		if (!(perm & (1 << bit)))
+			continue;
 		/* Print "read/write" instead of "read" and "write". */
-		if ((bit == TYPE_READ_ACL || bit == TYPE_WRITE_ACL) && (perm & (1 << TYPE_READ_WRITE_ACL))) continue;
+		if ((bit == TYPE_READ_ACL || bit == TYPE_WRITE_ACL) && (perm & (1 << TYPE_READ_WRITE_ACL)))
+			continue;
 		msg = sp_operation2keyword(bit);
 		pos = head->read_avail;
-		if (b && io_printf(head, "allow_%s @%s ", msg, ptr->u.group->group_name->name)) goto out;
-		if (!b && io_printf(head, "allow_%s %s ", msg, ptr->u.filename->name)) goto out;
-		if (DumpCondition(head, cond)) goto out;
+		if (b && io_printf(head, "allow_%s @%s ", msg, ptr->u.group->group_name->name))
+			goto out;
+		if (!b && io_printf(head, "allow_%s %s ", msg, ptr->u.filename->name))
+			goto out;
+		if (DumpCondition(head, cond))
+			goto out;
 	}
 	head->read_bit = 0;
 	return true;
@@ -987,15 +1120,22 @@
 	u8 bit;
 	for (bit = head->read_bit; bit < MAX_DOUBLE_PATH_OPERATION; bit++) {
 		const char *msg;
-		if (!(perm & (1 << bit))) continue;
+		if (!(perm & (1 << bit)))
+			continue;
 		msg = dp_operation2keyword(bit);
 		pos = head->read_avail;
-		if (io_printf(head, "allow_%s ", msg)) goto out;
-		if (b0 && io_printf(head, "@%s ", ptr->u1.group1->group_name->name)) goto out;
-		if (!b0 && io_printf(head, "%s ", ptr->u1.filename1->name)) goto out;
-		if (b1 && io_printf(head, "@%s", ptr->u2.group2->group_name->name)) goto out;
-		if (!b1 && io_printf(head, "%s", ptr->u2.filename2->name)) goto out;
-		if (DumpCondition(head, cond)) goto out;
+		if (io_printf(head, "allow_%s ", msg))
+			goto out;
+		if (b0 && io_printf(head, "@%s ", ptr->u1.group1->group_name->name))
+			goto out;
+		if (!b0 && io_printf(head, "%s ", ptr->u1.filename1->name))
+			goto out;
+		if (b1 && io_printf(head, "@%s", ptr->u2.group2->group_name->name))
+			goto out;
+		if (!b1 && io_printf(head, "%s", ptr->u2.filename2->name))
+			goto out;
+		if (DumpCondition(head, cond))
+			goto out;
 	}
 	head->read_bit = 0;
 	return true;
@@ -1009,8 +1149,10 @@
 {
 	int pos = head->read_avail;
 	if (io_printf(head, KEYWORD_ALLOW_ARGV0 "%s %s",
-		      ptr->filename->name, ptr->argv0->name)) goto out;
-	if (DumpCondition(head, cond)) goto out;
+		      ptr->filename->name, ptr->argv0->name))
+		goto out;
+	if (DumpCondition(head, cond))
+		goto out;
 	return true;
  out:
 	head->read_avail = pos;
@@ -1020,8 +1162,10 @@
 static bool print_env_acl(struct io_buffer *head, struct env_acl_record *ptr, const struct condition_list *cond)
 {
 	int pos = head->read_avail;
-	if (io_printf(head, KEYWORD_ALLOW_ENV "%s", ptr->env->name)) goto out;
-	if (DumpCondition(head, cond)) goto out;
+	if (io_printf(head, KEYWORD_ALLOW_ENV "%s", ptr->env->name))
+		goto out;
+	if (DumpCondition(head, cond))
+		goto out;
 	return true;
  out:
 	head->read_avail = pos;
@@ -1031,8 +1175,10 @@
 static bool print_capability_acl(struct io_buffer *head, struct capability_acl_record *ptr, const struct condition_list *cond)
 {
 	int pos = head->read_avail;
-	if (io_printf(head, KEYWORD_ALLOW_CAPABILITY "%s", cap_operation2keyword(ptr->operation))) goto out;
-	if (DumpCondition(head, cond)) goto out;
+	if (io_printf(head, KEYWORD_ALLOW_CAPABILITY "%s", cap_operation2keyword(ptr->operation)))
+		goto out;
+	if (DumpCondition(head, cond))
+		goto out;
 	return true;
  out:
 	head->read_avail = pos;
@@ -1042,16 +1188,20 @@
 static bool print_network_acl(struct io_buffer *head, struct ip_network_acl_record *ptr, const struct condition_list *cond)
 {
 	int pos = head->read_avail;
-	if (io_printf(head, KEYWORD_ALLOW_NETWORK "%s ", net_operation2keyword(ptr->operation_type))) goto out;
+	if (io_printf(head, KEYWORD_ALLOW_NETWORK "%s ", net_operation2keyword(ptr->operation_type)))
+		goto out;
 	switch (ptr->record_type) {
 	case IP_RECORD_TYPE_ADDRESS_GROUP:
-		if (io_printf(head, "@%s", ptr->u.group->group_name->name)) goto out;
+		if (io_printf(head, "@%s", ptr->u.group->group_name->name))
+			goto out;
 		break;
 	case IP_RECORD_TYPE_IPv4:
 		{
 			const u32 min_address = ptr->u.ipv4.min, max_address = ptr->u.ipv4.max;
-			if (io_printf(head, "%u.%u.%u.%u", HIPQUAD(min_address))) goto out;
-			if (min_address != max_address && io_printf(head, "-%u.%u.%u.%u", HIPQUAD(max_address))) goto out;
+			if (io_printf(head, "%u.%u.%u.%u", HIPQUAD(min_address)))
+				goto out;
+			if (min_address != max_address && io_printf(head, "-%u.%u.%u.%u", HIPQUAD(max_address)))
+				goto out;
 		}
 		break;
 	case IP_RECORD_TYPE_IPv6:
@@ -1059,20 +1209,25 @@
 			char buf[64];
 			const struct in6_addr *min_address = ptr->u.ipv6.min, *max_address = ptr->u.ipv6.max;
 			print_ipv6(buf, sizeof(buf), min_address);
-			if (io_printf(head, "%s", buf)) goto out;
+			if (io_printf(head, "%s", buf))
+				goto out;
 			if (min_address != max_address) {
 				print_ipv6(buf, sizeof(buf), max_address);
-				if (io_printf(head, "-%s", buf)) goto out;
+				if (io_printf(head, "-%s", buf))
+					goto out;
 			}
 		}
 		break;
 	}
 	{
 		const u16 min_port = ptr->min_port, max_port = ptr->max_port;
-		if (io_printf(head, " %u", min_port)) goto out;
-		if (min_port != max_port && io_printf(head, "-%u", max_port)) goto out;
+		if (io_printf(head, " %u", min_port))
+			goto out;
+		if (min_port != max_port && io_printf(head, "-%u", max_port))
+			goto out;
 	}
-	if (DumpCondition(head, cond)) goto out;
+	if (DumpCondition(head, cond))
+		goto out;
 	return true;
  out:
 	head->read_avail = pos;
@@ -1082,8 +1237,10 @@
 static bool print_signal_acl(struct io_buffer *head, struct signal_acl_record *ptr, const struct condition_list *cond)
 {
 	int pos = head->read_avail;
-	if (io_printf(head, KEYWORD_ALLOW_SIGNAL "%u %s", ptr->sig, ptr->domainname->name)) goto out;
-	if (DumpCondition(head, cond)) goto out;
+	if (io_printf(head, KEYWORD_ALLOW_SIGNAL "%u %s", ptr->sig, ptr->domainname->name))
+		goto out;
+	if (DumpCondition(head, cond))
+		goto out;
 	return true;
  out:
 	head->read_avail = pos;
@@ -1099,17 +1256,23 @@
 {
 	struct list1_head *dpos;
 	struct list1_head *apos;
-	if (head->read_eof) return 0;
-	if (head->read_step == 0) head->read_step = 1;
+	if (head->read_eof)
+		return 0;
+	if (head->read_step == 0)
+		head->read_step = 1;
 	list1_for_each_cookie(dpos, head->read_var1, &domain_list) {
 		struct domain_info *domain;
 		domain = list1_entry(dpos, struct domain_info, list);
-		if (head->read_step != 1) goto acl_loop;
-		if (domain->is_deleted) continue;
-		if (io_printf(head, "%s\n" KEYWORD_USE_PROFILE "%u\n%s\n%s%s", domain->domainname->name, domain->profile, domain->quota_warned ? "quota_exceeded\n" : "", domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ ? KEYWORD_IGNORE_GLOBAL_ALLOW_READ "\n" : "", domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV ? KEYWORD_IGNORE_GLOBAL_ALLOW_ENV "\n" : "")) return 0;
+		if (head->read_step != 1)
+			goto acl_loop;
+		if (domain->is_deleted)
+			continue;
+		if (io_printf(head, "%s\n" KEYWORD_USE_PROFILE "%u\n%s\n%s%s", domain->domainname->name, domain->profile, domain->quota_warned ? "quota_exceeded\n" : "", domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ ? KEYWORD_IGNORE_GLOBAL_ALLOW_READ "\n" : "", domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV ? KEYWORD_IGNORE_GLOBAL_ALLOW_ENV "\n" : ""))
+			return 0;
 		head->read_step = 2;
-	acl_loop: ;
-		if (head->read_step == 3) goto tail_mark;
+acl_loop:
+		if (head->read_step == 3)
+			goto tail_mark;
 		list1_for_each_cookie(apos, head->read_var2, &domain->acl_info_list) {
 			struct acl_info *ptr;
 			u8 acl_type;
@@ -1120,30 +1283,40 @@
 			if (acl_type & ACL_DELETED) {
 				/* Deleted entry. */
 			} else if (acl_type == TYPE_SINGLE_PATH_ACL) {
-				if (!print_single_path_acl(head, container_of(ptr, struct single_path_acl_record, head), cond)) return 0;
+				if (!print_single_path_acl(head, container_of(ptr, struct single_path_acl_record, head), cond))
+					return 0;
 			} else if (acl_type == TYPE_DOUBLE_PATH_ACL) {
-				if (!print_double_path_acl(head, container_of(ptr, struct double_path_acl_record, head), cond)) return 0;
+				if (!print_double_path_acl(head, container_of(ptr, struct double_path_acl_record, head), cond))
+					return 0;
 			} else if (acl_type == TYPE_ARGV0_ACL) {
-				if (!print_argv0_acl(head, container_of(ptr, struct argv0_acl_record, head), cond)) return 0;
+				if (!print_argv0_acl(head, container_of(ptr, struct argv0_acl_record, head), cond))
+					return 0;
 			} else if (acl_type == TYPE_ENV_ACL) {
-				if (!print_env_acl(head, container_of(ptr, struct env_acl_record, head), cond)) return 0;
+				if (!print_env_acl(head, container_of(ptr, struct env_acl_record, head), cond))
+					return 0;
 			} else if (acl_type == TYPE_CAPABILITY_ACL) {
-				if (!print_capability_acl(head, container_of(ptr, struct capability_acl_record, head), cond)) return 0;
+				if (!print_capability_acl(head, container_of(ptr, struct capability_acl_record, head), cond))
+					return 0;
 			} else if (acl_type == TYPE_IP_NETWORK_ACL) {
-				if (!print_network_acl(head, container_of(ptr, struct ip_network_acl_record, head), cond)) return 0;
+				if (!print_network_acl(head, container_of(ptr, struct ip_network_acl_record, head), cond))
+					return 0;
 			} else if (acl_type == TYPE_SIGNAL_ACL) {
-				if (!print_signal_acl(head, container_of(ptr, struct signal_acl_record, head), cond)) return 0;
+				if (!print_signal_acl(head, container_of(ptr, struct signal_acl_record, head), cond))
+					return 0;
 			} else if (acl_type == TYPE_PREFERRED_EXECUTE_HANDLER) {
-				if (!print_execute_handler_record(head, KEYWORD_PREFERRED_EXECUTE_HANDLER, container_of(ptr, struct execute_handler_record, head))) return 0;
+				if (!print_execute_handler_record(head, KEYWORD_PREFERRED_EXECUTE_HANDLER, container_of(ptr, struct execute_handler_record, head)))
+					return 0;
 			} else if (acl_type == TYPE_DEFAULT_EXECUTE_HANDLER) {
-				if (!print_execute_handler_record(head, KEYWORD_DEFAULT_EXECUTE_HANDLER, container_of(ptr, struct execute_handler_record, head))) return 0;
+				if (!print_execute_handler_record(head, KEYWORD_DEFAULT_EXECUTE_HANDLER, container_of(ptr, struct execute_handler_record, head)))
+					return 0;
 			} else {
 				BUG();
 			}
 		}
 		head->read_step = 3;
-	tail_mark: ;
-		if (io_printf(head, "\n")) return 0;
+tail_mark:
+		if (io_printf(head, "\n"))
+			return 0;
 		head->read_step = 1;
 	}
 	head->read_eof = true;
@@ -1158,11 +1331,13 @@
 	char *cp = strchr(data, ' ');
 	struct domain_info *domain;
 	unsigned int profile;
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp = '\0';
 	domain = FindDomain(cp + 1);
 	profile = simple_strtoul(data, NULL, 10);
-	if (domain && profile < MAX_PROFILES && (profile_ptr[profile] || !sbin_init_started)) domain->profile = (u8) profile;
+	if (domain && profile < MAX_PROFILES && (profile_ptr[profile] || !sbin_init_started))
+		domain->profile = (u8) profile;
 	UpdateCounter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 	return 0;
 }
@@ -1170,12 +1345,15 @@
 static int ReadDomainProfile(struct io_buffer *head)
 {
 	struct list1_head *pos;
-	if (head->read_eof) return 0;
+	if (head->read_eof)
+		return 0;
 	list1_for_each_cookie(pos, head->read_var1, &domain_list) {
 		struct domain_info *domain;
 		domain = list1_entry(pos, struct domain_info, list);
-		if (domain->is_deleted) continue;
-		if (io_printf(head, "%u %s\n", domain->profile, domain->domainname->name)) return 0;
+		if (domain->is_deleted)
+			continue;
+		if (io_printf(head, "%u %s\n", domain->profile, domain->domainname->name))
+			return 0;
 	}
 	head->read_eof = true;
 	return 0;
@@ -1197,10 +1375,12 @@
 		/***** CRITICAL SECTION START *****/
 		read_lock(&tasklist_lock);
 		p = find_task_by_pid(pid);
-		if (p) domain = p->domain_info;
+		if (p)
+			domain = p->domain_info;
 		read_unlock(&tasklist_lock);
 		/***** CRITICAL SECTION END *****/
-		if (domain) io_printf(head, "%d %u %s", pid, domain->profile, domain->domainname->name);
+		if (domain)
+			io_printf(head, "%d %u %s", pid, domain->profile, domain->domainname->name);
 		head->read_eof = true;
 	}
 	return 0;
@@ -1252,36 +1432,56 @@
 	if (!head->read_eof) {
 		switch (head->read_step) {
 		case 0:
-			head->read_var2 = NULL; head->read_step = 1;
+			head->read_var2 = NULL;
+			head->read_step = 1;
 		case 1:
-			if (ReadDomainKeeperPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 2;
+			if (ReadDomainKeeperPolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 2;
 		case 2:
-			if (ReadGloballyReadablePolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 3;
+			if (ReadGloballyReadablePolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 3;
 		case 3:
-			if (ReadGloballyUsableEnvPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 4;
+			if (ReadGloballyUsableEnvPolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 4;
 		case 4:
-			if (ReadDomainInitializerPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 5;
+			if (ReadDomainInitializerPolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 5;
 		case 5:
-			if (ReadAliasPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 6;
+			if (ReadAliasPolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 6;
 		case 6:
-			if (ReadAggregatorPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 7;
+			if (ReadAggregatorPolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 7;
 		case 7:
-			if (ReadFilePatternPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 8;
+			if (ReadFilePatternPolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 8;
 		case 8:
-			if (ReadNoRewritePolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 9;
+			if (ReadNoRewritePolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 9;
 		case 9:
-			if (ReadPathGroupPolicy(head)) break;
-			head->read_var1 = head->read_var2 = NULL; head->read_step = 10;
+			if (ReadPathGroupPolicy(head))
+				break;
+			head->read_var1 = head->read_var2 = NULL;
+			head->read_step = 10;
 		case 10:
-			if (ReadAddressGroupPolicy(head)) break;
+			if (ReadAddressGroupPolicy(head))
+				break;
 			head->read_eof = true;
 			break;
 		default:
@@ -1324,21 +1524,31 @@
 	if (!head->read_eof) {
 		switch (head->read_step) {
 		case 0:
-			head->read_var2 = NULL; head->read_step = 1;
+			head->read_var2 = NULL;
+			head->read_step = 1;
 		case 1:
-			if (ReadMountPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 2;
+			if (ReadMountPolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 2;
 		case 2:
-			if (ReadNoUmountPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 3;
+			if (ReadNoUmountPolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 3;
 		case 3:
-			if (ReadChrootPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 4;
+			if (ReadChrootPolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 4;
 		case 4:
-			if (ReadPivotRootPolicy(head)) break;
-			head->read_var2 = NULL; head->read_step = 5;
+			if (ReadPivotRootPolicy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 5;
 		case 5:
-			if (ReadReservedPortPolicy(head)) break;
+			if (ReadReservedPortPolicy(head))
+				break;
 			head->read_eof = true;
 			break;
 		default:
@@ -1354,7 +1564,7 @@
 
 static bool profile_loaded = false;
 
-static const char *ccs_loader = NULL;
+static const char *ccs_loader;
 
 static int __init CCS_loader_Setup(char *str)
 {
@@ -1366,14 +1576,16 @@
 
 void CCS_LoadPolicy(const char *filename)
 {
-	if (sbin_init_started) return;
+	if (sbin_init_started)
+		return;
 	/*
 	 * Check filename is /sbin/init or /sbin/ccs-start .
 	 * /sbin/ccs-start is a dummy filename in case where /sbin/init can't be passed.
 	 * You can create /sbin/ccs-start by "ln -s /bin/true /sbin/ccs-start", for
 	 * only the pathname is needed to activate Mandatory Access Control.
 	 */
-	if (strcmp(filename, "/sbin/init") != 0 && strcmp(filename, "/sbin/ccs-start") != 0) return;
+	if (strcmp(filename, "/sbin/init") != 0 && strcmp(filename, "/sbin/ccs-start") != 0)
+		return;
 	/*
 	 * Don't activate MAC if the path given by 'CCS_loader=' option doesn't exist.
 	 * If initrd.img includes /sbin/init but real-root-dev has not mounted on / yet,
@@ -1382,12 +1594,13 @@
 	 */
 	{
 		struct nameidata nd;
-		if (!ccs_loader) ccs_loader = "/sbin/ccs-init";
+		if (!ccs_loader)
+			ccs_loader = "/sbin/ccs-init";
 		if (path_lookup(ccs_loader, lookup_flags, &nd)) {
 			printk("Not activating Mandatory Access Control now since %s doesn't exist.\n", ccs_loader);
 			return;
 		}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,25)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 25)
 		path_put(&nd.path);
 #else
 		path_release(&nd);
@@ -1401,7 +1614,7 @@
 		envp[0] = "HOME=/";
 		envp[1] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
 		envp[2] = NULL;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 		call_usermodehelper(argv[0], argv, envp, 1);
 #else
 		call_usermodehelper(argv[0], argv, envp);
@@ -1424,7 +1637,8 @@
 		struct domain_info *domain;
 		list1_for_each_entry(domain, &domain_list, list) {
 			const u8 profile = domain->profile;
-			if (!profile_ptr[profile]) panic("Profile %u (used by '%s') not defined.\n", profile, domain->domainname->name);
+			if (!profile_ptr[profile])
+				panic("Profile %u (used by '%s') not defined.\n", profile, domain->domainname->name);
 		}
 	}
 }
@@ -1433,7 +1647,7 @@
 
 static DECLARE_WAIT_QUEUE_HEAD(query_wait);
 
-static spinlock_t query_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(query_lock);
 
 struct query_entry {
 	struct list_head list;
@@ -1452,7 +1666,7 @@
 	va_list args;
 	int error = -EPERM;
 	int pos, len;
-	static unsigned int serial = 0;
+	static unsigned int serial;
 	struct query_entry *query_entry;
 	if (!CheckCCSFlags(CCS_ALLOW_ENFORCE_GRACE) || !atomic_read(&queryd_watcher)) {
 		if ((current->tomoyo_flags & CCS_DONT_SLEEP_ON_ENFORCE_ERROR) == 0) {
@@ -1467,8 +1681,12 @@
 	va_start(args, fmt);
 	len = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 32;
 	va_end(args);
-	if ((query_entry = ccs_alloc(sizeof(*query_entry))) == NULL ||
-		(query_entry->query = ccs_alloc(len)) == NULL) goto out;
+	query_entry = ccs_alloc(sizeof(*query_entry));
+	if (!query_entry)
+		goto out;
+	query_entry->query = ccs_alloc(len);
+	if (!query_entry->query)
+		goto out;
 	INIT_LIST_HEAD(&query_entry->list);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&query_lock);
@@ -1491,7 +1709,8 @@
 		wake_up(&query_wait);
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ / 10);
-		if (query_entry->answer) break;
+		if (query_entry->answer)
+			break;
 	}
 	UpdateCounter(CCS_UPDATES_COUNTER_QUERY);
 	/***** CRITICAL SECTION START *****/
@@ -1512,7 +1731,8 @@
 		break;
 	}
  out: ;
-	if (query_entry) ccs_free(query_entry->query);
+	if (query_entry)
+		ccs_free(query_entry->query);
 	ccs_free(query_entry);
 	return error;
 }
@@ -1525,14 +1745,16 @@
 	found = !list_empty(&query_list);
 	spin_unlock(&query_lock);
 	/***** CRITICAL SECTION END *****/
-	if (found) return POLLIN | POLLRDNORM;
+	if (found)
+		return POLLIN | POLLRDNORM;
 	poll_wait(file, &query_wait, wait);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&query_lock);
 	found = !list_empty(&query_list);
 	spin_unlock(&query_lock);
 	/***** CRITICAL SECTION END *****/
-	if (found) return POLLIN | POLLRDNORM;
+	if (found)
+		return POLLIN | POLLRDNORM;
 	return 0;
 }
 
@@ -1541,9 +1763,11 @@
 	struct list_head *tmp;
 	int pos = 0, len = 0;
 	char *buf;
-	if (head->read_avail) return 0;
+	if (head->read_avail)
+		return 0;
 	if (head->read_buf) {
-		ccs_free(head->read_buf); head->read_buf = NULL;
+		ccs_free(head->read_buf);
+		head->read_buf = NULL;
 		head->readbuf_size = 0;
 	}
 	/***** CRITICAL SECTION START *****/
@@ -1561,7 +1785,8 @@
 		head->read_step = 0;
 		return 0;
 	}
-	if ((buf = ccs_alloc(len)) != NULL) {
+	buf = ccs_alloc(len);
+	if (buf) {
 		pos = 0;
 		/***** CRITICAL SECTION START *****/
 		spin_lock(&query_lock);
@@ -1569,7 +1794,8 @@
 			struct query_entry *ptr = list_entry(tmp, struct query_entry, list);
 			if (pos++ == head->read_step) {
 				/* Some query can be skiipped since query_list can change, but I don't care. */
-				if (len == ptr->query_len) memmove(buf, ptr->query, len);
+				if (len == ptr->query_len)
+					memmove(buf, ptr->query, len);
 				break;
 			}
 		}
@@ -1599,13 +1825,16 @@
 	}
 	spin_unlock(&query_lock);
 	/***** CRITICAL SECTION END *****/
-	if (sscanf(data, "A%u=%u", &serial, &answer) != 2) return -EINVAL;
+	if (sscanf(data, "A%u=%u", &serial, &answer) != 2)
+		return -EINVAL;
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&query_lock);
 	list_for_each(tmp, &query_list) {
 		struct query_entry *ptr = list_entry(tmp, struct query_entry, list);
-		if (ptr->serial != serial) continue;
-		if (!ptr->answer) ptr->answer = answer;
+		if (ptr->serial != serial)
+			continue;
+		if (!ptr->answer)
+			ptr->answer = answer;
 		break;
 	}
 	spin_unlock(&query_lock);
@@ -1617,13 +1846,14 @@
 
 /* Policy updates counter. */
 static unsigned int updates_counter[MAX_CCS_UPDATES_COUNTER];
-static spinlock_t updates_counter_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(updates_counter_lock);
 
 void UpdateCounter(const unsigned char index)
 {
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&updates_counter_lock);
-	if (index < MAX_CCS_UPDATES_COUNTER) updates_counter[index]++;
+	if (index < MAX_CCS_UPDATES_COUNTER)
+		updates_counter[index]++;
 	spin_unlock(&updates_counter_lock);
 	/***** CRITICAL SECTION END *****/
 }
@@ -1663,7 +1893,8 @@
 static int ReadVersion(struct io_buffer *head)
 {
 	if (!head->read_eof) {
-		if (io_printf(head, "1.6.0-pre") == 0) head->read_eof = true;
+		if (io_printf(head, "1.6.0-pre") == 0)
+			head->read_eof = true;
 	}
 	return 0;
 }
@@ -1672,7 +1903,8 @@
 {
 	if (!head->read_eof) {
 		const int shared = GetMemoryUsedForSaveName(), private = GetMemoryUsedForElements(), dynamic = GetMemoryUsedForDynamic();
-		if (io_printf(head, "Shared:  %10u\nPrivate: %10u\nDynamic: %10u\nTotal:   %10u\n", shared, private, dynamic, shared + private + dynamic) == 0) head->read_eof = true;
+		if (io_printf(head, "Shared:  %10u\nPrivate: %10u\nDynamic: %10u\nTotal:   %10u\n", shared, private, dynamic, shared + private + dynamic) == 0)
+			head->read_eof = true;
 	}
 	return 0;
 }
@@ -1689,7 +1921,8 @@
 int CCS_OpenControl(const u8 type, struct file *file)
 {
 	struct io_buffer *head = ccs_alloc(sizeof(*head));
-	if (!head) return -ENOMEM;
+	if (!head)
+		return -ENOMEM;
 	mutex_init(&head->read_sem);
 	mutex_init(&head->write_sem);
 	switch (type) {
@@ -1754,33 +1987,40 @@
 		break;
 	}
 	if (type != CCS_GRANTLOG && type != CCS_REJECTLOG && type != CCS_QUERY) {
-		if (!head->readbuf_size) head->readbuf_size = 4096 * 2;
-		if ((head->read_buf = ccs_alloc(head->readbuf_size)) == NULL) {
+		if (!head->readbuf_size)
+			head->readbuf_size = 4096 * 2;
+		head->read_buf = ccs_alloc(head->readbuf_size);
+		if (!head->read_buf) {
 			ccs_free(head);
 			return -ENOMEM;
 		}
 	}
 	if (head->write) {
 		head->writebuf_size = 4096 * 2;
-		if ((head->write_buf = ccs_alloc(head->writebuf_size)) == NULL) {
+		head->write_buf = ccs_alloc(head->writebuf_size);
+		if (!head->write_buf) {
 			ccs_free(head->read_buf);
 			ccs_free(head);
 			return -ENOMEM;
 		}
 	}
 	file->private_data = head;
-	if (type == CCS_SELFDOMAIN) CCS_ReadControl(file, NULL, 0);
-	else if (head->write == WriteAnswer) atomic_inc(&queryd_watcher);
+	if (type == CCS_SELFDOMAIN)
+		CCS_ReadControl(file, NULL, 0);
+	else if (head->write == WriteAnswer)
+		atomic_inc(&queryd_watcher);
 	return 0;
 }
 
-static int CopyToUser(struct io_buffer *head, char __user * buffer, int buffer_len)
+static int CopyToUser(struct io_buffer *head, char __user *buffer, int buffer_len)
 {
 	int len = head->read_avail;
 	char *cp = head->read_buf;
-	if (len > buffer_len) len = buffer_len;
+	if (len > buffer_len)
+		len = buffer_len;
 	if (len) {
-		if (copy_to_user(buffer, cp, len)) return -EFAULT;
+		if (copy_to_user(buffer, cp, len))
+			return -EFAULT;
 		head->read_avail -= len;
 		memmove(cp, cp + len, head->read_avail);
 	}
@@ -1790,7 +2030,8 @@
 int CCS_PollControl(struct file *file, poll_table *wait)
 {
 	struct io_buffer *head = file->private_data;
-	if (!head->poll) return -ENOSYS;
+	if (!head->poll)
+		return -ENOSYS;
 	return head->poll(file, wait);
 }
 
@@ -1798,11 +2039,15 @@
 {
 	int len = 0;
 	struct io_buffer *head = file->private_data;
-	if (!head->read) return -ENOSYS;
-	if (!access_ok(VERIFY_WRITE, buffer, buffer_len)) return -EFAULT;
-	if (mutex_lock_interruptible(&head->read_sem)) return -EINTR;
+	if (!head->read)
+		return -ENOSYS;
+	if (!access_ok(VERIFY_WRITE, buffer, buffer_len))
+		return -EFAULT;
+	if (mutex_lock_interruptible(&head->read_sem))
+		return -EINTR;
 	len = head->read(head);
-	if (len >= 0) len = CopyToUser(head, buffer, buffer_len);
+	if (len >= 0)
+		len = CopyToUser(head, buffer, buffer_len);
 	mutex_unlock(&head->read_sem);
 	return len;
 }
@@ -1813,12 +2058,15 @@
 	int error = buffer_len;
 	int avail_len = buffer_len;
 	char *cp0 = head->write_buf;
-	if (!head->write) return -ENOSYS;
-	if (!access_ok(VERIFY_READ, buffer, buffer_len)) return -EFAULT;
+	if (!head->write)
+		return -ENOSYS;
+	if (!access_ok(VERIFY_READ, buffer, buffer_len))
+		return -EFAULT;
 	if (head->write != WritePID && !IsPolicyManager()) {
 		return -EPERM; /* Forbid updating policies for non manager programs. */
 	}
-	if (mutex_lock_interruptible(&head->write_sem)) return -EINTR;
+	if (mutex_lock_interruptible(&head->write_sem))
+		return -EINTR;
 	while (avail_len > 0) {
 		char c;
 		if (head->write_avail >= head->writebuf_size - 1) {
@@ -1828,9 +2076,11 @@
 			error = -EFAULT;
 			break;
 		}
-		buffer++; avail_len--;
+		buffer++;
+		avail_len--;
 		cp0[head->write_avail++] = c;
-		if (c != '\n') continue;
+		if (c != '\n')
+			continue;
 		cp0[head->write_avail - 1] = '\0';
 		head->write_avail = 0;
 		NormalizeLine(cp0);
@@ -1844,11 +2094,16 @@
 int CCS_CloseControl(struct file *file)
 {
 	struct io_buffer *head = file->private_data;
-	if (head->write == WriteAnswer) atomic_dec(&queryd_watcher);
-	else if (head->read == ReadMemoryCounter) profile_loaded = true;
-	ccs_free(head->read_buf); head->read_buf = NULL;
-	ccs_free(head->write_buf); head->write_buf = NULL;
-	ccs_free(head); head = NULL;
+	if (head->write == WriteAnswer)
+		atomic_dec(&queryd_watcher);
+	else if (head->read == ReadMemoryCounter)
+		profile_loaded = true;
+	ccs_free(head->read_buf);
+	head->read_buf = NULL;
+	ccs_free(head->write_buf);
+	head->write_buf = NULL;
+	ccs_free(head);
+	head = NULL;
 	file->private_data = NULL;
 	return 0;
 }
@@ -1886,9 +2141,11 @@
 	default:
 		return NULL;
 	}
-	if (!condition) len -= sizeof(ptr->cond);
+	if (!condition)
+		len -= sizeof(ptr->cond);
 	ptr = alloc_element(len);
-	if (!ptr) return NULL;
+	if (!ptr)
+		return NULL;
 	if (condition) {
 		ptr->cond = condition;
 		ptr->type = acl_type | ACL_WITH_CONDITION;
Index: trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/proc/ccs_proc.c	(working copy)
@@ -23,7 +23,7 @@
 
 #if defined(CONFIG_SAKURA) || defined(CONFIG_TOMOYO)
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,23)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 23)
 static inline struct proc_dir_entry *PDE(const struct inode *inode)
 {
 	return (struct proc_dir_entry *) inode->u.generic_ip;
@@ -45,25 +45,27 @@
 	return CCS_PollControl(file, wait);
 }
 
-static ssize_t ccs_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
+static ssize_t ccs_read(struct file *file, char __user *buf, size_t count,
+			loff_t *ppos)
 {
 	return CCS_ReadControl(file, buf, count);
 }
 
-static ssize_t ccs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
+static ssize_t ccs_write(struct file *file, const char __user *buf,
+			 size_t count, loff_t *ppos)
 {
 	return CCS_WriteControl(file, buf, count);
 }
 
 static struct file_operations ccs_operations = {
-	open:    ccs_open,
-	release: ccs_release,
-	poll:    ccs_poll,
-	read:    ccs_read,
-	write:   ccs_write
+	.open    = ccs_open,
+	.release = ccs_release,
+	.poll    = ccs_poll,
+	.read    = ccs_read,
+	.write   = ccs_write,
 };
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 static int proc_notify_change(struct dentry *dentry, struct iattr *iattr)
 {
 	struct inode *inode = dentry->d_inode;
@@ -77,7 +79,7 @@
 	error = inode_setattr(inode, iattr);
 	if (error)
 		goto out;
-	
+
 	de->uid = inode->i_uid;
 	de->gid = inode->i_gid;
 	de->mode = inode->i_mode;
@@ -89,15 +91,18 @@
 static struct inode_operations ccs_file_inode_operations;
 #endif
 
-static __init void CreateEntry(const char *name, const mode_t mode, struct proc_dir_entry *parent, const u8 key)
+static __init void CreateEntry(const char *name, const mode_t mode,
+			       struct proc_dir_entry *parent, const u8 key)
 {
 	struct proc_dir_entry *entry = create_proc_entry(name, mode, parent);
 	if (entry) {
 		entry->proc_fops = &ccs_operations;
 		entry->data = ((u8 *) NULL) + key;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		if (entry->proc_iops) ccs_file_inode_operations = *entry->proc_iops;
-		if (!ccs_file_inode_operations.setattr) ccs_file_inode_operations.setattr = proc_notify_change;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+		if (entry->proc_iops)
+			ccs_file_inode_operations = *entry->proc_iops;
+		if (!ccs_file_inode_operations.setattr)
+			ccs_file_inode_operations.setattr = proc_notify_change;
 		entry->proc_iops = &ccs_file_inode_operations;
 #endif
 	}
@@ -106,9 +111,11 @@
 void __init CCSProc_Init(void)
 {
 	struct proc_dir_entry *ccs_dir = proc_mkdir("ccs", NULL);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if (ccs_dir->proc_iops) ccs_dir_inode_operations = *ccs_dir->proc_iops;
-	if (!ccs_dir_inode_operations.setattr) ccs_dir_inode_operations.setattr = proc_notify_change;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	if (ccs_dir->proc_iops)
+		ccs_dir_inode_operations = *ccs_dir->proc_iops;
+	if (!ccs_dir_inode_operations.setattr)
+		ccs_dir_inode_operations.setattr = proc_notify_change;
 	ccs_dir->proc_iops = &ccs_dir_inode_operations;
 #endif
 	realpath_Init();
@@ -130,7 +137,8 @@
 	CreateEntry("manager",          0600, ccs_dir, CCS_MANAGER);
 	CreateEntry(".updates_counter", 0400, ccs_dir, CCS_UPDATESCOUNTER);
 	CreateEntry("version",          0400, ccs_dir, CCS_VERSION);
-	if (sizeof(struct ccs_page_buffer) <  CCS_MAX_PATHNAME_LEN - 16) panic("Bad size!");
+	if (sizeof(struct ccs_page_buffer) <  CCS_MAX_PATHNAME_LEN - 16)
+		panic("Bad size!");
 }
 
 #else
Index: trunk/1.6.x/ccs-patch/fs/sakura_bind.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_bind.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/sakura_bind.c	(working copy)
@@ -47,7 +47,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->min_port = min_port;
 	new_entry->max_port = max_port;
 	list1_add_tail_mb(&new_entry->list, &reservedport_list);
@@ -61,9 +63,11 @@
 {
 	/* Must not sleep, for called inside spin_lock. */
 	struct reserved_entry *ptr;
-	if (!CheckCCSFlags_NoSleepCheck(CCS_SAKURA_RESTRICT_AUTOBIND)) return 0;
+	if (!CheckCCSFlags_NoSleepCheck(CCS_SAKURA_RESTRICT_AUTOBIND))
+		return 0;
 	list1_for_each_entry(ptr, &reservedport_list, list) {
-		if (ptr->min_port <= port && port <= ptr->max_port && !ptr->is_deleted) return -EPERM;
+		if (ptr->min_port <= port && port <= ptr->max_port && !ptr->is_deleted)
+ return -EPERM;
 	}
 	return 0;
 }
@@ -72,14 +76,17 @@
 int AddReservedPortPolicy(char *data, const bool is_delete)
 {
 	unsigned int from, to;
-	if (strchr(data, ' ')) goto out;
+	if (strchr(data, ' '))
+		goto out;
 	if (sscanf(data, "%u-%u", &from, &to) == 2) {
-		if (from <= to && to < 65536) return AddReservedEntry(from, to, is_delete);
+		if (from <= to && to < 65536)
+			return AddReservedEntry(from, to, is_delete);
 	} else if (sscanf(data, "%u", &from) == 1) {
-		if (from < 65536) return AddReservedEntry(from, from, is_delete);
+		if (from < 65536)
+			return AddReservedEntry(from, from, is_delete);
 	}
  out:
-	printk("%s: ERROR: Invalid port range '%s'\n", __FUNCTION__, data);
+	printk("%s: ERROR: Invalid port range '%s'\n", __func__, data);
 	return -EINVAL;
 }
 
@@ -89,11 +96,14 @@
 	list1_for_each_cookie(pos, head->read_var2, &reservedport_list) {
 		struct reserved_entry *ptr;
 		ptr = list1_entry(pos, struct reserved_entry, list);
-		if (ptr->is_deleted) continue;
+		if (ptr->is_deleted)
+			continue;
 		if (ptr->min_port != ptr->max_port) {
-			if (io_printf(head, KEYWORD_DENY_AUTOBIND "%u-%u\n", ptr->min_port, ptr->max_port)) return -ENOMEM;
+			if (io_printf(head, KEYWORD_DENY_AUTOBIND "%u-%u\n", ptr->min_port, ptr->max_port))
+				return -ENOMEM;
 		} else {
-			if (io_printf(head, KEYWORD_DENY_AUTOBIND "%u\n", ptr->min_port)) return -ENOMEM;
+			if (io_printf(head, KEYWORD_DENY_AUTOBIND "%u\n", ptr->min_port))
+				return -ENOMEM;
 		}
 	}
 	return 0;
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c	(working copy)
@@ -17,7 +17,7 @@
 #include <linux/tomoyo.h>
 #include <linux/realpath.h>
 #include <linux/version.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 #define find_task_by_pid find_task_by_vpid
 #endif
 
@@ -27,9 +27,12 @@
 {
 	char *buf;
 	int len;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
+	if (CanSaveAuditLog(is_granted) < 0)
+		return -ENOMEM;
 	len = dest_domain->total_len;
-	if ((buf = InitAuditLog(&len, profile, mode, NULL)) == NULL) return -ENOMEM;
+	buf = InitAuditLog(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
 	snprintf(buf + strlen(buf), len - strlen(buf) - 1, KEYWORD_ALLOW_SIGNAL "%d %s\n", signal, dest_domain->name);
 	return WriteAuditLog(buf, is_granted);
 }
@@ -43,31 +46,43 @@
 	const struct path_info *saved_dest_pattern;
 	const u16 hash = sig;
 	int error = -ENOMEM;
-	if (!domain) return -EINVAL;
-	if (!dest_pattern || !IsCorrectDomain(dest_pattern, __FUNCTION__)) return -EINVAL;
-	if ((saved_dest_pattern = SaveName(dest_pattern)) == NULL) return -ENOMEM;
+	if (!domain)
+		return -EINVAL;
+	if (!dest_pattern || !IsCorrectDomain(dest_pattern, __func__))
+		return -EINVAL;
+	saved_dest_pattern = SaveName(dest_pattern);
+	if (!saved_dest_pattern)
+		return -ENOMEM;
 	mutex_lock(&domain_acl_lock);
 	if (!is_delete) {
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_SIGNAL_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_SIGNAL_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct signal_acl_record, head);
-			if (acl->sig != hash || pathcmp(acl->domainname, saved_dest_pattern)) continue;
+			if (acl->sig != hash || pathcmp(acl->domainname, saved_dest_pattern))
+				continue;
 			error = AddDomainACL(NULL, ptr);
 			goto out;
 		}
 		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_SIGNAL_ACL, condition)) == NULL) goto out;
+		acl = alloc_acl_element(TYPE_SIGNAL_ACL, condition);
+		if (!acl)
+			goto out;
 		acl->sig = hash;
 		acl->domainname = saved_dest_pattern;
 		error = AddDomainACL(domain, &acl->head);
 	} else {
 		error = -ENOENT;
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SIGNAL_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SIGNAL_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct signal_acl_record, head);
-			if (acl->sig != hash || pathcmp(acl->domainname, saved_dest_pattern)) continue;
+			if (acl->sig != hash || pathcmp(acl->domainname, saved_dest_pattern))
+				continue;
 			error = DelDomainACL(ptr);
 			break;
 		}
@@ -88,8 +103,10 @@
 	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_SIGNAL);
 	const bool is_enforce = (mode == 3);
 	bool found = false;
-	if (!mode) return 0;
-	if (!sig) return 0;                               /* No check for NULL signal. */
+	if (!mode)
+		return 0;
+	if (!sig)
+		return 0;                               /* No check for NULL signal. */
 	if (current->pid == pid) {
 		AuditSignalLog(sig, domain->domainname, 1, profile, mode);
 		return 0;                /* No check for self. */
@@ -97,13 +114,19 @@
 	{ /* Simplified checking. */
 		struct task_struct *p = NULL;
 		read_lock(&tasklist_lock);
-		if (pid > 0) p = find_task_by_pid((pid_t) pid);
-		else if (pid == 0) p = current;
-		else if (pid == -1) dest = &KERNEL_DOMAIN;
-		else p = find_task_by_pid((pid_t) -pid);
-		if (p) dest = p->domain_info;
+		if (pid > 0)
+			p = find_task_by_pid((pid_t) pid);
+		else if (pid == 0)
+			p = current;
+		else if (pid == -1)
+			dest = &KERNEL_DOMAIN;
+		else
+			p = find_task_by_pid((pid_t) -pid);
+		if (p)
+			dest = p->domain_info;
 		read_unlock(&tasklist_lock);
-		if (!dest) return 0; /* I can't find destinatioin. */
+		if (!dest)
+			return 0; /* I can't find destinatioin. */
 	}
 	if (domain == dest) {
 		AuditSignalLog(sig, dest->domainname, 1, profile, mode);
@@ -112,24 +135,30 @@
 	dest_pattern = dest->domainname->name;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct signal_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SIGNAL_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SIGNAL_ACL)
+			continue;
 		acl = container_of(ptr, struct signal_acl_record, head);
 		if (acl->sig == hash && CheckCondition(ptr, NULL)) {
 			const int len = acl->domainname->total_len;
-			if (strncmp(acl->domainname->name, dest_pattern, len)) continue;
-			if (dest_pattern[len] != ' ' && dest_pattern[len] != '\0') continue;
+			if (strncmp(acl->domainname->name, dest_pattern, len))
+				continue;
+			if (dest_pattern[len] != ' ' && dest_pattern[len] != '\0')
+				continue;
 			UpdateCondition(ptr);
 			found = true;
 			break;
 		}
 	}
 	AuditSignalLog(sig, dest->domainname, found, profile, mode);
-	if (found) return 0;
+	if (found)
+		return 0;
 	if (TomoyoVerboseMode()) {
 		printk("TOMOYO-%s: Signal %d to %s denied for %s\n", GetMSG(is_enforce), sig, GetLastName(dest), GetLastName(domain));
 	}
-	if (is_enforce) return CheckSupervisor("%s\n" KEYWORD_ALLOW_SIGNAL "%d %s\n", domain->domainname->name, sig, dest_pattern);
-	else if (mode == 1 && CheckDomainQuota(domain)) AddSignalEntry(sig, dest_pattern, domain, NULL, 0);
+	if (is_enforce)
+		return CheckSupervisor("%s\n" KEYWORD_ALLOW_SIGNAL "%d %s\n", domain->domainname->name, sig, dest_pattern);
+	else if (mode == 1 && CheckDomainQuota(domain))
+		AddSignalEntry(sig, dest_pattern, domain, NULL, 0);
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_file.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(working copy)
@@ -89,7 +89,8 @@
 static bool strendswith(const char *name, const char *tail)
 {
 	int len;
-	if (!name || !tail) return 0;
+	if (!name || !tail)
+		return 0;
 	len = strlen(name) - strlen(tail);
 	return len >= 0 && strcmp(name + len, tail) == 0;
 }
@@ -98,8 +99,8 @@
 {
 	struct path_info_with_data *buf = ccs_alloc(sizeof(struct ccs_page_buffer));
 	if (buf) {
-		int error;
-		if ((error = realpath_from_dentry2(dentry, mnt, buf->body, sizeof(buf->body) - 1)) == 0) {
+		int error = realpath_from_dentry2(dentry, mnt, buf->body, sizeof(buf->body) - 1);
+		if (!error) {
 			buf->head.name = buf->body;
 			fill_path_info(&buf->head);
 			return &buf->head;
@@ -121,9 +122,12 @@
 {
 	char *buf;
 	int len;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
+	if (CanSaveAuditLog(is_granted) < 0)
+		return -ENOMEM;
 	len = strlen(operation) + filename1->total_len + (filename2 ? filename2->total_len : 0) + 16;
-	if ((buf = InitAuditLog(&len, profile, mode, bprm)) == NULL) return -ENOMEM;
+	buf = InitAuditLog(&len, profile, mode, bprm);
+	if (!buf)
+		return -ENOMEM;
 	snprintf(buf + strlen(buf), len - strlen(buf) - 1, "allow_%s %s %s\n", operation, filename1->name, filename2 ? filename2->name : "");
 	return WriteAuditLog(buf, is_granted);
 }
@@ -138,8 +142,11 @@
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_filename;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(filename, 1, -1, -1, __FUNCTION__)) return -EINVAL; /* No patterns allowed. */
-	if ((saved_filename = SaveName(filename)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(filename, 1, -1, -1, __func__))
+		return -EINVAL; /* No patterns allowed. */
+	saved_filename = SaveName(filename);
+	if (!saved_filename)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &globally_readable_list, list) {
 		if (ptr->filename == saved_filename) {
@@ -151,7 +158,9 @@
 	if (is_delete) {
 		error = -ENOENT; goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->filename = saved_filename;
 	list1_add_tail_mb(&new_entry->list, &globally_readable_list);
 	error = 0;
@@ -164,7 +173,8 @@
 {
 	struct globally_readable_file_entry *ptr;
 	list1_for_each_entry(ptr, &globally_readable_list, list) {
-		if (!ptr->is_deleted && !pathcmp(filename, ptr->filename)) return true;
+		if (!ptr->is_deleted && !pathcmp(filename, ptr->filename))
+			return true;
 	}
 	return false;
 }
@@ -180,8 +190,10 @@
 	list1_for_each_cookie(pos, head->read_var2, &globally_readable_list) {
 		struct globally_readable_file_entry *ptr;
 		ptr = list1_entry(pos, struct globally_readable_file_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_ALLOW_READ "%s\n", ptr->filename->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, KEYWORD_ALLOW_READ "%s\n", ptr->filename->name))
+			return -ENOMEM;
 	}
 	return 0;
 }
@@ -198,13 +210,17 @@
 	const struct path_info *saved_group_name, *saved_member_name;
 	int error = -ENOMEM;
 	bool found = false;
-	if (!IsCorrectPath(group_name, 0, 0, 0, __FUNCTION__) || !group_name[0] ||
-		!IsCorrectPath(member_name, 0, 0, 0, __FUNCTION__) || !member_name[0]) return -EINVAL;
-	if ((saved_group_name = SaveName(group_name)) == NULL ||
-		(saved_member_name = SaveName(member_name)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(group_name, 0, 0, 0, __func__) || !group_name[0] ||
+		!IsCorrectPath(member_name, 0, 0, 0, __func__) || !member_name[0])
+		return -EINVAL;
+	saved_group_name = SaveName(group_name);
+	saved_member_name = SaveName(member_name);
+	if (!saved_group_name || !saved_member_name)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(group, &path_group_list, list) {
-		if (saved_group_name != group->group_name) continue;
+		if (saved_group_name != group->group_name)
+			continue;
 		list1_for_each_entry(member, &group->path_group_member_list, list) {
 			if (member->member_name == saved_member_name) {
 				member->is_deleted = is_delete;
@@ -220,13 +236,17 @@
 		goto out;
 	}
 	if (!found) {
-		if ((new_group = alloc_element(sizeof(*new_group))) == NULL) goto out;
+		new_group = alloc_element(sizeof(*new_group));
+		if (!new_group)
+			goto out;
 		INIT_LIST1_HEAD(&new_group->path_group_member_list);
 		new_group->group_name = saved_group_name;
 		list1_add_tail_mb(&new_group->list, &path_group_list);
 		group = new_group;
 	}
-	if ((new_member = alloc_element(sizeof(*new_member))) == NULL) goto out;
+	new_member = alloc_element(sizeof(*new_member));
+	if (!new_member)
+		goto out;
 	new_member->member_name = saved_member_name;
 	list1_add_tail_mb(&new_member->list, &group->path_group_member_list);
 	error = 0;
@@ -238,7 +258,8 @@
 int AddPathGroupPolicy(char *data, const bool is_delete)
 {
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
 	return AddPathGroupEntry(data, cp, is_delete);
 }
@@ -249,7 +270,8 @@
 	struct path_group_entry *group;
 	for (i = 0; i <= 1; i++) {
 		list1_for_each_entry(group, &path_group_list, list) {
-			if (strcmp(group_name, group->group_name->name) == 0) return group;
+			if (strcmp(group_name, group->group_name->name) == 0)
+				return group;
 		}
 		if (i == 0) {
 			AddPathGroupEntry(group_name, "/", 0);
@@ -263,11 +285,14 @@
 {
 	struct path_group_member *member;
 	list1_for_each_entry(member, &group->path_group_member_list, list) {
-		if (member->is_deleted) continue;
+		if (member->is_deleted)
+			continue;
 		if (!member->member_name->is_patterned) {
-			if (!pathcmp(pathname, member->member_name)) return true;
+			if (!pathcmp(pathname, member->member_name))
+				return true;
 		} else if (may_use_pattern) {
-			if (PathMatchesToPattern(pathname, member->member_name)) return true;
+			if (PathMatchesToPattern(pathname, member->member_name))
+				return true;
 		}
 	}
 	return false;
@@ -283,8 +308,10 @@
 		list1_for_each_cookie(mpos, head->read_var2, &group->path_group_member_list) {
 			struct path_group_member *member;
 			member = list1_entry(mpos, struct path_group_member, list);
-			if (member->is_deleted) continue;
-			if (io_printf(head, KEYWORD_PATH_GROUP "%s %s\n", group->group_name->name, member->member_name->name)) return -ENOMEM;
+			if (member->is_deleted)
+				continue;
+			if (io_printf(head, KEYWORD_PATH_GROUP "%s %s\n", group->group_name->name, member->member_name->name))
+				return -ENOMEM;
 		}
 	}
 	return 0;
@@ -300,8 +327,11 @@
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_pattern;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(pattern, 0, 1, 0, __FUNCTION__)) return -EINVAL;
-	if ((saved_pattern = SaveName(pattern)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(pattern, 0, 1, 0, __func__))
+		return -EINVAL;
+	saved_pattern = SaveName(pattern);
+	if (!saved_pattern)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &pattern_list, list) {
 		if (saved_pattern == ptr->pattern) {
@@ -314,7 +344,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->pattern = saved_pattern;
 	list1_add_tail_mb(&new_entry->list, &pattern_list);
 	error = 0;
@@ -328,8 +360,10 @@
 	struct pattern_entry *ptr;
 	const struct path_info *pattern = NULL;
 	list1_for_each_entry(ptr, &pattern_list, list) {
-		if (ptr->is_deleted) continue;
-		if (!PathMatchesToPattern(filename, ptr->pattern)) continue;
+		if (ptr->is_deleted)
+			continue;
+		if (!PathMatchesToPattern(filename, ptr->pattern))
+			continue;
 		pattern = ptr->pattern;
 		if (strendswith(pattern->name, "/\\*")) {
 			/* Do nothing. Try to find the better match. */
@@ -338,7 +372,8 @@
 			break;
 		}
 	}
-	if (pattern) filename = pattern;
+	if (pattern)
+		filename = pattern;
 	return filename;
 }
 
@@ -353,8 +388,10 @@
 	list1_for_each_cookie(pos, head->read_var2, &pattern_list) {
 		struct pattern_entry *ptr;
 		ptr = list1_entry(pos, struct pattern_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_FILE_PATTERN "%s\n", ptr->pattern->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, KEYWORD_FILE_PATTERN "%s\n", ptr->pattern->name))
+			return -ENOMEM;
 	}
 	return 0;
 }
@@ -369,8 +406,11 @@
 	static DEFINE_MUTEX(lock);
 	const struct path_info *saved_pattern;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(pattern, 0, 0, 0, __FUNCTION__)) return -EINVAL;
-	if ((saved_pattern = SaveName(pattern)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(pattern, 0, 0, 0, __func__))
+		return -EINVAL;
+	saved_pattern = SaveName(pattern);
+	if (!saved_pattern)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &no_rewrite_list, list) {
 		if (ptr->pattern == saved_pattern) {
@@ -383,7 +423,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->pattern = saved_pattern;
 	list1_add_tail_mb(&new_entry->list, &no_rewrite_list);
 	error = 0;
@@ -396,8 +438,10 @@
 {
 	struct no_rewrite_entry *ptr;
 	list1_for_each_entry(ptr, &no_rewrite_list, list) {
-		if (ptr->is_deleted) continue;
-		if (!PathMatchesToPattern(filename, ptr->pattern)) continue;
+		if (ptr->is_deleted)
+			continue;
+		if (!PathMatchesToPattern(filename, ptr->pattern))
+			continue;
 		return true;
 	}
 	return false;
@@ -414,8 +458,10 @@
 	list1_for_each_cookie(pos, head->read_var2, &no_rewrite_list) {
 		struct no_rewrite_entry *ptr;
 		ptr = list1_entry(pos, struct no_rewrite_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_DENY_REWRITE "%s\n", ptr->pattern->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, KEYWORD_DENY_REWRITE "%s\n", ptr->pattern->name))
+			return -ENOMEM;
 	}
 	return 0;
 }
@@ -425,15 +471,18 @@
 static int AddFileACL(const char *filename, u8 perm, struct domain_info * const domain, const struct condition_list *condition, const bool is_delete)
 {
 	if (perm > 7 || !perm) {
-		printk(KERN_DEBUG "%s: Invalid permission '%d %s'\n", __FUNCTION__, perm, filename);
+		printk(KERN_DEBUG "%s: Invalid permission '%d %s'\n", __func__, perm, filename);
 		return -EINVAL;
 	}
 	if (filename[0] != '@' && strendswith(filename, "/")) {
 		return 0; /* Valid permissions for directory are only 'allow_mkdir' and 'allow_rmdir'. */
 	}
-	if (perm & 4) AddSinglePathACL(TYPE_READ_ACL, filename, domain, condition, is_delete);
-	if (perm & 2) AddSinglePathACL(TYPE_WRITE_ACL, filename, domain, condition, is_delete);
-	if (perm & 1) AddSinglePathACL(TYPE_EXECUTE_ACL, filename, domain, condition, is_delete);
+	if (perm & 4)
+		AddSinglePathACL(TYPE_READ_ACL, filename, domain, condition, is_delete);
+	if (perm & 2)
+		AddSinglePathACL(TYPE_WRITE_ACL, filename, domain, condition, is_delete);
+	if (perm & 1)
+		AddSinglePathACL(TYPE_EXECUTE_ACL, filename, domain, condition, is_delete);
 	return 0;
 }
 
@@ -443,13 +492,17 @@
 	struct acl_info *ptr;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct single_path_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SINGLE_PATH_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SINGLE_PATH_ACL)
+			continue;
 		acl = container_of(ptr, struct single_path_acl_record, head);
-		if (!(acl->perm & perm) || !CheckCondition(ptr, obj)) continue;
+		if (!(acl->perm & perm) || !CheckCondition(ptr, obj))
+			continue;
 		if (acl->u_is_group) {
-			if (!PathMatchesToGroup(filename, acl->u.group, may_use_pattern)) continue;
+			if (!PathMatchesToGroup(filename, acl->u.group, may_use_pattern))
+				continue;
 		} else if (may_use_pattern || !acl->u.filename->is_patterned) {
-			if (!PathMatchesToPattern(filename, acl->u.filename)) continue;
+			if (!PathMatchesToPattern(filename, acl->u.filename))
+				continue;
 		} else {
 			continue;
 		}
@@ -462,12 +515,18 @@
 static int CheckFileACL(const struct path_info *filename, const u8 operation, struct obj_info *obj)
 {
 	u16 perm = 0;
-	if (!CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE)) return 0;
-	if (operation == 6) perm = 1 << TYPE_READ_WRITE_ACL;
-	else if (operation == 4) perm = 1 << TYPE_READ_ACL;
-	else if (operation == 2) perm = 1 << TYPE_WRITE_ACL;
-	else if (operation == 1) perm = 1 << TYPE_EXECUTE_ACL;
-	else BUG();
+	if (!CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE))
+		return 0;
+	if (operation == 6)
+		perm = 1 << TYPE_READ_WRITE_ACL;
+	else if (operation == 4)
+		perm = 1 << TYPE_READ_ACL;
+	else if (operation == 2)
+		perm = 1 << TYPE_WRITE_ACL;
+	else if (operation == 1)
+		perm = 1 << TYPE_EXECUTE_ACL;
+	else
+		BUG();
 	return CheckSinglePathACL2(filename, perm, obj, operation != 1);
 }
 
@@ -477,20 +536,29 @@
 	const bool is_enforce = (mode == 3);
 	const char *msg = "<unknown>";
 	int error = 0;
-	if (!filename) return 0;
+	if (!filename)
+		return 0;
 	error = CheckFileACL(filename, perm, obj);
-	if (error && perm == 4 && (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ) == 0 && IsGloballyReadableFile(filename)) error = 0;
-	if (perm == 6) msg = sp_operation2keyword(TYPE_READ_WRITE_ACL);
-	else if (perm == 4) msg = sp_operation2keyword(TYPE_READ_ACL);
-	else if (perm == 2) msg = sp_operation2keyword(TYPE_WRITE_ACL);
-	else if (perm == 1) msg = sp_operation2keyword(TYPE_EXECUTE_ACL);
-	else BUG();
+	if (error && perm == 4 && (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ) == 0 && IsGloballyReadableFile(filename))
+		error = 0;
+	if (perm == 6)
+		msg = sp_operation2keyword(TYPE_READ_WRITE_ACL);
+	else if (perm == 4)
+		msg = sp_operation2keyword(TYPE_READ_ACL);
+	else if (perm == 2)
+		msg = sp_operation2keyword(TYPE_WRITE_ACL);
+	else if (perm == 1)
+		msg = sp_operation2keyword(TYPE_EXECUTE_ACL);
+	else
+		BUG();
 	AuditFileLog(msg, filename, NULL, !error, profile, mode, obj ? obj->bprm : NULL);
-	if (!error) return 0;
+	if (!error)
+		return 0;
 	if (TomoyoVerboseMode()) {
 		printk("TOMOYO-%s: Access '%s(%s) %s' denied for %s\n", GetMSG(is_enforce), msg, operation, filename->name, GetLastName(domain));
 	}
-	if (is_enforce) return CheckSupervisor("%s\nallow_%s %s\n", domain->domainname->name, msg, filename->name);
+	if (is_enforce)
+		return CheckSupervisor("%s\nallow_%s %s\n", domain->domainname->name, msg, filename->name);
 	else if (mode == 1 && CheckDomainQuota(domain)) {
 		/* Don't use patterns for execute permission. */
 		const struct path_info *patterned_file = (perm != 1) ? GetFilePattern(filename) : filename;
@@ -506,28 +574,37 @@
 	struct execute_handler_record *acl;
 	const u8 type = is_preferred ? TYPE_PREFERRED_EXECUTE_HANDLER : TYPE_DEFAULT_EXECUTE_HANDLER;
 	int error = -ENOMEM;
-	if (!domain) return -EINVAL;
-	if (!IsCorrectPath(filename, 1, -1, -1, __FUNCTION__)) return -EINVAL;
-	if ((saved_filename = SaveName(filename)) == NULL) return -ENOMEM;
+	if (!domain)
+		return -EINVAL;
+	if (!IsCorrectPath(filename, 1, -1, -1, __func__))
+		return -EINVAL;
+	saved_filename = SaveName(filename);
+	if (!saved_filename)
+		return -ENOMEM;
 	mutex_lock(&domain_acl_lock);
 	if (!is_delete) {
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_DELETED) != type) continue;
+			if ((ptr->type & ~ACL_DELETED) != type)
+				continue;
 			acl = container_of(ptr, struct execute_handler_record, head);
 			acl->handler = saved_filename;
 			error = AddDomainACL(NULL, ptr);
 			goto out;
 		}
 		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(type, NULL)) == NULL) goto out;
+		acl = alloc_acl_element(type, NULL);
+		if (!acl)
+			goto out;
 		acl->handler = saved_filename;
 		error = AddDomainACL(domain, &acl->head);
 	} else {
 		error = -ENOENT;
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_DELETED) != type) continue;
+			if ((ptr->type & ~ACL_DELETED) != type)
+				continue;
 			acl = container_of(ptr, struct execute_handler_record, head);
-			if (acl->handler != saved_filename) continue;
+			if (acl->handler != saved_filename)
+				continue;
 			error = DelDomainACL(ptr);
 			goto out;
 		}
@@ -543,7 +620,8 @@
 	char *filename2;
 	unsigned int perm;
 	u8 type;
-	if (!filename) return -EINVAL;
+	if (!filename)
+		return -EINVAL;
 	*filename++ = '\0';
 	if (sscanf(data, "%u", &perm) == 1) {
 		return AddFileACL(filename, (u8) perm, domain, condition, is_delete);
@@ -558,14 +636,17 @@
 	}
 	data += 6;
 	for (type = 0; type < MAX_SINGLE_PATH_OPERATION; type++) {
-		if (strcmp(data, sp_keyword[type])) continue;
+		if (strcmp(data, sp_keyword[type]))
+			continue;
 		return AddSinglePathACL(type, filename, domain, condition, is_delete);
 	}
 	filename2 = strchr(filename, ' ');
-	if (!filename2) goto out;
+	if (!filename2)
+		goto out;
 	*filename2++ = '\0';
 	for (type = 0; type < MAX_DOUBLE_PATH_OPERATION; type++) {
-		if (strcmp(data, dp_keyword[type])) continue;
+		if (strcmp(data, dp_keyword[type]))
+			continue;
 		return AddDoublePathACL(type, filename, filename2, domain, condition, is_delete);
 	}
  out:
@@ -581,31 +662,45 @@
 	int error = -ENOMEM;
 	bool is_group = false;
 	const u16 perm = 1 << type;
-	if (!domain) return -EINVAL;
-	if (!IsCorrectPath(filename, 0, 0, 0, __FUNCTION__)) return -EINVAL;
+	if (!domain)
+		return -EINVAL;
+	if (!IsCorrectPath(filename, 0, 0, 0, __func__))
+		return -EINVAL;
 	if (filename[0] == '@') {
 		/* This cast is OK because I don't dereference in this function. */
-		if ((saved_filename = (struct path_info *) FindOrAssignNewPathGroup(filename + 1)) == NULL) return -ENOMEM;
+		saved_filename = (struct path_info *) FindOrAssignNewPathGroup(filename + 1);
+		if (!saved_filename)
+			return -ENOMEM;
 		is_group = true;
 	} else {
-		if ((saved_filename = SaveName(filename)) == NULL) return -ENOMEM;
+		saved_filename = SaveName(filename);
+		if (!saved_filename)
+			return -ENOMEM;
 	}
 	mutex_lock(&domain_acl_lock);
 	if (!is_delete) {
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_SINGLE_PATH_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_SINGLE_PATH_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct single_path_acl_record, head);
-			if (acl->u.filename != saved_filename) continue;
-			if (ptr->type & ACL_DELETED) acl->perm = 0;
+			if (acl->u.filename != saved_filename)
+				continue;
+			if (ptr->type & ACL_DELETED)
+				acl->perm = 0;
 			acl->perm |= perm;
-			if ((acl->perm & rw_mask) == rw_mask) acl->perm |= 1 << TYPE_READ_WRITE_ACL;
-			else if (acl->perm & (1 << TYPE_READ_WRITE_ACL)) acl->perm |= rw_mask;
+			if ((acl->perm & rw_mask) == rw_mask)
+				acl->perm |= 1 << TYPE_READ_WRITE_ACL;
+			else if (acl->perm & (1 << TYPE_READ_WRITE_ACL))
+				acl->perm |= rw_mask;
 			error = AddDomainACL(NULL, ptr);
 			goto out;
 		}
 		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_SINGLE_PATH_ACL, condition)) == NULL) goto out;
+		acl = alloc_acl_element(TYPE_SINGLE_PATH_ACL, condition);
+		if (!acl)
+			goto out;
 		acl->perm = perm;
 		acl->u_is_group = is_group;
 		acl->u.filename = saved_filename;
@@ -613,13 +708,18 @@
 	} else {
 		error = -ENOENT;
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SINGLE_PATH_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_SINGLE_PATH_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct single_path_acl_record, head);
-			if (acl->u.filename != saved_filename) continue;
+			if (acl->u.filename != saved_filename)
+				continue;
 			acl->perm &= ~perm;
-			if ((acl->perm & rw_mask) != rw_mask) acl->perm &= ~(1 << TYPE_READ_WRITE_ACL);
-			else if (!(acl->perm & (1 << TYPE_READ_WRITE_ACL))) acl->perm &= ~rw_mask;
+			if ((acl->perm & rw_mask) != rw_mask)
+				acl->perm &= ~(1 << TYPE_READ_WRITE_ACL);
+			else if (!(acl->perm & (1 << TYPE_READ_WRITE_ACL)))
+				acl->perm &= ~rw_mask;
 			error = DelDomainACL(acl->perm ? NULL : ptr);
 			goto out;
 		}
@@ -637,36 +737,52 @@
 	int error = -ENOMEM;
 	bool is_group1 = false, is_group2 = false;
 	const u8 perm = 1 << type;
-	if (!domain) return -EINVAL;
-	if (!IsCorrectPath(filename1, 0, 0, 0, __FUNCTION__) || !IsCorrectPath(filename2, 0, 0, 0, __FUNCTION__)) return -EINVAL;
+	if (!domain)
+		return -EINVAL;
+	if (!IsCorrectPath(filename1, 0, 0, 0, __func__) || !IsCorrectPath(filename2, 0, 0, 0, __func__))
+		return -EINVAL;
 	if (filename1[0] == '@') {
 		/* This cast is OK because I don't dereference in this function. */
-		if ((saved_filename1 = (struct path_info *) FindOrAssignNewPathGroup(filename1 + 1)) == NULL) return -ENOMEM;
+		saved_filename1 = (struct path_info *) FindOrAssignNewPathGroup(filename1 + 1);
+		if (!saved_filename1)
+			return -ENOMEM;
 		is_group1 = true;
 	} else {
-		if ((saved_filename1 = SaveName(filename1)) == NULL) return -ENOMEM;
+		saved_filename1 = SaveName(filename1);
+		if (!saved_filename1)
+			return -ENOMEM;
 	}
 	if (filename2[0] == '@') {
 		/* This cast is OK because I don't dereference in this function. */
-		if ((saved_filename2 = (struct path_info *) FindOrAssignNewPathGroup(filename2 + 1)) == NULL) return -ENOMEM;
+		saved_filename2 = (struct path_info *) FindOrAssignNewPathGroup(filename2 + 1);
+		if (!saved_filename2)
+			return -ENOMEM;
 		is_group2 = true;
 	} else {
-		if ((saved_filename2 = SaveName(filename2)) == NULL) return -ENOMEM;
+		saved_filename2 = SaveName(filename2);
+		if (!saved_filename2)
+			return -ENOMEM;
 	}
 	mutex_lock(&domain_acl_lock);
 	if (!is_delete) {
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_DOUBLE_PATH_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_DOUBLE_PATH_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct double_path_acl_record, head);
-			if (acl->u1.filename1 != saved_filename1 || acl->u2.filename2 != saved_filename2) continue;
-			if (ptr->type & ACL_DELETED) acl->perm = 0;
+			if (acl->u1.filename1 != saved_filename1 || acl->u2.filename2 != saved_filename2)
+				continue;
+			if (ptr->type & ACL_DELETED)
+				acl->perm = 0;
 			acl->perm |= perm;
 			error = AddDomainACL(NULL, ptr);
 			goto out;
 		}
 		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_DOUBLE_PATH_ACL, condition)) == NULL) goto out;
+		acl = alloc_acl_element(TYPE_DOUBLE_PATH_ACL, condition);
+		if (!acl)
+			goto out;
 		acl->perm = perm;
 		acl->u1_is_group = is_group1;
 		acl->u2_is_group = is_group2;
@@ -676,10 +792,13 @@
 	} else {
 		error = -ENOENT;
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_DOUBLE_PATH_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_DOUBLE_PATH_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct double_path_acl_record, head);
-			if (acl->u1.filename1 != saved_filename1 || acl->u2.filename2 != saved_filename2) continue;
+			if (acl->u1.filename1 != saved_filename1 || acl->u2.filename2 != saved_filename2)
+				continue;
 			acl->perm &= ~perm;
 			error = DelDomainACL(acl->perm ? NULL : ptr);
 			break;
@@ -692,7 +811,8 @@
 
 static int CheckSinglePathACL(const u8 type, const struct path_info *filename, struct obj_info *obj)
 {
-	if (!CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE)) return 0;
+	if (!CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE))
+		return 0;
 	return CheckSinglePathACL2(filename, 1 << type, obj, 1);
 }
 
@@ -701,21 +821,28 @@
 	const struct domain_info *domain = current->domain_info;
 	struct acl_info *ptr;
 	const u8 perm = 1 << type;
-	if (!CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE)) return 0;
+	if (!CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE))
+		return 0;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct double_path_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_DOUBLE_PATH_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_DOUBLE_PATH_ACL)
+			continue;
 		acl = container_of(ptr, struct double_path_acl_record, head);
-		if (!(acl->perm & perm) || !CheckCondition(ptr, obj)) continue;
+		if (!(acl->perm & perm) || !CheckCondition(ptr, obj))
+			continue;
 		if (acl->u1_is_group) {
-			if (!PathMatchesToGroup(filename1, acl->u1.group1, 1)) continue;
+			if (!PathMatchesToGroup(filename1, acl->u1.group1, 1))
+				continue;
 		} else {
-			if (!PathMatchesToPattern(filename1, acl->u1.filename1)) continue;
+			if (!PathMatchesToPattern(filename1, acl->u1.filename1))
+				continue;
 		}
 		if (acl->u2_is_group) {
-			if (!PathMatchesToGroup(filename2, acl->u2.group2, 1)) continue;
+			if (!PathMatchesToGroup(filename2, acl->u2.group2, 1))
+				continue;
 		} else {
-			if (!PathMatchesToPattern(filename2, acl->u2.filename2)) continue;
+			if (!PathMatchesToPattern(filename2, acl->u2.filename2))
+				continue;
 		}
 		UpdateCondition(ptr);
 		return 0;
@@ -729,17 +856,22 @@
 	int error;
 	struct domain_info * const domain = current->domain_info;
 	const bool is_enforce = (mode == 3);
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	error = CheckSinglePathACL(operation, filename, obj);
 	msg = sp_operation2keyword(operation);
 	AuditFileLog(msg, filename, NULL, !error, profile, mode, NULL);
-	if (!error) goto next;
+	if (!error)
+		goto next;
 	if (TomoyoVerboseMode()) {
 		printk("TOMOYO-%s: Access '%s %s' denied for %s\n", GetMSG(is_enforce), msg, filename->name, GetLastName(domain));
 	}
-	if (is_enforce) error = CheckSupervisor("%s\nallow_%s %s\n", domain->domainname->name, msg, filename->name);
-	else if (mode == 1 && CheckDomainQuota(domain)) AddSinglePathACL(operation, GetFilePattern(filename)->name, domain, NULL, 0);
-	if (!is_enforce) error = 0;
+	if (is_enforce)
+		error = CheckSupervisor("%s\nallow_%s %s\n", domain->domainname->name, msg, filename->name);
+	else if (mode == 1 && CheckDomainQuota(domain))
+		AddSinglePathACL(operation, GetFilePattern(filename)->name, domain, NULL, 0);
+	if (!is_enforce)
+		error = 0;
  next:
 	if (!error && operation == TYPE_TRUNCATE_ACL && IsNoRewriteFile(filename)) {
 		error = CheckSinglePathPermission2(TYPE_REWRITE_ACL, filename, obj, profile, mode);
@@ -752,7 +884,8 @@
 	struct path_info filename;
 	const u8 profile = current->domain_info->profile;
 	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	filename.name = filename0;
 	fill_path_info(&filename);
 	return CheckFilePerm2(&filename, perm, operation, NULL, profile, mode);
@@ -763,7 +896,8 @@
 	struct obj_info obj;
 	const u8 profile = current->domain_info->profile;
 	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	memset(&obj, 0, sizeof(obj));
 	obj.path1_dentry = bprm->file->f_dentry;
 	obj.path1_vfsmnt = bprm->file->f_vfsmnt;
@@ -780,8 +914,10 @@
 	const u8 profile = current->domain_info->profile;
 	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
 	const bool is_enforce = (mode == 3);
-	if (!mode) return 0;
-	if (acc_mode == 0) return 0;
+	if (!mode)
+		return 0;
+	if (acc_mode == 0)
+		return 0;
 	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode)) {
 		/* I don't check directories here because mkdir() and rmdir() don't call me. */
 		return 0;
@@ -800,11 +936,14 @@
 				}
 			}
 		}
-		if (error == 0) error = CheckFilePerm2(buf, acc_mode, "open", &obj, profile, mode);
-		if (error == 0 && (flag & O_TRUNC)) error = CheckSinglePathPermission2(TYPE_TRUNCATE_ACL, buf, &obj, profile, mode);
+		if (error == 0)
+			error = CheckFilePerm2(buf, acc_mode, "open", &obj, profile, mode);
+		if (error == 0 && (flag & O_TRUNC))
+			error = CheckSinglePathPermission2(TYPE_TRUNCATE_ACL, buf, &obj, profile, mode);
 		ccs_free(buf);
 	}
-	if (!is_enforce) error = 0;
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
 
@@ -815,7 +954,8 @@
 	const u8 profile = current->domain_info->profile;
 	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
 	const bool is_enforce = (mode == 3);
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	buf = GetPath(dentry, mnt);
 	if (buf) {
 		struct obj_info obj;
@@ -833,7 +973,8 @@
 		error = CheckSinglePathPermission2(operation, buf, &obj, profile, mode);
 		ccs_free(buf);
 	}
-	if (!is_enforce) error = 0;
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
 EXPORT_SYMBOL(CheckSinglePathPermission);
@@ -857,7 +998,8 @@
 		}
 		ccs_free(buf);
 	}
-	if (!is_enforce) error = 0;
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
 
@@ -869,7 +1011,8 @@
 	const u8 profile = current->domain_info->profile;
 	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_FILE);
 	const bool is_enforce = (mode == 3);
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	buf1 = GetPath(dentry1, mnt1);
 	buf2 = GetPath(dentry2, mnt2);
 	if (buf1 && buf2) {
@@ -899,13 +1042,16 @@
 			if (TomoyoVerboseMode()) {
 				printk("TOMOYO-%s: Access '%s %s %s' denied for %s\n", GetMSG(is_enforce), msg, buf1->name, buf2->name, GetLastName(domain));
 			}
-			if (is_enforce) error = CheckSupervisor("%s\nallow_%s %s %s\n", domain->domainname->name, msg, buf1->name, buf2->name);
-			else if (mode == 1 && CheckDomainQuota(domain)) AddDoublePathACL(operation, GetFilePattern(buf1)->name, GetFilePattern(buf2)->name, domain, NULL, 0);
+			if (is_enforce)
+				error = CheckSupervisor("%s\nallow_%s %s %s\n", domain->domainname->name, msg, buf1->name, buf2->name);
+			else if (mode == 1 && CheckDomainQuota(domain))
+				AddDoublePathACL(operation, GetFilePattern(buf1)->name, GetFilePattern(buf2)->name, domain, NULL, 0);
 		}
 	}
 	ccs_free(buf1);
 	ccs_free(buf2);
-	if (!is_enforce) error = 0;
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c	(working copy)
@@ -63,8 +63,11 @@
 {
 	char *buf;
 	int len = 64;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
-	if ((buf = InitAuditLog(&len, profile, mode, NULL)) == NULL) return -ENOMEM;
+	if (CanSaveAuditLog(is_granted) < 0)
+		return -ENOMEM;
+	buf = InitAuditLog(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
 	snprintf(buf + strlen(buf), len - strlen(buf) - 1, KEYWORD_ALLOW_CAPABILITY "%s\n", cap_operation2keyword(operation));
 	return WriteAuditLog(buf, is_granted);
 }
@@ -76,28 +79,37 @@
 	struct acl_info *ptr;
 	struct capability_acl_record *acl;
 	int error = -ENOMEM;
-	if (!domain) return -EINVAL;
+	if (!domain)
+		return -EINVAL;
 	mutex_lock(&domain_acl_lock);
 	if (!is_delete) {
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_CAPABILITY_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_CAPABILITY_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct capability_acl_record, head);
-			if (acl->operation != operation) continue;
+			if (acl->operation != operation)
+				continue;
 			error = AddDomainACL(NULL, ptr);
 			goto out;
 		}
 		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_CAPABILITY_ACL, condition)) == NULL) goto out;
+		acl = alloc_acl_element(TYPE_CAPABILITY_ACL, condition);
+		if (!acl)
+			goto out;
 		acl->operation = operation;
 		error = AddDomainACL(domain, &acl->head);
 	} else {
 		error = -ENOENT;
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_CAPABILITY_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_CAPABILITY_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct capability_acl_record, head);
-			if (acl->operation != operation) continue;
+			if (acl->operation != operation)
+				continue;
 			error = DelDomainACL(ptr);
 			break;
 		}
@@ -115,23 +127,29 @@
 	const u8 mode = CheckCapabilityFlags(operation);
 	const bool is_enforce = (mode == 3);
 	bool found = false;
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct capability_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_CAPABILITY_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_CAPABILITY_ACL)
+			continue;
 		acl = container_of(ptr, struct capability_acl_record, head);
-		if (acl->operation != operation || !CheckCondition(ptr, NULL)) continue;
+		if (acl->operation != operation || !CheckCondition(ptr, NULL))
+			continue;
 		UpdateCondition(ptr);
 		found = true;
 		break;
 	}
 	AuditCapabilityLog(operation, found, profile, mode);
-	if (found) return 0;
+	if (found)
+		return 0;
 	if (TomoyoVerboseMode()) {
 		printk("TOMOYO-%s: %s denied for %s\n", GetMSG(is_enforce), cap_operation2name(operation), GetLastName(domain));
 	}
-	if (is_enforce) return CheckSupervisor("%s\n" KEYWORD_ALLOW_CAPABILITY "%s\n", domain->domainname->name, cap_operation2keyword(operation));
-	else if (mode == 1 && CheckDomainQuota(domain)) AddCapabilityACL(operation, domain, NULL, 0);
+	if (is_enforce)
+		return CheckSupervisor("%s\n" KEYWORD_ALLOW_CAPABILITY "%s\n", domain->domainname->name, cap_operation2keyword(operation));
+	else if (mode == 1 && CheckDomainQuota(domain))
+		AddCapabilityACL(operation, domain, NULL, 0);
 	return 0;
 }
 EXPORT_SYMBOL(CheckCapabilityACL);
@@ -140,7 +158,8 @@
 {
 	u8 capability;
 	for (capability = 0; capability < TOMOYO_MAX_CAPABILITY_INDEX; capability++) {
-		if (strcmp(data, cap_operation2keyword(capability))) continue;
+		if (strcmp(data, cap_operation2keyword(capability)))
+			continue;
 		return AddCapabilityACL(capability, domain, condition, is_delete);
 	}
 	return -EINVAL;
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(working copy)
@@ -44,7 +44,7 @@
 	while (argv_count || envp_count) {
 		struct page *page;
 		const char *kaddr;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 		if (get_user_pages(current, bprm->mm, pos, 1, 0, 1, &page, NULL) <= 0) {
 			*failed = true;
 			printk("get_user_pages() failed\n");
@@ -57,7 +57,7 @@
 		/* Map. */
 		kaddr = kmap(page);
 		if (!kaddr) { /* Mapping failed. */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 			put_page(page);
 #endif
 			*failed = true;
@@ -84,7 +84,8 @@
 			} else {
 				arg_ptr[arg_len] = '\0';
 			}
-			if (c) continue;
+			if (c)
+				continue;
 			/* Check. */
 			if (argv_count) {
 				if (is_argv && bprm->argc - argv_count == index) {
@@ -106,7 +107,8 @@
 						if (value) {
 							arg.name = cp + 1;
 							fill_path_info(&arg);
-							if (PathMatchesToPattern(&arg, value)) result = true;
+							if (PathMatchesToPattern(&arg, value))
+								result = true;
 						} else {
 							result = true;
 						}
@@ -116,7 +118,8 @@
 						}
 					}
 				}
-				if (--envp_count == 0) break;
+				if (--envp_count == 0)
+					break;
 			} else {
 				break;
 			}
@@ -124,7 +127,7 @@
 		}
 		/* Unmap. */
 		kunmap(page);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23) && defined(CONFIG_MMU)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23) && defined(CONFIG_MMU)
 		put_page(page);
 #endif
 		i++;
@@ -145,15 +148,18 @@
 	char *ep;
 	int base = 10;
 	if (*cp == '0') {
-		char c = * (cp + 1);
+		char c = *(cp + 1);
 		if (c == 'x' || c == 'X') {
-			base = 16; cp += 2;
+			base = 16;
+			cp += 2;
 		} else if (c >= '0' && c <= '7') {
-			base = 8; cp++;
+			base = 8;
+			cp++;
 		}
 	}
 	*result = simple_strtoul(cp, &ep, base);
-	if (cp == ep) return 0;
+	if (cp == ep)
+		return 0;
 	*str = ep;
 	return (base == 16 ? VALUE_TYPE_HEXADECIMAL : (base == 8 ? VALUE_TYPE_OCTAL : VALUE_TYPE_DECIMAL));
 }
@@ -253,30 +259,41 @@
 	unsigned long left_min = 0, left_max = 0, right_min = 0, right_max = 0;
 	const struct path_info *left_name = NULL, *right_name = NULL;
 	u8 post_state[4] = { 0, 0, 0, 0 };
-	if ((condition = strstr(condition, "; set ")) != NULL) {
+	condition = strstr(condition, "; set ");
+	if (condition) {
 		*condition = '\0';
 		condition += 6;
 		while (1) {
 			while (*condition == ' ') condition++;
-			if (!*condition) break;
-			if (strncmp(condition, "task.state[0]=", 14) == 0) i = 0;
-			else if (strncmp(condition, "task.state[1]=", 14) == 0) i = 1;
-			else if (strncmp(condition, "task.state[2]=", 14) == 0) i = 2;
-			else goto out;
+			if (!*condition)
+				break;
+			if (strncmp(condition, "task.state[0]=", 14) == 0)
+				i = 0;
+			else if (strncmp(condition, "task.state[1]=", 14) == 0)
+				i = 1;
+			else if (strncmp(condition, "task.state[2]=", 14) == 0)
+				i = 2;
+			else
+				goto out;
 			condition += 14;
-			if (post_state[3] & (1 << i)) goto out;
+			if (post_state[3] & (1 << i))
+				goto out;
 			post_state[3] |= 1 << i;
-			if (!parse_ulong(&right_min, &condition) || right_min > 255) goto out;
+			if (!parse_ulong(&right_min, &condition) || right_min > 255)
+				goto out;
 			post_state[i] = (u8) right_min;
 		}
 	}
 	condition = start;
-	if (strncmp(condition, "if ", 3) == 0) condition += 3;
-	else if (*condition) return NULL;
+	if (strncmp(condition, "if ", 3) == 0)
+		condition += 3;
+	else if (*condition)
+		return NULL;
 	start = condition;
 	while (1) {
 		while (*condition == ' ') condition++;
-		if (!*condition) break;
+		if (!*condition)
+			break;
 		for (left = 0; left < MAX_KEYWORD; left++) {
 			if (strncmp(condition, condition_control_keyword[left].keyword, condition_control_keyword[left].keyword_len) == 0) {
 				condition += condition_control_keyword[left].keyword_len;
@@ -284,8 +301,10 @@
 			}
 		}
 		if (left == EXEC_ARGV) {
-			if (!parse_ulong(&left_min, &condition)) goto out;
-			if (*condition++ != ']') goto out;
+			if (!parse_ulong(&left_min, &condition))
+				goto out;
+			if (*condition++ != ']')
+				goto out;
 			counter++; /* body */
 		} else if (left == EXEC_ENVP) {
 			char *tmp = condition;
@@ -295,50 +314,64 @@
 				 * Since environment variable names don't contain '=',
 				 * I can treat '"]=' and '"]!=' sequences as delimiters.
 				 */
-				if (strncmp(condition, "\"]=", 3) == 0 || strncmp(condition, "\"]!=", 4) == 0) break;
-				if (!c || c == ' ') goto out;
+				if (strncmp(condition, "\"]=", 3) == 0 || strncmp(condition, "\"]!=", 4) == 0)
+					break;
+				if (!c || c == ' ')
+					goto out;
 				condition++;
 			}
 			*condition = '\0';
-			if (!SaveName(tmp)) goto out;
+			if (!SaveName(tmp))
+				goto out;
 			counter++; /* body */
 			*condition = '"';
 			condition += 2;
 		} else if (left == MAX_KEYWORD) {
-			if (!parse_ulong(&left_min, &condition)) goto out;
+			if (!parse_ulong(&left_min, &condition))
+				goto out;
 			counter++; /* body */
 			if (*condition == '-') {
 				condition++;
-				if (!parse_ulong(&left_max, &condition) || left_min > left_max) goto out;
+				if (!parse_ulong(&left_max, &condition) || left_min > left_max)
+					goto out;
 				counter++; /* body */
 			}
 		}
-		if (strncmp(condition, "!=", 2) == 0) condition += 2;
-		else if (*condition == '=') condition++;
-		else goto out;
+		if (strncmp(condition, "!=", 2) == 0)
+			condition += 2;
+		else if (*condition == '=')
+			condition++;
+		else
+			goto out;
 		counter++; /* header */
 		if (left == EXEC_ENVP && strncmp(condition, "NULL", 4) == 0) {
 			char c;
 			condition += 4;
 			c = *condition;
 			counter++; /* body */
-			if (!c || c == ' ') continue;
+			if (!c || c == ' ')
+				continue;
 			goto out;
 		} else if (left == EXEC_ARGV || left == EXEC_ENVP) {
 			char c;
 			char *tmp;
-			if (*condition++ != '"') goto out;
+			if (*condition++ != '"')
+				goto out;
 			tmp = condition;
 			while (1) {
 				c = *condition++;
-				if (!c || c == ' ') goto out;
-				if (c != '"') continue;
+				if (!c || c == ' ')
+					goto out;
+				if (c != '"')
+					continue;
 				c = *condition;
-				if (!c || c == ' ') break;
+				if (!c || c == ' ')
+					break;
 			}
 			c = *--condition;
 			*condition = '\0';
-			if (!SaveName(tmp)) goto out;
+			if (!SaveName(tmp))
+				goto out;
 			counter++; /* body */
 			*condition = c;
 			condition++;
@@ -351,18 +384,21 @@
 			}
 		}
 		if (right == MAX_KEYWORD) {
-			if (!parse_ulong(&right_min, &condition)) goto out;
+			if (!parse_ulong(&right_min, &condition))
+				goto out;
 			counter++; /* body */
 			if (*condition == '-') {
 				condition++;
-				if (!parse_ulong(&right_max, &condition) || right_min > right_max) goto out;
+				if (!parse_ulong(&right_max, &condition) || right_min > right_max)
+					goto out;
 				counter++; /* body */
 			}
 		}
 	}
 	size = sizeof(*new_ptr) + counter * sizeof(union element);
 	new_ptr = ccs_alloc(size);
-	if (!new_ptr) return NULL;
+	if (!new_ptr)
+		return NULL;
 	new_ptr->length = counter;
 	for (i = 0; i < 4; i++) new_ptr->post_state[i] = post_state[i];
 	ptr2 = (union element *) (((u8 *) new_ptr) + sizeof(*new_ptr));
@@ -370,7 +406,8 @@
 	while (1) {
 		unsigned int match = 0;
 		while (*condition == ' ') condition++;
-		if (!*condition) break;
+		if (!*condition)
+			break;
 		for (left = 0; left < MAX_KEYWORD; left++) {
 			if (strncmp(condition, condition_control_keyword[left].keyword, condition_control_keyword[left].keyword_len) == 0) {
 				condition += condition_control_keyword[left].keyword_len;
@@ -378,8 +415,10 @@
 			}
 		}
 		if (left == EXEC_ARGV) {
-			if (!parse_ulong(&left_min, &condition)) goto out;
-			if (*condition++ != ']') goto out;
+			if (!parse_ulong(&left_min, &condition))
+				goto out;
+			if (*condition++ != ']')
+				goto out;
 			counter--; /* body */
 		} else if (left == EXEC_ENVP) {
 			char *tmp = condition;
@@ -389,8 +428,10 @@
 				 * Since environment variable names don't contain '=',
 				 * I can treat "\"]=" and "\"]!=" sequences as delimiters.
 				 */
-				if (strncmp(condition, "\"]=", 3) == 0 || strncmp(condition, "\"]!=", 4) == 0) break;
-				if (!c || c == ' ') goto out;
+				if (strncmp(condition, "\"]=", 3) == 0 || strncmp(condition, "\"]!=", 4) == 0)
+					break;
+				if (!c || c == ' ')
+					goto out;
 				condition++;
 			}
 			*condition = '\0';
@@ -412,7 +453,8 @@
 		if (strncmp(condition, "!=", 2) == 0) {
 			condition += 2;
 		} else if (*condition == '=') {
-			match |= 1; condition++;
+			match |= 1;
+			condition++;
 		} else {
 			goto out2;
 		}
@@ -423,20 +465,25 @@
 			right_name = NULL;
 			counter--; /* body */
 			c = *condition;
-			if (c && c != ' ') goto out;
+			if (c && c != ' ')
+				goto out;
 			right = 0;
 			goto skip_right;
 		} else if (left == EXEC_ARGV || left == EXEC_ENVP) {
 			char c;
 			char *tmp;
-			if (*condition++ != '"') goto out;
+			if (*condition++ != '"')
+				goto out;
 			tmp = condition;
 			while (1) {
 				c = *condition++;
-				if (!c || c == ' ') goto out;
-				if (c != '"') continue;
+				if (!c || c == ' ')
+					goto out;
+				if (c != '"')
+					continue;
 				c = *condition;
-				if (!c || c == ' ') break;
+				if (!c || c == ' ')
+					break;
 			}
 			c = *--condition;
 			*condition = '\0';
@@ -471,13 +518,34 @@
 		}
 		ptr2->value = (match << 16) | (left << 8) | right;
 		ptr2++;
-		if (left == EXEC_ARGV) { ptr2->value = left_min; ptr2++; }
-		if (left == EXEC_ENVP) { ptr2->string = left_name; ptr2++; }
-		if (left == EXEC_ARGV || left == EXEC_ENVP) { ptr2->string = right_name; ptr2++; }
-		if (left >= MAX_KEYWORD) { ptr2->value = left_min; ptr2++; }
-		if (left == MAX_KEYWORD + 1) { ptr2->value = left_max; ptr2++; }
-		if (right >= MAX_KEYWORD) { ptr2->value = right_min; ptr2++; }
-		if (right == MAX_KEYWORD + 1) { ptr2->value = right_max; ptr2++; }
+		if (left == EXEC_ARGV) {
+			ptr2->value = left_min;
+			ptr2++;
+		}
+		if (left == EXEC_ENVP) {
+			ptr2->string = left_name;
+			ptr2++;
+		}
+		if (left == EXEC_ARGV || left == EXEC_ENVP) {
+			ptr2->string = right_name;
+			ptr2++;
+		}
+		if (left >= MAX_KEYWORD) {
+			ptr2->value = left_min;
+			ptr2++;
+		}
+		if (left == MAX_KEYWORD + 1) {
+			ptr2->value = left_max;
+			ptr2++;
+		}
+		if (right >= MAX_KEYWORD) {
+			ptr2->value = right_min;
+			ptr2++;
+		}
+		if (right == MAX_KEYWORD + 1) {
+			ptr2->value = right_max;
+			ptr2++;
+		}
 	}
 	WARN_ON(counter);
 	{
@@ -486,9 +554,11 @@
 		mutex_lock(&lock);
 		list1_for_each_entry(ptr, &condition_list, list) {
 			/* Don't compare if size differs. */
-			if (ptr->length != new_ptr->length) continue;
+			if (ptr->length != new_ptr->length)
+				continue;
 			/* Compare ptr and new_ptr except ptr->list and new_ptr->list . */
-			if (memcmp(((u8 *) ptr) + sizeof(ptr->list), ((u8 *) new_ptr) + sizeof(new_ptr->list), size - sizeof(ptr->list))) continue;
+			if (memcmp(((u8 *) ptr) + sizeof(ptr->list), ((u8 *) new_ptr) + sizeof(new_ptr->list), size - sizeof(ptr->list)))
+				continue;
 			/* Same entry found. Share this entry. */
 			ccs_free(new_ptr);
 			new_ptr = ptr;
@@ -503,24 +573,25 @@
 		}
 		ccs_free(new_ptr);
 		new_ptr = ptr;
-	ok:
+ok:
 		mutex_unlock(&lock);
 	}
 	return new_ptr;
- out2:
+out2:
 	ccs_free(new_ptr);
- out:
+out:
 	return NULL;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 static void GetAttributes(struct obj_info *obj)
 {
 	struct dentry *dentry;
 	struct inode *inode;
 
 	dentry = obj->path1_dentry;
-	if ((inode = dentry->d_inode) != NULL) {
+	inode = dentry->d_inode;
+	if (inode) {
 		if (inode->i_op && inode->i_op->revalidate && inode->i_op->revalidate(dentry)) {
 			/* Nothing to do. */
 		} else {
@@ -601,7 +672,8 @@
 	}
 	dput(dentry);
 
-	if ((mnt = obj->path2_vfsmnt) != NULL) {
+	mnt = obj->path2_vfsmnt;
+	if (mnt) {
 		dentry = dget_parent(obj->path2_dentry);
 		inode = dentry->d_inode;
 		if (inode) {
@@ -628,7 +700,8 @@
 	const struct condition_list *ptr = GetConditionPart(acl);
 	struct linux_binprm *bprm;
 	bool failed = false;
-	if (!ptr) return true;
+	if (!ptr)
+		return true;
 	bprm = obj->bprm;
 	ptr2 = (union element *) (((u8 *) ptr) + sizeof(*ptr));
 	for (i = 0; i < ptr->length; i++) {
@@ -639,143 +712,283 @@
 			bool result;
 			unsigned long index;
 			const struct path_info *value;
-			index = ptr2->value; ptr2++; i++;
-			value = ptr2->string; ptr2++; i++;
-			if (!bprm) goto out;
+			index = ptr2->value;
+			ptr2++;
+			i++;
+			value = ptr2->string;
+			ptr2++;
+			i++;
+			if (!bprm)
+				goto out;
 			result = ScanBprm(bprm, true, index, NULL, value, &failed, obj->tmp);
-			if (failed) goto out;
-			if (!match) result = !result;
-			if (result) continue;
+			if (failed)
+				goto out;
+			if (!match)
+				result = !result;
+			if (result)
+				continue;
 			goto out;
 		} else if (left == EXEC_ENVP) {
 			bool result;
 			const struct path_info *name, *value;
-			name = ptr2->string; ptr2++; i++;
-			value = ptr2->string; ptr2++; i++;
-			if (!bprm) goto out;
+			name = ptr2->string;
+			ptr2++;
+			i++;
+			value = ptr2->string;
+			ptr2++;
+			i++;
+			if (!bprm)
+				goto out;
 			result = ScanBprm(bprm, false, 0, name, value, &failed, obj->tmp);
-			if (failed) goto out;
+			if (failed)
+				goto out;
 			if (value) {
-				if (!match) result = !result;
+				if (!match)
+					result = !result;
 			} else {
-				if (match) result = !result;
+				if (match)
+					result = !result;
 			}
-			if (result) continue;
+			if (result)
+				continue;
 			goto out;
 		}
 		if ((left >= PATH1_UID && left < MAX_KEYWORD) || (right >= PATH1_UID && right < MAX_KEYWORD)) {
-			if (!obj) goto out;
+			if (!obj)
+				goto out;
 			if (!obj->validate_done) {
 				GetAttributes(obj);
 				obj->validate_done = true;
 			}
 		}
 		switch (left) {
-		case TASK_UID:   left_min = left_max = task->uid; break;
-		case TASK_EUID:  left_min = left_max = task->euid; break;
-		case TASK_SUID:  left_min = left_max = task->suid; break;
-		case TASK_FSUID: left_min = left_max = task->fsuid; break;
-		case TASK_GID:   left_min = left_max = task->gid; break;
-		case TASK_EGID:  left_min = left_max = task->egid; break;
-		case TASK_SGID:  left_min = left_max = task->sgid; break;
-		case TASK_FSGID: left_min = left_max = task->fsgid; break;
-		case TASK_PID:   left_min = left_max = task->pid; break;
-		case TASK_PPID:  left_min = left_max = sys_getppid(); break;
+		case TASK_UID:
+			left_min = left_max = task->uid;
+			break;
+		case TASK_EUID:
+			left_min = left_max = task->euid;
+			break;
+		case TASK_SUID:
+			left_min = left_max = task->suid;
+			break;
+		case TASK_FSUID:
+			left_min = left_max = task->fsuid;
+			break;
+		case TASK_GID:
+			left_min = left_max = task->gid;
+			break;
+		case TASK_EGID:
+			left_min = left_max = task->egid;
+			break;
+		case TASK_SGID:
+			left_min = left_max = task->sgid;
+			break;
+		case TASK_FSGID:
+			left_min = left_max = task->fsgid;
+			break;
+		case TASK_PID:
+			left_min = left_max = task->pid;
+			break;
+		case TASK_PPID:
+			left_min = left_max = sys_getppid();
+			break;
 		case PATH1_UID:
-			if (!obj->path1_valid) goto out;
-			left_min = left_max = obj->path1_stat.uid; break;
+			if (!obj->path1_valid)
+				goto out;
+			left_min = left_max = obj->path1_stat.uid;
+			break;
 		case PATH1_GID:
-			if (!obj->path1_valid) goto out;
-			left_min = left_max = obj->path1_stat.gid; break;
+			if (!obj->path1_valid)
+				goto out;
+			left_min = left_max = obj->path1_stat.gid;
+			break;
 		case PATH1_INO:
-			if (!obj->path1_valid) goto out;
-			left_min = left_max = obj->path1_stat.ino; break;
+			if (!obj->path1_valid)
+				goto out;
+			left_min = left_max = obj->path1_stat.ino;
+			break;
 		case PATH1_PARENT_UID:
-			if (!obj->path1_parent_valid) goto out;
-			left_min = left_max = obj->path1_parent_stat.uid; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			left_min = left_max = obj->path1_parent_stat.uid;
+			break;
 		case PATH1_PARENT_GID:
-			if (!obj->path1_parent_valid) goto out;
-			left_min = left_max = obj->path1_parent_stat.gid; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			left_min = left_max = obj->path1_parent_stat.gid;
+			break;
 		case PATH1_PARENT_INO:
-			if (!obj->path1_parent_valid) goto out;
-			left_min = left_max = obj->path1_parent_stat.ino; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			left_min = left_max = obj->path1_parent_stat.ino;
+			break;
 		case PATH2_PARENT_UID:
-			if (!obj->path2_parent_valid) goto out;
-			left_min = left_max = obj->path2_parent_stat.uid; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			left_min = left_max = obj->path2_parent_stat.uid;
+			break;
 		case PATH2_PARENT_GID:
-			if (!obj->path2_parent_valid) goto out;
-			left_min = left_max = obj->path2_parent_stat.gid; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			left_min = left_max = obj->path2_parent_stat.gid;
+			break;
 		case PATH2_PARENT_INO:
-			if (!obj->path2_parent_valid) goto out;
-			left_min = left_max = obj->path2_parent_stat.ino; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			left_min = left_max = obj->path2_parent_stat.ino;
+			break;
 		case EXEC_ARGC:
-			if (!bprm) goto out;
-			left_min = left_max = bprm->argc; i++; break;
+			if (!bprm)
+				goto out;
+			left_min = left_max = bprm->argc;
+			i++;
+			break;
 		case EXEC_ENVC:
-			if (!bprm) goto out;
-			left_min = left_max = bprm->envc; i++; break;
-		case TASK_STATE_0: left_min = left_max = (u8) (task->tomoyo_flags >> 24); break;
-		case TASK_STATE_1: left_min = left_max = (u8) (task->tomoyo_flags >> 16); break;
-		case TASK_STATE_2: left_min = left_max = (u8) (task->tomoyo_flags >> 8); break;
-		case MAX_KEYWORD:     left_min = left_max = ptr2->value; ptr2++; i++; break;
-		case MAX_KEYWORD + 1: left_min = ptr2->value; ptr2++; left_max = ptr2->value; ptr2++; i += 2; break;
+			if (!bprm)
+				goto out;
+			left_min = left_max = bprm->envc;
+			i++;
+			break;
+		case TASK_STATE_0:
+			left_min = left_max = (u8) (task->tomoyo_flags >> 24);
+			break;
+		case TASK_STATE_1:
+			left_min = left_max = (u8) (task->tomoyo_flags >> 16);
+			break;
+		case TASK_STATE_2:
+			left_min = left_max = (u8) (task->tomoyo_flags >> 8);
+			break;
+		case MAX_KEYWORD:
+			left_min = left_max = ptr2->value;
+			ptr2++;
+			i++;
+			break;
+		case MAX_KEYWORD + 1:
+			left_min = ptr2->value;
+			ptr2++;
+			left_max = ptr2->value;
+			ptr2++;
+			i += 2;
+			break;
 		}
 		switch (right) {
-		case TASK_UID:   right_min = right_max = task->uid; break;
-		case TASK_EUID:  right_min = right_max = task->euid; break;
-		case TASK_SUID:  right_min = right_max = task->suid; break;
-		case TASK_FSUID: right_min = right_max = task->fsuid; break;
-		case TASK_GID:   right_min = right_max = task->gid; break;
-		case TASK_EGID:  right_min = right_max = task->egid; break;
-		case TASK_SGID:  right_min = right_max = task->sgid; break;
-		case TASK_FSGID: right_min = right_max = task->fsgid; break;
-		case TASK_PID:   right_min = right_max = task->pid; break;
-		case TASK_PPID:  right_min = right_max = sys_getppid(); break;
+		case TASK_UID:
+			right_min = right_max = task->uid;
+			break;
+		case TASK_EUID:
+			right_min = right_max = task->euid;
+			break;
+		case TASK_SUID:
+			right_min = right_max = task->suid;
+			break;
+		case TASK_FSUID:
+			right_min = right_max = task->fsuid;
+			break;
+		case TASK_GID:
+			right_min = right_max = task->gid;
+			break;
+		case TASK_EGID:
+			right_min = right_max = task->egid;
+			break;
+		case TASK_SGID:
+			right_min = right_max = task->sgid;
+			break;
+		case TASK_FSGID:
+			right_min = right_max = task->fsgid;
+			break;
+		case TASK_PID:
+			right_min = right_max = task->pid;
+			break;
+		case TASK_PPID:
+			right_min = right_max = sys_getppid();
+			break;
 		case PATH1_UID:
-			if (!obj->path1_valid) goto out;
-			right_min = right_max = obj->path1_stat.uid; break;
+			if (!obj->path1_valid)
+				goto out;
+			right_min = right_max = obj->path1_stat.uid;
+			break;
 		case PATH1_GID:
-			if (!obj->path1_valid) goto out;
-			right_min = right_max = obj->path1_stat.gid; break;
+			if (!obj->path1_valid)
+				goto out;
+			right_min = right_max = obj->path1_stat.gid;
+			break;
 		case PATH1_INO:
-			if (!obj->path1_valid) goto out;
-			right_min = right_max = obj->path1_stat.ino; break;
+			if (!obj->path1_valid)
+				goto out;
+			right_min = right_max = obj->path1_stat.ino;
+			break;
 		case PATH1_PARENT_UID:
-			if (!obj->path1_parent_valid) goto out;
-			right_min = right_max = obj->path1_parent_stat.uid; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			right_min = right_max = obj->path1_parent_stat.uid;
+			break;
 		case PATH1_PARENT_GID:
-			if (!obj->path1_parent_valid) goto out;
-			right_min = right_max = obj->path1_parent_stat.gid; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			right_min = right_max = obj->path1_parent_stat.gid;
+			break;
 		case PATH1_PARENT_INO:
-			if (!obj->path1_parent_valid) goto out;
-			right_min = right_max = obj->path1_parent_stat.ino; break;
+			if (!obj->path1_parent_valid)
+				goto out;
+			right_min = right_max = obj->path1_parent_stat.ino;
+			break;
 		case PATH2_PARENT_UID:
-			if (!obj->path2_parent_valid) goto out;
-			right_min = right_max = obj->path2_parent_stat.uid; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			right_min = right_max = obj->path2_parent_stat.uid;
+			break;
 		case PATH2_PARENT_GID:
-			if (!obj->path2_parent_valid) goto out;
-			right_min = right_max = obj->path2_parent_stat.gid; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			right_min = right_max = obj->path2_parent_stat.gid;
+			break;
 		case PATH2_PARENT_INO:
-			if (!obj->path2_parent_valid) goto out;
-			right_min = right_max = obj->path2_parent_stat.ino; break;
+			if (!obj->path2_parent_valid)
+				goto out;
+			right_min = right_max = obj->path2_parent_stat.ino;
+			break;
 		case EXEC_ARGC:
-			if (!bprm) goto out;
-			right_min = right_max = bprm->argc; i++; break;
+			if (!bprm)
+				goto out;
+			right_min = right_max = bprm->argc;
+			i++;
+			break;
 		case EXEC_ENVC:
-			if (!bprm) goto out;
-			right_min = right_max = bprm->envc; i++; break;
-		case TASK_STATE_0: right_min = right_max = (u8) (task->tomoyo_flags >> 24); break;
-		case TASK_STATE_1: right_min = right_max = (u8) (task->tomoyo_flags >> 16); break;
-		case TASK_STATE_2: right_min = right_max = (u8) (task->tomoyo_flags >> 8); break;
-		case MAX_KEYWORD:     right_min = right_max = ptr2->value; ptr2++; i++; break;
-		case MAX_KEYWORD + 1: right_min = ptr2->value; ptr2++; right_max = ptr2->value; ptr2++; i += 2; break;
+			if (!bprm)
+				goto out;
+			right_min = right_max = bprm->envc;
+			i++;
+			break;
+		case TASK_STATE_0:
+			right_min = right_max = (u8) (task->tomoyo_flags >> 24);
+			break;
+		case TASK_STATE_1:
+			right_min = right_max = (u8) (task->tomoyo_flags >> 16);
+			break;
+		case TASK_STATE_2:
+			right_min = right_max = (u8) (task->tomoyo_flags >> 8);
+			break;
+		case MAX_KEYWORD:
+			right_min = right_max = ptr2->value;
+			ptr2++;
+			i++;
+			break;
+		case MAX_KEYWORD + 1:
+			right_min = ptr2->value;
+			ptr2++;
+			right_max = ptr2->value;
+			ptr2++;
+			i += 2;
+			break;
 		}
 		if (match) {
-			if (left_min <= right_max && left_max >= right_min) continue;
+			if (left_min <= right_max && left_max >= right_min)
+				continue;
 		} else {
-			if (left_min > right_max || left_max < right_min) continue;
+			if (left_min > right_max || left_max < right_min)
+				continue;
 		}
-	out:
+out:
 		return false;
 	}
 	return true;
@@ -789,12 +1002,22 @@
 	struct task_struct *task;
 	u32 tomoyo_flags = current->tomoyo_flags;
 	const u8 flags = ptr ? ptr->post_state[3] : 0;
-	if (!flags) return;
+	if (!flags)
+		return;
 	task = current;
 	tomoyo_flags = task->tomoyo_flags;
-	if (flags & 1) { tomoyo_flags &= ~0xFF000000; tomoyo_flags |= ptr->post_state[0] << 24; }
-	if (flags & 2) { tomoyo_flags &= ~0x00FF0000; tomoyo_flags |= ptr->post_state[1] << 16; }
-	if (flags & 4) { tomoyo_flags &= ~0x0000FF00; tomoyo_flags |= ptr->post_state[2] << 8; }
+	if (flags & 1) {
+		tomoyo_flags &= ~0xFF000000;
+		tomoyo_flags |= ptr->post_state[0] << 24;
+	}
+	if (flags & 2) {
+		tomoyo_flags &= ~0x00FF0000;
+		tomoyo_flags |= ptr->post_state[1] << 16;
+	}
+	if (flags & 4) {
+		tomoyo_flags &= ~0x0000FF00;
+		tomoyo_flags |= ptr->post_state[2] << 8;
+	}
 	task->tomoyo_flags = tomoyo_flags;
 }
 
@@ -809,56 +1032,79 @@
 			const u16 match = (ptr2->value) >> 16;
 			const u8 left = (ptr2->value) >> 8, right = ptr2->value;
 			ptr2++;
-			if (io_printf(head, "%s", i ? " " : " if ")) break;
+			if (io_printf(head, "%s", i ? " " : " if "))
+				break;
 			if (left == EXEC_ARGV) {
-				unsigned long index = ptr2->value; ptr2++;
-				if (io_printf(head, "%s%lu]", condition_control_keyword[left].keyword, index)) break;
+				unsigned long index = ptr2->value;
+				ptr2++;
+				if (io_printf(head, "%s%lu]", condition_control_keyword[left].keyword, index))
+					break;
 				i++;
 			} else if (left == EXEC_ENVP) {
-				const struct path_info *name = ptr2->string; ptr2++;
-				if (io_printf(head, "%s%s\"]", condition_control_keyword[left].keyword, name->name)) break;
+				const struct path_info *name = ptr2->string;
+				ptr2++;
+				if (io_printf(head, "%s%s\"]", condition_control_keyword[left].keyword, name->name))
+					break;
 				i++;
 			} else if (left < MAX_KEYWORD) {
-				if (io_printf(head, "%s", condition_control_keyword[left].keyword)) break;
+				if (io_printf(head, "%s", condition_control_keyword[left].keyword))
+					break;
 			} else {
-				print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 2) & 3); ptr2++;
-				if (io_printf(head, "%s", buffer)) break;
+				print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 2) & 3);
+				ptr2++;
+				if (io_printf(head, "%s", buffer))
+					break;
 				i++;
 				if (left == MAX_KEYWORD + 1) {
-					print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 4) & 3); ptr2++;
-					if (io_printf(head, "-%s", buffer)) break;
+					print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 4) & 3);
+					ptr2++;
+					if (io_printf(head, "-%s", buffer))
+						break;
 					i++;
 				}
 			}
-			if (io_printf(head, "%s", (match & 1) ? "=" : "!=")) break;
+			if (io_printf(head, "%s", (match & 1) ? "=" : "!="))
+				break;
 			if (left == EXEC_ARGV || left == EXEC_ENVP) {
-				const struct path_info *name = ptr2->string; ptr2++;
+				const struct path_info *name = ptr2->string;
+				ptr2++;
 				if (name) {
-					if (io_printf(head, "\"%s\"", name->name)) break;
+					if (io_printf(head, "\"%s\"", name->name))
+						break;
 				} else {
-					if (io_printf(head, "NULL")) break;
+					if (io_printf(head, "NULL"))
+						break;
 				}
 				i++;
 			} else if (right < MAX_KEYWORD) {
-				if (io_printf(head, "%s", condition_control_keyword[right].keyword)) break;
+				if (io_printf(head, "%s", condition_control_keyword[right].keyword))
+					break;
 			} else {
-				print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 6) & 3); ptr2++;
-				if (io_printf(head, "%s", buffer)) break;
+				print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 6) & 3);
+				ptr2++;
+				if (io_printf(head, "%s", buffer))
+					break;
 				i++;
 				if (right == MAX_KEYWORD + 1) {
-					print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 8) & 3); ptr2++;
-					if (io_printf(head, "-%s", buffer)) break;
+					print_ulong(buffer, sizeof(buffer) - 1, ptr2->value, (match >> 8) & 3);
+					ptr2++;
+					if (io_printf(head, "-%s", buffer))
+						break;
 					i++;
 				}
 			}
 		}
-		if (i < ptr->length) return -ENOMEM;
-		if ((i = ptr->post_state[3]) != 0) {
+		if (i < ptr->length)
+			return -ENOMEM;
+		i = ptr->post_state[3];
+		if (i) {
 			unsigned int j;
-			if (io_printf(head, " ; set")) return -ENOMEM;
+			if (io_printf(head, " ; set"))
+				return -ENOMEM;
 			for (j = 0; j < 3; j++) {
 				if (i & (1 << j)) {
-					if (io_printf(head, " task.state[%u]=%u", j, ptr->post_state[j])) return -ENOMEM;
+					if (io_printf(head, " task.state[%u]=%u", j, ptr->post_state[j]))
+						return -ENOMEM;
 				}
 			}
 		}
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c	(working copy)
@@ -23,9 +23,12 @@
 {
 	char *buf;
 	int len;
-	if (CanSaveAuditLog(is_granted) < 0) return -ENOMEM;
+	if (CanSaveAuditLog(is_granted) < 0)
+		return -ENOMEM;
 	len = filename->total_len + strlen(argv0) + 8;
-	if ((buf = InitAuditLog(&len, profile, mode, NULL)) == NULL) return -ENOMEM;
+	buf = InitAuditLog(&len, profile, mode, NULL);
+	if (!buf)
+		return -ENOMEM;
 	snprintf(buf + strlen(buf), len - strlen(buf) - 1, KEYWORD_ALLOW_ARGV0 "%s %s\n", filename->name, argv0);
 	return WriteAuditLog(buf, is_granted);
 }
@@ -38,30 +41,42 @@
 	struct argv0_acl_record *acl;
 	const struct path_info *saved_filename, *saved_argv0;
 	int error = -ENOMEM;
-	if (!IsCorrectPath(filename, 1, 0, -1, __FUNCTION__) || !IsCorrectPath(argv0, -1, 0, -1, __FUNCTION__) || strchr(argv0, '/')) return -EINVAL;
-	if ((saved_filename = SaveName(filename)) == NULL || (saved_argv0 = SaveName(argv0)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(filename, 1, 0, -1, __func__) || !IsCorrectPath(argv0, -1, 0, -1, __func__) || strchr(argv0, '/'))
+		return -EINVAL;
+	saved_filename = SaveName(filename);
+	saved_argv0 = SaveName(argv0);
+	if (!saved_filename || !saved_argv0)
+		return -ENOMEM;
 	mutex_lock(&domain_acl_lock);
 	if (!is_delete) {
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_ARGV0_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION)) != TYPE_ARGV0_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct argv0_acl_record, head);
-			if (acl->filename != saved_filename || acl->argv0 != saved_argv0) continue;
+			if (acl->filename != saved_filename || acl->argv0 != saved_argv0)
+				continue;
 			error = AddDomainACL(NULL, ptr);
 			goto out;
 		}
 		/* Not found. Append it to the tail. */
-		if ((acl = alloc_acl_element(TYPE_ARGV0_ACL, condition)) == NULL) goto out;
+		acl = alloc_acl_element(TYPE_ARGV0_ACL, condition);
+		if (!acl)
+			goto out;
 		acl->filename = saved_filename;
 		acl->argv0 = saved_argv0;
 		error = AddDomainACL(domain, &acl->head);
 	} else {
 		error = -ENOENT;
 		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ARGV0_ACL) continue;
-			if (GetConditionPart(ptr) != condition) continue;
+			if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ARGV0_ACL)
+				continue;
+			if (GetConditionPart(ptr) != condition)
+				continue;
 			acl = container_of(ptr, struct argv0_acl_record, head);
-			if (acl->filename != saved_filename || acl->argv0 != saved_argv0) continue;
+			if (acl->filename != saved_filename || acl->argv0 != saved_argv0)
+				continue;
 			error = DelDomainACL(ptr);
 			break;
 		}
@@ -81,11 +96,13 @@
 	fill_path_info(&argv0);
 	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct argv0_acl_record *acl;
-		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ARGV0_ACL) continue;
+		if ((ptr->type & ~ACL_WITH_CONDITION) != TYPE_ARGV0_ACL)
+			continue;
 		acl = container_of(ptr, struct argv0_acl_record, head);
 		if (!CheckCondition(ptr, NULL) ||
 		    !PathMatchesToPattern(filename, acl->filename) ||
-		    !PathMatchesToPattern(&argv0, acl->argv0)) continue;
+		    !PathMatchesToPattern(&argv0, acl->argv0))
+			continue;
 		UpdateCondition(ptr);
 		error = 0;
 		break;
@@ -100,22 +117,27 @@
 	const u8 profile = domain->profile;
 	const u8 mode = CheckCCSFlags(CCS_TOMOYO_MAC_FOR_ARGV0);
 	const bool is_enforce = (mode == 3);
-	if (!filename || !argv0 || !*argv0) return 0;
+	if (!filename || !argv0 || !*argv0)
+		return 0;
 	error = CheckArgv0ACL(filename, argv0);
 	AuditArgv0Log(filename, argv0, !error, profile, mode);
-	if (!error) return 0;
+	if (!error)
+		return 0;
 	if (TomoyoVerboseMode()) {
 		printk("TOMOYO-%s: Run %s as %s denied for %s\n", GetMSG(is_enforce), filename->name, argv0, GetLastName(domain));
 	}
-	if (is_enforce) return CheckSupervisor("%s\n" KEYWORD_ALLOW_ARGV0 "%s %s\n", domain->domainname->name, filename->name, argv0);
-	else if (mode == 1 && CheckDomainQuota(domain)) AddArgv0Entry(filename->name, argv0, domain, NULL, 0);
+	if (is_enforce)
+		return CheckSupervisor("%s\n" KEYWORD_ALLOW_ARGV0 "%s %s\n", domain->domainname->name, filename->name, argv0);
+	else if (mode == 1 && CheckDomainQuota(domain))
+		AddArgv0Entry(filename->name, argv0, domain, NULL, 0);
 	return 0;
 }
 
 int AddArgv0Policy(char *data, struct domain_info *domain, const struct condition_list *condition, const bool is_delete)
 {
 	char *argv0 = strchr(data, ' ');
-	if (!argv0) return -EINVAL;
+	if (!argv0)
+		return -EINVAL;
 	*argv0++ = '\0';
 	return AddArgv0Entry(data, argv0, domain, condition, is_delete);
 }
Index: trunk/1.6.x/ccs-patch/fs/sakura_umount.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_umount.c	(revision 1034)
+++ trunk/1.6.x/ccs-patch/fs/sakura_umount.c	(working copy)
@@ -16,9 +16,9 @@
 #include <linux/ccs_common.h>
 #include <linux/sakura.h>
 #include <linux/realpath.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
 #include <linux/mount.h>
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 #include <linux/namespace.h>
 #endif
 
@@ -40,8 +40,11 @@
 	const struct path_info *saved_dir;
 	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
-	if (!IsCorrectPath(dir, 1, 0, 1, __FUNCTION__)) return -EINVAL;
-	if ((saved_dir = SaveName(dir)) == NULL) return -ENOMEM;
+	if (!IsCorrectPath(dir, 1, 0, 1, __func__))
+		return -EINVAL;
+	saved_dir = SaveName(dir);
+	if (!saved_dir)
+		return -ENOMEM;
 	mutex_lock(&lock);
 	list1_for_each_entry(ptr, &no_umount_list, list) {
 		if (ptr->dir == saved_dir) {
@@ -54,7 +57,9 @@
 		error = -ENOENT;
 		goto out;
 	}
-	if ((new_entry = alloc_element(sizeof(*new_entry))) == NULL) goto out;
+	new_entry = alloc_element(sizeof(*new_entry));
+	if (!new_entry)
+		goto out;
 	new_entry->dir = saved_dir;
 	list1_add_tail_mb(&new_entry->list, &no_umount_list);
 	error = 0;
@@ -70,7 +75,8 @@
 	const char *dir0;
 	const u8 mode = CheckCCSFlags(CCS_SAKURA_RESTRICT_UNMOUNT);
 	const bool is_enforce = (mode == 3);
-	if (!mode) return 0;
+	if (!mode)
+		return 0;
 	dir0 = realpath_from_dentry(mnt->mnt_root, mnt);
 	if (dir0) {
 		struct no_umount_entry *ptr;
@@ -79,7 +85,8 @@
 		dir.name = dir0;
 		fill_path_info(&dir);
 		list1_for_each_entry(ptr, &no_umount_list, list) {
-			if (ptr->is_deleted) continue;
+			if (ptr->is_deleted)
+				continue;
 			if (PathMatchesToPattern(&dir, ptr->dir)) {
 				found = true;
 				break;
@@ -88,14 +95,16 @@
 		if (found) {
 			const char *exename = GetEXE();
 			printk("SAKURA-%s: umount %s (pid=%d:exe=%s): Permission denied.\n", GetMSG(is_enforce), dir0, current->pid, exename);
-			if (is_enforce && CheckSupervisor("# %s is requesting\nunmount %s\n", exename, dir0) == 0) error = 0;
+			if (is_enforce && CheckSupervisor("# %s is requesting\nunmount %s\n", exename, dir0) == 0)
+				error = 0;
 			ccs_free(exename);
 		} else {
 			error = 0;
 		}
 		ccs_free(dir0);
 	}
-	if (!is_enforce) error = 0;
+	if (!is_enforce)
+		error = 0;
 	return error;
 }
 
@@ -110,8 +119,10 @@
 	list1_for_each_cookie(pos, head->read_var2, &no_umount_list) {
 		struct no_umount_entry *ptr;
 		ptr = list1_entry(pos, struct no_umount_entry, list);
-		if (ptr->is_deleted) continue;
-		if (io_printf(head, KEYWORD_DENY_UNMOUNT "%s\n", ptr->dir->name)) return -ENOMEM;
+		if (ptr->is_deleted)
+			continue;
+		if (io_printf(head, KEYWORD_DENY_UNMOUNT "%s\n", ptr->dir->name))
+			return -ENOMEM;
 	}
 	return 0;
 }
