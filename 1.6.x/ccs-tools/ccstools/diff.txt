Index: ccstools.src/ccstools.h
===================================================================
--- ccstools.src/ccstools.h	(リビジョン 1537)
+++ ccstools.src/ccstools.h	(作業コピー)
@@ -5,7 +5,7 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.2   2008/06/25
+ * Version: 1.6.4+   2008/09/06
  *
  */
 
@@ -120,6 +120,10 @@
 #define KEYWORD_NO_KEEP_DOMAIN           "no_" KEYWORD_KEEP_DOMAIN
 #define KEYWORD_NO_KEEP_DOMAIN_LEN       (sizeof(KEYWORD_NO_KEEP_DOMAIN) - 1)
 
+#define KEYWORD_EXECUTE_HANDLER          "execute_handler "
+#define KEYWORD_DENIED_EXECUTE_HANDLER   "denied_execute_handler "
+#define KEYWORD_ALLOW_EXECUTE            "allow_executer "
+
 #define CCS_AUDITD_MAX_FILES             2
 #define SAVENAME_MAX_HASH                256
 #define PAGE_SIZE                        4096
@@ -199,13 +203,13 @@
 	const struct domain_keeper_entry *domain_keeper;           /* This may be NULL */
 	const struct path_info **string_ptr;
 	int string_count;
-	int number; /* domain number (-1 if is_domain_initializer_source or is_domain_deleted) */ 
+	int number; /* domain number (-1 if is_dis or is_dd) */ 
 	u8 profile;
-	unsigned char is_domain_initializer_source:1;
-	unsigned char is_domain_initializer_target:1;
-	unsigned char is_domain_keeper:1;
-	unsigned char is_domain_unreachable:1;
-	unsigned char is_domain_deleted:1;
+	unsigned char is_dis:1; /* domain initializer source */
+	unsigned char is_dit:1; /* domain initializer target */
+	unsigned char is_dk:1;  /* domain keeper */
+	unsigned char is_du:1;  /* unreachable domain */
+	unsigned char is_dd:1;  /* deleted domain */
 };
 
 struct task_entry {
@@ -242,20 +246,25 @@
 int getch2(void);
 
 extern const char *proc_policy_dir,
-	*disk_policy_dir,
-	*proc_policy_domain_policy,
-	*disk_policy_domain_policy,
-	*proc_policy_exception_policy,
-	*disk_policy_exception_policy,
-	*proc_policy_system_policy,
-	*disk_policy_system_policy,
-	*proc_policy_profile,
-	*disk_policy_profile,
-	*proc_policy_manager,
-	*disk_policy_manager,
-	*proc_policy_query,
-	*proc_policy_grant_log,
-	*proc_policy_reject_log,
+ 	*disk_policy_dir,
+ 	*proc_policy_domain_policy,
+ 	*disk_policy_domain_policy,
+	*base_policy_domain_policy,
+ 	*proc_policy_exception_policy,
+ 	*disk_policy_exception_policy,
+	*base_policy_exception_policy,
+ 	*proc_policy_system_policy,
+ 	*disk_policy_system_policy,
+	*base_policy_system_policy,
+ 	*proc_policy_profile,
+ 	*disk_policy_profile,
+	*base_policy_profile,
+ 	*proc_policy_manager,
+ 	*disk_policy_manager,
+	*base_policy_manager,
+ 	*proc_policy_query,
+ 	*proc_policy_grant_log,
+ 	*proc_policy_reject_log,
 	*proc_policy_domain_status,
 	*proc_policy_process_status;
 
Index: ccstools.src/editpolicy.c
===================================================================
--- ccstools.src/editpolicy.c	(リビジョン 1537)
+++ ccstools.src/editpolicy.c	(作業コピー)
@@ -5,63 +5,85 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.4+   2008/09/04
+ * Version: 1.6.4+   2008/09/06
  *
  */
 #include "ccstools.h"
 
-/// add color start
+static int str_starts(char *str, const const char *begin)
+{
+	const int len = strlen(begin);
+	if (strncmp(str, begin, len))
+		return 0;
+	memmove(str, str + len, strlen(str + len) + 1);
+	return 1;
+}
+
+/* add color start */
 #ifdef COLOR_ON
 #define OFF 0
-#define ON !OFF
+#define ON  1
 
 enum color_pair {
-	NORMAL,
-	DOMAIN_HEAD, DOMAIN_CURSOR,
-	SYSTEM_HEAD, SYSTEM_CURSOR,
-	EXCEPTION_HEAD, EXCEPTION_CURSOR,
-	ACL_HEAD, ACL_CURSOR,
-	DISP_ERR
-}; 
-	
-static void ColorInit(void){
+	NORMAL, DOMAIN_HEAD, DOMAIN_CURSOR, SYSTEM_HEAD, SYSTEM_CURSOR,
+	EXCEPTION_HEAD, EXCEPTION_CURSOR, ACL_HEAD, ACL_CURSOR, DISP_ERR
+};
+
+static void editpolicy_color_init(void)
+{
 	static struct color_env_t {
 		enum color_pair	tag;
-		short		fore;
-		short		back;
-		char		*name;
+		short int fore;
+		short int back;
+		const char *name;
 	} color_env[] = {
-		{DOMAIN_HEAD,      COLOR_BLACK, COLOR_GREEN,  "DOMAIN_HEAD"},
-		{DOMAIN_CURSOR,    COLOR_BLACK, COLOR_GREEN,  "DOMAIN_CURSOR"},
-		{SYSTEM_HEAD,      COLOR_WHITE, COLOR_BLUE,   "SYSTEM_HEAD"},
-		{SYSTEM_CURSOR,    COLOR_WHITE, COLOR_BLUE,   "SYSTEM_CURSOR"},
-		{EXCEPTION_HEAD,   COLOR_BLACK, COLOR_CYAN,   "EXCEPTION_HEAD"},
-		{EXCEPTION_CURSOR, COLOR_BLACK, COLOR_CYAN,   "EXCEPTION_CURSOR"},
-		{ACL_HEAD,         COLOR_BLACK, COLOR_YELLOW, "ACL_HEAD"},
-		{ACL_CURSOR,       COLOR_BLACK, COLOR_YELLOW, "ACL_CURSOR"},
-		{NORMAL,           COLOR_WHITE, COLOR_BLACK,  NULL}
+		{ DOMAIN_HEAD,      COLOR_BLACK,
+		  COLOR_GREEN,      "DOMAIN_HEAD" },
+		{ DOMAIN_CURSOR,    COLOR_BLACK,
+		  COLOR_GREEN,      "DOMAIN_CURSOR" },
+		{ SYSTEM_HEAD,      COLOR_WHITE,
+		  COLOR_BLUE,       "SYSTEM_HEAD" },
+		{ SYSTEM_CURSOR,    COLOR_WHITE,
+		  COLOR_BLUE,       "SYSTEM_CURSOR" },
+		{ EXCEPTION_HEAD,   COLOR_BLACK,
+		  COLOR_CYAN,       "EXCEPTION_HEAD" },
+		{ EXCEPTION_CURSOR, COLOR_BLACK,
+		  COLOR_CYAN,       "EXCEPTION_CURSOR" },
+		{ ACL_HEAD,         COLOR_BLACK,
+		  COLOR_YELLOW,     "ACL_HEAD" },
+		{ ACL_CURSOR,       COLOR_BLACK,
+		  COLOR_YELLOW,     "ACL_CURSOR" },
+		{ NORMAL,           COLOR_WHITE,
+		  COLOR_BLACK,      NULL }
 	};
-	FILE *fp;
+	FILE *fp = fopen(CCSTOOLS_CONFIG_FILE, "r");
 	int i;
-	if ((fp = fopen(CCSTOOLS_CONFIG_FILE, "r")) == NULL) goto use_default;
+	if (!fp)
+		goto use_default;
 	get();
 	while (freadline(fp)) {
 		char *cp;
-		if (strncmp(shared_buffer, "editpolicy.line_color ", 22)) continue;
-		memmove(shared_buffer, shared_buffer + 22, strlen(shared_buffer + 22) + 1);
-		if ((cp = strchr(shared_buffer, '=')) == NULL) continue;
+		if (!str_starts(shared_buffer, "editpolicy.line_color "))
+			continue;
+		cp = strchr(shared_buffer, '=');
+		if (!cp)
+			continue;
 		*cp++ = '\0';
 		NormalizeLine(shared_buffer);
 		NormalizeLine(cp);
-		if (!*shared_buffer || !*cp) continue;
-		for (i = 0; color_env[i].name != NULL; i++) {
-			short fore, back;
-			if (strcmp(shared_buffer, color_env[i].name)) continue;
-			if (strlen(cp) != 2) break;
-			fore = (*cp++) - '0';		// foreground color
-			back = (*cp) - '0';		// background color
-			if (fore < 0 || fore > 7 ||
-			    back < 0 || back > 7) break;
+		if (!*shared_buffer || !*cp)
+			continue;
+		for (i = 0; color_env[i].name; i++) {
+			short int fore;
+			short int back;
+			if (strcmp(shared_buffer, color_env[i].name))
+				continue;
+			if (strlen(cp) != 2)
+				break;
+			fore = (*cp++) - '0'; /* foreground color */
+			back = (*cp) - '0';   /* background color */
+			if (fore < 0 || fore > 7 || back < 0 || back > 7)
+				break;
 			color_env[i].fore = fore;
 			color_env[i].back = back;
 			break;
@@ -69,16 +91,17 @@
 	}
 	put();
 	fclose(fp);
- use_default:
+use_default:
 	start_color();
-	for (i = 0; color_env[i].name != NULL; i++) {
+	for (i = 0; color_env[i].name; i++) {
 		struct color_env_t *colorp = &color_env[i];
 		init_pair(colorp->tag, colorp->fore, colorp->back);
 	}
-	init_pair(DISP_ERR, COLOR_RED, COLOR_BLACK);	// error massage
+	init_pair(DISP_ERR, COLOR_RED, COLOR_BLACK); /* error massage */
 }
 
-static void ColorSave(int flg) {
+static void editpolicy_color_save(const int flg)
+{
 	static int save_color = NORMAL;
 	if (flg == ON)
 		save_color = getattrs(stdscr);
@@ -86,49 +109,80 @@
 		attrset(save_color);
 }
 
-#define colorChange(attr, flg)	{flg ? attron(COLOR_PAIR(attr)) : attroff(COLOR_PAIR(attr));}
-#define attrChange(attr, flg)	{flg ? attron(attr) : attroff(attr);}
+static inline void editpolicy_color_change(const attr_t attr, const int flg)
+{
+	if (flg)
+		attron(COLOR_PAIR(attr));
+	else
+		attroff(COLOR_PAIR(attr));
+}
 
-#define sttrSave()		ColorSave(ON)
-#define sttrRestore()	ColorSave(OFF)
+static inline void editpolicy_attr_change(const attr_t attr, const int flg)
+{
+	if (flg)
+		attron(attr);
+	else
+		attroff(attr);
+}
 
-#define colorHead()	( \
-	(current_screen == SCREEN_DOMAIN_LIST) ? DOMAIN_HEAD \
-			: (current_screen == SCREEN_SYSTEM_LIST) ? SYSTEM_HEAD \
-			: (current_screen == SCREEN_EXCEPTION_LIST) ? EXCEPTION_HEAD \
-			: ACL_HEAD )
+static inline void editpolicy_sttr_save(void)
+{
+	editpolicy_color_save(ON);
+}
 
-#define colorCursor()	( \
-	(current_screen == SCREEN_DOMAIN_LIST) ? DOMAIN_CURSOR \
-			: (current_screen == SCREEN_SYSTEM_LIST) ? SYSTEM_CURSOR \
-			: (current_screen == SCREEN_EXCEPTION_LIST) ? EXCEPTION_CURSOR \
-			: ACL_CURSOR )
+static inline void editpolicy_sttr_restore(void)
+{
+	editpolicy_color_save(OFF);
+}
 
+static inline int editpolicy_color_head(const int screen)
+{
+	if (screen == SCREEN_DOMAIN_LIST)
+		return DOMAIN_HEAD;
+	if (screen == SCREEN_SYSTEM_LIST)
+		return SYSTEM_HEAD;
+	if (screen == SCREEN_EXCEPTION_LIST)
+		return EXCEPTION_HEAD;
+	return ACL_HEAD;
+}
 
+static inline int editpolicy_color_cursor(const int screen)
+{
+	if (screen == SCREEN_DOMAIN_LIST)
+		return DOMAIN_CURSOR;
+	if (screen == SCREEN_SYSTEM_LIST)
+		return SYSTEM_CURSOR;
+	if (screen == SCREEN_EXCEPTION_LIST)
+		return EXCEPTION_CURSOR;
+	return ACL_CURSOR;
+}
 
-#else	// no color
+#else /* no color */
 
-#define ColorInit()
-#define colorChange(attr, flg)
-#define attrChange(attr, flg)
-#define sttrSave()
-#define sttrRestore()
-#define colorHead()
-#define colorCursor()
+#define editpolicy_color_init()
+#define editpolicy_color_change(attr, flg)
+#define editpolicy_attr_change(attr, flg)
+#define editpolicy_sttr_save()
+#define editpolicy_sttr_restore()
+#define editpolicy_color_head()
+#define editpolicy_color_cursor()
 
 #endif
-/// add color end
+/* add color end */
 
 static struct path_group_entry *path_group_list = NULL;
 static int path_group_list_len = 0;
 static struct address_group_entry *address_group_list = NULL;
 static int address_group_list_len = 0;
 
-static struct domain_info *domain_list = NULL, *shadow_domain_list = NULL;
-static int domain_list_count = 0, shadow_domain_list_count = 0;
+static struct domain_info *domain_list = NULL;
+static struct domain_info *shadow_domain_list = NULL;
+static int domain_list_count = 0;
+static int shadow_domain_list_count = 0;
 static unsigned char *domain_list_selected = NULL;
 
-static void SwapDomainList(void) {
+static void swap_domain_list(void)
+{
 	struct domain_info *tmp_list = domain_list;
 	int tmp_list_count = domain_list_count;
 	domain_list = shadow_domain_list;
@@ -137,70 +191,91 @@
 	shadow_domain_list_count = tmp_list_count;
 }
 
-static const char *DomainName(const int index) {
+static const char *domain_name(const int index)
+{
 	return domain_list[index].domainname->name;
 }
 
-static const char *GetLastName(const int index) {
-	const char *cp0 = DomainName(index), *cp1;
-	if ((cp1 = strrchr(cp0, ' ')) != NULL) return cp1 + 1;
+static const char *get_last_name(const int index)
+{
+	const char *cp0 = domain_name(index);
+	const char *cp1 = strrchr(cp0, ' ');
+	if (cp1)
+		return cp1 + 1;
 	return cp0;
 }
 
-static int AddStringEntry(const char *entry, const int index) {
+static int add_string_entry(const char *entry, const int index)
+{
 	const struct path_info **acl_ptr;
 	int acl_count;
 	const struct path_info *cp;
 	int i;
 	if (index < 0 || index >= domain_list_count) {
-		fprintf(stderr, "AddStringEntry: ERROR: domain is out of range.\n");
+		fprintf(stderr, "%s: ERROR: domain is out of range.\n",
+			__func__);
 		return -EINVAL;
 	}
-	if (!entry || !*entry) return -EINVAL;
-	if ((cp = SaveName(entry)) == NULL) OutOfMemory();
+	if (!entry || !*entry)
+		return -EINVAL;
+	cp = SaveName(entry);
+	if (!cp)
+		OutOfMemory();
 
 	acl_ptr = domain_list[index].string_ptr;
 	acl_count = domain_list[index].string_count;
 
-	// Check for the same entry.
+	/* Check for the same entry. */
 	for (i = 0; i < acl_count; i++) {
-		// Faster comparison, for they are SaveName'd.
-		if (cp == acl_ptr[i]) return 0;
+		/* Faster comparison, for they are SaveName'd. */
+		if (cp == acl_ptr[i])
+			return 0;
 	}
 
-	if ((acl_ptr = (const struct path_info **) realloc(acl_ptr, (acl_count + 1) * sizeof(const struct path_info *))) == NULL) OutOfMemory();
+	acl_ptr = realloc(acl_ptr, (acl_count + 1)
+			  * sizeof(const struct path_info *));
+	if (!acl_ptr)
+		OutOfMemory();
 	acl_ptr[acl_count++] = cp;
 	domain_list[index].string_ptr = acl_ptr;
 	domain_list[index].string_count = acl_count;
 	return 0;
 }
 
-static int DelStringEntry(const char *entry, const int index) {
+static int del_string_entry(const char *entry, const int index)
+{
 	const struct path_info **acl_ptr;
 	int acl_count;
 	const struct path_info *cp;
 	int i;
 	if (index < 0 || index >= domain_list_count) {
-		fprintf(stderr, "DelStringEntry: ERROR: domain is out of range.\n");
+		fprintf(stderr, "%s: ERROR: domain is out of range.\n",
+			__func__);
 		return -EINVAL;
 	}
-	if (!entry || !*entry) return -EINVAL;
-	if ((cp = SaveName(entry)) == NULL) OutOfMemory();
+	if (!entry || !*entry)
+		return -EINVAL;
+	cp = SaveName(entry);
+	if (!cp)
+		OutOfMemory();
 
 	acl_ptr = domain_list[index].string_ptr;
 	acl_count = domain_list[index].string_count;
 
 	for (i = 0; i < acl_count; i++) {
-		// Faster comparison, for they are SaveName'd.
-		if (cp != acl_ptr[i]) continue;
+		/* Faster comparison, for they are SaveName'd. */
+		if (cp != acl_ptr[i])
+			continue;
 		domain_list[index].string_count--;
-		for (; i < acl_count - 1; i++) acl_ptr[i] = acl_ptr[i + 1];
+		for (; i < acl_count - 1; i++)
+			acl_ptr[i] = acl_ptr[i + 1];
 		return 0;
 	}
 	return -ENOENT;
 }
 
-static void ClearDomainPolicy(void) {
+static void clear_domain_policy(void)
+{
 	int index;
 	for (index = 0; index < domain_list_count; index++) {
 		free(domain_list[index].string_ptr);
@@ -212,70 +287,97 @@
 	domain_list_count = 0;
 }
 
-static int FindDomain(const char *domainname0, const int is_domain_initializer_source, const int is_domain_deleted) {
+static int find_domain(const char *domainname0, const int is_dis,
+		       const int is_dd)
+{
 	int i;
 	struct path_info domainname;
 	domainname.name = domainname0;
 	fill_path_info(&domainname);
 	for (i = 0; i < domain_list_count; i++) {
-		if (domain_list[i].is_domain_initializer_source == is_domain_initializer_source && domain_list[i].is_domain_deleted == is_domain_deleted && !pathcmp(&domainname, domain_list[i].domainname)) return i;
+		if (domain_list[i].is_dis == is_dis &&
+		    domain_list[i].is_dd == is_dd &&
+		    !pathcmp(&domainname, domain_list[i].domainname))
+			return i;
 	}
 	return EOF;
 }
 
-static int FindOrAssignNewDomain(const char *domainname, const int is_domain_initializer_source, const int is_domain_deleted) {
+static int find_or_assign_new_domain(const char *domainname, const int is_dis,
+				     const int is_dd)
+{
 	const struct path_info *saved_domainname;
-	int index;
-	if ((index = FindDomain(domainname, is_domain_initializer_source, is_domain_deleted)) == EOF) {
-		if (IsCorrectDomain(domainname)) {
-			if ((domain_list = (struct domain_info *) realloc(domain_list, (domain_list_count + 1) * sizeof(struct domain_info))) == NULL) OutOfMemory();
-			memset(&domain_list[domain_list_count], 0, sizeof(struct domain_info));
-			if ((saved_domainname = SaveName(domainname)) == NULL) OutOfMemory();
-			domain_list[domain_list_count].domainname = saved_domainname;
-			domain_list[domain_list_count].is_domain_initializer_source = is_domain_initializer_source;
-			domain_list[domain_list_count].is_domain_deleted = is_domain_deleted;
-			index = domain_list_count++;
-		} else {
-			fprintf(stderr, "FindOrAssignNewDomain: Invalid domainname '%s'\n", domainname);
-		}
+	int index = find_domain(domainname, is_dis, is_dd);
+	if (index >= 0)
+		goto found;
+	if (!IsCorrectDomain(domainname)) {
+		fprintf(stderr, "%s: Invalid domainname '%s'\n",
+			__func__, domainname);
+		return EOF;
 	}
+	domain_list = realloc(domain_list, (domain_list_count + 1) *
+			      sizeof(struct domain_info));
+	if (!domain_list)
+		OutOfMemory();
+	memset(&domain_list[domain_list_count], 0, sizeof(struct domain_info));
+	saved_domainname = SaveName(domainname);
+	if (!saved_domainname)
+		OutOfMemory();
+	domain_list[domain_list_count].domainname = saved_domainname;
+	domain_list[domain_list_count].is_dis = is_dis;
+	domain_list[domain_list_count].is_dd = is_dd;
+	index = domain_list_count++;
+found:
 	return index;
 }
 
-static void DeleteDomain(const int index) {
+static void delete_domain(const int index)
+{
 	if (index > 0 && index < domain_list_count) {
 		int i;
 		free(domain_list[index].string_ptr);
-		for (i = index; i < domain_list_count - 1; i++) domain_list[i] = domain_list[i + 1];
+		for (i = index; i < domain_list_count - 1; i++)
+			domain_list[i] = domain_list[i + 1];
 		domain_list_count--;
 	}
 }
 
-static int domainname_compare(const void *a, const void *b) {
-	return strcmp(((struct domain_info *) a)->domainname->name, ((struct domain_info *) b)->domainname->name);
+static int domainname_compare(const void *a, const void *b)
+{
+	return strcmp(((struct domain_info *) a)->domainname->name,
+		      ((struct domain_info *) b)->domainname->name);
 }
 
-static int path_info_compare(const void *a, const void *b) {
-	const char *a0 = (* (struct path_info **) a)->name;
-	const char *b0 = (* (struct path_info **) b)->name;
+static int path_info_compare(const void *a, const void *b)
+{
+	const char *a0 = (*(struct path_info **) a)->name;
+	const char *b0 = (*(struct path_info **) b)->name;
 	return strcmp(a0, b0);
 }
 
-static void SortPolicy(void) {
+static void sort_domain_policy(void)
+{
 	int i;
-	qsort(domain_list, domain_list_count, sizeof(struct domain_info), domainname_compare);
-	for (i = 0; i < domain_list_count; i++) qsort(domain_list[i].string_ptr, domain_list[i].string_count, sizeof(struct path_info *), path_info_compare);
+	qsort(domain_list, domain_list_count, sizeof(struct domain_info),
+	      domainname_compare);
+	for (i = 0; i < domain_list_count; i++)
+		qsort(domain_list[i].string_ptr, domain_list[i].string_count,
+		      sizeof(struct path_info *), path_info_compare);
 }
 
-static int WriteDomainPolicy(const int fd) {
-	int i, j;
+static int write_domain_policy(const int fd)
+{
+	int i;
+	int j;
 	for (i = 0; i < domain_list_count; i++) {
 		const struct path_info **string_ptr = domain_list[i].string_ptr;
 		const int string_count = domain_list[i].string_count;
-		write(fd, domain_list[i].domainname->name, domain_list[i].domainname->total_len);
+		write(fd, domain_list[i].domainname->name,
+		      domain_list[i].domainname->total_len);
 		write(fd, "\n\n", 2);
 		for (j = 0; j < string_count; j++) {
-			write(fd, string_ptr[j]->name, string_ptr[j]->total_len);
+			write(fd, string_ptr[j]->name,
+			      string_ptr[j]->total_len);
 			write(fd, "\n", 1);
 		}
 		write(fd, "\n", 1);
@@ -283,31 +385,38 @@
 	return 0;
 }
 
-static int IsKeeperDomain(const int index) {
-	return domain_list[index].is_domain_keeper;
+static int is_keeper_domain(const int index)
+{
+	return domain_list[index].is_dk;
 }
 
-static int IsInitializerSource(const int index) {
-	return domain_list[index].is_domain_initializer_source;
+static int is_initializer_source(const int index)
+{
+	return domain_list[index].is_dis;
 }
 
-static int IsInitializerTarget(const int index) {
-	return domain_list[index].is_domain_initializer_target;
+static int is_initializer_target(const int index)
+{
+	return domain_list[index].is_dit;
 }
 
-static int IsDomainUnreachable(const int index) {
-	return domain_list[index].is_domain_unreachable;
+static int is_domain_unreachable(const int index)
+{
+	return domain_list[index].is_du;
 }
 
-static int IsDeletedDomain(const int index) {
-	return domain_list[index].is_domain_deleted;
+static int is_deleted_domain(const int index)
+{
+	return domain_list[index].is_dd;
 }
 
-static void ReadDomainPolicy(const char *filename) {
+static void read_domain_policy(const char *filename)
+{
 	FILE *fp = stdin;
 	int index;
 	if (filename) {
-		if ((fp = fopen(filename, "r")) == NULL) {
+		fp = fopen(filename, "r");
+		if (!fp) {
 			fprintf(stderr, "Can't open %s\n", filename);
 			return;
 		}
@@ -315,82 +424,299 @@
 	index = EOF;
 	get();
 	while (freadline(fp)) {
-		if (IsDomainDef(shared_buffer)) {
-			index = FindOrAssignNewDomain(shared_buffer, 0, 0);
-		} else if (index >= 0 && shared_buffer[0]) {
-			AddStringEntry(shared_buffer, index);
-		}
+		if (IsDomainDef(shared_buffer))
+			index = find_or_assign_new_domain(shared_buffer, 0, 0);
+		else if (index >= 0 && shared_buffer[0])
+			add_string_entry(shared_buffer, index);
 	}
 	put();
-	if (fp != stdin) fclose(fp);
-	SortPolicy();
+	if (fp != stdin)
+		fclose(fp);
+	sort_domain_policy();
 }
 
 /***** sortpolicy start *****/
 
-int sortpolicy_main(int argc, char *argv[]) {
-	ReadDomainPolicy(NULL);
-	WriteDomainPolicy(1);
+int sortpolicy_main(int argc, char *argv[])
+{
+	read_domain_policy(NULL);
+	write_domain_policy(1);
 	return 0;
 }
 
 /***** sortpolicy end *****/
 
+/***** diffpolicy start *****/
+
+static int find_domain_by_ptr(const struct path_info *domainname)
+{
+	int i;
+	for (i = 0; i < domain_list_count; i++) {
+		if (domain_list[i].domainname == domainname)
+			return i;
+	}
+	return EOF;
+}
+
+static int save_domain_policy_with_diff(const char *proc, const char *base,
+					const char *diff)
+{
+	const struct path_info **proc_string_ptr;
+	const struct path_info **base_string_ptr;
+	int proc_string_count;
+	int base_string_count;
+	int proc_index;
+	int base_index;
+	const struct path_info *domainname;
+	int i;
+	int j;
+	FILE *diff_fp = stdout;
+	if (diff) {
+		diff_fp = fopen(diff, "w");
+		if (!diff_fp) {
+			fprintf(stderr, "Can't open %s\n", diff);
+			return 0;
+		}
+	}
+	read_domain_policy(proc);
+	swap_domain_list();
+	read_domain_policy(base);
+	swap_domain_list();
+
+	swap_domain_list();
+	for (base_index = 0; base_index < domain_list_count; base_index++) {
+		domainname = domain_list[base_index].domainname;
+		swap_domain_list();
+		proc_index = find_domain_by_ptr(domainname);
+		swap_domain_list();
+		if (proc_index >= 0)
+			continue;
+		/* This domain was deleted by diff policy. */
+		fprintf(diff_fp, "delete %s\n\n", domainname->name);
+	}
+	swap_domain_list();
+
+	for (proc_index = 0; proc_index < domain_list_count; proc_index++) {
+		domainname = domain_list[proc_index].domainname;
+		swap_domain_list();
+		base_index = find_domain_by_ptr(domainname);
+		swap_domain_list();
+		if (base_index >= 0)
+			continue;
+		/* This domain was added by diff policy. */
+		fprintf(diff_fp, "%s\n\n", domainname->name);
+		proc_string_ptr = domain_list[proc_index].string_ptr;
+		proc_string_count = domain_list[proc_index].string_count;
+		for (i = 0; i < proc_string_count; i++)
+			fprintf(diff_fp, "%s\n", proc_string_ptr[i]->name);
+		fprintf(diff_fp, "\n");
+	}
+
+	for (proc_index = 0; proc_index < domain_list_count; proc_index++) {
+		int first = 1;
+		domainname = domain_list[proc_index].domainname;
+		swap_domain_list();
+		base_index = find_domain_by_ptr(domainname);
+		swap_domain_list();
+		if (base_index == EOF)
+			continue;
+		/* This domain exists in both base policy and proc policy. */
+		proc_string_ptr = domain_list[proc_index].string_ptr;
+		proc_string_count = domain_list[proc_index].string_count;
+		base_string_ptr = shadow_domain_list[base_index].string_ptr;
+		base_string_count = shadow_domain_list[base_index].string_count;
+		for (i = 0; i < proc_string_count; i++) {
+			for (j = 0; j < base_string_count; j++) {
+				if (proc_string_ptr[i] != base_string_ptr[j])
+					continue;
+				proc_string_ptr[i] = NULL;
+				base_string_ptr[j] = NULL;
+			}
+		}
+
+		for (i = 0; i < base_string_count; i++) {
+			if (!base_string_ptr[i])
+				continue;
+			if (first)
+				fprintf(diff_fp, "%s\n\n", domainname->name);
+			first = 0;
+			fprintf(diff_fp, "delete %s\n",
+				base_string_ptr[i]->name);
+		}
+		for (i = 0; i < proc_string_count; i++) {
+			if (!proc_string_ptr[i])
+				continue;
+			if (first)
+				fprintf(diff_fp, "%s\n\n", domainname->name);
+			first = 0;
+			fprintf(diff_fp, "%s\n", proc_string_ptr[i]->name);
+		}
+		if (!first)
+			fprintf(diff_fp, "\n");
+	}
+
+	if (diff_fp != stdout)
+		fclose(diff_fp);
+	return 1;
+}
+
+int diffpolicy_main(int argc, char *argv[])
+{
+	const char *original = argc > 1 ? argv[1] : proc_policy_domain_policy;
+	const char *base = argc > 2 ? argv[2] : base_policy_domain_policy;
+	const char *diff = argc > 3 ? argv[3] : NULL;
+	if (access(original, R_OK)) {
+		fprintf(stderr, "%s not found.\n", original);
+		return 1;
+	}
+	if (base == argv[2] && access(base, R_OK)) {
+		fprintf(stderr, "%s not found.\n", base);
+		return 1;
+	}
+	return !save_domain_policy_with_diff(original, base, diff);
+}
+
+/***** diffpolicy end *****/
+
 /***** savepolicy start *****/
 
-static int MoveProcToFile(const char *src, const char *dest) {
-	FILE *proc_fp, *file_fp;
-	int first = 1;
-	int is_domain_policy = 0;
-	if ((proc_fp = fopen(src, "r")) == NULL) {
-		fprintf(stderr, "Can't open %s\n", src);
+static int cat_file(const char *path)
+{
+	FILE *fp = fopen(path, "r");
+	int c;
+	if (!fp) {
+		fprintf(stderr, "Can't open %s\n", path);
 		return 0;
 	}
-	if ((file_fp = dest ? fopen(dest, "w") : stdout) == NULL) {
-		fprintf(stderr, "Can't open %s\n", dest);
-		fclose(proc_fp);
+	while ((c = fgetc(fp)) != EOF)
+		putchar(c);
+	fclose(fp);
+	return 1;
+}
+
+static int move_proc_to_file(const char *src, const char *base,
+			     const char *dest)
+{
+	FILE *proc_fp;
+	FILE *base_fp;
+	FILE *file_fp = stdout;
+	char **original_list = NULL;
+	char **base_list = NULL;
+	int original_list_len = 0;
+	int base_list_len = 0;
+	int i;
+	proc_fp = fopen(src, "r");
+	if (!proc_fp) {
+		fprintf(stderr, "Can't open %s\n", src);
 		return 0;
 	}
+	if (dest) {
+		file_fp = fopen(dest, "w");
+		if (!file_fp) {
+			fprintf(stderr, "Can't open %s\n", dest);
+			fclose(proc_fp);
+			return 0;
+		}
+	}
 	get();
-	while (freadline(proc_fp)) {
-		if (first) {
-			first = 0;
-			if (strncmp(shared_buffer, "<kernel>", 8) == 0) is_domain_policy = 1;
-		} else if (is_domain_policy && strncmp(shared_buffer, "<kernel>", 8) == 0) {
-			fprintf(file_fp, "\n");
+	base_fp = fopen(base, "r");
+	if (base_fp) {
+		while (freadline(base_fp)) {
+			char *cp;
+			if (!shared_buffer[0])
+				continue;
+			base_list = realloc(base_list, sizeof(char *) *
+					    (base_list_len + 1));
+			if (!base_list)
+				OutOfMemory();
+			cp = strdup(shared_buffer);
+			if (!cp)
+				OutOfMemory();
+			base_list[base_list_len++] = cp;
 		}
-		if (shared_buffer[0]) fprintf(file_fp, "%s\n", shared_buffer);
-		if (is_domain_policy && strncmp(shared_buffer, "use_profile ", 12) == 0) fprintf(file_fp, "\n");
+		fclose(base_fp);
 	}
+	while (freadline(proc_fp)) {
+		char *cp;
+		if (!shared_buffer[0])
+			continue;
+		original_list = realloc(original_list, sizeof(char *) *
+					(original_list_len + 1));
+		if (!original_list)
+			OutOfMemory();
+		cp = strdup(shared_buffer);
+		if (!cp)
+			OutOfMemory();
+		original_list[original_list_len++] = cp;
+	}
 	put();
 	fclose(proc_fp);
-	if (file_fp != stdout) fclose(file_fp);
+
+	for (i = 0; i < original_list_len; i++) {
+		int j;
+		for (j = 0; j < base_list_len; j++) {
+			if (!original_list[i] || !base_list[j] ||
+			    strcmp(original_list[i], base_list[j]))
+				continue;
+			free(original_list[i]);
+			original_list[i] = NULL;
+			free(base_list[j]);
+			base_list[j] = NULL;
+			break;
+		}
+	}
+	for (i = 0; i < base_list_len; i++) {
+		if (base_list[i])
+			fprintf(file_fp, "delete %s\n", base_list[i]);
+	}
+	for (i = 0; i < original_list_len; i++) {
+		if (original_list[i])
+			fprintf(file_fp, "%s\n", original_list[i]);
+	}
+
+	if (file_fp != stdout)
+		fclose(file_fp);
+	while (original_list_len)
+		free(original_list[--original_list_len]);
+	free(original_list);
+	while (base_list_len)
+		free(base_list[--base_list_len]);
+	free(base_list);
 	return 1;
 }
 
-static int IsIdenticalFile(const char *file1, const char *file2) {
-	char buffer1[4096], buffer2[4096];
-	struct stat sb1, sb2;
-	const int fd1 = open(file1, O_RDONLY), fd2 = open(file2, O_RDONLY);
-	int len1, len2;
+static int is_identical_file(const char *file1, const char *file2)
+{
+	char buffer1[4096];
+	char buffer2[4096];
+	struct stat sb1;
+	struct stat sb2;
+	const int fd1 = open(file1, O_RDONLY);
+	const int fd2 = open(file2, O_RDONLY);
+	int len1;
+	int len2;
 	/* Don't compare if file1 is a symlink to file2. */
-	if (fstat(fd1, &sb1) || fstat(fd2, &sb2) || sb1.st_ino == sb2.st_ino) goto out;
+	if (fstat(fd1, &sb1) || fstat(fd2, &sb2) || sb1.st_ino == sb2.st_ino)
+		goto out;
 	do {
 		len1 = read(fd1, buffer1, sizeof(buffer1));
 		len2 = read(fd2, buffer2, sizeof(buffer2));
-		if (len1 < 0 || len1 != len2) goto out;
-		if (memcmp(buffer1, buffer2, len1)) goto out;
+		if (len1 < 0 || len1 != len2)
+			goto out;
+		if (memcmp(buffer1, buffer2, len1))
+			goto out;
 	} while (len1);
 	close(fd1);
 	close(fd2);
 	return 1;
- out:
+out:
 	close(fd1);
 	close(fd2);
 	return 0;
 }
 
-int savepolicy_main(int argc, char *argv[]) {
+int savepolicy_main(int argc, char *argv[])
+{
 	int remount_root = 0;
 	char filename[1024];
 	int write_to_stdout = 0;
@@ -403,13 +729,18 @@
 	time_t now = time(NULL);
 	struct tm *tm = localtime(&now);
 	memset(filename, 0, sizeof(filename));
-	if (access("/proc/self/", F_OK)) mount("/proc", "/proc", "proc", 0, NULL);
+	if (access("/proc/self/", F_OK))
+		mount("/proc", "/proc", "proc", 0, NULL);
 	if (access(proc_policy_dir, F_OK)) {
-		fprintf(stderr, "You can't run this program for this kernel.\n");
+		fprintf(stderr,
+			"You can't run this program for this kernel.\n");
 		return 0;
 	}
 	if (argc == 1) {
-		force_save = save_system_policy = save_exception_policy = save_domain_policy = 1;
+		force_save = 1;
+		save_system_policy = 1;
+		save_exception_policy = 1;
+		save_domain_policy = 1;
 	} else {
 		int i;
 		for (i = 1; i < argc; i++) {
@@ -422,27 +753,26 @@
 			char *p = strchr(ptr, 'p');
 			char *m = strchr(ptr, 'm');
 			char *i = strchr(ptr, '-');
-			if (s || a) save_system_policy = 1;
-			if (e || a) save_exception_policy = 1;
-			if (d || a) save_domain_policy = 1;
-			if (p) save_profile = 1;
-			if (m) save_manager = 1;
-			if (f) force_save = 1;
-			if (i) write_to_stdout = 1;
-			if (strcspn(ptr, "sedafpm-") ||
-			    (write_to_stdout && save_system_policy + save_exception_policy + save_domain_policy + save_profile + save_manager != 1)) {
-				printf("%s [s][e][d][a][f][p][m][-]\n"
-				       "s : Save system_policy.\n"
-				       "e : Save exception_policy.\n"
-				       "d : Save domain_policy.\n"
-				       "a : Save system_policy,exception_policy,domain_policy.\n"
-				       "p : Save profile.\n"
-				       "m : Save manager.\n"
-				       "- : Write policy to stdout. (Only one of 'sedpm' is possible when using '-'.)\n"
-				       "f : Save even if on-disk policy and on-memory policy are the same. (Valid for 'sed'.)\n\n"
-				       "If no options given, this program assumes 'a' and 'f' are given.\n", argv[0]);
-				return 0;
-			}
+			if (s || a)
+				save_system_policy = 1;
+			if (e || a)
+				save_exception_policy = 1;
+			if (d || a)
+				save_domain_policy = 1;
+			if (p)
+				save_profile = 1;
+			if (m)
+				save_manager = 1;
+			if (f)
+				force_save = 1;
+			if (i)
+				write_to_stdout = 1;
+			if (strcspn(ptr, "sedafpm-"))
+				goto usage;
+			if (write_to_stdout && save_system_policy +
+			    save_exception_policy + save_domain_policy +
+			    save_profile + save_manager != 1)
+				goto usage;
 		}
 	}
 	if (chdir(disk_policy_dir)) {
@@ -450,26 +780,53 @@
 		return 1;
 	}
 	if (access(".", W_OK) == EOF) {
-		if (errno != EROFS || mount("/", "/", "rootfs", MS_REMOUNT, NULL) == EOF) {
-			printf("Can't remount for read-write. (%s)\n", strerror(errno));
+		if (errno != EROFS ||
+		    mount("/", "/", "rootfs", MS_REMOUNT, NULL) == EOF) {
+			printf("Can't remount for read-write. (%s)\n",
+			       strerror(errno));
 			return 1;
 		}
 		remount_root = 1;
 	}
-	
+
 	/* Exclude nonexistent policy. */
-	if (access(proc_policy_system_policy, R_OK)) save_system_policy = 0;
-	if (access(proc_policy_exception_policy, R_OK)) save_exception_policy = 0;
-	if (access(proc_policy_domain_policy, R_OK)) save_domain_policy = 0;
-	
-	if (save_profile) MoveProcToFile(proc_policy_profile, write_to_stdout ? NULL : disk_policy_profile);
-	
-	if (save_manager) MoveProcToFile(proc_policy_manager, write_to_stdout ? NULL : disk_policy_manager);
-	
+	if (access(proc_policy_system_policy, R_OK))
+		save_system_policy = 0;
+	if (access(proc_policy_exception_policy, R_OK))
+		save_exception_policy = 0;
+	if (access(proc_policy_domain_policy, R_OK))
+		save_domain_policy = 0;
+
+	if (write_to_stdout) {
+		if (save_profile)
+			cat_file(proc_policy_profile);
+		else if (save_manager)
+			cat_file(proc_policy_manager);
+		else if (save_system_policy)
+			cat_file(proc_policy_system_policy);
+		else if (save_exception_policy)
+			cat_file(proc_policy_exception_policy);
+		else if (save_domain_policy)
+			cat_file(proc_policy_domain_policy);
+		goto done;
+	}
+	if (save_profile)
+		move_proc_to_file(proc_policy_profile, base_policy_profile,
+				  disk_policy_profile);
+	if (save_manager)
+		move_proc_to_file(proc_policy_manager, base_policy_manager,
+				  disk_policy_manager);
+
 	if (save_system_policy) {
-		snprintf(filename, sizeof(filename) - 1, "system_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if (MoveProcToFile(proc_policy_system_policy, write_to_stdout ? NULL : filename) && !write_to_stdout) {
-			if (!force_save && IsIdenticalFile("system_policy.conf", filename)) {
+		snprintf(filename, sizeof(filename) - 1,
+			 "system_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		if (move_proc_to_file(proc_policy_system_policy,
+				      base_policy_system_policy, filename)
+		    && !write_to_stdout) {
+			if (!force_save &&
+			    is_identical_file("system_policy.conf", filename)) {
 				unlink(filename);
 			} else {
 				unlink("system_policy.conf");
@@ -477,11 +834,18 @@
 			}
 		}
 	}
-	
+
 	if (save_exception_policy) {
-		snprintf(filename, sizeof(filename) - 1, "exception_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if (MoveProcToFile(proc_policy_exception_policy, write_to_stdout ? NULL : filename) && !write_to_stdout) {
-			if (!force_save && IsIdenticalFile("exception_policy.conf", filename)) {
+		snprintf(filename, sizeof(filename) - 1,
+			 "exception_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		if (move_proc_to_file(proc_policy_exception_policy,
+				      base_policy_exception_policy, filename)
+		    && !write_to_stdout) {
+			if (!force_save &&
+			    is_identical_file("exception_policy.conf",
+					      filename)) {
 				unlink(filename);
 			} else {
 				unlink("exception_policy.conf");
@@ -489,11 +853,18 @@
 			}
 		}
 	}
-	
+
 	if (save_domain_policy) {
-		snprintf(filename, sizeof(filename) - 1, "domain_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if (MoveProcToFile(proc_policy_domain_policy, write_to_stdout ? NULL : filename) && !write_to_stdout) {
-			if (!force_save && IsIdenticalFile("domain_policy.conf", filename)) {
+		snprintf(filename, sizeof(filename) - 1,
+			 "domain_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		if (save_domain_policy_with_diff(proc_policy_domain_policy,
+						 base_policy_domain_policy,
+						 filename)
+		    && !write_to_stdout) {
+			if (!force_save &&
+			    is_identical_file("domain_policy.conf", filename)) {
 				unlink(filename);
 			} else {
 				unlink("domain_policy.conf");
@@ -501,54 +872,93 @@
 			}
 		}
 	}
-	
-	if (remount_root) mount("/", "/", "rootfs", MS_REMOUNT | MS_RDONLY, NULL);
+done:
+	if (remount_root)
+		mount("/", "/", "rootfs", MS_REMOUNT | MS_RDONLY, NULL);
 	return 0;
+usage:
+	printf("%s [s][e][d][a][f][p][m][-]\n"
+	       "s : Save system_policy.\n"
+	       "e : Save exception_policy.\n"
+	       "d : Save domain_policy.\n"
+	       "a : Save system_policy,exception_policy,domain_policy.\n"
+	       "p : Save profile.\n"
+	       "m : Save manager.\n"
+	       "- : Write policy to stdout. "
+	       "(Only one of 'sedpm' is possible when using '-'.)\n"
+	       "f : Save even if on-disk policy and on-memory policy "
+	       "are the same. (Valid for 'sed'.)\n\n"
+	       "If no options given, this program assumes 'a' and 'f' "
+	       "are given.\n", argv[0]);
+	return 0;
 }
 
 /***** savepolicy end *****/
 
 /***** loadpolicy start *****/
 
-static void MoveFileToProc(const char *src, const char *dest) {
-	FILE *file_fp, *proc_fp;
-	if ((proc_fp = fopen(dest, "w")) == NULL) {
+static void move_file_to_proc(const char *base, const char *src,
+			      const char *dest)
+{
+	FILE *file_fp = stdin;
+	FILE *base_fp;
+	FILE *proc_fp = fopen(dest, "w");
+	if (!proc_fp) {
 		fprintf(stderr, "Can't open %s\n", dest);
 		return;
 	}
-	if ((file_fp = src ? fopen(src, "r") : stdin) == NULL) {
-		fprintf(stderr, "Can't open %s\n", src);
-		fclose(proc_fp);
-		return;
+	if (src) {
+		file_fp = fopen(src, "r");
+		if (!file_fp) {
+			fprintf(stderr, "Can't open %s\n", src);
+			fclose(proc_fp);
+			return;
+		}
 	}
 	get();
+	base_fp = fopen(base, "r");
+	if (base_fp) {
+		while (freadline(base_fp)) {
+			if (shared_buffer[0])
+				fprintf(proc_fp, "%s\n", shared_buffer);
+		}
+		fclose(base_fp);
+	}
 	while (freadline(file_fp)) {
-		if (shared_buffer[0]) fprintf(proc_fp, "%s\n", shared_buffer);
+		if (shared_buffer[0])
+			fprintf(proc_fp, "%s\n", shared_buffer);
 	}
 	put();
 	fclose(proc_fp);
-	if (file_fp != stdin) fclose(file_fp);
+	if (file_fp != stdin)
+		fclose(file_fp);
 }
 
-static void DeleteProcPolicy(const char *name) {
+static void delete_proc_policy(const char *name)
+{
 	FILE *proc_write_fp = fopen(name, "w");
 	FILE *proc_read_fp = fopen(name, "r");
 	if (!proc_write_fp || !proc_read_fp) {
 		fprintf(stderr, "Can't open %s\n", name);
-		if (proc_write_fp) fclose(proc_write_fp);
-		if (proc_read_fp) fclose(proc_read_fp);
+		if (proc_write_fp)
+			fclose(proc_write_fp);
+		if (proc_read_fp)
+			fclose(proc_read_fp);
 		return;
 	}
 	get();
 	while (freadline(proc_read_fp)) {
-		if (shared_buffer[0]) fprintf(proc_write_fp, "delete %s\n", shared_buffer);
+		if (shared_buffer[0])
+			fprintf(proc_write_fp, "delete %s\n", shared_buffer);
 	}
 	put();
 	fclose(proc_read_fp);
 	fclose(proc_write_fp);
 }
 
-static void LoadDomainPolicy(const char *src, const char *dest) {
+static void update_domain_policy(const char *base, const char *src,
+				 const char *dest)
+{
 	int new_index;
 	int old_index;
 	struct path_info reserved;
@@ -559,42 +969,61 @@
 	}
 	reserved.name = "";
 	fill_path_info(&reserved);
-	ReadDomainPolicy(src);
-	SwapDomainList();
-	ReadDomainPolicy(dest);
-	SwapDomainList();
+	read_domain_policy(base);
+	read_domain_policy(src);
+	swap_domain_list();
+	read_domain_policy(dest);
+	swap_domain_list();
 	for (new_index = 0; new_index < domain_list_count; new_index++) {
 		int i;
-		const char *domainname = DomainName(new_index);
-		const struct path_info **new_string_ptr = domain_list[new_index].string_ptr;
-		const int new_string_count = domain_list[new_index].string_count;
-		SwapDomainList(); old_index = FindDomain(domainname, 0, 0); SwapDomainList();
+		int j;
+		const char *domainname = domain_name(new_index);
+		const struct path_info **new_string_ptr
+			= domain_list[new_index].string_ptr;
+		const int new_string_count
+			= domain_list[new_index].string_count;
+		const struct path_info **old_string_ptr;
+		int old_string_count;
+		swap_domain_list();
+		old_index = find_domain(domainname, 0, 0);
+		swap_domain_list();
 		fprintf(proc_fp, "%s\n", domainname);
-		if (old_index >= 0) {
-			int j;
-			/* Old policy for this domain found. */
-			const struct path_info **old_string_ptr = shadow_domain_list[old_index].string_ptr;
-			const int old_string_count = shadow_domain_list[old_index].string_count;
-			shadow_domain_list[old_index].domainname = &reserved; /* Don't delete this domain later. */
-			for (j = 0; j < old_string_count; j++) {
-				for (i = 0; i < new_string_count; i++) {
-					if (new_string_ptr[i] == old_string_ptr[j]) break;
-				}
-				/* Delete this entry from old policy if not found in new policy. */
-				if (i == new_string_count) fprintf(proc_fp, "delete %s\n", old_string_ptr[j]->name);
+		if (old_index == EOF)
+			goto not_found;
+
+		/* Old policy for this domain found. */
+		old_string_ptr = shadow_domain_list[old_index].string_ptr;
+		old_string_count = shadow_domain_list[old_index].string_count;
+		/* Don't delete this domain later. */
+		shadow_domain_list[old_index].domainname = &reserved;
+		for (j = 0; j < old_string_count; j++) {
+			for (i = 0; i < new_string_count; i++) {
+				if (new_string_ptr[i] == old_string_ptr[j])
+					break;
 			}
+			/* Delete this entry from old policy if not found
+			   in new policy. */
+			if (i == new_string_count)
+				fprintf(proc_fp, "delete %s\n",
+					old_string_ptr[j]->name);
 		}
+not_found:
 		/* Append entries defined in new policy. */
-		for (i = 0; i < new_string_count; i++) fprintf(proc_fp, "%s\n", new_string_ptr[i]->name);
+		for (i = 0; i < new_string_count; i++)
+			fprintf(proc_fp, "%s\n", new_string_ptr[i]->name);
 	}
 	/* Delete all domains that are not defined in new policy. */
 	for (old_index = 0; old_index < shadow_domain_list_count; old_index++) {
-		if (shadow_domain_list[old_index].domainname != &reserved) fprintf(proc_fp, "delete %s\n", shadow_domain_list[old_index].domainname->name);
+		if (shadow_domain_list[old_index].domainname == &reserved)
+			continue;
+		fprintf(proc_fp, "delete %s\n",
+			shadow_domain_list[old_index].domainname->name);
 	}
 	fclose(proc_fp);
 }
 
-int loadpolicy_main(int argc, char *argv[]) {
+int loadpolicy_main(int argc, char *argv[])
+{
 	int read_from_stdin = 0;
 	int load_profile = 0;
 	int load_manager = 0;
@@ -603,7 +1032,8 @@
 	int load_domain_policy = 0;
 	int refresh_policy = 0;
 	if (access(proc_policy_dir, F_OK)) {
-		fprintf(stderr, "You can't run this program for this kernel.\n");
+		fprintf(stderr,
+			"You can't run this program for this kernel.\n");
 		return 0;
 	}
 	if (argc == 1) {
@@ -620,27 +1050,26 @@
 			char *p = strchr(ptr, 'p');
 			char *m = strchr(ptr, 'm');
 			char *i = strchr(ptr, '-');
-			if (s || a) load_system_policy = 1;
-			if (e || a) load_exception_policy = 1;
-			if (d || a) load_domain_policy = 1;
-			if (p) load_profile = 1;
-			if (m) load_manager = 1;
-			if (f) refresh_policy = 1;
-			if (i) read_from_stdin = 1;
-			if (strcspn(ptr, "sedafpm-") ||
-			    (read_from_stdin && load_system_policy + load_exception_policy + load_domain_policy + load_profile + load_manager != 1)) {
-			usage: ;
-				printf("%s [s][e][d][a][f][p][m][-]\n"
-				       "s : Load system_policy.\n"
-				       "e : Load exception_policy.\n"
-				       "d : Load domain_policy.\n"
-				       "a : Load system_policy,exception_policy,domain_policy.\n"
-				       "p : Load profile.\n"
-				       "m : Load manager.\n"
-				       "- : Read policy from stdin. (Only one of 'sedpm' is possible when using '-'.)\n"
-				       "f : Delete on-memory policy before loading on-disk policy. (Valid for 'sed'.)\n\n", argv[0]);
-				return 0;
-			}
+			if (s || a)
+				load_system_policy = 1;
+			if (e || a)
+				load_exception_policy = 1;
+			if (d || a)
+				load_domain_policy = 1;
+			if (p)
+				load_profile = 1;
+			if (m)
+				load_manager = 1;
+			if (f)
+				refresh_policy = 1;
+			if (i)
+				read_from_stdin = 1;
+			if (strcspn(ptr, "sedafpm-"))
+				goto usage;
+			if (read_from_stdin && load_system_policy +
+			    load_exception_policy + load_domain_policy +
+			    load_profile + load_manager != 1)
+				goto usage;
 		}
 	}
 	if (chdir(disk_policy_dir)) {
@@ -648,106 +1077,318 @@
 		return 1;
 	}
 
-	if (load_profile) MoveFileToProc(read_from_stdin ? NULL : disk_policy_profile, proc_policy_profile);
-	
-	if (load_manager) MoveFileToProc(read_from_stdin ? NULL : disk_policy_manager, proc_policy_manager);
-	
+	if (load_profile) {
+		if (read_from_stdin)
+			move_file_to_proc(NULL, NULL, proc_policy_profile);
+		else
+			move_file_to_proc(base_policy_profile,
+					  disk_policy_profile,
+					  proc_policy_profile);
+	}
+
+	if (load_manager) {
+		if (read_from_stdin)
+			move_file_to_proc(NULL, NULL, proc_policy_manager);
+		else
+			move_file_to_proc(base_policy_manager,
+					  disk_policy_manager,
+					  proc_policy_manager);
+	}
+
 	if (load_system_policy) {
-		if (refresh_policy) DeleteProcPolicy(proc_policy_system_policy);
-		MoveFileToProc(read_from_stdin ? NULL : disk_policy_system_policy, proc_policy_system_policy);
+		if (refresh_policy)
+			delete_proc_policy(proc_policy_system_policy);
+		if (read_from_stdin)
+			move_file_to_proc(NULL, NULL,
+					  proc_policy_system_policy);
+		else
+			move_file_to_proc(base_policy_system_policy,
+					  disk_policy_system_policy,
+					  proc_policy_system_policy);
 	}
-	
+
 	if (load_exception_policy) {
-		if (refresh_policy) DeleteProcPolicy(proc_policy_exception_policy);
-		MoveFileToProc(read_from_stdin ? NULL : disk_policy_exception_policy, proc_policy_exception_policy);
+		if (refresh_policy)
+			delete_proc_policy(proc_policy_exception_policy);
+		if (read_from_stdin)
+			move_file_to_proc(NULL, NULL,
+					  proc_policy_exception_policy);
+		else
+			move_file_to_proc(base_policy_exception_policy,
+					  disk_policy_exception_policy,
+					  proc_policy_exception_policy);
 	}
 
 	if (load_domain_policy) {
 		if (refresh_policy) {
-			LoadDomainPolicy(read_from_stdin ? NULL : disk_policy_domain_policy, proc_policy_domain_policy);
+			if (read_from_stdin)
+				update_domain_policy(NULL, NULL,
+						     proc_policy_domain_policy);
+			else
+				update_domain_policy(base_policy_domain_policy,
+						     disk_policy_domain_policy,
+						     proc_policy_domain_policy);
 		} else {
-			MoveFileToProc(read_from_stdin ? NULL : disk_policy_domain_policy, proc_policy_domain_policy);
+			if (read_from_stdin)
+				move_file_to_proc(NULL, NULL,
+						  proc_policy_domain_policy);
+			else
+				move_file_to_proc(base_policy_domain_policy,
+						  disk_policy_domain_policy,
+						  proc_policy_domain_policy);
 		}
 	}
 	return 0;
+usage:
+	printf("%s [s][e][d][a][f][p][m][-]\n"
+	       "s : Load system_policy.\n"
+	       "e : Load exception_policy.\n"
+	       "d : Load domain_policy.\n"
+	       "a : Load system_policy,exception_policy,domain_policy.\n"
+	       "p : Load profile.\n"
+	       "m : Load manager.\n"
+	       "- : Read policy from stdin. "
+	       "(Only one of 'sedpm' is possible when using '-'.)\n"
+	       "f : Delete on-memory policy before loading on-disk policy. "
+	       "(Valid for 'sed'.)\n\n", argv[0]);
+	return 0;
 }
 
 /***** loadpolicy end *****/
 
 /***** editpolicy start *****/
 
+#define DIRECTIVE_1                                 0
+#define DIRECTIVE_2                                 1
+#define DIRECTIVE_3                                 2
+#define DIRECTIVE_4                                 3
+#define DIRECTIVE_5                                 4
+#define DIRECTIVE_6                                 5
+#define DIRECTIVE_7                                 6
+#define DIRECTIVE_ALLOW_EXECUTE                     7
+#define DIRECTIVE_ALLOW_READ                        8
+#define DIRECTIVE_ALLOW_WRITE                       9
+#define DIRECTIVE_ALLOW_READ_WRITE                 10
+#define DIRECTIVE_ALLOW_CREATE                     11
+#define DIRECTIVE_ALLOW_UNLINK                     12
+#define DIRECTIVE_ALLOW_MKDIR                      13
+#define DIRECTIVE_ALLOW_RMDIR                      14
+#define DIRECTIVE_ALLOW_MKFIFO                     15
+#define DIRECTIVE_ALLOW_MKSOCK                     16
+#define DIRECTIVE_ALLOW_MKBLOCK                    17
+#define DIRECTIVE_ALLOW_MKCHAR                     18
+#define DIRECTIVE_ALLOW_TRUNCATE                   19
+#define DIRECTIVE_ALLOW_SYMLINK                    20
+#define DIRECTIVE_ALLOW_LINK                       21
+#define DIRECTIVE_ALLOW_RENAME                     22
+#define DIRECTIVE_ALLOW_REWRITE                    23
+#define DIRECTIVE_ALLOW_ARGV0                      24
+#define DIRECTIVE_ALLOW_SIGNAL                     25
+#define DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_BIND    26
+#define DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_CONNECT 27
+#define DIRECTIVE_ALLOW_NETWORK_TCP_BIND           28
+#define DIRECTIVE_ALLOW_NETWORK_TCP_LISTEN         29
+#define DIRECTIVE_ALLOW_NETWORK_TCP_CONNECT        30
+#define DIRECTIVE_ALLOW_NETWORK_TCP_ACCEPT         31
+#define DIRECTIVE_ALLOW_NETWORK_RAW_BIND           32
+#define DIRECTIVE_ALLOW_NETWORK_RAW_CONNECT        33
+#define DIRECTIVE_ALLOW_ENV                        34
+#define DIRECTIVE_ADDRESS_GROUP                    35
+#define DIRECTIVE_AGGREGATOR                       36
+#define DIRECTIVE_ALIAS                            37
+#define DIRECTIVE_ALLOW_CAPABILITY                 38
+#define DIRECTIVE_ALLOW_CHROOT                     39
+#define DIRECTIVE_ALLOW_MOUNT                      40
+#define DIRECTIVE_ALLOW_PIVOT_ROOT                 41
+#define DIRECTIVE_DENY_AUTOBIND                    42
+#define DIRECTIVE_DENY_REWRITE                     43
+#define DIRECTIVE_DENY_UNMOUNT                     44
+#define DIRECTIVE_FILE_PATTERN                     45
+#define DIRECTIVE_EXECUTE_HANDLER                  46
+#define DIRECTIVE_DENIED_EXECUTE_HANDLER           47
+#define DIRECTIVE_IGNORE_GLOBAL_ALLOW_ENV          48
+#define DIRECTIVE_IGNORE_GLOBAL_ALLOW_READ         49
+#define DIRECTIVE_INITIALIZE_DOMAIN                50
+#define DIRECTIVE_KEEP_DOMAIN                      51
+#define DIRECTIVE_NO_INITIALIZE_DOMAIN             52
+#define DIRECTIVE_NO_KEEP_DOMAIN                   53
+#define DIRECTIVE_PATH_GROUP                       54
+#define DIRECTIVE_QUOTA_EXCEEDED                   55
+#define DIRECTIVE_USE_PROFILE                      56
+#define MAX_DIRECTIVE_INDEX                        57
+
+static struct {
+	const char *original;
+	const char *alias;
+	int original_len;
+	int alias_len;
+} directives[MAX_DIRECTIVE_INDEX] = {
+	[DIRECTIVE_1]  = { "1", NULL, 0, 0 },
+	[DIRECTIVE_2]  = { "2", NULL, 0, 0 },
+	[DIRECTIVE_3]  = { "3", NULL, 0, 0 },
+	[DIRECTIVE_4]  = { "4", NULL, 0, 0 },
+	[DIRECTIVE_5]  = { "5", NULL, 0, 0 },
+	[DIRECTIVE_6]  = { "6", NULL, 0, 0 },
+	[DIRECTIVE_7]  = { "7", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_EXECUTE]    = { "allow_execute", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_READ]       = { "allow_read", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_WRITE]      = { "allow_write", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_READ_WRITE] = { "allow_read/write", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_CREATE]     = { "allow_create", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_UNLINK]     = { "allow_unlink", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MKDIR]      = { "allow_mkdir", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_RMDIR]      = { "allow_rmdir", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MKFIFO]     = { "allow_mkfifo", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MKSOCK]     = { "allow_mksock", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MKBLOCK]    = { "allow_mkblock", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MKCHAR]     = { "allow_mkchar", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_TRUNCATE]   = { "allow_truncate", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_SYMLINK]    = { "allow_symlink", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_LINK]       = { "allow_link", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_RENAME]     = { "allow_rename", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_REWRITE]    = { "allow_rewrite", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_ARGV0]      = { "allow_argv0", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_SIGNAL]     = { "allow_signal", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_BIND] = {
+		"allow_network UDP bind", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_CONNECT] = {
+		"allow_network UDP connect", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_TCP_BIND] = {
+		"allow_network TCP bind", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_TCP_LISTEN] = {
+		"allow_network TCP listen", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_TCP_CONNECT] = {
+		"allow_network TCP connect", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_TCP_ACCEPT] = {
+		"allow_network TCP accept", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_RAW_BIND] = {
+		"allow_network RAW bind", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_NETWORK_RAW_CONNECT] = {
+		"allow_network RAW connect", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_ENV]        = { "allow_env", NULL, 0, 0 },
+	[DIRECTIVE_ADDRESS_GROUP]    = { "address_group", NULL, 0, 0 },
+	[DIRECTIVE_AGGREGATOR]       = { "aggregator", NULL, 0, 0 },
+	[DIRECTIVE_ALIAS]            = { "alias", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_CAPABILITY] = { "allow_capability", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_CHROOT]     = { "allow_chroot", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_MOUNT]      = { "allow_mount", NULL, 0, 0 },
+	[DIRECTIVE_ALLOW_PIVOT_ROOT] = { "allow_pivot_root", NULL, 0, 0 },
+	[DIRECTIVE_DENY_AUTOBIND]    = { "deny_autobind", NULL, 0, 0 },
+	[DIRECTIVE_DENY_REWRITE]     = { "deny_rewrite", NULL, 0, 0 },
+	[DIRECTIVE_DENY_UNMOUNT]     = { "deny_unmount", NULL, 0, 0 },
+	[DIRECTIVE_FILE_PATTERN]     = { "file_pattern", NULL, 0, 0 },
+	[DIRECTIVE_EXECUTE_HANDLER]  = { "execute_handler", NULL, 0, 0 },
+	[DIRECTIVE_DENIED_EXECUTE_HANDLER] = {
+		"denied_execute_handler", NULL, 0, 0 },
+	[DIRECTIVE_IGNORE_GLOBAL_ALLOW_ENV] = {
+		"ignore_global_allow_env", NULL, 0, 0 },
+	[DIRECTIVE_IGNORE_GLOBAL_ALLOW_READ] = {
+		"ignore_global_allow_read", NULL, 0, 0 },
+	[DIRECTIVE_INITIALIZE_DOMAIN]    = { "initialize_domain", NULL, 0, 0 },
+	[DIRECTIVE_KEEP_DOMAIN]          = { "keep_domain", NULL, 0, 0 },
+	[DIRECTIVE_NO_INITIALIZE_DOMAIN] = {
+		"no_initialize_domain", NULL, 0, 0 },
+	[DIRECTIVE_NO_KEEP_DOMAIN]       = { "no_keep_domain", NULL, 0, 0 },
+	[DIRECTIVE_PATH_GROUP]       = { "path_group", NULL, 0, 0 },
+	[DIRECTIVE_QUOTA_EXCEEDED]   = { "quota_exceeded", NULL, 0, 0 },
+	[DIRECTIVE_USE_PROFILE]      = { "use_profile", NULL, 0, 0 },
+};
+
 static const char *policy_file = DOMAIN_POLICY_FILE;
 static const char *list_caption = NULL;
 static char *current_domain = NULL;
 
 static int current_screen = SCREEN_DOMAIN_LIST;
 
-// List for generic policy.
-static char **generic_acl_list = NULL;
+/* List for generic policy. */
+static struct generic_acl {
+	u8 directive;
+	u8 selected;
+	const char *operand;
+} *generic_acl_list = NULL;
 static int generic_acl_list_count = 0;
-static unsigned char *generic_acl_list_selected = NULL;
 
 static struct domain_keeper_entry *domain_keeper_list = NULL;
 static int domain_keeper_list_len = 0;
 static struct domain_initializer_entry *domain_initializer_list = NULL;
 static int domain_initializer_list_len = 0;
 
-///////////////////////////  ACL HANDLER  //////////////////////////////
+/* ACL HANDLER  */
 
-static const struct domain_keeper_entry *IsDomainKeeper(const struct path_info *domainname, const char *program) {
+static const struct domain_keeper_entry *
+is_domain_keeper(const struct path_info *domainname, const char *program)
+{
 	int i;
 	const struct domain_keeper_entry *flag = NULL;
 	struct path_info last_name;
-	if ((last_name.name = strrchr(domainname->name, ' ')) != NULL) last_name.name++;
-	else last_name.name = domainname->name;
+	last_name.name = strrchr(domainname->name, ' ');
+	if (last_name.name)
+		last_name.name++;
+	else
+		last_name.name = domainname->name;
 	fill_path_info(&last_name);
 	for (i = 0; i < domain_keeper_list_len; i++) {
 		struct domain_keeper_entry *ptr = &domain_keeper_list[i];
 		if (!ptr->is_last_name) {
-			if (pathcmp(ptr->domainname, domainname)) continue;
+			if (pathcmp(ptr->domainname, domainname))
+				continue;
 		} else {
-			if (pathcmp(ptr->domainname, &last_name)) continue;
+			if (pathcmp(ptr->domainname, &last_name))
+				continue;
 		}
-		if (ptr->program && strcmp(ptr->program->name, program)) continue;
-		if (ptr->is_not) return NULL;
+		if (ptr->program && strcmp(ptr->program->name, program))
+			continue;
+		if (ptr->is_not)
+			return NULL;
 		flag = ptr;
 	}
 	return flag;
 }
 
-static const struct domain_initializer_entry *IsDomainInitializer(const struct path_info *domainname, const char *program) {
+static const struct domain_initializer_entry *
+is_domain_initializer(const struct path_info *domainname, const char *program)
+{
 	int i;
 	const struct domain_initializer_entry *flag = NULL;
 	struct path_info last_name;
-	if ((last_name.name = strrchr(domainname->name, ' ')) != NULL) last_name.name++;
-	else last_name.name = domainname->name;
+	last_name.name = strrchr(domainname->name, ' ');
+	if (last_name.name)
+		last_name.name++;
+	else
+		last_name.name = domainname->name;
 	fill_path_info(&last_name);
 	for (i = 0; i < domain_initializer_list_len; i++) {
-		struct domain_initializer_entry *ptr = &domain_initializer_list[i];
+		struct domain_initializer_entry *ptr
+			= &domain_initializer_list[i];
 		if (ptr->domainname) {
 			if (!ptr->is_last_name) {
-				if (pathcmp(ptr->domainname, domainname)) continue;
+				if (pathcmp(ptr->domainname, domainname))
+					continue;
 			} else {
-				if (pathcmp(ptr->domainname, &last_name)) continue;
+				if (pathcmp(ptr->domainname, &last_name))
+					continue;
 			}
 		}
-		if (strcmp(ptr->program->name, program)) continue;
-		if (ptr->is_not) return NULL;
+		if (strcmp(ptr->program->name, program))
+			continue;
+		if (ptr->is_not)
+			return NULL;
 		flag = ptr;
 	}
 	return flag;
 }
 
-///////////////////////////  UTILITY FUNCTIONS  //////////////////////////////
+/* UTILITY FUNCTIONS */
 
 static int offline_mode = 0;
 static int persistent_fd = EOF;
 
-static void SendFD(char *data, int *fd) {
+static void send_fd(char *data, int *fd)
+{
 	struct msghdr msg;
 	struct iovec iov = { data, strlen(data) };
 	char cmsg_buf[CMSG_SPACE(sizeof(int))];
-	struct cmsghdr *cmsg = (struct cmsghdr *) cmsg_buf; 
+	struct cmsghdr *cmsg = (struct cmsghdr *) cmsg_buf;
 	memset(&msg, 0, sizeof(msg));
 	msg.msg_iov = &iov;
 	msg.msg_iovlen = 1;
@@ -755,13 +1396,15 @@
 	msg.msg_controllen = sizeof(cmsg_buf);
 	cmsg->cmsg_level = SOL_SOCKET;
 	cmsg->cmsg_type = SCM_RIGHTS;
-	msg.msg_controllen = cmsg->cmsg_len = CMSG_LEN(sizeof(int));
+	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
+	msg.msg_controllen = cmsg->cmsg_len;
 	memmove(CMSG_DATA(cmsg), fd, sizeof(int));
 	sendmsg(persistent_fd, &msg, 0);
 	close(*fd);
 }
 
-static FILE *open_read(const char *filename) {
+static FILE *open_read(const char *filename)
+{
 	if (offline_mode) {
 		char request[1024];
 		int fd[2];
@@ -770,20 +1413,26 @@
 			fprintf(stderr, "socketpair()\n");
 			exit(1);
 		}
-		if (shutdown(fd[0], SHUT_WR) || (fp = fdopen(fd[0], "r")) == NULL) {
-			close(fd[1]); close(fd[0]);
-			exit(1);
-		}
+		if (shutdown(fd[0], SHUT_WR))
+			goto out;
+		fp = fdopen(fd[0], "r");
+		if (!fp)
+			goto out;
 		memset(request, 0, sizeof(request));
 		snprintf(request, sizeof(request) - 1, "GET %s", filename);
-		SendFD(request, &fd[1]);
+		send_fd(request, &fd[1]);
 		return fp;
+out:
+		close(fd[1]);
+		close(fd[0]);
+		exit(1);
 	} else {
 		return fopen(filename, "r");
 	}
 }
 
-static FILE *open_write(const char *filename) {
+static FILE *open_write(const char *filename)
+{
 	if (offline_mode) {
 		char request[1024];
 		int fd[2];
@@ -791,172 +1440,245 @@
 			fprintf(stderr, "socketpair()\n");
 			exit(1);
 		}
-		if (shutdown(fd[0], SHUT_RD)) {
-			close(fd[1]); close(fd[0]);
-			exit(1);
-		}
+		if (shutdown(fd[0], SHUT_RD))
+			goto out;
 		memset(request, 0, sizeof(request));
 		snprintf(request, sizeof(request) - 1, "POST %s", filename);
-		SendFD(request, &fd[1]);
+		send_fd(request, &fd[1]);
 		return fdopen(fd[0], "w");
+out:
+		close(fd[1]);
+		close(fd[0]);
+		exit(1);
 	} else {
 		return fdopen(open(filename, O_WRONLY), "w");
 	}
 }
 
-static char *map_perm_keyword(const u8 forward, const char *line);
-static int string_acl_compare(const void *a, const void *b);
+static u8 find_directive(const u8 forward, char *line);
+static int generic_acl_compare(const void *a, const void *b);
 
-static void ReadGenericPolicy(void) {
+static void read_generic_policy(void)
+{
 	FILE *fp;
-	while (generic_acl_list_count) free(generic_acl_list[--generic_acl_list_count]);
-	if ((fp = open_read(policy_file)) != NULL) {
+	int flag = 0;
+	while (generic_acl_list_count)
+		free((void *)
+		     generic_acl_list[--generic_acl_list_count].operand);
+	fp = open_read(policy_file);
+	if (!fp)
+		return;
+	get();
+	while (freadline(fp)) {
+		u8 directive;
+		char *cp;
 		if (current_screen == SCREEN_ACL_LIST) {
-			int flag = 0;
-			get();
-			while (freadline(fp)) {
-				if (IsDomainDef(shared_buffer)) {
-					flag = strcmp(shared_buffer, current_domain) == 0 ? 1 : 0;
-				} else if (flag && shared_buffer[0] && strncmp(shared_buffer, KEYWORD_USE_PROFILE, KEYWORD_USE_PROFILE_LEN)) {
-					if ((generic_acl_list = (char **) realloc(generic_acl_list, (generic_acl_list_count + 1) * sizeof(char *))) == NULL
-					    || (generic_acl_list[generic_acl_list_count++] = strdup(map_perm_keyword(1, shared_buffer))) == NULL) OutOfMemory();
-				}
+			if (IsDomainDef(shared_buffer)) {
+				flag = !strcmp(shared_buffer, current_domain);
+				continue;
 			}
-			put();
-			qsort(generic_acl_list, generic_acl_list_count, sizeof(char *), string_acl_compare);
+			if (!flag || !shared_buffer[0] ||
+			    !strncmp(shared_buffer, KEYWORD_USE_PROFILE,
+				     KEYWORD_USE_PROFILE_LEN))
+				continue;
 		} else {
-			get();
-			while (freadline(fp)) {
-				if (!shared_buffer[0]) continue;
-				if ((generic_acl_list = (char **) realloc(generic_acl_list, (generic_acl_list_count + 1) * sizeof(char *))) == NULL
-					|| (generic_acl_list[generic_acl_list_count++] = strdup(map_perm_keyword(1, shared_buffer))) == NULL) OutOfMemory();
-			}
-			put();
-			qsort(generic_acl_list, generic_acl_list_count, sizeof(char *), string_compare);
+			if (!shared_buffer[0])
+				continue;
 		}
-		fclose(fp);
+		directive = find_directive(1, shared_buffer);
+		if (directive == (u8) EOF)
+			continue;
+		generic_acl_list = realloc(generic_acl_list,
+					   (generic_acl_list_count + 1) *
+					   sizeof(struct generic_acl));
+		if (!generic_acl_list)
+			OutOfMemory();
+		cp = strdup(shared_buffer);
+		if (!cp)
+			OutOfMemory();
+		generic_acl_list[generic_acl_list_count].directive = directive;
+		generic_acl_list[generic_acl_list_count].selected = 0;
+		generic_acl_list[generic_acl_list_count++].operand = cp;
 	}
-	generic_acl_list_selected = realloc(generic_acl_list_selected, generic_acl_list_count);
-	if (generic_acl_list_count && !generic_acl_list_selected) OutOfMemory();
-	memset(generic_acl_list_selected, 0, generic_acl_list_count);
+	put();
+	qsort(generic_acl_list, generic_acl_list_count,
+	      sizeof(struct generic_acl), generic_acl_compare);
+	fclose(fp);
 }
 
-static int AddDomainInitializerEntry(const char *domainname, const char *program, const int is_not) {
+static int add_domain_initializer_entry(const char *domainname,
+					const char *program, const int is_not)
+{
+	void *vp;
 	struct domain_initializer_entry *ptr;
 	int is_last_name = 0;
-	if (!IsCorrectPath(program, 1, 0, -1)) return -EINVAL;
+	if (!IsCorrectPath(program, 1, 0, -1))
+		return -EINVAL;
 	if (domainname) {
-		if (IsCorrectPath(domainname, 1, -1, -1)) {
+		if (IsCorrectPath(domainname, 1, -1, -1))
 			is_last_name = 1;
-		} else if (!IsCorrectDomain(domainname)) {
+		else if (!IsCorrectDomain(domainname))
 			return -EINVAL;
-		}
 	}
-	if ((domain_initializer_list = (struct domain_initializer_entry *) realloc(domain_initializer_list, (domain_initializer_list_len + 1) * sizeof(struct domain_initializer_entry))) == NULL) OutOfMemory();
+	vp = realloc(domain_initializer_list,
+		     (domain_initializer_list_len + 1) *
+		     sizeof(struct domain_initializer_entry));
+	if (!vp)
+		OutOfMemory();
+	domain_initializer_list = vp;
 	ptr = &domain_initializer_list[domain_initializer_list_len++];
 	memset(ptr, 0, sizeof(struct domain_initializer_entry));
-	if ((ptr->program = SaveName(program)) == NULL) OutOfMemory();
-	if (domainname && (ptr->domainname = SaveName(domainname)) == NULL) OutOfMemory();
+	ptr->program = SaveName(program);
+	if (!ptr->program)
+		OutOfMemory();
+	if (domainname) {
+		ptr->domainname = SaveName(domainname);
+		if (!ptr->domainname)
+			OutOfMemory();
+	}
 	ptr->is_not = is_not;
 	ptr->is_last_name = is_last_name;
 	return 0;
 }
 
-static int AddDomainInitializerPolicy(char *data, const int is_not) {
+static int add_domain_initializer_policy(char *data, const int is_not)
+{
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
-		return AddDomainInitializerEntry(cp + 6, data, is_not);
+		return add_domain_initializer_entry(cp + 6, data, is_not);
 	} else {
-		return AddDomainInitializerEntry(NULL, data, is_not);
+		return add_domain_initializer_entry(NULL, data, is_not);
 	}
 }
 
-static int AddDomainKeeperEntry(const char *domainname, const char *program, const int is_not) {
+static int add_domain_keeper_entry(const char *domainname, const char *program,
+				   const int is_not)
+{
 	struct domain_keeper_entry *ptr;
 	int is_last_name = 0;
-	if (IsCorrectPath(domainname, 1, -1, -1)) {
+	if (IsCorrectPath(domainname, 1, -1, -1))
 		is_last_name = 1;
-	} else if (!IsCorrectDomain(domainname)) {
+	else if (!IsCorrectDomain(domainname))
 		return -EINVAL;
-	}
-	if (program && !IsCorrectPath(program, 1, 0, -1)) return -EINVAL;
-	if ((domain_keeper_list = (struct domain_keeper_entry *) realloc(domain_keeper_list, (domain_keeper_list_len + 1) * sizeof(struct domain_keeper_entry))) == NULL) OutOfMemory();
+	if (program && !IsCorrectPath(program, 1, 0, -1))
+		return -EINVAL;
+	domain_keeper_list = realloc(domain_keeper_list,
+				     (domain_keeper_list_len + 1) *
+				     sizeof(struct domain_keeper_entry));
+	if (!domain_keeper_list)
+		OutOfMemory();
 	ptr = &domain_keeper_list[domain_keeper_list_len++];
 	memset(ptr, 0, sizeof(struct domain_keeper_entry));
-	if ((ptr->domainname = SaveName(domainname)) == NULL) OutOfMemory();
-	if (program && (ptr->program = SaveName(program)) == NULL) OutOfMemory();
+	ptr->domainname = SaveName(domainname);
+	if (!ptr->domainname)
+		OutOfMemory();
+	if (program) {
+		ptr->program = SaveName(program);
+		if (!ptr->program)
+			OutOfMemory();
+	}
 	ptr->is_not = is_not;
 	ptr->is_last_name = is_last_name;
 	return 0;
 }
 
-static int AddDomainKeeperPolicy(char *data, const int is_not) {
+static int add_domain_keeper_policy(char *data, const int is_not)
+{
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
-		return AddDomainKeeperEntry(cp + 6, data, is_not);
+		return add_domain_keeper_entry(cp + 6, data, is_not);
 	} else {
-		return AddDomainKeeperEntry(data, NULL, is_not);
+		return add_domain_keeper_entry(data, NULL, is_not);
 	}
 }
 
-static int AddPathGroupEntry(const char *group_name, const char *member_name, const int is_delete) {
-	const struct path_info *saved_group_name, *saved_member_name;
-	int i, j;
+static int add_path_group_entry(const char *group_name, const char *member_name,
+				const int is_delete)
+{
+	const struct path_info *saved_group_name;
+	const struct path_info *saved_member_name;
+	int i;
+	int j;
 	struct path_group_entry *group = NULL;
 	if (!IsCorrectPath(group_name, 0, 0, 0) ||
-		!IsCorrectPath(member_name, 0, 0, 0)) return -EINVAL;
-	if ((saved_group_name = SaveName(group_name)) == NULL ||
-		(saved_member_name = SaveName(member_name)) == NULL) return -ENOMEM;
+	    !IsCorrectPath(member_name, 0, 0, 0))
+		return -EINVAL;
+	saved_group_name = SaveName(group_name);
+	saved_member_name = SaveName(member_name);
+	if (!saved_group_name || !saved_member_name)
+		return -ENOMEM;
 	for (i = 0; i < path_group_list_len; i++) {
 		group = &path_group_list[i];
-		if (saved_group_name != group->group_name) continue;
+		if (saved_group_name != group->group_name)
+			continue;
 		for (j = 0; j < group->member_name_len; j++) {
-			if (group->member_name[j] == saved_member_name) {
-				if (is_delete) {
-					while (j < group->member_name_len - 1) group->member_name[j] = group->member_name[j + 1];
-					group->member_name_len--;
-				} else {
-					return 0;
-				}
-			}
+			if (group->member_name[j] != saved_member_name)
+				continue;
+			if (!is_delete)
+				return 0;
+			while (j < group->member_name_len - 1)
+				group->member_name[j] =
+					group->member_name[j + 1];
+			group->member_name_len--;
+			return 0;
 		}
 		break;
 	}
-	if (is_delete) return -ENOENT;
+	if (is_delete)
+		return -ENOENT;
 	if (i == path_group_list_len) {
-		if ((path_group_list = (struct path_group_entry *) realloc(path_group_list, (path_group_list_len + 1) * sizeof(struct path_group_entry))) == NULL) OutOfMemory();
+		path_group_list = realloc(path_group_list,
+					  (path_group_list_len + 1) *
+					  sizeof(struct path_group_entry));
+		if (!path_group_list)
+			OutOfMemory();
 		group = &path_group_list[path_group_list_len++];
 		memset(group, 0, sizeof(struct path_group_entry));
 		group->group_name = saved_group_name;
 	}
-	if ((group->member_name = (const struct path_info **) realloc(group->member_name, (group->member_name_len + 1) * sizeof(const struct path_info *))) == NULL) OutOfMemory();
+	group->member_name = realloc(group->member_name,
+				     (group->member_name_len + 1)
+				     * sizeof(const struct path_info *));
+	if (!group->member_name)
+		OutOfMemory();
 	group->member_name[group->member_name_len++] = saved_member_name;
 	return 0;
 }
 
-static int AddPathGroupPolicy(char *data, const int is_delete) {
+static int add_path_group_policy(char *data, const int is_delete)
+{
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
-	return AddPathGroupEntry(data, cp, is_delete);
+	return add_path_group_entry(data, cp, is_delete);
 }
 
-static struct path_group_entry *FindPathGroup(const char *group_name) {
+static struct path_group_entry *find_path_group(const char *group_name)
+{
 	int i;
 	for (i = 0; i < path_group_list_len; i++) {
-		if (strcmp(group_name, path_group_list[i].group_name->name) == 0) return &path_group_list[i];
+		if (!strcmp(group_name, path_group_list[i].group_name->name))
+			return &path_group_list[i];
 	}
 	return NULL;
 }
 
-static int parse_ip(const char *address, struct ip_address_entry *entry) {
-	unsigned int min[8], max[8];
-	int i, j;
+static int parse_ip(const char *address, struct ip_address_entry *entry)
+{
+	unsigned int min[8];
+	unsigned int max[8];
+	int i;
+	int j;
 	memset(entry, 0, sizeof(*entry));
-	i = sscanf(address, "%u.%u.%u.%u-%u.%u.%u.%u", &min[0], &min[1], &min[2], &min[3], &max[0], &max[1], &max[2], &max[3]);
-	if (i == 4) for (j = 0; j < 4; j++) max[j] = min[j]; 
+	i = sscanf(address, "%u.%u.%u.%u-%u.%u.%u.%u",
+		   &min[0], &min[1], &min[2], &min[3],
+		   &max[0], &max[1], &max[2], &max[3]);
+	if (i == 4)
+		for (j = 0; j < 4; j++)
+			max[j] = min[j];
 	if (i == 4 || i == 8) {
 		for (j = 0; j < 4; j++) {
 			entry->min[j] = (u8) min[j];
@@ -965,13 +1687,19 @@
 		return 0;
 	}
 	i = sscanf(address, "%X:%X:%X:%X:%X:%X:%X:%X-%X:%X:%X:%X:%X:%X:%X:%X",
-		   &min[0], &min[1], &min[2], &min[3], &min[4], &min[5], &min[6], &min[7],
-		   &max[0], &max[1], &max[2], &max[3], &max[4], &max[5], &max[6], &max[7]);
-	if (i == 8) for (j = 0; j < 8; j++) max[j] = min[j]; 
+		   &min[0], &min[1], &min[2], &min[3],
+		   &min[4], &min[5], &min[6], &min[7],
+		   &max[0], &max[1], &max[2], &max[3],
+		   &max[4], &max[5], &max[6], &max[7]);
+	if (i == 8)
+		for (j = 0; j < 8; j++)
+			max[j] = min[j];
 	if (i == 8 || i == 16) {
 		for (j = 0; j < 8; j++) {
-			entry->min[j * 2] = (u8) (min[j] >> 8); entry->min[j * 2 + 1] = (u8) min[j]; 
-			entry->max[j * 2] = (u8) (max[j] >> 8); entry->max[j * 2 + 1] = (u8) max[j]; 
+			entry->min[j * 2] = (u8) (min[j] >> 8);
+			entry->min[j * 2 + 1] = (u8) min[j];
+			entry->max[j * 2] = (u8) (max[j] >> 8);
+			entry->max[j * 2 + 1] = (u8) max[j];
 		}
 		entry->is_ipv6 = 1;
 		return 0;
@@ -979,233 +1707,330 @@
 	return -EINVAL;
 }
 
-static int AddAddressGroupEntry(const char *group_name, const char *member_name, const int is_delete) {
+static int add_address_group_entry(const char *group_name,
+				   const char *member_name, const int is_delete)
+{
 	const struct path_info *saved_group_name;
-	int i, j;
+	int i;
+	int j;
 	struct ip_address_entry entry;
 	struct address_group_entry *group = NULL;
-	if (parse_ip(member_name, &entry)) return -EINVAL;
-	if (!IsCorrectPath(group_name, 0, 0, 0)) return -EINVAL;
-	if ((saved_group_name = SaveName(group_name)) == NULL) return -ENOMEM;
+	if (parse_ip(member_name, &entry))
+		return -EINVAL;
+	if (!IsCorrectPath(group_name, 0, 0, 0))
+		return -EINVAL;
+	saved_group_name = SaveName(group_name);
+	if (!saved_group_name)
+		return -ENOMEM;
 	for (i = 0; i < address_group_list_len; i++) {
 		group = &address_group_list[i];
-		if (saved_group_name != group->group_name) continue;
+		if (saved_group_name != group->group_name)
+			continue;
 		for (j = 0; j < group->member_name_len; j++) {
-			if (memcmp(&group->member_name[j], &entry, sizeof(entry)) == 0) {
-				if (is_delete) {
-					while (j < group->member_name_len - 1) group->member_name[j] = group->member_name[j + 1];
-					group->member_name_len--;
-				} else {
-					return 0;
-				}
-			}
+			if (memcmp(&group->member_name[j], &entry,
+				   sizeof(entry)))
+				continue;
+			if (!is_delete)
+				return 0;
+			while (j < group->member_name_len - 1)
+				group->member_name[j]
+					= group->member_name[j + 1];
+			group->member_name_len--;
+			return 0;
 		}
 		break;
 	}
-	if (is_delete) return -ENOENT;
+	if (is_delete)
+		return -ENOENT;
 	if (i == address_group_list_len) {
-		if ((address_group_list = (struct address_group_entry *) realloc(address_group_list, (address_group_list_len + 1) * sizeof(struct address_group_entry))) == NULL) OutOfMemory();
+		void *vp;
+		vp = realloc(address_group_list,
+			     (address_group_list_len + 1) *
+			     sizeof(struct address_group_entry));
+		if (!vp)
+			OutOfMemory();
+		address_group_list = vp;
 		group = &address_group_list[address_group_list_len++];
 		memset(group, 0, sizeof(struct address_group_entry));
 		group->group_name = saved_group_name;
 	}
-	if ((group->member_name = (struct ip_address_entry *) realloc(group->member_name, (group->member_name_len + 1) * sizeof(const struct ip_address_entry))) == NULL) OutOfMemory();
+	group->member_name = realloc(group->member_name,
+				     (group->member_name_len + 1) *
+				     sizeof(const struct ip_address_entry));
+	if (!group->member_name)
+		OutOfMemory();
 	group->member_name[group->member_name_len++] = entry;
 	return 0;
 }
 
-static int AddAddressGroupPolicy(char *data, const int is_delete) {
+static int add_address_group_policy(char *data, const int is_delete)
+{
 	char *cp = strchr(data, ' ');
-	if (!cp) return -EINVAL;
+	if (!cp)
+		return -EINVAL;
 	*cp++ = '\0';
-	return AddAddressGroupEntry(data, cp, is_delete);
+	return add_address_group_entry(data, cp, is_delete);
 }
 
-static struct address_group_entry *FindAddressGroup(const char *group_name) {
+static struct address_group_entry *find_address_group(const char *group_name)
+{
 	int i;
 	for (i = 0; i < address_group_list_len; i++) {
-		if (strcmp(group_name, address_group_list[i].group_name->name) == 0) return &address_group_list[i];
+		if (!strcmp(group_name, address_group_list[i].group_name->name))
+			return &address_group_list[i];
 	}
 	return NULL;
 }
 
-static void AssignDomainInitializerSource(const struct path_info *domainname, const char *program) {
-	if (IsDomainInitializer(domainname, program)) {
+static void assign_domain_initializer_source(const struct path_info *domainname,
+					     const char *program)
+{
+	if (is_domain_initializer(domainname, program)) {
 		get();
 		memset(shared_buffer, 0, shared_buffer_len);
-		snprintf(shared_buffer, shared_buffer_len - 1, "%s %s", domainname->name, program);
+		snprintf(shared_buffer, shared_buffer_len - 1, "%s %s",
+			 domainname->name, program);
 		NormalizeLine(shared_buffer);
-		if (FindOrAssignNewDomain(shared_buffer, 1, 0) == EOF) OutOfMemory();
+		if (find_or_assign_new_domain(shared_buffer, 1, 0) == EOF)
+			OutOfMemory();
 		put();
 	}
 }
 
-static int domainname_attribute_compare(const void *a, const void *b) {
-	const int k = strcmp(((struct domain_info *) a)->domainname->name, ((struct domain_info *) b)->domainname->name);
-	if (k > 0 || (k == 0 && ((struct domain_info *) a)->is_domain_initializer_source < ((struct domain_info *) b)->is_domain_initializer_source)) return 1;
+static int domainname_attribute_compare(const void *a, const void *b)
+{
+	const struct domain_info *a0 = a;
+	const struct domain_info *b0 = b;
+	const int k = strcmp(a0->domainname->name, b0->domainname->name);
+	if ((k > 0) || (!k && a0->is_dis < b0->is_dis))
+		return 1;
 	return k;
 }
 
 static int unnumbered_domain_count = 0;
 
-static void ReadDomainAndExceptionPolicy(void) {
+static void read_domain_and_exception_policy(void)
+{
 	FILE *fp;
-	int i, j;
-	ClearDomainPolicy();
+	int i;
+	int j;
+	int index;
+	int max_index;
+	clear_domain_policy();
 	domain_keeper_list_len = 0;
 	domain_initializer_list_len = 0;
-	while (path_group_list_len) free(path_group_list[--path_group_list_len].member_name);
-	//while (address_group_list_len) free(address_group_list[--address_group_list_len].member_name);
+	while (path_group_list_len)
+		free(path_group_list[--path_group_list_len].member_name);
+	/*
+	while (address_group_list_len)
+		free(address_group_list[--address_group_list_len].member_name);
+	*/
 	address_group_list_len = 0;
-	FindOrAssignNewDomain(ROOT_NAME, 0, 0);
+	find_or_assign_new_domain(ROOT_NAME, 0, 0);
 
-	// Load domain_initializer list, domain_keeper list.
-	if ((fp = open_read(EXCEPTION_POLICY_FILE)) != NULL) {
-		get();
-		while (freadline(fp)) {
-			if (strncmp(shared_buffer, KEYWORD_INITIALIZE_DOMAIN, KEYWORD_INITIALIZE_DOMAIN_LEN) == 0) {
-				AddDomainInitializerPolicy(shared_buffer + KEYWORD_INITIALIZE_DOMAIN_LEN, 0);
-			} else if (strncmp(shared_buffer, KEYWORD_NO_INITIALIZE_DOMAIN, KEYWORD_NO_INITIALIZE_DOMAIN_LEN) == 0) {
-				AddDomainInitializerPolicy(shared_buffer + KEYWORD_NO_INITIALIZE_DOMAIN_LEN, 1);
-			} else if (strncmp(shared_buffer, KEYWORD_KEEP_DOMAIN, KEYWORD_KEEP_DOMAIN_LEN) == 0) {
-				AddDomainKeeperPolicy(shared_buffer + KEYWORD_KEEP_DOMAIN_LEN, 0);
-			} else if (strncmp(shared_buffer, KEYWORD_NO_KEEP_DOMAIN, KEYWORD_NO_KEEP_DOMAIN_LEN) == 0) {
-				AddDomainKeeperPolicy(shared_buffer + KEYWORD_NO_KEEP_DOMAIN_LEN, 1);
-			} else if (strncmp(shared_buffer, KEYWORD_PATH_GROUP, KEYWORD_PATH_GROUP_LEN) == 0) {
-				AddPathGroupPolicy(shared_buffer + KEYWORD_PATH_GROUP_LEN, 0);
-			} else if (strncmp(shared_buffer, KEYWORD_ADDRESS_GROUP, KEYWORD_ADDRESS_GROUP_LEN) == 0) {
-				AddAddressGroupPolicy(shared_buffer + KEYWORD_ADDRESS_GROUP_LEN, 0);
-			}
+	/* Load domain_initializer list, domain_keeper list. */
+	fp = open_read(EXCEPTION_POLICY_FILE);
+	if (!fp)
+		goto no_exception;
+	get();
+	while (freadline(fp)) {
+		if (str_starts(shared_buffer, KEYWORD_INITIALIZE_DOMAIN))
+			add_domain_initializer_policy(shared_buffer, 0);
+		else if (str_starts(shared_buffer,
+				    KEYWORD_NO_INITIALIZE_DOMAIN))
+			add_domain_initializer_policy(shared_buffer, 1);
+		else if (str_starts(shared_buffer, KEYWORD_KEEP_DOMAIN))
+			add_domain_keeper_policy(shared_buffer, 0);
+		else if (str_starts(shared_buffer, KEYWORD_NO_KEEP_DOMAIN))
+			add_domain_keeper_policy(shared_buffer, 1);
+		else if (str_starts(shared_buffer, KEYWORD_PATH_GROUP))
+			add_path_group_policy(shared_buffer, 0);
+		else if (str_starts(shared_buffer, KEYWORD_ADDRESS_GROUP))
+			add_address_group_policy(shared_buffer, 0);
+	}
+	put();
+	fclose(fp);
+ no_exception:
+
+	/* Load all domain list. */
+	fp = open_read(DOMAIN_POLICY_FILE);
+	if (!fp)
+		goto no_domain;
+	index = EOF;
+	get();
+	while (freadline(fp)) {
+		char *cp;
+		char *cp2;
+		unsigned int profile;
+		if (IsDomainDef(shared_buffer)) {
+			index = find_or_assign_new_domain(shared_buffer, 0, 0);
+			continue;
+		} else if (index == EOF) {
+			continue;
 		}
-		put();
-		fclose(fp);
+		if (str_starts(shared_buffer, KEYWORD_EXECUTE_HANDLER)) {
+			add_string_entry(shared_buffer, index);
+		} else if (str_starts(shared_buffer,
+				      KEYWORD_DENIED_EXECUTE_HANDLER)) {
+			add_string_entry(shared_buffer, index);
+		} else if (str_starts(shared_buffer, "1 ") ||
+			   str_starts(shared_buffer, "3 ") ||
+			   str_starts(shared_buffer, "5 ") ||
+			   str_starts(shared_buffer, "7 ") ||
+			   str_starts(shared_buffer, KEYWORD_ALLOW_EXECUTE)) {
+			cp = shared_buffer;
+			cp2 = strchr(cp, ' ');
+			if (cp2)
+				*cp2 = '\0';
+			if (*cp == '@' || IsCorrectPath(cp, 1, 0, -1))
+				add_string_entry(cp, index);
+		} else if (sscanf(shared_buffer,
+				  KEYWORD_USE_PROFILE "%u", &profile) == 1) {
+			domain_list[index].profile = (unsigned char) profile;
+		}
 	}
+	put();
+	fclose(fp);
+no_domain:
 
-	// Load all domain list.
-	if ((fp = open_read(DOMAIN_POLICY_FILE)) != NULL) {
-		int index = EOF;
+	max_index = domain_list_count;
+
+	/* Find unreachable domains. */
+	for (index = 0; index < max_index; index++) {
+		char *cp;
 		get();
-		while (freadline(fp)) {
-			char *cp, *cp2;
-			unsigned int profile;
-			if (IsDomainDef(shared_buffer)) {
-				index = FindOrAssignNewDomain(shared_buffer, 0, 0);
-			} else if (index >= 0 && strncmp(shared_buffer, "execute_handler ", 16) == 0) {
-				AddStringEntry(shared_buffer + 16, index);
-			} else if (index >= 0 && strncmp(shared_buffer, "denied_execute_handler ", 23) == 0) {
-				AddStringEntry(shared_buffer + 23, index);
-			} else if (index >= 0 && ((atoi(shared_buffer) & 1) == 1 || strncmp(shared_buffer, "allow_execute ", 14) == 0) && (cp = strchr(shared_buffer, ' ')) != NULL) {
-				cp++;
-				if ((cp2 = strchr(cp, ' ')) != NULL) *cp2 = '\0';
-				if (*cp == '@' || IsCorrectPath(cp, 1, 0, -1)) AddStringEntry(cp, index);
-			} else if (index >= 0 && sscanf(shared_buffer, "use_profile %u", &profile) == 1) {
-				domain_list[index].profile = (unsigned char) profile;
+		memset(shared_buffer, 0, shared_buffer_len);
+		snprintf(shared_buffer, shared_buffer_len - 1, "%s",
+			 domain_name(index));
+		while ((cp = strrchr(shared_buffer, ' ')) != NULL) {
+			const struct domain_initializer_entry
+				*domain_initializer;
+			const struct domain_keeper_entry *domain_keeper;
+			struct path_info parent;
+			*cp++ = '\0';
+			parent.name = shared_buffer;
+			fill_path_info(&parent);
+			domain_initializer = is_domain_initializer(&parent, cp);
+			if (domain_initializer) {
+				/* Initializer under <kernel> is reachable. */
+				if (parent.total_len == ROOT_NAME_LEN)
+					break;
+				domain_list[index].domain_initializer
+					= domain_initializer;
+				domain_list[index].domain_keeper = NULL;
+				continue;
 			}
+			domain_keeper = is_domain_keeper(&parent, cp);
+			if (domain_keeper) {
+				domain_list[index].domain_initializer = NULL;
+				domain_list[index].domain_keeper
+					= domain_keeper;
+			}
 		}
 		put();
-		fclose(fp);
+		if (domain_list[index].domain_initializer ||
+		    domain_list[index].domain_keeper)
+			domain_list[index].is_du = 1;
 	}
-	
-	{
-		int index, max_index = domain_list_count;
-		
-		// Find unreachable domains.
-		for (index = 0; index < max_index; index++) {
-			char *cp;
-			get();
-			memset(shared_buffer, 0, shared_buffer_len);
-			snprintf(shared_buffer, shared_buffer_len - 1, "%s", DomainName(index));
-			while ((cp = strrchr(shared_buffer, ' ')) != NULL) {
-				const struct domain_initializer_entry *domain_initializer;
-				const struct domain_keeper_entry *domain_keeper;
-				struct path_info parent;
-				*cp++ = '\0';
-				parent.name = shared_buffer;
-				fill_path_info(&parent);
-				if ((domain_initializer = IsDomainInitializer(&parent, cp)) != NULL) {
-					if (parent.total_len == ROOT_NAME_LEN) break; /* Initializer under <kernel> is reachable. */
-					domain_list[index].domain_initializer = domain_initializer;
-					domain_list[index].domain_keeper = NULL;
-				} else if ((domain_keeper = IsDomainKeeper(&parent, cp)) != NULL) {
-					domain_list[index].domain_initializer = NULL;
-					domain_list[index].domain_keeper = domain_keeper;
-				}
-			}
-			put();
-			if (domain_list[index].domain_initializer || domain_list[index].domain_keeper) domain_list[index].is_domain_unreachable = 1;
+
+	/* Find domain initializer target domains. */
+	for (index = 0; index < max_index; index++) {
+		char *cp = strchr(domain_name(index), ' ');
+		if (!cp || strchr(cp + 1, ' '))
+			continue;
+		for (i = 0; i < domain_initializer_list_len; i++) {
+			struct domain_initializer_entry *ptr
+				= &domain_initializer_list[i];
+			if (ptr->is_not)
+				continue;
+			if (strcmp(ptr->program->name, cp + 1))
+				continue;
+			domain_list[index].is_dit = 1;
 		}
-		
-		// Find domain initializer target domains.
-		for (index = 0; index < max_index; index++) {
+	}
+
+	/* Find domain keeper domains. */
+	for (index = 0; index < max_index; index++) {
+		for (i = 0; i < domain_keeper_list_len; i++) {
+			struct domain_keeper_entry *ptr
+				= &domain_keeper_list[i];
 			char *cp;
-			if ((cp = strchr(DomainName(index), ' ')) != NULL && strchr(cp + 1, ' ') == NULL) {
-				for (i = 0; i < domain_initializer_list_len; i++) {
-					struct domain_initializer_entry *ptr = &domain_initializer_list[i];
-					if (ptr->is_not) continue;
-					if (strcmp(ptr->program->name, cp + 1)) continue;
-					domain_list[index].is_domain_initializer_target = 1;
-				}
+			if (ptr->is_not)
+				continue;
+			if (!ptr->is_last_name) {
+				if (pathcmp(ptr->domainname,
+					    domain_list[index].domainname))
+					continue;
+				domain_list[index].is_dk = 1;
+				continue;
 			}
+			cp = strrchr(domain_list[index].domainname->name, ' ');
+			if (!cp || strcmp(ptr->domainname->name, cp + 1))
+				continue;
+			domain_list[index].is_dk = 1;
 		}
+	}
 
-		// Find domain keeper domains.
-		for (index = 0; index < max_index; index++) {
-			for (i = 0; i < domain_keeper_list_len; i++) {
-				struct domain_keeper_entry *ptr = &domain_keeper_list[i];
-				if (ptr->is_not) continue;
-				if (!ptr->is_last_name) {
-					if (pathcmp(ptr->domainname, domain_list[index].domainname)) continue;
-				} else {
-					char *cp = strrchr(domain_list[index].domainname->name, ' ');
-					if (!cp || strcmp(ptr->domainname->name, cp + 1)) continue;
-				}
-				domain_list[index].is_domain_keeper = 1;
+	/* Create domain initializer source domains. */
+	for (index = 0; index < max_index; index++) {
+		const struct path_info *domainname
+			= domain_list[index].domainname;
+		const struct path_info **string_ptr
+			= domain_list[index].string_ptr;
+		const int max_count = domain_list[index].string_count;
+		/* Don't create source domain under <kernel> because
+		   they will become target domains. */
+		if (domainname->total_len == ROOT_NAME_LEN)
+			continue;
+		for (i = 0; i < max_count; i++) {
+			const struct path_info *cp = string_ptr[i];
+			struct path_group_entry *group;
+			if (cp->name[0] != '@') {
+				assign_domain_initializer_source(domainname,
+								 cp->name);
+				continue;
 			}
-		}
-
-		// Create domain initializer source domains.
-		for (index = 0; index < max_index; index++) {
-			const struct path_info *domainname = domain_list[index].domainname;
-			const struct path_info **string_ptr = domain_list[index].string_ptr;
-			const int max_count = domain_list[index].string_count;
-			if (domainname->total_len == ROOT_NAME_LEN) continue; // Don't create source domain under <kernel> because they will become target domains. 
-			for (i = 0; i < max_count; i++) {
-				const struct path_info *cp = string_ptr[i];
-				if (cp->name[0] == '@') {
-					struct path_group_entry *group = FindPathGroup(cp->name + 1);
-					if (group) {
-						for (j = 0; j < group->member_name_len; j++) AssignDomainInitializerSource(domainname, group->member_name[j]->name);
-					}
-				} else {
-					AssignDomainInitializerSource(domainname, cp->name);
-				}
+			group = find_path_group(cp->name + 1);
+			if (!group)
+				continue;
+			for (j = 0; j < group->member_name_len; j++) {
+				cp = group->member_name[j];
+				assign_domain_initializer_source(domainname,
+								 cp->name);
 			}
 		}
+	}
 
-		// Create missing parent domains.
-		for (index = 0; index < max_index; index++) {
-			char *cp;
-			get();
-			memset(shared_buffer, 0, shared_buffer_len);
-			snprintf(shared_buffer, shared_buffer_len - 1, "%s", DomainName(index));
-			while ((cp = strrchr(shared_buffer, ' ')) != NULL) {
-				*cp = '\0';
-				if (FindDomain(shared_buffer, 0, 0) != EOF) continue;
-				if (FindOrAssignNewDomain(shared_buffer, 0, 1) == EOF) OutOfMemory();
-			}
-			put();
+	/* Create missing parent domains. */
+	for (index = 0; index < max_index; index++) {
+		char *cp;
+		get();
+		memset(shared_buffer, 0, shared_buffer_len);
+		snprintf(shared_buffer, shared_buffer_len - 1, "%s",
+			 domain_name(index));
+		while ((cp = strrchr(shared_buffer, ' ')) != NULL) {
+			*cp = '\0';
+			if (find_domain(shared_buffer, 0, 0) != EOF)
+				continue;
+			if (find_or_assign_new_domain(shared_buffer, 0, 1)
+			    == EOF)
+				OutOfMemory();
 		}
-
+		put();
 	}
-	// Sort by domain name.
-	qsort(domain_list, domain_list_count, sizeof(struct domain_info), domainname_attribute_compare);
 
-	// Assign domain numbers.
+	/* Sort by domain name. */
+	qsort(domain_list, domain_list_count, sizeof(struct domain_info),
+	      domainname_attribute_compare);
+
+	/* Assign domain numbers. */
 	{
-		int number = 0, index;
-		unnumbered_domain_count= 0;
+		int number = 0;
+		int index;
+		unnumbered_domain_count = 0;
 		for (index = 0; index < domain_list_count; index++) {
-			if (IsDeletedDomain(index) || IsInitializerSource(index)) {
+			if (is_deleted_domain(index) ||
+			    is_initializer_source(index)) {
 				domain_list[index].number = -1;
 				unnumbered_domain_count++;
 			} else {
@@ -1215,14 +2040,18 @@
 	}
 
 	domain_list_selected = realloc(domain_list_selected, domain_list_count);
-	if (domain_list_count && !domain_list_selected) OutOfMemory();
+	if (domain_list_count && !domain_list_selected)
+		OutOfMemory();
 	memset(domain_list_selected, 0, domain_list_count);
 }
 
-static void ShowCurrent(void);
+static void show_current(void);
 
-static int window_width = 0, window_height = 0;
-static int current_y[MAXSCREEN], current_item_index[MAXSCREEN], list_item_count[MAXSCREEN];
+static int window_width = 0;
+static int window_height = 0;
+static int current_y[MAXSCREEN];
+static int current_item_index[MAXSCREEN];
+static int list_item_count[MAXSCREEN];
 
 static const int header_lines = 3;
 static int body_lines = 0;
@@ -1230,516 +2059,794 @@
 static int max_eat_col[MAXSCREEN];
 static int eat_col = 0;
 static int max_col = 0;
+static int list_indent = 0;
 
-static const char *eat(const char *str) {
+static const char *eat(const char *str)
+{
 	while (*str && eat_col) {
-		str++; eat_col--;
+		str++;
+		eat_col--;
 	}
 	return str;
 }
- 
-static void ShowList(void) {
+
+static void show_list(void)
+{
 	const int offset = current_item_index[current_screen];
-	int i, tmp_col;
-	if (current_screen == SCREEN_DOMAIN_LIST) list_item_count[SCREEN_DOMAIN_LIST] = domain_list_count;
-	else list_item_count[current_screen] = generic_acl_list_count;
+	int i;
+	int tmp_col;
+	if (current_screen == SCREEN_DOMAIN_LIST)
+		list_item_count[SCREEN_DOMAIN_LIST] = domain_list_count;
+	else
+		list_item_count[current_screen] = generic_acl_list_count;
 	clear();
 	if (window_height < header_lines + 1) {
-		mvprintw(0, 0, "Please resize window. This program needs at least %d lines.\n", header_lines + 1);
+		mvprintw(0, 0, "Please resize window. "
+			 "This program needs at least %d lines.\n",
+			 header_lines + 1);
 		refresh();
 		return;
 	}
-	colorChange(colorHead(), ON);  // add color
-	if (current_screen == SCREEN_DOMAIN_LIST) mvprintw(0, 0, "<<< Domain Transition Editor >>>      %d domain%c    '?' for help", list_item_count[SCREEN_DOMAIN_LIST] - unnumbered_domain_count, list_item_count[SCREEN_DOMAIN_LIST] - unnumbered_domain_count > 1 ? 's' : ' ');
-	else mvprintw(0, 0, "<<< %s Editor >>>      %d entr%s    '?' for help", list_caption, list_item_count[current_screen], list_item_count[current_screen] > 1 ? "ies" : "y");
-	colorChange(colorHead(), OFF);  // add color
+	/* add color */
+	editpolicy_color_change(editpolicy_color_head(current_screen), ON);
+	if (current_screen == SCREEN_DOMAIN_LIST) {
+		i = list_item_count[SCREEN_DOMAIN_LIST]
+			- unnumbered_domain_count;
+		mvprintw(0, 0, "<<< Domain Transition Editor >>>"
+			 "      %d domain%c    '?' for help",
+			 i, i > 1 ? 's' : ' ');
+	} else {
+		i = list_item_count[current_screen];
+		mvprintw(0, 0, "<<< %s Editor >>>"
+			 "      %d entr%s    '?' for help", list_caption,
+			 i, i > 1 ? "ies" : "y");
+	}
+	/* add color */
+	editpolicy_color_change(editpolicy_color_head(current_screen), OFF);
 	eat_col = max_eat_col[current_screen];
 	max_col = 0;
 	if (current_screen == SCREEN_ACL_LIST) {
 		get();
 		memset(shared_buffer, 0, shared_buffer_len);
-		snprintf(shared_buffer, shared_buffer_len - 1, "%s", eat(current_domain));
-		attrChange(A_REVERSE, ON);  // add color --- 2007/11/27 changed
+		snprintf(shared_buffer, shared_buffer_len - 1, "%s",
+			 eat(current_domain));
+		editpolicy_attr_change(A_REVERSE, ON); /* add color */
 		mvprintw(2, 0, "%s", shared_buffer);
-		attrChange(A_REVERSE, OFF); // add color --- 2007/11/27 changed
+		editpolicy_attr_change(A_REVERSE, OFF); /* add color */
 		put();
 	}
+
+	if (current_screen != SCREEN_DOMAIN_LIST) {
+		list_indent = 0;
+		for (i = 0; i < list_item_count[current_screen]; i++) {
+			const u8 directive = generic_acl_list[i].directive;
+			const int len = directives[directive].alias_len;
+			if (len > list_indent)
+				list_indent = len;
+		}
+	}
+
 	for (i = 0; i < body_lines; i++) {
+		u8 directive;
+		const char *cp1;
+		const char *cp2;
+		int len;
 		const int index = offset + i;
 		eat_col = max_eat_col[current_screen];
 		tmp_col = 0;
-		if (index >= list_item_count[current_screen]) break;
-		if (current_screen == SCREEN_DOMAIN_LIST) {
-			const struct domain_initializer_entry *domain_initializer;
-			const struct domain_keeper_entry *domain_keeper;
-			const char *sp, *cp;
-			const int number = domain_list[index].number;
-			if (number >= 0) mvprintw(header_lines + i, 0, "%c%4d:%3u %c%c%c ", domain_list_selected[index] ? '&' : ' ', number, domain_list[index].profile, IsKeeperDomain(index) ? '#' : ' ', IsInitializerTarget(index) ? '*' : ' ', IsDomainUnreachable(index) ? '!' : ' ');
-			else mvprintw(header_lines + i, 0, "              ");
-			tmp_col += 14;
-			sp = DomainName(index);
-			while ((cp = strchr(sp, ' ')) != NULL) { printw("%s", eat("    ")); tmp_col += 4; sp = cp + 1; }
-			if (IsDeletedDomain(index)) { printw("%s", eat("( ")); tmp_col += 2; }
-			printw("%s", eat(sp)); tmp_col += strlen(sp);
-			if (IsDeletedDomain(index)) { printw("%s", eat(" )")); tmp_col += 2; }
-			if ((domain_initializer = domain_list[index].domain_initializer) != NULL) {
-				get();
-				memset(shared_buffer, 0, shared_buffer_len);
-				if (domain_initializer->domainname) snprintf(shared_buffer, shared_buffer_len - 1, " ( " KEYWORD_INITIALIZE_DOMAIN "%s from %s )", domain_initializer->program->name, domain_initializer->domainname->name);
-				else snprintf(shared_buffer, shared_buffer_len - 1, " ( " KEYWORD_INITIALIZE_DOMAIN "%s )", domain_initializer->program->name);
-				printw("%s", eat(shared_buffer)); tmp_col += strlen(shared_buffer);
-				put();
-			} else if ((domain_keeper = domain_list[index].domain_keeper) != NULL) {
-				get();
-				memset(shared_buffer, 0, shared_buffer_len);
-				if (domain_keeper->program) snprintf(shared_buffer, shared_buffer_len - 1, " ( " KEYWORD_KEEP_DOMAIN "%s from %s )", domain_keeper->program->name, domain_keeper->domainname->name);
-				else snprintf(shared_buffer, shared_buffer_len - 1, " ( " KEYWORD_KEEP_DOMAIN "%s )", domain_keeper->domainname->name);
-				printw("%s", eat(shared_buffer)); tmp_col += strlen(shared_buffer);
-				put();
-			} else if (IsInitializerSource(index)) {
-				int redirect_index;
-				get();
-				memset(shared_buffer, 0, shared_buffer_len);
-				snprintf(shared_buffer, shared_buffer_len - 1, ROOT_NAME "%s", strrchr(DomainName(index), ' '));
-				redirect_index = FindDomain(shared_buffer, 0, 0);
-				if (redirect_index >= 0) snprintf(shared_buffer, shared_buffer_len - 1, " ( -> %d )", domain_list[redirect_index].number);
-				else snprintf(shared_buffer, shared_buffer_len - 1, " ( -> Not Found )");
-				printw("%s", eat(shared_buffer)); tmp_col += strlen(shared_buffer);
-				put();
-			}
-		} else {
-			const char *cp = generic_acl_list[index];
-			mvprintw(header_lines + i, 0, "%c%4d: %s", generic_acl_list_selected[index] ? '&' : ' ', index, eat(cp)); tmp_col += strlen(cp) + 7;
+		if (index >= list_item_count[current_screen])
+			break;
+		if (current_screen != SCREEN_DOMAIN_LIST)
+			goto not_domain_list;
+		const struct domain_initializer_entry *domain_initializer;
+		const struct domain_keeper_entry *domain_keeper;
+		const char *sp, *cp;
+		const int number = domain_list[index].number;
+		int redirect_index;
+		if (number >= 0)
+			mvprintw(header_lines + i, 0,
+				 "%c%4d:%3u %c%c%c ",
+				 domain_list_selected[index] ? '&' : ' ',
+				 number, domain_list[index].profile,
+				 is_keeper_domain(index) ? '#' : ' ',
+				 is_initializer_target(index) ? '*' : ' ',
+				 is_domain_unreachable(index) ? '!' : ' ');
+		else
+			mvprintw(header_lines + i, 0, "              ");
+		tmp_col += 14;
+		sp = domain_name(index);
+		while ((cp = strchr(sp, ' ')) != NULL) {
+			printw("%s", eat("    "));
+			tmp_col += 4;
+			sp = cp + 1;
 		}
+		if (is_deleted_domain(index)) {
+			printw("%s", eat("( "));
+			tmp_col += 2;
+		}
+		printw("%s", eat(sp));
+		tmp_col += strlen(sp);
+		if (is_deleted_domain(index)) {
+			printw("%s", eat(" )"));
+			tmp_col += 2;
+		}
+		domain_initializer = domain_list[index].domain_initializer;
+		if (!domain_initializer)
+			goto not_domain_initializer;
+		get();
+		memset(shared_buffer, 0, shared_buffer_len);
+		if (domain_initializer->domainname)
+			snprintf(shared_buffer,
+				 shared_buffer_len - 1,
+				 " ( " KEYWORD_INITIALIZE_DOMAIN "%s from %s )",
+				 domain_initializer->program->name,
+				 domain_initializer->domainname->name);
+		else
+			snprintf(shared_buffer,
+				 shared_buffer_len - 1,
+				 " ( " KEYWORD_INITIALIZE_DOMAIN "%s )",
+				 domain_initializer->program->name);
+		printw("%s", eat(shared_buffer));
+		tmp_col += strlen(shared_buffer);
+		put();
+		goto done;
+not_domain_initializer:
+		domain_keeper = domain_list[index].domain_keeper;
+		if (!domain_keeper)
+			goto not_domain_keeper;
+		get();
+		memset(shared_buffer, 0, shared_buffer_len);
+		if (domain_keeper->program)
+			snprintf(shared_buffer, shared_buffer_len - 1,
+				 " ( " KEYWORD_KEEP_DOMAIN "%s from %s )",
+				 domain_keeper->program->name,
+				 domain_keeper->domainname->name);
+		else
+			snprintf(shared_buffer, shared_buffer_len - 1,
+				 " ( " KEYWORD_KEEP_DOMAIN "%s )",
+				 domain_keeper->domainname->name);
+		printw("%s", eat(shared_buffer));
+		tmp_col += strlen(shared_buffer);
+		put();
+		goto done;
+not_domain_keeper:
+		if (!is_initializer_source(index))
+			goto done;
+		get();
+		memset(shared_buffer, 0, shared_buffer_len);
+		snprintf(shared_buffer, shared_buffer_len - 1, ROOT_NAME "%s",
+			 strrchr(domain_name(index), ' '));
+		redirect_index = find_domain(shared_buffer, 0, 0);
+		if (redirect_index >= 0)
+			snprintf(shared_buffer, shared_buffer_len - 1,
+				 " ( -> %d )",
+				 domain_list[redirect_index].number);
+		else
+			snprintf(shared_buffer, shared_buffer_len - 1,
+				 " ( -> Not Found )");
+		printw("%s", eat(shared_buffer));
+		tmp_col += strlen(shared_buffer);
+		put();
+		goto done;
+not_domain_list:
+		directive = generic_acl_list[index].directive;
+		cp1 = directives[directive].alias;
+		cp2 = generic_acl_list[index].operand;
+		len = list_indent - directives[directive].alias_len;
+		mvprintw(header_lines + i, 0, "%c%4d: %s ",
+			 generic_acl_list[index].selected ? '&' : ' ',
+			 index, eat(cp1));
+		while (len-- > 0)
+			printw("%s", eat(" "));
+		printw("%s", eat(cp2));
+		tmp_col += strlen(cp1) + strlen(cp2) + 8 + list_indent;
+done:
 		clrtoeol();
 		tmp_col -= window_width;
-		if (tmp_col  > max_col) max_col = tmp_col;
+		if (tmp_col > max_col)
+			max_col = tmp_col;
 	}
-	ShowCurrent();
+	show_current();
 }
 
-static void ResizeWindow(void) {
+static void resize_window(void)
+{
 	getmaxyx(stdscr, window_height, window_width);
 	body_lines = window_height - header_lines;
-	if (body_lines <= current_y[current_screen]) current_y[current_screen] = body_lines - 1;
-	if (current_y[current_screen] < 0) current_y[current_screen] = 0;
+	if (body_lines <= current_y[current_screen])
+		current_y[current_screen] = body_lines - 1;
+	if (current_y[current_screen] < 0)
+		current_y[current_screen] = 0;
 }
 
-static void UpArrowKey(void) {
+static void up_arrow_key(void)
+{
 	if (current_y[current_screen] > 0) {
 		current_y[current_screen]--;
-		ShowCurrent();
+		show_current();
 	} else if (current_item_index[current_screen] > 0) {
 		current_item_index[current_screen]--;
-		ShowList();
+		show_list();
 	}
 }
 
-static void DownArrowKey(void) {
+static void down_arrow_key(void)
+{
 	if (current_y[current_screen] < body_lines - 1) {
-		if (current_item_index[current_screen] + current_y[current_screen] < list_item_count[current_screen] - 1) {
+		if (current_item_index[current_screen]
+		    + current_y[current_screen]
+		    < list_item_count[current_screen] - 1) {
 			current_y[current_screen]++;
-			ShowCurrent();
+			show_current();
 		}
-	} else if (current_item_index[current_screen] + current_y[current_screen] < list_item_count[current_screen] - 1) {
+	} else if (current_item_index[current_screen]
+		   + current_y[current_screen]
+		   < list_item_count[current_screen] - 1) {
 		current_item_index[current_screen]++;
-		ShowList();
+		show_list();
 	}
 }
 
-static void PageUpKey(void) {
-	if (current_item_index[current_screen] + current_y[current_screen] > body_lines) {
+static void page_up_key(void)
+{
+	if (current_item_index[current_screen] + current_y[current_screen]
+	    > body_lines) {
 		current_item_index[current_screen] -= body_lines;
-		if (current_item_index[current_screen] < 0) current_item_index[current_screen] = 0;
-		ShowList();
-	} else if (current_item_index[current_screen] + current_y[current_screen] > 0) {
+		if (current_item_index[current_screen] < 0)
+			current_item_index[current_screen] = 0;
+		show_list();
+	} else if (current_item_index[current_screen]
+		   + current_y[current_screen] > 0) {
 		current_item_index[current_screen] = 0;
 		current_y[current_screen] = 0;
-		ShowList();
+		show_list();
 	}
 }
 
-static void PageDownKey(void) {
-	if (list_item_count[current_screen] - current_item_index[current_screen] > body_lines) {
+static void page_down_key(void)
+{
+	if (list_item_count[current_screen] - current_item_index[current_screen]
+	    > body_lines) {
 		current_item_index[current_screen] += body_lines;
-		if (current_item_index[current_screen] + current_y[current_screen] > list_item_count[current_screen] - 1) current_y[current_screen] = list_item_count[current_screen] - 1 - current_item_index[current_screen];
-		ShowList();
-	} else if (current_item_index[current_screen] + current_y[current_screen] < list_item_count[current_screen] - 1) {
-		current_y[current_screen] = list_item_count[current_screen] - current_item_index[current_screen] - 1;
-		ShowCurrent();
+		if (current_item_index[current_screen]
+		    + current_y[current_screen]
+		    > list_item_count[current_screen] - 1)
+			current_y[current_screen]
+				= list_item_count[current_screen] - 1
+				- current_item_index[current_screen];
+		show_list();
+	} else if (current_item_index[current_screen]
+		   + current_y[current_screen]
+		   < list_item_count[current_screen] - 1) {
+		current_y[current_screen]
+			= list_item_count[current_screen]
+			- current_item_index[current_screen] - 1;
+		show_current();
 	}
 }
 
-static int GetCurrent(void) {
-	if (list_item_count[current_screen] == 0) return EOF;
-	if (current_item_index[current_screen] + current_y[current_screen] < 0 || current_item_index[current_screen] + current_y[current_screen] >= list_item_count[current_screen]) {
-		fprintf(stderr, "ERROR: current_item_index=%d current_y=%d\n", current_item_index[current_screen], current_y[current_screen]);
+static int get_current(void)
+{
+	if (list_item_count[current_screen] == 0)
+		return EOF;
+	if (current_item_index[current_screen] + current_y[current_screen] < 0
+	    || current_item_index[current_screen] + current_y[current_screen]
+	    >= list_item_count[current_screen]) {
+		fprintf(stderr, "ERROR: current_item_index=%d current_y=%d\n",
+			current_item_index[current_screen],
+			current_y[current_screen]);
 		exit(127);
 	}
 	return current_item_index[current_screen] + current_y[current_screen];
 }
 
-/// add color start
+/* add color start */
 #ifdef COLOR_ON
-static int before_current[MAXSCREEN] = {-1, -1, -1, -1};
-static int before_y[MAXSCREEN] = {-1, -1, -1, -1};
+static int before_current[MAXSCREEN] = { -1, -1, -1, -1 };
+static int before_y[MAXSCREEN]       = { -1, -1, -1, -1 };
 
-static void LineDraw(void) {
-	int current = GetCurrent();
+static void editpolicy_line_draw(void)
+{
+	int current = get_current();
 	int y, x;
 
-	if (current == EOF) return;
+	if (current == EOF)
+		return;
 
 	getyx(stdscr, y, x);
-	if (-1 < before_current[current_screen] && current != before_current[current_screen]){
+	if (-1 < before_current[current_screen] &&
+	    current != before_current[current_screen]){
 		move(header_lines + before_y[current_screen], 0);
 		chgat(-1, A_NORMAL, NORMAL, NULL);
 	}
 
 	move(y, x);
-	chgat(-1, A_NORMAL, colorCursor(), NULL);
+	chgat(-1, A_NORMAL, editpolicy_color_cursor(current_screen), NULL);
 	touchwin(stdscr);
 
 	before_current[current_screen] = current;
 	before_y[current_screen] = current_y[current_screen];
 }
 #else
-#define LineDraw()
+#define editpolicy_line_draw()
 #endif
-/// add color end
+/* add color end */
 
-static void ShowCurrent(void) {
+static void show_current(void)
+{
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		get();
 		memset(shared_buffer, 0, shared_buffer_len);
 		eat_col = max_eat_col[current_screen];
-		snprintf(shared_buffer, shared_buffer_len - 1, "%s", eat(DomainName(GetCurrent())));
-		if (window_width < shared_buffer_len) shared_buffer[window_width] = '\0';
+		snprintf(shared_buffer, shared_buffer_len - 1, "%s",
+			 eat(domain_name(get_current())));
+		if (window_width < shared_buffer_len)
+			shared_buffer[window_width] = '\0';
 		move(2, 0);
 		clrtoeol();
-		attrChange(A_REVERSE, ON);  // add color
+		editpolicy_attr_change(A_REVERSE, ON); /* add color */
 		printw("%s", shared_buffer);
-		attrChange(A_REVERSE, OFF);  // add color
+		editpolicy_attr_change(A_REVERSE, OFF); /* add color */
 		put();
 	}
 	move(header_lines + current_y[current_screen], 0);
-	LineDraw();     // add color
+	editpolicy_line_draw();     /* add color */
 	refresh();
 }
 
-static void AdjustCursorPos(const int item_count) {
+static void adjust_cursor_pos(const int item_count)
+{
 	if (item_count == 0) {
-		current_item_index[current_screen] = current_y[current_screen] = 0;
+		current_item_index[current_screen] = 0;
+		current_y[current_screen] = 0;
 	} else {
-		while (current_item_index[current_screen] + current_y[current_screen] >= item_count) {
-			if (current_y[current_screen] > 0) current_y[current_screen]--;
-			else if (current_item_index[current_screen] > 0) current_item_index[current_screen]--;
+		while (current_item_index[current_screen]
+		       + current_y[current_screen] >= item_count) {
+			if (current_y[current_screen] > 0)
+				current_y[current_screen]--;
+			else if (current_item_index[current_screen] > 0)
+				current_item_index[current_screen]--;
 		}
 	}
 }
 
-static void SetCursorPos(const int index) {
-	while (index < current_y[current_screen] + current_item_index[current_screen]) {
-		if (current_y[current_screen] > 0) current_y[current_screen]--;
-		else current_item_index[current_screen]--;
+static void set_cursor_pos(const int index)
+{
+	while (index < current_y[current_screen]
+	       + current_item_index[current_screen]) {
+		if (current_y[current_screen] > 0)
+			current_y[current_screen]--;
+		else
+			current_item_index[current_screen]--;
 	}
-	while (index > current_y[current_screen] + current_item_index[current_screen]) {
-		if (current_y[current_screen] < body_lines - 1) current_y[current_screen]++;
-		else current_item_index[current_screen]++;
+	while (index > current_y[current_screen]
+	       + current_item_index[current_screen]) {
+		if (current_y[current_screen] < body_lines - 1)
+			current_y[current_screen]++;
+		else
+			current_item_index[current_screen]++;
 	}
 }
 
-static int count(const unsigned char *array, const int len) {
-	int i, c = 0;
-	for (i = 0; i < len; i++) if (array[i]) c++;
+static int count(const unsigned char *array, const int len)
+{
+	int i;
+	int c = 0;
+	for (i = 0; i < len; i++)
+		if (array[i])
+			c++;
 	return c;
 }
 
-static int SelectItem(const int current) {
+static int count2(const struct generic_acl *array, int len)
+{
+	int i;
+	int c = 0;
+	for (i = 0; i < len; i++)
+		if (array[i].selected)
+			c++;
+	return c;
+}
+
+static int select_item(const int current)
+{
 	if (current >= 0) {
-		int x, y;
+		int x;
+		int y;
 		if (current_screen == SCREEN_DOMAIN_LIST) {
-			if (IsDeletedDomain(current) || IsInitializerSource(current)) return 0;
+			if (is_deleted_domain(current) ||
+			    is_initializer_source(current))
+				return 0;
 			domain_list_selected[current] ^= 1;
 		} else {
-			generic_acl_list_selected[current] ^= 1;
+			generic_acl_list[current].selected ^= 1;
 		}
 		getyx(stdscr, y, x);
-		sttrSave();		// add color
-		ShowList();
-		sttrRestore();	// add color
+		editpolicy_sttr_save();    /* add color */
+		show_list();
+		editpolicy_sttr_restore(); /* add color */
 		move(y, x);
 		return 1;
 	}
 	return 0;
 }
 
-static int PathMatchesToPattern(const struct path_info *pathname0, const struct path_info *pattern0) {
-	//if (!pathname || !pattern) return 0;
-	const char *pathname = pathname0->name, *pattern = pattern0->name;
+static int path_matches_pattern(const struct path_info *pathname0,
+				const struct path_info *pattern0)
+{
+	/*
+	if (!pathname || !pattern)
+		return 0;
+	*/
+	const char *pathname = pathname0->name;
+	const char *pattern = pattern0->name;
 	const int len = pattern0->const_len;
-	if (!pattern0->is_patterned) return !pathcmp(pathname0, pattern0);
-	if (pathname0->depth != pattern0->depth) return 0;
-	if (strncmp(pathname, pattern, len)) return 0;
-	pathname += len; pattern += len;
+	if (!pattern0->is_patterned)
+		return !pathcmp(pathname0, pattern0);
+	if (pathname0->depth != pattern0->depth)
+		return 0;
+	if (strncmp(pathname, pattern, len))
+		return 0;
+	pathname += len;
+	pattern += len;
 	while (*pathname && *pattern) {
-		const char *pathname_delimiter = strchr(pathname, '/'), *pattern_delimiter = strchr(pattern, '/');
-		if (!pathname_delimiter) pathname_delimiter = strchr(pathname, '\0');
-		if (!pattern_delimiter) pattern_delimiter = strchr(pattern, '\0');
-		if (!FileMatchesToPattern(pathname, pathname_delimiter, pattern, pattern_delimiter)) return 0;
-		pathname = *pathname_delimiter ? pathname_delimiter + 1 : pathname_delimiter;
-		pattern = *pattern_delimiter ? pattern_delimiter + 1 : pattern_delimiter;
+		const char *pathname_delimiter = strchr(pathname, '/');
+		const char *pattern_delimiter = strchr(pattern, '/');
+		if (!pathname_delimiter)
+			pathname_delimiter = strchr(pathname, '\0');
+		if (!pattern_delimiter)
+			pattern_delimiter = strchr(pattern, '\0');
+		if (!FileMatchesToPattern(pathname, pathname_delimiter,
+					  pattern, pattern_delimiter))
+			return 0;
+		pathname = *pathname_delimiter ? pathname_delimiter + 1 :
+			pathname_delimiter;
+		pattern = *pattern_delimiter ? pattern_delimiter + 1 :
+			pattern_delimiter;
 	}
-	while (*pattern == '\\' && (*(pattern + 1) == '*' || *(pattern + 1) == '@')) pattern += 2;
-	return (!*pathname && !*pattern);
+	while (*pattern == '\\' &&
+	       (*(pattern + 1) == '*' || *(pattern + 1) == '@'))
+		pattern += 2;
+	return !*pathname && !*pattern;
 }
 
-static void split_acl(char *data, struct path_info *arg1, struct path_info *arg2, struct path_info *arg3) {
-	/* data = word[0] word[1] ... word[n-1] word[n] if cond[0] cond[1] ... cond[m] ; set ... */
-	/*                                                 */
-	/* arg1 = word[0]                                  */
-	/* arg2 = word[1] ... word[n-1] word[n]            */
-	/* arg3 = if cond[0] cond[1] ... cond[m] ; set ... */
+static void split_acl(char *data, struct path_info *arg1,
+		      struct path_info *arg2, struct path_info *arg3)
+{
+	/* data = w[0] w[1] ... w[n-1] w[n] if c[0] c[1] ... c[m] ; set ... */
+	/*                                                                  */
+	/* arg1 = w[0]                                                      */
+	/* arg2 = w[1] ... w[n-1] w[n]                                      */
+	/* arg3 = if c[0] c[1] ... c[m] ; set ...                           */
 	char *cp;
 	arg1->name = data;
 	cp = strstr(data, " if ");
 	if (cp) {
 		char *cp2;
-		while ((cp2 = strstr(cp + 3, " if ")) != NULL) cp = cp2;
+		while ((cp2 = strstr(cp + 3, " if ")) != NULL)
+			cp = cp2;
 		*cp++ = '\0';
-	} else if ((cp = strstr(data, " ; set ")) != NULL) {
+		goto ok;
+	}
+	cp = strstr(data, " ; set ");
+	if (cp)
 		*cp++ = '\0';
-	} else {
+	else
 		cp = "";
-	}
+ok:
 	arg3->name = cp;
 	cp = strchr(data, ' ');
-	if (cp) *cp++ = '\0';
-	else cp = "";
+	if (cp)
+		*cp++ = '\0';
+	else
+		cp = "";
 	arg2->name = cp;
 	fill_path_info(arg1);
 	fill_path_info(arg2);
 	fill_path_info(arg3);
 }
 
-#define max_optimize_directive_index 35
-static const char *directive_list[max_optimize_directive_index] = {
-	[0]  = "1 ",
-	[1]  = "2 ",
-	[2]  = "3 ",
-	[3]  = "4 ",
-	[4]  = "5 ",
-	[5]  = "6 ",
-	[6]  = "7 ",
-	[7]  = "allow_execute ",
-	[8]  = "allow_read ",
-	[9]  = "allow_write ",
-	[10] = "allow_read/write ",
-	[11] = "allow_create ",
-	[12] = "allow_unlink ",
-	[13] = "allow_mkdir ",
-	[14] = "allow_rmdir ",
-	[15] = "allow_mkfifo ",
-	[16] = "allow_mksock ",
-	[17] = "allow_mkblock ",
-	[18] = "allow_mkchar ",
-	[19] = "allow_truncate ",
-	[20] = "allow_symlink ",
-	[21] = "allow_link ",
-	[22] = "allow_rename ",
-	[23] = "allow_rewrite ",
-	[24] = "allow_argv0 ",
-	[25] = "allow_signal ",
-	[26] = "allow_network UDP bind ",
-	[27] = "allow_network UDP connect ",
-	[28] = "allow_network TCP bind ",
-	[29] = "allow_network TCP listen ",
-	[30] = "allow_network TCP connect ",
-	[31] = "allow_network TCP accept ",
-	[32] = "allow_network RAW bind ",
-	[33] = "allow_network RAW connect ",
-	[34] = "allow_env ",
-};
-static int directive_list_len[max_optimize_directive_index];
 static int sort_type = 1;
 
-static int string_acl_compare(const void *a, const void *b) {
-	const char *a0 = * (char **) a;
-	const char *b0 = * (char **) b;
-	int i;
-	if (sort_type == 0) return strcmp(a0, b0);
-	for (i = 0; i < max_optimize_directive_index; i++) {
-		if (strncmp(a0, directive_list[i], directive_list_len[i])) continue;
-		a0 += directive_list_len[i];
-		break;
+static int generic_acl_compare(const void *a, const void *b)
+{
+	const struct generic_acl *a0 = (struct generic_acl *) a;
+	const struct generic_acl *b0 = (struct generic_acl *) b;
+	const char *a1 = directives[a0->directive].alias;
+	const char *b1 = directives[b0->directive].alias;
+	const char *a2 = a0->operand;
+	const char *b2 = b0->operand;
+	if (sort_type == 0) {
+		const int ret = strcmp(a1, b1);
+		if (ret)
+			return ret;
+		return strcmp(a2, b2);
+	} else {
+		const int ret = strcmp(a2, b2);
+		if (ret)
+			return ret;
+		return strcmp(a1, b1);
 	}
-	for (i = 0; i < max_optimize_directive_index; i++) {
-		if (strncmp(b0, directive_list[i], directive_list_len[i])) continue;
-		b0 += directive_list_len[i];
-		break;
-	}
-	i = strcmp(a0, b0);
-	if (i == 0) i = strcmp(* (char **) a, * (char **) b);
-	return i;
 }
 
-static void try_optimize(const int current) {
+static void try_optimize(const int current)
+{
 	char *cp;
-	const char *directive;
-	int directive_index, directive_len, index;
-	struct path_info sarg1, sarg2, sarg3;
-	struct path_info darg1, darg2, darg3;
-	if (current < 0) return;
-	cp = generic_acl_list[current];
-	for (directive_index = 0; directive_index < max_optimize_directive_index; directive_index++) {
-		if (strncmp(cp, directive_list[directive_index], directive_list_len[directive_index]) == 0) break;
-	}
-	if (directive_index == max_optimize_directive_index) return;
-	cp = strdup(cp);
-	if (!cp) return;
-	
-	directive = directive_list[directive_index];
-	directive_len = directive_list_len[directive_index];
+	u8 s_index;
+	int index;
+	struct path_info sarg1;
+	struct path_info sarg2;
+	struct path_info sarg3;
+	struct path_info darg1;
+	struct path_info darg2;
+	struct path_info darg3;
+	if (current < 0)
+		return;
+	s_index = generic_acl_list[current].directive;
+	if (s_index == (u8) EOF)
+		return;
+	cp = strdup(generic_acl_list[current].operand);
+	if (!cp)
+		return;
 
-	split_acl(cp + directive_len, &sarg1, &sarg2, &sarg3);
-	
+	split_acl(cp, &sarg1, &sarg2, &sarg3);
+
 	get();
 	for (index = 0; index < list_item_count[current_screen]; index++) {
-		const char *cp = generic_acl_list[index];
-		int d_len;
-		if (index == current) continue;
-		if (generic_acl_list_selected[index]) continue;
-		if (directive_index == 5 || directive_index == 10) {
+		const u8 d_index = generic_acl_list[index].directive;
+		if (index == current)
+			continue;
+		if (generic_acl_list[index].selected)
+			continue;
+		if (s_index == DIRECTIVE_6 ||
+		    s_index == DIRECTIVE_ALLOW_READ_WRITE) {
 			/* Source starts with "6 " or "allow_read/write " */
-			if (!strncmp(cp, directive_list[5], directive_list_len[5])) {
-				d_len = directive_list_len[5]; /* Dest starts with "6 " */
-			} else if (!strncmp(cp, directive_list[10], directive_list_len[10])) {
-				d_len = directive_list_len[10]; /* Dest starts with "allow_read/write " */
-			} else if (!strncmp(cp, directive_list[1], directive_list_len[1])) {
-				d_len = directive_list_len[1]; /* Dest starts with "2 " */
-			} else if (!strncmp(cp, directive_list[3], directive_list_len[3])) {
-				d_len = directive_list_len[3]; /* Dest starts with "4 " */
-			} else if (!strncmp(cp, directive_list[8], directive_list_len[8])) {
-				d_len = directive_list_len[8]; /* Dest starts with "allow_read " */
-			} else if (!strncmp(cp, directive_list[9], directive_list_len[9])) {
-				d_len = directive_list_len[9]; /* Dest starts with "allow_write " */
+			if (d_index == DIRECTIVE_6) {
+				/* Dest starts with "6 " */
+			} else if (d_index == DIRECTIVE_ALLOW_READ_WRITE) {
+				/* Dest starts with "allow_read/write " */
+			} else if (d_index == DIRECTIVE_2) {
+				/* Dest starts with "2 " */
+			} else if (d_index == DIRECTIVE_4) {
+				/* Dest starts with "4 " */
+			} else if (d_index == DIRECTIVE_ALLOW_READ) {
+				/* Dest starts with "allow_read " */
+			} else if (d_index == DIRECTIVE_ALLOW_WRITE) {
+				/* Dest starts with "allow_write " */
 			} else {
-				continue; /* Source and dest start with same directive. */
+				/* Source and dest start with same directive. */
+				continue;
 			}
-		} else if (directive_index == 1 && !strncmp(cp, directive_list[9], directive_list_len[9])) {
-			d_len = directive_list_len[9]; /* Source starts with "2 " and dest starts with "allow_write " */
-		} else if (directive_index == 3 && !strncmp(cp, directive_list[8], directive_list_len[8])) {
-			d_len = directive_list_len[8]; /* Source starts with "4 " and dest starts with "allow_read " */
-		} else if (directive_index == 9 && !strncmp(cp, directive_list[1], directive_list_len[1])) {
-			d_len = directive_list_len[1]; /* Source starts with "allow_write " and dest starts with "2 " */
-		} else if (directive_index == 8 && !strncmp(cp, directive_list[3], directive_list_len[3])) {
-			d_len = directive_list_len[3]; /* Source starts with "allow_read " and dest starts with "4 " */
-		} else if (!strncmp(cp, directive, directive_len)) {
-			d_len = directive_len; /* Source and dest start with same directive. */
+		} else if (s_index == DIRECTIVE_2 &&
+			   d_index == DIRECTIVE_ALLOW_WRITE) {
+			/* Source starts with "2 " and dest starts with
+			   "allow_write " */
+		} else if (s_index == DIRECTIVE_4 &&
+			   d_index == DIRECTIVE_ALLOW_READ) {
+			/* Source starts with "4 " and dest starts with
+			   "allow_read " */
+		} else if (s_index == DIRECTIVE_ALLOW_WRITE &&
+			   d_index == DIRECTIVE_2) {
+			/* Source starts with "allow_write " and dest starts
+			   with "2 " */
+		} else if (s_index == DIRECTIVE_ALLOW_READ &&
+			   d_index == DIRECTIVE_4) {
+			/* Source starts with "allow_read " and dest starts
+			   with "4 " */
+		} else if (s_index == d_index) {
+			/* Source and dest start with same directive. */
 		} else {
-			continue; /* Source and dest start with different directive. */
+			/* Source and dest start with different directive. */
+			continue;
 		}
-		strncpy(shared_buffer, cp, shared_buffer_len);
-		if (!memchr(shared_buffer, '\0', shared_buffer_len)) continue; /* Line too long. */
-		
-		split_acl(shared_buffer + d_len, &darg1, &darg2, &darg3);
-	
+		strncpy(shared_buffer, generic_acl_list[index].operand,
+			shared_buffer_len);
+		if (!memchr(shared_buffer, '\0', shared_buffer_len))
+			continue; /* Line too long. */
+
+		split_acl(shared_buffer, &darg1, &darg2, &darg3);
+
 		/* Compare condition part. */
-		if (pathcmp(&sarg3, &darg3)) continue;
-		
+		if (pathcmp(&sarg3, &darg3))
+			continue;
+
 		/* Compare first word. */
-		if (directive_index < 24) {
-			if (pathcmp(&sarg1, &darg1)) {
-				const int may_use_pattern = !darg1.is_patterned
-					&& (directive_index != 0) && (directive_index != 2) && (directive_index != 4) && (directive_index != 6) && (directive_index != 7);
-				if (darg1.name[0] == '@') continue;
-				if (sarg1.name[0] == '@') {
-					/* path_group component. */
-					int i;
-					struct path_group_entry *group = FindPathGroup(sarg1.name + 1);
-					if (!group) continue;
-					for (i = 0; i < group->member_name_len; i++) {
-						const struct path_info *member_name = group->member_name[i];
-						if (!pathcmp(member_name, &darg1)) break;
-						if (may_use_pattern && PathMatchesToPattern(&darg1, member_name)) break;
-					}
-					if (i == group->member_name_len) continue;
-				} else {
-					/* Pathname component. */
-					if (!may_use_pattern || !PathMatchesToPattern(&darg1, &sarg1)) continue;
-				}
+		switch (d_index) {
+			int i;
+			u8 may_use_pattern;
+			struct path_group_entry *p_group;
+			struct address_group_entry *a_group;
+			struct ip_address_entry sentry;
+			struct ip_address_entry dentry;
+		case DIRECTIVE_1:
+		case DIRECTIVE_2:
+		case DIRECTIVE_3:
+		case DIRECTIVE_4:
+		case DIRECTIVE_5:
+		case DIRECTIVE_6:
+		case DIRECTIVE_7:
+		case DIRECTIVE_ALLOW_EXECUTE:
+		case DIRECTIVE_ALLOW_READ:
+		case DIRECTIVE_ALLOW_WRITE:
+		case DIRECTIVE_ALLOW_READ_WRITE:
+		case DIRECTIVE_ALLOW_CREATE:
+		case DIRECTIVE_ALLOW_UNLINK:
+		case DIRECTIVE_ALLOW_MKDIR:
+		case DIRECTIVE_ALLOW_RMDIR:
+		case DIRECTIVE_ALLOW_MKFIFO:
+		case DIRECTIVE_ALLOW_MKSOCK:
+		case DIRECTIVE_ALLOW_MKBLOCK:
+		case DIRECTIVE_ALLOW_MKCHAR:
+		case DIRECTIVE_ALLOW_TRUNCATE:
+		case DIRECTIVE_ALLOW_SYMLINK:
+		case DIRECTIVE_ALLOW_LINK:
+		case DIRECTIVE_ALLOW_RENAME:
+		case DIRECTIVE_ALLOW_REWRITE:
+			if (!pathcmp(&sarg1, &darg1))
+				break;
+			may_use_pattern = !darg1.is_patterned
+				&& (d_index != DIRECTIVE_1)
+				&& (d_index != DIRECTIVE_3)
+				&& (d_index != DIRECTIVE_5)
+				&& (d_index != DIRECTIVE_7)
+				&& (d_index != DIRECTIVE_ALLOW_EXECUTE);
+			if (darg1.name[0] == '@')
+				continue;
+			if (sarg1.name[0] != '@')
+				goto not_path_group1;
+			/* path_group component. */
+			p_group = find_path_group(sarg1.name + 1);
+			if (!p_group)
+				continue;
+			for (i = 0; i < p_group->member_name_len; i++) {
+				const struct path_info *member_name;
+				member_name = p_group->member_name[i];
+				if (!pathcmp(member_name, &darg1))
+					break;
+				if (may_use_pattern &&
+				    path_matches_pattern(&darg1,
+							 member_name))
+					break;
 			}
-		} else if (directive_index == 24) {
+			if (i == p_group->member_name_len)
+				continue;
+			break;
+not_path_group1:
 			/* Pathname component. */
-			if (pathcmp(&sarg1, &darg1)) {
-				/* allow_argv0 doesn't support path_group. */
-				if (darg1.name[0] == '@' || darg1.is_patterned || !PathMatchesToPattern(&darg1, &sarg1)) continue;
-			}
-		} else if (directive_index == 25) {
+			if (!may_use_pattern ||
+			    !path_matches_pattern(&darg1, &sarg1))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_ARGV0:
+			/* Pathname component. */
+			if (!pathcmp(&sarg1, &darg1))
+				break;
+			/* allow_argv0 doesn't support path_group. */
+			if (darg1.name[0] == '@' || darg1.is_patterned ||
+			    !path_matches_pattern(&darg1, &sarg1))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_SIGNAL:
 			/* Signal number component. */
-			if (strcmp(sarg1.name, darg1.name)) continue;
-		} else if (directive_index < 34) {
-			struct ip_address_entry dentry;
-			if (parse_ip(darg1.name, &dentry)) continue;
-			if (sarg1.name[0] == '@') {
-				/* IP address group component. */
-				int i;
-				struct address_group_entry *group = FindAddressGroup(sarg1.name + 1);
-				if (!group) continue;
-				for (i = 0; i < group->member_name_len; i++) {
-					struct ip_address_entry *sentry = &group->member_name[i];
-					if (sentry->is_ipv6 == dentry.is_ipv6 && memcmp(sentry->min, dentry.min, 16) <= 0 && memcmp(dentry.max, sentry->max, 16) <= 0) break;
-				}
-				if (i == group->member_name_len) continue;
-			} else {
-				/* IP address component. */
-				struct ip_address_entry sentry;
-				if (parse_ip(sarg1.name, &sentry)) continue;
-				if (sentry.is_ipv6 != dentry.is_ipv6 || memcmp(dentry.min, sentry.min, 16) < 0 || memcmp(sentry.max, dentry.max, 16) < 0) continue;
+			if (strcmp(sarg1.name, darg1.name))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_CONNECT:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_LISTEN:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_CONNECT:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_ACCEPT:
+		case DIRECTIVE_ALLOW_NETWORK_RAW_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_RAW_CONNECT:
+			if (parse_ip(darg1.name, &dentry))
+				continue;
+			if (sarg1.name[0] != '@')
+				goto not_address_group1;
+			/* IP address group component. */
+			a_group = find_address_group(sarg1.name + 1);
+			if (!a_group)
+				continue;
+			for (i = 0; i < a_group->member_name_len; i++) {
+				struct ip_address_entry *sentry
+					= &a_group->member_name[i];
+				if (sentry->is_ipv6 == dentry.is_ipv6
+				    && memcmp(sentry->min, dentry.min, 16) <= 0
+				    && memcmp(dentry.max, sentry->max, 16) <= 0)
+					break;
 			}
-		} else {
+			if (i == a_group->member_name_len)
+				continue;
+			break;
+not_address_group1:
+			/* IP address component. */
+			if (parse_ip(sarg1.name, &sentry))
+				continue;
+			if (sentry.is_ipv6 != dentry.is_ipv6 ||
+			    memcmp(dentry.min, sentry.min, 16) < 0 ||
+			    memcmp(sentry.max, dentry.max, 16) < 0)
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_ENV:
 			/* An environemnt variable name component. */
-			if (pathcmp(&sarg1, &darg1)) {
-				/* allow_env doesn't interpret leading @ as path_group. */
-				if (darg1.is_patterned || !PathMatchesToPattern(&darg1, &sarg1)) continue;
-			}
+			if (!pathcmp(&sarg1, &darg1))
+				break;
+			/* allow_env doesn't interpret leading @ as
+			   path_group. */
+			if (darg1.is_patterned ||
+			    !path_matches_pattern(&darg1, &sarg1))
+				continue;
+			break;
+		default:
+			continue;
 		}
 
 		/* Compare rest words. */
-		if (directive_index == 21 || directive_index == 22) {
-			if (pathcmp(&sarg2, &darg2)) {
-				const int may_use_pattern = !darg2.is_patterned;
-				if (darg2.name[0] == '@') continue;
-				if (sarg2.name[0] == '@') {
-					/* path_group component. */
-					int i;
-					struct path_group_entry *group = FindPathGroup(sarg2.name + 1);
-					if (!group) continue;
-					for (i = 0; i < group->member_name_len; i++) {
-						const struct path_info *member_name = group->member_name[i];
-						if (!pathcmp(member_name, &darg2)) break;
-						if (may_use_pattern && PathMatchesToPattern(&darg2, member_name)) break;
-					}
-					if (i == group->member_name_len) continue;
-				} else {
-					/* Pathname component. */
-					if (!may_use_pattern || !PathMatchesToPattern(&darg2, &sarg2)) continue;
-				}
+		switch (d_index) {
+			char c;
+			int i;
+			u8 may_use_pattern;
+			struct path_group_entry *p_group;
+			unsigned int smin;
+			unsigned int smax;
+			unsigned int dmin;
+			unsigned int dmax;
+		case DIRECTIVE_ALLOW_LINK:
+		case DIRECTIVE_ALLOW_RENAME:
+			if (!pathcmp(&sarg2, &darg2))
+				break;
+			may_use_pattern = !darg2.is_patterned;
+			if (darg2.name[0] == '@')
+				continue;
+			if (sarg2.name[0] != '@')
+				goto not_path_group2;
+			/* path_group component. */
+			p_group = find_path_group(sarg2.name + 1);
+			if (!p_group)
+				continue;
+			for (i = 0; i < p_group->member_name_len; i++) {
+				const struct path_info *member_name
+					= p_group->member_name[i];
+				if (!pathcmp(member_name, &darg2))
+					break;
+				if (may_use_pattern &&
+				    path_matches_pattern(&darg2, member_name))
+					break;
 			}
-		} else if (directive_index == 24) {
+			if (i == p_group->member_name_len)
+				continue;
+			break;
+not_path_group2:
+			/* Pathname component. */
+			if (!may_use_pattern ||
+			    !path_matches_pattern(&darg2, &sarg2))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_ARGV0:
 			/* Basename component. */
-			if (pathcmp(&sarg2, &darg2)) {
-				if (darg2.is_patterned || !PathMatchesToPattern(&darg2, &sarg2)) continue;
-			}
-		} else if (directive_index == 25) {
+			if (!pathcmp(&sarg2, &darg2))
+				break;
+			if (darg2.is_patterned ||
+			    !path_matches_pattern(&darg2, &sarg2))
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_SIGNAL:
 			/* Domainname component. */
-			char c;
-			if (strncmp(sarg2.name, darg2.name, sarg2.total_len)) continue;
+			if (strncmp(sarg2.name, darg2.name, sarg2.total_len))
+				continue;
 			c = darg2.name[sarg2.total_len];
-			if (c && c != ' ') continue;
-		} else if (directive_index >= 26 && directive_index < 34) {
+			if (c && c != ' ')
+				continue;
+			break;
+		case DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_UDIRECTIVE_CONNECT:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_LISTEN:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_CONNECT:
+		case DIRECTIVE_ALLOW_NETWORK_TCP_ACCEPT:
+		case DIRECTIVE_ALLOW_NETWORK_RAW_BIND:
+		case DIRECTIVE_ALLOW_NETWORK_RAW_CONNECT:
 			/* Port number component. */
-			unsigned int smin, smax, dmin, dmax;
 			switch (sscanf(sarg2.name, "%u-%u", &smin, &smax)) {
 			case 1:
 				smax = smin;
@@ -1756,19 +2863,23 @@
 			default:
 				continue;
 			}
-			if (smin > dmin || smax < dmax) continue;
-		} else {
+			if (smin > dmin || smax < dmax)
+				continue;
+			break;
+		default:
 			/* This must be empty. */
-			if (sarg2.total_len || darg2.total_len) continue;
+			if (sarg2.total_len || darg2.total_len)
+				continue;
 		}
-		generic_acl_list_selected[index] = 1;
+		generic_acl_list[index].selected = 1;
 	}
 	put();
 	free(cp);
-	ShowList();
+	show_list();
 }
 
-static int GenericListLoop(void) {
+static int generic_list_loop(void)
+{
 	static char *last_error = NULL;
 	static const int max_readline_history = 20;
 	static const char **readline_history = NULL;
@@ -1778,9 +2889,11 @@
 	static int saved_current_item_index[MAXSCREEN];
 	static int first = 1;
 	if (first) {
-		readline_history = malloc(max_readline_history * sizeof(const char *));
+		readline_history = malloc(max_readline_history *
+					  sizeof(const char *));
 		memset(saved_current_y, 0, sizeof(saved_current_y));
-		memset(saved_current_item_index, 0, sizeof(saved_current_item_index));
+		memset(saved_current_item_index, 0,
+		       sizeof(saved_current_item_index));
 		memset(search_buffer, 0, sizeof(search_buffer));
 		first = 0;
 	}
@@ -1795,252 +2908,360 @@
 		list_caption = "Domain Policy";
 	} else {
 		policy_file = DOMAIN_POLICY_FILE;
-		//list_caption = "Domain Transition";
+		/* list_caption = "Domain Transition"; */
 	}
-	current_item_index[current_screen] = saved_current_item_index[current_screen];
+	current_item_index[current_screen]
+		= saved_current_item_index[current_screen];
 	current_y[current_screen] = saved_current_y[current_screen];
- start:
+start:
 	if (current_screen == SCREEN_DOMAIN_LIST) {
-		ReadDomainAndExceptionPolicy();
-		AdjustCursorPos(domain_list_count);
+		read_domain_and_exception_policy();
+		adjust_cursor_pos(domain_list_count);
 	} else {
-		ReadGenericPolicy();
-		AdjustCursorPos(generic_acl_list_count);
+		read_generic_policy();
+		adjust_cursor_pos(generic_acl_list_count);
 	}
- start2:
-	ShowList();
+start2:
+	show_list();
 	if (last_error && current_screen == SCREEN_DOMAIN_LIST) {
-		mvprintw(1, 0, "ERROR: %s", last_error); clrtoeol(); refresh();
-		free(last_error); last_error = NULL;
-	}	
+		mvprintw(1, 0, "ERROR: %s", last_error);
+		clrtoeol();
+		refresh();
+		free(last_error);
+		last_error = NULL;
+	}
 	while (1) {
-		const int current = GetCurrent();
+		const int current = get_current();
 		const int c = getch2();
-		saved_current_item_index[current_screen] = current_item_index[current_screen];
+		saved_current_item_index[current_screen]
+			= current_item_index[current_screen];
 		saved_current_y[current_screen] = current_y[current_screen];
-		if (c == 'q' || c == 'Q') return MAXSCREEN;
-		if ((c == '\r' || c == '\n') && current_screen == SCREEN_ACL_LIST) return SCREEN_DOMAIN_LIST;
+		if (c == 'q' || c == 'Q')
+			return MAXSCREEN;
+		if ((c == '\r' || c == '\n') &&
+		    current_screen == SCREEN_ACL_LIST)
+			return SCREEN_DOMAIN_LIST;
 		if (c == '\t') {
-			if (current_screen == SCREEN_DOMAIN_LIST) return SCREEN_SYSTEM_LIST;
-			else if (current_screen == SCREEN_SYSTEM_LIST) return SCREEN_EXCEPTION_LIST;
-			else return SCREEN_DOMAIN_LIST;
+			if (current_screen == SCREEN_DOMAIN_LIST)
+				return SCREEN_SYSTEM_LIST;
+			else if (current_screen == SCREEN_SYSTEM_LIST)
+				return SCREEN_EXCEPTION_LIST;
+			else
+				return SCREEN_DOMAIN_LIST;
 		}
-		if (c == ERR) continue; // Ignore invalid key.
-		switch(c) {
+		if (c == ERR)
+			continue; /* Ignore invalid key. */
+		switch (c) {
+			int index;
+			char *line;
+			const char *cline;
+			int d;
+			FILE *fp;
 		case KEY_RESIZE:
-			ResizeWindow();
-			ShowList();
+			resize_window();
+			show_list();
 			break;
 		case KEY_UP:
-			UpArrowKey();
+			up_arrow_key();
 			break;
 		case KEY_DOWN:
-			DownArrowKey();
+			down_arrow_key();
 			break;
 		case KEY_PPAGE:
-			PageUpKey();
+			page_up_key();
 			break;
 		case KEY_NPAGE:
-			PageDownKey();
+			page_down_key();
 			break;
 		case ' ':
-			SelectItem(current);
+			select_item(current);
 			break;
 		case 'c':
 		case 'C':
-			if (current >= 0) {
-				int index;
-				if (current_screen == SCREEN_DOMAIN_LIST) {
-					if (IsDeletedDomain(current) || IsInitializerSource(current)) break;
-					for (index = current; index < domain_list_count; index++) {
-						if (IsDeletedDomain(index) || IsInitializerSource(index)) continue;
-						domain_list_selected[index] = domain_list_selected[current];
-					}
-				} else {
-					for (index = current; index < generic_acl_list_count; index++) {
-						generic_acl_list_selected[index] = generic_acl_list_selected[current];
-					}
+			if (current == EOF)
+				break;
+			if (current_screen == SCREEN_DOMAIN_LIST) {
+				const u8 selected
+					= domain_list_selected[current];
+				if (is_deleted_domain(current) ||
+				    is_initializer_source(current))
+					break;
+				for (index = current;
+				     index < domain_list_count; index++) {
+					if (is_deleted_domain(index) ||
+					    is_initializer_source(index))
+						continue;
+					domain_list_selected[index] = selected;
 				}
-				ShowList();
+			} else {
+				const u8 selected
+					= generic_acl_list[current].selected;
+				for (index = current;
+				     index < generic_acl_list_count; index++) {
+					generic_acl_list[index].selected
+						= selected;
+				}
 			}
+			show_list();
 			break;
 		case 'f':
 		case 'F':
-			if (current >= 0) {
-				int index;
-				char *line;
-			input_path:
-				attrChange(A_BOLD, ON);	// add color
-				line = simple_readline(window_height - 1, 0, "Search> ", readline_history, readline_history_count, 4000, 8);
-				attrChange(A_BOLD, OFF);	// add color
-				if (line && *line) {
-					readline_history_count = simple_add_history(line, readline_history, readline_history_count, max_readline_history);
-					free(search_buffer[current_screen]); search_buffer[current_screen] = line; line = NULL;
-					for (index = 0; index < list_item_count[current_screen]; index++) {
-						const char *cp = (current_screen == SCREEN_DOMAIN_LIST) ? GetLastName(index) : generic_acl_list[index];
-						if (!strstr(cp, search_buffer[current_screen])) continue;
-						SetCursorPos(index);
-						break;
-					}
-				}
-				free(line);
-				ShowList();
+			if (current == EOF)
+				break;
+input_path:
+			editpolicy_attr_change(A_BOLD, ON); /* add color */
+			line = simple_readline(window_height - 1, 0,
+					       "Search> ", readline_history,
+					       readline_history_count, 4000, 8);
+			editpolicy_attr_change(A_BOLD, OFF); /* add color */
+			if (!line || !*line)
+				goto out1;
+			readline_history_count
+				= simple_add_history(line, readline_history,
+						     readline_history_count,
+						     max_readline_history);
+			free(search_buffer[current_screen]);
+			search_buffer[current_screen] = line;
+			line = NULL;
+			for (index = 0; index < list_item_count[current_screen];
+			     index++) {
+				const char *cp;
+				if (current_screen == SCREEN_DOMAIN_LIST)
+					cp = get_last_name(index);
+				else
+					cp = generic_acl_list[index].operand;
+				if (!strstr(cp, search_buffer[current_screen]))
+					continue;
+				set_cursor_pos(index);
+				break;
 			}
+out1:
+			free(line);
+			show_list();
 			break;
 		case 'p':
 		case 'P':
-			if (current >= 0) {
-				int index;
-				if (!search_buffer[current_screen]) goto input_path;
-				for (index = current - 1; index >= 0; index--) {
-					const char *cp = (current_screen == SCREEN_DOMAIN_LIST) ? GetLastName(index) : generic_acl_list[index];
-					if (!strstr(cp, search_buffer[current_screen])) continue;
-					SetCursorPos(index);
-					ShowList();
-					break;
-				}
+			if (current == EOF)
+				break;
+			if (!search_buffer[current_screen])
+				goto input_path;
+			for (index = current - 1; index >= 0; index--) {
+				const char *cp;
+				if (current_screen == SCREEN_DOMAIN_LIST)
+					cp = get_last_name(index);
+				else
+					cp = generic_acl_list[index].operand;
+				if (!strstr(cp, search_buffer[current_screen]))
+					continue;
+				set_cursor_pos(index);
+				show_list();
+				break;
 			}
 			break;
 		case 'n':
 		case 'N':
-			if (current >= 0) {
-				int index;
-				if (!search_buffer[current_screen]) goto input_path;
-				for (index = current + 1; index < list_item_count[current_screen]; index++) {
-					const char *cp = (current_screen == SCREEN_DOMAIN_LIST) ? GetLastName(index) : generic_acl_list[index];
-					if (!strstr(cp, search_buffer[current_screen])) continue;
-					SetCursorPos(index);
-					ShowList();
-					break;
-				}
+			if (current == EOF)
+				break;
+			if (!search_buffer[current_screen])
+				goto input_path;
+			for (index = current + 1;
+			     index < list_item_count[current_screen]; index++) {
+				const char *cp;
+				if (current_screen == SCREEN_DOMAIN_LIST)
+					cp = get_last_name(index);
+				else
+					cp = generic_acl_list[index].operand;
+				if (!strstr(cp, search_buffer[current_screen]))
+					continue;
+				set_cursor_pos(index);
+				show_list();
+				break;
 			}
 			break;
 		case 'd':
 		case 'D':
-			{
-				int c;
-				move(1, 0);
-				colorChange(DISP_ERR, ON);	// add color
-				if (current_screen == SCREEN_DOMAIN_LIST) {
-					if ((c = count(domain_list_selected, domain_list_count)) == 0 && (c = SelectItem(current)) == 0) printw("Select domain using Space key first.");
-					else printw("Delete selected domain%s? ('Y'es/'N'o)", c > 1 ? "s" : "");
-				} else {
-					if ((c = count(generic_acl_list_selected, generic_acl_list_count)) == 0 && (c = SelectItem(current)) == 0) printw("Select entry using Space key first.");
-					else printw("Delete selected entr%s? ('Y'es/'N'o)", c > 1 ? "ies" : "y");
+			move(1, 0);
+			editpolicy_color_change(DISP_ERR, ON);	/* add color */
+			if (current_screen != SCREEN_DOMAIN_LIST)
+				goto not_domain_list;
+			d = count(domain_list_selected, domain_list_count);
+			if (!d)
+				d = select_item(current);
+			if (!d)
+				printw("Select domain using Space key first.");
+			else
+				printw("Delete selected domain%s? ('Y'es/'N'o)",
+				       d > 1 ? "s" : "");
+			goto d_end;
+not_domain_list:
+			d = count2(generic_acl_list, generic_acl_list_count);
+			if (!d)
+				d = select_item(current);
+			if (!d)
+				printw("Select entry using Space key first.");
+			else
+				printw("Delete selected entr%s? ('Y'es/'N'o)",
+				       d > 1 ? "ies" : "y");
+d_end:
+			editpolicy_color_change(DISP_ERR, OFF);	/* add color */
+			clrtoeol();
+			refresh();
+			if (!d)
+				break;
+			do {
+				d = getch2();
+			} while (!(d == 'Y' || d == 'y' ||
+				   d == 'N' || d == 'n' || d == EOF));
+			resize_window();
+			if (d != 'Y' && d != 'y') {
+				show_list();
+				break;
+			}
+			if (current_screen == SCREEN_DOMAIN_LIST) {
+				FILE *fp = open_write(DOMAIN_POLICY_FILE);
+				if (!fp)
+					goto start;
+				for (index = 1; index < domain_list_count;
+				     index++) {
+					if (!domain_list_selected[index])
+						continue;
+					fprintf(fp, "delete %s\n",
+						domain_name(index));
 				}
-				colorChange(DISP_ERR, OFF);	// add color
-				clrtoeol();
-				refresh();
-				if (!c) break;
-				do {
-					c = getch2();
-				} while (!(c == 'Y' || c == 'y' || c == 'N' || c == 'n' || c == EOF));
-				ResizeWindow();
-				if (c == 'Y' || c == 'y') {
-					int index;
-					if (current_screen == SCREEN_DOMAIN_LIST) {
-						FILE *fp = open_write(DOMAIN_POLICY_FILE);
-						if (fp) {
-							for (index = 1; index < domain_list_count; index++) {
-								if (domain_list_selected[index]) fprintf(fp, "delete %s\n", DomainName(index));
-							}
-							fclose(fp);
-						}
-					} else {
-						FILE *fp = open_write(policy_file);
-						if (fp) {
-							if (current_screen == SCREEN_ACL_LIST) fprintf(fp, "select %s\n", current_domain);
-							for (index = 0; index < generic_acl_list_count; index++) {
-								if (generic_acl_list_selected[index]) fprintf(fp, "delete %s\n", map_perm_keyword(0, generic_acl_list[index]));
-							}
-							fclose(fp);
-						}
-					}
+				fclose(fp);
+			} else {
+				FILE *fp = open_write(policy_file);
+				if (!fp)
 					goto start;
+				if (current_screen == SCREEN_ACL_LIST)
+					fprintf(fp, "select %s\n",
+						current_domain);
+				for (index = 0; index < generic_acl_list_count;
+				     index++) {
+					u8 d;
+					const char *cp;
+					if (!generic_acl_list[index].selected)
+						continue;
+					d = generic_acl_list[index].directive;
+					cp = generic_acl_list[index].operand;
+					fprintf(fp, "delete %s %s\n",
+						directives[d].original, cp);
 				}
-				ShowList();
+				fclose(fp);
 			}
-			break;
+			goto start;
 		case 'a':
 		case 'A':
-			{
-				attrChange(A_BOLD, ON);	// add color
-				char *line = simple_readline(window_height - 1, 0, "Enter new entry> ", readline_history, readline_history_count, 8192, 8);
-				attrChange(A_BOLD, OFF);	// add color
-				if (line && *line) {
-					readline_history_count = simple_add_history(line, readline_history, readline_history_count, max_readline_history);
-					if (current_screen == SCREEN_DOMAIN_LIST && !IsCorrectDomain(line)) {
-						const int len = strlen(line) + 128;
-						if ((last_error = (char *) realloc(last_error, len)) == NULL) OutOfMemory();
-						memset(last_error, 0, len);
-						snprintf(last_error, len - 1, "%s is an invalid domainname.", line);
-					} else {
-						FILE *fp = open_write(policy_file);
-						if (fp) {
-							if (current_screen == SCREEN_ACL_LIST) fprintf(fp, "select %s\n", current_domain);
-							fprintf(fp, "%s\n", map_perm_keyword(0, line));
-							fclose(fp);
-						}
-					}
-				}
-				free(line);
-				goto start;
+			editpolicy_attr_change(A_BOLD, ON);  /* add color */
+			line = simple_readline(window_height - 1, 0,
+					       "Enter new entry> ",
+					       readline_history,
+					       readline_history_count, 8192, 8);
+			editpolicy_attr_change(A_BOLD, OFF); /* add color */
+			if (!line || !*line)
+				goto out2;
+			readline_history_count
+				= simple_add_history(line, readline_history,
+						     readline_history_count,
+						     max_readline_history);
+			if (current_screen == SCREEN_DOMAIN_LIST &&
+			    !IsCorrectDomain(line)) {
+				const int len = strlen(line) + 128;
+				last_error = realloc(last_error, len);
+				if (!last_error)
+					OutOfMemory();
+				memset(last_error, 0, len);
+				snprintf(last_error, len - 1,
+					 "%s is an invalid domainname.", line);
+			} else {
+				u8 d;
+				FILE *fp = open_write(policy_file);
+				if (!fp)
+					goto out1;
+				if (current_screen == SCREEN_ACL_LIST)
+					fprintf(fp, "select %s\n",
+						current_domain);
+				d = find_directive(0, line);
+				if (d != (u8) EOF)
+					fprintf(fp, "%s ",
+						directives[d].original);
+				fprintf(fp, "%s\n", line);
+				fclose(fp);
 			}
-			break;
+out2:
+			free(line);
+			goto start;
 		case '\r':
 		case '\n':
-			if (current_screen == SCREEN_DOMAIN_LIST) {
-				if (IsInitializerSource(current)) {
-					int redirect_index;
-					get();
-					memset(shared_buffer, 0, shared_buffer_len);
-					snprintf(shared_buffer, shared_buffer_len - 1, ROOT_NAME "%s", strrchr(DomainName(current), ' '));
-					redirect_index = FindDomain(shared_buffer, 0, 0);
-					put();
-					if (redirect_index != EOF) {
-						current_item_index[current_screen] = redirect_index - current_y[current_screen];
-						while (current_item_index[current_screen] < 0) {
-							current_item_index[current_screen]++; current_y[current_screen]--;
-						}
-						ShowList();
-					}
-				} else if (!IsDeletedDomain(current)) {
-					free(current_domain);
-					if ((current_domain = strdup(DomainName(current))) == NULL) OutOfMemory();
-					return SCREEN_ACL_LIST;
+			if (current_screen != SCREEN_DOMAIN_LIST)
+				break;
+			if (is_initializer_source(current)) {
+				int redirect_index;
+				get();
+				memset(shared_buffer, 0, shared_buffer_len);
+				snprintf(shared_buffer, shared_buffer_len - 1,
+					 ROOT_NAME "%s",
+					 strrchr(domain_name(current), ' '));
+				redirect_index = find_domain(shared_buffer, 0,
+							     0);
+				put();
+				if (redirect_index == EOF)
+					break;
+				current_item_index[current_screen]
+					= redirect_index
+					- current_y[current_screen];
+				while (current_item_index[current_screen] < 0) {
+					current_item_index[current_screen]++;
+					current_y[current_screen]--;
 				}
+				show_list();
+			} else if (!is_deleted_domain(current)) {
+				free(current_domain);
+				current_domain = strdup(domain_name(current));
+				if (!current_domain)
+					OutOfMemory();
+				return SCREEN_ACL_LIST;
 			}
 			break;
 		case 's':
 		case 'S':
-			if (current_screen == SCREEN_DOMAIN_LIST) {
-				if (!count(domain_list_selected, domain_list_count) && !SelectItem(current)) {
-					mvprintw(1, 0, "Select domain using Space key first."); clrtoeol(); refresh();
-				} else {
-					attrChange(A_BOLD, ON);	// add color
-					char *line = simple_readline(window_height - 1, 0, "Enter profile number> ", NULL, 0, 8, 1);
-					attrChange(A_BOLD, OFF);	// add color
-					if (line && *line) {
-						FILE *fp = open_write(DOMAIN_POLICY_FILE);
-						if (fp) {
-							int index;
-							for (index = 0; index < domain_list_count; index++) {
-								if (domain_list_selected[index]) fprintf(fp, "select %s\nuse_profile %s\n", DomainName(index), line);
-							}
-							fclose(fp);
-						}
-					}
-					free(line);
-					goto start;
-				}
+			if (current_screen != SCREEN_DOMAIN_LIST)
+				break;
+			if (!count(domain_list_selected, domain_list_count) &&
+			    !select_item(current)) {
+				mvprintw(1, 0, "Select domain "
+					 "using Space key first.");
+				clrtoeol();
+				refresh();
+				break;
 			}
-			break;
+			editpolicy_attr_change(A_BOLD, ON);  /* add color */
+			line = simple_readline(window_height - 1, 0,
+					       "Enter profile number> ", NULL,
+					       0, 8, 1);
+			editpolicy_attr_change(A_BOLD, OFF); /* add color */
+			if (!line || !*line)
+				goto out3;
+			fp = open_write(DOMAIN_POLICY_FILE);
+			if (!fp)
+				goto out3;
+			for (index = 0; index < domain_list_count; index++) {
+				if (!domain_list_selected[index])
+					continue;
+				fprintf(fp, "select %s\n" KEYWORD_USE_PROFILE
+					"%s\n", domain_name(index), line);
+			}
+			fclose(fp);
+out3:
+			free(line);
+			goto start;
 		case 'r':
 		case 'R':
 			goto start;
 		case KEY_LEFT:
-			if (!max_eat_col[current_screen]) break;
-			max_eat_col[current_screen]--; 
+			if (!max_eat_col[current_screen])
+				break;
+			max_eat_col[current_screen]--;
 			goto start2;
 		case KEY_RIGHT:
 			max_eat_col[current_screen]++;
@@ -2052,63 +3273,93 @@
 			max_eat_col[current_screen] = max_col;
 			goto start2;
 		case KEY_IC:
-			if (current >= 0) readline_history_count = simple_add_history(current_screen == SCREEN_DOMAIN_LIST ? DomainName(current) : generic_acl_list[current], readline_history, readline_history_count, max_readline_history);
+			if (current == EOF)
+				break;
+			if (current_screen == SCREEN_DOMAIN_LIST)
+				cline = domain_name(current);
+			else
+				cline = generic_acl_list[current].operand;
+			readline_history_count
+				= simple_add_history(cline, readline_history,
+						     readline_history_count,
+						     max_readline_history);
 			break;
 		case 'o':
 		case 'O':
-			if (current_screen == SCREEN_ACL_LIST) try_optimize(current);
+			if (current_screen == SCREEN_ACL_LIST)
+				try_optimize(current);
 			break;
 		case '@':
-			if (current_screen != SCREEN_ACL_LIST) break;
+			if (current_screen != SCREEN_ACL_LIST)
+				break;
 			sort_type = (sort_type + 1) % 2;
 			goto start;
 		case '?':
-			{
-				int c;
-				clear();
-				printw("Commands available for this screen are:\n\n"
-					   "Q/q        Quit this editor.\n"
-					   "R/r        Refresh to the latest information.\n"
-					   "F/f        Find first.\n"
-					   "N/n        Find next.\n"
-					   "P/p        Find previous.\n"
-					   "Tab        Switch to next screen.\n"
-					   "Insert     Copy an entry at the cursor position to history buffer.\n"
-					   "Space      Invert selection state of an entry at the cursor position.\n"
-					   "C/c        Copy selection state of an entry at the cursor position to all entries below the cursor position.\n");
-				if (current_screen == SCREEN_DOMAIN_LIST) {
-					printw("A/a        Add a new domain.\n"
-						   "Enter      Edit ACLs of a domain at the cursor position.\n"
-						   "D/d        Delete selected domains.\n"
-						   "S/s        Set profile number of selected domains.\n");
-				} else {
-					printw("A/a        Add a new entry.\n"
-						   "D/d        Delete selected entries.\n");
-					if (current_screen == SCREEN_ACL_LIST) {
-						printw("O/o        Set selection state to other entries included in an entry at the cursor position.\n");
-						printw("@          Switch sort type.\n");
-					}
-				}
-				printw("Arrow-keys and PageUp/PageDown/Home/End keys for scroll.\n\n"
-					   "Press '?' to escape from this help.\n"); refresh();
-				while ((c = getch2()) != '?' && c != EOF);
-				goto start;
+			clear();
+			printw("Commands available for this screen are:\n\n"
+			       "Q/q        Quit this editor.\n"
+			       "R/r        Refresh to the latest information.\n"
+			       "F/f        Find first.\n"
+			       "N/n        Find next.\n"
+			       "P/p        Find previous.\n"
+			       "Tab        Switch to next screen.\n"
+			       "Insert     Copy an entry at the cursor position"
+			       " to history buffer.\n"
+			       "Space      Invert selection state of an entry "
+			       "at the cursor position.\n"
+			       "C/c        Copy selection state of an entry at "
+			       "the cursor position to all entries below the "
+			       "cursor position.\n");
+			if (current_screen != SCREEN_DOMAIN_LIST)
+				goto not_domain_list2;
+			printw("A/a        Add a new domain.\n"
+			       "Enter      Edit ACLs of a domain at the cursor "
+			       "position.\n"
+			       "D/d        Delete selected domains.\n"
+			       "S/s        Set profile number of selected "
+			       "domains.\n");
+			goto wait_key;
+not_domain_list2:
+			printw("A/a        Add a new entry.\n"
+			       "D/d        Delete selected entries.\n");
+			if (current_screen != SCREEN_ACL_LIST)
+				goto wait_key;
+			printw("O/o        Set selection state to other entries"
+			       " included in an entry at the cursor position."
+			       "\n");
+			printw("@          Switch sort type.\n");
+wait_key:
+			printw("Arrow-keys and PageUp/PageDown/Home/End keys "
+			       "for scroll.\n\n"
+			       "Press '?' to escape from this help.\n");
+			refresh();
+			while (1) {
+				d = getch2();
+				if (d == '?' || d == EOF)
+					break;
 			}
-			break;
+			goto start;
 		}
 	}
 }
 
-static void policy_daemon(void) {
+static void policy_daemon(void)
+{
 	get();
-	FindOrAssignNewDomain(ROOT_NAME, 0, 0);
+	find_or_assign_new_domain(ROOT_NAME, 0, 0);
 	while (1) {
-		static const struct path_info **exception_list = NULL, **system_list = NULL;
-		static int exception_list_count = 0, system_list_count = 0;
+		static const struct path_info **exception_list = NULL;
+		static const struct path_info **system_list = NULL;
+		static int exception_list_count = 0;
+		static int system_list_count = 0;
 		FILE *fp;
+		int i;
+		int j;
+		int index;
 		{
 			struct msghdr msg;
-			struct iovec iov = { shared_buffer, shared_buffer_len - 1 };
+			struct iovec iov = { shared_buffer,
+					     shared_buffer_len - 1 };
 			char cmsg_buf[CMSG_SPACE(sizeof(int))];
 			struct cmsghdr *cmsg = (struct cmsghdr *) cmsg_buf;
 			memset(&msg, 0, sizeof(msg));
@@ -2123,8 +3374,9 @@
 				cmsg->cmsg_level == SOL_SOCKET &&
 				cmsg->cmsg_type == SCM_RIGHTS &&
 				cmsg->cmsg_len == CMSG_LEN(sizeof(int))) {
-				const int fd = * (int *) CMSG_DATA(cmsg);
-				if ((fp = fdopen(fd, "w+")) == NULL) {
+				const int fd = *(int *) CMSG_DATA(cmsg);
+				fp = fdopen(fd, "w+");
+				if (!fp) {
 					close(fd);
 					continue;
 				}
@@ -2132,98 +3384,144 @@
 				break;
 			}
 		}
-		if (strncmp(shared_buffer, "POST ", 5) == 0) {
-			if (strcmp(shared_buffer + 5, "domain_policy") == 0) {
-				int index = EOF;
-				while (freadline(fp)) {
-					int is_delete = 0, is_select = 0;
-					if (strncmp(shared_buffer, "delete ", 7) == 0) {
-						is_delete = 1;
-						RemoveHeader(shared_buffer, 7);
-					} else if (strncmp(shared_buffer, "select ", 7) == 0) {
-						is_select = 1;
-						RemoveHeader(shared_buffer, 7);
-					}
-					if (IsDomainDef(shared_buffer)) {
-						if (is_delete) {
-							index = FindDomain(shared_buffer, 0, 0);
-							if (index > 0) DeleteDomain(index);
-							index = EOF;
-						} else if (is_select) {
-							index = FindDomain(shared_buffer, 0, 0);
-						} else {
-							index = FindOrAssignNewDomain(shared_buffer, 0, 0);
-						}
-					} else if (index >= 0 && shared_buffer[0]) {
-						unsigned int profile;
-						if (sscanf(shared_buffer, "use_profile %u", &profile) == 1) {
-							domain_list[index].profile = (unsigned char) profile;
-						} else if (is_delete) {
-							DelStringEntry(shared_buffer, index);
-						} else {
-							AddStringEntry(shared_buffer, index);
-						}
-					}
-				}
-			} else if (strcmp(shared_buffer + 5, "exception_policy") == 0) {
-				while (freadline(fp)) {
-					if (!shared_buffer[0]) continue;
-					if (strncmp(shared_buffer, "delete ", 7) == 0) {
-						int i;
-						struct path_info path;
-						RemoveHeader(shared_buffer, 7);
-						path.name = shared_buffer;
-						fill_path_info(&path);
-						for (i = 0; i < exception_list_count; i++) {
-							if (pathcmp(exception_list[i], &path)) continue;
-							for (exception_list_count--; i < exception_list_count; i++) exception_list[i] = exception_list[i + 1];
-							break;
-						}
-					} else {
-						if ((exception_list = (const struct path_info **) realloc(exception_list, (exception_list_count + 1) * sizeof(const struct path_info *))) == NULL
-							|| (exception_list[exception_list_count++] = SaveName(shared_buffer)) == NULL) OutOfMemory();
-					}
-				}
-			} else if (strcmp(shared_buffer + 5, "system_policy") == 0) {
-				while (freadline(fp)) {
-					if (!shared_buffer[0]) continue;
-					if (strncmp(shared_buffer, "delete ", 7) == 0) {
-						int i;
-						struct path_info path;
-						RemoveHeader(shared_buffer, 7);
-						path.name = shared_buffer;
-						fill_path_info(&path);
-						for (i = 0; i < system_list_count; i++) {
-							if (pathcmp(system_list[i], &path)) continue;
-							for (system_list_count--; i < system_list_count; i++) system_list[i] = system_list[i + 1];
-							break;
-						}
-					} else {
-						if ((system_list = (const struct path_info **) realloc(system_list, (system_list_count + 1) * sizeof(struct path_info *))) == NULL
-							|| (system_list[system_list_count++] = SaveName(shared_buffer)) == NULL) OutOfMemory();
-					}
-				}
+		if (!str_starts(shared_buffer, "POST "))
+			goto not_post_method;
+		if (strcmp(shared_buffer, "domain_policy"))
+			goto not_domain_policy1;
+		index = EOF;
+		while (freadline(fp)) {
+			int is_delete = 0, is_select = 0;
+			unsigned int profile;
+			if (str_starts(shared_buffer, "delete "))
+				is_delete = 1;
+			else if (str_starts(shared_buffer, "select "))
+				is_select = 1;
+			if (!IsDomainDef(shared_buffer))
+				goto not_domain_def;
+			if (is_delete) {
+				index = find_domain(shared_buffer, 0, 0);
+				if (index > 0)
+					delete_domain(index);
+				index = EOF;
+				continue;
 			}
-		} else if (strncmp(shared_buffer, "GET ", 4) == 0) {
-			if (strcmp(shared_buffer + 4, "domain_policy") == 0) {
-				int i, j;
-				for (i = 0; i < domain_list_count; i++) {
-					const struct path_info **string_ptr = domain_list[i].string_ptr;
-					const int string_count = domain_list[i].string_count;
-					fprintf(fp, "%s\nuse_profile %u\n\n", DomainName(i), domain_list[i].profile);
-					for (j = 0; j < string_count; j++) {
-						fprintf(fp, "%s\n", string_ptr[j]->name);
-					}
-					fprintf(fp, "\n");
-				}
-			} else if (strcmp(shared_buffer + 4, "exception_policy") == 0) {
-				int i;
-				for (i = 0; i < exception_list_count; i++) fprintf(fp, "%s\n", exception_list[i]->name);
-			} else if (strcmp(shared_buffer + 4, "system_policy") == 0) {
-				int i;
-				for (i = 0; i < system_list_count; i++) fprintf(fp, "%s\n", system_list[i]->name);
+			if (is_select) {
+				index = find_domain(shared_buffer, 0, 0);
+				continue;
 			}
+			index = find_or_assign_new_domain(shared_buffer, 0, 0);
+			continue;
+not_domain_def:
+			if (index == EOF || !shared_buffer[0])
+				continue;
+			if (sscanf(shared_buffer, KEYWORD_USE_PROFILE "%u",
+				   &profile) == 1)
+				domain_list[index].profile = (u8) profile;
+			else if (is_delete)
+				del_string_entry(shared_buffer, index);
+			else
+				add_string_entry(shared_buffer, index);
 		}
+		goto close_file;
+not_domain_policy1:
+		if (!strcmp(shared_buffer, "exception_policy"))
+			goto not_exception_policy1;
+		while (freadline(fp)) {
+			int i;
+			struct path_info path;
+			const struct path_info *cp;
+			void *vp;
+			if (!shared_buffer[0])
+				continue;
+			if (!str_starts(shared_buffer, "delete "))
+				goto not_delete_exception;
+			path.name = shared_buffer;
+			fill_path_info(&path);
+			for (i = 0; i < exception_list_count; i++) {
+				if (pathcmp(exception_list[i], &path))
+					continue;
+				for (exception_list_count--;
+				     i < exception_list_count; i++)
+					exception_list[i]
+						= exception_list[i + 1];
+				break;
+			}
+			continue;
+not_delete_exception:
+			vp = realloc(exception_list, (exception_list_count + 1)
+				     * sizeof(const struct path_info *));
+			if (!vp)
+				OutOfMemory();
+			exception_list = vp;
+			cp = SaveName(shared_buffer);
+			if (!cp)
+				OutOfMemory();
+			exception_list[exception_list_count++] = cp;
+		}
+		goto close_file;
+not_exception_policy1:
+		if (!strcmp(shared_buffer, "system_policy"))
+			goto close_file;
+		while (freadline(fp)) {
+			int i;
+			struct path_info path;
+			const struct path_info *cp;
+			void *vp;
+			if (!shared_buffer[0])
+				continue;
+			if (!str_starts(shared_buffer, "delete "))
+				goto not_delete_system;
+			path.name = shared_buffer;
+			fill_path_info(&path);
+			for (i = 0; i < system_list_count; i++) {
+				if (pathcmp(system_list[i], &path))
+					continue;
+				for (system_list_count--;
+				     i < system_list_count; i++)
+					system_list[i] = system_list[i + 1];
+				break;
+			}
+			continue;
+not_delete_system:
+			vp = realloc(system_list, (system_list_count + 1)
+				     * sizeof(struct path_info *));
+			if (!vp)
+				OutOfMemory();
+			system_list = vp;
+			cp = SaveName(shared_buffer);
+			if (!cp)
+				OutOfMemory();
+			system_list[system_list_count++] = cp;
+		}
+		goto close_file;
+not_post_method:
+		if (!str_starts(shared_buffer, "GET "))
+			goto close_file;
+		if (strcmp(shared_buffer, "domain_policy"))
+			goto not_domain_policy2;
+		for (i = 0; i < domain_list_count; i++) {
+			const struct path_info **string_ptr
+				= domain_list[i].string_ptr;
+			const int string_count = domain_list[i].string_count;
+			fprintf(fp, "%s\n" KEYWORD_USE_PROFILE "%u\n\n",
+				domain_name(i), domain_list[i].profile);
+			for (j = 0; j < string_count; j++)
+				fprintf(fp, "%s\n", string_ptr[j]->name);
+			fprintf(fp, "\n");
+		}
+		goto close_file;
+not_domain_policy2:
+		if (strcmp(shared_buffer, "exception_policy"))
+			goto not_exception_policy2;
+		for (i = 0; i < exception_list_count; i++)
+			fprintf(fp, "%s\n", exception_list[i]->name);
+		goto close_file;
+not_exception_policy2:
+		if (strcmp(shared_buffer, "system_policy"))
+			goto close_file;
+		for (i = 0; i < system_list_count; i++)
+			fprintf(fp, "%s\n", system_list[i]->name);
+close_file:
 		fclose(fp);
 	}
 	put();
@@ -2232,15 +3530,19 @@
 
 static void init_keyword_map(void);
 
-int editpolicy_main(int argc, char *argv[]) {
+int editpolicy_main(int argc, char *argv[])
+{
 	memset(current_y, 0, sizeof(current_y));
 	memset(current_item_index, 0, sizeof(current_item_index));
 	memset(list_item_count, 0, sizeof(list_item_count));
 	memset(max_eat_col, 0, sizeof(max_eat_col));
 	if (argc > 1) {
-		if (strcmp(argv[1], "s") == 0) current_screen = SCREEN_SYSTEM_LIST;
-		else if (strcmp(argv[1], "e") == 0) current_screen = SCREEN_EXCEPTION_LIST;
-		else if (strcmp(argv[1], "d") == 0) current_screen = SCREEN_DOMAIN_LIST;
+		if (!strcmp(argv[1], "s"))
+			current_screen = SCREEN_SYSTEM_LIST;
+		else if (!strcmp(argv[1], "e"))
+			current_screen = SCREEN_EXCEPTION_LIST;
+		else if (!strcmp(argv[1], "d"))
+			current_screen = SCREEN_DOMAIN_LIST;
 		else {
 			printf("Usage: %s [s|e|d]\n", argv[0]);
 			return 1;
@@ -2249,14 +3551,18 @@
 	init_keyword_map();
 	{
 		char *cp = strrchr(argv[0], '/');
-		if (!cp) cp = argv[0];
-		else cp++;
-		if (strstr(cp, "editpolicy_offline")) offline_mode = 1;
+		if (!cp)
+			cp = argv[0];
+		else
+			cp++;
+		if (strstr(cp, "editpolicy_offline"))
+			offline_mode = 1;
 	}
 	if (offline_mode) {
 		int fd[2];
 		if (chdir(disk_policy_dir)) {
-			printf("Directory %s doesn't exist.\n", disk_policy_dir);
+			printf("Directory %s doesn't exist.\n",
+			       disk_policy_dir);
 			return 1;
 		}
 		if (socketpair(PF_UNIX, SOCK_STREAM, 0, fd)) {
@@ -2276,42 +3582,65 @@
 		close(fd[1]);
 		persistent_fd = fd[0];
 		{
-			int fd, len;
+			int fd;
+			int len;
 			FILE *fp;
 			get();
-			if ((fd = open(disk_policy_system_policy, O_RDONLY)) != EOF) {
+			fd = open(disk_policy_system_policy, O_RDONLY);
+			if (fd != EOF) {
 				fp = open_write(SYSTEM_POLICY_FILE);
-				while ((len = read(fd, shared_buffer, shared_buffer_len)) > 0) fwrite(shared_buffer, len, 1, fp);
-				fclose(fp); close(fd);
+				while ((len = read(fd, shared_buffer,
+						   shared_buffer_len)) > 0)
+					fwrite(shared_buffer, len, 1, fp);
+				fclose(fp);
+				close(fd);
 			}
-			if ((fd = open(disk_policy_exception_policy, O_RDONLY)) != EOF) {
+			fd = open(disk_policy_exception_policy, O_RDONLY);
+			if (fd != EOF) {
 				fp = open_write(EXCEPTION_POLICY_FILE);
-				while ((len = read(fd, shared_buffer, shared_buffer_len)) > 0) fwrite(shared_buffer, len, 1, fp);
-				fclose(fp); close(fd);
+				while ((len = read(fd, shared_buffer,
+						   shared_buffer_len)) > 0)
+					fwrite(shared_buffer, len, 1, fp);
+				fclose(fp);
+				close(fd);
 			}
-			if ((fd = open(disk_policy_domain_policy, O_RDONLY)) != EOF) {
+			fd = open(disk_policy_domain_policy, O_RDONLY);
+			if (fd != EOF) {
 				fp = open_write(DOMAIN_POLICY_FILE);
-				while ((len = read(fd, shared_buffer, shared_buffer_len)) > 0) fwrite(shared_buffer, len, 1, fp);
-				fclose(fp); close(fd);
+				while ((len = read(fd, shared_buffer,
+						   shared_buffer_len)) > 0)
+					fwrite(shared_buffer, len, 1, fp);
+				fclose(fp);
+				close(fd);
 			}
 			put();
 		}
 	} else {
 		if (chdir(proc_policy_dir)) {
-			fprintf(stderr, "You can't use this editor for this kernel.\n");
+			fprintf(stderr,
+				"You can't use this editor for this kernel.\n");
 			return 1;
 		}
 		{
-			const int fd1 = open(SYSTEM_POLICY_FILE, O_RDWR), fd2 = open(EXCEPTION_POLICY_FILE, O_RDWR), fd3 = open(DOMAIN_POLICY_FILE, O_RDWR);
-			if ((fd1 != EOF && write(fd1, "", 0) != 0) || (fd2 != EOF && write(fd2, "", 0) != 0) || (fd3 != EOF && write(fd3, "", 0) != 0)) {
-				fprintf(stderr, "You need to register this program to %s to run this program.\n", proc_policy_manager);
+			const int fd1 = open(SYSTEM_POLICY_FILE, O_RDWR);
+			const int fd2 = open(EXCEPTION_POLICY_FILE, O_RDWR);
+			const int fd3 = open(DOMAIN_POLICY_FILE, O_RDWR);
+			if ((fd1 != EOF && write(fd1, "", 0) != 0) ||
+			    (fd2 != EOF && write(fd2, "", 0) != 0) ||
+			    (fd3 != EOF && write(fd3, "", 0) != 0)) {
+				fprintf(stderr,
+					"You need to register this program to "
+					"%s to run this program.\n",
+					proc_policy_manager);
 				return 1;
 			}
-			close(fd1); close(fd2); close(fd3);
+			close(fd1);
+			close(fd2);
+			close(fd3);
 		}
 	}
 	initscr();
-	ColorInit();	// add color
+	editpolicy_color_init();
 	cbreak();
 	noecho();
 	nonl();
@@ -2320,53 +3649,85 @@
 	getmaxyx(stdscr, window_height, window_width);
 	while (current_screen < MAXSCREEN) {
 		if (!offline_mode) {
-			if (current_screen == SCREEN_DOMAIN_LIST && access(DOMAIN_POLICY_FILE, F_OK)) current_screen = SCREEN_SYSTEM_LIST;
-			else if (current_screen == SCREEN_SYSTEM_LIST && access(SYSTEM_POLICY_FILE, F_OK)) current_screen = SCREEN_EXCEPTION_LIST;
-			else if (current_screen == SCREEN_EXCEPTION_LIST && access(EXCEPTION_POLICY_FILE, F_OK)) {
+			if (current_screen == SCREEN_DOMAIN_LIST &&
+			    access(DOMAIN_POLICY_FILE, F_OK))
+				current_screen = SCREEN_SYSTEM_LIST;
+			else if (current_screen == SCREEN_SYSTEM_LIST &&
+				 access(SYSTEM_POLICY_FILE, F_OK))
+				current_screen = SCREEN_EXCEPTION_LIST;
+			else if (current_screen == SCREEN_EXCEPTION_LIST &&
+				 access(EXCEPTION_POLICY_FILE, F_OK)) {
 				current_screen = SCREEN_DOMAIN_LIST;
-				if (access(DOMAIN_POLICY_FILE, F_OK)) current_screen = SCREEN_SYSTEM_LIST;
+				if (access(DOMAIN_POLICY_FILE, F_OK))
+					current_screen = SCREEN_SYSTEM_LIST;
 			}
 		}
-		ResizeWindow();
-		current_screen = GenericListLoop();
+		resize_window();
+		current_screen = generic_list_loop();
 	}
 	clear();
 	move(0, 0);
 	refresh();
 	endwin();
 	if (offline_mode) {
-		int fd, len;
+		int fd;
+		int len;
 		FILE *fp;
 		time_t now = time(NULL);
 		struct tm *tm = localtime(&now);
-		char filename[1024], buffer[1024];
+		char filename[1024];
+		char buffer[1024];
 		memset(filename, 0, sizeof(filename));
-		snprintf(filename, sizeof(filename) - 1, "system_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if ((fd = open(filename, O_WRONLY | O_CREAT, 0600)) != EOF) {
-			if ((fp = open_read(SYSTEM_POLICY_FILE)) != NULL) {
-				while ((len = fread(buffer, 1, sizeof(buffer), fp)) > 0) write(fd, buffer, len);
-				close(fd); fclose(fp);
+		snprintf(filename, sizeof(filename) - 1,
+			 "system_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		fd = open(filename, O_WRONLY | O_CREAT, 0600);
+		if (fd != EOF) {
+			fp = open_read(SYSTEM_POLICY_FILE);
+			if (fp) {
+				while ((len = fread(buffer, 1, sizeof(buffer),
+						    fp)) > 0)
+					write(fd, buffer, len);
+				fclose(fp);
 				unlink(disk_policy_system_policy);
 				symlink(filename, "system_policy.conf");
 			}
+			close(fd);
 		}
-		snprintf(filename, sizeof(filename) - 1, "exception_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if ((fd = open(filename, O_WRONLY | O_CREAT, 0600)) != EOF) {
-			if ((fp = open_read(EXCEPTION_POLICY_FILE)) != NULL) {
-				while ((len = fread(buffer, 1, sizeof(buffer), fp)) > 0) write(fd, buffer, len);
-				close(fd); fclose(fp);
+		snprintf(filename, sizeof(filename) - 1,
+			 "exception_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		fd = open(filename, O_WRONLY | O_CREAT, 0600);
+		if (fd != EOF) {
+			fp = open_read(EXCEPTION_POLICY_FILE);
+			if (fp) {
+				while ((len = fread(buffer, 1, sizeof(buffer),
+						    fp)) > 0)
+					write(fd, buffer, len);
+				fclose(fp);
 				unlink(disk_policy_exception_policy);
 				symlink(filename, "exception_policy.conf");
 			}
+			close(fd);
 		}
-		snprintf(filename, sizeof(filename) - 1, "domain_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf", tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
-		if ((fd = open(filename, O_WRONLY | O_CREAT, 0600)) != EOF) {
-			if ((fp = open_read(DOMAIN_POLICY_FILE)) != NULL) {
-				while ((len = fread(buffer, 1, sizeof(buffer), fp)) > 0) write(fd, buffer, len);
-				close(fd); fclose(fp);
+		snprintf(filename, sizeof(filename) - 1,
+			 "domain_policy.%02d-%02d-%02d.%02d:%02d:%02d.conf",
+			 tm->tm_year % 100, tm->tm_mon + 1, tm->tm_mday,
+			 tm->tm_hour, tm->tm_min, tm->tm_sec);
+		fd = open(filename, O_WRONLY | O_CREAT, 0600);
+		if (fd != EOF) {
+			fp = open_read(DOMAIN_POLICY_FILE);
+			if (fp) {
+				while ((len = fread(buffer, 1, sizeof(buffer),
+						    fp)) > 0)
+					write(fd, buffer, len);
+				fclose(fp);
 				unlink(disk_policy_domain_policy);
 				symlink(filename, "domain_policy.conf");
 			}
+			close(fd);
 		}
 	}
 	return 0;
@@ -2374,77 +3735,71 @@
 
 /* keyword mapping */
 
-static char *strdup2(const char *s) {
-	const int len = strlen(s);
-	char *cp = malloc(len + 2);
-	if (cp) {
-		memmove(cp, s, len);
-		cp[len] = ' ';
-		cp[len + 1] = '\0'; 
+static u8 find_directive(const u8 forward, char *line)
+{
+	u8 i;
+	for (i = 0; i < MAX_DIRECTIVE_INDEX; i++) {
+		if (forward) {
+			const int len = directives[i].original_len;
+			if (strncmp(line, directives[i].original, len) ||
+			    line[len] != ' ')
+				continue;
+			memmove(line, line + len + 1,
+				strlen(line + len + 1) + 1);
+			return i;
+		} else {
+			const int len = directives[i].alias_len;
+			if (strncmp(line, directives[i].alias, len) ||
+			    line[len] != ' ')
+				continue;
+			memmove(line, line + len + 1,
+				strlen(line + len + 1) + 1);
+			return i;
+		}
 	}
-	return cp;
+	return EOF;
 }
 
-static struct directive_alias_list {
-	char *keyword;
-	char *alias;
-} *directive_alias = NULL;
-static int directive_alias_len = 0;
-
-static char *map_perm_keyword(const u8 forward, const char *line) {
-	static char *buffer = NULL;
+static void init_keyword_map(void)
+{
+	FILE *fp = fopen(CCSTOOLS_CONFIG_FILE, "r");
 	int i;
-	for (i = 0; i < directive_alias_len; i++) {
-		char *cp;
-		int old_len, new_len, rest_len;
-		cp = forward ? directive_alias[i].keyword : directive_alias[i].alias;
-		old_len = strlen(cp);
-		if (strncmp(cp, line, old_len)) continue;
-		rest_len = strlen(line + old_len);
-		cp = forward ? directive_alias[i].alias : directive_alias[i].keyword;
-		new_len = strlen(cp);
-		buffer = realloc(buffer, new_len + rest_len + 4);
-		if (!buffer) OutOfMemory();
-		snprintf(buffer, new_len + rest_len + 3, "%s%s", cp, line + old_len);
-		return buffer;
-	}
-	free(buffer);
-	buffer = strdup(line);
-	if (!buffer) OutOfMemory();
-	return buffer;
-}
-
-static void init_keyword_map(void) {
-	FILE *fp;
-	int i;
-	if ((fp = fopen(CCSTOOLS_CONFIG_FILE, "r")) == NULL) return;
+	if (!fp)
+		goto use_default;
 	get();
 	while (freadline(fp)) {
-		char *cp;
-		if (strncmp(shared_buffer, "editpolicy.keyword_alias ", 25)) continue;
-		memmove(shared_buffer, shared_buffer + 25, strlen(shared_buffer + 25) + 1);
-		if ((cp = strchr(shared_buffer, '=')) == NULL) continue;
+		char *cp = shared_buffer + 25;
+		if (strncmp(shared_buffer, "editpolicy.keyword_alias ", 25))
+			continue;
+		memmove(shared_buffer, cp, strlen(cp) + 1);
+		cp = strchr(shared_buffer, '=');
+		if (!cp)
+			continue;
 		*cp++ = '\0';
 		NormalizeLine(shared_buffer);
 		NormalizeLine(cp);
-		if (!*shared_buffer || !*cp) continue;
-		if ((directive_alias = (struct directive_alias_list *) realloc(directive_alias, (directive_alias_len + 1) * sizeof(struct directive_alias_list))) == NULL) OutOfMemory();
-		if ((cp = strdup2(cp)) == NULL) OutOfMemory();
-		directive_alias[directive_alias_len].alias = cp;
-		if ((cp = strdup2(shared_buffer)) == NULL) OutOfMemory();
-		directive_alias[directive_alias_len].keyword = cp;
-		/* Modify keyword list for try_optimize(). */
-		for (i = 0; i < max_optimize_directive_index; i++) {
-			if (strcmp(cp, directive_list[i])) continue;
-			directive_list[i] = directive_alias[directive_alias_len].alias;
+		if (!*shared_buffer || !*cp)
+			continue;
+		for (i = 0; i < MAX_DIRECTIVE_INDEX; i++) {
+			if (strcmp(shared_buffer, directives[i].original))
+				continue;
+			free((void *) directives[i].alias);
+			cp = strdup(cp);
+			if (!cp)
+				OutOfMemory();
+			directives[i].alias = cp;
+			directives[i].alias_len = strlen(cp);
 			break;
 		}
-		directive_alias_len++;
 	}
 	put();
 	fclose(fp);
-	for (i = 0; i < max_optimize_directive_index; i++) {
-		directive_list_len[i] = strlen(directive_list[i]);
+ use_default:
+	for (i = 0; i < MAX_DIRECTIVE_INDEX; i++) {
+		if (!directives[i].alias)
+			directives[i].alias = directives[i].original;
+		directives[i].original_len = strlen(directives[i].original);
+		directives[i].alias_len = strlen(directives[i].alias);
 	}
 }
 
Index: ccstools.src/ccstools.c
===================================================================
--- ccstools.src/ccstools.c	(リビジョン 1537)
+++ ccstools.src/ccstools.c	(作業コピー)
@@ -5,7 +5,7 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.4+   2008/09/04
+ * Version: 1.6.4+   2008/09/06
  *
  */
 #include "ccstools.h"
@@ -452,6 +452,7 @@
 extern int sortpolicy_main(int argc, char *argv[]);
 extern int setprofile_main(int argc, char *argv[]);
 extern int setlevel_main(int argc, char *argv[]);
+extern int diffpolicy_main(int argc, char *argv[]);
 extern int savepolicy_main(int argc, char *argv[]);
 extern int pathmatch_main(int argc, char *argv[]);
 extern int loadpolicy_main(int argc, char *argv[]);
@@ -468,14 +469,19 @@
 	*disk_policy_dir              = "/etc/ccs/",
 	*proc_policy_domain_policy    = "/proc/ccs/domain_policy",
 	*disk_policy_domain_policy    = "/etc/ccs/domain_policy.conf",
+	*base_policy_domain_policy    = "/etc/ccs/domain_policy.base",
 	*proc_policy_exception_policy = "/proc/ccs/exception_policy",
 	*disk_policy_exception_policy = "/etc/ccs/exception_policy.conf",
+	*base_policy_exception_policy = "/etc/ccs/exception_policy.base",
 	*proc_policy_system_policy    = "/proc/ccs/system_policy",
 	*disk_policy_system_policy    = "/etc/ccs/system_policy.conf",
+	*base_policy_system_policy    = "/etc/ccs/system_policy.base",
 	*proc_policy_profile          = "/proc/ccs/profile",
 	*disk_policy_profile          = "/etc/ccs/profile.conf",
+	*base_policy_profile          = "/etc/ccs/profile.base",
 	*proc_policy_manager          = "/proc/ccs/manager",
 	*disk_policy_manager          = "/etc/ccs/manager.conf",
+	*base_policy_manager          = "/etc/ccs/manager.base",
 	*proc_policy_query            = "/proc/ccs/query",
 	*proc_policy_grant_log        = "/proc/ccs/grant_log",
 	*proc_policy_reject_log       = "/proc/ccs/reject_log",
@@ -493,14 +499,19 @@
 		disk_policy_dir              = "/etc/tomoyo/";
 		proc_policy_domain_policy    = "/sys/kernel/security/tomoyo/domain_policy";
 		disk_policy_domain_policy    = "/etc/tomoyo/domain_policy.conf";
+		base_policy_domain_policy    = "/etc/tomoyo/domain_policy.base";
 		proc_policy_exception_policy = "/sys/kernel/security/tomoyo/exception_policy";
 		disk_policy_exception_policy = "/etc/tomoyo/exception_policy.conf";
+		base_policy_exception_policy = "/etc/tomoyo/exception_policy.base";
 		proc_policy_system_policy    = "/sys/kernel/security/tomoyo/system_policy";
 		disk_policy_system_policy    = "/etc/tomoyo/system_policy.conf";
+		base_policy_system_policy    = "/etc/tomoyo/system_policy.base";
 		proc_policy_profile          = "/sys/kernel/security/tomoyo/profile";
 		disk_policy_profile          = "/etc/tomoyo/profile.conf";
+		base_policy_profile          = "/etc/tomoyo/profile.base";
 		proc_policy_manager          = "/sys/kernel/security/tomoyo/manager";
 		disk_policy_manager          = "/etc/tomoyo/manager.conf";
+		base_policy_manager          = "/etc/tomoyo/manager.base";
 		proc_policy_query            = "/sys/kernel/security/tomoyo/query";
 		proc_policy_grant_log        = "/sys/kernel/security/tomoyo/grant_log";
 		proc_policy_reject_log       = "/sys/kernel/security/tomoyo/reject_log";
@@ -511,14 +522,19 @@
 		disk_policy_dir              = "/etc/tomoyo/";
 		proc_policy_domain_policy    = "/proc/tomoyo/domain_policy";
 		disk_policy_domain_policy    = "/etc/tomoyo/domain_policy.conf";
+		base_policy_domain_policy    = "/etc/tomoyo/domain_policy.base"; 
 		proc_policy_exception_policy = "/proc/tomoyo/exception_policy";
 		disk_policy_exception_policy = "/etc/tomoyo/exception_policy.conf";
+		base_policy_exception_policy = "/etc/tomoyo/exception_policy.base";
 		proc_policy_system_policy    = "/proc/tomoyo/system_policy";
 		disk_policy_system_policy    = "/etc/tomoyo/system_policy.conf";
+		base_policy_system_policy    = "/etc/tomoyo/system_policy.base"; 
 		proc_policy_profile          = "/proc/tomoyo/profile";
 		disk_policy_profile          = "/etc/tomoyo/profile.conf";
+		base_policy_profile          = "/etc/tomoyo/profile.base";
 		proc_policy_manager          = "/proc/tomoyo/manager";
 		disk_policy_manager          = "/etc/tomoyo/manager.conf";
+		base_policy_manager          = "/etc/tomoyo/manager.base";
 		proc_policy_query            = "/proc/tomoyo/query";
 		proc_policy_grant_log        = "/proc/tomoyo/grant_log";
 		proc_policy_reject_log       = "/proc/tomoyo/reject_log";
@@ -530,6 +546,7 @@
 	if (strcmp(argv0, "sortpolicy") == 0) return sortpolicy_main(argc, argv);
 	if (strcmp(argv0, "setprofile") == 0) return setprofile_main(argc, argv);
 	if (strcmp(argv0, "setlevel") == 0) return setlevel_main(argc, argv);
+	if (strcmp(argv0, "diffpolicy") == 0) return diffpolicy_main(argc, argv);
 	if (strcmp(argv0, "savepolicy") == 0) return savepolicy_main(argc, argv);
 	if (strcmp(argv0, "pathmatch") == 0) return pathmatch_main(argc, argv);
 	if (strcmp(argv0, "loadpolicy") == 0) return loadpolicy_main(argc, argv);
@@ -550,7 +567,7 @@
 	 * because it is dangerous to allow updating policies via unchecked argv[1].
 	 * You should use either "symbolic links with 'alias' directive" or "hard links".
 	 */
-	printf("ccstools version 1.6.4+ build 2008/09/04\n");
+	printf("ccstools version 1.6.4+ build 2008/09/06\n");
 	fprintf(stderr, "Function %s not implemented.\n", argv0);
 	return 1;
 }
