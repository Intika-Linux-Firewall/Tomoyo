Index: ccstools.src/ccstools.h
===================================================================
--- ccstools.src/ccstools.h	(revision 1571)
+++ ccstools.src/ccstools.h	(working copy)
@@ -178,10 +178,8 @@
 
 struct domain_info {
 	const struct path_info *domainname;
-	/* This may be NULL */
-	const struct domain_initializer_entry *domain_initializer;
-	/* This may be NULL */
-	const struct domain_keeper_entry *domain_keeper;
+	const struct domain_initializer_entry *d_i; /* This may be NULL */
+	const struct domain_keeper_entry *d_k; /* This may be NULL */
 	const struct path_info **string_ptr;
 	int string_count;
 	int number; /* domain number (-1 if is_dis or is_dd) */
Index: ccstools.src/editpolicy.c
===================================================================
--- ccstools.src/editpolicy.c	(revision 1571)
+++ ccstools.src/editpolicy.c	(working copy)
@@ -5,15 +5,13 @@
  *
  * Copyright (C) 2005-2008  NTT DATA CORPORATION
  *
- * Version: 1.6.4+   2008/09/09
+ * Version: 1.6.4+   2008/09/10
  *
  */
 #include "ccstools.h"
 
 /* add color start */
 #ifdef COLOR_ON
-#define OFF 0
-#define ON  1
 
 enum color_pair {
 	NORMAL, DOMAIN_HEAD, DOMAIN_CURSOR, SYSTEM_HEAD, SYSTEM_CURSOR,
@@ -88,19 +86,19 @@
 		struct color_env_t *colorp = &color_env[i];
 		init_pair(colorp->tag, colorp->fore, colorp->back);
 	}
-	init_pair(DISP_ERR, COLOR_RED, COLOR_BLACK); /* error massage */
+	init_pair(DISP_ERR, COLOR_RED, COLOR_BLACK); /* error message */
 }
 
-static void editpolicy_color_save(const int flg)
+static void editpolicy_color_save(const bool flg)
 {
-	static int save_color = NORMAL;
-	if (flg == ON)
+	static attr_t save_color = NORMAL;
+	if (flg)
 		save_color = getattrs(stdscr);
 	else
 		attrset(save_color);
 }
 
-static inline void editpolicy_color_change(const attr_t attr, const int flg)
+static inline void editpolicy_color_change(const attr_t attr, const bool flg)
 {
 	if (flg)
 		attron(COLOR_PAIR(attr));
@@ -108,7 +106,7 @@
 		attroff(COLOR_PAIR(attr));
 }
 
-static inline void editpolicy_attr_change(const attr_t attr, const int flg)
+static inline void editpolicy_attr_change(const attr_t attr, const bool flg)
 {
 	if (flg)
 		attron(attr);
@@ -118,12 +116,12 @@
 
 static inline void editpolicy_sttr_save(void)
 {
-	editpolicy_color_save(ON);
+	editpolicy_color_save(true);
 }
 
 static inline void editpolicy_sttr_restore(void)
 {
-	editpolicy_color_save(OFF);
+	editpolicy_color_save(false);
 }
 
 static inline int editpolicy_color_head(const int screen)
@@ -166,25 +164,25 @@
 static struct address_group_entry *address_group_list = NULL;
 static int address_group_list_len = 0;
 
-static struct domain_info *domain_list = NULL;
-static struct domain_info *shadow_domain_list = NULL;
-static int domain_list_count = 0;
-static int shadow_domain_list_count = 0;
-static unsigned char *domain_list_selected = NULL;
+static struct domain_info *proc_domain_list = NULL;
+static struct domain_info *base_domain_list = NULL;
+static int proc_domain_list_count = 0;
+static int base_domain_list_count = 0;
+static unsigned char *proc_domain_list_selected = NULL;
 
 static void swap_domain_list(void)
 {
-	struct domain_info *tmp_list = domain_list;
-	int tmp_list_count = domain_list_count;
-	domain_list = shadow_domain_list;
-	domain_list_count = shadow_domain_list_count;
-	shadow_domain_list = tmp_list;
-	shadow_domain_list_count = tmp_list_count;
+	struct domain_info *tmp_list = proc_domain_list;
+	int tmp_list_count = proc_domain_list_count;
+	proc_domain_list = base_domain_list;
+	proc_domain_list_count = base_domain_list_count;
+	base_domain_list = tmp_list;
+	base_domain_list_count = tmp_list_count;
 }
 
 static const char *domain_name(const int index)
 {
-	return domain_list[index].domainname->name;
+	return proc_domain_list[index].domainname->name;
 }
 
 static const char *get_last_name(const int index)
@@ -202,7 +200,7 @@
 	int acl_count;
 	const struct path_info *cp;
 	int i;
-	if (index < 0 || index >= domain_list_count) {
+	if (index < 0 || index >= proc_domain_list_count) {
 		fprintf(stderr, "%s: ERROR: domain is out of range.\n",
 			__func__);
 		return -EINVAL;
@@ -213,8 +211,8 @@
 	if (!cp)
 		out_of_memory();
 
-	acl_ptr = domain_list[index].string_ptr;
-	acl_count = domain_list[index].string_count;
+	acl_ptr = proc_domain_list[index].string_ptr;
+	acl_count = proc_domain_list[index].string_count;
 
 	/* Check for the same entry. */
 	for (i = 0; i < acl_count; i++) {
@@ -228,8 +226,8 @@
 	if (!acl_ptr)
 		out_of_memory();
 	acl_ptr[acl_count++] = cp;
-	domain_list[index].string_ptr = acl_ptr;
-	domain_list[index].string_count = acl_count;
+	proc_domain_list[index].string_ptr = acl_ptr;
+	proc_domain_list[index].string_count = acl_count;
 	return 0;
 }
 
@@ -239,7 +237,7 @@
 	int acl_count;
 	const struct path_info *cp;
 	int i;
-	if (index < 0 || index >= domain_list_count) {
+	if (index < 0 || index >= proc_domain_list_count) {
 		fprintf(stderr, "%s: ERROR: domain is out of range.\n",
 			__func__);
 		return -EINVAL;
@@ -250,14 +248,14 @@
 	if (!cp)
 		out_of_memory();
 
-	acl_ptr = domain_list[index].string_ptr;
-	acl_count = domain_list[index].string_count;
+	acl_ptr = proc_domain_list[index].string_ptr;
+	acl_count = proc_domain_list[index].string_count;
 
 	for (i = 0; i < acl_count; i++) {
 		/* Faster comparison, for they are savename'd. */
 		if (cp != acl_ptr[i])
 			continue;
-		domain_list[index].string_count--;
+		proc_domain_list[index].string_count--;
 		for (; i < acl_count - 1; i++)
 			acl_ptr[i] = acl_ptr[i + 1];
 		return 0;
@@ -268,14 +266,14 @@
 static void clear_domain_policy(void)
 {
 	int index;
-	for (index = 0; index < domain_list_count; index++) {
-		free(domain_list[index].string_ptr);
-		domain_list[index].string_ptr = NULL;
-		domain_list[index].string_count = 0;
+	for (index = 0; index < proc_domain_list_count; index++) {
+		free(proc_domain_list[index].string_ptr);
+		proc_domain_list[index].string_ptr = NULL;
+		proc_domain_list[index].string_count = 0;
 	}
-	free(domain_list);
-	domain_list = NULL;
-	domain_list_count = 0;
+	free(proc_domain_list);
+	proc_domain_list = NULL;
+	proc_domain_list_count = 0;
 }
 
 static int find_domain(const char *domainname0, const bool is_dis,
@@ -285,10 +283,10 @@
 	struct path_info domainname;
 	domainname.name = domainname0;
 	fill_path_info(&domainname);
-	for (i = 0; i < domain_list_count; i++) {
-		if (domain_list[i].is_dis == is_dis &&
-		    domain_list[i].is_dd == is_dd &&
-		    !pathcmp(&domainname, domain_list[i].domainname))
+	for (i = 0; i < proc_domain_list_count; i++) {
+		if (proc_domain_list[i].is_dis == is_dis &&
+		    proc_domain_list[i].is_dd == is_dd &&
+		    !pathcmp(&domainname, proc_domain_list[i].domainname))
 			return i;
 	}
 	return EOF;
@@ -306,30 +304,32 @@
 			__func__, domainname);
 		return EOF;
 	}
-	domain_list = realloc(domain_list, (domain_list_count + 1) *
-			      sizeof(struct domain_info));
-	if (!domain_list)
+	proc_domain_list = realloc(proc_domain_list,
+				   (proc_domain_list_count + 1) *
+				   sizeof(struct domain_info));
+	if (!proc_domain_list)
 		out_of_memory();
-	memset(&domain_list[domain_list_count], 0, sizeof(struct domain_info));
+	memset(&proc_domain_list[proc_domain_list_count], 0,
+	       sizeof(struct domain_info));
 	saved_domainname = savename(domainname);
 	if (!saved_domainname)
 		out_of_memory();
-	domain_list[domain_list_count].domainname = saved_domainname;
-	domain_list[domain_list_count].is_dis = is_dis;
-	domain_list[domain_list_count].is_dd = is_dd;
-	index = domain_list_count++;
+	proc_domain_list[proc_domain_list_count].domainname = saved_domainname;
+	proc_domain_list[proc_domain_list_count].is_dis = is_dis;
+	proc_domain_list[proc_domain_list_count].is_dd = is_dd;
+	index = proc_domain_list_count++;
 found:
 	return index;
 }
 
 static void delete_domain(const int index)
 {
-	if (index > 0 && index < domain_list_count) {
+	if (index >= 0 && index < proc_domain_list_count) {
 		int i;
-		free(domain_list[index].string_ptr);
-		for (i = index; i < domain_list_count - 1; i++)
-			domain_list[i] = domain_list[i + 1];
-		domain_list_count--;
+		free(proc_domain_list[index].string_ptr);
+		for (i = index; i < proc_domain_list_count - 1; i++)
+			proc_domain_list[i] = proc_domain_list[i + 1];
+		proc_domain_list_count--;
 	}
 }
 
@@ -349,10 +349,11 @@
 static void sort_domain_policy(void)
 {
 	int i;
-	qsort(domain_list, domain_list_count, sizeof(struct domain_info),
-	      domainname_compare);
-	for (i = 0; i < domain_list_count; i++)
-		qsort(domain_list[i].string_ptr, domain_list[i].string_count,
+	qsort(proc_domain_list, proc_domain_list_count,
+	      sizeof(struct domain_info), domainname_compare);
+	for (i = 0; i < proc_domain_list_count; i++)
+		qsort(proc_domain_list[i].string_ptr,
+		      proc_domain_list[i].string_count,
 		      sizeof(struct path_info *), path_info_compare);
 }
 
@@ -360,11 +361,12 @@
 {
 	int i;
 	int j;
-	for (i = 0; i < domain_list_count; i++) {
-		const struct path_info **string_ptr = domain_list[i].string_ptr;
-		const int string_count = domain_list[i].string_count;
-		write(fd, domain_list[i].domainname->name,
-		      domain_list[i].domainname->total_len);
+	for (i = 0; i < proc_domain_list_count; i++) {
+		const struct path_info **string_ptr
+			= proc_domain_list[i].string_ptr;
+		const int string_count = proc_domain_list[i].string_count;
+		write(fd, proc_domain_list[i].domainname->name,
+		      proc_domain_list[i].domainname->total_len);
 		write(fd, "\n\n", 2);
 		for (j = 0; j < string_count; j++) {
 			write(fd, string_ptr[j]->name,
@@ -378,33 +380,34 @@
 
 static bool is_keeper_domain(const int index)
 {
-	return domain_list[index].is_dk;
+	return proc_domain_list[index].is_dk;
 }
 
 static bool is_initializer_source(const int index)
 {
-	return domain_list[index].is_dis;
+	return proc_domain_list[index].is_dis;
 }
 
 static bool is_initializer_target(const int index)
 {
-	return domain_list[index].is_dit;
+	return proc_domain_list[index].is_dit;
 }
 
 static bool is_domain_unreachable(const int index)
 {
-	return domain_list[index].is_du;
+	return proc_domain_list[index].is_du;
 }
 
 static bool is_deleted_domain(const int index)
 {
-	return domain_list[index].is_dd;
+	return proc_domain_list[index].is_dd;
 }
 
+static void handle_domain_policy(FILE *fp, bool is_write);
+
 static void read_domain_policy(const char *filename, FILE *filename_fp)
 {
 	FILE *fp = stdin;
-	int index;
 	if (filename) {
 		fp = fopen(filename, "r");
 		if (!fp) {
@@ -413,14 +416,8 @@
 		}
 	} else if (filename_fp)
 		fp = filename_fp;
-	index = EOF;
 	get();
-	while (freadline(fp)) {
-		if (is_domain_def(shared_buffer))
-			index = find_or_assign_new_domain(shared_buffer, 0, 0);
-		else if (index >= 0 && shared_buffer[0])
-			add_string_entry(shared_buffer, index);
-	}
+	handle_domain_policy(fp, true);
 	put();
 	if (fp != stdin)
 		fclose(fp);
@@ -440,19 +437,29 @@
 
 /***** diffpolicy start *****/
 
-static int find_domain_by_ptr(const struct path_info *domainname)
+static int find_proc_domain_by_ptr(const struct path_info *domainname)
 {
 	int i;
-	for (i = 0; i < domain_list_count; i++) {
-		if (domain_list[i].domainname == domainname)
+	for (i = 0; i < proc_domain_list_count; i++) {
+		if (proc_domain_list[i].domainname == domainname)
 			return i;
 	}
 	return EOF;
 }
 
-static int save_domain_policy_with_diff(const char *proc, FILE *proc_fp,
-					const char *base, const char *diff)
+static int find_base_domain_by_ptr(const struct path_info *domainname)
 {
+	int i;
+	for (i = 0; i < base_domain_list_count; i++) {
+		if (base_domain_list[i].domainname == domainname)
+			return i;
+	}
+	return EOF;
+}
+
+static bool save_domain_policy_with_diff(const char *proc, FILE *proc_fp,
+					 const char *base, const char *diff)
+{
 	const struct path_info **proc_string_ptr;
 	const struct path_info **base_string_ptr;
 	int proc_string_count;
@@ -467,57 +474,53 @@
 		diff_fp = fopen(diff, "w");
 		if (!diff_fp) {
 			fprintf(stderr, "Can't open %s\n", diff);
-			return 0;
+			return false;
 		}
 	}
 	read_domain_policy(proc, proc_fp);
-	swap_domain_list();
-	if (!access(base, R_OK))
+	if (!access(base, R_OK)) {
+		swap_domain_list();
 		read_domain_policy(base, NULL);
-	swap_domain_list();
+		swap_domain_list();
+	}
 
-	swap_domain_list();
-	for (base_index = 0; base_index < domain_list_count; base_index++) {
-		domainname = domain_list[base_index].domainname;
-		swap_domain_list();
-		proc_index = find_domain_by_ptr(domainname);
-		swap_domain_list();
+	for (base_index = 0; base_index < base_domain_list_count;
+	     base_index++) {
+		domainname = base_domain_list[base_index].domainname;
+		proc_index = find_proc_domain_by_ptr(domainname);
 		if (proc_index >= 0)
 			continue;
 		/* This domain was deleted by diff policy. */
 		fprintf(diff_fp, "delete %s\n\n", domainname->name);
 	}
-	swap_domain_list();
 
-	for (proc_index = 0; proc_index < domain_list_count; proc_index++) {
-		domainname = domain_list[proc_index].domainname;
-		swap_domain_list();
-		base_index = find_domain_by_ptr(domainname);
-		swap_domain_list();
+	for (proc_index = 0; proc_index < proc_domain_list_count;
+	     proc_index++) {
+		domainname = proc_domain_list[proc_index].domainname;
+		base_index = find_base_domain_by_ptr(domainname);
 		if (base_index >= 0)
 			continue;
 		/* This domain was added by diff policy. */
 		fprintf(diff_fp, "%s\n\n", domainname->name);
-		proc_string_ptr = domain_list[proc_index].string_ptr;
-		proc_string_count = domain_list[proc_index].string_count;
+		proc_string_ptr = proc_domain_list[proc_index].string_ptr;
+		proc_string_count = proc_domain_list[proc_index].string_count;
 		for (i = 0; i < proc_string_count; i++)
 			fprintf(diff_fp, "%s\n", proc_string_ptr[i]->name);
 		fprintf(diff_fp, "\n");
 	}
 
-	for (proc_index = 0; proc_index < domain_list_count; proc_index++) {
+	for (proc_index = 0; proc_index < proc_domain_list_count;
+	     proc_index++) {
 		bool first = true;
-		domainname = domain_list[proc_index].domainname;
-		swap_domain_list();
-		base_index = find_domain_by_ptr(domainname);
-		swap_domain_list();
+		domainname = proc_domain_list[proc_index].domainname;
+		base_index = find_base_domain_by_ptr(domainname);
 		if (base_index == EOF)
 			continue;
 		/* This domain exists in both base policy and proc policy. */
-		proc_string_ptr = domain_list[proc_index].string_ptr;
-		proc_string_count = domain_list[proc_index].string_count;
-		base_string_ptr = shadow_domain_list[base_index].string_ptr;
-		base_string_count = shadow_domain_list[base_index].string_count;
+		proc_string_ptr = proc_domain_list[proc_index].string_ptr;
+		proc_string_count = proc_domain_list[proc_index].string_count;
+		base_string_ptr = base_domain_list[base_index].string_ptr;
+		base_string_count = base_domain_list[base_index].string_count;
 		for (i = 0; i < proc_string_count; i++) {
 			for (j = 0; j < base_string_count; j++) {
 				if (proc_string_ptr[i] != base_string_ptr[j])
@@ -550,7 +553,7 @@
 
 	if (diff_fp != stdout)
 		fclose(diff_fp);
-	return 1;
+	return true;
 }
 
 int diffpolicy_main(int argc, char *argv[])
@@ -590,15 +593,15 @@
 	return true;
 }
 
-static int move_proc_to_file(const char *src, FILE *src_fp, const char *base,
-			     const char *dest)
+static bool move_proc_to_file(const char *src, FILE *src_fp, const char *base,
+			      const char *dest)
 {
 	FILE *proc_fp;
 	FILE *base_fp;
 	FILE *file_fp = stdout;
-	char **original_list = NULL;
+	char **proc_list = NULL;
 	char **base_list = NULL;
-	int original_list_len = 0;
+	int proc_list_len = 0;
 	int base_list_len = 0;
 	int i;
 	if (src_fp)
@@ -607,14 +610,14 @@
 		proc_fp = fopen(src, "r");
 	if (!proc_fp) {
 		fprintf(stderr, "Can't open %s\n", src);
-		return 0;
+		return false;
 	}
 	if (dest) {
 		file_fp = fopen(dest, "w");
 		if (!file_fp) {
 			fprintf(stderr, "Can't open %s\n", dest);
 			fclose(proc_fp);
-			return 0;
+			return false;
 		}
 	}
 	get();
@@ -639,26 +642,26 @@
 		char *cp;
 		if (!shared_buffer[0])
 			continue;
-		original_list = realloc(original_list, sizeof(char *) *
-					(original_list_len + 1));
-		if (!original_list)
+		proc_list = realloc(proc_list, sizeof(char *) *
+					(proc_list_len + 1));
+		if (!proc_list)
 			out_of_memory();
 		cp = strdup(shared_buffer);
 		if (!cp)
 			out_of_memory();
-		original_list[original_list_len++] = cp;
+		proc_list[proc_list_len++] = cp;
 	}
 	put();
 	fclose(proc_fp);
 
-	for (i = 0; i < original_list_len; i++) {
+	for (i = 0; i < proc_list_len; i++) {
 		int j;
 		for (j = 0; j < base_list_len; j++) {
-			if (!original_list[i] || !base_list[j] ||
-			    strcmp(original_list[i], base_list[j]))
+			if (!proc_list[i] || !base_list[j] ||
+			    strcmp(proc_list[i], base_list[j]))
 				continue;
-			free(original_list[i]);
-			original_list[i] = NULL;
+			free(proc_list[i]);
+			proc_list[i] = NULL;
 			free(base_list[j]);
 			base_list[j] = NULL;
 			break;
@@ -668,20 +671,20 @@
 		if (base_list[i])
 			fprintf(file_fp, "delete %s\n", base_list[i]);
 	}
-	for (i = 0; i < original_list_len; i++) {
-		if (original_list[i])
-			fprintf(file_fp, "%s\n", original_list[i]);
+	for (i = 0; i < proc_list_len; i++) {
+		if (proc_list[i])
+			fprintf(file_fp, "%s\n", proc_list[i]);
 	}
 
 	if (file_fp != stdout)
 		fclose(file_fp);
-	while (original_list_len)
-		free(original_list[--original_list_len]);
-	free(original_list);
+	while (proc_list_len)
+		free(proc_list[--proc_list_len]);
+	free(proc_list);
 	while (base_list_len)
 		free(base_list[--base_list_len]);
 	free(base_list);
-	return 1;
+	return true;
 }
 
 static bool is_identical_file(const char *file1, const char *file2)
@@ -716,15 +719,15 @@
 
 int savepolicy_main(int argc, char *argv[])
 {
-	int remount_root = 0;
+	bool remount_root = false;
 	char *filename;
-	int write_to_stdout = 0;
+	bool write_to_stdout = false;
 	int save_profile = 0;
 	int save_manager = 0;
 	int save_system_policy = 0;
 	int save_exception_policy = 0;
 	int save_domain_policy = 0;
-	int force_save = 0;
+	bool force_save = false;
 	time_t now = time(NULL);
 	if (access("/proc/self/", F_OK))
 		mount("/proc", "/proc", "proc", 0, NULL);
@@ -734,7 +737,7 @@
 		return 0;
 	}
 	if (argc == 1) {
-		force_save = 1;
+		force_save = true;
 		save_system_policy = 1;
 		save_exception_policy = 1;
 		save_domain_policy = 1;
@@ -761,9 +764,9 @@
 			if (m)
 				save_manager = 1;
 			if (f)
-				force_save = 1;
+				force_save = true;
 			if (i)
-				write_to_stdout = 1;
+				write_to_stdout = true;
 			if (strcspn(ptr, "sedafpm-"))
 				goto usage;
 			if (write_to_stdout && save_system_policy +
@@ -783,7 +786,7 @@
 			       strerror(errno));
 			return 1;
 		}
-		remount_root = 1;
+		remount_root = true;
 	}
 
 	/* Exclude nonexistent policy. */
@@ -948,79 +951,76 @@
 static void update_domain_policy(const char *base, const char *src,
 				 const char *dest)
 {
-	int new_index;
-	int old_index;
-	struct path_info reserved;
+	int base_index;
+	int proc_index;
 	FILE *proc_fp = fopen(dest, "w");
 	if (!proc_fp) {
 		fprintf(stderr, "Can't open %s\n", dest);
 		return;
 	}
-	reserved.name = "";
-	fill_path_info(&reserved);
+	/* Load base and diff policy to base_domain_list. */
+	swap_domain_list();
 	if (!access(base, R_OK))
 		read_domain_policy(base, NULL);
 	read_domain_policy(src, NULL);
 	swap_domain_list();
+	/* Load proc policy to proc_domain_list. */
 	read_domain_policy(dest, NULL);
-	swap_domain_list();
-	for (new_index = 0; new_index < domain_list_count; new_index++) {
+	for (base_index = 0; base_index < base_domain_list_count;
+	     base_index++) {
 		int i;
 		int j;
-		const char *domainname = domain_name(new_index);
-		const struct path_info **new_string_ptr
-			= domain_list[new_index].string_ptr;
-		const int new_string_count
-			= domain_list[new_index].string_count;
-		const struct path_info **old_string_ptr;
-		int old_string_count;
-		swap_domain_list();
-		old_index = find_domain(domainname, 0, 0);
-		swap_domain_list();
-		fprintf(proc_fp, "%s\n", domainname);
-		if (old_index == EOF)
+		const struct path_info *domainname
+			= base_domain_list[base_index].domainname;
+		const struct path_info **base_string_ptr
+			= base_domain_list[base_index].string_ptr;
+		const int base_string_count
+			= base_domain_list[base_index].string_count;
+		const struct path_info **proc_string_ptr;
+		int proc_string_count;
+		proc_index = find_proc_domain_by_ptr(domainname);
+		fprintf(proc_fp, "%s\n", domainname->name);
+		if (proc_index == EOF)
 			goto not_found;
 
-		/* Old policy for this domain found. */
-		old_string_ptr = shadow_domain_list[old_index].string_ptr;
-		old_string_count = shadow_domain_list[old_index].string_count;
-		/* Don't delete this domain later. */
-		shadow_domain_list[old_index].domainname = &reserved;
-		for (j = 0; j < old_string_count; j++) {
-			for (i = 0; i < new_string_count; i++) {
-				if (new_string_ptr[i] == old_string_ptr[j])
+		/* Proc policy for this domain found. */
+		proc_string_ptr = proc_domain_list[proc_index].string_ptr;
+		proc_string_count = proc_domain_list[proc_index].string_count;
+		for (j = 0; j < proc_string_count; j++) {
+			for (i = 0; i < base_string_count; i++) {
+				if (base_string_ptr[i] == proc_string_ptr[j])
 					break;
 			}
-			/* Delete this entry from old policy if not found
-			   in new policy. */
-			if (i == new_string_count)
+			/* Delete this entry from proc policy if not found
+			   in base policy. */
+			if (i == base_string_count)
 				fprintf(proc_fp, "delete %s\n",
-					old_string_ptr[j]->name);
+					proc_string_ptr[j]->name);
 		}
+		delete_domain(proc_index);
 not_found:
-		/* Append entries defined in new policy. */
-		for (i = 0; i < new_string_count; i++)
-			fprintf(proc_fp, "%s\n", new_string_ptr[i]->name);
+		/* Append entries defined in base policy. */
+		for (i = 0; i < base_string_count; i++)
+			fprintf(proc_fp, "%s\n", base_string_ptr[i]->name);
 	}
-	/* Delete all domains that are not defined in new policy. */
-	for (old_index = 0; old_index < shadow_domain_list_count; old_index++) {
-		if (shadow_domain_list[old_index].domainname == &reserved)
-			continue;
+	/* Delete all domains that are not defined in base policy. */
+	for (proc_index = 0; proc_index < proc_domain_list_count;
+	     proc_index++) {
 		fprintf(proc_fp, "delete %s\n",
-			shadow_domain_list[old_index].domainname->name);
+			proc_domain_list[proc_index].domainname->name);
 	}
 	fclose(proc_fp);
 }
 
 int loadpolicy_main(int argc, char *argv[])
 {
-	int read_from_stdin = 0;
+	bool read_from_stdin = false;
 	int load_profile = 0;
 	int load_manager = 0;
 	int load_system_policy = 0;
 	int load_exception_policy = 0;
 	int load_domain_policy = 0;
-	int refresh_policy = 0;
+	bool refresh_policy = false;
 	if (access(proc_policy_dir, F_OK)) {
 		fprintf(stderr,
 			"You can't run this program for this kernel.\n");
@@ -1051,9 +1051,9 @@
 			if (m)
 				load_manager = 1;
 			if (f)
-				refresh_policy = 1;
+				refresh_policy = true;
 			if (i)
-				read_from_stdin = 1;
+				read_from_stdin = true;
 			if (strcspn(ptr, "sedafpm-"))
 				goto usage;
 			if (read_from_stdin && load_system_policy +
@@ -1467,7 +1467,7 @@
 static void read_generic_policy(void)
 {
 	FILE *fp;
-	int flag = 0;
+	bool flag = false;
 	while (generic_acl_list_count)
 		free((void *)
 		     generic_acl_list[--generic_acl_list_count].operand);
@@ -1803,7 +1803,8 @@
 		snprintf(shared_buffer, shared_buffer_len - 1, "%s %s",
 			 domainname->name, program);
 		normalize_line(shared_buffer);
-		if (find_or_assign_new_domain(shared_buffer, 1, 0) == EOF)
+		if (find_or_assign_new_domain(shared_buffer, true, false)
+		    == EOF)
 			out_of_memory();
 		put();
 	}
@@ -1838,7 +1839,7 @@
 		free(address_group_list[--address_group_list_len].member_name);
 	*/
 	address_group_list_len = 0;
-	find_or_assign_new_domain(ROOT_NAME, 0, 0);
+	find_or_assign_new_domain(ROOT_NAME, false, false);
 
 	/* Load domain_initializer list, domain_keeper list. */
 	fp = open_read(EXCEPTION_POLICY_FILE);
@@ -1847,18 +1848,18 @@
 	get();
 	while (freadline(fp)) {
 		if (str_starts(shared_buffer, KEYWORD_INITIALIZE_DOMAIN))
-			add_domain_initializer_policy(shared_buffer, 0);
+			add_domain_initializer_policy(shared_buffer, false);
 		else if (str_starts(shared_buffer,
 				    KEYWORD_NO_INITIALIZE_DOMAIN))
-			add_domain_initializer_policy(shared_buffer, 1);
+			add_domain_initializer_policy(shared_buffer, true);
 		else if (str_starts(shared_buffer, KEYWORD_KEEP_DOMAIN))
-			add_domain_keeper_policy(shared_buffer, 0);
+			add_domain_keeper_policy(shared_buffer, false);
 		else if (str_starts(shared_buffer, KEYWORD_NO_KEEP_DOMAIN))
-			add_domain_keeper_policy(shared_buffer, 1);
+			add_domain_keeper_policy(shared_buffer, true);
 		else if (str_starts(shared_buffer, KEYWORD_PATH_GROUP))
-			add_path_group_policy(shared_buffer, 0);
+			add_path_group_policy(shared_buffer, false);
 		else if (str_starts(shared_buffer, KEYWORD_ADDRESS_GROUP))
-			add_address_group_policy(shared_buffer, 0);
+			add_address_group_policy(shared_buffer, false);
 	}
 	put();
 	fclose(fp);
@@ -1875,7 +1876,8 @@
 		char *cp2;
 		unsigned int profile;
 		if (is_domain_def(shared_buffer)) {
-			index = find_or_assign_new_domain(shared_buffer, 0, 0);
+			index = find_or_assign_new_domain(shared_buffer, false,
+							  false);
 			continue;
 		} else if (index == EOF) {
 			continue;
@@ -1898,14 +1900,14 @@
 				add_string_entry(cp, index);
 		} else if (sscanf(shared_buffer,
 				  KEYWORD_USE_PROFILE "%u", &profile) == 1) {
-			domain_list[index].profile = (unsigned char) profile;
+			proc_domain_list[index].profile = (u8) profile;
 		}
 	}
 	put();
 	fclose(fp);
 no_domain:
 
-	max_index = domain_list_count;
+	max_index = proc_domain_list_count;
 
 	/* Find unreachable domains. */
 	for (index = 0; index < max_index; index++) {
@@ -1928,20 +1930,19 @@
 				/* Initializer under <kernel> is reachable. */
 				if (parent.total_len == ROOT_NAME_LEN)
 					break;
-				domain_list[index].domain_initializer = d_i;
-				domain_list[index].domain_keeper = NULL;
+				proc_domain_list[index].d_i = d_i;
+				proc_domain_list[index].d_k = NULL;
 				continue;
 			}
 			d_k = is_domain_keeper(&parent, cp);
 			if (d_k) {
-				domain_list[index].domain_initializer = NULL;
-				domain_list[index].domain_keeper = d_k;
+				proc_domain_list[index].d_i = NULL;
+				proc_domain_list[index].d_k = d_k;
 			}
 		}
 		put();
-		if (domain_list[index].domain_initializer ||
-		    domain_list[index].domain_keeper)
-			domain_list[index].is_du = true;
+		if (proc_domain_list[index].d_i || proc_domain_list[index].d_k)
+			proc_domain_list[index].is_du = true;
 	}
 
 	/* Find domain initializer target domains. */
@@ -1956,7 +1957,7 @@
 				continue;
 			if (strcmp(ptr->program->name, cp + 1))
 				continue;
-			domain_list[index].is_dit = true;
+			proc_domain_list[index].is_dit = true;
 		}
 	}
 
@@ -1970,25 +1971,26 @@
 				continue;
 			if (!ptr->is_last_name) {
 				if (pathcmp(ptr->domainname,
-					    domain_list[index].domainname))
+					    proc_domain_list[index].domainname))
 					continue;
-				domain_list[index].is_dk = true;
+				proc_domain_list[index].is_dk = true;
 				continue;
 			}
-			cp = strrchr(domain_list[index].domainname->name, ' ');
+			cp = strrchr(proc_domain_list[index].domainname->name,
+				     ' ');
 			if (!cp || strcmp(ptr->domainname->name, cp + 1))
 				continue;
-			domain_list[index].is_dk = true;
+			proc_domain_list[index].is_dk = true;
 		}
 	}
 
 	/* Create domain initializer source domains. */
 	for (index = 0; index < max_index; index++) {
 		const struct path_info *domainname
-			= domain_list[index].domainname;
+			= proc_domain_list[index].domainname;
 		const struct path_info **string_ptr
-			= domain_list[index].string_ptr;
-		const int max_count = domain_list[index].string_count;
+			= proc_domain_list[index].string_ptr;
+		const int max_count = proc_domain_list[index].string_count;
 		/* Don't create source domain under <kernel> because
 		   they will become target domains. */
 		if (domainname->total_len == ROOT_NAME_LEN)
@@ -2023,9 +2025,10 @@
 			if (!cp)
 				break;
 			*cp = '\0';
-			if (find_domain(shared_buffer, 0, 0) != EOF)
+			if (find_domain(shared_buffer, false, false) != EOF)
 				continue;
-			if (find_or_assign_new_domain(shared_buffer, 0, 1)
+			if (find_or_assign_new_domain(shared_buffer, false,
+						      true)
 			    == EOF)
 				out_of_memory();
 		}
@@ -2033,29 +2036,30 @@
 	}
 
 	/* Sort by domain name. */
-	qsort(domain_list, domain_list_count, sizeof(struct domain_info),
-	      domainname_attribute_compare);
+	qsort(proc_domain_list, proc_domain_list_count,
+	      sizeof(struct domain_info), domainname_attribute_compare);
 
 	/* Assign domain numbers. */
 	{
 		int number = 0;
 		int index;
 		unnumbered_domain_count = 0;
-		for (index = 0; index < domain_list_count; index++) {
+		for (index = 0; index < proc_domain_list_count; index++) {
 			if (is_deleted_domain(index) ||
 			    is_initializer_source(index)) {
-				domain_list[index].number = -1;
+				proc_domain_list[index].number = -1;
 				unnumbered_domain_count++;
 			} else {
-				domain_list[index].number = number++;
+				proc_domain_list[index].number = number++;
 			}
 		}
 	}
 
-	domain_list_selected = realloc(domain_list_selected, domain_list_count);
-	if (domain_list_count && !domain_list_selected)
+	proc_domain_list_selected = realloc(proc_domain_list_selected,
+					    proc_domain_list_count);
+	if (proc_domain_list_count && !proc_domain_list_selected)
 		out_of_memory();
-	memset(domain_list_selected, 0, domain_list_count);
+	memset(proc_domain_list_selected, 0, proc_domain_list_count);
 }
 
 static void show_current(void);
@@ -2089,13 +2093,13 @@
 	const struct domain_initializer_entry *domain_initializer;
 	const struct domain_keeper_entry *domain_keeper;
 	const char *sp;
-	const int number = domain_list[index].number;
+	const int number = proc_domain_list[index].number;
 	int redirect_index;
 	if (number >= 0)
 		mvprintw(header_lines + i, 0,
 			 "%c%4d:%3u %c%c%c ",
-			 domain_list_selected[index] ? '&' : ' ',
-			 number, domain_list[index].profile,
+			 proc_domain_list_selected[index] ? '&' : ' ',
+			 number, proc_domain_list[index].profile,
 			 is_keeper_domain(index) ? '#' : ' ',
 			 is_initializer_target(index) ? '*' : ' ',
 			 is_domain_unreachable(index) ? '!' : ' ');
@@ -2121,7 +2125,7 @@
 		printw("%s", eat(" )"));
 		tmp_col += 2;
 	}
-	domain_initializer = domain_list[index].domain_initializer;
+	domain_initializer = proc_domain_list[index].d_i;
 	if (!domain_initializer)
 		goto not_domain_initializer;
 	get();
@@ -2140,7 +2144,7 @@
 	put();
 	goto done;
 not_domain_initializer:
-	domain_keeper = domain_list[index].domain_keeper;
+	domain_keeper = proc_domain_list[index].d_k;
 	if (!domain_keeper)
 		goto not_domain_keeper;
 	get();
@@ -2165,10 +2169,10 @@
 	memset(shared_buffer, 0, shared_buffer_len);
 	snprintf(shared_buffer, shared_buffer_len - 1, ROOT_NAME "%s",
 		 strrchr(domain_name(index), ' '));
-	redirect_index = find_domain(shared_buffer, 0, 0);
+	redirect_index = find_domain(shared_buffer, false, false);
 	if (redirect_index >= 0)
 		snprintf(shared_buffer, shared_buffer_len - 1, " ( -> %d )",
-			 domain_list[redirect_index].number);
+			 proc_domain_list[redirect_index].number);
 	else
 		snprintf(shared_buffer, shared_buffer_len - 1,
 			 " ( -> Not Found )");
@@ -2200,7 +2204,7 @@
 	int i;
 	int tmp_col;
 	if (current_screen == SCREEN_DOMAIN_LIST)
-		list_item_count[SCREEN_DOMAIN_LIST] = domain_list_count;
+		list_item_count[SCREEN_DOMAIN_LIST] = proc_domain_list_count;
 	else
 		list_item_count[current_screen] = generic_acl_list_count;
 	clear();
@@ -2212,7 +2216,7 @@
 		return;
 	}
 	/* add color */
-	editpolicy_color_change(editpolicy_color_head(current_screen), ON);
+	editpolicy_color_change(editpolicy_color_head(current_screen), true);
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		i = list_item_count[SCREEN_DOMAIN_LIST]
 			- unnumbered_domain_count;
@@ -2226,7 +2230,7 @@
 			 i, i > 1 ? "ies" : "y");
 	}
 	/* add color */
-	editpolicy_color_change(editpolicy_color_head(current_screen), OFF);
+	editpolicy_color_change(editpolicy_color_head(current_screen), false);
 	eat_col = max_eat_col[current_screen];
 	max_col = 0;
 	if (current_screen == SCREEN_ACL_LIST) {
@@ -2234,9 +2238,9 @@
 		memset(shared_buffer, 0, shared_buffer_len);
 		snprintf(shared_buffer, shared_buffer_len - 1, "%s",
 			 eat(current_domain));
-		editpolicy_attr_change(A_REVERSE, ON); /* add color */
+		editpolicy_attr_change(A_REVERSE, true);  /* add color */
 		mvprintw(2, 0, "%s", shared_buffer);
-		editpolicy_attr_change(A_REVERSE, OFF); /* add color */
+		editpolicy_attr_change(A_REVERSE, false); /* add color */
 		put();
 	}
 	if (current_screen != SCREEN_DOMAIN_LIST) {
@@ -2400,9 +2404,9 @@
 			shared_buffer[window_width] = '\0';
 		move(2, 0);
 		clrtoeol();
-		editpolicy_attr_change(A_REVERSE, ON); /* add color */
+		editpolicy_attr_change(A_REVERSE, true);  /* add color */
 		printw("%s", shared_buffer);
-		editpolicy_attr_change(A_REVERSE, OFF); /* add color */
+		editpolicy_attr_change(A_REVERSE, false); /* add color */
 		put();
 	}
 	move(header_lines + current_y[current_screen], 0);
@@ -2473,7 +2477,7 @@
 			if (is_deleted_domain(current) ||
 			    is_initializer_source(current))
 				return 0;
-			domain_list_selected[current] ^= 1;
+			proc_domain_list_selected[current] ^= 1;
 		} else {
 			generic_acl_list[current].selected ^= 1;
 		}
@@ -2835,9 +2839,9 @@
 {
 	int c;
 	move(1, 0);
-	editpolicy_color_change(DISP_ERR, ON);	/* add color */
+	editpolicy_color_change(DISP_ERR, true);	/* add color */
 	if (current_screen == SCREEN_DOMAIN_LIST) {
-		c = count(domain_list_selected, domain_list_count);
+		c = count(proc_domain_list_selected, proc_domain_list_count);
 		if (!c)
 			c = select_item(current);
 		if (!c)
@@ -2855,7 +2859,7 @@
 			printw("Delete selected entr%s? ('Y'es/'N'o)",
 			       c > 1 ? "ies" : "y");
 	}
-	editpolicy_color_change(DISP_ERR, OFF);	/* add color */
+	editpolicy_color_change(DISP_ERR, false);	/* add color */
 	clrtoeol();
 	refresh();
 	if (!c)
@@ -2873,8 +2877,8 @@
 		FILE *fp = open_write(DOMAIN_POLICY_FILE);
 		if (!fp)
 			return;
-		for (index = 1; index < domain_list_count; index++) {
-			if (!domain_list_selected[index])
+		for (index = 1; index < proc_domain_list_count; index++) {
+			if (!proc_domain_list_selected[index])
 				continue;
 			fprintf(fp, "delete %s\n", domain_name(index));
 		}
@@ -2910,11 +2914,10 @@
 static void add_entry(struct readline_data *rl)
 {
 	char *line;
-	editpolicy_attr_change(A_BOLD, ON);  /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
 	line = simple_readline(window_height - 1, 0, "Enter new entry> ",
-			       rl->history, rl->count,
-			       8192, 8);
-	editpolicy_attr_change(A_BOLD, OFF); /* add color */
+			       rl->history, rl->count, 8192, 8);
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
 	rl->count = simple_add_history(line, rl->history, rl->count, rl->max);
@@ -2952,10 +2955,10 @@
 		return;
 	if (!input)
 		goto start_search;
-	editpolicy_attr_change(A_BOLD, ON);  /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
 	line = simple_readline(window_height - 1, 0, "Search> ",
 			       rl->history, rl->count, 4000, 8);
-	editpolicy_attr_change(A_BOLD, OFF); /* add color */
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
 	rl->count = simple_add_history(line, rl->history, rl->count, rl->max);
@@ -3001,24 +3004,24 @@
 	char *line;
 	if (current_screen != SCREEN_DOMAIN_LIST)
 		return;
-	if (!count(domain_list_selected, domain_list_count) &&
+	if (!count(proc_domain_list_selected, proc_domain_list_count) &&
 	    !select_item(current)) {
 		mvprintw(1, 0, "Select domain using Space key first.");
 		clrtoeol();
 		refresh();
 		return;
 	}
-	editpolicy_attr_change(A_BOLD, ON);  /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
 	line = simple_readline(window_height - 1, 0, "Enter profile number> ",
 			       NULL, 0, 8, 1);
-	editpolicy_attr_change(A_BOLD, OFF); /* add color */
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
 	fp = open_write(DOMAIN_POLICY_FILE);
 	if (!fp)
 		goto out;
-	for (index = 0; index < domain_list_count; index++) {
-		if (!domain_list_selected[index])
+	for (index = 0; index < proc_domain_list_count; index++) {
+		if (!proc_domain_list_selected[index])
 			continue;
 		fprintf(fp, "select %s\n" KEYWORD_USE_PROFILE "%s\n",
 			domain_name(index), line);
@@ -3106,7 +3109,7 @@
 start:
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		read_domain_and_exception_policy();
-		adjust_cursor_pos(domain_list_count);
+		adjust_cursor_pos(proc_domain_list_count);
 	} else {
 		read_generic_policy();
 		adjust_cursor_pos(generic_acl_list_count);
@@ -3169,16 +3172,17 @@
 				break;
 			if (current_screen == SCREEN_DOMAIN_LIST) {
 				const u8 selected
-					= domain_list_selected[current];
+					= proc_domain_list_selected[current];
 				if (is_deleted_domain(current) ||
 				    is_initializer_source(current))
 					break;
 				for (index = current;
-				     index < domain_list_count; index++) {
+				     index < proc_domain_list_count; index++) {
 					if (is_deleted_domain(index) ||
 					    is_initializer_source(index))
 						continue;
-					domain_list_selected[index] = selected;
+					proc_domain_list_selected[index]
+						= selected;
 				}
 			} else {
 				const u8 selected
@@ -3228,8 +3232,8 @@
 				snprintf(shared_buffer, shared_buffer_len - 1,
 					 ROOT_NAME "%s",
 					 strrchr(domain_name(current), ' '));
-				redirect_index = find_domain(shared_buffer, 0,
-							     0);
+				redirect_index = find_domain(shared_buffer,
+							     false, false);
 				put();
 				if (redirect_index == EOF)
 					break;
@@ -3321,24 +3325,27 @@
 			is_select = true;
 		if (is_domain_def(shared_buffer)) {
 			if (is_delete) {
-				index = find_domain(shared_buffer, 0, 0);
-				if (index > 0)
+				index = find_domain(shared_buffer, false,
+						    false);
+				if (index >= 0)
 					delete_domain(index);
 				index = EOF;
 				continue;
 			}
 			if (is_select) {
-				index = find_domain(shared_buffer, 0, 0);
+				index = find_domain(shared_buffer, false,
+						    false);
 				continue;
 			}
-			index = find_or_assign_new_domain(shared_buffer, 0, 0);
+			index = find_or_assign_new_domain(shared_buffer, false,
+							  false);
 			continue;
 		}
 		if (index == EOF || !shared_buffer[0])
 			continue;
 		if (sscanf(shared_buffer, KEYWORD_USE_PROFILE "%u", &profile)
 		    == 1)
-			domain_list[index].profile = (u8) profile;
+			proc_domain_list[index].profile = (u8) profile;
 		else if (is_delete)
 			del_string_entry(shared_buffer, index);
 		else
@@ -3346,12 +3353,13 @@
 	}
 	return;
 read_policy:
-	for (i = 0; i < domain_list_count; i++) {
+	for (i = 0; i < proc_domain_list_count; i++) {
 		int j;
-		const struct path_info **string_ptr = domain_list[i].string_ptr;
-		const int string_count = domain_list[i].string_count;
+		const struct path_info **string_ptr
+			= proc_domain_list[i].string_ptr;
+		const int string_count = proc_domain_list[i].string_count;
 		fprintf(fp, "%s\n" KEYWORD_USE_PROFILE "%u\n\n",
-			domain_name(i), domain_list[i].profile);
+			domain_name(i), proc_domain_list[i].profile);
 		for (j = 0; j < string_count; j++)
 			fprintf(fp, "%s\n", string_ptr[j]->name);
 		fprintf(fp, "\n");
@@ -3445,7 +3453,7 @@
 static void policy_daemon(void)
 {
 	get();
-	find_or_assign_new_domain(ROOT_NAME, 0, 0);
+	find_or_assign_new_domain(ROOT_NAME, false, false);
 	while (true) {
 		FILE *fp;
 		struct msghdr msg;
