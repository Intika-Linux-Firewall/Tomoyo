Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-exec.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-exec.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-exec.diff	(working copy)
@@ -8,12 +8,12 @@
 Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
- security/tomoyo/exec.c |  222 +++++++++++++++++++++++++++++++++++++++++++++++++
- 1 files changed, 222 insertions(+)
+ security/tomoyo/exec.c |  210 +++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 210 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/exec.c	2007-10-02 11:26:22.000000000 +0900
-@@ -0,0 +1,222 @@
++++ linux-2.6/security/tomoyo/exec.c	2007-10-27 00:01:51.000000000 +0900
+@@ -0,0 +1,210 @@
 +/*
 + * security/tomoyo/exec.c
 + *
@@ -27,8 +27,8 @@
 +
 +static int tmy_audit_argv0_log(const struct path_info *filename,
 +			       const char *argv0,
-+			       const u8 is_granted,
-+			       const u8 is_enforce)
++			       const bool is_granted,
++			       const bool is_enforce)
 +{
 +	char *buf;
 +	int len;
@@ -62,9 +62,10 @@
 +			       const char *argv0,
 +			       struct domain_info *domain,
 +			       const struct condition_list *cond,
-+			       const u8 is_delete)
++			       const bool is_delete)
 +{
 +	struct acl_info *ptr;
++	struct argv0_acl *acl;
 +	const struct path_info *saved_filename;
 +	const struct path_info *saved_argv0;
 +	int error = -ENOMEM;
@@ -79,52 +80,39 @@
 +	if (!saved_filename || !saved_argv0)
 +		return -ENOMEM;
 +
-+	down(&domain_acl_lock);
++	mutex_lock(&domain_acl_lock);
 +
 +	if (is_delete)
 +		goto remove;
 +
-+	ptr = domain->first_acl_ptr;
-+	if (!ptr)
-+		goto first_entry;
-+	while (1) {
-+		struct argv0_acl *acl = (struct argv0_acl *) ptr;
-+
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct argv0_acl *) ptr;
 +		if (ptr->type == TMY_TYPE_ARGV0_ACL && ptr->cond == cond &&
 +		    acl->filename == saved_filename &&
 +		    acl->argv0 == saved_argv0) {
 +			ptr->is_deleted = 0;
 +			/* Found. Nothing to do. */
 +			error = 0;
-+			break;
++			goto ok;
 +		}
++	}
 +
-+		if (ptr->next) {
-+			ptr = ptr->next;
-+			continue;
-+		}
++	/* Not found. Append it to the tail. */
++	acl = tmy_alloc_element(sizeof(*acl));
++	if (!acl)
++		goto ok;
 +
-+first_entry: ;
-+		/* Not found. Append it to the tail. */
-+		acl = tmy_alloc_element(sizeof(*acl));
-+		if (!acl)
-+			break;
-+
-+		acl->head.type = TMY_TYPE_ARGV0_ACL;
-+		acl->head.cond = cond;
-+		acl->filename = saved_filename;
-+		acl->argv0 = saved_argv0;
-+		error = tmy_add_acl(ptr, domain,
-+				    (struct acl_info *) acl);
-+
-+		break;
-+	}
++	acl->head.type = TMY_TYPE_ARGV0_ACL;
++	acl->head.cond = cond;
++	acl->filename = saved_filename;
++	acl->argv0 = saved_argv0;
++	error = tmy_add_acl(domain,
++			    (struct acl_info *) acl);
 +	goto ok;
 +remove: ;
 +	error = -ENOENT;
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
-+		struct argv0_acl *acl = (struct argv0_acl *) ptr;
-+
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct argv0_acl *) ptr;
 +		if (ptr->type != TMY_TYPE_ARGV0_ACL ||
 +		    ptr->cond != cond || ptr->is_deleted ||
 +		    acl->filename != saved_filename ||
@@ -135,7 +123,7 @@
 +		break;
 +	}
 +ok: ;
-+	up(&domain_acl_lock);
++	mutex_unlock(&domain_acl_lock);
 +
 +	return error;
 +}
@@ -154,7 +142,7 @@
 +	argv0.name = argv0_;
 +	tmy_fill_path_info(&argv0);
 +
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 +		struct argv0_acl *acl = (struct argv0_acl *) ptr;
 +
 +		if (ptr->type == TMY_TYPE_ARGV0_ACL &&
@@ -181,7 +169,7 @@
 +int tmy_argv0_perm(const struct path_info *filename, const char *argv0)
 +{
 +	int error = 0;
-+	const u8 is_enforce = tmy_enforce(TMY_MAC_FOR_ARGV0);
++	const bool is_enforce = tmy_enforce(TMY_MAC_FOR_ARGV0);
 +
 +	if (!tmy_flags(TMY_MAC_FOR_ARGV0))
 +		return 0;
@@ -224,7 +212,7 @@
 +int tmy_add_argv0_policy(char *data,
 +			 struct domain_info *domain,
 +			 const struct condition_list *cond,
-+			 const u8 is_delete)
++			 const bool is_delete)
 +{
 +	char *argv0 = strchr(data, ' ');
 +
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-condition.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-condition.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-condition.diff	(working copy)
@@ -6,10 +6,10 @@
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
  security/tomoyo/condition.c |  680 ++++++++++++++++++++++++++++++++++++++++++++
- 1 files changed, 680 insertions(+)
+ 1 file changed, 680 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/condition.c	2007-10-02 11:26:22.000000000 +0900
++++ linux-2.6/security/tomoyo/condition.c	2007-10-27 00:01:51.000000000 +0900
 @@ -0,0 +1,680 @@
 +/*
 + * security/tomoyo/condition.c
@@ -273,9 +273,9 @@
 +			*ptr2++ = right_max;
 +	}
 +	{
-+		static DECLARE_MUTEX(lock);
++		static DEFINE_MUTEX(mutex);
 +		struct condition_list *prev = NULL;
-+		down(&lock);
++		mutex_lock(&mutex);
 +		for (ptr = &head; ptr; prev = ptr, ptr = ptr->next) {
 +			/* Don't compare if size differs. */
 +			if (ptr->length != new_ptr->length)
@@ -302,7 +302,7 @@
 +		/* Append to chain. */
 +		prev->next = new_ptr;
 +ok: ;
-+		up(&lock);
++		mutex_unlock(&mutex);
 +	}
 +	return new_ptr;
 +out2: ;
@@ -386,7 +386,7 @@
 +		return 0;
 +	ptr2 = (unsigned long *) (((u8 *) ptr) + sizeof(*ptr));
 +	for (i = 0; i < ptr->length; i++) {
-+		const u8 match = ((*ptr2) >> 16) & 1;
++		const bool match = ((*ptr2) >> 16) & 1;
 +		const u8 left = (*ptr2) >> 8;
 +		const u8 right = *ptr2;
 +		ptr2++;
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-net.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-net.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-net.diff	(working copy)
@@ -13,12 +13,12 @@
 Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
- security/tomoyo/net.c |  975 ++++++++++++++++++++++++++++++++++++++++++++++++++
- 1 files changed, 975 insertions(+)
+ security/tomoyo/net.c |  928 ++++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 928 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/net.c	2007-10-02 11:26:22.000000000 +0900
-@@ -0,0 +1,975 @@
++++ linux-2.6/security/tomoyo/net.c	2007-10-27 00:01:51.000000000 +0900
+@@ -0,0 +1,928 @@
 +/*
 + * security/tomoyo/net.c
 + *
@@ -31,12 +31,12 @@
 +
 +/*************************  AUDIT FUNCTIONS  *************************/
 +
-+static int tmy_audit_network_log(const u8 is_ipv6,
++static int tmy_audit_network_log(const bool is_ipv6,
 +				 const char *operation,
 +				 const u32 *address,
 +				 const u16 port,
-+				 const u8 is_granted,
-+				 const u8 is_enforce)
++				 const bool is_granted,
++				 const bool is_enforce)
 +{
 +	char *buf;
 +	int len = 256;
@@ -73,15 +73,15 @@
 +/*************************  ADDRESS GROUP HANDLER  *************************/
 +
 +/* List of address group. */
-+static struct addr_group_entry *group_list;
++static LIST_HEAD(address_group_list);
 +
 +static int tmy_add_addr_group_entry(const char *group_name,
-+				    const u8 is_ipv6,
++				    const bool is_ipv6,
 +				    const u16 *min_address,
 +				    const u16 *max_address,
-+				    const u8 is_delete)
++				    const bool is_delete)
 +{
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	struct addr_group_entry *new_group;
 +	struct addr_group_entry *group;
 +	struct addr_group_member *new_member;
@@ -97,20 +97,14 @@
 +	if (!saved_group_name)
 +		return -ENOMEM;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
-+	for (group = group_list; group; group = group->next) {
-+
++	list_for_each_entry(group, &address_group_list, list) {
 +		if (saved_group_name != group->group_name)
 +			continue;
-+
-+		for (member = group->first_member;
-+		     member;
-+		     member = member->next) {
-+
++		list_for_each_entry(member, &group->address_group_member_list, list) {
 +			if (member->is_ipv6 != is_ipv6)
 +				continue;
-+
 +			if (is_ipv6) {
 +				if (memcmp(member->min.ipv6, min_address, 16) ||
 +				    memcmp(member->max.ipv6, max_address, 16))
@@ -120,7 +114,6 @@
 +				    member->max.ipv4 != *(u32 *) max_address)
 +					continue;
 +			}
-+
 +			member->is_deleted = is_delete;
 +			error = 0;
 +			goto out;
@@ -138,14 +131,7 @@
 +		if (!new_group)
 +			goto out;
 +		new_group->group_name = saved_group_name;
-+		mb(); /* Instead of using spinlock. */
-+		group = group_list;
-+		if (group) {
-+			while (group->next)
-+				group = group->next;
-+			group->next = new_group;
-+		} else
-+			group_list = new_group;
++		list_add_tail_mb(&new_group->list, &address_group_list);
 +		group = new_group;
 +	}
 +
@@ -163,19 +149,10 @@
 +		new_member->max.ipv4 = *(u32 *) max_address;
 +	}
 +
-+	mb(); /* Instead of using spinlock. */
-+
-+	member = group->first_member;
-+	if (member) {
-+		while (member->next)
-+			member = member->next;
-+		member->next = new_member;
-+	} else
-+		group->first_member = new_member;
-+
++	list_add_tail_mb(&new_member->list, &group->address_group_member_list);
 +	error = 0;
 +out: ;
-+	up(&lock);
++	mutex_unlock(&mutex);
 +
 +	return error;
 +}
@@ -188,10 +165,10 @@
 + * Returns zero on success.
 + * Returns nonzero on failure.
 + */
-+int tmy_add_addr_group_policy(char *data, const u8 is_delete)
++int tmy_add_addr_group_policy(char *data, const bool is_delete)
 +{
 +	int count;
-+	u8 is_ipv6;
++	bool is_ipv6;
 +	u16 min_address[8];
 +	u16 max_address[8];
 +	unsigned int min[8];
@@ -266,11 +243,9 @@
 +	struct addr_group_entry *group;
 +
 +	for (i = 0; i <= 1; i++) {
-+		for (group = group_list; group; group = group->next) {
-+
++		list_for_each_entry(group, &address_group_list, list) {
 +			if (strcmp(name, group->group_name->name) == 0)
 +				return group;
-+
 +		}
 +
 +		if (i == 0) {
@@ -287,15 +262,14 @@
 +	return NULL;
 +}
 +
-+static int tmy_address_match_group(const u8 is_ipv6,
++static int tmy_address_match_group(const bool is_ipv6,
 +				   const u32 *address,
 +				   const struct addr_group_entry *group)
 +{
 +	struct addr_group_member *member;
 +	const u32 ip = ntohl(*address);
 +
-+	for (member = group->first_member; member; member = member->next) {
-+
++	list_for_each_entry(member, &group->address_group_member_list, list) {
 +		if (member->is_deleted)
 +			continue;
 +
@@ -373,35 +347,21 @@
 + */
 +int tmy_read_addr_group_policy(struct io_buffer *head)
 +{
-+	struct addr_group_entry *group = head->read_var1;
-+	struct addr_group_member *member = head->read_var2;
-+
-+	if (!group)
-+		group = group_list;
-+
-+	while (group) {
-+		head->read_var1 = group;
-+		if (!member)
-+			member = group->first_member;
-+		while (member) {
-+
-+			head->read_var2 = member;
-+			if (member->is_deleted) {
-+				member = member->next;
++	struct list_head *gpos;
++	struct list_head *mpos;
++	list_for_each_cookie(gpos, head->read_var1, &address_group_list) {
++		struct addr_group_entry *group;
++		group = list_entry(gpos, struct addr_group_entry, list);
++		list_for_each_cookie(mpos, head->read_var2, &group->address_group_member_list) {
++			struct addr_group_member *member;
++			member = list_entry(mpos, struct addr_group_member, list);
++			if (member->is_deleted)
 +				continue;
-+			}
-+
 +			if (tmy_read_addr_group(head, group, member))
-+				break;
-+
-+			member = member->next;
++				return -ENOMEM;
 +		}
-+		if (member)
-+			break;
-+		head->read_var2 = NULL;
-+		group = group->next;
 +	}
-+	return group ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +/***********************  NETWORK NETWORK ACL HANDLER  ***********************/
@@ -505,9 +465,10 @@
 +				 const u16 max_port,
 +				 struct domain_info *domain,
 +				 const struct condition_list *cond,
-+				 const u8 is_delete)
++				 const bool is_delete)
 +{
 +	struct acl_info *ptr;
++	struct net_acl *acl;
 +	int error = -ENOMEM;
 +	/* using host byte order to allow u32 comparison than memcmp().*/
 +	const u32 min_ip = ntohl(*min_address);
@@ -516,18 +477,13 @@
 +	if (!domain)
 +		return -EINVAL;
 +
-+	down(&domain_acl_lock);
++	mutex_lock(&domain_acl_lock);
 +
 +	if (is_delete)
 +		goto remove;
 +
-+	ptr = domain->first_acl_ptr;
-+	if (!ptr)
-+		goto first_entry;
-+
-+	while (1) {
-+		struct net_acl *acl = (struct net_acl *) ptr;
-+
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct net_acl *) ptr;
 +		if (ptr->type == TMY_TYPE_IP_NETWORK_ACL &&
 +		    ptr->cond == cond &&
 +		    acl->operation_type == operation &&
@@ -540,45 +496,38 @@
 +					  max_address)) {
 +			ptr->is_deleted = 0;
 +			error = 0;
-+			break;
++			goto ok;
 +		}
++	}
++	/* Not found. Append it to the tail. */
++	acl = tmy_alloc_element(sizeof(*acl));
++	if (!acl)
++		goto ok;
 +
-+		if (ptr->next) {
-+			ptr = ptr->next;
-+			continue;
-+		}
-+first_entry: ;
-+		/* Not found. Append it to the tail. */
-+		acl = tmy_alloc_element(sizeof(*acl));
-+		if (!acl)
-+			break;
++	acl->head.type = TMY_TYPE_IP_NETWORK_ACL;
++	acl->head.cond = cond;
++	acl->operation_type = operation;
++	acl->record_type = record_type;
 +
-+		acl->head.type = TMY_TYPE_IP_NETWORK_ACL;
-+		acl->head.cond = cond;
-+		acl->operation_type = operation;
-+		acl->record_type = record_type;
-+
-+		if (record_type == TMY_TYPE_ADDRESS_GROUP)
-+			acl->u.group = group;
-+		else if (record_type == TMY_TYPE_IPv4) {
-+			acl->u.ipv4.min = min_ip;
-+			acl->u.ipv4.max = max_ip;
-+		} else {
-+			memmove(acl->u.ipv6.min, min_address, 16);
-+			memmove(acl->u.ipv6.max, max_address, 16);
-+		}
-+
-+		acl->min_port = min_port;
-+		acl->max_port = max_port;
-+		error = tmy_add_acl(ptr, domain,
-+				    (struct acl_info *) acl);
-+		break;
++	if (record_type == TMY_TYPE_ADDRESS_GROUP)
++		acl->u.group = group;
++	else if (record_type == TMY_TYPE_IPv4) {
++		acl->u.ipv4.min = min_ip;
++		acl->u.ipv4.max = max_ip;
++	} else {
++		memmove(acl->u.ipv6.min, min_address, 16);
++		memmove(acl->u.ipv6.max, max_address, 16);
 +	}
++
++	acl->min_port = min_port;
++	acl->max_port = max_port;
++	error = tmy_add_acl(domain,
++			    (struct acl_info *) acl);
 +	goto ok;
 +remove: ;
 +	error = -ENOENT;
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
-+		struct net_acl *acl = (struct net_acl *) ptr;
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct net_acl *) ptr;
 +		if (ptr->type != TMY_TYPE_IP_NETWORK_ACL ||
 +		    ptr->cond != cond ||
 +		    ptr->is_deleted ||
@@ -591,18 +540,17 @@
 +					   min_address,
 +					   max_address))
 +			continue;
-+
 +		error = tmy_del_acl(ptr);
 +		break;
 +	}
 +ok: ;
-+	up(&domain_acl_lock);
++	mutex_unlock(&domain_acl_lock);
 +
 +	return error;
 +}
 +
 +/* Check network permission. */
-+static int tmy_network_entry(const u8 is_ipv6,
++static int tmy_network_entry(const bool is_ipv6,
 +			     const int operation,
 +			     const u32 *address,
 +			     const u16 port)
@@ -610,16 +558,16 @@
 +	struct domain_info * const domain = TMY_SECURITY->domain;
 +	struct acl_info *ptr;
 +	const char *keyword = tmy_network2keyword(operation);
-+	const u8 is_enforce = tmy_enforce(TMY_MAC_FOR_NETWORK);
++	const bool is_enforce = tmy_enforce(TMY_MAC_FOR_NETWORK);
 +	/* using host byte order to allow u32 comparison than memcmp().*/
 +	const u32 ip = ntohl(*address);
++	bool found = 0;
 +
 +	if (!tmy_flags(TMY_MAC_FOR_NETWORK))
 +		return 0;
 +
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 +		struct net_acl *acl = (struct net_acl *) ptr;
-+
 +		if (ptr->type != TMY_TYPE_IP_NETWORK_ACL ||
 +		    ptr->is_deleted ||
 +		    acl->operation_type != operation ||
@@ -628,25 +576,30 @@
 +		    tmy_check_condition(ptr->cond, NULL))
 +			continue;
 +
-+		if (acl->record_type == TMY_TYPE_ADDRESS_GROUP &&
-+		    tmy_address_match_group(is_ipv6, address, acl->u.group))
-+			break;
-+
-+		else if (acl->record_type == TMY_TYPE_IPv4 && !is_ipv6 &&
-+			 (acl->u.ipv4.min <= ip && ip <= acl->u.ipv4.max))
-+			break;
-+
-+		else if (acl->record_type == TMY_TYPE_IPv6 && is_ipv6 &&
-+			 memcmp(acl->u.ipv6.min, address, 16) <= 0 &&
-+			 memcmp(address, acl->u.ipv6.max, 16) <= 0)
-+			break;
-+
++		if (acl->record_type == TMY_TYPE_ADDRESS_GROUP) {
++			if (tmy_address_match_group(is_ipv6, address, acl->u.group)) {
++				found = 1;
++				break;
++			}
++		} else if (acl->record_type == TMY_TYPE_IPv4) {
++			if (!is_ipv6 && (acl->u.ipv4.min <= ip && ip <= acl->u.ipv4.max)) {
++				found = 1;
++				break;
++			}
++		} else {
++			if (is_ipv6 &&
++			    memcmp(acl->u.ipv6.min, address, 16) <= 0 &&
++			    memcmp(address, acl->u.ipv6.max, 16) <= 0) {
++				found = 1;
++				break;
++			}
++		}
 +	}
 +
 +	tmy_audit_network_log(is_ipv6, keyword, address,
-+			      port, ptr != 0, is_enforce);
++			      port, found, is_enforce);
 +
-+	if (ptr)
++	if (found)
 +		return 0;
 +
 +	if (is_enforce) {
@@ -692,7 +645,7 @@
 +int tmy_add_network_policy(char *data,
 +			   struct domain_info *domain,
 +			   const struct condition_list *cond,
-+			   const u8 is_delete)
++			   const bool is_delete)
 +{
 +	u8 sock_type;
 +	u8 operation;
@@ -858,7 +811,7 @@
 + * Returns zero if permission granted.
 + * Returns nonzero if permission denied.
 + */
-+int tmy_network_listen_acl(const u8 is_ipv6,
++int tmy_network_listen_acl(const bool is_ipv6,
 +			   const u8 *address,
 +			   const u16 port)
 +{
@@ -878,7 +831,7 @@
 + * Returns zero if permission granted.
 + * Returns nonzero if permission denied.
 + */
-+int tmy_network_connect_acl(const u8 is_ipv6,
++int tmy_network_connect_acl(const bool is_ipv6,
 +			    const int sock_type,
 +			    const u8 *address,
 +			    const u16 port)
@@ -911,7 +864,7 @@
 + * Returns zero if permission granted.
 + * Returns nonzero if permission denied.
 + */
-+int tmy_network_bind_acl(const u8 is_ipv6,
++int tmy_network_bind_acl(const bool is_ipv6,
 +			 const int sock_type,
 +			 const u8 *address,
 +			 const u16 port)
@@ -944,7 +897,7 @@
 + * Returns zero if permission granted.
 + * Returns nonzero if permission denied.
 + */
-+int tmy_network_sendmsg_acl(const u8 is_ipv6,
++int tmy_network_sendmsg_acl(const bool is_ipv6,
 +			    const int sock_type,
 +			    const u8 *address,
 +			    const u16 port)
@@ -969,7 +922,7 @@
 + * Returns zero if permission granted.
 + * Returns nonzero if permission denied.
 + */
-+int tmy_network_accept_acl(const u8 is_ipv6, const u8 *address,
++int tmy_network_accept_acl(const bool is_ipv6, const u8 *address,
 +			   const u16 port)
 +{
 +	return tmy_network_entry(is_ipv6, TMY_NETWORK_ACL_TCP_ACCEPT,
@@ -986,7 +939,7 @@
 + * Returns zero if permission granted.
 + * Returns nonzero if permission denied.
 + */
-+int tmy_network_recvmsg_acl(const u8 is_ipv6, const int sock_type,
++int tmy_network_recvmsg_acl(const bool is_ipv6, const int sock_type,
 +			    const u8 *address, const u16 port)
 +{
 +	return tmy_network_entry(is_ipv6, sock_type == SOCK_DGRAM ?
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-common.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-common.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-common.diff	(working copy)
@@ -20,12 +20,12 @@
 Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
- security/tomoyo/common.c | 2406 +++++++++++++++++++++++++++++++++++++++++++++++
- 1 files changed, 2406 insertions(+)
+ security/tomoyo/common.c | 2383 +++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 2383 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/common.c	2007-10-02 11:26:21.000000000 +0900
-@@ -0,0 +1,2406 @@
++++ linux-2.6/security/tomoyo/common.c	2007-10-27 00:01:51.000000000 +0900
+@@ -0,0 +1,2383 @@
 +/*
 + * security/tomoyo/common.c
 + *
@@ -852,7 +852,7 @@
 + * Returns nonzero if given access control is enforce mode.
 + * Returns zero otherwise.
 + */
-+u8 tmy_enforce(const unsigned int index)
++bool tmy_enforce(const unsigned int index)
 +{
 +	return tmy_flags(index) == 3;
 +}
@@ -869,7 +869,7 @@
 + * This is a safeguard for "learning mode", for appending entries
 + * without limit dulls the system response and consumes much memory.
 + */
-+u8 tmy_accept(const unsigned int index,
++bool tmy_accept(const unsigned int index,
 +	      struct domain_info * const domain)
 +{
 +	unsigned int count = 0;
@@ -878,7 +878,7 @@
 +		return 0;
 +	if (!domain)
 +		return 1;
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 +		if (!ptr->is_deleted)
 +			count++;
 +	}
@@ -898,10 +898,10 @@
 +/* Create a new profile. */
 +static struct profile *tmy_find_new_profile(const unsigned int profile)
 +{
-+	static DECLARE_MUTEX(profile_lock);
++	static DEFINE_MUTEX(profile_lock);
 +	struct profile *ptr = NULL;
 +
-+	down(&profile_lock);
++	mutex_lock(&profile_lock);
 +
 +	ptr = profile_ptr[profile];
 +	if (profile < TMY_MAX_PROFILES && ptr == NULL) {
@@ -915,7 +915,7 @@
 +		}
 +	}
 +
-+	up(&profile_lock);
++	mutex_unlock(&profile_lock);
 +
 +	return ptr;
 +}
@@ -1018,24 +1018,24 @@
 +/*************************  POLICY MANAGER HANDLER  *************************/
 +
 +struct policy_manager_entry {
-+	struct policy_manager_entry *next;
++	struct list_head list;
 +	const struct path_info *manager;
-+	u8 is_domain;
-+	u8 is_deleted;
++	bool is_domain;
++	bool is_deleted;
 +};
 +
-+static struct policy_manager_entry *policy_manager_list;
++static LIST_HEAD(policy_manager_list);
 +
 +/* Update manager list. */
-+static int tmy_add_manager_entry(const char *manager, const u8 is_delete)
++static int tmy_add_manager_entry(const char *manager, const bool is_delete)
 +{
 +	struct policy_manager_entry *new_entry;
 +	struct policy_manager_entry *ptr;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	const struct path_info *saved_manager;
 +	int error = -ENOMEM;
 +
-+	u8 is_domain = 0;
++	bool is_domain = 0;
 +	if (!tmy_is_root())
 +		return -EPERM;
 +	if (tmy_is_domain_def(manager)) {
@@ -1051,9 +1051,9 @@
 +	if (saved_manager == NULL)
 +		return -ENOMEM;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
-+	for (ptr = policy_manager_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &policy_manager_list, list) {
 +		if (ptr->manager == saved_manager) {
 +			ptr->is_deleted = is_delete;
 +			error = 0;
@@ -1071,18 +1071,11 @@
 +		goto out;
 +	new_entry->manager = saved_manager;
 +	new_entry->is_domain = is_domain;
-+	mb(); /* Instead of using spinlock. */
-+	ptr = policy_manager_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		policy_manager_list = new_entry;
++	list_add_tail_mb(&new_entry->list, &policy_manager_list);
 +	error = 0;
 +out: ;
 +
-+	up(&lock);
++	mutex_unlock(&mutex);
 +
 +	if (!error)
 +		tmy_update_counter(TMY_UPDATE_MANAGER);
@@ -1093,7 +1086,7 @@
 +static int tmy_add_manager_policy(struct io_buffer *head)
 +{
 +	char *data = head->write_buf;
-+	u8 is_delete = 0;
++	bool is_delete = 0;
 +
 +	if (!tmy_is_root())
 +		return -EPERM;
@@ -1105,21 +1098,19 @@
 +/* Read manager list.*/
 +static int tmy_read_manager_policy(struct io_buffer *head)
 +{
-+	struct policy_manager_entry *ptr = head->read_var2;
++	struct list_head *pos;
 +	if (head->read_eof)
 +		return 0;
 +	if (!tmy_is_root())
 +		return -EPERM;
-+	if (!ptr)
-+		ptr = policy_manager_list;
-+	while (ptr) {
-+		head->read_var2 = ptr;
++	list_for_each_cookie(pos, head->read_var2, &policy_manager_list) {
++		struct policy_manager_entry *ptr;
++		ptr = list_entry(pos, struct policy_manager_entry, list);
 +		if (!ptr->is_deleted &&
 +		    tmy_io_printf(head, "%s\n", ptr->manager->name))
 +			break;
-+		ptr = ptr->next;
 +	}
-+	if (!ptr)
++	if (!head->read_var2)
 +		head->read_eof = 1;
 +	return 0;
 +}
@@ -1143,12 +1134,13 @@
 +	const char *exe;
 +	const struct path_info *domainname =
 +		TMY_SECURITY->domain->domainname;
++	bool found = 0;
 +
 +	/* Everyone can modify policy before /sbin/init starts. */
 +	if (!sbin_init_started)
 +		return 1;
 +
-+	for (ptr = policy_manager_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &policy_manager_list, list) {
 +		if (!ptr->is_deleted &&
 +		    ptr->is_domain &&
 +		    !tmy_pathcmp(domainname, ptr->manager))
@@ -1159,14 +1151,16 @@
 +	if (!exe)
 +		return 0;
 +
-+	for (ptr = policy_manager_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &policy_manager_list, list) {
 +		if (!ptr->is_deleted &&
 +		    !ptr->is_domain &&
-+		    !strcmp(exe, ptr->manager->name))
++		    !strcmp(exe, ptr->manager->name)) {
++			found = 1;
 +			break;
++		}
 +	}
 +
-+	if (!ptr) { /* Reduce error messages. */
++	if (!found) { /* Reduce error messages. */
 +		static pid_t last_pid;
 +		const pid_t pid = current->pid;
 +		if (last_pid != pid) {
@@ -1178,7 +1172,7 @@
 +	}
 +
 +	tmy_free(exe);
-+	return ptr ? 1 : 0;
++	return found;
 +}
 +
 +/*************************  DOMAIN POLICY HANDLER  *************************/
@@ -1190,9 +1184,9 @@
 +	char *cp;
 +	const struct condition_list *cond = NULL;
 +	struct domain_info *domain = head->write_var1;
-+	u8 is_delete = 0;
-+	u8 is_select = 0;
-+	u8 is_undelete = 0;
++	bool is_delete = 0;
++	bool is_select = 0;
++	bool is_undelete = 0;
 +	unsigned int profile;
 +
 +	if (!tmy_is_root())
@@ -1360,8 +1354,8 @@
 +
 +	if (tmy_acltype2paths(acl_type) == 2) {
 +		struct double_acl *ptr2 = (struct double_acl *) ptr;
-+		const u8 b1 = ptr2->u1_is_group;
-+		const u8 b2 = ptr2->u2_is_group;
++		const bool b1 = ptr2->u1_is_group;
++		const bool b2 = ptr2->u2_is_group;
 +
 +		if (tmy_io_printf(head,
 +				  "allow_%s %s%s %s%s",
@@ -1375,7 +1369,7 @@
 +			return -ENOMEM;
 +	} else {
 +		struct single_acl *ptr2 = (struct single_acl *) ptr;
-+		const u8 b = ptr2->u_is_group;
++		const bool b = ptr2->u_is_group;
 +
 +		if (tmy_io_printf(head,
 +				  "allow_%s %s%s",
@@ -1391,47 +1385,45 @@
 +/* Read domain policy. */
 +static int tmy_read_domain_policy(struct io_buffer *head)
 +{
-+	struct domain_info *domain = head->read_var1;
++	struct list_head *dpos;
++	struct list_head *apos;
 +
 +	if (head->read_eof)
 +		return 0;
-+	switch (head->read_step) {
-+	case 0: break; /* Resume from printing domainname. */
-+	case 1: goto step1; /* Resume from printing profile number. */
-+	case 2: goto step2; /* Resume from printing ACL entries. */
-+	case 3: goto step3; /* Resume from printing trailing '\n'. */
-+	default: return -EINVAL;
-+	}
 +
-+	if (!tmy_is_root())
-+		return -EPERM;
-+
-+	for (domain = &KERNEL_DOMAIN; domain; domain = domain->next) {
-+		struct acl_info *ptr;
++	if (head->read_step == 0) {
++		if (!tmy_is_root())
++			return -EPERM;
++		head->read_step = 1;
++	}
++	list_for_each_cookie(dpos, head->read_var1, &domain_list) {
++		struct domain_info *domain;
++		domain = list_entry(dpos, struct domain_info, list);
++		if (head->read_step != 1)
++			goto acl_loop;
 +		if (domain->is_deleted)
 +			continue;
-+		head->read_var1 = domain;
-+		head->read_var2 = NULL;
-+		head->read_step = 1;
 +
-+step1: ;
-+		if (tmy_io_printf(head,
++		if (!head->read_var2 && tmy_io_printf(head,
 +				  "%s\n" TMY_USE_PROFILE "%u\n%s\n",
 +				  domain->domainname->name,
 +				  domain->profile,
 +				  domain->quota_warned ?
 +				  "quota_exceeded\n" : ""))
 +			break;
-+		head->read_var2 = domain->first_acl_ptr;
 +		head->read_step = 2;
-+
-+step2: ;
-+		for (ptr = head->read_var2; ptr; ptr = ptr->next) {
-+			const u8 acl_type = ptr->type;
-+			const int pos = head->read_avail;
-+			head->read_var2 = ptr;
++	acl_loop: ;
++		if (head->read_step == 3)
++			goto tail_mark;
++		list_for_each_cookie(apos, head->read_var2, &domain->acl_info_list) {
++			struct acl_info *ptr;
++			int pos;
++			u8 acl_type;
++			ptr = list_entry(apos, struct acl_info, list);
 +			if (ptr->is_deleted)
 +				continue;
++			pos = head->read_avail;
++			acl_type = ptr->type;
 +			if (acl_type == TMY_TYPE_FILE_ACL) {
 +				if (print_file_rwx_acl(head, ptr))
 +					goto print_acl_rollback;
@@ -1450,50 +1442,37 @@
 +			if (tmy_dump_condition(head, ptr->cond)) {
 +print_acl_rollback: ;
 +				head->read_avail = pos;
-+				break;
++				return 0;
 +			}
 +		}
-+		if (ptr)
-+			break;
-+		head->read_var2 = NULL;
 +		head->read_step = 3;
-+
-+step3: ;
++	tail_mark: ;
 +		if (tmy_io_printf(head, "\n"))
-+			break;
++			return 0;
++		head->read_step = 1;
 +	}
-+
-+	if (!domain)
-+		head->read_eof = 1;
++	head->read_eof = 1;
 +	return 0;
 +}
 +
 +/* Read domainname and its profile values. */
 +static int tmy_read_domain_profile(struct io_buffer *head)
 +{
-+	struct domain_info *domain;
-+
++	struct list_head *pos;
 +	if (head->read_eof)
 +		return 0;
-+
-+	if (head->read_step == 0) {
-+		head->read_var1 = &KERNEL_DOMAIN;
-+		head->read_step = 1;
-+	}
 +	if (!tmy_is_root())
 +		return -EPERM;
-+
-+	for (domain = head->read_var1; domain; domain = domain->next) {
++	list_for_each_cookie(pos, head->read_var1, &domain_list) {
++		struct domain_info *domain;
++		domain = list_entry(pos, struct domain_info, list);
 +		if (domain->is_deleted)
 +			continue;
-+		head->read_var1 = domain;
 +		if (tmy_io_printf(head, "%u %s\n",
 +				  domain->profile, domain->domainname->name))
-+			break;
++			return 0;
 +	}
-+	if (!domain)
-+		head->read_eof = 1;
-+
++	head->read_eof = 1;
 +	return 0;
 +}
 +
@@ -1564,7 +1543,7 @@
 +static int tmy_add_system_policy(struct io_buffer *head)
 +{
 +	char *data = head->write_buf;
-+	u8 is_delete = 0;
++	bool is_delete = 0;
 +
 +	if (!tmy_is_root())
 +		return -EPERM;
@@ -1619,7 +1598,7 @@
 +static int tmy_add_exception_policy(struct io_buffer *head)
 +{
 +	char *data = head->write_buf;
-+	u8 is_delete = 0;
++	bool is_delete = 0;
 +
 +	if (!tmy_is_root())
 +		return -EPERM;
@@ -1763,7 +1742,7 @@
 +		call_usermodehelper(argv[0], argv, envp, 1);
 +	}
 +
-+	printk(KERN_INFO "TOMOYO: %s   2007/08/21\n", TOMOYO_VERSION_CODE);
++	printk(KERN_INFO "TOMOYO: %s   2007/10/27\n", TOMOYO_VERSION_CODE);
 +
 +	if (!profile_loaded)
 +		panic("TOMOYO: No profiles loaded.\n");
@@ -1773,7 +1752,7 @@
 +
 +	{ /* Check all profiles currently assigned to domains are defined. */
 +		struct domain_info *domain;
-+		for (domain = &KERNEL_DOMAIN; domain; domain = domain->next) {
++		list_for_each_entry(domain, &domain_list, list) {
 +			const u8 profile = domain->profile;
 +			if (profile_ptr[profile])
 +				continue;
@@ -2149,8 +2128,8 @@
 +
 +	if (!head)
 +		return -ENOMEM;
-+	init_MUTEX(&head->read_sem);
-+	init_MUTEX(&head->write_sem);
++	mutex_init(&head->read_sem);
++	mutex_init(&head->write_sem);
 +
 +	switch (type) {
 +	case TMY_POLICY_DOMAINPOLICY:
@@ -2270,12 +2249,12 @@
 +		return -ENOSYS;
 +	if (!access_ok(VERIFY_WRITE, buffer, buffer_len))
 +		return -EFAULT;
-+	if (down_interruptible(&head->read_sem))
++	if (mutex_lock_interruptible(&head->read_sem))
 +		return -EINTR;
 +	len = head->read(head);
 +	if (len >= 0)
 +		len = tmy_copy_to_user(head, buffer, buffer_len);
-+	up(&head->read_sem);
++	mutex_unlock(&head->read_sem);
 +
 +	return len;
 +}
@@ -2299,7 +2278,7 @@
 +		/* Forbid updating policies for non manager programs. */
 +		return -EPERM;
 +
-+	if (down_interruptible(&head->write_sem))
++	if (mutex_lock_interruptible(&head->write_sem))
 +		return -EINTR;
 +	while (avail_len > 0) {
 +		char c;
@@ -2320,7 +2299,7 @@
 +		tmy_normalize_line(cp0);
 +		head->write(head);
 +	}
-+	up(&head->write_sem);
++	mutex_unlock(&head->write_sem);
 +
 +	return error;
 +}
@@ -2402,8 +2381,6 @@
 +	struct dentry *tmy_dir;
 +
 +	tmy_dir = securityfs_create_dir("tomoyo", NULL);
-+	tmy_realpath_init();
-+	tmy_find_domain(""); /* Set domainname of KERNEL domain. */
 +	tmy_create_entry("query",            0600, tmy_dir,
 +			 TMY_POLICY_QUERY);
 +	tmy_create_entry("domain_policy",    0600, tmy_dir,
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-realpath.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-realpath.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-realpath.diff	(working copy)
@@ -5,12 +5,12 @@
 Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
- security/tomoyo/realpath.c |  697 +++++++++++++++++++++++++++++++++++++++++++++
- 1 files changed, 697 insertions(+)
+ security/tomoyo/realpath.c |  695 +++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 695 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/realpath.c	2007-10-02 11:26:21.000000000 +0900
-@@ -0,0 +1,697 @@
++++ linux-2.6/security/tomoyo/realpath.c	2007-10-27 00:01:51.000000000 +0900
+@@ -0,0 +1,695 @@
 +/*
 + * security/tomoyo/realpath.c
 + *
@@ -103,7 +103,7 @@
 +{
 +	char *start = buffer;
 +	char *end = buffer + buflen;
-+	u8 is_dir = (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode));
++	bool is_dir = (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode));
 +	const char *sp;
 +	const char *cp;
 +
@@ -397,7 +397,7 @@
 + */
 +void *tmy_alloc_element(const unsigned int size)
 +{
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	static char *buf;
 +	static unsigned int buf_used_len = PAGE_SIZE;
 +	char *ptr = NULL;
@@ -406,10 +406,10 @@
 +	if (word_aligned_size > PAGE_SIZE)
 +		return NULL;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
 +	if (buf_used_len + word_aligned_size > PAGE_SIZE) {
-+		ptr = kmalloc(PAGE_SIZE, GFP_KERNEL);
++		ptr = kzalloc(PAGE_SIZE, GFP_KERNEL);
 +
 +		if (!ptr) {
 +			printk(KERN_INFO "ERROR: "
@@ -417,7 +417,6 @@
 +			if (!sbin_init_started)
 +				panic("MAC Initialization failed.\n");
 +		} else {
-+			memset(ptr, 0, PAGE_SIZE);
 +			buf = ptr;
 +			allocated_memory_for_elements += PAGE_SIZE;
 +			buf_used_len = word_aligned_size;
@@ -441,7 +440,7 @@
 +
 +	}
 +
-+	up(&lock);
++	mutex_unlock(&mutex);
 +	return ptr;
 +}
 +
@@ -488,7 +487,7 @@
 +{
 +	static struct free_memory_block_list fmb_list = { NULL, NULL, 0 };
 +	static struct name_entry name_list[MAX_HASH]; /* The list of names. */
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	struct name_entry *ptr;
 +	struct name_entry *prev = NULL;
 +	unsigned int hash;
@@ -507,7 +506,7 @@
 +
 +	hash = full_name_hash((const unsigned char *) name, len - 1);
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
 +	if (first_call) {
 +		int i;
@@ -541,7 +540,7 @@
 +			continue;
 +		}
 +
-+		cp = kmalloc(PAGE_SIZE, GFP_KERNEL);
++		cp = kzalloc(PAGE_SIZE, GFP_KERNEL);
 +		if (!cp)
 +			goto out2;
 +
@@ -556,7 +555,6 @@
 +			goto out; /* ptr == NULL */
 +		}
 +
-+		memset(cp, 0, PAGE_SIZE);
 +		allocated_memory_for_savename += PAGE_SIZE;
 +		fmb = fmb->next;
 +		fmb->ptr = cp;
@@ -583,7 +581,7 @@
 +	}
 +out: ;
 +
-+	up(&lock);
++	mutex_unlock(&mutex);
 +
 +	return ptr ? &ptr->entry : NULL;
 +}
@@ -602,12 +600,14 @@
 +/**
 + * tmy_realpath_init - initialize memory allocator.
 + */
-+void tmy_realpath_init(void)
++static int __init tmy_realpath_init(void)
 +{
 +	tmy_cachep = kmem_cache_create("tomoyo_cache",
 +				       sizeof(struct cache_entry),
 +				       0, SLAB_PANIC, NULL);
++	return 0;
 +}
++postcore_initcall(tmy_realpath_init);
 +
 +static LIST_HEAD(cache_list);
 +static DEFINE_SPINLOCK(cache_list_lock);
@@ -636,7 +636,7 @@
 + */
 +void *tmy_alloc(const size_t size)
 +{
-+	void *ret = kmalloc(size, GFP_KERNEL);
++	void *ret = kzalloc(size, GFP_KERNEL);
 +	struct cache_entry *new_entry;
 +
 +	if (!ret) {
@@ -655,16 +655,14 @@
 +	} else {
 +		INIT_LIST_HEAD(&new_entry->list);
 +		new_entry->ptr = ret;
-+		new_entry->size = size;
++		new_entry->size = ksize(ret);
 +
 +		/***** CRITICAL SECTION START *****/
 +		spin_lock(&cache_list_lock);
 +		list_add_tail(&new_entry->list, &cache_list);
-+		dynamic_memory_size += size;
++		dynamic_memory_size += new_entry->size;
 +		spin_unlock(&cache_list_lock);
 +		/***** CRITICAL SECTION END *****/
-+
-+		memset(ret, 0, size);
 +	}
 +
 +	return ret;
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-mount.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-mount.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-mount.diff	(working copy)
@@ -9,12 +9,12 @@
 Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
- security/tomoyo/mount.c | 1019 ++++++++++++++++++++++++++++++++++++++++++++++++
- 1 files changed, 1019 insertions(+)
+ security/tomoyo/mount.c |  959 ++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 959 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/mount.c	2007-10-02 11:26:22.000000000 +0900
-@@ -0,0 +1,1019 @@
++++ linux-2.6/security/tomoyo/mount.c	2007-10-27 00:01:51.000000000 +0900
+@@ -0,0 +1,959 @@
 +/*
 + * security/tomoyo/mount.c
 + *
@@ -39,29 +39,29 @@
 +/***** The structure for mount restrictions. *****/
 +
 +struct mount_entry {
-+	struct mount_entry *next; /* NULL if none. */
++	struct list_head list;
 +	const struct path_info *dev_name;
 +	const struct path_info *dir_name;
 +	const struct path_info *fs_type;
 +	unsigned int flags; /* Mount flags. */
-+	u8 is_deleted;
++	bool is_deleted;
 +};
 +
 +struct no_umount_entry {
-+	struct no_umount_entry *next; /* NULL if none. */
++	struct list_head list;
 +	const struct path_info *dir;
-+	u8 is_deleted;
++	bool is_deleted;
 +};
 +
 +/*************************  AUDIT FUNCTIONS  *************************/
 +
-+static int tmy_audit_mount_log(const u8 is_granted,
-+			       const u8 is_enforce,
++static int tmy_audit_mount_log(const bool is_granted,
++			       const bool is_enforce,
 +			       const char *fmt, ...)
 +	__attribute__((format(printf, 3, 4)));
 +
-+static int tmy_audit_mount_log(const u8 is_granted,
-+			       const u8 is_enforce,
++static int tmy_audit_mount_log(const bool is_granted,
++			       const bool is_enforce,
 +			       const char *fmt, ...)
 +{
 +	char *buf1;
@@ -109,26 +109,21 @@
 +
 +/************************  MOUNT RESTRICTION HANDLER  ************************/
 +
-+static void put_filesystem(struct file_system_type *fs)
-+{
-+	module_put(fs->owner);
-+}
++static LIST_HEAD(mount_list);
 +
-+static struct mount_entry *mount_list;
-+
 +/* Add or remove a mount entry. */
 +static int tmy_add_mount_acl(const char *dev_name,
 +			     const char *dir_name,
 +			     const char *fs_type,
 +			     const unsigned int flags,
-+			     const u8 is_delete)
++			     const bool is_delete)
 +{
 +	struct mount_entry *new_entry;
 +	struct mount_entry  *ptr;
 +	const struct path_info *fs;
 +	const struct path_info *dev;
 +	const struct path_info *dir;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	int error = -ENOMEM;
 +
 +	fs = tmy_save_name(fs_type);
@@ -158,33 +153,17 @@
 +	if (!dir)
 +		return -ENOMEM;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
-+	for (ptr = mount_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &mount_list, list) {
 +		if (ptr->flags != flags ||
 +		    tmy_pathcmp(ptr->dev_name, dev) ||
 +		    tmy_pathcmp(ptr->dir_name, dir) ||
 +		    tmy_pathcmp(ptr->fs_type, fs))
 +			continue;
-+
-+		if (is_delete) {
-+			ptr->is_deleted = 1;
-+			error = 0;
-+			goto out;
-+		} else {
-+			if (ptr->is_deleted) {
-+				ptr->flags = flags;
-+				ptr->is_deleted = 0;
-+			} else {
-+				if (ptr->flags == flags) {
-+					error = 0;
-+					goto out; /* No changes. */
-+				}
-+				ptr->flags = flags;
-+			}
-+			error = 0;
-+			goto out;
-+		}
++		ptr->is_deleted = is_delete;
++		error = 0;
++		goto out;
 +	}
 +
 +	if (is_delete) {
@@ -200,22 +179,10 @@
 +	new_entry->dir_name = dir;
 +	new_entry->fs_type = fs;
 +	new_entry->flags = flags;
-+	mb(); /* Instead of using spinlock. */
-+
-+	ptr = mount_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		mount_list = new_entry;
-+
++	list_add_tail_mb(&new_entry->list, &mount_list);
 +	error = 0;
-+	ptr = new_entry;
-+
 +out: ;
-+	up(&lock);
-+
++	mutex_unlock(&mutex);
 +	return error;
 +}
 +
@@ -224,7 +191,7 @@
 +				       char *dir_name,
 +				       char *type,
 +				       unsigned long flags,
-+				       const u8 is_enforce)
++				       const bool is_enforce)
 +{
 +	int error = -EPERM;
 +	const char *realname1 = tmy_realpath(dev_name);
@@ -307,7 +274,7 @@
 +		   char *type,
 +		   unsigned long flags)
 +{
-+	const u8 is_enforce = tmy_enforce(TMY_RESTRICT_MOUNT);
++	const bool is_enforce = tmy_enforce(TMY_RESTRICT_MOUNT);
 +	int error = -EPERM;
 +
 +	if (!tmy_flags(TMY_RESTRICT_MOUNT))
@@ -429,7 +396,7 @@
 +			goto cleanup;
 +		}
 +
-+		for (ptr = mount_list; ptr; ptr = ptr->next) {
++		list_for_each_entry(ptr, &mount_list, list) {
 +			if (ptr->is_deleted)
 +				continue;
 +
@@ -518,7 +485,7 @@
 + * Returns zero on success.
 + * Returns nonzero on failure.
 + */
-+int tmy_add_mount_policy(char *data, const u8 is_delete)
++int tmy_add_mount_policy(char *data, const bool is_delete)
 +{
 +	char *cp;
 +	char *cp2;
@@ -561,22 +528,18 @@
 + */
 +int tmy_read_mount_policy(struct io_buffer *head)
 +{
-+	struct mount_entry *ptr = head->read_var2;
-+
-+	if (!ptr)
-+		ptr = mount_list;
-+
-+	while (ptr) {
-+		head->read_var2 = ptr;
-+		if (ptr->is_deleted == 0 &&
-+		    tmy_io_printf(head, TMY_ALLOW_MOUNT "%s %s %s 0x%x\n",
++	struct list_head *pos;
++	list_for_each_cookie(pos, head->read_var2, &mount_list) {
++		struct mount_entry *ptr;
++		ptr = list_entry(pos, struct mount_entry, list);
++		if (ptr->is_deleted)
++			continue;
++		if (tmy_io_printf(head, TMY_ALLOW_MOUNT "%s %s %s 0x%x\n",
 +				  ptr->dev_name->name, ptr->dir_name->name,
 +				  ptr->fs_type->name, ptr->flags))
-+			break;
-+		ptr = ptr->next;
++			return -ENOMEM;
 +	}
-+
-+	return ptr ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +static int tmy_find_conceal(struct nameidata *nd,
@@ -633,7 +596,7 @@
 +{
 +	int flag = 0;
 +	struct mnt_namespace *namespace = current->nsproxy->mnt_ns;
-+	u8 is_enforce;
++	bool is_enforce;
 +	char *dir;
 +
 +	if (!tmy_flags(TMY_DENY_CONCEAL_MOUNT))
@@ -689,15 +652,15 @@
 +
 +/************************  UMOUNT RESTRICTION HANDLER  ************************/
 +
-+static struct no_umount_entry *no_umount_list;
++static LIST_HEAD(no_umount_list);
 +
 +/* Add or remove a no-unmount entry. */
-+static int tmy_add_no_umount_acl(const char *dir, const u8 is_delete)
++static int tmy_add_no_umount_acl(const char *dir, const bool is_delete)
 +{
 +	struct no_umount_entry *new_entry;
 +	struct no_umount_entry *ptr;
 +	const struct path_info *saved_dir;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	int error = -ENOMEM;
 +
 +	if (!tmy_correct_path(dir, 1, 0, 1, __FUNCTION__))
@@ -706,9 +669,9 @@
 +	if (!saved_dir)
 +		return -ENOMEM;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
-+	for (ptr = no_umount_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &no_umount_list, list) {
 +		if (ptr->dir == saved_dir) {
 +			ptr->is_deleted = is_delete;
 +			error = 0;
@@ -726,20 +689,11 @@
 +		goto out;
 +
 +	new_entry->dir = saved_dir;
-+	mb(); /* Instead of using spinlock. */
-+
-+	ptr = no_umount_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		no_umount_list = new_entry;
-+
++	list_add_tail_mb(&new_entry->list, &no_umount_list);
 +	error = 0;
 +out: ;
 +
-+	up(&lock);
++	mutex_unlock(&mutex);
 +
 +	return error;
 +}
@@ -755,7 +709,7 @@
 +{
 +	int error = -EPERM;
 +	const char *dir0;
-+	const u8 is_enforce = tmy_enforce(TMY_RESTRICT_UMOUNT);
++	const bool is_enforce = tmy_enforce(TMY_RESTRICT_UMOUNT);
 +
 +	if (!tmy_flags(TMY_RESTRICT_UMOUNT))
 +		return 0;
@@ -765,18 +719,21 @@
 +	if (dir0) {
 +		struct no_umount_entry *ptr;
 +		struct path_info dir;
++		bool found = 0;
 +
 +		dir.name = dir0;
 +		tmy_fill_path_info(&dir);
 +
-+		for (ptr = no_umount_list; ptr; ptr = ptr->next) {
++		list_for_each_entry(ptr, &no_umount_list, list) {
 +			if (ptr->is_deleted)
 +				continue;
-+			if (tmy_path_match(&dir, ptr->dir))
++			if (tmy_path_match(&dir, ptr->dir)) {
++				found = 1;
 +				break;
++			}
 +		}
 +
-+		if (ptr) {
++		if (found) {
 +			const char *exename = tmy_get_exe();
 +
 +			tmy_audit_mount_log(0, is_enforce, "umount %s", dir0);
@@ -807,7 +764,7 @@
 + * Returns zero on success.
 + * Returns nonzero on failure.
 + */
-+int tmy_add_no_umount_policy(char *data, const u8 is_delete)
++int tmy_add_no_umount_policy(char *data, const bool is_delete)
 +{
 +	return tmy_add_no_umount_acl(data, is_delete);
 +}
@@ -821,46 +778,42 @@
 + */
 +int tmy_read_no_umount_policy(struct io_buffer *head)
 +{
-+	struct no_umount_entry *ptr = head->read_var2;
-+
-+	if (!ptr)
-+		ptr = no_umount_list;
-+
-+	while (ptr) {
-+		head->read_var2 = ptr;
-+		if (ptr->is_deleted == 0 &&
-+		    tmy_io_printf(head, TMY_DENY_UNMOUNT "%s\n",
++	struct list_head *pos;
++	list_for_each_cookie(pos, head->read_var2, &no_umount_list) {
++		struct no_umount_entry *ptr;
++		ptr = list_entry(pos, struct no_umount_entry, list);
++		if (ptr->is_deleted)
++			continue;
++		if (tmy_io_printf(head, TMY_DENY_UNMOUNT "%s\n",
 +				  ptr->dir->name))
-+			break;
-+		ptr = ptr->next;
++			return -ENOMEM;
 +	}
-+
-+	return ptr ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +/***** The structure for pivot_root restrictions. *****/
 +
 +struct pivot_root_entry {
-+	struct pivot_root_entry *next;
++	struct list_head list;
 +	const struct path_info *old_root;
 +	const struct path_info *new_root;
-+	u8 is_deleted;
++	bool is_deleted;
 +};
 +
 +/**********************  PIVOT_ROOT RESTRICTION HANDLER  **********************/
 +
-+static struct pivot_root_entry *pivot_root_list;
++static LIST_HEAD(pivot_root_list);
 +
 +/* Add or remove a pivot_root entry. */
 +static int tmy_add_pivot_root_acl(const char *old_root,
 +				  const char *new_root,
-+				  const u8 is_delete)
++				  const bool is_delete)
 +{
 +	struct pivot_root_entry *new_entry;
 +	struct pivot_root_entry *ptr;
 +	const struct path_info *saved_old_root;
 +	const struct path_info *saved_new_root;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	int error = -ENOMEM;
 +
 +	if (!tmy_correct_path(old_root, 1, 0, 1, __FUNCTION__) ||
@@ -874,9 +827,9 @@
 +	if (!saved_new_root)
 +		return -ENOMEM;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
-+	for (ptr = pivot_root_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &pivot_root_list, list) {
 +		if (ptr->old_root == saved_old_root &&
 +		    ptr->new_root == saved_new_root) {
 +			ptr->is_deleted = is_delete;
@@ -896,20 +849,11 @@
 +
 +	new_entry->old_root = saved_old_root;
 +	new_entry->new_root = saved_new_root;
-+	mb(); /* Instead of using spinlock. */
-+
-+	ptr = pivot_root_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		pivot_root_list = new_entry;
-+
++	list_add_tail_mb(&new_entry->list, &pivot_root_list);
 +	error = 0;
 +out: ;
 +
-+	up(&lock);
++	mutex_unlock(&mutex);
 +
 +	return error;
 +}
@@ -927,7 +871,7 @@
 +	int error = -EPERM;
 +	char *old_root;
 +	char *new_root;
-+	u8 is_enforce;
++	bool is_enforce;
 +	struct path_info old_root_dir;
 +	struct path_info new_root_dir;
 +
@@ -947,8 +891,7 @@
 +
 +	if (old_root_dir.is_dir && new_root_dir.is_dir) {
 +		struct pivot_root_entry *ptr;
-+
-+		for (ptr = pivot_root_list; ptr; ptr = ptr->next) {
++		list_for_each_entry(ptr, &pivot_root_list, list) {
 +			if (ptr->is_deleted)
 +				continue;
 +			if (tmy_path_match(&old_root_dir, ptr->old_root) &&
@@ -999,7 +942,7 @@
 + * Returns zero on success.
 + * Returns nonzero on failure.
 + */
-+int tmy_add_pivot_root_policy(char *data, const u8 is_delete)
++int tmy_add_pivot_root_policy(char *data, const bool is_delete)
 +{
 +	char *cp = strchr(data, ' ');
 +
@@ -1019,18 +962,15 @@
 + */
 +int tmy_read_pivot_root_policy(struct io_buffer *head)
 +{
-+	struct pivot_root_entry *ptr = head->read_var2;
-+	if (!ptr)
-+		ptr = pivot_root_list;
-+
-+	while (ptr) {
-+		head->read_var2 = ptr;
-+		if (ptr->is_deleted == 0 &&
-+		    tmy_io_printf(head, TMY_ALLOW_PIVOT_ROOT "%s %s\n",
++	struct list_head *pos;
++	list_for_each_cookie(pos, head->read_var2, &pivot_root_list) {
++		struct pivot_root_entry *ptr;
++		ptr = list_entry(pos, struct pivot_root_entry, list);
++		if (ptr->is_deleted)
++			continue;
++		if (tmy_io_printf(head, TMY_ALLOW_PIVOT_ROOT "%s %s\n",
 +				  ptr->new_root->name, ptr->old_root->name))
-+			break;
-+		ptr = ptr->next;
++			return -ENOMEM;
 +	}
-+
-+	return ptr ? -ENOMEM : 0;
++	return 0;
 +}
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-audit.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-audit.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-audit.diff	(working copy)
@@ -13,7 +13,7 @@
  2 files changed, 71 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/audit.c	2007-10-02 11:26:22.000000000 +0900
++++ linux-2.6/security/tomoyo/audit.c	2007-10-27 00:01:51.000000000 +0900
 @@ -0,0 +1,68 @@
 +/*
 + * security/tomoyo/audit.c
@@ -66,7 +66,7 @@
 + * Write audit log.
 + * Caller must allocate @buf with tmy_init_audit_log().
 + */
-+int tmy_write_audit_log(char *buf, const u8 is_granted, const u8 is_enforce)
++int tmy_write_audit_log(char *buf, const bool is_granted, const bool is_enforce)
 +{
 +	struct audit_buffer *ab;
 +	int type = is_granted ? AUDIT_TMY_GRANTED : AUDIT_TMY_REJECTED;
@@ -83,9 +83,9 @@
 +	tmy_free(buf);
 +	return ab ? 0 : -ENOMEM;
 +}
---- linux-2.6.orig/include/linux/audit.h	2007-10-02 11:11:52.000000000 +0900
-+++ linux-2.6/include/linux/audit.h	2007-10-02 11:26:22.000000000 +0900
-@@ -120,6 +120,9 @@
+--- linux-2.6.orig/include/linux/audit.h	2007-10-26 21:33:00.000000000 +0900
++++ linux-2.6/include/linux/audit.h	2007-10-26 21:33:52.000000000 +0900
+@@ -123,6 +123,9 @@
  
  #define AUDIT_KERNEL		2000	/* Asynchronous audit record. NOT A REQUEST. */
  
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-domain.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-domain.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-domain.diff	(working copy)
@@ -8,12 +8,12 @@
 Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
- security/tomoyo/domain.c | 1256 +++++++++++++++++++++++++++++++++++++++++++++++
- 1 files changed, 1256 insertions(+)
+ security/tomoyo/domain.c | 1170 +++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 1170 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/domain.c	2007-10-02 11:26:21.000000000 +0900
-@@ -0,0 +1,1256 @@
++++ linux-2.6/security/tomoyo/domain.c	2007-10-27 00:04:04.000000000 +0900
+@@ -0,0 +1,1170 @@
 +/*
 + * security/tomoyo/domain.c
 + *
@@ -27,50 +27,53 @@
 +
 +/*************************  VARIABLES  *************************/
 +
++/* The initial domain. */
++struct domain_info KERNEL_DOMAIN;
++
 +/* Lock for appending domain's ACL. */
-+DECLARE_MUTEX(domain_acl_lock);
++DEFINE_MUTEX(domain_acl_lock);
 +
 +/* Domain creation lock. */
-+static DECLARE_MUTEX(new_domain_assign_lock);
++static DEFINE_MUTEX(new_domain_assign_lock);
 +
 +/***** The structure for program files to force domain reconstruction. *****/
 +
 +struct domain_initializer_entry {
-+	struct domain_initializer_entry *next;
++	struct list_head list;
 +	const struct path_info *domainname;    /* This may be NULL */
 +	const struct path_info *program;
-+	u8 is_deleted;
-+	u8 is_not;
-+	u8 is_last_name;
++	bool is_deleted;
++	bool is_not;
++	bool is_last_name;
 +};
 +
 +/***** The structure for domains to not to transit domains. *****/
 +
 +struct domain_keeper_entry {
-+	struct domain_keeper_entry *next;
++	struct list_head list;
 +	const struct path_info *domainname;
 +	const struct path_info *program;       /* This may be NULL */
-+	u8 is_deleted;
-+	u8 is_not;
-+	u8 is_last_name;
++	bool is_deleted;
++	bool is_not;
++	bool is_last_name;
 +};
 +
 +/***** The structure for program files that should be aggregated. *****/
 +
 +struct aggregator_entry {
-+	struct aggregator_entry *next;
++	struct list_head list;
 +	const struct path_info *original_name;
 +	const struct path_info *aggregated_name;
-+	u8 is_deleted;
++	bool is_deleted;
 +};
 +
 +/***** The structure for program files that should be aliased. *****/
 +
 +struct alias_entry {
-+	struct alias_entry *next;
++	struct list_head list;
 +	const struct path_info *original_name;
 +	const struct path_info *aliased_name;
-+	u8 is_deleted;
++	bool is_deleted;
 +};
 +
 +/*************************  UTILITY FUNCTIONS  *************************/
@@ -91,26 +94,15 @@
 +
 +/**
 + * tmy_add_acl - add an entry to a domain.
-+ * @ptr: pointer to the last "struct acl_info" of @domain. May be NULL.
 + * @domain: pointer to "struct domain_info".
-+ * @new_ptr: pointer to "struct acl_info" to add.
++ * @acl: pointer to "struct acl_info" to add.
 + *
 + * Returns zero.
-+ *
-+ * To be honest, I can calculate @ptr from @domain.
-+ * But since the caller knows @ptr, I use it.
 + */
-+int tmy_add_acl(struct acl_info *ptr,
-+		struct domain_info *domain,
-+		struct acl_info *new_ptr)
++int tmy_add_acl(struct domain_info *domain,
++		struct acl_info *acl)
 +{
-+	mb(); /* Instead of using spinlock. */
-+
-+	if (!ptr)
-+		domain->first_acl_ptr = (struct acl_info *) new_ptr;
-+	else
-+		ptr->next = (struct acl_info *) new_ptr;
-+
++	list_add_tail_mb(&acl->list, &domain->acl_info_list);
 +	tmy_update_counter(TMY_UPDATE_DOMAINPOLICY);
 +	return 0;
 +}
@@ -135,21 +127,21 @@
 +
 +/************************  DOMAIN INITIALIZER HANDLER  ************************/
 +
-+static struct domain_initializer_entry *domain_initializer_list;
++static LIST_HEAD(domain_initializer_list);
 +
 +/* Update domain initializer list. */
 +static int tmy_add_domain_initializer_entry(const char *domainname,
 +					    const char *program,
-+					    const u8 is_not,
-+					    const u8 is_delete)
++					    const bool is_not,
++					    const bool is_delete)
 +{
 +	struct domain_initializer_entry *new_entry;
 +	struct domain_initializer_entry *ptr;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	const struct path_info *saved_program;
 +	const struct path_info *saved_domainname = NULL;
 +	int error = -ENOMEM;
-+	u8 is_last_name = 0;
++	bool is_last_name = 0;
 +
 +	if (!tmy_correct_path(program, 1, -1, -1, __FUNCTION__))
 +		return -EINVAL; /* No patterns allowed. */
@@ -171,9 +163,9 @@
 +	if (!saved_program)
 +		return -ENOMEM;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
-+	for (ptr = domain_initializer_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &domain_initializer_list, list) {
 +		if (ptr->is_not == is_not &&
 +		    ptr->domainname == saved_domainname &&
 +		    ptr->program == saved_program) {
@@ -196,20 +188,11 @@
 +	new_entry->program = saved_program;
 +	new_entry->is_not = is_not;
 +	new_entry->is_last_name = is_last_name;
-+
-+	mb(); /* Instead of using spinlock. */
-+	ptr = domain_initializer_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		domain_initializer_list = new_entry;
-+
++	list_add_tail_mb(&new_entry->list, &domain_initializer_list);
 +	error = 0;
 +out: ;
 +
-+	up(&lock);
++	mutex_unlock(&mutex);
 +	return error;
 +}
 +
@@ -222,33 +205,28 @@
 + */
 +int tmy_read_domain_initializer_policy(struct io_buffer *head)
 +{
-+	struct domain_initializer_entry *ptr = head->read_var2;
-+
-+	if (!ptr)
-+		ptr = domain_initializer_list;
-+
-+	while (ptr) {
-+		head->read_var2 = ptr;
-+		if (!ptr->is_deleted) {
-+			const char *s1 = ptr->is_not ? "no_" : "";
-+			const char *s2 = TMY_INITIALIZE_DOMAIN;
-+			const char *s3 = ptr->program->name;
-+
-+			if (ptr->domainname) {
-+				if (tmy_io_printf(head, "%s%s%s from %s\n",
-+						  s1, s2, s3,
-+						  ptr->domainname->name))
-+					break;
-+			} else {
-+				if (tmy_io_printf(head, "%s%s%s\n",
-+						  s1, s2, s3))
-+					break;
-+			}
++	struct list_head *pos;
++	list_for_each_cookie(pos, head->read_var2, &domain_initializer_list) {
++		struct domain_initializer_entry *ptr;
++		ptr = list_entry(pos, struct domain_initializer_entry, list);
++		if (ptr->is_deleted)
++			continue;
++		if (ptr->domainname) {
++			if (tmy_io_printf(head, "%s" TMY_INITIALIZE_DOMAIN
++					  "%s from %s\n",
++					  ptr->is_not ? "no_" : "",
++					  ptr->program->name,
++					  ptr->domainname->name))
++				return -ENOMEM;
++		} else {
++			if (tmy_io_printf(head, "%s" TMY_INITIALIZE_DOMAIN
++					  "%s\n",
++					  ptr->is_not ? "no_" : "",
++					  ptr->program->name))
++				return -ENOMEM;
 +		}
-+		ptr = ptr->next;
 +	}
-+
-+	return ptr ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +/**
@@ -263,8 +241,8 @@
 + * This function adds or removes a domain initializer entry.
 + */
 +int tmy_add_domain_initializer_policy(char *data,
-+				      const u8 is_not,
-+				      const u8 is_delete)
++				      const bool is_not,
++				      const bool is_delete)
 +{
 +	char *cp = strstr(data, " from ");
 +
@@ -284,11 +262,9 @@
 +{
 +	struct domain_initializer_entry *ptr;
 +	int flag = 0;
-+
-+	for (ptr = domain_initializer_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr,  &domain_initializer_list, list) {
 +		if (ptr->is_deleted)
 +			continue;
-+
 +		if (ptr->domainname) {
 +			if (!ptr->is_last_name) {
 +				if (ptr->domainname != domainname)
@@ -298,35 +274,32 @@
 +					continue;
 +			}
 +		}
-+
 +		if (tmy_pathcmp(ptr->program, program))
 +			continue;
 +		if (ptr->is_not)
 +			return 0;
-+
 +		flag = 1;
 +	}
-+
 +	return flag;
 +}
 +
 +/*************************  DOMAIN KEEPER HANDLER  *************************/
 +
-+static struct domain_keeper_entry *domain_keeper_list;
++static LIST_HEAD(domain_keeper_list);
 +
 +/* Update domain keeper list. */
 +static int tmy_add_domain_keeper_entry(const char *domainname,
 +				       const char *program,
-+				       const u8 is_not,
-+				       const u8 is_delete)
++				       const bool is_not,
++				       const bool is_delete)
 +{
 +	struct domain_keeper_entry *new_entry;
 +	struct domain_keeper_entry *ptr;
 +	const struct path_info *saved_domainname;
 +	const struct path_info *saved_program = NULL;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	int error = -ENOMEM;
-+	u8 is_last_name = 0;
++	bool is_last_name = 0;
 +
 +	if (!tmy_is_domain_def(domainname) &&
 +	    tmy_correct_path(domainname, 1, -1, -1, __FUNCTION__))
@@ -348,9 +321,8 @@
 +	if (!saved_domainname)
 +		return -ENOMEM;
 +
-+	down(&lock);
-+
-+	for (ptr = domain_keeper_list; ptr; ptr = ptr->next) {
++	mutex_lock(&mutex);
++	list_for_each_entry(ptr, &domain_keeper_list, list) {
 +		if (ptr->is_not == is_not &&
 +		    ptr->domainname == saved_domainname &&
 +		    ptr->program == saved_program) {
@@ -373,20 +345,12 @@
 +	new_entry->program = saved_program;
 +	new_entry->is_not = is_not;
 +	new_entry->is_last_name = is_last_name;
-+
-+	mb(); /* Instead of using spinlock. */
-+	ptr = domain_keeper_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		domain_keeper_list = new_entry;
++	list_add_tail_mb(&new_entry->list, &domain_keeper_list);
 +	error = 0;
 +
 +out: ;
 +
-+	up(&lock);
++	mutex_unlock(&mutex);
 +	return error;
 +}
 +
@@ -403,8 +367,8 @@
 + *
 + */
 +int tmy_add_domain_keeper_policy(char *data,
-+				 const u8 is_not,
-+				 const u8 is_delete)
++				 const bool is_not,
++				 const bool is_delete)
 +{
 +	char *cp = strstr(data, " from ");
 +
@@ -426,16 +390,12 @@
 + */
 +int tmy_read_domain_keeper_policy(struct io_buffer *head)
 +{
-+	struct domain_keeper_entry *ptr = head->read_var2;
-+
-+	if (!ptr)
-+		ptr = domain_keeper_list;
-+
-+	for (; ptr; ptr = ptr->next) {
-+		head->read_var2 = ptr;
++        struct list_head *pos;
++	list_for_each_cookie(pos, head->read_var2, &domain_keeper_list) {
++		struct domain_keeper_entry *ptr;
++		ptr = list_entry(pos, struct domain_keeper_entry, list);
 +		if (ptr->is_deleted)
 +			continue;
-+
 +		if (ptr->program) {
 +			if (tmy_io_printf(head,
 +					  "%s" TMY_KEEP_DOMAIN
@@ -443,20 +403,17 @@
 +					  ptr->is_not ? "no_" : "",
 +					  ptr->program->name,
 +					  ptr->domainname->name))
-+				break;
-+
++				return -ENOMEM;
 +		} else {
 +			if (tmy_io_printf(head,
 +					  "%s" TMY_KEEP_DOMAIN
 +					  "%s\n",
 +					  ptr->is_not ? "no_" : "",
 +					  ptr->domainname->name))
-+				break;
-+
++				return -ENOMEM;
 +		}
 +	}
-+
-+	return ptr ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +/* Should I remain in current domain? */
@@ -466,11 +423,9 @@
 +{
 +	struct domain_keeper_entry *ptr;
 +	int flag = 0;
-+
-+	for (ptr = domain_keeper_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &domain_keeper_list, list) {
 +		if (ptr->is_deleted)
 +			continue;
-+
 +		if (!ptr->is_last_name) {
 +			if (ptr->domainname != domainname)
 +				continue;
@@ -478,29 +433,27 @@
 +			if (tmy_pathcmp(ptr->domainname, last_name))
 +				continue;
 +		}
-+
 +		if (ptr->program && tmy_pathcmp(ptr->program, program))
 +			continue;
 +		if (ptr->is_not)
 +			return 0;
 +		flag = 1;
 +	}
-+
 +	return flag;
 +}
 +
 +/*********************  SYMBOLIC LINKED PROGRAM HANDLER  *********************/
 +
-+static struct alias_entry *alias_list;
++static LIST_HEAD(alias_list);
 +
 +/* Update alias list. */
 +static int tmy_add_alias_entry(const char *original_name,
 +			       const char *aliased_name,
-+			       const u8 is_delete)
++			       const bool is_delete)
 +{
 +	struct alias_entry *new_entry;
 +	struct alias_entry *ptr;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	const struct path_info *saved_original_name;
 +	const struct path_info *saved_aliased_name;
 +	int error = -ENOMEM;
@@ -514,9 +467,9 @@
 +	if (!saved_original_name || !saved_aliased_name)
 +		return -ENOMEM;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
-+	for (ptr = alias_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &alias_list, list) {
 +		if (ptr->original_name == saved_original_name &&
 +		    ptr->aliased_name == saved_aliased_name) {
 +			ptr->is_deleted = is_delete;
@@ -536,21 +489,10 @@
 +
 +	new_entry->original_name = saved_original_name;
 +	new_entry->aliased_name = saved_aliased_name;
-+
-+	mb(); /* Instead of using spinlock. */
-+	ptr = alias_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		alias_list = new_entry;
-+
++	list_add_tail_mb(&new_entry->list, &alias_list);
 +	error = 0;
 +out: ;
-+
-+	up(&lock);
-+
++	mutex_unlock(&mutex);
 +	return error;
 +}
 +
@@ -563,22 +505,19 @@
 + */
 +int tmy_read_alias_policy(struct io_buffer *head)
 +{
-+	struct alias_entry *ptr = head->read_var2;
-+
-+	if (!ptr)
-+		ptr = alias_list;
-+
-+	for (; ptr; ptr = ptr->next) {
-+		head->read_var2 = ptr;
-+		if (!ptr->is_deleted &&
-+		    tmy_io_printf(head,
++	struct list_head *pos;
++        list_for_each_cookie(pos, head->read_var2, &alias_list) {
++		struct alias_entry *ptr;
++		ptr = list_entry(pos, struct alias_entry, list);
++		if (ptr->is_deleted)
++			continue;
++		if (tmy_io_printf(head,
 +				  TMY_ALIAS "%s %s\n",
 +				  ptr->original_name->name,
 +				  ptr->aliased_name->name))
-+			break;
++			return -ENOMEM;
 +	}
-+
-+	return ptr ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +/**
@@ -591,7 +530,7 @@
 + *
 + * This function adds or removes an alias entry.
 + */
-+int tmy_add_alias_policy(char *data, const u8 is_delete)
++int tmy_add_alias_policy(char *data, const bool is_delete)
 +{
 +	char *cp = strchr(data, ' ');
 +
@@ -604,16 +543,16 @@
 +
 +/************************  DOMAIN AGGREGATOR HANDLER  ************************/
 +
-+static struct aggregator_entry *aggregator_list;
++static LIST_HEAD(aggregator_list);
 +
 +/* Update aggregator list. */
 +static int tmy_add_aggregator_entry(const char *original_name,
 +				    const char *aggregated_name,
-+				    const u8 is_delete)
++				    const bool is_delete)
 +{
 +	struct aggregator_entry *new_entry;
 +	struct aggregator_entry *ptr;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	const struct path_info *saved_original_name;
 +	const struct path_info *saved_aggregated_name;
 +	int error = -ENOMEM;
@@ -624,12 +563,12 @@
 +
 +	saved_original_name = tmy_save_name(original_name);
 +	saved_aggregated_name = tmy_save_name(aggregated_name);
-+	if (!saved_original_name || saved_aggregated_name)
++	if (!saved_original_name || !saved_aggregated_name)
 +		return -ENOMEM;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
-+	for (ptr = aggregator_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &aggregator_list, list) {
 +		if (ptr->original_name == saved_original_name &&
 +		    ptr->aggregated_name == saved_aggregated_name) {
 +			ptr->is_deleted = is_delete;
@@ -649,20 +588,11 @@
 +
 +	new_entry->original_name = saved_original_name;
 +	new_entry->aggregated_name = saved_aggregated_name;
-+
-+	mb(); /* Instead of using spinlock. */
-+	ptr = aggregator_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		aggregator_list = new_entry;
-+
++	list_add_tail_mb(&new_entry->list, &aggregator_list);
 +	error = 0;
 +out: ;
 +
-+	up(&lock);
++	mutex_unlock(&mutex);
 +
 +	return error;
 +}
@@ -676,22 +606,19 @@
 + */
 +int tmy_read_aggregator_policy(struct io_buffer *head)
 +{
-+	struct aggregator_entry *ptr = head->read_var2;
-+
-+	if (!ptr)
-+		ptr = aggregator_list;
-+
-+	for (; ptr; ptr = ptr->next) {
-+		head->read_var2 = ptr;
-+		if (!ptr->is_deleted &&
-+		    tmy_io_printf(head,
++	struct list_head *pos;
++        list_for_each_cookie(pos, head->read_var2, &aggregator_list) {
++		struct aggregator_entry *ptr;
++		ptr = list_entry(pos, struct aggregator_entry, list);
++		if (ptr->is_deleted)
++			continue;
++		if (tmy_io_printf(head,
 +				  TMY_AGGREGATOR "%s %s\n",
 +				  ptr->original_name->name,
 +				  ptr->aggregated_name->name))
-+			break;
++			return -ENOMEM;
 +	}
-+
-+	return ptr ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +/**
@@ -704,7 +631,7 @@
 + *
 + * This function adds or removes an aggregator entry.
 + */
-+int tmy_add_aggregator_policy(char *data, const u8 is_delete)
++int tmy_add_aggregator_policy(char *data, const bool is_delete)
 +{
 +	char *cp = strchr(data, ' ');
 +
@@ -742,34 +669,26 @@
 +	domainname.name = domainname0;
 +	tmy_fill_path_info(&domainname);
 +
-+	down(&new_domain_assign_lock);
-+
++	mutex_lock(&new_domain_assign_lock);
 +	/* Is there an active domain? */ /* Never delete KERNEL_DOMAIN */
-+	for (domain = KERNEL_DOMAIN.next; domain; domain = domain->next) {
-+		if (domain->is_deleted ||
++	list_for_each_entry(domain, &domain_list, list) {
++		struct domain_info *domain2;
++		if (domain == &KERNEL_DOMAIN ||
++		    domain->is_deleted ||
 +		    tmy_pathcmp(domain->domainname, &domainname))
 +			continue;
-+		break;
-+	}
-+	if (domain) {
-+		struct domain_info *domain2;
-+
 +		/* Mark already deleted domains as non undeletable. */
-+		for (domain2 = KERNEL_DOMAIN.next;
-+		     domain2;
-+		     domain2 = domain2->next) {
++		list_for_each_entry(domain2, &domain_list, list) {
 +			if (!domain2->is_deleted ||
 +			    tmy_pathcmp(domain2->domainname, &domainname))
 +				continue;
 +			domain2->is_deleted = 255;
 +		}
-+
 +		/* Delete and mark active domain as undeletable. */
 +		domain->is_deleted = 1;
++		break;
 +	}
-+
-+	up(&new_domain_assign_lock);
-+
++	mutex_unlock(&new_domain_assign_lock);
 +	return 0;
 +}
 +
@@ -796,9 +715,9 @@
 +	domainname.name = domainname0;
 +	tmy_fill_path_info(&domainname);
 +
-+	down(&new_domain_assign_lock);
++	mutex_lock(&new_domain_assign_lock);
 +
-+	for (domain = KERNEL_DOMAIN.next; domain; domain = domain->next) {
++	list_for_each_entry(domain, &domain_list, list) {
 +		if (tmy_pathcmp(&domainname, domain->domainname))
 +			continue;
 +
@@ -815,7 +734,7 @@
 +	if (candidate_domain)
 +		candidate_domain->is_deleted = 0;
 +
-+	up(&new_domain_assign_lock);
++	mutex_unlock(&new_domain_assign_lock);
 +
 +	return candidate_domain;
 +}
@@ -846,7 +765,7 @@
 +		first = 0;
 +	}
 +
-+	for (domain = &KERNEL_DOMAIN; domain; domain = domain->next) {
++	list_for_each_entry(domain, &domain_list, list) {
 +		if (!domain->is_deleted &&
 +		    !tmy_pathcmp(&domainname, domain->domainname))
 +			return domain;
@@ -872,7 +791,7 @@
 +	struct domain_info *domain = NULL;
 +	const struct path_info *saved_domainname;
 +
-+	down(&new_domain_assign_lock);
++	mutex_lock(&new_domain_assign_lock);
 +
 +	domain = tmy_find_domain(domainname);
 +	if (domain)
@@ -886,7 +805,7 @@
 +		goto out;
 +
 +	/* Can I reuse memory of deleted domain? */
-+	for (domain = KERNEL_DOMAIN.next; domain; domain = domain->next) {
++	list_for_each_entry(domain, &domain_list, list) {
 +		struct task_struct *p;
 +		struct acl_info *ptr;
 +		int flag;
@@ -916,13 +835,13 @@
 +		/* OK. Let's reuse memory for this deleted domain. */
 +
 +		/* Delete all entries in this deleted domain. */
-+		for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next)
++		list_for_each_entry(ptr, &domain->acl_info_list, list)
 +			ptr->is_deleted = 1;
 +
 +		domain->profile = profile;
 +		domain->quota_warned = 0;
 +
-+		mb(); /* Instead of using spinlock. */
++		mb(); /* Avoid out-of-order execution. */
 +		/* Undelete this deleted domain. */
 +		domain->is_deleted = 0;
 +		goto out;
@@ -931,18 +850,13 @@
 +	/* No memory reusable. Create using new memory. */
 +	domain = tmy_alloc_element(sizeof(*domain));
 +	if (domain) {
-+		struct domain_info *ptr = &KERNEL_DOMAIN;
-+
++		INIT_LIST_HEAD(&domain->acl_info_list);
 +		domain->domainname = saved_domainname;
 +		domain->profile = profile;
-+
-+		mb(); /* Instead of using spinlock. */
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = domain;
++		list_add_tail_mb(&domain->list, &domain_list);
 +	}
 +out: ;
-+	up(&new_domain_assign_lock);
++	mutex_unlock(&new_domain_assign_lock);
 +
 +	return domain;
 +}
@@ -1076,7 +990,7 @@
 +	char *new_domain_name = NULL;
 +	char *real_program_name = NULL;
 +	char *symlink_program_name = NULL;
-+	const u8 is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
++	const bool is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
 +	int retval;
 +	struct path_info r;
 +	struct path_info s;
@@ -1125,7 +1039,7 @@
 +		struct alias_entry *ptr;
 +
 +		/* Is this program allowed to be called via symbolic links? */
-+		for (ptr = alias_list; ptr; ptr = ptr->next) {
++		list_for_each_entry(ptr, &alias_list, list) {
 +			if (ptr->is_deleted ||
 +			    tmy_pathcmp(&r, ptr->original_name) ||
 +			    tmy_pathcmp(&s, ptr->aliased_name))
@@ -1189,7 +1103,7 @@
 +		struct aggregator_entry *ptr;
 +
 +		/* Is this program allowed to be aggregated? */
-+		for (ptr = aggregator_list; ptr; ptr = ptr->next) {
++		list_for_each_entry(ptr, &aggregator_list, list) {
 +			if (ptr->is_deleted ||
 +			    !tmy_path_match(&r, ptr->original_name))
 +				continue;
Index: trunk/2.1.x/tomoyo-lsm/patches/namespace.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/namespace.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/namespace.diff	(working copy)
@@ -5,10 +5,10 @@
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
  fs/namespace.c |    2 +-
- 1 files changed, 1 insertion(+), 1 deletion(-)
+ 1 file changed, 1 insertion(+), 1 deletion(-)
 
---- linux-2.6.orig/fs/namespace.c	2007-10-02 11:11:53.000000000 +0900
-+++ linux-2.6/fs/namespace.c	2007-10-02 11:26:21.000000000 +0900
+--- linux-2.6.orig/fs/namespace.c	2007-10-26 21:33:00.000000000 +0900
++++ linux-2.6/fs/namespace.c	2007-10-26 21:33:52.000000000 +0900
 @@ -38,7 +38,7 @@ static int event;
  static struct list_head *mount_hashtable __read_mostly;
  static int hash_mask __read_mostly, hash_bits __read_mostly;
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-headers.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-headers.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-headers.diff	(working copy)
@@ -3,13 +3,13 @@
 Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
- security/tomoyo/include/realpath.h |   44 +++
- security/tomoyo/include/tomoyo.h   |  517 +++++++++++++++++++++++++++++++++++++
- 2 files changed, 561 insertions(+)
+ security/tomoyo/include/realpath.h |   43 ++
+ security/tomoyo/include/tomoyo.h   |  551 +++++++++++++++++++++++++++++++++++++
+ 2 files changed, 594 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/include/realpath.h	2007-10-02 11:26:21.000000000 +0900
-@@ -0,0 +1,44 @@
++++ linux-2.6/security/tomoyo/include/realpath.h	2007-10-26 21:52:05.000000000 +0900
+@@ -0,0 +1,43 @@
 +/*
 + * security/tomoyo/include/realpath.h
 + *
@@ -51,12 +51,11 @@
 +
 +unsigned int tmy_get_memory_used_for_dynamic(void);
 +char *sysctlpath_from_table(struct ctl_table *table);
-+extern void tmy_realpath_init(void);
 +
 +#endif
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/include/tomoyo.h	2007-10-02 11:26:21.000000000 +0900
-@@ -0,0 +1,517 @@
++++ linux-2.6/security/tomoyo/include/tomoyo.h	2007-10-26 23:30:39.000000000 +0900
+@@ -0,0 +1,551 @@
 +/*
 + * security/tomoyo/include/tomoyo.h
 + *
@@ -66,7 +65,7 @@
 +#ifndef _TOMOYO_H
 +#define _TOMOYO_H
 +
-+#define TOMOYO_VERSION_CODE "2.1.0-rc4"
++#define TOMOYO_VERSION_CODE "2.1.0-rc6"
 +
 +#include <linux/string.h>
 +#include <linux/mm.h>
@@ -81,8 +80,43 @@
 +#include <stdarg.h>
 +#include <linux/delay.h>
 +
++/**
++ * list_for_each_cookie - iterate over a list with cookie.
++ * @pos:        the &struct list_head to use as a loop cursor.
++ * @cookie:     the &struct list_head to use as a cookie.
++ * @head:       the head for your list.
++ *
++ * Same with list_for_each except that this primitive uses cookie
++ * so that we can continue iteration.
++ */
++#define list_for_each_cookie(pos, cookie, head) \
++	for ((cookie) || ((cookie) = (head)), pos = (cookie)->next; \
++	     prefetch(pos->next), pos != (head) || ((cookie) = NULL); \
++	     (cookie) = pos, pos = pos->next)
++
++/**
++ * list_add_tail_mb - add a new entry with memory barrier.
++ * @new: new entry to be added.
++ * @head: list head to add it before.
++ *
++ * Same with list_add_tail_rcu() except that this primitive uses mb()
++ * so that we can traverse forwards using list_for_each() and
++ * list_for_each_cookie().
++ */
++static inline void list_add_tail_mb(struct list_head *new,
++                                    struct list_head *head)
++{
++	struct list_head *prev = head->prev;
++	struct list_head *next = head;
++	new->next = next;
++	new->prev = prev;
++	mb();
++	next->prev = new;
++	prev->next = new;
++}
++
 +extern struct rw_semaphore namespace_sem;
-+extern struct semaphore domain_acl_lock;
++extern struct mutex domain_acl_lock;
 +extern int sbin_init_started;
 +
 +struct tmy_security {
@@ -98,23 +132,23 @@
 +	u32 hash;        /* = full_name_hash(name, strlen(name)) */
 +	u16 total_len;   /* = strlen(name)                       */
 +	u16 const_len;   /* = tmy_const_part_length(name)        */
-+	u8 is_dir;       /* = tmy_strendswith(name, "/")         */
-+	u8 is_patterned; /* = PathContainsPattern(name)          */
++	bool is_dir;       /* = tmy_strendswith(name, "/")         */
++	bool is_patterned; /* = PathContainsPattern(name)          */
 +	u16 depth;       /* = tmy_path_depth(name)               */
 +};
 +
 +#define TMY_MAX_PATHNAME_LEN 4000
 +
-+struct group_member {
-+	struct group_member *next;
++struct path_group_member {
++	struct list_head list;
 +	const struct path_info *member_name;
-+	u8 is_deleted;
++	bool is_deleted;
 +};
 +
-+struct group_entry {
-+	struct group_entry *next;
++struct path_group_entry {
++	struct list_head list;
 +	const struct path_info *group_name;
-+	struct group_member *first_member;
++	struct list_head path_group_member_list;
 +};
 +
 +
@@ -126,10 +160,10 @@
 +struct dentry;
 +struct vfsmount;
 +struct obj_info {
-+	u8 validate_done;
-+	u8 path1_valid;
-+	u8 path1_parent_valid;
-+	u8 path2_parent_valid;
++	bool validate_done;
++	bool path1_valid;
++	bool path1_parent_valid;
++	bool path2_parent_valid;
 +	struct dentry *path1_dentry;
 +	struct vfsmount *path1_vfsmnt;
 +	struct dentry *path2_dentry;
@@ -154,19 +188,19 @@
 +/************************  The structure for domains.  ************************/
 +
 +struct acl_info {
-+	struct acl_info *next;
++	struct list_head list;
 +	const struct condition_list *cond;
 +	u8 type;
-+	u8 is_deleted;
++	bool is_deleted;
 +} __attribute__((__packed__));
 +
 +struct domain_info {
-+	struct domain_info *next;           /* NULL if none. */
-+	struct acl_info *first_acl_ptr;     /* NULL if none. */
++	struct list_head list;
++	struct list_head acl_info_list;
 +	const struct path_info *domainname; /* Never NULL.   */
 +	u8 profile;
-+	u8 is_deleted;
-+	u8 quota_warned;
++	u8 is_deleted; /* 0: active, 1:deleted, 255:deleted-permanently */
++	bool quota_warned;
 +};
 +
 +#define TMY_MAX_PROFILES 256
@@ -175,10 +209,10 @@
 +	/* type = TMY_TYPE_FILE_ACL */
 +	struct acl_info head;
 +	u8 perm;
-+	u8 u_is_group;
++	bool u_is_group;
 +	union {
 +		const struct path_info *filename;
-+		const struct group_entry *group;
++		const struct path_group_entry *group;
 +	} u;
 +};
 +
@@ -192,42 +226,42 @@
 +struct single_acl {
 +	/* type = TMY_TYPE_* */
 +	struct acl_info head;
-+	u8 u_is_group;
++	bool u_is_group;
 +	union {
 +		const struct path_info *filename;
-+		const struct group_entry *group;
++		const struct path_group_entry *group;
 +	} u;
 +};
 +
 +struct double_acl {
 +	/* type = TMY_TYPE_RENAME_ACL or TMY_TYPE_LINK_ACL, */
 +	struct acl_info head;
-+	u8 u1_is_group;
-+	u8 u2_is_group;
++	bool u1_is_group;
++	bool u2_is_group;
 +	union {
 +		const struct path_info *filename1;
-+		const struct group_entry *group1;
++		const struct path_group_entry *group1;
 +	} u1;
 +	union {
 +		const struct path_info *filename2;
-+		const struct group_entry *group2;
++		const struct path_group_entry *group2;
 +	} u2;
 +};
 +
 +struct addr_group_member {
-+	struct addr_group_member *next;
++	struct list_head list;
 +	union {
 +		u32 ipv4;    /* Host byte order    */
 +		u16 ipv6[8]; /* Network byte order */
 +	} min, max;
-+	u8 is_deleted;
-+	u8 is_ipv6;
++	bool is_deleted;
++	bool is_ipv6;
 +};
 +
 +struct addr_group_entry {
-+	struct addr_group_entry *next;
++	struct list_head list;
 +	const struct path_info *group_name;
-+	struct addr_group_member *first_member;
++	struct list_head address_group_member_list;
 +};
 +
 +#define TMY_TYPE_ADDRESS_GROUP 0
@@ -235,7 +269,7 @@
 +#define TMY_TYPE_IPv6          2
 +
 +struct net_acl {
-+	/* type = TYPE_IP_NETWORK_ACL, */
++	/* type = TYPE_IP_NETWORK_ACL */
 +	struct acl_info head;
 +	u8 operation_type;
 +	u8 record_type;
@@ -369,12 +403,12 @@
 +
 +struct io_buffer {
 +	int (*read) (struct io_buffer *);
-+	struct semaphore read_sem;
++	struct mutex read_sem;
 +	int (*write) (struct io_buffer *);
-+	struct semaphore write_sem;
++	struct mutex write_sem;
 +	int (*poll) (struct file *file, poll_table *wait);
-+	void *read_var1;              /* The position currently reading from. */
-+	void *read_var2;              /* Extra variables for reading.         */
++	struct list_head *read_var1;  /* The position currently reading from. */
++	struct list_head *read_var2;  /* Extra variables for reading.         */
 +	struct domain_info *write_var1;	 /* The position currently writing to.*/
 +	int read_step;                /* The step for reading.                */
 +	char *read_buf;               /* Buffer for reading.                  */
@@ -403,44 +437,42 @@
 +		   unsigned long flags);
 +int tmy_conceal_mount(struct nameidata *nd);
 +int tmy_umount_perm(struct vfsmount *mnt);
-+int tmy_add_mount_policy(char *data, const u8 is_delete);
++int tmy_add_mount_policy(char *data, const bool is_delete);
 +int tmy_read_mount_policy(struct io_buffer *head);
-+int tmy_add_no_umount_policy(char *data, const u8 is_delete);
++int tmy_add_no_umount_policy(char *data, const bool is_delete);
 +int tmy_read_no_umount_policy(struct io_buffer *head);
 +int tmy_pivot_root_perm(struct nameidata *old_nd,
 +			struct nameidata *new_nd);
-+int tmy_add_pivot_root_policy(char *data, const u8 is_delete);
++int tmy_add_pivot_root_policy(char *data, const bool is_delete);
 +int tmy_read_pivot_root_policy(struct io_buffer *head);
 +
-+int tmy_add_aggregator_policy(char *data, const u8 is_delete);
-+int tmy_add_addr_group_policy(char *data, const u8 is_delete);
-+int tmy_add_alias_policy(char *data, const u8 is_delete);
++int tmy_add_aggregator_policy(char *data, const bool is_delete);
++int tmy_add_addr_group_policy(char *data, const bool is_delete);
++int tmy_add_alias_policy(char *data, const bool is_delete);
 +int tmy_add_argv0_policy(char *data,
 +			 struct domain_info *domain,
 +			 const struct condition_list *cond,
-+			 const u8 is_delete);
-+int tmy_add_acl(struct acl_info *ptr,
-+		struct domain_info *domain,
-+		struct acl_info *new_ptr);
++			 const bool is_delete);
++int tmy_add_acl(struct domain_info *domain, struct acl_info *acl);
 +int tmy_add_domain_initializer_policy(char *data,
-+				      const u8 is_not,
-+				      const u8 is_delete);
++				      const bool is_not,
++				      const bool is_delete);
 +int tmy_add_domain_keeper_policy(char *data,
-+				 const u8 is_not,
-+				 const u8 is_delete);
++				 const bool is_not,
++				 const bool is_delete);
 +int tmy_file_perm(const char *filename0, const u8 perm, const char *operation);
 +int tmy_add_file_policy(char *data,
 +			struct domain_info *domain,
 +			const struct condition_list *cond,
-+			const u8 is_delete);
-+int tmy_add_globally_readable_policy(char *data, const u8 is_delete);
-+int tmy_add_group_policy(char *data, const u8 is_delete);
++			const bool is_delete);
++int tmy_add_globally_readable_policy(char *data, const bool is_delete);
++int tmy_add_group_policy(char *data, const bool is_delete);
 +int tmy_add_network_policy(char *data,
 +			   struct domain_info *domain,
 +			   const struct condition_list *cond,
-+			   const u8 is_delete);
-+int tmy_add_no_rewrite_policy(char *pattern, const u8 is_delete);
-+int tmy_add_pattern_policy(char *data, const u8 is_delete);
++			   const bool is_delete);
++int tmy_add_no_rewrite_policy(char *pattern, const bool is_delete);
++int tmy_add_pattern_policy(char *data, const bool is_delete);
 +int tmy_supervisor(const char *fmt, ...)
 +	__attribute__((format(printf, 1, 2)));
 +
@@ -466,25 +498,25 @@
 +int tmy_read_pattern_policy(struct io_buffer *head);
 +int tmy_read_addr_group_policy(struct io_buffer *head);
 +int tmy_argv0_perm(const struct path_info *filename, const char *argv0);
-+int tmy_network_listen_acl(const u8 is_ipv6,
++int tmy_network_listen_acl(const bool is_ipv6,
 +			   const u8 *address,
 +			   const u16 port);
-+int tmy_network_connect_acl(const u8 is_ipv6,
++int tmy_network_connect_acl(const bool is_ipv6,
 +			    const int sock_type,
 +			    const u8 *address,
 +			    const u16 port);
-+int tmy_network_bind_acl(const u8 is_ipv6,
++int tmy_network_bind_acl(const bool is_ipv6,
 +			 const int sock_type,
 +			 const u8 *address,
 +			 const u16 port);
-+int tmy_network_sendmsg_acl(const u8 is_ipv6,
++int tmy_network_sendmsg_acl(const bool is_ipv6,
 +			    const int sock_type,
 +			    const u8 *address,
 +			    const u16 port);
-+int tmy_network_accept_acl(const u8 is_ipv6,
++int tmy_network_accept_acl(const bool is_ipv6,
 +			   const u8 *address,
 +			   const u16 port);
-+int tmy_network_recvmsg_acl(const u8 is_ipv6,
++int tmy_network_recvmsg_acl(const bool is_ipv6,
 +			    const int sock_type,
 +			    const u8 *address,
 +			    const u16 port);
@@ -493,19 +525,19 @@
 +int tmy_add_signal_policy(char *data,
 +			  struct domain_info *domain,
 +			  const struct condition_list *cond,
-+			  const u8 is_delete);
++			  const bool is_delete);
 +
 +char *tmy_init_audit_log(int *len);
-+int tmy_write_audit_log(char *log, const u8 is_granted, const u8 is_enforce);
++int tmy_write_audit_log(char *log, const bool is_granted, const bool is_enforce);
 +int tmy_acltype2paths(const unsigned int acl_type);
 +int tmy_io_printf(struct io_buffer *head, const char *fmt, ...)
 +	__attribute__((format(printf, 2, 3)));
 +struct domain_info *tmy_find_domain(const char *domainname);
 +struct domain_info *tmy_new_domain(const char *domainname, const u8 profile);
 +struct domain_info *tmy_undelete_domain(const char *domainname0);
-+u8 tmy_accept(const unsigned int index,
++bool tmy_accept(const unsigned int index,
 +	      struct domain_info * const domain);
-+u8 tmy_enforce(const unsigned int index);
++bool tmy_enforce(const unsigned int index);
 +unsigned int tmy_flags(const unsigned int index);
 +unsigned int tmy_audit_grant(void);
 +unsigned int tmy_audit_reject(void);
@@ -521,6 +553,7 @@
 +}
 +
 +extern struct domain_info KERNEL_DOMAIN;
++extern struct list_head domain_list;
 +void tmy_load_policy(const char *filename);
 +int tmy_find_next_domain(struct linux_binprm *,
 +			 struct domain_info **);
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-signal.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-signal.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-signal.diff	(working copy)
@@ -9,12 +9,12 @@
 Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
- security/tomoyo/signal.c |  229 +++++++++++++++++++++++++++++++++++++++++++++++
- 1 files changed, 229 insertions(+)
+ security/tomoyo/signal.c |  219 +++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 219 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/signal.c	2007-10-02 11:26:22.000000000 +0900
-@@ -0,0 +1,229 @@
++++ linux-2.6/security/tomoyo/signal.c	2007-10-27 00:01:51.000000000 +0900
+@@ -0,0 +1,219 @@
 +/*
 + * security/tomoyo/signal.c
 + *
@@ -28,8 +28,8 @@
 +
 +static int tmy_audit_signal_log(const int signal,
 +				const struct path_info *dest_domain,
-+				const u8 is_granted,
-+				const u8 is_enforce)
++				const bool is_granted,
++				const bool is_enforce)
 +{
 +	char *buf;
 +	int len;
@@ -61,9 +61,10 @@
 +static int tmy_add_signal_entry(const u16 sig, const char *dest_pattern,
 +				struct domain_info *domain,
 +				const struct condition_list *cond,
-+				const u8 is_delete)
++				const bool is_delete)
 +{
 +	struct acl_info *ptr;
++	struct signal_acl *acl;
 +	const struct path_info *saved_dest_pattern;
 +	int error = -ENOMEM;
 +
@@ -77,50 +78,38 @@
 +	if (!saved_dest_pattern)
 +		return -ENOMEM;
 +
-+	down(&domain_acl_lock);
++	mutex_lock(&domain_acl_lock);
 +
 +	if (is_delete)
 +		goto remove;
 +
-+	ptr = domain->first_acl_ptr;
-+	if (!ptr)
-+		goto first_entry;
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct signal_acl *) ptr;
 +
-+	while (1) {
-+		struct signal_acl *acl = (struct signal_acl *) ptr;
-+
 +		if (ptr->type == TMY_TYPE_SIGNAL_ACL && acl->sig == sig
 +		    && ptr->cond == cond
 +		    && !tmy_pathcmp(acl->domainname, saved_dest_pattern)) {
 +			ptr->is_deleted = 0;
 +			/* Found. Nothing to do. */
 +			error = 0;
-+			break;
++			goto ok;
 +		}
-+
-+		if (ptr->next) {
-+			ptr = ptr->next;
-+			continue;
-+		}
-+
-+first_entry: ;
-+		/* Not found. Append it to the tail. */
-+		acl = tmy_alloc_element(sizeof(*acl));
-+		if (!acl)
-+			break;
-+
-+		acl->head.type = TMY_TYPE_SIGNAL_ACL;
-+		acl->head.cond = cond;
-+		acl->sig = sig;
-+		acl->domainname = saved_dest_pattern;
-+		error = tmy_add_acl(ptr, domain, (struct acl_info *) acl);
-+		break;
 +	}
++	/* Not found. Append it to the tail. */
++	acl = tmy_alloc_element(sizeof(*acl));
++	if (!acl)
++		goto ok;
++
++	acl->head.type = TMY_TYPE_SIGNAL_ACL;
++	acl->head.cond = cond;
++	acl->sig = sig;
++	acl->domainname = saved_dest_pattern;
++	error = tmy_add_acl(domain, (struct acl_info *) acl);
 +	goto ok;
 +remove: ;
 +	error = -ENOENT;
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
-+		struct signal_acl *acl = (struct signal_acl *) ptr;
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct signal_acl *) ptr;
 +		if (ptr->type != TMY_TYPE_SIGNAL_ACL || ptr->cond != cond ||
 +		    ptr->is_deleted || acl->sig != sig ||
 +		    tmy_pathcmp(acl->domainname, saved_dest_pattern))
@@ -130,7 +119,7 @@
 +	}
 +
 +ok: ;
-+	up(&domain_acl_lock);
++	mutex_unlock(&domain_acl_lock);
 +
 +	return error;
 +}
@@ -150,7 +139,8 @@
 +	const char *dest_pattern;
 +	struct acl_info *ptr;
 +	const u16 hash = sig;
-+	const u8 is_enforce = tmy_enforce(TMY_MAC_FOR_SIGNAL);
++	const bool is_enforce = tmy_enforce(TMY_MAC_FOR_SIGNAL);
++	bool found = 0;
 +
 +	if (!tmy_flags(TMY_MAC_FOR_SIGNAL))
 +		return 0;
@@ -186,7 +176,7 @@
 +	}
 +
 +	dest_pattern = dest->domainname->name;
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 +		struct signal_acl *acl = (struct signal_acl *) ptr;
 +
 +		if (ptr->type == TMY_TYPE_SIGNAL_ACL && ptr->is_deleted == 0
@@ -197,18 +187,18 @@
 +			if (strncmp(acl->domainname->name,
 +				    dest_pattern, len) == 0
 +			    && (dest_pattern[len] == ' ' ||
-+				dest_pattern[len] == '\0'))
++				dest_pattern[len] == '\0')) {
++				found = 1;
 +				break;
-+
++			}
 +		}
 +	}
 +
-+	if (ptr) {
-+		tmy_audit_signal_log(sig, dest->domainname, 1, is_enforce);
++	tmy_audit_signal_log(sig, dest->domainname, found, is_enforce);
++
++	if (found)
 +		return 0;
-+	}
 +
-+	tmy_audit_signal_log(sig, dest->domainname, 0, is_enforce);
 +	if (is_enforce)
 +		return tmy_supervisor("%s\n" TMY_ALLOW_SIGNAL "%d %s\n",
 +				      domain->domainname->name,
@@ -232,7 +222,7 @@
 +int tmy_add_signal_policy(char *data,
 +			  struct domain_info *domain,
 +			  const struct condition_list *cond,
-+			  const u8 is_delete)
++			  const bool is_delete)
 +{
 +	int sig;
 +	char *domainname = strchr(data, ' ');
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-file.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-file.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-file.diff	(working copy)
@@ -9,12 +9,12 @@
 Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
- security/tomoyo/file.c | 1544 +++++++++++++++++++++++++++++++++++++++++++++++++
- 1 files changed, 1544 insertions(+)
+ security/tomoyo/file.c | 1434 +++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 1434 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/file.c	2007-10-02 11:26:22.000000000 +0900
-@@ -0,0 +1,1544 @@
++++ linux-2.6/security/tomoyo/file.c	2007-10-27 00:01:51.000000000 +0900
+@@ -0,0 +1,1434 @@
 +/*
 + * security/tomoyo/file.c
 + *
@@ -30,25 +30,25 @@
 +/***** The structure for globally readable files. *****/
 +
 +struct globally_readable_file_entry {
-+	struct globally_readable_file_entry *next;
++	struct list_head list;
 +	const struct path_info *filename;
-+	u8 is_deleted;
++	bool is_deleted;
 +};
 +
 +/***** The structure for filename patterns. *****/
 +
 +struct pattern_entry {
-+	struct pattern_entry *next;
++	struct list_head list;
 +	const struct path_info *pattern;
-+	u8 is_deleted;
++	bool is_deleted;
 +};
 +
 +/***** The structure for non-rewritable-by-default file patterns. *****/
 +
 +struct no_rewrite_entry {
-+	struct no_rewrite_entry *next;
++	struct list_head list;
 +	const struct path_info *pattern;
-+	u8 is_deleted;
++	bool is_deleted;
 +};
 +
 +/***** The structure for detailed write operations. *****/
@@ -149,19 +149,19 @@
 +				    const char *filename2,
 +				    struct domain_info * const domain,
 +				    const struct condition_list *cond,
-+				    const u8 is_delete);
++				    const bool is_delete);
 +static int tmy_add_single_write_acl(const u8 type,
 +				    const char *filename,
 +				    struct domain_info * const domain,
 +				    const struct condition_list *cond,
-+				    const u8 is_delete);
++				    const bool is_delete);
 +
 +/*************************  AUDIT FUNCTIONS  *************************/
 +
 +static int tmy_audit_file_log(const struct path_info *filename,
 +			      const u8 perm,
-+			      const u8 is_granted,
-+			      const u8 is_enforce)
++			      const bool is_granted,
++			      const bool is_enforce)
 +{
 +	char *buf;
 +	int len;
@@ -192,8 +192,8 @@
 +static int tmy_audit_write_log(const char *operation,
 +			       const struct path_info *filename1,
 +			       const struct path_info *filename2,
-+			       const u8 is_granted,
-+			       const u8 is_enforce)
++			       const bool is_granted,
++			       const bool is_enforce)
 +{
 +	char *buf;
 +	int len;
@@ -224,14 +224,14 @@
 +
 +/**********************  GLOBALLY READABLE FILE HANDLER  **********************/
 +
-+static struct globally_readable_file_entry *globally_readable_list;
++static LIST_HEAD(globally_readable_list);
 +
 +static int tmy_add_globally_readable_entry(const char *filename,
-+					   const u8 is_delete)
++					   const bool is_delete)
 +{
 +	struct globally_readable_file_entry *new_entry;
 +	struct globally_readable_file_entry *ptr;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	const struct path_info *saved;
 +	int error = -ENOMEM;
 +
@@ -241,9 +241,9 @@
 +	if (!saved)
 +		return -ENOMEM;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
-+	for (ptr = globally_readable_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &globally_readable_list, list) {
 +		if (ptr->filename == saved) {
 +			ptr->is_deleted = is_delete;
 +			error = 0;
@@ -260,19 +260,11 @@
 +		goto out;
 +
 +	new_entry->filename = saved;
-+	mb(); /* Instead of using spinlock. */
-+	ptr = globally_readable_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		globally_readable_list = new_entry;
-+
++	list_add_tail_mb(&new_entry->list, &globally_readable_list);
 +	error = 0;
 +
 +out: ;
-+	up(&lock);
++	mutex_unlock(&mutex);
 +
 +	return error;
 +}
@@ -281,7 +273,7 @@
 +{
 +	struct globally_readable_file_entry *ptr;
 +
-+	for (ptr = globally_readable_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &globally_readable_list, list) {
 +		if (!ptr->is_deleted &&
 +		    !tmy_pathcmp(filename, ptr->filename))
 +			return 1;
@@ -298,7 +290,7 @@
 + * Returns zero on success.
 + * Returns nonzero on failure.
 + */
-+int tmy_add_globally_readable_policy(char *filename, const u8 is_delete)
++int tmy_add_globally_readable_policy(char *filename, const bool is_delete)
 +{
 +	return tmy_add_globally_readable_entry(filename, is_delete);
 +}
@@ -312,36 +304,32 @@
 + */
 +int tmy_read_globally_readable_policy(struct io_buffer *head)
 +{
-+	struct globally_readable_file_entry *ptr = head->read_var2;
-+
-+	if (!ptr)
-+		ptr = globally_readable_list;
-+
-+	while (ptr) {
-+		head->read_var2 = ptr;
-+		if (!ptr->is_deleted &&
-+		    tmy_io_printf(head, TMY_ALLOW_READ "%s\n",
++	struct list_head *pos;
++	list_for_each_cookie(pos, head->read_var2, &globally_readable_list) {
++		struct globally_readable_file_entry *ptr;
++		ptr = list_entry(pos, struct globally_readable_file_entry, list);
++		if (ptr->is_deleted)
++			continue;
++		if (tmy_io_printf(head, TMY_ALLOW_READ "%s\n",
 +				  ptr->filename->name))
-+			break;
-+		ptr = ptr->next;
++			return -ENOMEM;
 +	}
-+
-+	return ptr ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +/*************************  FILE GROUP HANDLER  *************************/
 +
-+static struct group_entry *group_list;
++static LIST_HEAD(path_group_list);
 +
 +static int tmy_add_group_entry(const char *group_name,
 +			       const char *member_name,
-+			       const u8 is_delete)
++			       const bool is_delete)
 +{
-+	static DECLARE_MUTEX(lock);
-+	struct group_entry *new_group;
-+	struct group_entry *group;
-+	struct group_member *new_member;
-+	struct group_member *member;
++	static DEFINE_MUTEX(mutex);
++	struct path_group_entry *new_group;
++	struct path_group_entry *group;
++	struct path_group_member *new_member;
++	struct path_group_member *member;
 +	const struct path_info *saved_group;
 +	const struct path_info *saved_member;
 +	int error = -ENOMEM;
@@ -358,14 +346,12 @@
 +	if (!saved_group || !saved_member)
 +		return -ENOMEM;
 +
-+	down(&lock);
-+	for (group = group_list; group; group = group->next) {
++	mutex_lock(&mutex);
++	list_for_each_entry(group, &path_group_list, list) {
 +		if (saved_group != group->group_name)
 +			continue;
 +
-+		for (member = group->first_member;
-+		     member;
-+		     member = member->next) {
++		list_for_each_entry(member, &group->path_group_member_list, list) {
 +			if (member->member_name == saved_member) {
 +				member->is_deleted = is_delete;
 +				error = 0;
@@ -384,38 +370,20 @@
 +		new_group = tmy_alloc_element(sizeof(*new_group));
 +		if (!new_group)
 +			goto out;
++		INIT_LIST_HEAD(&new_group->path_group_member_list);
 +		new_group->group_name = saved_group;
-+		mb(); /* Instead of using spinlock. */
-+		group = group_list;
-+
-+		if (group) {
-+			while (group->next)
-+				group = group->next;
-+			group->next = new_group;
-+		} else
-+			group_list = new_group;
-+
++		list_add_tail_mb(&new_group->list, &path_group_list);
 +		group = new_group;
 +	}
 +
 +	new_member = tmy_alloc_element(sizeof(*new_member));
 +	if (!new_member)
 +		goto out;
-+
 +	new_member->member_name = saved_member;
-+	mb(); /* Instead of using spinlock. */
-+	member = group->first_member;
-+
-+	if (member) {
-+		while (member->next)
-+			member = member->next;
-+		member->next = new_member;
-+	} else
-+		group->first_member = new_member;
-+
++	list_add_tail_mb(&new_member->list, &group->path_group_member_list);
 +	error = 0;
 +out: ;
-+	up(&lock);
++	mutex_unlock(&mutex);
 +
 +	return error;
 +}
@@ -428,7 +396,7 @@
 + * Returns zero on success.
 + * Returns nonzero on failure.
 + */
-+int tmy_add_group_policy(char *data, const u8 is_delete)
++int tmy_add_group_policy(char *data, const bool is_delete)
 +{
 +	char *cp = strchr(data, ' ');
 +
@@ -438,13 +406,13 @@
 +	return tmy_add_group_entry(data, cp, is_delete);
 +}
 +
-+static struct group_entry *tmy_new_path_group(const char *group_name)
++static struct path_group_entry *tmy_new_path_group(const char *group_name)
 +{
 +	int i;
-+	struct group_entry *group;
++	struct path_group_entry *group;
 +
 +	for (i = 0; i <= 1; i++) {
-+		for (group = group_list; group; group = group->next) {
++		list_for_each_entry(group, &path_group_list, list) {
 +			if (strcmp(group_name, group->group_name->name) == 0)
 +				return group;
 +		}
@@ -463,15 +431,14 @@
 +}
 +
 +static int tmy_path_match_group(const struct path_info *pathname,
-+				const struct group_entry *group,
++				const struct path_group_entry *group,
 +				const int may_use_pattern)
 +{
-+	struct group_member *member;
++	struct path_group_member *member;
 +
-+	for (member = group->first_member; member; member = member->next) {
++	list_for_each_entry(member, &group->path_group_member_list, list) {
 +		if (member->is_deleted)
 +			continue;
-+
 +		if (!member->member_name->is_patterned) {
 +			if (!tmy_pathcmp(pathname, member->member_name))
 +				return 1;
@@ -493,46 +460,35 @@
 + */
 +int tmy_read_group_policy(struct io_buffer *head)
 +{
-+	struct group_entry *group = head->read_var1;
-+	struct group_member *member = head->read_var2;
-+
-+	if (!group)
-+		group = group_list;
-+
-+	while (group) {
-+		head->read_var1 = group;
-+		if (!member)
-+			member = group->first_member;
-+		while (member) {
-+			head->read_var2 = member;
-+			if (!member->is_deleted &&
-+			    tmy_io_printf(head,
++        struct list_head *gpos;
++        struct list_head *mpos;
++	list_for_each_cookie(gpos, head->read_var1, &path_group_list) {
++		struct path_group_entry *group;
++		group = list_entry(gpos, struct path_group_entry, list);
++		list_for_each_cookie(mpos, head->read_var2, &group->path_group_member_list) {
++			struct path_group_member *member;
++			member = list_entry(mpos, struct path_group_member, list);
++			if (member->is_deleted)
++				continue;
++			if (tmy_io_printf(head,
 +					  TMY_PATH_GROUP "%s %s\n",
 +					  group->group_name->name,
 +					  member->member_name->name))
-+				break;
-+			member = member->next;
++				return -ENOMEM;
 +		}
-+
-+		if (member)
-+			break;
-+
-+		head->read_var2 = NULL;
-+		group = group->next;
 +	}
-+
-+	return group ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +/*************************  FILE PATTERN HANDLER  *************************/
 +
-+static struct pattern_entry *pattern_list;
++static LIST_HEAD(pattern_list);
 +
-+static int tmy_add_pattern_entry(const char *pattern, const u8 is_delete)
++static int tmy_add_pattern_entry(const char *pattern, const bool is_delete)
 +{
 +	struct pattern_entry *new_entry;
 +	struct pattern_entry *ptr;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	const struct path_info *saved;
 +	int error = -ENOMEM;
 +
@@ -543,9 +499,9 @@
 +	if (!saved)
 +		return -ENOMEM;
 +
-+	down(&lock);
++	mutex_lock(&mutex);
 +
-+	for (ptr = pattern_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &pattern_list, list) {
 +		if (saved == ptr->pattern) {
 +			ptr->is_deleted = is_delete;
 +			error = 0;
@@ -563,19 +519,10 @@
 +	if (!new_entry)
 +		goto out;
 +	new_entry->pattern = saved;
-+	mb(); /* Instead of using spinlock. */
-+
-+	ptr = pattern_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		pattern_list = new_entry;
-+
++	list_add_tail_mb(&new_entry->list, &pattern_list);
 +	error = 0;
 +out: ;
-+	up(&lock);
++	mutex_unlock(&mutex);
 +	return error;
 +}
 +
@@ -584,12 +531,11 @@
 +	struct pattern_entry *ptr;
 +	const struct path_info *pattern = NULL;
 +
-+	for (ptr = pattern_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &pattern_list, list) {
 +		if (ptr->is_deleted)
 +			continue;
 +		if (!tmy_path_match(filename, ptr->pattern))
 +			continue;
-+
 +		pattern = ptr->pattern;
 +		if (!tmy_strendswith(pattern->name, "/\\*"))
 +			break;
@@ -609,7 +555,7 @@
 + * Returns zero on success.
 + * Returns nonzero on failure.
 + */
-+int tmy_add_pattern_policy(char *pattern, const u8 is_delete)
++int tmy_add_pattern_policy(char *pattern, const bool is_delete)
 +{
 +	return tmy_add_pattern_entry(pattern, is_delete);
 +}
@@ -623,32 +569,28 @@
 + */
 +int tmy_read_pattern_policy(struct io_buffer *head)
 +{
-+	struct pattern_entry *ptr = head->read_var2;
-+
-+	if (!ptr)
-+		ptr = pattern_list;
-+
-+	while (ptr) {
-+		head->read_var2 = ptr;
-+		if (!ptr->is_deleted &&
-+		    tmy_io_printf(head, TMY_FILE_PATTERN "%s\n",
++	struct list_head *pos;
++	list_for_each_cookie(pos, head->read_var2, &pattern_list) {
++		struct pattern_entry *ptr;
++		ptr = list_entry(pos, struct pattern_entry, list);
++		if (ptr->is_deleted)
++			continue;
++		if (tmy_io_printf(head, TMY_FILE_PATTERN "%s\n",
 +				  ptr->pattern->name))
-+			break;
-+		ptr = ptr->next;
++			return -ENOMEM;
 +	}
-+
-+	return ptr ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +/***********************  NON REWRITABLE FILE HANDLER  ***********************/
 +
-+static struct no_rewrite_entry *no_rewrite_list;
++static LIST_HEAD(no_rewrite_list);
 +
-+static int tmy_add_no_rewrite_entry(const char *pattern, const u8 is_delete)
++static int tmy_add_no_rewrite_entry(const char *pattern, const bool is_delete)
 +{
 +	struct no_rewrite_entry *new_entry;
 +	struct no_rewrite_entry *ptr;
-+	static DECLARE_MUTEX(lock);
++	static DEFINE_MUTEX(mutex);
 +	const struct path_info *saved;
 +	int error = -ENOMEM;
 +
@@ -658,8 +600,8 @@
 +	if (!saved)
 +		return -ENOMEM;
 +
-+	down(&lock);
-+	for (ptr = no_rewrite_list; ptr; ptr = ptr->next) {
++	mutex_lock(&mutex);
++	list_for_each_entry(ptr, &no_rewrite_list, list) {
 +		if (ptr->pattern == saved) {
 +			ptr->is_deleted = is_delete;
 +			error = 0;
@@ -677,19 +619,10 @@
 +		goto out;
 +
 +	new_entry->pattern = saved;
-+	mb(); /* Instead of using spinlock. */
-+
-+	ptr = no_rewrite_list;
-+	if (ptr) {
-+		while (ptr->next)
-+			ptr = ptr->next;
-+		ptr->next = new_entry;
-+	} else
-+		no_rewrite_list = new_entry;
-+
++	list_add_tail_mb(&new_entry->list, &no_rewrite_list);
 +	error = 0;
 +out: ;
-+	up(&lock);
++	mutex_unlock(&mutex);
 +
 +	return error;
 +}
@@ -698,7 +631,7 @@
 +{
 +	struct no_rewrite_entry *ptr;
 +
-+	for (ptr = no_rewrite_list; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &no_rewrite_list, list) {
 +		if (ptr->is_deleted)
 +			continue;
 +		if (!tmy_path_match(filename, ptr->pattern))
@@ -717,7 +650,7 @@
 + * Returns zero on success.
 + * Returns nonzero on failure.
 + */
-+int tmy_add_no_rewrite_policy(char *pattern, const u8 is_delete)
++int tmy_add_no_rewrite_policy(char *pattern, const bool is_delete)
 +{
 +	return tmy_add_no_rewrite_entry(pattern, is_delete);
 +}
@@ -731,21 +664,17 @@
 + */
 +int tmy_read_no_rewrite_policy(struct io_buffer *head)
 +{
-+	struct no_rewrite_entry *ptr = head->read_var2;
-+
-+	if (!ptr)
-+		ptr = no_rewrite_list;
-+
-+	while (ptr) {
-+		head->read_var2 = ptr;
-+		if (!ptr->is_deleted &&
-+		    tmy_io_printf(head, TMY_DENY_REWRITE "%s\n",
++	struct list_head *pos;
++	list_for_each_cookie(pos, head->read_var2, &no_rewrite_list) {
++		struct no_rewrite_entry *ptr;
++		ptr = list_entry(pos, struct no_rewrite_entry, list);
++		if (ptr->is_deleted)
++			continue;
++		if (tmy_io_printf(head, TMY_DENY_REWRITE "%s\n",
 +				  ptr->pattern->name))
-+			break;
-+		ptr = ptr->next;
++			return -ENOMEM;
 +	}
-+
-+	return ptr ? -ENOMEM : 0;
++	return 0;
 +}
 +
 +/*************************  FILE ACL HANDLER  *************************/
@@ -754,12 +683,13 @@
 +			    u8 perm,
 +			    struct domain_info * const domain,
 +			    const struct condition_list *cond,
-+			    const u8 is_delete)
++			    const bool is_delete)
 +{
 +	const struct path_info *saved;
 +	struct acl_info *ptr;
++	struct file_acl *acl;
 +	int error = -ENOMEM;
-+	u8 is_group = 0;
++	bool is_group = 0;
 +
 +	if (!domain)
 +		return -EINVAL;
@@ -796,71 +726,55 @@
 +
 +	}
 +
-+	down(&domain_acl_lock);
++	mutex_lock(&domain_acl_lock);
 +
 +	if (is_delete)
 +		goto remove;
 +
-+	ptr = domain->first_acl_ptr;
-+	if (!ptr)
-+		goto first_entry;
-+
-+	while (1) {
-+		struct file_acl *acl = (struct file_acl *) ptr;
-+
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct file_acl *) ptr;
 +		if ((ptr->type == TMY_TYPE_FILE_ACL) &&
 +		    ptr->cond == cond &&
 +		    (acl->u.filename == saved)) {
 +			if (ptr->is_deleted) {
 +				acl->perm = 0;
-+				mb(); /* Instead of using spinlock. */
++				mb(); /* Avoid out-of-order execution. */
 +				ptr->is_deleted = 0;
 +			}
 +			/* Found. Just 'OR' the permission bits. */
 +			acl->perm |= perm;
 +			error = 0;
 +			tmy_update_counter(TMY_UPDATE_DOMAINPOLICY);
-+			break;
++			goto ok;
 +		}
-+
-+		if (ptr->next) {
-+			ptr = ptr->next;
-+			continue;
-+		}
-+
-+first_entry: ;
-+		/* Not found. Append it to the tail. */
-+		acl = tmy_alloc_element(sizeof(*acl));
-+		if (!acl)
-+			break;
-+
-+		acl->head.type = TMY_TYPE_FILE_ACL;
-+		acl->head.cond = cond;
-+		acl->perm = perm;
-+		acl->u_is_group = is_group;
-+		acl->u.filename = saved;
-+		error = tmy_add_acl(ptr, domain,
-+				    (struct acl_info *) acl);
-+		break;
 +	}
++	/* Not found. Append it to the tail. */
++	acl = tmy_alloc_element(sizeof(*acl));
++	if (!acl)
++		goto ok;
++
++	acl->head.type = TMY_TYPE_FILE_ACL;
++	acl->head.cond = cond;
++	acl->perm = perm;
++	acl->u_is_group = is_group;
++	acl->u.filename = saved;
++	error = tmy_add_acl(domain, (struct acl_info *) acl);
 +	goto ok;
 +remove: ;
 +	error = -ENOENT;
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
-+		struct file_acl *acl = (struct file_acl *) ptr;
-+
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct file_acl *) ptr;
 +		if (ptr->type != TMY_TYPE_FILE_ACL ||
 +		    ptr->cond != cond ||
 +		    ptr->is_deleted ||
 +		    acl->perm != perm ||
 +		    acl->u.filename != saved)
 +			continue;
-+
 +		error = tmy_del_acl(ptr);
 +		break;
 +	}
 +ok: ;
-+	up(&domain_acl_lock);
++	mutex_unlock(&domain_acl_lock);
 +	return error;
 +}
 +
@@ -878,7 +792,7 @@
 +			return 0;
 +	}
 +
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 +		struct file_acl *acl = (struct file_acl *) ptr;
 +
 +		if (ptr->type != TMY_TYPE_FILE_ACL ||
@@ -909,7 +823,7 @@
 +{
 +	int error = 0;
 +	struct domain_info * const domain = TMY_SECURITY->domain;
-+	const u8 is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
++	const bool is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
 +
 +	if (!filename)
 +		return 0;
@@ -975,7 +889,7 @@
 +int tmy_add_file_policy(char *data,
 +			struct domain_info *domain,
 +			const struct condition_list *cond,
-+			const u8 is_delete)
++			const bool is_delete)
 +{
 +	char *filename = strchr(data, ' ');
 +	unsigned int perm;
@@ -1023,12 +937,13 @@
 +				    const char *filename,
 +				    struct domain_info * const domain,
 +				    const struct condition_list *cond,
-+				    const u8 is_delete)
++				    const bool is_delete)
 +{
 +	const struct path_info *saved;
 +	struct acl_info *ptr;
++	struct single_acl *acl;
 +	int error = -ENOMEM;
-+	u8 is_group = 0;
++	bool is_group = 0;
 +
 +	if (!domain)
 +		return -EINVAL;
@@ -1047,48 +962,36 @@
 +			return -ENOMEM;
 +	}
 +
-+	down(&domain_acl_lock);
++	mutex_lock(&domain_acl_lock);
 +	if (is_delete)
 +		goto remove;
 +
-+	ptr = domain->first_acl_ptr;
-+	if (!ptr)
-+		goto first_entry;
-+	while (1) {
-+		struct single_acl *acl = (struct single_acl *) ptr;
-+
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct single_acl *) ptr;
 +		if (ptr->type == type && ptr->cond == cond) {
 +			if (acl->u.filename == saved) {
 +				ptr->is_deleted = 0;
 +				/* Found. Nothing to do. */
 +				error = 0;
-+				break;
++				goto ok;
 +			}
 +		}
-+		if (ptr->next) {
-+			ptr = ptr->next;
-+			continue;
-+		}
-+
-+first_entry: ;
-+		/* Not found. Append it to the tail. */
-+		acl = tmy_alloc_element(sizeof(*acl));
-+		if (!acl)
-+			break;
-+
-+		acl->head.type = type;
-+		acl->head.cond = cond;
-+		acl->u_is_group = is_group;
-+		acl->u.filename = saved;
-+		error = tmy_add_acl(ptr, domain,
-+				    (struct acl_info *) acl);
-+		break;
 +	}
++	/* Not found. Append it to the tail. */
++	acl = tmy_alloc_element(sizeof(*acl));
++	if (!acl)
++		goto ok;
++
++	acl->head.type = type;
++	acl->head.cond = cond;
++	acl->u_is_group = is_group;
++	acl->u.filename = saved;
++	error = tmy_add_acl(domain, (struct acl_info *) acl);
 +	goto ok;
 +remove: ;
 +	error = -ENOENT;
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
-+		struct single_acl *acl = (struct single_acl *) ptr;
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct single_acl *) ptr;
 +
 +		if (ptr->type != type || ptr->is_deleted ||
 +		    ptr->cond != cond || acl->u.filename != saved)
@@ -1098,7 +1001,7 @@
 +		break;
 +	}
 +ok: ;
-+	up(&domain_acl_lock);
++	mutex_unlock(&domain_acl_lock);
 +
 +	return error;
 +}
@@ -1108,14 +1011,15 @@
 +				    const char *filename2,
 +				    struct domain_info * const domain,
 +				    const struct condition_list *cond,
-+				    const u8 is_delete)
++				    const bool is_delete)
 +{
 +	const struct path_info *saved1;
 +	const struct path_info *saved2;
 +	struct acl_info *ptr;
++	struct double_acl *acl;
 +	int error = -ENOMEM;
-+	u8 is_group1 = 0;
-+	u8 is_group2 = 0;
++	bool is_group1 = 0;
++	bool is_group2 = 0;
 +
 +	if (!domain)
 +		return -EINVAL;
@@ -1147,65 +1051,51 @@
 +			return -ENOMEM;
 +	}
 +
-+	down(&domain_acl_lock);
++	mutex_lock(&domain_acl_lock);
 +
 +	if (is_delete)
 +		goto remove;
 +
-+	ptr = domain->first_acl_ptr;
-+	if (!ptr)
-+		goto first_entry;
-+	while (1) {
-+		struct double_acl *acl = (struct double_acl *) ptr;
-+
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct double_acl *) ptr;
 +		if (ptr->type == type && ptr->cond == cond) {
 +			if (acl->u1.filename1 == saved1 &&
 +			    acl->u2.filename2 == saved2) {
 +				ptr->is_deleted = 0;
 +				/* Found. Nothing to do. */
 +				error = 0;
-+				break;
++				goto ok;
 +			}
 +		}
-+
-+		if (ptr->next) {
-+			ptr = ptr->next;
-+			continue;
-+		}
-+
-+first_entry: ;
-+		/* Not found. Append it to the tail. */
-+		acl = tmy_alloc_element(sizeof(*acl));
-+		if (!acl)
-+			break;
-+
-+		acl->head.type = type;
-+		acl->head.cond = cond;
-+		acl->u1_is_group = is_group1;
-+		acl->u2_is_group = is_group2;
-+		acl->u1.filename1 = saved1;
-+		acl->u2.filename2 = saved2;
-+		error = tmy_add_acl(ptr, domain,
-+				    (struct acl_info *) acl);
-+		break;
 +	}
++	/* Not found. Append it to the tail. */
++	acl = tmy_alloc_element(sizeof(*acl));
++	if (!acl)
++		goto ok;
++
++	acl->head.type = type;
++	acl->head.cond = cond;
++	acl->u1_is_group = is_group1;
++	acl->u2_is_group = is_group2;
++	acl->u1.filename1 = saved1;
++	acl->u2.filename2 = saved2;
++	error = tmy_add_acl(domain,
++			    (struct acl_info *) acl);
 +	goto ok;
 +remove: ;
 +	error = -ENOENT;
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
-+		struct double_acl *acl = (struct double_acl *) ptr;
-+
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
++		acl = (struct double_acl *) ptr;
 +		if (ptr->type != type || ptr->is_deleted ||
 +		    ptr->cond != cond ||
 +		    acl->u1.filename1 != saved1 ||
 +		    acl->u2.filename2 != saved2)
 +			continue;
-+
 +		error = tmy_del_acl(ptr);
 +		break;
 +	}
-+ok: ;
-+	up(&domain_acl_lock);
++ ok: ;
++	mutex_unlock(&domain_acl_lock);
 +	return error;
 +}
 +
@@ -1219,7 +1109,7 @@
 +	if (!tmy_flags(TMY_MAC_FOR_FILE))
 +		return 0;
 +
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 +		struct single_acl *acl = (struct single_acl *) ptr;
 +
 +		if (ptr->type != type || ptr->is_deleted ||
@@ -1250,7 +1140,7 @@
 +	if (!tmy_flags(TMY_MAC_FOR_FILE))
 +		return 0;
 +
-+	for (ptr = domain->first_acl_ptr; ptr; ptr = ptr->next) {
++	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 +		struct double_acl *acl = (struct double_acl *) ptr;
 +
 +		if (ptr->type != type || ptr->is_deleted ||
@@ -1287,7 +1177,7 @@
 +{
 +	int error;
 +	struct domain_info * const domain = TMY_SECURITY->domain;
-+	const u8 is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
++	const bool is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
 +
 +	if (!tmy_flags(TMY_MAC_FOR_FILE))
 +		return 0;
@@ -1359,7 +1249,7 @@
 +	const int acc_mode = ACC_MODE(flag);
 +	int error = -ENOMEM;
 +	struct path_info *buf;
-+	const u8 is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
++	const bool is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
 +
 +	if (!tmy_flags(TMY_MAC_FOR_FILE))
 +		return 0;
@@ -1417,7 +1307,7 @@
 +	struct obj_info obj;
 +	int error = -ENOMEM;
 +	struct path_info *buf;
-+	const u8 is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
++	const bool is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
 +
 +	if (!tmy_flags(TMY_MAC_FOR_FILE))
 +		return 0;
@@ -1459,7 +1349,7 @@
 +int tmy_rewrite_perm(struct file *filp)
 +{
 +	int error = -ENOMEM;
-+	const u8 is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
++	const bool is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
 +	struct path_info *buf = tmy_get_path(filp->f_dentry, filp->f_vfsmnt);
 +
 +	if (!buf)
@@ -1505,7 +1395,7 @@
 +	struct path_info *buf1;
 +	struct path_info *buf2;
 +	struct domain_info * const domain = TMY_SECURITY->domain;
-+	const u8 is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
++	const bool is_enforce = tmy_enforce(TMY_MAC_FOR_FILE);
 +
 +	if (!tmy_flags(TMY_MAC_FOR_FILE))
 +		return 0;
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-kconfig.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-kconfig.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-kconfig.diff	(working copy)
@@ -10,9 +10,9 @@
  security/tomoyo/Makefile |    3 +++
  4 files changed, 23 insertions(+)
 
---- linux-2.6.orig/security/Kconfig	2007-10-02 11:11:53.000000000 +0900
-+++ linux-2.6/security/Kconfig	2007-10-02 11:26:21.000000000 +0900
-@@ -94,6 +94,7 @@ config SECURITY_ROOTPLUG
+--- linux-2.6.orig/security/Kconfig	2007-10-26 21:33:01.000000000 +0900
++++ linux-2.6/security/Kconfig	2007-10-26 21:33:52.000000000 +0900
+@@ -104,6 +104,7 @@ config SECURITY_ROOTPLUG
  	  If you are unsure how to answer this question, answer N.
  
  source security/selinux/Kconfig
@@ -20,8 +20,8 @@
  
  endmenu
  
---- linux-2.6.orig/security/Makefile	2007-10-02 11:11:53.000000000 +0900
-+++ linux-2.6/security/Makefile	2007-10-02 11:26:21.000000000 +0900
+--- linux-2.6.orig/security/Makefile	2007-10-11 20:45:17.000000000 +0900
++++ linux-2.6/security/Makefile	2007-10-26 21:33:52.000000000 +0900
 @@ -16,3 +16,4 @@ obj-$(CONFIG_SECURITY)			+= security.o d
  obj-$(CONFIG_SECURITY_SELINUX)		+= selinux/built-in.o
  obj-$(CONFIG_SECURITY_CAPABILITIES)	+= commoncap.o capability.o
@@ -29,7 +29,7 @@
 +obj-$(CONFIG_SECURITY_TOMOYO)       += tomoyo/
 \ No newline at end of file
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/Kconfig	2007-10-02 11:26:21.000000000 +0900
++++ linux-2.6/security/tomoyo/Kconfig	2007-10-26 21:48:02.000000000 +0900
 @@ -0,0 +1,18 @@
 +config SECURITY_TOMOYO
 +	bool "TOMOYO Linux support"
@@ -50,7 +50,7 @@
 +	  of your system, for TOMOYO uses the canonicalized absolute
 +	  pathnames and TreeView style domain transitions.
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/Makefile	2007-10-02 11:26:21.000000000 +0900
++++ linux-2.6/security/tomoyo/Makefile	2007-10-26 21:48:02.000000000 +0900
 @@ -0,0 +1,3 @@
 +obj-$(CONFIG_SECURITY_TOMOYO) += tomoyo.o tomoyo_func.o
 +tomoyo_func-objs := domain.o common.o realpath.o audit.o file.o exec.o net.o mount.o signal.o condition.o
Index: trunk/2.1.x/tomoyo-lsm/patches/tomoyo-hooks.diff
===================================================================
--- trunk/2.1.x/tomoyo-lsm/patches/tomoyo-hooks.diff	(revision 614)
+++ trunk/2.1.x/tomoyo-lsm/patches/tomoyo-hooks.diff	(working copy)
@@ -7,12 +7,12 @@
 Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 ---
- security/tomoyo/tomoyo.c |  748 +++++++++++++++++++++++++++++++++++++++++++++++
- 1 files changed, 748 insertions(+)
+ security/tomoyo/tomoyo.c |  751 +++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 751 insertions(+)
 
 --- /dev/null	1970-01-01 00:00:00.000000000 +0000
-+++ linux-2.6/security/tomoyo/tomoyo.c	2007-10-02 11:26:22.000000000 +0900
-@@ -0,0 +1,748 @@
++++ linux-2.6/security/tomoyo/tomoyo.c	2007-10-27 00:01:51.000000000 +0900
+@@ -0,0 +1,751 @@
 +/*
 + * security/tomoyo/tomoyo.c
 + *
@@ -36,8 +36,8 @@
 +#include "realpath.h"
 +#define MAX_SOCK_ADDR 128 /* net/socket.c */
 +
-+/* The initial domain. */
-+struct domain_info KERNEL_DOMAIN = { NULL, NULL, NULL, 0, 0, 0 };
++extern struct domain_info KERNEL_DOMAIN;
++LIST_HEAD(domain_list);
 +
 +static struct kmem_cache *tmy_cachep;
 +
@@ -746,7 +746,10 @@
 +
 +	printk(KERN_INFO "TOMOYO Linux initialized\n");
 +
-+	/*tmy_proc_init();*/
++	INIT_LIST_HEAD(&KERNEL_DOMAIN.list);
++	INIT_LIST_HEAD(&KERNEL_DOMAIN.acl_info_list);
++	KERNEL_DOMAIN.domainname = tmy_save_name(TMY_ROOT_NAME);
++	list_add_tail_mb(&KERNEL_DOMAIN.list, &domain_list);
 +
 +	tmy_cachep = kmem_cache_create("tomoyo_security",
 +				       sizeof(struct tmy_security),
