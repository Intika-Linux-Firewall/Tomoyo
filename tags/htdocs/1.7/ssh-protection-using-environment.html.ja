<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>環境変数を用いた SSH サービスのブルートフォース対策</title>
<link rel="stylesheet" href="https://tomoyo.osdn.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<p>Info: Version <a href="../1.8/">1.8.x</a> is available.</p>
<p style="text-align:right;"><a href="ssh-protection-using-environment.html.en">English Page</a></p>
<p style="text-align:right;">Last modified: $Date$</p>
<h1>環境変数を用いた SSH サービスのブルートフォース対策</h1>

<h2>概要</h2>

<p><object data="http://www.youtube.com/v/-2AQSqNa58c&amp;hl=en_US&amp;fs=1" type="application/x-shockwave-flash" width="425" height="344"><param name="movie" value="http://www.youtube.com/v/-2AQSqNa58c&amp;hl=en_US&amp;fs=1"><param name="allowFullScreen" value="true"><param name="allowscriptaccess" value="always"></object></p>

<p>このページでは、ＳＳＨサーバからログインシェルが実行される時に環境変数を用いた追加のユーザ認証を行うことにより、ブルートフォース対策を行う手順について紹介します。</p>

<p>システムのユーザ認証で使うパスワードがブルートフォース攻撃により割り出されてしまっても、もう１つのパスワードとして環境変数名とその値の両方が割り出されない限り、ログインシェルが実行されることがありません。</p>

<p>従来のブルートフォース対策は、認証が失敗したＩＰアドレスからの接続を一定時間拒否するという方法のため、多数のＩＰアドレスに分散されると防ぎきれない場合があります。この方法は２段階に分けているので、第１段階が突破されたとしても被害を防ぐことが可能です。また、第２段階での認証の自由度が高く認証方式も秘密にできるのでブルートフォース攻撃を仕掛けることが困難です。</p>

<hr>

<h2>ステップ１：ソースコードのコンパイル</h2>

<p>パスワードとして使用する環境変数の名前と値を決めます。このページでは、環境変数名として CERBERUS を、値として sftp を使用します。また、コンパイルされたプログラムの名前を /bin/env_chk とします。また、ＳＳＨサーバのパス名を /usr/sbin/sshd とします。</p>

<p>以下のソースコードの SECRET_ENVIRONMENT に環境変数名と値を、 SSHD_EXECUTABLE_PATH にＳＳＨサーバへのパス名を設定し、コンパイルします。</p>

<table border="1">
<tr><td><pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;syslog.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

#define SECRET_ENVIRONMENT "CERBERUS=sftp"
#define SSHD_EXECUTABLE_PATH "/usr/sbin/sshd"

int main(int raw_argc, char *raw_argv[])
{
	int i;
	int argc;
	int envc;
	char *filename;
	char **argv;
	char **envp;
	{ /* Check that I'm an execute handler process.  */
		int fd = open("/proc/ccs/.execute_handler", O_RDONLY);
		close(fd);
		if (fd == EOF) {
			fprintf(stderr, "FATAL: I'm not execute_handler.\n");
			return 1;
		}
	}
	if (raw_argc &lt; 7)
		return 1;
	filename = raw_argv[4];
	argc = atoi(raw_argv[5]);
	envc = atoi(raw_argv[6]);
	if (raw_argc != argc + envc + 7)
		return 1;
	for (i = 5; i &lt; argc + 5; i++)
		raw_argv[i] = raw_argv[i + 2];
	raw_argv[argc + 5] = NULL;
	for (i = argc + 6; i &lt; argc + envc + 6; i++)
		raw_argv[i] = raw_argv[i + 1];
	raw_argv[argc + envc + 6] = NULL;
	argv = raw_argv + 5;
	envp = raw_argv + argc + 6;
	/* "/usr/sbin/sshd" executes "/usr/sbin/sshd" with "-R" option. */
	if (argc == 2 &amp;&amp; !strcmp(argv[1], "-R") &amp;&amp;
	    !strcmp(raw_argv[2], SSHD_EXECUTABLE_PATH) &amp;&amp;
	    !strcmp(filename, SSHD_EXECUTABLE_PATH)) {
		execve(filename, argv, envp);
		return 1;
	}
	/*
	 * Check environment variables passed to execve() request
	 * and execute the program if it has SECRET_ENVIRONMENT environment.
	 */
	for (i = 0; i &lt; envc; i++) {
		if (strcmp(envp[i], SECRET_ENVIRONMENT))
			continue;
		while (i &lt; envc) {
			envp[i] = envp[i + 1];
			i++;
		}
		execve(filename, argv, envp);
		break;
	}
	return 1;
}
</pre></td></tr>
</table>

<h2>ステップ２：環境変数を渡すための設定</h2>

<p>サーバ側の /etc/ssh/sshd_config の末尾に環境変数名を指定します。</p>

<table border="1">
<tr><td>
AcceptEnv CERBERUS
</td></tr>
</table>

<p>クライアント側の /etc/ssh/ssh_config の末尾に環境変数名を指定します。</p>

<table border="1">
<tr><td>
SendEnv CERBERUS
</td></tr>
</table>

<h2>ステップ３： TOMOYO Linux のインストールと初期化</h2>

<p><a href="install.html.ja">TOMOYO Linux をインストール</a>してから、以下のコマンドを実行して初期設定を行ってください。</p>

<table border="1">
<tr><td>
/usr/lib/ccs/init_policy
</td></tr>
</table>

<p>その後、 TOMOYO Linux カーネルで再起動する前に以下の操作を行ってください。</p>

<p>/usr/sbin/sshd が実行された場合にはドメイン遷移が初期化されるようにするために、 /etc/ccs/exception_policy.conf に以下の内容を追加します。</p>

<table border="1">
<tr><td>
initialize_domain /usr/sbin/sshd
</td></tr>
</table>

<p>/usr/sbin/sshd からのプログラムの実行要求が /bin/env_chk に渡されるようにするために、 /etc/ccs/domain_policy.conf に以下の内容を追加します。</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
execute_handler /bin/env_chk
</td></tr>
</table>

<h2>ステップ４：運用</h2>

<p>以上で設定は完了です。 TOMOYO Linux カーネルで再起動してください。</p>

<p>クライアント側から sftp でサーバ側にアクセスし、すぐに切断されることを確認してください。</p>

<p>クライアント側で環境変数 CERBERUS=sftp を設定してください。</p>

<p>クライアント側から sftp でサーバ側にアクセスし、操作が行えることを確認してください。</p>

<h2>説明</h2>

<p>TOMOYO Linux の execute_handler 機能が /usr/sbin/sshd からのプログラムの実行要求を横取りして、 /bin/env_chk に渡しています。 /bin/env_chk がプログラムの実行要求に渡されたパラメータの検査を行い、適切であると判断した場合には要求されたプログラムを実行します。</p>

<p>システムのユーザ認証を通過後なので、シェルの実行要求を伴わないＳＳＨの機能は許可されています。ポートフォワーディングの制限やシェルセッションの制限なども行いたい場合は、通常通り学習モードで動作を学習させて、強制モードで動作を制限してやる必要があります。</p>

<h2>応用</h2>

<p>冒頭の動画では sftp を実行するために ssh ログインをしているため、パスワードとして sftp を指定しています。パスワードは固定されている必要は無く、パスワードの内容に応じて異なる動作をさせることもできます。例えば、 ssh_type=ro-sftp の場合はダウンロード専用の sftp サービス、 ssh_type=rw-sftp の場合はアップロードも可能な sftp サービスとして動作させることができます。</p>

<p>また、プログラム実行時のパラメータが渡されるので、その内容を記録に残すことができます。例えば、ＳＳＨセッションで実行されたプログラムと引数や環境変数などの情報を取得することができます。</p>

<hr>

<p><a href="index.html.ja">目次へ戻る</a></p>
<p><a href="https://osdn.jp/"><img src="https://osdn.jp/sflogo.php?group_id=1973" width="96" height="31" alt="sflogo.php" title="SourceForge.jp"></a></p>
</body>
</html>
