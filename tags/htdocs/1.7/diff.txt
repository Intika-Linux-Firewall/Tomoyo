Index: tutorial-10.html.ja
===================================================================
--- tutorial-10.html.ja	(revision 3668)
+++ tutorial-10.html.ja	(working copy)
@@ -3,7 +3,7 @@
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <meta http-equiv="Content-Style-Type" content="text/css">
-<title>TOMOYO Linuxの世界　第１０回：「ログインセッションを制限してみよう（前編）」</title>
+<title>TOMOYO Linuxの世界　第１０回：「blogのポリシーを作成してみよう（前編）」</title>
 <link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
 </head>
 <body>
@@ -11,373 +11,483 @@
 <p style="text-align:right;"><a href="tutorial-10.html.en">English Page</a></p>
 <p style="text-align:right;">Last modified: $Date$</p>
 -->
+<h1>TOMOYO Linuxの世界<br>第１０回：「blogのポリシーを作成してみよう（前編）」</h1>
 
-<h1>TOMOYO Linuxの世界<br>第１０回：「ログインセッションを制限してみよう（前編）」</h1>
-
-<p>今回は，さらに実践的なTOMOYO Linuxの設定方法として，システムへのログイン後にユーザが行う操作を制限する手順を解説します．</p>
-
 <h2>今回の内容</h2>
 
-<p>今回はTOMOYO Linux 1.7.2の機能をフルに活用して，システムにログイン後行う操作を制限する方法について解説します．</p>
+<p>今回は実際のシステムに近い形でTOMOYO Linuxを用いたシステム構築手順について紹介しようと思います．環境としては，CentOS 5.5上でMovableType 3.3を動作させることにします．</p>
 
-<p>SELinuxでは現在reference policyへの移行が進行中ですが，これまではログインセッションを含めてすべてのプロセスに対して強制アクセス制御を適用するstrictポリシーと，攻撃を受けやすいサービスに対してだけ強制アクセス制御を適用するtargetedポリシーの2種類がデフォルトポリシーとして提供されていました． 「セキュリティの強化」という観点からは，文字通り厳格なstrictポリシーのほうが効果が高いわけですが，制限の内容を間違えるとログインすらできなくなるなどの問題もあり，SELinuxを有効にしているユーザの多くはtargetedポリシーをベースにカスタマイズしているケースが多いのではないかと思われます． Russell Coker氏やLKMLでのSELinux関係者の発言によると，SELinux陣営には， 「SELinuxのポリシーの内容を理解できないシステム管理者はポリシーを修正すべきではない．我々プロが作成したポリシーをそのまま使いなさい」という考え方があります．これに対して， 「システム管理者自身がポリシーを作成する」TOMOYO Linuxは，まっこうから考え方が異なっています．これに関連した議論の一部は，<a href="http://slashdot.jp/linux/article.pl?sid=07/06/07/1211201">http://slashdot.jp/linux/article.pl?sid=07/06/07/1211201</a>から辿ることができます．読者のみなさんはどのように考えられますでしょうか．</p>
+<h3>MovableTypeのインストール</h3>
 
-<p>さて，この連載はTOMOYO Linuxの連載なので，ポリシーを自分で作ることができるTOMOYO Linuxを使って，ログインして行う操作の制限を行ってみることにしましょう．</p>
+<p>CentOS 5.5にMovableTypeをインストールするところから始めます．TOMOYO Linuxの設定は含まれませんので，すでにMovableTypeを導入済みの方は次の項目へ飛んでください．なお，MovableTypeのインストールについて，本稿では最低限の内容しか触れません．詳細については，<a href="http://www.sixapart.jp/movabletype/manual/3.3/">オンラインドキュメントの「システム管理者ガイド」</a>などを参照してください．</p>
 
-<h2>ログインセッションを制御してみよう</h2>
+<h3>Apache のインストール</h3>
 
-<h3>ログインセッションを制御する理由</h3>
+<p>まず，Apacheをインストールします．rootユーザとしてログインし，図1のコマンドを実行してください．</p>
 
-<p>Linuxをサーバとして利用する場合，ユーザがシステムにログインしてからの操作を制限したいと思う場合があるでしょう．たとえば， 「システム管理者が顧客情報の格納されたデータベースファイルを持ち出すのを禁止したい」とか「システムにログインしたユーザに対してパスワードの変更だけを許可したい」とか「Webサーバの再起動とWebコンテンツの更新だけを社外に委託したい（それ以外の操作は行えないようにしたい） 」などなど．他にも， 「システムにログインしたユーザが他人のパスワードを盗聴するためのバックドアを仕掛けるのを阻止したい」とか「インターネットから社内ネットワークにアクセスするためのゲートウェイサーバとして使いたい」という要求もあるかもしれません．プロセスの起動履歴ごとにドメインを管理するTOMOYO Linuxを使えば，このような要求に対応するのは簡単です．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図1 Apacheのインストール
+<pre>
+# yum install httpd
+</pre>
+</td></tr>
+</table>
 
-<h3>基本手順</h3>
+<p>iptablesを有効にしている場合，設定が不適切だとApacheに接続できなくなります．図2のコマンドを実行して， ［Firewall Configuration］→［Customize］から［WWW (HTTP)］にチェックがされていることを確認してください．</p>
 
-<p>ログインセッションを保護するための手順は大きく分けて4つあります．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図2 firstbootコマンドの実行
+<pre>
+# /usr/sbin/firstboot --reconfig
+</pre>
+</td></tr>
+</table>
 
-<ol>
-<li>まず，ログインセッションで実行を許可するコマンドを決定します（たとえば，ファイルの内容を閲覧するために/bin/catの実行を許可したり，パスワードの変更を行うために/usr/bin/passwdの実行を許可したりするなど） ．</li>
-<li>次に，ログインセッションでアクセスを許可したいファイルを決定します（たとえば，原則としてホームディレクトリ以下のファイルのみ読み書きを許可するなど） ．</li>
-<li>次に，ログインセッションで通信を許可したいネットワークを決定します（たとえば，DNSサーバ，HTTPサーバ，FTPサーバ，SSHサーバとだけ通信を許可するなど） ．</li>
-<li>以上の作業で決定したアクセス許可をあらかじめ与えたうえで，実際に学習モードを用いて不足しているアクセス許可を追加していきます．</li>
-</ol>
+<h3>MovableType のインストール</h3>
 
-<p>以上の手順で登場するキーワードを図1に示します．</p>
+<p>本稿では図3のディレクトリ構成で使用します．データベースにはBERKELEYDBを使用します．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図1 使用するキーワード<br>
+■図3 本稿で使用するディレクトリ構成<br>
 <table border="1" summary="fig">
-<tr><td>キーワード</td><td>意味</td></tr>
-<tr><td>path_group</td><td>プログラムファイルやホームディレクトリ以下のファイルをグループ化する</td></tr>
-<tr><td>keep_domain</td><td>ドメイン遷移を抑制する</td></tr>
-<tr><td>no_keep_domain</td><td>ドメイン遷移を再開する</td></tr>
-<tr><td>exec.argv[0]</td><td>シンボリックリンク経由の不正アクセスを防ぐ</td></tr>
-<tr><td>address_group</td><td>ネットワークアドレスをグループ化する</td></tr>
-<tr><td>if</td><td>自分が所有しているファイルへのアクセスのみを認める</td></tr>
+<tr><td>用途</td><td>ディレクトリ</td></tr>
+<tr><td>アプリケーションディレクトリ</td><td>/var/www/cgi-bin/mt/</td></tr>
+<tr><td>スタティックディレクトリ</td><td>/var/www/html/mt-static/</td></tr>
+<tr><td>blogディレクトリ</td><td>/var/www/html/blog/</td></tr>
+<tr><td>データベースディレクトリ</td><td>/var/www/mt-db/</td></tr>
+<tr><td>テンポラリディレクトリ</td><td>/var/www/mt-tmp/</td></tr>
 </table>
 </td></tr>
 </table>
 
-<h2>ステップ1：実行可能なコマンドの決定</h2>
+<p>MovableType 3.3をダウンロードしてインストールします．本稿ではMT-3_36-ja.zipを使用します．図4の内容を実行します．</p>
 
-<h3>実行を許可するプログラムの決定</h3>
+<table border="1" summary="fig">
+<tr><td>
+■図4 MovableType 3.3のインストール
+<pre>
+# cd /var/www/cgi-bin/
+# unzip MT-3_36-ja.zip
+# mv MT-3.36-ja mt
+# cd mt/
+# mv mt-static /var/www/html/
+# mkdir /var/www/html/blog /var/www/mt-db /var/www/mt-tmp
+# chown apache:apache /var/www/html/blog/ /var/www/mt-db/ /var/www/mt-tmp/
+# cp -p mt-config.cgi-original mt-config.cgi
+</pre>
+</td></tr>
+</table>
 
-<p>システムにログインしたユーザが悪意あるプログラムを実行できないようにするには，あらかじめシステムにインストールされているプログラム以外の実行を禁止するのが効果的です．この連載では，システムにすでにインストールされているプログラムの内，ログインセッションにおいて図2のコマンドの実行だけを許可するものとします．</p>
+<p>次に，mt-config.cgiを編集します．/var/www/cgi-bin/mt/mt-config.cgiをエディタで開き，www.example.comとなっている箇所（2ヵ所）を実際のサーバ名（本稿ではyourserverと表記します）に置き換えてください（図5） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図2 実行を許可するコマンド<br>
-<table border="1" summary="fig">
-<tr><td>/bin/basename /bin/bash /bin/cat /bin/egrep /bin/grep /bin/hostname /bin/ln /bin/ls /bin/mkdir /bin/mv /bin/rm /bin/rmdir /bin/sed /bin/touch /sbin/consoletype /usr/bin/clear /usr/bin/dircolors /usr/bin/emacs /usr/bin/id /usr/bin/passwd /usr/bin/perl /usr/bin/ssh /usr/bin/ssh-keygen /usr/bin/wget /usr/bin/which</td></tr>
-</table>
+■図5 /var/www/cgi-bin/mt/mt-config.cgiの変更箇所
+<pre>
+[修正前]
+CGIPath http://www.example.com/cgi-bin/mt/
+StaticWebPath http://www.example.com/mt-static
+[修正後]
+CGIPath http://yourserver/cgi-bin/mt/
+StaticWebPath http://yourserver/mt-static
+</pre>
 </td></tr>
 </table>
 
-<p>これらのコマンドをpath_groupとして例外ポリシーに登録しておきましょう（図3） ．</p>
+<p>「##### MYSQL #####」 「##### POSTGRESQL#####」 「##### SQLITE #####」のセクションは不要なので削除します． 「##### BERKELEYDB #####」セクションではDataSourceという箇所を実際のパス名（/var/www/mt-db）に置き換えてください（図6） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図3 実行を許可するコマンドをグループ化
+■図6 DataSourceを変更（/var/www/cgi-bin/mt/mt-config.cgi）
 <pre>
-path_group COMMANDS_FOR_LOGIN_SESSION /bin/basename
-path_group COMMANDS_FOR_LOGIN_SESSION /bin/bash
-（中略）
-path_group COMMANDS_FOR_LOGIN_SESSION /usr/bin/wget
-path_group COMMANDS_FOR_LOGIN_SESSION /usr/bin/which
+[修正前]
+DataSource /path/to/database/directory
+[修正後]
+DataSource /var/www/mt-db
 </pre>
 </td></tr>
 </table>
 
-<p>コマンドの所在（パス）を確認するにはwhichやtypeなどのコマンドを使います（図4） ．</p>
+<p>また，図7の内容を追加します．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図4 コマンドの所在を確認する
+■図7 /var/www/cgi-bin/mt/mt-config.cgiに追加する内容
 <pre>
-# which perl sed grep
-/usr/bin/perl
-/bin/sed
-/bin/grep
+DBUmask 0077
+HTMLUmask 0077
+UploadUmask 0077
+DirUmask 0077
+TempDir /var/www/mt-tmp
 </pre>
 </td></tr>
 </table>
 
-<p>「/sbin/consoletypeや/usr/bin/dircolorsなども許可する必要があるの？」と思われるかも知れませんが，シェルを起動したときに自動実行されるスクリプト（/bin/bashの場合は~/.bashrc）によって利用者が意識していない場所で多くのコマンドが実行されています．それらの内容を知るためには，TOMOYO Linuxカーネルで動作しているシステムで「ログイン」してすぐに「ログアウト」してください．そうすることで，ログインシェルの子ドメインという形でどのようなコマンドが実行されたのかを知ることができます．さらに，CONFIG::file={ mode=learning } （学習モード）が指定されたプロファイルをログインシェルのドメインに割り当てた状態で実行すれば，プログラムの実行だけでなくアクセスされたファイルも知ることができます．</p>
+<p>apacheユーザの権限で実行するのでファイル作成時には所有者のみがアクセスできるようにしておくことができます．テンポラリディレクトリは TempDirキーワードを用いて指示します．</p>
 
-<h3>ドメイン遷移の設計</h3>
+<h3>MovableType の初期化</h3>
 
-<p>これまでの連載で説明してきたようにTOMOYO Linuxでは，原則としてコマンドを実行するたびにドメイン遷移を行う仕様となっています．そのため，たとえば図5の場合は/bin/catはシェルの子ドメインとして動作しますが，図6の場合は/bin/catは/usr/bin/xargsの子ドメインとして動作します．</p>
+<p>Apacheをスタートさせます（図8） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図5 シェルから/bin/catを実行
+■図8 Apacheの起動
 <pre>
-# /bin/cat /etc/*.conf
+# service httpd start
 </pre>
-</td><td>
-■図6 xargsから/bin/catを実行
-<pre>
-# echo /etc/*.conf | xargs /bin/cat --
-</pre>
 </td></tr>
 </table>
 
-<p>しかし，この場合はどちらも同じドメインで動作してくれたほうがユーザとしては使い勝手が良く，まとめたとしてもとくにセキュリティ上の問題はなさそうですね．ログインセッションでは，どのようなコマンドをどのような順序で実行するかを予測することが困難であるため，原則としてドメイン遷移は行いません．ログインシェルを/bin/bashと仮定した場合，sshdからログインしたシェルのドメインは&lt;kernel&gt; /usr/sbin/sshd /bin/bashとなるので，例外ポリシーに「keep_domain &lt;kernel&gt; /usr/sbin/sshd /bin/bash」という指定を行うことでドメイン遷移を抑制します．しかし，パスワードを格納している/etc/shadowのように，/bin/catコマンドなどで閲覧されるのは困るが，パスワードを変更する/usr /bin/passwdコマンドがアクセスできないのも困るという場合があります．そのような場合は，例外ポリシーに「no_keep_domain /usr/bin/passwd from &lt;kernel&gt; /usr/sbin/sshd /bin/bash」という指定を行うことで，/usr/bin/passwdコマンドを &lt;kernel&gt; /usr/sbin/sshd /bin/bash /usr/bin/passwdドメインで実行させることができます．同様に，sshの秘密鍵などを格納している~/.ssh/ディレクトリのファイルのように，/bin/catコマンドなどで閲覧されては困るが，ssh接続を行う/usr/bin/sshコマンドがアクセスできないのも困るので，例外ポリシーに「no_keep_domain /usr/bin/ssh from &lt;kernel&gt; /usr/sbin/sshd /bin/bash」という指定を行うことで，sshコマンドを別のドメインで実行させることができます．</p>
+<p>Webブラウザを使って http://yourserver/cgi-bin/mt/mt-check.cgi を表示し，MovableTypeの実行に必要なプログラムが揃っていることを確認します．</p>
 
-<h3>プログラムの起動方法による振る舞いの変化について</h3>
+<p>「MovableTypeのシステム・チェックは，無事に完了しました． 」という表示を確認したら， http://yourserver/cgi-bin/mt/mt.cgi にアクセスしてmt.cgiを実行します．</p>
 
-<p>ちょっと横道に逸れますが，ここでアクセス制御を行う場合に注意すべき点として，プログラムの起動方法による振る舞いの変化について触れておきたいと思います．システム（TOMOYO Linuxカーネルで動作しているシステムである必要はありません）にログインして，図7のプログラムを/tmp/argv0.cという名前で保存してください．</p>
+<p>この画面でMovableTypeのシステム管理者を登録してから，ログインしてください．ログイン後は， ［First Weblog］→［設定］→［サイトＵＲＬ／パス］の順に選択して，サイトURLとサイトパスを図9のように設定してください．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図7 起動方法を表示するＣプログラム
+■図9 サイトURLとサイトパスの設定<br>
+<table border="1" summary="fig">
+<tr><td>設定項目</td><td>設定内容</td></tr>
+<tr><td>サイトURL</td><td>http://yourserver/blog/</td></tr>
+<tr><td>サイトパス</td><td>/var/www/html/blog</td></tr>
+</table>
+</td></tr>
+</table>
+
+<p>その後， ［変更を保存］を選択し， ［サイトを再構築］→［再構築］の順に選択してください．以上でMovableTypeのインストールは完了です．</p>
+
+<h2>TOMOYO Linuxのインストール</h2>
+
+<p>では，いよいよTOMOYO Linuxをインストールしてみることにしましょう．この連載では，2010年4月1日にリリースされたバージョン1.7.2を用います．</p>
+
+
+<h3>プログラムのインストール</h3>
+
+<p>CentOS 5.5用のコンパイル済みパッケージをダウンロードしインストールします（図10） ．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図10 TOMOYO Linux 1.7.2のインストール
 <pre>
-#include &lt;stdio.h&gt;
-int main(int argc, char *argv[])
-{
-        printf("I am running as %s\n", argv[0]);
-        return 0;
-}
+# wget -O /tmp/key 'http://pgp.nic.ad.jp/pks/lookup?op=get&amp;search=0x4B975A98'
+# rpm --import /tmp/key
+# wget -O /etc/yum.repos.d/ccs.repo http://tomoyo.sourceforge.jp/repos-1.7/CentOS5/ccs.repo
+# yum install ccs-kernel
 </pre>
 </td></tr>
 </table>
 
-<p>その後，図8のようにコンパイルしておよびシンボリックリンク（またはハードリンク）を作成してください．</p>
+<p>利用可能な最新のカーネルは<a href="http://tomoyo.sourceforge.jp/1.7/install.html#install_from_repository">バイナリパッケージをインストール</a>を参照ください．</p>
 
+<p>次にツールをインストールします．（図11） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図8 コンパイルしてシンボリックリンクを作成するする
+■図11 ツールをインストール
 <pre>
-# gcc -o /tmp/argv0 /tmp/argv0.c
-# ln -s /tmp/argv0 /tmp/cat
-# ln -s /tmp/argv0 /tmp/passwd
+# yum install ccs-tools
 </pre>
 </td></tr>
 </table>
 
-<p>そして，そのシンボリックリンク（またはハードリンク）を実行してください．すると，シンボリックリンクの名前が表示されます（図9） ．</p>
+<p>TOMOYO Linuxのユーティリティを保存してある場所を環境変数PATHに追加しておきます．bashを使っている場合は~/.bashrcに図12の行を追加します．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図9 シンボリックリンク経由で起動する
+■図12 環境変数PATHの設定
 <pre>
-# /tmp/cat
-I am running as /tmp/cat
-# /tmp/passwd
-I am running as /tmp/passwd
+export PATH=$PATH:/usr/sbin
 </pre>
 </td></tr>
 </table>
 
-<p>一部のコマンドは，そのコマンドが起動されたときの「名前（argv[0]と呼ばれているものです） 」によって振る舞いを変えるように作られています．たとえば，CentOS 5.5において，/sbin/pidofは/sbin/killall5へのシンボリックリンクであり，pidofという名前で起動された場合には指定されたプログラムのプロセスIDを表示し，killall5という名前で起動された場合には自分のセッション以外のすべてのプロセスにシグナルを送信します．</p>
+<h3>ポリシーの初期化</h3>
 
-<p>TOMOYO Linuxでは/tmp/catを実行すれば/tmp/catのドメインで動作し，/tmp/passwdを実行すれば/tmp/passwdのドメインで動作します．では，図10のように/tmp/catという名前で/tmp/passwdを実行した場合には，どのようになるでしょうか？（結果を予想してみてください）</p>
+<p>init_policyによりポリシーファイルを初期化します（図13） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図10 passwdコマンドをcatという名前で実行する
+■図13 ポリシーファイルを初期化
 <pre>
-# sh -c 'exec -a /tmp/cat /tmp/passwd'
+# /usr/lib/ccs/init_policy
 </pre>
 </td></tr>
 </table>
 
-<p>図10の実行結果は図11となります．このことから，図10を認めることは図12を認めることと同じです．ただし，図12は/tmp/catドメインで/tmp/catとして動作するのを認めているのに対して，図10は/tmp/passwdドメインで/tmp/catとして動作することを認めているという点に注意してください．</p>
+<p>このプログラムはポリシーファイルが存在する場合は何もしないので，すでに/etc/ccs/ディレクトリが存在する場合には/etc/ccs/ディレクトリをどこかに移動してから実行してください． init_policyの実行により，/etc/ccs/ディレクトリに図14の5つのファイルが作成されます．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図11 catコマンドとして動作する
+■図14 init_policyによって作成されるファイル<br>
+<table border="1" summary="fig">
+<tr><td>ファイル名</td><td>役割</td></tr>
+<tr><td>exception_policy.conf</td><td>例外ポリシー</td></tr>
+<tr><td>domain_policy.conf</td><td>ドメインポリシー</td></tr>
+<tr><td>manager.conf</td><td>マネージャーポリシー</td></tr>
+<tr><td>profile.conf</td><td>プロファイル</td></tr>
+<tr><td>meminfo.conf</td><td>メモリ使用量制限</td></tr>
+</table>
+</td></tr>
+</table>
+
+<p>exception_policy.confは「例外ポリシー」と呼ばれ，パス名のグループを定義したりドメイン遷移を制御したりするために使われます． domain_policy.confは「ドメインポリシー」と呼ばれ，ドメイン単位でアクセスを制御するために使われます． manager.confは「マネージャーポリシー」と呼ばれ，/proc/ccs/ディレクトリ経由でポリシーの更新を許可するプログラムやドメインを指定するために使われます． profile.confは「プロファイル」と呼ばれ，アクセス制御の方法(どの機能を有効にするか)を指定するために使われます．行頭の数字はプロファイル番号で， 「0-」で始まる行は要求された内容をチェックしないで許可する「無効モード」 ， 「1-」で始まる行は要求された内容を記録に残してから許可する「学習モード」 ， 「2-」で始まる行は要求された内容をチェックするが拒否はしない「確認モード」 ， 「3-」で始まる行は要求された内容をチェックして許可されていない場合には拒否する「強制モード」用として使います．この連載では，すべてのアクセス制御を有効にしたプロファイルを用いますが，難しいと感じたらファイルに関するアクセス制御以外は無効（CONFIG= という部分を CONFIG::file= に書き換える）にしてもかまいません．</p>
+
+<h2>学習の開始</h2>
+
+<h3>システムの再起動</h3>
+
+<p>ここまで準備ができたら，システムをリブートします．GRUBのメニューではTOMOYO Linuxカーネルを選択してください．</p>
+
+<h3>学習モードに切り替える</h3>
+
+<p>Apache をスタートさせます（図15） ．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図15 Apacheの起動
 <pre>
-I am running as /tmp/cat
+# service httpd start
 </pre>
 </td></tr>
 </table>
 
+<p>ポリシーエディタを起動してください（図16） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図12 図10がもたらす結果
+■図16 ポリシーエディタの起動
 <pre>
-# sh -c 'exec /tmp/cat'
+# /usr/sbin/ccs-editpolicy
 </pre>
 </td></tr>
 </table>
 
-<p>/usr/bin/passwdコマンドと/bin/catコマンドが/sbin/busyboxのハードリンクまたはシンボリックリンクとして提供されていると仮定します．この場合，TOMOYO Linuxでは/bin/catを実行すれば/bin/catのドメインで動作し，/usr/bin/passwdを実行すれば/usr/bin/passwdのドメインで動作します．パスワードを変更するための/usr/bin/passwdドメインには/etc/shadowへのアクセスを認める必要がありますが，ファイルの内容を表示するための/bin/catドメインには/etc/shadowへのアクセスを認めたくありません．</p>
+<p>すると「&lt;&lt;&lt; Domain Transition Editor &gt;&gt;&gt;」という画面が表示され，ドメイン遷移の一覧が表示されます．行番号の右には各ドメインのモード（プロファイル番号）が表示されています．「&lt;kernel&gt; /usr/sbin/httpd」というドメインにカーソルを合わせて，「S」を押してから学習モードに対応するプロファイルの番号「1」を入力して「ENTER」を押します（図17） ．</p>
 
-<p>図13のように/bin/catという名前で/usr/bin/passwdを実行した場合には，どのようになるでしょうか？</p>
+<table border="1" summary="fig">
+<tr><td>
+■図17 &lt;kernel&gt; /usr/sbin/httpdドメインを学習モードにする<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig12.png" alt="sd200708-fig12.png">
+</td></tr>
+</table>
 
+<p>これにより，&lt;kernel&gt; /usr/sbin/httpdドメインが学習モードになり，今後&lt;kernel&gt; /usr/sbin/httpdによって新規作成されるドメインも学習モードになります．</p>
+
+<h3>アクセス許可を学習させる</h3>
+
+<p>Apacheを再起動させます（図18） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図13 passwdコマンドをcatという名前で実行する
+■図18 Apacheの再起動
 <pre>
-# sh -c 'exec -a /bin/cat /usr/bin/passwd /etc/shadow'
+# service httpd restart
 </pre>
 </td></tr>
 </table>
 
-<p>図13を実行すると，/usr/bin/passwdは/usr/bin/passwdドメインで動作します．しかし，起動時の名前が/bin/catであったため，その振る舞いは/bin/catとなります．結果として図14のような振る舞いを許可してしまったことになります．</p>
+<p>これにより，Apacheの起動と終了に必要なアクセス許可が学習されます．その後， http://yourserver/cgi-bin/mt/mt.cgi にアクセスしてmt.cgiを実行します．</p>
 
+<p>MovableTypeにログインし，エントリを投稿したりページを再構築したりトラックバックを受け付けるなどの操作を行います．TOMOYO Linuxは操作に対する要求に応えながら，それに必要なアクセス許可内容を学習します．ポリシーは後から確認，追加できますが，初期の自動学習で多くの機能を実行させておくと全体の作業がスムーズに進みます．MovableTypeのように複雑なものでは少し難しいですが，あらかじめ試験項目を作成しておくと良いでしょう．</p>
+
+<h3>アクセス許可を確認する </h3>
+
+<p>ひととおり学習したら，ccs-editpolicyで学習結果を確認してみましょう．図19のようなドメインが作成されているはずです（操作内容や設定内容により異なる場合があります．）．ApacheからMovable TypeのCGIが呼ばれ，そこからいくつかの外部プログラムが呼ばれていることがわかります．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図14 パスワードファイルを閲覧できる
+■図19 ドメインの学習結果<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig14.png" alt="sd200708-fig14.png">
+</td></tr>
+</table>
+
+<h3>パス名のグループ化</h3>
+
+<p>「&lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt.cgi」ドメインにカーソルを合わせて「ENTER」を押すと，&lt;&lt;&lt; Domain Policy Editor &gt;&gt;&gt;という画面に移動します．その画面をスクロールしてみると，図20のようなエントリが見つかるはずです．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図20 作成されたポリシーの内容（一部）
 <pre>
-# sh -c 'exec /bin/cat /etc/shadow'
+allow_read /var/www/cgi-bin/mt/extlib/CGI.pm
+allow_read /var/www/cgi-bin/mt/extlib/CGI/Cookie.pm
+allow_read /var/www/cgi-bin/mt/extlib/CGI/Util.pm
+（中略）
+allow_read /var/www/cgi-bin/mt/lib/MT/Trackback.pm
+allow_read /var/www/cgi-bin/mt/lib/MT/Util.pm
+allow_read /var/www/cgi-bin/mt/lib/MT/WeblogPublisher.pm
 </pre>
 </td></tr>
 </table>
 
-<p>このような脅威を防ぐために，TOMOYO Linuxではプログラムのパス名とargv[0]の組み合わせをチェックする機能を備えています．図13のような脅威も/usr/bin/passwdコマンドを/bin/catという名前で起動することを禁止することで防ぐことができるようになります．実は，前回示したMovable Typeのポリシーの中にもallow_execute /usr/sbin/sendmail.sendmail if exec.argv[0]="sendmail"というアクセス許可がありました．これは，/usr/sbin/sendmail.sendmailコマンドをsendmailという名前で起動することを許可するという意味です．図2で指定しているプログラムの中に図13のような指定をされると困るプログラムが含まれている場合には，そのプログラムはpath_groupから除外し，allow_execute /usr/bin/passwd if exec.argv[0]="passwd"のように個別に指定するようにしてください．</p>
+<p>もちろん，ここまでの内容で作成したポリシーでも運用は可能ですが，実際のシステム運用ではポリシーを整理してから行います．今度はその手順を紹介します．さきほど確認したmt.cgiドメインの学習結果を見ると，多数のPerlモジュールにアクセスしていることがわかります．そこでまず，これらの Perlモジュールへのパス名を“MT-LIB”という名前でグループ化することにします．グループ化をすると，対象となるパス名をまとめて扱えるのでポリシーがコンパクトで見通しやすくなります．</p>
 
-<h2>ステップ2：読み書きを許可するファイルの決定</h2>
+<p>ccs-editpolicyで，「TAB」を押して&lt;&lt;&lt; ExceptionPolicy Editor &gt;&gt;&gt;という画面に移動してから図21の内容の指定を追加してください．</p>
 
-<h3>ハードリンクの脅威と対策</h3>
-
-<p>TOMOYO Linuxではハードリンクの作成時には「リンク元のパス名／リンク先のパス名」をペアにして，名前の変更時には「変更前のパス名／変更後のパス名」をペアにしてアクセス許可のチェックを行っています．その理由について触れておきます．システム（TOMOYO Linuxカーネルで動作しているシステムである必要はありません）にログインして，図15の操作を試してみてください（/etc/ディレクトリと /tmp/ディレクトリが別のパーティションになっているシステムでは失敗します．その場合，/etc/ディレクトリと同じパーティションにある /root/ディレクトリなどに読み替えてください） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図15 ハードリンク経由でパスワードファイルにアクセスする
+■図21 パス名をグループ化するための設定内容
 <pre>
-# ln /etc/shadow /tmp/shadow
-# cat /tmp/shadow
+path_group MT-LIB /var/www/cgi-bin/mt/\{\*\}/\@.pm
 </pre>
 </td></tr>
 </table>
 
-<p>これは，ログインパスワードを格納している/etc/shadowというファイルを/tmp/ディレクトリの下にハードリンクすることで，/tmp /shadowというパス名を用いてログインパスワードを格納しているファイルにアクセスできることを示しています．「/etc/shadowを/tmp/shadowにハードリンクしてしまうシステム管理者なんていないよ」と思われるかもしれませんが，実は，/etc /shadowのハードリンクの作成はrootユーザでなくても可能です．一般ユーザが/etc/shadowのハードリンクを一般ユーザが書き込めるディレクトリである/tmp/ディレクトリに作成し，実行を許可されているコマンド（たとえば/usr/bin/sudo）を利用してroot権限を手に入れてから，/tmp/ディレクトリにハードリンクされたパスワードファイルにアクセスできてしまう危険性があるのです．だからTOMOYO Linuxでは，ハードリンクを作成する際に，リンク元とリンク先の両方をチェックすることでその危険性を最小限に抑えられるようにしているわけです． （実際に/tmp/shadowを作成した方は，この先を読み続ける前に，忘れないうちに/tmp/shadowを削除しておくように！）/etc /shadowのリンク数が2以上であれば，どこかにハードリンクが残っています（図16） ．</p>
+<p>その後，「TAB」を押すと&lt;&lt;&lt; Domain Transition Editor &gt;&gt;&gt;という画面に戻り，さらに「ENTER」を押すと&lt;&lt;&lt; Domain Policy Editor &gt;&gt;&gt;という画面に移動することができます．登録したばかりのMT-LIBを使ってグループ化してみましょう．まずccs-editpolicyで，mt.cgiのドメインを選択し，図22の行を追加します．図22の行を追加後に，図22の行にカーソルを合わせてから「O」キーを押すと，カーソル行のアクセス許可に包含されているアクセス許可に対して&amp;マークが付与されるので，「D」キーを押すことで学習結果から図22の行のアクセス許可に包含されているエントリを削除できます．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図16 /etc/shadowのハードリンクを削除する
+■図22 図21でグループ化したパス名を指定
 <pre>
-# ls -l /etc/shadow
--r-------- 2 root root 946 May 29 18:14 /etc/shadow
-# unlink /tmp/shadow
-# ls -l /etc/shadow
--r-------- 1 root root 946 May 29 18:14 /etc/shadow
+allow_read @MT-LIB
 </pre>
 </td></tr>
 </table>
 
-<p>名前の変更についても同様です．/etc/shadowの読み書きは厳しく制限できますが，/tmp/ディレクトリ内のファイルの読み書きを厳しく制限することは困難です．しかし，図17のような操作ができてしまうようでは困ります（/etc/ディレクトリと/tmp/ディレクトリが別のパーティションになっているシステムでは，パーティションを跨ぐ名前の変更はできないので，/etc/shadowの読み書きを禁止することで/tmp/ディレクトリに移動されることを防止できます） ．</p>
+<p>これは， 「グループ名がMT-LIBであるpath_groupに割り当てられているパス名」に対して読み込みを許可するという意味です．</p>
 
+<p>mt.cgiドメインにはMT-LIBで定義した以外にもグループ化するほうが良さそうなエントリがありそうです（図23） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図17 名前を変更してからパスワードファイルにアクセスする
+■図23 グループ化できそうなパス名のエントリ
 <pre>
-# mv /etc/shadow /tmp/shadow
-# cat /tmp/shadow
-# mv /tmp/shadow /etc/shadow
+allow_read/write /var/www/mt-db/__db.notification.blog_id.idx
+allow_read/write /var/www/mt-db/__db.notification.db
+（中略）
+allow_read/write /var/www/mt-db/trackback.entry_id.idx
+allow_read/write /var/www/mt-db/trackback.entry_id.idx.lock
+allow_create /var/www/mt-db/__db.notification.blog_id.idx
+allow_create /var/www/mt-db/__db.notification.db
+（中略）
+allow_create /var/www/mt-db/objecttag.db.lock
+allow_create /var/www/mt-db/plugindata.blog_id.idx.lock
+allow_rename /var/www/mt-db/__db.notification.blog_id.idx /var/www/mt-db/notification.blog_id.idx
+allow_rename /var/www/mt-db/__db.notification.db /var/www/mt-db/notification.db
+（略）
 </pre>
 </td></tr>
 </table>
 
-<p>そのため，TOMOYO Linuxではファイル名を変更する際に，変更前のパス名と変更後のパス名の両方をチェックすることで，その危険性を最小限に抑えられるようにしています．パス名でアクセスを制限する方式では，ちょっとした油断で想定外のアクセスを認めてしまうことになります． TOMOYO Linuxを用いてハードリンクや名前の変更の許可を与える際には，必要以上の範囲にアクセスさせないように注意してください．</p>
+<p>データベースディレクトリ内のファイルは読み書き／新規作成／名称変更が行われることがわかります．これらのパス名もグループ化することにします．ここでは，/var/www/mt-db/\*をMT-DBという名前で登録することにします．</p>
 
-<h3>アクセスをホームディレクトリ以下に限定する</h3>
+<p>&lt;&lt;&lt; Exception Policy Editor &gt;&gt;&gt;という画面において図24の指定を登録し，&lt;&lt;&lt; Domain Policy Editor &gt;&gt;&gt;という画面に戻ってから，さきほどと同様に登録済みエントリの削除を行い，新たに図25の3行を追加します．</p>
 
-<p>ドメインを遷移させるのは，アクセス権限を切り替えるためです．ログインセッションでは原則としてドメイン遷移を行わないということは，ログインセッションで読み書きを許可するファイルを区別しないことを意味します．基本的に，ログインセッションでは，プログラムファイルを作成したり書き換えたりする必要はありません．そのため，ホームディレクトリ以下のファイルの読み書きを中心に許可すれば良いでしょう．ホームディレクトリ以下のファイルをグループ化するために，例外ポリシーで図18のグループを定義します．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図24 /var/www/mt-db/\*をグループ化
+<pre>
+path_group MT-DB /var/www/mt-db/\*
+</pre>
+</td></tr>
+</table>
 
 <table border="1" summary="fig">
 <tr><td>
-■図18 ホームディレクトリのファイルをグループ化
+■図25 図24でグループ化したパス名を指定
 <pre>
-path_group HOME_FILE /home/\{\*\}/\*
-path_group HOME_DIR /home/\{\*\}/\*/
+allow_read/write @MT-DB
+allow_create @MT-DB
+allow_rename @MT-DB @MT-DB
 </pre>
 </td></tr>
 </table>
 
-<p>このように定義すると，ホームディレクトリ以下のファイルを区別しないで扱うことになります．</p>
+<p>これは， 「グループ名がMT-DBであるpath_groupに割り当てられているパス名」に対して読み書きと新規作成と名称変更を許可するという意味です． MT-LIB, MT-DBの登録を行った後でmt.cgiを実行すると登録したパターンに一致する個別のファイルは学習結果に現れなくなります．パス名のグループ化はどこまで行わなければならないという決まりはありません．学習結果を見ながら，まとめられそうな部分があれば同様に処理を行います．ここで示した以外には，Perlのライブラリ（/usr/lib/perl5/5.8.8/ディレクトリ以下のファイル）やblogディレクトリのファイル（/var/www/html/blog/ディレクトリ以下のファイル）などが対象になるでしょう．mt.cgi以外のCGIについても同様にグループ化を行ってください．</p>
 
-<h3>特定のパス名を除外する</h3>
+<h3>ポリシーを保存する</h3>
 
-<p>しかし，ホームディレクトリ以下のファイルでも，~/.ssh/ディレクトリのファイルのように，/bin/catなどでの閲覧を禁止させたいファイルがあるはずです．そこで，\*\-.sshという指定を行うことで，.sshディレクトリ内のパス名を除外することができるようになっています．具体的には，図19のように修正します．</p>
+<p>ポリシーエディタで表示されるポリシーはカーネル内にのみ存在しており，再起動すると失われてしまいます．ポリシーをディスク上のファイルに保存するにはccs-savepolicyというコマンドを実行してください（図26） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図19 .sshディレクトリをグループから除外する
+■図26 ccs-savepolicyコマンドの実行
 <pre>
-path_group HOME_FILE /home/\{\*\-.ssh\}/\*
-path_group HOME_DIR /home/\{\*\-.ssh\}/
+# /usr/sbin/ccs-savepolicy
 </pre>
 </td></tr>
 </table>
 
-<p>これで， /bin/cat コマンドなどで/home/\*/.ssh/\*にアクセスしたり，/bin/mvコマンドなどで/home/\*/.ssh/を/home/\*/ssh/にリネームしたりするのを阻止することができます．</p>
+<h3>ドメインの集約</h3>
 
-<h3>アクセス許可をあらかじめ与えておく</h3>
+<p>パス名のグループ化を行っているときに，個々のCGIに必要なアクセス許可が似ていることに気が付いたと思います．MovableTypeは機能ごとに別々のCGIプログラムに分かれているので，TOMOYO Linuxでは個々のCGIごとにドメインが分かれます．もちろん，個々のCGIごとにアクセス許可を設定するほうが安全ですが，数が多くて手間がかかります．そこで，個々のCGI用のドメインを1個に集約してしまうという選択肢もあります．ここでは例として，MovableTypeのCGIプログラムを，/./MovableTypeCGIという名前で集約してみることにします．ドメインを集約するには，&lt;&lt;&lt; Exception Policy Editor &gt;&gt;&gt;という画面に移動してから図27の指定を追加してください．</p>
 
-<p>ログインセッションである&lt;kernel&gt; /usr/sbin/sshd /bin/bashドメインに対しては，図20のようなアクセスを認めます．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図20 あらかじめアクセス許可を与えておく
+■図27 ドメインを集約するための設定
 <pre>
-allow_execute @COMMANDS_FOR_LOGIN
-allow_read/write @HOME_FILE
-allow_create @HOME_FILE
-allow_unlink @HOME_FILE
-allow_symlink @HOME_FILE
-allow_link @HOME_FILE @HOME_FILE
-allow_rename @HOME_FILE @HOME_FILE
-allow_truncate @HOME_FILE
-allow_rewrite @HOME_FILE
-allow_mkdir @HOME_DIR
-allow_rmdir @HOME_DIR
-allow_rename @HOME_DIR @HOME_DIR
+aggregator /var/www/cgi-bin/mt/\@.cgi /./MovableTypeCGI
+aggregator /var/www/cgi-bin/mt/extras/examples/plugins/\*/\@.cgi /./MovableTypeCGI
+aggregator /var/www/cgi-bin/mt/plugins/\*/\@.cgi /./MovableTypeCGI
 </pre>
 </td></tr>
 </table>
 
-<p>上から順番に，</p>
+<p>このように指定すると，/var/www/cgi-bin/mt/\@.cgiまたは/var/www/cgi-bin/mt/extras /examples/plugins/\*/\@.cgiまたは/var/www/cgi-bin/mt/plugins/\*/\@.cgiというパターンに一致するプログラムが実行された場合には/./MovableTypeCGIというプログラムが実行されたのかのように振舞うようになり，結果としてドメインが集約されます．その後，「TAB」を押して&lt;&lt;&lt; Domain Transition Editor &gt;&gt;&gt;という画面に戻り，図28のドメインを削除してください．</p>
 
-<ul>
-<li>COMMANDS_FOR_LOGIN というグループに指定されているプログラムの実行を許可</li>
-<li>ホームディレクトリ内のファイルを読み書きモードでオープンすることを許可</li>
-<li>ホームディレクトリ内のファイル作成を許可</li>
-<li>ホームディレクトリ内のファイル削除を許可</li>
-<li>ホームディレクトリ内でのシンボリックリンク作成を許可</li>
-<li>ホームディレクトリ内であればハードリンクの作成を許可</li>
-<li>ホームディレクトリ内であればファイルの名前の変更を許可</li>
-<li>ホームディレクトリ内のファイル切り詰めを許可</li>
-<li>ホームディレクトリ内のファイル上書きを許可</li>
-<li>ホームディレクトリ内のディレクトリ作成を許可</li>
-<li>ホームディレクトリ内のディレクトリ削除を許可</li>
-<li>ホームディレクトリであればディレクトリ名変更を許可</li>
-</ul>
+<table border="1" summary="fig">
+<tr><td>
+■図28 ドメインを削除する<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig17.png" alt="sd200708-fig17.png">
+</td></tr>
+</table>
 
-<p>という意味です．なお，リスト4の修正により，上記のホームディレクトリには ~/.ssh/および~/.ssh/\*に一致するものは含まれません．上記では，ホームディレクトリ内では自由にシンボリックリンクを作成できるようにしています． TOMOYO Linuxはシンボリックリンクを解決したパス名を用いてファイルの読み書きを制限しているので，どのようにシンボリックリンクを作成しようとも関係ありません．プログラムの実行時にはシンボリックリンクを経由することでargv[0]の内容を自由に指定できてしまいますが，exec.argv[0]のチェックを有効にしているので，busyboxのハードリンクへのシンボリックリンクを作成して任意のコマンドを実行されるという危険性はありません．ホームディレクトリ内でのみハードリンクの作成を認めています．そのため，/etc/shadowのハードリンクをホームディレクトリ内に作成して，ホームディレクトリを経由してパスワードファイルにアクセスされるという危険性はありません．名前の変更についても同様です．</p>
+<p>また，&lt;kernel&gt; /usr/sbin/httpdドメインのアクセス許可からこれらのCGIの実行許可を削除してください（図29） ．</p>
 
-<h3>所有者によるアクセスのみを認める</h3>
+<table border="1" summary="fig">
+<tr><td>
+■図29 CGIの実行許可を削除する<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig18.png" alt="sd200708-fig18.png">
+</td></tr>
+</table>
 
-<p>他人が自分のホームディレクトリ内にアクセスしてくるのを阻止するには，ホームディレクトリのパーミッションを0700に設定することで実現できます．しかし，たとえば Apache に対して~/public_html/ディレクトリへのアクセスを認めるためにホームディレクトリのパーミッションを緩くしておかざるを得ない場合もあります．そんな場合，個々のアクセス許可に対してif task.uid=path1.uidのように条件を付与することで，ホームディレクトリのパーミッションでは防げないアクセスを防げるようになります．具体的には，図20を図21のように置き換えます．</p>
+<p>この状態で先ほどと同様に操作すると，図30のようなドメインが作成されるはずです．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図21 所有者によるアクセスのみを認める
+■図30 集約したドメインが作成される<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig19.jpg" alt="sd200708-fig19.jpg">
+</td></tr>
+</table>
+
+<h3>ドメイン遷移を抑制する</h3>
+
+<p>環境や設定によっては，perlのCwdモジュールによりカレントディレクトリを取得するために/bin/pwdコマンドが実行される場合があります．そのような場合には，図31のように/bin/pwdコマンド用のドメインが作成されます．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図31 /bin/pwdコマンド用のドメインが作成される<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig20.jpg" alt="sd200708-fig20.jpg">
+</td></tr>
+</table>
+
+<p>しかし，この/bin/pwdについてはわざわざドメイン遷移させる必要はなさそうです．そこで，/./MovableTypeCGIから/bin /pwdが実行される場合にはドメイン遷移させないようにするという選択肢もあります．ドメイン遷移を抑制するには，&lt;&lt;&lt; Exception Policy Editor &gt;&gt;&gt;という画面に移動してから図32の指定を追加してください．その後，&lt;&lt;&lt; Domain Transition Editor &gt;&gt;&gt;という画面に戻ると，/bin/pwdドメインに対して( keep_domain /bin/pwdfrom /./MovableTypeCGI )という理由と共に「!」という表示により「このドメインには到達不能である」ことを示すようになるので，そのドメインを削除します（図33） ．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図32 ドメインを集約するための設定
 <pre>
-allow_execute @COMMANDS_FOR_LOGIN
-allow_read/write @HOME_FILE if task.uid=path1.uid
-allow_create @HOME_FILE if task.uid=path1.parent.uid
-allow_unlink @HOME_FILE if task.uid=path1.uid
-allow_symlink @HOME_FILE if task.uid=path1.parent.uid
-allow_link @HOME_FILE @HOME_FILE if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
-allow_rename @HOME_FILE @HOME_FILE if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
-allow_truncate @HOME_FILE if task.uid=path1.uid
-allow_rewrite @HOME_FILE if task.uid=path1.uid
-allow_mkdir @HOME_DIR if task.uid=path1.parent.uid
-allow_rmdir @HOME_DIR if task.uid=path1.uid
-allow_rename @HOME_DIR @HOME_DIR if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
+keep_domain /bin/pwd from /./MovableTypeCGI
 </pre>
 </td></tr>
 </table>
 
-<p>task.uidはアクセスを要求しているプロセスのユーザID（つまり，ログインしているユーザのユーザID） ，path1.uidは1つ目のパス名（たとえば「 allow_read/write /dev/null」であれば/dev/null，allow_link /tmp/source /tmp/destであれば/tmp/source）の所有者IDです．path1.parent.uidはpath1の親ディレクトリ（たとえば「 allow_read/write /dev/null」であれば/dev/）の所有者IDです．path2.uidは2つめのパス名（たとえば「 allow_mount /dev/sda2 /home/ ext3 0」であれば/home/）の所有者IDです．ただし，allow_renameやallow_linkで指定する2つめのパス名は，アクセス許可のチェックの時点ではアクセスできないパス名であるため，path2.uidという指定はできません．path2.parent.uidは2つ目のパス名（たとえば「allow_link /tmp/source /tmp/dest」であれば/tmp/dest）の親ディレクトリの所有者IDです．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図33 到達不能なドメインを削除する<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig21.jpg" alt="sd200708-fig21.jpg">
+</td></tr>
+</table>
 
+<p>なお，ドメイン遷移を抑制しているのは/bin/pwdプログラムだからであって，たとえば/bin/catプログラムの場合にはドメイン遷移を抑制すべきではありません．/bin/catを呼び出し元のドメイン（この例では/./MovableTypeCGI）で実行することは，呼び出し元のドメインで読み込みが許可されているすべての資源（たとえばCGIプログラムやデータベース）の内容をそっくり漏洩させてしまう危険性を高めることにつながります．</p>
+
 <h2>次回予告</h2>
 
-<p>今回は，システムにログインして行う操作を制限する手順のうち，ファイルアクセスに関する部分について解説しました．次回は，残りのステップと実際の操作手順を説明します．</p>
+<p>今回は，MovableTypeの導入からポリシーの自動学習までの手順について紹介し，併せて応用的な使い方であるパス名のグループ化，ドメイン遷移の集約と抑制について解説しました．パス名のグループ化やドメイン遷移の調整については，最初のうちは難しいかもしれませんが，本稿を参考に少しずつ挑戦していただければと思います．次回は，確認モードを用いて必要なアクセス許可が与えられているかどうかを確認する方法と，チューニングの続きについて説明します．</p>
 
 <p><a href="tutorial-9.html.ja">第９回へ戻る</a>　<a href="tutorial-11.html.ja">第１１回へ進む</a></p>
 
Index: tutorial-11.html.ja
===================================================================
--- tutorial-11.html.ja	(revision 3668)
+++ tutorial-11.html.ja	(working copy)
@@ -3,7 +3,7 @@
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <meta http-equiv="Content-Style-Type" content="text/css">
-<title>TOMOYO Linuxの世界　第１１回：「ログインセッションを制限してみよう（後編）」</title>
+<title>TOMOYO Linuxの世界　第１１回：「blogのポリシーを作成してみよう（後編）」</title>
 <link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
 </head>
 <body>
@@ -11,365 +11,544 @@
 <p style="text-align:right;"><a href="tutorial-11.html.en">English Page</a></p>
 <p style="text-align:right;">Last modified: $Date$</p>
 -->
+<h1>TOMOYO Linuxの世界<br>第１１回：「blogのポリシーを作成してみよう（後編）」</h1>
 
-<h1>TOMOYO Linuxの世界<br>第１１回：「ログインセッションを制限してみよう（後編）」</h1>
+<p>今回も引き続き，blogソフトウェアとして広く利用されているMovable Typeを題材に，ポリシー設定方法を解説します．TOMOYO Linux活用のための実践的なノウハウ満載でお届けします．</p>
 
-<p>今回は前回に引き続き，TOMOYO Linuxを使ってシステムへのログイン後にユーザが行う操作を制限する手順を解説します．</p>
-
 <h2>今回の内容</h2>
 
-<p>前回は，システムにログインして行う操作を制限する手順のうち，ドメイン遷移とファイルアクセスに関する制限について解説しました．今回は，ネットワーク（通信）の制限と実際の操作手順を説明します．</p>
+<p>前回はCentOS 5.5上でMovable Type 3.3を動作させるためのポリシーを学習させる方法と，パス名をパターン化する方法およびドメイン遷移を調節する方法について紹介しました．今回は前回説明しきれなかった残りの部分について紹介します．</p>
 
-<h2>ステップ3：通信を許可したいネットワークの決定</h2>
+<h2>チューニング</h2>
 
-<h3>ネットワークのアクセス制限</h3>
+<h3>グループ化の利点</h3>
 
-<p>システムにログインしたユーザはファイルへのアクセスだけでなくネットワークにもアクセスすることでしょう．そこで，ログインしたユーザに対してどのサーバへのアクセスを許可するかを設計します．ネットワークに関するアクセス許可の構文は，「allow_network プロトコル IPアドレス ポート番号」となっています．プロトコルはTCPまたはUDPまたはRAWのいずれか，IPアドレスはIPv4またはIPv6アドレスを指定します．IP アドレスの部分は前回の記事で説明したファイルのグループ化と同様にグループ化が可能です．ここではHTTP，DNS，FTPとSSHの設定について説明します．</p>
+<p>前回，path_groupという構文を使ってパス名のグループ化を行いました．以前からTOMOYO Linuxを使われている方の中には， 「file_pattern構文であらかじめパス名のパターンを定義しておけば，path_group構文は不要なのでは？」と思われた方もいらっしゃると思います．実際，path_groupは必須の機能ではなく，file_patternでも代用可能です．しかし，file_patternはすべてのドメインに対して適用されてしまうため， 「あるドメインでは/var/www/html/\*.htmlという単位でグループ化したいが，別のドメインでは/var/www/html /index.htmlのようにグループ化させたくない」といった場合に対応できません．そして，path_groupを使うことで，見通しよくポリシーを記述できるようになります．今回使用しているMovable Typeの例で説明しましょう．Movable TypeはApacheから起動されるCGIとして動作し，動的にWebページを作成します．そして，CGIによって作成されたWebコンテンツを Apacheがクライアントに提供します．そのため，ApacheのドメインとMovable Typeのドメインの間には，同じパス名にアクセスしているという共通点があります．図1の上側はpath_groupを使わない場合のアクセス許可の与え方，下側はpath_groupを使う場合のアクセス許可の与え方です．</p>
 
-<h4>●HTTP</h4>
+<table border="1" summary="fig">
+<tr><td>
+■図1 path_groupによるグループ化<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig01.png" alt="sd200709-fig01.png">
+</td></tr>
+</table>
 
-<p>最初に，HTTPサーバのIPアドレスをHTTP_SERVERSという名前でグループ化することにします．グループ化することにより，ポリシーファイルを読みやすくすることができ，また，サーバのIPアドレスの変更や追加や削除が発生した場合にも修正個所が1ヵ所で済みます．IPアドレスをグループ化するには，address_groupというキーワードを使います． HTTPサーバのアドレスが192.168.1.100と192.168.1.200の場合，例外ポリシーで図1のように定義してから，ログインシェルのドメイン（&lt;kernel&gt; /usr/sbin/sshd /bin/bash）に対して図2という許可を与えます（以降に登場するDNS_SERVERSやFTP_SERVERSやSSH_SERVERSも，HTTP_SERVERSと同様に定義してください） ．</p>
+<p>アクセスするパス名が変化した場合，path_groupを使わない場合には個々のドメイン内のアクセス許可を修正してやらなければいけませんが，path_groupを使う場合には1ヵ所を修正するだけで対処できます． Movable Typeを用いてサービスを提供する際には，通常，DNSサーバに対して問い合わせを行うことは欠かせません．そこで今回は，パス名だけでなくIPアドレスもグループ化することにします．図2の上側はaddress_groupを使わない場合のアクセス許可の与え方，下側はaddress_groupを使う場合のアクセス許可の与え方です．DNSサーバのIPアドレスが変化した場合，address_groupを使わない場合には個々のドメイン内のアクセス許可を修正してやらなければいけませんが，address_groupを使う場合には1ヵ所を修正するだけで対処できます．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図1 アドレスをグループ化する
-<pre>
-address_group HTTP_SERVERS 192.168.1.100
-address_group HTTP_SERVERS 192.168.1.20
-</pre>
+■図2 address_groupによるグループ化<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig02.png" alt="sd200709-fig02.png">
 </td></tr>
 </table>
 
+<h3>プロセスの依存関係について</h3>
+
+<p>図3は，Movable Typeが動作するために関連しているプロセスの一覧とそれぞれの連携を表示したものです．矢印はTCPまたはUDPによる通信を示しています．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図2 HTTPサーバと通信するためのアクセス許可
-<pre>
-allow_network TCP connect @HTTP_SERVERS 80
-</pre>
+■図3 Movable Typeと関連するプロセス<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig03.png" alt="sd200709-fig03.png">
 </td></tr>
 </table>
 
-<h4>●DNS</h4>
+<p>この連載では，Apacheと書かれている円の内部をTOMOYO Linuxで保護する手順について説明しています．Movable TypeはApacheの上で動作します．そのため，Movable Typeのドメインだけでなくその親ドメインであるApacheのドメインも含めた形でポリシーを作成しています（Movable Typeをいくら保護してもその土台のApacheの脆弱性を突かれては意味がありませんからね） ．</p>
 
-<p>DNSサーバとの通信ではUDPプロトコルのポート53を使うので，ログインシェルのドメインに対して図3という許可を与えます．</p>
+<h3>確認モードに切り替える</h3>
 
+<p>ポリシーエディタを実行して「&lt;kernel&gt; /usr/sbin/httpd」ドメイン以下を選択し，「S」を押してから2を入力して「ENTER」を押します（本連載における各プロファイルの定義内容については前回の記事を参照ください） ．これにより，&lt;kernel&gt; /usr/sbin/httpdドメイン以下が確認モードになります（図4） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図3 DNSサーバと通信するためのアクセス許可
-<pre>
-allow_network TCP connect @HTTP_SERVERS 80
-</pre>
+■図4 確認モードに変更する<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig04.jpg" alt="sd200709-fig04.jpg">
 </td></tr>
 </table>
 
-<h4>●FTP</h4>
+<p>確認モードでは，ポリシー違反が発生しても自動的にアクセス許可が追加されることはありません．また，PREFERENCE::permissive={ verbose=yes }と指定しているので，ポリシー違反が発生した場合にはコンソールに警告メッセージが表示されます（図5） ．</p>
 
-<p>FTPサーバとの通信ではTCPプロトコルのポート21を使うので，図4という許可を与えます．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図4 FTP制御用のアクセス許可
+■図5 PREFERENCE::permissive={ verbose=yes }による警告メッセージ
 <pre>
-allow_network TCP connect @HTTP_SERVERS 80
+CentOS release 5.5 (Final)
+Kernel 2.6.18-194.3.1.el5_tomoyo_1.7.2 on an i686
+tomoyo login: WARNING: Access read /var/www/cgi-bin/mt/mt.cgi denied for /var/www/cgi-bin/mt/mt.cgi
+WARNING: Signal 15 to /var/www/cgi-bin/mt/mt.cgi denied for /usr/sbin/httpd
 </pre>
 </td></tr>
 </table>
 
-<p>FTPプロトコルではサーバ側からクライアント側へ向けてTCPコネクションを張る場合があるので，図5の許可が必要になる場合があります．</p>
+<p>操作を行って大量に警告メッセージが表示されるようであれば，まだ学習内容が不十分であることを意味します．再度学習モードに戻りポリシーを追加しましょう．学習モードに戻すには，ポリシーエディタを実行して&lt;kernel&gt; /usr/sbin/httpdドメイン以下を選択し，「S」を押してから1を入力して「ENTER」を押します．</p>
 
+<h3>アクセスログの保存</h3>
+
+<p>確認モードではポリシーにないアクセス要求が発生しても，コンソールに警告メッセージが表示されるだけであり，ポリシーへのアクセス許可の追加は行われません．そのため，そのまま強制モードにしてしまうと，正常に動作できなくなってしまいます．しかし，警告メッセージからはどのようなアクセス許可を追加したら良いのかわからないので，どのように対処すれば良いのか困ってしまうでしょう． TOMOYO Linuxでは，ポリシーに違反したアクセス要求のログ（アクセス拒否ログ）とポリシーに違反しなかったアクセス要求のログ（アクセス許可ログ）を取得することができます．アクセス許可ログとアクセス拒否ログはドメイン用ポリシーと同じ形式で生成されます．アクセス拒否ログを閲覧して，許可すべきアクセス要求と判断したものは手作業で追加することができます．</p>
+
+<p>ここで，アクセスログを保存する方法について紹介します．まず，アクセスログを保存するためのディレクトリを作成します（図6）．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図5 FTPデータ（アクティブモード）用のアクセス許可
+■図6 アクセスログを保存するディレクトリを作成する
 <pre>
-allow_network TCP accept @FTP_SERVERS 20
+# mkdir /var/log/tomoyo
 </pre>
 </td></tr>
 </table>
 
-<p>ファイアウォールの内側にいる場合など，サーバ側からクライアント側へ向けてTCPコネクションを張ることができない場合にはパッシブモードを使うので，図5の代わりに図6という許可を与えることになるでしょう．</p>
+<p>/etc/rc.d/rc.localの末尾にccs-auditdを起動するための指定を追加します（図7） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図6 FTPデータ（パッシブモード）用のアクセス許可
+■図7 ccs-auditdを自動起動する
 <pre>
-allow_network TCP connect @FTP_SERVERS 1024-65535
+# echo /usr/sbin/ccs-auditd /dev/null /var/log/tomoyo/reject_log.txt &gt;&gt; /etc/rc.d/rc.local
 </pre>
 </td></tr>
 </table>
 
-<h4>●SSH</h4>
+<p>この例では，アクセス許可ログを/dev/nullへ保存し（つまり読み捨てる） ，アクセス拒否ログを/var/log/tomoyo/reject_log.txtへ保存するように指定しています． /etc/rc.d/rc.localを実行してccs-auditdを起動します（図8） ．</p>
 
-<p>SSHサーバとの通信ではTCPプロトコルでポート22へコネクションを張るので，図7という許可を与えることになります．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図7 SSHサーバと通信するためのアクセス許可
+■図8 ccs-auditdを起動する
 <pre>
-allow_network TCP connect @FTP_SERVERS 1024-65535
+# /etc/rc.d/rc.local
 </pre>
 </td></tr>
 </table>
 
-<p>ただし，前回のドメイン遷移の設計では，SSHの秘密鍵へのアクセスを認める必要がある/usr/bin/sshコマンドはログインシェルとは別のドメインで動作させるように指定している（図8）ので，このアクセス許可はログインシェルのドメインにではなく，/usr/bin/sshのドメイン（図9）に対して与えることに注意してください．ポリシーエディタを実行して，「A」を押してからリスト9の内容を入力して「ENTER」を押すことで/usr/bin/sshのドメインを作成できます．</p>
+<p>この状態でポリシー違反が発生すると，コンソールへの警告メッセージだけでなく/var/log/tomoyo/reject_log.txtへの出力も行われます（図9） ．ログは3行で1組です．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図8 ログインシェルとは別のドメインで実行する
+■図9 アクセスログの例（/var/log/tomoyo/reject_log.txt）
 <pre>
-no_keep_domain /usr/bin/ssh from &lt;kernel&gt; /usr/bin/sshd /bin/bash
+#2007-07-06 13:16:49# profile=2 mode=permissive (global-pid=4620) task={ pid=4620 ppid=4581 uid=500 gid=500 euid=500 egid=500 suid=500 sgid=500 fsuid=500 fsgid=500 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=501 gid=501 ino=393251 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
+&lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/mt.cgi
+allow_read /var/www/cgi-bin/mt/mt.cgi
 </pre>
 </td></tr>
 </table>
 
+<p>1行目は発生時刻とプロセスのIDなどの情報，2行目はドメイン，3行目がアクセス要求の内容です．アクセス要求の内容を判断し，許可すべきであると判断した場合は，ポリシーエディタを起動して2行目のドメイン名が示すドメインを選択し，「A」を押してから3行目の内容を入力して「ENTER」を押します．必要であれば3行目の内容をワイルドカードでパターン化してから入力してもかまいません．また，対象が個々のドメインに閉じたものではなく複数のドメインにまたがるような場合にはpath_groupの定義を検討すると良いでしょう． /var/log/tomoyo/reject_log.txtを監視し，ログが発生したら，内容を確認したうえでポリシーエディタを使ってアクセス許可を追加してください（図10） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図9 /usr/bin/ssh用のドメイン
+■図10 ログの発生を監視する
 <pre>
-&lt;kernel&gt; /usr/sbin/sshd /bin/bash /usr/bin/ssh
+# tail -f /var/log/tomoyo/reject_log.txt
 </pre>
 </td></tr>
 </table>
 
-<h2>ステップ4：学習の開始</h2>
+<h3>アクセスログのローテーション</h3>
 
-<p>さて，これまでの作業でアクセス許可の基本的な設定が完了しました．しかし，これだけではまだアクセス許可が不足していますから，学習モードを用いて不足しているアクセス許可を追加していくことにします．ポリシーエディタを用いてログインシェルのドメインとその子孫ドメインに対してプロファイル1を割り当てます（ポリシーエディタを使わずに，rootユーザで図10のコマンドラインを実行しても結構です） ．</p>
+<p>先ほどアクセスログを保存する設定をしましたが，自動的にローテーションさせたい場合もあると思います．そのような場合は，図11の内容を /etc/logrotate.d/tomoyoという名前で作成してください．nocreateオプションを忘れるとローテーション以降のログが保存されなくなりますので注意してください．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図10 学習モード用プロファイルを割り当てる
+■図11 アクセスログをローテーションの対象にする（/etc/logrotate.d/tomoyo）
 <pre>
-# /usr/sbin/ccs-setprofile -r 1 '&lt;kernel&gt; /usr/sbin/sshd /bin/bash'
+/var/log/tomoyo/reject_log.txt {
+   weekly
+   rotate 9
+   missingok
+   notifempty
+   nocreate
+}
 </pre>
 </td></tr>
 </table>
 
-<p>そして，許可したい操作（具体的には，前回定義したCOMMANDS_FOR_LOGIN_SESSIONに含まれているコマンドを実行したり，HOME_FILEに該当するファイルを編集したり，ネットワークへアクセスしたりなど）を行ってください．操作例として，図11～図15の内容を参考にしてください．</p>
+<h3>パス名のパターン化</h3>
 
+<p>前回，MT-LIBやMT-DBというグループ名を用いてパス名のパターン化を行ったと思いますが，他にもパターン化が必要な個所があると思います． Movable Typeにより動的に生成されるWebコンテンツは「&lt;kernel&gt; /usr/sbin/httpd」ドメインからアクセスされるので，パターン化が必要です．この時点でパターン化に漏れがないかを確認してください．確認できたらネットワークへと進みます．</p>
+
+<h3>ネットワークアドレスのパターン化</h3>
+
+<p>前回定義したプロファイルではネットワークに関する強制アクセス制御（CONFIG::network）を有効にしています．ファイルに対するアクセス制御だけで十分だとお考えの方もいらっしゃると思いますが，そうではありません．2003年に開催されたJNSA主催のイベント， 「セキュリティ・スタジアム」では，防御側として出展したTOMOYO Linuxサーバについて，Apacheの脆弱性（バッファオーバーフロー）を突いて他のホストへの接続を試みるという攻撃を受けました．接続を許可すべきIPアドレスやポート番号を把握するのは，どんなパス名にアクセスしているかを把握するのに比べればずっと簡単です．ワームなどの拡散を防ぐためにも，ネットワークに対するアクセス制御も有効にしておくことを推奨します．</p>
+
+<p>&lt;kernel&gt; /usr/sbin/httpdドメインに対するアクセス許可を確認してみると，allow_network TCP acceptで始まる行が多数見つかるはずです（図12） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図11 SSHの鍵ペアを作成する
-<pre>
-$ ssh-keygen
-Generating public/private rsa key pair.
-Enter file in which to save the key (/home/example/.ssh/id_rsa):
-Created directory '/home/example/.ssh'.
-Enter passphrase (empty for no passphrase):
-Enter same passphrase again:
-Your identification has been saved in /home/example/.ssh/id_rsa.
-Your public key has been saved in /home/example/.ssh/id_rsa.pub.
-The key fingerprint is:
-c7:4f:53:39:6f:7e:17:fb:ec:94:0d:02:09:84:d5:67 example@tomoyo
-</pre>
+■図12 クライアントのIPアドレスとポート番号<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig10.jpg" alt="sd200709-fig10.jpg">
 </td></tr>
 </table>
 
+<p>これらは，ApacheにアクセスしてきたクライアントのIPアドレスとポート番号を示しています．通常，クライアントがサーバにアクセスする場合には，クライアントは1024以上の未使用のローカルポート番号を選択してアクセスします．そのため，Apacheサーバ側では1024以上の任意のローカルポート番号からのアクセスを許可するようにします（図13） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図12 SSHで接続する
-<pre>
-$ ssh 192.168.99.138 id
-example@192.168.99.138's password:
-uid=500(example) gid=500(example) groups=500(example)
-</pre>
+■図13 ポート番号部分をまとめる<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig11.jpg" alt="sd200709-fig11.jpg">
 </td></tr>
 </table>
 
+<p>1024以上のローカルポート番号を一括して許可したので，個々のローカルポートに対するアクセス許可は不要となりますから削除してください（図14） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図13 パスワードを変更する
-<pre>
-$ passwd
-Changing password for user example.
-Changing password for example
-(current) UNIX password:
-New UNIX password:
-Retype new UNIX password:
-passwd: all authentication tokens updated successfully.
-</pre>
+■図14 不要になったアクセス許可を削除する<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig12.jpg" alt="sd200709-fig12.jpg">
 </td></tr>
 </table>
 
+<p>この例ではアクセス元のIPアドレスは2つ（127.0.0.1と192.168.99.1）だけなのでこのままでもかまいませんが，実際のシステムでは他のアドレスからの接続も受け付けると思います．そこで，接続を受け付けるクライアントのアドレスをグループ化してみましょう．この連載では HTTP_CLIENTSという名前でグループ化することにします．</p>
+
+<p>&lt;&lt;&lt; Exception Policy Editor &gt;&gt;&gt;という画面に移動し，「A」を押してから「address_group HTTP_CLIENTS IPアドレス」または「address_group HTTP_CLIENTS 開始IPアドレス-終了IPアドレス」という形式で入力して「ENTER」を押します（図15） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図14 HTTPサーバにアクセスする 
-<pre>
-$ wget http://192.168.1.100/
-Length: unspecified [text/html]
-Saving to: `index.html'
-[ &lt;=&gt;     ] 2,997       --.-K/s   in 0s
-14:22:14 (286 MB/s) - `index.html' saved [2997]
-</pre>
+■図15 IPアドレスもまとめる<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig13.jpg" alt="sd200709-fig13.jpg">
 </td></tr>
 </table>
 
+<p>HTTP_CLIENTSという名前を用いてアクセス許可を追加後，HTTP_CLIENTSに含まれるアドレスに対するアクセス許可を削除します（図16） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図15 ホームディレクトリ内のファイルにアクセスする 
-<pre>
-$ ls .bashrc | xargs /bin/cat &gt; /dev/null
-</pre>
+■図16 グループ名に置き換える<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig14.jpg" alt="sd200709-fig14.jpg">
 </td></tr>
 </table>
 
-<p>ここでは，一般ユーザとしてexampleユーザを使用しています．前回の手順で図16のようにホームディレクトリ以下のファイルの読み書きに関するアクセス許可をあらかじめ与えているため，図16に含まれるアクセス要求は学習されません．</p>
+<p>このようにしておくことで，アクセスを許可するクライアントのIPアドレスを変更したくなった場合に，個々のドメインのアクセス許可を編集する代わりにHTTP_CLIENTS の定義を修正するだけで対応できるようになります．これがaddress_groupの利点です．</p>
 
+<p>&lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt.cgiドメインに対するアクセス許可を確認してみると，Movable TypeのCGIがトラックバックを送信するために外部のWebサーバにアクセスしていることがわかります（図17） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図16 あらかじめ与えておいたアクセス許可
-<pre>
-allow_execute @COMMANDS_FOR_LOGIN
-allow_read/write @HOME_FILE if task.uid=path1.uid
-allow_create @HOME_FILE if task.uid=path1.parent.uid
-allow_unlink @HOME_FILE if task.uid=path1.uid
-allow_symlink @HOME_FILE if task.uid=path1.parent.uid
-allow_link @HOME_FILE @HOME_FILE if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
-allow_rename @HOME_FILE @HOME_FILE if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
-allow_truncate @HOME_FILE if task.uid=path1.uid
-allow_rewrite @HOME_FILE if task.uid=path1.uid
-allow_mkdir @HOME_DIR if task.uid=path1.parent.uid
-allow_rmdir @HOME_DIR if task.uid=path1.uid
-allow_rename @HOME_DIR @HOME_DIR if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
-</pre>
+■図17 Movable Typeがアクセスしたネットワーク<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig15.jpg" alt="sd200709-fig15.jpg">
 </td></tr>
 </table>
 
-<p>ただし，図17に示したようにSSHの秘密鍵を保存するディレクトリはHOME_FILEから除外してあるので，図11の操作を行うと/home/example/.ssh/id_rsaのように個別に学習されます．</p>
+<p>TCPのポート80へのアクセスはWebサーバへのアクセスを，UDPのポート53へのアクセスはDNSサーバへのアクセスを，TCPのポート25 へのアクセスはメールサーバへのアクセスを意味します．これらのWebサーバのアドレスもグループ化してみます．この連載ではHTTP_PING_SERVERSという名前でグループ化することにします（図16） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図17 ホームディレクトリに含まれる範囲
-<pre>
-path_group HOME_FILE /home/\{\*\-.ssh\}/\*
-path_group HOME_DIR /home/\{\*\-.ssh\}/
-</pre>
+■図18 外部のWebサーバをまとめる<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig16.jpg" alt="sd200709-fig16.jpg">
 </td></tr>
 </table>
 
-<h2>ポリシーのチューニング</h2>
+<p>HTTP_PING_SERVERSという名前を用いてアクセス許可を追加後，HTTP_PING_SERVERSに含まれるアクセス許可を削除します（図19） ．</p>
 
-<h3>確認モードに切り替える</h3>
+<table border="1" summary="fig">
+<tr><td>
+■図19 グループ名で置き換える<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig17.jpg" alt="sd200709-fig17.jpg">
+</td></tr>
+</table>
 
-<p>ポリシーエディタを用いてログインシェルのドメインとその子孫ドメインに対してプロファイル2を割り当てます．ここから先は必要に応じて学習モード（プロファイル1）と確認モード（プロファイル2）を切り替えながら使います．ポリシーエディタを起動して，ログインシェルのドメインに対して与えられたアクセス許可の内容を確認してください．実は，前回の連載の手順では解説を行うために意図的にいくつかの設定を不完全なものにしています．この後，順に内容を見ながら修正していきますので，読みながら一緒に考えてみてください．</p>
+<p>もし，Movable Typeから外部のメールサーバにメールを送るなどネットワークを利用している場合，この時点でチューニングを行います．</p>
 
-<h3>ドメイン遷移の見直し</h3>
+<h3>パターン化の例</h3>
 
-<p>前回，/usr/bin/sshをログインシェルとは別のドメインで実行するように指定しました．しかし，よくよく考えてみると，SSHの秘密鍵へのアクセスを認めなければいけないのは/usr/bin/ssh-keygenも同じです．せっかく/usr/bin/sshをログインシェルとは別のドメインで動作させることで/bin/catなどでアクセスできないようにしようとしているのに，/usr/bin/ssh-keygenがログインシェルのドメインで動作してしまうと，ログインシェルのドメインからもSSHの秘密鍵へアクセスできるようになってしまいます．そこで，/usr/bin/ssh-keygenも/usr/bin/sshと同様にログインシェルとは別のドメインで実行させるように修正します．単純に図18の指定を追加するだけでも可能ですが， 「SSHの秘密鍵へのアクセスを認めなければいけないプログラム」という意味で，/usr/bin/sshと/usr/bin/ssh-keygenを同じようにまとめて扱えると便利ですね．</p>
+<p>参考までに，筆者の環境ではどのようなパターン化を行ったかを載せておきます（図20） ．適切なパターン化の内容は環境により異なりますから，あくまでパターン化の一例とお考えください．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図18 ログインシェルとは別のドメインで実行する
+■図20 パターン化の例
 <pre>
-no_keep_domain /usr/bin/ssh-keygen from &lt;kernel&gt; /usr/sbin/sshd /bin/bash
+path_group MT-LIB /var/www/cgi-bin/mt/\{\*\}/\@.pm
+path_group MT-PLUGIN /var/www/cgi-bin/mt/plugins/\*
+path_group MT-PLUGIN /var/www/cgi-bin/mt/plugins/\{\*\}/\*
+path_group MT-STATIC /var/www/html/mt-static/\*
+path_group MT-STATIC /var/www/html/mt-static/\{\*\}/\*
+path_group MT-TEMPLATE /var/www/cgi-bin/mt/tmpl/\*
+path_group MT-TEMPLATE /var/www/cgi-bin/mt/tmpl/\{\*\}/\*
+path_group PERL-LIB /usr/lib/perl5/5.8.8/\*
+path_group PERL-LIB /usr/lib/perl5/5.8.8/\{\*\}/\*
+path_group MT-DB /var/www/mt-db/\*
+path_group BLOG-FILE /var/www/html/blog/\*
+path_group BLOG-FILE /var/www/html/blog/\{\*\}/\*
+path_group BLOG-DIR /var/www/html/blog/\{\*\}/
+address_group HTTP_CLIENTS 0:0:0:0:0:ffff:7f00:1
+address_group HTTP_CLIENTS 0:0:0:0:0:ffff:c0a8:6301
+address_group HTTP_PING_SERVERS 172.18.1.53
+address_group HTTP_PING_SERVERS 192.168.99.129
+address_group HTTP_PING_SERVERS 204.9.178.67
 </pre>
 </td></tr>
 </table>
 
-<p>そのような目的のためにTOMOYO Linuxでは，aggregatorというキーワードが利用できます．構文は「aggregator 集約前のプログラム名 集約後のプログラム名」で，このように指定すると集約前のプログラムは集約後のプログラム名と同様に扱われます．図19のように指定すると，/usr/bin/ssh-keygenの実行が要求された場合，実行許可のチェックとドメイン遷移処理は/usr/bin/sshの実行が要求されたものとして行われるようになります．</p>
+<h3>ポリシーの例（抜粋） </h3>
 
+<p>参考までに，筆者の環境ではどのようなポリシーになったかを載せておきます（図21～図27） ．こちらも参考としてご利用ください．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図19 /usr/bin/ssh-keygenを/usr/bin/sshと同様に扱う
+■図21 &lt;kernel&gt; /usr/sbin/httpdドメインのアクセス許可
 <pre>
-aggregator /usr/bin/ssh-keygen /usr/bin/ssh
+allow_read/write /dev/null
+allow_read /dev/urandom
+allow_read /etc/group
+allow_read /etc/host.conf
+allow_read /etc/hosts
+allow_read /etc/httpd/conf.d/proxy_ajp.conf
+allow_read /etc/httpd/conf.d/welcome.conf
+allow_read /etc/httpd/conf/httpd.conf
+allow_read /etc/httpd/conf/magic
+allow_read /etc/mime.types
+allow_read /etc/nsswitch.conf
+allow_read /etc/passwd
+allow_read /etc/resolv.conf
+allow_read /etc/selinux/config
+allow_read /proc/filesystems
+allow_read /proc/sys/kernel/ngroups_max
+allow_read /usr/lib/httpd/modules/\*.so
+allow_write /var/log/httpd/access_log
+allow_write /var/log/httpd/error_log
+allow_write /var/run/httpd.pid
+allow_execute /var/www/cgi-bin/mt/mt-comments.cgi
+allow_execute /var/www/cgi-bin/mt/mt-feed.cgi
+allow_execute /var/www/cgi-bin/mt/mt-tb.cgi
+allow_execute /var/www/cgi-bin/mt/mt.cgi
+allow_execute /var/www/cgi-bin/mt/plugins/StyleCatcher/stylecatcher.cgi
+allow_read /var/www/cgi-bin/mt/mt-comments.cgi
+allow_read /var/www/cgi-bin/mt/mt-feed.cgi
+allow_read /var/www/cgi-bin/mt/mt-tb.cgi
+allow_read /var/www/cgi-bin/mt/mt.cgi
+allow_read /var/www/cgi-bin/mt/plugins/StyleCatcher/stylecatcher.cgi
+allow_read @MT-BLOG-FILE
+allow_read @MT-STATIC
+allow_capability SYS_KILL
+allow_capability SYS_UNLINK
+allow_capability inet_tcp_create
+allow_capability inet_tcp_listen
+allow_capability use_inet_udp
+allow_capability use_route
+allow_create /var/run/httpd.pid
+allow_network TCP accept @HTTP_CLIENTS 1024-65535
+allow_network TCP bind 0:0:0:0:0:0:0:0 80
+allow_network TCP listen 0:0:0:0:0:0:0:0 80
+allow_network UDP connect 0.0.0.0 80
+allow_network UDP connect 0:0:0:0:0:0:0:0 80
+allow_truncate /var/run/httpd.pid
+allow_unlink /var/run/httpd.pid
 </pre>
 </td></tr>
 </table>
 
-<p>そのため，時20のようなドメインを作成したり，図18という指定を追加したりする必要がなくなります．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図20 /usr/bin/ssh-keygen用のドメイン
+■図22 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/ mt-comments.cgiドメインのアクセス許可
 <pre>
-&lt;kernel&gt; /usr/sbin/sshd /bin/bash /usr/bin/ssh-keygen
+allow_read /dev/urandom
+allow_read /etc/host.conf
+allow_read /etc/hosts
+allow_read /etc/nsswitch.conf
+allow_read /etc/resolv.conf
+allow_read /proc/stat
+allow_read /usr/bin/perl
+allow_execute /usr/sbin/sendmail.sendmail
+allow_read/write @MT-DB
+allow_read @MT-LIB
+allow_read @PERL-LIB
+allow_argv0 /usr/sbin/sendmail.sendmail sendmail
+allow_capability SYS_IOCTL
+allow_capability use_inet_udp
+allow_network UDP connect 192.168.99.2 53
+allow_truncate /var/www/mt-db/blog.db
 </pre>
 </td></tr>
 </table>
 
-<p>今回はaggregatorを使うことにしますので，図19の内容を例外ポリシーに追加してください．その後，ログインシェルのドメインからSSHの秘密鍵へのアクセス許可（図20）を削除しておいてください．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図20 ログインシェルのドメインから削除すべきアクセス許可
+■図23 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/mt-comments.cgi /usr/sbin/sendmail.sendmailドメインのアクセス許可
 <pre>
-allow_write /home/example/.ssh/id_rsa
-allow_write /home/example/.ssh/id_rsa.pub
-allow_mkdir /home/example/.ssh/
-allow_create /home/example/.ssh/id_rsa
-allow_create /home/example/.ssh/id_rsa.pub
+allow_read /etc/host.conf
+allow_read /etc/hosts
+allow_read /etc/mail/submit.cf
+allow_read /etc/mail/trusted-users
+allow_read /etc/nsswitch.conf
+allow_read /etc/passwd
+allow_read /etc/resolv.conf
+allow_read /etc/services
+allow_read /proc/loadavg
+allow_read /proc/stat
+allow_read/write /var/spool/clientmqueue/\*
+allow_capability SYS_IOCTL
+allow_capability SYS_UNLINK
+allow_capability inet_tcp_connect
+allow_capability inet_tcp_create
+allow_capability use_inet_udp
+allow_create /var/spool/clientmqueue/\*
+allow_network TCP connect 0:0:0:0:0:ffff:7f00:1 25
+allow_network UDP connect 192.168.99.2 53
+allow_unlink /var/spool/clientmqueue/\*
 </pre>
 </td></tr>
 </table>
 
-<h3>path_groupの更新</h3>
-
-<p>ログインシェルのドメインに与えられたプログラムの実行許可を見ると，リスト16の内容も学習されていることがわかります．これは前回，実行を許可するコマンドを定義したときに想定していなかったものです．/usr/bin/xargsは複数のファイルに対して一括操作を行うときに便利なコマンドですので，ログインセッションでの実行を許可することにします．このまま図21の内容を残しておいてもかまいませんが，せっかくなのでCOMMANDS_FOR_LOGIN_SESSIONグループに追加してみましょう．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図21 想定していなかったコマンドの実行許可
+■図24 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/mt-feed.cgiドメインのアクセス許可
 <pre>
-allow_execute /usr/bin/xargs
+allow_read /dev/urandom
+allow_read /proc/stat
+allow_read /usr/bin/perl
+allow_read/write /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
+allow_read/write @MT-DB
+allow_read @MT-LIB
+allow_read @PERL-LIB
+allow_capability SYS_IOCTL
+allow_capability SYS_UNLINK
+allow_create /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
+allow_unlink /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
 </pre>
 </td></tr>
 </table>
 
-<p>例外ポリシーの画面に移動して，リスト17というエントリを追加してから，ログインシェルのドメインに戻って図22の内容を削除します．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図22 想定していなかったコマンドの実行許可
+■図25 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/mt-tb.cgiドメインのアクセス許可
 <pre>
-path_group COMMANDS_FOR_LOGIN_SESSION /usr/bin/xargs
+allow_read /dev/urandom
+allow_read /etc/host.conf
+allow_read /etc/hosts
+allow_read /etc/nsswitch.conf
+allow_read /etc/resolv.conf
+allow_read /proc/stat
+allow_read /usr/bin/perl
+allow_read/write /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
+allow_read/write @MT-DB
+allow_read @MT-LIB
+allow_read @PERL-LIB
+allow_capability SYS_IOCTL
+allow_capability SYS_UNLINK
+allow_capability use_inet_udp
+allow_create /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
+allow_network UDP connect 192.168.99.2 53
+allow_truncate @MT-DB
+allow_unlink /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
 </pre>
 </td></tr>
 </table>
 
-<h3>ケイパビリティについて</h3>
-
-<p>学習モードで操作を行うと，図23のようにallow_capabilityで始まる行が学習されたと思います．ケイパビリティは許可する操作種別を指定するだけであるため，操作対象を指定する必要はありません．学習モードで必要だったものは運用中にも必要になるのでそのまま残しておきます．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図23 学習されたケイパビリティの例
+■図26 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/mt.cgiドメインのアクセス許可
 <pre>
-allow_capability SYS_CHMOD
+allow_read /dev/urandom
+allow_read /etc/host.conf
+allow_read /etc/hosts
+allow_read /etc/nsswitch.conf
+allow_read /etc/protocols
+allow_read /etc/resolv.conf
+allow_read /proc/stat
+allow_read /usr/bin/perl
+allow_read/write /var/tmp/CGItemp\$
+allow_read /var/www/cgi-bin/mt/mt-config.cgi
+allow_read/write /var/www/html/mt-static/themes/base-weblog.css
+allow_read/write @MT-BLOG-FILE
+allow_read/write @MT-DB
+allow_read @MT-LIB
+allow_read @MT-PLUGIN
+allow_read @MT-TEMPLATE
+allow_read @PERL-LIB
 allow_capability SYS_IOCTL
-allow_capability SYS_KILL
-allow_capability SYS_LINK
 allow_capability SYS_RENAME
-allow_capability SYS_SYMLINK
 allow_capability SYS_UNLINK
+allow_capability inet_tcp_connect
+allow_capability inet_tcp_create
+allow_capability use_inet_udp
+allow_create /var/tmp/CGItemp\$
+allow_create /var/www/html/mt-static/themes/base-weblog.css
+allow_create @MT-BLOG-FILE
+allow_create @MT-DB
+allow_mkdir /var/www/html/mt-static/themes/
+allow_mkdir @MT-BLOG-DIR
+allow_network TCP connect @HTTP_PING_SERVERS 80
+allow_network UDP connect 192.168.99.2 53
+allow_rename @MT-BLOG-FILE @MT-BLOG-FILE
+allow_rename @MT-DB @MT-DB
+allow_truncate /var/www/html/mt-static/themes/base-weblog.css
+allow_truncate /var/www/mt-db/blog.db
+allow_truncate @MT-BLOG-FILE
+allow_unlink /var/tmp/CGItemp\$
+allow_unlink @MT-DB
 </pre>
 </td></tr>
 </table>
 
-<p>なお，TOMOYO Linuxで扱うケイパビリティは，普通のLinuxが扱うPOSIXケイパビリティとは異なり，独自に定義したものですのでご注意ください．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図27 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/plugins/StyleCatcher/stylecatcher.cgiドメインのアクセス許可
+<pre>
+allow_read /dev/urandom
+allow_read /etc/host.conf
+allow_read /etc/hosts
+allow_read /etc/nsswitch.conf
+allow_read /etc/protocols
+allow_read /etc/resolv.conf
+allow_read /proc/stat
+allow_read /usr/bin/perl
+allow_read /var/www/cgi-bin/mt/mt-config.cgi
+allow_read/write @MT-DB
+allow_read @MT-LIB
+allow_read @MT-PLUGIN
+allow_read @MT-TEMPLATE
+allow_read @PERL-LIB
+allow_capability SYS_IOCTL
+allow_capability inet_tcp_connect
+allow_capability inet_tcp_create
+allow_capability use_inet_udp
+allow_network TCP connect 204.9.178.25 80
+allow_network UDP connect 192.168.99.2 53
+</pre>
+</td></tr>
+</table>
 
-<h3>シグナルについて</h3>
+<h3>強制モードに切り替える</h3>
 
-<p>学習モードで操作中に，allow_signalで始まる行が学習されたかもしれません．TOMOYO Linuxではシグナルの送信先を制限することもできます．シグナルを送信する場合には/bin/killというコマンドを使用します．しかし，/bin/bashなどのシェルは，内部コマンドとしてkillというコマンドを提供しているため，実際には/bin/bashから/bin/killを実行することなくシグナルを送信することができます．そのため，シグナルの送信を制限しない場合，COMMANDS_FOR_LOGIN_SESSIONに/bin/killが含まれていないにもかかわらず，rootユーザとしてログインして/bin/bashの内部コマンドとしてのkillコマンドを使用することで任意のプロセスを強制終了させてしまうことができてしまいます．シグナルのアクセス制御を行うにはプロファイル中でMAC_FOR_SIGNALを有効にします．今回使用しているプロファイルでは有効になっているので，シグナルの送信要求を制限することができます．シグナルに関するアクセス許可の構文は，「allow_signal シグナル番号 送信先ドメイン名」となっています．シグナルの送信先となるプロセスが属しているドメインのドメイン名が「送信先ドメイン名」で始まる場合に， 「シグナル番号」の種類のシグナルを送信できます（いくつか例外がありますが，通常は気にする必要はありません．詳細についてはプロジェクトのwebページのポリシー仕様書を参照ください） ．</p>
+<p>ポリシーエディタを実行して &lt;kernel&gt; /usr/sbin/httpdドメイン以下を選択し，「S」を押してから3を入力して「ENTER」を押します．つまり，&lt;kernel&gt;  /usr/sbin/httpdドメイン以下が強制モードになります．これによりApacheとApacheから起動されるMovable TypeのCGIが保護されている状態になります．今回作成したポリシーは，パス名をpath_group構文で，IPアドレスをaddress_group構文でグループ化しています．そのため，同様な構成で動作するシステムであれば，ポリシーファイルをコピーしてpath_groupやaddress_groupを修正するだけで再利用できることでしょう．筆者はMovable Typeについては初心者であり，まだ試していない機能がたくさんあります．手順としては本稿で説明したとおりですが，もし他に学習させるべき操作や注意点などコメントがあればご連絡いただければ幸いです．</p>
 
-<h2>仕上げ</h2>
+<h3>さらに高度なチューニング</h3>
 
-<h3>学習モードと確認モードを繰り返す</h3>
+<p>TOMOYO Linuxでは必要に応じてアクセス許可に条件を付与することができます．</p>
 
-<p>再度学習モードで学習を行い，確認モードで許可したい操作を行ってください．警告メッセージが表示されないようになれば学習は完了です．確認モードでポリシーエディタを実行し，ログインシェルのドメインに対して不適切なアクセス許可（たとえば/etc/shadowへのアクセス許可や SSH秘密鍵へのアクセス許可など）がないことを確認してください．</p>
+<h4>①rootにmt.cgiを実行させない</h4>
 
-<h3>強制モードに切り替える</h3>
+<p>たとえば， &lt;kernel&gt; /usr/sbin/httpd ドメインに与えられた/var/www/cgi-bin/mt/mt.cgiに対する実行許可に対して「if task.uid!=0 task.euid!=0 task.gid!=0 task.egid!=0」という条件を追加することで，rootユーザの権限のまま/var/www/cgi-bin/mt/mt.cgiが実行されないようにすることができます（図28） ．</p>
 
-<p>ポリシーエディタを用いてログインシェルのドメインとその子孫ドメインに対してプロファイル3を割り当てます．ポリシーエディタなどを用いてポリシーを変更できるのはrootユーザだけです．rootユーザの操作を制限するつもりがないのならこのままでもかまいませんが，rootユーザで行う作業の一部を委託する場合，SSHログインしたログインシェルからポリシーエディタを用いてアクセス制御を無効化されてしまっては困ります．そのため，自分以外にrootユーザとしてSSHログインさせる場合には，ログインシェルのドメイン（&lt;kernel&gt; /usr/sbin/sshd /bin/bash）からポリシーエディタ（ccs-editpolicyやccs-setprofileなど）の実行許可と/proc/ccs/\*へのアクセス許可を削除しておくのを忘れないでください．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図28 rootユーザでの実行を禁止
+<pre>
+allow_execute /var/www/cgi-bin/mt/mt.cgi if task.uid!=0 task.euid!=0 task.gid!=0 task.egid!=0
+allow_read /var/www/cgi-bin/mt/mt.cgi if task.uid!=0 task.euid!=0 task.gid!=0 task.egid!=0
+</pre>
+</td></tr>
+</table>
 
-<p>以上でTOMOYO Linuxを用いてログインセッションを制限する方法の説明は終わりです．</p>
+<h4>②所有者以外にblogデータをアクセスさせない</h4>
 
+<p>Movable Typeがアクセスするファイルに対して「if task.uid=path1.uid」という条件を追加することで，所有者以外の権限で動作しているMovable Typeプロセスからアクセスさせないようにすることができます（図29） ．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図29 自分のホームディレクトリ内だけ読み書きを許可
+<pre>
+allow_read/write /home/\*/public_html/blog/\* if task.uid=path1.uid
+</pre>
+</td></tr>
+</table>
+
+<p>これは，/usr/sbin/suexec経由でMovable Typeを実行している場合に，他人からアクセスされないようにする場合に利用できます．</p>
+
 <h2>次回予告</h2>
 
-<p>2007年1月号から始まった「TOMOYO Linuxの世界」の連載は今回で11回目となりました．基本的な機能およびその使い方について第7回までで紹介し，第8回と9回ではMovable Typeを素材にシステムの構築とポリシーの定義について紹介しました．構築したシステムを安全に運用するためにはログイン後の操作も制限することが大切です．第10回と11回ではログイン後の操作を制限する手法について解説しました．</p>
+<p>今回は，Movable Typeのポリシーをチューニングして，実際に保護するまでの手順について解説しました．利用するパッケージの構成などが変わっても行うべき手順としては今回と大きく変わることはありません．ぜひご自分の環境でTOMOYO Linuxによるセキュリティ強化にチャレンジいただきたいと思います．</p>
 
-<p>システムの運用を開始すると必要になる重要な作業の1つにアップデートがあります．セキュリティ強化OSを用いることで，被害を受ける可能性や被害の範囲を軽減できます．しかし，すべてのセキュリティホールに対処できるわけではありませんから，アップデート作業の必要性はなくなりません．</p>
+<p>本連載では，読者の方々が実際にTOMOYO Linuxを使ううえで参考になるような情報をご紹介したいと思っています．ご利用に際して，不明な点，難しいとお感じになった点，また今後の連載に関するご要望などあれば，お気軽にメーリングリストでご質問ください．</p>
 
-<p>アップデート作業を行うと，プログラムの依存関係やファイルのパス名が変化する場合があるため，ポリシーの見直しが必要になります．しかし，いくら簡単にポリシーを作成できるとしてもアップデートのたびに同じ作業をやり直したくはありませんね．次回は，ソフトウェアのアップデートを支援する TOMOYO Linuxの機能について説明します．</p>
-
 <p><a href="tutorial-10.html.ja">第１０回へ戻る</a>　<a href="tutorial-12.html.ja">第１２回へ進む</a></p>
 
 <hr>
Index: tutorial-12.html.ja
===================================================================
--- tutorial-12.html.ja	(revision 3668)
+++ tutorial-12.html.ja	(working copy)
@@ -3,7 +3,7 @@
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <meta http-equiv="Content-Style-Type" content="text/css">
-<title>TOMOYO Linuxの世界　第１２回：「【最終回】パッケージのアップデートをしてみよう」</title>
+<title>TOMOYO Linuxの世界　第１２回：「【最終回】」</title>
 <link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
 </head>
 <body>
@@ -12,216 +12,212 @@
 <p style="text-align:right;">Last modified: $Date$</p>
 -->
 
-<h1>TOMOYO Linuxの世界<br>第１２回：「【最終回】パッケージのアップデートをしてみよう」</h1>
+<h1>TOMOYO Linuxの世界<br>第１２回：「【最終回】」</h1>
 
-<p>本連載は今回で最終回となります．今回は，TOMOYO Linuxを使ってパッケージのアップデートを行う方法を解説します．</p>
-
 <h2>今回の内容</h2>
 
-<p>セキュアOSを導入していれば，プロセスを乗っ取られたり，管理者権限を不正に奪われたりしてもそれがただちに致命的被害にはつながりません．システムのアップデートについて，標準のOSほど神経を使わなくても良くなりますが過信は禁物です．アップデートを適用しシステムを万全な状態に維持しましょう．強制アクセス制御機能を搭載しているOSでは，管理者が定義したポリシーにより振る舞いが制限されます．そのため，ソフトウェアのアップデートなどによりプログラムの依存関係などが変化した場合，ポリシーを修正してやらないと正常に動作できなくなってしまう可能性があります．管理者が自らポリシーを作成するという考え方を持つTOMOYO Linuxでは，ポリシーの修正も自力で行わなければいけません．今回は，ソフトウェアのアップデートに伴って必要となる，ポリシーの修正作業を支援する機能について紹介します．</p>
+<p>今回は読み物です．</p>
 
-<h2>ポリシーの修正を支援する機能について</h2>
+<h2>パス名に基づくアクセス制御の注意点</h2>
 
-<h3>使用するプログラム</h3>
+<p>TOMOYO Linuxはパス名に基づきアクセスを制御します．ポリシーファイルの中でもパス名を用いて記述しますから，パス名の正しさが保たれていなければ，期待された効果をあげられません．ファイルシステムが意図したとおりにマウントされていることも不可欠です．</p>
 
-<p>TOMOYO Linuxでは，ポリシーの修正を支援するためのツールとして，図1のプログラムを提供しています．</p>
+<p>今回例として紹介する操作はファイルシステムに関する操作であるため，一歩間違えるとファイルにアクセスできなくなったりシステムが動作しなくなったりする危険があります．記事を読みながら実際に動作を確認される際にはご注意ください．万一起動できなくなってしまった場合には，本記事末尾のレスキュー手順を参照してください．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図1 TOMOYO の管理を行うためのプログラム<br>
-<table border="1" summary="fig">
-<tr><td>プログラム名</td><td>役割</td></tr>
-<tr><td>ccs-queryd</td><td>アクセス要求を対話的に許可する</td></tr>
-</table>
-</td></tr>
-</table>
+<h3>パス名は便利だけど曖昧</h3>
 
-<h3>コンソールでの操作例</h3>
+<p>ユーザにはそれぞれホームディレクトリという領域が割り当てられており，そこに個人が管理するデータを保存しています．そのため，たとえば"mount -t tmpfs none /home/"というマウントが行われてしまうと，一般ユーザのホームディレクトリが見えなくなってしまいます（図1）．</p>
 
-<p>まずはログイン後の操作を制限する場合の例で説明します．操作を間違えてロックアウトされてしまわないようにするため，この連載ではexampleというユーザを作成して作業することにします．また，exampleユーザとrootユーザの作業をコンソールウィンドウの切り替えを行いながら進めることにします．コンソールウィンドウの切り替えは「ALT」＋「F1」～「F6」で行います．「ALT」＋「F1」でウィンドウ1を開き，rootユーザとexampleユーザのシェルを異なるものに設定してください．これは，ログインシェルを異なるものにすることによって，ログインシェルのドメインを異なるものにし，特定のログインシェルのドメインだけでアクセス制御を有効にするためです．本連載ではrootユーザのシェルは/bin/bashの場合で説明しているので，exampleユーザには/bin/tcshを割り当てます（図2） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図2 exampleユーザに/bin/tcshを割り当てる
+■図1 一般ユーザのホームディレクトリが見えない
 <pre>
-# usermod -s /bin/tcsh example
+# ls -l /home/
+total 8
+drwx------3 user1 user1 4096 Feb 21 10:16 user1
+drwx------3 user2 user2 4096 Feb 21 10:17 user2
+# mount -t tmpfs none /home/
+# ls -l /home/
+total 0
+# umount /home/
+# ls -l /home/
+total 8
+drwx------3 user1 user1 4096 Feb 21 10:16 user1
+drwx------3 user2 user2 4096 Feb 21 10:17 user2
 </pre>
 </td></tr>
 </table>
 
-<p>次に「ALT」＋「F2」でウィンドウ2を開き，exampleユーザとしてログインしてください．CentOS 5.3の場合，コンソールからログインしたドメインは「&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh」となるはずです．（sshdからログインした場合は「&lt;kernel&gt; /usr/sbin/sshd /bin/tcsh」となるはずです．）ウィンドウ1に切り替えて，このドメインに対して強制モード用のプロファイル（プロファイル3）を割り当てます（図3） ．</p>
+<p>また，Linuxでは，あるディレクトリの内容を別のディレクトリからも見えるようにする bind mountという機能（ハードリンク機能のディレクトリ版に相当）を備えているので，"mount --bind / /var/www/html/"というマウントが行われてしまうと，Webサーバを通じて/ディレクトリ以下の全内容が丸見えになってしまいます（図 2）．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図3 exampleユーザのシェル（ウィンドウ2）のドメインに強制モード用プロファイルを割り当て
+■図2 Webサーバを通じて/ディレクトリ以下が丸見えに
 <pre>
-# /usr/sbin/ccs-setprofile -r 3 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh'
+# ls /var/www/html/
+en index.html.en index.html.ja index.var ja tomoyo-links.html tomoyo.css
+# mount --bind / /var/www/html/
+# ls /var/www/html/
+bin boot dev etc home initrd lib lost+found media misc mnt opt proc root sbin selinux srv sys tmp usr var
+# umount /var/www/html/
+# ls /var/www/html/
+en index.html.en index.html.ja index.var ja tomoyo-links.html tomoyo.css
 </pre>
 </td></tr>
 </table>
 
-<p>これにより，exampleユーザのシェル（ウィンドウ2）からは，ほとんど何もできない状態になります（図4） ．</p>
+<p>これまでの例で，パス名というものはマウントの内容1つでがらりと変わってしまうということをご理解いただけたと思います．もちろん，このような異常なマウントは正規の管理者であれば行わないはずですが，管理者権限で動作しているプロセスの欠陥を攻撃して侵入してきたクラッカーが行わないとは限りません．TOMOYO Linuxではそうした脅威を防ぐための機能を備えています．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図4 図3の適用結果を確認
-<pre>
-$ ls
-/bin/ls: Operation not permitted.
-$ cat /etc/passwd
-/bin/cat: Operation not permitted.
-</pre>
-</td></tr>
-</table>
+<h3>曖昧さを減らすために</h3>
 
-<p>ccs-querydというプログラムを使用する（図5）と，強制モードで動作中のプロセスがポリシーに違反する内容のアクセス要求を行った場合でも，ただちに拒否するのではなく，システム管理者の指示を仰ぐようにすることができます．このモードは，SELinuxやAppArmorには存在しない，TOMOYO Linux特有の機能です．</p>
+<p>TOMOYO Linuxでは，allow_mountというキーワードを用いて，マウント可能なデバイスファイルとマウントポイントの組み合わせを制限できます．これにより，システム管理者が許可したいマウントだけを許可できるようになります．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図5 ccs-querydの実行
-<pre>
-# /usr/sbin/ccs-queryd
-</pre>
-</td></tr>
-</table>
+<h3>それだけで充分？</h3>
 
-<p>ウィンドウ2に切り替えて，/bin/lsコマンドの実行を要求してみましょう（図6）．</p>
+<p>allow_mountキーワードでマウントを制限するだけで充分なのでしょうか？次のようなケースを考えてみましょう．</p>
 
+<p>まず，マウントポイントとして/mnt/dir/を作成します．次に，/mnt/dir/の上にtmpfsをマウントし，/mnt/dir /fileという名前のファイルを作成します（図3）．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図6 lsコマンドを実行
+■図3 /mnt/dir/にtmpfsをマウントし，/mnt/dir/fileを作成
 <pre>
-$ /bin/ls
+# mkdir -p /mnt/dir
+# mount -t tmpfs none /mnt/dir/
+# touch /mnt/dir/file
+# ls /mnt/dir/file
+/mnt/dir/file
 </pre>
 </td></tr>
 </table>
 
-<p>先ほどはただちに拒否されてしまいましたが，今度は拒否されずに止まっています．この状態のままウィンドウ1に切り替えてみましょう．すると，図7のようなプロンプトが表示されているはずです．</p>
+<p>この状態で，再度/mnt/dir/の上にtmpfsをマウントすると，/mnt/dir/fileが見えなくなってしまいました（図4）．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図7 図6実行後，ウィンドウ1に表示されるプロンプト
+■図4 再度tmpfsをマウントすると，/mnt/dir/fileが見えない
 <pre>
-#2010-05-13 15:29:35# profile=3 mode=enforcing (global-pid=4561) task={ pid=4561 ppid=4557 uid=502 gid=502 euid=502 egid=502 suid=502 sgid=502 fsuid=502 fsgid=502 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=0 gid=0 ino=1507379 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=1507329 perm=0755 } exec={ realpath="/bin/ls" argc=1 envc=6 argv[]={ "ls" } envp[]={ "TERM=xterm" "PATH=/sbin:/usr/sbin:/bin:/usr/bin" "PWD=/" "LANG=en_US.UTF-8" "SHLVL=1" "_=/bin/cat" } }
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh
-allow_execute /bin/ls
-Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):
+# mount -t tmpfs none /mnt/dir/
+# ls /mnt/dir/file
+ls: /mnt/dir/file: No such file or directory
+# umount /mnt/dir/
+# ls /mnt/dir/file
+/mnt/dir/file
+# umount /mnt/dir/
 </pre>
 </td></tr>
 </table>
 
-<p>最初の行はポリシーに違反するアクセス要求を行ったプロセスの属しているドメイン名が，2行目はアクセス要求の内容が表示されています．このように，ドメイン用ポリシーと同じ構文で要求内容が表示されます．ここで，「Y」を押すと，そのアクセス要求を許可することができます．また，「N」を押すと，そのアクセス要求を拒否することができます．「Y」キーを押した場合，/bin/lsの実行が許可されますが，ドメイン用ポリシーの中には/bin/lsを実行するためのドメインがまだ作成されていません．そのため，図8のようなプロンプトが表示されます．</p>
+<p>アンマウントすれば元に戻るわけですが，前述したallow_mountキーワードによるマウント制限だけでは，マウント可能なデバイスファイルとマウントポイントの組み合わせを制限できても，許可されている組み合わせで複数回マウントすることは防げないことがわかります．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図8 ドメイン作成の許可を求めるプロンプト
-<pre>
-#2010-05-13 15:29:40# profile=3 mode=enforcing (global-pid=4561) task={ pid=4561 ppid=4557 uid=502 gid=502 euid=502 egid=502 suid=502 sgid=502 fsuid=502 fsgid=502 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=0 gid=0 ino=1507379 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=1507329 perm=0755 } exec={ realpath="/bin/ls" argc=1 envc=6 argv[]={ "ls" } envp[]={ "TERM=xterm" "PATH=/sbin:/usr/sbin:/bin:/usr/bin" "PWD=/" "LANG=en_US.UTF-8" "SHLVL=1" "_=/bin/cat" } }
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh
-# wants to create domain
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh /bin/ls
-Allow? ('Y'es/'N'o/'R'etry):
-</pre>
-</td></tr>
-</table>
+<p>でも，ちょっと待ってください．普通は，マウントは/ディレクトリに近い順に行いますよね．たとえば，/usr/と/usr/local/が別パーティションになっている場合，/usr/→/usr/local/の順にマウントするでしょう．/usr/local/→/usr/の順番にしてしまうと /usr/local/の内容が見えなくなってしまい，システムの動作に支障が発生するので，そのような順番にはしません．つまり，既存のマウントを隠蔽するようなマウントは禁止してしまっても大丈夫ということです．</p>
 
-<p>「Y」を押した場合，/bin/ls用のドメインが作成されるので，/bin/lsは先に進むことができます．「N」を押した場合，ドメインが見つからないという理由で/bin/lsの実行要求は拒否されます．/bin/lsのドメインの作成を許可すると，図9のように聞かれます．</p>
+<p>TOMOYO Linuxでは，既存のマウントを隠蔽するようなマウントを行う場合，conceal_mountという（TOMOYO Linux独自の）ケイパビリティがチェックされます（図5）．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図9 ドメイン作成を許可した際のプロンプト
+■図5 既存のマウントを隠蔽するようなマウントを行うためのアクセス許可
 <pre>
-#2010-05-13 15:29:45# profile=3 mode=enforcing (global-pid=4561) task={ pid=4561 ppid=4557 uid=502 gid=502 euid=502 egid=502 suid=502 sgid=502 fsuid=502 fsgid=502 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=0 gid=0 ino=1507380 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=1507329 perm=0755 }
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh /bin/ls
-allow_read /etc/selinux/config
-Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):
+allow_capability conceal_mount
 </pre>
 </td></tr>
 </table>
 
-<p>/bin/lsのドメインは作成されたばかりですから，何もアクセス許可が与えられていません．表示されている内容を見ながら，許可するかどうかを慎重に判断して回答してください．「A」を押すと，必要に応じてアクセス許可の内容を編集してポリシーに追加してから再試行することができます．たとえば/etc/passwdだけでなく，/etc/\*shadow\*以外の/etc/\*に一致するファイルへのアクセスを許可したい場合には，/etc/passwdという内容を/etc/\*\-\*shadow\*に書き換えてから「ENTER」を押してください． ccs-querydを終了させるには「CTRL」＋「C」を押してください．</p>
+<h3>アンマウントは？</h3>
 
-<p>ccs-querydを使う際には，無条件にアクセス要求の内容を許可しないように注意してください．ポリシー違反の原因がクラッカーの攻撃によるものであった場合，せっかくの強制アクセス制御によるシステムの保護が無意味になってしまいます．（もしポリシー違反の原因がクラッカーによる攻撃であるかどうかをコンピュータ自身が判断できるのであれば，人間がポリシーを作成する必要はなくなりますが，実際にはそういうわけにはいきません．判断するのは人間の役目なのです．）</p>
+<p>マウントを制限するだけでは，まだ不十分です．たとえば，/proc/ディレクトリにマウントされているprocファイルシステムがアンマウントされてしまうと，多くのプログラムが正常に動作できなくなってしまう可能性があります．</p>
 
-<h2>実際のサービスに対する操作例</h2>
+<p>TOMOYO Linuxでは，allow_unmountというキーワードを用いて，アンマウント可能なマウントポイントを制限できます．</p>
 
-<p><a href="http://tomoyo.sourceforge.jp/1.7/enforcing.html#using_interactive_mode">ソフトウェアのアップデート時に発生するポリシー違反を処理する</a>を参照してください．</p>
+<p>以上でマウントおよびアンマウントの制御の説明を終わります．</p>
 
-<h3>共有ライブラリの扱い</h3>
+<h3>chrootは？</h3>
 
-<p>TOMOYO Linuxのインストール時に実行したinit_policyにより，/etc/ld.so.cacheに登録されている共有ライブラリ（/sbin/ldconfig -NXpにより確認できます）に関しては例外ポリシーでallow_read（無条件に参照を許す）という指定が行われているため，ドメイン用ポリシーで個別に読み込みアクセスの許可を与える必要はありません．しかし，ソフトウェアのアップデートに伴い，共有ライブラリのバージョンを含むファイル名が変化した場合，そのままではサービスの再起動に失敗してしまう可能性があります．新しくインストールされたライブラリファイルに関しては，例外ポリシーにallow_readという指定が行われるよりも前に要求された場合，例外ポリシーにもドメイン用ポリシーにも指定されていないのでポリシー違反と判断されます．</p>
+<p>Linuxでは，chrootという，ルートディレクトリを変更する機能を備えています．アプリケーションがchrootを用いて/tmp/のように書き込み可能なディレクトリへルートディレクトリを変更できてしまうと，悪意あるプログラム一式を展開して実行されてしまう危険性があります．</p>
 
-<p>先に説明したccs-querydにより検出してポリシーに追加していくことは可能ですが，このような場合に限っては，自動的にallow_readという指定を更新してくれたほうが便利でしょう．そのため，ccs-querydはポリシー違反の発生を監視するだけではなく，ライブラリファイルの情報を集めたファイルである/etc/ld.so.cacheの変化を監視し，自動的にallow_readを例外ポリシーに追加するようになっています．</p>
+<p>TOMOYO Linuxはchroot前のルートディレクトリから見たパス名を記憶しており，chrootする前のパス名でアクセス制御をするため，どこに chrootしても問題ありませんが，
+allow_chrootというキーワードを用いて移動可能なディレクトリを制限できます．</p>
 
-<h3>まとめ</h3>
+<h3>デバイスファイルの作成は？</h3>
 
-<p>手順をまとめると以下のようになります．</p>
+<p>Linuxでは，マウントするときもデバイス名を使います（LABEL=やUUID=という指定方法も使えますが，ここでは侵入者が前述したマウント制限の突破を試みる場合を想定します）．たとえば，SCSI接続された最初のHDDの最初のパーティションをマウントするときには"mount -dev=0801 /mnt/"のようにデバイスの属性ではなく，"mount /dev/sda1 /mnt/"のようにデバイス名を使います．これが正しく動作するためには，デバイスファイルが指すデバイスが，管理者が期待したとおりの属性を持っていることが不可欠です．いくらマウントできるデバイス名とマウントポイントの組み合わせを制限しても，デバイスファイルが改竄されていたら何の役にも立ちません．root権限があれば，ファイルを削除して同名のファイルを作り直すことで改竄できてしまいます．</p>
 
-<ol>
-<li>ウィンドウ1でポリシーに違反するアクセス要求を監視するccs-querydを実行</li>
-<li>ウィンドウ2で実際のアップデート操作（yum -y update）を行う</li>
-<li>ウィンドウ1のccs-querydを終了</li>
-</ol>
+<p>パス名が指すデバイスが期待していたものとは違っていたら何が起こるでしょう？たとえば，/dev/nullが通常ファイルになっていたら……．消えたはずだと思っていた情報が蓄積されていき，情報漏洩や誤動作の原因になる場合もあります．たとえば，/dev/sda1が/dev/sda2の属性を持っていたら…．/home/ディレクトリにマウントされるべき内容が/var/ディレクトリにマウントされてしまい，ユーザがログインできなくなってしまったという事態も起こり得ます．そのような不安を解消するために，TOMOYO Linuxではallow_unlink（ファイルの削除を許可）やallow_mkblock（ブロック型デバイスファイルの作成を許可）のように書き込み権限を細分化することでリスクを減らしています．</p>
 
-<h2>ポリシーのゴミを除去する機能について</h2>
+<h2>レスキュー手順</h2>
 
-<h3>使用するプログラム</h3>
+<p>もし，TOMOYO Linuxのアクセス制御が原因でシステムが起動できなくなった場合には，カーネル起動時のコマンドラインに ccsecurity=off というパラメータを追加することにより，TOMOYO Linuxのアクセス制御を無効化して起動することができます．</p>
 
-<p>TOMOYO Linuxでは，ポリシーに含まれる不要なアクセス許可の削除を支援するためのツールとして，図10のプログラムを提供しています．</p>
+<h2>TOMOYOプロジェクト便り</h2>
 
-<table border="1" summary="fig">
-<tr><td>
-■図10 TOMOYO の管理を行うためのプログラム<br>
-<table border="1" summary="fig">
-<tr><td>プログラム名</td><td>役割</td></tr>
-<tr><td>ccs-findtemp</td><td>存在しないパス名を検出する</td></tr>
-<tr><td>ccs-domainmatch</td><td>アクセス許可が与えられているドメインを検索する</td></tr>
-</table>
-</td></tr>
-</table>
+<p>2006年12月にCE Linux Forumのイベント，「Japan Technical Jamboree12」で，組込みLinuxフォーラムの関係の方々にTOMOYO Linuxをご紹介させていただきました．そのときの説明資料と様子は，<a href="http://tree.celinuxforum.org/CelfPubWiki/JapanTechnicalJamboree12">Wikiページ</a>で参照することができます．</p>
 
-<p>これらを使うことで，パターン化する前のテンポラリファイルやソフトウェアのアップデートにより削除されたライブラリファイルなどの余計なアクセス許可を検出して除去することができます．</p>
+<p>Linuxはデジタルテレビや携帯電話など組込み機器の分野でも急速に利用が広まっています．ハードディスクレコーダーが掲示板への書き込みの踏み台にされたり，携帯電話を対象にしたウィルスが問題になるなど，セキュリティに対する関心は，むしろ通常のサーバ用途以上に高まっています．</p>
 
-<h3>コンソールでの操作例</h3>
+<p>イベントでは多数の貴重なご意見をいただきましたが，その中に「ぜひTOMOYO Linuxをメインラインに含めることを目指してほしい」という声がありました．このイベントの関係の方々から，2007年4月に米サンノゼで開催される組込みLinuxの国際会議，「<a href="http://www.celinux.org/elc2007/">CELF Embedded Linux Conference</a>」をご紹介いただき，投稿したところプレゼンテーションとチュートリアルを行えることになりました．TOMOYO Linuxとしての世界デビューとなります．</p>
 
-<p>簡単に試してもらうために，コンソールで説明することにします．学習モードの状態で図11の操作を行ってみてください．</p>
+<p>また、2007年2月にYLUGのイベント，「第72回カーネル読書会」でもTOMOYO Linuxをご紹介させていただきました．そのイベントでもメインラインへ向けて頑張るよう激励され，このイベントの参加者の方々から2007年6月にカナダのオタワで開催されるLinuxの国際会議「<a href="http://www.linuxsymposium.org/2007/">Linux Symposium 2007</a>」をご紹介いただき，投稿したところBoFセッションを行えることになりました．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図11 学習モードで行う操作
-<pre>
-# touch /tmp/abc12345
-# rm -f /tmp/abc12345
-</pre>
-</td></tr>
-</table>
+<p>今年はメインストリームを目標に一気に活動が広がるかもしれません．TOMOYOプロジェクトでは，社外からも開発者やテスターなどを募集しています．みんなの力で盛り上げていきたいと思います．</p>
 
-<p>この操作によりtouchとrmの/tmp/abc12345に対するアクセスが学習されましたが，/tmp/abc12345というファイル自体はもう存在しません．この操作が本来不要なものであればポリシーに使われないアクセス許可が残されたことになります．このように，ポリシーには記録されていても存在しないパス名は，テンポラリファイルとして使用されていたか，アップデートにより削除された可能性が高いと言えます．この状態で，ccs-findtempコマンドはそうした可能性を持つファイルを探します．なお，図12の実行例では/tmp/abc12345というパス名しか表示されていませんが，実際には他のパス名も表示されるはずです．</p>
+<p>このコラムは2007年3月28日に執筆していますが，読者の皆さんがこの号を手にとられるときにはCELFの発表が終了しているはずです．今後連載の中で組込み向けの機能や会議の様子についてご紹介していきたいと思います．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図12 ccs-findtempの実行例
-<pre>
-# /usr/sbin/ccs-findtemp &lt; /proc/ccs/domain_policy
-/tmp/abc12345
-# /usr/sbin/ccs-findtemp --with-domainname &lt; /proc/ccs/domain_policy
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/touch
-/tmp/abc12345
-/tmp/abc12345
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/rm
-/tmp/abc12345
-# /usr/sbin/ccs-domainmatch /tmp/abc12345
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/touch
-allow_create /tmp/abc12345
-allow_write /tmp/abc12345
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/rm
-allow_unlink /tmp/abc12345
-</pre>
-</td></tr>
-</table>
+<h2>今回の内容</h2>
 
-<p>ccs-findtempにより表示されたパス名を引数としてccs-domainmatchコマンドを実行すると，引数で指定されたパス名に対するアクセス許可を含んでいるドメインが表示されます．不要だと判断した場合には，ccs-editpolicyを起動して，当該するドメインへ移動し，不要なアクセス許可を削除します．</p>
+<p>今回は4月に発表を行ったELC2007の様子も紹介します．リリースの詳細については，<a href="http://sourceforge.jp/projects/tomoyo/news/">プロジェクトのニュース</a>や<a href="http://lists.sourceforge.jp/mailman/archives/tomoyo-users/">メーリングリストのアーカイブ</a>にてご確認ください．</p>
 
+<h2>ELC2007レポート</h2>
+
+<h3>ELC2007について</h3>
+
+<p>連載第5回で予告したように4月17～19日までサンノゼで開催されたCE Linux Forum Worldwide Embedded Linux Conference 2007に参加し，TOMOYO Linuxのプレゼンテーションとチュートリアルを行ってきました．</p>
+
+<ul>
+<li><a href="http://www.celinux.org/elc2007/">イベントWebページ</a></li>
+<li><a href="http://tree.celinuxforum.org/CelfPubWiki/ELC2007Presentations">プレゼンテーション資料</a></li>
+<li><a href="http://tree.celinuxforum.org/CelfPubWiki/JapanTechnicalJamboree12">CELinux Forum Japan Technical Jamboree12</a></li>
+</ul>
+
+<p>CE LinuxのCEはConsumer Electronicsの略です．本会議については，2006年12月8日にJapan Technical Jamboree12でTOMOYO Linuxについて紹介させていただいた際に， 「ぜひ国内だけでなく海外のイベントでも発表してみては」とお勧めいただいたことが応募のきっかけとなり実現しました．</p>
+
+<h3>会議の模様</h3>
+
+<p>会議は，3つの部屋でプログラムが同時進行するという形式で行われ，参加者は興味のあるセッションを自由に選択します．参加者名簿がないので正確な人数はわかりませんが，会場の規模から判断して少なくとも200名以上が参加していたと思います．</p>
+
+<p>発表の内容はハードウェアからソフトウェアまで多岐にわたり，組込みLinuxの領域の広さをあらためて感じました．キーノートセッションは，Thomas Gleixner氏によるしゃれっ気に満ちた“Embedded Linux - An Increasing Nightmare?” （ 「組込みLinuxは増殖する悪夢か？」 ）と，LinuxDevice Driversの著者で有名なJonathan Corbet氏による“The State of the Linux Kernel” （ 「Linuxカーネルの状態」 ）の2本で（資料はいずれも上記のプレゼンテーション資料のリンクより参照，ダウンロードできます） ，BOFも含めると56ものセッションがありました．</p>
+
+<p>セキュリティに関するものは残念ながらあまり多くはなく，日立ソフトウェアエンジニアリング㈱中村雄一氏の“Comparison of Secure OSes and Embedded SELinux Activity in Japan”と，TOMOYO Linuxのプレゼンテーション“TOMOYOLinux - A Lightweight and Manageable Security System for PC and Embedded Linux” ，およびチュートリアル“TOMOYO Linux - Tutorial”の3本でした．</p>
+
+<p>プログラムでは予定されていなかったのですが，「日本セキュアOS連合チーム」はデモにも参加しました．</p>
+
+<p>TOMOYO Linux関連のセッションについての反響ですが，残念ながら参加者はあまり多くありませんでした．ただ，Jonathan Corbet氏が足を運んでくれて，発表を聞いてもらうことができ，「 （TOMOYO Linuxと同じくパス名ベースのアクセス制御を行っている）AppArmorのチームと話をしてみると良い」 「できるだけ早くLinuxカーネルに対するパッチを投稿してみるべきだ」などのコメントをいただくことができました．これらのアドバイスについては，帰国後さっそく対応を行っています．</p>
+
+<p>余談ですが，氏は大変長身で，話をすると見上げるような形になります．発言は静かですが深みがあり， 「達人」という言葉を連想しました．</p>
+
+<h3>サンノゼ，会場の様子</h3>
+
+<p>サンノゼを訪れたのは今回が初めてでしたが，とにかくお店が少なく，人が歩いていないところという印象でした．宿泊したホテルから会場まで徒歩約 30分の距離を毎日往復しましたが，基本的に他の人とすれ違うことはありません（歩いている人はほとんどいないのです） ．空はまさに「カリフォルニアの青い空！」という感じで，CGで描いたような色をしています．</p>
+
+<p>会場は会議用の施設で，無線LAN の設備が提供されていましたが，セキュリティはかかっておらず（笑） ，誰でも自由につなげられます．2日目の夜にはレセプションがあり，チャーターバスで何故か博物館に連れて行かれ，そこで立食パーティが開催されました．</p>
+
+<h3>ゲーム</h3>
+
+<p>最終日，すべてのセッションが終了後，ELC恒例（？）のゲームが始まるというので呼び出されました．</p>
+
+<p>ゲームの内容は，人物，契約などテーマ毎に分類されたクイズを参加者の出身地区3つを代表するメンバー3人が回答するというもので，どうやらアメリカの有名なクイズ番組のパロディのようです．</p>
+
+<p>問題はテーマごとに難易度の異なるものが配置されていて，当然ながら難しいものほど得点が高くなっています．司会は，CE Linux Forum の Wiki の管理者でもある Tim Bird氏が行いましたが，設問が茶目っ気たっぷりで大変楽しいものでした．たとえば， 「人物」ではLinus氏のアップの写真が投影されて， 「これは誰でしょう？」という感じです．</p>
+
+<h3>そしてOLSへ！</h3>
+
+<p>ELC2007への参加はもちろん，世界の組込み Linux の関係者に対して TOMOYO Linux を知ってもらうことが目的でしたが，それは同時にメインライン化（Linuxカーネル本体への取り込み）提案を行うための最初のステップでもありました．</p>
+
+<p>本誌が店頭に並ぶのは6月18日ですが，6月27～29日までオタワで開催される Ottawa Linux Symposium（通称OLS）では，TOMOYO Linux の BOFセッションを持ちます．国産セキュアOSであるTOMOYO Linuxの開発を通じて得られたものを Linux の世界とコミュニティにフィードバックすることができればと願っています．</p>
+
+<h2>まとめ</h2>
+
+<p>セキュアOSというと「なんだか難しそう」「特殊な技術」「使えない」というイメージがありますが，TOMOYO Linuxに関しては決してそんなことがないことをご理解いただけたのではないかと思います．セキュアOSは，バッファオーバーフローによる侵入を防ぐための保険としてだけではなく，抜け道を心配しながらのアプリケーションレベルでの複雑な設定をも一掃してくれる，便利な機能を備えています．この連載が，セキュアOSによるセキュリティ強化推進の役に立つことを願っています．ぜひ連載の原稿を手元に置きながら，TOMOYO Linuxを皆さまのサーバのセキュリティ強化にご活用ください．</p>
+
 <h2>本連載のまとめ</h2>
 
 <p>2007年1月号から始まった本連載は，12回目となる今回で終了することとなりました．連載に先立ち特集を掲載いただいた『ネットワークセキュリティ Expert 5』（技術評論社）ともども，TOMOYO Linuxとしては初の活字メディアであり，執筆者としても思い入れの深いものとなりました．執筆にあたっては，リファレンス的な使い方を意識し，Webの情報を補完するものとして活用いただくことを心がけました．行き届かない面も多々あったと思いますが，皆さんのおかげで1年の連載を無事完了できました．ここに深く感謝致します．連載は終ってもTOMOYO Linuxの活動はまだ続きます．また，皆さんとお会いできることを楽しみにしています．</p>
Index: tutorial-1.html.ja
===================================================================
--- tutorial-1.html.ja	(revision 3668)
+++ tutorial-1.html.ja	(working copy)
@@ -13,8 +13,6 @@
 <p style="text-align:right;">Last modified: $Date$</p>
 <h1>TOMOYO Linux の世界<br>第１回：「ポリシー自動学習を経験する」</h1>
 
-<p>今回から始まる本連載では，国産のセキュアＯＳとして注目を集めている「 TOMOYO Linux 」にフォーカスを当て，その使いこなし術を徹底的に解説していきます．どうぞお楽しみに！</p>
-
 <h2>TOMOYO Linux の世界へようこそ</h2>
 
 <h3>TOMOYO Linux とは</h3>
Index: tutorial-2.html.ja
===================================================================
--- tutorial-2.html.ja	(revision 3668)
+++ tutorial-2.html.ja	(working copy)
@@ -14,8 +14,6 @@
 
 <h1>TOMOYO Linux の世界<br>第２回：「アクセス制御を経験する」</h1>
 
-<p>連載第２回となる今回は， TOMOYO Linux における制御モードとプロファイルについて紹介し，それらを組み合わせて実際に強制アクセス制御を行うまでを紹介します．</p>
-
 <h2>今回の内容</h2>
 
 <p>前回は， TOMOYO Linux の導入からファイルに対するアクセスの自動学習の手順と学習結果の保存までを紹介しました．今回は TOMOYO Linux における制御モードとプロファイルについて紹介し，それらを組み合わせて実際に強制アクセス制御を行うまでを紹介します．</p>
@@ -340,7 +338,7 @@
 
 <p>今回は実際にアクセス制御を行う手順と， Web サービスを保護する方法について紹介しました． TOMOYO Linux の基本的な操作方法は，前回と今回で説明した内容に含まれており，ここに書かれた内容を理解すれば，「 TOMOYO Linux を使える」と言って良いでしょう．</p>
 
-<p>次回は，ポリシーのチューニングの続きと，それを支援する機能について紹介します．どうぞお楽しみに．</p>
+<p>次回は， TOMOYO Linux のドメイン遷移について紹介します．どうぞお楽しみに．</p>
 
 <p><a href="tutorial-1.html.ja">第１回へ戻る</a>　<a href="tutorial-3.html.ja">第３回へ進む</a></p>
 
Index: tutorial-3.html.ja
===================================================================
--- tutorial-3.html.ja	(revision 3668)
+++ tutorial-3.html.ja	(working copy)
@@ -3,7 +3,7 @@
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <meta http-equiv="Content-Style-Type" content="text/css">
-<title>TOMOYO Linux の世界　第３回：「ポリシーをチューニングしてみよう」</title>
+<title>TOMOYO Linux の世界　第３回：「ドメイン遷移をマスターしよう」</title>
 <link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
 </head>
 <body>
@@ -12,13 +12,11 @@
 -->
 <p style="text-align:right;">Last modified: $Date$</p>
 
-<h1>TOMOYO Linux の世界<br>第３回：「ポリシーをチューニングしてみよう」</h1>
+<h1>TOMOYO Linux の世界<br>第３回：「ドメイン遷移をマスターしよう」</h1>
 
-<p>「 TOMOYO Linux 」の魅力をお届けする連載の第３回．今回は， TOMOYO Linux を使いこなすうえで必須のポリシーチューニング手法について解説していきます．どうぞお楽しみに．</p>
-
 <h2>今回の内容</h2>
 
-<p>第２回は， TOMOYO Linux における制御モードとプロファイルについて紹介し，それらを組み合わせて実際に強制アクセス制御を行う手順について紹介しました．やや駆け足でしたが，実はこれまでの部分で TOMOYO Linux の基本部分の説明は終わっています．今回からは必要に応じて説明を補足しながら，詳細，応用的な使い方について紹介していくことにします．どうぞおつきあいください．今回のテーマは，ポリシーのチューニングと，それを支援する機能についてです．</p>
+<p>第２回は， TOMOYO Linux における制御モードとプロファイルについて紹介し，それらを組み合わせて実際に強制アクセス制御を行う手順について紹介しました．やや駆け足でしたが，実はこれまでの部分で TOMOYO Linux の基本部分の説明は終わっています．今回からは必要に応じて説明を補足しながら，詳細，応用的な使い方について紹介していくことにします．どうぞおつきあいください．今回のテーマは，ドメイン遷移についてです．</p>
 
 <h2>ドメイン遷移をマスターする</h2>
 
@@ -203,569 +201,9 @@
 
 <p>TOMOYO Linux の自動ドメイン定義機能は強力です．しかし，実行するプログラムの限定とそのアクセス制御は行いたいけれども，プログラムの実行順序が特定できないような場合（典型的なものとしてはログイン後の作業）はポリシーの策定が大変です．グループ化を行うことで，ログイン後のドメインをグループ化してから，そのドメインに強制モード用のプロファイルを割り当てれば，コマンドの実行順序は制限せずにアクセス可能な資源だけを制限することができます．また，強制モード用以外のプロファイルを割り当てれば，従来の Linux と同様に自由に振る舞うことができるようになります．</p>
 
-<h2>アクセス許可に条件を付ける</h2>
-
-<h3>条件付きアクセス許可について</h3>
-
-<p>TOMOYO Linux には RBAC （ Role Based Access Control ）機能はありませんが，ポリシーの中でユーザＩＤに基づく条件を付けることができます．これにより，システムアカウントのユーザＩＤに基づくアクセス制御が可能です．条件はアクセス許可の後ろに「 if 条件式」という形で指定します．利用できる条件について図１７に，使い方の例を図１８に示します．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図１７　条件指定に使えるパラメータ<br>
-<table border="1" summary="fig">
-<tr><td>変数</td><td>意味</td></tr>
-<tr><td>task.uid</td><td>呼び出したプロセスのユーザＩＤ</td></tr>
-<tr><td>task.euid</td><td>呼び出したプロセスの実効ユーザＩＤ</td></tr>
-<tr><td>task.suid</td><td>呼び出したプロセスの保存ユーザＩＤ</td></tr>
-<tr><td>task.fsuid</td><td>呼び出したプロセスのファイルシステムユーザＩＤ</td></tr>
-<tr><td>task.gid</td><td>呼び出したプロセスのグループＩＤ</td></tr>
-<tr><td>task.egid</td><td>呼び出したプロセスの実効グループＩＤ</td></tr>
-<tr><td>task.sgid</td><td>呼び出したプロセスの保存グループＩＤ</td></tr>
-<tr><td>task.fsgid</td><td>呼び出したプロセスのファイルシステムグループＩＤ</td></tr>
-<tr><td>task.pid</td><td>呼び出したプロセスのプロセスＩＤ</td></tr>
-<tr><td>task.ppid</td><td>呼び出したプロセスの親プロセスのプロセスＩＤ</td></tr>
-<tr><td>task.type</td><td>呼び出したプロセスの種類（ execute_handler か否か）</td></tr>
-<tr><td>task.state[0]</td><td>呼び出したプロセスの状態変数0</td></tr>
-<tr><td>task.state[1]</td><td>呼び出したプロセスの状態変数1</td></tr>
-<tr><td>task.state[2]</td><td>呼び出したプロセスの状態変数2</td></tr>
-<tr><td>path1.uid</td><td>１つめのパス名の所有者ＩＤ</td></tr>
-<tr><td>path1.gid</td><td>１つめのパス名のグループＩＤ</td></tr>
-<tr><td>path1.ino</td><td>１つめのパス名のiノード番号</td></tr>
-<tr><td>path1.type</td><td>１つめのパス名の種類（ファイル，ディレクトリ，ソケット等）</td></tr>
-<tr><td>path1.perm</td><td>１つめのパス名のパーミッション</td></tr>
-<tr><td>path1.major</td><td>１つめのパス名の存在しているデバイスファイルのメジャー番号</td></tr>
-<tr><td>path1.minor</td><td>１つめのパス名の存在しているデバイスファイルのマイナー番号</td></tr>
-<tr><td>path1.dev_major</td><td>１つめのパス名のパス名（デバイスファイル）のメジャー番号</td></tr>
-<tr><td>path1.dev_minor</td><td>１つめのパス名のパス名（デバイスファイル）のマイナー番号</td></tr>
-<tr><td>path1.parent.uid</td><td>１つめのパス名の親ディレクトリの所有者ＩＤ</td></tr>
-<tr><td>path1.parent.gid</td><td>１つめのパス名の親ディレクトリのグループＩＤ</td></tr>
-<tr><td>path1.parent.ino</td><td>１つめのパス名の親ディレクトリのiノード番号</td></tr>
-<tr><td>path1.parent.perm</td><td>１つめのパス名の親ディレクトリのパーミッション</td></tr>
-<tr><td>path2.uid</td><td>２つめのパス名の所有者ＩＤ</td></tr>
-<tr><td>path2.gid</td><td>２つめのパス名のグループＩＤ</td></tr>
-<tr><td>path2.ino</td><td>２つめのパス名のiノード番号</td></tr>
-<tr><td>path2.type</td><td>２つめのパス名の種類（ファイル，ディレクトリ，ソケット等）</td></tr>
-<tr><td>path2.perm</td><td>２つめのパス名のパーミッション</td></tr>
-<tr><td>path2.major</td><td>２つめのパス名の存在しているデバイスファイルのメジャー番号</td></tr>
-<tr><td>path2.minor</td><td>２つめのパス名の存在しているデバイスファイルのマイナー番号</td></tr>
-<tr><td>path2.dev_major</td><td>２つめのパス名のパス名（デバイスファイル）のメジャー番号</td></tr>
-<tr><td>path2.dev_minor</td><td>２つめのパス名のパス名（デバイスファイル）のマイナー番号</td></tr>
-<tr><td>path2.parent.uid</td><td>２つめのパス名の親ディレクトリの所有者ＩＤ</td></tr>
-<tr><td>path2.parent.gid</td><td>２つめのパス名の親ディレクトリのグループＩＤ</td></tr>
-<tr><td>path2.parent.ino</td><td>２つめのパス名の親ディレクトリのiノード番号</td></tr>
-<tr><td>path2.parent.perm</td><td>２つめのパス名の親ディレクトリのパーミッション</td></tr>
-<tr><td>exec.argc</td><td>プログラム実行時の引数の数</td></tr>
-<tr><td>exec.envc</td><td>プログラム実行時の環境変数の数</td></tr>
-<tr><td>exec.argv[index]</td><td>プログラム実行時のindex番目の引数</td></tr>
-<tr><td>exec.envp["name"]</td><td>プログラム実行時の環境変数name</td></tr>
-<tr><td>exec.realpath</td><td>プログラム実行時のシンボリックリンクを解決したパス</td></tr>
-<tr><td>symlink.target</td><td>シンボリックリンク作成時のリンク先</td></tr>
-</table>
-</td></tr>
-</table>
-
-<table border="1" summary="fig">
-<tr><td>
-■図１８　条件指定の例<br>
-<table border="1" summary="fig">
-<tr><td>条件</td><td>意味</td></tr>
-<tr><td>if task.uid=0</td><td>プロセスのユーザＩＤが 0 （ root ）である場合</td></tr>
-<tr><td>if task.uid!=0</td><td>プロセスのユーザＩＤが 0 （ root ）ではない場合</td></tr>
-<tr><td>if task.uid=100-500</td><td>プロセスのユーザＩＤが 100 以上 500 以下である場合</td></tr>
-<tr><td>if task.uid=0 task.gid=0</td><td>プロセスのユーザＩＤとグループＩＤの両方が 0 （ root ）である場合</td></tr>
-<tr><td>if task.uid!=0 task.gid!=0</td><td>プロセスのユーザＩＤとグループＩＤの両方が 0 （ root ）ではない場合</td></tr>
-<tr><td>if task.uid=100-500 task.gid!=0</td><td>プロセスのユーザＩＤが 100 以上 500 以下であり，かつ，グループＩＤが 0 ではない場合</td></tr>
-<tr><td>if exec.argv[index]="value"</td><td>index （ 0&lt;=index&lt;exec.argc ）番目の引数の値が value である場合</td></tr>
-<tr><td>if exec.argv[index]!="value"</td><td>index （ 0&lt;=index&lt;exec.argc ）番目の引数の値が value ではない場合</td></tr>
-<tr><td>if exec.envp["name"]="value"</td><td>環境変数 name が定義されており，値が value である場合</td></tr>
-<tr><td>if exec.envp["name"]!="value"</td><td>環境変数 name が定義されていないか，あるいは値が value ではない場合</td></tr>
-<tr><td>if exec.envp["name"]!=NULL</td><td>環境変数 name が定義されている場合</td></tr>
-<tr><td>if exec.envp["name"]=NULL</td><td>環境変数 name が定義されていない場合</td></tr>
-</table>
-</td></tr>
-</table>
-
-<h3>条件を付与してみよう</h3>
-
-<p>例として，コンソールからログインしたユーザが， cat コマンドで自分の所有するファイルのみを閲覧できるようにする手順について説明します．説明用に， user1 と user2 というアカウント使用します．コンソールからログインして，以降の操作を行ってください．まず，アカウントを２つ作成します（図１９）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図１９　アカウントを２つ作成
-<pre>
-# useradd -s /bin/bash user1
-# useradd -s /bin/bash user2
-</pre>
-</td></tr>
-</table>
-
-<p>パスワードを適当に設定してください（図２０）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図２０　作成したアカウントのパスワードを設定
-<pre>
-# passwd user1
-# passwd user2
-</pre>
-</td></tr>
-</table>
-
-<p>cat コマンド用のドメインを作成するために， cat コマンドを実行してください．ついでに，このコマンドが動作するドメインも表示してみます（図２１）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図２１　cat コマンドが動作するドメインを表示
-<pre>
-# cat /proc/ccs/self_domain
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
-</pre>
-</td></tr>
-</table>
-
-<p>このドメインに学習用プロファイルを割り当ててください．この連載では学習用プロファイルの番号は１ですので，図２２のようになります．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図２２　cat コマンド用ドメインに学習用プロファイルを割り当て
-<pre>
-# /usr/sbin/ccs-setprofile 1 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat'
-</pre>
-</td></tr>
-</table>
-
-<p>ログアウトして， user1 としてログインし直します．そして，図２３の操作を行ってください．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図２３　user1 でログインし， /tmp/testfile1 を作成
-<pre>
-$ echo "This file was created by user1" &gt; /tmp/testfile1
-$ cat /tmp/testfile1
-This file was created by user1
-</pre>
-</td></tr>
-</table>
-
-<p>ログアウトして， user2 としてログインし直します． user1 と同様に操作を行ってください（図２４）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図２４　user2 でログインし， /tmp/testfile2 を作成
-<pre>
-$ echo "This file was created by user2" &gt; /tmp/testfile2
-$ cat /tmp/testfile2
-This file was created by user2
-</pre>
-</td></tr>
-</table>
-
-<p>ログアウトして， root としてログインし直します． ccs-editpolicy を起動して，「 &lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat 」ドメインのアクセス許可を確認してください．図２５のようなエントリが含まれているはずです．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図２５　&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat ドメインのアクセス許可
-<pre>
-allow_read /tmp/testfile1
-allow_read /tmp/testfile2
-</pre>
-</td></tr>
-</table>
-
-<p>このままではどちらのファイルもＤＡＣ（任意アクセス制御）のパーミッションにより許可されれば誰でも読むことができてしまいます．ここで，キーボードの「 A 」を押して，図２６のように入力してください．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図２６　アクセス許可を追加<br>（※これらをまとめて， allow_read /tmp/testfile\+ if task.uid=path1.uid のように入力してもかまいません．）
-<pre>
-allow_read /tmp/testfile1 if task.uid=path1.uid
-allow_read /tmp/testfile2 if task.uid=path1.uid
-</pre>
-</td></tr>
-</table>
-
-<p>それから，図２７の内容をキーボードの「 D 」を押して削除します．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図２７　削除する内容
-<pre>
-allow_read /tmp/testfile1
-allow_read /tmp/testfile2
-</pre>
-</td></tr>
-</table>
-
-<p>キーボードの「 Q 」を押して， ccs-editpolicy を終了します．そして， cat コマンド用のドメインに強制用プロファイルを割り当ててください．この連載では強制用プロファイルの番号は３ですので図２８のようになります．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図２８　cat コマンド用ドメインに強制用プロファイルを割り当て
-<pre>
-# /usr/sbin/ccs-setprofile 3 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat'
-</pre>
-</td></tr>
-</table>
-
-<p>ログアウトして， user1 としてログインし直します．そして， /tmp/testfile1 と /tmp/testfile2 を cat してみてください． /tmp/testfile2 へのアクセスが禁止されていることを確認できます（図２９）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図２９ /tmp/testfile2 へのアクセスが禁止されている
-<pre>
-$ cat /tmp/testfile1
-This file was created by user1
-$ cat /tmp/testfile2
-cat: /tmp/testfile2: Operation not permitted
-</pre>
-</td></tr>
-</table>
-
-<p>ログアウトして， user2 としてログインし直します． user1 と同様に操作を行ってください． /tmp/testfile1 へのアクセスが禁止されていることを確認できます．変数の代わりにユーザＩＤを直接指定することもできます．たとえば，ユーザ認証を行ってログインシェルを起動するための「 &lt;kernel&gt; /sbin/mingetty /bin/login 」ドメインに対して，図３０のように変更してやると， root ユーザのログインを禁止することができます．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図３０　root ユーザのログインを禁止する設定
-<pre>
-[修正前]
-allow_execute /bin/bash
-[修正後]
-allow_execute /bin/bash if task.uid!=0
-</pre>
-</td></tr>
-</table>
-
-<p>また，図３１のように変更してやると，ユーザＩＤが 500 以上 1000 以下のユーザだけがログインできるようにすることができます． SSH 経由でのログインを制限したい場合に使うことができます．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図３１　ユーザＩＤ 500 以上 1000 以下のユーザのみログインできる設定
-<pre>
-[修正前]
-allow_execute /bin/bash
-[修正後]
-allow_execute /bin/bash if task.uid=500-1000
-</pre>
-</td></tr>
-</table>
-
-<h2>アクセスログを保存する</h2>
-
-<p>TOMOYO Linux では，「ポリシーに違反しなかったアクセス要求のログ」（アクセス許可ログ）と「ポリシーに違反したアクセス要求のログ」（アクセス拒否ログ）を取得することができます．アクセス許可ログとアクセス拒否ログをカーネルから読み出してファイルに保存するために， ccs-auditd というデーモンプログラムを利用できます．</p>
-
-<h3>アクセスログを保存してみよう</h3>
-
-<p>まず，アクセスログを保存するディレクトリを作成します（図３２）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図３２　アクセスログ保存用のディレクトリを作成
-<pre>
-# mkdir -p /var/log/tomoyo
-</pre>
-</td></tr>
-</table>
-
-<p>次に， /etc/rc.d/rc.local に図３３の行を追加します．１番目の引数が「アクセス許可ログ」の保存場所で，２番目の引数が「アクセス拒否ログ」の保存場所です．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図３３　/etc/rc.d/rc.local を修正
-<pre>
-/usr/sbin/ccs-auditd /dev/null /var/log/tomoyo/reject_log.txt
-</pre>
-</td></tr>
-</table>
-
-<p>次に， logrotate によるローテーションを行わせるために，図３４のような内容のファイルを /etc/logrotate.d/tomoyo として作成してください．なお， nocreate オプションを必ず指定してください． nocreate オプションを忘れると，最初のローテーションが実行されて以降のログが保存されなくなってしまいます．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図３４　logrotate によるローテーションの設定（ /etc/logrotate.d/tomoyo ）
-<pre>
-/var/log/tomoyo/reject_log.txt {
-    weekly
-    rotate 9
-    missingok
-    notifempty
-    nocreate
-}
-</pre>
-</td></tr>
-</table>
-
-<p>アクセス許可ログを保存する必要がない場合は，プロファイルで「 PREFERENCE::audit={ max_grant_log=0 } 」という指定をして，アクセス許可ログの保存場所として /dev/null を指定することができます． ccs-auditd にはフィルタリング機能がありませんので，アクセス許可ログを保存する場合はディスク容量に注意してください．アクセス拒否ログを保存する必要がない場合は，プロファイルで「 PREFERENCE::audit={ max_reject_log=0 } 」という指定をして，アクセス拒否ログの保存場所として /dev/null を指定することができます．アクセス拒否ログは保存しておくことを推奨します．アクセス許可ログ／アクセス拒否ログのどちらも保存しない場合には ccs-auditd を実行する必要はありません．また，プロファイルで「 PREFERENCE::audit={ max_grant_log=0 max_reject_log=0 } 」を指定しておくことで，消費メモリの節約と応答速度の向上が期待できます．</p>
-
-<h3>アクセスログを閲覧してみよう</h3>
-
-<p>アクセスログは，そのまま /etc/ccs/domain_policy.conf に追記可能な形式になっています（図３５）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図３５　アクセスログの内容例（ /var/log/tomoyo/reject_log.txt ）
-<pre>
-# cat /var/log/tomoyo/reject_log.txt
-#2010-05-13 15:36:22# profile=3 mode=enforcing (global-pid=4350) task={ pid=4350 ppid=4312 uid=500 gid=500 euid=500 egid=500 suid=500 sgid=500 fsuid=500 fsgid=500 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=501 gid=501 ino=393251 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
-allow_read /tmp/testfile2
-
-#2010-05-13 15:36:36# profile=3 mode=enforcing (global-pid=4518) task={ pid=4518 ppid=4480 uid=501 gid=501 euid=501 egid=501 suid=501 sgid=501 fsuid=501 fsgid=501 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=500 gid=500 ino=393250 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
-allow_read /tmp/testfile1
-</pre>
-</td></tr>
-</table>
-
-<p>また，プロセスのユーザＩＤなどの情報も記録されているため，個々のアクセス許可に条件を付与する際のヒントにもなります．</p>
-
-<h2>対話的にアクセス許可を追加する</h2>
-
-<p>TOMOYO Linux では，強制モードで運用中にポリシー違反が発生しても，そのアクセス要求を直ちに拒否する（図３６）のではなく，管理者による対話的な操作によりそのアクセス要求の諾否を指示する（図３７）ことができます．この機能は，強制モードでの動作確認中にポリシー違反が発生した場合や，ソフトウェアのアップデートなどによりポリシーの微調整が必要になった場合に役に立ちます．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図３６　ポリシーに違反する要求はすぐに拒否<br>
-<img src="tutorial/fig-3-36.png" alt="fig-3-36.png">
-</td></tr>
-</table>
-
-<table border="1" summary="fig">
-<tr><td>
-■図３７　ポリシーに違反する要求は対話的に処理<br>
-<img src="tutorial/fig-3-37.png" alt="fig-3-37.png">
-</td></tr>
-</table>
-
-<h3>対話的にアクセス許可を追加してみよう</h3>
-
-<p>ポリシー違反の発生を監視して管理者に問い合わせを行う ccs-queryd コマンドを起動してください（図３８）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図３８　ccs-queryd を起動
-<pre>
-# /usr/sbin/ccs-queryd
-Monitoring /proc/ccs/query and /etc/ld.so.cache . Press Ctrl-C to terminate.
-</pre>
-</td></tr>
-</table>
-
-<p>この状態でポリシー違反が発生すると， ccs-queryd を実行中の画面にアクセス要求の内容が表示されます．このメッセージは， /etc/ccs/domain_policy.conf と同じ構文になっていますので，許可すべきかどうかを判断してください．先ほど，コンソールからログインしたユーザが cat コマンドで自分の所有するファイルのみを閲覧できるようにするポリシーを作成しましたので，ここではそれを用いてポリシー違反を発生させることにします． ccs-queryd を動作させている画面を残したまま，別の画面を開いて user1 としてログインします．その後，図３９のコマンドを実行してください．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図３９　user1 で操作を行う
-<pre>
-$ cat /tmp/testfile1
-This file was created by user1
-$ cat /tmp/testfile2
-</pre>
-</td></tr>
-</table>
-
-<p>この操作によりポリシー違反が発生しました． ccs-queryd を動作させている画面をチェックしてみてください．図４０のようなメッセージが表示されているはずです．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図４０　ポリシー違反が発生した場合の ccs-queryd の画面
-<pre>
-#2010-05-13 15:39:20# profile=3 mode=enforcing (global-pid=4619) task={ pid=4619 ppid=4581 uid=500 gid=500 euid=500 egid=500 suid=500 sgid=500 fsuid=500 fsgid=500 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=501 gid=501 ino=393251 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
-allow_read /tmp/testfile2
-Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):
-</pre>
-</td></tr>
-</table>
-
-<p>許可したい場合は「 Y 」を，拒否したい場合は「 N 」を，ポリシーに追加したうえで再試行したい場合は「 A 」を押します．ここで「 N 」を押してから， user1 の画面を見てください．図４１のようなメッセージが表示されました．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図４１　操作が許可されていないことを知らせるメッセージ
-<pre>
-cat: /tmp/testfile2: Operation not permitted
-</pre>
-</td></tr>
-</table>
-
-<p>再度図４２を実行して， ccs-queryd の画面をチェックしてください．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図４２　再度 user1 で操作を行う
-<pre>
-$ cat /tmp/testfile2
-</pre>
-</td></tr>
-</table>
-
-<p>図４３のようなメッセージが表示されているはずです．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図４３　ポリシー違反が発生した場合の ccs-queryd の画面
-<pre>
-#2010-05-13 15:41:36# profile=3 mode=enforcing (global-pid=4620) task={ pid=4620 ppid=4581 uid=500 gid=500 euid=500 egid=500 suid=500 sgid=500 fsuid=500 fsgid=500 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=501 gid=501 ino=393251 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
-&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
-allow_read /tmp/testfile2
-Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):
-</pre>
-</td></tr>
-</table>
-
-<p>ここで「 Y 」を押してから， user1 の画面を見てください．図４４のように， /tmp/testfile2 の内容が表示されました．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図４４　/tmp/testfile2 の内容が表示される
-<pre>
-This file was created by user2
-</pre>
-</td></tr>
-</table>
-
-<p>再度図４２を実行して， ccs-queryd の画面をチェックしてください．</p>
-
-<p>今度は「 A 」を押してください．図４５という内容が表示されます．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図４５　編集を行うプロンプト
-<pre>
-Enter new entry&gt; allow_read /tmp/testfile2
-</pre>
-</td></tr>
-</table>
-
-<p>このまま「 ENTER 」を押すと，編集中の内容がポリシーに追加され（図４６），再試行されます．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図４６　ポリシーに追加される
-<pre>
-Added 'allow_read /tmp/testfile2'.
-</pre>
-</td></tr>
-</table>
-
-<p>ポリシーに追加されたことでポリシー違反は発生しなくなるため，図４４のように /tmp/testfile2 の内容が表示されます．</p>
-
-<p>また， ccs-editpolicy を起動して「 &lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat 」ドメインに対するアクセス許可の一覧を表示してみると，図４７のようになっているはずです．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図４７　アクセス許可の一覧を表示する
-<pre>
-allow_read /tmp/testfile1 if task.uid=path1.uid
-allow_read /tmp/testfile2
-allow_read /tmp/testfile2 if task.uid=path1.uid
-</pre>
-</td></tr>
-</table>
-
-<p>これは， ccs-queryd によって「 allow_read /tmp/testfile2 」というアクセス許可が追加されたためです．チューニングが終わったら， ccs-queryd を「 CTRL＋C 」により終了させてください．</p>
-
-<h3>ccs-queryd 利用時の注意点</h3>
-
-<p>ccs-queryd を利用するうえで注意すべき点が２つあります．１つは，無条件にアクセス要求を許可してはいけない点です．ポリシー違反の原因が悪意あるユーザによる攻撃である可能性があるからです．もし，悪意あるユーザによる攻撃によって発生したアクセス要求に対してアクセスを許可してしまった場合，強制アクセス制御による保護が無意味になってしまいます．もう１つは， ccs-queryd が動作している間は，ポリシー違反が発生しても管理者が応答するまでそのアクセス要求は保留状態となる点です．そのため， ccs-queryd を動作させたまま席を外したりログアウトしたりしないでください．</p>
-
-<h2>アクセスログからポリシーを生成する（上級者向け）</h2>
-
-<p>学習モードで生成されるポリシーに含まれているアクセス許可には exec.realpath と exec.argv[0] と symlink.target だけしか含まれていませんが，アクセスログには図１７で示した全ての変数が含まれています．そのため，アクセスログからポリシーを生成してやれば，最も厳格な条件付きアクセス許可を定義することができます．</p>
-
-<h3>自動的にアクセス許可を追加しないように設定する</h3>
-
-<p>学習モードでは，一度ポリシー違反が発生すると，そのポリシー違反を起こさないようにするために必要なアクセス許可が自動的に追加されてしまいます．しかし，自動的に追加されるアクセス許可には図１７で示した全ての情報が含まれているわけではありません．そのため，プロファイルを図４８のように編集して自動的に追加されないようにします．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図４８　/etc/ccs/profile.conf の変更箇所
-<pre>
-[修正前]
-PREFERENCE::learning={ verbose=no }
-[修正後]
-PREFERENCE::learning={ verbose=no max_entry=0 }
-</pre>
-</td></tr>
-</table>
-
-<p>保存したら，図４９のコマンドを実行して変更を反映してください．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図４９　変更を反映する
-<pre>
-# /usr/sbin/ccs-loadpolicy p
-</pre>
-</td></tr>
-</table>
-
-<h3>プログラムを動作させる</h3>
-
-<p>この状態でプログラムを動作させます．ポリシー違反は全てアクセスログとして保存されていきます．</p>
-
-<p>図４８で max_entry=0 という指定をしたため，図５０のようなメッセージが大量に表示されますが無視してください．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図５０　学習する件数の上限に達したことを示すメッセージ
-<pre>
-WARNING: Domain 'ドメイン名' has so many ACLs to hold. Stopped learning mode.
-</pre>
-</td></tr>
-</table>
-
-<h3>アクセスログから必要な部分を抽出する</h3>
-
-<p>grep を用いて mode=learning を含むログを抽出します（図５１）．前後に空白を含めていることに注意してください．空白を入れ忘れると，ファイル名などと一致してしまう可能性があります．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図５１　学習モードのアクセスログだけを抽出する
-<pre>
-# grep -F -A 2 " mode=learning " /var/log/tomoyo/reject_log.txt &gt; /var/log/tomoyo/learning_log.txt
-</pre>
-</td></tr>
-</table>
-
-<p>抽出したら，条件付きのアクセス許可に変換します（図５２）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図５２　条件付きのアクセス許可に変換する
-<pre>
-# /usr/lib/ccs/convert-audit-log &lt; /var/log/tomoyo/learning_log.txt &gt; /var/log/tomoyo/policy.tmp
-</pre>
-</td></tr>
-</table>
-
-<p>変換したら，ドメイン単位でソートすることにより圧縮します（図５３）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図５３　ドメイン単位でソートする
-<pre>
-# /usr/sbin/ccs-sortpolicy &lt; /var/log/tomoyo/policy.tmp &gt; /var/log/tomoyo/policy.txt
-</pre>
-</td></tr>
-</table>
-
-<h3>加工してからポリシーとして追加する</h3>
-
-<p>/var/log/tomoyo/policy.txt はそのままドメインポリシーとして /etc/ccs/domain_policy.conf に追加することが可能ですが，図５４のように条件が厳密すぎて使い物にならない（例えばプロセスＩＤやｉノード番号などは毎回変わるため、指定しない方が良い）ので，テキストエディタを用いて条件を緩めて（不要と思われる条件部分を除去して）から追加してください．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図５４　厳密すぎるアクセス許可
-<pre>
-allow_execute /usr/bin/id if task.pid=4641 task.ppid=4637 task.uid=48 task.gid=48 task.euid=48 task.egid=48 task.suid=48 task.sgid=48 task.fsuid=48 task.fsgid=48 task.state[0]=0 task.state[1]=0 task.state[2]=0 task.type!=execute_handler path1.uid=0 path1.gid=0 path1.ino=603159 path1.major=8 path1.minor=1 path1.perm=0755 path1.type=file path1.parent.uid=0 path1.parent.gid=0 path1.parent.ino=589834 path1.parent.perm=0755 exec.realpath="/usr/bin/id" exec.argc=1 exec.envc=7 exec.argv[0]="id" exec.envp["TERM"]="linux" exec.envp["PATH"]="/sbin:/usr/sbin:/bin:/usr/bin" exec.envp["PWD"]="/usr/share/horde/admin" exec.envp["LANG"]="en_US.UTF-8" exec.envp["SHLVL"]="3" exec.envp["LANGUAGE"]="en_US.UTF-8" exec.envp["_"]="/usr/bin/id"
-</pre>
-</td></tr>
-</table>
-
 <h2>次回予告</h2>
 
-<p>今回はドメイン遷移の制御とポリシーのチューニング方法について紹介しました．次回は，ファイル以外に関する強制アクセス制御機能について紹介していきます．どうぞお楽しみに．</p>
+<p>今回はドメイン遷移について紹介しました．次回は，ポリシーのチューニングについて紹介していきます．どうぞお楽しみに．</p>
 
 <p><a href="tutorial-2.html.ja">第２回へ戻る</a>　<a href="tutorial-4.html.ja">第４回へ進む</a></p>
 
Index: tutorial-4.html.ja
===================================================================
--- tutorial-4.html.ja	(revision 3668)
+++ tutorial-4.html.ja	(working copy)
@@ -3,519 +3,305 @@
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <meta http-equiv="Content-Style-Type" content="text/css">
-<title>TOMOYO Linuxの世界　第４回：「いろんな機能を試してみよう（前編）」</title>
+<title>TOMOYO Linux の世界　第４回：「ポリシーをチューニングしてみよう」</title>
 <link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
 </head>
 <body>
 <!--
 <p style="text-align:right;"><a href="tutorial-4.html.en">English Page</a></p>
-<p style="text-align:right;">Last modified: $Date$</p>
 -->
-<h1>TOMOYO Linuxの世界<br>第４回：「いろんな機能を試してみよう（前編）」</h1>
+<p style="text-align:right;">Last modified: $Date$</p>
 
-<p>TOMOYO Linuxでは，ファイルに対して以外にもさまざまなアクセス制御を行うことができます．今回は，ネットワーク，ケイパビリティ，シグナルに対するアクセス制御について解説します．</p>
+<h1>TOMOYO Linux の世界<br>第４回：「ポリシーをチューニングしてみよう」</h1>
 
 <h2>今回の内容</h2>
 
-<p>これまでの連載では，ファイルに対するアクセス制御機能について紹介してきました．ファイルに対するアクセス制御機能は，プログラムやデータへの不要なアクセスを排除する，セキュアOSを用いたセキュリティ強化の基本となります．しかし，この機能だけでは十分とは言えません．今回は，TOMOYO Linuxが備える他のアクセス制御機能の中からネットワークに対するアクセス制御機能をはじめ主要なものを紹介します．</p>
+<p>今回のテーマは， TOMOYO Linux を使いこなすうえで必須のポリシーのチューニングと，それを支援する機能についてです．</p>
 
-<h2>ネットワークに対するアクセス制御機能について</h2>
+<h2>ポリシーの修正を支援する機能について</h2>
 
-<p>Linuxではデフォルトでiptablesというパケットフィルタリングを行うための機能が利用できます．TOMOYO Linuxでも同様の機能を提供しますが，TOMOYO Linuxのネットワークに対するアクセス制御機能はドメイン単位やユーザID単位でパケットフィルタリングを行うことができ，設定も容易です．iptablesの設定は構文が難しくてわからないという人でも使えます（ただし，iptablesと連携しているわけではないので，iptablesでしか利用できない機能もあります．）．</p>
+<p>セキュアOSを導入していれば，プロセスを乗っ取られたり，管理者権限を不正に奪われたりしてもそれがただちに致命的被害にはつながりません．システムのアップデートについて，標準のOSほど神経を使わなくても良くなりますが過信は禁物です．アップデートを適用しシステムを万全な状態に維持しましょう．強制アクセス制御機能を搭載しているOSでは，管理者が定義したポリシーにより振る舞いが制限されます．そのため，ソフトウェアのアップデートなどによりプログラムの依存関係などが変化した場合，ポリシーを修正してやらないと正常に動作できなくなってしまう可能性があります．管理者が自らポリシーを作成するという考え方を持つTOMOYO Linuxでは，ポリシーの修正も自力で行わなければいけません．今回は，ソフトウェアのアップデートに伴って必要となる，ポリシーの修正作業を支援する機能について紹介します．</p>
 
-<h3>制御可能な範囲</h3>
+<p>TOMOYO Linux では，強制モードで運用中にポリシー違反が発生しても，そのアクセス要求を直ちに拒否する（図３６）のではなく，管理者による対話的な操作によりそのアクセス要求の諾否を指示する（図３７）ことができます．この機能は，強制モードでの動作確認中にポリシー違反が発生した場合や，ソフトウェアのアップデートなどによりポリシーの微調整が必要になった場合に役に立ちます．</p>
 
-<p>TOMOYO Linuxにおけるネットワーク制御の対象について図1に示します．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図1 ネットワーク制御の対象
-<pre>
-TCPプロトコル／UDPプロトコル／IPプロトコル
-IPv4ネットワークアドレス／IPv6ネットワークアドレス
-ポート番号
-</pre>
+■図３６　ポリシーに違反する要求はすぐに拒否<br>
+<img src="tutorial/fig-3-36.png" alt="fig-3-36.png">
 </td></tr>
 </table>
 
-<p>TOMOYO Linuxのネットワークアクセス制御機能を用いると，たとえば「sshdからログインしたuidが500のユーザが実行したsvnプロセスのみが，ホスト202.221.179.21のポート80に対してTCPプロトコルを用いた通信を行うことができる」といった制御が可能となります．次節以降，実際に設定してみることにしましょう．</p>
-
-<h3>準備</h3>
-
-<p>ネットワークに対するアクセス制御はファイルに対するアクセス制御と同様にドメイン毎に指定ができます．ここでは，「ネットワークアクセス制御のみの学習」「ネットワークアクセス制御のみの確認」「ネットワークアクセス制御のみの強制」の3種類のプロファイルを作ります．</p>
-
-<h3>(1)プロファイルの定義</h3>
-
-<p>準備としてプロファイル5～7を作成することにします．/etc/ccs/profile.confの末尾に図2の内容を追加してください．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図2 /etc/ccs/profile.confの末尾に追加する内容
-<pre>
-5-COMMENT=Learning Mode (Network Only)
-5-CONFIG::network={ mode=learning }
-6-COMMENT=Permissive Mode (Network Only)
-6-CONFIG::network={ mode=permissive }
-7-COMMENT=Enforcing Mode (Network Only)
-7-CONFIG::network={ mode=enforcing }
-</pre>
+■図３７　ポリシーに違反する要求は対話的に処理<br>
+<img src="tutorial/fig-3-37.png" alt="fig-3-37.png">
 </td></tr>
 </table>
 
-<p>保存したら，図3のコマンドを実行して変更を反映してください．</p>
+<h3>使用するプログラム</h3>
 
-<table border="1" summary="fig">
-<tr><td>
-■図3 変更を反映する
-<pre>
-# /usr/sbin/ccs-loadpolicy p
-</pre>
-</td></tr>
-</table>
+<p>TOMOYO Linuxでは，ポリシーの修正を支援するためのツールとして，図1のプログラムを提供しています．</p>
 
-<h3>(2)学習させるドメインの決定</h3>
-
-<p>学習させるドメインの範囲は任意ですが，今回は操作中のシェルが属しているドメイン以下を対象としましょう．現在のプロセスが属しているドメイン名は，/proc/ccs/self_domainの内容をcatするとわかります．もし，現在実行中のシェルがkeep_domainによりドメイン遷移を行わないように指定されていた場合は，ポリシーエディタを用いて一時的にkeep_domainの指定を削除してください（ポリシーエディタで表示する際に見やすくするためであり，実環境で利用する場合にはkeep_domainの指定を削除する必要はありません．）．なお，学習されるIPアドレスやポート番号は環境により異なりますのでご了承ください．</p>
-
-<h3>学習させてみよう</h3>
-
-<h4>(1)クライアント側の学習</h4>
-
-<p>図4の内容を実行し，現在のプロセスの属しているドメイン以下を学習モードにします（リダイレクトの部分は，実際のドメイン名を文字列として引用しても結構です）．</p>
 <table border="1" summary="fig">
 <tr><td>
-■図4 現在のプロセスが属しているドメイン以下を学習モードにする
-<pre>
-# xargs -0 /usr/sbin/ccs-setprofile -r 5 &lt; /proc/ccs/self_domain
-</pre>
-</td></tr>
-</table>
-
-<p>学習させるためのコマンドとして，ここではcurlコマンドを用いてhttp://www.sourceforge.jp/にアクセスしてみます（図5）．</p>
-
+■図1 TOMOYO の管理を行うためのプログラム<br>
 <table border="1" summary="fig">
-<tr><td>
-■図5 curlコマンドを学習させる
-<pre>
-# curl http://www.sourceforge.jp/ &gt; /dev/null
-</pre>
-</td></tr>
+<tr><td>プログラム名</td><td>役割</td></tr>
+<tr><td>ccs-queryd</td><td>アクセス要求を対話的に許可する</td></tr>
 </table>
-
-<p>なお，curlコマンドが使えない場合は，wgetやtelnetなどでもかまいません．ポリシーエディタを起動して，curlコマンドを実行したドメインのアクセス許可を表示してみましょう（図6）．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図6 curlコマンドを実行したドメインのアクセス許可<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig04.jpg" alt="sd200704-fig04.jpg">
 </td></tr>
 </table>
 
-<p>allow_networkで始まる行が，ネットワークに対するアクセス制御のためのアクセス許可です．「allow_network UDP connect 192.168.10.1 53」という部分は，UDPプロトコルを用いてDNSサーバ192.168.10.1のポート53にアクセスすることを許可するという意味です．また，「allow_network TCPconnect 202.221.179.21 80」という部分は，TCPプロトコルを用いてHTTPサーバ202.221.179.21（本稿執筆時点のwww.sourceforge.jpのIP アドレスです）のポート80にアクセスすることを許可するという意味です．</p>
+<h3>コンソールでの操作例</h3>
 
-<h4>(2)サーバ側の学習</h4>
+<p>まずはログイン後の操作を制限する場合の例で説明します．操作を間違えてロックアウトされてしまわないようにするため，この連載ではexampleというユーザを作成して作業することにします．また，exampleユーザとrootユーザの作業をコンソールウィンドウの切り替えを行いながら進めることにします．コンソールウィンドウの切り替えは「ALT」＋「F1」～「F6」で行います．「ALT」＋「F1」でウィンドウ1を開き，rootユーザとexampleユーザのシェルを異なるものに設定してください．これは，ログインシェルを異なるものにすることによって，ログインシェルのドメインを異なるものにし，特定のログインシェルのドメインだけでアクセス制御を有効にするためです．本連載ではrootユーザのシェルは/bin/bashの場合で説明しているので，exampleユーザには/bin/tcshを割り当てます（図2） ．</p>
 
-<p>今度は，sshコマンドを用いてSSHサービスにログインしてみます（SSHサービスを稼動させていない場合には，HTTPなどの他のサービスでもかまいません）．例外ポリシーで「initialize_domain /usr/sbin/sshd」という指定がされている場合（連載第1回で実行したinit_policy.shによりそのように指定されているはずです），/usr/sbin/sshdは「&lt;kernel&gt; /usr/sbin/sshd」というドメインで動作することになるので，そのドメインに学習用のプロファイルを割り当ててみます（図7）．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図7 &lt;kernel&gt; /usr/sbin/sshdドメインに学習用プロファイルを割り当てる
+■図2 exampleユーザに/bin/tcshを割り当てる
 <pre>
-# /usr/sbin/ccs-setprofile 5 '&lt;kernel&gt; /usr/sbin/sshd'
+# usermod -s /bin/tcsh example
 </pre>
 </td></tr>
 </table>
 
-<p>その後，sshでlocalhostにログインし（図8），ポリシーエディタを実行して&lt;kernel&gt; /usr/sbin/sshdドメインに対するアクセス許可を確認してください（図9）．</p>
+<p>次に「ALT」＋「F2」でウィンドウ2を開き，exampleユーザとしてログインしてください．CentOS 5.3の場合，コンソールからログインしたドメインは「&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh」となるはずです．（sshdからログインした場合は「&lt;kernel&gt; /usr/sbin/sshd /bin/tcsh」となるはずです．）ウィンドウ1に切り替えて，このドメインに対して強制モード用のプロファイル（プロファイル3）を割り当てます（図3） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図8 sshでlocalhostにログイン
+■図3 exampleユーザのシェル（ウィンドウ2）のドメインに強制モード用プロファイルを割り当て
 <pre>
-# ssh localhost
+# /usr/sbin/ccs-setprofile -r 3 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh'
 </pre>
 </td></tr>
 </table>
 
-<table border="1" summary="fig">
-<tr><td>
-■図9 &lt;kernel&gt; /usr/sbin/sshdドメインに対するアクセス許可<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig07.jpg" alt="sd200704-fig07.jpg">
-</td></tr>
-</table>
+<p>これにより，exampleユーザのシェル（ウィンドウ2）からは，ほとんど何もできない状態になります（図4） ．</p>
 
-<p>図9では「allow_network TCP accept 127.0.0.1 51051」としてアクセス許可が与えられていますが，もしIPv6が有効になっている場合はv6のアドレスになりますので注意してください．ファイルに対するアクセス許可と同様に，ネットワークに対するアクセス許可にも条件を付与することができます．たとえば，図10のようにプロセスのユーザIDと組み合わせることで，ユーザごとに接続可能なサーバを制限したりすることもできます．</p>
 <table border="1" summary="fig">
 <tr><td>
-■図10 ユーザごとに接続可能なサーバを制限
+■図4 図3の適用結果を確認
 <pre>
-allow_network TCP connect 202.221.179.21 80 if task.uid=500
-allow_network TCP connect 66.35.250.203 80 if task.uid=501
+$ ls
+/bin/ls: Operation not permitted.
+$ cat /etc/passwd
+/bin/cat: Operation not permitted.
 </pre>
 </td></tr>
 </table>
 
-<p>IPソケットの場合には，ポート番号の代わりにプロトコル番号を指定します．pingコマンドを例に説明します．図11の内容を実行してから，ポリシーエディタでpingコマンドの動作するドメインに対するアクセス許可を確認してください（図12）．</p>
+<p>ccs-querydというプログラムを使用する（図5）と，強制モードで動作中のプロセスがポリシーに違反する内容のアクセス要求を行った場合でも，ただちに拒否するのではなく，システム管理者の指示を仰ぐようにすることができます．このモードは，SELinuxやAppArmorには存在しない，TOMOYO Linux特有の機能です．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図11 pingコマンドを実行
+■図5 ccs-querydの実行
 <pre>
-# ping -c 4 www.sourceforge.jp
+# /usr/sbin/ccs-queryd
 </pre>
 </td></tr>
 </table>
 
-<table border="1" summary="fig">
-<tr><td>
-■図12 pingコマンドの動作するドメインに対するアクセス許可<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig09.jpg" alt="sd200704-fig09.jpg">
-</td></tr>
-</table>
+<p>ウィンドウ2に切り替えて，/bin/lsコマンドの実行を要求してみましょう（図6）．</p>
 
-<p>「allow_network RAW connect 202.221.179.21 1」というアクセス許可が与えられていることを確認できます．これは，pingコマンドが動作しているドメインではIPソケット上でプロトコル番号1のプロトコル（ICMP）を用いて202.221.179.21と通信を行うことを許可するという意味です．</p>
-
-<h3>チューニングしてみよう</h3>
-
-<p>ひととおり学習してみたら，確認モードに切り替えて確認してみましょう．確認モードにするにはプロファイル6を割り当てます（図13）．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図13 プロファイル6を割り当て，確認モードに切り替え
+■図6 lsコマンドを実行
 <pre>
-# xargs -0 /usr/sbin/ccs-setprofile -r 6 &lt; /proc/ccs/self_domain
+$ /bin/ls
 </pre>
 </td></tr>
 </table>
 
-<h4>(1)アドレスのパターン化</h4>
+<p>先ほどはただちに拒否されてしまいましたが，今度は拒否されずに止まっています．この状態のままウィンドウ1に切り替えてみましょう．すると，図7のようなプロンプトが表示されているはずです．</p>
 
-<p>ファイルに対するアクセス制御を行う際にワイルドカードを用いてパターン化したように，ネットワークに対するアクセス制御を行う際にもパターン化が必要になります．パターン化を行う場合は，開始アドレスと終了アドレスを-を用いて図14のように指定してください．-の前後に空白を入れてはいけません．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図14 IPv4アドレスを範囲で指定する
+■図7 図6実行後，ウィンドウ1に表示されるプロンプト
 <pre>
-xxx.xxx.xxx.xxx-yyy.yyy.yyy.yyy
+#2010-05-13 15:29:35# profile=3 mode=enforcing (global-pid=4561) task={ pid=4561 ppid=4557 uid=502 gid=502 euid=502 egid=502 suid=502 sgid=502 fsuid=502 fsgid=502 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=0 gid=0 ino=1507379 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=1507329 perm=0755 } exec={ realpath="/bin/ls" argc=1 envc=6 argv[]={ "ls" } envp[]={ "TERM=xterm" "PATH=/sbin:/usr/sbin:/bin:/usr/bin" "PWD=/" "LANG=en_US.UTF-8" "SHLVL=1" "_=/bin/cat" } }
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh
+allow_execute /bin/ls
+Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):
 </pre>
 </td></tr>
 </table>
 
-<p>IPv6アドレスによる指定もIPv4アドレスの場合と同様ですが，"::"という省略表記や"."混じりの表記はサポートしていません．つねに図15のような形式で指定する必要があります．その他，負荷分散のため複数のIPアドレスを持つサーバに対するアクセス許可を与える場合は，使う可能性のあるすべてのIPアドレスを指定することを忘れないでください．</p>
+<p>最初の行はポリシーに違反するアクセス要求を行ったプロセスの属しているドメイン名が，2行目はアクセス要求の内容が表示されています．このように，ドメイン用ポリシーと同じ構文で要求内容が表示されます．ここで，「Y」を押すと，そのアクセス要求を許可することができます．また，「N」を押すと，そのアクセス要求を拒否することができます．「Y」キーを押した場合，/bin/lsの実行が許可されますが，ドメイン用ポリシーの中には/bin/lsを実行するためのドメインがまだ作成されていません．そのため，図8のようなプロンプトが表示されます．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図15 IPv6アドレスを指定する
+■図8 ドメイン作成の許可を求めるプロンプト
 <pre>
-xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx
+#2010-05-13 15:29:40# profile=3 mode=enforcing (global-pid=4561) task={ pid=4561 ppid=4557 uid=502 gid=502 euid=502 egid=502 suid=502 sgid=502 fsuid=502 fsgid=502 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=0 gid=0 ino=1507379 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=1507329 perm=0755 } exec={ realpath="/bin/ls" argc=1 envc=6 argv[]={ "ls" } envp[]={ "TERM=xterm" "PATH=/sbin:/usr/sbin:/bin:/usr/bin" "PWD=/" "LANG=en_US.UTF-8" "SHLVL=1" "_=/bin/cat" } }
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh
+# wants to create domain
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh /bin/ls
+Allow? ('Y'es/'N'o/'R'etry):
 </pre>
 </td></tr>
 </table>
 
-<h4>(2)ポート番号のパターン化</h4>
+<p>「Y」を押した場合，/bin/ls用のドメインが作成されるので，/bin/lsは先に進むことができます．「N」を押した場合，ドメインが見つからないという理由で/bin/lsの実行要求は拒否されます．/bin/lsのドメインの作成を許可すると，図9のように聞かれます．</p>
 
-<p>サーバがクライアントからのリクエストを受け付けるためのポート番号は一般に固定されているのに対し，クライアントがリクエストを送り出すときに使用するポート番号は固定されていません．そのため，サーバ側でクライアントが使用する可能性のあるポート番号を範囲としてパターン化してやる必要があります．パターン化を行う場合は，開始ポートと終了ポートを-を用いて図16のように指定してください．-の前後に空白を入れてはいけません．よくあるパターンは図17の3つです．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図16 ポート番号を範囲で指定する
+■図9 ドメイン作成を許可した際のプロンプト
 <pre>
-xxxxx-yyyyy
+#2010-05-13 15:29:45# profile=3 mode=enforcing (global-pid=4561) task={ pid=4561 ppid=4557 uid=502 gid=502 euid=502 egid=502 suid=502 sgid=502 fsuid=502 fsgid=502 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=0 gid=0 ino=1507380 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=1507329 perm=0755 }
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/tcsh /bin/ls
+allow_read /etc/selinux/config
+Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):
 </pre>
 </td></tr>
 </table>
 
-<table border="1" summary="fig">
-<tr><td>
-■図17 ポート番号パターン化の例
-<pre>
-1024-65535
-32768-61000
-600-1023
-</pre>
-</td></tr>
-</table>
+<p>/bin/lsのドメインは作成されたばかりですから，何もアクセス許可が与えられていません．表示されている内容を見ながら，許可するかどうかを慎重に判断して回答してください．「A」を押すと，必要に応じてアクセス許可の内容を編集してポリシーに追加してから再試行することができます．たとえば/etc/passwdだけでなく，/etc/\*shadow\*以外の/etc/\*に一致するファイルへのアクセスを許可したい場合には，/etc/passwdという内容を/etc/\*\-\*shadow\*に書き換えてから「ENTER」を押してください． ccs-querydを終了させるには「CTRL」＋「C」を押してください．</p>
 
-<p>最初のパターンは通常のクライアントがサーバに接続する際に選択する可能性がある範囲で，おもにサーバ側のプログラムで必要になります．2番目のパターンは「/proc/sys/net/ipv4/ip_local_port_range」に指定されているポート番号の範囲です．通常のクライアントはこの範囲から未使用のローカルポート番号を選択してサーバに接続するため，おもにクライアント側のプログラムで必要になります．実際の/proc /sys/net/ipv4/ip_local_port_rangeの内容に合わせてパターンを定義してください．</p>
+<h3>ccs-queryd 利用時の注意点</h3>
 
-<p>最後のパターンは，portmapコマンドのように未使用の特権ポート（ポート番号が1024未満のポート）を選択して接続するプログラムで必要になります．実際に必要な範囲は異なる場合があります．パターン化が必要か否かを判断する簡単な方法は，プログラムを何度か実行してみることです．たとえば，学習モードで何度か実行すると，図18のように，ポート番号が連続するアクセス許可が増えていきますので，その傾向から必要な範囲を推測してください．</p>
+<p>ccs-queryd を利用するうえで注意すべき点が２つあります．１つは，無条件にアクセス要求を許可してはいけない点です．ポリシー違反の原因が悪意あるユーザによる攻撃である可能性があるからです．もし，悪意あるユーザによる攻撃によって発生したアクセス要求に対してアクセスを許可してしまった場合，強制アクセス制御による保護が無意味になってしまいます．もう１つは， ccs-queryd が動作している間は，ポリシー違反が発生しても管理者が応答するまでそのアクセス要求は保留状態となる点です．そのため， ccs-queryd を動作させたまま席を外したりログアウトしたりしないでください．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図18 ポート番号が連続するアクセス許可の例①
-<pre>
-allow_network TCP bind 127.0.0.1 610
-allow_network TCP bind 127.0.0.1 611
-allow_network TCP bind 127.0.0.1 612
-allow_network TCP bind 127.0.0.1 613
-</pre>
-</td></tr>
-</table>
+<h3>共有ライブラリの扱い</h3>
 
-<p>図18の例の場合，図19のような許可が必要である可能性が高いと言えます．</p>
+<p>TOMOYO Linuxのインストール時に実行したinit_policyにより，/etc/ld.so.cacheに登録されている共有ライブラリ（/sbin/ldconfig -NXpにより確認できます）に関しては例外ポリシーでallow_read（無条件に参照を許す）という指定が行われているため，ドメイン用ポリシーで個別に読み込みアクセスの許可を与える必要はありません．しかし，ソフトウェアのアップデートに伴い，共有ライブラリのバージョンを含むファイル名が変化した場合，そのままではサービスの再起動に失敗してしまう可能性があります．新しくインストールされたライブラリファイルに関しては，例外ポリシーにallow_readという指定が行われるよりも前に要求された場合，例外ポリシーにもドメイン用ポリシーにも指定されていないのでポリシー違反と判断されます．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図19 図19を元にパターン化したアクセス許可
-<pre>
-allow_network TCP bind 127.0.0.1 600-1023
-</pre>
-</td></tr>
-</table>
+<p>先に説明したccs-querydにより検出してポリシーに追加していくことは可能ですが，このような場合に限っては，自動的にallow_readという指定を更新してくれたほうが便利でしょう．そのため，ccs-querydはポリシー違反の発生を監視するだけではなく，ライブラリファイルの情報を集めたファイルである/etc/ld.so.cacheの変化を監視し，自動的にallow_readを例外ポリシーに追加するようになっています．</p>
 
-<p>また，図20であれば，図21または図22という許可が必要である可能性が高いでしょう．</p>
+<h3>実際のサービスに対する操作例</h3>
 
-<table border="1" summary="fig">
-<tr><td>
-■図20 ポート番号が連続するアクセス許可の例②
-<pre>
-allow_network TCP accept 127.0.0.1 32780
-allow_network TCP accept 127.0.0.1 32781
-allow_network TCP accept 127.0.0.1 32782
-allow_network TCP accept 127.0.0.1 32783
-allow_network TCP accept 127.0.0.1 32784
-</pre>
-</td></tr>
-</table>
+<p><a href="http://tomoyo.sourceforge.jp/1.7/enforcing.html#using_interactive_mode">ソフトウェアのアップデート時に発生するポリシー違反を処理する</a>を参照してください．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図21 図20を元にパターン化したアクセス許可
-<pre>
-allow_network TCP accept 127.0.0.1 1024-65535
-</pre>
-</td></tr>
-</table>
+<h2>ポリシーのゴミを除去する機能について</h2>
 
-<table border="1" summary="fig">
-<tr><td>
-■図22 図20を元にパターン化したアクセス許可
-<pre>
-allow_network TCP accept 127.0.0.1 32768-61000
-</pre>
-</td></tr>
-</table>
+<h3>使用するプログラム</h3>
 
-<h3>強制してみよう</h3>
+<p>TOMOYO Linuxでは，ポリシーに含まれる不要なアクセス許可の削除を支援するためのツールとして，図10のプログラムを提供しています．</p>
 
-<p>確認が終わったら，実際にネットワークのアクセス制御を適用しましょう．強制モードにするにはプロファイル7を割り当てます（図23）．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図23 プロファイル7を割り当て，強制モードを適用
-<pre>
-xargs -0 /usr/sbin/ccs-setprofile -r 7 &lt; /proc/ccs/self_domain
-</pre>
-</td></tr>
-</table>
-
-<p>なお，プロファイル5～7はファイルに関するアクセス制御を行っていないことに注意してください．前回の本連載で紹介した，対話的にアクセス許可を追加するccs-querydを用いることで，その場で不足しているアクセス許可を追加することもできます．TOMOYO Linuxを使うと，iptables単体で行えるネットワークアクセス制御の内容を細分，詳細化できることがご理解いただけると思います．</p>
-
-<h2>ケイパビリティに対するアクセス制御機能について</h2>
-
-<p>Linuxカーネル2.2以降ではPOSIXケイパビリティに対応しています．ケイパビリティは，セキュアOSの基本概念である最少権限を形にしたもので，プロセス単位で各種特権の利用について制限を加えるために用いられます．Linuxで対応済みのケイパビリティについては，/usr /include/linux/capability.hの中で参照することができます．しかし，CAP_SYS_ADMIN権限がさまざまな目的に用いられているので，そのままでは本来の効果が期待できません．そこでTOMOYOLinuxでは独自にケイパビリティを定義，制御しています（以下「ケイパビリティ」はTOMOYO Linuxにおけるケイパビリティを指します）．</p>
-
-<p>TOMOYO LinuxではPOSIXとは異なる独自のケイパビリティを使用していますが，プログラムからはその存在は見えないので，プログラムに変更を加える必要はありません．バージョン1.7.2では図24の操作の可否を制限することができます．</p>
-
+■図10 TOMOYO の管理を行うためのプログラム<br>
 <table border="1" summary="fig">
-<tr><td>
-■図24 TOMOYO Linux 1.7.2のケイパビリティ<br>
-<table border="1" summary="fig">
-<tr><td>値</td><td>内容</td></tr>
-<tr><td>inet_tcp_create</td><td>TCPソケットの使用を許可</td></tr>
-<tr><td>inet_tcp_listen</td><td>TCPソケットのlistenを許可</td></tr>
-<tr><td>inet_tcp_connect</td><td>TCPソケットのconnectを許可</td></tr>
-<tr><td>use_inet_udp</td><td>UDPソケットの使用を許可</td></tr>
-<tr><td>use_inet_ip</td><td>RAWソケットの使用を許可</td></tr>
-<tr><td>use_route</td><td>ROUTEソケットの使用を許可</td></tr>
-<tr><td>use_packet</td><td>PACKETソケットの使用を許可</td></tr>
-<tr><td>use_kernel_module</td><td>create_module(2),init_module(2),delete_module(2)の使用を許可</td></tr>
-<tr><td>create_fifo</td><td>mknod(2)でFIFOの作成を許可</td></tr>
-<tr><td>create_block_dev</td><td>mknod(2)でブロック型デバイスの作成を許可</td></tr>
-<tr><td>create_char_dev</td><td>mknod(2)でキャラクタ型デバイスの作成を許可</td></tr>
-<tr><td>create_unix_socket</td><td>mknod(2)でUNIXドメインソケットの作成を許可</td></tr>
-<tr><td>SYS_MOUNT</td><td>mount(2)の使用を許可</td></tr>
-<tr><td>SYS_UMOUNT</td><td>umount(2)の使用を許可</td></tr>
-<tr><td>SYS_REBOOT</td><td>reboot(2)の使用を許可</td></tr>
-<tr><td>SYS_CHROOT</td><td>chroot(2)の使用を許可</td></tr>
-<tr><td>SYS_KILL</td><td>0以外のシグナルでkill(2),tkill(2),tgkill(2)の使用を許可</td></tr>
-<tr><td>SYS_VHANGUP</td><td>vhangup(2)の使用を許可</td></tr>
-<tr><td>SYS_TIME</td><td>stime(2),settimeofday(2),adjtimex(2)の使用を許可</td></tr>
-<tr><td>SYS_NICE</td><td>nice(2),setpriority(2)の使用を許可</td></tr>
-<tr><td>SYS_SETHOSTNAME</td><td>sethostname(2),setdomainname(2)の使用を許可</td></tr>
-<tr><td>SYS_LINK</td><td>link(2)の使用を許可</td></tr>
-<tr><td>SYS_SYMLINK</td><td>symlink(2)の使用を許可</td></tr>
-<tr><td>SYS_RENAME</td><td>rename(2)の使用を許可</td></tr>
-<tr><td>SYS_UNLINK</td><td>unlink(2)の使用を許可</td></tr>
-<tr><td>SYS_CHMOD</td><td>chmod(2),fchmod(2)の使用を許可</td></tr>
-<tr><td>SYS_CHOWN</td><td>chown(2),fchown(2),lchown(2)の使用を許可</td></tr>
-<tr><td>SYS_IOCTL</td><td>ioctl(2),compat_sys_ioctl(2)の使用を許可</td></tr>
-<tr><td>SYS_KEXEC_LOAD</td><td>kexec_load(2)の使用を許可</td></tr>
-<tr><td>SYS_PIVOT_ROOT</td><td>pivot_root(2)の使用を許可</td></tr>
-<tr><td>SYS_PTRACE</td><td>ptrace(2)の使用を許可</td></tr>
-<tr><td>conceal_mount</td><td>既存のマウントを隠ぺいするようなマウントを許可</td></tr>
+<tr><td>プログラム名</td><td>役割</td></tr>
+<tr><td>ccs-findtemp</td><td>存在しないパス名を検出する</td></tr>
+<tr><td>ccs-domainmatch</td><td>アクセス許可が与えられているドメインを検索する</td></tr>
 </table>
 </td></tr>
 </table>
 
-<p>ここではマウント操作を行う権限（SYS_MOUNT）を例に説明します．TOMOYO Linuxはパス名を用いてアクセス制御を行うため，管理者が期待したとおりにファイルシステムがマウントされていることは絶対の前提となります．root権限で動作しているすべてのプロセスが好き勝手にマウントをしてしまうようでは困ります．そのため，ケイパビリティを用いることでマウント操作を許可するドメインを制限します．ケイパビリティのアクセス制御の手順はネットワークに関するアクセス制御のときと同様です．まず，制限したいケイパビリティをプロファイルで指定します．/etc/ccs/profile.confの末尾に図25の内容を追加してください．</p>
+<p>これらを使うことで，パターン化する前のテンポラリファイルやソフトウェアのアップデートにより削除されたライブラリファイルなどの余計なアクセス許可を検出して除去することができます．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図25 /etc/ccs/profile.confの末尾に追加する内容（ケイパビリティに対するアクセス制御）
-<pre>
-9-CONFIG::capability::SYS_MOUNT={ mode=learning }
-10-CONFIG::capability::SYS_MOUNT={ mode=enforcing }
-</pre>
-</td></tr>
-</table>
+<h3>コンソールでの操作例</h3>
 
-<p>ファイルやネットワークとは異なり，ケイパビリティの場合は操作対象を指定する必要がありません．学習モードで学習させるだけで強制モードで必要なすべてのケイパビリティが与えられるので，図25のプロファイルでは確認モードを省略しています．保存したら，図3のコマンドを実行して変更を反映してください．</p>
+<p>簡単に試してもらうために，コンソールで説明することにします．学習モードの状態で図11の操作を行ってみてください．</p>
 
-<p>説明のために，先に強制モード用のプロファイル（10）を使用します（図26）．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図26 強制モード用プロファイルを使用
+■図11 学習モードで行う操作
 <pre>
-# xargs -0 /usr/sbin/ccs-setprofile -r 10 &lt; /proc/ccs/self_domain
+# touch /tmp/abc12345
+# rm -f /tmp/abc12345
 </pre>
 </td></tr>
 </table>
 
-<p>その後，適当なディレクトリにtmpfsをマウントします（図27）．</p>
+<p>この操作によりtouchとrmの/tmp/abc12345に対するアクセスが学習されましたが，/tmp/abc12345というファイル自体はもう存在しません．この操作が本来不要なものであればポリシーに使われないアクセス許可が残されたことになります．このように，ポリシーには記録されていても存在しないパス名は，テンポラリファイルとして使用されていたか，アップデートにより削除された可能性が高いと言えます．この状態で，ccs-findtempコマンドはそうした可能性を持つファイルを探します．なお，図12の実行例では/tmp/abc12345というパス名しか表示されていませんが，実際には他のパス名も表示されるはずです．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図27 tmpfsをマウントする
+■図12 ccs-findtempの実行例
 <pre>
-# mount -t tmpfs none /tmp/
-mount: permission denied
+# /usr/sbin/ccs-findtemp &lt; /proc/ccs/domain_policy
+/tmp/abc12345
+# /usr/sbin/ccs-findtemp --with-domainname &lt; /proc/ccs/domain_policy
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/touch
+/tmp/abc12345
+/tmp/abc12345
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/rm
+/tmp/abc12345
+# /usr/sbin/ccs-domainmatch /tmp/abc12345
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/touch
+allow_create /tmp/abc12345
+allow_write /tmp/abc12345
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/rm
+allow_unlink /tmp/abc12345
 </pre>
 </td></tr>
 </table>
 
-<p>拒否されました．これは，mountコマンドを実行したドメインに対して，マウント操作を行う権限が与えられていないためです．次に，学習モード用のプロファイル（9）を割り当てます（図28）．</p>
+<p>ccs-findtempにより表示されたパス名を引数としてccs-domainmatchコマンドを実行すると，引数で指定されたパス名に対するアクセス許可を含んでいるドメインが表示されます．不要だと判断した場合には，ccs-editpolicyを起動して，当該するドメインへ移動し，不要なアクセス許可を削除します．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図28 学習モード用プロファイルを使用
-<pre>
-# xargs -0 /usr/sbin/ccs-setprofile -r 9 &lt; /proc/ccs/self_domain
-</pre>
-</td></tr>
-</table>
+<h2>アクセスログを保存する</h2>
 
-<p>再度，適当なディレクトリにtmpfsをマウントします（図29）．</p>
+<p>TOMOYO Linux では，「ポリシーに違反しなかったアクセス要求のログ」（アクセス許可ログ）と「ポリシーに違反したアクセス要求のログ」（アクセス拒否ログ）を取得することができます．アクセス許可ログとアクセス拒否ログをカーネルから読み出してファイルに保存するために， ccs-auditd というデーモンプログラムを利用できます．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図29 tmpfsをマウントする
-<pre>
-# mount -t tmpfs none /tmp/
-</pre>
-</td></tr>
-</table>
+<h3>アクセスログを保存してみよう</h3>
 
-<p>今度は正常に動作しました．ポリシーエディタを起動してmountコマンドを実行したドメインを探し，アクセス許可を確認してください（図30）．</p>
+<p>まず，アクセスログを保存するディレクトリを作成します（図３２）．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図30 allow_capability SYS_MOUNTというアクセス許可が学習されている<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig18.jpg" alt="sd200704-fig18.jpg">
-</td></tr>
-</table>
-
-<p>allow_capability SYS_MOUNTというアクセス許可が学習されていることを確認できます．この状態で強制モード用のプロファイル（10）を割り当てれば，許可されていないドメインからマウント操作を行うことを禁止できるようになります．</p>
-
-<p>マウント操作の可否だけを制限しても，マウント操作が許可されていれば任意のディレクトリにマウントできてしまうので，不十分だと思われる方がいるかもしれません．実際そのとおりであり，TOMOYO Linuxではマウントを許可するパーティションとマウントポイントの組み合わせを制限する機能も備えています．それについては次回紹介する予定です．</p>
-
-<h2>シグナルに対するアクセス制御機能について</h2>
-
-<p>TOMOYO Linuxでは，シグナルの種類と送信先を制限することができます．手順はネットワークに関するアクセス制御のときと同様です．/etc/ccs /profile.conf末尾に図31の内容を追加してください．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図31 /etc/ccs/profile.confの末尾に追加する内容（シグナルに対するアクセス制御）
+■図３２　アクセスログ保存用のディレクトリを作成
 <pre>
-11-CONFIG::ipc::signal={ mode=learning }
-12-CONFIG::ipc::signal={ mode=enforcing }
+# mkdir -p /var/log/tomoyo
 </pre>
 </td></tr>
 </table>
 
-<p>保存したら，図3のコマンドを実行して変更を反映してください．</p>
+<p>次に， /etc/rc.d/rc.local に図３３の行を追加します．１番目の引数が「アクセス許可ログ」の保存場所で，２番目の引数が「アクセス拒否ログ」の保存場所です．</p>
 
-<p>以降の操作は，「&lt;kernel&gt; /usr/sbin/sshd /bin/bash」ドメインに属しているシェル（つまりsshdからログインしたときのログインシェル）から行うものとします．事前に「keep_domain &lt;kernel&gt; /usr/sbin/sshd /bin/bash」という指定がされていないことを確認しておいてください．最初に，sleepコマンドを実行してください（図32）．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図32 sleepコマンドを実行
+■図３３　/etc/rc.d/rc.local を修正
 <pre>
-# sleep 100
+/usr/sbin/ccs-auditd /dev/null /var/log/tomoyo/reject_log.txt
 </pre>
 </td></tr>
 </table>
 
-<p>この状態で，別の画面を開いてログインしてください．説明のために，先に強制モード用のプロファイル（14）を割り当てます（図33）．</p>
+<p>次に， logrotate によるローテーションを行わせるために，図３４のような内容のファイルを /etc/logrotate.d/tomoyo として作成してください．なお， nocreate オプションを必ず指定してください． nocreate オプションを忘れると，最初のローテーションが実行されて以降のログが保存されなくなってしまいます．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図33 強制モード用プロファイルを使用
+■図３４　logrotate によるローテーションの設定（ /etc/logrotate.d/tomoyo ）
 <pre>
-# xargs -0 /usr/sbin/ccs-setprofile -r 14 &lt; /proc/ccs/self_domain
+/var/log/tomoyo/reject_log.txt {
+    weekly
+    rotate 9
+    missingok
+    notifempty
+    nocreate
+}
 </pre>
 </td></tr>
 </table>
 
-<p>次に，動作中のsleepコマンドのプロセスIDを取得し，そのプロセスIDに対してシグナルを送信します（図34）（シェルのビルトインではなく，/bin/killが実行されるよう明示的に指定しています．）．</p>
+<p>アクセス許可ログを保存する必要がない場合は，プロファイルで「 PREFERENCE::audit={ max_grant_log=0 } 」という指定をして，アクセス許可ログの保存場所として /dev/null を指定することができます． ccs-auditd にはフィルタリング機能がありませんので，アクセス許可ログを保存する場合はディスク容量に注意してください．アクセス拒否ログを保存する必要がない場合は，プロファイルで「 PREFERENCE::audit={ max_reject_log=0 } 」という指定をして，アクセス拒否ログの保存場所として /dev/null を指定することができます．アクセス拒否ログは保存しておくことを推奨します．アクセス許可ログ／アクセス拒否ログのどちらも保存しない場合には ccs-auditd を実行する必要はありません．また，プロファイルで「 PREFERENCE::audit={ max_grant_log=0 max_reject_log=0 } 」を指定しておくことで，消費メモリの節約と応答速度の向上が期待できます．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図34 sleepコマンドのプロセスIDに対してシグナル送信
-<pre>
-# pidof sleep
-4649
-# /bin/kill -15 4649
-kill 4649: Operation not permitted
-</pre>
-</td></tr>
-</table>
+<h3>アクセスログを閲覧してみよう</h3>
 
-<p>拒否されました．これは，killコマンドが動作するドメインに対して，sleepコマンドが動作するドメインへシグナルを送信する権限が与えられていないためです．次に，学習モード用のプロファイル（13）を割り当て（図35），再度シグナルを送信します（図36）．</p>
+<p>アクセスログは，そのまま /etc/ccs/domain_policy.conf に追記可能な形式になっています（図３５）．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図35 学習モード用プロファイルを使用
+■図３５　アクセスログの内容例（ /var/log/tomoyo/reject_log.txt ）
 <pre>
-# xargs -0 /usr/sbin/ccs-setprofile -r 13 &lt; /proc/ccs/self_domain
-</pre>
-</td></tr>
-</table>
+# cat /var/log/tomoyo/reject_log.txt
+#2010-05-13 15:36:22# profile=3 mode=enforcing (global-pid=4350) task={ pid=4350 ppid=4312 uid=500 gid=500 euid=500 egid=500 suid=500 sgid=500 fsuid=500 fsgid=500 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=501 gid=501 ino=393251 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
+allow_read /tmp/testfile2
 
-<table border="1" summary="fig">
-<tr><td>
-■図36 再度sleepコマンドのプロセスIDに対してシグナル送信
-<pre>
-# /bin/kill -15 4649
+#2010-05-13 15:36:36# profile=3 mode=enforcing (global-pid=4518) task={ pid=4518 ppid=4480 uid=501 gid=501 euid=501 egid=501 suid=501 sgid=501 fsuid=501 fsgid=501 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=500 gid=500 ino=393250 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
+allow_read /tmp/testfile1
 </pre>
 </td></tr>
 </table>
 
-<p>今度は正常に動作しました．ポリシーエディタを起動してkillコマンドを実行したドメインを探し，アクセス許可を確認してください（図37）．</p>
+<p>アクセスログの中にはプロセスのユーザＩＤなどの情報も記録されています．これらの情報は次回説明する条件付きアクセス許可で使用することができます．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図37 killコマンドを実行したドメインのアクセス許可<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig25.jpg" alt="sd200704-fig25.jpg">
-</td></tr>
-</table>
-
-<p>「allow_signal 15 &lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/sleep」というアクセス許可が学習されていることを確認できます．これは，「&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/sleep」という名前で始まるドメインに属しているプロセスに対して15番のシグナル（SIGTERM）を送信することを許可するという意味です．TOMOYO Linuxにおけるドメイン名は&lt;kernel&gt;で始まる階層構造であるため，allow_signal 15 &lt;kernel&gt;のように指定した場合，すべてのプロセスに対して15番のシグナルを送信することが許可されることに注意してください．例外として，シグナルの送信元が送信先と同じドメインの場合はつねに許可されます．また，0番のシグナルもつねに許可されます．</p>
-
 <h2>次回予告</h2>
 
-<p>今回はTOMOYO Linuxのネットワークのアクセス制御機能を中心に紹介しました．通信を行うドメインを限定したうえで，強力かつ柔軟なアクセス制御を行えることがご理解いただけたと思います．次回は，パス名に基づくアクセス制御を行う際の注意点についての紹介を行います．どうぞお楽しみに．</p>
+<p>今回はポリシーのチューニング方法について紹介しました．次回は，条件付きアクセス許可について紹介していきます．どうぞお楽しみに．</p>
 
 <p><a href="tutorial-3.html.ja">第３回へ戻る</a>　<a href="tutorial-5.html.ja">第５回へ進む</a></p>
 
Index: tutorial-5.html.ja
===================================================================
--- tutorial-5.html.ja	(revision 3668)
+++ tutorial-5.html.ja	(working copy)
@@ -3,169 +3,364 @@
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <meta http-equiv="Content-Style-Type" content="text/css">
-<title>TOMOYO Linuxの世界　第５回：「いろんな機能を試してみよう（後編）」</title>
+<title>TOMOYO Linux の世界　第５回：「アクセス許可に条件を付けてみよう」</title>
 <link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
 </head>
 <body>
 <!--
 <p style="text-align:right;"><a href="tutorial-5.html.en">English Page</a></p>
+-->
 <p style="text-align:right;">Last modified: $Date$</p>
--->
-<h1>TOMOYO Linuxの世界<br>第５回：「いろんな機能を試してみよう（後編）」</h1>
 
-<p>今回は，パス名に基づくアクセス制御の注意点について解説します．</p>
+<h1>TOMOYO Linux の世界<br>第５回：「アクセス許可に条件を付けてみよう」</h1>
 
 <h2>今回の内容</h2>
 
-<p>今回は自分で手を動かし作業するというよりは，機能の説明，解説が中心で読み物っぽくなってしまいますがご了承ください．</p>
+<p>今回は TOMOYO Linux の強力なパラメータチェック機能を活用するための「条件付きアクセス許可」について紹介します．</p>
 
-<h2>パス名に基づくアクセス制御の注意点</h2>
+<h2>アクセス許可に条件を付ける</h2>
 
-<p>TOMOYO Linuxはパス名に基づきアクセスを制御します．ポリシーファイルの中でもパス名を用いて記述しますから，パス名の正しさが保たれていなければ，期待された効果をあげられません．ファイルシステムが意図したとおりにマウントされていることも不可欠です．</p>
+<h3>条件付きアクセス許可について</h3>
 
-<p>今回例として紹介する操作はファイルシステムに関する操作であるため，一歩間違えるとファイルにアクセスできなくなったりシステムが動作しなくなったりする危険があります．記事を読みながら実際に動作を確認される際にはご注意ください．万一起動できなくなってしまった場合には，本記事末尾のレスキュー手順を参照してください．</p>
+<p>TOMOYO Linux には RBAC （ Role Based Access Control ）機能はありませんが，ポリシーの中でユーザＩＤに基づく条件を付けることができます．これにより，システムアカウントのユーザＩＤに基づくアクセス制御が可能です．条件はアクセス許可の後ろに「 if 条件式」という形で指定します．利用できる条件について図１７に，使い方の例を図１８に示します．</p>
 
-<h3>パス名は便利だけど曖昧</h3>
+<table border="1" summary="fig">
+<tr><td>
+■図１７　条件指定に使えるパラメータ<br>
+<table border="1" summary="fig">
+<tr><td>変数</td><td>意味</td></tr>
+<tr><td>task.uid</td><td>呼び出したプロセスのユーザＩＤ</td></tr>
+<tr><td>task.euid</td><td>呼び出したプロセスの実効ユーザＩＤ</td></tr>
+<tr><td>task.suid</td><td>呼び出したプロセスの保存ユーザＩＤ</td></tr>
+<tr><td>task.fsuid</td><td>呼び出したプロセスのファイルシステムユーザＩＤ</td></tr>
+<tr><td>task.gid</td><td>呼び出したプロセスのグループＩＤ</td></tr>
+<tr><td>task.egid</td><td>呼び出したプロセスの実効グループＩＤ</td></tr>
+<tr><td>task.sgid</td><td>呼び出したプロセスの保存グループＩＤ</td></tr>
+<tr><td>task.fsgid</td><td>呼び出したプロセスのファイルシステムグループＩＤ</td></tr>
+<tr><td>task.pid</td><td>呼び出したプロセスのプロセスＩＤ</td></tr>
+<tr><td>task.ppid</td><td>呼び出したプロセスの親プロセスのプロセスＩＤ</td></tr>
+<tr><td>task.type</td><td>呼び出したプロセスの種類（ execute_handler か否か）</td></tr>
+<tr><td>task.state[0]</td><td>呼び出したプロセスの状態変数0</td></tr>
+<tr><td>task.state[1]</td><td>呼び出したプロセスの状態変数1</td></tr>
+<tr><td>task.state[2]</td><td>呼び出したプロセスの状態変数2</td></tr>
+<tr><td>path1.uid</td><td>１つめのパス名の所有者ＩＤ</td></tr>
+<tr><td>path1.gid</td><td>１つめのパス名のグループＩＤ</td></tr>
+<tr><td>path1.ino</td><td>１つめのパス名のiノード番号</td></tr>
+<tr><td>path1.type</td><td>１つめのパス名の種類（ファイル，ディレクトリ，ソケット等）</td></tr>
+<tr><td>path1.perm</td><td>１つめのパス名のパーミッション</td></tr>
+<tr><td>path1.major</td><td>１つめのパス名の存在しているデバイスファイルのメジャー番号</td></tr>
+<tr><td>path1.minor</td><td>１つめのパス名の存在しているデバイスファイルのマイナー番号</td></tr>
+<tr><td>path1.dev_major</td><td>１つめのパス名のパス名（デバイスファイル）のメジャー番号</td></tr>
+<tr><td>path1.dev_minor</td><td>１つめのパス名のパス名（デバイスファイル）のマイナー番号</td></tr>
+<tr><td>path1.parent.uid</td><td>１つめのパス名の親ディレクトリの所有者ＩＤ</td></tr>
+<tr><td>path1.parent.gid</td><td>１つめのパス名の親ディレクトリのグループＩＤ</td></tr>
+<tr><td>path1.parent.ino</td><td>１つめのパス名の親ディレクトリのiノード番号</td></tr>
+<tr><td>path1.parent.perm</td><td>１つめのパス名の親ディレクトリのパーミッション</td></tr>
+<tr><td>path2.uid</td><td>２つめのパス名の所有者ＩＤ</td></tr>
+<tr><td>path2.gid</td><td>２つめのパス名のグループＩＤ</td></tr>
+<tr><td>path2.ino</td><td>２つめのパス名のiノード番号</td></tr>
+<tr><td>path2.type</td><td>２つめのパス名の種類（ファイル，ディレクトリ，ソケット等）</td></tr>
+<tr><td>path2.perm</td><td>２つめのパス名のパーミッション</td></tr>
+<tr><td>path2.major</td><td>２つめのパス名の存在しているデバイスファイルのメジャー番号</td></tr>
+<tr><td>path2.minor</td><td>２つめのパス名の存在しているデバイスファイルのマイナー番号</td></tr>
+<tr><td>path2.dev_major</td><td>２つめのパス名のパス名（デバイスファイル）のメジャー番号</td></tr>
+<tr><td>path2.dev_minor</td><td>２つめのパス名のパス名（デバイスファイル）のマイナー番号</td></tr>
+<tr><td>path2.parent.uid</td><td>２つめのパス名の親ディレクトリの所有者ＩＤ</td></tr>
+<tr><td>path2.parent.gid</td><td>２つめのパス名の親ディレクトリのグループＩＤ</td></tr>
+<tr><td>path2.parent.ino</td><td>２つめのパス名の親ディレクトリのiノード番号</td></tr>
+<tr><td>path2.parent.perm</td><td>２つめのパス名の親ディレクトリのパーミッション</td></tr>
+<tr><td>exec.argc</td><td>プログラム実行時の引数の数</td></tr>
+<tr><td>exec.envc</td><td>プログラム実行時の環境変数の数</td></tr>
+<tr><td>exec.argv[index]</td><td>プログラム実行時のindex番目の引数</td></tr>
+<tr><td>exec.envp["name"]</td><td>プログラム実行時の環境変数name</td></tr>
+<tr><td>exec.realpath</td><td>プログラム実行時のシンボリックリンクを解決したパス</td></tr>
+<tr><td>symlink.target</td><td>シンボリックリンク作成時のリンク先</td></tr>
+</table>
+</td></tr>
+</table>
 
-<p>ユーザにはそれぞれホームディレクトリという領域が割り当てられており，そこに個人が管理するデータを保存しています．そのため，たとえば"mount -t tmpfs none /home/"というマウントが行われてしまうと，一般ユーザのホームディレクトリが見えなくなってしまいます（図1）．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図１８　条件指定の例<br>
+<table border="1" summary="fig">
+<tr><td>条件</td><td>意味</td></tr>
+<tr><td>if task.uid=0</td><td>プロセスのユーザＩＤが 0 （ root ）である場合</td></tr>
+<tr><td>if task.uid!=0</td><td>プロセスのユーザＩＤが 0 （ root ）ではない場合</td></tr>
+<tr><td>if task.uid=100-500</td><td>プロセスのユーザＩＤが 100 以上 500 以下である場合</td></tr>
+<tr><td>if task.uid=0 task.gid=0</td><td>プロセスのユーザＩＤとグループＩＤの両方が 0 （ root ）である場合</td></tr>
+<tr><td>if task.uid!=0 task.gid!=0</td><td>プロセスのユーザＩＤとグループＩＤの両方が 0 （ root ）ではない場合</td></tr>
+<tr><td>if task.uid=100-500 task.gid!=0</td><td>プロセスのユーザＩＤが 100 以上 500 以下であり，かつ，グループＩＤが 0 ではない場合</td></tr>
+<tr><td>if exec.argv[index]="value"</td><td>index （ 0&lt;=index&lt;exec.argc ）番目の引数の値が value である場合</td></tr>
+<tr><td>if exec.argv[index]!="value"</td><td>index （ 0&lt;=index&lt;exec.argc ）番目の引数の値が value ではない場合</td></tr>
+<tr><td>if exec.envp["name"]="value"</td><td>環境変数 name が定義されており，値が value である場合</td></tr>
+<tr><td>if exec.envp["name"]!="value"</td><td>環境変数 name が定義されていないか，あるいは値が value ではない場合</td></tr>
+<tr><td>if exec.envp["name"]!=NULL</td><td>環境変数 name が定義されている場合</td></tr>
+<tr><td>if exec.envp["name"]=NULL</td><td>環境変数 name が定義されていない場合</td></tr>
+</table>
+</td></tr>
+</table>
 
+<h3>条件を付与してみよう</h3>
+
+<p>例として，コンソールからログインしたユーザが， cat コマンドで自分の所有するファイルのみを閲覧できるようにする手順について説明します．説明用に， user1 と user2 というアカウント使用します．コンソールからログインして，以降の操作を行ってください．まず，アカウントを２つ作成します（図１９）．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図1 一般ユーザのホームディレクトリが見えない
+■図１９　アカウントを２つ作成
 <pre>
-# ls -l /home/
-total 8
-drwx------3 user1 user1 4096 Feb 21 10:16 user1
-drwx------3 user2 user2 4096 Feb 21 10:17 user2
-# mount -t tmpfs none /home/
-# ls -l /home/
-total 0
-# umount /home/
-# ls -l /home/
-total 8
-drwx------3 user1 user1 4096 Feb 21 10:16 user1
-drwx------3 user2 user2 4096 Feb 21 10:17 user2
+# useradd -s /bin/bash user1
+# useradd -s /bin/bash user2
 </pre>
 </td></tr>
 </table>
 
-<p>また，Linuxでは，あるディレクトリの内容を別のディレクトリからも見えるようにする bind mountという機能（ハードリンク機能のディレクトリ版に相当）を備えているので，"mount --bind / /var/www/html/"というマウントが行われてしまうと，Webサーバを通じて/ディレクトリ以下の全内容が丸見えになってしまいます（図 2）．</p>
+<p>パスワードを適当に設定してください（図２０）．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図2 Webサーバを通じて/ディレクトリ以下が丸見えに
+■図２０　作成したアカウントのパスワードを設定
 <pre>
-# ls /var/www/html/
-en index.html.en index.html.ja index.var ja tomoyo-links.html tomoyo.css
-# mount --bind / /var/www/html/
-# ls /var/www/html/
-bin boot dev etc home initrd lib lost+found media misc mnt opt proc root sbin selinux srv sys tmp usr var
-# umount /var/www/html/
-# ls /var/www/html/
-en index.html.en index.html.ja index.var ja tomoyo-links.html tomoyo.css
+# passwd user1
+# passwd user2
 </pre>
 </td></tr>
 </table>
 
-<p>これまでの例で，パス名というものはマウントの内容1つでがらりと変わってしまうということをご理解いただけたと思います．もちろん，このような異常なマウントは正規の管理者であれば行わないはずですが，管理者権限で動作しているプロセスの欠陥を攻撃して侵入してきたクラッカーが行わないとは限りません．TOMOYO Linuxではそうした脅威を防ぐための機能を備えています．</p>
+<p>cat コマンド用のドメインを作成するために， cat コマンドを実行してください．ついでに，このコマンドが動作するドメインも表示してみます（図２１）．</p>
 
-<h3>曖昧さを減らすために</h3>
+<table border="1" summary="fig">
+<tr><td>
+■図２１　cat コマンドが動作するドメインを表示
+<pre>
+# cat /proc/ccs/self_domain
+&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
+</pre>
+</td></tr>
+</table>
 
-<p>TOMOYO Linuxでは，allow_mountというキーワードを用いて，マウント可能なデバイスファイルとマウントポイントの組み合わせを制限できます．これにより，システム管理者が許可したいマウントだけを許可できるようになります．</p>
+<p>このドメインに学習用プロファイルを割り当ててください．この連載では学習用プロファイルの番号は１ですので，図２２のようになります．</p>
 
-<h3>それだけで充分？</h3>
+<table border="1" summary="fig">
+<tr><td>
+■図２２　cat コマンド用ドメインに学習用プロファイルを割り当て
+<pre>
+# /usr/sbin/ccs-setprofile 1 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat'
+</pre>
+</td></tr>
+</table>
 
-<p>allow_mountキーワードでマウントを制限するだけで充分なのでしょうか？次のようなケースを考えてみましょう．</p>
+<p>ログアウトして， user1 としてログインし直します．そして，図２３の操作を行ってください．</p>
 
-<p>まず，マウントポイントとして/mnt/dir/を作成します．次に，/mnt/dir/の上にtmpfsをマウントし，/mnt/dir /fileという名前のファイルを作成します（図3）．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図２３　user1 でログインし， /tmp/testfile1 を作成
+<pre>
+$ echo "This file was created by user1" &gt; /tmp/testfile1
+$ cat /tmp/testfile1
+This file was created by user1
+</pre>
+</td></tr>
+</table>
 
+<p>ログアウトして， user2 としてログインし直します． user1 と同様に操作を行ってください（図２４）．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図3 /mnt/dir/にtmpfsをマウントし，/mnt/dir/fileを作成
+■図２４　user2 でログインし， /tmp/testfile2 を作成
 <pre>
-# mkdir -p /mnt/dir
-# mount -t tmpfs none /mnt/dir/
-# touch /mnt/dir/file
-# ls /mnt/dir/file
-/mnt/dir/file
+$ echo "This file was created by user2" &gt; /tmp/testfile2
+$ cat /tmp/testfile2
+This file was created by user2
 </pre>
 </td></tr>
 </table>
 
-<p>この状態で，再度/mnt/dir/の上にtmpfsをマウントすると，/mnt/dir/fileが見えなくなってしまいました（図4）．</p>
+<p>ログアウトして， root としてログインし直します． ccs-editpolicy を起動して，「 &lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat 」ドメインのアクセス許可を確認してください．図２５のようなエントリが含まれているはずです．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図4 再度tmpfsをマウントすると，/mnt/dir/fileが見えない
+■図２５　&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat ドメインのアクセス許可
 <pre>
-# mount -t tmpfs none /mnt/dir/
-# ls /mnt/dir/file
-ls: /mnt/dir/file: No such file or directory
-# umount /mnt/dir/
-# ls /mnt/dir/file
-/mnt/dir/file
-# umount /mnt/dir/
+allow_read /tmp/testfile1
+allow_read /tmp/testfile2
 </pre>
 </td></tr>
 </table>
 
-<p>アンマウントすれば元に戻るわけですが，前述したallow_mountキーワードによるマウント制限だけでは，マウント可能なデバイスファイルとマウントポイントの組み合わせを制限できても，許可されている組み合わせで複数回マウントすることは防げないことがわかります．</p>
+<p>このままではどちらのファイルもＤＡＣ（任意アクセス制御）のパーミッションにより許可されれば誰でも読むことができてしまいます．ここで，キーボードの「 A 」を押して，図２６のように入力してください．</p>
 
-<p>でも，ちょっと待ってください．普通は，マウントは/ディレクトリに近い順に行いますよね．たとえば，/usr/と/usr/local/が別パーティションになっている場合，/usr/→/usr/local/の順にマウントするでしょう．/usr/local/→/usr/の順番にしてしまうと /usr/local/の内容が見えなくなってしまい，システムの動作に支障が発生するので，そのような順番にはしません．つまり，既存のマウントを隠蔽するようなマウントは禁止してしまっても大丈夫ということです．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図２６　アクセス許可を追加<br>（※これらをまとめて， allow_read /tmp/testfile\+ if task.uid=path1.uid のように入力してもかまいません．）
+<pre>
+allow_read /tmp/testfile1 if task.uid=path1.uid
+allow_read /tmp/testfile2 if task.uid=path1.uid
+</pre>
+</td></tr>
+</table>
 
-<p>TOMOYO Linuxでは，既存のマウントを隠蔽するようなマウントを行う場合，conceal_mountという（TOMOYO Linux独自の）ケイパビリティがチェックされます（図5）．</p>
+<p>それから，図２７の内容をキーボードの「 D 」を押して削除します．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図5 既存のマウントを隠蔽するようなマウントを行うためのアクセス許可
+■図２７　削除する内容
 <pre>
-allow_capability conceal_mount
+allow_read /tmp/testfile1
+allow_read /tmp/testfile2
 </pre>
 </td></tr>
 </table>
 
-<h3>アンマウントは？</h3>
+<p>キーボードの「 Q 」を押して， ccs-editpolicy を終了します．そして， cat コマンド用のドメインに強制用プロファイルを割り当ててください．この連載では強制用プロファイルの番号は３ですので図２８のようになります．</p>
 
-<p>マウントを制限するだけでは，まだ不十分です．たとえば，/proc/ディレクトリにマウントされているprocファイルシステムがアンマウントされてしまうと，多くのプログラムが正常に動作できなくなってしまう可能性があります．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図２８　cat コマンド用ドメインに強制用プロファイルを割り当て
+<pre>
+# /usr/sbin/ccs-setprofile 3 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat'
+</pre>
+</td></tr>
+</table>
 
-<p>TOMOYO Linuxでは，allow_unmountというキーワードを用いて，アンマウント可能なマウントポイントを制限できます．</p>
+<p>ログアウトして， user1 としてログインし直します．そして， /tmp/testfile1 と /tmp/testfile2 を cat してみてください． /tmp/testfile2 へのアクセスが禁止されていることを確認できます（図２９）．</p>
 
-<p>以上でマウントおよびアンマウントの制御の説明を終わります．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図２９ /tmp/testfile2 へのアクセスが禁止されている
+<pre>
+$ cat /tmp/testfile1
+This file was created by user1
+$ cat /tmp/testfile2
+cat: /tmp/testfile2: Operation not permitted
+</pre>
+</td></tr>
+</table>
 
-<h3>chrootは？</h3>
+<p>ログアウトして， user2 としてログインし直します． user1 と同様に操作を行ってください． /tmp/testfile1 へのアクセスが禁止されていることを確認できます．変数の代わりにユーザＩＤを直接指定することもできます．たとえば，ユーザ認証を行ってログインシェルを起動するための「 &lt;kernel&gt; /sbin/mingetty /bin/login 」ドメインに対して，図３０のように変更してやると， root ユーザのログインを禁止することができます．</p>
 
-<p>Linuxでは，chrootという，ルートディレクトリを変更する機能を備えています．アプリケーションがchrootを用いて/tmp/のように書き込み可能なディレクトリへルートディレクトリを変更できてしまうと，悪意あるプログラム一式を展開して実行されてしまう危険性があります．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図３０　root ユーザのログインを禁止する設定
+<pre>
+[修正前]
+allow_execute /bin/bash
+[修正後]
+allow_execute /bin/bash if task.uid!=0
+</pre>
+</td></tr>
+</table>
 
-<p>TOMOYO Linuxはchroot前のルートディレクトリから見たパス名を記憶しており，chrootする前のパス名でアクセス制御をするため，どこに chrootしても問題ありませんが，
-allow_chrootというキーワードを用いて移動可能なディレクトリを制限できます．</p>
+<p>また，図３１のように変更してやると，ユーザＩＤが 500 以上 1000 以下のユーザだけがログインできるようにすることができます． SSH 経由でのログインを制限したい場合に使うことができます．</p>
 
-<h3>デバイスファイルの作成は？</h3>
+<table border="1" summary="fig">
+<tr><td>
+■図３１　ユーザＩＤ 500 以上 1000 以下のユーザのみログインできる設定
+<pre>
+[修正前]
+allow_execute /bin/bash
+[修正後]
+allow_execute /bin/bash if task.uid=500-1000
+</pre>
+</td></tr>
+</table>
 
-<p>Linuxでは，マウントするときもデバイス名を使います（LABEL=やUUID=という指定方法も使えますが，ここでは侵入者が前述したマウント制限の突破を試みる場合を想定します）．たとえば，SCSI接続された最初のHDDの最初のパーティションをマウントするときには"mount -dev=0801 /mnt/"のようにデバイスの属性ではなく，"mount /dev/sda1 /mnt/"のようにデバイス名を使います．これが正しく動作するためには，デバイスファイルが指すデバイスが，管理者が期待したとおりの属性を持っていることが不可欠です．いくらマウントできるデバイス名とマウントポイントの組み合わせを制限しても，デバイスファイルが改竄されていたら何の役にも立ちません．root権限があれば，ファイルを削除して同名のファイルを作り直すことで改竄できてしまいます．</p>
+<h2>アクセスログからポリシーを生成する（上級者向け）</h2>
 
-<p>パス名が指すデバイスが期待していたものとは違っていたら何が起こるでしょう？たとえば，/dev/nullが通常ファイルになっていたら……．消えたはずだと思っていた情報が蓄積されていき，情報漏洩や誤動作の原因になる場合もあります．たとえば，/dev/sda1が/dev/sda2の属性を持っていたら…．/home/ディレクトリにマウントされるべき内容が/var/ディレクトリにマウントされてしまい，ユーザがログインできなくなってしまったという事態も起こり得ます．そのような不安を解消するために，TOMOYO Linuxではallow_unlink（ファイルの削除を許可）やallow_mkblock（ブロック型デバイスファイルの作成を許可）のように書き込み権限を細分化することでリスクを減らしています．</p>
+<p>学習モードで生成されるポリシーに含まれているアクセス許可には exec.realpath と exec.argv[0] と symlink.target だけしか含まれていませんが，アクセスログには図１７で示した全ての変数が含まれています．そのため，アクセスログからポリシーを生成してやれば，最も厳格な条件付きアクセス許可を定義することができます．</p>
 
-<h2>TOMOYOプロジェクト便り</h2>
+<h3>自動的にアクセス許可を追加しないように設定する</h3>
 
-<p>2006年12月にCE Linux Forumのイベント，「Japan Technical Jamboree12」で，組込みLinuxフォーラムの関係の方々にTOMOYO Linuxをご紹介させていただきました．そのときの説明資料と様子は，<a href="http://tree.celinuxforum.org/CelfPubWiki/JapanTechnicalJamboree12">Wikiページ</a>で参照することができます．</p>
+<p>学習モードでは，一度ポリシー違反が発生すると，そのポリシー違反を起こさないようにするために必要なアクセス許可が自動的に追加されてしまいます．しかし，自動的に追加されるアクセス許可には図１７で示した全ての情報が含まれているわけではありません．そのため，プロファイルを図４８のように編集して自動的に追加されないようにします．</p>
 
-<p>Linuxはデジタルテレビや携帯電話など組込み機器の分野でも急速に利用が広まっています．ハードディスクレコーダーが掲示板への書き込みの踏み台にされたり，携帯電話を対象にしたウィルスが問題になるなど，セキュリティに対する関心は，むしろ通常のサーバ用途以上に高まっています．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図４８　/etc/ccs/profile.conf の変更箇所
+<pre>
+[修正前]
+PREFERENCE::learning={ verbose=no }
+[修正後]
+PREFERENCE::learning={ verbose=no max_entry=0 }
+</pre>
+</td></tr>
+</table>
 
-<p>イベントでは多数の貴重なご意見をいただきましたが，その中に「ぜひTOMOYO Linuxをメインラインに含めることを目指してほしい」という声がありました．このイベントの関係の方々から，2007年4月に米サンノゼで開催される組込みLinuxの国際会議，「<a href="http://www.celinux.org/elc2007/">CELF Embedded Linux Conference</a>」をご紹介いただき，投稿したところプレゼンテーションとチュートリアルを行えることになりました．TOMOYO Linuxとしての世界デビューとなります．</p>
+<p>保存したら，図４９のコマンドを実行して変更を反映してください．</p>
 
-<p>また、2007年2月にYLUGのイベント，「第72回カーネル読書会」でもTOMOYO Linuxをご紹介させていただきました．そのイベントでもメインラインへ向けて頑張るよう激励され，このイベントの参加者の方々から2007年6月にカナダのオタワで開催されるLinuxの国際会議「<a href="http://www.linuxsymposium.org/2007/">Linux Symposium 2007</a>」をご紹介いただき，投稿したところBoFセッションを行えることになりました．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図４９　変更を反映する
+<pre>
+# /usr/sbin/ccs-loadpolicy p
+</pre>
+</td></tr>
+</table>
 
-<p>今年はメインストリームを目標に一気に活動が広がるかもしれません．TOMOYOプロジェクトでは，社外からも開発者やテスターなどを募集しています．みんなの力で盛り上げていきたいと思います．</p>
+<h3>プログラムを動作させる</h3>
 
-<p>このコラムは2007年3月28日に執筆していますが，読者の皆さんがこの号を手にとられるときにはCELFの発表が終了しているはずです．今後連載の中で組込み向けの機能や会議の様子についてご紹介していきたいと思います．</p>
+<p>この状態でプログラムを動作させます．ポリシー違反は全てアクセスログとして保存されていきます．</p>
 
-<h2>レスキュー手順</h2>
+<p>図４８で max_entry=0 という指定をしたため，図５０のようなメッセージが大量に表示されますが無視してください．</p>
 
-<p>もし，TOMOYO Linuxのアクセス制御が原因でシステムが起動できなくなった場合には，カーネル起動時のコマンドラインに ccsecurity=off というパラメータを追加することにより，TOMOYO Linuxのアクセス制御を無効化して起動することができます．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図５０　学習する件数の上限に達したことを示すメッセージ
+<pre>
+WARNING: Domain 'ドメイン名' has so many ACLs to hold. Stopped learning mode.
+</pre>
+</td></tr>
+</table>
 
+<h3>アクセスログから必要な部分を抽出する</h3>
+
+<p>grep を用いて mode=learning を含むログを抽出します（図５１）．前後に空白を含めていることに注意してください．空白を入れ忘れると，ファイル名などと一致してしまう可能性があります．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図５１　学習モードのアクセスログだけを抽出する
+<pre>
+# grep -F -A 2 " mode=learning " /var/log/tomoyo/reject_log.txt &gt; /var/log/tomoyo/learning_log.txt
+</pre>
+</td></tr>
+</table>
+
+<p>抽出したら，条件付きのアクセス許可に変換します（図５２）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図５２　条件付きのアクセス許可に変換する
+<pre>
+# /usr/lib/ccs/convert-audit-log &lt; /var/log/tomoyo/learning_log.txt &gt; /var/log/tomoyo/policy.tmp
+</pre>
+</td></tr>
+</table>
+
+<p>変換したら，ドメイン単位でソートすることにより圧縮します（図５３）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図５３　ドメイン単位でソートする
+<pre>
+# /usr/sbin/ccs-sortpolicy &lt; /var/log/tomoyo/policy.tmp &gt; /var/log/tomoyo/policy.txt
+</pre>
+</td></tr>
+</table>
+
+<h3>加工してからポリシーとして追加する</h3>
+
+<p>/var/log/tomoyo/policy.txt はそのままドメインポリシーとして /etc/ccs/domain_policy.conf に追加することが可能ですが，図５４のように条件が厳密すぎて使い物にならない（例えばプロセスＩＤやｉノード番号などは毎回変わるため、指定しない方が良い）ので，テキストエディタを用いて条件を緩めて（不要と思われる条件部分を除去して）から追加してください．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図５４　厳密すぎるアクセス許可
+<pre>
+allow_execute /usr/bin/id if task.pid=4641 task.ppid=4637 task.uid=48 task.gid=48 task.euid=48 task.egid=48 task.suid=48 task.sgid=48 task.fsuid=48 task.fsgid=48 task.state[0]=0 task.state[1]=0 task.state[2]=0 task.type!=execute_handler path1.uid=0 path1.gid=0 path1.ino=603159 path1.major=8 path1.minor=1 path1.perm=0755 path1.type=file path1.parent.uid=0 path1.parent.gid=0 path1.parent.ino=589834 path1.parent.perm=0755 exec.realpath="/usr/bin/id" exec.argc=1 exec.envc=7 exec.argv[0]="id" exec.envp["TERM"]="linux" exec.envp["PATH"]="/sbin:/usr/sbin:/bin:/usr/bin" exec.envp["PWD"]="/usr/share/horde/admin" exec.envp["LANG"]="en_US.UTF-8" exec.envp["SHLVL"]="3" exec.envp["LANGUAGE"]="en_US.UTF-8" exec.envp["_"]="/usr/bin/id"
+</pre>
+</td></tr>
+</table>
+
 <h2>次回予告</h2>
 
-<p>今回で，TOMOYO Linuxの基本的な使い方と主要機能の説明は終わりです．次回は，TOMOYO Linuxの特徴である階層化されたドメイン遷移を利用して，近年急増しているsshブルートフォース攻撃への対策と管理者権限の分割方法について紹介します．どうぞお楽しみに．</p>
+<p>今回はドメイン遷移の制御とポリシーのチューニング方法について紹介しました．次回は，TOMOYO Linuxの特徴である階層化されたドメイン遷移を利用して，近年急増しているsshブルートフォース攻撃への対策と管理者権限の分割方法について紹介します．どうぞお楽しみに．</p>
 
 <p><a href="tutorial-4.html.ja">第４回へ戻る</a>　<a href="tutorial-6.html.ja">第６回へ進む</a></p>
 
Index: tutorial-6.html.ja
===================================================================
--- tutorial-6.html.ja	(revision 3668)
+++ tutorial-6.html.ja	(working copy)
@@ -481,14 +481,10 @@
 
 <p><a href="ssh-recording-cmdline.html.ja">シェルセッションのコマンドラインを記録する</a></p>
 
-<h2>まとめ</h2>
+<h2>次回予告</h2>
 
-<p>2007年1月号から6回にわたりTOMOYO Linuxの機能について紹介してきましたが，今回をもって基本的な機能の紹介は完了です（お疲れさまでした）．</p>
+次回は，ファイル以外のアクセス制御について紹介します．
 
-<p>セキュアOSというと「なんだか難しそう」「特殊な技術」「使えない」というイメージがありますが，TOMOYO Linuxに関しては決してそんなことがないことをご理解いただけたのではないかと思います．セキュアOSは，バッファオーバーフローによる侵入を防ぐための保険としてだけではなく，抜け道を心配しながらのアプリケーションレベルでの複雑な設定をも一掃してくれる，便利な機能を備えています．この連載が，セキュアOSによるセキュリティ強化推進の役に立つことを願っています．ぜひ連載の原稿を手元に置きながら，TOMOYO Linuxを皆さまのサーバのセキュリティ強化にご活用ください．</p>
-
-<p>さて，次回からはシーズン2ということで，実際のアプリケーションを用いてポリシー作成の手順を中心に紹介していく予定です．どうぞお楽しみに！</p>
-
 <p><a href="tutorial-5.html.ja">第５回へ戻る</a>　<a href="tutorial-7.html.ja">第７回へ進む</a></p>
 
 <hr>
Index: tutorial-7.html.ja
===================================================================
--- tutorial-7.html.ja	(revision 3668)
+++ tutorial-7.html.ja	(working copy)
@@ -3,72 +3,520 @@
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <meta http-equiv="Content-Style-Type" content="text/css">
-<title>TOMOYO Linuxの世界　第７回：「新学期スタート」</title>
+<title>TOMOYO Linuxの世界　第７回：「いろんな機能を試してみよう」</title>
 <link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
 </head>
 <body>
 <!--
-<p style="text-align:right;"><a href="tutorial-7.html.en">English Page</a></p>
+<p style="text-align:right;"><a href="tutorial-4.html.en">English Page</a></p>
 <p style="text-align:right;">Last modified: $Date$</p>
 -->
-<h1>TOMOYO Linuxの世界<br>第７回：「新学期スタート」</h1>
+<h1>TOMOYO Linuxの世界<br>第７回：「いろんな機能を試してみよう」</h1>
 
-<p>今回は， CE Linux Forum Worldwide Embedded Linux Conference 2007の模様をお届けします．</p>
+<p>TOMOYO Linuxでは，ファイルに対して以外にもさまざまなアクセス制御を行うことができます．今回は，ネットワーク，ケイパビリティ，シグナルに対するアクセス制御について解説します．</p>
 
 <h2>今回の内容</h2>
 
-<p>前回まででTOMOYO Linuxの基本的な機能の紹介と使い方についての説明が完了しました．</p>
+<p>これまでの連載では，ファイルに対するアクセス制御機能について紹介してきました．ファイルに対するアクセス制御機能は，プログラムやデータへの不要なアクセスを排除する，セキュアOSを用いたセキュリティ強化の基本となります．しかし，この機能だけでは十分とは言えません．今回は，TOMOYO Linuxが備える他のアクセス制御機能の中からネットワークに対するアクセス制御機能をはじめ主要なものを紹介します．</p>
 
-<p>今回は4月に発表を行ったELC2007の様子も紹介します．リリースの詳細については，<a href="http://sourceforge.jp/projects/tomoyo/news/">プロジェクトのニュース</a>や<a href="http://lists.sourceforge.jp/mailman/archives/tomoyo-users/">メーリングリストのアーカイブ</a>にてご確認ください．</p>
+<h2>ネットワークに対するアクセス制御機能について</h2>
 
-<h2>ELC2007レポート</h2>
+<p>Linuxではデフォルトでiptablesというパケットフィルタリングを行うための機能が利用できます．TOMOYO Linuxでも同様の機能を提供しますが，TOMOYO Linuxのネットワークに対するアクセス制御機能はドメイン単位やユーザID単位でパケットフィルタリングを行うことができ，設定も容易です．iptablesの設定は構文が難しくてわからないという人でも使えます（ただし，iptablesと連携しているわけではないので，iptablesでしか利用できない機能もあります．）．</p>
 
-<h3>ELC2007について</h3>
+<h3>制御可能な範囲</h3>
 
-<p>連載第5回で予告したように4月17～19日までサンノゼで開催されたCE Linux Forum Worldwide Embedded Linux Conference 2007に参加し，TOMOYO Linuxのプレゼンテーションとチュートリアルを行ってきました．</p>
+<p>TOMOYO Linuxにおけるネットワーク制御の対象について図1に示します．</p>
 
-<ul>
-<li><a href="http://www.celinux.org/elc2007/">イベントWebページ</a></li>
-<li><a href="http://tree.celinuxforum.org/CelfPubWiki/ELC2007Presentations">プレゼンテーション資料</a></li>
-<li><a href="http://tree.celinuxforum.org/CelfPubWiki/JapanTechnicalJamboree12">CELinux Forum Japan Technical Jamboree12</a></li>
-</ul>
+<table border="1" summary="fig">
+<tr><td>
+■図1 ネットワーク制御の対象
+<pre>
+TCPプロトコル／UDPプロトコル／IPプロトコル
+IPv4ネットワークアドレス／IPv6ネットワークアドレス
+ポート番号
+</pre>
+</td></tr>
+</table>
 
-<p>CE LinuxのCEはConsumer Electronicsの略です．本会議については，2006年12月8日にJapan Technical Jamboree12でTOMOYO Linuxについて紹介させていただいた際に， 「ぜひ国内だけでなく海外のイベントでも発表してみては」とお勧めいただいたことが応募のきっかけとなり実現しました．</p>
+<p>TOMOYO Linuxのネットワークアクセス制御機能を用いると，たとえば「sshdからログインしたuidが500のユーザが実行したsvnプロセスのみが，ホスト202.221.179.21のポート80に対してTCPプロトコルを用いた通信を行うことができる」といった制御が可能となります．次節以降，実際に設定してみることにしましょう．</p>
 
-<h3>会議の模様</h3>
+<h3>準備</h3>
 
-<p>会議は，3つの部屋でプログラムが同時進行するという形式で行われ，参加者は興味のあるセッションを自由に選択します．参加者名簿がないので正確な人数はわかりませんが，会場の規模から判断して少なくとも200名以上が参加していたと思います．</p>
+<p>ネットワークに対するアクセス制御はファイルに対するアクセス制御と同様にドメイン毎に指定ができます．ここでは，「ネットワークアクセス制御のみの学習」「ネットワークアクセス制御のみの確認」「ネットワークアクセス制御のみの強制」の3種類のプロファイルを作ります．</p>
 
-<p>発表の内容はハードウェアからソフトウェアまで多岐にわたり，組込みLinuxの領域の広さをあらためて感じました．キーノートセッションは，Thomas Gleixner氏によるしゃれっ気に満ちた“Embedded Linux - An Increasing Nightmare?” （ 「組込みLinuxは増殖する悪夢か？」 ）と，LinuxDevice Driversの著者で有名なJonathan Corbet氏による“The State of the Linux Kernel” （ 「Linuxカーネルの状態」 ）の2本で（資料はいずれも上記のプレゼンテーション資料のリンクより参照，ダウンロードできます） ，BOFも含めると56ものセッションがありました．</p>
+<h3>(1)プロファイルの定義</h3>
 
-<p>セキュリティに関するものは残念ながらあまり多くはなく，日立ソフトウェアエンジニアリング㈱中村雄一氏の“Comparison of Secure OSes and Embedded SELinux Activity in Japan”と，TOMOYO Linuxのプレゼンテーション“TOMOYOLinux - A Lightweight and Manageable Security System for PC and Embedded Linux” ，およびチュートリアル“TOMOYO Linux - Tutorial”の3本でした．</p>
+<p>準備としてプロファイル5～7を作成することにします．/etc/ccs/profile.confの末尾に図2の内容を追加してください．</p>
 
-<p>プログラムでは予定されていなかったのですが，「日本セキュアOS連合チーム」はデモにも参加しました．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図2 /etc/ccs/profile.confの末尾に追加する内容
+<pre>
+5-COMMENT=Learning Mode (Network Only)
+5-CONFIG::network={ mode=learning }
+6-COMMENT=Permissive Mode (Network Only)
+6-CONFIG::network={ mode=permissive }
+7-COMMENT=Enforcing Mode (Network Only)
+7-CONFIG::network={ mode=enforcing }
+</pre>
+</td></tr>
+</table>
 
-<p>TOMOYO Linux関連のセッションについての反響ですが，残念ながら参加者はあまり多くありませんでした．ただ，Jonathan Corbet氏が足を運んでくれて，発表を聞いてもらうことができ，「 （TOMOYO Linuxと同じくパス名ベースのアクセス制御を行っている）AppArmorのチームと話をしてみると良い」 「できるだけ早くLinuxカーネルに対するパッチを投稿してみるべきだ」などのコメントをいただくことができました．これらのアドバイスについては，帰国後さっそく対応を行っています．</p>
+<p>保存したら，図3のコマンドを実行して変更を反映してください．</p>
 
-<p>余談ですが，氏は大変長身で，話をすると見上げるような形になります．発言は静かですが深みがあり， 「達人」という言葉を連想しました．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図3 変更を反映する
+<pre>
+# /usr/sbin/ccs-loadpolicy p
+</pre>
+</td></tr>
+</table>
 
-<h3>サンノゼ，会場の様子</h3>
+<h3>(2)学習させるドメインの決定</h3>
 
-<p>サンノゼを訪れたのは今回が初めてでしたが，とにかくお店が少なく，人が歩いていないところという印象でした．宿泊したホテルから会場まで徒歩約 30分の距離を毎日往復しましたが，基本的に他の人とすれ違うことはありません（歩いている人はほとんどいないのです） ．空はまさに「カリフォルニアの青い空！」という感じで，CGで描いたような色をしています．</p>
+<p>学習させるドメインの範囲は任意ですが，今回は操作中のシェルが属しているドメイン以下を対象としましょう．現在のプロセスが属しているドメイン名は，/proc/ccs/self_domainの内容をcatするとわかります．もし，現在実行中のシェルがkeep_domainによりドメイン遷移を行わないように指定されていた場合は，ポリシーエディタを用いて一時的にkeep_domainの指定を削除してください（ポリシーエディタで表示する際に見やすくするためであり，実環境で利用する場合にはkeep_domainの指定を削除する必要はありません．）．なお，学習されるIPアドレスやポート番号は環境により異なりますのでご了承ください．</p>
 
-<p>会場は会議用の施設で，無線LAN の設備が提供されていましたが，セキュリティはかかっておらず（笑） ，誰でも自由につなげられます．2日目の夜にはレセプションがあり，チャーターバスで何故か博物館に連れて行かれ，そこで立食パーティが開催されました．</p>
+<h3>学習させてみよう</h3>
 
-<h3>ゲーム</h3>
+<h4>(1)クライアント側の学習</h4>
 
-<p>最終日，すべてのセッションが終了後，ELC恒例（？）のゲームが始まるというので呼び出されました．</p>
+<p>図4の内容を実行し，現在のプロセスの属しているドメイン以下を学習モードにします（リダイレクトの部分は，実際のドメイン名を文字列として引用しても結構です）．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図4 現在のプロセスが属しているドメイン以下を学習モードにする
+<pre>
+# xargs -0 /usr/sbin/ccs-setprofile -r 5 &lt; /proc/ccs/self_domain
+</pre>
+</td></tr>
+</table>
 
-<p>ゲームの内容は，人物，契約などテーマ毎に分類されたクイズを参加者の出身地区3つを代表するメンバー3人が回答するというもので，どうやらアメリカの有名なクイズ番組のパロディのようです．</p>
+<p>学習させるためのコマンドとして，ここではcurlコマンドを用いてhttp://www.sourceforge.jp/にアクセスしてみます（図5）．</p>
 
-<p>問題はテーマごとに難易度の異なるものが配置されていて，当然ながら難しいものほど得点が高くなっています．司会は，CE Linux Forum の Wiki の管理者でもある Tim Bird氏が行いましたが，設問が茶目っ気たっぷりで大変楽しいものでした．たとえば， 「人物」ではLinus氏のアップの写真が投影されて， 「これは誰でしょう？」という感じです．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図5 curlコマンドを学習させる
+<pre>
+# curl http://www.sourceforge.jp/ &gt; /dev/null
+</pre>
+</td></tr>
+</table>
 
-<h3>そしてOLSへ！</h3>
+<p>なお，curlコマンドが使えない場合は，wgetやtelnetなどでもかまいません．ポリシーエディタを起動して，curlコマンドを実行したドメインのアクセス許可を表示してみましょう（図6）．</p>
 
-<p>ELC2007への参加はもちろん，世界の組込み Linux の関係者に対して TOMOYO Linux を知ってもらうことが目的でしたが，それは同時にメインライン化（Linuxカーネル本体への取り込み）提案を行うための最初のステップでもありました．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図6 curlコマンドを実行したドメインのアクセス許可<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig04.jpg" alt="sd200704-fig04.jpg">
+</td></tr>
+</table>
 
-<p>本誌が店頭に並ぶのは6月18日ですが，6月27～29日までオタワで開催される Ottawa Linux Symposium（通称OLS）では，TOMOYO Linux の BOFセッションを持ちます．国産セキュアOSであるTOMOYO Linuxの開発を通じて得られたものを Linux の世界とコミュニティにフィードバックすることができればと願っています．</p>
+<p>allow_networkで始まる行が，ネットワークに対するアクセス制御のためのアクセス許可です．「allow_network UDP connect 192.168.10.1 53」という部分は，UDPプロトコルを用いてDNSサーバ192.168.10.1のポート53にアクセスすることを許可するという意味です．また，「allow_network TCPconnect 202.221.179.21 80」という部分は，TCPプロトコルを用いてHTTPサーバ202.221.179.21（本稿執筆時点のwww.sourceforge.jpのIP アドレスです）のポート80にアクセスすることを許可するという意味です．</p>
 
+<h4>(2)サーバ側の学習</h4>
+
+<p>今度は，sshコマンドを用いてSSHサービスにログインしてみます（SSHサービスを稼動させていない場合には，HTTPなどの他のサービスでもかまいません）．例外ポリシーで「initialize_domain /usr/sbin/sshd」という指定がされている場合（連載第1回で実行したinit_policy.shによりそのように指定されているはずです），/usr/sbin/sshdは「&lt;kernel&gt; /usr/sbin/sshd」というドメインで動作することになるので，そのドメインに学習用のプロファイルを割り当ててみます（図7）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図7 &lt;kernel&gt; /usr/sbin/sshdドメインに学習用プロファイルを割り当てる
+<pre>
+# /usr/sbin/ccs-setprofile 5 '&lt;kernel&gt; /usr/sbin/sshd'
+</pre>
+</td></tr>
+</table>
+
+<p>その後，sshでlocalhostにログインし（図8），ポリシーエディタを実行して&lt;kernel&gt; /usr/sbin/sshdドメインに対するアクセス許可を確認してください（図9）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図8 sshでlocalhostにログイン
+<pre>
+# ssh localhost
+</pre>
+</td></tr>
+</table>
+
+<table border="1" summary="fig">
+<tr><td>
+■図9 &lt;kernel&gt; /usr/sbin/sshdドメインに対するアクセス許可<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig07.jpg" alt="sd200704-fig07.jpg">
+</td></tr>
+</table>
+
+<p>図9では「allow_network TCP accept 127.0.0.1 51051」としてアクセス許可が与えられていますが，もしIPv6が有効になっている場合はv6のアドレスになりますので注意してください．ファイルに対するアクセス許可と同様に，ネットワークに対するアクセス許可にも条件を付与することができます．たとえば，図10のようにプロセスのユーザIDと組み合わせることで，ユーザごとに接続可能なサーバを制限したりすることもできます．</p>
+<table border="1" summary="fig">
+<tr><td>
+■図10 ユーザごとに接続可能なサーバを制限
+<pre>
+allow_network TCP connect 202.221.179.21 80 if task.uid=500
+allow_network TCP connect 66.35.250.203 80 if task.uid=501
+</pre>
+</td></tr>
+</table>
+
+<p>IPソケットの場合には，ポート番号の代わりにプロトコル番号を指定します．pingコマンドを例に説明します．図11の内容を実行してから，ポリシーエディタでpingコマンドの動作するドメインに対するアクセス許可を確認してください（図12）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図11 pingコマンドを実行
+<pre>
+# ping -c 4 www.sourceforge.jp
+</pre>
+</td></tr>
+</table>
+
+<table border="1" summary="fig">
+<tr><td>
+■図12 pingコマンドの動作するドメインに対するアクセス許可<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig09.jpg" alt="sd200704-fig09.jpg">
+</td></tr>
+</table>
+
+<p>「allow_network RAW connect 202.221.179.21 1」というアクセス許可が与えられていることを確認できます．これは，pingコマンドが動作しているドメインではIPソケット上でプロトコル番号1のプロトコル（ICMP）を用いて202.221.179.21と通信を行うことを許可するという意味です．</p>
+
+<h3>チューニングしてみよう</h3>
+
+<p>ひととおり学習してみたら，確認モードに切り替えて確認してみましょう．確認モードにするにはプロファイル6を割り当てます（図13）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図13 プロファイル6を割り当て，確認モードに切り替え
+<pre>
+# xargs -0 /usr/sbin/ccs-setprofile -r 6 &lt; /proc/ccs/self_domain
+</pre>
+</td></tr>
+</table>
+
+<h4>(1)アドレスのパターン化</h4>
+
+<p>ファイルに対するアクセス制御を行う際にワイルドカードを用いてパターン化したように，ネットワークに対するアクセス制御を行う際にもパターン化が必要になります．パターン化を行う場合は，開始アドレスと終了アドレスを-を用いて図14のように指定してください．-の前後に空白を入れてはいけません．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図14 IPv4アドレスを範囲で指定する
+<pre>
+xxx.xxx.xxx.xxx-yyy.yyy.yyy.yyy
+</pre>
+</td></tr>
+</table>
+
+<p>IPv6アドレスによる指定もIPv4アドレスの場合と同様ですが，"::"という省略表記や"."混じりの表記はサポートしていません．つねに図15のような形式で指定する必要があります．その他，負荷分散のため複数のIPアドレスを持つサーバに対するアクセス許可を与える場合は，使う可能性のあるすべてのIPアドレスを指定することを忘れないでください．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図15 IPv6アドレスを指定する
+<pre>
+xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx
+</pre>
+</td></tr>
+</table>
+
+<h4>(2)ポート番号のパターン化</h4>
+
+<p>サーバがクライアントからのリクエストを受け付けるためのポート番号は一般に固定されているのに対し，クライアントがリクエストを送り出すときに使用するポート番号は固定されていません．そのため，サーバ側でクライアントが使用する可能性のあるポート番号を範囲としてパターン化してやる必要があります．パターン化を行う場合は，開始ポートと終了ポートを-を用いて図16のように指定してください．-の前後に空白を入れてはいけません．よくあるパターンは図17の3つです．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図16 ポート番号を範囲で指定する
+<pre>
+xxxxx-yyyyy
+</pre>
+</td></tr>
+</table>
+
+<table border="1" summary="fig">
+<tr><td>
+■図17 ポート番号パターン化の例
+<pre>
+1024-65535
+32768-61000
+600-1023
+</pre>
+</td></tr>
+</table>
+
+<p>最初のパターンは通常のクライアントがサーバに接続する際に選択する可能性がある範囲で，おもにサーバ側のプログラムで必要になります．2番目のパターンは「/proc/sys/net/ipv4/ip_local_port_range」に指定されているポート番号の範囲です．通常のクライアントはこの範囲から未使用のローカルポート番号を選択してサーバに接続するため，おもにクライアント側のプログラムで必要になります．実際の/proc /sys/net/ipv4/ip_local_port_rangeの内容に合わせてパターンを定義してください．</p>
+
+<p>最後のパターンは，portmapコマンドのように未使用の特権ポート（ポート番号が1024未満のポート）を選択して接続するプログラムで必要になります．実際に必要な範囲は異なる場合があります．パターン化が必要か否かを判断する簡単な方法は，プログラムを何度か実行してみることです．たとえば，学習モードで何度か実行すると，図18のように，ポート番号が連続するアクセス許可が増えていきますので，その傾向から必要な範囲を推測してください．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図18 ポート番号が連続するアクセス許可の例①
+<pre>
+allow_network TCP bind 127.0.0.1 610
+allow_network TCP bind 127.0.0.1 611
+allow_network TCP bind 127.0.0.1 612
+allow_network TCP bind 127.0.0.1 613
+</pre>
+</td></tr>
+</table>
+
+<p>図18の例の場合，図19のような許可が必要である可能性が高いと言えます．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図19 図19を元にパターン化したアクセス許可
+<pre>
+allow_network TCP bind 127.0.0.1 600-1023
+</pre>
+</td></tr>
+</table>
+
+<p>また，図20であれば，図21または図22という許可が必要である可能性が高いでしょう．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図20 ポート番号が連続するアクセス許可の例②
+<pre>
+allow_network TCP accept 127.0.0.1 32780
+allow_network TCP accept 127.0.0.1 32781
+allow_network TCP accept 127.0.0.1 32782
+allow_network TCP accept 127.0.0.1 32783
+allow_network TCP accept 127.0.0.1 32784
+</pre>
+</td></tr>
+</table>
+
+<table border="1" summary="fig">
+<tr><td>
+■図21 図20を元にパターン化したアクセス許可
+<pre>
+allow_network TCP accept 127.0.0.1 1024-65535
+</pre>
+</td></tr>
+</table>
+
+<table border="1" summary="fig">
+<tr><td>
+■図22 図20を元にパターン化したアクセス許可
+<pre>
+allow_network TCP accept 127.0.0.1 32768-61000
+</pre>
+</td></tr>
+</table>
+
+<h3>強制してみよう</h3>
+
+<p>確認が終わったら，実際にネットワークのアクセス制御を適用しましょう．強制モードにするにはプロファイル7を割り当てます（図23）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図23 プロファイル7を割り当て，強制モードを適用
+<pre>
+xargs -0 /usr/sbin/ccs-setprofile -r 7 &lt; /proc/ccs/self_domain
+</pre>
+</td></tr>
+</table>
+
+<p>なお，プロファイル5～7はファイルに関するアクセス制御を行っていないことに注意してください．前回の本連載で紹介した，対話的にアクセス許可を追加するccs-querydを用いることで，その場で不足しているアクセス許可を追加することもできます．TOMOYO Linuxを使うと，iptables単体で行えるネットワークアクセス制御の内容を細分，詳細化できることがご理解いただけると思います．</p>
+
+<h2>ケイパビリティに対するアクセス制御機能について</h2>
+
+<p>Linuxカーネル2.2以降ではPOSIXケイパビリティに対応しています．ケイパビリティは，セキュアOSの基本概念である最少権限を形にしたもので，プロセス単位で各種特権の利用について制限を加えるために用いられます．Linuxで対応済みのケイパビリティについては，/usr /include/linux/capability.hの中で参照することができます．しかし，CAP_SYS_ADMIN権限がさまざまな目的に用いられているので，そのままでは本来の効果が期待できません．そこでTOMOYOLinuxでは独自にケイパビリティを定義，制御しています（以下「ケイパビリティ」はTOMOYO Linuxにおけるケイパビリティを指します）．</p>
+
+<p>TOMOYO LinuxではPOSIXとは異なる独自のケイパビリティを使用していますが，プログラムからはその存在は見えないので，プログラムに変更を加える必要はありません．バージョン1.7.2では図24の操作の可否を制限することができます．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図24 TOMOYO Linux 1.7.2のケイパビリティ<br>
+<table border="1" summary="fig">
+<tr><td>値</td><td>内容</td></tr>
+<tr><td>inet_tcp_create</td><td>TCPソケットの使用を許可</td></tr>
+<tr><td>inet_tcp_listen</td><td>TCPソケットのlistenを許可</td></tr>
+<tr><td>inet_tcp_connect</td><td>TCPソケットのconnectを許可</td></tr>
+<tr><td>use_inet_udp</td><td>UDPソケットの使用を許可</td></tr>
+<tr><td>use_inet_ip</td><td>RAWソケットの使用を許可</td></tr>
+<tr><td>use_route</td><td>ROUTEソケットの使用を許可</td></tr>
+<tr><td>use_packet</td><td>PACKETソケットの使用を許可</td></tr>
+<tr><td>use_kernel_module</td><td>create_module(2),init_module(2),delete_module(2)の使用を許可</td></tr>
+<tr><td>create_fifo</td><td>mknod(2)でFIFOの作成を許可</td></tr>
+<tr><td>create_block_dev</td><td>mknod(2)でブロック型デバイスの作成を許可</td></tr>
+<tr><td>create_char_dev</td><td>mknod(2)でキャラクタ型デバイスの作成を許可</td></tr>
+<tr><td>create_unix_socket</td><td>mknod(2)でUNIXドメインソケットの作成を許可</td></tr>
+<tr><td>SYS_MOUNT</td><td>mount(2)の使用を許可</td></tr>
+<tr><td>SYS_UMOUNT</td><td>umount(2)の使用を許可</td></tr>
+<tr><td>SYS_REBOOT</td><td>reboot(2)の使用を許可</td></tr>
+<tr><td>SYS_CHROOT</td><td>chroot(2)の使用を許可</td></tr>
+<tr><td>SYS_KILL</td><td>0以外のシグナルでkill(2),tkill(2),tgkill(2)の使用を許可</td></tr>
+<tr><td>SYS_VHANGUP</td><td>vhangup(2)の使用を許可</td></tr>
+<tr><td>SYS_TIME</td><td>stime(2),settimeofday(2),adjtimex(2)の使用を許可</td></tr>
+<tr><td>SYS_NICE</td><td>nice(2),setpriority(2)の使用を許可</td></tr>
+<tr><td>SYS_SETHOSTNAME</td><td>sethostname(2),setdomainname(2)の使用を許可</td></tr>
+<tr><td>SYS_LINK</td><td>link(2)の使用を許可</td></tr>
+<tr><td>SYS_SYMLINK</td><td>symlink(2)の使用を許可</td></tr>
+<tr><td>SYS_RENAME</td><td>rename(2)の使用を許可</td></tr>
+<tr><td>SYS_UNLINK</td><td>unlink(2)の使用を許可</td></tr>
+<tr><td>SYS_CHMOD</td><td>chmod(2),fchmod(2)の使用を許可</td></tr>
+<tr><td>SYS_CHOWN</td><td>chown(2),fchown(2),lchown(2)の使用を許可</td></tr>
+<tr><td>SYS_IOCTL</td><td>ioctl(2),compat_sys_ioctl(2)の使用を許可</td></tr>
+<tr><td>SYS_KEXEC_LOAD</td><td>kexec_load(2)の使用を許可</td></tr>
+<tr><td>SYS_PIVOT_ROOT</td><td>pivot_root(2)の使用を許可</td></tr>
+<tr><td>SYS_PTRACE</td><td>ptrace(2)の使用を許可</td></tr>
+<tr><td>conceal_mount</td><td>既存のマウントを隠ぺいするようなマウントを許可</td></tr>
+</table>
+</td></tr>
+</table>
+
+<p>ここではマウント操作を行う権限（SYS_MOUNT）を例に説明します．TOMOYO Linuxはパス名を用いてアクセス制御を行うため，管理者が期待したとおりにファイルシステムがマウントされていることは絶対の前提となります．root権限で動作しているすべてのプロセスが好き勝手にマウントをしてしまうようでは困ります．そのため，ケイパビリティを用いることでマウント操作を許可するドメインを制限します．ケイパビリティのアクセス制御の手順はネットワークに関するアクセス制御のときと同様です．まず，制限したいケイパビリティをプロファイルで指定します．/etc/ccs/profile.confの末尾に図25の内容を追加してください．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図25 /etc/ccs/profile.confの末尾に追加する内容（ケイパビリティに対するアクセス制御）
+<pre>
+9-CONFIG::capability::SYS_MOUNT={ mode=learning }
+10-CONFIG::capability::SYS_MOUNT={ mode=enforcing }
+</pre>
+</td></tr>
+</table>
+
+<p>ファイルやネットワークとは異なり，ケイパビリティの場合は操作対象を指定する必要がありません．学習モードで学習させるだけで強制モードで必要なすべてのケイパビリティが与えられるので，図25のプロファイルでは確認モードを省略しています．保存したら，図3のコマンドを実行して変更を反映してください．</p>
+
+<p>説明のために，先に強制モード用のプロファイル（10）を使用します（図26）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図26 強制モード用プロファイルを使用
+<pre>
+# xargs -0 /usr/sbin/ccs-setprofile -r 10 &lt; /proc/ccs/self_domain
+</pre>
+</td></tr>
+</table>
+
+<p>その後，適当なディレクトリにtmpfsをマウントします（図27）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図27 tmpfsをマウントする
+<pre>
+# mount -t tmpfs none /tmp/
+mount: permission denied
+</pre>
+</td></tr>
+</table>
+
+<p>拒否されました．これは，mountコマンドを実行したドメインに対して，マウント操作を行う権限が与えられていないためです．次に，学習モード用のプロファイル（9）を割り当てます（図28）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図28 学習モード用プロファイルを使用
+<pre>
+# xargs -0 /usr/sbin/ccs-setprofile -r 9 &lt; /proc/ccs/self_domain
+</pre>
+</td></tr>
+</table>
+
+<p>再度，適当なディレクトリにtmpfsをマウントします（図29）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図29 tmpfsをマウントする
+<pre>
+# mount -t tmpfs none /tmp/
+</pre>
+</td></tr>
+</table>
+
+<p>今度は正常に動作しました．ポリシーエディタを起動してmountコマンドを実行したドメインを探し，アクセス許可を確認してください（図30）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図30 allow_capability SYS_MOUNTというアクセス許可が学習されている<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig18.jpg" alt="sd200704-fig18.jpg">
+</td></tr>
+</table>
+
+<p>allow_capability SYS_MOUNTというアクセス許可が学習されていることを確認できます．この状態で強制モード用のプロファイル（10）を割り当てれば，許可されていないドメインからマウント操作を行うことを禁止できるようになります．</p>
+
+<p>マウント操作の可否だけを制限しても，マウント操作が許可されていれば任意のディレクトリにマウントできてしまうので，不十分だと思われる方がいるかもしれません．実際そのとおりであり，TOMOYO Linuxではマウントを許可するパーティションとマウントポイントの組み合わせを制限する機能も備えています．それについては次回紹介する予定です．</p>
+
+<h2>シグナルに対するアクセス制御機能について</h2>
+
+<p>TOMOYO Linuxでは，シグナルの種類と送信先を制限することができます．手順はネットワークに関するアクセス制御のときと同様です．/etc/ccs /profile.conf末尾に図31の内容を追加してください．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図31 /etc/ccs/profile.confの末尾に追加する内容（シグナルに対するアクセス制御）
+<pre>
+11-CONFIG::ipc::signal={ mode=learning }
+12-CONFIG::ipc::signal={ mode=enforcing }
+</pre>
+</td></tr>
+</table>
+
+<p>保存したら，図3のコマンドを実行して変更を反映してください．</p>
+
+<p>以降の操作は，「&lt;kernel&gt; /usr/sbin/sshd /bin/bash」ドメインに属しているシェル（つまりsshdからログインしたときのログインシェル）から行うものとします．事前に「keep_domain &lt;kernel&gt; /usr/sbin/sshd /bin/bash」という指定がされていないことを確認しておいてください．最初に，sleepコマンドを実行してください（図32）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図32 sleepコマンドを実行
+<pre>
+# sleep 100
+</pre>
+</td></tr>
+</table>
+
+<p>この状態で，別の画面を開いてログインしてください．説明のために，先に強制モード用のプロファイル（14）を割り当てます（図33）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図33 強制モード用プロファイルを使用
+<pre>
+# xargs -0 /usr/sbin/ccs-setprofile -r 14 &lt; /proc/ccs/self_domain
+</pre>
+</td></tr>
+</table>
+
+<p>次に，動作中のsleepコマンドのプロセスIDを取得し，そのプロセスIDに対してシグナルを送信します（図34）（シェルのビルトインではなく，/bin/killが実行されるよう明示的に指定しています．）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図34 sleepコマンドのプロセスIDに対してシグナル送信
+<pre>
+# pidof sleep
+4649
+# /bin/kill -15 4649
+kill 4649: Operation not permitted
+</pre>
+</td></tr>
+</table>
+
+<p>拒否されました．これは，killコマンドが動作するドメインに対して，sleepコマンドが動作するドメインへシグナルを送信する権限が与えられていないためです．次に，学習モード用のプロファイル（13）を割り当て（図35），再度シグナルを送信します（図36）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図35 学習モード用プロファイルを使用
+<pre>
+# xargs -0 /usr/sbin/ccs-setprofile -r 13 &lt; /proc/ccs/self_domain
+</pre>
+</td></tr>
+</table>
+
+<table border="1" summary="fig">
+<tr><td>
+■図36 再度sleepコマンドのプロセスIDに対してシグナル送信
+<pre>
+# /bin/kill -15 4649
+</pre>
+</td></tr>
+</table>
+
+<p>今度は正常に動作しました．ポリシーエディタを起動してkillコマンドを実行したドメインを探し，アクセス許可を確認してください（図37）．</p>
+
+<table border="1" summary="fig">
+<tr><td>
+■図37 killコマンドを実行したドメインのアクセス許可<br>
+<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig25.jpg" alt="sd200704-fig25.jpg">
+</td></tr>
+</table>
+
+<p>「allow_signal 15 &lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/sleep」というアクセス許可が学習されていることを確認できます．これは，「&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/sleep」という名前で始まるドメインに属しているプロセスに対して15番のシグナル（SIGTERM）を送信することを許可するという意味です．TOMOYO Linuxにおけるドメイン名は&lt;kernel&gt;で始まる階層構造であるため，allow_signal 15 &lt;kernel&gt;のように指定した場合，すべてのプロセスに対して15番のシグナルを送信することが許可されることに注意してください．例外として，シグナルの送信元が送信先と同じドメインの場合はつねに許可されます．また，0番のシグナルもつねに許可されます．</p>
+
+<h2>次回予告</h2>
+
+<p>今回はTOMOYO Linuxのネットワークのアクセス制御機能を中心に紹介しました．通信を行うドメインを限定したうえで，強力かつ柔軟なアクセス制御を行えることがご理解いただけたと思います．次回は，ログインセッションを制限する方法についての紹介を行います．どうぞお楽しみに．</p>
+
 <p><a href="tutorial-6.html.ja">第６回へ戻る</a>　<a href="tutorial-8.html.ja">第８回へ進む</a></p>
 
 <hr>
Index: tutorial-8.html.ja
===================================================================
--- tutorial-8.html.ja	(revision 3668)
+++ tutorial-8.html.ja	(working copy)
@@ -3,7 +3,7 @@
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <meta http-equiv="Content-Style-Type" content="text/css">
-<title>TOMOYO Linuxの世界　第８回：「blogのポリシーを作成してみよう（前編）」</title>
+<title>TOMOYO Linuxの世界　第８回：「ログインセッションを制限してみよう（前編）」</title>
 <link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
 </head>
 <body>
@@ -11,487 +11,375 @@
 <p style="text-align:right;"><a href="tutorial-8.html.en">English Page</a></p>
 <p style="text-align:right;">Last modified: $Date$</p>
 -->
-<h1>TOMOYO Linuxの世界<br>第８回：「blogのポリシーを作成してみよう（前編）」</h1>
 
-<p>今回からは，より実践的なTOMOYO Linuxの設定方法について紹介していきます．blogソフトウェアとして広く利用されているMovableTypeを題材に，ポリシー設定方法を解説します．</p>
+<h1>TOMOYO Linuxの世界<br>第８回：「ログインセッションを制限してみよう（前編）」</h1>
 
+<p>今回は，さらに実践的なTOMOYO Linuxの設定方法として，システムへのログイン後にユーザが行う操作を制限する手順を解説します．</p>
+
 <h2>今回の内容</h2>
 
-<p>連載の第1回～6回まででTOMOYO Linuxの基本的な使い方について紹介しました．そこで，今回から数回にわたり，実際のシステムに近い形でTOMOYO Linuxを用いたシステム構築手順について紹介しようと思います．環境としては，CentOS 5.3上でMovableType 3.3を動作させることにします．</p>
+<p>今回はTOMOYO Linux 1.7.2の機能をフルに活用して，システムにログイン後行う操作を制限する方法について解説します．</p>
 
-<h3>MovableTypeのインストール</h3>
+<p>SELinuxでは現在reference policyへの移行が進行中ですが，これまではログインセッションを含めてすべてのプロセスに対して強制アクセス制御を適用するstrictポリシーと，攻撃を受けやすいサービスに対してだけ強制アクセス制御を適用するtargetedポリシーの2種類がデフォルトポリシーとして提供されていました． 「セキュリティの強化」という観点からは，文字通り厳格なstrictポリシーのほうが効果が高いわけですが，制限の内容を間違えるとログインすらできなくなるなどの問題もあり，SELinuxを有効にしているユーザの多くはtargetedポリシーをベースにカスタマイズしているケースが多いのではないかと思われます． Russell Coker氏やLKMLでのSELinux関係者の発言によると，SELinux陣営には， 「SELinuxのポリシーの内容を理解できないシステム管理者はポリシーを修正すべきではない．我々プロが作成したポリシーをそのまま使いなさい」という考え方があります．これに対して， 「システム管理者自身がポリシーを作成する」TOMOYO Linuxは，まっこうから考え方が異なっています．これに関連した議論の一部は，<a href="http://slashdot.jp/linux/article.pl?sid=07/06/07/1211201">http://slashdot.jp/linux/article.pl?sid=07/06/07/1211201</a>から辿ることができます．読者のみなさんはどのように考えられますでしょうか．</p>
 
-<p>CentOS 5.5にMovableTypeをインストールするところから始めます．TOMOYO Linuxの設定は含まれませんので，すでにMovableTypeを導入済みの方は次の項目へ飛んでください．なお，MovableTypeのインストールについて，本稿では最低限の内容しか触れません．詳細については，<a href="http://www.sixapart.jp/movabletype/manual/3.3/">オンラインドキュメントの「システム管理者ガイド」</a>などを参照してください．</p>
+<p>さて，この連載はTOMOYO Linuxの連載なので，ポリシーを自分で作ることができるTOMOYO Linuxを使って，ログインして行う操作の制限を行ってみることにしましょう．</p>
 
-<h3>Apache のインストール</h3>
+<h2>ログインセッションを制御してみよう</h2>
 
-<p>まず，Apacheをインストールします．rootユーザとしてログインし，図1のコマンドを実行してください．</p>
+<h3>ログインセッションを制御する理由</h3>
 
-<table border="1" summary="fig">
-<tr><td>
-■図1 Apacheのインストール
-<pre>
-# yum install httpd
-</pre>
-</td></tr>
-</table>
+<p>Linuxをサーバとして利用する場合，ユーザがシステムにログインしてからの操作を制限したいと思う場合があるでしょう．たとえば， 「システム管理者が顧客情報の格納されたデータベースファイルを持ち出すのを禁止したい」とか「システムにログインしたユーザに対してパスワードの変更だけを許可したい」とか「Webサーバの再起動とWebコンテンツの更新だけを社外に委託したい（それ以外の操作は行えないようにしたい） 」などなど．他にも， 「システムにログインしたユーザが他人のパスワードを盗聴するためのバックドアを仕掛けるのを阻止したい」とか「インターネットから社内ネットワークにアクセスするためのゲートウェイサーバとして使いたい」という要求もあるかもしれません．プロセスの起動履歴ごとにドメインを管理するTOMOYO Linuxを使えば，このような要求に対応するのは簡単です．</p>
 
-<p>iptablesを有効にしている場合，設定が不適切だとApacheに接続できなくなります．図2のコマンドを実行して， ［Firewall Configuration］→［Customize］から［WWW (HTTP)］にチェックがされていることを確認してください．</p>
+<h3>基本手順</h3>
 
-<table border="1" summary="fig">
-<tr><td>
-■図2 firstbootコマンドの実行
-<pre>
-# /usr/sbin/firstboot --reconfig
-</pre>
-</td></tr>
-</table>
+<p>ログインセッションを保護するための手順は大きく分けて4つあります．</p>
 
-<h3>MovableType のインストール</h3>
+<ol>
+<li>まず，ログインセッションで実行を許可するコマンドを決定します（たとえば，ファイルの内容を閲覧するために/bin/catの実行を許可したり，パスワードの変更を行うために/usr/bin/passwdの実行を許可したりするなど） ．</li>
+<li>次に，ログインセッションでアクセスを許可したいファイルを決定します（たとえば，原則としてホームディレクトリ以下のファイルのみ読み書きを許可するなど） ．</li>
+<li>次に，ログインセッションで通信を許可したいネットワークを決定します（たとえば，DNSサーバ，HTTPサーバ，FTPサーバ，SSHサーバとだけ通信を許可するなど） ．</li>
+<li>以上の作業で決定したアクセス許可をあらかじめ与えたうえで，実際に学習モードを用いて不足しているアクセス許可を追加していきます．</li>
+</ol>
 
-<p>本稿では図3のディレクトリ構成で使用します．データベースにはBERKELEYDBを使用します．</p>
+<p>以上の手順で登場するキーワードを図1に示します．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図3 本稿で使用するディレクトリ構成<br>
+■図1 使用するキーワード<br>
 <table border="1" summary="fig">
-<tr><td>用途</td><td>ディレクトリ</td></tr>
-<tr><td>アプリケーションディレクトリ</td><td>/var/www/cgi-bin/mt/</td></tr>
-<tr><td>スタティックディレクトリ</td><td>/var/www/html/mt-static/</td></tr>
-<tr><td>blogディレクトリ</td><td>/var/www/html/blog/</td></tr>
-<tr><td>データベースディレクトリ</td><td>/var/www/mt-db/</td></tr>
-<tr><td>テンポラリディレクトリ</td><td>/var/www/mt-tmp/</td></tr>
+<tr><td>キーワード</td><td>意味</td></tr>
+<tr><td>path_group</td><td>プログラムファイルやホームディレクトリ以下のファイルをグループ化する</td></tr>
+<tr><td>keep_domain</td><td>ドメイン遷移を抑制する</td></tr>
+<tr><td>no_keep_domain</td><td>ドメイン遷移を再開する</td></tr>
+<tr><td>exec.argv[0]</td><td>シンボリックリンク経由の不正アクセスを防ぐ</td></tr>
+<tr><td>address_group</td><td>ネットワークアドレスをグループ化する</td></tr>
+<tr><td>if</td><td>自分が所有しているファイルへのアクセスのみを認める</td></tr>
 </table>
 </td></tr>
 </table>
 
-<p>MovableType 3.3をダウンロードしてインストールします．本稿ではMT-3_36-ja.zipを使用します．図4の内容を実行します．</p>
+<h2>ステップ1：実行可能なコマンドの決定</h2>
 
-<table border="1" summary="fig">
-<tr><td>
-■図4 MovableType 3.3のインストール
-<pre>
-# cd /var/www/cgi-bin/
-# unzip MT-3_36-ja.zip
-# mv MT-3.36-ja mt
-# cd mt/
-# mv mt-static /var/www/html/
-# mkdir /var/www/html/blog /var/www/mt-db /var/www/mt-tmp
-# chown apache:apache /var/www/html/blog/ /var/www/mt-db/ /var/www/mt-tmp/
-# cp -p mt-config.cgi-original mt-config.cgi
-</pre>
-</td></tr>
-</table>
+<h3>実行を許可するプログラムの決定</h3>
 
-<p>次に，mt-config.cgiを編集します．/var/www/cgi-bin/mt/mt-config.cgiをエディタで開き，www.example.comとなっている箇所（2ヵ所）を実際のサーバ名（本稿ではyourserverと表記します）に置き換えてください（図5） ．</p>
+<p>システムにログインしたユーザが悪意あるプログラムを実行できないようにするには，あらかじめシステムにインストールされているプログラム以外の実行を禁止するのが効果的です．この連載では，システムにすでにインストールされているプログラムの内，ログインセッションにおいて図2のコマンドの実行だけを許可するものとします．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図5 /var/www/cgi-bin/mt/mt-config.cgiの変更箇所
-<pre>
-[修正前]
-CGIPath http://www.example.com/cgi-bin/mt/
-StaticWebPath http://www.example.com/mt-static
-[修正後]
-CGIPath http://yourserver/cgi-bin/mt/
-StaticWebPath http://yourserver/mt-static
-</pre>
+■図2 実行を許可するコマンド<br>
+<table border="1" summary="fig">
+<tr><td>/bin/basename /bin/bash /bin/cat /bin/egrep /bin/grep /bin/hostname /bin/ln /bin/ls /bin/mkdir /bin/mv /bin/rm /bin/rmdir /bin/sed /bin/touch /sbin/consoletype /usr/bin/clear /usr/bin/dircolors /usr/bin/emacs /usr/bin/id /usr/bin/passwd /usr/bin/perl /usr/bin/ssh /usr/bin/ssh-keygen /usr/bin/wget /usr/bin/which</td></tr>
+</table>
 </td></tr>
 </table>
 
-<p>「##### MYSQL #####」 「##### POSTGRESQL#####」 「##### SQLITE #####」のセクションは不要なので削除します． 「##### BERKELEYDB #####」セクションではDataSourceという箇所を実際のパス名（/var/www/mt-db）に置き換えてください（図6） ．</p>
+<p>これらのコマンドをpath_groupとして例外ポリシーに登録しておきましょう（図3） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図6 DataSourceを変更（/var/www/cgi-bin/mt/mt-config.cgi）
+■図3 実行を許可するコマンドをグループ化
 <pre>
-[修正前]
-DataSource /path/to/database/directory
-[修正後]
-DataSource /var/www/mt-db
+path_group COMMANDS_FOR_LOGIN_SESSION /bin/basename
+path_group COMMANDS_FOR_LOGIN_SESSION /bin/bash
+（中略）
+path_group COMMANDS_FOR_LOGIN_SESSION /usr/bin/wget
+path_group COMMANDS_FOR_LOGIN_SESSION /usr/bin/which
 </pre>
 </td></tr>
 </table>
 
-<p>また，図7の内容を追加します．</p>
+<p>コマンドの所在（パス）を確認するにはwhichやtypeなどのコマンドを使います（図4） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図7 /var/www/cgi-bin/mt/mt-config.cgiに追加する内容
+■図4 コマンドの所在を確認する
 <pre>
-DBUmask 0077
-HTMLUmask 0077
-UploadUmask 0077
-DirUmask 0077
-TempDir /var/www/mt-tmp
+# which perl sed grep
+/usr/bin/perl
+/bin/sed
+/bin/grep
 </pre>
 </td></tr>
 </table>
 
-<p>apacheユーザの権限で実行するのでファイル作成時には所有者のみがアクセスできるようにしておくことができます．テンポラリディレクトリは TempDirキーワードを用いて指示します．</p>
+<p>「/sbin/consoletypeや/usr/bin/dircolorsなども許可する必要があるの？」と思われるかも知れませんが，シェルを起動したときに自動実行されるスクリプト（/bin/bashの場合は~/.bashrc）によって利用者が意識していない場所で多くのコマンドが実行されています．それらの内容を知るためには，TOMOYO Linuxカーネルで動作しているシステムで「ログイン」してすぐに「ログアウト」してください．そうすることで，ログインシェルの子ドメインという形でどのようなコマンドが実行されたのかを知ることができます．さらに，CONFIG::file={ mode=learning } （学習モード）が指定されたプロファイルをログインシェルのドメインに割り当てた状態で実行すれば，プログラムの実行だけでなくアクセスされたファイルも知ることができます．</p>
 
-<h3>MovableType の初期化</h3>
+<h3>ドメイン遷移の設計</h3>
 
-<p>Apacheをスタートさせます（図8） ．</p>
+<p>これまでの連載で説明してきたようにTOMOYO Linuxでは，原則としてコマンドを実行するたびにドメイン遷移を行う仕様となっています．そのため，たとえば図5の場合は/bin/catはシェルの子ドメインとして動作しますが，図6の場合は/bin/catは/usr/bin/xargsの子ドメインとして動作します．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図8 Apacheの起動
+■図5 シェルから/bin/catを実行
 <pre>
-# service httpd start
+# /bin/cat /etc/*.conf
 </pre>
+</td><td>
+■図6 xargsから/bin/catを実行
+<pre>
+# echo /etc/*.conf | xargs /bin/cat --
+</pre>
 </td></tr>
 </table>
 
-<p>Webブラウザを使って http://yourserver/cgi-bin/mt/mt-check.cgi を表示し，MovableTypeの実行に必要なプログラムが揃っていることを確認します．</p>
+<p>しかし，この場合はどちらも同じドメインで動作してくれたほうがユーザとしては使い勝手が良く，まとめたとしてもとくにセキュリティ上の問題はなさそうですね．ログインセッションでは，どのようなコマンドをどのような順序で実行するかを予測することが困難であるため，原則としてドメイン遷移は行いません．ログインシェルを/bin/bashと仮定した場合，sshdからログインしたシェルのドメインは&lt;kernel&gt; /usr/sbin/sshd /bin/bashとなるので，例外ポリシーに「keep_domain &lt;kernel&gt; /usr/sbin/sshd /bin/bash」という指定を行うことでドメイン遷移を抑制します．しかし，パスワードを格納している/etc/shadowのように，/bin/catコマンドなどで閲覧されるのは困るが，パスワードを変更する/usr /bin/passwdコマンドがアクセスできないのも困るという場合があります．そのような場合は，例外ポリシーに「no_keep_domain /usr/bin/passwd from &lt;kernel&gt; /usr/sbin/sshd /bin/bash」という指定を行うことで，/usr/bin/passwdコマンドを &lt;kernel&gt; /usr/sbin/sshd /bin/bash /usr/bin/passwdドメインで実行させることができます．同様に，sshの秘密鍵などを格納している~/.ssh/ディレクトリのファイルのように，/bin/catコマンドなどで閲覧されては困るが，ssh接続を行う/usr/bin/sshコマンドがアクセスできないのも困るので，例外ポリシーに「no_keep_domain /usr/bin/ssh from &lt;kernel&gt; /usr/sbin/sshd /bin/bash」という指定を行うことで，sshコマンドを別のドメインで実行させることができます．</p>
 
-<p>「MovableTypeのシステム・チェックは，無事に完了しました． 」という表示を確認したら， http://yourserver/cgi-bin/mt/mt.cgi にアクセスしてmt.cgiを実行します．</p>
+<h3>プログラムの起動方法による振る舞いの変化について</h3>
 
-<p>この画面でMovableTypeのシステム管理者を登録してから，ログインしてください．ログイン後は， ［First Weblog］→［設定］→［サイトＵＲＬ／パス］の順に選択して，サイトURLとサイトパスを図9のように設定してください．</p>
+<p>ちょっと横道に逸れますが，ここでアクセス制御を行う場合に注意すべき点として，プログラムの起動方法による振る舞いの変化について触れておきたいと思います．システム（TOMOYO Linuxカーネルで動作しているシステムである必要はありません）にログインして，図7のプログラムを/tmp/argv0.cという名前で保存してください．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図9 サイトURLとサイトパスの設定<br>
-<table border="1" summary="fig">
-<tr><td>設定項目</td><td>設定内容</td></tr>
-<tr><td>サイトURL</td><td>http://yourserver/blog/</td></tr>
-<tr><td>サイトパス</td><td>/var/www/html/blog</td></tr>
-</table>
-</td></tr>
-</table>
-
-<p>その後， ［変更を保存］を選択し， ［サイトを再構築］→［再構築］の順に選択してください．以上でMovableTypeのインストールは完了です．</p>
-
-<h2>TOMOYO Linuxのインストール</h2>
-
-<p>では，いよいよTOMOYO Linuxをインストールしてみることにしましょう．この連載では，2010年4月1日にリリースされたバージョン1.7.2を用います．</p>
-
-
-<h3>プログラムのインストール</h3>
-
-<p>CentOS 5.5用のコンパイル済みパッケージをダウンロードしインストールします（図10） ．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図10 TOMOYO Linux 1.7.2のインストール
+■図7 起動方法を表示するＣプログラム
 <pre>
-# wget -O /tmp/key 'http://pgp.nic.ad.jp/pks/lookup?op=get&amp;search=0x4B975A98'
-# rpm --import /tmp/key
-# wget -O /etc/yum.repos.d/ccs.repo http://tomoyo.sourceforge.jp/repos-1.7/CentOS5/ccs.repo
-# yum install ccs-kernel
+#include &lt;stdio.h&gt;
+int main(int argc, char *argv[])
+{
+        printf("I am running as %s\n", argv[0]);
+        return 0;
+}
 </pre>
 </td></tr>
 </table>
 
-<p>利用可能な最新のカーネルは<a href="http://tomoyo.sourceforge.jp/1.7/install.html#install_from_repository">バイナリパッケージをインストール</a>を参照ください．</p>
+<p>その後，図8のようにコンパイルしておよびシンボリックリンク（またはハードリンク）を作成してください．</p>
 
-<p>次にツールをインストールします．（図11） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図11 ツールをインストール
+■図8 コンパイルしてシンボリックリンクを作成するする
 <pre>
-# yum install ccs-tools
+# gcc -o /tmp/argv0 /tmp/argv0.c
+# ln -s /tmp/argv0 /tmp/cat
+# ln -s /tmp/argv0 /tmp/passwd
 </pre>
 </td></tr>
 </table>
 
-<p>TOMOYO Linuxのユーティリティを保存してある場所を環境変数PATHに追加しておきます．bashを使っている場合は~/.bashrcに図12の行を追加します．</p>
+<p>そして，そのシンボリックリンク（またはハードリンク）を実行してください．すると，シンボリックリンクの名前が表示されます（図9） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図12 環境変数PATHの設定
+■図9 シンボリックリンク経由で起動する
 <pre>
-export PATH=$PATH:/usr/sbin
+# /tmp/cat
+I am running as /tmp/cat
+# /tmp/passwd
+I am running as /tmp/passwd
 </pre>
 </td></tr>
 </table>
 
-<h3>ポリシーの初期化</h3>
+<p>一部のコマンドは，そのコマンドが起動されたときの「名前（argv[0]と呼ばれているものです） 」によって振る舞いを変えるように作られています．たとえば，CentOS 5.5において，/sbin/pidofは/sbin/killall5へのシンボリックリンクであり，pidofという名前で起動された場合には指定されたプログラムのプロセスIDを表示し，killall5という名前で起動された場合には自分のセッション以外のすべてのプロセスにシグナルを送信します．</p>
 
-<p>init_policyによりポリシーファイルを初期化します（図13） ．</p>
+<p>TOMOYO Linuxでは/tmp/catを実行すれば/tmp/catのドメインで動作し，/tmp/passwdを実行すれば/tmp/passwdのドメインで動作します．では，図10のように/tmp/catという名前で/tmp/passwdを実行した場合には，どのようになるでしょうか？（結果を予想してみてください）</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図13 ポリシーファイルを初期化
+■図10 passwdコマンドをcatという名前で実行する
 <pre>
-# /usr/lib/ccs/init_policy
+# sh -c 'exec -a /tmp/cat /tmp/passwd'
 </pre>
 </td></tr>
 </table>
 
-<p>このプログラムはポリシーファイルが存在する場合は何もしないので，すでに/etc/ccs/ディレクトリが存在する場合には/etc/ccs/ディレクトリをどこかに移動してから実行してください． init_policyの実行により，/etc/ccs/ディレクトリに図14の5つのファイルが作成されます．</p>
+<p>図10の実行結果は図11となります．このことから，図10を認めることは図12を認めることと同じです．ただし，図12は/tmp/catドメインで/tmp/catとして動作するのを認めているのに対して，図10は/tmp/passwdドメインで/tmp/catとして動作することを認めているという点に注意してください．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図14 init_policyによって作成されるファイル<br>
-<table border="1" summary="fig">
-<tr><td>ファイル名</td><td>役割</td></tr>
-<tr><td>exception_policy.conf</td><td>例外ポリシー</td></tr>
-<tr><td>domain_policy.conf</td><td>ドメインポリシー</td></tr>
-<tr><td>manager.conf</td><td>マネージャーポリシー</td></tr>
-<tr><td>profile.conf</td><td>プロファイル</td></tr>
-<tr><td>meminfo.conf</td><td>メモリ使用量制限</td></tr>
-</table>
-</td></tr>
-</table>
-
-<p>exception_policy.confは「例外ポリシー」と呼ばれ，パス名のグループを定義したりドメイン遷移を制御したりするために使われます． domain_policy.confは「ドメインポリシー」と呼ばれ，ドメイン単位でアクセスを制御するために使われます． manager.confは「マネージャーポリシー」と呼ばれ，/proc/ccs/ディレクトリ経由でポリシーの更新を許可するプログラムやドメインを指定するために使われます． profile.confは「プロファイル」と呼ばれ，アクセス制御の方法(どの機能を有効にするか)を指定するために使われます．行頭の数字はプロファイル番号で， 「0-」で始まる行は要求された内容をチェックしないで許可する「無効モード」 ， 「1-」で始まる行は要求された内容を記録に残してから許可する「学習モード」 ， 「2-」で始まる行は要求された内容をチェックするが拒否はしない「確認モード」 ， 「3-」で始まる行は要求された内容をチェックして許可されていない場合には拒否する「強制モード」用として使います．この連載では，すべてのアクセス制御を有効にしたプロファイルを用いますが，難しいと感じたらファイルに関するアクセス制御以外は無効（CONFIG= という部分を CONFIG::file= に書き換える）にしてもかまいません．</p>
-
-<h2>学習の開始</h2>
-
-<h3>システムの再起動</h3>
-
-<p>ここまで準備ができたら，システムをリブートします．GRUBのメニューではTOMOYO Linuxカーネルを選択してください．</p>
-
-<h3>学習モードに切り替える</h3>
-
-<p>Apache をスタートさせます（図15） ．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図15 Apacheの起動
+■図11 catコマンドとして動作する
 <pre>
-# service httpd start
+I am running as /tmp/cat
 </pre>
 </td></tr>
 </table>
 
-<p>ポリシーエディタを起動してください（図16） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図16 ポリシーエディタの起動
+■図12 図10がもたらす結果
 <pre>
-# /usr/sbin/ccs-editpolicy
+# sh -c 'exec /tmp/cat'
 </pre>
 </td></tr>
 </table>
 
-<p>すると「&lt;&lt;&lt; Domain Transition Editor &gt;&gt;&gt;」という画面が表示され，ドメイン遷移の一覧が表示されます．行番号の右には各ドメインのモード（プロファイル番号）が表示されています．「&lt;kernel&gt; /usr/sbin/httpd」というドメインにカーソルを合わせて，「S」を押してから学習モードに対応するプロファイルの番号「1」を入力して「ENTER」を押します（図17） ．</p>
+<p>/usr/bin/passwdコマンドと/bin/catコマンドが/sbin/busyboxのハードリンクまたはシンボリックリンクとして提供されていると仮定します．この場合，TOMOYO Linuxでは/bin/catを実行すれば/bin/catのドメインで動作し，/usr/bin/passwdを実行すれば/usr/bin/passwdのドメインで動作します．パスワードを変更するための/usr/bin/passwdドメインには/etc/shadowへのアクセスを認める必要がありますが，ファイルの内容を表示するための/bin/catドメインには/etc/shadowへのアクセスを認めたくありません．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図17 &lt;kernel&gt; /usr/sbin/httpdドメインを学習モードにする<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig12.png" alt="sd200708-fig12.png">
-</td></tr>
-</table>
+<p>図13のように/bin/catという名前で/usr/bin/passwdを実行した場合には，どのようになるでしょうか？</p>
 
-<p>これにより，&lt;kernel&gt; /usr/sbin/httpdドメインが学習モードになり，今後&lt;kernel&gt; /usr/sbin/httpdによって新規作成されるドメインも学習モードになります．</p>
-
-<h3>アクセス許可を学習させる</h3>
-
-<p>Apacheを再起動させます（図18） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図18 Apacheの再起動
+■図13 passwdコマンドをcatという名前で実行する
 <pre>
-# service httpd restart
+# sh -c 'exec -a /bin/cat /usr/bin/passwd /etc/shadow'
 </pre>
 </td></tr>
 </table>
 
-<p>これにより，Apacheの起動と終了に必要なアクセス許可が学習されます．その後， http://yourserver/cgi-bin/mt/mt.cgi にアクセスしてmt.cgiを実行します．</p>
+<p>図13を実行すると，/usr/bin/passwdは/usr/bin/passwdドメインで動作します．しかし，起動時の名前が/bin/catであったため，その振る舞いは/bin/catとなります．結果として図14のような振る舞いを許可してしまったことになります．</p>
 
-<p>MovableTypeにログインし，エントリを投稿したりページを再構築したりトラックバックを受け付けるなどの操作を行います．TOMOYO Linuxは操作に対する要求に応えながら，それに必要なアクセス許可内容を学習します．ポリシーは後から確認，追加できますが，初期の自動学習で多くの機能を実行させておくと全体の作業がスムーズに進みます．MovableTypeのように複雑なものでは少し難しいですが，あらかじめ試験項目を作成しておくと良いでしょう．</p>
-
-<h3>アクセス許可を確認する </h3>
-
-<p>ひととおり学習したら，ccs-editpolicyで学習結果を確認してみましょう．図19のようなドメインが作成されているはずです（操作内容や設定内容により異なる場合があります．）．ApacheからMovable TypeのCGIが呼ばれ，そこからいくつかの外部プログラムが呼ばれていることがわかります．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図19 ドメインの学習結果<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig14.png" alt="sd200708-fig14.png">
-</td></tr>
-</table>
-
-<h3>パス名のグループ化</h3>
-
-<p>「&lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt.cgi」ドメインにカーソルを合わせて「ENTER」を押すと，&lt;&lt;&lt; Domain Policy Editor &gt;&gt;&gt;という画面に移動します．その画面をスクロールしてみると，図20のようなエントリが見つかるはずです．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図20 作成されたポリシーの内容（一部）
+■図14 パスワードファイルを閲覧できる
 <pre>
-allow_read /var/www/cgi-bin/mt/extlib/CGI.pm
-allow_read /var/www/cgi-bin/mt/extlib/CGI/Cookie.pm
-allow_read /var/www/cgi-bin/mt/extlib/CGI/Util.pm
-（中略）
-allow_read /var/www/cgi-bin/mt/lib/MT/Trackback.pm
-allow_read /var/www/cgi-bin/mt/lib/MT/Util.pm
-allow_read /var/www/cgi-bin/mt/lib/MT/WeblogPublisher.pm
+# sh -c 'exec /bin/cat /etc/shadow'
 </pre>
 </td></tr>
 </table>
 
-<p>もちろん，ここまでの内容で作成したポリシーでも運用は可能ですが，実際のシステム運用ではポリシーを整理してから行います．今度はその手順を紹介します．さきほど確認したmt.cgiドメインの学習結果を見ると，多数のPerlモジュールにアクセスしていることがわかります．そこでまず，これらの Perlモジュールへのパス名を“MT-LIB”という名前でグループ化することにします．グループ化をすると，対象となるパス名をまとめて扱えるのでポリシーがコンパクトで見通しやすくなります．</p>
+<p>このような脅威を防ぐために，TOMOYO Linuxではプログラムのパス名とargv[0]の組み合わせをチェックする機能を備えています．図13のような脅威も/usr/bin/passwdコマンドを/bin/catという名前で起動することを禁止することで防ぐことができるようになります．実は，前回示したMovable Typeのポリシーの中にもallow_execute /usr/sbin/sendmail.sendmail if exec.argv[0]="sendmail"というアクセス許可がありました．これは，/usr/sbin/sendmail.sendmailコマンドをsendmailという名前で起動することを許可するという意味です．図2で指定しているプログラムの中に図13のような指定をされると困るプログラムが含まれている場合には，そのプログラムはpath_groupから除外し，allow_execute /usr/bin/passwd if exec.argv[0]="passwd"のように個別に指定するようにしてください．</p>
 
-<p>ccs-editpolicyで，「TAB」を押して&lt;&lt;&lt; ExceptionPolicy Editor &gt;&gt;&gt;という画面に移動してから図21の内容の指定を追加してください．</p>
+<h2>ステップ2：読み書きを許可するファイルの決定</h2>
 
+<h3>ハードリンクの脅威と対策</h3>
+
+<p>TOMOYO Linuxではハードリンクの作成時には「リンク元のパス名／リンク先のパス名」をペアにして，名前の変更時には「変更前のパス名／変更後のパス名」をペアにしてアクセス許可のチェックを行っています．その理由について触れておきます．システム（TOMOYO Linuxカーネルで動作しているシステムである必要はありません）にログインして，図15の操作を試してみてください（/etc/ディレクトリと /tmp/ディレクトリが別のパーティションになっているシステムでは失敗します．その場合，/etc/ディレクトリと同じパーティションにある /root/ディレクトリなどに読み替えてください） ．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図21 パス名をグループ化するための設定内容
+■図15 ハードリンク経由でパスワードファイルにアクセスする
 <pre>
-path_group MT-LIB /var/www/cgi-bin/mt/\{\*\}/\@.pm
+# ln /etc/shadow /tmp/shadow
+# cat /tmp/shadow
 </pre>
 </td></tr>
 </table>
 
-<p>その後，「TAB」を押すと&lt;&lt;&lt; Domain Transition Editor &gt;&gt;&gt;という画面に戻り，さらに「ENTER」を押すと&lt;&lt;&lt; Domain Policy Editor &gt;&gt;&gt;という画面に移動することができます．登録したばかりのMT-LIBを使ってグループ化してみましょう．まずccs-editpolicyで，mt.cgiのドメインを選択し，図22の行を追加します．図22の行を追加後に，図22の行にカーソルを合わせてから「O」キーを押すと，カーソル行のアクセス許可に包含されているアクセス許可に対して&amp;マークが付与されるので，「D」キーを押すことで学習結果から図22の行のアクセス許可に包含されているエントリを削除できます．</p>
+<p>これは，ログインパスワードを格納している/etc/shadowというファイルを/tmp/ディレクトリの下にハードリンクすることで，/tmp /shadowというパス名を用いてログインパスワードを格納しているファイルにアクセスできることを示しています．「/etc/shadowを/tmp/shadowにハードリンクしてしまうシステム管理者なんていないよ」と思われるかもしれませんが，実は，/etc /shadowのハードリンクの作成はrootユーザでなくても可能です．一般ユーザが/etc/shadowのハードリンクを一般ユーザが書き込めるディレクトリである/tmp/ディレクトリに作成し，実行を許可されているコマンド（たとえば/usr/bin/sudo）を利用してroot権限を手に入れてから，/tmp/ディレクトリにハードリンクされたパスワードファイルにアクセスできてしまう危険性があるのです．だからTOMOYO Linuxでは，ハードリンクを作成する際に，リンク元とリンク先の両方をチェックすることでその危険性を最小限に抑えられるようにしているわけです． （実際に/tmp/shadowを作成した方は，この先を読み続ける前に，忘れないうちに/tmp/shadowを削除しておくように！）/etc /shadowのリンク数が2以上であれば，どこかにハードリンクが残っています（図16） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図22 図21でグループ化したパス名を指定
+■図16 /etc/shadowのハードリンクを削除する
 <pre>
-allow_read @MT-LIB
+# ls -l /etc/shadow
+-r-------- 2 root root 946 May 29 18:14 /etc/shadow
+# unlink /tmp/shadow
+# ls -l /etc/shadow
+-r-------- 1 root root 946 May 29 18:14 /etc/shadow
 </pre>
 </td></tr>
 </table>
 
-<p>これは， 「グループ名がMT-LIBであるpath_groupに割り当てられているパス名」に対して読み込みを許可するという意味です．</p>
+<p>名前の変更についても同様です．/etc/shadowの読み書きは厳しく制限できますが，/tmp/ディレクトリ内のファイルの読み書きを厳しく制限することは困難です．しかし，図17のような操作ができてしまうようでは困ります（/etc/ディレクトリと/tmp/ディレクトリが別のパーティションになっているシステムでは，パーティションを跨ぐ名前の変更はできないので，/etc/shadowの読み書きを禁止することで/tmp/ディレクトリに移動されることを防止できます） ．</p>
 
-<p>mt.cgiドメインにはMT-LIBで定義した以外にもグループ化するほうが良さそうなエントリがありそうです（図23） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図23 グループ化できそうなパス名のエントリ
+■図17 名前を変更してからパスワードファイルにアクセスする
 <pre>
-allow_read/write /var/www/mt-db/__db.notification.blog_id.idx
-allow_read/write /var/www/mt-db/__db.notification.db
-（中略）
-allow_read/write /var/www/mt-db/trackback.entry_id.idx
-allow_read/write /var/www/mt-db/trackback.entry_id.idx.lock
-allow_create /var/www/mt-db/__db.notification.blog_id.idx
-allow_create /var/www/mt-db/__db.notification.db
-（中略）
-allow_create /var/www/mt-db/objecttag.db.lock
-allow_create /var/www/mt-db/plugindata.blog_id.idx.lock
-allow_rename /var/www/mt-db/__db.notification.blog_id.idx /var/www/mt-db/notification.blog_id.idx
-allow_rename /var/www/mt-db/__db.notification.db /var/www/mt-db/notification.db
-（略）
+# mv /etc/shadow /tmp/shadow
+# cat /tmp/shadow
+# mv /tmp/shadow /etc/shadow
 </pre>
 </td></tr>
 </table>
 
-<p>データベースディレクトリ内のファイルは読み書き／新規作成／名称変更が行われることがわかります．これらのパス名もグループ化することにします．ここでは，/var/www/mt-db/\*をMT-DBという名前で登録することにします．</p>
+<p>そのため，TOMOYO Linuxではファイル名を変更する際に，変更前のパス名と変更後のパス名の両方をチェックすることで，その危険性を最小限に抑えられるようにしています．パス名でアクセスを制限する方式では，ちょっとした油断で想定外のアクセスを認めてしまうことになります． TOMOYO Linuxを用いてハードリンクや名前の変更の許可を与える際には，必要以上の範囲にアクセスさせないように注意してください．</p>
 
-<p>&lt;&lt;&lt; Exception Policy Editor &gt;&gt;&gt;という画面において図24の指定を登録し，&lt;&lt;&lt; Domain Policy Editor &gt;&gt;&gt;という画面に戻ってから，さきほどと同様に登録済みエントリの削除を行い，新たに図25の3行を追加します．</p>
+<h3>アクセスをホームディレクトリ以下に限定する</h3>
 
-<table border="1" summary="fig">
-<tr><td>
-■図24 /var/www/mt-db/\*をグループ化
-<pre>
-path_group MT-DB /var/www/mt-db/\*
-</pre>
-</td></tr>
-</table>
+<p>ドメインを遷移させるのは，アクセス権限を切り替えるためです．ログインセッションでは原則としてドメイン遷移を行わないということは，ログインセッションで読み書きを許可するファイルを区別しないことを意味します．基本的に，ログインセッションでは，プログラムファイルを作成したり書き換えたりする必要はありません．そのため，ホームディレクトリ以下のファイルの読み書きを中心に許可すれば良いでしょう．ホームディレクトリ以下のファイルをグループ化するために，例外ポリシーで図18のグループを定義します．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図25 図24でグループ化したパス名を指定
+■図18 ホームディレクトリのファイルをグループ化
 <pre>
-allow_read/write @MT-DB
-allow_create @MT-DB
-allow_rename @MT-DB @MT-DB
+path_group HOME_FILE /home/\{\*\}/\*
+path_group HOME_DIR /home/\{\*\}/\*/
 </pre>
 </td></tr>
 </table>
 
-<p>これは， 「グループ名がMT-DBであるpath_groupに割り当てられているパス名」に対して読み書きと新規作成と名称変更を許可するという意味です． MT-LIB, MT-DBの登録を行った後でmt.cgiを実行すると登録したパターンに一致する個別のファイルは学習結果に現れなくなります．パス名のグループ化はどこまで行わなければならないという決まりはありません．学習結果を見ながら，まとめられそうな部分があれば同様に処理を行います．ここで示した以外には，Perlのライブラリ（/usr/lib/perl5/5.8.8/ディレクトリ以下のファイル）やblogディレクトリのファイル（/var/www/html/blog/ディレクトリ以下のファイル）などが対象になるでしょう．mt.cgi以外のCGIについても同様にグループ化を行ってください．</p>
+<p>このように定義すると，ホームディレクトリ以下のファイルを区別しないで扱うことになります．</p>
 
-<h3>ポリシーを保存する</h3>
+<h3>特定のパス名を除外する</h3>
 
-<p>ポリシーエディタで表示されるポリシーはカーネル内にのみ存在しており，再起動すると失われてしまいます．ポリシーをディスク上のファイルに保存するにはccs-savepolicyというコマンドを実行してください（図26） ．</p>
+<p>しかし，ホームディレクトリ以下のファイルでも，~/.ssh/ディレクトリのファイルのように，/bin/catなどでの閲覧を禁止させたいファイルがあるはずです．そこで，\*\-.sshという指定を行うことで，.sshディレクトリ内のパス名を除外することができるようになっています．具体的には，図19のように修正します．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図26 ccs-savepolicyコマンドの実行
+■図19 .sshディレクトリをグループから除外する
 <pre>
-# /usr/sbin/ccs-savepolicy
+path_group HOME_FILE /home/\{\*\-.ssh\}/\*
+path_group HOME_DIR /home/\{\*\-.ssh\}/
 </pre>
 </td></tr>
 </table>
 
-<h3>ドメインの集約</h3>
+<p>これで， /bin/cat コマンドなどで/home/\*/.ssh/\*にアクセスしたり，/bin/mvコマンドなどで/home/\*/.ssh/を/home/\*/ssh/にリネームしたりするのを阻止することができます．</p>
 
-<p>パス名のグループ化を行っているときに，個々のCGIに必要なアクセス許可が似ていることに気が付いたと思います．MovableTypeは機能ごとに別々のCGIプログラムに分かれているので，TOMOYO Linuxでは個々のCGIごとにドメインが分かれます．もちろん，個々のCGIごとにアクセス許可を設定するほうが安全ですが，数が多くて手間がかかります．そこで，個々のCGI用のドメインを1個に集約してしまうという選択肢もあります．ここでは例として，MovableTypeのCGIプログラムを，/./MovableTypeCGIという名前で集約してみることにします．ドメインを集約するには，&lt;&lt;&lt; Exception Policy Editor &gt;&gt;&gt;という画面に移動してから図27の指定を追加してください．</p>
+<h3>アクセス許可をあらかじめ与えておく</h3>
 
+<p>ログインセッションである&lt;kernel&gt; /usr/sbin/sshd /bin/bashドメインに対しては，図20のようなアクセスを認めます．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図27 ドメインを集約するための設定
+■図20 あらかじめアクセス許可を与えておく
 <pre>
-aggregator /var/www/cgi-bin/mt/\@.cgi /./MovableTypeCGI
-aggregator /var/www/cgi-bin/mt/extras/examples/plugins/\*/\@.cgi /./MovableTypeCGI
-aggregator /var/www/cgi-bin/mt/plugins/\*/\@.cgi /./MovableTypeCGI
+allow_execute @COMMANDS_FOR_LOGIN
+allow_read/write @HOME_FILE
+allow_create @HOME_FILE
+allow_unlink @HOME_FILE
+allow_symlink @HOME_FILE
+allow_link @HOME_FILE @HOME_FILE
+allow_rename @HOME_FILE @HOME_FILE
+allow_truncate @HOME_FILE
+allow_rewrite @HOME_FILE
+allow_mkdir @HOME_DIR
+allow_rmdir @HOME_DIR
+allow_rename @HOME_DIR @HOME_DIR
 </pre>
 </td></tr>
 </table>
 
-<p>このように指定すると，/var/www/cgi-bin/mt/\@.cgiまたは/var/www/cgi-bin/mt/extras /examples/plugins/\*/\@.cgiまたは/var/www/cgi-bin/mt/plugins/\*/\@.cgiというパターンに一致するプログラムが実行された場合には/./MovableTypeCGIというプログラムが実行されたのかのように振舞うようになり，結果としてドメインが集約されます．その後，「TAB」を押して&lt;&lt;&lt; Domain Transition Editor &gt;&gt;&gt;という画面に戻り，図28のドメインを削除してください．</p>
+<p>上から順番に，</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図28 ドメインを削除する<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig17.png" alt="sd200708-fig17.png">
-</td></tr>
-</table>
+<ul>
+<li>COMMANDS_FOR_LOGIN というグループに指定されているプログラムの実行を許可</li>
+<li>ホームディレクトリ内のファイルを読み書きモードでオープンすることを許可</li>
+<li>ホームディレクトリ内のファイル作成を許可</li>
+<li>ホームディレクトリ内のファイル削除を許可</li>
+<li>ホームディレクトリ内でのシンボリックリンク作成を許可</li>
+<li>ホームディレクトリ内であればハードリンクの作成を許可</li>
+<li>ホームディレクトリ内であればファイルの名前の変更を許可</li>
+<li>ホームディレクトリ内のファイル切り詰めを許可</li>
+<li>ホームディレクトリ内のファイル上書きを許可</li>
+<li>ホームディレクトリ内のディレクトリ作成を許可</li>
+<li>ホームディレクトリ内のディレクトリ削除を許可</li>
+<li>ホームディレクトリであればディレクトリ名変更を許可</li>
+</ul>
 
-<p>また，&lt;kernel&gt; /usr/sbin/httpdドメインのアクセス許可からこれらのCGIの実行許可を削除してください（図29） ．</p>
+<p>という意味です．なお，リスト4の修正により，上記のホームディレクトリには ~/.ssh/および~/.ssh/\*に一致するものは含まれません．上記では，ホームディレクトリ内では自由にシンボリックリンクを作成できるようにしています． TOMOYO Linuxはシンボリックリンクを解決したパス名を用いてファイルの読み書きを制限しているので，どのようにシンボリックリンクを作成しようとも関係ありません．プログラムの実行時にはシンボリックリンクを経由することでargv[0]の内容を自由に指定できてしまいますが，exec.argv[0]のチェックを有効にしているので，busyboxのハードリンクへのシンボリックリンクを作成して任意のコマンドを実行されるという危険性はありません．ホームディレクトリ内でのみハードリンクの作成を認めています．そのため，/etc/shadowのハードリンクをホームディレクトリ内に作成して，ホームディレクトリを経由してパスワードファイルにアクセスされるという危険性はありません．名前の変更についても同様です．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図29 CGIの実行許可を削除する<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig18.png" alt="sd200708-fig18.png">
-</td></tr>
-</table>
+<h3>所有者によるアクセスのみを認める</h3>
 
-<p>この状態で先ほどと同様に操作すると，図30のようなドメインが作成されるはずです．</p>
+<p>他人が自分のホームディレクトリ内にアクセスしてくるのを阻止するには，ホームディレクトリのパーミッションを0700に設定することで実現できます．しかし，たとえば Apache に対して~/public_html/ディレクトリへのアクセスを認めるためにホームディレクトリのパーミッションを緩くしておかざるを得ない場合もあります．そんな場合，個々のアクセス許可に対してif task.uid=path1.uidのように条件を付与することで，ホームディレクトリのパーミッションでは防げないアクセスを防げるようになります．具体的には，図20を図21のように置き換えます．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図30 集約したドメインが作成される<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig19.jpg" alt="sd200708-fig19.jpg">
-</td></tr>
-</table>
-
-<h3>ドメイン遷移を抑制する</h3>
-
-<p>環境や設定によっては，perlのCwdモジュールによりカレントディレクトリを取得するために/bin/pwdコマンドが実行される場合があります．そのような場合には，図31のように/bin/pwdコマンド用のドメインが作成されます．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図31 /bin/pwdコマンド用のドメインが作成される<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig20.jpg" alt="sd200708-fig20.jpg">
-</td></tr>
-</table>
-
-<p>しかし，この/bin/pwdについてはわざわざドメイン遷移させる必要はなさそうです．そこで，/./MovableTypeCGIから/bin /pwdが実行される場合にはドメイン遷移させないようにするという選択肢もあります．ドメイン遷移を抑制するには，&lt;&lt;&lt; Exception Policy Editor &gt;&gt;&gt;という画面に移動してから図32の指定を追加してください．その後，&lt;&lt;&lt; Domain Transition Editor &gt;&gt;&gt;という画面に戻ると，/bin/pwdドメインに対して( keep_domain /bin/pwdfrom /./MovableTypeCGI )という理由と共に「!」という表示により「このドメインには到達不能である」ことを示すようになるので，そのドメインを削除します（図33） ．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図32 ドメインを集約するための設定
+■図21 所有者によるアクセスのみを認める
 <pre>
-keep_domain /bin/pwd from /./MovableTypeCGI
+allow_execute @COMMANDS_FOR_LOGIN
+allow_read/write @HOME_FILE if task.uid=path1.uid
+allow_create @HOME_FILE if task.uid=path1.parent.uid
+allow_unlink @HOME_FILE if task.uid=path1.uid
+allow_symlink @HOME_FILE if task.uid=path1.parent.uid
+allow_link @HOME_FILE @HOME_FILE if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
+allow_rename @HOME_FILE @HOME_FILE if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
+allow_truncate @HOME_FILE if task.uid=path1.uid
+allow_rewrite @HOME_FILE if task.uid=path1.uid
+allow_mkdir @HOME_DIR if task.uid=path1.parent.uid
+allow_rmdir @HOME_DIR if task.uid=path1.uid
+allow_rename @HOME_DIR @HOME_DIR if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
 </pre>
 </td></tr>
 </table>
 
-<table border="1" summary="fig">
-<tr><td>
-■図33 到達不能なドメインを削除する<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-8&amp;src=sd200708-fig21.jpg" alt="sd200708-fig21.jpg">
-</td></tr>
-</table>
+<p>task.uidはアクセスを要求しているプロセスのユーザID（つまり，ログインしているユーザのユーザID） ，path1.uidは1つ目のパス名（たとえば「 allow_read/write /dev/null」であれば/dev/null，allow_link /tmp/source /tmp/destであれば/tmp/source）の所有者IDです．path1.parent.uidはpath1の親ディレクトリ（たとえば「 allow_read/write /dev/null」であれば/dev/）の所有者IDです．path2.uidは2つめのパス名（たとえば「 allow_mount /dev/sda2 /home/ ext3 0」であれば/home/）の所有者IDです．ただし，allow_renameやallow_linkで指定する2つめのパス名は，アクセス許可のチェックの時点ではアクセスできないパス名であるため，path2.uidという指定はできません．path2.parent.uidは2つ目のパス名（たとえば「allow_link /tmp/source /tmp/dest」であれば/tmp/dest）の親ディレクトリの所有者IDです．</p>
 
-<p>なお，ドメイン遷移を抑制しているのは/bin/pwdプログラムだからであって，たとえば/bin/catプログラムの場合にはドメイン遷移を抑制すべきではありません．/bin/catを呼び出し元のドメイン（この例では/./MovableTypeCGI）で実行することは，呼び出し元のドメインで読み込みが許可されているすべての資源（たとえばCGIプログラムやデータベース）の内容をそっくり漏洩させてしまう危険性を高めることにつながります．</p>
-
 <h2>次回予告</h2>
 
-<p>今回は，MovableTypeの導入からポリシーの自動学習までの手順について紹介し，併せて応用的な使い方であるパス名のグループ化，ドメイン遷移の集約と抑制について解説しました．パス名のグループ化やドメイン遷移の調整については，最初のうちは難しいかもしれませんが，本稿を参考に少しずつ挑戦していただければと思います．次回は，確認モードを用いて必要なアクセス許可が与えられているかどうかを確認する方法と，チューニングの続きについて説明します．</p>
+<p>今回は，システムにログインして行う操作を制限する手順のうち，ファイルアクセスに関する部分について解説しました．次回は，残りのステップと実際の操作手順を説明します．</p>
 
-<p><a href="tutorial-7.html.ja">第７回へ戻る</a>　<a href="tutorial-9.html.ja">第９回へ進む</a></p>
+<p><a href="tutorial-7.html.ja">第８回へ戻る</a>　<a href="tutorial-9.html.ja">第９回へ進む</a></p>
 
 <hr>
 
Index: tutorial-9.html.ja
===================================================================
--- tutorial-9.html.ja	(revision 3668)
+++ tutorial-9.html.ja	(working copy)
@@ -3,552 +3,369 @@
 <head>
 <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
 <meta http-equiv="Content-Style-Type" content="text/css">
-<title>TOMOYO Linuxの世界　第９回：「blogのポリシーを作成してみよう（後編）」</title>
+<title>TOMOYO Linuxの世界　第９回：「ログインセッションを制限してみよう（後編）」</title>
 <link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
 </head>
 <body>
 <!--
-<p style="text-align:right;"><a href="tutorial-9.html.en">English Page</a></p>
+<p style="text-align:right;"><a href="tutorial-11.html.en">English Page</a></p>
 <p style="text-align:right;">Last modified: $Date$</p>
 -->
-<h1>TOMOYO Linuxの世界<br>第９回：「blogのポリシーを作成してみよう（後編）」</h1>
 
-<p>今回も引き続き，blogソフトウェアとして広く利用されているMovable Typeを題材に，ポリシー設定方法を解説します．TOMOYO Linux活用のための実践的なノウハウ満載でお届けします．</p>
+<h1>TOMOYO Linuxの世界<br>第９回：「ログインセッションを制限してみよう（後編）」</h1>
 
+<p>今回は前回に引き続き，TOMOYO Linuxを使ってシステムへのログイン後にユーザが行う操作を制限する手順を解説します．</p>
+
 <h2>今回の内容</h2>
 
-<p>前回はCentOS 5.5上でMovable Type 3.3を動作させるためのポリシーを学習させる方法と，パス名をパターン化する方法およびドメイン遷移を調節する方法について紹介しました．今回は前回説明しきれなかった残りの部分について紹介します．</p>
+<p>前回は，システムにログインして行う操作を制限する手順のうち，ドメイン遷移とファイルアクセスに関する制限について解説しました．今回は，ネットワーク（通信）の制限と実際の操作手順を説明します．</p>
 
-<h2>チューニング</h2>
+<h2>ステップ3：通信を許可したいネットワークの決定</h2>
 
-<h3>グループ化の利点</h3>
+<h3>ネットワークのアクセス制限</h3>
 
-<p>前回，path_groupという構文を使ってパス名のグループ化を行いました．以前からTOMOYO Linuxを使われている方の中には， 「file_pattern構文であらかじめパス名のパターンを定義しておけば，path_group構文は不要なのでは？」と思われた方もいらっしゃると思います．実際，path_groupは必須の機能ではなく，file_patternでも代用可能です．しかし，file_patternはすべてのドメインに対して適用されてしまうため， 「あるドメインでは/var/www/html/\*.htmlという単位でグループ化したいが，別のドメインでは/var/www/html /index.htmlのようにグループ化させたくない」といった場合に対応できません．そして，path_groupを使うことで，見通しよくポリシーを記述できるようになります．今回使用しているMovable Typeの例で説明しましょう．Movable TypeはApacheから起動されるCGIとして動作し，動的にWebページを作成します．そして，CGIによって作成されたWebコンテンツを Apacheがクライアントに提供します．そのため，ApacheのドメインとMovable Typeのドメインの間には，同じパス名にアクセスしているという共通点があります．図1の上側はpath_groupを使わない場合のアクセス許可の与え方，下側はpath_groupを使う場合のアクセス許可の与え方です．</p>
+<p>システムにログインしたユーザはファイルへのアクセスだけでなくネットワークにもアクセスすることでしょう．そこで，ログインしたユーザに対してどのサーバへのアクセスを許可するかを設計します．ネットワークに関するアクセス許可の構文は，「allow_network プロトコル IPアドレス ポート番号」となっています．プロトコルはTCPまたはUDPまたはRAWのいずれか，IPアドレスはIPv4またはIPv6アドレスを指定します．IP アドレスの部分は前回の記事で説明したファイルのグループ化と同様にグループ化が可能です．ここではHTTP，DNS，FTPとSSHの設定について説明します．</p>
 
-<table border="1" summary="fig">
-<tr><td>
-■図1 path_groupによるグループ化<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig01.png" alt="sd200709-fig01.png">
-</td></tr>
-</table>
+<h4>●HTTP</h4>
 
-<p>アクセスするパス名が変化した場合，path_groupを使わない場合には個々のドメイン内のアクセス許可を修正してやらなければいけませんが，path_groupを使う場合には1ヵ所を修正するだけで対処できます． Movable Typeを用いてサービスを提供する際には，通常，DNSサーバに対して問い合わせを行うことは欠かせません．そこで今回は，パス名だけでなくIPアドレスもグループ化することにします．図2の上側はaddress_groupを使わない場合のアクセス許可の与え方，下側はaddress_groupを使う場合のアクセス許可の与え方です．DNSサーバのIPアドレスが変化した場合，address_groupを使わない場合には個々のドメイン内のアクセス許可を修正してやらなければいけませんが，address_groupを使う場合には1ヵ所を修正するだけで対処できます．</p>
+<p>最初に，HTTPサーバのIPアドレスをHTTP_SERVERSという名前でグループ化することにします．グループ化することにより，ポリシーファイルを読みやすくすることができ，また，サーバのIPアドレスの変更や追加や削除が発生した場合にも修正個所が1ヵ所で済みます．IPアドレスをグループ化するには，address_groupというキーワードを使います． HTTPサーバのアドレスが192.168.1.100と192.168.1.200の場合，例外ポリシーで図1のように定義してから，ログインシェルのドメイン（&lt;kernel&gt; /usr/sbin/sshd /bin/bash）に対して図2という許可を与えます（以降に登場するDNS_SERVERSやFTP_SERVERSやSSH_SERVERSも，HTTP_SERVERSと同様に定義してください） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図2 address_groupによるグループ化<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig02.png" alt="sd200709-fig02.png">
+■図1 アドレスをグループ化する
+<pre>
+address_group HTTP_SERVERS 192.168.1.100
+address_group HTTP_SERVERS 192.168.1.20
+</pre>
 </td></tr>
 </table>
 
-<h3>プロセスの依存関係について</h3>
-
-<p>図3は，Movable Typeが動作するために関連しているプロセスの一覧とそれぞれの連携を表示したものです．矢印はTCPまたはUDPによる通信を示しています．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図3 Movable Typeと関連するプロセス<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig03.png" alt="sd200709-fig03.png">
+■図2 HTTPサーバと通信するためのアクセス許可
+<pre>
+allow_network TCP connect @HTTP_SERVERS 80
+</pre>
 </td></tr>
 </table>
 
-<p>この連載では，Apacheと書かれている円の内部をTOMOYO Linuxで保護する手順について説明しています．Movable TypeはApacheの上で動作します．そのため，Movable Typeのドメインだけでなくその親ドメインであるApacheのドメインも含めた形でポリシーを作成しています（Movable Typeをいくら保護してもその土台のApacheの脆弱性を突かれては意味がありませんからね） ．</p>
+<h4>●DNS</h4>
 
-<h3>確認モードに切り替える</h3>
+<p>DNSサーバとの通信ではUDPプロトコルのポート53を使うので，ログインシェルのドメインに対して図3という許可を与えます．</p>
 
-<p>ポリシーエディタを実行して「&lt;kernel&gt; /usr/sbin/httpd」ドメイン以下を選択し，「S」を押してから2を入力して「ENTER」を押します（本連載における各プロファイルの定義内容については前回の記事を参照ください） ．これにより，&lt;kernel&gt; /usr/sbin/httpdドメイン以下が確認モードになります（図4） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図4 確認モードに変更する<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig04.jpg" alt="sd200709-fig04.jpg">
+■図3 DNSサーバと通信するためのアクセス許可
+<pre>
+allow_network TCP connect @HTTP_SERVERS 80
+</pre>
 </td></tr>
 </table>
 
-<p>確認モードでは，ポリシー違反が発生しても自動的にアクセス許可が追加されることはありません．また，PREFERENCE::permissive={ verbose=yes }と指定しているので，ポリシー違反が発生した場合にはコンソールに警告メッセージが表示されます（図5） ．</p>
+<h4>●FTP</h4>
 
+<p>FTPサーバとの通信ではTCPプロトコルのポート21を使うので，図4という許可を与えます．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図5 PREFERENCE::permissive={ verbose=yes }による警告メッセージ
+■図4 FTP制御用のアクセス許可
 <pre>
-CentOS release 5.5 (Final)
-Kernel 2.6.18-194.3.1.el5_tomoyo_1.7.2 on an i686
-tomoyo login: WARNING: Access read /var/www/cgi-bin/mt/mt.cgi denied for /var/www/cgi-bin/mt/mt.cgi
-WARNING: Signal 15 to /var/www/cgi-bin/mt/mt.cgi denied for /usr/sbin/httpd
+allow_network TCP connect @HTTP_SERVERS 80
 </pre>
 </td></tr>
 </table>
 
-<p>操作を行って大量に警告メッセージが表示されるようであれば，まだ学習内容が不十分であることを意味します．再度学習モードに戻りポリシーを追加しましょう．学習モードに戻すには，ポリシーエディタを実行して&lt;kernel&gt; /usr/sbin/httpdドメイン以下を選択し，「S」を押してから1を入力して「ENTER」を押します．</p>
+<p>FTPプロトコルではサーバ側からクライアント側へ向けてTCPコネクションを張る場合があるので，図5の許可が必要になる場合があります．</p>
 
-<h3>アクセスログの保存</h3>
-
-<p>確認モードではポリシーにないアクセス要求が発生しても，コンソールに警告メッセージが表示されるだけであり，ポリシーへのアクセス許可の追加は行われません．そのため，そのまま強制モードにしてしまうと，正常に動作できなくなってしまいます．しかし，警告メッセージからはどのようなアクセス許可を追加したら良いのかわからないので，どのように対処すれば良いのか困ってしまうでしょう． TOMOYO Linuxでは，ポリシーに違反したアクセス要求のログ（アクセス拒否ログ）とポリシーに違反しなかったアクセス要求のログ（アクセス許可ログ）を取得することができます．アクセス許可ログとアクセス拒否ログはドメイン用ポリシーと同じ形式で生成されます．アクセス拒否ログを閲覧して，許可すべきアクセス要求と判断したものは手作業で追加することができます．</p>
-
-<p>ここで，アクセスログを保存する方法について紹介します．まず，アクセスログを保存するためのディレクトリを作成します（図6）．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図6 アクセスログを保存するディレクトリを作成する
+■図5 FTPデータ（アクティブモード）用のアクセス許可
 <pre>
-# mkdir /var/log/tomoyo
+allow_network TCP accept @FTP_SERVERS 20
 </pre>
 </td></tr>
 </table>
 
-<p>/etc/rc.d/rc.localの末尾にccs-auditdを起動するための指定を追加します（図7） ．</p>
+<p>ファイアウォールの内側にいる場合など，サーバ側からクライアント側へ向けてTCPコネクションを張ることができない場合にはパッシブモードを使うので，図5の代わりに図6という許可を与えることになるでしょう．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図7 ccs-auditdを自動起動する
+■図6 FTPデータ（パッシブモード）用のアクセス許可
 <pre>
-# echo /usr/sbin/ccs-auditd /dev/null /var/log/tomoyo/reject_log.txt &gt;&gt; /etc/rc.d/rc.local
+allow_network TCP connect @FTP_SERVERS 1024-65535
 </pre>
 </td></tr>
 </table>
 
-<p>この例では，アクセス許可ログを/dev/nullへ保存し（つまり読み捨てる） ，アクセス拒否ログを/var/log/tomoyo/reject_log.txtへ保存するように指定しています． /etc/rc.d/rc.localを実行してccs-auditdを起動します（図8） ．</p>
+<h4>●SSH</h4>
 
+<p>SSHサーバとの通信ではTCPプロトコルでポート22へコネクションを張るので，図7という許可を与えることになります．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図8 ccs-auditdを起動する
+■図7 SSHサーバと通信するためのアクセス許可
 <pre>
-# /etc/rc.d/rc.local
+allow_network TCP connect @FTP_SERVERS 1024-65535
 </pre>
 </td></tr>
 </table>
 
-<p>この状態でポリシー違反が発生すると，コンソールへの警告メッセージだけでなく/var/log/tomoyo/reject_log.txtへの出力も行われます（図9） ．ログは3行で1組です．</p>
+<p>ただし，前回のドメイン遷移の設計では，SSHの秘密鍵へのアクセスを認める必要がある/usr/bin/sshコマンドはログインシェルとは別のドメインで動作させるように指定している（図8）ので，このアクセス許可はログインシェルのドメインにではなく，/usr/bin/sshのドメイン（図9）に対して与えることに注意してください．ポリシーエディタを実行して，「A」を押してからリスト9の内容を入力して「ENTER」を押すことで/usr/bin/sshのドメインを作成できます．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図9 アクセスログの例（/var/log/tomoyo/reject_log.txt）
+■図8 ログインシェルとは別のドメインで実行する
 <pre>
-#2007-07-06 13:16:49# profile=2 mode=permissive (global-pid=4620) task={ pid=4620 ppid=4581 uid=500 gid=500 euid=500 egid=500 suid=500 sgid=500 fsuid=500 fsgid=500 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=501 gid=501 ino=393251 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
-&lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/mt.cgi
-allow_read /var/www/cgi-bin/mt/mt.cgi
+no_keep_domain /usr/bin/ssh from &lt;kernel&gt; /usr/bin/sshd /bin/bash
 </pre>
 </td></tr>
 </table>
 
-<p>1行目は発生時刻とプロセスのIDなどの情報，2行目はドメイン，3行目がアクセス要求の内容です．アクセス要求の内容を判断し，許可すべきであると判断した場合は，ポリシーエディタを起動して2行目のドメイン名が示すドメインを選択し，「A」を押してから3行目の内容を入力して「ENTER」を押します．必要であれば3行目の内容をワイルドカードでパターン化してから入力してもかまいません．また，対象が個々のドメインに閉じたものではなく複数のドメインにまたがるような場合にはpath_groupの定義を検討すると良いでしょう． /var/log/tomoyo/reject_log.txtを監視し，ログが発生したら，内容を確認したうえでポリシーエディタを使ってアクセス許可を追加してください（図10） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図10 ログの発生を監視する
+■図9 /usr/bin/ssh用のドメイン
 <pre>
-# tail -f /var/log/tomoyo/reject_log.txt
+&lt;kernel&gt; /usr/sbin/sshd /bin/bash /usr/bin/ssh
 </pre>
 </td></tr>
 </table>
 
-<h3>アクセスログのローテーション</h3>
+<h2>ステップ4：学習の開始</h2>
 
-<p>先ほどアクセスログを保存する設定をしましたが，自動的にローテーションさせたい場合もあると思います．そのような場合は，図11の内容を /etc/logrotate.d/tomoyoという名前で作成してください．nocreateオプションを忘れるとローテーション以降のログが保存されなくなりますので注意してください．</p>
+<p>さて，これまでの作業でアクセス許可の基本的な設定が完了しました．しかし，これだけではまだアクセス許可が不足していますから，学習モードを用いて不足しているアクセス許可を追加していくことにします．ポリシーエディタを用いてログインシェルのドメインとその子孫ドメインに対してプロファイル1を割り当てます（ポリシーエディタを使わずに，rootユーザで図10のコマンドラインを実行しても結構です） ．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図11 アクセスログをローテーションの対象にする（/etc/logrotate.d/tomoyo）
+■図10 学習モード用プロファイルを割り当てる
 <pre>
-/var/log/tomoyo/reject_log.txt {
-   weekly
-   rotate 9
-   missingok
-   notifempty
-   nocreate
-}
+# /usr/sbin/ccs-setprofile -r 1 '&lt;kernel&gt; /usr/sbin/sshd /bin/bash'
 </pre>
 </td></tr>
 </table>
 
-<h3>パス名のパターン化</h3>
+<p>そして，許可したい操作（具体的には，前回定義したCOMMANDS_FOR_LOGIN_SESSIONに含まれているコマンドを実行したり，HOME_FILEに該当するファイルを編集したり，ネットワークへアクセスしたりなど）を行ってください．操作例として，図11～図15の内容を参考にしてください．</p>
 
-<p>前回，MT-LIBやMT-DBというグループ名を用いてパス名のパターン化を行ったと思いますが，他にもパターン化が必要な個所があると思います． Movable Typeにより動的に生成されるWebコンテンツは「&lt;kernel&gt; /usr/sbin/httpd」ドメインからアクセスされるので，パターン化が必要です．この時点でパターン化に漏れがないかを確認してください．確認できたらネットワークへと進みます．</p>
-
-<h3>ネットワークアドレスのパターン化</h3>
-
-<p>前回定義したプロファイルではネットワークに関する強制アクセス制御（CONFIG::network）を有効にしています．ファイルに対するアクセス制御だけで十分だとお考えの方もいらっしゃると思いますが，そうではありません．2003年に開催されたJNSA主催のイベント， 「セキュリティ・スタジアム」では，防御側として出展したTOMOYO Linuxサーバについて，Apacheの脆弱性（バッファオーバーフロー）を突いて他のホストへの接続を試みるという攻撃を受けました．接続を許可すべきIPアドレスやポート番号を把握するのは，どんなパス名にアクセスしているかを把握するのに比べればずっと簡単です．ワームなどの拡散を防ぐためにも，ネットワークに対するアクセス制御も有効にしておくことを推奨します．</p>
-
-<p>&lt;kernel&gt; /usr/sbin/httpdドメインに対するアクセス許可を確認してみると，allow_network TCP acceptで始まる行が多数見つかるはずです（図12） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図12 クライアントのIPアドレスとポート番号<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig10.jpg" alt="sd200709-fig10.jpg">
+■図11 SSHの鍵ペアを作成する
+<pre>
+$ ssh-keygen
+Generating public/private rsa key pair.
+Enter file in which to save the key (/home/example/.ssh/id_rsa):
+Created directory '/home/example/.ssh'.
+Enter passphrase (empty for no passphrase):
+Enter same passphrase again:
+Your identification has been saved in /home/example/.ssh/id_rsa.
+Your public key has been saved in /home/example/.ssh/id_rsa.pub.
+The key fingerprint is:
+c7:4f:53:39:6f:7e:17:fb:ec:94:0d:02:09:84:d5:67 example@tomoyo
+</pre>
 </td></tr>
 </table>
 
-<p>これらは，ApacheにアクセスしてきたクライアントのIPアドレスとポート番号を示しています．通常，クライアントがサーバにアクセスする場合には，クライアントは1024以上の未使用のローカルポート番号を選択してアクセスします．そのため，Apacheサーバ側では1024以上の任意のローカルポート番号からのアクセスを許可するようにします（図13） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図13 ポート番号部分をまとめる<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig11.jpg" alt="sd200709-fig11.jpg">
+■図12 SSHで接続する
+<pre>
+$ ssh 192.168.99.138 id
+example@192.168.99.138's password:
+uid=500(example) gid=500(example) groups=500(example)
+</pre>
 </td></tr>
 </table>
 
-<p>1024以上のローカルポート番号を一括して許可したので，個々のローカルポートに対するアクセス許可は不要となりますから削除してください（図14） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図14 不要になったアクセス許可を削除する<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig12.jpg" alt="sd200709-fig12.jpg">
+■図13 パスワードを変更する
+<pre>
+$ passwd
+Changing password for user example.
+Changing password for example
+(current) UNIX password:
+New UNIX password:
+Retype new UNIX password:
+passwd: all authentication tokens updated successfully.
+</pre>
 </td></tr>
 </table>
 
-<p>この例ではアクセス元のIPアドレスは2つ（127.0.0.1と192.168.99.1）だけなのでこのままでもかまいませんが，実際のシステムでは他のアドレスからの接続も受け付けると思います．そこで，接続を受け付けるクライアントのアドレスをグループ化してみましょう．この連載では HTTP_CLIENTSという名前でグループ化することにします．</p>
-
-<p>&lt;&lt;&lt; Exception Policy Editor &gt;&gt;&gt;という画面に移動し，「A」を押してから「address_group HTTP_CLIENTS IPアドレス」または「address_group HTTP_CLIENTS 開始IPアドレス-終了IPアドレス」という形式で入力して「ENTER」を押します（図15） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図15 IPアドレスもまとめる<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig13.jpg" alt="sd200709-fig13.jpg">
+■図14 HTTPサーバにアクセスする 
+<pre>
+$ wget http://192.168.1.100/
+Length: unspecified [text/html]
+Saving to: `index.html'
+[ &lt;=&gt;     ] 2,997       --.-K/s   in 0s
+14:22:14 (286 MB/s) - `index.html' saved [2997]
+</pre>
 </td></tr>
 </table>
 
-<p>HTTP_CLIENTSという名前を用いてアクセス許可を追加後，HTTP_CLIENTSに含まれるアドレスに対するアクセス許可を削除します（図16） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図16 グループ名に置き換える<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig14.jpg" alt="sd200709-fig14.jpg">
+■図15 ホームディレクトリ内のファイルにアクセスする 
+<pre>
+$ ls .bashrc | xargs /bin/cat &gt; /dev/null
+</pre>
 </td></tr>
 </table>
 
-<p>このようにしておくことで，アクセスを許可するクライアントのIPアドレスを変更したくなった場合に，個々のドメインのアクセス許可を編集する代わりにHTTP_CLIENTS の定義を修正するだけで対応できるようになります．これがaddress_groupの利点です．</p>
+<p>ここでは，一般ユーザとしてexampleユーザを使用しています．前回の手順で図16のようにホームディレクトリ以下のファイルの読み書きに関するアクセス許可をあらかじめ与えているため，図16に含まれるアクセス要求は学習されません．</p>
 
-<p>&lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt.cgiドメインに対するアクセス許可を確認してみると，Movable TypeのCGIがトラックバックを送信するために外部のWebサーバにアクセスしていることがわかります（図17） ．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図17 Movable Typeがアクセスしたネットワーク<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig15.jpg" alt="sd200709-fig15.jpg">
+■図16 あらかじめ与えておいたアクセス許可
+<pre>
+allow_execute @COMMANDS_FOR_LOGIN
+allow_read/write @HOME_FILE if task.uid=path1.uid
+allow_create @HOME_FILE if task.uid=path1.parent.uid
+allow_unlink @HOME_FILE if task.uid=path1.uid
+allow_symlink @HOME_FILE if task.uid=path1.parent.uid
+allow_link @HOME_FILE @HOME_FILE if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
+allow_rename @HOME_FILE @HOME_FILE if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
+allow_truncate @HOME_FILE if task.uid=path1.uid
+allow_rewrite @HOME_FILE if task.uid=path1.uid
+allow_mkdir @HOME_DIR if task.uid=path1.parent.uid
+allow_rmdir @HOME_DIR if task.uid=path1.uid
+allow_rename @HOME_DIR @HOME_DIR if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
+</pre>
 </td></tr>
 </table>
 
-<p>TCPのポート80へのアクセスはWebサーバへのアクセスを，UDPのポート53へのアクセスはDNSサーバへのアクセスを，TCPのポート25 へのアクセスはメールサーバへのアクセスを意味します．これらのWebサーバのアドレスもグループ化してみます．この連載ではHTTP_PING_SERVERSという名前でグループ化することにします（図16） ．</p>
+<p>ただし，図17に示したようにSSHの秘密鍵を保存するディレクトリはHOME_FILEから除外してあるので，図11の操作を行うと/home/example/.ssh/id_rsaのように個別に学習されます．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図18 外部のWebサーバをまとめる<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig16.jpg" alt="sd200709-fig16.jpg">
+■図17 ホームディレクトリに含まれる範囲
+<pre>
+path_group HOME_FILE /home/\{\*\-.ssh\}/\*
+path_group HOME_DIR /home/\{\*\-.ssh\}/
+</pre>
 </td></tr>
 </table>
 
-<p>HTTP_PING_SERVERSという名前を用いてアクセス許可を追加後，HTTP_PING_SERVERSに含まれるアクセス許可を削除します（図19） ．</p>
+<h2>ポリシーのチューニング</h2>
 
-<table border="1" summary="fig">
-<tr><td>
-■図19 グループ名で置き換える<br>
-<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-9&amp;src=sd200709-fig17.jpg" alt="sd200709-fig17.jpg">
-</td></tr>
-</table>
+<h3>確認モードに切り替える</h3>
 
-<p>もし，Movable Typeから外部のメールサーバにメールを送るなどネットワークを利用している場合，この時点でチューニングを行います．</p>
+<p>ポリシーエディタを用いてログインシェルのドメインとその子孫ドメインに対してプロファイル2を割り当てます．ここから先は必要に応じて学習モード（プロファイル1）と確認モード（プロファイル2）を切り替えながら使います．ポリシーエディタを起動して，ログインシェルのドメインに対して与えられたアクセス許可の内容を確認してください．実は，前回の連載の手順では解説を行うために意図的にいくつかの設定を不完全なものにしています．この後，順に内容を見ながら修正していきますので，読みながら一緒に考えてみてください．</p>
 
-<h3>パターン化の例</h3>
+<h3>ドメイン遷移の見直し</h3>
 
-<p>参考までに，筆者の環境ではどのようなパターン化を行ったかを載せておきます（図20） ．適切なパターン化の内容は環境により異なりますから，あくまでパターン化の一例とお考えください．</p>
+<p>前回，/usr/bin/sshをログインシェルとは別のドメインで実行するように指定しました．しかし，よくよく考えてみると，SSHの秘密鍵へのアクセスを認めなければいけないのは/usr/bin/ssh-keygenも同じです．せっかく/usr/bin/sshをログインシェルとは別のドメインで動作させることで/bin/catなどでアクセスできないようにしようとしているのに，/usr/bin/ssh-keygenがログインシェルのドメインで動作してしまうと，ログインシェルのドメインからもSSHの秘密鍵へアクセスできるようになってしまいます．そこで，/usr/bin/ssh-keygenも/usr/bin/sshと同様にログインシェルとは別のドメインで実行させるように修正します．単純に図18の指定を追加するだけでも可能ですが， 「SSHの秘密鍵へのアクセスを認めなければいけないプログラム」という意味で，/usr/bin/sshと/usr/bin/ssh-keygenを同じようにまとめて扱えると便利ですね．</p>
 
 <table border="1" summary="fig">
 <tr><td>
-■図20 パターン化の例
+■図18 ログインシェルとは別のドメインで実行する
 <pre>
-path_group MT-LIB /var/www/cgi-bin/mt/\{\*\}/\@.pm
-path_group MT-PLUGIN /var/www/cgi-bin/mt/plugins/\*
-path_group MT-PLUGIN /var/www/cgi-bin/mt/plugins/\{\*\}/\*
-path_group MT-STATIC /var/www/html/mt-static/\*
-path_group MT-STATIC /var/www/html/mt-static/\{\*\}/\*
-path_group MT-TEMPLATE /var/www/cgi-bin/mt/tmpl/\*
-path_group MT-TEMPLATE /var/www/cgi-bin/mt/tmpl/\{\*\}/\*
-path_group PERL-LIB /usr/lib/perl5/5.8.8/\*
-path_group PERL-LIB /usr/lib/perl5/5.8.8/\{\*\}/\*
-path_group MT-DB /var/www/mt-db/\*
-path_group BLOG-FILE /var/www/html/blog/\*
-path_group BLOG-FILE /var/www/html/blog/\{\*\}/\*
-path_group BLOG-DIR /var/www/html/blog/\{\*\}/
-address_group HTTP_CLIENTS 0:0:0:0:0:ffff:7f00:1
-address_group HTTP_CLIENTS 0:0:0:0:0:ffff:c0a8:6301
-address_group HTTP_PING_SERVERS 172.18.1.53
-address_group HTTP_PING_SERVERS 192.168.99.129
-address_group HTTP_PING_SERVERS 204.9.178.67
+no_keep_domain /usr/bin/ssh-keygen from &lt;kernel&gt; /usr/sbin/sshd /bin/bash
 </pre>
 </td></tr>
 </table>
 
-<h3>ポリシーの例（抜粋） </h3>
+<p>そのような目的のためにTOMOYO Linuxでは，aggregatorというキーワードが利用できます．構文は「aggregator 集約前のプログラム名 集約後のプログラム名」で，このように指定すると集約前のプログラムは集約後のプログラム名と同様に扱われます．図19のように指定すると，/usr/bin/ssh-keygenの実行が要求された場合，実行許可のチェックとドメイン遷移処理は/usr/bin/sshの実行が要求されたものとして行われるようになります．</p>
 
-<p>参考までに，筆者の環境ではどのようなポリシーになったかを載せておきます（図21～図27） ．こちらも参考としてご利用ください．</p>
-
 <table border="1" summary="fig">
 <tr><td>
-■図21 &lt;kernel&gt; /usr/sbin/httpdドメインのアクセス許可
+■図19 /usr/bin/ssh-keygenを/usr/bin/sshと同様に扱う
 <pre>
-allow_read/write /dev/null
-allow_read /dev/urandom
-allow_read /etc/group
-allow_read /etc/host.conf
-allow_read /etc/hosts
-allow_read /etc/httpd/conf.d/proxy_ajp.conf
-allow_read /etc/httpd/conf.d/welcome.conf
-allow_read /etc/httpd/conf/httpd.conf
-allow_read /etc/httpd/conf/magic
-allow_read /etc/mime.types
-allow_read /etc/nsswitch.conf
-allow_read /etc/passwd
-allow_read /etc/resolv.conf
-allow_read /etc/selinux/config
-allow_read /proc/filesystems
-allow_read /proc/sys/kernel/ngroups_max
-allow_read /usr/lib/httpd/modules/\*.so
-allow_write /var/log/httpd/access_log
-allow_write /var/log/httpd/error_log
-allow_write /var/run/httpd.pid
-allow_execute /var/www/cgi-bin/mt/mt-comments.cgi
-allow_execute /var/www/cgi-bin/mt/mt-feed.cgi
-allow_execute /var/www/cgi-bin/mt/mt-tb.cgi
-allow_execute /var/www/cgi-bin/mt/mt.cgi
-allow_execute /var/www/cgi-bin/mt/plugins/StyleCatcher/stylecatcher.cgi
-allow_read /var/www/cgi-bin/mt/mt-comments.cgi
-allow_read /var/www/cgi-bin/mt/mt-feed.cgi
-allow_read /var/www/cgi-bin/mt/mt-tb.cgi
-allow_read /var/www/cgi-bin/mt/mt.cgi
-allow_read /var/www/cgi-bin/mt/plugins/StyleCatcher/stylecatcher.cgi
-allow_read @MT-BLOG-FILE
-allow_read @MT-STATIC
-allow_capability SYS_KILL
-allow_capability SYS_UNLINK
-allow_capability inet_tcp_create
-allow_capability inet_tcp_listen
-allow_capability use_inet_udp
-allow_capability use_route
-allow_create /var/run/httpd.pid
-allow_network TCP accept @HTTP_CLIENTS 1024-65535
-allow_network TCP bind 0:0:0:0:0:0:0:0 80
-allow_network TCP listen 0:0:0:0:0:0:0:0 80
-allow_network UDP connect 0.0.0.0 80
-allow_network UDP connect 0:0:0:0:0:0:0:0 80
-allow_truncate /var/run/httpd.pid
-allow_unlink /var/run/httpd.pid
+aggregator /usr/bin/ssh-keygen /usr/bin/ssh
 </pre>
 </td></tr>
 </table>
 
+<p>そのため，時20のようなドメインを作成したり，図18という指定を追加したりする必要がなくなります．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図22 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/ mt-comments.cgiドメインのアクセス許可
+■図20 /usr/bin/ssh-keygen用のドメイン
 <pre>
-allow_read /dev/urandom
-allow_read /etc/host.conf
-allow_read /etc/hosts
-allow_read /etc/nsswitch.conf
-allow_read /etc/resolv.conf
-allow_read /proc/stat
-allow_read /usr/bin/perl
-allow_execute /usr/sbin/sendmail.sendmail
-allow_read/write @MT-DB
-allow_read @MT-LIB
-allow_read @PERL-LIB
-allow_argv0 /usr/sbin/sendmail.sendmail sendmail
-allow_capability SYS_IOCTL
-allow_capability use_inet_udp
-allow_network UDP connect 192.168.99.2 53
-allow_truncate /var/www/mt-db/blog.db
+&lt;kernel&gt; /usr/sbin/sshd /bin/bash /usr/bin/ssh-keygen
 </pre>
 </td></tr>
 </table>
 
+<p>今回はaggregatorを使うことにしますので，図19の内容を例外ポリシーに追加してください．その後，ログインシェルのドメインからSSHの秘密鍵へのアクセス許可（図20）を削除しておいてください．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図23 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/mt-comments.cgi /usr/sbin/sendmail.sendmailドメインのアクセス許可
+■図20 ログインシェルのドメインから削除すべきアクセス許可
 <pre>
-allow_read /etc/host.conf
-allow_read /etc/hosts
-allow_read /etc/mail/submit.cf
-allow_read /etc/mail/trusted-users
-allow_read /etc/nsswitch.conf
-allow_read /etc/passwd
-allow_read /etc/resolv.conf
-allow_read /etc/services
-allow_read /proc/loadavg
-allow_read /proc/stat
-allow_read/write /var/spool/clientmqueue/\*
-allow_capability SYS_IOCTL
-allow_capability SYS_UNLINK
-allow_capability inet_tcp_connect
-allow_capability inet_tcp_create
-allow_capability use_inet_udp
-allow_create /var/spool/clientmqueue/\*
-allow_network TCP connect 0:0:0:0:0:ffff:7f00:1 25
-allow_network UDP connect 192.168.99.2 53
-allow_unlink /var/spool/clientmqueue/\*
+allow_write /home/example/.ssh/id_rsa
+allow_write /home/example/.ssh/id_rsa.pub
+allow_mkdir /home/example/.ssh/
+allow_create /home/example/.ssh/id_rsa
+allow_create /home/example/.ssh/id_rsa.pub
 </pre>
 </td></tr>
 </table>
 
+<h3>path_groupの更新</h3>
+
+<p>ログインシェルのドメインに与えられたプログラムの実行許可を見ると，リスト16の内容も学習されていることがわかります．これは前回，実行を許可するコマンドを定義したときに想定していなかったものです．/usr/bin/xargsは複数のファイルに対して一括操作を行うときに便利なコマンドですので，ログインセッションでの実行を許可することにします．このまま図21の内容を残しておいてもかまいませんが，せっかくなのでCOMMANDS_FOR_LOGIN_SESSIONグループに追加してみましょう．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図24 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/mt-feed.cgiドメインのアクセス許可
+■図21 想定していなかったコマンドの実行許可
 <pre>
-allow_read /dev/urandom
-allow_read /proc/stat
-allow_read /usr/bin/perl
-allow_read/write /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
-allow_read/write @MT-DB
-allow_read @MT-LIB
-allow_read @PERL-LIB
-allow_capability SYS_IOCTL
-allow_capability SYS_UNLINK
-allow_create /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
-allow_unlink /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
+allow_execute /usr/bin/xargs
 </pre>
 </td></tr>
 </table>
 
+<p>例外ポリシーの画面に移動して，リスト17というエントリを追加してから，ログインシェルのドメインに戻って図22の内容を削除します．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図25 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/mt-tb.cgiドメインのアクセス許可
+■図22 想定していなかったコマンドの実行許可
 <pre>
-allow_read /dev/urandom
-allow_read /etc/host.conf
-allow_read /etc/hosts
-allow_read /etc/nsswitch.conf
-allow_read /etc/resolv.conf
-allow_read /proc/stat
-allow_read /usr/bin/perl
-allow_read/write /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
-allow_read/write @MT-DB
-allow_read @MT-LIB
-allow_read @PERL-LIB
-allow_capability SYS_IOCTL
-allow_capability SYS_UNLINK
-allow_capability use_inet_udp
-allow_create /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
-allow_network UDP connect 192.168.99.2 53
-allow_truncate @MT-DB
-allow_unlink /var/www/mt-tmp/mt-tasks-_var_www_cgi_bin_mt.lock
+path_group COMMANDS_FOR_LOGIN_SESSION /usr/bin/xargs
 </pre>
 </td></tr>
 </table>
 
+<h3>ケイパビリティについて</h3>
+
+<p>学習モードで操作を行うと，図23のようにallow_capabilityで始まる行が学習されたと思います．ケイパビリティは許可する操作種別を指定するだけであるため，操作対象を指定する必要はありません．学習モードで必要だったものは運用中にも必要になるのでそのまま残しておきます．</p>
+
 <table border="1" summary="fig">
 <tr><td>
-■図26 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/mt.cgiドメインのアクセス許可
+■図23 学習されたケイパビリティの例
 <pre>
-allow_read /dev/urandom
-allow_read /etc/host.conf
-allow_read /etc/hosts
-allow_read /etc/nsswitch.conf
-allow_read /etc/protocols
-allow_read /etc/resolv.conf
-allow_read /proc/stat
-allow_read /usr/bin/perl
-allow_read/write /var/tmp/CGItemp\$
-allow_read /var/www/cgi-bin/mt/mt-config.cgi
-allow_read/write /var/www/html/mt-static/themes/base-weblog.css
-allow_read/write @MT-BLOG-FILE
-allow_read/write @MT-DB
-allow_read @MT-LIB
-allow_read @MT-PLUGIN
-allow_read @MT-TEMPLATE
-allow_read @PERL-LIB
+allow_capability SYS_CHMOD
 allow_capability SYS_IOCTL
+allow_capability SYS_KILL
+allow_capability SYS_LINK
 allow_capability SYS_RENAME
+allow_capability SYS_SYMLINK
 allow_capability SYS_UNLINK
-allow_capability inet_tcp_connect
-allow_capability inet_tcp_create
-allow_capability use_inet_udp
-allow_create /var/tmp/CGItemp\$
-allow_create /var/www/html/mt-static/themes/base-weblog.css
-allow_create @MT-BLOG-FILE
-allow_create @MT-DB
-allow_mkdir /var/www/html/mt-static/themes/
-allow_mkdir @MT-BLOG-DIR
-allow_network TCP connect @HTTP_PING_SERVERS 80
-allow_network UDP connect 192.168.99.2 53
-allow_rename @MT-BLOG-FILE @MT-BLOG-FILE
-allow_rename @MT-DB @MT-DB
-allow_truncate /var/www/html/mt-static/themes/base-weblog.css
-allow_truncate /var/www/mt-db/blog.db
-allow_truncate @MT-BLOG-FILE
-allow_unlink /var/tmp/CGItemp\$
-allow_unlink @MT-DB
 </pre>
 </td></tr>
 </table>
 
-<table border="1" summary="fig">
-<tr><td>
-■図27 &lt;kernel&gt; /usr/sbin/httpd /var/www/cgi-bin/mt/plugins/StyleCatcher/stylecatcher.cgiドメインのアクセス許可
-<pre>
-allow_read /dev/urandom
-allow_read /etc/host.conf
-allow_read /etc/hosts
-allow_read /etc/nsswitch.conf
-allow_read /etc/protocols
-allow_read /etc/resolv.conf
-allow_read /proc/stat
-allow_read /usr/bin/perl
-allow_read /var/www/cgi-bin/mt/mt-config.cgi
-allow_read/write @MT-DB
-allow_read @MT-LIB
-allow_read @MT-PLUGIN
-allow_read @MT-TEMPLATE
-allow_read @PERL-LIB
-allow_capability SYS_IOCTL
-allow_capability inet_tcp_connect
-allow_capability inet_tcp_create
-allow_capability use_inet_udp
-allow_network TCP connect 204.9.178.25 80
-allow_network UDP connect 192.168.99.2 53
-</pre>
-</td></tr>
-</table>
+<p>なお，TOMOYO Linuxで扱うケイパビリティは，普通のLinuxが扱うPOSIXケイパビリティとは異なり，独自に定義したものですのでご注意ください．</p>
 
-<h3>強制モードに切り替える</h3>
+<h3>シグナルについて</h3>
 
-<p>ポリシーエディタを実行して &lt;kernel&gt; /usr/sbin/httpdドメイン以下を選択し，「S」を押してから3を入力して「ENTER」を押します．つまり，&lt;kernel&gt;  /usr/sbin/httpdドメイン以下が強制モードになります．これによりApacheとApacheから起動されるMovable TypeのCGIが保護されている状態になります．今回作成したポリシーは，パス名をpath_group構文で，IPアドレスをaddress_group構文でグループ化しています．そのため，同様な構成で動作するシステムであれば，ポリシーファイルをコピーしてpath_groupやaddress_groupを修正するだけで再利用できることでしょう．筆者はMovable Typeについては初心者であり，まだ試していない機能がたくさんあります．手順としては本稿で説明したとおりですが，もし他に学習させるべき操作や注意点などコメントがあればご連絡いただければ幸いです．</p>
+<p>学習モードで操作中に，allow_signalで始まる行が学習されたかもしれません．TOMOYO Linuxではシグナルの送信先を制限することもできます．シグナルを送信する場合には/bin/killというコマンドを使用します．しかし，/bin/bashなどのシェルは，内部コマンドとしてkillというコマンドを提供しているため，実際には/bin/bashから/bin/killを実行することなくシグナルを送信することができます．そのため，シグナルの送信を制限しない場合，COMMANDS_FOR_LOGIN_SESSIONに/bin/killが含まれていないにもかかわらず，rootユーザとしてログインして/bin/bashの内部コマンドとしてのkillコマンドを使用することで任意のプロセスを強制終了させてしまうことができてしまいます．シグナルのアクセス制御を行うにはプロファイル中でMAC_FOR_SIGNALを有効にします．今回使用しているプロファイルでは有効になっているので，シグナルの送信要求を制限することができます．シグナルに関するアクセス許可の構文は，「allow_signal シグナル番号 送信先ドメイン名」となっています．シグナルの送信先となるプロセスが属しているドメインのドメイン名が「送信先ドメイン名」で始まる場合に， 「シグナル番号」の種類のシグナルを送信できます（いくつか例外がありますが，通常は気にする必要はありません．詳細についてはプロジェクトのwebページのポリシー仕様書を参照ください） ．</p>
 
-<h3>さらに高度なチューニング</h3>
+<h2>仕上げ</h2>
 
-<p>TOMOYO Linuxでは必要に応じてアクセス許可に条件を付与することができます．</p>
+<h3>学習モードと確認モードを繰り返す</h3>
 
-<h4>①rootにmt.cgiを実行させない</h4>
+<p>再度学習モードで学習を行い，確認モードで許可したい操作を行ってください．警告メッセージが表示されないようになれば学習は完了です．確認モードでポリシーエディタを実行し，ログインシェルのドメインに対して不適切なアクセス許可（たとえば/etc/shadowへのアクセス許可や SSH秘密鍵へのアクセス許可など）がないことを確認してください．</p>
 
-<p>たとえば， &lt;kernel&gt; /usr/sbin/httpd ドメインに与えられた/var/www/cgi-bin/mt/mt.cgiに対する実行許可に対して「if task.uid!=0 task.euid!=0 task.gid!=0 task.egid!=0」という条件を追加することで，rootユーザの権限のまま/var/www/cgi-bin/mt/mt.cgiが実行されないようにすることができます（図28） ．</p>
+<h3>強制モードに切り替える</h3>
 
-<table border="1" summary="fig">
-<tr><td>
-■図28 rootユーザでの実行を禁止
-<pre>
-allow_execute /var/www/cgi-bin/mt/mt.cgi if task.uid!=0 task.euid!=0 task.gid!=0 task.egid!=0
-allow_read /var/www/cgi-bin/mt/mt.cgi if task.uid!=0 task.euid!=0 task.gid!=0 task.egid!=0
-</pre>
-</td></tr>
-</table>
+<p>ポリシーエディタを用いてログインシェルのドメインとその子孫ドメインに対してプロファイル3を割り当てます．ポリシーエディタなどを用いてポリシーを変更できるのはrootユーザだけです．rootユーザの操作を制限するつもりがないのならこのままでもかまいませんが，rootユーザで行う作業の一部を委託する場合，SSHログインしたログインシェルからポリシーエディタを用いてアクセス制御を無効化されてしまっては困ります．そのため，自分以外にrootユーザとしてSSHログインさせる場合には，ログインシェルのドメイン（&lt;kernel&gt; /usr/sbin/sshd /bin/bash）からポリシーエディタ（ccs-editpolicyやccs-setprofileなど）の実行許可と/proc/ccs/\*へのアクセス許可を削除しておくのを忘れないでください．</p>
 
-<h4>②所有者以外にblogデータをアクセスさせない</h4>
+<p>以上でTOMOYO Linuxを用いてログインセッションを制限する方法の説明は終わりです．</p>
 
-<p>Movable Typeがアクセスするファイルに対して「if task.uid=path1.uid」という条件を追加することで，所有者以外の権限で動作しているMovable Typeプロセスからアクセスさせないようにすることができます（図29） ．</p>
-
-<table border="1" summary="fig">
-<tr><td>
-■図29 自分のホームディレクトリ内だけ読み書きを許可
-<pre>
-allow_read/write /home/\*/public_html/blog/\* if task.uid=path1.uid
-</pre>
-</td></tr>
-</table>
-
-<p>これは，/usr/sbin/suexec経由でMovable Typeを実行している場合に，他人からアクセスされないようにする場合に利用できます．</p>
-
 <h2>次回予告</h2>
 
-<p>今回は，Movable Typeのポリシーをチューニングして，実際に保護するまでの手順について解説しました．利用するパッケージの構成などが変わっても行うべき手順としては今回と大きく変わることはありません．ぜひご自分の環境でTOMOYO Linuxによるセキュリティ強化にチャレンジいただきたいと思います．次回からは，TOMOYO Linux 1.7.2の機能をフル活用して，システムにログインして行う操作を制限する方法について解説します．</p>
+<p>次回からは本格的にブログのポリシーを生成します．</p>
 
-<p>本連載では，読者の方々が実際にTOMOYO Linuxを使ううえで参考になるような情報をご紹介したいと思っています．ご利用に際して，不明な点，難しいとお感じになった点，また今後の連載に関するご要望などあれば，お気軽にメーリングリストでご質問ください．</p>
-
 <p><a href="tutorial-8.html.ja">第８回へ戻る</a>　<a href="tutorial-10.html.ja">第１０回へ進む</a></p>
 
 <hr>
Index: tutorial/fig-1-18.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
