<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linuxの世界　第１１回：「ログインセッションを制限してみよう（後編）」</title>
<link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<!--
<p style="text-align:right;"><a href="tutorial-11.html.en">English Page</a></p>
<p style="text-align:right;">Last modified: $Date$</p>
-->

<h1>TOMOYO Linuxの世界<br>第１１回：「ログインセッションを制限してみよう（後編）」</h1>

<p>今回は前回に引き続き，TOMOYO Linuxを使ってシステムへのログイン後にユーザが行う操作を制限する手順を解説します．</p>

<h2>今回の内容</h2>

<p>前回は，システムにログインして行う操作を制限する手順のうち，ドメイン遷移とファイルアクセスに関する制限について解説しました．今回は，ネットワーク（通信）の制限と実際の操作手順を説明します．</p>

<h2>ステップ3：通信を許可したいネットワークの決定</h2>

<h3>ネットワークのアクセス制限</h3>

<p>システムにログインしたユーザはファイルへのアクセスだけでなくネットワークにもアクセスすることでしょう．そこで，ログインしたユーザに対してどのサーバへのアクセスを許可するかを設計します．ネットワークに関するアクセス許可の構文は，「allow_network プロトコル IPアドレス ポート番号」となっています．プロトコルはTCPまたはUDPまたはRAWのいずれか，IPアドレスはIPv4またはIPv6アドレスを指定します．IP アドレスの部分は前回の記事で説明したファイルのグループ化と同様にグループ化が可能です．ここではHTTP，DNS，FTPとSSHの設定について説明します．</p>

<h4>●HTTP</h4>

<p>最初に，HTTPサーバのIPアドレスをHTTP_SERVERSという名前でグループ化することにします．グループ化することにより，ポリシーファイルを読みやすくすることができ，また，サーバのIPアドレスの変更や追加や削除が発生した場合にも修正個所が1ヵ所で済みます．IPアドレスをグループ化するには，address_groupというキーワードを使います． HTTPサーバのアドレスが192.168.1.100と192.168.1.200の場合，例外ポリシーで図1のように定義してから，ログインシェルのドメイン（&lt;kernel&gt; /usr/sbin/sshd /bin/bash）に対して図2という許可を与えます（以降に登場するDNS_SERVERSやFTP_SERVERSやSSH_SERVERSも，HTTP_SERVERSと同様に定義してください） ．</p>

<table border="1" summary="fig">
<tr><td>
■図1 アドレスをグループ化する
<pre>
address_group HTTP_SERVERS 192.168.1.100
address_group HTTP_SERVERS 192.168.1.20
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図2 HTTPサーバと通信するためのアクセス許可
<pre>
allow_network TCP connect @HTTP_SERVERS 80
</pre>
</td></tr>
</table>

<h4>●DNS</h4>

<p>DNSサーバとの通信ではUDPプロトコルのポート53を使うので，ログインシェルのドメインに対して図3という許可を与えます．</p>

<table border="1" summary="fig">
<tr><td>
■図3 DNSサーバと通信するためのアクセス許可
<pre>
allow_network TCP connect @HTTP_SERVERS 80
</pre>
</td></tr>
</table>

<h4>●FTP</h4>

<p>FTPサーバとの通信ではTCPプロトコルのポート21を使うので，図4という許可を与えます．</p>

<table border="1" summary="fig">
<tr><td>
■図4 FTP制御用のアクセス許可
<pre>
allow_network TCP connect @HTTP_SERVERS 80
</pre>
</td></tr>
</table>

<p>FTPプロトコルではサーバ側からクライアント側へ向けてTCPコネクションを張る場合があるので，図5の許可が必要になる場合があります．</p>

<table border="1" summary="fig">
<tr><td>
■図5 FTPデータ（アクティブモード）用のアクセス許可
<pre>
allow_network TCP accept @FTP_SERVERS 20
</pre>
</td></tr>
</table>

<p>ファイアウォールの内側にいる場合など，サーバ側からクライアント側へ向けてTCPコネクションを張ることができない場合にはパッシブモードを使うので，図5の代わりに図6という許可を与えることになるでしょう．</p>

<table border="1" summary="fig">
<tr><td>
■図6 FTPデータ（パッシブモード）用のアクセス許可
<pre>
allow_network TCP connect @FTP_SERVERS 1024-65535
</pre>
</td></tr>
</table>

<h4>●SSH</h4>

<p>SSHサーバとの通信ではTCPプロトコルでポート22へコネクションを張るので，図7という許可を与えることになります．</p>

<table border="1" summary="fig">
<tr><td>
■図7 SSHサーバと通信するためのアクセス許可
<pre>
allow_network TCP connect @FTP_SERVERS 1024-65535
</pre>
</td></tr>
</table>

<p>ただし，前回のドメイン遷移の設計では，SSHの秘密鍵へのアクセスを認める必要がある/usr/bin/sshコマンドはログインシェルとは別のドメインで動作させるように指定している（図8）ので，このアクセス許可はログインシェルのドメインにではなく，/usr/bin/sshのドメイン（図9）に対して与えることに注意してください．ポリシーエディタを実行して，「A」を押してからリスト9の内容を入力して「ENTER」を押すことで/usr/bin/sshのドメインを作成できます．</p>

<table border="1" summary="fig">
<tr><td>
■図8 ログインシェルとは別のドメインで実行する
<pre>
no_keep_domain /usr/bin/ssh from &lt;kernel&gt; /usr/bin/sshd /bin/bash
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図9 /usr/bin/ssh用のドメイン
<pre>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /usr/bin/ssh
</pre>
</td></tr>
</table>

<h2>ステップ4：学習の開始</h2>

<p>さて，これまでの作業でアクセス許可の基本的な設定が完了しました．しかし，これだけではまだアクセス許可が不足していますから，学習モードを用いて不足しているアクセス許可を追加していくことにします．ポリシーエディタを用いてログインシェルのドメインとその子孫ドメインに対してプロファイル1を割り当てます（ポリシーエディタを使わずに，rootユーザで図10のコマンドラインを実行しても結構です） ．</p>

<table border="1" summary="fig">
<tr><td>
■図10 学習モード用プロファイルを割り当てる
<pre>
# /usr/sbin/ccs-setprofile -r 1 '&lt;kernel&gt; /usr/sbin/sshd /bin/bash'
</pre>
</td></tr>
</table>

<p>そして，許可したい操作（具体的には，前回定義したCOMMANDS_FOR_LOGIN_SESSIONに含まれているコマンドを実行したり，HOME_FILEに該当するファイルを編集したり，ネットワークへアクセスしたりなど）を行ってください．操作例として，図11～図15の内容を参考にしてください．</p>

<table border="1" summary="fig">
<tr><td>
■図11 SSHの鍵ペアを作成する
<pre>
$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/example/.ssh/id_rsa):
Created directory '/home/example/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/example/.ssh/id_rsa.
Your public key has been saved in /home/example/.ssh/id_rsa.pub.
The key fingerprint is:
c7:4f:53:39:6f:7e:17:fb:ec:94:0d:02:09:84:d5:67 example@tomoyo
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図12 SSHで接続する
<pre>
$ ssh 192.168.99.138 id
example@192.168.99.138's password:
uid=500(example) gid=500(example) groups=500(example)
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図13 パスワードを変更する
<pre>
$ passwd
Changing password for user example.
Changing password for example
(current) UNIX password:
New UNIX password:
Retype new UNIX password:
passwd: all authentication tokens updated successfully.
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図14 HTTPサーバにアクセスする 
<pre>
$ wget http://192.168.1.100/
Length: unspecified [text/html]
Saving to: `index.html'
[ &lt;=&gt;     ] 2,997       --.-K/s   in 0s
14:22:14 (286 MB/s) - `index.html' saved [2997]
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図15 ホームディレクトリ内のファイルにアクセスする 
<pre>
$ ls .bashrc | xargs /bin/cat &gt; /dev/null
</pre>
</td></tr>
</table>

<p>ここでは，一般ユーザとしてexampleユーザを使用しています．前回の手順で図16のようにホームディレクトリ以下のファイルの読み書きに関するアクセス許可をあらかじめ与えているため，図16に含まれるアクセス要求は学習されません．</p>

<table border="1" summary="fig">
<tr><td>
■図16 あらかじめ与えておいたアクセス許可
<pre>
allow_execute @COMMANDS_FOR_LOGIN
allow_read/write @HOME_FILE if task.uid=path1.uid
allow_create @HOME_FILE if task.uid=path1.parent.uid
allow_unlink @HOME_FILE if task.uid=path1.uid
allow_symlink @HOME_FILE if task.uid=path1.parent.uid
allow_link @HOME_FILE @HOME_FILE if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
allow_rename @HOME_FILE @HOME_FILE if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
allow_truncate @HOME_FILE if task.uid=path1.uid
allow_rewrite @HOME_FILE if task.uid=path1.uid
allow_mkdir @HOME_DIR if task.uid=path1.parent.uid
allow_rmdir @HOME_DIR if task.uid=path1.uid
allow_rename @HOME_DIR @HOME_DIR if task.uid=path1.uid task.uid=path1.parent.uid task.uid=path2.parent.uid
</pre>
</td></tr>
</table>

<p>ただし，図17に示したようにSSHの秘密鍵を保存するディレクトリはHOME_FILEから除外してあるので，図11の操作を行うと/home/example/.ssh/id_rsaのように個別に学習されます．</p>

<table border="1" summary="fig">
<tr><td>
■図17 ホームディレクトリに含まれる範囲
<pre>
path_group HOME_FILE /home/\{\*\-.ssh\}/\*
path_group HOME_DIR /home/\{\*\-.ssh\}/
</pre>
</td></tr>
</table>

<h2>ポリシーのチューニング</h2>

<h3>確認モードに切り替える</h3>

<p>ポリシーエディタを用いてログインシェルのドメインとその子孫ドメインに対してプロファイル2を割り当てます．ここから先は必要に応じて学習モード（プロファイル1）と確認モード（プロファイル2）を切り替えながら使います．ポリシーエディタを起動して，ログインシェルのドメインに対して与えられたアクセス許可の内容を確認してください．実は，前回の連載の手順では解説を行うために意図的にいくつかの設定を不完全なものにしています．この後，順に内容を見ながら修正していきますので，読みながら一緒に考えてみてください．</p>

<h3>ドメイン遷移の見直し</h3>

<p>前回，/usr/bin/sshをログインシェルとは別のドメインで実行するように指定しました．しかし，よくよく考えてみると，SSHの秘密鍵へのアクセスを認めなければいけないのは/usr/bin/ssh-keygenも同じです．せっかく/usr/bin/sshをログインシェルとは別のドメインで動作させることで/bin/catなどでアクセスできないようにしようとしているのに，/usr/bin/ssh-keygenがログインシェルのドメインで動作してしまうと，ログインシェルのドメインからもSSHの秘密鍵へアクセスできるようになってしまいます．そこで，/usr/bin/ssh-keygenも/usr/bin/sshと同様にログインシェルとは別のドメインで実行させるように修正します．単純に図18の指定を追加するだけでも可能ですが， 「SSHの秘密鍵へのアクセスを認めなければいけないプログラム」という意味で，/usr/bin/sshと/usr/bin/ssh-keygenを同じようにまとめて扱えると便利ですね．</p>

<table border="1" summary="fig">
<tr><td>
■図18 ログインシェルとは別のドメインで実行する
<pre>
no_keep_domain /usr/bin/ssh-keygen from &lt;kernel&gt; /usr/sbin/sshd /bin/bash
</pre>
</td></tr>
</table>

<p>そのような目的のためにTOMOYO Linuxでは，aggregatorというキーワードが利用できます．構文は「aggregator 集約前のプログラム名 集約後のプログラム名」で，このように指定すると集約前のプログラムは集約後のプログラム名と同様に扱われます．図19のように指定すると，/usr/bin/ssh-keygenの実行が要求された場合，実行許可のチェックとドメイン遷移処理は/usr/bin/sshの実行が要求されたものとして行われるようになります．</p>

<table border="1" summary="fig">
<tr><td>
■図19 /usr/bin/ssh-keygenを/usr/bin/sshと同様に扱う
<pre>
aggregator /usr/bin/ssh-keygen /usr/bin/ssh
</pre>
</td></tr>
</table>

<p>そのため，時20のようなドメインを作成したり，図18という指定を追加したりする必要がなくなります．</p>

<table border="1" summary="fig">
<tr><td>
■図20 /usr/bin/ssh-keygen用のドメイン
<pre>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /usr/bin/ssh-keygen
</pre>
</td></tr>
</table>

<p>今回はaggregatorを使うことにしますので，図19の内容を例外ポリシーに追加してください．その後，ログインシェルのドメインからSSHの秘密鍵へのアクセス許可（図20）を削除しておいてください．</p>

<table border="1" summary="fig">
<tr><td>
■図20 ログインシェルのドメインから削除すべきアクセス許可
<pre>
allow_write /home/example/.ssh/id_rsa
allow_write /home/example/.ssh/id_rsa.pub
allow_mkdir /home/example/.ssh/
allow_create /home/example/.ssh/id_rsa
allow_create /home/example/.ssh/id_rsa.pub
</pre>
</td></tr>
</table>

<h3>path_groupの更新</h3>

<p>ログインシェルのドメインに与えられたプログラムの実行許可を見ると，リスト16の内容も学習されていることがわかります．これは前回，実行を許可するコマンドを定義したときに想定していなかったものです．/usr/bin/xargsは複数のファイルに対して一括操作を行うときに便利なコマンドですので，ログインセッションでの実行を許可することにします．このまま図21の内容を残しておいてもかまいませんが，せっかくなのでCOMMANDS_FOR_LOGIN_SESSIONグループに追加してみましょう．</p>

<table border="1" summary="fig">
<tr><td>
■図21 想定していなかったコマンドの実行許可
<pre>
allow_execute /usr/bin/xargs
</pre>
</td></tr>
</table>

<p>例外ポリシーの画面に移動して，リスト17というエントリを追加してから，ログインシェルのドメインに戻って図22の内容を削除します．</p>

<table border="1" summary="fig">
<tr><td>
■図22 想定していなかったコマンドの実行許可
<pre>
path_group COMMANDS_FOR_LOGIN_SESSION /usr/bin/xargs
</pre>
</td></tr>
</table>

<h3>ケイパビリティについて</h3>

<p>学習モードで操作を行うと，図23のようにallow_capabilityで始まる行が学習されたと思います．ケイパビリティは許可する操作種別を指定するだけであるため，操作対象を指定する必要はありません．学習モードで必要だったものは運用中にも必要になるのでそのまま残しておきます．</p>

<table border="1" summary="fig">
<tr><td>
■図23 学習されたケイパビリティの例
<pre>
allow_capability SYS_CHMOD
allow_capability SYS_IOCTL
allow_capability SYS_KILL
allow_capability SYS_LINK
allow_capability SYS_RENAME
allow_capability SYS_SYMLINK
allow_capability SYS_UNLINK
</pre>
</td></tr>
</table>

<p>なお，TOMOYO Linuxで扱うケイパビリティは，普通のLinuxが扱うPOSIXケイパビリティとは異なり，独自に定義したものですのでご注意ください．</p>

<h3>シグナルについて</h3>

<p>学習モードで操作中に，allow_signalで始まる行が学習されたかもしれません．TOMOYO Linuxではシグナルの送信先を制限することもできます．シグナルを送信する場合には/bin/killというコマンドを使用します．しかし，/bin/bashなどのシェルは，内部コマンドとしてkillというコマンドを提供しているため，実際には/bin/bashから/bin/killを実行することなくシグナルを送信することができます．そのため，シグナルの送信を制限しない場合，COMMANDS_FOR_LOGIN_SESSIONに/bin/killが含まれていないにもかかわらず，rootユーザとしてログインして/bin/bashの内部コマンドとしてのkillコマンドを使用することで任意のプロセスを強制終了させてしまうことができてしまいます．シグナルのアクセス制御を行うにはプロファイル中でMAC_FOR_SIGNALを有効にします．今回使用しているプロファイルでは有効になっているので，シグナルの送信要求を制限することができます．シグナルに関するアクセス許可の構文は，「allow_signal シグナル番号 送信先ドメイン名」となっています．シグナルの送信先となるプロセスが属しているドメインのドメイン名が「送信先ドメイン名」で始まる場合に， 「シグナル番号」の種類のシグナルを送信できます（いくつか例外がありますが，通常は気にする必要はありません．詳細についてはプロジェクトのwebページのポリシー仕様書を参照ください） ．</p>

<h2>仕上げ</h2>

<h3>学習モードと確認モードを繰り返す</h3>

<p>再度学習モードで学習を行い，確認モードで許可したい操作を行ってください．警告メッセージが表示されないようになれば学習は完了です．確認モードでポリシーエディタを実行し，ログインシェルのドメインに対して不適切なアクセス許可（たとえば/etc/shadowへのアクセス許可や SSH秘密鍵へのアクセス許可など）がないことを確認してください．</p>

<h3>強制モードに切り替える</h3>

<p>ポリシーエディタを用いてログインシェルのドメインとその子孫ドメインに対してプロファイル3を割り当てます．ポリシーエディタなどを用いてポリシーを変更できるのはrootユーザだけです．rootユーザの操作を制限するつもりがないのならこのままでもかまいませんが，rootユーザで行う作業の一部を委託する場合，SSHログインしたログインシェルからポリシーエディタを用いてアクセス制御を無効化されてしまっては困ります．そのため，自分以外にrootユーザとしてSSHログインさせる場合には，ログインシェルのドメイン（&lt;kernel&gt; /usr/sbin/sshd /bin/bash）からポリシーエディタ（ccs-editpolicyやccs-setprofileなど）の実行許可と/proc/ccs/\*へのアクセス許可を削除しておくのを忘れないでください．</p>

<p>以上でTOMOYO Linuxを用いてログインセッションを制限する方法の説明は終わりです．</p>

<h2>次回予告</h2>

<p>2007年1月号から始まった「TOMOYO Linuxの世界」の連載は今回で11回目となりました．基本的な機能およびその使い方について第7回までで紹介し，第8回と9回ではMovable Typeを素材にシステムの構築とポリシーの定義について紹介しました．構築したシステムを安全に運用するためにはログイン後の操作も制限することが大切です．第10回と11回ではログイン後の操作を制限する手法について解説しました．</p>

<p>システムの運用を開始すると必要になる重要な作業の1つにアップデートがあります．セキュリティ強化OSを用いることで，被害を受ける可能性や被害の範囲を軽減できます．しかし，すべてのセキュリティホールに対処できるわけではありませんから，アップデート作業の必要性はなくなりません．</p>

<p>アップデート作業を行うと，プログラムの依存関係やファイルのパス名が変化する場合があるため，ポリシーの見直しが必要になります．しかし，いくら簡単にポリシーを作成できるとしてもアップデートのたびに同じ作業をやり直したくはありませんね．次回は，ソフトウェアのアップデートを支援する TOMOYO Linuxの機能について説明します．</p>

<hr>

<p><a href="index.html.ja">目次へ戻る</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</body>
</html>
