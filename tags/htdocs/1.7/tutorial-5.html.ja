<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linux の世界　第５回：「アクセス許可に条件を付けてみよう」</title>
<link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<!--
<p style="text-align:right;"><a href="tutorial-5.html.en">English Page</a></p>
-->
<p style="text-align:right;">Last modified: $Date$</p>

<h1>TOMOYO Linux の世界<br>第５回：「アクセス許可に条件を付けてみよう」</h1>

<h2>今回の内容</h2>

<p>今回は TOMOYO Linux の強力なパラメータチェック機能を活用するための「条件付きアクセス許可」について紹介します．</p>

<h2>アクセス許可に条件を付ける</h2>

<h3>条件付きアクセス許可について</h3>

<p>TOMOYO Linux には RBAC （ Role Based Access Control ）機能はありませんが，ポリシーの中でユーザＩＤに基づく条件を付けることができます．これにより，システムアカウントのユーザＩＤに基づくアクセス制御が可能です．条件はアクセス許可の後ろに「 if 条件式」という形で指定します．利用できる条件について図１に，使い方の例を図２に示します．</p>

<table border="1" summary="fig">
<tr><td>
■図１　条件指定に使えるパラメータ<br>
<table border="1" summary="fig">
<tr><td>変数</td><td>意味</td></tr>
<tr><td>task.uid</td><td>呼び出したプロセスのユーザＩＤ</td></tr>
<tr><td>task.euid</td><td>呼び出したプロセスの実効ユーザＩＤ</td></tr>
<tr><td>task.suid</td><td>呼び出したプロセスの保存ユーザＩＤ</td></tr>
<tr><td>task.fsuid</td><td>呼び出したプロセスのファイルシステムユーザＩＤ</td></tr>
<tr><td>task.gid</td><td>呼び出したプロセスのグループＩＤ</td></tr>
<tr><td>task.egid</td><td>呼び出したプロセスの実効グループＩＤ</td></tr>
<tr><td>task.sgid</td><td>呼び出したプロセスの保存グループＩＤ</td></tr>
<tr><td>task.fsgid</td><td>呼び出したプロセスのファイルシステムグループＩＤ</td></tr>
<tr><td>task.pid</td><td>呼び出したプロセスのプロセスＩＤ</td></tr>
<tr><td>task.ppid</td><td>呼び出したプロセスの親プロセスのプロセスＩＤ</td></tr>
<tr><td>task.type</td><td>呼び出したプロセスの種類（ execute_handler か否か）</td></tr>
<tr><td>task.state[0]</td><td>呼び出したプロセスの状態変数0</td></tr>
<tr><td>task.state[1]</td><td>呼び出したプロセスの状態変数1</td></tr>
<tr><td>task.state[2]</td><td>呼び出したプロセスの状態変数2</td></tr>
<tr><td>path1.uid</td><td>１つめのパス名の所有者ＩＤ</td></tr>
<tr><td>path1.gid</td><td>１つめのパス名のグループＩＤ</td></tr>
<tr><td>path1.ino</td><td>１つめのパス名のiノード番号</td></tr>
<tr><td>path1.type</td><td>１つめのパス名の種類（ファイル，ディレクトリ，ソケット等）</td></tr>
<tr><td>path1.perm</td><td>１つめのパス名のパーミッション</td></tr>
<tr><td>path1.major</td><td>１つめのパス名の存在しているデバイスファイルのメジャー番号</td></tr>
<tr><td>path1.minor</td><td>１つめのパス名の存在しているデバイスファイルのマイナー番号</td></tr>
<tr><td>path1.dev_major</td><td>１つめのパス名のパス名（デバイスファイル）のメジャー番号</td></tr>
<tr><td>path1.dev_minor</td><td>１つめのパス名のパス名（デバイスファイル）のマイナー番号</td></tr>
<tr><td>path1.parent.uid</td><td>１つめのパス名の親ディレクトリの所有者ＩＤ</td></tr>
<tr><td>path1.parent.gid</td><td>１つめのパス名の親ディレクトリのグループＩＤ</td></tr>
<tr><td>path1.parent.ino</td><td>１つめのパス名の親ディレクトリのiノード番号</td></tr>
<tr><td>path1.parent.perm</td><td>１つめのパス名の親ディレクトリのパーミッション</td></tr>
<tr><td>path2.uid</td><td>２つめのパス名の所有者ＩＤ</td></tr>
<tr><td>path2.gid</td><td>２つめのパス名のグループＩＤ</td></tr>
<tr><td>path2.ino</td><td>２つめのパス名のiノード番号</td></tr>
<tr><td>path2.type</td><td>２つめのパス名の種類（ファイル，ディレクトリ，ソケット等）</td></tr>
<tr><td>path2.perm</td><td>２つめのパス名のパーミッション</td></tr>
<tr><td>path2.major</td><td>２つめのパス名の存在しているデバイスファイルのメジャー番号</td></tr>
<tr><td>path2.minor</td><td>２つめのパス名の存在しているデバイスファイルのマイナー番号</td></tr>
<tr><td>path2.dev_major</td><td>２つめのパス名のパス名（デバイスファイル）のメジャー番号</td></tr>
<tr><td>path2.dev_minor</td><td>２つめのパス名のパス名（デバイスファイル）のマイナー番号</td></tr>
<tr><td>path2.parent.uid</td><td>２つめのパス名の親ディレクトリの所有者ＩＤ</td></tr>
<tr><td>path2.parent.gid</td><td>２つめのパス名の親ディレクトリのグループＩＤ</td></tr>
<tr><td>path2.parent.ino</td><td>２つめのパス名の親ディレクトリのiノード番号</td></tr>
<tr><td>path2.parent.perm</td><td>２つめのパス名の親ディレクトリのパーミッション</td></tr>
<tr><td>exec.argc</td><td>プログラム実行時の引数の数</td></tr>
<tr><td>exec.envc</td><td>プログラム実行時の環境変数の数</td></tr>
<tr><td>exec.argv[index]</td><td>プログラム実行時のindex番目の引数</td></tr>
<tr><td>exec.envp["name"]</td><td>プログラム実行時の環境変数name</td></tr>
<tr><td>exec.realpath</td><td>プログラム実行時のシンボリックリンクを解決したパス</td></tr>
<tr><td>symlink.target</td><td>シンボリックリンク作成時のリンク先</td></tr>
</table>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図２　条件指定の例<br>
<table border="1" summary="fig">
<tr><td>条件</td><td>意味</td></tr>
<tr><td>if task.uid=0</td><td>プロセスのユーザＩＤが 0 （ root ）である場合</td></tr>
<tr><td>if task.uid!=0</td><td>プロセスのユーザＩＤが 0 （ root ）ではない場合</td></tr>
<tr><td>if task.uid=100-500</td><td>プロセスのユーザＩＤが 100 以上 500 以下である場合</td></tr>
<tr><td>if task.uid=0 task.gid=0</td><td>プロセスのユーザＩＤとグループＩＤの両方が 0 （ root ）である場合</td></tr>
<tr><td>if task.uid!=0 task.gid!=0</td><td>プロセスのユーザＩＤとグループＩＤの両方が 0 （ root ）ではない場合</td></tr>
<tr><td>if task.uid=100-500 task.gid!=0</td><td>プロセスのユーザＩＤが 100 以上 500 以下であり，かつ，グループＩＤが 0 ではない場合</td></tr>
<tr><td>if exec.argv[index]="value"</td><td>index （ 0&lt;=index&lt;exec.argc ）番目の引数の値が value である場合</td></tr>
<tr><td>if exec.argv[index]!="value"</td><td>index （ 0&lt;=index&lt;exec.argc ）番目の引数の値が value ではない場合</td></tr>
<tr><td>if exec.envp["name"]="value"</td><td>環境変数 name が定義されており，値が value である場合</td></tr>
<tr><td>if exec.envp["name"]!="value"</td><td>環境変数 name が定義されていないか，あるいは値が value ではない場合</td></tr>
<tr><td>if exec.envp["name"]!=NULL</td><td>環境変数 name が定義されている場合</td></tr>
<tr><td>if exec.envp["name"]=NULL</td><td>環境変数 name が定義されていない場合</td></tr>
</table>
</td></tr>
</table>

<h3>条件を付与してみよう</h3>

<p>例として，コンソールからログインしたユーザが， cat コマンドで自分の所有するファイルのみを閲覧できるようにする手順について説明します．説明用に， user1 と user2 というアカウントを使用します．コンソールからログインして，以降の操作を行ってください．まず，アカウントを２つ作成します（図３）．</p>

<table border="1" summary="fig">
<tr><td>
■図３　アカウントを２つ作成
<pre>
# useradd -s /bin/bash user1
# useradd -s /bin/bash user2
</pre>
</td></tr>
</table>

<p>パスワードを適当に設定してください（図４）．</p>

<table border="1" summary="fig">
<tr><td>
■図４　作成したアカウントのパスワードを設定
<pre>
# passwd user1
# passwd user2
</pre>
</td></tr>
</table>

<p>cat コマンド用のドメインを作成するために， cat コマンドを実行してください．ついでに，このコマンドが動作するドメインも表示してみます（図５）．</p>

<table border="1" summary="fig">
<tr><td>
■図５　cat コマンドが動作するドメインを表示
<pre>
# cat /proc/ccs/self_domain
&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
</pre>
</td></tr>
</table>

<p>このドメインに学習用プロファイルを割り当ててください．この連載では学習用プロファイルの番号は１ですので，図６のようになります．</p>

<table border="1" summary="fig">
<tr><td>
■図６　cat コマンド用ドメインに学習用プロファイルを割り当て
<pre>
# /usr/sbin/ccs-setprofile 1 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat'
</pre>
</td></tr>
</table>

<p>ログアウトして， user1 としてログインし直します．そして，図７の操作を行ってください．</p>

<table border="1" summary="fig">
<tr><td>
■図７　user1 でログインし， /tmp/testfile1 を作成
<pre>
$ echo "This file was created by user1" &gt; /tmp/testfile1
$ cat /tmp/testfile1
This file was created by user1
</pre>
</td></tr>
</table>

<p>ログアウトして， user2 としてログインし直します． user1 と同様に操作を行ってください（図８）．</p>

<table border="1" summary="fig">
<tr><td>
■図８　user2 でログインし， /tmp/testfile2 を作成
<pre>
$ echo "This file was created by user2" &gt; /tmp/testfile2
$ cat /tmp/testfile2
This file was created by user2
</pre>
</td></tr>
</table>

<p>ログアウトして， root としてログインし直します． ccs-editpolicy を起動して，「 &lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat 」ドメインのアクセス許可を確認してください．図９のようなエントリが含まれているはずです．</p>

<table border="1" summary="fig">
<tr><td>
■図９　&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat ドメインのアクセス許可
<pre>
allow_read /tmp/testfile1
allow_read /tmp/testfile2
</pre>
</td></tr>
</table>

<p>このままではどちらのファイルもＤＡＣ（任意アクセス制御）のパーミッションにより許可されれば誰でも読むことができてしまいます．ここで，キーボードの「 A 」を押して，図１０のように入力してください．</p>

<table border="1" summary="fig">
<tr><td>
■図１０　アクセス許可を追加<br>（※これらをまとめて， allow_read /tmp/testfile\+ if task.uid=path1.uid のように入力してもかまいません．）
<pre>
allow_read /tmp/testfile1 if task.uid=path1.uid
allow_read /tmp/testfile2 if task.uid=path1.uid
</pre>
</td></tr>
</table>

<p>それから，図１１の内容をキーボードの「 D 」を押して削除します．</p>

<table border="1" summary="fig">
<tr><td>
■図１１　削除する内容
<pre>
allow_read /tmp/testfile1
allow_read /tmp/testfile2
</pre>
</td></tr>
</table>

<p>キーボードの「 Q 」を押して， ccs-editpolicy を終了します．そして， cat コマンド用のドメインに強制用プロファイルを割り当ててください．この連載では強制用プロファイルの番号は３ですので図１２のようになります．</p>

<table border="1" summary="fig">
<tr><td>
■図１２　cat コマンド用ドメインに強制用プロファイルを割り当て
<pre>
# /usr/sbin/ccs-setprofile 3 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat'
</pre>
</td></tr>
</table>

<p>ログアウトして， user1 としてログインし直します．そして， /tmp/testfile1 と /tmp/testfile2 を cat してみてください． /tmp/testfile2 へのアクセスが禁止されていることを確認できます（図１３）．</p>

<table border="1" summary="fig">
<tr><td>
■図１３ /tmp/testfile2 へのアクセスが禁止されている
<pre>
$ cat /tmp/testfile1
This file was created by user1
$ cat /tmp/testfile2
cat: /tmp/testfile2: Operation not permitted
</pre>
</td></tr>
</table>

<p>ログアウトして， user2 としてログインし直します． user1 と同様に操作を行ってください． /tmp/testfile1 へのアクセスが禁止されていることを確認できます．変数の代わりにユーザＩＤを直接指定することもできます．たとえば，ユーザ認証を行ってログインシェルを起動するための「 &lt;kernel&gt; /sbin/mingetty /bin/login 」ドメインに対して，図１４のように変更してやると， root ユーザのログインを禁止することができます．</p>

<table border="1" summary="fig">
<tr><td>
■図１４　root ユーザのログインを禁止する設定
<pre>
[修正前]
allow_execute /bin/bash
[修正後]
allow_execute /bin/bash if task.uid!=0
</pre>
</td></tr>
</table>

<p>また，図１５のように変更してやると，ユーザＩＤが 500 以上 1000 以下のユーザだけがログインできるようにすることができます． SSH 経由でのログインを制限したい場合に使うことができます．</p>

<table border="1" summary="fig">
<tr><td>
■図１５　ユーザＩＤ 500 以上 1000 以下のユーザのみログインできる設定
<pre>
[修正前]
allow_execute /bin/bash
[修正後]
allow_execute /bin/bash if task.uid=500-1000
</pre>
</td></tr>
</table>

<p>以上で条件付きアクセス許可の説明は終わりです．この説明のために作成したアカウントを削除します（図１６）．</p>

<table border="1" summary="fig">
<tr><td>
■図１６　図３で作成したアカウントを削除
<pre>
# userdel user1
# userdel user2
</pre>
</td></tr>
</table>

<h2>アクセスログからポリシーを生成する（上級者向け）</h2>

<p>学習モードで生成されるポリシーに含まれているアクセス許可には exec.realpath と exec.argv[0] と symlink.target だけしか含まれていませんが，アクセスログには図１で示した全ての変数が含まれています．そのため，アクセスログからポリシーを生成してやれば，最も厳格な条件付きアクセス許可を定義することができます．</p>

<h3>自動的にアクセス許可を追加しないように設定する</h3>

<p>学習モードでは，一度ポリシー違反が発生すると，そのポリシー違反を起こさないようにするために必要なアクセス許可が自動的に追加されてしまいます．しかし，自動的に追加されるアクセス許可には図１で示した全ての情報が含まれているわけではありません．そのため，プロファイルを図１７のように編集して自動的に追加されないようにします．</p>

<table border="1" summary="fig">
<tr><td>
■図１７　/etc/ccs/profile.conf の変更箇所
<pre>
[修正前]
PREFERENCE::learning={ verbose=no }
[修正後]
PREFERENCE::learning={ verbose=no max_entry=0 }
</pre>
</td></tr>
</table>

<p>保存したら，図１８のコマンドを実行して変更を反映してください．</p>

<table border="1" summary="fig">
<tr><td>
■図１８　変更を反映する
<pre>
# /usr/sbin/ccs-loadpolicy p
</pre>
</td></tr>
</table>

<h3>プログラムを動作させる</h3>

<p>この状態でプログラムを動作させます．ポリシー違反は全てアクセスログとして保存されていきます．</p>

<p>図１７で max_entry=0 という指定をしたため，図１９のようなメッセージが大量に表示されますが無視してください．</p>

<table border="1" summary="fig">
<tr><td>
■図１９　学習する件数の上限に達したことを示すメッセージ
<pre>
WARNING: Domain 'ドメイン名' has so many ACLs to hold. Stopped learning mode.
</pre>
</td></tr>
</table>

<h3>アクセスログから必要な部分を抽出する</h3>

<p>grep を用いて mode=learning を含むログを抽出します（図２０）．前後に空白を含めていることに注意してください．空白を入れ忘れると，ファイル名などと一致してしまう可能性があります．</p>

<table border="1" summary="fig">
<tr><td>
■図２０　学習モードのアクセスログだけを抽出する
<pre>
# grep -F -A 2 " mode=learning " /var/log/tomoyo/reject_log.txt &gt; /var/log/tomoyo/learning_log.txt
</pre>
</td></tr>
</table>

<p>抽出したら，条件付きのアクセス許可に変換します（図２１）．</p>

<table border="1" summary="fig">
<tr><td>
■図２１　条件付きのアクセス許可に変換する
<pre>
# /usr/lib/ccs/convert-audit-log &lt; /var/log/tomoyo/learning_log.txt &gt; /var/log/tomoyo/policy.tmp
</pre>
</td></tr>
</table>

<p>変換したら，ドメイン単位でソートすることにより圧縮します（図２２）．</p>

<table border="1" summary="fig">
<tr><td>
■図２２　ドメイン単位でソートする
<pre>
# /usr/sbin/ccs-sortpolicy &lt; /var/log/tomoyo/policy.tmp &gt; /var/log/tomoyo/policy.txt
</pre>
</td></tr>
</table>

<h3>加工してからポリシーとして追加する</h3>

<p>/var/log/tomoyo/policy.txt はそのままドメインポリシーとして /etc/ccs/domain_policy.conf に追加することが可能ですが，図２３のように条件が厳密すぎて使い物にならない（例えばプロセスＩＤやｉノード番号などは毎回変わるため、指定しない方が良い）ので，テキストエディタを用いて条件を緩めて（不要と思われる条件部分を除去して）から追加してください．</p>

<table border="1" summary="fig">
<tr><td>
■図２３　厳密すぎるアクセス許可
<pre>
allow_execute /usr/bin/id if task.pid=4641 task.ppid=4637 task.uid=48 task.gid=48 task.euid=48 task.egid=48 task.suid=48 task.sgid=48 task.fsuid=48 task.fsgid=48 task.state[0]=0 task.state[1]=0 task.state[2]=0 task.type!=execute_handler path1.uid=0 path1.gid=0 path1.ino=603159 path1.major=8 path1.minor=1 path1.perm=0755 path1.type=file path1.parent.uid=0 path1.parent.gid=0 path1.parent.ino=589834 path1.parent.perm=0755 exec.realpath="/usr/bin/id" exec.argc=1 exec.envc=7 exec.argv[0]="id" exec.envp["TERM"]="linux" exec.envp["PATH"]="/sbin:/usr/sbin:/bin:/usr/bin" exec.envp["PWD"]="/usr/share/horde/admin" exec.envp["LANG"]="en_US.UTF-8" exec.envp["SHLVL"]="3" exec.envp["LANGUAGE"]="en_US.UTF-8" exec.envp["_"]="/usr/bin/id"
</pre>
</td></tr>
</table>

<h2>次回予告</h2>

<p>今回はドメイン遷移の制御とポリシーのチューニング方法について紹介しました．次回は， TOMOYO Linux の特徴である階層化されたドメイン遷移を利用して，近年急増している ssh ブルートフォース攻撃への対策と管理者権限の分割方法について紹介します．どうぞお楽しみに．</p>

<p><a href="tutorial-4.html.ja">第４回へ戻る</a>　<a href="tutorial-6.html.ja">第６回へ進む</a></p>

<hr>

<p><a href="index.html.ja">目次へ戻る</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</body>
</html>
