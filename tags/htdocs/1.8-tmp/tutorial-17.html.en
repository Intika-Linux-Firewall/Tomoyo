<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>The world of TOMOYO Linux&nbsp;&nbsp;The ???th installment: "Let's restrict login sessions."</title>
<link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<p style="text-align:right;"><a href="tutorial-10.html.ja">Japanese Page</a></p>
<p style="text-align:right;">Last modified: $Date$</p>

<h1>The world of TOMOYO Linux<br>The ???th installment: "Let's restrict login sessions."</h1>

<h2>Contents of this installment.</h2>

<p>In this installment, I explain how not to suppress domain transitions in login sessions for auditing purpose.</p>

<h3>About keep_domain keyword</h3>

<p>In the earlier installment of this tutorial, I explained how to use keep_domain keyword. The keep_domain keyword was originally designed for allowing users to execute programs without knowing which program calls which programs beforehand (e.g. /bin/bash calls /bin/tcsh and /bin/tcsh calls /bin/bash ).</p>

<p>Until TOMOYO 1.7.x, domains are not automatically created if access control mode for program execution (i.e. CONFIG::file::execute ) is enforcing mode. But in TOMOYO Linux 1.8.0, domains are automatically created even if access control mode for program execution is enforcing mode. Also, TOMOYO Linux 1.8.0 supports ACL groups. As a result, you can develop policies that restrict operations in login sessions (strictly speaking, not only login sessions but also arbitrary domains) without suppressing domain transition.</p>

<p>You must be aware that creating a new domain consumes kernel memory. If you forgot to limit memory used by policy, your system will crash due to out of memory. For example, running below program can eat much memory because the domainname is represented by a concatenation of all previously executed pathnames:</p>

<pre>
$ cat &gt; /tmp/recursive.sh &lt;&lt; "EOF"
#! /bin/sh
cat /proc/ccs/self_domain
echo
exec /tmp/recursive.sh
EOF
$ chmod 755 /tmp/recursive.sh 
$ cat /proc/ccs/stat
Policy update:                               928 (Last: 2011/01/27 08:21:08)
Policy violation in learning mode:             0
Policy violation in permissive mode:           0
Policy violation in enforcing mode:            0
Memory used by policy:                    763232
Memory used by audit log:                      0 (Quota:   16777216)
Memory used by query message:                  0 (Quota:    1048576)
Total memory used:                        763232
$ /tmp/recursive.sh
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /tmp/recursive.sh /bin/cat
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /tmp/recursive.sh /tmp/recursive.sh /bin/cat
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /tmp/recursive.sh /tmp/recursive.sh /tmp/recursive.sh /bin/cat
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /tmp/recursive.sh /tmp/recursive.sh /tmp/recursive.sh /tmp/recursive.sh /bin/cat
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /tmp/recursive.sh /tmp/recursive.sh /tmp/recursive.sh /tmp/recursive.sh /tmp/recursive.sh /bin/cat
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /tmp/recursive.sh /tmp/recursive.sh /tmp/recursive.sh /tmp/recursive.sh /tmp/recursive.sh /tmp/recursive.sh /bin/cat
(...snipped...)^C
$ cat /proc/ccs/stat
Policy update:                              1152 (Last: 2011/01/27 08:21:40)
Policy violation in learning mode:             0
Policy violation in permissive mode:           0
Policy violation in enforcing mode:            0
Memory used by policy:                   1407584
Memory used by audit log:                      0 (Quota:   16777216)
Memory used by query message:                  0 (Quota:    1048576)
Total memory used:                       1407584
</pre>

<p>To limit memory used by policy, you can use /etc/ccs/stat.conf :</p>

<pre>
# Memory quota (byte). 0 means no quota.
Memory used by policy:               0
Memory used by audit log:     16777216
Memory used by query message:  1048576
</pre>

<p>You can change the "Memory used by policy:" line in /etc/ccs/stat.conf to (e.g.) 16777216 for allowing policy to consume up to 16 megabytes of kernel memory, and then execute "ccs-loadpolicy -s &lt; /etc/ccs/stat.conf" to reflect changes.</p>

<p>If access control mode for program execution (i.e. CONFIG::file::execute ) is enforcing mode, the execution of /tmp/recursive.sh will stop when the domainname became longer than 4000 bytes or reached the memory quota given by "Memory used by policy:" line:</p>

<pre>
/tmp/recursive.sh: line 2: /bin/cat: Cannot allocate memory

/tmp/recursive.sh: line 4: /tmp/recursive.sh: Cannot allocate memory
/tmp/recursive.sh: line 4: /tmp/recursive.sh: Success
</pre>

<p>All ACL entries which should be inherited to dynamically created descendants should be given using ACL groups, for a newly created domain has no ACL entries except ACL entries referenced by use_group line but the newly created domain is already in enforcing mode. Therefore, to use ACL groups, you need to firstly assign a different group number (e.g. "use_group 1") to the root domain for login session before you start collecting ACL entries using the learning mode.</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
use_profile 3<br>
use_group 0<br>
(...snipped...)<br>
<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
use_profile 1<br>
use_group 1
</td></tr>
</table>

<p>After you have finished collecting ACL entries, you can summarize using awk program.</p>

<table border="1">
<tr><td>
ccs-selectpolicy -r '&lt;kernel&gt; /usr/sbin/sshd /bin/bash' | awk ' { print "acl_group 1 " $0 } ' | sort | uniq | ccs-loadpolicy -e
</td></tr>
</table>

<p>Above script is just for demonstration. You should review before appending to the exception policy.</p>

<p>Then, you can delete descendant domains of the login session, and assign a profile for enforcing mode:</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
use_profile 3<br>
use_group 0<br>
(...snipped...)<br>
<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
use_profile 3<br>
use_group 1
</td></tr>
</table>

<p>Now, the login session is protected without suppressing domain transition.</p>

<h3>About execute handler mechanism.</h3>

<p>TOMOYO Linux supports a mechanism named execute handler. If this mechanism is used, the kernel no longer controls whether to execute a requested program or not, and the kernel merely executes the program specified by "task auto_execute_handler" keyword, and the program specified by "task auto_execute_handler" keyword does preprocessing before executing the requested program. Of course, the kernel will control whether to execute the requested program or not when requested by the program specified by "task auto_execute_handler" keyword if access control mode for program execution is enforcing mode. Therefore, you can use this mechanism for auditing parameters (e.g. command line arguments, environment variables, open()ed file's descriptors) passed to program execution requests in the user's login session.</p>

<p>The configuration for using this mechanism is easy. You can add:</p>

<pre>
task auto_execute_handler /usr/lib/ccs/audit-exec-param
</pre>

<p>line to domains you want to audit. You can add:</p>

<pre>
acl_group 1 task auto_execute_handler /usr/lib/ccs/audit-exec-param
</pre>

<p>line to the exception policy if domains for login session is configured with:</p>

<pre>
use_group 1
</pre>

line. The parameters passed to program execution requests will be logged to syslog. ( /usr/lib/ccs/ccs-audit-param is an example program included in ccs-tools package. You can modify as you like.)</p>

<p>Above example used the execute handler mechanism only for auditing. But you can also use this mechanism for judging whether to execute the requested program or not and sanitizing parameters. For more information on execute handler, please see <a href="policy-reference.html.en#auto_execute_handler">Judging execute request outside the kernel.</a></p>

<hr>

<p><a href="index.html.en#tutorial">Return to index page.</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</body>
</html>
