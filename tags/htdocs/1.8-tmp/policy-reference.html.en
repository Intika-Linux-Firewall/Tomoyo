<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en-US">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<link rel="stylesheet" href="../media/tomoyolinux.css" media="all" type="text/css">
<title>TOMOYO Linux 1.8.x : The Official Guide : Policy specification</title>
</head>

<body>

<div id="titlebar">
<a href="../index.html.en"><img src="../media/tomoyotitle.png" alt="tomoyotitle.png" width="320" height="40" border="0" align="left"></a>
</div>

<div id="navbar" class="tomoyo-documentation">
<ul id="navbarlist">
<li id="tomoyo-home"><a href="../index.html.en" title="TOMOYO Linux Home Page">Home</a></li>
<li id="tomoyo-about"><a href="../about.html.en" title="About TOMOYO Linux">About</a></li>
<li id="tomoyo-download"><a href="../download.html.en" title="Get TOMOYO Linux">Download</a></li>
<li id="tomoyo-changelogs"><a href="../changelogs.html.en" title="TOMOYO Linux ChangeLogs">ChangeLogs</a></li>
<li id="tomoyo-documentation"><a href="../documentation.html.en" title="Official Documentation">Documentation</a></li>
<li id="tomoyo-support"><a href="../support.html.en" title="Support information">Support</a></li>
<li id="tomoyo-links"><a href="../links.html.en" title="Links">Links</a></li>
</ul>
<ul id="switch-language">
<li id="tomoyo-switch-language"><a href="index.html.ja" title="Go to Japanese page">Japanese page</a></li>
</ul>
</div>

<div id="content">

<div id="documentation">
<h2>4.3 <a name="access_logs">Access Logs</a></h2>

<p>TOMOYO Linux generates two types of access logs. One contains access requests that didn't violate domain policy. The other contains access requests that violated domain policy. The former is called grant log and the latter is called reject log. These logs are readable via /proc/ccs/audit . A utility program /usr/sbin/ccs-auditd is included for reading these logs and saving the logs as files.</p>

<p>Some examples are shown below. The first log is generated by execute request.</p>

<table border="1">
<tr><td>
#2010-01-13 21:00:50# profile=1 mode=learning granted=yes (global-pid=2908) task={ pid=2908 ppid=2879 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 type!=execute_handler } path1={ uid=0 gid=0 ino=852049 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=851969 perm=0755 } exec={ realpath="/bin/cat" argc=2 envc=20 argv[]={ "cat" "/etc/fstab" } envp[]={ "HOSTNAME=tomoyo" "TERM=vt100" "SHELL=/bin/bash" "HISTSIZE=1000" "SSH_CLIENT=192.168.1.2\0402845\04022" "SSH_TTY=/dev/pts/0" "USER=root" "LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:" "MAIL=/var/spool/mail/root" "PATH=/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/sbin:/root/bin" "PWD=/root" "LANG=C" "SHLVL=1" "HOME=/root" "LOGNAME=root" "CVS_RSH=ssh" "SSH_CONNECTION=192.168.1.2\0402845\040192.168.1.7\04022" "LESSOPEN=|/usr/bin/lesspipe.sh\040%s" "G_BROKEN_FILENAMES=1" "_=/bin/cat" } }<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
file execute /bin/cat
</td></tr>
</table>

<p>This log shows that a process that belongs to "&lt;kernel&gt; /usr/sbin/sshd /bin/bash" domain attempted to execute /bin/cat , and the arguments were "cat" and "/etc/fstab", environment variables were "HOSTNAME=tomoyo" "TERM=vt100" "SHELL=/bin/bash" "HISTSIZE=1000" "SSH_CLIENT=192.168.1.2\0402845\04022" "SSH_TTY=/dev/pts/0" "USER=root" "LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:" "MAIL=/var/spool/mail/root" "PATH=/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/sbin:/root/bin" "PWD=/root" "LANG=C" "SHLVL=1" "HOME=/root" "LOGNAME=root" "CVS_RSH=ssh" "SSH_CONNECTION=192.168.1.2\0402845\040192.168.1.7\04022" "LESSOPEN=|/usr/bin/lesspipe.sh\040%s" "G_BROKEN_FILENAMES=1" "_=/bin/cat". Also, process information such as PID, UID are shown.</p>

<p>The next log is generated by opening a file for reading.</p>

<table border="1">
<tr><td>
#2010-01-13 21:00:50# profile=1 mode=learning granted=yes (global-pid=2908) task={ pid=2908 ppid=2879 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 type!=execute_handler } path1={ uid=0 gid=0 ino=901920 major=8 minor=1 perm=0644 type=file } path1.parent={ uid=0 gid=0 ino=901121 perm=0755 }<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/cat<br>
file read /etc/fstab
</td></tr>
</table>

<p>This log shows that a process that belongs to "&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/cat" domain opened /etc/fstab for reading.</p>

<p>The next log is generated when a new domain is created.</p>

<table border="1">
<tr><td>
#2010-01-13 21:05:22# profile=1 mode=learning granted=no (global-pid=3007) task={ pid=3007 ppid=2991 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 type=execute_handler }<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash /bin/audit-exec-param /bin/cat<br>
use_profile 1
</td></tr>
</table>

<p>This log shows that a domain named "&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash /bin/audit-exec-param /bin/cat" was created and profile 1 was assigned. TOMOYO Linux automatically creates domains as needed. When a domain is automatically created, the profile number of the domain the process that requested program execution belongs to is inherited.</p>

<p>The next log is generated when a program that is different from the program being requested was executed because of <a href="#auto_execute_handler">Judging execute request outside the kernel.</a></p>
<table border="1">
<tr><td>
#2010-01-13 21:05:22# profile=1 mode=learning granted=yes (global-pid=3007) task={ pid=3007 ppid=2991 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 type!=execute_handler } path1={ uid=0 gid=0 ino=360482 major=8 minor=1 perm=0755 type=file } path1.parent={ uid=0 gid=0 ino=851969 perm=0755 } exec={ realpath="/bin/audit-exec-param" argc=29 envc=0 argv[]={ "/bin/audit-exec-param" "&lt;kernel&gt;\040/usr/sbin/sshd\040/bin/bash\040/bin/bash" "/bin/bash" "pid=3007\040uid=0\040gid=0\040euid=0\040egid=0\040suid=0\040sgid=0\040fsuid=0\040fsgid=0" "/bin/cat" "2" "20" "cat" "/etc/fstab" "HOSTNAME=tomoyo" "SHELL=/bin/bash" "TERM=vt100" "HISTSIZE=1000" "SSH_CLIENT=192.168.1.2\0402845\04022" "SSH_TTY=/dev/pts/0" "USER=root" "LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:" "PATH=/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/sbin:/root/bin:/usr/sbin" "MAIL=/var/spool/mail/root" "PWD=/root" "LANG=C" "HOME=/root" "SHLVL=2" "LOGNAME=root" "CVS_RSH=ssh" "SSH_CONNECTION=192.168.1.2\0402845\040192.168.1.7\04022" "LESSOPEN=|/usr/bin/lesspipe.sh\040%s" "G_BROKEN_FILENAMES=1" "_=/bin/cat" } envp[]={ } }<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash<br>
task auto_execute_handler /bin/audit-exec-param
</td></tr>
</table>

<p>This log shows that a process that belongs to a domain named "&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash" attempted to execute a program, but since the task auto_execute_handler keyword is specified to the domain, /bin/audit-exec-param was executed, and arguments passed to /bin/audit-exec-param were "/bin/audit-exec-param" "&lt;kernel&gt;\040/usr/sbin/sshd\040/bin/bash\040/bin/bash" "/bin/bash" "pid=3007\040uid=0\040gid=0\040euid=0\040egid=0\040suid=0\040sgid=0\040fsuid=0\040fsgid=0" "/bin/cat" "2" "20" "cat" "/etc/fstab" "HOSTNAME=tomoyo" "SHELL=/bin/bash" "TERM=vt100" "HISTSIZE=1000" "SSH_CLIENT=192.168.1.2\0402845\04022" "SSH_TTY=/dev/pts/0" "USER=root" "LS_COLORS=no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.sh=01;32:*.csh=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tz=01;31:*.rpm=01;31:*.cpio=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.xbm=01;35:*.xpm=01;35:*.png=01;35:*.tif=01;35:" "PATH=/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/sbin:/root/bin:/usr/sbin" "MAIL=/var/spool/mail/root" "PWD=/root" "LANG=C" "HOME=/root" "SHLVL=2" "LOGNAME=root" "CVS_RSH=ssh" "SSH_CONNECTION=192.168.1.2\0402845\040192.168.1.7\04022" "LESSOPEN=|/usr/bin/lesspipe.sh\040%s" "G_BROKEN_FILENAMES=1" "_=/bin/cat". To avoid /bin/audit-exec-param affected by environment variables such as LD_PRELOAD, environment variables are moved to arguments.</p>

<p>In this way, an access log consists of 3 lines (or 4 lines since /usr/sbin/ccs-auditd inserts an empty line), and they are in the domain policy format and appendable to the domain policy. Pick up portions you want to permit from reject log and save (for example, /var/log/tomoyo/diff.txt) and you can add to domain policy by doing</p>

<table border="1">
<tr><td>
# /usr/sbin/ccs-loadpolicy -d &lt; /var/log/tomoyo/diff.txt
</td></tr>
</table>

<p>Therefore, you don't need to use "learning mode" from the beginning. If you wish, you can use "permissive mode" from the beginning and let reject logs generated, then edit reject logs and append to domain policy when developing domain policy. When domain policy is generated by "learning mode", process state (the first line of an access logs) is not taken into account. But when domain policy is generated from reject logs, you can use <a href="#conditional_acl">Using conditional ACL.</a> from the beginning. For example, generate a reject log by not using "learning mode" and append like</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
file execute /bin/cat exec.argc=2 exec.realpath="/bin/cat" exec.argv[0]="cat" exec.argv[1]="/etc/fstab"
</td></tr>
</table>

<p>then, you can give more precise permission compared to the permission appended by "learning mode"'s log (shown below).</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
file execute /bin/cat exec.realpath="/bin/cat" exec.argv[0]="cat"
</td></tr>
</table>

<h1>6. <a name="Advanced_Features">Advanced Features</a></h1>

<h2>6.1 <a name="non_root_policy_update">Allowing policy modification by non root user.</a></h2>

<p>By default, only processes with both UID = 0 and EUID = 0 can modify policy via /proc/ccs/ interface. But if you want to permit policy modification via /proc/ccs/ interface by non root user, you can write this keyword like</p>

<table border="1">
<tr><td>
# echo manage_by_non_root | /usr/sbin/ccs-loadpolicy -m
</td></tr>
</table>

<p>to disable UID and EUID checks. Also, you can write this keyword like</p>

<table border="1">
<tr><td>
# echo delete manage_by_non_root | /usr/sbin/ccs-loadpolicy -m
</td></tr>
</table>

<p>to enable UID and EUID checks again. Use chown/chmod as needed since the owner of /proc/ccs/ interface is root.<br>
To be able to do this steps, /sbin/ccs-init also executes /etc/ccs/ccs-post-init if /etc/ccs/ccs-post-init is executable. Therefore, to allow access to /proc/ccs/ interface by user demo, create /etc/ccs/ccs-post-init with</p>

<table border="1">
<tr><td>
#! /bin/sh<br>
echo manage_by_non_root &gt; /proc/ccs/manager<br>
chown -R demo /proc/ccs/
</td></tr>
</table>

<p>and initialize like</p>

<table border="1">
<tr><td>
# chmod 755 /etc/ccs/ccs-post-init<br>
# chown -R demo /etc/ccs/
</td></tr>
</table>

<p>Then, user demo will be able to access policy directories and policy editors.</p>

<h2>6.2 <a name="conditional_acl">Using conditional ACL.</a></h2>

<p>You can add conditions (e.g. UID and GID) as needed. The condition clause are appended to the tail of each permission.</p>

<table border="1">
<tr><td>Example</td><td>Meaning</td></tr>
<tr><td>file read /etc/passwd</td><td>Allow opening /etc/passwd for reading.</td></tr>
<tr><td>file read /etc/passwd task.uid=0</td><td>Allow opening /etc/passwd for reading only if the process's UID is 0.</td></tr>
<tr><td>file read /etc/passwd task.uid!=0</td><td>Allow opening /etc/passwd for reading only if the process's UID is not 0.</td></tr>
<tr><td>network inet stream connect 10.0.0.1 80</td><td>Allow connecting TCP socket to 10.0.0.1 port 80.</td></tr>
<tr><td>network inet stream connect 10.0.0.1 80 task.uid=100</td><td>Allow connecting TCP socket to 10.0.0.1 port 80 only if the process's UID is 100.</td></tr>
<tr><td>capability SYS_PTRACE</td><td>Allow using ptrace(2) syscall.</td></tr>
<tr><td>capability SYS_PTRACE task.ppid=1 task.uid=0 task.euid=0</td><td>Allow using ptrace(2) syscall only if the parent process is /sbin/init and the process's UID is 0 and the process's EUID is 0.</td></tr>
</table>

<p>The following variables are available.</p>

<table border="1">
<tr><td>Variable</td><td>Meaning</td></tr>
<tr><td>task.uid</td><td>UID of current process</td></tr>
<tr><td>task.euid</td><td>Effective UID of current process</td></tr>
<tr><td>task.suid</td><td>Saved UID of current process</td></tr>
<tr><td>task.fsuid</td><td>File System UID of current process</td></tr>
<tr><td>task.gid</td><td>GID of current process</td></tr>
<tr><td>task.egid</td><td>Effective GID of current process</td></tr>
<tr><td>task.sgid</td><td>Saved GID of current process</td></tr>
<tr><td>task.fsgid</td><td>File System GID of current process</td></tr>
<tr><td>task.pid</td><td>PID of current process</td></tr>
<tr><td>task.ppid</td><td>PID of parent process</td></tr>
<tr><td>path1.uid</td><td>UID of object.</td></tr>
<tr><td>path1.gid</td><td>GID of object.</td></tr>
<tr><td>path1.ino</td><td>i-node number of object.</td></tr>
<tr><td>path1.parent.uid</td><td>UID of object's parent directory.</td></tr>
<tr><td>path1.parent.gid</td><td>GID of object's parent directory.</td></tr>
<tr><td>path1.parent.ino</td><td>i-node number of object's parent directory.</td></tr>
<tr><td>path2.parent.uid</td><td>UID of object's parent directory.</td></tr>
<tr><td>path2.parent.gid</td><td>GID of object's parent directory.</td></tr>
<tr><td>path2.parent.ino</td><td>i-node number of object's parent directory.</td></tr>
</table>

<p>"path1" corresponds to the first pathname of operations that requires pathnames, and "path2" corresponds to the second pathname of operations that requires pathnames. For example, the case of "<a href="#domain_policy_file_rename">file rename</a> file1 file2", path1 corresponds to file1 and path2 corresponds to file2.</p>

<p>"path1" except "path1.parent" is not available for pathnames that don't exist. Thus, you can't use when creating pathnames (such as <a href="#domain_policy_file_create">file create</a> keyword).</p>

<p>"path1.parent" is always available.</p>

<p>"path2.parent" is available only for operations that require 2 pathnames (i.e. <a href="#domain_policy_file_link">file link</a> and <a href="#domain_policy_file_rename">file rename</a> keywords).</p>

<p>"path2" is available only for mount operations.</p>

<p>"path1" is not supported when accessing via "sysctl" (i.e. accessing files under /proc/sys/ directories using "sysctl" instead for "open").</p>

<h3>The following variables and conditions are available for <a href="#domain_policy_file_execute">file execute</a> keyword.</h3>

<table border="1">
<tr><td>Variable</td><td>Meaning</td></tr>
<tr><td>exec.realpath</td><td>Dereferenced pathname of the requested program.</td></tr>
<tr><td>exec.argc</td><td>Number of argv[] passed for execute request.</td></tr>
<tr><td>exec.envc</td><td>Number of envp[] passed for execute request.</td></tr></table>

<table border="1">
<tr><td>Condition</td><td>Meaning</td></tr>
<tr><td>exec.realpath="value"</td><td>Dereferenced pathname of the requested program matches "value".</td></tr>
<tr><td>exec.realpath!="value"</td><td>Dereferenced pathname of the requested program does not match "value".</td></tr>
<tr><td>exec.argv[index]="value"</td><td>argv[index] (where 0 &lt;= index &lt; exec.argc) matches "value".</td></tr>
<tr><td>exec.argv[index]!="value"</td><td>argv[index] (where 0 &lt;= index &lt; exec.argc) does not match "value".</td></tr>
<tr><td>exec.envp["name"]="value"</td><td>Environment variable "name" is defined and matches "value".</td></tr>
<tr><td>exec.envp["name"]!="value"</td><td>Environment variable "name" is not defined or does not match "value".</td></tr>
<tr><td>exec.envp["name"]!=NULL</td><td>Environment variable "name" is defined.</td></tr>
<tr><td>exec.envp["name"]=NULL</td><td>Environment variable "name" is not defined.</td></tr>
</table>

<h3>The following conditions are also available.</h3>

<h4>Type of process</h4>

<table border="1">
<tr><td>Condition</td><td>Meaning</td></tr>
<tr><td>task.type=execute_handler</td><td>Current process is a program specified by execute_handler keyword.</td></tr>
<tr><td>task.type!=execute_handler</td><td>Current process is not a program specified by execute_handler keyword.</td></tr>
</table>

<h4>Type of file.</h4>

<table border="1">
<tr><td>Condition</td><td>Meaning</td></tr>
<tr><td>path1.type=file</td><td>path1 is a regular file.</td></tr>
<tr><td>path1.type=directory</td><td>path1 is a directory.</td></tr>
<tr><td>path1.type=fifo</td><td>path1 is a FIFO.</td></tr>
<tr><td>path1.type=socket</td><td>path1 is a socket.</td></tr>
<tr><td>path1.type=symlink</td><td>path1 is a symbolic link.</td></tr>
<tr><td>path1.type=block</td><td>path1 is a block device file.</td></tr>
<tr><td>path1.type=char</td><td>path1 is a character device file.</td></tr>
<tr><td>path1.type!=file</td><td>path1 is not a regular file.</td></tr>
<tr><td>path1.type!=directory</td><td>path1 is not a directory.</td></tr>
<tr><td>path1.type!=fifo</td><td>path1 is not a FIFO.</td></tr>
<tr><td>path1.type!=socket</td><td>path1 is not a socket.</td></tr>
<tr><td>path1.type!=symlink</td><td>path1 is not a symbolic link.</td></tr>
<tr><td>path1.type!=block</td><td>path1 is not a block device file.</td></tr>
<tr><td>path1.type!=char</td><td>path1 is not a character device file.</td></tr></table>

<p>Since path1.parent and path2.parent are always directory, TOMOYO Linux does not support path1.parent and path2.parent for type of file.</p>

<h4>Device numbers of a device file where the file resides.</h4>

<table border="1">
<tr><td>Condition</td><td>Meaning</td></tr>
<tr><td>path1.major=num1-num2</td><td>Device major number of a device file which path1 resides is between num1 and num2.</td></tr>
<tr><td>path1.minor=num1-num2</td><td>Device minor number of a device file which path1 resides is between num1 and num2.</td></tr>
<tr><td>path1.major!=num1-num2</td><td>Device major number of a device file which path1 resides is not between num1 and num2.</td></tr>
<tr><td>path1.minor!=num1-num2</td><td>Device minor number of a device file which path1 resides is not between num1 and num2.</td></tr>
</table>

<p>Since a device file where path1.parent and path2.parent reside is always same as the device file where path1 resides (because cross device operation is not permitted), TOMOYO Linux does not support path1.parent and path2.parent for device numbers.</p>

<p>If num1 and num2 is the same value, you can omit -num2 part.</p>

<h4>Device numbers of the device file itself.</h4>

<table border="1">
<tr><td>Condition</td><td>Meaning</td></tr>
<tr><td>path1.dev_major=num1-num2</td><td>Device file's major number is between num1 and num2.</td></tr>
<tr><td>path1.dev_minor=num1-num2</td><td>Device file's minor number is between num1 and num2.</td></tr>
<tr><td>path1.dev_major!=num1-num2</td><td>Device file's major number is not between num1 and num2.</td></tr>
<tr><td>path1.dev_minor!=num1-num2</td><td>Device file's minor number is not between num1 and num2.</td></tr>
</table>

<p>These conditions are valid only for path1.type=block or path1.type=char cases.</p>

<p>If num1 and num2 is the same value, you can omit -num2 part.</p>

<h4>DAC's permissions</h4>

<table border="1">
<tr><td>Condition</td><td>Meaning</td></tr>
<tr><td>path1.perm=num1-num2</td><td>path1's permission is between num1 and num2.</td></tr>
<tr><td>path1.perm!=num1-num2</td><td>path1's permission is not between num1 and num2.</td></tr>
<tr><td>path1.perm=setuid</td><td>path1's setuid bit is on.</td></tr>
<tr><td>path1.perm!=setuid</td><td>path1's setuid bit is off.</td></tr>
<tr><td>path1.perm=setgid</td><td>path1's setgid bit is on.</td></tr>
<tr><td>path1.perm!=setgid</td><td>path1's setgid bit is off.</td></tr>
<tr><td>path1.perm=sticky</td><td>path1's sticky bit is on.</td></tr>
<tr><td>path1.perm!=sticky</td><td>path1's sticky bit is off.</td></tr>
<tr><td>path1.perm=owner_read</td><td>path1's owner read bit is on.</td></tr>
<tr><td>path1.perm!=owner_read</td><td>path1's owner read bit is off.</td></tr>
<tr><td>path1.perm=owner_write</td><td>path1's owner write bit is on.</td></tr>
<tr><td>path1.perm!=owner_write</td><td>path1's owner write bit is off.</td></tr>
<tr><td>path1.perm=owner_execute</td><td>path1's owner execute bit is on.</td></tr>
<tr><td>path1.perm!=owner_execute</td><td>path1's owner execute bit is off.</td></tr>
<tr><td>path1.perm=group_read</td><td>path1's group read bit is on.</td></tr>
<tr><td>path1.perm!=group_read</td><td>path1's group read bit is off.</td></tr>
<tr><td>path1.perm=group_write</td><td>path1's group write bit is on.</td></tr>
<tr><td>path1.perm!=group_write</td><td>path1's group write bit is off.</td></tr>
<tr><td>path1.perm=group_execute</td><td>path1's group execute bit is on.</td></tr>
<tr><td>path1.perm!=group_execute</td><td>path1's group execute bit is off.</td></tr>
<tr><td>path1.perm=others_read</td><td>path1's others read bit is on.</td></tr>
<tr><td>path1.perm!=others_read</td><td>path1's others read bit is off.</td></tr>
<tr><td>path1.perm=others_write</td><td>path1's others write bit is on.</td></tr>
<tr><td>path1.perm!=others_write</td><td>path1's others write bit is off.</td></tr>
<tr><td>path1.perm=others_execute</td><td>path1's others execute bit is on.</td></tr>
<tr><td>path1.perm!=others_execute</td><td>path1's others execute bit is off.</td></tr>
</table>

<p>These conditions are applicable for path1.parent and path2.parent as well as path1 .</p>

<p>If num1 and num2 is the same value, you can omit -num2 part.</p>

<p>To specify value in octal format, start from 0 (e.g. path1.perm=0644 ).</p>

<h4>Example:</h4>

<ul>
<li>file append /dev/null path1.type=char path1.major=1 path1.minor=3 path1.perm=0666
</ul>

<p>will allow opening /dev/null for reading and writing only if /dev/null's type is character device file and /dev/null's major number is 1 and /dev/null's minor number is 3 and /dev/null's permission is 0666.</p>

<h3>The following conditions for <a href="#domain_policy_file_symlink">file symlink</a> keyword are also available.</h3>

<table border="1">
<tr><td>Condition</td><td>Meaning</td></tr>
<tr><td>symlink.target="value"</td><td>The content of a symlink to be created matches "value".</td></tr>
<tr><td>symlink.target!="value"</td><td>The content of a symlink to be created does not match "value".</td></tr>
</table>

<h2>6.3 <a name="sleep_penalty">Sleep penalty for policy violation.</a></h2>

<p>You can make the process which violated policy in enforcing mode sleep for specified period.</p>

<table border="1">
<tr><td>Example of /proc/ccs/profile</td><td>Meaning</td></tr>
<tr><td>3-PREFERENCE={ enforcing_penalty=1 }</td><td>Make the process which violated policy in enforcing mode and which belongs to a domain with profile 3 sleep for 0.1 second.</td></tr>
<tr><td>4-PREFERENCE={ enforcing_penalty = 10 }</td><td>Make the process which violated policy in enforcing mode and which belongs to a domain with profile 4 sleep for 1 second.</td></tr>
</table>

<p>This feature is a safeguard to avoid that the CPU usage remains 100% when policy violation occurs in an infinite loop. Usually, making processes sleep for 0.1 second is enough.</p>

<p>This feature is not applied against network's receive operation so that attackers cannot make services sleep for long time (in other words, delay your system's response) by intentionally sending TCP connection requests and UDP packets from unwanted sources.</p>

<h2>6.4 <a name="auto_execute_handler">Judging execute request outside the kernel.</a></h2>

<p>Basically, TOMOYO Linux controls whether to execute a program or not according to the domain policy. You can check parameters using exec.argv and exec.envp described in <a href="#conditional_acl">Using conditional ACL.</a> But this approach support only simple pattern matching and you need to specify what programs are permitted to be executed beforehand.</p>

<p>Therefore, TOMOYO Linux supports a mechanism named <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a>. If this mechanism is used, the kernel no longer controls whether to execute a requested program or not, and the kernel merely executes the program specified by <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a>, and the program specified by <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a> determines whether to execute the requested program or not, and the program specified by <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a> executes the requested program only if the program specified by <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a> considers it is appropriate.</p>

<p>In Linux, the behavior "execute a program" means "overwrite the process which requested to execute a program with the requested program's image" and "the process which requested to execute a program cannot regain control if the execute request was succeeded". Therefore, the process which requested to execute a program can receive a notification only when the execute request was failed.<br>
For example, let's consider a situation where a process running as program-A attempts to execute program-B.<br>
When the process running as program-A requests the execution of program-B, the kernel checks the domain policy for "whether it is appropriate to execute program-B from a process running as program-A or not" and the kernel overwrites the process running as program-A with program-B if the kernel considers it is appropriate, and the kernel doesn't overwrite the process running as program-A with program-B and notifies the process running as program-A that execution of program-B is not permitted if the kernel considers it is not appropriate.</p>

<p>When <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a> is specified, a different program program-C specified as task auto_execute_handler mediates this behavior.<br>
When the process running as program-A requests the execution of program-B, the kernel overwrites the process running as program-A with program-C to let the program-C judge whether it is appropriate to execute program-B from a process running as program-A or not.
The process now running as program-C determines whether it is appropriate to execute program-B from a process running as program-A or not, and the process now running as program-C requests the execution of program-B (and the kernel will overwrite the process now running as program-C with program-B) if the process now running as program-C considers it is appropriate, and the process now running as program-C terminates without executing program-B if the process now running as program-C considers it is not appropriate.</p>

<p>As stated above, this mechanism has a side effect that it becomes impossible to notify the process running as program-A that the requested program (i.e. program-B) was not executed since program-C abandons a mean to notify the process running as program-A that the execute request of program-B was not accepted.<br>
But, even if <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a> is not specified, there are various factors that cause "the execute request was accepted but the program terminated before starting the expected behavior" such as "the process was unable to read shared libraries", "the process received KILL signal", "the system became out of memory and the process was killed by OOM killer". In other words, there are uncertainties between "the execute request did not fail" and "the executed program starts the expected behavior".<br>
Viewing in this light, there is no guarantee that "the program starts expected behavior unless the process receives a notification that the execution of the program failed" from the beginning. And, it is possible to say that it is an acceptable result that the program-C specified by <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a> failed to notify the process previously running as program-A that the execution of program-B failed.</p>

<p>TOMOYO Linux's assumes that the administrator knows what programs needs to be executed from what programs beforehand and permits execution of minimal programs. Thus, assuming that unexpected execute request which are not permitted by policy won't occur as long as the system is running properly, it is OK to accept all execute requests. If an execute request that should not be accepted occurs, you can take different actions such as terminating the process instead of rejecting the request by using <a href="#domain_policy_task_denied_execute_handler">task denied_execute_handler</a> mechanism. So, you don't have to let the kernel judge whether to execute the program or not alone.</p>

<p>Thus, you can let external userland program judge whether to execute the requested program or not occurred from a domain by specifying <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a> keyword to the domain.</p>
<p>If you try to judge inside the kernel, there are few library functions available and it is more likely to fail when allocating contiguous memory area. But if you try to judge outside the kernel, there are many library functions available and it is less likely to fail when allocating contiguous memory area, and you can do more detailed checking. So, you can let external userland program specified by <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a> keyword examine parameters and let the program execute the requested program only if parameters are appropriate.</p>

<p>The side effect of this approach is that there is no mean to notify the process that the execute request was not accepted when it is not appropriate to execute the requested program. But since you can freely customize the program for <a href="#domain_policy_task_auto_execute_handler">task auto_execute_handler</a> keyword, you can even  judge using ssh to ask remotely.</p>

<p>To use this feature, specify like below.</p>

<table border="1">
<tr><td>Example of /proc/ccs/domain_policy</td><td>Meaning</td></tr>
<tr><td>task auto_execute_handler /usr/sbin/check-and-exec</td><td>Whenever a process which belongs to this domain requests execution of a program, execute /usr/sbin/check-and-exec instead for the requested program. /usr/sbin/check-and-exec checks parameters and executes the requested program if /usr/sbin/check-and-exec considers it is appropriate to execute.</td></tr>
</table>

<p>The program specified by task auto_execute_handler keyword receives the following parameters. Compare with file execute log described in <a href="#access_logs">Access Logs</a>.</p>

<ul>
<li>argv[0] contains the pathname of the program specified by task auto_execute_handler keyword.</li>
<li>argv[1] contains the name of the domain which the process which issued an execute request belongs to.</li>
<li>argv[2] contains the name of the program which the process which issued an execute request.</li>
<li>argv[3] contains information of the process which the process which issued an execute request.</li>
<li>argv[4] contains the name of the program which was requested by the process.</li>
<li>argv[5] contains the number of arguments.</li>
<li>argv[6] contains the number of environment variables.</li>
<li>From argv[7] to argv[6 + argc] contains the arguments.</li>
<li>From argv[7 + argc] to argv [6 + argc + envc] contains the environment variables.</li>
<li>All environment variables are cleared for safety.</li>
<li>Other resources such as standard input/output are inherited.</li>
</ul>

<p>Be careful with the following notes when you use this feature.</p>

<ul>
<li>You need not to and should not give execute permission (<a href="#domain_policy_file_execute">file execute</a> keyword) to the program specified by task auto_execute_handler keyword.</li>
<li>This mechanism can't work if a process cannot access the program specified by task auto_execute_handler keyword because the process is running inside a chroot environment. Since it is dangerous to allow execution of programs outside the chroot environment, the program specified by task auto_execute_handler keyword is searched from the current process's / directory rather than the current process's namespace's / directory.</li>
<li>This mechanism can't work if the domain for the program specified for task auto_execute_handler keyword doesn't exist. So, you need to prepare domains by (for example) creating a domain for the program specified by task auto_execute_handler keyword just under the &lt;kernel&gt; and mark the program specified by task auto_execute_handler keyword using <a href="#exception_policy_initialize_domain">initialize_domain</a> keyword.</li>
<li>The program specified by task auto_execute_handler keyword is invoked with all environment variables cleared so that the program won't be affected by some dangerous environment variables (e.g. LD_PRELOAD). This means that even environment variable PATH is not set, so please be careful when executing external programs. Also, I recommend you to assign profile for enforcing mode against the domain for the program specified by task auto_execute_handler keyword.</li>
</ul>

<p>A source code named audit-exec-param.c is included as a sample program of how to use this mechanism in the ccs-tools source package. You can customize freely.</p>
<p>This mechanism is just providing a hook. How to utilize this hook is up to you.</p>

<h2>6.5 <a name="denied_execute_handler">Invoking alternative program for execute requests that are not permitted by policy.</a></h2>

<p>TOMOYO Linux's approach is "know what programs needs to be executed from what programs beforehand and create policy that permits execution of minimal programs". Thus, you can not only reject unnecessary execution requests but also do different behavior.</p>

<p>By default, if an execute request of a program which is not permitted by file execute keyword occurs in enforcing mode, the kernel rejects the execute request. But assuming that you know what programs needs to be executed from what programs beforehand, an execute request of a program which is not permitted by file execute keyword will not occur as long as the process is keeping control, and you can regard that the process is not keeping control (in other words, the process already lost control) if such request occurs.</p>

<p>Attackers steal control of a process by attacking security holes such as buffer overflow and attempt to execute commands such as shells. If the process does not need to execute the shell (in other words, you needn't to give permission like "file execute /bin/bash"), it is considered that the process has already lost control at the moment of the execution request of shells.</p>

<p>Normally, when execution of a program which is not permitted by the policy is requested, the kernel merely reject the request. But it is unlikely that the process gets back control (in other words, the process resumes proper operations) by just rejecting the request if the request is issued by the process that has lost control.<br>
In Linux, "execute a program" means that the current process is overwritten by the requested program and transfer control to the requested program. This means that a process gets back control by overwriting the process with different program even if the process has lost control because of buffer overflow.</p>

<p>The control of a process which has once lost control by the attacker and is overwritten by a program requested by the attacker depends on the program used for overwriting. If a program like shells is executed, the control remains on the attacker's side (in other words, the owner of the process) because shells accept whatever the user requested. But if a program which terminates silently (e.g. /bin/true) is executed, the control will not remains on the attacker's side because the process owned by the attacker will terminate immediately.</p>

<p>As described above, an event that "an execute request of an unnecessary program is issued by an attacker" depending on how you look at it. You can consider that "the attacker is giving the system a chance to get back control on the system's side".<br>
Thus, TOMOYO Linux provides a mechanism that executes different program instead of merely rejecting the request when an execute request of a program which is not permitted by policy occurs. How to utilize this mechanism is up to you.</p>

<p>For example, you can replace the execute request of a program which is not permitted by the policy with /bin/true so that the process which requested the execution of a program which is not permitted by the policy will terminate immediately.</p>

<p>For example, you can replace the execute request of shells with a honey pot client's program and observe what requests the attacker issues.</p>

<p>For example, you can forcibly terminate the login session.</p>

<p>For example, you can show warning message like "You are not permitted to execute this program." which is similar to Ubuntu's command-not-found package (which tells the user in what package the requested command is included).</p>

<p>For example, you can change a firewall's configuration if you succeeded to derive the IP address of the attacker.</p>

<p>To use this feature, specify like below.</p>

<table border="1">
<tr><td>Example of /proc/ccs/profile</td><td>Example of /proc/ccs/domain_policy</td><td>Meaning</td></tr>
<tr><td>3-CONFIG::file::execute={ mode=enforcing }</td><td>use_profile 3<br>task denied_execute_handler /bin/true</td><td>If a process which belongs to a domain with profile 3 requested execution of a program which is not permitted by the domain policy, execute /bin/true instead of rejecting the execute request.</td></tr>
</table>

<p>Notes on this feature is the same as <a href="#auto_execute_handler">Judging execute request outside the kernel.</a></p>

<h2>6.6 <a name="manual_domain_transition">Performing domain transition without program execution request.</a></h2>

<p>You can transit to domains specified by <a href="#domain_policy_task_manual_domain_transition">"task manual_domain_transition"</a> keyword by writing domainnames specified by that keyword to /proc/ccs/self_domain interface. This feature is useful for dividing permissions without calling execve() system call, at the cost of inserting a few lines (for writing domainnames to /proc/ccs/self_domain) to application and rebuild the application.</p>

<h2>6.7 <a name="auto_domain_transition">Performing domain transition automatically when conditions are met.</a></h2>

<p>You can automatically transit to domains specified by <a href="#domain_policy_task_auto_domain_transition">"task auto_domain_transition"</a> keyword. This feature is useful for dividing permissions without calling execve() system call.</p>

<p>Be sure to specify conditions (e.g. task.uid!=0) to "task auto_domain_transition" entries.</p>

</div><!-- documentation -->

</div><!-- content -->

<div id="navfooter">
<hr>
<table>
<tr>
<td class="docs-previous">
</td>
<td class="docs-index">
<a href="index.html.en">Index</a>
</td>
<td class="docs-next">
<a href="chapter-2.html.en">Next</a>
</td>
</tr>
<tr>
<td class="docs-previous-description">
</td>
<td class="docs-home">
</td>
<td class="docs-next-description">
<p>Chapter 2: Why do I need TOMOYO Linux?</p>
</td>
</tr>
</table>
</div>

<div id="footer">
<p class="language">Go to <a href="index.html.ja">Japanese page</a>.</p>
<p class="timestamp">Last modified: $Date$</p>
<p class="trademark">Linux&reg; is a registered trademark of Linus Torvalds world-wide. TOMOYO&reg; is a registered trademark of <a href="http://www.nttdata.co.jp/en/">NTT DATA Corporation</a>.</p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</div>

</body>
</html>
