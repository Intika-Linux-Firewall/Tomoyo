[PATCH] TOMOYO 2.5 bugfix patch for Linux 2.6.38

Apply this patch if you want to fix

  Permission for binary loader (e.g. /lib/ld-linux.so.2 ) cannot be checked
  upon do_execve().

  Interactive judgment feature cannot be used when the target process's
  subjective credentials and objective credentials differ. Regarding
  do_execve(), checking permission for binary loader and environment variables
  are impossible.

bugs.

Note that this patch is not yet accepted for upstream.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 fs/exec.c                       |    2 
 include/linux/sched.h           |    3 
 include/linux/security.h        |   30 ++++
 kernel/fork.c                   |    8 +
 security/capability.c           |   16 ++
 security/security.c             |   15 ++
 security/tomoyo/audit.c         |   11 -
 security/tomoyo/common.c        |   28 ++--
 security/tomoyo/common.h        |   98 +++++++++------
 security/tomoyo/domain.c        |   43 +++---
 security/tomoyo/file.c          |   19 +-
 security/tomoyo/gc.c            |   52 ++++++-
 security/tomoyo/mount.c         |    2 
 security/tomoyo/network.c       |    4 
 security/tomoyo/securityfs_if.c |   28 ----
 security/tomoyo/tomoyo.c        |  261 ++++++++++++++++++----------------------
 security/tomoyo/util.c          |   22 +--
 17 files changed, 367 insertions(+), 275 deletions(-)

--- linux-2.6.38.8.orig/fs/exec.c
+++ linux-2.6.38.8/fs/exec.c
@@ -1137,7 +1137,9 @@ void free_bprm(struct linux_binprm *bprm
 	if (bprm->cred) {
 		mutex_unlock(&current->signal->cred_guard_mutex);
 		abort_creds(bprm->cred);
+		bprm->cred = NULL;
 	}
+	security_bprm_free(bprm);
 	kfree(bprm);
 }
 
--- linux-2.6.38.8.orig/include/linux/sched.h
+++ linux-2.6.38.8/include/linux/sched.h
@@ -1369,6 +1369,9 @@ struct task_struct {
 	int (*notifier)(void *priv);
 	void *notifier_data;
 	sigset_t *notifier_mask;
+#ifdef CONFIG_SECURITY
+	void *security;
+#endif
 	struct audit_context *audit_context;
 #ifdef CONFIG_AUDITSYSCALL
 	uid_t loginuid;
--- linux-2.6.38.8.orig/include/linux/security.h
+++ linux-2.6.38.8/include/linux/security.h
@@ -227,6 +227,9 @@ static inline void security_free_mnt_opt
  *	on the initial stack to the ELF interpreter to indicate whether libc
  *	should enable secure mode.
  *	@bprm contains the linux_binprm structure.
+ * @bprm_free_security:
+ *	Tell current thread that do_execve() has finished.
+ *	@bprm contains the linux_binprm structure.
  *
  * Security hooks for filesystem operations.
  *
@@ -636,6 +639,14 @@ static inline void security_free_mnt_opt
  *	manual page for definitions of the @clone_flags.
  *	@clone_flags contains the flags indicating what should be shared.
  *	Return 0 if permission is granted.
+ * @task_alloc_security:
+ *      Copy current thread's per task_struct variables to a chlid thread.
+ *      Note that the task_struct does not provide ->security field.
+ *      @p contains the task_struct for child process.
+ *      Return 0 on success, negative value otherwise.
+ * @task_free_security:
+ *      Clean up per task_struct variables.
+ *      @p contains the task_struct.
  * @cred_alloc_blank:
  *	@cred points to the credentials.
  *	@gfp indicates the atomicity of any memory allocations.
@@ -1395,6 +1406,7 @@ struct security_operations {
 	int (*bprm_secureexec) (struct linux_binprm *bprm);
 	void (*bprm_committing_creds) (struct linux_binprm *bprm);
 	void (*bprm_committed_creds) (struct linux_binprm *bprm);
+	void (*bprm_free_security) (struct linux_binprm *bprm);
 
 	int (*sb_alloc_security) (struct super_block *sb);
 	void (*sb_free_security) (struct super_block *sb);
@@ -1490,6 +1502,8 @@ struct security_operations {
 	int (*dentry_open) (struct file *file, const struct cred *cred);
 
 	int (*task_create) (unsigned long clone_flags);
+	int (*task_alloc_security) (struct task_struct *p);
+	void (*task_free_security) (struct task_struct *p);
 	int (*cred_alloc_blank) (struct cred *cred, gfp_t gfp);
 	void (*cred_free) (struct cred *cred);
 	int (*cred_prepare)(struct cred *new, const struct cred *old,
@@ -1678,6 +1692,7 @@ int security_bprm_check(struct linux_bin
 void security_bprm_committing_creds(struct linux_binprm *bprm);
 void security_bprm_committed_creds(struct linux_binprm *bprm);
 int security_bprm_secureexec(struct linux_binprm *bprm);
+void security_bprm_free(struct linux_binprm *bprm);
 int security_sb_alloc(struct super_block *sb);
 void security_sb_free(struct super_block *sb);
 int security_sb_copy_data(char *orig, char *copy);
@@ -1744,6 +1759,8 @@ int security_file_send_sigiotask(struct 
 int security_file_receive(struct file *file);
 int security_dentry_open(struct file *file, const struct cred *cred);
 int security_task_create(unsigned long clone_flags);
+int security_task_alloc(struct task_struct *p);
+void security_task_free(struct task_struct *p);
 int security_cred_alloc_blank(struct cred *cred, gfp_t gfp);
 void security_cred_free(struct cred *cred);
 int security_prepare_creds(struct cred *new, const struct cred *old, gfp_t gfp);
@@ -1951,6 +1968,10 @@ static inline int security_bprm_secureex
 	return cap_bprm_secureexec(bprm);
 }
 
+static inline void security_bprm_free(struct linux_binprm *bprm)
+{
+}
+
 static inline int security_sb_alloc(struct super_block *sb)
 {
 	return 0;
@@ -2245,6 +2266,15 @@ static inline int security_dentry_open(s
 	return 0;
 }
 
+static inline int security_task_alloc(struct task_struct *p)
+{
+	return 0;
+}
+
+static inline void security_task_free(struct task_struct *p)
+{
+}
+
 static inline int security_task_create(unsigned long clone_flags)
 {
 	return 0;
--- linux-2.6.38.8.orig/kernel/fork.c
+++ linux-2.6.38.8/kernel/fork.c
@@ -186,6 +186,7 @@ void __put_task_struct(struct task_struc
 	WARN_ON(atomic_read(&tsk->usage));
 	WARN_ON(tsk == current);
 
+	security_task_free(tsk);
 	exit_creds(tsk);
 	delayacct_tsk_free(tsk);
 	put_signal_struct(tsk->signal);
@@ -1152,8 +1153,11 @@ static struct task_struct *copy_process(
 	if (retval)
 		goto bad_fork_cleanup_policy;
 
-	if ((retval = audit_alloc(p)))
+	retval = security_task_alloc(p);
+	if (retval)
 		goto bad_fork_cleanup_policy;
+	if ((retval = audit_alloc(p)))
+		goto bad_fork_cleanup_security;
 	/* copy all the process information */
 	if ((retval = copy_semundo(clone_flags, p)))
 		goto bad_fork_cleanup_audit;
@@ -1341,6 +1345,8 @@ bad_fork_cleanup_semundo:
 	exit_sem(p);
 bad_fork_cleanup_audit:
 	audit_free(p);
+bad_fork_cleanup_security:
+	security_task_free(p);
 bad_fork_cleanup_policy:
 	perf_event_free_task(p);
 #ifdef CONFIG_NUMA
--- linux-2.6.38.8.orig/security/capability.c
+++ linux-2.6.38.8/security/capability.c
@@ -45,6 +45,10 @@ static void cap_bprm_committed_creds(str
 {
 }
 
+static void cap_bprm_free_security(struct linux_binprm *bprm)
+{
+}
+
 static int cap_sb_alloc_security(struct super_block *sb)
 {
 	return 0;
@@ -358,6 +362,15 @@ static int cap_task_create(unsigned long
 	return 0;
 }
 
+static int cap_task_alloc_security(struct task_struct *p)
+{
+	return 0;
+}
+
+static void cap_task_free_security(struct task_struct *p)
+{
+}
+
 static int cap_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 {
 	return 0;
@@ -889,6 +902,7 @@ void __init security_fixup_ops(struct se
 	set_to_cap_if_null(ops, bprm_committed_creds);
 	set_to_cap_if_null(ops, bprm_check_security);
 	set_to_cap_if_null(ops, bprm_secureexec);
+	set_to_cap_if_null(ops, bprm_free_security);
 	set_to_cap_if_null(ops, sb_alloc_security);
 	set_to_cap_if_null(ops, sb_free_security);
 	set_to_cap_if_null(ops, sb_copy_data);
@@ -954,6 +968,8 @@ void __init security_fixup_ops(struct se
 	set_to_cap_if_null(ops, file_receive);
 	set_to_cap_if_null(ops, dentry_open);
 	set_to_cap_if_null(ops, task_create);
+	set_to_cap_if_null(ops, task_alloc_security);
+	set_to_cap_if_null(ops, task_free_security);
 	set_to_cap_if_null(ops, cred_alloc_blank);
 	set_to_cap_if_null(ops, cred_free);
 	set_to_cap_if_null(ops, cred_prepare);
--- linux-2.6.38.8.orig/security/security.c
+++ linux-2.6.38.8/security/security.c
@@ -255,6 +255,11 @@ int security_bprm_secureexec(struct linu
 	return security_ops->bprm_secureexec(bprm);
 }
 
+void security_bprm_free(struct linux_binprm *bprm)
+{
+	security_ops->bprm_free_security(bprm);
+}
+
 int security_sb_alloc(struct super_block *sb)
 {
 	return security_ops->sb_alloc_security(sb);
@@ -695,6 +700,16 @@ int security_task_create(unsigned long c
 	return security_ops->task_create(clone_flags);
 }
 
+int security_task_alloc(struct task_struct *p)
+{
+	return security_ops->task_alloc_security(p);
+}
+
+void security_task_free(struct task_struct *p)
+{
+	security_ops->task_free_security(p);
+}
+
 int security_cred_alloc_blank(struct cred *cred, gfp_t gfp)
 {
 	return security_ops->cred_alloc_blank(cred, gfp);
--- linux-2.6.38.8.orig/security/tomoyo/audit.c
+++ linux-2.6.38.8/security/tomoyo/audit.c
@@ -240,7 +240,7 @@ char *tomoyo_init_log(struct tomoyo_requ
 	char *realpath = NULL;
 	const char *symlink = NULL;
 	int pos;
-	const char *domainname = r->domain->domainname->name;
+	const char *domainname = tomoyo_current_domain()->domainname->name;
 	header = tomoyo_print_header(r);
 	if (!header)
 		return NULL;
@@ -304,15 +304,13 @@ static unsigned int tomoyo_log_count;
 /**
  * tomoyo_get_audit - Get audit mode.
  *
- * @ns:          Pointer to "struct tomoyo_policy_namespace".
  * @profile:     Profile number.
  * @index:       Index number of functionality.
  * @is_granted:  True if granted log, false otherwise.
  *
  * Returns true if this request should be audited, false otherwise.
  */
-static bool tomoyo_get_audit(const struct tomoyo_policy_namespace *ns,
-			     const u8 profile, const u8 index,
+static bool tomoyo_get_audit(const u8 profile, const u8 index,
 			     const struct tomoyo_acl_info *matched_acl,
 			     const bool is_granted)
 {
@@ -322,7 +320,7 @@ static bool tomoyo_get_audit(const struc
 	struct tomoyo_profile *p;
 	if (!tomoyo_policy_loaded)
 		return false;
-	p = tomoyo_profile(ns, profile);
+	p = tomoyo_profile(profile);
 	if (tomoyo_log_count >= p->pref[TOMOYO_PREF_MAX_AUDIT_LOG])
 		return false;
 	if (is_granted && matched_acl && matched_acl->cond &&
@@ -354,8 +352,7 @@ void tomoyo_write_log2(struct tomoyo_req
 	char *buf;
 	struct tomoyo_log *entry;
 	bool quota_exceeded = false;
-	if (!tomoyo_get_audit(r->domain->ns, r->profile, r->type,
-			      r->matched_acl, r->granted))
+	if (!tomoyo_get_audit(r->profile, r->type, r->matched_acl, r->granted))
 		goto out;
 	buf = tomoyo_init_log(r, len, fmt, args);
 	if (!buf)
--- linux-2.6.38.8.orig/security/tomoyo/common.c
+++ linux-2.6.38.8/security/tomoyo/common.c
@@ -519,16 +519,15 @@ static struct tomoyo_profile *tomoyo_ass
 /**
  * tomoyo_profile - Find a profile.
  *
- * @ns:      Pointer to "struct tomoyo_policy_namespace".
  * @profile: Profile number to find.
  *
  * Returns pointer to "struct tomoyo_profile".
  */
-struct tomoyo_profile *tomoyo_profile(const struct tomoyo_policy_namespace *ns,
-				      const u8 profile)
+struct tomoyo_profile *tomoyo_profile(const u8 profile)
 {
 	static struct tomoyo_profile tomoyo_null_profile;
-	struct tomoyo_profile *ptr = ns->profile_ptr[profile];
+	struct tomoyo_profile *ptr = tomoyo_current_namespace()->
+		profile_ptr[profile];
 	if (!ptr)
 		ptr = &tomoyo_null_profile;
 	return ptr;
@@ -925,7 +924,8 @@ static bool tomoyo_manager(void)
 	struct tomoyo_manager *ptr;
 	const char *exe;
 	const struct task_struct *task = current;
-	const struct tomoyo_path_info *domainname = tomoyo_domain()->domainname;
+	const struct tomoyo_path_info *domainname =
+		tomoyo_current_domain()->domainname;
 	bool found = false;
 
 	if (!tomoyo_policy_loaded)
@@ -994,7 +994,7 @@ static bool tomoyo_select_domain(struct 
 		else
 			p = find_task_by_vpid(pid);
 		if (p)
-			domain = tomoyo_real_domain(p);
+			domain = tomoyo_task_domain(p);
 		rcu_read_unlock();
 	} else if (!strncmp(data, "domain=", 7)) {
 		if (tomoyo_domain_def(data + 7))
@@ -1672,7 +1672,7 @@ static void tomoyo_read_pid(struct tomoy
 	else
 		p = find_task_by_vpid(pid);
 	if (p)
-		domain = tomoyo_real_domain(p);
+		domain = tomoyo_task_domain(p);
 	rcu_read_unlock();
 	if (!domain)
 		return;
@@ -1933,12 +1933,11 @@ static int tomoyo_truncate(char *str)
 /**
  * tomoyo_add_entry - Add an ACL to current thread's domain. Used by learning mode.
  *
- * @domain: Pointer to "struct tomoyo_domain_info".
  * @header: Lines containing ACL.
  *
  * Returns nothing.
  */
-static void tomoyo_add_entry(struct tomoyo_domain_info *domain, char *header)
+static void tomoyo_add_entry(char *header)
 {
 	char *buffer;
 	char *realpath = NULL;
@@ -1980,9 +1979,12 @@ static void tomoyo_add_entry(struct tomo
 	if (symlink)
 		tomoyo_addprintf(buffer, len, "%s", symlink);
 	tomoyo_normalize_line(buffer);
-	if (!tomoyo_write_domain2(domain->ns, &domain->acl_info_list, buffer,
-				  false))
-		tomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);
+	{
+		struct tomoyo_domain_info *domain = tomoyo_current_domain();
+		if (!tomoyo_write_domain2(domain->ns, &domain->acl_info_list,
+					  buffer, false))
+			tomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);
+	}
 	kfree(buffer);
 }
 
@@ -2040,7 +2042,7 @@ int tomoyo_supervisor(struct tomoyo_requ
 		goto out;
 	entry.query_len = strlen(entry.query) + 1;
 	if (!error) {
-		tomoyo_add_entry(r->domain, entry.query);
+		tomoyo_add_entry(entry.query);
 		goto out;
 	}
 	len = tomoyo_round2(entry.query_len);
--- linux-2.6.38.8.orig/security/tomoyo/common.h
+++ linux-2.6.38.8/security/tomoyo/common.h
@@ -424,7 +424,6 @@ struct tomoyo_request_info {
 	 * NULL if not dealing do_execve().
 	 */
 	struct tomoyo_execve *ee;
-	struct tomoyo_domain_info *domain;
 	/* For holding parameters. */
 	union {
 		struct {
@@ -684,7 +683,6 @@ struct tomoyo_domain_info {
 	u8 group;          /* Group number to use.   */
 	bool is_deleted;   /* Delete flag.           */
 	bool flags[TOMOYO_MAX_DOMAIN_INFO_FLAGS];
-	atomic_t users; /* Number of referring credentials. */
 };
 
 /*
@@ -912,6 +910,24 @@ struct tomoyo_policy_namespace {
 	const char *name;
 };
 
+/*
+ * Structure for holding "struct tomoyo_domain_info *" for each
+ * "struct task_struct".
+ */
+struct tomoyo_security {
+	/*
+	 * Holds current thread's domain. Only current thread can modify this
+	 * member but any threads can read this member under RCU.
+	 */
+	struct tomoyo_domain_info *tomoyo_domain_info;
+	/*
+	 * Holds previous tomoyo_domain_info during do_execve() in case
+	 * do_execve() failed, NULL otherwise. Only current thread can modify
+	 * this member but any threads can compare address under RCU.
+	 */
+	struct tomoyo_domain_info *previous_domain_info;
+};
+
 /********** Function prototypes. **********/
 
 bool tomoyo_address_matches_group(const bool is_ipv6, const __be32 *address,
@@ -957,18 +973,14 @@ const struct tomoyo_path_info *tomoyo_ge
 const struct tomoyo_path_info *tomoyo_get_name(const char *name);
 const struct tomoyo_path_info *tomoyo_path_matches_group
 (const struct tomoyo_path_info *pathname, const struct tomoyo_group *group);
-int tomoyo_check_open_permission(struct tomoyo_domain_info *domain,
-				 struct path *path, const int flag);
+int tomoyo_check_open_permission(struct path *path, const int flag);
 int tomoyo_close_control(struct tomoyo_io_buffer *head);
 int tomoyo_env_perm(struct tomoyo_request_info *r, const char *env);
 int tomoyo_execute_permission(struct tomoyo_request_info *r,
 			      const struct tomoyo_path_info *filename);
 int tomoyo_find_next_domain(struct linux_binprm *bprm);
-int tomoyo_get_mode(const struct tomoyo_policy_namespace *ns, const u8 profile,
-		    const u8 index);
-int tomoyo_init_request_info(struct tomoyo_request_info *r,
-			     struct tomoyo_domain_info *domain,
-			     const u8 index);
+int tomoyo_get_mode(const u8 profile, const u8 index);
+int tomoyo_init_request_info(struct tomoyo_request_info *r, const u8 index);
 int tomoyo_mkdev_perm(const u8 operation, struct path *path,
 		      const unsigned int mode, unsigned int dev);
 int tomoyo_mount_permission(char *dev_name, struct path *path,
@@ -1025,8 +1037,7 @@ struct tomoyo_group *tomoyo_get_group(st
 				      const u8 idx);
 struct tomoyo_policy_namespace *tomoyo_assign_namespace
 (const char *domainname);
-struct tomoyo_profile *tomoyo_profile(const struct tomoyo_policy_namespace *ns,
-				      const u8 profile);
+struct tomoyo_profile *tomoyo_profile(const u8 profile);
 unsigned int tomoyo_check_flags(const struct tomoyo_domain_info *domain,
 				const u8 index);
 u8 tomoyo_parse_ulong(unsigned long *result, char **str);
@@ -1062,6 +1073,7 @@ void tomoyo_write_log2(struct tomoyo_req
 /********** External variable definitions. **********/
 
 extern bool tomoyo_policy_loaded;
+extern bool tomoyo_registered;
 extern const char * const tomoyo_condition_keyword
 [TOMOYO_MAX_CONDITION_KEYWORD];
 extern const char * const tomoyo_dif[TOMOYO_MAX_DOMAIN_INFO_FLAGS];
@@ -1197,29 +1209,6 @@ static inline void tomoyo_put_group(stru
 }
 
 /**
- * tomoyo_domain - Get "struct tomoyo_domain_info" for current thread.
- *
- * Returns pointer to "struct tomoyo_domain_info" for current thread.
- */
-static inline struct tomoyo_domain_info *tomoyo_domain(void)
-{
-	return current_cred()->security;
-}
-
-/**
- * tomoyo_real_domain - Get "struct tomoyo_domain_info" for specified thread.
- *
- * @task: Pointer to "struct task_struct".
- *
- * Returns pointer to "struct tomoyo_security" for specified thread.
- */
-static inline struct tomoyo_domain_info *tomoyo_real_domain(struct task_struct
-							    *task)
-{
-	return task_cred_xxx(task, security);
-}
-
-/**
  * tomoyo_same_name_union - Check for duplicated "struct tomoyo_name_union" entry.
  *
  * @a: Pointer to "struct tomoyo_name_union".
@@ -1265,13 +1254,52 @@ static inline bool tomoyo_same_ipaddr_un
 }
 
 /**
+ * tomoyo_current_security - Get "struct tomoyo_security" for current thread.
+ *
+ * Returns pointer to "struct tomoyo_security" for current thread.
+ */
+static inline struct tomoyo_security *tomoyo_current_security(void)
+{
+	return current->security;
+}
+
+/**
+ * tomoyo_task_domain - Get "struct tomoyo_domain_info" for specified thread.
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns pointer to "struct tomoyo_security" for specified thread.
+ */
+static inline struct tomoyo_domain_info *tomoyo_task_domain
+(struct task_struct *task)
+{
+	struct tomoyo_domain_info *domain;
+	rcu_read_lock();
+	domain = ((struct tomoyo_security *) task->security)->
+		tomoyo_domain_info;
+	rcu_read_unlock();
+	return domain;
+}
+
+/**
+ * tomoyo_current_domain - Get "struct tomoyo_domain_info" for current thread.
+ *
+ * Returns pointer to "struct tomoyo_domain_info" for current thread.
+ */
+static inline struct tomoyo_domain_info *tomoyo_current_domain(void)
+{
+	return ((struct tomoyo_security *) current->security)->
+		tomoyo_domain_info;
+}
+
+/**
  * tomoyo_current_namespace - Get "struct tomoyo_policy_namespace" for current thread.
  *
  * Returns pointer to "struct tomoyo_policy_namespace" for current thread.
  */
 static inline struct tomoyo_policy_namespace *tomoyo_current_namespace(void)
 {
-	return tomoyo_domain()->ns;
+	return tomoyo_current_domain()->ns;
 }
 
 #if defined(CONFIG_SLOB)
--- linux-2.6.38.8.orig/security/tomoyo/domain.c
+++ linux-2.6.38.8/security/tomoyo/domain.c
@@ -157,7 +157,7 @@ void tomoyo_check_acl(struct tomoyo_requ
 		      bool (*check_entry) (struct tomoyo_request_info *,
 					   const struct tomoyo_acl_info *))
 {
-	const struct tomoyo_domain_info *domain = r->domain;
+	const struct tomoyo_domain_info *domain = tomoyo_current_domain();
 	struct tomoyo_acl_info *ptr;
 	bool retried = false;
 	const struct list_head *list = &domain->acl_info_list;
@@ -504,6 +504,7 @@ static bool tomoyo_namespace_jump(const 
 struct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,
 						const bool transit)
 {
+	struct tomoyo_security *security = tomoyo_current_security();
 	struct tomoyo_domain_info e = { };
 	struct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);
 	bool created = false;
@@ -518,6 +519,7 @@ struct tomoyo_domain_info *tomoyo_assign
 			if (tomoyo_policy_loaded &&
 			    !entry->ns->profile_ptr[entry->profile])
 				return NULL;
+			security->tomoyo_domain_info = entry;
 		}
 		return entry;
 	}
@@ -542,7 +544,8 @@ struct tomoyo_domain_info *tomoyo_assign
 	 * created domains.
 	 */
 	if (transit) {
-		const struct tomoyo_domain_info *domain = tomoyo_domain();
+		const struct tomoyo_domain_info *domain =
+			tomoyo_current_domain();
 		e.profile = domain->profile;
 		e.group = domain->group;
 	}
@@ -564,10 +567,10 @@ struct tomoyo_domain_info *tomoyo_assign
 out:
 	tomoyo_put_name(e.domainname);
 	if (entry && transit) {
+		security->tomoyo_domain_info = entry;
 		if (created) {
 			struct tomoyo_request_info r;
-			tomoyo_init_request_info(&r, entry,
-						 TOMOYO_MAC_FILE_EXECUTE);
+			tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_EXECUTE);
 			r.granted = false;
 			tomoyo_write_log(&r, "use_profile %u\n",
 					 entry->profile);
@@ -600,9 +603,8 @@ static int tomoyo_environ(struct tomoyo_
 	int error = -ENOMEM;
 
 	ee->r.type = TOMOYO_MAC_ENVIRON;
-	ee->r.profile = r->domain->profile;
-	ee->r.mode = tomoyo_get_mode(r->domain->ns, ee->r.profile,
-				     TOMOYO_MAC_ENVIRON);
+	ee->r.profile = tomoyo_current_domain()->profile;
+	ee->r.mode = tomoyo_get_mode(ee->r.profile, TOMOYO_MAC_ENVIRON);
 	if (!r->mode || !envp_count)
 		return 0;
 	arg_ptr = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);
@@ -675,7 +677,8 @@ out:
  */
 int tomoyo_find_next_domain(struct linux_binprm *bprm)
 {
-	struct tomoyo_domain_info *old_domain = tomoyo_domain();
+	struct tomoyo_security *security = tomoyo_current_security();
+	struct tomoyo_domain_info *old_domain = tomoyo_current_domain();
 	struct tomoyo_domain_info *domain = NULL;
 	const char *original_name = bprm->filename;
 	int retval = -ENOMEM;
@@ -692,7 +695,7 @@ int tomoyo_find_next_domain(struct linux
 		return -ENOMEM;
 	}
 	/* ee->dump->data is allocated by tomoyo_dump_page(). */
-	tomoyo_init_request_info(&ee->r, NULL, TOMOYO_MAC_FILE_EXECUTE);
+	tomoyo_init_request_info(&ee->r, TOMOYO_MAC_FILE_EXECUTE);
 	ee->r.ee = ee;
 	ee->bprm = bprm;
 	ee->r.obj = &ee->obj;
@@ -814,6 +817,17 @@ force_child_domain:
 		break;
 	}
 force_jump_domain:
+	security->previous_domain_info = old_domain;
+	/*
+	 * Make security->previous_domain_info visible to GC before changing
+	 * security->tomoyo_domain_info.
+	 */
+	smp_wmb();
+	/*
+	 * Proceed to the next domain in order to allow checking permissions
+	 * for binary loader programs. Current thread will go back to the
+	 * previous domain if do_execve() failed.
+	 */
 	if (!domain)
 		domain = tomoyo_assign_domain(ee->tmp, true);
 	if (domain)
@@ -836,16 +850,9 @@ force_jump_domain:
 		}
 	}
  out:
-	if (!domain)
-		domain = old_domain;
-	/* Update reference count on "struct tomoyo_domain_info". */
-	atomic_inc(&domain->users);
-	bprm->cred->security = domain;
-	kfree(exename.name);
-	if (!retval) {
-		ee->r.domain = domain;
+	if (!retval)
 		retval = tomoyo_environ(ee);
-	}
+	kfree(exename.name);
 	kfree(ee->tmp);
 	kfree(ee->dump.data);
 	kfree(ee);
--- linux-2.6.38.8.orig/security/tomoyo/file.c
+++ linux-2.6.38.8/security/tomoyo/file.c
@@ -561,7 +561,7 @@ static int tomoyo_path_permission(struct
 	int error;
 
 	r->type = tomoyo_p2mac[operation];
-	r->mode = tomoyo_get_mode(r->domain->ns, r->profile, r->type);
+	r->mode = tomoyo_get_mode(r->profile, r->type);
 	if (r->mode == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	r->param_type = TOMOYO_TYPE_PATH_ACL;
@@ -593,7 +593,7 @@ int tomoyo_execute_permission(struct tom
 	 * preference.
 	 */
 	r->type = TOMOYO_MAC_FILE_EXECUTE;
-	r->mode = tomoyo_get_mode(r->domain->ns, r->profile, r->type);
+	r->mode = tomoyo_get_mode(r->profile, r->type);
 	r->param_type = TOMOYO_TYPE_PATH_ACL;
 	r->param.path.filename = filename;
 	r->param.path.operation = TOMOYO_TYPE_EXECUTE;
@@ -698,7 +698,7 @@ int tomoyo_path_number_perm(const u8 typ
 	struct tomoyo_path_info buf;
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])
+	if (tomoyo_init_request_info(&r, tomoyo_pn2mac[type])
 	    == TOMOYO_CONFIG_DISABLED || !path->dentry)
 		return 0;
 	idx = tomoyo_read_lock();
@@ -726,14 +726,12 @@ int tomoyo_path_number_perm(const u8 typ
 /**
  * tomoyo_check_open_permission - Check permission for "read" and "write".
  *
- * @domain: Pointer to "struct tomoyo_domain_info".
  * @path:   Pointer to "struct path".
  * @flag:   Flags for open().
  *
  * Returns 0 on success, negative value otherwise.
  */
-int tomoyo_check_open_permission(struct tomoyo_domain_info *domain,
-				 struct path *path, const int flag)
+int tomoyo_check_open_permission(struct path *path, const int flag)
 {
 	const u8 acc_mode = ACC_MODE(flag);
 	int error = 0;
@@ -747,8 +745,7 @@ int tomoyo_check_open_permission(struct 
 	buf.name = NULL;
 	r.mode = TOMOYO_CONFIG_DISABLED;
 	idx = tomoyo_read_lock();
-	if (acc_mode &&
-	    tomoyo_init_request_info(&r, domain, TOMOYO_MAC_FILE_OPEN)
+	if (acc_mode && tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_OPEN)
 	    != TOMOYO_CONFIG_DISABLED) {
 		if (!tomoyo_get_realpath(&buf, path)) {
 			error = -ENOMEM;
@@ -794,7 +791,7 @@ int tomoyo_path_perm(const u8 operation,
 	struct tomoyo_path_info symlink_target;
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])
+	if (tomoyo_init_request_info(&r, tomoyo_p2mac[operation])
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	is_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);
@@ -849,7 +846,7 @@ int tomoyo_mkdev_perm(const u8 operation
 	struct tomoyo_path_info buf;
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, tomoyo_pnnn2mac[operation])
+	if (tomoyo_init_request_info(&r, tomoyo_pnnn2mac[operation])
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	idx = tomoyo_read_lock();
@@ -895,7 +892,7 @@ int tomoyo_path2_perm(const u8 operation
 	};
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, tomoyo_pp2mac[operation])
+	if (tomoyo_init_request_info(&r, tomoyo_pp2mac[operation])
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	buf1.name = NULL;
--- linux-2.6.38.8.orig/security/tomoyo/gc.c
+++ linux-2.6.38.8/security/tomoyo/gc.c
@@ -232,6 +232,42 @@ static void tomoyo_del_acl(struct list_h
 }
 
 /**
+ * tomoyo_domain_used_by_task - Check whether the given pointer is referenced by a task.
+ *
+ * @domain: Pointer to "struct tomoyo_domain_info".
+ *
+ * Returns true if @domain is in use, false otherwise.
+ */
+static bool tomoyo_domain_used_by_task(struct tomoyo_domain_info *domain)
+{
+	bool in_use = false;
+	/*
+	 * Don't delete this domain if somebody is doing execve().
+	 *
+	 * Since tomoyo_find_task_security() first reverts tomoyo_domain_info
+	 * and then clears previous_domain_info, we need smp_rmb() to make sure
+	 * that GC first checks previous_domain_info and then checks
+	 * tomoyo_domain_info.
+	 */
+	struct task_struct *g;
+	struct task_struct *t;
+	rcu_read_lock();
+	do_each_thread(g, t) {
+		struct tomoyo_security *security = t->security;
+		if (security->previous_domain_info != domain) {
+			smp_rmb(); /* Avoid out of order execution. */
+			if (security->tomoyo_domain_info != domain)
+				continue;
+		}
+		in_use = true;
+		goto out;
+	} while_each_thread(g, t);
+out:
+	rcu_read_unlock();
+	return in_use;
+}
+
+/**
  * tomoyo_del_domain - Delete members in "struct tomoyo_domain_info".
  *
  * @element: Pointer to "struct list_head".
@@ -248,7 +284,8 @@ static inline void tomoyo_del_domain(str
 	struct tomoyo_acl_info *tmp;
 	/*
 	 * Since this domain is referenced from neither
-	 * "struct tomoyo_io_buffer" nor "struct cred"->security, we can delete
+	 * "struct tomoyo_io_buffer" nor
+	 * "struct tooyo_security"->tomoyo_domain_info, we can delete
 	 * elements without checking for is_deleted flag.
 	 */
 	list_for_each_entry_safe(acl, tmp, &domain->acl_info_list, list) {
@@ -433,12 +470,12 @@ static void tomoyo_try_to_gc(const enum 
 		break;
 	case TOMOYO_ID_DOMAIN:
 		/*
-		 * Don't kfree() until all "struct cred"->security forget this
-		 * element.
+		 * Don't kfree() until all "struct tomoyo_security"->
+		 * tomoyo_domain_info forget this element.
 		 */
-		if (atomic_read(&container_of
-				(element, typeof(struct tomoyo_domain_info),
-				 list)->users))
+		if (tomoyo_domain_used_by_task
+		    (container_of(element, typeof(struct tomoyo_domain_info),
+				  list)))
 			goto reinject;
 		break;
 	case TOMOYO_MAX_POLICY:
@@ -519,7 +556,8 @@ static void tomoyo_collect_entry(void)
 		list_for_each_entry_safe(domain, tmp, &tomoyo_domain_list,
 					 list) {
 			tomoyo_collect_acl(&domain->acl_info_list);
-			if (!domain->is_deleted || atomic_read(&domain->users))
+			if (!domain->is_deleted ||
+			    tomoyo_domain_used_by_task(domain))
 				continue;
 			tomoyo_try_to_gc(TOMOYO_ID_DOMAIN, &domain->list);
 		}
--- linux-2.6.38.8.orig/security/tomoyo/mount.c
+++ linux-2.6.38.8/security/tomoyo/mount.c
@@ -191,7 +191,7 @@ int tomoyo_mount_permission(char *dev_na
 	int error;
 	int idx;
 
-	if (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_MOUNT)
+	if (tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_MOUNT)
 	    == TOMOYO_CONFIG_DISABLED)
 		return 0;
 	if ((flags & MS_MGC_MSK) == MS_MGC_VAL)
--- linux-2.6.38.8.orig/security/tomoyo/network.c
+++ linux-2.6.38.8/security/tomoyo/network.c
@@ -470,7 +470,7 @@ static int tomoyo_inet_entry(const struc
 	int error = 0;
 	const u8 type = tomoyo_inet2mac[address->protocol][address->operation];
 
-	if (type && tomoyo_init_request_info(&r, NULL, type)
+	if (type && tomoyo_init_request_info(&r, type)
 	    != TOMOYO_CONFIG_DISABLED) {
 		r.param_type = TOMOYO_TYPE_INET_ACL;
 		r.param.inet_network.protocol = address->protocol;
@@ -545,7 +545,7 @@ static int tomoyo_unix_entry(const struc
 	int error = 0;
 	const u8 type = tomoyo_unix2mac[address->protocol][address->operation];
 
-	if (type && tomoyo_init_request_info(&r, NULL, type)
+	if (type && tomoyo_init_request_info(&r, type)
 	    != TOMOYO_CONFIG_DISABLED) {
 		char *buf = address->unix0.addr;
 		int len = address->unix0.addr_len - sizeof(sa_family_t);
--- linux-2.6.38.8.orig/security/tomoyo/securityfs_if.c
+++ linux-2.6.38.8/security/tomoyo/securityfs_if.c
@@ -58,32 +58,14 @@ static ssize_t tomoyo_write_self(struct 
 		name.name = data;
 		tomoyo_fill_path_info(&name);
 		/* Check "task manual_domain_transition" permission. */
-		tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_EXECUTE);
+		tomoyo_init_request_info(&r, TOMOYO_MAC_FILE_EXECUTE);
 		r.param_type = TOMOYO_TYPE_MANUAL_TASK_ACL;
 		r.param.task.domainname = &name;
 		tomoyo_check_acl(&r, tomoyo_check_task_acl);
 		if (!r.granted)
 			error = -EPERM;
-		else {
-			struct tomoyo_domain_info *new_domain =
-				tomoyo_assign_domain(data, true);
-			if (!new_domain) {
-				error = -ENOENT;
-			} else {
-				struct cred *cred = prepare_creds();
-				if (!cred) {
-					error = -ENOMEM;
-				} else {
-					struct tomoyo_domain_info *old_domain =
-						cred->security;
-					cred->security = new_domain;
-					atomic_inc(&new_domain->users);
-					atomic_dec(&old_domain->users);
-					commit_creds(cred);
-					error = 0;
-				}
-			}
-		}
+		else
+			error = tomoyo_assign_domain(data, true) ? 0 : -ENOENT;
 		tomoyo_read_unlock(idx);
 	} else
 		error = -EINVAL;
@@ -105,7 +87,7 @@ out:
 static ssize_t tomoyo_read_self(struct file *file, char __user *buf,
 				size_t count, loff_t *ppos)
 {
-	const char *domain = tomoyo_domain()->domainname->name;
+	const char *domain = tomoyo_current_domain()->domainname->name;
 	loff_t len = strlen(domain);
 	loff_t pos = *ppos;
 	if (pos >= len || !count)
@@ -241,7 +223,7 @@ static int __init tomoyo_initerface_init
 	struct dentry *tomoyo_dir;
 
 	/* Don't create securityfs entries unless registered. */
-	if (current_cred()->security != &tomoyo_kernel_domain)
+	if (!tomoyo_registered)
 		return 0;
 
 	tomoyo_dir = securityfs_create_dir("tomoyo", NULL);
--- linux-2.6.38.8.orig/security/tomoyo/tomoyo.c
+++ linux-2.6.38.8/security/tomoyo/tomoyo.c
@@ -8,135 +8,6 @@
 #include "common.h"
 
 /**
- * tomoyo_cred_alloc_blank - Target for security_cred_alloc_blank().
- *
- * @new: Pointer to "struct cred".
- * @gfp: Memory allocation flags.
- *
- * Returns 0.
- */
-static int tomoyo_cred_alloc_blank(struct cred *new, gfp_t gfp)
-{
-	new->security = NULL;
-	return 0;
-}
-
-/**
- * tomoyo_cred_prepare - Target for security_prepare_creds().
- *
- * @new: Pointer to "struct cred".
- * @old: Pointer to "struct cred".
- * @gfp: Memory allocation flags.
- *
- * Returns 0.
- */
-static int tomoyo_cred_prepare(struct cred *new, const struct cred *old,
-			       gfp_t gfp)
-{
-	struct tomoyo_domain_info *domain = old->security;
-	new->security = domain;
-	if (domain)
-		atomic_inc(&domain->users);
-	return 0;
-}
-
-/**
- * tomoyo_cred_transfer - Target for security_transfer_creds().
- *
- * @new: Pointer to "struct cred".
- * @old: Pointer to "struct cred".
- */
-static void tomoyo_cred_transfer(struct cred *new, const struct cred *old)
-{
-	tomoyo_cred_prepare(new, old, 0);
-}
-
-/**
- * tomoyo_cred_free - Target for security_cred_free().
- *
- * @cred: Pointer to "struct cred".
- */
-static void tomoyo_cred_free(struct cred *cred)
-{
-	struct tomoyo_domain_info *domain = cred->security;
-	if (domain)
-		atomic_dec(&domain->users);
-}
-
-/**
- * tomoyo_bprm_set_creds - Target for security_bprm_set_creds().
- *
- * @bprm: Pointer to "struct linux_binprm".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int tomoyo_bprm_set_creds(struct linux_binprm *bprm)
-{
-	int rc;
-
-	rc = cap_bprm_set_creds(bprm);
-	if (rc)
-		return rc;
-
-	/*
-	 * Do only if this function is called for the first time of an execve
-	 * operation.
-	 */
-	if (bprm->cred_prepared)
-		return 0;
-#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER
-	/*
-	 * Load policy if /sbin/tomoyo-init exists and /sbin/init is requested
-	 * for the first time.
-	 */
-	if (!tomoyo_policy_loaded)
-		tomoyo_load_policy(bprm->filename);
-#endif
-	/*
-	 * Release reference to "struct tomoyo_domain_info" stored inside
-	 * "bprm->cred->security". New reference to "struct tomoyo_domain_info"
-	 * stored inside "bprm->cred->security" will be acquired later inside
-	 * tomoyo_find_next_domain().
-	 */
-	atomic_dec(&((struct tomoyo_domain_info *)
-		     bprm->cred->security)->users);
-	/*
-	 * Tell tomoyo_bprm_check_security() is called for the first time of an
-	 * execve operation.
-	 */
-	bprm->cred->security = NULL;
-	return 0;
-}
-
-/**
- * tomoyo_bprm_check_security - Target for security_bprm_check().
- *
- * @bprm: Pointer to "struct linux_binprm".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int tomoyo_bprm_check_security(struct linux_binprm *bprm)
-{
-	struct tomoyo_domain_info *domain = bprm->cred->security;
-
-	/*
-	 * Execute permission is checked against pathname passed to do_execve()
-	 * using current domain.
-	 */
-	if (!domain) {
-		const int idx = tomoyo_read_lock();
-		const int err = tomoyo_find_next_domain(bprm);
-		tomoyo_read_unlock(idx);
-		return err;
-	}
-	/*
-	 * Read permission is checked against interpreters using next domain.
-	 */
-	return tomoyo_check_open_permission(domain, &bprm->file->f_path,
-					    O_RDONLY);
-}
-
-/**
  * tomoyo_inode_getattr - Target for security_inode_getattr().
  *
  * @mnt:    Pointer to "struct vfsmount".
@@ -314,7 +185,7 @@ static int tomoyo_file_fcntl(struct file
 {
 	if (!(cmd == F_SETFL && ((arg ^ file->f_flags) & O_APPEND)))
 		return 0;
-	return tomoyo_check_open_permission(tomoyo_domain(), &file->f_path,
+	return tomoyo_check_open_permission(&file->f_path,
 					    O_WRONLY | (arg & O_APPEND));
 }
 
@@ -328,11 +199,15 @@ static int tomoyo_file_fcntl(struct file
  */
 static int tomoyo_dentry_open(struct file *f, const struct cred *cred)
 {
-	int flags = f->f_flags;
-	/* Don't check read permission here if called from do_execve(). */
-	if (current->in_execve)
+	/*
+	 * Don't check read permission here if called from do_execve().
+	 * But check read permission here if called from (e.g.)
+	 * load_elf_binary().
+	 */
+	if (current->in_execve &&
+	    !tomoyo_current_security()->previous_domain_info)
 		return 0;
-	return tomoyo_check_open_permission(tomoyo_domain(), &f->f_path, flags);
+	return tomoyo_check_open_permission(&f->f_path, f->f_flags);
 }
 
 /**
@@ -500,17 +375,117 @@ static int tomoyo_socket_sendmsg(struct 
 	return tomoyo_socket_sendmsg_permission(sock, msg, size);
 }
 
+/* Security context for init_task task. */
+static struct tomoyo_security tomoyo_init_security = {
+	.tomoyo_domain_info = &tomoyo_kernel_domain,
+};
+
+/**
+ * tomoyo_task_alloc_security - Allocate memory for new tasks.
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_task_alloc_security(struct task_struct *task)
+{
+	struct tomoyo_security *old_security = current->security;
+	struct tomoyo_security *new_security = kzalloc(sizeof(*new_security),
+						       GFP_KERNEL);
+	if (!new_security)
+		return -ENOMEM;
+	*new_security = *old_security;
+	task->security = new_security;
+	return 0;
+}
+
+/**
+ * tomoyo_task_free_security - Release memory associated with "struct task_struct".
+ *
+ * @task: Pointer to "struct task_struct".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_task_free_security(struct task_struct *task)
+{
+	kfree(task->security);
+}
+
+/**
+ * tomoyo_bprm_committing_creds - A hook which is called when do_execve() succeeded.
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_bprm_committing_creds(struct linux_binprm *bprm)
+{
+	struct tomoyo_security *security = tomoyo_current_security();
+	/* do_execve() succeeded. Forget previous domain. */
+	security->previous_domain_info = NULL;
+}
+
+/**
+ * tomoyo_bprm_free_security - A hook which is called when do_execve() finished.
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ *
+ * Returns nothing.
+ */
+static void tomoyo_bprm_free_security(struct linux_binprm *bprm)
+{
+	struct tomoyo_security *security = tomoyo_current_security();
+	/*
+	 * tomoyo_bprm_committing_creds() already cleared it if do_execve()
+	 * succeeded.
+	 */
+	if (!security->previous_domain_info)
+		return;
+	/* do_execve() failed. Revert to previous domain. */
+	security->tomoyo_domain_info = security->previous_domain_info;
+	/* Make sure that GC sees valid domain. */
+	smp_wmb();
+	security->previous_domain_info = NULL;
+}
+
+/**
+ * tomoyo_bprm_check_security - Check permission for execve().
+ *
+ * @bprm: Pointer to "struct linux_binprm".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_bprm_check_security(struct linux_binprm *bprm)
+{
+	struct tomoyo_security *security;
+#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER
+	/*
+	 * Load policy if /sbin/tomoyo-init exists and /sbin/init is requested
+	 * for the first time.
+	 */
+	if (!tomoyo_policy_loaded)
+		tomoyo_load_policy(bprm->filename);
+#endif
+	security = tomoyo_current_security();
+	if (!security->previous_domain_info) {
+		const int idx = tomoyo_read_lock();
+		const int rc = tomoyo_find_next_domain(bprm);
+		tomoyo_read_unlock(idx);
+		return rc;
+	}
+	return 0;
+}
+
 /*
  * tomoyo_security_ops is a "struct security_operations" which is used for
  * registering TOMOYO.
  */
 static struct security_operations tomoyo_security_ops = {
 	.name                = "tomoyo",
-	.cred_alloc_blank    = tomoyo_cred_alloc_blank,
-	.cred_prepare        = tomoyo_cred_prepare,
-	.cred_transfer	     = tomoyo_cred_transfer,
-	.cred_free           = tomoyo_cred_free,
-	.bprm_set_creds      = tomoyo_bprm_set_creds,
+	.task_alloc_security = tomoyo_task_alloc_security,
+	.task_free_security  = tomoyo_task_free_security,
+	.bprm_committing_creds = tomoyo_bprm_committing_creds,
+	.bprm_free_security  = tomoyo_bprm_free_security,
 	.bprm_check_security = tomoyo_bprm_check_security,
 	.file_fcntl          = tomoyo_file_fcntl,
 	.dentry_open         = tomoyo_dentry_open,
@@ -539,6 +514,9 @@ static struct security_operations tomoyo
 /* Lock for GC. */
 struct srcu_struct tomoyo_ss;
 
+/* TOMOYO registered by register_security()? */
+bool tomoyo_registered;
+
 /**
  * tomoyo_init - Register TOMOYO Linux as a LSM module.
  *
@@ -546,8 +524,6 @@ struct srcu_struct tomoyo_ss;
  */
 static int __init tomoyo_init(void)
 {
-	struct cred *cred = (struct cred *) current_cred();
-
 	if (!security_module_enable(&tomoyo_security_ops))
 		return 0;
 	/* register ourselves with the security framework */
@@ -555,7 +531,8 @@ static int __init tomoyo_init(void)
 	    init_srcu_struct(&tomoyo_ss))
 		panic("Failure registering TOMOYO Linux");
 	printk(KERN_INFO "TOMOYO Linux initialized\n");
-	cred->security = &tomoyo_kernel_domain;
+	init_task.security = &tomoyo_init_security;
+	tomoyo_registered = true;
 	tomoyo_mm_init();
 	return 0;
 }
--- linux-2.6.38.8.orig/security/tomoyo/util.c
+++ linux-2.6.38.8/security/tomoyo/util.c
@@ -968,21 +968,19 @@ const char *tomoyo_get_exe(void)
 /**
  * tomoyo_get_mode - Get MAC mode.
  *
- * @ns:      Pointer to "struct tomoyo_policy_namespace".
  * @profile: Profile number.
  * @index:   Index number of functionality.
  *
  * Returns mode.
  */
-int tomoyo_get_mode(const struct tomoyo_policy_namespace *ns, const u8 profile,
-		    const u8 index)
+int tomoyo_get_mode(const u8 profile, const u8 index)
 {
 	u8 mode;
 	struct tomoyo_profile *p;
 
 	if (!tomoyo_policy_loaded)
 		return TOMOYO_CONFIG_DISABLED;
-	p = tomoyo_profile(ns, profile);
+	p = tomoyo_profile(profile);
 	mode = p->config[index];
 	if (mode == TOMOYO_CONFIG_USE_DEFAULT)
 		mode = p->config[tomoyo_index2category[index]
@@ -996,23 +994,17 @@ int tomoyo_get_mode(const struct tomoyo_
  * tomoyo_init_request_info - Initialize "struct tomoyo_request_info" members.
  *
  * @r:      Pointer to "struct tomoyo_request_info" to initialize.
- * @domain: Pointer to "struct tomoyo_domain_info". NULL for tomoyo_domain().
  * @index:  Index number of functionality.
  *
  * Returns mode.
  */
-int tomoyo_init_request_info(struct tomoyo_request_info *r,
-			     struct tomoyo_domain_info *domain, const u8 index)
+int tomoyo_init_request_info(struct tomoyo_request_info *r, const u8 index)
 {
-	u8 profile;
+	u8 profile = tomoyo_current_domain()->profile;
 	memset(r, 0, sizeof(*r));
-	if (!domain)
-		domain = tomoyo_domain();
-	r->domain = domain;
-	profile = domain->profile;
 	r->profile = profile;
 	r->type = index;
-	r->mode = tomoyo_get_mode(domain->ns, profile, index);
+	r->mode = tomoyo_get_mode(profile, index);
 	return r->mode;
 }
 
@@ -1028,7 +1020,7 @@ int tomoyo_init_request_info(struct tomo
 bool tomoyo_domain_quota_is_ok(struct tomoyo_request_info *r)
 {
 	unsigned int count = 0;
-	struct tomoyo_domain_info *domain = r->domain;
+	struct tomoyo_domain_info *domain = tomoyo_current_domain();
 	struct tomoyo_acl_info *ptr;
 
 	if (r->mode != TOMOYO_CONFIG_LEARNING)
@@ -1075,7 +1067,7 @@ bool tomoyo_domain_quota_is_ok(struct to
 			if (perm & (1 << i))
 				count++;
 	}
-	if (count < tomoyo_profile(domain->ns, domain->profile)->
+	if (count < tomoyo_profile(domain->profile)->
 	    pref[TOMOYO_PREF_MAX_LEARNING_ENTRY])
 		return true;
 	if (!domain->flags[TOMOYO_DIF_QUOTA_WARNED]) {
