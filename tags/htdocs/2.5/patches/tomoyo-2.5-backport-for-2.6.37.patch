[PATCH] TOMOYO 2.5 backport patch for Linux 2.6.37

Apply this patch after overwriting security/tomoyo/ directory by doing

 $ wget http://www.kernel.org/pub/linux/kernel/v3.0/linux-3.5.tar.bz2
 $ tar -jxf linux-3.5.tar.bz2 --strip 1 linux-3.5/security/tomoyo/

.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/gc.c       |   12 ++++++++++
 security/tomoyo/realpath.c |   53 +++++++++++++++++++++++++++++++++++----------
 security/tomoyo/tomoyo.c   |   21 ++++++++++-------
 3 files changed, 66 insertions(+), 20 deletions(-)

--- linux-2.6.37.6.orig/security/tomoyo/gc.c
+++ linux-2.6.37.6/security/tomoyo/gc.c
@@ -362,6 +362,18 @@ static inline void tomoyo_del_number_gro
 }
 
 /**
+ * __list_del_entry - Deletes entry from list without re-initialization.
+ *
+ * @entry: Pointer to "struct list_head".
+ *
+ * Returns nothing.
+ */
+static inline void __list_del_entry(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+}
+
+/**
  * tomoyo_try_to_gc - Try to kfree() an entry.
  *
  * @type:    One of values in "enum tomoyo_policy_id".
--- linux-2.6.37.6.orig/security/tomoyo/realpath.c
+++ linux-2.6.37.6/security/tomoyo/realpath.c
@@ -94,8 +94,29 @@ static char *tomoyo_get_absolute_path(st
 {
 	char *pos = ERR_PTR(-ENOMEM);
 	if (buflen >= 256) {
-		/* go to whatever namespace root we are under */
-		pos = d_absolute_path(path, buffer, buflen - 1);
+		/*
+		 * Determine whether d_absolute_path() is provided or not,
+		 * based on the type of __d_path() arguments. If the second
+		 * argument of __d_path() is "const struct path *", it means
+		 * that d_namespace_path() is provided. If the second argument
+		 * of __d_path() is "struct path *", it means that
+		 * d_namespace_path() is not provided.
+		 */
+		pos = __builtin_choose_expr
+			(__builtin_types_compatible_p
+			 (typeof(__d_path),
+			  char *(const struct path *, const struct path *,
+				 char *, int)),
+			 ({
+				 extern char *d_absolute_path
+					 (const struct path *, char *, int);
+				 d_absolute_path(path, buffer, buflen - 1);
+			 }),
+			 ({
+				 struct path ns_root = { };
+				 __d_path(path, &ns_root, buffer, buflen - 1);
+			 })
+			 );
 		if (!IS_ERR(pos) && *pos == '/' && pos[1]) {
 			struct inode *inode = path->dentry->d_inode;
 			if (inode && S_ISDIR(inode->i_mode)) {
@@ -121,17 +142,27 @@ static char *tomoyo_get_absolute_path(st
 static char *tomoyo_get_dentry_path(struct dentry *dentry, char * const buffer,
 				    const int buflen)
 {
-	char *pos = ERR_PTR(-ENOMEM);
-	if (buflen >= 256) {
-		pos = dentry_path_raw(dentry, buffer, buflen - 1);
-		if (!IS_ERR(pos) && *pos == '/' && pos[1]) {
-			struct inode *inode = dentry->d_inode;
-			if (inode && S_ISDIR(inode->i_mode)) {
-				buffer[buflen - 2] = '/';
-				buffer[buflen - 1] = '\0';
-			}
+	char *pos = buffer + buflen - 1;
+	if (buflen < 256)
+		return ERR_PTR(-ENOMEM);
+	*pos = '\0';
+	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode))
+		*--pos = '/';
+	spin_lock(&dcache_lock);
+	while (!IS_ROOT(dentry)) {
+		struct dentry *parent = dentry->d_parent;
+		const char *name = dentry->d_name.name;
+		const int len = dentry->d_name.len;
+		pos -= len;
+		if (pos <= buffer) {
+			pos = ERR_PTR(-ENOMEM);
+			break;
 		}
+		memmove(pos, name, len);
+		*--pos = '/';
+		dentry = parent;
 	}
+	spin_unlock(&dcache_lock);
 	return pos;
 }
 
--- linux-2.6.37.6.orig/security/tomoyo/tomoyo.c
+++ linux-2.6.37.6/security/tomoyo/tomoyo.c
@@ -186,7 +186,7 @@ static int tomoyo_path_unlink(struct pat
  * Returns 0 on success, negative value otherwise.
  */
 static int tomoyo_path_mkdir(struct path *parent, struct dentry *dentry,
-			     umode_t mode)
+			     int mode)
 {
 	struct path path = { parent->mnt, dentry };
 	return tomoyo_path_number_perm(TOMOYO_TYPE_MKDIR, &path,
@@ -234,7 +234,7 @@ static int tomoyo_path_symlink(struct pa
  * Returns 0 on success, negative value otherwise.
  */
 static int tomoyo_path_mknod(struct path *parent, struct dentry *dentry,
-			     umode_t mode, unsigned int dev)
+			     int mode, unsigned int dev)
 {
 	struct path path = { parent->mnt, dentry };
 	int type = TOMOYO_TYPE_CREATE;
@@ -319,14 +319,14 @@ static int tomoyo_file_fcntl(struct file
 }
 
 /**
- * tomoyo_file_open - Target for security_file_open().
+ * tomoyo_dentry_open - Target for security_dentry_open().
  *
  * @f:    Pointer to "struct file".
  * @cred: Pointer to "struct cred".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int tomoyo_file_open(struct file *f, const struct cred *cred)
+static int tomoyo_dentry_open(struct file *f, const struct cred *cred)
 {
 	int flags = f->f_flags;
 	/* Don't check read permission here if called from do_execve(). */
@@ -353,14 +353,17 @@ static int tomoyo_file_ioctl(struct file
 /**
  * tomoyo_path_chmod - Target for security_path_chmod().
  *
- * @path: Pointer to "struct path".
- * @mode: DAC permission mode.
+ * @dentry: Pointer to "struct dentry".
+ * @mnt:    Pointer to "struct vfsmount".
+ * @mode:   DAC permission mode.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int tomoyo_path_chmod(struct path *path, umode_t mode)
+static int tomoyo_path_chmod(struct dentry *dentry, struct vfsmount *mnt,
+			     mode_t mode)
 {
-	return tomoyo_path_number_perm(TOMOYO_TYPE_CHMOD, path,
+	struct path path = { mnt, dentry };
+	return tomoyo_path_number_perm(TOMOYO_TYPE_CHMOD, &path,
 				       mode & S_IALLUGO);
 }
 
@@ -510,7 +513,7 @@ static struct security_operations tomoyo
 	.bprm_set_creds      = tomoyo_bprm_set_creds,
 	.bprm_check_security = tomoyo_bprm_check_security,
 	.file_fcntl          = tomoyo_file_fcntl,
-	.file_open           = tomoyo_file_open,
+	.dentry_open         = tomoyo_dentry_open,
 	.path_truncate       = tomoyo_path_truncate,
 	.path_unlink         = tomoyo_path_unlink,
 	.path_mkdir          = tomoyo_path_mkdir,
