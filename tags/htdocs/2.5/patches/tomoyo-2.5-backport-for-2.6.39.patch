[PATCH] TOMOYO 2.5 backport patch for Linux 2.6.39

Apply this patch after overwriting security/tomoyo/ directory by doing

 $ wget http://www.kernel.org/pub/linux/kernel/v3.0/testing/linux-3.4-rc1.tar.bz2
 $ tar -jxf linux-3.4-rc1.tar.bz2 --strip 1 linux-3.4-rc1/security/tomoyo/

.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/realpath.c |   25 +++++++++++++++++++++++--
 security/tomoyo/tomoyo.c   |   15 +++++++++------
 2 files changed, 32 insertions(+), 8 deletions(-)

--- linux-2.6.39.4.orig/security/tomoyo/realpath.c
+++ linux-2.6.39.4/security/tomoyo/realpath.c
@@ -94,8 +94,29 @@ static char *tomoyo_get_absolute_path(st
 {
 	char *pos = ERR_PTR(-ENOMEM);
 	if (buflen >= 256) {
-		/* go to whatever namespace root we are under */
-		pos = d_absolute_path(path, buffer, buflen - 1);
+		/*
+		 * Determine whether d_absolute_path() is provided or not,
+		 * based on the type of __d_path() arguments. If the second
+		 * argument of __d_path() is "const struct path *", it means
+		 * that d_namespace_path() is provided. If the second argument
+		 * of __d_path() is "struct path *", it means that
+		 * d_namespace_path() is not provided.
+		 */
+		pos = __builtin_choose_expr
+			(__builtin_types_compatible_p
+			 (typeof(__d_path),
+			  char *(const struct path *, const struct path *,
+				 char *, int)),
+			 ({
+				 extern char *d_absolute_path
+					 (const struct path *, char *, int);
+				 d_absolute_path(path, buffer, buflen - 1);
+			 }),
+			 ({
+				 struct path ns_root = { };
+				 __d_path(path, &ns_root, buffer, buflen - 1);
+			 })
+			 );
 		if (!IS_ERR(pos) && *pos == '/' && pos[1]) {
 			struct inode *inode = path->dentry->d_inode;
 			if (inode && S_ISDIR(inode->i_mode)) {
--- linux-2.6.39.4.orig/security/tomoyo/tomoyo.c
+++ linux-2.6.39.4/security/tomoyo/tomoyo.c
@@ -186,7 +186,7 @@ static int tomoyo_path_unlink(struct pat
  * Returns 0 on success, negative value otherwise.
  */
 static int tomoyo_path_mkdir(struct path *parent, struct dentry *dentry,
-			     umode_t mode)
+			     int mode)
 {
 	struct path path = { parent->mnt, dentry };
 	return tomoyo_path_number_perm(TOMOYO_TYPE_MKDIR, &path,
@@ -234,7 +234,7 @@ static int tomoyo_path_symlink(struct pa
  * Returns 0 on success, negative value otherwise.
  */
 static int tomoyo_path_mknod(struct path *parent, struct dentry *dentry,
-			     umode_t mode, unsigned int dev)
+			     int mode, unsigned int dev)
 {
 	struct path path = { parent->mnt, dentry };
 	int type = TOMOYO_TYPE_CREATE;
@@ -353,14 +353,17 @@ static int tomoyo_file_ioctl(struct file
 /**
  * tomoyo_path_chmod - Target for security_path_chmod().
  *
- * @path: Pointer to "struct path".
- * @mode: DAC permission mode.
+ * @dentry: Pointer to "struct dentry".
+ * @mnt:    Pointer to "struct vfsmount".
+ * @mode:   DAC permission mode.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int tomoyo_path_chmod(struct path *path, umode_t mode)
+static int tomoyo_path_chmod(struct dentry *dentry, struct vfsmount *mnt,
+			     mode_t mode)
 {
-	return tomoyo_path_number_perm(TOMOYO_TYPE_CHMOD, path,
+	struct path path = { mnt, dentry };
+	return tomoyo_path_number_perm(TOMOYO_TYPE_CHMOD, &path,
 				       mode & S_IALLUGO);
 }
 
