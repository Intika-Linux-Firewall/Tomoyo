<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=shift_jis">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linux導入手順（保護対象限定版）</title>
<link rel="stylesheet" href="tomoyo.css" media="all" type="text/css">
</head>
<body>
<h1>TOMOYO Linux導入手順（保護対象限定版）</h1>
<p style="text-align:right;">Last modified: $Date$</p>

<h1>目次</h1>

<table border="0">
<tr><td>
<a href="#preparation">準備</a><br>
　<a href="#install-kernel">カーネルのインストール</a><br>
　<a href="#install-tool">ツールのインストール</a><br>
　<a href="#boot-test">起動テスト</a>
</td></tr><tr><td>
<a href="#policy-preparation">ポリシーの作成準備</a><br>
　<a href="#example_policy">デフォルトポリシーについて</a><br>
　<a href="#manager-programs">ポリシーの変更を許可するプログラムの指定</a><br>
　<a href="#patch-shutdown">シャットダウン処理の修正</a><br>
　<a href="#create-profiles">プロファイルの作成</a><br>
　<a href="#create-exceptions">例外ポリシーの作成</a>
</td></tr><tr><td>
<a href="#generate-policy">ポリシーの作成</a><br>
　<a href="#accept-mode-1">学習モードとチューニング</a><br>
　<a href="#accept-mode-2">学習モードで再学習</a><br>
　<a href="#permissive-mode">確認モード</a>
</td></tr><tr><td>
<a href="#production-state">ポリシーの利用</a><br>
　<a href="#enforce-mode">強制モード</a>
</td></tr>
</table>
<hr>

<h1><a name="preparation">準備</a></h1>

<p>使用するディストリビューションの制限はありません。しかし、全てのディストリビューションで共通に使える手順書を作成することはできないため、この手順書では「RedHat Linux 9」「Fedora Core 3」「Debian Sarge」の３種類について記述します。</p>

<p>不要なアプリケーションは事前にアンインストールしておくことで、ポリシーのサイズを小さくすることができます。
どのアプリケーションが必要かを事前に把握しておくことを推奨します。</p>

<h2><a name="install-kernel">カーネルのインストール</a></h2>

<p>TOMOYO Linux では、いくつかのコンパイル済みのカーネルをパッケージにして提供しています。コンパイル済みのカーネルを利用する場合は、以下のファイルをダウンロードしてインストールしてください。</p>

<table border="1">
<tr><td>
RedHat Linux 9 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.4.20-46.9.legacy_tomoyo_1.2.i386.rpm
</td></tr><tr><td>
Fedora Core 3 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.12-2.3.legacy_FC3_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Fedora Core 4 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.17-1.2142_FC4_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Fedora Core 5 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.18-1.2200_FC5_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Fedora Core 6 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.18-1.2798_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
CentOS 4.4 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-2.6.9-42.0.3.EL_tomoyo_1.2.i586.rpm
</td></tr><tr><td>
Debian Sarge （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-image-2.4.27-10sarge4-ccs_1.2_i586.deb<br>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-image-2.6.8-16sarge5-ccs_1.2_i586.deb
</td></tr><tr><td>
OpenSUSE 10.1 （80586以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/kernel-default-2.6.16.21-0.25_tomoyo_1.2.i586.rpm
</td></tr>
</table>

<p>アーキテクチャが異なる場合やカスタマイズしたい場合には、カーネルをコンパイルする必要があります。カーネルをコンパイルする方法については、<a href="compile.html">TOMOYO Linuxカーネルの作成手順</a>を参照してください。</p>

<h2><a name="install-tool">ツールのインストール</a></h2>

<p>TOMOYO Linux では、いくつかのコンパイル済みのツールを提供しています。コンパイル済みのツールを利用する場合は、以下のファイルをダウンロードして /root/ ディレクトリの下に展開してください。</p>

<table border="1">
<tr><td>
RedHat Linux 9 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-RHL9.tar.gz
</td></tr><tr><td>
Fedora Core 3 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC3.tar.gz
</td></tr><tr><td>
Fedora Core 4 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC4.tar.gz
</td></tr><tr><td>
Fedora Core 5 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC5.tar.gz
</td></tr><tr><td>
Fedora Core 6 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-FC6.tar.gz
</td></tr><tr><td>
CentOS 4.4 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-CentOS4.4.tar.gz
</td></tr><tr><td>
Debian Sarge （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-Sarge.tar.gz
</td></tr><tr><td>
OpenSUSE 10.1 （80386以降用）</td><td>
http://osdn.dl.sourceforge.jp/tomoyo/21518/ccs-tools-1.2-i386-SUSE10.1.tar.gz
</td></tr>
</table>

<p>アーキテクチャが異なる場合には、ツールをコンパイルする必要があります。ツールをコンパイルするには、以下のコマンドを実行してください。</p>

<table border="1">
<tr><td>
# TOMOYO Linux ツールのソースをダウンロードする。<br>
wget http://osdn.dl.sourceforge.jp/tomoyo/21579/ccs-tools-1.2-20060903.tar.gz<br>
# 展開する。<br>
tar -zxf ccs-tools-1.2-20060903.tar.gz<br>
# コンパイルする。<br>
make -sC ccstools/
</td></tr>
</table>

<h2><a name="boot-test">起動テスト</a></h2>

<p>TOMOYO Linux カーネルで起動して、正常に動作できることを確認できたら、 /proc/ccs/status の内容を /root/security/status.txt というファイルに保存しておいてください。このファイルに含まれる項目が、このカーネルで制御できる項目になります。このファイルは、後述する手順でプロファイルを作成する際のヒントとして使用します。</p>

<table border="1">
<tr><td>
mkdir -p /root/security<br>
cat /proc/ccs/status &gt; /root/security/status.txt
</td></tr>
</table>

<h1><a name="policy-preparation">ポリシーの作成準備</a></h1>

<p>この章の作業は通常のカーネルで行うようにしてください。<br>
TOMOYO Linux カーネルで行うと、シャットダウン時に /root/ccstools/savepolicy が実行されるために /root/security/exception_policy.txt に加えた変更内容が失われてしまいます。</p>

<h2><a name="example_policy">デフォルトポリシーについて</a></h2>
<p>TOMOYO Linux には、ソフトウェアと一緒に配布されるデフォルトポリシーはありません。学習モードを使用して策定する必要があります。<br>
参考までに、<a href="http://tomoyo.sourceforge.jp/cgi-bin/lxr/source/?v=policy-sample">サンプルのポリシー</a>を置いてあります。参照は自由ですが、デフォルトポリシーとしての利用はしないでください。</p>

<h2><a name="manager-programs">ポリシーの変更を許可するプログラムの指定</a></h2>

<p>/root/security/manager.txt を作成し、その中にポリシーの変更を許可したいプログラムを指定します。<br>
具体的には、ポリシーを再読み込みする loadpolicy 、ポリシーを編集する editpolicy 、制御レベルを変更する setlevel 、無条件読み込み許可を更新する ld-watch 、対話的にアクセス要求を許可する ccs-queryd の５つを指定してください。</p>
<table border="1">
<tr><td>
cat &gt; /root/security/manager.txt &lt;&lt; EOF<br>
/root/ccstools/loadpolicy<br>
/root/ccstools/editpolicy<br>
/root/ccstools/setlevel<br>
/root/ccstools/ld-watch<br>
/root/ccstools/ccs-queryd<br>
EOF<br></td>
</tr>
</table>

<h2><a name="patch-shutdown">シャットダウン処理の修正</a></h2>

<p>電源が切れる直前にメモリ上のポリシーをディスク上に保存するために、シャットダウンスクリプトの中で /root/ccstools/savepolicy が実行されるように修正します。具体的な修正箇所はディストリビューション毎に異なります。多くの場合、 /etc/init.d/ ディレクトリ直下にあるシャットダウンを行うスクリプトの最後に実行されるプログラムが電源を切るためのプログラムなので、その直前で保存するように修正します。</p>

<p>RedHat Linux 9 および Fedora Core 3 の場合は以下のように修正してください。</p>

<table border="1">
<tr><td colspan="2">/etc/rc.d/init.d/halt</td></tr>
<tr><td>修正前</td><td>修正後</td></tr>
<tr><td>
<br>
exec $command $HALTARGS
</td><td>
/root/ccstools/savepolicy<br>
exec $command $HALTARGS
</td></tr>
</table>

<p>Debian Sarge の場合は以下のように修正してください。 savepolicy の前に halt/reboot を一度実行しているのは halt/reboot を実行するドメインを作成するためです。</p>

<table border="1">
<tr><td colspan="2">/etc/init.d/halt</td><td colspan="2">/etc/init.d/reboot</td></tr>
<tr><td>修正前</td><td>修正後</td><td>修正前</td><td>修正後</td></tr>
<tr><td>
<br>
<br>
halt -d -f -i $poweroff $hddown
</td><td>
halt --help 2&gt; /dev/null<br>
/root/ccstools/savepolicy<br>
halt -d -f -i $poweroff $hddown
</td><td>
<br>
<br>
reboot -d -f -i
</td><td>
reboot --help 2&gt; /dev/null<br>
/root/ccstools/savepolicy<br>
reboot -d -f -i
</td></tr>
</table>

<h2><a name="create-profiles">プロファイルの作成</a></h2>

<p>TOMOYO Linuxでは、ファイル以外にもいくつかの項目について強制アクセス制御を行うことができますが、ポリシー管理の負担を減らすために、必要の無い機能を無効化できるようになっています。</p>

<p>有効にしたい機能とそのモードを記述した初期制御レベル定義ファイルを１つ以上作成し、カーネル起動時のコマンドラインから番号を指定することで切り替えができるようになっています。具体的には、カーネル起動時のコマンドラインで CCS=$INDEX （$INDEX は整数）というパラメータを指定すると、対応する /root/security/profile$INDEX.txt が読み込まれます。</p>

<p>以下の説明を参照しながら、用途毎のプロファイルを作成してください。 /root/security/status.txt に含まれる項目だけが指定可能です。 /root/security/status.txt に含まれる項目の数は、カーネルコンパイル時の設定により変化します。</p>

<table border="1">
<tr><td>項目</td><td>制御する内容</td><td>自動学習対応</td></tr>
<tr><td>MAC_FOR_FILE</td><td>ファイルの読み書き実行</td><td>○</td></tr>
<tr><td>MAX_ACCEPT_FILES</td><td>学習モードで自動的に追加されるアクセス許可の上限を指定する。</td><td>−</td></tr>
<tr><td>MAX_GRANT_LOG</td><td>メモリ上に保持するアクセス許可ログの上限を指定する。</td><td>−</td></tr>
<tr><td>MAX_REJECT_LOG</td><td>メモリ上に保持するアクセス拒否ログの上限を指定する。</td><td>−</td></tr>
<tr><td>TOMOYO_VERBOSE</td><td>ドメイン別ポリシーに対する違反を syslog に表示する。</td><td>−</td></tr>
<tr><td>MAX_ENFORCE_GRACE</td><td>強制モードでポリシー違反が発生した場合に、アクセス要求を拒否するまでの猶予時間を指定する。</td><td>−</td></tr>
</table>

<p>MAX_ACCEPT_FILES については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>任意の整数</td><td>学習モードで自動的に追加されるアクセス許可の上限。デフォルトはカーネルのコンパイル時に指定。</td></tr>
</table>

<p>MAX_GRANT_LOG および MAX_REJECT_LOG については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>任意の整数</td><td>カーネル内に保持するアクセスログの件数。デフォルトはカーネルのコンパイル時に指定。ログが不要ならば 0 を指定する。</td></tr>
</table>

<p>TOMOYO_VERBOSE については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>0</td><td>ドメイン別ポリシーに対する違反を表示しない。</td></tr>
<tr><td>1</td><td>ドメイン別ポリシーに対する違反を表示する。</td></tr>
</table>

<p>MAX_ENFORCE_GRACE については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>任意の整数</td><td>強制モードで動作中にポリシー違反が発生してから、そのアクセス要求を拒否するまでの猶予期間を秒単位で指定する。この時間内に管理者がそのアクセス要求を許可するように指示した場合、そのアクセス要求は許可される。</td></tr>
</table>

<p>上記以外については以下の値を指定できます。</p>

<table border="1">
<tr><td>値</td><td>内容</td></tr>
<tr><td>0</td><td>無効。通常のカーネルと同様に動作する。</td></tr>
<tr><td>1</td><td>学習モード。ポリシーに違反しても警告をエラーにせず、ポリシーへの自動追加を行う。</td></tr>
<tr><td>2</td><td>許容モード。ポリシーに違反してもエラーにせず、ポリシーへの自動追加も行わない。</td></tr>
<tr><td>3</td><td>強制モード。ポリシーに違反したらエラーとする。</td></tr>
</table>

<h2><a name="create-exceptions">例外ポリシーの作成</a></h2>

<p>全てのシステムに共通して存在している可能性が高いパス名のパターンを事前に登録しておきます。<br>
/root/security/exception_policy.txt に file_pattern というキーワードを使用してパス名のパターンを登録します。<br>
アクセス許可を学習する際に、要求されたパス名が file_pattern というキーワードを使用して登録されたパス名のパターンと一致した場合、パターン化されたパス名でアクセス許可が学習されます。<br>
目安としては以下のものが挙げられます。</p>

<ul>
<li>/proc/PID/ ディレクトリ以下に存在するファイルのパス名
<li>/sys/ ディレクトリ以下に存在するファイルのパス名（カーネル 2.6 系の場合のみ）
<li>/dev/ ディレクトリ以下の一部のパス名
<li>ポリシーファイルのパス名
<li>マニュアルページのパス名
<li>スプールディレクトリのパス名
<li>メールの送受信時に作成されるテンポラリファイルのパス名
<li>man コマンドが作成するテンポラリファイルのパス名
<li>mount コマンドが作成するテンポラリファイルのパス名
</ul>

<p>システムにインストールされているアプリケーションやその設定により、上記以外にもパターン化されたパス名が必要になります。不足しているパターンは実際にアクセス許可を学習させてから、適切にパターン化して追加します。</p>

<p>全てのプログラムへの読み込みアクセスを許可するファイルを登録しておきます。<br>
/root/security/exception_policy.txt に allow_read というキーワードを使用してパス名を登録します。パターンは使用できません。<br>
読み込みモードで要求されたパス名が allow_read というキーワードを使用して登録されたパス名と一致した場合、その場で読み込みアクセスが許可されます。<br>
目安としては以下のものが挙げられます。</p>

<ul>
<li>ldconfig に登録されている共有ライブラリ
<li>/proc/ ディレクトリ以下に存在するファイルの一部
<li>/usr/share/locale/ ディレクトリ以下に存在するロケールデータの一部
</ul>

<p>以上の操作を自動的に行うためのスクリプトが用意されています。以下のように実行してください。</p>

<table border="1">
<tr><td>
/root/ccstools/make_targeted_exception.sh | sort | uniq &gt; /root/security/exception_policy.txt
</td></tr>
</table>

<p>次に、強制アクセス制御を適用したいプログラムを指定します。以下のコマンドを実行すると、いくつかのプログラムが表示されます。</p>

<table border="1">
<tr><td>
/root/ccstools/make_exception.sh | grep '^initializer' | sort | uniq
</td></tr>
</table>

<p>もし、 /usr/sbin/httpd と /usr/sbin/httpd から起動されるプログラムだけを強制アクセス制御の対象としたい場合、以下のように指定してください。</p>

<table border="1">
<tr><td>
initializer /usr/sbin/httpd
</td></tr>
</table>

<p>このようにすると、 /usr/sbin/httpd および /usr/sbin/httpd から起動されるプログラムは「&lt;kernel&gt; /usr/sbin/httpd」ドメインおよびその子孫ドメインに属することで強制アクセス制御が適用されます。</p>

<p>もし、 /usr/sbin/sshd と /usr/sbin/sshd から起動されるプログラムだけを強制アクセス制御の対象としたい場合、以下のように指定してください。</p>

<table border="1">
<tr><td>
initializer /usr/sbin/sshd
</td></tr>
</table>

<p>このようにすると、 /usr/sbin/sshd および /usr/sbin/sshd から起動されるプログラムは「&lt;kernel&gt; /usr/sbin/sshd」ドメインおよびその子孫ドメインに属することで強制アクセス制御が適用されます。</p>

<h1><a name="generate-policy">ポリシーの作成</a></h1>

<h2><a name="accept-mode-1">学習モードとチューニング</a></h2>

<h3>起動方法</h3>

<p>起動時のブートプロンプトで TOMOYO Linuxカーネルを選択し、学習モード用のプロファイル番号を CCS= に指定して起動します。１回目は TOMOYO_NOLOAD パラメータも指定してください。
TOMOYO_NOLOAD というパラメータを指定すると、ドメイン単位のポリシー（domain_policy.txt）をロードしないで再起動することができます。（つまり、起動時のブートプロンプトで TOMOYO Linuxカーネルを選択し、学習モード用のプロファイル番号を CCS= に指定するのに加えて、 TOMOYO_NOLOAD も指定して起動します。）</p>

<h3>保護対象の確認</h3>

<p>以下のコマンドを実行すると、強制アクセス制御が適用されていないプロセスのＩＤの一覧が表示されます。</p>

<table border="1">
<tr><td>
cat /proc/ccs/info/trusted_pids
</td></tr>
</table>

<p>保護したいプログラムのプロセスＩＤが表示されていないことを確認してください。もし、保護したいプログラムが表示される場合、以下の手順を実行してください。</p>

<table border="1">
<tr><td>
・/root/ccstools/editpolicy e を実行する。<br>
・矢印キーで上下へ移動し、「initializer 保護したいプログラム」という行が存在しないことを確認する。例えば、 /usr/sbin/squid を保護したい場合、「initializer /usr/sbin/squid」という行が存在しないことを確認する。<br>
・a を押すと「Enter new entry&gt;」というプロンプトが表示されるので、 「initializer 保護したいプログラム」と入力し、 Enter を押す。<br>
・矢印キーで上下へ移動し、「initializer 保護したいプログラム」という行が存在していることを確認する。<br>
・q を押して終了する。<br>
・保護したいプログラムを再起動させる。<br>
・/proc/ccs/info/trusted_pids の内容を確認し、保護したいプログラムのプロセスＩＤが表示されないことを確認する。
</td></tr>
</table>

<h3>挙動の調査</h3>

<p>許可したい操作に必要なアクセス許可を学習させます。</p>

<p>１回で全てのアクセスパターンを学習できるとは限らないので、何度か繰り返します。<br>
また、起動時や終了時にのみ行われる操作も存在するため、再起動も何度か繰り返します。</p>

<p>学習モードで動作中には、以下のようなメッセージが表示される場合があります。</p>

<table border="1">
<tr><td>
TOMOYO-WARNING: Domain '&lt;kernel&gt; ...' has so many ACLs to hold. Stopped auto-append mode.
</td></tr>
</table>

<p>これは、特定のプログラムがあまりにも多くのファイルにアクセスしたものだから、メモリの浪費と応答速度の悪化を防ぐために安全装置が作動したことを知らせるメッセージです。安全装置が作動すると、このドメインに対してはファイルに対するアクセス許可がこれ以上自動的に追加されないようになります。</p>

<p>このメッセージに対処するには、手作業でアクセス許可を修正する必要があります。<br>
例えば、以下のメッセージが表示された場合、適切なパターンを利用してグループ化することで &lt;kernel&gt; /usr/sbin/hald というドメインに対するアクセス許可の数を減らす必要があります。</p>

<table border="1">
<tr><td>
TOMOYO-WARNING: Domain '&lt;kernel&gt; /usr/sbin/hald' has so many ACLs to hold. Stopped auto-append mode.
</td></tr>
</table>

<h3>パス名のパターン化</h3>

<p>以下のコマンドを実行すると、テンポラリであると思われるパス名が表示されます。</p>

<table border="1">
<tr><td>
/root/ccstools/findtemp &lt; /proc/ccs/policy/domain_policy | sort | uniq
</td></tr>
</table>

<p>適切にパターン化した上で以下の手順を実行してください。</p>

<table border="1">
<tr><td>
・/root/ccstools/editpolicy e を実行する。<br>
・矢印キーで上下へ移動し、「file_pattern パス名のパターン」という行が存在しないことを確認する。例えば、 /tmp/sh-thd-\$ というパターンを追加したい場合、「file_pattern /tmp/sh-thd-\$」という行が存在しないことを確認する。<br>
・a を押すと「Enter new entry&gt;」というプロンプトが表示されるので、 「file_pattern パス名のパターン」と入力し、 Enter を押す。<br>
・矢印キーで上下へ移動し、「file_pattern パス名のパターン」という行が存在していることを確認する。<br>
・q を押して終了する。<br>
</td></tr>
</table>

<p>テンポラリの基準としては、「最後の６文字だけが異なるパス名が複数存在している」「パス名の中の数値部分だけが異なるパス名が複数存在している」等があります。<br>
パターン化する際の例を以下に示します。これらはインストールされているアプリケーションや設定により存在しなかったり違うディレクトリに存在していたりすることがあります。</p>
<ul>
<li>file_pattern /etc/.fstab.hal.\?</li>
<li>file_pattern /etc/blkid.tab-\?\?\?\?\?\?</li>
<li>file_pattern /etc/mrtg/mrtg.cfg_l_\$</li>
<li>file_pattern /root/.emacs.d/auto-save-list/.saves-\$-\*</li>
<li>file_pattern /root/Mail/inbox/\$</li>
<li>file_pattern /tmp/auto\?\?\?\?\?\?/</li>
<li>file_pattern /tmp/autofs.\?\?\?\?\?\?</li>
<li>file_pattern /tmp/logrotate.\?\?\?\?\?\?</li>
<li>file_pattern /tmp/logwatch.\*/</li>
<li>file_pattern /tmp/logwatch.\*/\*</li>
<li>file_pattern /tmp/makewhatis\?\?\?\?\?\?/</li>
<li>file_pattern /tmp/makewhatis\?\?\?\?\?\?/w</li>
<li>file_pattern /tmp/sh-thd-\$</li>
<li>file_pattern /tmp/spamassassin-\$/</li>
<li>file_pattern /tmp/spamassassin-\$/.spamassassin/</li>
<li>file_pattern /tmp/spamassassin-\$/.spamassassin/auto-whitelist\*</li>
<li>file_pattern /tmp/whatis.\?\?\?\?\?\?</li>
<li>file_pattern /var/lib/dhcp/dhcpd.leases.\$</li>
<li>file_pattern /var/lock/autofs.\$</li>
<li>file_pattern /var/lock/mrtg/mrtg_l_\$</li>
<li>file_pattern /var/log/ksymoops/\*</li>
<li>file_pattern /var/log/sa/sa\*</li>
<li>file_pattern /var/mailman/locks/gate_news.lock.\*</li>
<li>file_pattern /var/run/gpm\?\?\?\?\?\?</li>
</ul>

<h3>アクセス許可条件の付与</h3>

<p>TOMOYO Linux 1.2 では、個々のアクセス許可に対して必要に応じて条件を付けることができます。これにより、システムアカウントのユーザＩＤに基づくアクセス制御が可能です。</p>

<p>匿名ではない FTP サーバを保護する場合、以下のように条件を付けることで、当該ユーザのホームディレクトリ以外へのアクセスを禁止することができるようになります。ホームディレクトリ以下全部を FTP でアクセス可能にすることは、侵入された場合に被害が大きくなるため、自分のホームディレクトリにある ftp ディレクトリ以下だけのアクセスを認めます。 vsftpd を用いる場合、例えば以下のように許可を与えます。</p>

<table border="1">
<tr><td>修正前</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/vsftpd<br>
<br>
6 /home/\*/ftp/\*<br>
6 /home/\*/ftp/\*/\*<br>
6 /home/\*/ftp/\*/\*/\*<br>
6 /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_mkdir /home/\*/ftp/\*/<br>
allow_mkdir /home/\*/ftp/\*/\*/<br>
allow_mkdir /home/\*/ftp/\*/\*/\*/<br>
<br>
allow_rmdir /home/\*/ftp/\*/<br>
allow_rmdir /home/\*/ftp/\*/\*/<br>
allow_rmdir /home/\*/ftp/\*/\*/\*/<br>
<br>
allow_create /home/\*/ftp/\*<br>
allow_create /home/\*/ftp/\*/\*<br>
allow_create /home/\*/ftp/\*/\*/\*<br>
allow_create /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_truncate /home/\*/ftp/\*<br>
allow_truncate /home/\*/ftp/\*/\*<br>
allow_truncate /home/\*/ftp/\*/\*/\*<br>
allow_truncate /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_unlink /home/\*/ftp/\*<br>
allow_unlink /home/\*/ftp/\*/\*<br>
allow_unlink /home/\*/ftp/\*/\*/\*<br>
allow_unlink /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/ftp/\* /home/\*/ftp/\*<br>
allow_rename /home/\*/ftp/\*/\* /home/\*/ftp/\*/\*<br>
allow_rename /home/\*/ftp/\*/\*/\* /home/\*/ftp/\*/\*/\*<br>
allow_rename /home/\*/ftp/\*/\*/\*/\* /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/ftp/\*/ /home/\*/ftp/\*/<br>
allow_rename /home/\*/ftp/\*/\*/ /home/\*/ftp/\*/\*/<br>
allow_rename /home/\*/ftp/\*/\*/\*/ /home/\*/ftp/\*/\*/\*/<br>
</td></tr>
</table>


<table border="1">
<tr><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/vsftpd<br>
<br>
6 /home/\*/ftp/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_mkdir /home/\*/ftp/\*/ if task.uid=path1.parent.uid<br>
allow_mkdir /home/\*/ftp/\*/\*/ if task.uid=path1.parent.uid<br>
allow_mkdir /home/\*/ftp/\*/\*/\*/ if task.uid=path1.parent.uid<br>
<br>
allow_rmdir /home/\*/ftp/\*/ if task.uid=path1.uid<br>
allow_rmdir /home/\*/ftp/\*/\*/ if task.uid=path1.uid<br>
allow_rmdir /home/\*/ftp/\*/\*/\*/ if task.uid=path1.uid<br>
<br>
allow_create /home/\*/ftp/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\*/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.parent.uid<br>
<br>
allow_truncate /home/\*/ftp/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_unlink /home/\*/ftp/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_rename /home/\*/ftp/\* /home/\*/ftp/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\* /home/\*/ftp/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\* /home/\*/ftp/\*/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\*/\* /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
<br>
allow_rename /home/\*/ftp/\*/ /home/\*/ftp/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/ /home/\*/ftp/\*/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\*/ /home/\*/ftp/\*/\*/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
</td></tr>
</table>

<p>Samba サーバを保護する場合、以下のように条件を付けることで、当該ユーザのホームディレクトリ以外へのアクセスを禁止することができるようになります。ホームディレクトリ以下全部を Samba でアクセス可能にすることは、侵入された場合に被害が大きくなるため、自分のホームディレクトリにある samba ディレクトリ以下だけのアクセスを認めます。</p>

<table border="1">
<tr><td>修正前</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
<br>
6 /home/\*/samba/\*<br>
6 /home/\*/samba/\*/\*<br>
6 /home/\*/samba/\*/\*/\*<br>
6 /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_mkdir /home/\*/samba/\*/<br>
allow_mkdir /home/\*/samba/\*/\*/<br>
allow_mkdir /home/\*/samba/\*/\*/\*/<br>
<br>
allow_rmdir /home/\*/samba/\*/<br>
allow_rmdir /home/\*/samba/\*/\*/<br>
allow_rmdir /home/\*/samba/\*/\*/\*/<br>
<br>
allow_create /home/\*/samba/\*<br>
allow_create /home/\*/samba/\*/\*<br>
allow_create /home/\*/samba/\*/\*/\*<br>
allow_create /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_truncate /home/\*/samba/\*<br>
allow_truncate /home/\*/samba/\*/\*<br>
allow_truncate /home/\*/samba/\*/\*/\*<br>
allow_truncate /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_unlink /home/\*/samba/\*<br>
allow_unlink /home/\*/samba/\*/\*<br>
allow_unlink /home/\*/samba/\*/\*/\*<br>
allow_unlink /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/samba/\* /home/\*/samba/\*<br>
allow_rename /home/\*/samba/\*/\* /home/\*/samba/\*/\*<br>
allow_rename /home/\*/samba/\*/\*/\* /home/\*/samba/\*/\*/\*<br>
allow_rename /home/\*/samba/\*/\*/\*/\* /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/samba/\*/ /home/\*/samba/\*/<br>
allow_rename /home/\*/samba/\*/\*/ /home/\*/samba/\*/\*/<br>
allow_rename /home/\*/samba/\*/\*/\*/ /home/\*/samba/\*/\*/\*/
</td></tr>
</table>

<table border="1">
<tr><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
<br>
6 /home/\*/samba/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_mkdir /home/\*/samba/\*/ if task.euid=path1.parent.uid<br>
allow_mkdir /home/\*/samba/\*/\*/ if task.euid=path1.parent.uid<br>
allow_mkdir /home/\*/samba/\*/\*/\*/ if task.euid=path1.parent.uid<br>
<br>
allow_rmdir /home/\*/samba/\*/ if task.euid=path1.uid<br>
allow_rmdir /home/\*/samba/\*/\*/ if task.euid=path1.uid<br>
allow_rmdir /home/\*/samba/\*/\*/\*/ if task.euid=path1.uid<br>
<br>
allow_create /home/\*/samba/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\*/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\*/\*/\* if task.euid=path1.parent.uid<br>
<br>
allow_truncate /home/\*/samba/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_unlink /home/\*/samba/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_rename /home/\*/samba/\* /home/\*/samba/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\* /home/\*/samba/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\* /home/\*/samba/\*/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\*/\* /home/\*/samba/\*/\*/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
<br>
allow_rename /home/\*/samba/\*/ /home/\*/samba/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/ /home/\*/samba/\*/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\*/ /home/\*/samba/\*/\*/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid
</td></tr>
</table>

<p>SSH サーバを保護する場合、以下のように条件を付けることで、 root ユーザとしてログインすることを禁止できます。</p>

<table border="1">
<tr><td>修正前</td><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
<br>
1 /bin/bash
</td><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
<br>
1 /bin/bash if task.uid!=0 task.euid!=0
</td></tr>
</table>

<p>指定可能な条件については<a href="policy-reference.html#conditional_acl">条件付きアクセス許可</a>を参照してください。</p>

<h3>アクセス許可のパターン化</h3>

<p>WWW サーバがアクセスするコンテンツのように、自動学習では必ずしもアクセスされないファイルに対するアクセス許可を /root/security/domain_policy.txt に追加します。<br>
以下の例では、 /usr/sbin/httpd に対して /var/www/html/ 以下の読み込みを許可しています。</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/httpd<br>
4 /var/www/html/\*<br>
4 /var/www/html/\*/\*<br>
4 /var/www/html/\*/\*/\*<br>
4 /var/www/html/\*/\*/\*/\*<br>
4 /var/www/html/\*/\*/\*/\*/\*<br></td>
</tr>
</table>

<p>同様に、パターンを使用して手作業でのグループ化を行います。<br>
以下の例では、 /usr/sbin/smbd に対して全てのログファイルを同様に扱うように指示しています。</p>

<table border="1">
<tr><td>修正前</td><td>修正後</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
2 /var/log/samba/host1.log<br>
2 /var/log/samba/host2.log<br>
2 /var/log/samba/host3.log<br>
2 /var/log/samba/host4.log<br>
2 /var/log/samba/host5.log
</td><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
2 /var/log/samba/\*.log
</td></tr>
</table>

<h2><a name="accept-mode-2">学習モードで再学習</a></h2>

<p>ドメイン別ポリシーを最初から学習しなおします。起動時のブートプロンプトで TOMOYO Linux カーネルを選択し、学習モード用のプロファイル番号を CCS= に指定して起動します。１回目は TOMOYO_NOLOAD パラメータも指定してください。</p>

<h2><a name="permissive-mode">確認モード</a></h2>

<p>起動時のブートプロンプトで TOMOYO Linux カーネルを選択し、許容モード用のプロファイル番号を CCS= に指定して起動します。</p>
<p>許可したい操作を行ってもエラーメッセージが表示されないことを確認してください。</p>
<p>正常に動作すればポリシーの完成です。</p>

<h1><a name="production-state">ポリシーの利用</a></h1>

<h2><a name="enforce-mode">強制モード</a></h2>

<p>起動時のブートプロンプトで TOMOYO Linux カーネルを選択し、強制モード用のプロファイル番号を CCS= に指定して起動します。</p>
</body>
</html>
