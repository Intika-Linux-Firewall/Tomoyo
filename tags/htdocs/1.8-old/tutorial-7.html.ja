<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linuxの世界　第７回：「いろんな機能を試してみよう」</title>
<link rel="stylesheet" href="http://tomoyo.osdn.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<p style="text-align:right;"><a href="tutorial-7.html.en">English Page</a></p>
<p style="text-align:right;">Last modified: $Date$</p>

<h1>TOMOYO Linux の世界<br>第７回：「いろんな機能を試してみよう」</h1>

<h2>今回の内容</h2>

<p>これまでの連載では，ファイルに対するアクセス制御機能について紹介してきました．ファイルに対するアクセス制御機能は，プログラムやデータへの不要なアクセスを排除する，セキュアＯＳを用いたセキュリティ強化の基本となります．しかし，この機能だけでは十分とは言えません．今回は， TOMOYO Linux が備える他のアクセス制御機能の中からネットワークに対するアクセス制御機能をはじめ主要なものを紹介します．</p>

<h2>ネットワークに対するアクセス制御機能について</h2>

<p>Linux ではデフォルトで iptables というパケットフィルタリングを行うための機能が利用できます． TOMOYO Linux でも同様の機能を提供しますが， TOMOYO Linux のネットワークに対するアクセス制御機能はドメイン単位やユーザＩＤ単位でパケットフィルタリングを行うことができ，設定も容易です． iptables の設定は構文が難しくてわからないという人でも使えます（ただし， iptables と連携しているわけではないので， iptables でしか利用できない機能もあります．）．</p>

<h3>制御可能な範囲</h3>

<p>TOMOYO Linux におけるネットワーク制御の対象について図１に示します．</p>

<table border="1" summary="fig">
<tr><td>
■図１　ネットワーク制御の対象
<pre>
（インターネットドメインソケットに関して）
Ｓｔｒｅａｍ（別名ＴＣＰ）プロトコル／Ｄａｔａｇｒａｍ（別名ＵＤＰ）プロトコル／Ｒａｗ（別名ＩＰ）プロトコル
ＩＰｖ４ネットワークアドレス／ＩＰｖ６ネットワークアドレス
ポート番号（ＳｔｒｅａｍおよびＤａｔａｇｒａｍ）／プロトコル番号（Ｒａｗ）
</pre>
<pre>
（ＵＮＩＸドメインソケットに関して）
Ｓｔｒｅａｍプロトコル／Ｄａｔａｇｒａｍプロトコル／ＳｅｑＰａｃｋｅｔプロトコル
ファイルシステム上のＵｎｉｘドメインアドレス／抽象名前空間上のＵｎｉｘドメインアドレス
</pre>
</td></tr>
</table>

<p>TOMOYO Linux のネットワークアクセス制御機能を用いると，たとえば「 /usr/sbin/sshd からログインしたユーザＩＤが 500 のユーザが実行した svn プロセスのみが，ホスト 202.221.179.11 のポート 80 に対してＴＣＰプロトコルを用いた通信を行うことができる」といった制御が可能となります．次節以降，実際に設定してみることにしましょう．</p>

<h3>準備</h3>

<p>ネットワークに対するアクセス制御はファイルに対するアクセス制御と同様にドメイン毎に指定ができます．ここでは，「ネットワークアクセス制御のみの学習」「ネットワークアクセス制御のみの確認」「ネットワークアクセス制御のみの強制」の３種類のプロファイルを作ります．</p>

<h4>(1)プロファイルの定義</h4>

<p>準備としてプロファイル５～７を作成することにします． /etc/ccs/profile.conf の末尾に図２の内容を追加してください．</p>

<table border="1" summary="fig">
<tr><td>
■図２　/etc/ccs/profile.conf の末尾に追加する内容
<pre>
5-COMMENT=Learning Mode (Network Only)
5-CONFIG::network={ mode=learning }
6-COMMENT=Permissive Mode (Network Only)
6-CONFIG::network={ mode=permissive }
7-COMMENT=Enforcing Mode (Network Only)
7-CONFIG::network={ mode=enforcing }
</pre>
</td></tr>
</table>

<p>保存したら，図３のコマンドを実行して変更を反映してください．</p>

<table border="1" summary="fig">
<tr><td>
■図３　変更を反映する
<pre>
# /usr/sbin/ccs-loadpolicy -p &lt; /etc/ccs/profile.conf
</pre>
</td></tr>
</table>

<h4>(2)学習させるドメインの決定</h4>

<p>学習させるドメインの範囲は任意ですが，今回は操作中のシェルが属しているドメイン以下を対象としましょう． /bin/bash を使用している場合、 /bin/bash のプロセスが属しているドメイン名は図４の操作を行うことで取得できます．</p>

<table border="1" summary="fig">
<tr><td>
■図４　現在の /bin/bash プロセスが属しているドメインを環境変数 SELF_DOMAIN に割り当てる
<pre>
# exec 1023&lt;/proc/ccs/self_domain
# read -u 1023 SELF_DOMAIN
# echo "$SELF_DOMAIN"
&lt;kernel&gt; /usr/sbin/sshd /bin/bash
</pre>
</td></tr>
</table>

<p>もし，現在実行中のシェルが keep_domain によりドメイン遷移を行わないように指定されていた場合は，ポリシーエディタを用いて一時的に keep_domain の指定を削除してください（ポリシーエディタで表示する際に見やすくするためであり，実環境で利用する場合には keep_domain の指定を削除する必要はありません．）．なお，学習されるＩＰアドレスやポート番号は環境により異なりますのでご了承ください．</p>

<h3>学習させてみよう</h3>

<h4>(1)クライアント側の学習</h4>

<p>図５の内容を実行し，現在のプロセスの属しているドメイン以下を学習モードにします．</p>

<table border="1" summary="fig">
<tr><td>
■図５　現在のプロセスが属しているドメイン以下を学習モードにする
<pre>
# /usr/sbin/ccs-setprofile -r 5 "$SELF_DOMAIN"
</pre>
</td></tr>
</table>

<p>学習させるためのコマンドとして，ここでは /usr/bin/curl コマンドを用いて http://www.osdn.jp/ にアクセスしてみます（図６）．</p>

<table border="1" summary="fig">
<tr><td>
■図６　/usr/bin/curl コマンドを学習させる
<pre>
# curl http://www.osdn.jp/ &gt; /dev/null
</pre>
</td></tr>
</table>

<p>なお， /usr/bin/curl コマンドが使えない場合は， /usr/bin/wget や /usr/kerberos/bin/telnet などでもかまいません．ポリシーエディタを起動して， /usr/bin/curl コマンドを実行したドメインのアクセス許可を表示してみましょう（図７）．</p>

<table border="1" summary="fig">
<tr><td>
■図７　/usr/bin/curl コマンドを実行したドメインのアクセス許可<br>
<img src="tutorial/fig-7-7.png" alt="fig-7-7.png" width="556" height="210">
</td></tr>
</table>

<p>network で始まる行が，ネットワークに対するアクセス制御のためのアクセス許可です．「 network inet dgram send 192.168.1.2 53 」および「 network inet dgram recv 192.168.1.2 53 」という部分は，ＵＤＰプロトコルを用いてＤＮＳサーバ 192.168.1.2 のポート 53 にアクセスすることを許可するという意味です．また，「 network inet stream connect 202.221.179.11 80 」という部分は，ＴＣＰプロトコルを用いてＨＴＴＰサーバ 202.221.179.11 （本稿執筆時点の www.osdn.jp のＩＰアドレスです）のポート 80 にアクセスすることを許可するという意味です．</p>

<h4>(2)サーバ側の学習</h4>

<p>今度は，/usr/bin/ssh コマンドを用いてＳＳＨサービスにログインしてみます（ＳＳＨサービスを稼動させていない場合には，ＨＴＴＰなどの他のサービスでもかまいません）．例外ポリシーで「 initialize_domain /usr/sbin/sshd 」という指定がされている場合（連載第１回で実行した init_policy によりそのように指定されているはずです）， /usr/sbin/sshd は「 &lt;kernel&gt; /usr/sbin/sshd 」というドメインで動作することになるので，そのドメインに学習用のプロファイルを割り当ててみます（図８）．</p>

<table border="1" summary="fig">
<tr><td>
■図８　&lt;kernel&gt; /usr/sbin/sshd ドメインに学習用プロファイルを割り当てる
<pre>
# /usr/sbin/ccs-setprofile 5 '&lt;kernel&gt; /usr/sbin/sshd'
</pre>
</td></tr>
</table>

<p>その後，ＳＳＨで localhost にログインし（図９），ポリシーエディタを実行して &lt;kernel&gt; /usr/sbin/sshd ドメインに対するアクセス許可を確認してください（図１０）．</p>

<table border="1" summary="fig">
<tr><td>
■図９　ＳＳＨで localhost にログイン
<pre>
# ssh localhost
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図１０　&lt;kernel&gt; /usr/sbin/sshd ドメインに対するアクセス許可<br>
<img src="tutorial/fig-7-10.png" alt="fig-7-10.png" width="556" height="274">
</td></tr>
</table>

<p>「 network inet stream accept 0:0:0:0:0:ffff:7f00:1 39044 」という部分は， 0:0:0:0:0:ffff:7f00:1 というＩＰｖ６アドレスを持つホストのポート 39044 からのＴＣＰコネクションを受け付けることを許可するという意味です．</p>

<p>ファイルに対するアクセス許可と同様に，ネットワークに対するアクセス許可にも条件を付与することができます．たとえば，図１１のようにプロセスのユーザＩＤと組み合わせることで，ユーザごとに接続可能なサーバを制限したりすることもできます．</p>

<table border="1" summary="fig">
<tr><td>
■図１１　ユーザごとに接続可能なサーバを制限
<pre>
network inet stream connect 202.221.179.11 80 task.uid=500
network inet stream connect 66.35.250.203 80 task.uid=501
</pre>
</td></tr>
</table>

<p>ＩＰソケットの場合には，ポート番号の代わりにプロトコル番号を指定します． ping コマンドを例に説明します．図１２の内容を実行してから，ポリシーエディタで ping コマンドの動作するドメインに対するアクセス許可を確認してください（図１３）．</p>

<table border="1" summary="fig">
<tr><td>
■図１２　ping コマンドを実行
<pre>
# ping -c 4 www.osdn.jp
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図１３　ping コマンドの動作するドメインに対するアクセス許可<br>
<img src="tutorial/fig-7-13.png" alt="fig-7-13.png" width="508" height="226">
</td></tr>
</table>

<p>「 network inet raw send 202.221.179.11 1 」および「 network inet raw recv 202.221.179.11 1 」というアクセス許可が与えられていることを確認できます．これは， ping コマンドが動作しているドメインではＩＰソケット上でプロトコル番号１のプロトコル（ ICMP ）を用いて 202.221.179.11 と通信を行うことを許可するという意味です．</p>

<h3>チューニングしてみよう</h3>

<p>ひととおり学習してみたら，確認モードに切り替えて確認してみましょう．確認モードにするにはプロファイル６を割り当てます（図１４）．</p>

<table border="1" summary="fig">
<tr><td>
■図１４　プロファイル６を割り当て，確認モードに切り替え
<pre>
# /usr/sbin/ccs-setprofile -r 6 "$SELF_DOMAIN"
</pre>
</td></tr>
</table>

<h4>(1)アドレスのパターン化</h4>

<p>ファイルに対するアクセス制御を行う際にワイルドカードを用いてパターン化したように，ネットワークに対するアクセス制御を行う際にもパターン化が必要になります．パターン化を行う場合は，開始アドレスと終了アドレスを-を用いて図１５のように指定してください．-の前後に空白を入れてはいけません．</p>

<table border="1" summary="fig">
<tr><td>
■図１５　ＩＰｖ４アドレスを範囲で指定する
<pre>
xxx.xxx.xxx.xxx-yyy.yyy.yyy.yyy
</pre>
</td></tr>
</table>

<p>ＩＰｖ６アドレスによる指定もＩＰｖ４アドレスの場合と同様ですが，「 :: 」という省略表記や「 . 」混じりの表記はサポートしていません．つねに図１６のような形式で指定する必要があります．その他，負荷分散のため複数のＩＰアドレスを持つサーバに対するアクセス許可を与える場合は，使う可能性のあるすべてのＩＰアドレスを指定することを忘れないでください．</p>

<table border="1" summary="fig">
<tr><td>
■図１６　ＩＰｖ６アドレスを指定する
<pre>
xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx
</pre>
</td></tr>
</table>

<h4>(2)ポート番号のパターン化</h4>

<p>サーバがクライアントからのリクエストを受け付けるためのポート番号は一般に固定されているのに対し，クライアントがリクエストを送り出すときに使用するポート番号は固定されていません．そのため，サーバ側でクライアントが使用する可能性のあるポート番号を範囲としてパターン化してやる必要があります．パターン化を行う場合は，開始ポートと終了ポートを-を用いて図１７のように指定してください．-の前後に空白を入れてはいけません．よくあるパターンは図１８の３つです．</p>

<table border="1" summary="fig">
<tr><td>
■図１７　ポート番号を範囲で指定する
<pre>
xxxxx-yyyyy
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図１８　ポート番号パターン化の例
<pre>
1024-65535
32768-61000
600-1023
</pre>
</td></tr>
</table>

<p>最初のパターンは通常のクライアントがサーバに接続する際に選択する可能性がある範囲で，おもにサーバ側のプログラムで必要になります．２番目のパターンは「 /proc/sys/net/ipv4/ip_local_port_range 」に指定されているポート番号の範囲です．通常のクライアントはこの範囲から未使用のローカルポート番号を選択してサーバに接続するため，おもにクライアント側のプログラムで必要になります．実際の /proc/sys/net/ipv4/ip_local_port_range の内容に合わせてパターンを定義してください．</p>

<p>最後のパターンは， portmap コマンドのように未使用の特権ポート（ポート番号が 1024 未満のポート）を選択して接続するプログラムで必要になります．実際に必要な範囲は異なる場合があります．パターン化が必要か否かを判断する簡単な方法は，プログラムを何度か実行してみることです．たとえば，学習モードで何度か実行すると，図１９のように，ポート番号が連続するアクセス許可が増えていきますので，その傾向から必要な範囲を推測してください．</p>

<table border="1" summary="fig">
<tr><td>
■図１９　ポート番号が連続するアクセス許可の例①
<pre>
network inet stream bind 127.0.0.1 610
network inet stream bind 127.0.0.1 611
network inet stream bind 127.0.0.1 612
network inet stream bind 127.0.0.1 613
</pre>
</td></tr>
</table>

<p>図１９の例の場合，図２０のような許可が必要である可能性が高いと言えます．</p>

<table border="1" summary="fig">
<tr><td>
■図２０　図１９を元にパターン化したアクセス許可
<pre>
network inet stream bind 127.0.0.1 600-1023
</pre>
</td></tr>
</table>

<p>また，図２１であれば，図２２または図２３という許可が必要である可能性が高いでしょう．</p>

<table border="1" summary="fig">
<tr><td>
■図２１　ポート番号が連続するアクセス許可の例②
<pre>
network inet stream accept 127.0.0.1 32780
network inet stream accept 127.0.0.1 32781
network inet stream accept 127.0.0.1 32782
network inet stream accept 127.0.0.1 32783
network inet stream accept 127.0.0.1 32784
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図２２　図２１を元にパターン化したアクセス許可
<pre>
network inet stream accept 127.0.0.1 1024-65535
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図２３　図２１を元にパターン化したアクセス許可
<pre>
network inet stream accept 127.0.0.1 32768-61000
</pre>
</td></tr>
</table>

<h3>強制してみよう</h3>

<p>確認が終わったら，実際にネットワークのアクセス制御を適用しましょう．強制モードにするにはプロファイル７を割り当てます（図２４）．</p>

<table border="1" summary="fig">
<tr><td>
■図２４　プロファイル７を割り当て，強制モードを適用
<pre>
# /usr/sbin/ccs-setprofile -r 7 "$SELF_DOMAIN"
</pre>
</td></tr>
</table>

<p>なお，プロファイル５～７はファイルに関するアクセス制御を行っていないことに注意してください．本連載の４回目で紹介した，対話的にアクセス許可を追加する ccs-queryd を用いることで，その場で不足しているアクセス許可を追加することもできます． TOMOYO Linux を使うと， iptables 単体で行えるネットワークアクセス制御の内容を細分，詳細化できることがご理解いただけると思います．</p>

<h2>ケイパビリティに対するアクセス制御機能について</h2>

<p>Linux カーネル 2.2 以降では POSIX ケイパビリティに対応しています．ケイパビリティは，セキュアＯＳの基本概念である最少権限を形にしたもので，プロセス単位で各種特権の利用について制限を加えるために用いられます． Linux で対応済みのケイパビリティについては， /usr/include/linux/capability.h の中で参照することができます．しかし， CAP_SYS_ADMIN 権限がさまざまな目的に用いられているので，そのままでは本来の効果が期待できません．そこで TOMOYO Linux では独自にケイパビリティを定義，制御しています（以下「ケイパビリティ」は TOMOYO Linux におけるケイパビリティを指します）．</p>

<p>TOMOYO Linux では POSIX とは異なる独自のケイパビリティを使用していますが，プログラムからはその存在は見えないので，プログラムに変更を加える必要はありません．バージョン 1.8.0 では図２５の操作の可否を制限することができます．</p>

<table border="1" summary="fig">
<tr><td>
■図２５　TOMOYO Linux 1.8.0 のケイパビリティ<br>
<table border="1" summary="fig">
<tr><td>値</td><td>内容</td></tr>
<tr><td>use_route</td><td>ＲＯＵＴＥソケットの使用を許可</td></tr>
<tr><td>use_packet</td><td>ＰＡＣＫＥＴソケットの使用を許可</td></tr>
<tr><td>use_kernel_module</td><td>create_module(2), init_module(2), delete_module(2) の使用を許可</td></tr>
<tr><td>SYS_REBOOT</td><td>reboot(2) の使用を許可</td></tr>
<tr><td>SYS_VHANGUP</td><td>vhangup(2) の使用を許可</td></tr>
<tr><td>SYS_TIME</td><td>stime(2), settimeofday(2), adjtimex(2) の使用を許可</td></tr>
<tr><td>SYS_NICE</td><td>nice(2), setpriority(2) の使用を許可</td></tr>
<tr><td>SYS_SETHOSTNAME</td><td>sethostname(2), setdomainname(2) の使用を許可</td></tr>
<tr><td>SYS_KEXEC_LOAD</td><td>kexec_load(2) の使用を許可</td></tr>
<tr><td>SYS_PTRACE</td><td>ptrace(2) の使用を許可</td></tr>
</table>
</td></tr>
</table>

<p>ここではシステムの時計を設定する権限（ SYS_TIME ）を例に説明します．ケイパビリティのアクセス制御の手順はネットワークに関するアクセス制御のときと同様です．まず，制限したいケイパビリティをプロファイルで指定します． /etc/ccs/profile.conf の末尾に図２６の内容を追加してください．</p>

<table border="1" summary="fig">
<tr><td>
■図２６　/etc/ccs/profile.conf の末尾に追加する内容（ケイパビリティに対するアクセス制御）
<pre>
9-CONFIG::capability::SYS_TIME={ mode=learning }
10-CONFIG::capability::SYS_TIME={ mode=enforcing }
</pre>
</td></tr>
</table>

<p>ファイルやネットワークとは異なり，ケイパビリティの場合は操作対象を指定する必要がありません．学習モードで学習させるだけで強制モードで必要なすべてのケイパビリティが与えられるので，図２６のプロファイルでは確認モードを省略しています．保存したら，図３のコマンドを実行して変更を反映してください．</p>

<p>説明のために，先に強制モード用のプロファイルを使用します（図２７）．</p>

<table border="1" summary="fig">
<tr><td>
■図２７　強制モード用プロファイルを使用
<pre>
# /usr/sbin/ccs-setprofile -r 10 "$SELF_DOMAIN"
</pre>
</td></tr>
</table>

<p>その後，システムの時計を設定します（図２８）．</p>

<table border="1" summary="fig">
<tr><td>
■図２８　システムの時計を設定する
<pre>
# date 112200002010.00
date: cannot set date: Operation not permitted
Mon Nov 22 00:00:00 JST 2010
</pre>
</td></tr>
</table>

<p>拒否されました．これは， date コマンドを実行したドメインに対して，システムの時計を変更する権限が与えられていないためです．次に，学習モード用のプロファイルを割り当てます（図２９）．</p>

<table border="1" summary="fig">
<tr><td>
■図２９　学習モード用プロファイルを使用
<pre>
# /usr/sbin/ccs-setprofile -r 9 "$SELF_DOMAIN"
</pre>
</td></tr>
</table>

<p>再度，システムの時計を設定します（図３０）．</p>

<table border="1" summary="fig">
<tr><td>
■図３０　システムの時計を設定する
<pre>
# date 112200002010.00
Mon Nov 22 00:00:00 JST 2010
</pre>
</td></tr>
</table>

<p>今度は正常に動作しました．ポリシーエディタを起動して date コマンドを実行したドメインを探し，アクセス許可を確認してください（図３１）．</p>

<table border="1" summary="fig">
<tr><td>
■図３１　capability SYS_TIME というアクセス許可が学習されている<br>
<img src="tutorial/fig-7-31.png" alt="fig-7-31.png" width="508" height="146">
</td></tr>
</table>

<p>capability SYS_TIME というアクセス許可が学習されていることを確認できます．この状態で強制モード用のプロファイルを割り当てれば，許可されていないドメインからシステムの時計を設定することを禁止できるようになります．</p>

<h2>シグナルに対するアクセス制御機能について</h2>

<p>TOMOYO Linux では，シグナルの種類と送信先を制限することができます．手順はネットワークに関するアクセス制御のときと同様です． /etc/ccs/profile.conf 末尾に図３２の内容を追加してください．</p>

<table border="1" summary="fig">
<tr><td>
■図３２　/etc/ccs/profile.conf の末尾に追加する内容（シグナルに対するアクセス制御）
<pre>
11-CONFIG::ipc::signal={ mode=learning }
12-CONFIG::ipc::signal={ mode=enforcing }
</pre>
</td></tr>
</table>

<p>保存したら，図３のコマンドを実行して変更を反映してください．</p>

<p>以降の操作は，「 &lt;kernel&gt; /usr/sbin/sshd /bin/bash 」ドメインに属しているシェル（つまり /usr/sbin/sshd からログインしたときのログインシェル）から行うものとします．事前に「 keep_domain &lt;kernel&gt; /usr/sbin/sshd /bin/bash 」という指定がされていないことを確認しておいてください．最初に， /bin/sleep コマンドを実行してください（図３３）．</p>

<table border="1" summary="fig">
<tr><td>
■図３３　/bin/sleep コマンドを実行
<pre>
# sleep 100
</pre>
</td></tr>
</table>

<p>この状態で，別の画面を開いてログインしてください．説明のために，先に強制モード用のプロファイルを割り当てます（図３４）．</p>

<table border="1" summary="fig">
<tr><td>
■図３４　強制モード用プロファイルを使用
<pre>
# /usr/sbin/ccs-setprofile -r 12 "$SELF_DOMAIN"
</pre>
</td></tr>
</table>

<p>次に，動作中の /bin/sleep コマンドのプロセスＩＤを取得し，そのプロセスＩＤに対してシグナルを送信します（図３５．シェルのビルトインではなく， /bin/kill が実行されるよう明示的に指定しています）．</p>

<table border="1" summary="fig">
<tr><td>
■図３５　/bin/sleep コマンドのプロセスＩＤに対してシグナル送信
<pre>
# pidof sleep
4649
# /bin/kill -15 4649
kill 4649: Operation not permitted
</pre>
</td></tr>
</table>

<p>拒否されました．これは， /bin/kill コマンドが動作するドメインに対して， /bin/sleep コマンドが動作するドメインへシグナルを送信する権限が与えられていないためです．次に，学習モード用のプロファイルを割り当て（図３６），再度シグナルを送信します（図３７）．</p>

<table border="1" summary="fig">
<tr><td>
■図３６　学習モード用プロファイルを使用
<pre>
# /usr/sbin/ccs-setprofile -r 11 "$SELF_DOMAIN"
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図３７　再度 /bin/sleep コマンドのプロセスＩＤに対してシグナル送信
<pre>
# /bin/kill -15 4649
</pre>
</td></tr>
</table>

<p>今度は正常に動作しました．ポリシーエディタを起動して kill コマンドを実行したドメインを探し，アクセス許可を確認してください（図３８）．</p>

<table border="1" summary="fig">
<tr><td>
■図３８　kill コマンドを実行したドメインのアクセス許可<br>
<img src="tutorial/fig-7-38.png" alt="fig-7-38.png" width="556" height="146">
</td></tr>
</table>

<p>「 ipc signal 15 &lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/sleep 」というアクセス許可が学習されていることを確認できます．これは，「 &lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/sleep 」という名前で始まるドメインに属しているプロセスに対して１５番のシグナル（ SIGTERM ）を送信することを許可するという意味です． TOMOYO Linux におけるドメイン名は &lt;kernel&gt; で始まる階層構造であるため， ipc signal 15 &lt;kernel&gt; のように指定した場合，すべてのプロセスに対して１５番のシグナルを送信することが許可されることに注意してください．例外として，シグナルの送信元が送信先と同じドメインの場合はつねに許可されます．また，０番のシグナルもつねに許可されます．</p>

<h2>次回予告</h2>

<p>今回は TOMOYO Linux のネットワークのアクセス制御機能を中心に紹介しました．通信を行うドメインを限定したうえで，強力かつ柔軟なアクセス制御を行えることがご理解いただけたと思います．次回は，ログインセッションを制限する方法についての紹介を行います．どうぞお楽しみに．</p>

<p><a href="tutorial-6.html.ja">第６回へ戻る</a>　<a href="tutorial-8.html.ja">第８回へ進む</a></p>

<hr>

<p><a href="index.html.ja#tutorial">目次へ戻る</a></p>
<p><a href="http://osdn.jp/"><img src="http://osdn.jp/sflogo.php?group_id=1973" width="96" height="31" alt="sflogo.php" title="SourceForge.jp"></a></p>
</body>
</html>
