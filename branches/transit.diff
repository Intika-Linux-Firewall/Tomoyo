Index: trunk/1.7.x/ccs-patch/README.ccs
===================================================================
--- trunk/1.7.x/ccs-patch/README.ccs	(revision 3412)
+++ trunk/1.7.x/ccs-patch/README.ccs	(working copy)
@@ -2326,3 +2326,19 @@
 
       Since 1.6.7 , /proc/ccs/grant_log was by error using next domain's name
       when auditing current domain's "execute_handler" line.
+
+Fix 2010/02/01
+
+    @ Allow domain transition without execve().
+
+      To be able to split permissions for Apache's CGI programs which are
+      executed without execve(), I added special domain transition which is
+      performed by simply writing to /proc/ccs/self_domain interface.
+
+      For example, a process which belongs to "<kernel> /usr/sbin/httpd" domain
+      will transit to "<kernel> /usr/sbin/httpd //var/www/cgi-bin/program.cgi"
+      domain by writing "/var/www/cgi-bin/program.cgi\n" to
+      /proc/ccs/self_domain using Apache's ap_hook_handler() functionality.
+      Note that prefix "/" is automatically added to requested domainname
+      so that we can distinguish domain transitions with execve() and domain
+      transitions without execve(). 
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/load_policy.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/load_policy.c	(revision 3412)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/load_policy.c	(working copy)
@@ -158,7 +158,7 @@
 		spin_unlock_irq(&task->sigmask_lock);
 	}
 #endif
-	printk(KERN_INFO "CCSecurity: 1.7.1+   2010/01/17\n");
+	printk(KERN_INFO "CCSecurity: 1.7.2-pre   2010/02/01\n");
 	ccs_check_profile();
 	printk(KERN_INFO "Mandatory Access Control activated.\n");
 }
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c	(revision 3412)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c	(working copy)
@@ -62,7 +62,7 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_audit_domain_creation_log(struct ccs_domain_info *domain)
+int ccs_audit_domain_creation_log(struct ccs_domain_info *domain)
 {
 	struct ccs_request_info r;
 	ccs_init_request_info(&r, domain, CCS_MAC_FILE_EXECUTE);
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h	(revision 3412)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -994,6 +994,7 @@
 void ccs_warn_log(struct ccs_request_info *r, const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
 void ccs_warn_oom(const char *function);
+int ccs_audit_domain_creation_log(struct ccs_domain_info *domain);
 
 /* strcmp() for "struct ccs_path_info" structure. */
 static inline bool ccs_pathcmp(const struct ccs_path_info *a,
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/proc_if.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/proc_if.c	(revision 3412)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/proc_if.c	(working copy)
@@ -214,7 +214,7 @@
 	ccs_create_entry("grant_log",        0400, ccs_dir, CCS_GRANTLOG);
 	ccs_create_entry("reject_log",       0400, ccs_dir, CCS_REJECTLOG);
 #endif
-	ccs_create_entry("self_domain",      0400, ccs_dir, CCS_SELFDOMAIN);
+	ccs_create_entry("self_domain",      0666, ccs_dir, CCS_SELFDOMAIN);
 	ccs_create_entry(".domain_status",   0600, ccs_dir, CCS_DOMAIN_STATUS);
 	ccs_create_entry(".process_status",  0600, ccs_dir, CCS_PROCESS_STATUS);
 	ccs_create_entry("meminfo",          0600, ccs_dir, CCS_MEMINFO);
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/policy_io.c	(revision 3412)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -2420,11 +2420,76 @@
 {
 	if (head->read_eof)
 		return;
-	ccs_io_printf(head, "1.7.1");
+	ccs_io_printf(head, "1.7.2-pre");
 	head->read_eof = true;
 }
 
 /**
+ * ccs_write_self_domain - Transit domain without execve().
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_self_domain(struct ccs_io_buffer *head)
+{
+	struct ccs_request_info r;
+	struct ccs_domain_info *domain = NULL;
+	char *data = head->write_buf;
+	char *domainname;
+	int idx;
+	int error = -ENOMEM;
+	head->read_eof = false;
+	head->read_avail = 0;
+	if (!ccs_is_correct_path(data, 1, -1, -1))
+		return -EINVAL;
+	idx = ccs_read_lock();
+	ccs_init_request_info(&r, NULL, CCS_MAC_FILE_EXECUTE);
+	domainname = kzalloc(CCS_EXEC_TMPSIZE, GFP_KERNEL);
+	if (!domainname)
+		goto out;
+	snprintf(domainname, CCS_EXEC_TMPSIZE - 1, "%s /%s",
+		 r.domain->domainname->name, data);
+	if (strlen(domainname) >= CCS_EXEC_TMPSIZE - 10 ||
+	    !ccs_is_correct_domain(domainname))
+		goto out;
+ retry:
+	domain = ccs_find_domain(domainname);
+	if (domain)
+		goto done;
+	if (r.mode == CCS_CONFIG_ENFORCING) {
+		int error = ccs_supervisor(&r, "# wants to create domain\n"
+					   "%s\n", domainname);
+		if (error == 1)
+			goto retry;
+		if (error < 0)
+			goto done;
+	}
+	domain = ccs_find_or_assign_new_domain(domainname, r.profile);
+	if (domain)
+		ccs_audit_domain_creation_log(domain);
+ done:
+	if (!domain) {
+		error = (r.mode == CCS_CONFIG_ENFORCING) ? -EPERM : 0;
+		if (!r.domain->domain_transition_failed) {
+			r.domain->domain_transition_failed = true;
+			ccs_write_audit_log(false, &r,
+					    CCS_KEYWORD_TRANSITION_FAILED
+					    "\n");
+			printk(KERN_WARNING "ERROR: Domain '%s' not defined.\n",
+			       domainname);
+		}
+	} else {
+		current->ccs_domain_info = domain;
+		error = 0;
+	}
+ out:
+	kfree(domainname);
+	ccs_read_unlock(idx);
+	return error;
+}
+
+/**
  * ccs_read_self_domain - Get the current process's domainname.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -2476,6 +2541,7 @@
 		break;
 #endif
 	case CCS_SELFDOMAIN: /* /proc/ccs/self_domain */
+		head->write = ccs_write_self_domain;
 		head->read = ccs_read_self_domain;
 		break;
 	case CCS_DOMAIN_STATUS: /* /proc/ccs/.domain_status */
@@ -2665,6 +2731,7 @@
 		return -EFAULT;
 	/* Don't allow updating policies by non manager programs. */
 	if (head->write != ccs_write_pid &&
+	    head->write != ccs_write_self_domain && 
 	    head->write != ccs_write_domain_policy &&
 	    !ccs_is_policy_manager())
 		return -EPERM;
