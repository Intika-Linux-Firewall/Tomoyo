Index: internal.h
===================================================================
--- internal.h	(revision 5666)
+++ internal.h	(working copy)
@@ -1397,27 +1397,17 @@
 struct ccs_io_buffer {
 	/* Exclusive lock for this structure.   */
 	struct mutex io_sem;
-	char __user *read_user_buf;
-	size_t read_user_buf_avail;
 	struct {
 		struct list_head *ns;
 		struct list_head *domain;
 		struct list_head *group;
 		struct list_head *acl;
-		size_t avail;
-		unsigned int step;
 		unsigned int query_index;
-		u16 index;
-		u16 cond_index;
 		u8 acl_group_index;
-		u8 cond_step;
-		u8 bit;
-		u8 w_pos;
 		bool eof;
 		bool print_this_domain_only;
 		bool print_transition_related_only;
-		bool print_cond_part;
-		const char *w[CCS_MAX_IO_READ_QUEUE];
+		const char *w;
 	} r;
 	struct {
 		struct ccs_policy_namespace *ns;
@@ -1429,6 +1419,13 @@
 	char *read_buf;
 	/* Size of read buffer.                 */
 	size_t readbuf_size;
+	size_t readbuf_pos;
+	bool read_paused;
+	bool read_abort;
+	bool reader_thread_started;
+	int reader_idx;
+	wait_queue_head_t read_request_wait;
+	wait_queue_head_t read_response_wait;
 	/* Buffer for writing.                  */
 	char *write_buf;
 	/* Size of write buffer.                */
Index: policy_io.c
===================================================================
--- policy_io.c	(revision 5666)
+++ policy_io.c	(working copy)
@@ -408,15 +408,12 @@
 			    struct ccs_page_dump *dump);
 static char *ccs_print_header(struct ccs_request_info *r);
 static char *ccs_read_token(struct ccs_acl_param *param);
-static void ccs_update_task_domain(struct ccs_request_info *r);
-
 static bool ccs_correct_domain(const unsigned char *domainname);
 static bool ccs_correct_path(const char *filename);
 static bool ccs_correct_word(const char *string);
 static bool ccs_correct_word2(const char *string, size_t len);
 static bool ccs_domain_def(const unsigned char *buffer);
 static bool ccs_domain_quota_ok(struct ccs_request_info *r);
-static bool ccs_flush(struct ccs_io_buffer *head);
 static bool ccs_has_more_namespace(struct ccs_io_buffer *head);
 static bool ccs_manager(void);
 static bool ccs_namespace_jump(const char *domainname);
@@ -429,18 +426,9 @@
 static bool ccs_parse_number_union(struct ccs_acl_param *param,
 				   struct ccs_number_union *ptr);
 static bool ccs_permstr(const char *string, const char *keyword);
-static bool ccs_print_condition(struct ccs_io_buffer *head,
-				const struct ccs_condition *cond);
-static bool ccs_print_entry(struct ccs_io_buffer *head,
-			    const struct ccs_acl_info *acl);
-static bool ccs_read_domain2(struct ccs_io_buffer *head,
-			     struct list_head *list);
-static bool ccs_read_group(struct ccs_io_buffer *head, const int idx);
-static bool ccs_read_policy(struct ccs_io_buffer *head, const int idx);
 static bool ccs_same_condition(const struct ccs_condition *a,
 			       const struct ccs_condition *b);
 static bool ccs_select_domain(struct ccs_io_buffer *head, const char *data);
-static bool ccs_set_lf(struct ccs_io_buffer *head);
 static bool ccs_str_starts(char **src, const char *find);
 static char *ccs_get_transit_preference(struct ccs_acl_param *param,
 					struct ccs_condition *e);
@@ -512,8 +500,6 @@
 static void ccs_check_profile(void);
 static void ccs_convert_time(time_t time, struct ccs_time *stamp);
 static void ccs_init_policy_namespace(struct ccs_policy_namespace *ns);
-static void ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
-	__printf(2, 3);
 static void ccs_normalize_line(unsigned char *buffer);
 static void ccs_print_config(struct ccs_io_buffer *head, const u8 config);
 static void ccs_print_name_union(struct ccs_io_buffer *head,
@@ -525,22 +511,34 @@
 				   const struct ccs_number_union *ptr);
 static void ccs_print_number_union_nospace(struct ccs_io_buffer *head,
 					   const struct ccs_number_union *ptr);
+static void ccs_print_condition(struct ccs_io_buffer *head,
+				const struct ccs_condition *cond);
+static void ccs_print_entry(struct ccs_io_buffer *head,
+			    const struct ccs_acl_info *acl);
+static void ccs_printf(struct ccs_io_buffer *head, const char *fmt, ...)
+	__printf(2, 3);
+static void ccs_print(struct ccs_io_buffer *head, const char *string);
+static void ccs_read_domain2(struct ccs_io_buffer *head,
+			     struct list_head *list);
+static void ccs_read_group(struct ccs_io_buffer *head, const int idx);
 static void ccs_read_domain(struct ccs_io_buffer *head);
 static void ccs_read_exception(struct ccs_io_buffer *head);
 static void ccs_read_manager(struct ccs_io_buffer *head);
 static void ccs_read_pid(struct ccs_io_buffer *head);
+static void ccs_read_policy(struct ccs_io_buffer *head, const int idx);
 static void ccs_read_profile(struct ccs_io_buffer *head);
 static void ccs_read_query(struct ccs_io_buffer *head);
 static void ccs_read_stat(struct ccs_io_buffer *head);
 static void ccs_read_version(struct ccs_io_buffer *head);
 static void ccs_set_group(struct ccs_io_buffer *head, const char *category);
+static void ccs_set_lf(struct ccs_io_buffer *head);
 static void ccs_set_namespace_cursor(struct ccs_io_buffer *head);
 static void ccs_set_slash(struct ccs_io_buffer *head);
 static void ccs_set_space(struct ccs_io_buffer *head);
-static void ccs_set_string(struct ccs_io_buffer *head, const char *string);
 static void ccs_set_uint(unsigned int *i, const char *string,
 			 const char *find);
 static void ccs_update_stat(const u8 index);
+static void ccs_update_task_domain(struct ccs_request_info *r);
 
 #ifdef CONFIG_CCSECURITY_PORTRESERVE
 static bool __ccs_lport_reserved(const u16 port);
@@ -2185,93 +2183,56 @@
 }
 
 /**
- * ccs_flush - Flush queued string to userspace's buffer.
+ * ccs_print - Print string to "struct ccs_io_buffer" structure.
  *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true if all data was flushed, false otherwise.
- */
-static bool ccs_flush(struct ccs_io_buffer *head)
-{
-	while (head->r.w_pos) {
-		const char *w = head->r.w[0];
-		size_t len = strlen(w);
-		if (len) {
-			if (len > head->read_user_buf_avail)
-				len = head->read_user_buf_avail;
-			if (!len)
-				return false;
-			if (copy_to_user(head->read_user_buf, w, len))
-				return false;
-			head->read_user_buf_avail -= len;
-			head->read_user_buf += len;
-			w += len;
-		}
-		head->r.w[0] = w;
-		if (*w)
-			return false;
-		/* Add '\0' for audit logs and query. */
-		if (head->type == CCS_AUDIT || head->type == CCS_QUERY) {
-			if (!head->read_user_buf_avail ||
-			    copy_to_user(head->read_user_buf, "", 1))
-				return false;
-			head->read_user_buf_avail--;
-			head->read_user_buf++;
-		}
-		head->r.w_pos--;
-		for (len = 0; len < head->r.w_pos; len++)
-			head->r.w[len] = head->r.w[len + 1];
-	}
-	head->r.avail = 0;
-	return true;
-}
-
-/**
- * ccs_set_string - Queue string to "struct ccs_io_buffer" structure.
- *
  * @head:   Pointer to "struct ccs_io_buffer".
  * @string: String to print.
  *
  * Returns nothing.
  *
- * Note that @string has to be kept valid until @head is kfree()d.
- * This means that char[] allocated on stack memory cannot be passed to
- * this function. Use ccs_io_printf() for char[] allocated on stack memory.
+ * Caller holds ccs_read_lock().
  */
-static void ccs_set_string(struct ccs_io_buffer *head, const char *string)
+static void ccs_print(struct ccs_io_buffer *head, const char *string)
 {
-	if (head->r.w_pos < CCS_MAX_IO_READ_QUEUE) {
-		head->r.w[head->r.w_pos++] = string;
-		ccs_flush(head);
-	} else
-		printk(KERN_WARNING "Too many words in a line.\n");
+	head->r.w = string;
+	if (head->read_abort)
+		return;
+	do {
+		while (head->readbuf_pos < head->readbuf_size && *string)
+			head->read_buf[head->readbuf_pos++] = *string++;
+		if (head->readbuf_pos == head->readbuf_size) {
+			head->read_paused = true;
+			ccs_read_unlock(head->reader_idx);
+			wake_up(&head->read_response_wait);
+			wait_event(head->read_request_wait,
+				   head->readbuf_pos < head->readbuf_size ||
+				   head->read_abort);
+			head->reader_idx = ccs_read_lock();
+			if (head->read_abort)
+				return;
+		}
+	} while (*string);
+	head->r.w = NULL;
 }
 
 /**
- * ccs_io_printf - printf() to "struct ccs_io_buffer" structure.
+ * ccs_printf - printf() to "struct ccs_io_buffer" structure.
  *
  * @head: Pointer to "struct ccs_io_buffer".
  * @fmt:  The printf()'s format string, followed by parameters.
  *
  * Returns nothing.
  */
-static void ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
+static void ccs_printf(struct ccs_io_buffer *head, const char *fmt, ...)
 {
+	char buf[128];
 	va_list args;
 	size_t len;
-	size_t pos = head->r.avail;
-	int size = head->readbuf_size - pos;
-	if (size <= 0)
-		return;
 	va_start(args, fmt);
-	len = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;
+	len = vsnprintf(buf, sizeof(buf), fmt, args) + 1;
 	va_end(args);
-	if (pos + len >= head->readbuf_size) {
-		printk(KERN_WARNING "Too many words in a line.\n");
-		return;
-	}
-	head->r.avail += len;
-	ccs_set_string(head, head->read_buf + pos);
+	if (len < sizeof(buf))
+		ccs_print(head, buf);
 }
 
 /**
@@ -2283,7 +2244,7 @@
  */
 static void ccs_set_space(struct ccs_io_buffer *head)
 {
-	ccs_set_string(head, " ");
+	ccs_print(head, " ");
 }
 
 /**
@@ -2293,10 +2254,9 @@
  *
  * Returns nothing.
  */
-static bool ccs_set_lf(struct ccs_io_buffer *head)
+static void ccs_set_lf(struct ccs_io_buffer *head)
 {
-	ccs_set_string(head, "\n");
-	return !head->r.w_pos;
+	ccs_print(head, "\n");
 }
 
 /**
@@ -2308,7 +2268,7 @@
  */
 static void ccs_set_slash(struct ccs_io_buffer *head)
 {
-	ccs_set_string(head, "/");
+	ccs_print(head, "/");
 }
 
 /**
@@ -2343,9 +2303,8 @@
 {
 	if (!ccs_namespace_enabled)
 		return;
-	ccs_set_string(head,
-		       container_of(head->r.ns, struct ccs_policy_namespace,
-				    namespace_list)->name);
+	ccs_print(head, container_of(head->r.ns, struct ccs_policy_namespace,
+				     namespace_list)->name);
 	ccs_set_space(head);
 }
 
@@ -2671,10 +2630,10 @@
  */
 static void ccs_print_config(struct ccs_io_buffer *head, const u8 config)
 {
-	ccs_io_printf(head, "={ mode=%s grant_log=%s reject_log=%s }\n",
-		      ccs_mode[config & 3],
-		      ccs_yesno(config & CCS_CONFIG_WANT_GRANT_LOG),
-		      ccs_yesno(config & CCS_CONFIG_WANT_REJECT_LOG));
+	ccs_printf(head, "={ mode=%s grant_log=%s reject_log=%s }\n",
+		   ccs_mode[config & 3],
+		   ccs_yesno(config & CCS_CONFIG_WANT_GRANT_LOG),
+		   ccs_yesno(config & CCS_CONFIG_WANT_REJECT_LOG));
 }
 
 /**
@@ -2686,88 +2645,51 @@
  */
 static void ccs_read_profile(struct ccs_io_buffer *head)
 {
-	u8 index;
+	u16 index;
 	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
 						       namespace_list);
-	const struct ccs_profile *profile;
 	if (head->r.eof)
 		return;
-next:
-	index = head->r.index;
-	profile = ns->profile_ptr[index];
-	switch (head->r.step) {
-	case 0:
+	ccs_print_namespace(head);
+	ccs_printf(head, "PROFILE_VERSION=%u\n", ns->profile_version);
+	for (index = 0; index < CCS_MAX_PROFILES; index++) {
+		u8 i;
+		const struct ccs_path_info *comment;
+		const struct ccs_profile *profile = ns->profile_ptr[index];
+		if (!profile)
+			continue;
+		comment = profile->comment;
 		ccs_print_namespace(head);
-		ccs_io_printf(head, "PROFILE_VERSION=%u\n",
-			      ns->profile_version);
-		head->r.step++;
-		break;
-	case 1:
-		for ( ; head->r.index < CCS_MAX_PROFILES; head->r.index++)
-			if (ns->profile_ptr[head->r.index])
-				break;
-		if (head->r.index == CCS_MAX_PROFILES) {
-			head->r.eof = true;
-			return;
-		}
-		head->r.step++;
-		break;
-	case 2:
-		{
-			u8 i;
-			const struct ccs_path_info *comment = profile->comment;
-			ccs_print_namespace(head);
-			ccs_io_printf(head, "%u-COMMENT=", index);
-			ccs_set_string(head, comment ? comment->name : "");
-			ccs_set_lf(head);
-			ccs_print_namespace(head);
-			ccs_io_printf(head, "%u-PREFERENCE={ ", index);
-			for (i = 0; i < CCS_MAX_PREF; i++)
-				ccs_io_printf(head, "%s=%u ",
-					      ccs_pref_keywords[i],
-					      profile->pref[i]);
-			ccs_set_string(head, "}\n");
-			head->r.step++;
-		}
-		break;
-	case 3:
-		{
-			ccs_print_namespace(head);
-			ccs_io_printf(head, "%u-%s", index, "CONFIG");
-			ccs_print_config(head, profile->default_config);
-			head->r.bit = 0;
-			head->r.step++;
-		}
-		break;
-	case 4:
-		for ( ; head->r.bit < CCS_MAX_MAC_INDEX
-			      + CCS_MAX_MAC_CATEGORY_INDEX; head->r.bit++) {
-			const u8 i = head->r.bit;
+		ccs_printf(head, "%u-COMMENT=", index);
+		ccs_print(head, comment ? comment->name : "");
+		ccs_set_lf(head);
+		ccs_print_namespace(head);
+		ccs_printf(head, "%u-PREFERENCE={ ", index);
+		for (i = 0; i < CCS_MAX_PREF; i++)
+			ccs_printf(head, "%s=%u ", ccs_pref_keywords[i],
+				   profile->pref[i]);
+		ccs_print(head, "}\n");
+		ccs_print_namespace(head);
+		ccs_printf(head, "%u-%s", index, "CONFIG");
+		ccs_print_config(head, profile->default_config);
+		for (i = 0; i < CCS_MAX_MAC_INDEX + CCS_MAX_MAC_CATEGORY_INDEX;
+		     i++) {
 			const u8 config = profile->config[i];
 			if (config == CCS_CONFIG_USE_DEFAULT)
 				continue;
 			ccs_print_namespace(head);
 			if (i < CCS_MAX_MAC_INDEX)
-				ccs_io_printf(head, "%u-CONFIG::%s::%s", index,
-					      ccs_category_keywords
-					      [ccs_index2category[i]],
-					      ccs_mac_keywords[i]);
+				ccs_printf(head, "%u-CONFIG::%s::%s", index,
+					   ccs_category_keywords
+					   [ccs_index2category[i]],
+					   ccs_mac_keywords[i]);
 			else
-				ccs_io_printf(head, "%u-CONFIG::%s", index,
-					      ccs_mac_keywords[i]);
+				ccs_printf(head, "%u-CONFIG::%s", index,
+					   ccs_mac_keywords[i]);
 			ccs_print_config(head, config);
-			head->r.bit++;
-			break;
 		}
-		if (head->r.bit == CCS_MAX_MAC_INDEX
-		    + CCS_MAX_MAC_CATEGORY_INDEX) {
-			head->r.index++;
-			head->r.step = 1;
-		}
-		break;
 	}
-	if (ccs_flush(head))
-		goto next;
+	head->r.eof = true;
 }
 
 /**
@@ -2881,9 +2803,7 @@
 			list_entry(head->r.acl, typeof(*ptr), head.list);
 		if (ptr->head.is_deleted)
 			continue;
-		if (!ccs_flush(head))
-			return;
-		ccs_set_string(head, ptr->manager->name);
+		ccs_print(head, ptr->manager->name);
 		ccs_set_lf(head);
 	}
 	head->r.eof = true;
@@ -3008,17 +2928,12 @@
 		return false;
 	head->w.domain = domain;
 	/* Accessing read_buf is safe because head->io_sem is held. */
-	if (!head->read_buf)
-		return true; /* Do nothing if open(O_WRONLY). */
 	memset(&head->r, 0, sizeof(head->r));
 	head->r.print_this_domain_only = true;
 	if (domain)
 		head->r.domain = &domain->list;
 	else
 		head->r.eof = true;
-	ccs_io_printf(head, "# select %s\n", data);
-	if (domain && domain->is_deleted)
-		ccs_set_string(head, "# This is a deleted domain.\n");
 	return true;
 }
 
@@ -3546,10 +3461,10 @@
 {
 	ccs_set_space(head);
 	if (ptr->group) {
-		ccs_set_string(head, "@");
-		ccs_set_string(head, ptr->group->group_name->name);
+		ccs_print(head, "@");
+		ccs_print(head, ptr->group->group_name->name);
 	} else {
-		ccs_set_string(head, ptr->filename->name);
+		ccs_print(head, ptr->filename->name);
 	}
 }
 
@@ -3565,12 +3480,12 @@
 					const struct ccs_name_union *ptr)
 {
 	if (ptr->group) {
-		ccs_set_string(head, "@");
-		ccs_set_string(head, ptr->group->group_name->name);
+		ccs_print(head, "@");
+		ccs_print(head, ptr->group->group_name->name);
 	} else {
-		ccs_set_string(head, "\"");
-		ccs_set_string(head, ptr->filename->name);
-		ccs_set_string(head, "\"");
+		ccs_print(head, "\"");
+		ccs_print(head, ptr->filename->name);
+		ccs_print(head, "\"");
 	}
 }
 
@@ -3586,8 +3501,8 @@
 					   const struct ccs_number_union *ptr)
 {
 	if (ptr->group) {
-		ccs_set_string(head, "@");
-		ccs_set_string(head, ptr->group->group_name->name);
+		ccs_print(head, "@");
+		ccs_print(head, ptr->group->group_name->name);
 	} else {
 		int i;
 		unsigned long min = ptr->values[0];
@@ -3617,7 +3532,7 @@
 			min_type = max_type;
 			min = max;
 		}
-		ccs_io_printf(head, "%s", buffer);
+		ccs_print(head, buffer);
 	}
 }
 
@@ -3642,142 +3557,84 @@
  * @head: Pointer to "struct ccs_io_buffer".
  * @cond: Pointer to "struct ccs_condition".
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
  */
-static bool ccs_print_condition(struct ccs_io_buffer *head,
+static void ccs_print_condition(struct ccs_io_buffer *head,
 				const struct ccs_condition *cond)
 {
-	switch (head->r.cond_step) {
-	case 0:
-		head->r.cond_index = 0;
-		head->r.cond_step++;
-		if (cond->transit && cond->exec_transit) {
-			ccs_set_space(head);
-			ccs_set_string(head, cond->transit->name);
-		}
-		/* fall through */
-	case 1:
-		{
-			const u16 condc = cond->condc;
-			const struct ccs_condition_element *condp =
-				(typeof(condp)) (cond + 1);
-			const struct ccs_number_union *numbers_p =
-				(typeof(numbers_p)) (condp + condc);
-			const struct ccs_name_union *names_p =
-				(typeof(names_p))
-				(numbers_p + cond->numbers_count);
-			const struct ccs_argv *argv =
-				(typeof(argv)) (names_p + cond->names_count);
-			const struct ccs_envp *envp =
-				(typeof(envp)) (argv + cond->argc);
-			u16 skip;
-			for (skip = 0; skip < head->r.cond_index; skip++) {
-				const u8 left = condp->left;
-				const u8 right = condp->right;
-				condp++;
-				switch (left) {
-				case CCS_ARGV_ENTRY:
-					argv++;
-					continue;
-				case CCS_ENVP_ENTRY:
-					envp++;
-					continue;
-				case CCS_NUMBER_UNION:
-					numbers_p++;
-					break;
-				}
-				switch (right) {
-				case CCS_NAME_UNION:
-					names_p++;
-					break;
-				case CCS_NUMBER_UNION:
-					numbers_p++;
-					break;
-				}
+	const u16 condc = cond->condc;
+	const struct ccs_condition_element *condp =
+		(typeof(condp)) (cond + 1);
+	const struct ccs_number_union *numbers_p =
+		(typeof(numbers_p)) (condp + condc);
+	const struct ccs_name_union *names_p =
+		(typeof(names_p))
+		(numbers_p + cond->numbers_count);
+	const struct ccs_argv *argv =
+		(typeof(argv)) (names_p + cond->names_count);
+	const struct ccs_envp *envp =
+		(typeof(envp)) (argv + cond->argc);
+	u16 i;
+	if (cond->transit && cond->exec_transit) {
+		ccs_set_space(head);
+		ccs_print(head, cond->transit->name);
+	}
+	for (i = 0; i < condc; i++) {
+		const u8 match = condp->equals;
+		const u8 left = condp->left;
+		const u8 right = condp->right;
+		condp++;
+		ccs_set_space(head);
+		switch (left) {
+		case CCS_ARGV_ENTRY:
+			ccs_printf(head, "exec.argv[%lu]%s=\"", argv->index,
+				   argv->is_not ? "!" : "");
+			ccs_print(head, argv->value->name);
+			ccs_print(head, "\"");
+			argv++;
+			continue;
+		case CCS_ENVP_ENTRY:
+			ccs_print(head, "exec.envp[\"");
+			ccs_print(head, envp->name->name);
+			ccs_printf(head, "\"]%s=", envp->is_not ? "!" : "");
+			if (envp->value) {
+				ccs_print(head, "\"");
+				ccs_print(head, envp->value->name);
+				ccs_print(head, "\"");
+			} else {
+				ccs_print(head, "NULL");
 			}
-			while (head->r.cond_index < condc) {
-				const u8 match = condp->equals;
-				const u8 left = condp->left;
-				const u8 right = condp->right;
-				if (!ccs_flush(head))
-					return false;
-				condp++;
-				head->r.cond_index++;
-				ccs_set_space(head);
-				switch (left) {
-				case CCS_ARGV_ENTRY:
-					ccs_io_printf(head,
-						      "exec.argv[%lu]%s=\"",
-						      argv->index,
-						      argv->is_not ? "!" : "");
-					ccs_set_string(head,
-						       argv->value->name);
-					ccs_set_string(head, "\"");
-					argv++;
-					continue;
-				case CCS_ENVP_ENTRY:
-					ccs_set_string(head, "exec.envp[\"");
-					ccs_set_string(head, envp->name->name);
-					ccs_io_printf(head, "\"]%s=",
-						      envp->is_not ? "!" : "");
-					if (envp->value) {
-						ccs_set_string(head, "\"");
-						ccs_set_string(head, envp->
-							       value->name);
-						ccs_set_string(head, "\"");
-					} else {
-						ccs_set_string(head, "NULL");
-					}
-					envp++;
-					continue;
-				case CCS_NUMBER_UNION:
-					ccs_print_number_union_nospace
-						(head, numbers_p++);
-					break;
-				default:
-					ccs_set_string(head,
-					       ccs_condition_keyword[left]);
-					break;
-				}
-				ccs_set_string(head, match ? "=" : "!=");
-				switch (right) {
-				case CCS_NAME_UNION:
-					ccs_print_name_union_quoted
-						(head, names_p++);
-					break;
-				case CCS_NUMBER_UNION:
-					ccs_print_number_union_nospace
-						(head, numbers_p++);
-					break;
-				default:
-					ccs_set_string(head,
-					       ccs_condition_keyword[right]);
-					break;
-				}
-			}
+			envp++;
+			continue;
+		case CCS_NUMBER_UNION:
+			ccs_print_number_union_nospace(head, numbers_p++);
+			break;
+		default:
+			ccs_print(head, ccs_condition_keyword[left]);
+			break;
 		}
-		head->r.cond_step++;
-		/* fall through */
-	case 2:
-		if (!ccs_flush(head))
+		ccs_print(head, match ? "=" : "!=");
+		switch (right) {
+		case CCS_NAME_UNION:
+			ccs_print_name_union_quoted(head, names_p++);
 			break;
-		head->r.cond_step++;
-		/* fall through */
-	case 3:
-		if (cond->grant_log != CCS_GRANTLOG_AUTO)
-			ccs_io_printf(head, " grant_log=%s",
-				      ccs_yesno(cond->grant_log ==
-						CCS_GRANTLOG_YES));
-		if (cond->transit && !cond->exec_transit) {
-			const char *name = cond->transit->name;
-			ccs_set_string(head, " auto_domain_transition=\"");
-			ccs_set_string(head, name);
-			ccs_set_string(head, "\"");
+		case CCS_NUMBER_UNION:
+			ccs_print_number_union_nospace(head, numbers_p++);
+			break;
+		default:
+			ccs_print(head, ccs_condition_keyword[right]);
+			break;
 		}
-		ccs_set_lf(head);
-		return true;
 	}
-	return false;
+	if (cond->grant_log != CCS_GRANTLOG_AUTO)
+		ccs_printf(head, " grant_log=%s",
+			   ccs_yesno(cond->grant_log == CCS_GRANTLOG_YES));
+	if (cond->transit && !cond->exec_transit) {
+		const char *name = cond->transit->name;
+		ccs_print(head, " auto_domain_transition=\"");
+		ccs_print(head, name);
+		ccs_print(head, "\"");
+	}
 }
 
 /**
@@ -3792,9 +3649,9 @@
 {
 	if (head->type == CCS_EXCEPTIONPOLICY) {
 		ccs_print_namespace(head);
-		ccs_io_printf(head, "acl_group %u ", head->r.acl_group_index);
+		ccs_printf(head, "acl_group %u ", head->r.acl_group_index);
 	}
-	ccs_set_string(head, category);
+	ccs_print(head, category);
 }
 
 /**
@@ -3803,22 +3660,18 @@
  * @head: Pointer to "struct ccs_io_buffer".
  * @acl:  Pointer to an ACL entry.
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
  */
-static bool ccs_print_entry(struct ccs_io_buffer *head,
+static void ccs_print_entry(struct ccs_io_buffer *head,
 			    const struct ccs_acl_info *acl)
 {
 	const u8 acl_type = acl->type;
 	const bool may_trigger_transition = acl->cond && acl->cond->transit;
 	bool first = true;
 	u8 bit;
-	if (head->r.print_cond_part)
-		goto print_cond_part;
 	if (acl->is_deleted)
-		return true;
-	if (!ccs_flush(head))
-		return false;
-	else if (acl_type == CCS_TYPE_PATH_ACL) {
+		return;
+	if (acl_type == CCS_TYPE_PATH_ACL) {
 		struct ccs_path_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
 		for (bit = 0; bit < CCS_MAX_PATH_OPERATION; bit++) {
@@ -3833,10 +3686,10 @@
 			} else {
 				ccs_set_slash(head);
 			}
-			ccs_set_string(head, ccs_path_keyword[bit]);
+			ccs_print(head, ccs_path_keyword[bit]);
 		}
 		if (first)
-			return true;
+			return;
 		ccs_print_name_union(head, &ptr->name);
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 	} else if (acl_type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
@@ -3844,10 +3697,9 @@
 		struct ccs_handler_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
 		ccs_set_group(head, "task ");
-		ccs_set_string(head, acl_type == CCS_TYPE_AUTO_EXECUTE_HANDLER
-			       ? "auto_execute_handler " :
-			       "denied_execute_handler ");
-		ccs_set_string(head, ptr->handler->name);
+		ccs_print(head, acl_type == CCS_TYPE_AUTO_EXECUTE_HANDLER ?
+			  "auto_execute_handler " : "denied_execute_handler ");
+		ccs_print(head, ptr->handler->name);
 #endif
 #ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
 	} else if (acl_type == CCS_TYPE_AUTO_TASK_ACL ||
@@ -3855,14 +3707,14 @@
 		struct ccs_task_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
 		ccs_set_group(head, "task ");
-		ccs_set_string(head, acl_type == CCS_TYPE_AUTO_TASK_ACL ?
-			       "auto_domain_transition " :
-			       "manual_domain_transition ");
-		ccs_set_string(head, ptr->domainname->name);
+		ccs_print(head, acl_type == CCS_TYPE_AUTO_TASK_ACL ?
+			  "auto_domain_transition " :
+			  "manual_domain_transition ");
+		ccs_print(head, ptr->domainname->name);
 #endif
 	} else if (head->r.print_transition_related_only &&
 		   !may_trigger_transition) {
-		return true;
+		return;
 	} else if (acl_type == CCS_TYPE_MKDEV_ACL) {
 		struct ccs_mkdev_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
@@ -3875,11 +3727,10 @@
 			} else {
 				ccs_set_slash(head);
 			}
-			ccs_set_string(head, ccs_mac_keywords
-				       [ccs_pnnn2mac[bit]]);
+			ccs_print(head, ccs_mac_keywords[ccs_pnnn2mac[bit]]);
 		}
 		if (first)
-			return true;
+			return;
 		ccs_print_name_union(head, &ptr->name);
 		ccs_print_number_union(head, &ptr->mode);
 		ccs_print_number_union(head, &ptr->major);
@@ -3896,11 +3747,10 @@
 			} else {
 				ccs_set_slash(head);
 			}
-			ccs_set_string(head, ccs_mac_keywords
-				       [ccs_pp2mac[bit]]);
+			ccs_print(head, ccs_mac_keywords[ccs_pp2mac[bit]]);
 		}
 		if (first)
-			return true;
+			return;
 		ccs_print_name_union(head, &ptr->name1);
 		ccs_print_name_union(head, &ptr->name2);
 	} else if (acl_type == CCS_TYPE_PATH_NUMBER_ACL) {
@@ -3915,11 +3765,10 @@
 			} else {
 				ccs_set_slash(head);
 			}
-			ccs_set_string(head, ccs_mac_keywords
-				       [ccs_pn2mac[bit]]);
+			ccs_print(head, ccs_mac_keywords[ccs_pn2mac[bit]]);
 		}
 		if (first)
-			return true;
+			return;
 		ccs_print_name_union(head, &ptr->name);
 		ccs_print_number_union(head, &ptr->number);
 #ifdef CONFIG_CCSECURITY_MISC
@@ -3927,15 +3776,14 @@
 		struct ccs_env_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
 		ccs_set_group(head, "misc env ");
-		ccs_set_string(head, ptr->env->name);
+		ccs_print(head, ptr->env->name);
 #endif
 #ifdef CONFIG_CCSECURITY_CAPABILITY
 	} else if (acl_type == CCS_TYPE_CAPABILITY_ACL) {
 		struct ccs_capability_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
 		ccs_set_group(head, "capability ");
-		ccs_set_string(head, ccs_mac_keywords
-			       [ccs_c2mac[ptr->operation]]);
+		ccs_print(head, ccs_mac_keywords[ccs_c2mac[ptr->operation]]);
 #endif
 #ifdef CONFIG_CCSECURITY_NETWORK
 	} else if (acl_type == CCS_TYPE_INET_ACL) {
@@ -3946,26 +3794,25 @@
 				continue;
 			if (first) {
 				ccs_set_group(head, "network inet ");
-				ccs_set_string(head, ccs_proto_keyword
-					       [ptr->protocol]);
+				ccs_print(head, ccs_proto_keyword
+					  [ptr->protocol]);
 				ccs_set_space(head);
 				first = false;
 			} else {
 				ccs_set_slash(head);
 			}
-			ccs_set_string(head, ccs_socket_keyword[bit]);
+			ccs_print(head, ccs_socket_keyword[bit]);
 		}
 		if (first)
-			return true;
+			return;
 		ccs_set_space(head);
 		if (ptr->address.group) {
-			ccs_set_string(head, "@");
-			ccs_set_string(head,
-				       ptr->address.group->group_name->name);
+			ccs_print(head, "@");
+			ccs_print(head, ptr->address.group->group_name->name);
 		} else {
 			char buf[128];
 			ccs_print_ip(buf, sizeof(buf), &ptr->address);
-			ccs_io_printf(head, "%s", buf);
+			ccs_print(head, buf);
 		}
 		ccs_print_number_union(head, &ptr->port);
 	} else if (acl_type == CCS_TYPE_UNIX_ACL) {
@@ -3976,17 +3823,17 @@
 				continue;
 			if (first) {
 				ccs_set_group(head, "network unix ");
-				ccs_set_string(head, ccs_proto_keyword
-					       [ptr->protocol]);
+				ccs_print(head, ccs_proto_keyword
+					  [ptr->protocol]);
 				ccs_set_space(head);
 				first = false;
 			} else {
 				ccs_set_slash(head);
 			}
-			ccs_set_string(head, ccs_socket_keyword[bit]);
+			ccs_print(head, ccs_socket_keyword[bit]);
 		}
 		if (first)
-			return true;
+			return;
 		ccs_print_name_union(head, &ptr->name);
 #endif
 #ifdef CONFIG_CCSECURITY_IPC
@@ -3996,7 +3843,7 @@
 		ccs_set_group(head, "ipc signal ");
 		ccs_print_number_union_nospace(head, &ptr->sig);
 		ccs_set_space(head);
-		ccs_set_string(head, ptr->domainname->name);
+		ccs_print(head, ptr->domainname->name);
 #endif
 	} else if (acl_type == CCS_TYPE_MOUNT_ACL) {
 		struct ccs_mount_acl *ptr =
@@ -4007,19 +3854,9 @@
 		ccs_print_name_union(head, &ptr->fs_type);
 		ccs_print_number_union(head, &ptr->flags);
 	}
-	if (acl->cond) {
-		head->r.print_cond_part = true;
-		head->r.cond_step = 0;
-		if (!ccs_flush(head))
-			return false;
-print_cond_part:
-		if (!ccs_print_condition(head, acl->cond))
-			return false;
-		head->r.print_cond_part = false;
-	} else {
-		ccs_set_lf(head);
-	}
-	return true;
+	if (acl->cond)
+		ccs_print_condition(head, acl->cond);
+	ccs_set_lf(head);
 }
 
 /**
@@ -4028,21 +3865,19 @@
  * @head: Pointer to "struct ccs_io_buffer".
  * @list: Pointer to "struct list_head".
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_read_domain2(struct ccs_io_buffer *head,
+static void ccs_read_domain2(struct ccs_io_buffer *head,
 			     struct list_head *list)
 {
 	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_acl_info *ptr =
 			list_entry(head->r.acl, typeof(*ptr), list);
-		if (!ccs_print_entry(head, ptr))
-			return false;
+		ccs_print_entry(head, ptr);
 	}
 	head->r.acl = NULL;
-	return true;
 }
 
 /**
@@ -4061,38 +3896,24 @@
 	list_for_each_cookie(head->r.domain, &ccs_domain_list) {
 		struct ccs_domain_info *domain =
 			list_entry(head->r.domain, typeof(*domain), list);
-		switch (head->r.step) {
-			u8 i;
-		case 0:
-			if (domain->is_deleted &&
-			    !head->r.print_this_domain_only)
-				continue;
-			/* Print domainname and flags. */
-			ccs_set_string(head, domain->domainname->name);
-			ccs_set_lf(head);
-			ccs_io_printf(head, "use_profile %u\n",
-				      domain->profile);
-			ccs_io_printf(head, "use_group %u\n", domain->group);
-			for (i = 0; i < CCS_MAX_DOMAIN_INFO_FLAGS; i++)
-				if (domain->flags[i])
-					ccs_set_string(head, ccs_dif[i]);
-			head->r.step++;
-			ccs_set_lf(head);
-			/* fall through */
-		case 1:
-			if (!ccs_read_domain2(head, &domain->acl_info_list))
-				return;
-			head->r.step++;
-			if (!ccs_set_lf(head))
-				return;
-			/* fall through */
-		case 2:
-			head->r.step = 0;
-			if (head->r.print_this_domain_only)
-				goto done;
-		}
+		u8 i;
+		if (domain->is_deleted && !head->r.print_this_domain_only)
+			continue;
+		/* Print domainname and flags. */
+		ccs_print(head, domain->domainname->name);
+		ccs_set_lf(head);
+		ccs_printf(head, "use_profile %u\n", domain->profile);
+		ccs_printf(head, "use_group %u\n", domain->group);
+		for (i = 0; i < CCS_MAX_DOMAIN_INFO_FLAGS; i++)
+			if (domain->flags[i])
+				ccs_print(head, ccs_dif[i]);
+		ccs_set_lf(head);
+		ccs_read_domain2(head, &domain->acl_info_list);
+		ccs_set_lf(head);
+		if (head->r.print_this_domain_only)
+			break;
 	}
-done:
+	head->r.domain = NULL;
 	head->r.eof = true;
 }
 
@@ -4134,7 +3955,7 @@
 		head->r.eof = true;
 		return; /* Do nothing if open(O_RDONLY). */
 	}
-	if (head->r.w_pos || head->r.eof)
+	if (head->r.w || head->r.eof)
 		return;
 	head->r.eof = true;
 	if (ccs_str_starts(&buf, "info "))
@@ -4159,14 +3980,12 @@
 	if (!domain)
 		return;
 	if (!task_info) {
-		ccs_io_printf(head, "%u %u ", pid, domain->profile);
-		ccs_set_string(head, domain->domainname->name);
+		ccs_printf(head, "%u %u ", pid, domain->profile);
+		ccs_print(head, domain->domainname->name);
 	} else {
-		ccs_io_printf(head, "%u manager=%s execute_handler=%s ", pid,
-			      ccs_yesno(ccs_flags &
-					CCS_TASK_IS_MANAGER),
-			      ccs_yesno(ccs_flags &
-					CCS_TASK_IS_EXECUTE_HANDLER));
+		ccs_printf(head, "%u manager=%s execute_handler=%s ", pid,
+			   ccs_yesno(ccs_flags & CCS_TASK_IS_MANAGER),
+			   ccs_yesno(ccs_flags & CCS_TASK_IS_EXECUTE_HANDLER));
 	}
 }
 
@@ -4403,11 +4222,11 @@
  * @head: Pointer to "struct ccs_io_buffer".
  * @idx:  Index number.
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_read_group(struct ccs_io_buffer *head, const int idx)
+static void ccs_read_group(struct ccs_io_buffer *head, const int idx)
 {
 	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
 						       namespace_list);
@@ -4420,18 +4239,17 @@
 				list_entry(head->r.acl, typeof(*ptr), list);
 			if (ptr->is_deleted)
 				continue;
-			if (!ccs_flush(head))
-				return false;
 			ccs_print_namespace(head);
-			ccs_set_string(head, ccs_group_name[idx]);
-			ccs_set_string(head, group->group_name->name);
+			ccs_print(head, ccs_group_name[idx]);
+			ccs_print(head, group->group_name->name);
+			ccs_set_space(head);
 			if (idx == CCS_PATH_GROUP) {
-				ccs_set_space(head);
-				ccs_set_string(head, container_of
-					       (ptr, struct ccs_path_group,
-						head)->member_name->name);
+				ccs_print(head, container_of
+					  (ptr, struct ccs_path_group,
+					   head)->member_name->name);
 			} else if (idx == CCS_NUMBER_GROUP) {
-				ccs_print_number_union(head, &container_of
+				ccs_print_number_union_nospace(head,
+							       &container_of
 					       (ptr, struct ccs_number_group,
 						head)->number);
 #ifdef CONFIG_CCSECURITY_NETWORK
@@ -4442,7 +4260,7 @@
 						     head);
 				ccs_print_ip(buffer, sizeof(buffer),
 					     &member->address);
-				ccs_io_printf(head, " %s", buffer);
+				ccs_print(head, buffer);
 #endif
 			}
 			ccs_set_lf(head);
@@ -4450,7 +4268,6 @@
 		head->r.acl = NULL;
 	}
 	head->r.group = NULL;
-	return true;
 }
 
 /**
@@ -4459,11 +4276,11 @@
  * @head: Pointer to "struct ccs_io_buffer".
  * @idx:  Index number.
  *
- * Returns true on success, false otherwise.
+ * Returns nothing.
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_read_policy(struct ccs_io_buffer *head, const int idx)
+static void ccs_read_policy(struct ccs_io_buffer *head, const int idx)
 {
 	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
 						       namespace_list);
@@ -4476,21 +4293,19 @@
 		if (head->r.print_transition_related_only &&
 		    idx != CCS_ID_TRANSITION_CONTROL)
 			continue;
-		if (!ccs_flush(head))
-			return false;
 		switch (idx) {
 		case CCS_ID_TRANSITION_CONTROL:
 			{
 				struct ccs_transition_control *ptr =
 					container_of(acl, typeof(*ptr), head);
 				ccs_print_namespace(head);
-				ccs_set_string(head,
-					       ccs_transition_type[ptr->type]);
-				ccs_set_string(head, ptr->program ?
-					       ptr->program->name : "any");
-				ccs_set_string(head, " from ");
-				ccs_set_string(head, ptr->domainname ?
-					       ptr->domainname->name : "any");
+				ccs_print(head,
+					  ccs_transition_type[ptr->type]);
+				ccs_print(head, ptr->program ?
+					  ptr->program->name : "any");
+				ccs_print(head, " from ");
+				ccs_print(head, ptr->domainname ?
+					  ptr->domainname->name : "any");
 			}
 			break;
 		case CCS_ID_AGGREGATOR:
@@ -4498,11 +4313,10 @@
 				struct ccs_aggregator *ptr =
 					container_of(acl, typeof(*ptr), head);
 				ccs_print_namespace(head);
-				ccs_set_string(head, "aggregator ");
-				ccs_set_string(head, ptr->original_name->name);
+				ccs_print(head, "aggregator ");
+				ccs_print(head, ptr->original_name->name);
 				ccs_set_space(head);
-				ccs_set_string(head,
-					       ptr->aggregated_name->name);
+				ccs_print(head, ptr->aggregated_name->name);
 			}
 			break;
 #ifdef CONFIG_CCSECURITY_PORTRESERVE
@@ -4511,7 +4325,7 @@
 				struct ccs_reserved *ptr =
 					container_of(acl, typeof(*ptr), head);
 				ccs_print_namespace(head);
-				ccs_set_string(head, "deny_autobind ");
+				ccs_print(head, "deny_autobind ");
 				ccs_print_number_union_nospace(head,
 							       &ptr->port);
 			}
@@ -4523,7 +4337,6 @@
 		ccs_set_lf(head);
 	}
 	head->r.acl = NULL;
-	return true;
 }
 
 /**
@@ -4537,28 +4350,18 @@
  */
 static void ccs_read_exception(struct ccs_io_buffer *head)
 {
+	u16 i;
 	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
 						       namespace_list);
 	if (head->r.eof)
 		return;
-	while (head->r.step < CCS_MAX_POLICY &&
-	       ccs_read_policy(head, head->r.step))
-		head->r.step++;
-	if (head->r.step < CCS_MAX_POLICY)
-		return;
-	while (head->r.step < CCS_MAX_POLICY + CCS_MAX_GROUP &&
-	       ccs_read_group(head, head->r.step - CCS_MAX_POLICY))
-		head->r.step++;
-	if (head->r.step < CCS_MAX_POLICY + CCS_MAX_GROUP)
-		return;
-	while (head->r.step < CCS_MAX_POLICY + CCS_MAX_GROUP
-	       + CCS_MAX_ACL_GROUPS) {
-		head->r.acl_group_index =
-			head->r.step - CCS_MAX_POLICY - CCS_MAX_GROUP;
-		if (!ccs_read_domain2(head, &ns->acl_group
-				      [head->r.acl_group_index]))
-			return;
-		head->r.step++;
+	for (i = 0; i < CCS_MAX_POLICY; i++)
+		ccs_read_policy(head, i);
+	for (i = 0; i < CCS_MAX_GROUP; i++)
+		ccs_read_group(head, i);
+	for (i = 0; i < CCS_MAX_ACL_GROUPS; i++) {
+		head->r.acl_group_index = i;
+		ccs_read_domain2(head, &ns->acl_group[i]);
 	}
 	head->r.eof = true;
 }
@@ -4898,7 +4701,7 @@
 	unsigned int pos = 0;
 	size_t len = 0;
 	char *buf;
-	if (head->r.w_pos)
+	if (head->readbuf_pos)
 		return;
 	kfree(head->read_buf);
 	head->read_buf = NULL;
@@ -4940,7 +4743,7 @@
 	spin_unlock(&ccs_query_list_lock);
 	if (buf[0]) {
 		head->read_buf = buf;
-		head->r.w[head->r.w_pos++] = buf;
+		head->readbuf_pos = strlen(buf) + 1;
 		head->r.query_index++;
 	} else {
 		kfree(buf);
@@ -4993,7 +4796,7 @@
 {
 	if (head->r.eof)
 		return;
-	ccs_set_string(head, "1.8.3");
+	ccs_print(head, "1.8.3");
 	head->r.eof = true;
 }
 
@@ -5029,30 +4832,30 @@
 	if (head->r.eof)
 		return;
 	for (i = 0; i < CCS_MAX_POLICY_STAT; i++) {
-		ccs_io_printf(head, "Policy %-30s %10u", ccs_policy_headers[i],
-			      ccs_stat_updated[i]);
+		ccs_printf(head, "Policy %-30s %10u", ccs_policy_headers[i],
+			   ccs_stat_updated[i]);
 		if (ccs_stat_modified[i]) {
 			struct ccs_time stamp;
 			ccs_convert_time(ccs_stat_modified[i], &stamp);
-			ccs_io_printf(head, " (Last: %04u/%02u/%02u "
-				      "%02u:%02u:%02u)",
-				      stamp.year, stamp.month, stamp.day,
-				      stamp.hour, stamp.min, stamp.sec);
+			ccs_printf(head, " (Last: %04u/%02u/%02u "
+				   "%02u:%02u:%02u)",
+				   stamp.year, stamp.month, stamp.day,
+				   stamp.hour, stamp.min, stamp.sec);
 		}
 		ccs_set_lf(head);
 	}
 	for (i = 0; i < CCS_MAX_MEMORY_STAT; i++) {
 		unsigned int used = ccs_memory_used[i];
 		total += used;
-		ccs_io_printf(head, "Memory used by %-22s %10u",
-			      ccs_memory_headers[i], used);
+		ccs_printf(head, "Memory used by %-22s %10u",
+			   ccs_memory_headers[i], used);
 		used = ccs_memory_quota[i];
 		if (used)
-			ccs_io_printf(head, " (Quota: %10u)", used);
+			ccs_printf(head, " (Quota: %10u)", used);
 		ccs_set_lf(head);
 	}
-	ccs_io_printf(head, "Total memory used:                    %10u\n",
-		      total);
+	ccs_printf(head, "Total memory used:                    %10u\n",
+		   total);
 	head->r.eof = true;
 }
 
@@ -5533,7 +5336,7 @@
 static void ccs_read_log(struct ccs_io_buffer *head)
 {
 	struct ccs_log *ptr = NULL;
-	if (head->r.w_pos)
+	if (head->readbuf_pos)
 		return;
 	kfree(head->read_buf);
 	head->read_buf = NULL;
@@ -5547,7 +5350,7 @@
 	spin_unlock(&ccs_log_lock);
 	if (ptr) {
 		head->read_buf = ptr->log;
-		head->r.w[head->r.w_pos++] = head->read_buf;
+		head->readbuf_pos = strlen(ptr->log) + 1;
 		kfree(ptr);
 	}
 }
@@ -5588,7 +5391,7 @@
 	 */
 	ns = head->r.ns;
 	if (!ns || (head->r.eof && ns->next != &ccs_namespace_list)) {
-		/* Clearing is OK because ccs_flush() returned true. */
+		/* Clearing is OK because nothing is pending. */
 		memset(&head->r, 0, sizeof(head->r));
 		head->r.ns = ns ? ns->next : ccs_namespace_list.next;
 	}
@@ -5946,6 +5749,8 @@
 	if (!head)
 		return -ENOMEM;
 	mutex_init(&head->io_sem);
+	init_waitqueue_head(&head->read_request_wait);
+	init_waitqueue_head(&head->read_response_wait);
 	head->type = type;
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 	if (type == CCS_EXECUTE_HANDLER) {
@@ -5998,6 +5803,9 @@
 static int ccs_release(struct inode *inode, struct file *file)
 {
 	struct ccs_io_buffer *head = file->private_data;
+	head->read_abort = true;
+	wake_up(&head->read_request_wait);
+	wait_event(head->read_response_wait, !head->reader_thread_started);
 	/*
 	 * If the file is /proc/ccs/query, decrement the observer counter.
 	 */
@@ -6030,6 +5838,83 @@
 }
 
 /**
+ * ccs_reader_thread - Policy reader thread function.
+ *
+ * @arg: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0.
+ */
+static int ccs_reader_thread(void *arg)
+{
+	struct ccs_io_buffer *head = arg;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 6)
+	/* daemonize() not needed. */
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
+	daemonize("CCS Reader");
+#else
+	daemonize();
+	reparent_to_init();
+#if defined(TASK_DEAD)
+	{
+		struct task_struct *task = current;
+		spin_lock_irq(&task->sighand->siglock);
+		siginitsetinv(&task->blocked, 0);
+		recalc_sigpending();
+		spin_unlock_irq(&task->sighand->siglock);
+	}
+#else
+	{
+		struct task_struct *task = current;
+		spin_lock_irq(&task->sigmask_lock);
+		siginitsetinv(&task->blocked, 0);
+		recalc_sigpending(task);
+		spin_unlock_irq(&task->sigmask_lock);
+	}
+#endif
+	snprintf(current->comm, sizeof(current->comm) - 1, "CCS Reader");
+#endif
+	head->reader_idx = ccs_read_lock();
+	/* Call the policy handler. */
+	do {
+		ccs_set_namespace_cursor(head);
+		switch (head->type) {
+		case CCS_DOMAINPOLICY:
+			ccs_read_domain(head);
+			break;
+		case CCS_EXCEPTIONPOLICY:
+			ccs_read_exception(head);
+			break;
+#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
+		case CCS_EXECUTE_HANDLER:
+#endif
+		case CCS_PROCESS_STATUS:
+			ccs_read_pid(head);
+			break;
+		case CCS_VERSION:
+			ccs_read_version(head);
+			break;
+		case CCS_STAT:
+			ccs_read_stat(head);
+			break;
+		case CCS_PROFILE:
+			ccs_read_profile(head);
+			break;
+		case CCS_MANAGER:
+			ccs_read_manager(head);
+			break;
+		default:
+			break;
+		}
+	} while (ccs_has_more_namespace(head));
+	ccs_read_unlock(head->reader_idx);
+	head->read_paused = true;
+	head->r.eof = true;
+	head->reader_thread_started = false;
+	wake_up(&head->read_response_wait);
+	return 0;
+}
+
+/**
  * ccs_read - read() for /proc/ccs/ interface.
  *
  * @file:  Pointer to "struct file".
@@ -6043,54 +5928,61 @@
 			loff_t *ppos)
 {
 	struct ccs_io_buffer *head = file->private_data;
-	int len;
-	int idx;
+	int error;
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
-	head->read_user_buf = buf;
-	head->read_user_buf_avail = count;
-	idx = ccs_read_lock();
-	if (ccs_flush(head))
-		/* Call the policy handler. */
-		do {
-			ccs_set_namespace_cursor(head);
-			switch (head->type) {
-			case CCS_DOMAINPOLICY:
-				ccs_read_domain(head);
-				break;
-			case CCS_EXCEPTIONPOLICY:
-				ccs_read_exception(head);
-				break;
-			case CCS_AUDIT:
-				ccs_read_log(head);
-				break;
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-			case CCS_EXECUTE_HANDLER:
+	if (head->type == CCS_AUDIT) {
+		ccs_read_log(head);
+		goto done;
+	}
+	if (head->type == CCS_QUERY) {
+		ccs_read_query(head);
+		goto done;
+	}
+	if (head->r.eof)
+		goto done;
+	if (!head->reader_thread_started) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 6)
+		struct task_struct *task = kthread_create(ccs_reader_thread,
+							  head, "CCS Reader");
+		if (!IS_ERR(task)) {
+			head->reader_thread_started = true;
+			wake_up_process(task);
+		}
+#else
+		if (kernel_thread(ccs_reader_thread, head, 0) >= 0)
+			head->reader_thread_started = true;
 #endif
-			case CCS_PROCESS_STATUS:
-				ccs_read_pid(head);
-				break;
-			case CCS_VERSION:
-				ccs_read_version(head);
-				break;
-			case CCS_STAT:
-				ccs_read_stat(head);
-				break;
-			case CCS_PROFILE:
-				ccs_read_profile(head);
-				break;
-			case CCS_QUERY:
-				ccs_read_query(head);
-				break;
-			case CCS_MANAGER:
-				ccs_read_manager(head);
-				break;
-			}
-		} while (ccs_flush(head) && ccs_has_more_namespace(head));
-	ccs_read_unlock(idx);
-	len = head->read_user_buf - buf;
+		if (!head->reader_thread_started) {
+			error = -ENOMEM;
+			goto unlock;
+			//} else {
+			//head->users++;
+		}
+	}
+	if (head->readbuf_pos < head->readbuf_size) {
+		head->read_paused = false;
+		wake_up(&head->read_request_wait);
+		wait_event_interruptible(head->read_response_wait,
+					 head->read_paused);
+		if (!head->read_paused) {
+			error = -EINTR;
+			goto unlock;
+		}
+	}
+done:
+	if (count > head->readbuf_pos)
+		count = head->readbuf_pos;
+	if (copy_to_user(buf, head->read_buf, count)) {
+		error = -EFAULT;
+		goto unlock;
+	}
+	head->readbuf_pos -= count;
+	memmove(head->read_buf, head->read_buf + count, head->readbuf_pos);
+	error = count;
+unlock:
 	mutex_unlock(&head->io_sem);
-	return len;
+	return error;
 }
 
 #ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
@@ -6167,7 +6059,7 @@
 	int idx;
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
-	head->read_user_buf_avail = 0;
+	//head->read_user_buf_avail = 0;
 	idx = ccs_read_lock();
 	/* Read a line and dispatch it to the policy handler. */
 	while (count) {
Index: gc.c
===================================================================
--- gc.c	(revision 5666)
+++ gc.c	(working copy)
@@ -237,17 +237,12 @@
 	bool in_use = false;
 	spin_lock(&ccs_io_buffer_list_lock);
 	list_for_each_entry(head, &ccs_io_buffer_list, list) {
-		int i;
 		head->users++;
 		spin_unlock(&ccs_io_buffer_list_lock);
 		mutex_lock(&head->io_sem);
-		for (i = 0; i < CCS_MAX_IO_READ_QUEUE; i++) {
-			const char *w = head->r.w[i];
-			if (w < string || w > string + size)
-				continue;
-			in_use = true;
-			break;
-		}
+		if (head->r.w < string || head->r.w > string + size)
+			continue;
+		in_use = true;
 		mutex_unlock(&head->io_sem);
 		spin_lock(&ccs_io_buffer_list_lock);
 		head->users--;
@@ -765,7 +760,7 @@
 		break;
 	case CCS_ID_NAME:
 		/*
-		 * Don't kfree() until all "struct ccs_io_buffer"->r.w[] forget
+		 * Don't kfree() until all "struct ccs_io_buffer"->r.w forget
 		 * this element.
 		 */
 		if (ccs_name_used_by_io_buffer
