Index: realpath.c
===================================================================
--- realpath.c	(revision 5869)
+++ realpath.c	(working copy)
@@ -28,7 +28,6 @@
 char *ccs_encode(const char *str);
 char *ccs_encode2(const char *str, int str_len);
 char *ccs_realpath(struct path *path);
-char *ccs_realpath2(struct path *path, bool force_no_fsname);
 const char *ccs_get_exe(void);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
 
@@ -493,18 +492,16 @@
 #define SOCKFS_MAGIC 0x534F434B
 
 /**
- * ccs_realpath2 - Returns realpath(3) of the given pathname but ignores chroot'ed root.
+ * ccs_realpath - Returns realpath(3) of the given pathname but ignores chroot'ed root.
  *
- * @path:            Pointer to "struct path".
- * @force_no_fsname: Force use of normal pathname if true, may use fsname
- *                   otherwise.
+ * @path: Pointer to "struct path".
  *
  * Returns the realpath of the given @path on success, NULL otherwise.
  *
  * This function uses kzalloc(), so caller must kfree() if this function
  * didn't return NULL.
  */
-char *ccs_realpath2(struct path *path, bool force_no_fsname)
+char *ccs_realpath(struct path *path)
 {
 	char *buf = NULL;
 	char *name = NULL;
@@ -524,8 +521,6 @@
 			break;
 		/* To make sure that pos is '\0' terminated. */
 		buf[buf_len - 1] = '\0';
-		if (force_no_fsname)
-			goto absolute_path;
 		/* Get better name for socket. */
 		if (sb->s_magic == SOCKFS_MAGIC) {
 			pos = ccs_get_socket_name(path, buf, buf_len - 1);
@@ -547,7 +542,6 @@
 		if (!path->mnt || (inode->i_op && !inode->i_op->rename))
 			pos = ERR_PTR(-EINVAL);
 		else {
-absolute_path:
 			/* Get absolute name for the rest. */
 			ccs_realpath_lock();
 			pos = ccs_get_absolute_path(path, buf, buf_len - 1);
@@ -569,21 +563,6 @@
 }
 
 /**
- * ccs_realpath - Returns realpath(3) of the given pathname but ignores chroot'ed root.
- *
- * @path: Pointer to "struct path".
- *
- * Returns the realpath of the given @path on success, NULL otherwise.
- *
- * This function uses kzalloc(), so caller must kfree() if this function
- * didn't return NULL.
- */
-char *ccs_realpath(struct path *path)
-{
-	return ccs_realpath2(path, false);
-}
-
-/**
  * ccs_encode2 - Encode binary string to ascii string.
  *
  * @str:     String in binary format.
@@ -597,20 +576,17 @@
 char *ccs_encode2(const char *str, int str_len)
 {
 	int i;
-	int len = 0;
+	int len;
 	const char *p = str;
 	char *cp;
 	char *cp0;
 	if (!p)
 		return NULL;
+	len = str_len;
 	for (i = 0; i < str_len; i++) {
 		const unsigned char c = p[i];
-		if (c == '\\')
-			len += 2;
-		else if (c > ' ' && c < 127)
-			len++;
-		else
-			len += 4;
+		if (!(c > ' ' && c < 127 && c != '\\'))
+			len += 3;
 	}
 	len++;
 	/* Reserve space for appending "/". */
@@ -621,10 +597,7 @@
 	p = str;
 	for (i = 0; i < str_len; i++) {
 		const unsigned char c = p[i];
-		if (c == '\\') {
-			*cp++ = '\\';
-			*cp++ = '\\';
-		} else if (c > ' ' && c < 127) {
+		if (c > ' ' && c < 127 && c != '\\') {
 			*cp++ = c;
 		} else {
 			*cp++ = '\\';
@@ -674,9 +647,6 @@
 		}
 		c = *filename++;
 		switch (c) {
-		case '\\':  /* "\\" */
-			len += 2;
-			continue;
 		case '0':   /* "\ooo" */
 		case '1':
 		case '2':
@@ -744,3 +714,13 @@
 	up_read(&mm->mmap_sem);
 	return cp;
 }
+
+bool ccs_get_exename(struct ccs_path_info *buf)
+{
+	buf->name = ccs_get_exe();
+	if (buf->name) {
+		ccs_fill_path_info(buf);
+		return true;
+	}
+	return false;
+}
Index: internal.h
===================================================================
--- internal.h	(revision 5869)
+++ internal.h	(working copy)
@@ -34,6 +34,7 @@
 #include <linux/in.h>
 #include <linux/in6.h>
 #include <linux/un.h>
+#include <linux/ptrace.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #include <linux/fs.h>
 #endif
@@ -384,59 +385,34 @@
 
 /* Enumeration definition for internal use. */
 
-/* Index numbers for Access Controls. */
-enum ccs_acl_entry_type_index {
-	CCS_TYPE_EXECUTE_ACL,
-	CCS_TYPE_PATH_ACL,
-	CCS_TYPE_PATH2_ACL,
-	CCS_TYPE_PATH_NUMBER_ACL,
-	CCS_TYPE_MKDEV_ACL,
-	CCS_TYPE_MOUNT_ACL,
-#ifdef CONFIG_CCSECURITY_MISC
-	CCS_TYPE_ENV_ACL,
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-	CCS_TYPE_CAPABILITY_ACL,
-#endif
-#ifdef CONFIG_CCSECURITY_NETWORK
-	CCS_TYPE_INET_ACL,
-	CCS_TYPE_UNIX_ACL,
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-	CCS_TYPE_PTRACE_ACL,
-#endif
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-	CCS_TYPE_AUTO_EXECUTE_HANDLER,
-	CCS_TYPE_DENIED_EXECUTE_HANDLER,
-#endif
-#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
-	CCS_TYPE_AUTO_TASK_ACL,
-	CCS_TYPE_MANUAL_TASK_ACL,
-#endif
-	CCS_TYPE_USE_GROUP_ACL,
-};
-
 /* Index numbers for "struct ccs_condition". */
 enum ccs_conditions_index {
-	CCS_TASK_UID,             /* current_uid()   */
-	CCS_TASK_EUID,            /* current_euid()  */
-	CCS_TASK_SUID,            /* current_suid()  */
-	CCS_TASK_FSUID,           /* current_fsuid() */
-	CCS_TASK_GID,             /* current_gid()   */
-	CCS_TASK_EGID,            /* current_egid()  */
-	CCS_TASK_SGID,            /* current_sgid()  */
-	CCS_TASK_FSGID,           /* current_fsgid() */
-	CCS_TASK_PID,             /* sys_getpid()   */
-	CCS_TASK_PPID,            /* sys_getppid()  */
+	/* 0 */
+	CCS_SELF_UID,             /* current_uid()   */
+	CCS_SELF_EUID,            /* current_euid()  */
+	CCS_SELF_SUID,            /* current_suid()  */
+	CCS_SELF_FSUID,           /* current_fsuid() */
+	CCS_SELF_GID,             /* current_gid()   */
+	CCS_SELF_EGID,            /* current_egid()  */
+	CCS_SELF_SGID,            /* current_sgid()  */
+	CCS_SELF_FSGID,           /* current_fsgid() */
+	CCS_SELF_PID,             /* sys_getpid()   */
+	CCS_SELF_PPID,            /* sys_getppid()  */
+	/* 10 */
+	CCS_TASK_TYPE,            /* ((u8) task->ccs_flags) &
+				     CCS_TASK_IS_EXECUTE_HANDLER */
+	CCS_SELF_DOMAIN,
+	CCS_SELF_EXE,
 	CCS_EXEC_ARGC,            /* "struct linux_binprm *"->argc */
 	CCS_EXEC_ENVC,            /* "struct linux_binprm *"->envc */
-	CCS_TYPE_IS_SOCKET,       /* S_IFSOCK */
-	CCS_TYPE_IS_SYMLINK,      /* S_IFLNK */
-	CCS_TYPE_IS_FILE,         /* S_IFREG */
-	CCS_TYPE_IS_BLOCK_DEV,    /* S_IFBLK */
-	CCS_TYPE_IS_DIRECTORY,    /* S_IFDIR */
-	CCS_TYPE_IS_CHAR_DEV,     /* S_IFCHR */
-	CCS_TYPE_IS_FIFO,         /* S_IFIFO */
+	CCS_OBJ_IS_SOCKET,        /* S_IFSOCK */
+	CCS_OBJ_IS_SYMLINK,       /* S_IFLNK */
+	CCS_OBJ_IS_FILE,          /* S_IFREG */
+	CCS_OBJ_IS_BLOCK_DEV,     /* S_IFBLK */
+	CCS_OBJ_IS_DIRECTORY,     /* S_IFDIR */
+	/* 20 */
+	CCS_OBJ_IS_CHAR_DEV,      /* S_IFCHR */
+	CCS_OBJ_IS_FIFO,          /* S_IFIFO */
 	CCS_MODE_SETUID,          /* S_ISUID */
 	CCS_MODE_SETGID,          /* S_ISGID */
 	CCS_MODE_STICKY,          /* S_ISVTX */
@@ -445,67 +421,63 @@
 	CCS_MODE_OWNER_EXECUTE,   /* S_IXUSR */
 	CCS_MODE_GROUP_READ,      /* S_IRGRP */
 	CCS_MODE_GROUP_WRITE,     /* S_IWGRP */
+	/* 30 */
 	CCS_MODE_GROUP_EXECUTE,   /* S_IXGRP */
 	CCS_MODE_OTHERS_READ,     /* S_IROTH */
 	CCS_MODE_OTHERS_WRITE,    /* S_IWOTH */
 	CCS_MODE_OTHERS_EXECUTE,  /* S_IXOTH */
-	CCS_TASK_TYPE,            /* ((u8) task->ccs_flags) &
-				     CCS_TASK_IS_EXECUTE_HANDLER */
 	CCS_TASK_EXECUTE_HANDLER, /* CCS_TASK_IS_EXECUTE_HANDLER */
-	CCS_EXEC_REALPATH,
-	CCS_PATH1_UID,
-	CCS_PATH1_GID,
-	CCS_PATH1_INO,
-	CCS_PATH1_MAJOR,
-	CCS_PATH1_MINOR,
-	CCS_PATH1_PERM,
-	CCS_PATH1_TYPE,
-	CCS_PATH1_DEV_MAJOR,
-	CCS_PATH1_DEV_MINOR,
-	CCS_PATH2_UID,
-	CCS_PATH2_GID,
-	CCS_PATH2_INO,
-	CCS_PATH2_MAJOR,
-	CCS_PATH2_MINOR,
-	CCS_PATH2_PERM,
-	CCS_PATH2_TYPE,
-	CCS_PATH2_DEV_MAJOR,
-	CCS_PATH2_DEV_MINOR,
-	CCS_PATH1_PARENT_UID,
-	CCS_PATH1_PARENT_GID,
-	CCS_PATH1_PARENT_INO,
-	CCS_PATH1_PARENT_PERM,
-	CCS_PATH2_PARENT_UID,
-	CCS_PATH2_PARENT_GID,
-	CCS_PATH2_PARENT_INO,
-	CCS_PATH2_PARENT_PERM,
+	CCS_HANDLER_PATH,
+	CCS_TRANSIT_DOMAIN,
 	CCS_MAX_CONDITION_KEYWORD,
-	CCS_NUMBER_UNION,
-	CCS_NAME_UNION,
+	CCS_COND_SARG0,
+	CCS_COND_SARG1,
+	/* 40 */
+	CCS_COND_SARG2,
+	CCS_COND_NARG0,
+	CCS_COND_NARG1,
+	CCS_COND_NARG2,
+	CCS_COND_IPARG,
+	CCS_COND_DOMAIN,
+	CCS_IMM_GROUP,
+	CCS_IMM_NAME_ENTRY,
+	CCS_IMM_DOMAINNAME_ENTRY,
+	CCS_IMM_NUMBER_ENTRY1,
+	/* 50 */
+	CCS_IMM_NUMBER_ENTRY2,
+	CCS_IMM_IPV4ADDR_ENTRY1,
+	CCS_IMM_IPV4ADDR_ENTRY2,
+	CCS_IMM_IPV6ADDR_ENTRY1,
+	CCS_IMM_IPV6ADDR_ENTRY2,
 	CCS_ARGV_ENTRY,
 	CCS_ENVP_ENTRY,
-};
+	CCS_PATH_ATTRIBUTE_START = 192,
+	CCS_PATH_ATTRIBUTE_END = 255,
+} __packed;
 
-/* Index numbers for audit type. */
-enum ccs_grant_log {
-	/* Follow profile's configuration. */
-	CCS_GRANTLOG_AUTO,
-	/* Do not generate grant log. */
-	CCS_GRANTLOG_NO,
-	/* Generate grant_log. */
-	CCS_GRANTLOG_YES,
+enum ccs_path_attribute_index {
+	CCS_PATH_ATTRIBUTE_UID,
+	CCS_PATH_ATTRIBUTE_GID,
+	CCS_PATH_ATTRIBUTE_INO,
+	CCS_PATH_ATTRIBUTE_TYPE,
+	CCS_PATH_ATTRIBUTE_MAJOR,
+	CCS_PATH_ATTRIBUTE_MINOR,
+	CCS_PATH_ATTRIBUTE_PERM,
+	CCS_PATH_ATTRIBUTE_DEV_MAJOR,
+	CCS_PATH_ATTRIBUTE_DEV_MINOR,
+	CCS_PATH_ATTRIBUTE_FSMAGIC,
+	CCS_MAX_PATH_ATTRIBUTE,
 };
 
 /* Index numbers for group entries. */
 enum ccs_group_id {
 	CCS_PATH_GROUP,
 	CCS_NUMBER_GROUP,
-	CCS_ACL_GROUP,
 #ifdef CONFIG_CCSECURITY_NETWORK
 	CCS_ADDRESS_GROUP,
 #endif
 	CCS_MAX_GROUP
-};
+} __packed;
 
 /* Index numbers for category of functionality. */
 enum ccs_mac_category_index {
@@ -519,9 +491,11 @@
 #ifdef CONFIG_CCSECURITY_IPC
 	CCS_MAC_CATEGORY_IPC,
 #endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
 	CCS_MAC_CATEGORY_CAPABILITY,
+#if defined(CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER) || defined(CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION)
+	CCS_MAC_CATEGORY_TASK,
 #endif
+	CCS_MAC_CATEGORY_NONE,
 	CCS_MAX_MAC_CATEGORY_INDEX
 };
 
@@ -589,6 +563,7 @@
 #ifdef CONFIG_CCSECURITY_IPC
 	CCS_MAC_PTRACE,
 #endif
+	CCS_MAC_CAPABILITY_MODIFY_POLICY,
 #ifdef CONFIG_CCSECURITY_CAPABILITY
 	CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET,
 	CCS_MAC_CAPABILITY_USE_PACKET_SOCKET,
@@ -600,10 +575,18 @@
 	CCS_MAC_CAPABILITY_USE_KERNEL_MODULE,
 	CCS_MAC_CAPABILITY_SYS_KEXEC_LOAD,
 #endif
-	CCS_MAX_MAC_INDEX
+#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
+	CCS_MAC_AUTO_EXECUTE_HANDLER,
+	CCS_MAC_DENIED_EXECUTE_HANDLER,
+#endif
+#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
+	CCS_MAC_AUTO_TASK_TRANSITION,
+	CCS_MAC_MANUAL_TASK_TRANSITION,
+#endif
+	CCS_MAX_MAC_INDEX,
 };
 
-/* Index numbers for /proc/ccs/stat interface. */
+/* Index numbers for statistic information. */
 enum ccs_memory_stat_type {
 	CCS_MEMORY_POLICY,
 	CCS_MEMORY_AUDIT,
@@ -611,76 +594,14 @@
 	CCS_MAX_MEMORY_STAT
 };
 
-/* Index numbers for access controls with one pathname and three numbers. */
-enum ccs_mkdev_acl_index {
-	CCS_TYPE_MKBLOCK,
-	CCS_TYPE_MKCHAR,
-	CCS_MAX_MKDEV_OPERATION
-};
-
 /* Index numbers for operation mode. */
 enum ccs_mode_value {
 	CCS_CONFIG_DISABLED,
-	CCS_CONFIG_LEARNING,
 	CCS_CONFIG_PERMISSIVE,
 	CCS_CONFIG_ENFORCING,
 	CCS_CONFIG_MAX_MODE,
-	CCS_CONFIG_WANT_REJECT_LOG =  64,
-	CCS_CONFIG_WANT_GRANT_LOG  = 128,
-	CCS_CONFIG_USE_DEFAULT     = 255,
-};
+} __packed;
 
-/* Index numbers for socket operations. */
-enum ccs_network_acl_index {
-	CCS_NETWORK_BIND,    /* bind() operation. */
-	CCS_NETWORK_LISTEN,  /* listen() operation. */
-	CCS_NETWORK_CONNECT, /* connect() operation. */
-	CCS_NETWORK_ACCEPT,  /* accept() operation. */
-	CCS_NETWORK_SEND,    /* send() operation. */
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-	CCS_NETWORK_RECV,    /* recv() operation. */
-#endif
-	CCS_MAX_NETWORK_OPERATION
-};
-
-/* Index numbers for access controls with two pathnames. */
-enum ccs_path2_acl_index {
-	CCS_TYPE_LINK,
-	CCS_TYPE_RENAME,
-	CCS_TYPE_PIVOT_ROOT,
-	CCS_TYPE_SYMLINK,
-	CCS_MAX_PATH2_OPERATION
-};
-
-/* Index numbers for access controls with one pathname. */
-enum ccs_path_acl_index {
-	CCS_TYPE_READ,
-	CCS_TYPE_WRITE,
-	CCS_TYPE_APPEND,
-	CCS_TYPE_UNLINK,
-#ifdef CONFIG_CCSECURITY_FILE_GETATTR
-	CCS_TYPE_GETATTR,
-#endif
-	CCS_TYPE_RMDIR,
-	CCS_TYPE_TRUNCATE,
-	CCS_TYPE_CHROOT,
-	CCS_TYPE_UMOUNT,
-	CCS_MAX_PATH_OPERATION
-};
-
-/* Index numbers for access controls with one pathname and one number. */
-enum ccs_path_number_acl_index {
-	CCS_TYPE_CREATE,
-	CCS_TYPE_MKDIR,
-	CCS_TYPE_MKFIFO,
-	CCS_TYPE_MKSOCK,
-	CCS_TYPE_IOCTL,
-	CCS_TYPE_CHMOD,
-	CCS_TYPE_CHOWN,
-	CCS_TYPE_CHGRP,
-	CCS_MAX_PATH_NUMBER_OPERATION
-};
-
 /* Index numbers for stat(). */
 enum ccs_path_stat_index {
 	/* Do not change this order. */
@@ -699,7 +620,6 @@
 #endif
 	CCS_ID_PATH_GROUP,
 	CCS_ID_NUMBER_GROUP,
-	CCS_ID_MANAGER,
 	CCS_ID_CONDITION,
 	CCS_ID_NAME,
 	CCS_ID_ACL,
@@ -707,39 +627,25 @@
 	CCS_MAX_POLICY
 };
 
-/* Index numbers for /proc/ccs/stat interface. */
+/* Index numbers for statistic information. */
 enum ccs_policy_stat_type {
 	/* Do not change this order. */
 	CCS_STAT_POLICY_UPDATES,
-	CCS_STAT_POLICY_LEARNING,   /* == CCS_CONFIG_LEARNING */
 	CCS_STAT_POLICY_PERMISSIVE, /* == CCS_CONFIG_PERMISSIVE */
 	CCS_STAT_POLICY_ENFORCING,  /* == CCS_CONFIG_ENFORCING */
 	CCS_MAX_POLICY_STAT
 };
 
-/* Index numbers for profile's PREFERENCE values. */
-enum ccs_pref_index {
-	CCS_PREF_MAX_AUDIT_LOG,
-	CCS_PREF_MAX_LEARNING_ENTRY,
-	CCS_PREF_ENFORCING_PENALTY,
-	CCS_MAX_PREF
-};
-
 /* Index numbers for /proc/ccs/ interfaces. */
 enum ccs_proc_interface_index {
-	CCS_DOMAIN_POLICY,
-	CCS_EXCEPTION_POLICY,
+	CCS_POLICY,
 	CCS_PROCESS_STATUS,
-	CCS_STAT,
 	CCS_AUDIT,
 	CCS_VERSION,
-	CCS_PROFILE,
 	CCS_QUERY,
-	CCS_MANAGER,
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 	CCS_EXECUTE_HANDLER,
 #endif
-	CCS_ACL_POLICY,
 };
 
 /* Index numbers for special mount operations. */
@@ -760,7 +666,7 @@
 	CCS_VALUE_TYPE_DECIMAL,
 	CCS_VALUE_TYPE_OCTAL,
 	CCS_VALUE_TYPE_HEXADECIMAL,
-};
+} __packed;
 
 /* Constants definition for internal use. */
 
@@ -784,9 +690,6 @@
 /* Garbage collector is trying to kfree() this element. */
 #define CCS_GC_IN_PROGRESS -1
 
-/* Profile number is an integer between 0 and 255. */
-#define CCS_MAX_PROFILES 256
-
 /* Current thread is doing open(O_RDONLY | O_TRUNC) ? */
 #define CCS_OPEN_FOR_READ_TRUNCATE        1
 /* Current thread is doing open(3) ? */
@@ -845,43 +748,20 @@
 /* Common header for individual entries. */
 struct ccs_acl_info {
 	struct list_head list;
-	struct list_head domain_list; /* Used by inverse mode. */
+	struct list_head acl_info_list;
 	struct ccs_condition *cond; /* Maybe NULL. */
 	s8 is_deleted; /* true or false or CCS_GC_IN_PROGRESS */
-	u8 type; /* One of values in "enum ccs_acl_entry_type_index". */
-	u8 mode; /* Used by inverse mode. */
-	u16 perm;
-} __packed;
-
-/* Structure for holding a word. */
-struct ccs_name_union {
-	/* Either @filename or @group is NULL. */
-	const struct ccs_path_info *filename;
-	struct ccs_group *group;
-	bool is_not;
+	enum ccs_mode_value mode;
+	bool is_deny;
+	u16 priority;
+	u16 max_grant_log;
+	u16 max_reject_log;
 };
 
-/* Structure for holding a number. */
-struct ccs_number_union {
-	unsigned long values[2];
-	struct ccs_group *group; /* Maybe NULL. */
-	/* One of values in "enum ccs_value_type". */
-	u8 value_type[2];
-	bool is_not;
-};
-
-/* Structure for holding an IP address. */
-struct ccs_ipaddr_union {
-	struct in6_addr ip[2]; /* Big endian. */
-	struct ccs_group *group; /* Pointer to address group. */
-	bool is_ipv6; /* Valid only if @group == NULL. */
-	bool is_not;
-};
-
 /* Structure for "path_group"/"number_group"/"address_group" directive. */
 struct ccs_group {
 	struct ccs_shared_acl_head head;
-	/* Name of group (without leading "\\=" or "\\!"). */
+	/* Name of group (without leading "@"). */
 	const struct ccs_path_info *group_name;
 	/*
 	 * List of "struct ccs_path_group" or "struct ccs_number_group" or
@@ -899,15 +779,16 @@
 /* Structure for "number_group" directive. */
 struct ccs_number_group {
 	struct ccs_acl_head head;
-	struct ccs_number_union number;
+	u8 radix;
+	unsigned long value[2];
 };
 
 /* Structure for "address_group" directive. */
 struct ccs_address_group {
 	struct ccs_acl_head head;
+	bool is_ipv6;
 	/* Structure for holding an IP address. */
-	struct ccs_ipaddr_union address;
-	bool is_not;
+	struct in6_addr ip[2]; /* Big endian. */
 };
 
 /* Subset of "struct stat". Used by conditional ACL and audit logs. */
@@ -918,6 +799,7 @@
 	umode_t mode;
 	dev_t dev;
 	dev_t rdev;
+	unsigned long fsmagic;
 };
 
 /* Structure for dumping argv[] and envp[] of "struct linux_binprm". */
@@ -926,166 +808,101 @@
 	char *data;           /* Contents of "page". Size is PAGE_SIZE. */
 };
 
-/* Structure for attribute checks in addition to pathname checks. */
-struct ccs_obj_info {
-	/* True if ccs_get_attributes() was already called, false otherwise. */
-	bool validate_done;
-	/* True if @stat[] is valid. */
-	bool stat_valid[CCS_MAX_PATH_STAT];
-	/* First pathname. Initialized with { NULL, NULL } if no path. */
-	struct path path1;
-	/* Second pathname. Initialized with { NULL, NULL } if no path. */
-	struct path path2;
-	/*
-	 * Information on @path1, @path1's parent directory, @path2, @path2's
-	 * parent directory.
-	 */
-	struct ccs_mini_stat stat[CCS_MAX_PATH_STAT];
-};
-
 /* Structure for entries which follows "struct ccs_condition". */
-struct ccs_condition_element {
-	/*
-	 * Left hand operand. A "struct ccs_argv" for CCS_ARGV_ENTRY, a
-	 * "struct ccs_envp" for CCS_ENVP_ENTRY is attached to the tail
-	 * of the array of this struct.
-	 */
-	u8 left;
-	/*
-	 * Right hand operand. A "struct ccs_number_union" for
-	 * CCS_NUMBER_UNION, a "struct ccs_name_union" for CCS_NAME_UNION is
-	 * attached to the tail of the array of this struct.
-	 */
-	u8 right;
-	/* Equation operator. True if equals or overlaps, false otherwise. */
-	bool equals;
+union ccs_condition_element {
+	struct {
+		enum ccs_conditions_index left;
+		enum ccs_conditions_index right;
+		bool is_not;
+		u8 radix;
+	};
+	struct ccs_group *group;
+	const struct ccs_path_info *path;
+	u32 ip; /* Repeat 4 times if IPv6 address. */
+	unsigned long value;
 };
 
 /* Structure for optional arguments. */
 struct ccs_condition {
 	struct ccs_shared_acl_head head;
 	u32 size; /* Memory size allocated for this entry. */
-	u16 condc; /* Number of conditions in this struct. */
-	u16 numbers_count; /* Number of "struct ccs_number_union values". */
-	u16 names_count; /* Number of "struct ccs_name_union names". */
-	u16 argc; /* Number of "struct ccs_argv". */
-	u16 envc; /* Number of "struct ccs_envp". */
-	u8 grant_log; /* One of values in "enum ccs_grant_log". */
-	/*
-	 * struct ccs_condition_element condition[condc];
-	 * struct ccs_number_union values[numbers_count];
-	 * struct ccs_name_union names[names_count];
-	 * struct ccs_argv argv[argc];
-	 * struct ccs_envp envp[envc];
-	 */
+	/* union ccs_condition_element condition[]; */
 };
 
-struct ccs_execve;
-struct ccs_policy_namespace;
+/* Structure for holding a token. */
+struct ccs_path_info {
+	const char *name;
+	u32 hash;          /* = full_name_hash(name, strlen(name)) */
+	u16 total_len;     /* = strlen(name)                       */
+	u16 const_len;     /* = ccs_const_part_length(name)        */
+	bool is_dir;       /* = ccs_strendswith(name, "/")         */
+	bool is_patterned; /* = const_len < total_len              */
+};
 
 /* Structure for request info. */
 struct ccs_request_info {
-	/*
-	 * For holding parameters specific to operations which deal files.
-	 * NULL if not dealing files.
-	 */
-	struct ccs_obj_info *obj;
-	/*
-	 * For holding parameters specific to execve() request.
-	 * NULL if not dealing do_execve().
-	 */
-	struct ccs_execve *ee;
-	/* For holding parameters. Pointers in this union are not NULL. */
-	union {
-		struct {
-			const struct ccs_path_info *program;
-		} execute;
-		struct {
-			const struct ccs_path_info *filename;
-			/* One of values in "enum ccs_path_acl_index". */
-			u8 operation;
-		} path;
-		struct {
-			const struct ccs_path_info *filename1;
-			const struct ccs_path_info *filename2;
-			/* One of values in "enum ccs_path2_acl_index". */
-			u8 operation;
-		} path2;
-		struct {
-			const struct ccs_path_info *filename;
-			unsigned int mode;
-			unsigned int major;
-			unsigned int minor;
-			/* One of values in "enum ccs_mkdev_acl_index". */
-			u8 operation;
-		} mkdev;
-		struct {
-			const struct ccs_path_info *filename;
-			unsigned long number;
-			/*
-			 * One of values in "enum ccs_path_number_acl_index".
-			 */
-			u8 operation;
-		} path_number;
+	/* For holding parameters. */
+	struct ccs_request_param {
+		const struct ccs_path_info *s[3];
+		unsigned long i[3];
 #ifdef CONFIG_CCSECURITY_NETWORK
-		struct {
-			const u32 *address; /* Big endian. */
-			u16 port; /* Host endian. */
-			/* One of values smaller than CCS_SOCK_MAX. */
-			u8 protocol;
-			/* One of values in "enum ccs_network_acl_index". */
-			u8 operation;
-			bool is_ipv6;
-		} inet_network;
-		struct {
-			const struct ccs_path_info *address;
-			/* One of values smaller than CCS_SOCK_MAX. */
-			u8 protocol;
-			/* One of values in "enum ccs_network_acl_index". */
-			u8 operation;
-		} unix_network;
+		const u8 *ip; /* Big endian. */
+		bool is_ipv6;
 #endif
-#ifdef CONFIG_CCSECURITY_MISC
-		struct {
-			const struct ccs_path_info *name;
-		} environ;
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-		struct {
-			/* One of values in "enum ccs_capability_acl_index". */
-			u8 operation;
-		} capability;
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-		struct {
-			const char *domainname;
-			unsigned long request;
-		} ptrace;
-#endif
-		struct {
-			const struct ccs_path_info *type;
-			const struct ccs_path_info *dir;
-			const struct ccs_path_info *dev;
-			unsigned long flags;
-			int need_dev;
-		} mount;
-#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
-		struct {
-			const struct ccs_path_info *domainname;
-		} task;
-#endif
 	} param;
+	/* For holding pathnames and attributes. */
+	struct {
+		/*
+		 * True if ccs_get_attributes() was already called, false
+		 * otherwise.
+		 */
+		bool validate_done;
+		/* True if @stat[] is valid. */
+		bool stat_valid[CCS_MAX_PATH_STAT];
+		struct path path[2];
+		/*
+		 * Information on @path[0], @path[0]'s parent directory,
+		 * @path[1] and @path[1]'s parent directory.
+		 */
+		struct ccs_mini_stat stat[CCS_MAX_PATH_STAT];
+		/*
+		 * Name of @path[0] and @path[1].
+		 * Cleared by ccs_crear_request_info().
+		 */
+		struct ccs_path_info pathname[2];
+	} obj;
+	struct {
+		struct linux_binprm *bprm;
+		struct ccs_domain_info *previous_domain;
+		/* For execute_handler. */
+		char *handler; /* kstrdup(handler_path->name, CCS_GFP_FLAGS) */
+		/* For dumping argv[] and envp[]. */
+		struct ccs_page_dump dump;
+		/* For temporary use. Size is CCS_EXEC_TMPSIZE bytes. */
+		char *tmp;
+	};
 	/*
-	 * Matching "struct ccs_acl_info" is copied if access request was
-	 * granted.
+	 * Name of current thread's executable.
+	 * Cleared by ccs_crear_request_info().
 	 */
+	struct ccs_path_info exename;
+	/*
+	 * Matching "struct ccs_acl_info" is copied.
+	 * Valid until ccs_read_unlock().
+	 */
 	struct ccs_acl_info *matched_acl;
-	u8 param_type; /* One of values in "enum ccs_acl_entry_type_index". */
+	/*
+	 * Matching handler and domain transition are copied.
+	 * Valid until ccs_read_unlock().
+	 */
+	const struct ccs_path_info *handler_path;
+	const struct ccs_path_info *transition;
+	/*
+	 * For holding operation index used for this request.
+	 * One of values in "enum ccs_mac_index".
+	 */
+	enum ccs_mac_index type;
 	bool granted; /* True if granted, false otherwise. */
-	/* True if rejected by inverse mode match, false otherwise. */
-	bool inversed;
-	/* True if current thread should not be carried sleep penalty. */
-	bool dont_sleep_on_enforce_error;
 	/*
 	 * For counting number of retries made for this request.
 	 * This counter is incremented whenever ccs_supervisor() returned
@@ -1093,217 +910,21 @@
 	 */
 	u8 retry;
 	/*
-	 * For holding profile number used for this request.
-	 * One of values between 0 and CCS_MAX_PROFILES - 1.
-	 */
-	u8 profile;
-	/*
 	 * For holding operation mode used for this request.
-	 * One of CCS_CONFIG_DISABLED, CCS_CONFIG_LEARNING,
-	 * CCS_CONFIG_PERMISSIVE, CCS_CONFIG_ENFORCING.
+	 * One of CCS_CONFIG_DISABLED, CCS_CONFIG_PERMISSIVE,
+	 * CCS_CONFIG_ENFORCING.
 	 */
-	u8 mode;
-	/*
-	 * For holding operation index used for this request.
-	 * One of values in "enum ccs_mac_index".
-	 */
-	u8 type;
+	enum ccs_mode_value mode;
 };
 
-/* Structure for holding a token. */
-struct ccs_path_info {
-	const char *name;
-	u32 hash;          /* = full_name_hash(name, strlen(name)) */
-	u16 total_len;     /* = strlen(name)                       */
-	u16 const_len;     /* = ccs_const_part_length(name)        */
-	bool is_dir;       /* = ccs_strendswith(name, "/")         */
-	bool is_patterned; /* = const_len < total_len              */
-};
-
-/* Structure for execve() operation. */
-struct ccs_execve {
-	struct ccs_request_info r;
-	struct ccs_obj_info obj;
-	struct linux_binprm *bprm;
-	struct ccs_domain_info *previous_domain;
-	const struct ccs_path_info *transition;
-	/* For execute_handler */
-	const struct ccs_path_info *handler;
-	char *handler_path; /* = kstrdup(handler->name, CCS_GFP_FLAGS) */
-	/* For dumping argv[] and envp[]. */
-	struct ccs_page_dump dump;
-	/* For temporary use. */
-	char *tmp; /* Size is CCS_EXEC_TMPSIZE bytes */
-};
-
 /* Structure for domain information. */
 struct ccs_domain_info {
 	struct list_head list;
-	struct list_head acl_info_list;
 	/* Name of this domain. Never NULL.          */
 	const struct ccs_path_info *domainname;
-	/* Namespace for this domain. Never NULL. */
-	struct ccs_policy_namespace *ns;
-	/* Default domain transition. Never NULL. */
-	const struct ccs_path_info *default_transition;
-	u8 profile;        /* Profile number to use. */
-	bool quota_exceeded;
 	s8 is_deleted;     /* Delete flag.           */
-	struct ccs_condition *cond; /* Used by inverse mode. */
 };
 
-/* Structure for policy manager. */
-struct ccs_manager {
-	struct ccs_acl_head head;
-	bool is_domain;  /* True if manager is a domainname. */
-	/* A path to program or a domainname. */
-	const struct ccs_path_info *manager;
-};
-
-/* Structure for argv[]. */
-struct ccs_argv {
-	unsigned long index;
-	const struct ccs_path_info *value;
-	bool is_not;
-};
-
-/* Structure for envp[]. */
-struct ccs_envp {
-	const struct ccs_path_info *name;
-	const struct ccs_path_info *value;
-	bool is_not;
-};
-
-/*
- * Structure for "task auto_execute_handler" and "task denied_execute_handler"
- * directive.
- *
- * If "task auto_execute_handler" directive exists and the current process is
- * not an execute handler, all execve() requests are replaced by execve()
- * requests of a program specified by "task auto_execute_handler" directive.
- * If the current process is an execute handler, "task auto_execute_handler"
- * and "task denied_execute_handler" directives are ignored.
- * The program specified by "task execute_handler" validates execve()
- * parameters and executes the original execve() requests if appropriate.
- *
- * "task denied_execute_handler" directive is used only when execve() request
- * was rejected in enforcing mode (i.e. CONFIG::file::execute={ mode=enforcing
- * }). The program specified by "task denied_execute_handler" does whatever it
- * wants to do (e.g. silently terminate, change firewall settings, redirect the
- * user to honey pot etc.).
- */
-struct ccs_handler_acl {
-	struct ccs_acl_info head;       /* type = CCS_TYPE_*_EXECUTE_HANDLER */
-	const struct ccs_path_info *handler; /* Pointer to single pathname.  */
-	const struct ccs_path_info *transit; /* Maybe NULL. */
-};
-
-/*
- * Structure for "task auto_domain_transition" and
- * "task manual_domain_transition" directive.
- */
-struct ccs_task_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_*_TASK_ACL */
-	/* Pointer to domainname. */
-	const struct ccs_path_info *domainname;
-};
-
-/* Structure for "file execute" directive. */
-struct ccs_execute_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_EXECUTE_ACL */
-	struct ccs_name_union program;
-	const struct ccs_path_info *transit; /* Maybe NULL. */
-};
-
-/*
- * Structure for "file read", "file write", "file append", "file unlink",
- * "file getattr", "file rmdir", "file truncate", "file chroot" and
- * "file unmount" directive.
- */
-struct ccs_path_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_PATH_ACL */
-	struct ccs_name_union name;
-};
-
-/*
- * Structure for "file rename", "file link", "file pivot_root" and
- * "file symlink" directive.
- */
-struct ccs_path2_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_PATH2_ACL */
-	struct ccs_name_union name1;
-	struct ccs_name_union name2;
-};
-
-/*
- * Structure for "file create", "file mkdir", "file mkfifo", "file mksock",
- * "file ioctl", "file chmod", "file chown" and "file chgrp" directive.
- */
-struct ccs_path_number_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_PATH_NUMBER_ACL */
-	struct ccs_name_union name;
-	struct ccs_number_union number;
-};
-
-/* Structure for "file mkblock" and "file mkchar" directive. */
-struct ccs_mkdev_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_MKDEV_ACL */
-	struct ccs_name_union name;
-	struct ccs_number_union mode;
-	struct ccs_number_union major;
-	struct ccs_number_union minor;
-};
-
-/* Structure for "file mount" directive. */
-struct ccs_mount_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_MOUNT_ACL */
-	struct ccs_name_union dev_name;
-	struct ccs_name_union dir_name;
-	struct ccs_name_union fs_type;
-	struct ccs_number_union flags;
-};
-
-/* Structure for "misc env" directive in domain policy. */
-struct ccs_env_acl {
-	struct ccs_acl_info head;  /* type = CCS_TYPE_ENV_ACL  */
-	struct ccs_name_union env; /* environment variable */
-};
-
-/* Structure for "capability" directive. */
-struct ccs_capability_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_CAPABILITY_ACL */
-	u8 operation; /* One of values in "enum ccs_capability_acl_index". */
-};
-
-/* Structure for "ipc ptrace" directive. */
-struct ccs_ptrace_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_PTRACE_ACL */
-	struct ccs_number_union request;
-	const struct ccs_path_info *domainname;
-};
-
-/* Structure for "network inet" directive. */
-struct ccs_inet_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_INET_ACL */
-	u8 protocol;
-	struct ccs_ipaddr_union address;
-	struct ccs_number_union port;
-};
-
-/* Structure for "network unix" directive. */
-struct ccs_unix_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_UNIX_ACL */
-	u8 protocol;
-	struct ccs_name_union name;
-};
-
-/* Structure for "use_group" directive. */
-struct ccs_use_group_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_USE_GROUP_ACL */
-	struct ccs_group *group;
-	bool is_not;
-};
-
 /* Structure for holding string data. */
 struct ccs_name {
 	struct ccs_shared_acl_head head;
@@ -1311,38 +932,6 @@
 	struct ccs_path_info entry;
 };
 
-/* Structure for holding a line from /proc/ccs/ interface. */
-struct ccs_acl_param {
-	char *data; /* Unprocessed data. */
-	struct list_head *list; /* List to add or remove. */
-	struct ccs_policy_namespace *ns; /* Namespace to use. */
-	bool is_delete; /* True if it is a delete request. */
-	union ccs_acl_union {
-		struct ccs_acl_info acl_info;
-		struct ccs_handler_acl handler_acl;
-		struct ccs_task_acl task_acl;
-		struct ccs_execute_acl execute_acl;
-		struct ccs_path_acl path_acl;
-		struct ccs_path2_acl path2_acl;
-		struct ccs_path_number_acl path_number_acl;
-		struct ccs_mkdev_acl mkdev_acl;
-		struct ccs_mount_acl mount_acl;
-		struct ccs_env_acl env_acl;
-		struct ccs_capability_acl capability_acl;
-		struct ccs_ptrace_acl ptrace_acl;
-		struct ccs_inet_acl inet_acl;
-		struct ccs_unix_acl unix_acl;
-		struct ccs_use_group_acl use_group_acl;
-		/**/
-		struct ccs_acl_head acl_head;
-		struct ccs_manager manager;
-		struct ccs_path_group path_group;
-		struct ccs_number_group number_group;
-		struct ccs_address_group address_group;
-	} e;
-	struct ccs_acl_info *matched_entry; /* Used by inverse mode. */
-};
-
 /* Structure for reading/writing policy via /proc/ccs/ interfaces. */
 struct ccs_io_buffer {
 	/* Exclusive lock for this structure.   */
@@ -1350,32 +939,32 @@
 	char __user *read_user_buf;
 	size_t read_user_buf_avail;
 	struct {
-		struct list_head *ns;
-		struct list_head *domain;
 		struct list_head *group;
 		struct list_head *acl;
-		const struct ccs_path_info *acl_group_name;
+		struct list_head *subacl;
+		const union ccs_condition_element *cond;
 		size_t avail;
 		unsigned int step;
 		unsigned int query_index;
 		u16 index;
-		u16 cond_index;
 		u8 cond_step;
-		u8 bit;
 		u8 w_pos;
+		enum ccs_mac_index acl_index;
 		bool eof;
-		bool print_this_domain_only;
-		bool print_transition_related_only;
-		bool print_cond_part;
-		bool print_default_transition;
+		bool print_this_acl_only;
+		bool version_done;
+		bool stat_done;
+		bool group_done;
 		const char *w[CCS_MAX_IO_READ_QUEUE];
 	} r;
 	struct {
-		struct ccs_policy_namespace *ns;
-		struct ccs_domain_info *domain;
-		struct ccs_acl_info *acl; /* Used by inverse mode. */
+		char *data;
+		struct ccs_acl_info *acl;
 		size_t avail;
+		enum ccs_mac_index acl_index;
 		bool is_delete;
+		bool is_deny;
+		u16 priority;
 	} w;
 	/* Buffer for reading.                  */
 	char *read_buf;
@@ -1393,14 +982,6 @@
 	struct list_head list;
 };
 
-/* Structure for /proc/ccs/profile interface. */
-struct ccs_profile {
-	const struct ccs_path_info *comment;
-	u8 default_config;
-	u8 config[CCS_MAX_MAC_INDEX + CCS_MAX_MAC_CATEGORY_INDEX];
-	unsigned int pref[CCS_MAX_PREF];
-};
-
 /* Structure for representing YYYY/MM/DD hh/mm/ss. */
 struct ccs_time {
 	u16 year;
@@ -1411,22 +992,6 @@
 	u8 sec;
 };
 
-/* Structure for policy namespace. */
-struct ccs_policy_namespace {
-	/* Profile table. Memory is allocated as needed. */
-	struct ccs_profile *profile_ptr[CCS_MAX_PROFILES];
-	/* List of "struct ccs_group". */
-	struct list_head group_list[CCS_MAX_GROUP];
-	/* List of default transition pattern. */
-	struct list_head default_transition_list;
-	/* List for connecting to ccs_namespace_list list. */
-	struct list_head namespace_list;
-	/* Profile version. Currently only 20100903 is defined. */
-	unsigned int profile_version;
-	/* Name of this namespace (e.g. "<kernel>", "</usr/sbin/httpd>" ). */
-	const char *name;
-};
-
 /* Prototype definition for "struct ccsecurity_operations". */
 
 void __init ccs_permission_init(void);
@@ -1436,42 +1001,35 @@
 
 bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos,
 		   struct ccs_page_dump *dump);
+bool ccs_get_exename(struct ccs_path_info *buf);
+bool ccs_manager(void);
 bool ccs_memory_ok(const void *ptr, const unsigned int size);
 char *ccs_encode(const char *str);
 char *ccs_encode2(const char *str, int str_len);
 char *ccs_realpath(struct path *path);
-char *ccs_realpath2(struct path *path, bool force_no_fsname);
 const char *ccs_get_exe(void);
 const struct ccs_path_info *ccs_get_name(const char *name);
 int ccs_audit_log(struct ccs_request_info *r);
-int ccs_check_acl(struct ccs_request_info *r);
-struct ccs_domain_info *ccs_assign_domain(const char *domainname,
-					  const bool transit);
+int ccs_check_acl(struct ccs_request_info *r, const bool clear);
+struct ccs_domain_info *ccs_assign_domain(const char *domainname);
 void *ccs_commit_ok(void *data, const unsigned int size);
-void ccs_del_acl(struct list_head *element);
 void ccs_del_condition(struct list_head *element);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
-void ccs_get_attributes(struct ccs_obj_info *obj);
+void ccs_get_attributes(struct ccs_request_info *r);
 void ccs_notify_gc(struct ccs_io_buffer *head, const bool is_register);
+void ccs_populate_patharg(struct ccs_request_info *r, const bool first);
 void ccs_transition_failed(const char *domainname);
 void ccs_warn_oom(const char *function);
 
 /* Variable definition for internal use. */
 
 extern bool ccs_policy_loaded;
-extern const u8 ccs_c2mac[CCS_MAX_CAPABILITY_INDEX];
-extern const u8 ccs_p2mac[CCS_MAX_PATH_OPERATION];
-extern const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION];
-extern const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION];
-extern const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION];
 extern struct ccs_domain_info ccs_kernel_domain;
-extern struct ccs_group ccs_group_any;
+extern struct list_head ccs_acl_list[CCS_MAX_MAC_INDEX];
 extern struct list_head ccs_condition_list;
 extern struct list_head ccs_domain_list;
-extern struct list_head ccs_inversed_acl_list;
+extern struct list_head ccs_group_list[CCS_MAX_GROUP];
 extern struct list_head ccs_name_list[CCS_MAX_HASH];
-extern struct list_head ccs_namespace_list;
-extern struct list_head ccs_manager_list;
 extern struct mutex ccs_policy_lock;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
 extern struct srcu_struct ccs_ss;
@@ -1782,8 +1340,8 @@
 #ifdef CONFIG_CCSECURITY_USE_EXTERNAL_TASK_SECURITY
 
 /*
- * Structure for holding "struct ccs_domain_info *" and "struct ccs_execve *"
- * and "u32 ccs_flags" for each "struct task_struct".
+ * Structure for holding "struct ccs_domain_info *" and "u32 ccs_flags" for
+ * each "struct task_struct".
  *
  * "struct ccs_domain_info *" and "u32 ccs_flags" for each "struct task_struct"
  * are maintained outside that "struct task_struct". Therefore, ccs_security
@@ -1957,14 +1515,4 @@
 
 #endif
 
-/**
- * ccs_current_namespace - Get "struct ccs_policy_namespace" for current thread.
- *
- * Returns pointer to "struct ccs_policy_namespace" for current thread.
- */
-static inline struct ccs_policy_namespace *ccs_current_namespace(void)
-{
-	return ccs_current_domain()->ns;
-}
-
 #endif
Index: policy_io.c
===================================================================
--- policy_io.c	(revision 5869)
+++ policy_io.c	(working copy)
@@ -21,7 +21,7 @@
 
 /* Mapping table from "enum ccs_mac_index" to "enum ccs_mac_category_index". */
 static const u8 ccs_index2category[CCS_MAX_MAC_INDEX] = {
-	/* CONFIG::file group */
+	/* file group */
 	[CCS_MAC_FILE_EXECUTE]    = CCS_MAC_CATEGORY_FILE,
 	[CCS_MAC_FILE_READ]       = CCS_MAC_CATEGORY_FILE,
 	[CCS_MAC_FILE_WRITE]      = CCS_MAC_CATEGORY_FILE,
@@ -49,12 +49,12 @@
 	[CCS_MAC_FILE_MOUNT]      = CCS_MAC_CATEGORY_FILE,
 	[CCS_MAC_FILE_UMOUNT]     = CCS_MAC_CATEGORY_FILE,
 	[CCS_MAC_FILE_PIVOT_ROOT] = CCS_MAC_CATEGORY_FILE,
+	/* misc group */
 #ifdef CONFIG_CCSECURITY_MISC
-	/* CONFIG::misc group */
 	[CCS_MAC_ENVIRON]         = CCS_MAC_CATEGORY_MISC,
 #endif
+	/* network group */
 #ifdef CONFIG_CCSECURITY_NETWORK
-	/* CONFIG::network group */
 	[CCS_MAC_NETWORK_INET_STREAM_BIND]       = CCS_MAC_CATEGORY_NETWORK,
 	[CCS_MAC_NETWORK_INET_STREAM_LISTEN]     = CCS_MAC_CATEGORY_NETWORK,
 	[CCS_MAC_NETWORK_INET_STREAM_CONNECT]    = CCS_MAC_CATEGORY_NETWORK,
@@ -83,12 +83,13 @@
 	[CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = CCS_MAC_CATEGORY_NETWORK,
 	[CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT]  = CCS_MAC_CATEGORY_NETWORK,
 #endif
+	/* ipc group */
 #ifdef CONFIG_CCSECURITY_IPC
-	/* CONFIG::ipc group */
 	[CCS_MAC_PTRACE]          = CCS_MAC_CATEGORY_IPC,
 #endif
+	/* capability group */
+	[CCS_MAC_CAPABILITY_MODIFY_POLICY]     = CCS_MAC_CATEGORY_CAPABILITY,
 #ifdef CONFIG_CCSECURITY_CAPABILITY
-	/* CONFIG::capability group */
 	[CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET]  = CCS_MAC_CATEGORY_CAPABILITY,
 	[CCS_MAC_CAPABILITY_USE_PACKET_SOCKET] = CCS_MAC_CATEGORY_CAPABILITY,
 	[CCS_MAC_CAPABILITY_SYS_REBOOT]        = CCS_MAC_CATEGORY_CAPABILITY,
@@ -99,20 +100,26 @@
 	[CCS_MAC_CAPABILITY_USE_KERNEL_MODULE] = CCS_MAC_CATEGORY_CAPABILITY,
 	[CCS_MAC_CAPABILITY_SYS_KEXEC_LOAD]    = CCS_MAC_CATEGORY_CAPABILITY,
 #endif
+#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
+	[CCS_MAC_AUTO_EXECUTE_HANDLER]   = CCS_MAC_CATEGORY_TASK,
+	[CCS_MAC_DENIED_EXECUTE_HANDLER] = CCS_MAC_CATEGORY_TASK,
+#endif
+#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
+	[CCS_MAC_AUTO_TASK_TRANSITION]   = CCS_MAC_CATEGORY_TASK,
+	[CCS_MAC_MANUAL_TASK_TRANSITION] = CCS_MAC_CATEGORY_TASK,
+#endif
 };
 
 /* String table for operation mode. */
 static const char * const ccs_mode[CCS_CONFIG_MAX_MODE] = {
 	[CCS_CONFIG_DISABLED]   = "disabled",
-	[CCS_CONFIG_LEARNING]   = "learning",
 	[CCS_CONFIG_PERMISSIVE] = "permissive",
 	[CCS_CONFIG_ENFORCING]  = "enforcing"
 };
 
-/* String table for /proc/ccs/profile interface. */
-static const char * const ccs_mac_keywords[CCS_MAX_MAC_INDEX
-					   + CCS_MAX_MAC_CATEGORY_INDEX] = {
-	/* CONFIG::file group */
+/* String table for operation. */
+static const char * const ccs_mac_keywords[CCS_MAX_MAC_INDEX] = {
+	/* file group */
 	[CCS_MAC_FILE_EXECUTE]    = "execute",
 	[CCS_MAC_FILE_READ]       = "read",
 	[CCS_MAC_FILE_WRITE]      = "write",
@@ -140,12 +147,12 @@
 	[CCS_MAC_FILE_MOUNT]      = "mount",
 	[CCS_MAC_FILE_UMOUNT]     = "unmount",
 	[CCS_MAC_FILE_PIVOT_ROOT] = "pivot_root",
+	/* misc group */
 #ifdef CONFIG_CCSECURITY_MISC
-	/* CONFIG::misc group */
 	[CCS_MAC_ENVIRON] = "env",
 #endif
+	/* network group */
 #ifdef CONFIG_CCSECURITY_NETWORK
-	/* CONFIG::network group */
 	[CCS_MAC_NETWORK_INET_STREAM_BIND]       = "inet_stream_bind",
 	[CCS_MAC_NETWORK_INET_STREAM_LISTEN]     = "inet_stream_listen",
 	[CCS_MAC_NETWORK_INET_STREAM_CONNECT]    = "inet_stream_connect",
@@ -174,12 +181,13 @@
 	[CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = "unix_seqpacket_connect",
 	[CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT]  = "unix_seqpacket_accept",
 #endif
+	/* ipc group */
 #ifdef CONFIG_CCSECURITY_IPC
-	/* CONFIG::ipc group */
 	[CCS_MAC_PTRACE] = "ptrace",
 #endif
+	/* capability group */
+	[CCS_MAC_CAPABILITY_MODIFY_POLICY]     = "modify_policy",
 #ifdef CONFIG_CCSECURITY_CAPABILITY
-	/* CONFIG::capability group */
 	[CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET]  = "use_route",
 	[CCS_MAC_CAPABILITY_USE_PACKET_SOCKET] = "use_packet",
 	[CCS_MAC_CAPABILITY_SYS_REBOOT]        = "SYS_REBOOT",
@@ -190,48 +198,17 @@
 	[CCS_MAC_CAPABILITY_USE_KERNEL_MODULE] = "use_kernel_module",
 	[CCS_MAC_CAPABILITY_SYS_KEXEC_LOAD]    = "SYS_KEXEC_LOAD",
 #endif
-	/* CONFIG group */
-	[CCS_MAX_MAC_INDEX + CCS_MAC_CATEGORY_FILE]       = "file",
-#ifdef CONFIG_CCSECURITY_NETWORK
-	[CCS_MAX_MAC_INDEX + CCS_MAC_CATEGORY_NETWORK]    = "network",
+	/* No corresponding profile line. */
+#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
+	[CCS_MAC_AUTO_EXECUTE_HANDLER]   = "auto_execute_handler",
+	[CCS_MAC_DENIED_EXECUTE_HANDLER] = "denied_execute_handler",
 #endif
-#ifdef CONFIG_CCSECURITY_MISC
-	[CCS_MAX_MAC_INDEX + CCS_MAC_CATEGORY_MISC]       = "misc",
+#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
+	[CCS_MAC_AUTO_TASK_TRANSITION]   = "auto_domain_transition",
+	[CCS_MAC_MANUAL_TASK_TRANSITION] = "manual_domain_transition",
 #endif
-#ifdef CONFIG_CCSECURITY_IPC
-	[CCS_MAX_MAC_INDEX + CCS_MAC_CATEGORY_IPC]        = "ipc",
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-	[CCS_MAX_MAC_INDEX + CCS_MAC_CATEGORY_CAPABILITY] = "capability",
-#endif
 };
 
-#ifdef CONFIG_CCSECURITY_NETWORK
-
-/* String table for socket's operation. */
-static const char * const ccs_socket_keyword[CCS_MAX_NETWORK_OPERATION] = {
-	[CCS_NETWORK_BIND]    = "bind",
-	[CCS_NETWORK_LISTEN]  = "listen",
-	[CCS_NETWORK_CONNECT] = "connect",
-	[CCS_NETWORK_ACCEPT]  = "accept",
-	[CCS_NETWORK_SEND]    = "send",
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-	[CCS_NETWORK_RECV]    = "recv",
-#endif
-};
-
-/* String table for socket's protocols. */
-static const char * const ccs_proto_keyword[CCS_SOCK_MAX] = {
-	[SOCK_STREAM]    = "stream",
-	[SOCK_DGRAM]     = "dgram",
-	[SOCK_RAW]       = "raw",
-	[SOCK_SEQPACKET] = "seqpacket",
-	[0] = " ", /* Dummy for avoiding NULL pointer dereference. */
-	[4] = " ", /* Dummy for avoiding NULL pointer dereference. */
-};
-
-#endif
-
 /* String table for categories. */
 static const char * const ccs_category_keywords[CCS_MAX_MAC_CATEGORY_INDEX] = {
 	[CCS_MAC_CATEGORY_FILE]       = "file",
@@ -244,32 +221,37 @@
 #ifdef CONFIG_CCSECURITY_IPC
 	[CCS_MAC_CATEGORY_IPC]        = "ipc",
 #endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
 	[CCS_MAC_CATEGORY_CAPABILITY] = "capability",
+#if defined(CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER) || defined(CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION)
+	[CCS_MAC_CATEGORY_TASK]       = "task",
 #endif
+	[CCS_MAC_CATEGORY_NONE]       = "",
 };
 
 /* String table for conditions. */
-static const char * const ccs_condition_keyword[CCS_MAX_CONDITION_KEYWORD] = {
-	[CCS_TASK_UID]             = "task.uid",
-	[CCS_TASK_EUID]            = "task.euid",
-	[CCS_TASK_SUID]            = "task.suid",
-	[CCS_TASK_FSUID]           = "task.fsuid",
-	[CCS_TASK_GID]             = "task.gid",
-	[CCS_TASK_EGID]            = "task.egid",
-	[CCS_TASK_SGID]            = "task.sgid",
-	[CCS_TASK_FSGID]           = "task.fsgid",
-	[CCS_TASK_PID]             = "task.pid",
-	[CCS_TASK_PPID]            = "task.ppid",
-	[CCS_EXEC_ARGC]            = "exec.argc",
-	[CCS_EXEC_ENVC]            = "exec.envc",
-	[CCS_TYPE_IS_SOCKET]       = "socket",
-	[CCS_TYPE_IS_SYMLINK]      = "symlink",
-	[CCS_TYPE_IS_FILE]         = "file",
-	[CCS_TYPE_IS_BLOCK_DEV]    = "block",
-	[CCS_TYPE_IS_DIRECTORY]    = "directory",
-	[CCS_TYPE_IS_CHAR_DEV]     = "char",
-	[CCS_TYPE_IS_FIFO]         = "fifo",
+static const char *const ccs_condition_keyword[CCS_MAX_CONDITION_KEYWORD] = {
+	[CCS_SELF_UID]             = "uid",
+	[CCS_SELF_EUID]            = "euid",
+	[CCS_SELF_SUID]            = "suid",
+	[CCS_SELF_FSUID]           = "fsuid",
+	[CCS_SELF_GID]             = "gid",
+	[CCS_SELF_EGID]            = "egid",
+	[CCS_SELF_SGID]            = "sgid",
+	[CCS_SELF_FSGID]           = "fsgid",
+	[CCS_SELF_PID]             = "pid",
+	[CCS_SELF_PPID]            = "ppid",
+	[CCS_TASK_TYPE]            = "type",
+	[CCS_SELF_DOMAIN]          = "domain",
+	[CCS_SELF_EXE]             = "exe",
+	[CCS_EXEC_ARGC]            = "argc",
+	[CCS_EXEC_ENVC]            = "envc",
+	[CCS_OBJ_IS_SOCKET]        = "socket",
+	[CCS_OBJ_IS_SYMLINK]       = "symlink",
+	[CCS_OBJ_IS_FILE]          = "file",
+	[CCS_OBJ_IS_BLOCK_DEV]     = "block",
+	[CCS_OBJ_IS_DIRECTORY]     = "directory",
+	[CCS_OBJ_IS_CHAR_DEV]      = "char",
+	[CCS_OBJ_IS_FIFO]          = "fifo",
 	[CCS_MODE_SETUID]          = "setuid",
 	[CCS_MODE_SETGID]          = "setgid",
 	[CCS_MODE_STICKY]          = "sticky",
@@ -282,70 +264,39 @@
 	[CCS_MODE_OTHERS_READ]     = "others_read",
 	[CCS_MODE_OTHERS_WRITE]    = "others_write",
 	[CCS_MODE_OTHERS_EXECUTE]  = "others_execute",
-	[CCS_TASK_TYPE]            = "task.type",
 	[CCS_TASK_EXECUTE_HANDLER] = "execute_handler",
-	[CCS_EXEC_REALPATH]        = "exec.realpath",
-	[CCS_PATH1_UID]            = "path1.uid",
-	[CCS_PATH1_GID]            = "path1.gid",
-	[CCS_PATH1_INO]            = "path1.ino",
-	[CCS_PATH1_MAJOR]          = "path1.major",
-	[CCS_PATH1_MINOR]          = "path1.minor",
-	[CCS_PATH1_PERM]           = "path1.perm",
-	[CCS_PATH1_TYPE]           = "path1.type",
-	[CCS_PATH1_DEV_MAJOR]      = "path1.dev_major",
-	[CCS_PATH1_DEV_MINOR]      = "path1.dev_minor",
-	[CCS_PATH2_UID]            = "path2.uid",
-	[CCS_PATH2_GID]            = "path2.gid",
-	[CCS_PATH2_INO]            = "path2.ino",
-	[CCS_PATH2_MAJOR]          = "path2.major",
-	[CCS_PATH2_MINOR]          = "path2.minor",
-	[CCS_PATH2_PERM]           = "path2.perm",
-	[CCS_PATH2_TYPE]           = "path2.type",
-	[CCS_PATH2_DEV_MAJOR]      = "path2.dev_major",
-	[CCS_PATH2_DEV_MINOR]      = "path2.dev_minor",
-	[CCS_PATH1_PARENT_UID]     = "path1.parent.uid",
-	[CCS_PATH1_PARENT_GID]     = "path1.parent.gid",
-	[CCS_PATH1_PARENT_INO]     = "path1.parent.ino",
-	[CCS_PATH1_PARENT_PERM]    = "path1.parent.perm",
-	[CCS_PATH2_PARENT_UID]     = "path2.parent.uid",
-	[CCS_PATH2_PARENT_GID]     = "path2.parent.gid",
-	[CCS_PATH2_PARENT_INO]     = "path2.parent.ino",
-	[CCS_PATH2_PARENT_PERM]    = "path2.parent.perm",
+	[CCS_HANDLER_PATH]         = "handler",
+	[CCS_TRANSIT_DOMAIN]       = "transition",
 };
 
-/* String table for PREFERENCE keyword. */
-static const char * const ccs_pref_keywords[CCS_MAX_PREF] = {
-	[CCS_PREF_MAX_AUDIT_LOG]      = "max_audit_log",
-	[CCS_PREF_MAX_LEARNING_ENTRY] = "max_learning_entry",
-	[CCS_PREF_ENFORCING_PENALTY]  = "enforcing_penalty",
+/* String table for file attributes. */
+static const char *const ccs_path_attribute[CCS_MAX_PATH_ATTRIBUTE] = {
+	[CCS_PATH_ATTRIBUTE_UID]       = "uid",
+	[CCS_PATH_ATTRIBUTE_GID]       = "gid",
+	[CCS_PATH_ATTRIBUTE_INO]       = "ino",
+	[CCS_PATH_ATTRIBUTE_MAJOR]     = "major",
+	[CCS_PATH_ATTRIBUTE_MINOR]     = "minor",
+	[CCS_PATH_ATTRIBUTE_PERM]      = "perm",
+	[CCS_PATH_ATTRIBUTE_TYPE]      = "type",
+	[CCS_PATH_ATTRIBUTE_DEV_MAJOR] = "dev_major",
+	[CCS_PATH_ATTRIBUTE_DEV_MINOR] = "dev_minor",
+	[CCS_PATH_ATTRIBUTE_FSMAGIC]   = "fsmagic",
 };
 
-/* String table for domain flags. */
-#define CCS_QUOTA_EXCEEDED "quota_exceeded\n"
-
 /* String table for grouping keywords. */
 static const char * const ccs_group_name[CCS_MAX_GROUP] = {
-	[CCS_PATH_GROUP]    = "path_group ",
-	[CCS_NUMBER_GROUP]  = "number_group ",
-	[CCS_ACL_GROUP]     = "acl_group ",
+	[CCS_PATH_GROUP]    = "path_group",
+	[CCS_NUMBER_GROUP]  = "number_group",
 #ifdef CONFIG_CCSECURITY_NETWORK
-	[CCS_ADDRESS_GROUP] = "address_group ",
+	[CCS_ADDRESS_GROUP] = "address_group",
 #endif
 };
 
-/* String table for /proc/ccs/stat interface. */
-static const char * const ccs_policy_headers[CCS_MAX_POLICY_STAT] = {
-	[CCS_STAT_POLICY_UPDATES]    = "update:",
-	[CCS_STAT_POLICY_LEARNING]   = "violation in learning mode:",
-	[CCS_STAT_POLICY_PERMISSIVE] = "violation in permissive mode:",
-	[CCS_STAT_POLICY_ENFORCING]  = "violation in enforcing mode:",
-};
-
-/* String table for /proc/ccs/stat interface. */
+/* String table for stat info. */
 static const char * const ccs_memory_headers[CCS_MAX_MEMORY_STAT] = {
-	[CCS_MEMORY_POLICY]     = "policy:",
-	[CCS_MEMORY_AUDIT]      = "audit log:",
-	[CCS_MEMORY_QUERY]      = "query message:",
+	[CCS_MEMORY_POLICY]     = "policy",
+	[CCS_MEMORY_AUDIT]      = "audit",
+	[CCS_MEMORY_QUERY]      = "query",
 };
 
 /***** SECTION2: Structure definition *****/
@@ -355,7 +306,7 @@
 /* Structure for query. */
 struct ccs_query {
 	struct list_head list;
-	struct ccs_domain_info *domain;
+	struct ccs_acl_info *acl;
 	char *query;
 	size_t query_len;
 	unsigned int serial;
@@ -369,117 +320,63 @@
 	struct list_head list;
 	char *log;
 	int size;
+	bool is_granted;
 };
 
 /***** SECTION3: Prototype definition section *****/
 
 int ccs_audit_log(struct ccs_request_info *r);
-struct ccs_domain_info *ccs_assign_domain(const char *domainname,
-					  const bool transit);
+bool ccs_manager(void);
+struct ccs_domain_info *ccs_assign_domain(const char *domainname);
 
 static bool ccs_correct_domain(const unsigned char *domainname);
-static bool ccs_correct_path(const char *filename);
 static bool ccs_correct_word(const char *string);
 static bool ccs_correct_word2(const char *string, size_t len);
-static bool ccs_domain_def(const unsigned char *buffer);
-static bool ccs_domain_quota_ok(struct ccs_request_info *r);
 static bool ccs_flush(struct ccs_io_buffer *head);
 static bool ccs_get_audit(const struct ccs_request_info *r);
-static bool ccs_has_more_namespace(struct ccs_io_buffer *head);
-static bool ccs_manager(void);
-static bool ccs_namespace_jump(const char *domainname);
-static bool ccs_parse_argv(char *left, char *right, struct ccs_argv *argv);
-static bool ccs_parse_envp(char *left, char *right, struct ccs_envp *envp);
-static bool ccs_parse_name_union(struct ccs_acl_param *param,
-				 struct ccs_name_union *ptr);
-static bool ccs_parse_name_union_quoted(struct ccs_acl_param *param,
-					struct ccs_name_union *ptr);
-static bool ccs_parse_number_union(struct ccs_acl_param *param,
-				   struct ccs_number_union *ptr);
-static bool ccs_permstr(const char *string, const char *keyword);
 static bool ccs_print_condition(struct ccs_io_buffer *head,
 				const struct ccs_condition *cond);
-static bool ccs_print_entry(struct ccs_io_buffer *head,
-			    const struct ccs_acl_info *acl);
-static bool ccs_print_group(struct ccs_io_buffer *head, const bool is_not,
-			    const struct ccs_group *group);
-static bool ccs_read_acl(struct ccs_io_buffer *head, struct list_head *list);
+static bool ccs_read_acl(struct ccs_io_buffer *head,
+			 const struct ccs_acl_info *acl);
 static bool ccs_read_group(struct ccs_io_buffer *head, const int idx);
-static bool ccs_same_condition(const struct ccs_condition *a,
-			       const struct ccs_condition *b);
-static bool ccs_select_domain(struct ccs_io_buffer *head, const char *data);
+static bool ccs_select_acl(struct ccs_io_buffer *head, const char *data);
 static bool ccs_set_lf(struct ccs_io_buffer *head);
 static bool ccs_str_starts(char **src, const char *find);
-static char *ccs_get_transit_preference(struct ccs_acl_param *param,
-					struct ccs_execute_acl *e);
 static char *ccs_init_log(struct ccs_request_info *r, int len, const char *fmt,
 			  va_list args);
 static char *ccs_print_bprm(struct linux_binprm *bprm,
 			    struct ccs_page_dump *dump);
 static char *ccs_print_header(struct ccs_request_info *r);
-static char *ccs_read_token(struct ccs_acl_param *param);
+static char *ccs_read_token(struct ccs_io_buffer *head);
 static const char *ccs_yesno(const unsigned int value);
-static const struct ccs_path_info *ccs_get_domainname
-(struct ccs_acl_param *param);
 static const struct ccs_path_info *ccs_get_dqword(char *start);
 static int __init ccs_init_module(void);
-static int ccs_delete_domain(char *domainname);
 static int ccs_open(struct inode *inode, struct file *file);
 static int ccs_parse_policy(struct ccs_io_buffer *head, char *line);
 static int ccs_poll_log(struct file *file, poll_table *wait);
 static int ccs_poll_query(struct file *file, poll_table *wait);
 static int ccs_release(struct inode *inode, struct file *file);
-static int ccs_set_mode(char *name, const char *value,
-			struct ccs_profile *profile);
 static int ccs_supervisor(struct ccs_request_info *r, const char *fmt, ...)
 	__printf(2, 3);
-static int ccs_update_acl(const int size, struct ccs_acl_param *param);
-static int ccs_update_inverse_list(struct ccs_acl_info *new_entry,
-				   const int size,
-				   struct ccs_acl_param *param);
-static int ccs_update_manager_entry(const char *manager, const bool is_delete);
-static int ccs_update_policy(const int size, struct ccs_acl_param *param);
-static int ccs_write_acl(struct ccs_policy_namespace *ns,
-			 struct list_head *list, char *data,
-			 const bool is_delete);
-static int ccs_write_acl_policy(struct ccs_io_buffer *head);
+static int ccs_update_group(struct ccs_io_buffer *head,
+			    const enum ccs_group_id type);
 static int ccs_write_answer(struct ccs_io_buffer *head);
-static int ccs_write_domain(struct ccs_io_buffer *head);
-static int ccs_write_exception(struct ccs_io_buffer *head);
-static int ccs_write_file(struct ccs_acl_param *param);
-static int ccs_write_group(struct ccs_acl_param *param, const u8 type);
-static int ccs_write_manager(struct ccs_io_buffer *head);
 static int ccs_write_pid(struct ccs_io_buffer *head);
-static int ccs_write_profile(struct ccs_io_buffer *head);
-static int ccs_write_stat(struct ccs_io_buffer *head);
-static int ccs_write_task(struct ccs_acl_param *param);
-static int ccs_write_transition_control(struct ccs_acl_param *param);
-static int ccs_write_use_group_acl(struct ccs_acl_param *param);
-static s8 ccs_find_yesno(const char *string, const char *find);
+static int ccs_write_policy(struct ccs_io_buffer *head);
+static int ccs_write_quota(char *data);
 static ssize_t ccs_read(struct file *file, char __user *buf, size_t count,
 			loff_t *ppos);
 static ssize_t ccs_read_self(struct file *file, char __user *buf, size_t count,
 			     loff_t *ppos);
 static ssize_t ccs_write(struct file *file, const char __user *buf,
 			 size_t count, loff_t *ppos);
-static struct ccs_condition *ccs_commit_condition(struct ccs_condition *entry);
-static struct ccs_condition *ccs_get_condition(struct ccs_acl_param *param);
+static struct ccs_condition *ccs_get_condition(struct ccs_io_buffer *head);
 static struct ccs_domain_info *ccs_find_domain(const char *domainname);
-static struct ccs_domain_info *ccs_find_domain_by_qid(unsigned int serial);
-static struct ccs_group *ccs_get_group(struct ccs_acl_param *param,
-				       const u8 idx);
-static struct ccs_policy_namespace *ccs_assign_namespace
-(const char *domainname);
-static struct ccs_policy_namespace *ccs_find_namespace(const char *name,
-						       const unsigned int len);
-static struct ccs_profile *ccs_assign_profile(struct ccs_policy_namespace *ns,
-					      const unsigned int profile);
-static struct ccs_profile *ccs_profile(const u8 profile);
-static u8 ccs_condition_type(const char *word);
-static u8 ccs_get_config(const u8 profile, const u8 index);
-static u8 ccs_group_type(char **src);
+static struct ccs_acl_info *ccs_find_acl_by_qid(unsigned int serial);
+static struct ccs_group *ccs_get_group(struct ccs_io_buffer *head,
+				       const enum ccs_group_id idx);
 static u8 ccs_make_byte(const u8 c1, const u8 c2, const u8 c3);
-static u8 ccs_parse_ulong(unsigned long *result, char **str);
+static enum ccs_value_type ccs_parse_ulong(unsigned long *result, char **str);
 static unsigned int ccs_poll(struct file *file, poll_table *wait);
 static void __init ccs_create_entry(const char *name, const umode_t mode,
 				    struct proc_dir_entry *parent,
@@ -487,75 +384,33 @@
 static void __init ccs_load_builtin_policy(void);
 static void __init ccs_policy_io_init(void);
 static void __init ccs_proc_init(void);
-static void ccs_add_entry(char *header);
-static void ccs_addprintf(char *buffer, int len, const char *fmt, ...)
-	__printf(3, 4);
-static void ccs_addprintf(char *buffer, int len, const char *fmt, ...);
 static void ccs_check_profile(void);
 static void ccs_convert_time(time_t time, struct ccs_time *stamp);
-static void ccs_init_policy_namespace(struct ccs_policy_namespace *ns);
 static void ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
 	__printf(2, 3);
 static void ccs_normalize_line(unsigned char *buffer);
-static void ccs_print_config(struct ccs_io_buffer *head, const u8 config);
-static void ccs_print_name_union(struct ccs_io_buffer *head,
-				 const struct ccs_name_union *ptr);
-static void ccs_print_name_union_quoted(struct ccs_io_buffer *head,
-					const struct ccs_name_union *ptr);
-static void ccs_print_namespace(struct ccs_io_buffer *head);
-static void ccs_print_number_union(struct ccs_io_buffer *head,
-				   const struct ccs_number_union *ptr);
-static void ccs_print_number_union_nospace(struct ccs_io_buffer *head,
-					   const struct ccs_number_union *ptr);
-static void ccs_read_domain(struct ccs_io_buffer *head);
-static void ccs_read_exception(struct ccs_io_buffer *head);
-static void ccs_read_inverse_policy(struct ccs_io_buffer *head);
 static void ccs_read_log(struct ccs_io_buffer *head);
-static void ccs_read_manager(struct ccs_io_buffer *head);
 static void ccs_read_pid(struct ccs_io_buffer *head);
-static void ccs_read_profile(struct ccs_io_buffer *head);
+static void ccs_read_policy(struct ccs_io_buffer *head);
 static void ccs_read_query(struct ccs_io_buffer *head);
-static void ccs_read_stat(struct ccs_io_buffer *head);
+static bool ccs_read_stat(struct ccs_io_buffer *head);
 static void ccs_read_version(struct ccs_io_buffer *head);
-static void ccs_set_group(struct ccs_io_buffer *head, const char *category);
-static void ccs_set_namespace_cursor(struct ccs_io_buffer *head);
-static void ccs_set_slash(struct ccs_io_buffer *head);
 static void ccs_set_space(struct ccs_io_buffer *head);
 static void ccs_set_string(struct ccs_io_buffer *head, const char *string);
-static void ccs_set_uint(unsigned int *i, const char *string,
-			 const char *find);
 static void ccs_update_stat(const u8 index);
-static void ccs_write_log(struct ccs_request_info *r, const char *fmt, ...)
-	__printf(2, 3);
-static void ccs_write_log2(struct ccs_request_info *r, int len,
-			   const char *fmt, va_list args);
+static void ccs_write_log(struct ccs_request_info *r, int len, const char *fmt,
+			  va_list args);
 
 
 #ifdef CONFIG_CCSECURITY_NETWORK
-static bool ccs_parse_ipaddr_union(struct ccs_acl_param *param,
-				   struct ccs_ipaddr_union *ptr);
 static int ccs_print_ipv4(char *buffer, const unsigned int buffer_len,
-			  const u32 *ip);
+			  const u8 *ip);
 static int ccs_print_ipv6(char *buffer, const unsigned int buffer_len,
 			  const struct in6_addr *ip);
-static int ccs_write_inet_network(struct ccs_acl_param *param);
-static int ccs_write_unix_network(struct ccs_acl_param *param);
-static void ccs_print_ip(char *buf, const unsigned int size,
-			 const struct ccs_ipaddr_union *ptr);
+static void ccs_print_ip(struct ccs_io_buffer *head,
+			 struct ccs_address_group *member);
 #endif
 
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-static int ccs_write_capability(struct ccs_acl_param *param);
-#endif
-
-#ifdef CONFIG_CCSECURITY_MISC
-static int ccs_write_misc(struct ccs_acl_param *param);
-#endif
-
-#ifdef CONFIG_CCSECURITY_IPC
-static int ccs_write_ipc(struct ccs_acl_param *param);
-#endif
-
 #ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
 static ssize_t ccs_write_self(struct file *file, const char __user *buf,
 			      size_t count, loff_t *ppos);
@@ -1088,18 +943,18 @@
  *
  * @buffer:     Buffer to write to.
  * @buffer_len: Size of @buffer.
- * @ip:         Pointer to "u32 in network byte order".
+ * @ip:         Pointer to "u8" in network byte order.
  *
  * Returns written length.
  */
 static int ccs_print_ipv4(char *buffer, const unsigned int buffer_len,
-			  const u32 *ip)
+			  const u8 *ip)
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
 	return snprintf(buffer, buffer_len, "%pI4", ip);
 #else
 	char addr[sizeof("255.255.255.255")];
-	ip4_string(addr, (const u8 *) ip);
+	ip4_string(addr, ip);
 	return snprintf(buffer, buffer_len, "%s", addr);
 #endif
 }
@@ -1128,60 +983,255 @@
 /**
  * ccs_print_ip - Print an IP address.
  *
- * @buf:  Buffer to write to.
- * @size: Size of @buf.
- * @ptr:  Pointer to "struct ipaddr_union".
+ * @head:   Pointer to "struct ccs_io_buffer".
+ * @member: Pointer to "struct ccs_address_group".
  *
  * Returns nothing.
  */
-static void ccs_print_ip(char *buf, const unsigned int size,
-			 const struct ccs_ipaddr_union *ptr)
+static void ccs_print_ip(struct ccs_io_buffer *head,
+			 struct ccs_address_group *member)
 {
-	int len;
-	if (ptr->is_ipv6)
-		len = ccs_print_ipv6(buf, size, &ptr->ip[0]);
-	else
-		len = ccs_print_ipv4(buf, size, &ptr->ip[0].s6_addr32[0]);
-	if (!memcmp(&ptr->ip[0], &ptr->ip[1], 16) || len >= size / 2)
-		return;
-	buf[len++] = '-';
-	if (ptr->is_ipv6)
-		ccs_print_ipv6(buf + len, size - len, &ptr->ip[1]);
-	else
-		ccs_print_ipv4(buf + len, size - len,
-			       &ptr->ip[1].s6_addr32[0]);
+	char addr[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255")];
+	u8 i;
+	for (i = 0; i < 2; i++) {
+		if (member->is_ipv6)
+			ccs_print_ipv6(addr, sizeof(addr), &member->ip[i]);
+		else
+			ccs_print_ipv4(addr, sizeof(addr),
+				       member->ip[i].s6_addr);
+		ccs_io_printf(head, "%s", addr);
+		if (i)
+			break;
+		if (!memcmp(&member->ip[0], &member->ip[1], 16))
+			break;
+		ccs_set_string(head, "-");
+	}
 }
 
 #endif
 
-/***** SECTION5: Variables definition section *****/
+/**
+ * ccs_get_sarg - Get attribute name of CCS_SARG argument.
+ *
+ * @type:  One of values in "enum ccs_mac_index".
+ * @index: Index to return.
+ *
+ * Returns attribute name.
+ */
+static const char *ccs_get_sarg(const enum ccs_mac_index type, const u8 index)
+{
+	switch (type) {
+	case CCS_MAC_FILE_LINK:
+	case CCS_MAC_FILE_RENAME:
+		if (index == 0)
+			return "old_path";
+		if (index == 1)
+			return "new_path";
+		break;
+	case CCS_MAC_FILE_MOUNT:
+		if (index == 0)
+			return "source";
+		if (index == 1)
+			return "target";
+		if (index == 2)
+			return "fstype";
+		break;
+	case CCS_MAC_FILE_PIVOT_ROOT:
+		if (index == 0)
+			return "new_root";
+		if (index == 1)
+			return "put_old";
+		break;
+	case CCS_MAC_FILE_EXECUTE:
+		if (index == 0)
+			return "path";
+		if (index == 1)
+			return "exec";
+		break;
+	case CCS_MAC_FILE_SYMLINK:
+		if (index == 0)
+			return "path";
+		if (index == 1)
+			return "target";
+		break;
+	case CCS_MAC_FILE_READ:
+	case CCS_MAC_FILE_WRITE:
+	case CCS_MAC_FILE_APPEND:
+	case CCS_MAC_FILE_UNLINK:
+#ifdef CONFIG_CCSECURITY_FILE_GETATTR
+	case CCS_MAC_FILE_GETATTR:
+#endif
+	case CCS_MAC_FILE_RMDIR:
+	case CCS_MAC_FILE_TRUNCATE:
+	case CCS_MAC_FILE_CHROOT:
+	case CCS_MAC_FILE_CHMOD:
+	case CCS_MAC_FILE_CHOWN:
+	case CCS_MAC_FILE_CHGRP:
+	case CCS_MAC_FILE_IOCTL:
+	case CCS_MAC_FILE_MKDIR:
+	case CCS_MAC_FILE_CREATE:
+	case CCS_MAC_FILE_MKFIFO:
+	case CCS_MAC_FILE_MKSOCK:
+	case CCS_MAC_FILE_MKBLOCK:
+	case CCS_MAC_FILE_MKCHAR:
+	case CCS_MAC_FILE_UMOUNT:
+		if (index == 0)
+			return "path";
+		break;
+#ifdef CONFIG_CCSECURITY_MISC
+	case CCS_MAC_ENVIRON:
+		if (index == 0)
+			return "name";
+		break;
+#endif
+	case CCS_MAC_CAPABILITY_MODIFY_POLICY:
+#ifdef CONFIG_CCSECURITY_CAPABILITY
+	case CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET:
+	case CCS_MAC_CAPABILITY_USE_PACKET_SOCKET:
+	case CCS_MAC_CAPABILITY_SYS_REBOOT:
+	case CCS_MAC_CAPABILITY_SYS_VHANGUP:
+	case CCS_MAC_CAPABILITY_SYS_SETTIME:
+	case CCS_MAC_CAPABILITY_SYS_NICE:
+	case CCS_MAC_CAPABILITY_SYS_SETHOSTNAME:
+	case CCS_MAC_CAPABILITY_USE_KERNEL_MODULE:
+	case CCS_MAC_CAPABILITY_SYS_KEXEC_LOAD:
+#endif
+		break;
+#ifdef CONFIG_CCSECURITY_NETWORK
+	case CCS_MAC_NETWORK_INET_STREAM_BIND:
+	case CCS_MAC_NETWORK_INET_STREAM_LISTEN:
+	case CCS_MAC_NETWORK_INET_STREAM_CONNECT:
+	case CCS_MAC_NETWORK_INET_STREAM_ACCEPT:
+	case CCS_MAC_NETWORK_INET_DGRAM_BIND:
+	case CCS_MAC_NETWORK_INET_DGRAM_SEND:
+	case CCS_MAC_NETWORK_INET_DGRAM_RECV:
+	case CCS_MAC_NETWORK_INET_RAW_BIND:
+	case CCS_MAC_NETWORK_INET_RAW_SEND:
+	case CCS_MAC_NETWORK_INET_RAW_RECV:
+		if (index == 0)
+			return "ip";
+		break;
+	case CCS_MAC_NETWORK_UNIX_STREAM_BIND:
+	case CCS_MAC_NETWORK_UNIX_STREAM_LISTEN:
+	case CCS_MAC_NETWORK_UNIX_STREAM_CONNECT:
+	case CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT:
+	case CCS_MAC_NETWORK_UNIX_DGRAM_BIND:
+	case CCS_MAC_NETWORK_UNIX_DGRAM_SEND:
+	case CCS_MAC_NETWORK_UNIX_DGRAM_RECV:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_BIND:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_LISTEN:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT:
+		if (index == 0)
+			return "addr";
+		break;
+#endif
+#ifdef CONFIG_CCSECURITY_IPC
+	case CCS_MAC_PTRACE:
+		if (index == 0)
+			return "domain";
+		break;
+#endif
+	default:
+		break;
+	}
+	return "unknown"; /* This should not happen. */
+}
 
-/* Permit policy management by non-root user? */
-static bool ccs_manage_by_non_root;
+/**
+ * ccs_get_narg - Get attribute name of CCS_NARG argument.
+ *
+ * @type:  One of values in "enum ccs_mac_index".
+ * @index: Index to return.
+ *
+ * Returns attribute name.
+ */
+static const char *ccs_get_narg(const enum ccs_mac_index type, const u8 index)
+{
+	switch (type) {
+	case CCS_MAC_FILE_MOUNT:
+	case CCS_MAC_FILE_UMOUNT:
+		if (index == 0)
+			return "flags";
+		break;
+	case CCS_MAC_FILE_CHMOD:
+		if (index == 0)
+			return "perm";
+		break;
+	case CCS_MAC_FILE_CHOWN:
+		if (index == 0)
+			return "uid";
+		break;
+	case CCS_MAC_FILE_CHGRP:
+		if (index == 0)
+			return "gid";
+		break;
+	case CCS_MAC_FILE_IOCTL:
+		if (index == 0)
+			return "cmd";
+		break;
+	case CCS_MAC_FILE_MKDIR:
+	case CCS_MAC_FILE_CREATE:
+	case CCS_MAC_FILE_MKFIFO:
+	case CCS_MAC_FILE_MKSOCK:
+		if (index == 0)
+			return "perm";
+		break;
+	case CCS_MAC_FILE_MKBLOCK:
+	case CCS_MAC_FILE_MKCHAR:
+		if (index == 0)
+			return "perm";
+		if (index == 1)
+			return "dev_major";
+		if (index == 2)
+			return "dev_minor";
+		break;
+#ifdef CONFIG_CCSECURITY_NETWORK
+	case CCS_MAC_NETWORK_INET_STREAM_BIND:
+	case CCS_MAC_NETWORK_INET_STREAM_LISTEN:
+	case CCS_MAC_NETWORK_INET_STREAM_CONNECT:
+	case CCS_MAC_NETWORK_INET_STREAM_ACCEPT:
+	case CCS_MAC_NETWORK_INET_DGRAM_BIND:
+	case CCS_MAC_NETWORK_INET_DGRAM_SEND:
+	case CCS_MAC_NETWORK_INET_DGRAM_RECV:
+		if (index == 0)
+			return "port";
+		break;
+	case CCS_MAC_NETWORK_INET_RAW_BIND:
+	case CCS_MAC_NETWORK_INET_RAW_SEND:
+	case CCS_MAC_NETWORK_INET_RAW_RECV:
+		if (index == 0)
+			return "proto";
+		break;
+#endif
+#ifdef CONFIG_CCSECURITY_IPC
+	case CCS_MAC_PTRACE:
+		if (index == 0)
+			return "cmd";
+		break;
+#endif
+	default:
+		break;
+	}
+	return "unknown"; /* This should not happen. */
+}
 
+/***** SECTION5: Variables definition section *****/
+
 /* Lock for protecting policy. */
 DEFINE_MUTEX(ccs_policy_lock);
 
 /* Has /sbin/init started? */
 bool ccs_policy_loaded;
 
-/* List of namespaces. */
-LIST_HEAD(ccs_namespace_list);
-/* True if namespace other than ccs_kernel_namespace is defined. */
-static bool ccs_namespace_enabled;
+/* List of "struct ccs_group". */
+struct list_head ccs_group_list[CCS_MAX_GROUP];
+/* Policy version. Currently only 20100903 is defined. */
+static unsigned int ccs_policy_version = 20100903;
 
-/* Initial namespace.*/
-static struct ccs_policy_namespace ccs_kernel_namespace;
-static struct ccs_path_info ccs_kernel_transition;
-
-struct ccs_group ccs_group_any;
-
 /* List of "struct ccs_condition". */
 LIST_HEAD(ccs_condition_list);
 
-/* List of "struct ccs_manager". */
-LIST_HEAD(ccs_manager_list);
-
 /* Wait queue for kernel -> userspace notification. */
 static DECLARE_WAIT_QUEUE_HEAD(ccs_query_wait);
 /* Wait queue for userspace -> kernel notification. */
@@ -1206,7 +1256,8 @@
 static DEFINE_SPINLOCK(ccs_log_lock);
 
 /* Length of "stuct list_head ccs_log". */
-static unsigned int ccs_log_count;
+static unsigned int ccs_grant_log_count;
+static unsigned int ccs_reject_log_count;
 
 /* Timestamp counter for last updated. */
 static unsigned int ccs_stat_updated[CCS_MAX_POLICY_STAT];
@@ -1264,22 +1315,22 @@
 /**
  * ccs_read_token - Read a word from a line.
  *
- * @param: Pointer to "struct ccs_acl_param".
+ * @head: Pointer to "struct ccs_io_buffer".
  *
  * Returns a word on success, "" otherwise.
  *
  * To allow the caller to skip NULL check, this function returns "" rather than
  * NULL if there is no more words to read.
  */
-static char *ccs_read_token(struct ccs_acl_param *param)
+static char *ccs_read_token(struct ccs_io_buffer *head)
 {
-	char *pos = param->data;
+	char *pos = head->w.data;
 	char *del = strchr(pos, ' ');
 	if (del)
 		*del++ = '\0';
 	else
 		del = pos + strlen(pos);
-	param->data = del;
+	head->w.data = del;
 	return pos;
 }
 
@@ -1321,8 +1372,6 @@
 				goto out;
 			c = *string++;
 			switch (c) {
-			case '\\':  /* "\\" */
-				continue;
 			case '$':   /* "\$" */
 			case '+':   /* "\+" */
 			case '?':   /* "\?" */
@@ -1357,7 +1406,7 @@
 				if (d < '0' || d > '7' || e < '0' || e > '7')
 					break;
 				c = ccs_make_byte(c, d, e);
-				if (c <= ' ' || c >= 127)
+				if (c <= ' ' || c >= 127 || c == '\\')
 					continue;
 			}
 			goto out;
@@ -1389,21 +1438,19 @@
 /**
  * ccs_get_group - Allocate memory for "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group".
  *
- * @param: Pointer to "struct ccs_acl_param".
- * @idx:   Index number.
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @idx:  Index number.
  *
  * Returns pointer to "struct ccs_group" on success, NULL otherwise.
  */
-static struct ccs_group *ccs_get_group(struct ccs_acl_param *param,
-				       const u8 idx)
+static struct ccs_group *ccs_get_group(struct ccs_io_buffer *head,
+				       const enum ccs_group_id idx)
 {
 	struct ccs_group e = { };
 	struct ccs_group *group = NULL;
 	struct list_head *list;
-	const char *group_name = ccs_read_token(param);
+	const char *group_name = ccs_read_token(head);
 	bool found = false;
-	if (!strcmp(group_name, "any"))
-		return &ccs_group_any;
 	if (!ccs_correct_word(group_name) || idx >= CCS_MAX_GROUP)
 		return NULL;
 	e.group_name = ccs_get_name(group_name);
@@ -1411,7 +1458,7 @@
 		return NULL;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list = &param->ns->group_list[idx];
+	list = &ccs_group_list[idx];
 	list_for_each_entry(group, list, head.list) {
 		if (e.group_name != group->group_name ||
 		    atomic_read(&group->head.users) == CCS_GC_IN_PROGRESS)
@@ -1437,33 +1484,6 @@
 }
 
 /**
- * ccs_parse_name_union - Parse a ccs_name_union.
- *
- * @param: Pointer to "struct ccs_acl_param".
- * @ptr:   Pointer to "struct ccs_name_union".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_name_union(struct ccs_acl_param *param,
-				 struct ccs_name_union *ptr)
-{
-	char *filename;
-	switch (ccs_group_type(&param->data)) {
-	case 2:
-		ptr->is_not = true;
-		/* fall through */
-	case 1:
-		ptr->group = ccs_get_group(param, CCS_PATH_GROUP);
-		return ptr->group != NULL;
-	}
-	filename = ccs_read_token(param);
-	if (!ccs_correct_word(filename))
-		return false;
-	ptr->filename = ccs_get_name(filename);
-	return ptr->filename != NULL;
-}
-
-/**
  * ccs_parse_ulong - Parse an "unsigned long" value.
  *
  * @result: Pointer to "unsigned long".
@@ -1474,7 +1494,7 @@
  * The @src is updated to point the first character after the value
  * on success.
  */
-static u8 ccs_parse_ulong(unsigned long *result, char **str)
+static enum ccs_value_type ccs_parse_ulong(unsigned long *result, char **str)
 {
 	const char *cp = *str;
 	char *ep;
@@ -1504,100 +1524,6 @@
 }
 
 /**
- * ccs_parse_number_union - Parse a ccs_number_union.
- *
- * @param: Pointer to "struct ccs_acl_param".
- * @ptr:   Pointer to "struct ccs_number_union".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_number_union(struct ccs_acl_param *param,
-				   struct ccs_number_union *ptr)
-{
-	char *data;
-	u8 type;
-	unsigned long v;
-	memset(ptr, 0, sizeof(*ptr));
-	switch (ccs_group_type(&param->data)) {
-	case 2:
-		ptr->is_not = true;
-		/* fall through */
-	case 1:
-		ptr->group = ccs_get_group(param, CCS_NUMBER_GROUP);
-		return ptr->group != NULL;
-	}
-	data = ccs_read_token(param);
-	type = ccs_parse_ulong(&v, &data);
-	if (type == CCS_VALUE_TYPE_INVALID)
-		return false;
-	ptr->values[0] = v;
-	ptr->value_type[0] = type;
-	if (!*data) {
-		ptr->values[1] = v;
-		ptr->value_type[1] = type;
-		return true;
-	}
-	if (*data++ != '-')
-		return false;
-	type = ccs_parse_ulong(&v, &data);
-	if (type == CCS_VALUE_TYPE_INVALID || *data || ptr->values[0] > v)
-		return false;
-	ptr->values[1] = v;
-	ptr->value_type[1] = type;
-	return true;
-}
-
-#ifdef CONFIG_CCSECURITY_NETWORK
-
-/**
- * ccs_parse_ipaddr_union - Parse an IP address.
- *
- * @param: Pointer to "struct ccs_acl_param".
- * @ptr:   Pointer to "struct ccs_ipaddr_union".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_ipaddr_union(struct ccs_acl_param *param,
-				   struct ccs_ipaddr_union *ptr)
-{
-	u8 * const min = ptr->ip[0].in6_u.u6_addr8;
-	u8 * const max = ptr->ip[1].in6_u.u6_addr8;
-	char *address;
-	const char *end;
-	switch (ccs_group_type(&param->data)) {
-	case 2:
-		ptr->is_not = true;
-		/* fall through */
-	case 1:
-		ptr->group = ccs_get_group(param, CCS_ADDRESS_GROUP);
-		return ptr->group != NULL;
-	}
-	address = ccs_read_token(param);
-	if (!strchr(address, ':') &&
-	    ccs_in4_pton(address, -1, min, '-', &end) > 0) {
-		ptr->is_ipv6 = false;
-		if (!*end)
-			ptr->ip[1].s6_addr32[0] = ptr->ip[0].s6_addr32[0];
-		else if (*end++ != '-' ||
-			 ccs_in4_pton(end, -1, max, '\0', &end) <= 0 || *end)
-			return false;
-		return true;
-	}
-	if (ccs_in6_pton(address, -1, min, '-', &end) > 0) {
-		ptr->is_ipv6 = true;
-		if (!*end)
-			memmove(max, min, sizeof(u16) * 8);
-		else if (*end++ != '-' ||
-			 ccs_in6_pton(end, -1, max, '\0', &end) <= 0 || *end)
-			return false;
-		return true;
-	}
-	return false;
-}
-
-#endif
-
-/**
  * ccs_get_dqword - ccs_get_name() for a quoted string.
  *
  * @start: String to save.
@@ -1616,80 +1542,6 @@
 }
 
 /**
- * ccs_parse_name_union_quoted - Parse a quoted word.
- *
- * @param: Pointer to "struct ccs_acl_param".
- * @ptr:   Pointer to "struct ccs_name_union".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_name_union_quoted(struct ccs_acl_param *param,
-					struct ccs_name_union *ptr)
-{
-	char *filename = param->data;
-	if (ccs_group_type(&filename))
-		return ccs_parse_name_union(param, ptr);
-	ptr->filename = ccs_get_dqword(filename);
-	return ptr->filename != NULL;
-}
-
-/**
- * ccs_parse_argv - Parse an argv[] condition part.
- *
- * @left:  Lefthand value.
- * @right: Righthand value.
- * @argv:  Pointer to "struct ccs_argv".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_argv(char *left, char *right, struct ccs_argv *argv)
-{
-	if (ccs_parse_ulong(&argv->index, &left) != CCS_VALUE_TYPE_DECIMAL ||
-	    *left++ != ']' || *left)
-		return false;
-	argv->value = ccs_get_dqword(right);
-	return argv->value != NULL;
-}
-
-/**
- * ccs_parse_envp - Parse an envp[] condition part.
- *
- * @left:  Lefthand value.
- * @right: Righthand value.
- * @envp:  Pointer to "struct ccs_envp".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_envp(char *left, char *right, struct ccs_envp *envp)
-{
-	const struct ccs_path_info *name;
-	const struct ccs_path_info *value;
-	char *cp = left + strlen(left) - 1;
-	if (*cp-- != ']' || *cp != '"')
-		goto out;
-	*cp = '\0';
-	if (!ccs_correct_word(left))
-		goto out;
-	name = ccs_get_name(left);
-	if (!name)
-		goto out;
-	if (!strcmp(right, "NULL")) {
-		value = NULL;
-	} else {
-		value = ccs_get_dqword(right);
-		if (!value) {
-			ccs_put_name(name);
-			goto out;
-		}
-	}
-	envp->name = name;
-	envp->value = value;
-	return true;
-out:
-	return false;
-}
-
-/**
  * ccs_same_condition - Check for duplicated "struct ccs_condition" entry.
  *
  * @a: Pointer to "struct ccs_condition".
@@ -1700,33 +1552,11 @@
 static bool ccs_same_condition(const struct ccs_condition *a,
 			       const struct ccs_condition *b)
 {
-	return a->size == b->size && a->condc == b->condc &&
-		a->numbers_count == b->numbers_count &&
-		a->names_count == b->names_count &&
-		a->argc == b->argc && a->envc == b->envc &&
-		a->grant_log == b->grant_log &&
+	return a->size == b->size &&
 		!memcmp(a + 1, b + 1, a->size - sizeof(*a));
 }
 
 /**
- * ccs_condition_type - Get condition type.
- *
- * @word: Keyword string.
- *
- * Returns one of values in "enum ccs_conditions_index" on success,
- * CCS_MAX_CONDITION_KEYWORD otherwise.
- */
-static u8 ccs_condition_type(const char *word)
-{
-	u8 i;
-	for (i = 0; i < CCS_MAX_CONDITION_KEYWORD; i++) {
-		if (!strcmp(word, ccs_condition_keyword[i]))
-			break;
-	}
-	return i;
-}
-
-/**
  * ccs_commit_condition - Commit "struct ccs_condition".
  *
  * @entry: Pointer to "struct ccs_condition".
@@ -1775,41 +1605,6 @@
 }
 
 /**
- * ccs_correct_path - Check whether the given pathname follows the naming rules.
- *
- * @filename: The pathname to check.
- *
- * Returns true if @filename follows the naming rules, false otherwise.
- */
-static bool ccs_correct_path(const char *filename)
-{
-	return *filename == '/' && ccs_correct_word(filename);
-}
-
-/**
- * ccs_domain_def - Check whether the given token can be a domainname.
- *
- * @buffer: The token to check.
- *
- * Returns true if @buffer possibly be a domainname, false otherwise.
- */
-static bool ccs_domain_def(const unsigned char *buffer)
-{
-	const unsigned char *cp;
-	int len;
-	if (*buffer != '<')
-		return false;
-	cp = strchr(buffer, ' ');
-	if (!cp)
-		len = strlen(buffer);
-	else
-		len = cp - buffer;
-	if (buffer[len - 1] != '>' || !ccs_correct_word2(buffer + 1, len - 2))
-		return false;
-	return true;
-}
-
-/**
  * ccs_correct_domain - Check whether the given domainname follows the naming rules.
  *
  * @domainname: The domainname to check.
@@ -1818,21 +1613,17 @@
  */
 static bool ccs_correct_domain(const unsigned char *domainname)
 {
-	if (!domainname || !ccs_domain_def(domainname))
+	if (!domainname)
 		return false;
-	domainname = strchr(domainname, ' ');
-	if (!domainname++)
-		return true;
 	while (1) {
-		const unsigned char *cp = strchr(domainname, ' ');
+		const unsigned char *cp = strstr(domainname, "\\_");
 		if (!cp)
 			break;
-		if (*domainname != '/' ||
-		    !ccs_correct_word2(domainname, cp - domainname))
+		if (!ccs_correct_word2(domainname, cp - domainname))
 			return false;
-		domainname = cp + 1;
+		domainname = cp + 2;
 	}
-	return ccs_correct_path(domainname);
+	return ccs_correct_word(domainname);
 }
 
 /**
@@ -1864,273 +1655,722 @@
 	*dp = '\0';
 }
 
-/**
- * ccs_get_domainname - Read a domainname from a line.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns a domainname on success, NULL otherwise.
- */
-static const struct ccs_path_info *ccs_get_domainname
-(struct ccs_acl_param *param)
+struct ccs_cond_tmp {
+	u8 left;
+	u8 right;
+	bool is_not;
+	u8 radix;
+	struct ccs_group *group;
+	const struct ccs_path_info *path;
+	struct in6_addr ipv6[2];
+	unsigned long value[2];
+	unsigned long argv;
+	const struct ccs_path_info *envp;
+};
+
+static u8 ccs_parse_values(char *value, unsigned long v[2])
 {
-	char *start = param->data;
-	char *pos = start;
-	while (*pos) {
-		if (*pos++ != ' ' || *pos++ == '/')
-			continue;
-		pos -= 2;
-		*pos++ = '\0';
+	enum ccs_value_type radix1 = ccs_parse_ulong(&v[0], &value);
+	enum ccs_value_type radix2;
+	if (radix1 == CCS_VALUE_TYPE_INVALID)
+		return CCS_VALUE_TYPE_INVALID;
+	if (!*value) {
+		v[1] = v[0];
+		return radix1;
+	}
+	if (*value++ != '-')
+		return CCS_VALUE_TYPE_INVALID;
+	radix2 = ccs_parse_ulong(&v[1], &value);
+	if (radix2 == CCS_VALUE_TYPE_INVALID || *value || v[0] > v[1])
+		return CCS_VALUE_TYPE_INVALID;
+	return radix1 | (radix2 << 2);
+}
+
+#ifdef CONFIG_CCSECURITY_NETWORK
+
+static u8 ccs_parse_ipaddr(char *address, struct in6_addr ipv6[2])
+{
+	const char *end;
+	if (!strchr(address, ':') &&
+	    ccs_in4_pton(address, -1, ipv6[0].s6_addr, '-', &end) > 0) {
+		if (!*end) {
+			ipv6[0].s6_addr32[0] = ipv6[0].s6_addr32[0];
+			return 1;
+		}
+		if (*end++ != '-' ||
+		    ccs_in4_pton(end, -1, ipv6[1].s6_addr, '\0', &end) <= 0 ||
+		    *end || memcmp(&ipv6[0], &ipv6[1], 4) >= 0)
+			return 0;
+		return 2;
+	}
+	if (ccs_in6_pton(address, -1, ipv6[0].s6_addr, '-', &end) > 0) {
+		if (!*end) {
+			ipv6[1] = ipv6[0];
+			return 3;
+		}
+		if (*end++ != '-' ||
+		    ccs_in6_pton(end, -1, ipv6[1].s6_addr, '\0', &end) <= 0 ||
+		    *end || memcmp(&ipv6[0], &ipv6[1], 16) >= 0)
+			return 0;
+		return 4;
+	}
+	return 0;
+}
+
+#endif
+
+static enum ccs_conditions_index ccs_parse_task_cond(const char *word)
+{
+	if (!strncmp(word, "task.", 5)) {
+		word += 5;
+		if (!strcmp(word, "uid"))
+			return CCS_SELF_UID;
+		if (!strcmp(word, "euid"))
+			return  CCS_SELF_EUID;
+		if (!strcmp(word, "suid"))
+			return CCS_SELF_SUID;
+		if (!strcmp(word, "fsuid"))
+			return  CCS_SELF_FSUID;
+		if (!strcmp(word, "gid"))
+			return CCS_SELF_GID;
+		if (!strcmp(word, "egid"))
+			return CCS_SELF_EGID;
+		if (!strcmp(word, "sgid"))
+			return CCS_SELF_SGID;
+		if (!strcmp(word, "fsgid"))
+			return CCS_SELF_FSGID;
+		if (!strcmp(word, "pid"))
+			return CCS_SELF_PID;
+		if (!strcmp(word, "ppid"))
+			return CCS_SELF_PPID;
+		if (!strcmp(word, "type"))
+			return CCS_TASK_TYPE;
+		if (!strcmp(word, "domain"))
+			return CCS_SELF_DOMAIN;
+		if (!strcmp(word, "exe"))
+			return CCS_SELF_EXE;
+	}
+	return CCS_MAX_CONDITION_KEYWORD;
+}
+
+static enum ccs_conditions_index ccs_parse_syscall_arg
+(const char *word, const enum ccs_mac_index type)
+{
+	switch (type) {
+	case CCS_MAC_FILE_READ:
+	case CCS_MAC_FILE_WRITE:
+	case CCS_MAC_FILE_APPEND:
+	case CCS_MAC_FILE_UNLINK:
+#ifdef CONFIG_CCSECURITY_FILE_GETATTR
+	case CCS_MAC_FILE_GETATTR:
+#endif
+	case CCS_MAC_FILE_RMDIR:
+	case CCS_MAC_FILE_TRUNCATE:
+	case CCS_MAC_FILE_CHROOT:
+	case CCS_MAC_FILE_CHOWN:
+	case CCS_MAC_FILE_CHGRP:
+	case CCS_MAC_FILE_IOCTL:
+	case CCS_MAC_FILE_EXECUTE:
+	case CCS_MAC_FILE_SYMLINK:
+		if (!strcmp(word, "path"))
+			return CCS_COND_SARG0;
+		if (type == CCS_MAC_FILE_CHOWN && !strcmp(word, "uid"))
+			return CCS_COND_NARG0;
+		if (type == CCS_MAC_FILE_CHGRP && !strcmp(word, "gid"))
+			return CCS_COND_NARG0;
+		if (type == CCS_MAC_FILE_IOCTL && !strcmp(word, "cmd"))
+			return CCS_COND_NARG0;
+		if (type == CCS_MAC_FILE_EXECUTE && !strcmp(word, "exec"))
+			return CCS_COND_SARG1;
+		if (type == CCS_MAC_FILE_SYMLINK && !strcmp(word, "target"))
+			return CCS_COND_SARG1;
 		break;
+	case CCS_MAC_FILE_CHMOD:
+	case CCS_MAC_FILE_MKDIR:
+	case CCS_MAC_FILE_CREATE:
+	case CCS_MAC_FILE_MKFIFO:
+	case CCS_MAC_FILE_MKSOCK:
+	case CCS_MAC_FILE_MKBLOCK:
+	case CCS_MAC_FILE_MKCHAR:
+		if (!strcmp(word, "path"))
+			return CCS_COND_SARG0;
+		if (!strcmp(word, "perm"))
+			return CCS_COND_NARG0;
+		if (type == CCS_MAC_FILE_MKBLOCK ||
+		    type == CCS_MAC_FILE_MKCHAR) {
+			if (!strcmp(word, "dev_major"))
+				return CCS_COND_NARG1;
+			if (!strcmp(word, "dev_minor"))
+				return CCS_COND_NARG2;
+		}
+		break;
+	case CCS_MAC_FILE_LINK:
+	case CCS_MAC_FILE_RENAME:
+		if (!strcmp(word, "old_path"))
+			return CCS_COND_SARG0;
+		if (!strcmp(word, "new_path"))
+			return CCS_COND_SARG1;
+		break;
+	case CCS_MAC_FILE_MOUNT:
+		if (!strcmp(word, "source"))
+			return CCS_COND_SARG0;
+		if (!strcmp(word, "target"))
+			return CCS_COND_SARG1;
+		if (!strcmp(word, "fstype"))
+			return CCS_COND_SARG2;
+		if (!strcmp(word, "flags"))
+			return CCS_COND_NARG0;
+		break;
+	case CCS_MAC_FILE_UMOUNT:
+		if (!strcmp(word, "path"))
+			return CCS_COND_SARG0;
+		if (!strcmp(word, "flags"))
+			return CCS_COND_NARG0;
+		break;
+	case CCS_MAC_FILE_PIVOT_ROOT:
+		if (!strcmp(word, "new_root"))
+			return CCS_COND_SARG0;
+		if (!strcmp(word, "put_old"))
+			return CCS_COND_SARG1;
+		break;
+#ifdef CONFIG_CCSECURITY_NETWORK
+	case CCS_MAC_NETWORK_INET_STREAM_BIND:
+	case CCS_MAC_NETWORK_INET_STREAM_LISTEN:
+	case CCS_MAC_NETWORK_INET_STREAM_CONNECT:
+	case CCS_MAC_NETWORK_INET_STREAM_ACCEPT:
+	case CCS_MAC_NETWORK_INET_DGRAM_BIND:
+	case CCS_MAC_NETWORK_INET_DGRAM_SEND:
+	case CCS_MAC_NETWORK_INET_DGRAM_RECV:
+		if (!strcmp(word, "ip"))
+			return CCS_COND_IPARG;
+		if (!strcmp(word, "port"))
+			return CCS_COND_NARG0;
+		break;
+	case CCS_MAC_NETWORK_INET_RAW_BIND:
+	case CCS_MAC_NETWORK_INET_RAW_SEND:
+	case CCS_MAC_NETWORK_INET_RAW_RECV:
+		if (!strcmp(word, "ip"))
+			return CCS_COND_IPARG;
+		if (!strcmp(word, "proto"))
+			return CCS_COND_NARG0;
+		break;
+	case CCS_MAC_NETWORK_UNIX_STREAM_BIND:
+	case CCS_MAC_NETWORK_UNIX_STREAM_LISTEN:
+	case CCS_MAC_NETWORK_UNIX_STREAM_CONNECT:
+	case CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT:
+	case CCS_MAC_NETWORK_UNIX_DGRAM_BIND:
+	case CCS_MAC_NETWORK_UNIX_DGRAM_SEND:
+	case CCS_MAC_NETWORK_UNIX_DGRAM_RECV:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_BIND:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_LISTEN:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT:
+		if (!strcmp(word, "addr"))
+			return CCS_COND_SARG0;
+		break;
+#endif
+#ifdef CONFIG_CCSECURITY_MISC
+	case CCS_MAC_ENVIRON:
+		if (!strcmp(word, "name"))
+			return CCS_COND_SARG0;
+		break;
+#endif
+#ifdef CONFIG_CCSECURITY_IPC
+	case CCS_MAC_PTRACE:
+		if (!strcmp(word, "domain"))
+			return CCS_COND_DOMAIN;
+		break;
+#endif
+	case CCS_MAC_CAPABILITY_MODIFY_POLICY:
+#ifdef CONFIG_CCSECURITY_CAPABILITY
+	case CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET:
+	case CCS_MAC_CAPABILITY_USE_PACKET_SOCKET:
+	case CCS_MAC_CAPABILITY_SYS_REBOOT:
+	case CCS_MAC_CAPABILITY_SYS_VHANGUP:
+	case CCS_MAC_CAPABILITY_SYS_SETTIME:
+	case CCS_MAC_CAPABILITY_SYS_NICE:
+	case CCS_MAC_CAPABILITY_SYS_SETHOSTNAME:
+	case CCS_MAC_CAPABILITY_USE_KERNEL_MODULE:
+	case CCS_MAC_CAPABILITY_SYS_KEXEC_LOAD:
+#endif
+		break;
+	case CCS_MAX_MAC_INDEX:
+#if defined(CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER) || defined(CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION)
+	case CCS_MAC_AUTO_EXECUTE_HANDLER:
+	case CCS_MAC_DENIED_EXECUTE_HANDLER:
+	case CCS_MAC_AUTO_TASK_TRANSITION:
+	case CCS_MAC_MANUAL_TASK_TRANSITION:
+#endif
+		break;
 	}
-	param->data = pos;
+	return CCS_MAX_CONDITION_KEYWORD;
+}
+
+static enum ccs_conditions_index ccs_parse_path_attribute
+(char *word, const enum ccs_mac_index type)
+{
+	u8 i;
+	enum ccs_conditions_index start;
+	switch (type) {
+	case CCS_MAC_FILE_READ:
+	case CCS_MAC_FILE_WRITE:
+	case CCS_MAC_FILE_APPEND:
+	case CCS_MAC_FILE_UNLINK:
+#ifdef CONFIG_CCSECURITY_FILE_GETATTR
+	case CCS_MAC_FILE_GETATTR:
+#endif
+	case CCS_MAC_FILE_RMDIR:
+	case CCS_MAC_FILE_TRUNCATE:
+	case CCS_MAC_FILE_CHROOT:
+	case CCS_MAC_FILE_CHMOD:
+	case CCS_MAC_FILE_CHOWN:
+	case CCS_MAC_FILE_CHGRP:
+	case CCS_MAC_FILE_IOCTL:
+	case CCS_MAC_FILE_EXECUTE:
+	case CCS_MAC_FILE_UMOUNT:
+		if (ccs_str_starts(&word, "path"))
+			goto path1;
+		break;
+	case CCS_MAC_FILE_MKDIR:
+	case CCS_MAC_FILE_CREATE:
+	case CCS_MAC_FILE_MKFIFO:
+	case CCS_MAC_FILE_MKSOCK:
+	case CCS_MAC_FILE_MKBLOCK:
+	case CCS_MAC_FILE_MKCHAR:
+	case CCS_MAC_FILE_SYMLINK:
+		if (ccs_str_starts(&word, "path"))
+			goto path1_parent;
+		break;
+	case CCS_MAC_FILE_LINK:
+	case CCS_MAC_FILE_RENAME:
+		if (ccs_str_starts(&word, "old_path"))
+			goto path1;
+		if (ccs_str_starts(&word, "new_path"))
+			goto path2_parent;
+		break;
+	case CCS_MAC_FILE_MOUNT:
+		if (ccs_str_starts(&word, "source"))
+			goto path1;
+		if (ccs_str_starts(&word, "target"))
+			goto path2;
+		break;
+	case CCS_MAC_FILE_PIVOT_ROOT:
+		if (ccs_str_starts(&word, "new_root"))
+			goto path1;
+		if (ccs_str_starts(&word, "put_old"))
+			goto path2;
+		break;
+	default:
+		break;
+	}
+	goto out;
+path1_parent:
+	if (strncmp(word, ".parent", 7))
+		goto out;
+path1:
+	start = CCS_PATH_ATTRIBUTE_START;
+	goto check;
+path2_parent:
+	if (strncmp(word, ".parent", 7))
+		goto out;
+path2:
+	start = CCS_PATH_ATTRIBUTE_START + 32;
+check:
+	if (ccs_str_starts(&word, ".parent"))
+		start += 16;
+	if (*word++ == '.')
+		for (i = 0; i < CCS_MAX_PATH_ATTRIBUTE; i++)
+			if (!strcmp(word, ccs_path_attribute[i]))
+				return start + i;
+out:
+	return CCS_MAX_CONDITION_KEYWORD;
+}
+
+static enum ccs_conditions_index ccs_find_path_type(const char *word)
+{
+	if (!strcmp(word, "socket"))
+		return CCS_OBJ_IS_SOCKET;
+	if (!strcmp(word, "symlink"))
+		return CCS_OBJ_IS_SYMLINK;
+	if (!strcmp(word, "file"))
+		return CCS_OBJ_IS_FILE;
+	if (!strcmp(word, "block"))
+		return CCS_OBJ_IS_BLOCK_DEV;
+	if (!strcmp(word, "directory"))
+		return CCS_OBJ_IS_DIRECTORY;
+	if (!strcmp(word, "char"))
+		return CCS_OBJ_IS_CHAR_DEV;
+	if (!strcmp(word, "fifo"))
+		return CCS_OBJ_IS_FIFO;
+	return CCS_MAX_CONDITION_KEYWORD;
+}
+
+static enum ccs_conditions_index ccs_find_path_perm(const char *word)
+{
+	if (!strcmp(word, "setuid"))
+		return CCS_MODE_SETUID;
+	if (!strcmp(word, "setgid"))
+		return CCS_MODE_SETGID;
+	if (!strcmp(word, "sticky"))
+		return CCS_MODE_STICKY;
+	if (!strcmp(word, "owner_read"))
+		return CCS_MODE_OWNER_READ;
+	if (!strcmp(word, "owner_write"))
+		return CCS_MODE_OWNER_WRITE;
+	if (!strcmp(word, "owner_execute"))
+		return CCS_MODE_OWNER_EXECUTE;
+	if (!strcmp(word, "group_read"))
+		return CCS_MODE_GROUP_READ;
+	if (!strcmp(word, "group_write"))
+		return CCS_MODE_GROUP_WRITE;
+	if (!strcmp(word, "group_execute"))
+		return CCS_MODE_GROUP_EXECUTE;
+	if (!strcmp(word, "others_read"))
+		return CCS_MODE_OTHERS_READ;
+	if (!strcmp(word, "others_write"))
+		return CCS_MODE_OTHERS_WRITE;
+	if (!strcmp(word, "others_execute"))
+		return CCS_MODE_OTHERS_EXECUTE;
+	return CCS_MAX_CONDITION_KEYWORD;
+}
+
+static const struct ccs_path_info *ccs_get_dqdomain(char *start,
+						    const bool must_domainname)
+{
+	char *cp = start + strlen(start) - 1;
+	if (!must_domainname &&
+	    (!strcmp(start, "keep") || !strcmp(start, "child")))
+		return ccs_get_name(start);
+	if (*start++ != '"' || cp < start + 1 || *cp != '"')
+		return NULL;
+	*cp = '\0';
+	//printk(KERN_INFO "get_dqdomain('%s')=%u\n",
+	//       start, ccs_correct_domain(start));
 	if (ccs_correct_domain(start))
 		return ccs_get_name(start);
 	return NULL;
 }
 
-/**
- * ccs_get_transit_preference - Parse domain transition preference for execve().
- *
- * @param: Pointer to "struct ccs_acl_param".
- * @e:     Pointer to "struct ccs_condition".
- *
- * Returns the condition string part.
- */
-static char *ccs_get_transit_preference(struct ccs_acl_param *param,
-					struct ccs_execute_acl *e)
+static bool ccs_parse_cond(struct ccs_cond_tmp *tmp,
+			   struct ccs_io_buffer *head)
 {
-	char * const pos = param->data;
-	bool flag;
-	if (*pos == '<') {
-		e->transit = ccs_get_domainname(param);
-		goto done;
-	}
-	{
-		char *cp = strchr(pos, ' ');
-		if (cp)
+	enum ccs_group_id g;
+	char *left = head->w.data;
+	char *right;
+	const enum ccs_mac_index type = head->w.acl_index;
+	right = strchr(left, '=');
+	if (!right || right == left)
+		return false;
+	*right++ = '\0';
+	tmp->is_not = (*(right - 2) == '!');
+	if (tmp->is_not)
+		*(right - 2) = '\0';
+	if (!*left || !*right)
+		return false;
+	//printk(KERN_WARNING "%u: <%s>%s=<%s>\n", __LINE__, left,
+	//       tmp->equals ? "" : "!", right);
+	if (type == CCS_MAC_FILE_EXECUTE
+#ifdef CONFIG_CCSECURITY_MISC
+	    || type == CCS_MAC_ENVIRON
+#endif
+	    ) {
+		if (ccs_str_starts(&left, "argv[")) {
+			tmp->left = CCS_ARGV_ENTRY;
+			if (ccs_parse_ulong(&tmp->argv, &left) !=
+			    CCS_VALUE_TYPE_DECIMAL || *left++ != ']' || *left)
+				goto out;
+		} else if (ccs_str_starts(&left, "envp[")) {
+			char *cp = left + strlen(left) - 1;
+			tmp->left = CCS_ENVP_ENTRY;
+			if (*cp != ']')
+				goto out;
 			*cp = '\0';
-		flag = ccs_correct_path(pos) || !strcmp(pos, "keep") ||
-			!strcmp(pos, "child");
-		if (cp)
-			*cp = ' ';
+			tmp->envp = ccs_get_dqword(left);
+			if (!tmp->envp)
+				goto out;
+		} else if (!strcmp(left, "argc"))
+			tmp->left = CCS_EXEC_ARGC;
+		else if (!strcmp(left, "envc"))
+			tmp->left = CCS_EXEC_ENVC;
 	}
-	if (!flag)
-		return pos;
-	e->transit = ccs_get_name(ccs_read_token(param));
-done:
-	if (e->transit)
-		return param->data;
-	return NULL;
+	if (tmp->left == CCS_MAX_CONDITION_KEYWORD)
+		tmp->left = ccs_parse_syscall_arg(left, type);
+	if (tmp->left == CCS_MAX_CONDITION_KEYWORD)
+		tmp->left = ccs_parse_task_cond(left);
+	if (tmp->left == CCS_MAX_CONDITION_KEYWORD)
+		tmp->left = ccs_parse_path_attribute(left, type);
+	if (tmp->left == CCS_MAX_CONDITION_KEYWORD) {
+		/*
+		 * CCS_HANDLER_PATH and CCS_TRANSIT_DOMAIN are not for
+		 * comparison.
+		 */
+		if (tmp->is_not)
+			goto out;
+		if (!strcmp(left, "handler")) {
+			tmp->left = CCS_HANDLER_PATH;
+			tmp->right = CCS_IMM_NAME_ENTRY;
+			tmp->path = ccs_get_dqword(right);
+			if (!tmp->path || tmp->path->is_patterned)
+				goto out;
+			return true;
+		} else if (!strcmp(left, "transition")) {
+			tmp->left = CCS_TRANSIT_DOMAIN;
+			tmp->right = CCS_IMM_DOMAINNAME_ENTRY;
+			tmp->path = ccs_get_dqdomain(right, false);
+			if (!tmp->path)
+				goto out;
+			return true;
+		}
+	}
+	if (tmp->left == CCS_MAX_CONDITION_KEYWORD)
+		goto out;
+	switch (tmp->left) {
+	case CCS_COND_DOMAIN:
+	case CCS_SELF_DOMAIN:
+		tmp->right = CCS_IMM_DOMAINNAME_ENTRY;
+		//printk(KERN_INFO "right=%s\n", right);
+		tmp->path = ccs_get_dqdomain(right, true);
+		//printk(KERN_INFO "tmp->path=%p\n", tmp->path);
+		if (!tmp->path)
+			goto out;
+		return true;
+	case CCS_ARGV_ENTRY:
+	case CCS_ENVP_ENTRY:
+	case CCS_COND_SARG0:
+	case CCS_COND_SARG1:
+	case CCS_COND_SARG2:
+	case CCS_SELF_EXE:
+		g = CCS_PATH_GROUP;
+		break;
+#ifdef CONFIG_CCSECURITY_NETWORK
+	case CCS_COND_IPARG:
+		g = CCS_ADDRESS_GROUP;
+		break;
+#endif
+	case CCS_TASK_TYPE:
+		if (!strcmp(right, "execute_handler"))
+			goto out;
+		tmp->right = CCS_TASK_EXECUTE_HANDLER;
+		return true;
+	case CCS_PATH_ATTRIBUTE_START + CCS_PATH_ATTRIBUTE_TYPE:
+	case CCS_PATH_ATTRIBUTE_START + 16 + CCS_PATH_ATTRIBUTE_TYPE:
+	case CCS_PATH_ATTRIBUTE_START + 32 + CCS_PATH_ATTRIBUTE_TYPE:
+	case CCS_PATH_ATTRIBUTE_START + 48 + CCS_PATH_ATTRIBUTE_TYPE:
+		tmp->right = ccs_find_path_type(right);
+		if (tmp->right != CCS_MAX_CONDITION_KEYWORD)
+			return true;
+		goto out;
+	case CCS_PATH_ATTRIBUTE_START + CCS_PATH_ATTRIBUTE_PERM:
+	case CCS_PATH_ATTRIBUTE_START + 16 + CCS_PATH_ATTRIBUTE_PERM:
+	case CCS_PATH_ATTRIBUTE_START + 32 + CCS_PATH_ATTRIBUTE_PERM:
+	case CCS_PATH_ATTRIBUTE_START + 48 + CCS_PATH_ATTRIBUTE_PERM:
+		tmp->right = ccs_find_path_perm(right);
+		if (tmp->right != CCS_MAX_CONDITION_KEYWORD)
+			return true;
+		/* fall through */
+	default:
+		g = CCS_NUMBER_GROUP;
+	}
+	if (*right == '@') {
+		tmp->right = CCS_IMM_GROUP;
+		head->w.data = ++right;
+		tmp->group = ccs_get_group(head, g);
+		if (!tmp->group)
+			goto out;
+	} else if (*right == '"') {
+		if (g != CCS_PATH_GROUP)
+			goto out;
+		tmp->right = CCS_IMM_NAME_ENTRY;
+		tmp->path = ccs_get_dqword(right);
+		if (!tmp->path)
+			goto out;
+	} else if (tmp->left == CCS_ENVP_ENTRY) {
+		tmp->right = CCS_IMM_NAME_ENTRY;
+		if (strcmp(right, "NULL"))
+			goto out;
+	} else if (g == CCS_NUMBER_GROUP) {
+		tmp->right = ccs_parse_task_cond(right);
+		if (tmp->right == CCS_SELF_DOMAIN ||
+		    tmp->right == CCS_SELF_EXE)
+			goto out;
+		if (tmp->right == CCS_MAX_CONDITION_KEYWORD)
+			tmp->right = ccs_parse_path_attribute(right, type);
+		if (tmp->right != CCS_MAX_CONDITION_KEYWORD)
+			return true;
+		tmp->radix = ccs_parse_values(right, tmp->value);
+		if (tmp->radix == CCS_VALUE_TYPE_INVALID)
+			goto out;
+		if (tmp->radix >> 2)
+			tmp->right = CCS_IMM_NUMBER_ENTRY2;
+		else
+			tmp->right = CCS_IMM_NUMBER_ENTRY1;
+#ifdef CONFIG_CCSECURITY_NETWORK
+	} else if (g == CCS_ADDRESS_GROUP) {
+		switch (ccs_parse_ipaddr(right, tmp->ipv6)) {
+		case 1:
+			tmp->right = CCS_IMM_IPV4ADDR_ENTRY1;
+			break;
+		case 2:
+			tmp->right = CCS_IMM_IPV4ADDR_ENTRY2;
+			break;
+		case 3:
+			tmp->right = CCS_IMM_IPV6ADDR_ENTRY1;
+			break;
+		case 4:
+			tmp->right = CCS_IMM_IPV6ADDR_ENTRY2;
+			break;
+		default:
+			goto out;
+		}
+#endif
+	} else
+		goto out;
+	return true;
+out:
+	return false;
 }
 
 /**
  * ccs_get_condition - Parse condition part.
  *
- * @param: Pointer to "struct ccs_acl_param".
+ * @head: Pointer to "struct ccs_io_buffer".
  *
  * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
  */
-struct ccs_condition *ccs_get_condition(struct ccs_acl_param *param)
+struct ccs_condition *ccs_get_condition(struct ccs_io_buffer *head)
 {
-	struct ccs_condition *entry = NULL;
-	struct ccs_condition_element *condp = NULL;
-	struct ccs_number_union *numbers_p = NULL;
-	struct ccs_name_union *names_p = NULL;
-	struct ccs_argv *argv = NULL;
-	struct ccs_envp *envp = NULL;
-	struct ccs_condition e = { };
-	char * const start_of_string = param->data;
-	char * const end_of_string = start_of_string + strlen(start_of_string);
-	char *pos;
-rerun:
-	pos = start_of_string;
+	struct ccs_condition *entry = kmalloc(PAGE_SIZE, CCS_GFP_FLAGS);
+	union ccs_condition_element *condp;
+	struct ccs_cond_tmp tmp;
+	const enum ccs_mac_index type = head->w.acl_index;
+#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
+	bool handler_path_done =
+		type != CCS_MAC_AUTO_EXECUTE_HANDLER &&
+		type != CCS_MAC_DENIED_EXECUTE_HANDLER;
+#else
+	bool handler_path_done = true;
+#endif
+	bool transit_domain_done = type != CCS_MAC_FILE_EXECUTE
+#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
+		&& type != CCS_MAC_MANUAL_TASK_TRANSITION
+		&& type != CCS_MAC_AUTO_TASK_TRANSITION
+#endif
+		;
+	char *pos = head->w.data;
+	if (!entry)
+		return NULL;
+	condp = (union ccs_condition_element *) (entry + 1);
 	while (1) {
-		u8 left = -1;
-		u8 right = -1;
-		char *left_word = pos;
-		char *cp;
-		char *right_word;
-		bool is_not;
-		if (!*left_word)
+		memset(&tmp, 0, sizeof(tmp));
+		tmp.left = CCS_MAX_CONDITION_KEYWORD;
+		tmp.right = CCS_MAX_CONDITION_KEYWORD;
+		while (*pos == ' ')
+			pos++;
+		if (!*pos)
 			break;
-		/*
-		 * Since left-hand condition does not allow use of "path_group"
-		 * or "number_group" and environment variable's names do not
-		 * accept '=', it is guaranteed that the original line consists
-		 * of one or more repetition of $left$operator$right blocks
-		 * where "$left is free from '=' and ' '" and "$operator is
-		 * either '=' or '!='" and "$right is free from ' '".
-		 * Therefore, we can reconstruct the original line at the end
-		 * of dry run even if we overwrite $operator with '\0'.
-		 */
-		cp = strchr(pos, ' ');
-		if (cp) {
-			*cp = '\0'; /* Will restore later. */
-			pos = cp + 1;
-		} else {
-			pos = "";
-		}
-		right_word = strchr(left_word, '=');
-		if (!right_word || right_word == left_word)
+		if ((u8 *) condp >= ((u8 *) entry) + PAGE_SIZE
+		    - (sizeof(*condp) + sizeof(struct in6_addr) * 2))
 			goto out;
-		is_not = *(right_word - 1) == '!';
-		if (is_not)
-			*(right_word++ - 1) = '\0'; /* Will restore later. */
-		else if (*(right_word + 1) != '=')
-			*right_word++ = '\0'; /* Will restore later. */
-		else
-			goto out;
-		dprintk(KERN_WARNING "%u: <%s>%s=<%s>\n", __LINE__, left_word,
-			is_not ? "!" : "", right_word);
-		if (!strcmp(left_word, "grant_log")) {
-			if (entry) {
-				if (is_not ||
-				    entry->grant_log != CCS_GRANTLOG_AUTO)
-					goto out;
-				else if (!strcmp(right_word, "yes"))
-					entry->grant_log = CCS_GRANTLOG_YES;
-				else if (!strcmp(right_word, "no"))
-					entry->grant_log = CCS_GRANTLOG_NO;
-				else
-					goto out;
-			}
-			continue;
+		{
+			char *next = strchr(pos, ' ');
+			if (next)
+				*next++ = '\0';
+			else
+				next = "";
+			head->w.data = pos;
+			pos = next;
 		}
-		if (!strncmp(left_word, "exec.argv[", 10)) {
-			if (!argv) {
-				e.argc++;
-				e.condc++;
-			} else {
-				e.argc--;
-				e.condc--;
-				left = CCS_ARGV_ENTRY;
-				argv->is_not = is_not;
-				if (!ccs_parse_argv(left_word + 10,
-						    right_word, argv++))
-					goto out;
+		{
+			//char *word = kstrdup(head->w.data, GFP_KERNEL);
+			if (!ccs_parse_cond(&tmp, head)) {
+				/*
+				printk(KERN_WARNING "%u: '%s' failed\n",
+				       __LINE__, word);
+				kfree(word);
+				*/
+				goto out;
 			}
-			goto store_value;
+			//kfree(word);
 		}
-		if (!strncmp(left_word, "exec.envp[\"", 11)) {
-			if (!envp) {
-				e.envc++;
-				e.condc++;
-			} else {
-				e.envc--;
-				e.condc--;
-				left = CCS_ENVP_ENTRY;
-				envp->is_not = is_not;
-				if (!ccs_parse_envp(left_word + 11,
-						    right_word, envp++))
-					goto out;
-			}
-			goto store_value;
+		if (tmp.left == CCS_HANDLER_PATH) {
+			if (handler_path_done)
+				goto out;
+			handler_path_done = true;
 		}
-		left = ccs_condition_type(left_word);
-		dprintk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__, left_word,
-			left);
-		if (left == CCS_MAX_CONDITION_KEYWORD) {
-			if (!numbers_p) {
-				e.numbers_count++;
-			} else {
-				e.numbers_count--;
-				left = CCS_NUMBER_UNION;
-				param->data = left_word;
-				if (ccs_group_type(&left_word) ||
-				    !ccs_parse_number_union(param,
-							    numbers_p++))
-					goto out;
-			}
+		if (tmp.left == CCS_TRANSIT_DOMAIN) {
+			if (transit_domain_done)
+				goto out;
+			transit_domain_done = true;
 		}
-		if (!condp)
-			e.condc++;
-		else
-			e.condc--;
-		if (left == CCS_EXEC_REALPATH) {
-			if (!names_p) {
-				e.names_count++;
-			} else {
-				e.names_count--;
-				right = CCS_NAME_UNION;
-				param->data = right_word;
-				if (!ccs_parse_name_union_quoted(param,
-								 names_p++))
-					goto out;
-			}
-			goto store_value;
+		condp->is_not = tmp.is_not;
+		condp->left = tmp.left;
+		condp->right = tmp.right;
+		condp->radix = tmp.radix;
+		condp++;
+		if (tmp.left == CCS_ARGV_ENTRY) {
+			condp->value = tmp.argv;
+			condp++;
+		} else if (tmp.left == CCS_ENVP_ENTRY) {
+			condp->path = tmp.envp;
+			condp++;
 		}
-		right = ccs_condition_type(right_word);
-		if (right == CCS_MAX_CONDITION_KEYWORD) {
-			if (!numbers_p) {
-				e.numbers_count++;
-			} else {
-				e.numbers_count--;
-				right = CCS_NUMBER_UNION;
-				param->data = right_word;
-				if (!ccs_parse_number_union(param,
-							    numbers_p++))
-					goto out;
+		if (tmp.right == CCS_IMM_GROUP) {
+			condp->group = tmp.group;
+			condp++;
+		} else if (tmp.right == CCS_IMM_NAME_ENTRY ||
+			   tmp.right == CCS_IMM_DOMAINNAME_ENTRY) {
+			condp->path = tmp.path;
+			condp++;
+		} else if (tmp.right == CCS_IMM_NUMBER_ENTRY1 ||
+			   tmp.right == CCS_IMM_NUMBER_ENTRY2) {
+			condp->value = tmp.value[0];
+			condp++;
+			if (tmp.right == CCS_IMM_NUMBER_ENTRY2) {
+				condp->value = tmp.value[1];
+				condp++;
 			}
+		} else if (tmp.right == CCS_IMM_IPV4ADDR_ENTRY1 ||
+			   tmp.right == CCS_IMM_IPV4ADDR_ENTRY2) {
+			condp->ip = * (u32 *) &tmp.ipv6[0];
+			condp++;
+			if (tmp.right == CCS_IMM_IPV4ADDR_ENTRY2) {
+				condp->ip = * (u32 *) &tmp.ipv6[1];
+				condp++;
+			}
+		} else if (tmp.right == CCS_IMM_IPV6ADDR_ENTRY1 ||
+			   tmp.right == CCS_IMM_IPV6ADDR_ENTRY2) {
+			* (struct in6_addr *) condp = tmp.ipv6[0];
+			condp = (void *) (((u8 *) condp) +
+					  sizeof(struct in6_addr));
+			if (tmp.right == CCS_IMM_IPV6ADDR_ENTRY2) {
+				* (struct in6_addr *) condp = tmp.ipv6[1];
+				condp = (void *) (((u8 *) condp) +
+						  sizeof(struct in6_addr));
+			}
 		}
-store_value:
-		if (!condp) {
-			dprintk(KERN_WARNING "%u: dry_run left=%u right=%u "
-				"match=%u\n", __LINE__, left, right, !is_not);
-			continue;
-		}
-		condp->left = left;
-		condp->right = right;
-		condp->equals = !is_not;
-		dprintk(KERN_WARNING "%u: left=%u right=%u match=%u\n",
-			__LINE__, condp->left, condp->right,
-			condp->equals);
-		condp++;
+		/*else {
+			printk(KERN_WARNING "Unknown tmp.left=%u "
+			       "tmp.right=%u\n", tmp.left, tmp.right);
+			goto out;
+			}*/
 	}
-	dprintk(KERN_INFO "%u: cond=%u numbers=%u names=%u ac=%u ec=%u\n",
-		__LINE__, e.condc, e.numbers_count, e.names_count, e.argc,
-		e.envc);
-	if (entry) {
-		BUG_ON(e.names_count | e.numbers_count | e.argc | e.envc |
-		       e.condc);
-		return ccs_commit_condition(entry);
-	}
-	e.size = sizeof(*entry)
-		+ e.condc * sizeof(struct ccs_condition_element)
-		+ e.numbers_count * sizeof(struct ccs_number_union)
-		+ e.names_count * sizeof(struct ccs_name_union)
-		+ e.argc * sizeof(struct ccs_argv)
-		+ e.envc * sizeof(struct ccs_envp);
-	entry = kzalloc(e.size, CCS_GFP_FLAGS);
-	if (!entry)
-		return NULL;
-	*entry = e;
-	condp = (struct ccs_condition_element *) (entry + 1);
-	numbers_p = (struct ccs_number_union *) (condp + e.condc);
-	names_p = (struct ccs_name_union *) (numbers_p + e.numbers_count);
-	argv = (struct ccs_argv *) (names_p + e.names_count);
-	envp = (struct ccs_envp *) (argv + e.argc);
-	{
-		bool flag = false;
-		for (pos = start_of_string; pos < end_of_string; pos++) {
-			if (*pos)
-				continue;
-			if (flag) /* Restore " ". */
-				*pos = ' ';
-			else if (*(pos + 1) == '=') /* Restore "!=". */
-				*pos = '!';
-			else /* Restore "=". */
-				*pos = '=';
-			flag = !flag;
-		}
-	}
-	goto rerun;
+	if (!handler_path_done)
+		goto out;
+	//if (!transit_domain_done)
+	//	goto out;
+	entry->size = (void *) condp - (void *) entry;
+	return ccs_commit_condition(entry);
 out:
-	dprintk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);
-	if (entry) {
-		ccs_del_condition(&entry->head.list);
-		kfree(entry);
-	}
+	printk(KERN_WARNING "%u: type=%u env='%s' path='%s' group='%s'\n",
+	       __LINE__, type, tmp.envp ? tmp.envp->name : "",
+	       tmp.path ? tmp.path->name : "",
+	       tmp.group ? tmp.group->group_name->name : "");
+	ccs_put_name(tmp.envp);
+	ccs_put_name(tmp.path);
+	ccs_put_group(tmp.group);
+	entry->size = (void *) condp - (void *) entry;
+	ccs_del_condition(&entry->head.list);
+	kfree(entry);
 	return NULL;
 }
 
@@ -2147,24 +2387,6 @@
 }
 
 /**
- * ccs_addprintf - strncat()-like-snprintf().
- *
- * @buffer: Buffer to write to. Must be '\0'-terminated.
- * @len:    Size of @buffer.
- * @fmt:    The printf()'s format string, followed by parameters.
- *
- * Returns nothing.
- */
-static void ccs_addprintf(char *buffer, int len, const char *fmt, ...)
-{
-	va_list args;
-	const int pos = strlen(buffer);
-	va_start(args, fmt);
-	vsnprintf(buffer + pos, len - pos - 1, fmt, args);
-	va_end(args);
-}
-
-/**
  * ccs_flush - Flush queued string to userspace's buffer.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -2280,213 +2502,28 @@
 }
 
 /**
- * ccs_set_slash - Put a shash to "struct ccs_io_buffer" structure.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns nothing.
- */
-static void ccs_set_slash(struct ccs_io_buffer *head)
-{
-	ccs_set_string(head, "/");
-}
-
-/**
- * ccs_init_policy_namespace - Initialize namespace.
- *
- * @ns: Pointer to "struct ccs_policy_namespace".
- *
- * Returns nothing.
- */
-static void ccs_init_policy_namespace(struct ccs_policy_namespace *ns)
-{
-	unsigned int idx;
-	for (idx = 0; idx < CCS_MAX_GROUP; idx++)
-		INIT_LIST_HEAD(&ns->group_list[idx]);
-	INIT_LIST_HEAD(&ns->default_transition_list);
-	ns->profile_version = 20100903;
-	ccs_namespace_enabled = !list_empty(&ccs_namespace_list);
-	list_add_tail_rcu(&ns->namespace_list, &ccs_namespace_list);
-}
-
-/**
- * ccs_print_namespace - Print namespace header.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns nothing.
- */
-static void ccs_print_namespace(struct ccs_io_buffer *head)
-{
-	if (!ccs_namespace_enabled)
-		return;
-	ccs_set_string(head,
-		       container_of(head->r.ns, struct ccs_policy_namespace,
-				    namespace_list)->name);
-	ccs_set_space(head);
-}
-
-/**
- * ccs_assign_profile - Create a new profile.
- *
- * @ns:      Pointer to "struct ccs_policy_namespace".
- * @profile: Profile number to create.
- *
- * Returns pointer to "struct ccs_profile" on success, NULL otherwise.
- */
-static struct ccs_profile *ccs_assign_profile(struct ccs_policy_namespace *ns,
-					      const unsigned int profile)
-{
-	struct ccs_profile *ptr;
-	struct ccs_profile *entry;
-	if (profile >= CCS_MAX_PROFILES)
-		return NULL;
-	ptr = ns->profile_ptr[profile];
-	if (ptr)
-		return ptr;
-	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	ptr = ns->profile_ptr[profile];
-	if (!ptr && ccs_memory_ok(entry, sizeof(*entry))) {
-		ptr = entry;
-		ptr->default_config = CCS_CONFIG_DISABLED |
-			CCS_CONFIG_WANT_GRANT_LOG | CCS_CONFIG_WANT_REJECT_LOG;
-		memset(ptr->config, CCS_CONFIG_USE_DEFAULT,
-		       sizeof(ptr->config));
-		ptr->pref[CCS_PREF_MAX_AUDIT_LOG] =
-			CONFIG_CCSECURITY_MAX_AUDIT_LOG;
-		ptr->pref[CCS_PREF_MAX_LEARNING_ENTRY] =
-			CONFIG_CCSECURITY_MAX_ACCEPT_ENTRY;
-		mb(); /* Avoid out-of-order execution. */
-		ns->profile_ptr[profile] = ptr;
-		entry = NULL;
-	}
-	mutex_unlock(&ccs_policy_lock);
-out:
-	kfree(entry);
-	return ptr;
-}
-
-/**
  * ccs_check_profile - Check all profiles currently assigned to domains are defined.
  *
  * Returns nothing.
  */
 static void ccs_check_profile(void)
 {
-	struct ccs_domain_info *domain;
-	const int idx = ccs_read_lock();
 	ccs_policy_loaded = true;
 	printk(KERN_INFO "CCSecurity: 1.8.3+   2011/12/13\n");
-	list_for_each_entry_srcu(domain, &ccs_domain_list, list, &ccs_ss) {
-		const u8 profile = domain->profile;
-		const struct ccs_policy_namespace *ns = domain->ns;
-		if (ns->profile_version != 20100903)
-			printk(KERN_ERR
-			       "Profile version %u is not supported.\n",
-			       ns->profile_version);
-		else if (!ns->profile_ptr[profile])
-			printk(KERN_ERR
-			       "Profile %u (used by '%s') is not defined.\n",
-			       profile, domain->domainname->name);
-		else
-			continue;
-		printk(KERN_ERR
-		       "Userland tools for TOMOYO 1.8 must be installed and "
-		       "policy must be initialized.\n");
-		printk(KERN_ERR "Please see http://tomoyo.sourceforge.jp/1.8/ "
-		       "for more information.\n");
-		panic("STOP!");
+	if (ccs_policy_version == 20100903) {
+		printk(KERN_INFO "Mandatory Access Control activated.\n");
+		return;
 	}
-	ccs_read_unlock(idx);
-	printk(KERN_INFO "Mandatory Access Control activated.\n");
+	printk(KERN_ERR "Policy version %u is not supported.\n",
+	       ccs_policy_version);
+	printk(KERN_ERR "Userland tools for TOMOYO 1.8 must be installed and "
+	       "policy must be initialized.\n");
+	printk(KERN_ERR "Please see http://tomoyo.sourceforge.jp/1.8/ "
+	       "for more information.\n");
+	panic("STOP!");
 }
 
 /**
- * ccs_profile - Find a profile.
- *
- * @profile: Profile number to find.
- *
- * Returns pointer to "struct ccs_profile".
- */
-static struct ccs_profile *ccs_profile(const u8 profile)
-{
-	static struct ccs_profile ccs_null_profile;
-	struct ccs_profile *ptr = ccs_current_namespace()->
-		profile_ptr[profile];
-	if (!ptr)
-		ptr = &ccs_null_profile;
-	return ptr;
-}
-
-/**
- * ccs_get_config - Get config for specified profile's specified functionality.
- *
- * @profile: Profile number.
- * @index:   Index number of functionality.
- *
- * Returns config.
- *
- * First, check for CONFIG::category::functionality.
- * If CONFIG::category::functionality is set to use default, then check
- * CONFIG::category. If CONFIG::category is set to use default, then use
- * CONFIG. CONFIG cannot be set to use default.
- */
-static u8 ccs_get_config(const u8 profile, const u8 index)
-{
-	u8 config;
-	const struct ccs_profile *p;
-	if (!ccs_policy_loaded)
-		return CCS_CONFIG_DISABLED;
-	p = ccs_profile(profile);
-	config = p->config[index];
-	if (config == CCS_CONFIG_USE_DEFAULT)
-		config = p->config[ccs_index2category[index]
-				   + CCS_MAX_MAC_INDEX];
-	if (config == CCS_CONFIG_USE_DEFAULT)
-		config = p->default_config;
-	return config;
-}
-
-/**
- * ccs_find_yesno - Find values for specified keyword.
- *
- * @string: String to check.
- * @find:   Name of keyword.
- *
- * Returns 1 if "@find=yes" was found, 0 if "@find=no" was found, -1 otherwise.
- */
-static s8 ccs_find_yesno(const char *string, const char *find)
-{
-	const char *cp = strstr(string, find);
-	if (cp) {
-		cp += strlen(find);
-		if (!strncmp(cp, "=yes", 4))
-			return 1;
-		else if (!strncmp(cp, "=no", 3))
-			return 0;
-	}
-	return -1;
-}
-
-/**
- * ccs_set_uint - Set value for specified preference.
- *
- * @i:      Pointer to "unsigned int".
- * @string: String to check.
- * @find:   Name of keyword.
- *
- * Returns nothing.
- */
-static void ccs_set_uint(unsigned int *i, const char *string, const char *find)
-{
-	const char *cp = strstr(string, find);
-	if (cp)
-		sscanf(cp + strlen(find), "=%u", i);
-}
-
-/**
  * ccs_str_starts - Check whether the given string starts with the given keyword.
  *
  * @src:  Pointer to pointer to the string.
@@ -2509,453 +2546,6 @@
 }
 
 /**
- * ccs_group_type - Check whether the given string refers group or not.
- *
- * @src:  Pointer to pointer to the string.
- *
- * Returns 1 if @src refers a group in positive match, 2 if psrc refers a group
- * in negative match, 0 otherwise.
- *
- * The @src is updated to point the first character of a group name if @src
- * refers a group.
- */
-static u8 ccs_group_type(char **src)
-{
-	if (ccs_str_starts(src, "\\="))
-		return 1;
-	if (ccs_str_starts(src, "\\!"))
-		return 2;
-	return 0;
-}
-
-/**
- * ccs_print_group - Print group's name.
- *
- * @head:   Pointer to "struct ccs_io_buffer".
- * @is_not: True if @group is negative match, false otherwise.
- * @group:  Pointer to "struct ccsgroup". Maybe NULL.
- *
- * Returns true if @group is not NULL. false otherwise.
- */
-static bool ccs_print_group(struct ccs_io_buffer *head, const bool is_not,
-			    const struct ccs_group *group)
-{
-	if (group) {
-		ccs_set_string(head, is_not ? "\\!" : "\\=");
-		ccs_set_string(head, group->group_name->name);
-		return true;
-	}
-	return false;
-}
-
-/**
- * ccs_set_mode - Set mode for specified profile.
- *
- * @name:    Name of functionality.
- * @value:   Mode for @name.
- * @profile: Pointer to "struct ccs_profile".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_set_mode(char *name, const char *value,
-			struct ccs_profile *profile)
-{
-	u8 i;
-	u8 config;
-	if (!strcmp(name, "CONFIG")) {
-		i = CCS_MAX_MAC_INDEX + CCS_MAX_MAC_CATEGORY_INDEX;
-		config = profile->default_config;
-	} else if (ccs_str_starts(&name, "CONFIG::")) {
-		config = 0;
-		for (i = 0; i < CCS_MAX_MAC_INDEX + CCS_MAX_MAC_CATEGORY_INDEX;
-		     i++) {
-			int len = 0;
-			if (i < CCS_MAX_MAC_INDEX) {
-				const u8 c = ccs_index2category[i];
-				const char *category =
-					ccs_category_keywords[c];
-				len = strlen(category);
-				if (strncmp(name, category, len) ||
-				    name[len++] != ':' || name[len++] != ':')
-					continue;
-			}
-			if (strcmp(name + len, ccs_mac_keywords[i]))
-				continue;
-			config = profile->config[i];
-			break;
-		}
-		if (i == CCS_MAX_MAC_INDEX + CCS_MAX_MAC_CATEGORY_INDEX)
-			return -EINVAL;
-	} else {
-		return -EINVAL;
-	}
-	if (strstr(value, "use_default")) {
-		config = CCS_CONFIG_USE_DEFAULT;
-	} else {
-		u8 mode;
-		for (mode = 0; mode < CCS_CONFIG_MAX_MODE; mode++)
-			if (strstr(value, ccs_mode[mode]))
-				/*
-				 * Update lower 3 bits in order to distinguish
-				 * 'config' from 'CCS_CONFIG_USE_DEAFULT'.
-				 */
-				config = (config & ~7) | mode;
-		if (config != CCS_CONFIG_USE_DEFAULT) {
-			switch (ccs_find_yesno(value, "grant_log")) {
-			case 1:
-				config |= CCS_CONFIG_WANT_GRANT_LOG;
-				break;
-			case 0:
-				config &= ~CCS_CONFIG_WANT_GRANT_LOG;
-				break;
-			}
-			switch (ccs_find_yesno(value, "reject_log")) {
-			case 1:
-				config |= CCS_CONFIG_WANT_REJECT_LOG;
-				break;
-			case 0:
-				config &= ~CCS_CONFIG_WANT_REJECT_LOG;
-				break;
-			}
-		}
-	}
-	if (i < CCS_MAX_MAC_INDEX + CCS_MAX_MAC_CATEGORY_INDEX)
-		profile->config[i] = config;
-	else if (config != CCS_CONFIG_USE_DEFAULT)
-		profile->default_config = config;
-	return 0;
-}
-
-/**
- * ccs_write_profile - Write profile table.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_write_profile(struct ccs_io_buffer *head)
-{
-	char *data = head->write_buf;
-	unsigned int i;
-	char *cp;
-	struct ccs_profile *profile;
-	if (sscanf(data, "PROFILE_VERSION=%u", &head->w.ns->profile_version)
-	    == 1)
-		return 0;
-	i = simple_strtoul(data, &cp, 10);
-	if (*cp != '-')
-		return -EINVAL;
-	data = cp + 1;
-	profile = ccs_assign_profile(head->w.ns, i);
-	if (!profile)
-		return -EINVAL;
-	cp = strchr(data, '=');
-	if (!cp)
-		return -EINVAL;
-	*cp++ = '\0';
-	if (!strcmp(data, "COMMENT")) {
-		static DEFINE_SPINLOCK(lock);
-		const struct ccs_path_info *new_comment = ccs_get_name(cp);
-		const struct ccs_path_info *old_comment;
-		if (!new_comment)
-			return -ENOMEM;
-		spin_lock(&lock);
-		old_comment = profile->comment;
-		profile->comment = new_comment;
-		spin_unlock(&lock);
-		ccs_put_name(old_comment);
-		return 0;
-	}
-	if (!strcmp(data, "PREFERENCE")) {
-		for (i = 0; i < CCS_MAX_PREF; i++)
-			ccs_set_uint(&profile->pref[i], cp,
-				     ccs_pref_keywords[i]);
-		return 0;
-	}
-	return ccs_set_mode(data, cp, profile);
-}
-
-/**
- * ccs_print_config - Print mode for specified functionality.
- *
- * @head:   Pointer to "struct ccs_io_buffer".
- * @config: Mode for that functionality.
- *
- * Returns nothing.
- *
- * Caller prints functionality's name.
- */
-static void ccs_print_config(struct ccs_io_buffer *head, const u8 config)
-{
-	ccs_io_printf(head, "={ mode=%s grant_log=%s reject_log=%s }\n",
-		      ccs_mode[config & 3],
-		      ccs_yesno(config & CCS_CONFIG_WANT_GRANT_LOG),
-		      ccs_yesno(config & CCS_CONFIG_WANT_REJECT_LOG));
-}
-
-/**
- * ccs_read_profile - Read profile table.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns nothing.
- */
-static void ccs_read_profile(struct ccs_io_buffer *head)
-{
-	u8 index;
-	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
-						       namespace_list);
-	const struct ccs_profile *profile;
-	if (head->r.eof)
-		return;
-next:
-	index = head->r.index;
-	profile = ns->profile_ptr[index];
-	switch (head->r.step) {
-	case 0:
-		ccs_print_namespace(head);
-		ccs_io_printf(head, "PROFILE_VERSION=%u\n",
-			      ns->profile_version);
-		head->r.step++;
-		break;
-	case 1:
-		for ( ; head->r.index < CCS_MAX_PROFILES; head->r.index++)
-			if (ns->profile_ptr[head->r.index])
-				break;
-		if (head->r.index == CCS_MAX_PROFILES) {
-			head->r.eof = true;
-			return;
-		}
-		head->r.step++;
-		break;
-	case 2:
-		{
-			u8 i;
-			const struct ccs_path_info *comment = profile->comment;
-			ccs_print_namespace(head);
-			ccs_io_printf(head, "%u-COMMENT=", index);
-			ccs_set_string(head, comment ? comment->name : "");
-			ccs_set_lf(head);
-			ccs_print_namespace(head);
-			ccs_io_printf(head, "%u-PREFERENCE={ ", index);
-			for (i = 0; i < CCS_MAX_PREF; i++)
-				ccs_io_printf(head, "%s=%u ",
-					      ccs_pref_keywords[i],
-					      profile->pref[i]);
-			ccs_set_string(head, "}\n");
-			head->r.step++;
-		}
-		break;
-	case 3:
-		{
-			ccs_print_namespace(head);
-			ccs_io_printf(head, "%u-%s", index, "CONFIG");
-			ccs_print_config(head, profile->default_config);
-			head->r.bit = 0;
-			head->r.step++;
-		}
-		break;
-	case 4:
-		for ( ; head->r.bit < CCS_MAX_MAC_INDEX
-			      + CCS_MAX_MAC_CATEGORY_INDEX; head->r.bit++) {
-			const u8 i = head->r.bit;
-			const u8 config = profile->config[i];
-			if (config == CCS_CONFIG_USE_DEFAULT)
-				continue;
-			ccs_print_namespace(head);
-			if (i < CCS_MAX_MAC_INDEX)
-				ccs_io_printf(head, "%u-CONFIG::%s::%s", index,
-					      ccs_category_keywords
-					      [ccs_index2category[i]],
-					      ccs_mac_keywords[i]);
-			else
-				ccs_io_printf(head, "%u-CONFIG::%s", index,
-					      ccs_mac_keywords[i]);
-			ccs_print_config(head, config);
-			head->r.bit++;
-			break;
-		}
-		if (head->r.bit == CCS_MAX_MAC_INDEX
-		    + CCS_MAX_MAC_CATEGORY_INDEX) {
-			head->r.index++;
-			head->r.step = 1;
-		}
-		break;
-	}
-	if (ccs_flush(head))
-		goto next;
-}
-
-/**
- * ccs_update_policy - Update an entry for exception policy.
- *
- * @size:  Size of new entry in bytes.
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_update_policy(const int size, struct ccs_acl_param *param)
-{
-	struct ccs_acl_head *new_entry = &param->e.acl_head;
-	int error = param->is_delete ? -ENOENT : -ENOMEM;
-	struct ccs_acl_head *entry;
-	struct list_head *list = param->list;
-	BUG_ON(size < sizeof(*entry));
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		return -ENOMEM;
-	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
-		if (entry->is_deleted == CCS_GC_IN_PROGRESS)
-			continue;
-		if (memcmp(entry + 1, new_entry + 1, size - sizeof(*entry)))
-			continue;
-		entry->is_deleted = param->is_delete;
-		error = 0;
-		break;
-	}
-	if (error && !param->is_delete) {
-		entry = ccs_commit_ok(new_entry, size);
-		if (entry) {
-			list_add_tail_rcu(&entry->list, list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
-	return error;
-}
-
-/**
- * ccs_update_manager_entry - Add a manager entry.
- *
- * @manager:   The path to manager or the domainnamme.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_manager_entry(const char *manager,
-				    const bool is_delete)
-{
-	struct ccs_acl_param param = {
-		/* .ns = &ccs_kernel_namespace, */
-		.is_delete = is_delete,
-		.list = &ccs_manager_list,
-	};
-	struct ccs_manager *e = &param.e.manager;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	/* Forced zero clear for using memcmp() at ccs_update_policy(). */
-	memset(&param.e, 0, sizeof(param.e));
-	if (ccs_domain_def(manager)) {
-		if (!ccs_correct_domain(manager))
-			return -EINVAL;
-		e->is_domain = true;
-	} else {
-		if (!ccs_correct_path(manager))
-			return -EINVAL;
-	}
-	e->manager = ccs_get_name(manager);
-	if (e->manager) {
-		error = ccs_update_policy(sizeof(*e), &param);
-		ccs_put_name(e->manager);
-	}
-	return error;
-}
-
-/**
- * ccs_write_manager - Write manager policy.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_write_manager(struct ccs_io_buffer *head)
-{
-	const char *data = head->write_buf;
-	if (!strcmp(data, "manage_by_non_root")) {
-		ccs_manage_by_non_root = !head->w.is_delete;
-		return 0;
-	}
-	return ccs_update_manager_entry(data, head->w.is_delete);
-}
-
-/**
- * ccs_read_manager - Read manager policy.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns nothing.
- *
- * Caller holds ccs_read_lock().
- */
-static void ccs_read_manager(struct ccs_io_buffer *head)
-{
-	if (head->r.eof)
-		return;
-	list_for_each_cookie(head->r.acl, &ccs_manager_list) {
-		struct ccs_manager *ptr =
-			list_entry(head->r.acl, typeof(*ptr), head.list);
-		if (ptr->head.is_deleted)
-			continue;
-		if (!ccs_flush(head))
-			return;
-		ccs_set_string(head, ptr->manager->name);
-		ccs_set_lf(head);
-	}
-	head->r.eof = true;
-}
-
-/**
- * ccs_manager - Check whether the current process is a policy manager.
- *
- * Returns true if the current process is permitted to modify policy
- * via /proc/ccs/ interface.
- *
- * Caller holds ccs_read_lock().
- */
-static bool ccs_manager(void)
-{
-	struct ccs_manager *ptr;
-	const char *exe;
-	struct ccs_security *task = ccs_current_security();
-	const struct ccs_path_info *domainname
-		= ccs_current_domain()->domainname;
-	bool found = false;
-	if (!ccs_policy_loaded)
-		return true;
-	if (task->ccs_flags & CCS_TASK_IS_MANAGER)
-		return true;
-	if (!ccs_manage_by_non_root && (current_uid() || current_euid()))
-		return false;
-	exe = ccs_get_exe();
-	list_for_each_entry_srcu(ptr, &ccs_manager_list, head.list, &ccs_ss) {
-		if (ptr->head.is_deleted)
-			continue;
-		if (ptr->is_domain) {
-			if (ccs_pathcmp(domainname, ptr->manager))
-				continue;
-		} else {
-			if (!exe || strcmp(exe, ptr->manager->name))
-				continue;
-		}
-		/* Set manager flag. */
-		task->ccs_flags |= CCS_TASK_IS_MANAGER;
-		found = true;
-		break;
-	}
-	if (!found) { /* Reduce error messages. */
-		static pid_t ccs_last_pid;
-		const pid_t pid = current->pid;
-		if (ccs_last_pid != pid) {
-			printk(KERN_WARNING "%s ( %s ) is not permitted to "
-			       "update policies.\n", domainname->name, exe);
-			ccs_last_pid = pid;
-		}
-	}
-	kfree(exe);
-	return found;
-}
-
-/**
  * ccs_find_domain - Find a domain by the given name.
  *
  * @domainname: The domainname to find.
@@ -2979,7 +2569,7 @@
 }
 
 /**
- * ccs_select_domain - Parse select command.
+ * ccs_select_acl - Parse select command.
  *
  * @head: Pointer to "struct ccs_io_buffer".
  * @data: String to parse.
@@ -2988,737 +2578,331 @@
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_select_domain(struct ccs_io_buffer *head, const char *data)
+static bool ccs_select_acl(struct ccs_io_buffer *head, const char *data)
 {
-	unsigned int pid;
-	struct ccs_domain_info *domain = NULL;
-	bool global_pid = false;
-	if (strncmp(data, "select ", 7))
+	unsigned int qid;
+	struct ccs_acl_info *acl;
+	if (sscanf(data, "Q=%u", &qid) != 1)
 		return false;
-	data += 7;
-	if (sscanf(data, "pid=%u", &pid) == 1 ||
-	    (global_pid = true, sscanf(data, "global-pid=%u", &pid) == 1)) {
-		struct task_struct *p;
-		ccs_tasklist_lock();
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
-		if (global_pid)
-			p = ccsecurity_exports.find_task_by_pid_ns(pid,
-							       &init_pid_ns);
-		else
-			p = ccsecurity_exports.find_task_by_vpid(pid);
-#else
-		p = find_task_by_pid(pid);
-#endif
-		if (p)
-			domain = ccs_task_domain(p);
-		ccs_tasklist_unlock();
-	} else if (!strncmp(data, "domain=", 7)) {
-		if (*(data + 7) == '<')
-			domain = ccs_find_domain(data + 7);
-	} else if (sscanf(data, "Q=%u", &pid) == 1) {
-		domain = ccs_find_domain_by_qid(pid);
-	} else
-		return false;
-	head->w.domain = domain;
+	acl = ccs_find_acl_by_qid(qid);
+	head->w.acl = acl;
 	/* Accessing read_buf is safe because head->io_sem is held. */
 	if (!head->read_buf)
 		return true; /* Do nothing if open(O_WRONLY). */
 	memset(&head->r, 0, sizeof(head->r));
-	head->r.print_this_domain_only = true;
-	if (domain)
-		head->r.domain = &domain->list;
+	head->r.print_this_acl_only = true;
+	if (acl)
+		head->r.acl = &acl->list;
 	else
 		head->r.eof = true;
 	ccs_io_printf(head, "# select %s\n", data);
-	if (domain && domain->is_deleted)
-		ccs_set_string(head, "# This is a deleted domain.\n");
 	return true;
 }
 
-/**
- * ccs_update_inverse_list - Update an entry for domain policy.
- *
- * @new_entry: Pointer to "struct ccs_acl_info".
- * @size:      Size of @new_entry in bytes.
- * @param:     Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_update_inverse_list(struct ccs_acl_info *new_entry,
-				   const int size, struct ccs_acl_param *param)
+static struct ccs_condition *ccs_parse_condition_in_param
+(struct ccs_io_buffer *head)
 {
-	const bool is_delete = param->is_delete;
-	struct ccs_acl_info *entry;
-	list_for_each_entry_srcu(entry, &ccs_inversed_acl_list, list,
-				 &ccs_ss) {
-		if (entry->is_deleted == CCS_GC_IN_PROGRESS ||
-		    entry->perm != new_entry->perm ||
-		    entry->type != new_entry->type ||
-		    entry->cond != new_entry->cond ||
-		    memcmp(entry + 1, new_entry + 1, size - sizeof(*entry)))
-			continue;
-		entry->is_deleted = is_delete;
-		param->matched_entry = entry;
-		return 0;
-	}
-	if (is_delete)
-		return -ENOENT;
-	entry = ccs_commit_ok(new_entry, size);
-	if (!entry)
-		return -ENOMEM;
-	INIT_LIST_HEAD(&entry->domain_list);
-	list_add_tail_rcu(&entry->list, &ccs_inversed_acl_list);
-	param->matched_entry = entry;
-	return 0;
+	struct ccs_condition *cond;
+	char *line = kstrdup(head->w.data, CCS_GFP_FLAGS);
+	cond = ccs_get_condition(head);
+	if (!cond)
+		printk(KERN_WARNING "%u: '%s' failed\n", __LINE__, line);
+	kfree(line);
+	return cond;
 }
 
 /**
  * ccs_update_acl - Update "struct ccs_acl_info" entry.
  *
- * @size:  Size of new entry in bytes.
- * @param: Pointer to "struct ccs_acl_param".
+ * @list:   Pointer to "struct list_head".
+ * @head:   Pointer to "struct ccs_io_buffer".
+ * @update: True to store matching entry, false otherwise.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_update_acl(const int size, struct ccs_acl_param *param)
+static int ccs_update_acl(struct list_head * const list,
+			  struct ccs_io_buffer *head, const bool update)
 {
-	struct ccs_acl_info *new_entry = &param->e.acl_info;
-	const bool is_delete = param->is_delete;
+	struct ccs_acl_info *ptr;
+	struct ccs_acl_info new_entry = { };
+	const bool is_delete = head->w.is_delete;
 	int error = is_delete ? -ENOENT : -ENOMEM;
-	struct ccs_acl_info *entry;
-	struct list_head * const list = param->list;
-	BUG_ON(size < sizeof(*entry));
-	if (param->data[0]) {
-		new_entry->cond = ccs_get_condition(param);
-		if (!new_entry->cond)
+	new_entry.priority = head->w.priority;
+	new_entry.priority = head->w.priority;
+	new_entry.is_deny = head->w.is_deny;
+	if (head->w.data[0]) {
+		new_entry.cond = ccs_parse_condition_in_param(head);
+		if (!new_entry.cond)
 			return -EINVAL;
 	}
 	if (mutex_lock_interruptible(&ccs_policy_lock))
-		return -ENOMEM;
-	if (!list) {
-		error = ccs_update_inverse_list(new_entry, size, param);
-		goto unlock;
-	}
-	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
-		if (entry->is_deleted == CCS_GC_IN_PROGRESS)
+		goto out;
+	list_for_each_entry_srcu(ptr, list, list, &ccs_ss) {
+		if (ptr->priority > new_entry.priority)
+			break;
+		if (ptr->is_deleted == CCS_GC_IN_PROGRESS ||
+		    ptr->cond != new_entry.cond ||
+		    ptr->priority != new_entry.priority ||
+		    ptr->is_deny != new_entry.is_deny)
 			continue;
-		if (entry->type != new_entry->type ||
-		    entry->cond != new_entry->cond ||
-		    memcmp(entry + 1, new_entry + 1, size - sizeof(*entry)))
-			continue;
-		if (is_delete)
-			entry->perm &= ~new_entry->perm;
-		else
-			entry->perm |= new_entry->perm;
-		entry->is_deleted = !entry->perm;
+		ptr->is_deleted = is_delete;
+		if (!is_delete && update)
+			head->w.acl = ptr;
 		error = 0;
 		break;
 	}
 	if (error && !is_delete) {
-		entry = ccs_commit_ok(new_entry, size);
+		struct ccs_acl_info *entry =
+			ccs_commit_ok(&new_entry, sizeof(new_entry));
 		if (entry) {
-			list_add_tail_rcu(&entry->list, list);
-			error = 0;
+			INIT_LIST_HEAD(&entry->acl_info_list);
+			entry->mode = CCS_CONFIG_PERMISSIVE;
+			entry->max_reject_log = 1024;
+			list_add_tail_rcu(&entry->list, &ptr->list);
+			if (update)
+				head->w.acl = entry;
 		}
 	}
-unlock:
 	mutex_unlock(&ccs_policy_lock);
+out:
+	ccs_put_condition(new_entry.cond);
 	return error;
 }
 
 /**
- * ccs_permstr - Find permission keywords.
+ * ccs_parse_entry - Update ACL entry.
  *
- * @string: String representation for permissions in foo/bar/buz format.
- * @keyword: Keyword to find from @string/
+ * @head: Pointer to "struct ccs_io_buffer".
  *
- * Returns ture if @keyword was found in @string, false otherwise.
- *
- * This function assumes that strncmp(w1, w2, strlen(w1)) != 0 if w1 != w2.
- */
-static bool ccs_permstr(const char *string, const char *keyword)
-{
-	const char *cp = strstr(string, keyword);
-	if (cp)
-		return cp == string || *(cp - 1) == '/';
-	return false;
-}
-
-/**
- * ccs_write_task - Update task related list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_write_task(struct ccs_acl_param *param)
+static int ccs_parse_entry(struct ccs_io_buffer *head)
 {
-	int error;
-	const bool is_auto = ccs_str_starts(&param->data,
-					    "auto_domain_transition ");
-	if (!is_auto && !ccs_str_starts(&param->data,
-					"manual_domain_transition ")) {
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-		struct ccs_handler_acl *e = &param->e.handler_acl;
-		char *handler;
-		if (ccs_str_starts(&param->data, "auto_execute_handler "))
-			e->head.type = CCS_TYPE_AUTO_EXECUTE_HANDLER;
-		else if (ccs_str_starts(&param->data,
-					"denied_execute_handler "))
-			e->head.type = CCS_TYPE_DENIED_EXECUTE_HANDLER;
-		else
-			return -EINVAL;
-		handler = ccs_read_token(param);
-		if (!ccs_correct_path(handler))
-			return -EINVAL;
-		e->handler = ccs_get_name(handler);
-		if (!e->handler)
-			return -ENOMEM;
-		if (e->handler->is_patterned)
-			return -EINVAL; /* No patterns allowed. */
-		return ccs_update_acl(sizeof(*e), param);
-#else
-		error = -EINVAL;
-#endif
-	} else {
-#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
-		struct ccs_task_acl *e = &param->e.task_acl;
-		e->head.type = is_auto ?
-			CCS_TYPE_AUTO_TASK_ACL : CCS_TYPE_MANUAL_TASK_ACL;
-		e->domainname = ccs_get_domainname(param);
-		if (!e->domainname)
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-#else
-		error = -EINVAL;
-#endif
-	}
-	return error;
-}
-
-#ifdef CONFIG_CCSECURITY_NETWORK
-
-/**
- * ccs_write_inet_network - Write "struct ccs_inet_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_write_inet_network(struct ccs_acl_param *param)
-{
-	struct ccs_inet_acl *e = &param->e.inet_acl;
-	u8 type;
-	const char *protocol = ccs_read_token(param);
-	const char *operation = ccs_read_token(param);
-	e->head.type = CCS_TYPE_INET_ACL;
-	for (type = 0; type < CCS_SOCK_MAX; type++)
-		if (!strcmp(protocol, ccs_proto_keyword[type]))
-			break;
-	if (type == CCS_SOCK_MAX)
-		return -EINVAL;
-	e->protocol = type;
-	e->head.perm = 0;
-	for (type = 0; type < CCS_MAX_NETWORK_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_socket_keyword[type]))
-			e->head.perm |= 1 << type;
-	if (!e->head.perm)
-		return -EINVAL;
-	if (!ccs_parse_ipaddr_union(param, &e->address))
-		return -EINVAL;
-	if (!ccs_parse_number_union(param, &e->port) ||
-	    e->port.values[1] > 65535)
-		return -EINVAL;
-	return ccs_update_acl(sizeof(*e), param);
-}
-
-/**
- * ccs_write_unix_network - Write "struct ccs_unix_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_write_unix_network(struct ccs_acl_param *param)
-{
-	struct ccs_unix_acl *e = &param->e.unix_acl;
-	u8 type;
-	const char *protocol = ccs_read_token(param);
-	const char *operation = ccs_read_token(param);
-	e->head.type = CCS_TYPE_UNIX_ACL;
-	for (type = 0; type < CCS_SOCK_MAX; type++)
-		if (!strcmp(protocol, ccs_proto_keyword[type]))
-			break;
-	if (type == CCS_SOCK_MAX)
-		return -EINVAL;
-	e->protocol = type;
-	e->head.perm = 0;
-	for (type = 0; type < CCS_MAX_NETWORK_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_socket_keyword[type]))
-			e->head.perm |= 1 << type;
-	if (!e->head.perm)
-		return -EINVAL;
-	if (!ccs_parse_name_union(param, &e->name))
-		return -EINVAL;
-	return ccs_update_acl(sizeof(*e), param);
-}
-
-#endif
-
-/**
- * ccs_update_execute_acl - Update execute entry.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_update_execute_acl(struct ccs_acl_param *param)
-{
-	struct ccs_execute_acl *e = &param->e.execute_acl;
-	e->head.type = CCS_TYPE_EXECUTE_ACL;
-	e->head.perm = 1;
-	if (!ccs_parse_name_union(param, &e->program))
-		return -EINVAL;
-	param->data = ccs_get_transit_preference(param, e);
-	if (!param->data)
-		return -EINVAL;
-	return ccs_update_acl(sizeof(*e), param);
-}
-
-/**
- * ccs_write_file - Update file related list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_write_file(struct ccs_acl_param *param)
-{
-	u16 perm = 0;
-	u8 type;
-	const char *operation = ccs_read_token(param);
-	if (ccs_permstr(operation, ccs_mac_keywords[CCS_MAC_FILE_EXECUTE]))
-		return ccs_update_execute_acl(param);
-	for (type = 0; type < CCS_MAX_PATH_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_mac_keywords[ccs_p2mac[type]]))
-			perm |= 1 << type;
-	if (perm) {
-		struct ccs_path_acl *e = &param->e.path_acl;
-		e->head.type = CCS_TYPE_PATH_ACL;
-		e->head.perm = perm;
-		if (!ccs_parse_name_union(param, &e->name))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-	}
-	for (type = 0; type < CCS_MAX_PATH2_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_mac_keywords[ccs_pp2mac[type]]))
-			perm |= 1 << type;
-	if (perm) {
-		struct ccs_path2_acl *e = &param->e.path2_acl;
-		e->head.type = CCS_TYPE_PATH2_ACL;
-		e->head.perm = perm;
-		if (!ccs_parse_name_union(param, &e->name1) ||
-		    !ccs_parse_name_union(param, &e->name2))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-	}
-	for (type = 0; type < CCS_MAX_PATH_NUMBER_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_mac_keywords[ccs_pn2mac[type]]))
-			perm |= 1 << type;
-	if (perm) {
-		struct ccs_path_number_acl *e = &param->e.path_number_acl;
-		e->head.type = CCS_TYPE_PATH_NUMBER_ACL;
-		e->head.perm = perm;
-		if (!ccs_parse_name_union(param, &e->name) ||
-		    !ccs_parse_number_union(param, &e->number))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-	}
-	for (type = 0; type < CCS_MAX_MKDEV_OPERATION; type++)
-		if (ccs_permstr(operation,
-				ccs_mac_keywords[ccs_pnnn2mac[type]]))
-			perm |= 1 << type;
-	if (perm) {
-		struct ccs_mkdev_acl *e = &param->e.mkdev_acl;
-		e->head.type = CCS_TYPE_MKDEV_ACL;
-		e->head.perm = perm;
-		if (!ccs_parse_name_union(param, &e->name) ||
-		    !ccs_parse_number_union(param, &e->mode) ||
-		    !ccs_parse_number_union(param, &e->major) ||
-		    !ccs_parse_number_union(param, &e->minor))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-	}
-	if (ccs_permstr(operation, ccs_mac_keywords[CCS_MAC_FILE_MOUNT])) {
-		struct ccs_mount_acl *e = &param->e.mount_acl;
-		e->head.type = CCS_TYPE_MOUNT_ACL;
-		if (!ccs_parse_name_union(param, &e->dev_name) ||
-		    !ccs_parse_name_union(param, &e->dir_name) ||
-		    !ccs_parse_name_union(param, &e->fs_type) ||
-		    !ccs_parse_number_union(param, &e->flags))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-	}
-	return -EINVAL;
-}
-
-#ifdef CONFIG_CCSECURITY_MISC
-
-/**
- * ccs_write_misc - Update environment variable list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_write_misc(struct ccs_acl_param *param)
-{
-	if (ccs_str_starts(&param->data, "env ")) {
-		struct ccs_env_acl *e = &param->e.env_acl;
-		e->head.type = CCS_TYPE_ENV_ACL;
-		if (!ccs_parse_name_union(param, &e->env))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-	}
-	return -EINVAL;
-}
-
-#endif
-
-#ifdef CONFIG_CCSECURITY_IPC
-
-/**
- * ccs_write_ipc - Update "struct ccs_ptrace_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_write_ipc(struct ccs_acl_param *param)
-{
-	struct ccs_ptrace_acl *e = &param->e.ptrace_acl;
-	e->head.type = CCS_TYPE_PTRACE_ACL;
-	if (!ccs_parse_number_union(param, &e->request))
-		return -EINVAL;
-	e->domainname = ccs_get_domainname(param);
-	if (!e->domainname)
-		return -EINVAL;
-	return ccs_update_acl(sizeof(*e), param);
-}
-
-#endif
-
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-
-/**
- * ccs_write_capability - Write "struct ccs_capability_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_write_capability(struct ccs_acl_param *param)
-{
-	struct ccs_capability_acl *e = &param->e.capability_acl;
-	const char *operation = ccs_read_token(param);
-	u8 type;
-	e->head.type = CCS_TYPE_CAPABILITY_ACL;
-	for (type = 0; type < CCS_MAX_CAPABILITY_INDEX; type++) {
-		if (strcmp(operation, ccs_mac_keywords[ccs_c2mac[type]]))
+	enum ccs_mac_index type;
+	const char *category = ccs_read_token(head);
+	const char *operation = ccs_read_token(head);
+	for (type = CCS_MAC_FILE_EXECUTE; type < CCS_MAX_MAC_INDEX; type++) {
+		if (!ccs_category_keywords[ccs_index2category[type]]) {
+			printk(KERN_INFO
+			       "ccs_category_keywords[ccs_index2category[%u]]"
+			       "==NULL\n", type);
 			continue;
-		e->operation = type;
-		return ccs_update_acl(sizeof(*e), param);
-	}
-	return -EINVAL;
-}
-
-#endif
-
-/**
- * ccs_write_use_group_acl - Write "struct ccs_use_group_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_write_use_group_acl(struct ccs_acl_param *param)
-{
-	struct ccs_use_group_acl *e = &param->e.use_group_acl;
-	e->head.type = CCS_TYPE_USE_GROUP_ACL;
-	switch (ccs_group_type(&param->data)) {
-	case 2:
-		e->is_not = true;
-		/* fall through */
-	case 1:
-		e->group = ccs_get_group(param, CCS_ACL_GROUP);
-		if (e->group)
-			return ccs_update_acl(sizeof(*e), param);
-	}
-	return -EINVAL;
-}
-
-/**
- * ccs_write_acl - Write "struct ccs_acl_info" list.
- *
- * @ns:        Pointer to "struct ccs_policy_namespace".
- * @list:      Pointer to "struct list_head".
- * @data:      Policy to be interpreted.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_write_acl(struct ccs_policy_namespace *ns,
-			 struct list_head *list, char *data,
-			 const bool is_delete)
-{
-	struct ccs_acl_param param = {
-		.ns = ns,
-		.list = list,
-		.data = data,
-		.is_delete = is_delete,
-	};
-	static const struct {
-		const char *keyword;
-		int (*write) (struct ccs_acl_param *);
-	} ccs_callback[] = {
-		{ "file ", ccs_write_file },
-#ifdef CONFIG_CCSECURITY_NETWORK
-		{ "network inet ", ccs_write_inet_network },
-		{ "network unix ", ccs_write_unix_network },
-#endif
-#ifdef CONFIG_CCSECURITY_MISC
-		{ "misc ", ccs_write_misc },
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-		{ "capability ", ccs_write_capability },
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-		{ "ipc ptrace ", ccs_write_ipc },
-#endif
-		{ "task ", ccs_write_task },
-		{ "use_group ", ccs_write_use_group_acl },
-	};
-	u8 i;
-	/* Forced zero clear for using memcmp() at ccs_update_acl(). */
-	memset(&param.e, 0, sizeof(param.e));
-	param.e.acl_info.perm = 1;
-	for (i = 0; i < ARRAY_SIZE(ccs_callback); i++) {
-		int error;
-		if (!ccs_str_starts(&param.data, ccs_callback[i].keyword))
+		}
+		if (!ccs_mac_keywords[type]) {
+			printk(KERN_INFO "ccs_mac_keywords[%u]==NULL\n", type);
 			continue;
-		error = ccs_callback[i].write(&param);
-		ccs_del_acl(&param.e.acl_info.list);
-		return error;
+		}
+		if (strcmp(category, ccs_category_keywords
+			   [ccs_index2category[type]]) ||
+		    strcmp(operation, ccs_mac_keywords[type]))
+			continue;
+		head->w.acl_index = type;
+		return ccs_update_acl(&ccs_acl_list[type], head, true);
 	}
 	return -EINVAL;
 }
 
-/**
- * ccs_delete_domain - Delete a domain.
- *
- * @domainname: The name of domain.
- *
- * Returns 0.
- */
-static int ccs_delete_domain(char *domainname)
+static void ccs_print_number(struct ccs_io_buffer *head,
+			     const enum ccs_value_type radix,
+			     const unsigned long value)
 {
-	struct ccs_domain_info *domain;
-	struct ccs_path_info name;
-	name.name = domainname;
-	ccs_fill_path_info(&name);
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		return 0;
-	/* Is there an active domain? */
-	list_for_each_entry_srcu(domain, &ccs_domain_list, list, &ccs_ss) {
-		/* Never delete ccs_kernel_domain. */
-		if (domain == &ccs_kernel_domain)
-			continue;
-		if (domain->is_deleted ||
-		    ccs_pathcmp(domain->domainname, &name))
-			continue;
-		domain->is_deleted = true;
+	switch (radix) {
+	case CCS_VALUE_TYPE_HEXADECIMAL:
+		ccs_io_printf(head, "0x%lX", value);
 		break;
+	case CCS_VALUE_TYPE_OCTAL:
+		ccs_io_printf(head, "0%lo", value);
+		break;
+	default:
+		ccs_io_printf(head, "%lu", value);
 	}
-	mutex_unlock(&ccs_policy_lock);
-	return 0;
 }
 
-/**
- * ccs_write_domain - Write domain policy.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_write_domain(struct ccs_io_buffer *head)
+static void ccs_print_misc_attribute(struct ccs_io_buffer *head,
+				     const enum ccs_mac_index type,
+				     const enum ccs_conditions_index cond)
 {
-	char *data = head->write_buf;
-	struct ccs_policy_namespace *ns;
-	struct ccs_domain_info *domain = head->w.domain;
-	const bool is_delete = head->w.is_delete;
-	const bool is_select = !is_delete && ccs_str_starts(&data, "select ");
-	unsigned int profile;
-	if (*data == '<') {
-		domain = NULL;
-		if (is_delete)
-			ccs_delete_domain(data);
-		else if (is_select)
-			domain = ccs_find_domain(data);
+	if (cond >= CCS_PATH_ATTRIBUTE_START) {
+		const u8 pos = cond - CCS_PATH_ATTRIBUTE_START;
+		ccs_io_printf(head, "%s.%s%s", ccs_get_sarg(type, pos >= 32),
+			      pos % 32 >= 16 ? "parent." : "",
+			      ccs_path_attribute[pos % 16]);
+		return;
+	}
+	switch (cond) {
+	case CCS_SELF_UID:
+	case CCS_SELF_EUID:
+	case CCS_SELF_SUID:
+	case CCS_SELF_FSUID:
+	case CCS_SELF_GID:
+	case CCS_SELF_EGID:
+	case CCS_SELF_SGID:
+	case CCS_SELF_FSGID:
+	case CCS_SELF_PID:
+	case CCS_SELF_PPID:
+	case CCS_TASK_TYPE:
+	case CCS_SELF_DOMAIN:
+	case CCS_SELF_EXE:
+		ccs_set_string(head, "task.");
+		/* fall through */
+	default:
+		if (cond < CCS_MAX_CONDITION_KEYWORD)
+			ccs_set_string(head, ccs_condition_keyword[cond]);
 		else
-			domain = ccs_assign_domain(data, false);
-		head->w.domain = domain;
-		return 0;
+			ccs_io_printf(head, "unknown(%u)", cond);
 	}
-	if (!domain)
-		return -EINVAL;
-	ns = domain->ns;
-	if (sscanf(data, "use_profile %u\n", &profile) == 1
-	    && profile < CCS_MAX_PROFILES) {
-		if (!ccs_policy_loaded || ns->profile_ptr[(u8) profile])
-			if (!is_delete)
-				domain->profile = (u8) profile;
-		return 0;
-	}
-	if (ccs_str_starts(&data, "default_transition ")) {
-		static DEFINE_SPINLOCK(lock);
-		const struct ccs_path_info *new_transition = NULL;
-		const struct ccs_path_info *old_transition;
-		if (is_delete)
-			return 0;
-		if (ccs_correct_domain(data) || ccs_correct_path(data) ||
-		    !strcmp(data, "keep") || !strcmp(data, "child"))
-			new_transition = ccs_get_name(data);
-		if (!new_transition)
-			return -EINVAL;
-		spin_lock(&lock);
-		old_transition = domain->default_transition;
-		domain->default_transition = new_transition;
-		spin_unlock(&lock);
-		ccs_put_name(old_transition);
-		return 0;
-	}
-	if (!strncmp(data, CCS_QUOTA_EXCEEDED,
-		     sizeof(CCS_QUOTA_EXCEEDED) - 2)) {
-		domain->quota_exceeded = !is_delete;
-		return 0;
-	}
-	return ccs_write_acl(ns, &domain->acl_info_list, data, is_delete);
 }
 
-/**
- * ccs_print_name_union - Print a ccs_name_union.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- * @ptr:  Pointer to "struct ccs_name_union".
- *
- * Returns nothing.
- */
-static void ccs_print_name_union(struct ccs_io_buffer *head,
-				 const struct ccs_name_union *ptr)
+static void ccs_print_ipv4_address(struct ccs_io_buffer *head,
+				   const u32 *ip)
 {
-	ccs_set_space(head);
-	if (!ccs_print_group(head, ptr->is_not, ptr->group))
-		ccs_set_string(head, ptr->filename->name);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	ccs_io_printf(head, "%pI4", ip);
+#else
+	char addr[sizeof("255.255.255.255")];
+	ip4_string(addr, (const u8 *) ip);
+	ccs_io_printf(head, "%s", addr);
+#endif
 }
 
-/**
- * ccs_print_name_union_quoted - Print a ccs_name_union with a quote.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- * @ptr:  Pointer to "struct ccs_name_union".
- *
- * Returns nothing.
- */
-static void ccs_print_name_union_quoted(struct ccs_io_buffer *head,
-					const struct ccs_name_union *ptr)
+static void ccs_print_ipv6_address(struct ccs_io_buffer *head,
+				   const struct in6_addr *ip)
 {
-	if (!ccs_print_group(head, ptr->is_not, ptr->group)) {
-		ccs_set_string(head, "\"");
-		ccs_set_string(head, ptr->filename->name);
-		ccs_set_string(head, "\"");
-	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+	ccs_io_printf(head, "%pI6c", ip);
+#else
+	char addr[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:"
+			 "255.255.255.255")];
+	ip6_compressed_string(addr, (const u8 *) ip);
+	ccs_io_printf(head, "%s", addr);
+#endif
 }
 
 /**
- * ccs_print_number_union_nospace - Print a ccs_number_union without a space.
+ * ccs_print_condition_loop - Print condition part.
  *
  * @head: Pointer to "struct ccs_io_buffer".
- * @ptr:  Pointer to "struct ccs_number_union".
+ * @type: One of values in "enum ccs_mac_index".
+ * @cond: Pointer to "struct ccs_condition".
  *
- * Returns nothing.
+ * Returns true on success, false otherwise.
  */
-static void ccs_print_number_union_nospace(struct ccs_io_buffer *head,
-					   const struct ccs_number_union *ptr)
+static bool ccs_print_condition_loop(struct ccs_io_buffer *head,
+				     const struct ccs_condition *cond)
 {
-	if (!ccs_print_group(head, ptr->is_not, ptr->group)) {
-		int i;
-		unsigned long min = ptr->values[0];
-		const unsigned long max = ptr->values[1];
-		u8 min_type = ptr->value_type[0];
-		const u8 max_type = ptr->value_type[1];
-		char buffer[128];
-		buffer[0] = '\0';
-		for (i = 0; i < 2; i++) {
-			switch (min_type) {
-			case CCS_VALUE_TYPE_HEXADECIMAL:
-				ccs_addprintf(buffer, sizeof(buffer), "0x%lX",
-					      min);
+	const enum ccs_mac_index type = head->r.acl_index;
+	const union ccs_condition_element *condp = head->r.cond;
+	while ((void *) condp < (void *) ((u8 *) cond) + cond->size) {
+		const bool is_not = condp->is_not;
+		const enum ccs_conditions_index left = condp->left;
+		const enum ccs_conditions_index right = condp->right;
+		const u8 radix = condp->radix;
+		if (!ccs_flush(head)) {
+			head->r.cond = condp;
+			return false;
+		}
+		condp++;
+		ccs_set_space(head);
+		switch (left) {
+		case CCS_ARGV_ENTRY:
+			ccs_io_printf(head, "argv[%lu]", condp->value);
+			condp++;
+			break;
+		case CCS_ENVP_ENTRY:
+			ccs_set_string(head, "envp[\"");
+			ccs_set_string(head, condp->path->name);
+			condp++;
+			ccs_set_string(head, "\"]");
+			break;
+		case CCS_COND_SARG0:
+			ccs_set_string(head, ccs_get_sarg(type, 0));
+			break;
+		case CCS_COND_SARG1:
+			ccs_set_string(head, ccs_get_sarg(type, 1));
+			break;
+		case CCS_COND_SARG2:
+			ccs_set_string(head, ccs_get_sarg(type, 2));
+			break;
+		case CCS_COND_NARG0:
+			ccs_set_string(head, ccs_get_narg(type, 0));
+			break;
+		case CCS_COND_NARG1:
+			ccs_set_string(head, ccs_get_narg(type, 1));
+			break;
+		case CCS_COND_NARG2:
+			ccs_set_string(head, ccs_get_narg(type, 2));
+			break;
+		case CCS_COND_IPARG:
+			ccs_set_string(head, "ip");
+			break;
+		default:
+			ccs_print_misc_attribute(head, type, left);
+		}
+		ccs_set_string(head, is_not ? "!=" : "=");
+		switch (right) {
+		case CCS_IMM_GROUP:
+			ccs_set_string(head, "@");
+			ccs_set_string(head, condp->group->group_name->name);
+			condp++;
+			break;
+		case CCS_IMM_NAME_ENTRY:
+		case CCS_IMM_DOMAINNAME_ENTRY:
+			if (condp->path) {
+				ccs_set_string(head, "\"");
+				ccs_set_string(head, condp->path->name);
+				ccs_set_string(head, "\"");
+			} else {
+				ccs_set_string(head, "NULL");
+			}
+			condp++;
+			break;
+		case CCS_IMM_NUMBER_ENTRY1:
+		case CCS_IMM_NUMBER_ENTRY2:
+			ccs_print_number(head, radix & 3, condp->value);
+			condp++;
+			if (right == CCS_IMM_NUMBER_ENTRY1)
 				break;
-			case CCS_VALUE_TYPE_OCTAL:
-				ccs_addprintf(buffer, sizeof(buffer), "0%lo",
-					      min);
+			ccs_set_string(head, "-");
+			ccs_print_number(head, (radix >> 2) & 3, condp->value);
+			condp++;
+			break;
+		case CCS_IMM_IPV4ADDR_ENTRY1:
+		case CCS_IMM_IPV4ADDR_ENTRY2:
+			ccs_print_ipv4_address(head, &condp->ip);
+			condp++;
+			if (right == CCS_IMM_IPV4ADDR_ENTRY1)
 				break;
-			default:
-				ccs_addprintf(buffer, sizeof(buffer), "%lu",
-					      min);
+			ccs_set_string(head, "-");
+			ccs_print_ipv4_address(head, &condp->ip);
+			condp++;
+			break;
+		case CCS_IMM_IPV6ADDR_ENTRY1:
+		case CCS_IMM_IPV6ADDR_ENTRY2:
+			ccs_print_ipv6_address(head, (const struct in6_addr *)
+					       condp);
+			condp = (void *)
+				((u8 *) condp) + sizeof(struct in6_addr);
+			if (right == CCS_IMM_IPV6ADDR_ENTRY1)
 				break;
-			}
-			if (min == max && min_type == max_type)
-				break;
-			ccs_addprintf(buffer, sizeof(buffer), "-");
-			min_type = max_type;
-			min = max;
+			ccs_set_string(head, "-");
+			ccs_print_ipv6_address(head, (const struct in6_addr *)
+					       condp);
+			condp = (void *)
+				((u8 *) condp) + sizeof(struct in6_addr);
+			break;
+		default:
+			ccs_print_misc_attribute(head, type, right);
 		}
-		ccs_io_printf(head, "%s", buffer);
 	}
+	head->r.cond = NULL;
+	return true;
 }
 
 /**
- * ccs_print_number_union - Print a ccs_number_union.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- * @ptr:  Pointer to "struct ccs_number_union".
- *
- * Returns nothing.
- */
-static void ccs_print_number_union(struct ccs_io_buffer *head,
-				   const struct ccs_number_union *ptr)
-{
-	ccs_set_space(head);
-	ccs_print_number_union_nospace(head, ptr);
-}
-
-/**
  * ccs_print_condition - Print condition part.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -3731,467 +2915,64 @@
 {
 	switch (head->r.cond_step) {
 	case 0:
-		head->r.cond_index = 0;
+		//printk(KERN_INFO "Enter %s 0\n", __func__);
+		head->r.cond = (const union ccs_condition_element *)
+			(cond + 1);
 		head->r.cond_step++;
 		/* fall through */
 	case 1:
-		{
-			const u16 condc = cond->condc;
-			const struct ccs_condition_element *condp =
-				(typeof(condp)) (cond + 1);
-			const struct ccs_number_union *numbers_p =
-				(typeof(numbers_p)) (condp + condc);
-			const struct ccs_name_union *names_p =
-				(typeof(names_p))
-				(numbers_p + cond->numbers_count);
-			const struct ccs_argv *argv =
-				(typeof(argv)) (names_p + cond->names_count);
-			const struct ccs_envp *envp =
-				(typeof(envp)) (argv + cond->argc);
-			u16 skip;
-			for (skip = 0; skip < head->r.cond_index; skip++) {
-				const u8 left = condp->left;
-				const u8 right = condp->right;
-				condp++;
-				switch (left) {
-				case CCS_ARGV_ENTRY:
-					argv++;
-					continue;
-				case CCS_ENVP_ENTRY:
-					envp++;
-					continue;
-				case CCS_NUMBER_UNION:
-					numbers_p++;
-					break;
-				}
-				switch (right) {
-				case CCS_NAME_UNION:
-					names_p++;
-					break;
-				case CCS_NUMBER_UNION:
-					numbers_p++;
-					break;
-				}
-			}
-			while (head->r.cond_index < condc) {
-				const u8 match = condp->equals;
-				const u8 left = condp->left;
-				const u8 right = condp->right;
-				if (!ccs_flush(head))
-					return false;
-				condp++;
-				head->r.cond_index++;
-				ccs_set_space(head);
-				switch (left) {
-				case CCS_ARGV_ENTRY:
-					ccs_io_printf(head,
-						      "exec.argv[%lu]%s=\"",
-						      argv->index,
-						      argv->is_not ? "!" : "");
-					ccs_set_string(head,
-						       argv->value->name);
-					ccs_set_string(head, "\"");
-					argv++;
-					continue;
-				case CCS_ENVP_ENTRY:
-					ccs_set_string(head, "exec.envp[\"");
-					ccs_set_string(head, envp->name->name);
-					ccs_io_printf(head, "\"]%s=",
-						      envp->is_not ? "!" : "");
-					if (envp->value) {
-						ccs_set_string(head, "\"");
-						ccs_set_string(head, envp->
-							       value->name);
-						ccs_set_string(head, "\"");
-					} else {
-						ccs_set_string(head, "NULL");
-					}
-					envp++;
-					continue;
-				case CCS_NUMBER_UNION:
-					ccs_print_number_union_nospace
-						(head, numbers_p++);
-					break;
-				default:
-					ccs_set_string(head,
-					       ccs_condition_keyword[left]);
-					break;
-				}
-				ccs_set_string(head, match ? "=" : "!=");
-				switch (right) {
-				case CCS_NAME_UNION:
-					ccs_print_name_union_quoted
-						(head, names_p++);
-					break;
-				case CCS_NUMBER_UNION:
-					ccs_print_number_union_nospace
-						(head, numbers_p++);
-					break;
-				default:
-					ccs_set_string(head,
-					       ccs_condition_keyword[right]);
-					break;
-				}
-			}
-		}
+		//printk(KERN_INFO "Enter %s 1\n", __func__);
+		if (!ccs_print_condition_loop(head, cond))
+			return false;
 		head->r.cond_step++;
 		/* fall through */
 	case 2:
-		if (!ccs_flush(head))
-			break;
-		head->r.cond_step++;
-		/* fall through */
-	case 3:
-		if (cond->grant_log != CCS_GRANTLOG_AUTO)
-			ccs_io_printf(head, " grant_log=%s",
-				      ccs_yesno(cond->grant_log ==
-						CCS_GRANTLOG_YES));
-		ccs_set_lf(head);
+		//printk(KERN_INFO "Enter %s 2\n", __func__);
+		//if (!ccs_flush(head))
+		//break;
+		//ccs_set_lf(head);
+		head->r.cond = NULL;
 		return true;
 	}
 	return false;
 }
 
 /**
- * ccs_set_group - Print "acl_group " header keyword and category name.
+ * ccs_read_acl - Print an ACL entry.
  *
- * @head:     Pointer to "struct ccs_io_buffer".
- * @category: Category name.
- *
- * Returns nothing.
- */
-static void ccs_set_group(struct ccs_io_buffer *head, const char *category)
-{
-	if (head->type == CCS_EXCEPTION_POLICY) {
-		ccs_print_namespace(head);
-		ccs_set_string(head, "acl_group ");
-		ccs_set_string(head, head->r.acl_group_name->name);
-		ccs_set_space(head);
-	} else if (head->type == CCS_ACL_POLICY) {
-		ccs_set_string(head, "allow ");
-	}
-	ccs_set_string(head, category);
-}
-
-/**
- * ccs_print_entry - Print an ACL entry.
- *
  * @head: Pointer to "struct ccs_io_buffer".
  * @acl:  Pointer to an ACL entry.
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_print_entry(struct ccs_io_buffer *head,
-			    const struct ccs_acl_info *acl)
+static bool ccs_read_acl(struct ccs_io_buffer *head,
+			 const struct ccs_acl_info *acl)
 {
-	const u8 acl_type = acl->type;
-	bool first = true;
-	u8 bit;
-	if (head->r.print_cond_part)
+	const enum ccs_mac_index type = head->r.acl_index;
+	//printk(KERN_INFO "Enter %s 0\n", __func__);
+	if (head->r.cond)
 		goto print_cond_part;
 	if (acl->is_deleted)
 		return true;
 	if (!ccs_flush(head))
 		return false;
-	/*
-	if (head->type == CCS_EXCEPTION_POLICY && head->r.acl_group_name)
-		printk(KERN_INFO "%s ptr=%p\n", __func__, acl);
-	*/
-	else if (acl_type == CCS_TYPE_EXECUTE_ACL) {
-		struct ccs_execute_acl *ptr
-			= container_of(acl, typeof(*ptr), head);
-		if (head->r.print_default_transition) {
-			ccs_print_namespace(head);
-			ccs_set_string(head, "default_transition");
-		} else {
-			ccs_set_group(head, "file ");
-			ccs_set_string(head, "execute");
-		}
-		ccs_print_name_union(head, &ptr->program);
-		if (ptr->transit) {
-			ccs_set_space(head);
-			ccs_set_string(head, ptr->transit->name);
-		}
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-	} else if (acl_type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
-		   acl_type == CCS_TYPE_DENIED_EXECUTE_HANDLER) {
-		struct ccs_handler_acl *ptr
-			= container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head, "task ");
-		ccs_set_string(head, acl_type == CCS_TYPE_AUTO_EXECUTE_HANDLER
-			       ? "auto_execute_handler " :
-			       "denied_execute_handler ");
-		ccs_set_string(head, ptr->handler->name);
-		if (ptr->transit) {
-			ccs_set_space(head);
-			ccs_set_string(head, ptr->transit->name);
-		}
-#endif
-#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
-	} else if (acl_type == CCS_TYPE_AUTO_TASK_ACL ||
-		   acl_type == CCS_TYPE_MANUAL_TASK_ACL) {
-		struct ccs_task_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head, "task ");
-		ccs_set_string(head, acl_type == CCS_TYPE_AUTO_TASK_ACL ?
-			       "auto_domain_transition " :
-			       "manual_domain_transition ");
-		ccs_set_string(head, ptr->domainname->name);
-#endif
-	} else if (acl_type == CCS_TYPE_USE_GROUP_ACL) {
-		struct ccs_use_group_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head, "use_group ");
-		ccs_print_group(head, ptr->is_not, ptr->group);
-	} else if (head->r.print_transition_related_only) {
-		return true;
-	} else if (acl_type == CCS_TYPE_PATH_ACL) {
-		struct ccs_path_acl *ptr
-			= container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_PATH_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "file ");
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_mac_keywords[ccs_p2mac[bit]]);
-		}
-		if (first)
-			return true;
-		ccs_print_name_union(head, &ptr->name);
-	} else if (acl_type == CCS_TYPE_MKDEV_ACL) {
-		struct ccs_mkdev_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_MKDEV_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "file ");
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_mac_keywords
-				       [ccs_pnnn2mac[bit]]);
-		}
-		if (first)
-			return true;
-		ccs_print_name_union(head, &ptr->name);
-		ccs_print_number_union(head, &ptr->mode);
-		ccs_print_number_union(head, &ptr->major);
-		ccs_print_number_union(head, &ptr->minor);
-	} else if (acl_type == CCS_TYPE_PATH2_ACL) {
-		struct ccs_path2_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_PATH2_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "file ");
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_mac_keywords
-				       [ccs_pp2mac[bit]]);
-		}
-		if (first)
-			return true;
-		ccs_print_name_union(head, &ptr->name1);
-		ccs_print_name_union(head, &ptr->name2);
-	} else if (acl_type == CCS_TYPE_PATH_NUMBER_ACL) {
-		struct ccs_path_number_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_PATH_NUMBER_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "file ");
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_mac_keywords
-				       [ccs_pn2mac[bit]]);
-		}
-		if (first)
-			return true;
-		ccs_print_name_union(head, &ptr->name);
-		ccs_print_number_union(head, &ptr->number);
-#ifdef CONFIG_CCSECURITY_MISC
-	} else if (acl_type == CCS_TYPE_ENV_ACL) {
-		struct ccs_env_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head, "misc env");
-		ccs_print_name_union(head, &ptr->env);
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-	} else if (acl_type == CCS_TYPE_CAPABILITY_ACL) {
-		struct ccs_capability_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head, "capability ");
-		ccs_set_string(head, ccs_mac_keywords
-			       [ccs_c2mac[ptr->operation]]);
-#endif
-#ifdef CONFIG_CCSECURITY_NETWORK
-	} else if (acl_type == CCS_TYPE_INET_ACL) {
-		struct ccs_inet_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_NETWORK_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "network inet ");
-				ccs_set_string(head, ccs_proto_keyword
-					       [ptr->protocol]);
-				ccs_set_space(head);
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_socket_keyword[bit]);
-		}
-		if (first)
-			return true;
-		ccs_set_space(head);
-		if (!ccs_print_group(head, ptr->address.is_not,
-				     ptr->address.group)) {
-			char buf[128];
-			ccs_print_ip(buf, sizeof(buf), &ptr->address);
-			ccs_io_printf(head, "%s", buf);
-		}
-		ccs_print_number_union(head, &ptr->port);
-	} else if (acl_type == CCS_TYPE_UNIX_ACL) {
-		struct ccs_unix_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_NETWORK_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "network unix ");
-				ccs_set_string(head, ccs_proto_keyword
-					       [ptr->protocol]);
-				ccs_set_space(head);
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_socket_keyword[bit]);
-		}
-		if (first)
-			return true;
-		ccs_print_name_union(head, &ptr->name);
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-	} else if (acl_type == CCS_TYPE_PTRACE_ACL) {
-		struct ccs_ptrace_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head, "ipc ptrace ");
-		ccs_print_number_union_nospace(head, &ptr->request);
-		ccs_set_space(head);
-		ccs_set_string(head, ptr->domainname->name);
-#endif
-	} else if (acl_type == CCS_TYPE_MOUNT_ACL) {
-		struct ccs_mount_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head, "file mount");
-		ccs_print_name_union(head, &ptr->dev_name);
-		ccs_print_name_union(head, &ptr->dir_name);
-		ccs_print_name_union(head, &ptr->fs_type);
-		ccs_print_number_union(head, &ptr->flags);
-	}
+	BUG_ON(type >= CCS_MAX_MAC_INDEX);
+	ccs_io_printf(head, "%u ", acl->priority);
+	ccs_set_string(head, "acl ");
+	ccs_set_string(head, ccs_category_keywords[ccs_index2category[type]]);
+	ccs_set_space(head);
+	ccs_set_string(head, ccs_mac_keywords[type]);
 	if (acl->cond) {
-		head->r.print_cond_part = true;
 		head->r.cond_step = 0;
-		if (!ccs_flush(head))
-			return false;
 print_cond_part:
 		if (!ccs_print_condition(head, acl->cond))
 			return false;
-		head->r.print_cond_part = false;
-	} else {
-		ccs_set_lf(head);
 	}
+	ccs_set_lf(head);
 	return true;
 }
 
 /**
- * ccs_read_acl - Read "struct ccs_acl_info" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- * @list: Pointer to "struct list_head".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static bool ccs_read_acl(struct ccs_io_buffer *head, struct list_head *list)
-{
-	list_for_each_cookie(head->r.acl, list) {
-		struct ccs_acl_info *ptr =
-			list_entry(head->r.acl, typeof(*ptr), list);
-		if (!ccs_print_entry(head, ptr))
-			return false;
-	}
-	head->r.acl = NULL;
-	return true;
-}
-
-/**
- * ccs_read_domain - Read domain policy.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns nothing.
- *
- * Caller holds ccs_read_lock().
- */
-static void ccs_read_domain(struct ccs_io_buffer *head)
-{
-	if (head->r.eof)
-		return;
-	list_for_each_cookie(head->r.domain, &ccs_domain_list) {
-		struct ccs_domain_info *domain =
-			list_entry(head->r.domain, typeof(*domain), list);
-		switch (head->r.step) {
-		case 0:
-			if (domain->is_deleted &&
-			    !head->r.print_this_domain_only)
-				continue;
-			/* Print domainname and flags. */
-			ccs_set_string(head, domain->domainname->name);
-			ccs_set_lf(head);
-			ccs_io_printf(head, "use_profile %u\n",
-				      domain->profile);
-			ccs_set_string(head, "default_transition ");
-			ccs_set_string(head, domain->default_transition->name);
-			ccs_set_lf(head);
-			if (domain->quota_exceeded)
-				ccs_set_string(head, CCS_QUOTA_EXCEEDED);
-			ccs_set_lf(head);
-			head->r.step++;
-			/* fall through */
-		case 1:
-			if (!ccs_read_acl(head, &domain->acl_info_list))
-				return;
-			head->r.step++;
-			if (!ccs_set_lf(head))
-				return;
-			/* fall through */
-		case 2:
-			head->r.step = 0;
-			if (head->r.print_this_domain_only)
-				goto done;
-		}
-	}
-done:
-	head->r.eof = true;
-}
-
-/**
  * ccs_write_pid - Specify PID to obtain domainname.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -4254,7 +3035,7 @@
 	if (!domain)
 		return;
 	if (!task_info) {
-		ccs_io_printf(head, "%u %u ", pid, domain->profile);
+		ccs_io_printf(head, "%u ", pid);
 		ccs_set_string(head, domain->domainname->name);
 	} else {
 		ccs_io_printf(head, "%u manager=%s execute_handler=%s ", pid,
@@ -4266,204 +3047,150 @@
 }
 
 /**
- * ccs_write_group - Write "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group" list.
+ * ccs_update_group - Update "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group" list.
  *
- * @param: Pointer to "struct ccs_acl_param".
- * @type:  Type of this group.
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @type: Type of this group.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_write_group(struct ccs_acl_param *param, const u8 type)
+static int ccs_update_group(struct ccs_io_buffer *head,
+			    const enum ccs_group_id type)
 {
-	int error = -EINVAL;
-	struct ccs_group *group = ccs_get_group(param, type);
-	if (!group || group == &ccs_group_any)
+	u8 size;
+	const bool is_delete = head->w.is_delete;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct ccs_group *group = ccs_get_group(head, type);
+	char *word = ccs_read_token(head);
+	union {
+		struct ccs_acl_head head;
+		struct ccs_path_group path;
+		struct ccs_number_group number;
+		struct ccs_address_group address;
+	} e = { };
+	if (!group)
 		return -ENOMEM;
-	if (type != CCS_ACL_GROUP && ccs_group_type(&param->data))
+	if (*word == '@')
 		goto out;
-	param->list = &group->member_list;
 	if (type == CCS_PATH_GROUP) {
-		struct ccs_path_group *e = &param->e.path_group;
-		e->member_name = ccs_get_name(ccs_read_token(param));
-		if (!e->member_name) {
+		e.path.member_name = ccs_get_name(word);
+		if (!e.path.member_name) {
 			error = -ENOMEM;
 			goto out;
 		}
-		error = ccs_update_policy(sizeof(*e), param);
-		ccs_put_name(e->member_name);
+		size = sizeof(e.path);
 	} else if (type == CCS_NUMBER_GROUP) {
-		struct ccs_number_group *e = &param->e.number_group;
-		if (ccs_parse_number_union(param, &e->number))
-			error = ccs_update_policy(sizeof(*e), param);
-	} else if (type == CCS_ACL_GROUP) {
-		error = ccs_write_acl(param->ns, param->list, param->data,
-				      param->is_delete);
-		/*
-		printk(KERN_INFO "%s: ptr=%p ret=%d\n", __func__, group,
-		       error);
-		*/
+		e.number.radix = ccs_parse_values(word, e.number.value);
+		if (e.number.radix == CCS_VALUE_TYPE_INVALID)
+			goto out;
+		size = sizeof(e.number);
 #ifdef CONFIG_CCSECURITY_NETWORK
 	} else {
-		struct ccs_address_group *e = &param->e.address_group;
-		if (ccs_parse_ipaddr_union(param, &e->address))
-			error = ccs_update_policy(sizeof(*e), param);
+		switch (ccs_parse_ipaddr(word, e.address.ip)) {
+		case 1:
+		case 2:
+			e.address.is_ipv6 = false;
+			break;
+		case 3:
+		case 4:
+			e.address.is_ipv6 = true;
+			break;
+		default:
+			goto out;
+		}
+		size = sizeof(e.address);
 #endif
 	}
-out:
-	ccs_put_group(group);
-	return error;
-}
-
-/**
- * ccs_write_transition_control - Write default domain transition rules.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_write_transition_control(struct ccs_acl_param *param)
-{
-	param->list = &param->ns->default_transition_list;
-	return ccs_update_execute_acl(param);
-}
-
-/**
- * ccs_update_domain_in_acl - Update "struct ccs_domain_info" in "struct ccs_acl_info".
- *
- * @acl:   Pointer to "struct ccs_acl_info".
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_domain_in_acl(struct ccs_acl_info *acl,
-				    struct ccs_acl_param *param)
-{
-	struct ccs_domain_info *ptr;
-	struct ccs_domain_info domain = { };
-	int error = param->is_delete ? -ENOENT : -ENOMEM;
-	domain.domainname = ccs_get_domainname(param);
-	if (!domain.domainname)
-		return error;
-	if (param->data[0]) {
-		domain.cond = ccs_get_condition(param);
-		if (!domain.cond)
-			goto out;
-	}
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_srcu(ptr, &acl->domain_list, list, &ccs_ss) {
-		if (ptr->cond != domain.cond ||
-		    ptr->domainname != domain.domainname)
-			continue;
-		ptr->is_deleted = param->is_delete;
-		error = 0;
-		break;
-	}
-	if (!param->is_delete && error) {
-		struct ccs_domain_info *entry =
-			ccs_commit_ok(&domain, sizeof(domain));
-		if (entry) {
-			INIT_LIST_HEAD(&entry->acl_info_list);
-			list_add_tail_rcu(&entry->list, &acl->domain_list);
+	if (mutex_lock_interruptible(&ccs_policy_lock) == 0) {
+		struct ccs_acl_head *entry;
+		list_for_each_entry_srcu(entry, &group->member_list,
+					 list, &ccs_ss) {
+			if (entry->is_deleted == CCS_GC_IN_PROGRESS ||
+			    memcmp(entry + 1, &e.head + 1,
+				   size - sizeof(*entry)))
+				continue;
+			entry->is_deleted = is_delete;
 			error = 0;
+			break;
 		}
+		if (error && !is_delete) {
+			entry = ccs_commit_ok(&e, size);
+			if (entry) {
+				list_add_tail_rcu(&entry->list,
+						  &group->member_list);
+				error = 0;
+			}
+		}
+		mutex_unlock(&ccs_policy_lock);
 	}
-	mutex_unlock(&ccs_policy_lock);
+	if (type == CCS_PATH_GROUP)
+		ccs_put_name(e.path.member_name);
 out:
-	ccs_put_name(domain.domainname);
-	ccs_put_condition(domain.cond);
+	ccs_put_group(group);
 	return error;
 }
 
 /**
- * ccs_write_acl_policy - Write inverse mode policy.
+ * ccs_write_policy - Write policy.
  *
  * @head: Pointer to "struct ccs_io_buffer".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_write_acl_policy(struct ccs_io_buffer *head)
+static int ccs_write_policy(struct ccs_io_buffer *head)
 {
-	static const struct {
-		const char *keyword;
-		int (*write) (struct ccs_acl_param *);
-	} ccs_callback[] = {
-		{ "file ", ccs_write_file },
-#ifdef CONFIG_CCSECURITY_NETWORK
-		{ "network inet ", ccs_write_inet_network },
-		{ "network unix ", ccs_write_unix_network },
-#endif
-#ifdef CONFIG_CCSECURITY_MISC
-		{ "misc ", ccs_write_misc },
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-		{ "capability ", ccs_write_capability },
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-		{ "ipc ptrace ", ccs_write_ipc },
-#endif
-	};
-	struct ccs_acl_param param = {
-		.data = head->write_buf,
-		.is_delete = head->w.is_delete,
-		.e.acl_info.perm = 1,
-	};
-	u8 i;
-	if (ccs_str_starts(&param.data, "by ")) {
-		if (!head->w.acl)
-			return -EINVAL;
-		return ccs_update_domain_in_acl(head->w.acl, &param);
-	}
-	if (ccs_str_starts(&param.data, "mode ")) {
-		u8 mode;
-		if (!head->w.acl)
-			return -EINVAL;
-		for (mode = 0; mode < CCS_CONFIG_MAX_MODE; mode++)
-			if (!strcmp(param.data, ccs_mode[mode])) {
-				head->w.acl->mode = mode;
-				return 0;
-			}
+	enum ccs_group_id i;
+	unsigned int priority;
+	char *word = ccs_read_token(head);
+	if (sscanf(word, "%u", &priority) == 1)
+		word = ccs_read_token(head);
+	else
+		priority = 1000;
+	if (priority >= 65536 || !*word)
 		return -EINVAL;
+	head->w.priority = priority;
+	if (!head->w.acl)
+		goto no_acl_selected;
+	head->w.is_deny = !strcmp(word, "deny");
+	if (head->w.is_deny || !strcmp(word, "allow"))
+		return ccs_update_acl(&head->w.acl->acl_info_list, head,
+				      false);
+	if (!strcmp(word, "config")) {
+		char *cp = head->w.data;
+		while (1) {
+			unsigned short int logs;
+			char *cp2 = strchr(cp, ' ');
+			if (cp2)
+				*cp2++ = '\0';
+			if (!strcmp(cp, "mode=disabled"))
+				head->w.acl->mode = CCS_CONFIG_DISABLED;
+			else if (!strcmp(cp, "mode=permissive"))
+				head->w.acl->mode = CCS_CONFIG_PERMISSIVE;
+			else if (!strcmp(cp, "mode=enforcing"))
+				head->w.acl->mode = CCS_CONFIG_ENFORCING;
+			else if (sscanf(cp, "grant_log=%hu", &logs) == 1)
+				head->w.acl->max_grant_log = logs;
+			else if (sscanf(cp, "reject_log=%hu", &logs) == 1)
+				head->w.acl->max_reject_log = logs;
+			if (!cp2)
+				break;
+			cp = cp2;
+		}
+		return 0;
 	}
 	head->w.acl = NULL;
-	if (!ccs_str_starts(&param.data, "allow "))
-		return -EINVAL;
-	for (i = 0; i < ARRAY_SIZE(ccs_callback); i++) {
-		int error;
-		if (!ccs_str_starts(&param.data, ccs_callback[i].keyword))
-			continue;
-		error = ccs_callback[i].write(&param);
-		if (!error && !head->w.is_delete)
-			head->w.acl = param.matched_entry;
-		ccs_del_acl(&param.e.acl_info.list);
-		return error;
-	}
-	return -EINVAL;
-}
-
-/**
- * ccs_write_exception - Write exception policy.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_write_exception(struct ccs_io_buffer *head)
-{
-	const bool is_delete = head->w.is_delete;
-	struct ccs_acl_param param = {
-		.ns = head->w.ns,
-		.is_delete = is_delete,
-		.data = head->write_buf,
-	};
-	u8 i;
-	/* Forced zero clear for using memcmp() at ccs_update_policy(). */
-	memset(&param.e, 0, sizeof(param.e));
-	param.e.acl_info.perm = 1;
-	if (ccs_str_starts(&param.data, "default_transition "))
-		return ccs_write_transition_control(&param);
+no_acl_selected:
+	if (ccs_select_acl(head, word))
+		return 0;
+	if (!strcmp(word, "acl"))
+		return ccs_parse_entry(head);
 	for (i = 0; i < CCS_MAX_GROUP; i++)
-		if (ccs_str_starts(&param.data, ccs_group_name[i]))
-			return ccs_write_group(&param, i);
+		if (!strcmp(word, ccs_group_name[i]))
+			return ccs_update_group(head, i);
+	if (!strcmp(word, "memory") && ccs_str_starts(&head->w.data, "quota "))
+		return ccs_write_quota(head->w.data);
+	if (sscanf(word, "POLICY_VERSION=%u", &ccs_policy_version) == 1)
+		return 0;
 	return -EINVAL;
 }
 
@@ -4479,27 +3206,7 @@
  */
 static bool ccs_read_group(struct ccs_io_buffer *head, const int idx)
 {
-	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
-						       namespace_list);
-	struct list_head *list = &ns->group_list[idx];
-	if (idx == CCS_ACL_GROUP) {
-		list_for_each_cookie(head->r.group, list) {
-			struct ccs_group *group =
-				list_entry(head->r.group, typeof(*group),
-					   head.list);
-			/*
-			printk(KERN_INFO "%s ptr=%p\n", __func__, group);
-			*/
-			head->r.acl_group_name = group->group_name;
-			head->r.domain = &group->member_list;
-			if (!ccs_read_acl(head, head->r.domain))
-				return false;
-			head->r.acl_group_name = NULL;
-			head->r.domain = NULL;
-		}
-		head->r.group = NULL;
-		return true;
-	}
+	struct list_head *list = &ccs_group_list[idx];
 	list_for_each_cookie(head->r.group, list) {
 		struct ccs_group *group =
 			list_entry(head->r.group, typeof(*group), head.list);
@@ -4510,27 +3217,30 @@
 				continue;
 			if (!ccs_flush(head))
 				return false;
-			ccs_print_namespace(head);
 			ccs_set_string(head, ccs_group_name[idx]);
+			ccs_set_space(head);
 			ccs_set_string(head, group->group_name->name);
+			ccs_set_space(head);
 			if (idx == CCS_PATH_GROUP) {
-				ccs_set_space(head);
 				ccs_set_string(head, container_of
 					       (ptr, struct ccs_path_group,
 						head)->member_name->name);
 			} else if (idx == CCS_NUMBER_GROUP) {
-				ccs_print_number_union(head, &container_of
-					       (ptr, struct ccs_number_group,
-						head)->number);
+				struct ccs_number_group *e =
+					container_of(ptr, typeof(*e), head);
+				ccs_print_number(head, e->radix & 3,
+						 e->value[0]);
+				if (e->radix >> 2) {
+					ccs_set_string(head, "-");
+					ccs_print_number(head,
+							 (e->radix >> 2) & 3,
+							 e->value[1]);
+				}
 #ifdef CONFIG_CCSECURITY_NETWORK
 			} else if (idx == CCS_ADDRESS_GROUP) {
-				char buffer[128];
-				struct ccs_address_group *member =
-					container_of(ptr, typeof(*member),
-						     head);
-				ccs_print_ip(buffer, sizeof(buffer),
-					     &member->address);
-				ccs_io_printf(head, " %s", buffer);
+				ccs_print_ip(head, container_of
+					     (ptr, struct ccs_address_group,
+					      head));
 #endif
 			}
 			ccs_set_lf(head);
@@ -4538,179 +3248,11 @@
 		head->r.acl = NULL;
 	}
 	head->r.group = NULL;
+	ccs_set_lf(head);
 	return true;
 }
 
 /**
- * ccs_read_exception - Read exception policy.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns nothing.
- *
- * Caller holds ccs_read_lock().
- */
-static void ccs_read_exception(struct ccs_io_buffer *head)
-{
-	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
-						       namespace_list);
-	if (head->r.eof)
-		return;
-	while (head->r.step < CCS_MAX_GROUP)
-		if (!ccs_read_group(head, head->r.step))
-			return;
-		else
-			head->r.step++;
-	head->r.print_default_transition = true;
-	head->r.eof = ccs_read_acl(head, &ns->default_transition_list);
-	head->r.print_default_transition = false;
-}
-
-/**
- * ccs_truncate - Truncate a line.
- *
- * @str: String to truncate.
- *
- * Returns length of truncated @str.
- */
-static int ccs_truncate(char *str)
-{
-	char *start = str;
-	while (*(unsigned char *) str > (unsigned char) ' ')
-		str++;
-	*str = '\0';
-	return strlen(start) + 1;
-}
-
-/**
- * ccs_add_entry - Add an ACL to current thread's domain. Used by learning mode.
- *
- * @header: Lines containing ACL.
- *
- * Returns nothing.
- */
-static void ccs_add_entry(char *header)
-{
-	char *buffer;
-	char *realpath = NULL;
-	char *argv0 = NULL;
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-	char *handler;
-#endif
-	char *cp = strchr(header, '\n');
-	int len;
-	if (!cp)
-		return;
-	cp = strchr(cp + 1, '\n');
-	if (!cp)
-		return;
-	*cp++ = '\0';
-	len = strlen(cp) + 1;
-	/* strstr() will return NULL if ordering is wrong. */
-	if (*cp == 'f') {
-		argv0 = strstr(header, " argv[]={ \"");
-		if (argv0) {
-			argv0 += 10;
-			len += ccs_truncate(argv0) + 14;
-		}
-		realpath = strstr(header, " exec={ realpath=\"");
-		if (realpath) {
-			realpath += 8;
-			len += ccs_truncate(realpath) + 6;
-		}
-	}
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-	handler = strstr(header, "type=execute_handler");
-	if (handler)
-		len += ccs_truncate(handler) + 6;
-#endif
-	buffer = kmalloc(len, CCS_GFP_FLAGS);
-	if (!buffer)
-		return;
-	snprintf(buffer, len - 1, "%s", cp);
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-	if (handler)
-		ccs_addprintf(buffer, len, " task.%s", handler);
-#endif
-	if (realpath)
-		ccs_addprintf(buffer, len, " exec.%s", realpath);
-	if (argv0)
-		ccs_addprintf(buffer, len, " exec.argv[0]=%s", argv0);
-	ccs_normalize_line(buffer);
-	{
-		struct ccs_domain_info *domain = ccs_current_domain();
-		if (!ccs_write_acl(domain->ns, &domain->acl_info_list,
-				   buffer, false))
-			ccs_update_stat(CCS_STAT_POLICY_UPDATES);
-	}
-	kfree(buffer);
-}
-
-/**
- * ccs_domain_quota_ok - Check for domain's quota.
- *
- * @r: Pointer to "struct ccs_request_info".
- *
- * Returns true if the domain is not exceeded quota, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static bool ccs_domain_quota_ok(struct ccs_request_info *r)
-{
-	unsigned int count = 0;
-	struct ccs_domain_info * const domain = ccs_current_domain();
-	struct ccs_acl_info *ptr;
-	if (r->mode != CCS_CONFIG_LEARNING)
-		return false;
-	if (!domain)
-		return true;
-	list_for_each_entry_srcu(ptr, &domain->acl_info_list, list, &ccs_ss) {
-		u16 perm;
-		u8 i;
-		if (ptr->is_deleted)
-			continue;
-		switch (ptr->type) {
-		case CCS_TYPE_PATH_ACL:
-		case CCS_TYPE_PATH2_ACL:
-		case CCS_TYPE_PATH_NUMBER_ACL:
-		case CCS_TYPE_MKDEV_ACL:
-#ifdef CONFIG_CCSECURITY_NETWORK
-		case CCS_TYPE_INET_ACL:
-		case CCS_TYPE_UNIX_ACL:
-#endif
-			perm = ptr->perm;
-			break;
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-		case CCS_TYPE_AUTO_EXECUTE_HANDLER:
-		case CCS_TYPE_DENIED_EXECUTE_HANDLER:
-#endif
-#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
-		case CCS_TYPE_AUTO_TASK_ACL:
-		case CCS_TYPE_MANUAL_TASK_ACL:
-#endif
-			perm = 0;
-			break;
-		default:
-			perm = 1;
-		}
-		for (i = 0; i < 16; i++)
-			if (perm & (1 << i))
-				count++;
-	}
-	if (count < ccs_profile(r->profile)->pref[CCS_PREF_MAX_LEARNING_ENTRY])
-		return true;
-	if (!domain->quota_exceeded) {
-		domain->quota_exceeded = true;
-		/* r->granted = false; */
-		ccs_write_log(r, "%s", CCS_QUOTA_EXCEEDED);
-		printk(KERN_WARNING "WARNING: "
-		       "Domain '%s' has too many ACLs to hold. "
-		       "Stopped learning mode.\n", domain->domainname->name);
-	}
-	return false;
-}
-
-/**
  * ccs_supervisor - Ask for the supervisor's decision.
  *
  * @r:   Pointer to "struct ccs_request_info".
@@ -4729,48 +3271,26 @@
 	static unsigned int ccs_serial;
 	struct ccs_query entry = { };
 	bool quota_exceeded = false;
-	if (!r->inversed) {
-		r->profile = ccs_current_domain()->profile;
-		r->mode = ccs_get_config(r->profile, r->type) &
-			(CCS_CONFIG_MAX_MODE - 1);
-	}
+	if (WARN_ON(!r->matched_acl))
+		return 0;
 	va_start(args, fmt);
 	len = vsnprintf((char *) &len, 1, fmt, args) + 1;
 	va_end(args);
 	/* Write /proc/ccs/audit. */
-	va_start(args, fmt);
-	ccs_write_log2(r, len, fmt, args);
-	va_end(args);
+	if (ccs_get_audit(r)) {
+		va_start(args, fmt);
+		ccs_write_log(r, len, fmt, args);
+		va_end(args);
+	}
 	/* Nothing more to do if granted. */
 	if (r->granted)
 		return 0;
-	if (r->mode)
-		ccs_update_stat(r->mode);
-	switch (r->mode) {
-		int i;
-		struct ccs_profile *p;
-	case CCS_CONFIG_ENFORCING:
-		error = -EPERM;
-		if (atomic_read(&ccs_query_observers))
-			break;
-		if (r->dont_sleep_on_enforce_error)
-			goto out;
-		p = ccs_profile(r->profile);
-		/* Check enforcing_penalty parameter. */
-		for (i = 0; i < p->pref[CCS_PREF_ENFORCING_PENALTY]; i++) {
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(HZ / 10);
-		}
-		goto out;
-	case CCS_CONFIG_LEARNING:
-		error = 0;
-		/* Check max_learning_entry parameter. */
-		if (ccs_domain_quota_ok(r))
-			break;
-		/* fall through */
-	default:
+	/* Nothing more to do if not enforcing mode. */
+	if (r->mode != CCS_CONFIG_ENFORCING)
 		return 0;
-	}
+	error = -EPERM;
+	if (!atomic_read(&ccs_query_observers))
+		return error;
 	/* Get message. */
 	va_start(args, fmt);
 	entry.query = ccs_init_log(r, len, fmt, args);
@@ -4778,12 +3298,8 @@
 	if (!entry.query)
 		goto out;
 	entry.query_len = strlen(entry.query) + 1;
-	if (!error) {
-		ccs_add_entry(entry.query);
-		goto out;
-	}
 	len = ccs_round2(entry.query_len);
-	entry.domain = ccs_current_domain();
+	entry.acl = r->matched_acl;
 	spin_lock(&ccs_query_list_lock);
 	if (ccs_memory_quota[CCS_MEMORY_QUERY] &&
 	    ccs_memory_used[CCS_MEMORY_QUERY] + len
@@ -4839,125 +3355,296 @@
  */
 int ccs_audit_log(struct ccs_request_info *r)
 {
-	switch (r->param_type) {
-		u8 type;
-		char buf[48];
+	const char *keyword = ccs_mac_keywords[r->type];
+	if (WARN_ON(!keyword))
+		return 0;
+	if (!ccs_policy_loaded)
+		return 0;
+	/* Do not audit "task auto_domain_transition". */
+	if (WARN_ON(r->type == CCS_MAC_AUTO_TASK_TRANSITION))
+		return 0;
+	if (r->granted) {
+		/* Nothing to do if granted and no audit mode. */
+		if (r->matched_acl &&
+		    ccs_grant_log_count >= r->matched_acl->max_grant_log)
+			return 0;
+	} else {
+		/* Update policy violation counter. */
+		if (r->mode)
+			ccs_update_stat(r->mode);
+		/*
+		 * Nothing to do if no audit mode and rejected in non enforcing
+		 * mode.
+		 */
+		if (r->mode != CCS_CONFIG_ENFORCING && r->matched_acl &&
+		    ccs_reject_log_count >= r->matched_acl->max_reject_log)
+			return 0;
+		/*
+		 * Nothing to do if no audit mode and rejected in enforcing
+		 * mode and ccs-queryd is not running.
+		 */
+		if (r->mode == CCS_CONFIG_ENFORCING && r->matched_acl &&
+		    ccs_reject_log_count >= r->matched_acl->max_reject_log &&
+		    !atomic_read(&ccs_query_observers))
+			return -EPERM;
+	}
+	/* We want audit logs. Make sure that string arguments are ready. */
+	if (!r->param.s[0])
+		ccs_populate_patharg(r, true);
+	if (!r->param.s[1])
+		ccs_populate_patharg(r, false);
+	switch (r->type) {
 #ifdef CONFIG_CCSECURITY_NETWORK
-		const u32 *address;
+		char buf[48];
 #endif
-	case CCS_TYPE_EXECUTE_ACL:
-		return ccs_supervisor(r, "file execute %s\n",
-				      r->param.path.filename->name);
-	case CCS_TYPE_PATH_ACL:
-		return ccs_supervisor(r, "file %s %s\n", ccs_mac_keywords
-				      [ccs_p2mac[r->param.path.operation]],
-				      r->param.path.filename->name);
-	case CCS_TYPE_PATH2_ACL:
-		return ccs_supervisor(r, "file %s %s %s\n", ccs_mac_keywords
-				      [ccs_pp2mac[r->param.path2.operation]],
-				      r->param.path2.filename1->name,
-				      r->param.path2.filename2->name);
-	case CCS_TYPE_PATH_NUMBER_ACL:
-		type = r->param.path_number.operation;
-		switch (type) {
-		case CCS_TYPE_CREATE:
-		case CCS_TYPE_MKDIR:
-		case CCS_TYPE_MKFIFO:
-		case CCS_TYPE_MKSOCK:
-		case CCS_TYPE_CHMOD:
-			snprintf(buf, sizeof(buf), "0%lo",
-				 r->param.path_number.number);
-			break;
-		case CCS_TYPE_IOCTL:
-			snprintf(buf, sizeof(buf), "0x%lX",
-				 r->param.path_number.number);
-			break;
-		default:
-			snprintf(buf, sizeof(buf), "%lu",
-				 r->param.path_number.number);
-			break;
-		}
-		return ccs_supervisor(r, "file %s %s %s\n", ccs_mac_keywords
-				      [ccs_pn2mac[type]],
-				      r->param.path_number.filename->name,
-				      buf);
-	case CCS_TYPE_MKDEV_ACL:
-		return ccs_supervisor(r, "file %s %s 0%o %u %u\n",
-				      ccs_mac_keywords
-				      [ccs_pnnn2mac[r->param.mkdev.operation]],
-				      r->param.mkdev.filename->name,
-				      r->param.mkdev.mode,
-				      r->param.mkdev.major,
-				      r->param.mkdev.minor);
-	case CCS_TYPE_MOUNT_ACL:
-		return ccs_supervisor(r, "file mount %s %s %s 0x%lX\n",
-				      r->param.mount.dev->name,
-				      r->param.mount.dir->name,
-				      r->param.mount.type->name,
-				      r->param.mount.flags);
+	case CCS_MAC_FILE_EXECUTE:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		if (WARN_ON(!r->param.s[1]))
+			return 0;
+		if (WARN_ON(!r->param.s[1]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s exec=\"%s\" path=\"%s\"\n",
+				      keyword, r->param.s[1]->name,
+				      r->param.s[0]->name);
+	case CCS_MAC_FILE_READ:
+	case CCS_MAC_FILE_WRITE:
+	case CCS_MAC_FILE_APPEND:
+	case CCS_MAC_FILE_UNLINK:
+#ifdef CONFIG_CCSECURITY_FILE_GETATTR
+	case CCS_MAC_FILE_GETATTR:
+#endif
+	case CCS_MAC_FILE_RMDIR:
+	case CCS_MAC_FILE_TRUNCATE:
+	case CCS_MAC_FILE_CHROOT:
+	case CCS_MAC_FILE_UMOUNT:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s path=\"%s\"\n", keyword,
+				      r->param.s[0]->name);
+	case CCS_MAC_FILE_CREATE:
+	case CCS_MAC_FILE_MKDIR:
+	case CCS_MAC_FILE_MKFIFO:
+	case CCS_MAC_FILE_MKSOCK:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s path=\"%s\" perm=0%lo\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0]);
+	case CCS_MAC_FILE_SYMLINK:
+		return ccs_supervisor(r, "file %s path=\"%s\" target=\"%s\""
+				      "\n", keyword, r->param.s[0]->name,
+				      r->param.s[1]->name);
+	case CCS_MAC_FILE_MKBLOCK:
+	case CCS_MAC_FILE_MKCHAR:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s path=\"%s\" perm=0%lo "
+				      "dev_major=%lu dev_minor=%lu\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0], r->param.i[1],
+				      r->param.i[2]);
+	case CCS_MAC_FILE_LINK:
+	case CCS_MAC_FILE_RENAME:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		if (WARN_ON(!r->param.s[1]))
+			return 0;
+		if (WARN_ON(!r->param.s[1]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s old_path=\"%s\" "
+				      "new_path=\"%s\"\n", keyword,
+				      r->param.s[0]->name,
+				      r->param.s[1]->name);
+	case CCS_MAC_FILE_CHMOD:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s path=\"%s\" perm=0%lo\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0]);
+	case CCS_MAC_FILE_CHOWN:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s path=\"%s\" uid=%lu\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0]);
+	case CCS_MAC_FILE_CHGRP:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s path=\"%s\" gid=%lu\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0]);
+	case CCS_MAC_FILE_IOCTL:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s path=\"%s\" cmd=0x%lX\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0]);
+	case CCS_MAC_FILE_MOUNT:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		if (WARN_ON(!r->param.s[1]))
+			return 0;
+		if (WARN_ON(!r->param.s[1]->name))
+			return 0;
+		if (WARN_ON(!r->param.s[2]))
+			return 0;
+		if (WARN_ON(!r->param.s[2]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s source=\"%s\" target=\"%s\" "
+				      "fstype=\"%s\" flags=0x%lX\n", keyword,
+				      r->param.s[0]->name, r->param.s[1]->name,
+				      r->param.s[2]->name, r->param.i[0]);
+	case CCS_MAC_FILE_PIVOT_ROOT:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		if (WARN_ON(!r->param.s[1]))
+			return 0;
+		if (WARN_ON(!r->param.s[1]->name))
+			return 0;
+		return ccs_supervisor(r, "file %s new_root=\"%s\" "
+				      "put_old=\"%s\"\n", keyword,
+				      r->param.s[0]->name,
+				      r->param.s[1]->name);
 #ifdef CONFIG_CCSECURITY_MISC
-	case CCS_TYPE_ENV_ACL:
-		return ccs_supervisor(r, "misc env %s\n",
-				      r->param.environ.name->name);
+	case CCS_MAC_ENVIRON:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		return ccs_supervisor(r, "misc %s name=\"%s\"\n", keyword,
+				      r->param.s[0]->name);
 #endif
+	case CCS_MAC_CAPABILITY_MODIFY_POLICY:
 #ifdef CONFIG_CCSECURITY_CAPABILITY
-	case CCS_TYPE_CAPABILITY_ACL:
-		return ccs_supervisor(r, "capability %s\n", ccs_mac_keywords
-				      [ccs_c2mac[r->param.capability.
-						 operation]]);
+	case CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET:
+	case CCS_MAC_CAPABILITY_USE_PACKET_SOCKET:
+	case CCS_MAC_CAPABILITY_SYS_REBOOT:
+	case CCS_MAC_CAPABILITY_SYS_VHANGUP:
+	case CCS_MAC_CAPABILITY_SYS_SETTIME:
+	case CCS_MAC_CAPABILITY_SYS_NICE:
+	case CCS_MAC_CAPABILITY_SYS_SETHOSTNAME:
+	case CCS_MAC_CAPABILITY_USE_KERNEL_MODULE:
+	case CCS_MAC_CAPABILITY_SYS_KEXEC_LOAD:
 #endif
+		return ccs_supervisor(r, "capability %s\n", keyword);
 #ifdef CONFIG_CCSECURITY_NETWORK
-	case CCS_TYPE_INET_ACL:
-		address = r->param.inet_network.address;
-		if (r->param.inet_network.is_ipv6)
+	case CCS_MAC_NETWORK_INET_STREAM_BIND:
+	case CCS_MAC_NETWORK_INET_STREAM_LISTEN:
+	case CCS_MAC_NETWORK_INET_STREAM_CONNECT:
+	case CCS_MAC_NETWORK_INET_STREAM_ACCEPT:
+	case CCS_MAC_NETWORK_INET_DGRAM_BIND:
+	case CCS_MAC_NETWORK_INET_DGRAM_SEND:
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+	case CCS_MAC_NETWORK_INET_DGRAM_RECV:
+#endif
+		if (WARN_ON(!r->param.ip))
+			return 0;
+		if (r->param.is_ipv6)
 			ccs_print_ipv6(buf, sizeof(buf),
-				       (const struct in6_addr *) address);
+				       (const struct in6_addr *) r->param.ip);
 		else
-			ccs_print_ipv4(buf, sizeof(buf), address);
-		return ccs_supervisor(r, "network inet %s %s %s %u\n",
-				      ccs_proto_keyword[r->param.inet_network.
-							protocol],
-				      ccs_socket_keyword[r->param.inet_network.
-							 operation],
-				      buf, r->param.inet_network.port);
-	case CCS_TYPE_UNIX_ACL:
-		return ccs_supervisor(r, "network unix %s %s %s\n",
-				      ccs_proto_keyword[r->param.
-							unix_network.protocol],
-				      ccs_socket_keyword[r->param.unix_network.
-							 operation],
-				      r->param.unix_network.address->name);
+			ccs_print_ipv4(buf, sizeof(buf), r->param.ip);
+		return ccs_supervisor(r, "network %s ip=%s port=%lu\n",
+				      keyword, buf, r->param.i[0]);
+	case CCS_MAC_NETWORK_INET_RAW_BIND:
+	case CCS_MAC_NETWORK_INET_RAW_SEND:
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+	case CCS_MAC_NETWORK_INET_RAW_RECV:
 #endif
+		if (WARN_ON(!r->param.ip))
+			return 0;
+		if (r->param.is_ipv6)
+			ccs_print_ipv6(buf, sizeof(buf),
+				       (const struct in6_addr *) r->param.ip);
+		else
+			ccs_print_ipv4(buf, sizeof(buf), r->param.ip);
+		return ccs_supervisor(r, "network %s ip=%s proto=%lu\n",
+				      keyword, buf, r->param.i[0]);
+	case CCS_MAC_NETWORK_UNIX_STREAM_BIND:
+	case CCS_MAC_NETWORK_UNIX_STREAM_LISTEN:
+	case CCS_MAC_NETWORK_UNIX_STREAM_CONNECT:
+	case CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT:
+	case CCS_MAC_NETWORK_UNIX_DGRAM_BIND:
+	case CCS_MAC_NETWORK_UNIX_DGRAM_SEND:
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+	case CCS_MAC_NETWORK_UNIX_DGRAM_RECV:
+#endif
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_BIND:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_LISTEN:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		return ccs_supervisor(r, "network %s addr=\"%s\"\n", keyword,
+				      r->param.s[0]->name);
+#endif
 #ifdef CONFIG_CCSECURITY_IPC
-	case CCS_TYPE_PTRACE_ACL:
-		return ccs_supervisor(r, "ipc ptrace %lu %s\n",
-				      r->param.ptrace.request,
-				      r->param.ptrace.domainname);
+	case CCS_MAC_PTRACE:
+		if (WARN_ON(!r->param.s[0]))
+			return 0;
+		if (WARN_ON(!r->param.s[0]->name))
+			return 0;
+		return ccs_supervisor(r, "ipc %s cmd=%lu domain=\"%s\"\n",
+				      keyword, r->param.i[0],
+				      r->param.s[0]->name);
 #endif
+	case CCS_MAX_MAC_INDEX:
+#if defined(CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER) || defined(CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION)
+	case CCS_MAC_AUTO_EXECUTE_HANDLER:
+	case CCS_MAC_DENIED_EXECUTE_HANDLER:
+	case CCS_MAC_AUTO_TASK_TRANSITION:
+	case CCS_MAC_MANUAL_TASK_TRANSITION:
+#endif
+		break;
 	}
 	return 0;
 }
 
 /**
- * ccs_find_domain_by_qid - Get domain by query id.
+ * ccs_find_acl_by_qid - Get ACL by query id.
  *
  * @serial: Query ID assigned by ccs_supervisor().
  *
- * Returns pointer to "struct ccs_domain_info" if found, NULL otherwise.
+ * Returns pointer to "struct ccs_ack_info" if found, NULL otherwise.
  */
-static struct ccs_domain_info *ccs_find_domain_by_qid(unsigned int serial)
+static struct ccs_acl_info *ccs_find_acl_by_qid(unsigned int serial)
 {
 	struct ccs_query *ptr;
-	struct ccs_domain_info *domain = NULL;
+	struct ccs_acl_info *acl = NULL;
 	spin_lock(&ccs_query_list_lock);
 	list_for_each_entry(ptr, &ccs_query_list, list) {
 		if (ptr->serial != serial || ptr->answer)
 			continue;
-		domain = ptr->domain;
+		acl = ptr->acl;
 		break;
 	}
 	spin_unlock(&ccs_query_list_lock);
-	return domain;
+	return acl;
 }
 
 /**
@@ -5130,16 +3817,20 @@
  *
  * @head: Pointer to "struct ccs_io_buffer".
  *
- * Returns nothing.
+ * Returns true on success, false otherwise.
  */
-static void ccs_read_stat(struct ccs_io_buffer *head)
+static bool ccs_read_stat(struct ccs_io_buffer *head)
 {
 	u8 i;
-	unsigned int total = 0;
-	if (head->r.eof)
-		return;
 	for (i = 0; i < CCS_MAX_POLICY_STAT; i++) {
-		ccs_io_printf(head, "Policy %-30s %10u", ccs_policy_headers[i],
+		static const char * const k[CCS_MAX_POLICY_STAT] = {
+			[CCS_STAT_POLICY_UPDATES]    = "update:",
+			[CCS_STAT_POLICY_PERMISSIVE] =
+			"violation in permissive mode:",
+			[CCS_STAT_POLICY_ENFORCING]  =
+			"violation in enforcing mode:",
+		};
+		ccs_io_printf(head, "stat Policy %-30s %10u", k[i],
 			      ccs_stat_updated[i]);
 		if (ccs_stat_modified[i]) {
 			struct ccs_time stamp;
@@ -5151,40 +3842,35 @@
 		}
 		ccs_set_lf(head);
 	}
-	for (i = 0; i < CCS_MAX_MEMORY_STAT; i++) {
-		unsigned int used = ccs_memory_used[i];
-		total += used;
-		ccs_io_printf(head, "Memory used by %-22s %10u",
-			      ccs_memory_headers[i], used);
-		used = ccs_memory_quota[i];
-		if (used)
-			ccs_io_printf(head, " (Quota: %10u)", used);
-		ccs_set_lf(head);
-	}
-	ccs_io_printf(head, "Total memory used:                    %10u\n",
-		      total);
-	head->r.eof = true;
+	for (i = 0; i < CCS_MAX_MEMORY_STAT; i++)
+		ccs_io_printf(head, "stat Memory used by %s: %u\n",
+			      ccs_memory_headers[i], ccs_memory_used[i]);
+	for (i = 0; i < CCS_MAX_MEMORY_STAT; i++)
+		if (ccs_memory_quota[i])
+			ccs_io_printf(head, "memory quota %s %u\n",
+				      ccs_memory_headers[i],
+				      ccs_memory_quota[i]);
+	ccs_set_lf(head);
+	return true;
 }
 
 /**
- * ccs_write_stat - Set memory quota.
+ * ccs_write_quota - Set memory quota.
  *
- * @head: Pointer to "struct ccs_io_buffer".
+ * @data: Line to parse.
  *
  * Returns 0.
  */
-static int ccs_write_stat(struct ccs_io_buffer *head)
+static int ccs_write_quota(char *data)
 {
-	char *data = head->write_buf;
 	u8 i;
-	if (ccs_str_starts(&data, "Memory used by "))
-		for (i = 0; i < CCS_MAX_MEMORY_STAT; i++)
-			if (ccs_str_starts(&data, ccs_memory_headers[i])) {
-				if (*data == ' ')
-					data++;
-				ccs_memory_quota[i] =
-					simple_strtoul(data, NULL, 10);
-			}
+	for (i = 0; i < CCS_MAX_MEMORY_STAT; i++)
+		if (ccs_str_starts(&data, ccs_memory_headers[i])) {
+			if (*data == ' ')
+				data++;
+			ccs_memory_quota[i] =
+				simple_strtoul(data, NULL, 10);
+		}
 	return 0;
 }
 
@@ -5214,7 +3900,8 @@
 	bool truncated = false;
 	if (!buffer)
 		return NULL;
-	len = snprintf(buffer, ccs_buffer_len - 1, "argv[]={ ");
+	len = snprintf(buffer, ccs_buffer_len - 1,
+		       " argc=%d envc=%d argv[]={ ", argv_count, envp_count);
 	cp = buffer + len;
 	if (!argv_count) {
 		memmove(cp, "} envp[]={ ", 11);
@@ -5234,10 +3921,7 @@
 			if (cp >= buffer + ccs_buffer_len - 32) {
 				/* Reserve some room for "..." string. */
 				truncated = true;
-			} else if (c == '\\') {
-				*cp++ = '\\';
-				*cp++ = '\\';
-			} else if (c > ' ' && c < 127) {
+			} else if (c > ' ' && c < 127 && c != '\\') {
 				*cp++ = c;
 			} else if (!c) {
 				*cp++ = '"';
@@ -5297,19 +3981,19 @@
 	switch (mode & S_IFMT) {
 	case S_IFREG:
 	case 0:
-		return ccs_condition_keyword[CCS_TYPE_IS_FILE];
+		return "file";
 	case S_IFDIR:
-		return ccs_condition_keyword[CCS_TYPE_IS_DIRECTORY];
+		return "directory";
 	case S_IFLNK:
-		return ccs_condition_keyword[CCS_TYPE_IS_SYMLINK];
+		return "symlink";
 	case S_IFIFO:
-		return ccs_condition_keyword[CCS_TYPE_IS_FIFO];
+		return "fifo";
 	case S_IFSOCK:
-		return ccs_condition_keyword[CCS_TYPE_IS_SOCKET];
+		return "socket";
 	case S_IFBLK:
-		return ccs_condition_keyword[CCS_TYPE_IS_BLOCK_DEV];
+		return "block";
 	case S_IFCHR:
-		return ccs_condition_keyword[CCS_TYPE_IS_CHAR_DEV];
+		return "char";
 	}
 	return "unknown"; /* This should not happen. */
 }
@@ -5327,14 +4011,15 @@
 static char *ccs_print_header(struct ccs_request_info *r)
 {
 	struct ccs_time stamp;
-	struct ccs_obj_info *obj = r->obj;
-	const u32 ccs_flags = ccs_current_flags();
+	const char *handler =
+		ccs_current_flags() & CCS_TASK_IS_EXECUTE_HANDLER ? "" : "!";
+	const char *exe = r->exename.name;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 	const pid_t gpid = ccs_sys_getpid();
 #else
 	const pid_t gpid = task_pid_nr(current);
 #endif
-	static const int ccs_buffer_len = 4096;
+	const int ccs_buffer_len = 2000 + strlen(exe);
 	char *buffer = kmalloc(ccs_buffer_len, CCS_GFP_FLAGS);
 	int pos;
 	u8 i;
@@ -5346,52 +4031,38 @@
 		ccs_convert_time(tv.tv_sec, &stamp);
 	}
 	pos = snprintf(buffer, ccs_buffer_len - 1, "#%04u/%02u/%02u "
-		       "%02u:%02u:%02u# profile=", stamp.year, stamp.month,
-		       stamp.day, stamp.hour, stamp.min, stamp.sec);
-	if (r->inversed)
-		pos += snprintf(buffer + pos, ccs_buffer_len - 1 - pos, "acl");
-	else
-		pos += snprintf(buffer + pos, ccs_buffer_len - 1 - pos, "%u",
-				r->profile);
-	pos += snprintf(buffer + pos, ccs_buffer_len - 1 - pos,
-			" mode=%s granted=%s (global-pid=%u) task={ "
-			"pid=%u ppid=%u uid=%u gid=%u euid=%u egid=%u suid=%u "
-			"sgid=%u fsuid=%u fsgid=%u type%s=execute_handler }",
-			ccs_mode[r->mode], ccs_yesno(r->granted), gpid,
-			ccs_sys_getpid(), ccs_sys_getppid(), current_uid(),
-			current_gid(), current_euid(), current_egid(),
-			current_suid(), current_sgid(), current_fsuid(),
-			current_fsgid(),
-			ccs_flags & CCS_TASK_IS_EXECUTE_HANDLER ? "" : "!");
-	if (!obj)
+		       "%02u:%02u:%02u# mode=%s granted=%s (global-pid=%u) "
+		       "task={ pid=%u ppid=%u uid=%u gid=%u euid=%u egid=%u "
+		       "suid=%u sgid=%u fsuid=%u fsgid=%u "
+		       "type%s=execute_handler exe=\"%s\" }", stamp.year,
+		       stamp.month, stamp.day, stamp.hour, stamp.min,
+		       stamp.sec, ccs_mode[r->mode], ccs_yesno(r->granted),
+		       gpid, ccs_sys_getpid(), ccs_sys_getppid(),
+		       current_uid(), current_gid(), current_euid(),
+		       current_egid(), current_suid(), current_sgid(),
+		       current_fsuid(), current_fsgid(), handler, exe);
+	if (!r->obj.path[0].dentry && !r->obj.path[1].dentry)
 		goto no_obj_info;
-	if (!obj->validate_done) {
-		ccs_get_attributes(obj);
-		obj->validate_done = true;
-	}
+	ccs_get_attributes(r);
 	for (i = 0; i < CCS_MAX_PATH_STAT; i++) {
+		const char *objname;
 		struct ccs_mini_stat *stat;
 		unsigned int dev;
 		umode_t mode;
-		if (!obj->stat_valid[i])
+		if (!r->obj.stat_valid[i])
 			continue;
-		stat = &obj->stat[i];
+		stat = &r->obj.stat[i];
 		dev = stat->dev;
 		mode = stat->mode;
-		if (i & 1) {
-			pos += snprintf(buffer + pos, ccs_buffer_len - 1 - pos,
-					" path%u.parent={ uid=%u gid=%u "
-					"ino=%lu perm=0%o }", (i >> 1) + 1,
-					stat->uid, stat->gid, (unsigned long)
-					stat->ino, stat->mode & S_IALLUGO);
-			continue;
-		}
+		objname = ccs_get_sarg(r->type, (i >> 1));
 		pos += snprintf(buffer + pos, ccs_buffer_len - 1 - pos,
-				" path%u={ uid=%u gid=%u ino=%lu major=%u"
-				" minor=%u perm=0%o type=%s", (i >> 1) + 1,
+				" %s%s={ uid=%u gid=%u ino=%lu major=%u"
+				" minor=%u perm=0%o type=%s fsmagic=0x%lX",
+				objname, i & 1 ? ".parent" : "",
 				stat->uid, stat->gid, (unsigned long)
 				stat->ino, MAJOR(dev), MINOR(dev),
-				mode & S_IALLUGO, ccs_filetype(mode));
+				mode & S_IALLUGO, ccs_filetype(mode),
+				stat->fsmagic);
 		if (S_ISCHR(mode) || S_ISBLK(mode)) {
 			dev = stat->rdev;
 			pos += snprintf(buffer + pos, ccs_buffer_len - 1 - pos,
@@ -5425,28 +4096,22 @@
 {
 	char *buf = NULL;
 	char *bprm_info = NULL;
-	char *realpath = NULL;
 	const char *header = NULL;
 	int pos;
 	const char *domainname = ccs_current_domain()->domainname->name;
+	if (!r->exename.name && !ccs_get_exename(&r->exename))
+		return NULL;
 	header = ccs_print_header(r);
 	if (!header)
 		return NULL;
 	/* +10 is for '\n' etc. and '\0'. */
 	len += strlen(domainname) + strlen(header) + 10;
-	if (r->ee) {
-		struct file *file = r->ee->bprm->file;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
-		struct path path = { file->f_vfsmnt, file->f_dentry };
-		realpath = ccs_realpath(&path);
-#else
-		realpath = ccs_realpath(&file->f_path);
-#endif
-		bprm_info = ccs_print_bprm(r->ee->bprm, &r->ee->dump);
-		if (!realpath || !bprm_info)
+	if (r->bprm) {
+		bprm_info = ccs_print_bprm(r->bprm, &r->dump);
+		if (!bprm_info)
 			goto out;
-		/* +80 is for " exec={ realpath=\"%s\" argc=%d envc=%d %s }" */
-		len += strlen(realpath) + 80 + strlen(bprm_info);
+		/* +2 is for " %s " */
+		len += strlen(bprm_info) + 2;
 	}
 	len = ccs_round2(len);
 	buf = kzalloc(len, CCS_GFP_FLAGS);
@@ -5454,16 +4119,11 @@
 		goto out;
 	len--;
 	pos = snprintf(buf, len, "%s", header);
-	if (realpath) {
-		struct linux_binprm *bprm = r->ee->bprm;
-		pos += snprintf(buf + pos, len - pos,
-				" exec={ realpath=\"%s\" argc=%d envc=%d %s }",
-				realpath, bprm->argc, bprm->envc, bprm_info);
-	}
+	if (bprm_info)
+		pos += snprintf(buf + pos, len - pos, "%s ", bprm_info);
 	pos += snprintf(buf + pos, len - pos, "\n%s\n", domainname);
 	vsnprintf(buf + pos, len - pos, fmt, args);
 out:
-	kfree(realpath);
 	kfree(bprm_info);
 	kfree(header);
 	return buf;
@@ -5478,36 +4138,15 @@
  */
 static bool ccs_get_audit(const struct ccs_request_info *r)
 {
-	const u8 profile = r->profile;
-	const u8 index = r->type;
-	const bool is_granted = r->granted;
-	u8 mode;
-	struct ccs_profile *p;
-	if (!ccs_policy_loaded)
-		return false;
-	p = ccs_profile(profile);
-	if (ccs_log_count >= p->pref[CCS_PREF_MAX_AUDIT_LOG])
-		return false;
-	if (is_granted) {
-		const struct ccs_acl_info *matched_acl = r->matched_acl;
-		if (matched_acl && matched_acl->cond &&
-		    matched_acl->cond->grant_log != CCS_GRANTLOG_AUTO)
-			return matched_acl->cond->grant_log ==
-				CCS_GRANTLOG_YES;
-	}
-	mode = p->config[index];
-	if (mode == CCS_CONFIG_USE_DEFAULT)
-		mode = p->config
-			[ccs_index2category[index] + CCS_MAX_MAC_INDEX];
-	if (mode == CCS_CONFIG_USE_DEFAULT)
-		mode = p->default_config;
-	if (is_granted)
-		return mode & CCS_CONFIG_WANT_GRANT_LOG;
-	return mode & CCS_CONFIG_WANT_REJECT_LOG;
+	struct ccs_acl_info *matched_acl = r->matched_acl;
+	if (r->granted)
+		return ccs_grant_log_count < matched_acl->max_grant_log;
+	else
+		return ccs_reject_log_count < matched_acl->max_reject_log;
 }
 
 /**
- * ccs_write_log2 - Write an audit log.
+ * ccs_write_log - Write an audit log.
  *
  * @r:    Pointer to "struct ccs_request_info".
  * @len:  Buffer size needed for @fmt and @args.
@@ -5516,15 +4155,12 @@
  *
  * Returns nothing.
  */
-static void ccs_write_log2(struct ccs_request_info *r, int len,
-			   const char *fmt, va_list args)
+static void ccs_write_log(struct ccs_request_info *r, int len, const char *fmt,
+			  va_list args)
 {
-	char *buf;
 	struct ccs_log *entry;
 	bool quota_exceeded = false;
-	if (!ccs_get_audit(r))
-		return;
-	buf = ccs_init_log(r, len, fmt, args);
+	char *buf = ccs_init_log(r, len, fmt, args);
 	if (!buf)
 		return;
 	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
@@ -5539,6 +4175,7 @@
 	 * Don't go beyond strlen(entry->log).
 	 */
 	entry->size = len + ccs_round2(sizeof(*entry));
+	entry->is_granted = r->granted;
 	spin_lock(&ccs_log_lock);
 	if (ccs_memory_quota[CCS_MEMORY_AUDIT] &&
 	    ccs_memory_used[CCS_MEMORY_AUDIT] + entry->size >=
@@ -5547,7 +4184,10 @@
 	} else {
 		ccs_memory_used[CCS_MEMORY_AUDIT] += entry->size;
 		list_add_tail(&entry->list, &ccs_log);
-		ccs_log_count++;
+		if (entry->is_granted)
+			ccs_grant_log_count++;
+		else
+			ccs_reject_log_count++;
 	}
 	spin_unlock(&ccs_log_lock);
 	if (quota_exceeded) {
@@ -5559,26 +4199,6 @@
 }
 
 /**
- * ccs_write_log - Write an audit log.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @fmt: The printf()'s format string, followed by parameters.
- *
- * Returns nothing.
- */
-void ccs_write_log(struct ccs_request_info *r, const char *fmt, ...)
-{
-	va_list args;
-	int len;
-	va_start(args, fmt);
-	len = vsnprintf((char *) &len, 1, fmt, args) + 1;
-	va_end(args);
-	va_start(args, fmt);
-	ccs_write_log2(r, len, fmt, args);
-	va_end(args);
-}
-
-/**
  * ccs_read_log - Read an audit log.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -5596,7 +4216,10 @@
 	if (!list_empty(&ccs_log)) {
 		ptr = list_entry(ccs_log.next, typeof(*ptr), list);
 		list_del(&ptr->list);
-		ccs_log_count--;
+		if (ptr->is_granted)
+			ccs_grant_log_count--;
+		else
+			ccs_reject_log_count--;
 		ccs_memory_used[CCS_MEMORY_AUDIT] -= ptr->size;
 	}
 	spin_unlock(&ccs_log_lock);
@@ -5617,188 +4240,39 @@
  */
 static int ccs_poll_log(struct file *file, poll_table *wait)
 {
-	if (ccs_log_count)
+	if (ccs_grant_log_count || ccs_reject_log_count)
 		return POLLIN | POLLRDNORM;
 	poll_wait(file, &ccs_log_wait, wait);
-	if (ccs_log_count)
+	if (ccs_grant_log_count || ccs_reject_log_count)
 		return POLLIN | POLLRDNORM;
 	return 0;
 }
 
 /**
- * ccs_set_namespace_cursor - Set namespace to read.
+ * ccs_assign_domain - Create a domain.
  *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns nothing.
- */
-static void ccs_set_namespace_cursor(struct ccs_io_buffer *head)
-{
-	struct list_head *ns;
-	if (head->type != CCS_EXCEPTION_POLICY && head->type != CCS_PROFILE)
-		return;
-	/*
-	 * If this is the first read, or reading previous namespace finished
-	 * and has more namespaces to read, update the namespace cursor.
-	 */
-	ns = head->r.ns;
-	if (!ns || (head->r.eof && ns->next != &ccs_namespace_list)) {
-		/* Clearing is OK because ccs_flush() returned true. */
-		memset(&head->r, 0, sizeof(head->r));
-		head->r.ns = ns ? ns->next : ccs_namespace_list.next;
-	}
-}
-
-/**
- * ccs_has_more_namespace - Check for unread namespaces.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true if we have more entries to print, false otherwise.
- */
-static bool ccs_has_more_namespace(struct ccs_io_buffer *head)
-{
-	return (head->type == CCS_EXCEPTION_POLICY ||
-		head->type == CCS_PROFILE) && head->r.eof &&
-		head->r.ns->next != &ccs_namespace_list;
-}
-
-/**
- * ccs_find_namespace - Find specified namespace.
- *
- * @name: Name of namespace to find.
- * @len:  Length of @name.
- *
- * Returns pointer to "struct ccs_policy_namespace" if found, NULL otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static struct ccs_policy_namespace *ccs_find_namespace(const char *name,
-						       const unsigned int len)
-{
-	struct ccs_policy_namespace *ns;
-	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
-				 &ccs_ss) {
-		if (strncmp(name, ns->name, len) ||
-		    (name[len] && name[len] != ' '))
-			continue;
-		return ns;
-	}
-	return NULL;
-}
-
-/**
- * ccs_assign_namespace - Create a new namespace.
- *
- * @domainname: Name of namespace to create.
- *
- * Returns pointer to "struct ccs_policy_namespace" on success, NULL otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static struct ccs_policy_namespace *ccs_assign_namespace
-(const char *domainname)
-{
-	struct ccs_policy_namespace *ptr;
-	struct ccs_policy_namespace *entry;
-	const char *cp = domainname;
-	unsigned int len = 0;
-	while (*cp && *cp++ != ' ')
-		len++;
-	ptr = ccs_find_namespace(domainname, len);
-	if (ptr)
-		return ptr;
-	if (len >= CCS_EXEC_TMPSIZE - 10 || !ccs_domain_def(domainname))
-		return NULL;
-	entry = kzalloc(sizeof(*entry) + len + 1, CCS_GFP_FLAGS);
-	if (!entry)
-		return NULL;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	ptr = ccs_find_namespace(domainname, len);
-	if (!ptr && ccs_memory_ok(entry, sizeof(*entry) + len + 1)) {
-		char *name = (char *) (entry + 1);
-		ptr = entry;
-		memmove(name, domainname, len);
-		name[len] = '\0';
-		entry->name = name;
-		ccs_init_policy_namespace(entry);
-		entry = NULL;
-	}
-	mutex_unlock(&ccs_policy_lock);
-out:
-	kfree(entry);
-	return ptr;
-}
-
-/**
- * ccs_namespace_jump - Check for namespace jump.
- *
- * @domainname: Name of domain.
- *
- * Returns true if namespace differs, false otherwise.
- */
-static bool ccs_namespace_jump(const char *domainname)
-{
-	const char *namespace = ccs_current_namespace()->name;
-	const int len = strlen(namespace);
-	return strncmp(domainname, namespace, len) ||
-		(domainname[len] && domainname[len] != ' ');
-}
-
-/**
- * ccs_assign_domain - Create a domain or a namespace.
- *
  * @domainname: The name of domain.
- * @transit:    True if transit to domain found or created.
  *
  * Returns pointer to "struct ccs_domain_info" on success, NULL otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-struct ccs_domain_info *ccs_assign_domain(const char *domainname,
-					  const bool transit)
+struct ccs_domain_info *ccs_assign_domain(const char *domainname)
 {
 	struct ccs_security *security = ccs_current_security();
 	struct ccs_domain_info e = { };
 	struct ccs_domain_info *entry = ccs_find_domain(domainname);
-	bool created = false;
 	if (entry) {
-		if (transit) {
-			/*
-			 * Since namespace is created at runtime, profiles may
-			 * not be created by the moment the process transits to
-			 * that domain. Do not perform domain transition if
-			 * profile for that domain is not yet created.
-			 */
-			if (ccs_policy_loaded &&
-			    !entry->ns->profile_ptr[entry->profile])
-				return NULL;
-			security->ccs_domain_info = entry;
-		}
+		security->ccs_domain_info = entry;
 		return entry;
 	}
 	/* Requested domain does not exist. */
 	/* Don't create requested domain if domainname is invalid. */
-	if (strlen(domainname) >= CCS_EXEC_TMPSIZE - 10 ||
-	    !ccs_correct_domain(domainname))
+	if (!ccs_correct_domain(domainname))
 		return NULL;
-	/*
-	 * Since definition of profiles and acl_groups may differ across
-	 * namespaces, do not inherit "use_profile" and "use_group" settings
-	 * by automatically creating requested domain upon domain transition.
-	 */
-	if (transit && ccs_namespace_jump(domainname))
-		return NULL;
-	e.ns = ccs_assign_namespace(domainname);
-	if (!e.ns)
-		return NULL;
 	e.domainname = ccs_get_name(domainname);
 	if (!e.domainname)
 		return NULL;
-	e.default_transition = ccs_get_name("child");
-	if (!e.default_transition)
-		goto out;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
 	entry = ccs_find_domain(domainname);
@@ -5807,63 +4281,13 @@
 	entry = ccs_commit_ok(&e, sizeof(e));
 	if (!entry)
 		goto done;
-	INIT_LIST_HEAD(&entry->acl_info_list);
-	/*
-	 * "use_profile" and "use_group" settings for automatically created
-	 * domains are inherited from current domain. These are 0 for manually
-	 * created domains.
-	 */
-	if (transit) {
-		const struct ccs_domain_info *domain =
-			security->ccs_domain_info;
-		struct ccs_acl_info *ptr;
-		entry->profile = domain->profile;
-		list_for_each_entry_srcu(ptr, &domain->acl_info_list, list,
-					 &ccs_ss) {
-			struct ccs_use_group_acl tmp;
-			struct ccs_use_group_acl *acl;
-			/*
-			printk(KERN_INFO "ptr->is_deleted=%u ptr->type=%u\n",
-			       ptr->is_deleted, ptr->type);
-			*/
-			if (ptr->is_deleted ||
-			    ptr->type != CCS_TYPE_USE_GROUP_ACL)
-				continue;
-			tmp = *container_of(ptr, typeof(tmp), head);
-			atomic_inc(&tmp.group->head.users);
-			if (tmp.head.cond)
-				atomic_inc(&tmp.head.cond->head.users);
-			/*
-			printk(KERN_INFO "Inherit %s\n",
-			       tmp.group->group_name->name);
-			*/
-			acl = ccs_commit_ok(&tmp, sizeof(tmp));
-			if (!acl) {
-				entry->is_deleted = true;
-				break;
-			}
-			list_add_tail(&acl->head.list, &entry->acl_info_list);
-		}
-	}
 	list_add_tail_rcu(&entry->list, &ccs_domain_list);
-	if (!entry->is_deleted)
-		created = true;
-	else
-		entry = NULL;
 done:
 	mutex_unlock(&ccs_policy_lock);
 out:
 	ccs_put_name(e.domainname);
-	ccs_put_name(e.default_transition);
-	if (entry && transit) {
+	if (entry)
 		security->ccs_domain_info = entry;
-		if (created) {
-			struct ccs_request_info r = { };
-			r.type = CCS_MAC_FILE_EXECUTE;
-			ccs_write_log(&r, "use_profile %u\n", entry->profile);
-			ccs_update_stat(CCS_STAT_POLICY_UPDATES);
-		}
-	}
 	return entry;
 }
 
@@ -5879,47 +4303,25 @@
  */
 static int ccs_parse_policy(struct ccs_io_buffer *head, char *line)
 {
+	/* Set current line's content. */
+	head->w.data = line;
+	head->w.is_deny = false;
+	head->w.priority = 0;
 	/* Delete request? */
 	head->w.is_delete = !strncmp(line, "delete ", 7);
 	if (head->w.is_delete)
 		memmove(line, line + 7, strlen(line + 7) + 1);
-	/* Selecting namespace to update. */
-	if (head->type == CCS_EXCEPTION_POLICY || head->type == CCS_PROFILE) {
-		if (*line == '<') {
-			char *cp = strchr(line, ' ');
-			if (cp) {
-				*cp++ = '\0';
-				head->w.ns = ccs_assign_namespace(line);
-				memmove(line, cp, strlen(cp) + 1);
-			} else
-				head->w.ns = NULL;
-		} else
-			head->w.ns = &ccs_kernel_namespace;
-		/* Don't allow updating if namespace is invalid. */
-		if (!head->w.ns)
-			return -ENOENT;
-	}
 	/* Do the update. */
 	switch (head->type) {
-	case CCS_DOMAIN_POLICY:
-		return ccs_write_domain(head);
-	case CCS_EXCEPTION_POLICY:
-		return ccs_write_exception(head);
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 	case CCS_EXECUTE_HANDLER:
 #endif
 	case CCS_PROCESS_STATUS:
 		return ccs_write_pid(head);
-	case CCS_STAT:
-		return ccs_write_stat(head);
-	case CCS_PROFILE:
-		return ccs_write_profile(head);
 	case CCS_QUERY:
 		return ccs_write_answer(head);
-	case CCS_MANAGER:
-		return ccs_write_manager(head);
-	case CCS_ACL_POLICY:
-		return ccs_write_acl_policy(head);
+	case CCS_POLICY:
+		return ccs_write_policy(head);
 	default:
 		return -ENOSYS;
 	}
@@ -5943,49 +4345,24 @@
 static void __init ccs_load_builtin_policy(void)
 {
 	/*
-	 * This include file is manually created and contains built-in policy
-	 * named "ccs_builtin_profile", "ccs_builtin_exception_policy",
-	 * "ccs_builtin_domain_policy", "ccs_builtin_manager",
-	 * "ccs_builtin_stat" in the form of "static char [] __initdata".
+	 * This include file is manually created and contains built-in policy.
+	 *
+	 * static char [] __initdata ccs_builtin_policy = { ... };
 	 */
 #include "builtin-policy.h"
-	u8 i;
 	const int idx = ccs_read_lock();
-	for (i = 0; i < 5; i++) {
-		struct ccs_io_buffer head = { };
-		char *start = "";
-		switch (i) {
-		case 0:
-			start = ccs_builtin_profile;
-			head.type = CCS_PROFILE;
+	struct ccs_io_buffer head = { };
+	char *start = ccs_builtin_policy;
+	head.type = CCS_POLICY;
+	while (1) {
+		char *end = strchr(start, '\n');
+		if (!end)
 			break;
-		case 1:
-			start = ccs_builtin_exception_policy;
-			head.type = CCS_EXCEPTION_POLICY;
-			break;
-		case 2:
-			start = ccs_builtin_domain_policy;
-			head.type = CCS_DOMAIN_POLICY;
-			break;
-		case 3:
-			start = ccs_builtin_manager;
-			head.type = CCS_MANAGER;
-			break;
-		case 4:
-			start = ccs_builtin_stat;
-			head.type = CCS_STAT;
-			break;
-		}
-		while (1) {
-			char *end = strchr(start, '\n');
-			if (!end)
-				break;
-			*end = '\0';
-			ccs_normalize_line(start);
-			head.write_buf = start;
-			ccs_parse_policy(&head, start);
-			start = end + 1;
-		}
+		*end = '\0';
+		ccs_normalize_line(start);
+		head.write_buf = start;
+		ccs_parse_policy(&head, start);
+		start = end + 1;
 	}
 	ccs_read_unlock(idx);
 #ifdef CONFIG_CCSECURITY_OMIT_USERSPACE_LOADER
@@ -6021,7 +4398,7 @@
 }
 
 /**
- * ccs_read_domain_in_acl - Read domainname and condition.
+ * ccs_read_subacl - Read sub ACL in ACL entry.
  *
  * @head: Pointer to "struct ccs_io_buffer".
  * @list: Pointer to "struct list_head".
@@ -6030,85 +4407,126 @@
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_read_domain_in_acl(struct ccs_io_buffer *head,
-				   struct list_head *list)
+static bool ccs_read_subacl(struct ccs_io_buffer *head,
+			    const struct list_head *list)
 {
-	list_for_each_cookie(head->r.domain, list) {
-		struct ccs_domain_info *domain =
-			list_entry(head->r.domain, typeof(*domain), list);
+	list_for_each_cookie(head->r.subacl, list) {
+		struct ccs_acl_info *acl =
+			list_entry(head->r.subacl, typeof(*acl), list);
 		switch (head->r.step) {
 		case 3:
-			if (domain->is_deleted)
+			if (acl->is_deleted)
 				continue;
 			if (!ccs_flush(head))
 				return false;
-			ccs_set_string(head, "    by ");
-			ccs_set_string(head, domain->domainname->name);
+			ccs_io_printf(head, "    %u ", acl->priority);
+			if (acl->is_deny)
+				ccs_set_string(head, "deny");
+			else
+				ccs_set_string(head, "allow");
 			head->r.cond_step = 0;
 			head->r.step++;
 			/* fall through */
 		case 4:
 			if (!ccs_flush(head))
 				return false;
-			if (domain->cond) {
-				if (!ccs_print_condition(head, domain->cond))
-					return false;
-			} else {
-				ccs_set_lf(head);
-			}
+			if (acl->cond &&
+			    !ccs_print_condition(head, acl->cond))
+				return false;
+			ccs_set_lf(head);
 			head->r.step--;
 		}
 	}
+	head->r.subacl = NULL;
 	return true;
 }
 
 /**
- * ccs_read_inverse_policy - Read inversed mode policy.
+ * ccs_read_policy - Read policy.
  *
  * @head: Pointer to "struct ccs_io_buffer".
  *
  * Caller holds ccs_read_lock().
  */
-static void ccs_read_inverse_policy(struct ccs_io_buffer *head)
+static void ccs_read_policy(struct ccs_io_buffer *head)
 {
 	if (head->r.eof)
 		return;
-	list_for_each_cookie(head->r.acl, &ccs_inversed_acl_list) {
-		struct ccs_acl_info *ptr =
-			list_entry(head->r.acl, typeof(*ptr), list);
-		switch (head->r.step) {
-		case 0:
-			if (ptr->is_deleted)
-				continue;
-			head->r.step++;
-			/* fall through */
-		case 1:
-			if (!ccs_print_entry(head, ptr))
+	if (head->r.print_this_acl_only)
+		goto skip;
+	if (!head->r.version_done) {
+		ccs_io_printf(head, "POLICY_VERSION=%u\n", ccs_policy_version);
+		ccs_set_lf(head);
+		head->r.version_done = true;
+	}
+	if (!head->r.stat_done)
+		head->r.stat_done = ccs_read_stat(head);
+	if (!head->r.group_done) {
+		while (head->r.step < CCS_MAX_GROUP)
+			if (!ccs_read_group(head, head->r.step))
 				return;
-			head->r.step++;
-			/* fall through */
-		case 2:
-			if (!ccs_flush(head))
-				return;
-			ccs_set_string(head, "    mode ");
-			ccs_set_string(head, ccs_mode[ptr->mode]);
-			ccs_set_lf(head);
-			head->r.domain = NULL;
-			head->r.step++;
-			/* fall through */
-		case 3:
-		case 4:
-			if (!ccs_read_domain_in_acl(head, &ptr->domain_list))
-				return;
-			head->r.domain = NULL;
-			head->r.step = 5;
-			/* fall through */
-		case 5:
-			if (!ccs_flush(head))
-				return;
-			ccs_set_lf(head);
-			head->r.step = 0;
+			else
+				head->r.step++;
+		head->r.step = 0;
+		head->r.group_done = true;
+	}
+skip:
+	//printk(KERN_INFO "%u: Current head->r.acl_index=%u\n", __LINE__,
+	//       head->r.acl_index);
+	while (head->r.acl_index < CCS_MAX_MAC_INDEX) {
+		struct list_head * const list =
+			&ccs_acl_list[head->r.acl_index];
+		//printk(KERN_INFO "%u: Start head->r.acl_index=%u\n", __LINE__,
+		//       head->r.acl_index);
+		list_for_each_cookie(head->r.acl, list) {
+			struct ccs_acl_info *ptr =
+				list_entry(head->r.acl, typeof(*ptr), list);
+			//printk(KERN_INFO "%u: head->r.step=%u\n", __LINE__,
+			//       head->r.step);
+			switch (head->r.step) {
+			case 0:
+				if (ptr->is_deleted &&
+				    !head->r.print_this_acl_only)
+					continue;
+				head->r.step++;
+				/* fall through */
+			case 1:
+				if (!ccs_read_acl(head, ptr))
+					return;
+				head->r.step++;
+				/* fall through */
+			case 2:
+				if (!ccs_flush(head))
+					return;
+				ccs_set_string(head, "    config mode=");
+				ccs_set_string(head, ccs_mode[ptr->mode]);
+				ccs_io_printf(head,
+					      " grant_log=%u reject_log=%u\n",
+					      ptr->max_grant_log,
+					      ptr->max_reject_log);
+				head->r.step++;
+				/* fall through */
+			case 3:
+			case 4:
+				if (!ccs_read_subacl(head,
+						     &ptr->acl_info_list))
+					return;
+				head->r.step = 5;
+				/* fall through */
+			case 5:
+				if (!ccs_flush(head))
+					return;
+				ccs_set_lf(head);
+				if (head->r.print_this_acl_only)
+					head->r.step = 6;
+				else
+					head->r.step = 0;
+				//printk(KERN_INFO "%u: head->r.step=%u\n",
+				//     __LINE__, head->r.step);
+			}
 		}
+		head->r.acl = NULL;
+		head->r.acl_index++;
 	}
 	head->r.eof = true;
 }
@@ -6232,46 +4650,30 @@
 	head->read_user_buf = buf;
 	head->read_user_buf_avail = count;
 	idx = ccs_read_lock();
-	if (ccs_flush(head))
+	if (ccs_flush(head)) {
 		/* Call the policy handler. */
-		do {
-			ccs_set_namespace_cursor(head);
-			switch (head->type) {
-			case CCS_DOMAIN_POLICY:
-				ccs_read_domain(head);
-				break;
-			case CCS_EXCEPTION_POLICY:
-				ccs_read_exception(head);
-				break;
-			case CCS_AUDIT:
-				ccs_read_log(head);
-				break;
+		switch (head->type) {
+		case CCS_AUDIT:
+			ccs_read_log(head);
+			break;
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-			case CCS_EXECUTE_HANDLER:
+		case CCS_EXECUTE_HANDLER:
 #endif
-			case CCS_PROCESS_STATUS:
-				ccs_read_pid(head);
-				break;
-			case CCS_VERSION:
-				ccs_read_version(head);
-				break;
-			case CCS_STAT:
-				ccs_read_stat(head);
-				break;
-			case CCS_PROFILE:
-				ccs_read_profile(head);
-				break;
-			case CCS_QUERY:
-				ccs_read_query(head);
-				break;
-			case CCS_MANAGER:
-				ccs_read_manager(head);
-				break;
-			case CCS_ACL_POLICY:
-				ccs_read_inverse_policy(head);
-				break;
-			}
-		} while (ccs_flush(head) && ccs_has_more_namespace(head));
+		case CCS_PROCESS_STATUS:
+			ccs_read_pid(head);
+			break;
+		case CCS_VERSION:
+			ccs_read_version(head);
+			break;
+		case CCS_QUERY:
+			ccs_read_query(head);
+			break;
+		case CCS_POLICY:
+			ccs_read_policy(head);
+			break;
+		}
+		ccs_flush(head);
+	}
 	ccs_read_unlock(idx);
 	len = head->read_user_buf - buf;
 	mutex_unlock(&head->io_sem);
@@ -6315,14 +4717,13 @@
 		name.name = data;
 		ccs_fill_path_info(&name);
 		/* Check "task manual_domain_transition" permission. */
-		r.type = CCS_MAC_FILE_EXECUTE;
-		r.param_type = CCS_TYPE_MANUAL_TASK_ACL;
-		r.param.task.domainname = &name;
-		ccs_check_acl(&r);
-		if (!r.granted)
+		r.type = CCS_MAC_MANUAL_TASK_TRANSITION;
+		r.param.s[0] = &name;
+		ccs_check_acl(&r, true);
+		if (!r.granted || !r.matched_acl)
 			error = -EPERM;
 		else
-			error = ccs_assign_domain(data, true) ? 0 : -ENOENT;
+			error = ccs_assign_domain(data) ? 0 : -ENOENT;
 		ccs_read_unlock(idx);
 	} else
 		error = -EINVAL;
@@ -6382,32 +4783,10 @@
 		cp0[head->w.avail - 1] = '\0';
 		head->w.avail = 0;
 		ccs_normalize_line(cp0);
-		if (!strcmp(cp0, "reset")) {
-			head->w.ns = &ccs_kernel_namespace;
-			head->w.domain = NULL;
-			memset(&head->r, 0, sizeof(head->r));
-			continue;
-		}
 		/* Don't allow updating policies by non manager programs. */
-		switch (head->type) {
-		case CCS_PROCESS_STATUS:
-			/* This does not write anything. */
-			break;
-		case CCS_DOMAIN_POLICY:
-			if (ccs_select_domain(head, cp0))
-				continue;
-			/* fall through */
-		case CCS_EXCEPTION_POLICY:
-			if (!strcmp(cp0, "select transition_only")) {
-				head->r.print_transition_related_only = true;
-				continue;
-			}
-			/* fall through */
-		default:
-			if (!ccs_manager()) {
-				error = -EPERM;
-				goto out;
-			}
+		if (head->type != CCS_PROCESS_STATUS && !ccs_manager()) {
+			error = -EPERM;
+			goto out;
 		}
 		switch (ccs_parse_policy(head, cp0)) {
 		case -EPERM:
@@ -6415,18 +4794,8 @@
 			goto out;
 		case 0:
 			/* Update statistics. */
-			switch (head->type) {
-			case CCS_DOMAIN_POLICY:
-			case CCS_EXCEPTION_POLICY:
-			case CCS_STAT:
-			case CCS_PROFILE:
-			case CCS_MANAGER:
-			case CCS_ACL_POLICY:
+			if (head->type == CCS_POLICY)
 				ccs_update_stat(CCS_STAT_POLICY_UPDATES);
-				break;
-			default:
-				break;
-			}
 			break;
 		}
 	}
@@ -6480,21 +4849,15 @@
 	ccs_dir->proc_iops = &ccs_dir_inode_operations;
 #endif
 	ccs_create_entry("query",            0600, ccs_dir, CCS_QUERY);
-	ccs_create_entry("domain_policy",    0600, ccs_dir, CCS_DOMAIN_POLICY);
-	ccs_create_entry("exception_policy", 0600, ccs_dir,
-			 CCS_EXCEPTION_POLICY);
 	ccs_create_entry("audit",            0400, ccs_dir, CCS_AUDIT);
 	ccs_create_entry(".process_status",  0600, ccs_dir,
 			 CCS_PROCESS_STATUS);
-	ccs_create_entry("stat",             0644, ccs_dir, CCS_STAT);
-	ccs_create_entry("profile",          0600, ccs_dir, CCS_PROFILE);
-	ccs_create_entry("manager",          0600, ccs_dir, CCS_MANAGER);
 	ccs_create_entry("version",          0400, ccs_dir, CCS_VERSION);
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 	ccs_create_entry(".execute_handler", 0666, ccs_dir,
 			 CCS_EXECUTE_HANDLER);
 #endif
-	ccs_create_entry("acl_policy",       0600, ccs_dir, CCS_ACL_POLICY);
+	ccs_create_entry("policy",           0600, ccs_dir, CCS_POLICY);
 	{
 		struct proc_dir_entry *e = create_proc_entry("self_domain",
 							     0666, ccs_dir);
@@ -6510,6 +4873,7 @@
  */
 static int __init ccs_init_module(void)
 {
+	u8 idx;
 	if (ccsecurity_ops.disabled)
 		return -EINVAL;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
@@ -6519,21 +4883,10 @@
 	if (init_srcu_struct(&ccs_ss))
 		panic("Out of memory.");
 #endif
-	{
-		static struct ccs_path_info any;
-		any.name = "any";
-		ccs_fill_path_info(&any);
-		ccs_group_any.group_name = &any;
-		INIT_LIST_HEAD(&ccs_group_any.head.list);
-		INIT_LIST_HEAD(&ccs_group_any.member_list);
-	}
-	ccs_kernel_namespace.name = "<kernel>";
-	ccs_init_policy_namespace(&ccs_kernel_namespace);
-	ccs_kernel_transition.name = "child";
-	ccs_fill_path_info(&ccs_kernel_transition);
-	ccs_kernel_domain.default_transition = &ccs_kernel_transition;
-	ccs_kernel_domain.ns = &ccs_kernel_namespace;
-	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list);
+	for (idx = 0; idx < CCS_MAX_MAC_INDEX; idx++)
+		INIT_LIST_HEAD(&ccs_acl_list[idx]);
+	for (idx = 0; idx < CCS_MAX_GROUP; idx++)
+		INIT_LIST_HEAD(&ccs_group_list[idx]);
 	ccs_mm_init();
 	ccs_policy_io_init();
 	ccs_permission_init();
Index: memory.c
===================================================================
--- memory.c	(revision 5869)
+++ memory.c	(working copy)
@@ -162,8 +162,11 @@
 #else
 	head = &ccs_name_list[hash % CCS_MAX_HASH];
 #endif
-	if (mutex_lock_interruptible(&ccs_policy_lock))
+	if (mutex_lock_interruptible(&ccs_policy_lock)) {
+		printk(KERN_INFO "ccs_get_name('%s') interrupted\n", name);
+		WARN_ON(1);
 		return NULL;
+	}
 	list_for_each_entry(ptr, head, head.list) {
 		if (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||
 		    atomic_read(&ptr->head.users) == CCS_GC_IN_PROGRESS)
Index: permission.c
===================================================================
--- permission.c	(revision 5869)
+++ permission.c	(working copy)
@@ -42,112 +42,12 @@
 	[CCS_MOUNT_MAKE_SHARED]     = "--make-shared",
 };
 
-/* Mapping table from "enum ccs_path_acl_index" to "enum ccs_mac_index". */
-const u8 ccs_p2mac[CCS_MAX_PATH_OPERATION] = {
-	[CCS_TYPE_READ]       = CCS_MAC_FILE_READ,
-	[CCS_TYPE_WRITE]      = CCS_MAC_FILE_WRITE,
-	[CCS_TYPE_APPEND]     = CCS_MAC_FILE_APPEND,
-	[CCS_TYPE_UNLINK]     = CCS_MAC_FILE_UNLINK,
-#ifdef CONFIG_CCSECURITY_FILE_GETATTR
-	[CCS_TYPE_GETATTR]    = CCS_MAC_FILE_GETATTR,
-#endif
-	[CCS_TYPE_RMDIR]      = CCS_MAC_FILE_RMDIR,
-	[CCS_TYPE_TRUNCATE]   = CCS_MAC_FILE_TRUNCATE,
-	[CCS_TYPE_CHROOT]     = CCS_MAC_FILE_CHROOT,
-	[CCS_TYPE_UMOUNT]     = CCS_MAC_FILE_UMOUNT,
-};
-
-/* Mapping table from "enum ccs_mkdev_acl_index" to "enum ccs_mac_index". */
-const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION] = {
-	[CCS_TYPE_MKBLOCK] = CCS_MAC_FILE_MKBLOCK,
-	[CCS_TYPE_MKCHAR]  = CCS_MAC_FILE_MKCHAR,
-};
-
-/* Mapping table from "enum ccs_path2_acl_index" to "enum ccs_mac_index". */
-const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION] = {
-	[CCS_TYPE_LINK]       = CCS_MAC_FILE_LINK,
-	[CCS_TYPE_RENAME]     = CCS_MAC_FILE_RENAME,
-	[CCS_TYPE_PIVOT_ROOT] = CCS_MAC_FILE_PIVOT_ROOT,
-	[CCS_TYPE_SYMLINK]    = CCS_MAC_FILE_SYMLINK,
-};
-
-/*
- * Mapping table from "enum ccs_path_number_acl_index" to "enum ccs_mac_index".
- */
-const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION] = {
-	[CCS_TYPE_CREATE] = CCS_MAC_FILE_CREATE,
-	[CCS_TYPE_MKDIR]  = CCS_MAC_FILE_MKDIR,
-	[CCS_TYPE_MKFIFO] = CCS_MAC_FILE_MKFIFO,
-	[CCS_TYPE_MKSOCK] = CCS_MAC_FILE_MKSOCK,
-	[CCS_TYPE_IOCTL]  = CCS_MAC_FILE_IOCTL,
-	[CCS_TYPE_CHMOD]  = CCS_MAC_FILE_CHMOD,
-	[CCS_TYPE_CHOWN]  = CCS_MAC_FILE_CHOWN,
-	[CCS_TYPE_CHGRP]  = CCS_MAC_FILE_CHGRP,
-};
-
-#ifdef CONFIG_CCSECURITY_NETWORK
-
-/*
- * Mapping table from "enum ccs_network_acl_index" to "enum ccs_mac_index" for
- * inet domain socket.
- */
-static const u8 ccs_inet2mac[CCS_SOCK_MAX][CCS_MAX_NETWORK_OPERATION] = {
-	[SOCK_STREAM] = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_INET_STREAM_BIND,
-		[CCS_NETWORK_LISTEN]  = CCS_MAC_NETWORK_INET_STREAM_LISTEN,
-		[CCS_NETWORK_CONNECT] = CCS_MAC_NETWORK_INET_STREAM_CONNECT,
-		[CCS_NETWORK_ACCEPT]  = CCS_MAC_NETWORK_INET_STREAM_ACCEPT,
-	},
-	[SOCK_DGRAM] = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_INET_DGRAM_BIND,
-		[CCS_NETWORK_SEND]    = CCS_MAC_NETWORK_INET_DGRAM_SEND,
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-		[CCS_NETWORK_RECV]    = CCS_MAC_NETWORK_INET_DGRAM_RECV,
-#endif
-	},
-	[SOCK_RAW]    = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_INET_RAW_BIND,
-		[CCS_NETWORK_SEND]    = CCS_MAC_NETWORK_INET_RAW_SEND,
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-		[CCS_NETWORK_RECV]    = CCS_MAC_NETWORK_INET_RAW_RECV,
-#endif
-	},
-};
-
-/*
- * Mapping table from "enum ccs_network_acl_index" to "enum ccs_mac_index" for
- * unix domain socket.
- */
-static const u8 ccs_unix2mac[CCS_SOCK_MAX][CCS_MAX_NETWORK_OPERATION] = {
-	[SOCK_STREAM] = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_UNIX_STREAM_BIND,
-		[CCS_NETWORK_LISTEN]  = CCS_MAC_NETWORK_UNIX_STREAM_LISTEN,
-		[CCS_NETWORK_CONNECT] = CCS_MAC_NETWORK_UNIX_STREAM_CONNECT,
-		[CCS_NETWORK_ACCEPT]  = CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT,
-	},
-	[SOCK_DGRAM] = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_UNIX_DGRAM_BIND,
-		[CCS_NETWORK_SEND]    = CCS_MAC_NETWORK_UNIX_DGRAM_SEND,
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-		[CCS_NETWORK_RECV]    = CCS_MAC_NETWORK_UNIX_DGRAM_RECV,
-#endif
-	},
-	[SOCK_SEQPACKET] = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_UNIX_SEQPACKET_BIND,
-		[CCS_NETWORK_LISTEN]  = CCS_MAC_NETWORK_UNIX_SEQPACKET_LISTEN,
-		[CCS_NETWORK_CONNECT] = CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT,
-		[CCS_NETWORK_ACCEPT]  = CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT,
-	},
-};
-
-#endif
-
 #ifdef CONFIG_CCSECURITY_CAPABILITY
 
 /*
  * Mapping table from "enum ccs_capability_acl_index" to "enum ccs_mac_index".
  */
-const u8 ccs_c2mac[CCS_MAX_CAPABILITY_INDEX] = {
+static const u8 ccs_c2mac[CCS_MAX_CAPABILITY_INDEX] = {
 	[CCS_USE_ROUTE_SOCKET]  = CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET,
 	[CCS_USE_PACKET_SOCKET] = CCS_MAC_CAPABILITY_USE_PACKET_SOCKET,
 	[CCS_SYS_REBOOT]        = CCS_MAC_CAPABILITY_SYS_REBOOT,
@@ -165,8 +65,8 @@
 
 /* Structure for holding inet domain socket's address. */
 struct ccs_inet_addr_info {
-	u16 port;           /* In network byte order. */
-	const u32 *address; /* In network byte order. */
+	u16 port;          /* In network byte order. */
+	const u8 *address; /* In network byte order. */
 	bool is_ipv6;
 };
 
@@ -178,7 +78,6 @@
 
 /* Structure for holding socket address. */
 struct ccs_addr_info {
-	u8 protocol;
 	u8 operation;
 	struct ccs_inet_addr_info inet;
 	struct ccs_unix_addr_info unix0;
@@ -188,35 +87,16 @@
 
 bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos,
 		   struct ccs_page_dump *dump);
-void ccs_get_attributes(struct ccs_obj_info *obj);
+void ccs_get_attributes(struct ccs_request_info *r);
+void ccs_populate_patharg(struct ccs_request_info *r, const bool first);
 
 static bool ccs_alphabet_char(const char c);
-static bool ccs_argv(const unsigned int index, const char *arg_ptr,
-		     const int argc, const struct ccs_argv *argv, u8 *checked);
 static bool ccs_byte_range(const char *str);
 static bool ccs_check_entry(struct ccs_request_info *r,
 			    struct ccs_acl_info *ptr);
-static bool ccs_check_execute_acl(struct ccs_request_info *r,
-				  const struct ccs_acl_info *ptr);
-static bool ccs_check_mkdev_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr);
-static bool ccs_check_mount_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr);
-static bool ccs_check_path2_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr);
-static bool ccs_check_path_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr);
-static bool ccs_check_path_number_acl(struct ccs_request_info *r,
-				      const struct ccs_acl_info *ptr);
-static bool ccs_check_use_group_acl(struct ccs_request_info *r,
-				    struct ccs_acl_info *ptr);
-static bool ccs_compare_number_union(const unsigned long value,
-				     const struct ccs_number_union *ptr);
 static bool ccs_condition(struct ccs_request_info *r,
 			  const struct ccs_condition *cond);
 static bool ccs_decimal(const char c);
-static bool ccs_envp(const char *env_name, const char *env_value,
-		     const int envc, const struct ccs_envp *envp, u8 *checked);
 static bool ccs_file_matches_pattern(const char *filename,
 				     const char *filename_end,
 				     const char *pattern,
@@ -225,7 +105,6 @@
 				      const char *filename_end,
 				      const char *pattern,
 				      const char *pattern_end);
-static bool ccs_get_realpath(struct ccs_path_info *buf, struct path *path);
 static bool ccs_hexadecimal(const char c);
 static bool ccs_number_matches_group(const unsigned long min,
 				     const unsigned long max,
@@ -233,18 +112,8 @@
 static bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 				     const struct ccs_path_info *pattern);
 static bool ccs_path_matches_pattern2(const char *f, const char *p);
-static bool ccs_scan_bprm(struct ccs_execve *ee, const u16 argc,
-			  const struct ccs_argv *argv, const u16 envc,
-			  const struct ccs_envp *envp);
-static bool ccs_scan_exec_realpath(struct file *file,
-				   const struct ccs_name_union *ptr,
-				   const bool match);
-static bool ccs_compare_name_union(const struct ccs_path_info *name,
-				   const struct ccs_name_union *ptr);
 static bool ccs_path_matches_group(const struct ccs_path_info *pathname,
 				   const struct ccs_group *group);
-static const struct ccs_path_info *ccs_transition_type
-(struct ccs_request_info *r);
 static int __ccs_chmod_permission(struct dentry *dentry,
 				  struct vfsmount *vfsmnt, mode_t mode);
 static int __ccs_chown_permission(struct dentry *dentry,
@@ -272,6 +141,8 @@
 static int __ccs_open_permission(struct dentry *dentry, struct vfsmount *mnt,
 				 const int flag);
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18) || (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33) && defined(CONFIG_SYSCTL_SYSCALL))
+static int ccs_sysctl_permission(enum ccs_mac_index type,
+				 const struct ccs_path_info *filename);
 static int __ccs_parse_table(int __user *name, int nlen, void __user *oldval,
 			     void __user *newval, struct ctl_table *table);
 #endif
@@ -294,11 +165,8 @@
 static int __ccs_uselib_permission(struct dentry *dentry,
 				   struct vfsmount *mnt);
 #endif
-static int ccs_execute_path(struct linux_binprm *bprm,
-			    struct ccs_path_info *name);
-static int ccs_execute_permission(struct ccs_request_info *r,
-				  const struct ccs_path_info *filename);
-static int ccs_find_next_domain(struct ccs_execve *ee);
+static int ccs_execute_path(struct linux_binprm *bprm, struct path *path);
+static int ccs_find_next_domain(struct ccs_request_info *r);
 static int ccs_get_path(const char *pathname, struct path *path);
 static int ccs_kern_path(const char *pathname, int flags, struct path *path);
 static int ccs_mkdev_perm(const u8 operation, struct dentry *dentry,
@@ -317,49 +185,39 @@
 static int ccs_old_pivot_root_permission(struct nameidata *old_nd,
 					 struct nameidata *new_nd);
 #endif
-static int ccs_path2_perm(const u8 operation, struct dentry *dentry1,
-			  struct vfsmount *mnt1, struct dentry *dentry2,
-			  struct vfsmount *mnt2);
-static int ccs_path_number_perm(const u8 type, struct dentry *dentry,
-				struct vfsmount *vfsmnt, unsigned long number);
-static int ccs_path_perm(const u8 operation, struct dentry *dentry,
-			 struct vfsmount *mnt);
-static int ccs_path_permission(u8 operation,
-			       const struct ccs_path_info *filename,
-			       struct ccs_obj_info *obj);
+static int ccs_path2_perm(const enum ccs_mac_index operation,
+			  struct dentry *dentry1, struct vfsmount *mnt1,
+			  struct dentry *dentry2, struct vfsmount *mnt2);
+static int ccs_path_number_perm(const enum ccs_mac_index type,
+				struct dentry *dentry, struct vfsmount *vfsmnt,
+				unsigned long number);
+static int ccs_path_perm(const enum ccs_mac_index operation,
+			 struct dentry *dentry, struct vfsmount *mnt);
 static int ccs_start_execve(struct linux_binprm *bprm,
-			    struct ccs_execve **eep);
+			    struct ccs_request_info **rp);
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
 static void __ccs_clear_open_mode(void);
 static void __ccs_save_open_mode(int mode);
 #endif
-static void ccs_add_slash(struct ccs_path_info *buf);
 static void ccs_check_auto_domain_transition(void);
-static void ccs_finish_execve(int retval, struct ccs_execve *ee);
+static void ccs_clear_request_info(struct ccs_request_info *r);
+static void ccs_finish_execve(int retval, struct ccs_request_info *r);
 
 #ifdef CONFIG_CCSECURITY_MISC
-static bool ccs_check_env_acl(struct ccs_request_info *r,
-			      const struct ccs_acl_info *ptr);
 static int ccs_env_perm(struct ccs_request_info *r, const char *env);
-static int ccs_environ(struct ccs_execve *ee);
+static int ccs_environ(struct ccs_request_info *r);
 #endif
 
 #ifdef CONFIG_CCSECURITY_CAPABILITY
 static bool __ccs_capable(const u8 operation);
-static bool ccs_check_capability_acl(struct ccs_request_info *r,
-				     const struct ccs_acl_info *ptr);
 static bool ccs_kernel_service(void);
 static int __ccs_ptrace_permission(long request, long pid);
 static int __ccs_socket_create_permission(int family, int type, int protocol);
 #endif
 
 #ifdef CONFIG_CCSECURITY_NETWORK
-static bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
+static bool ccs_address_matches_group(const bool is_ipv6, const u8 *address,
 				      const struct ccs_group *group);
-static bool ccs_check_inet_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr);
-static bool ccs_check_unix_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr);
 static bool ccs_kernel_service(void);
 static int __ccs_socket_bind_permission(struct socket *sock,
 					struct sockaddr *addr, int addr_len);
@@ -389,8 +247,6 @@
 #endif
 
 #ifdef CONFIG_CCSECURITY_IPC
-static bool ccs_check_ptrace_acl(struct ccs_request_info *r,
-				 const struct ccs_acl_info *ptr);
 static int __ccs_ptrace_permission(long request, long pid);
 #endif
 
@@ -400,16 +256,12 @@
 #endif
 
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-static bool ccs_find_execute_handler(struct ccs_execve *ee, const u8 type);
-static int ccs_try_alt_exec(struct ccs_execve *ee);
+static bool ccs_find_execute_handler(struct ccs_request_info *r,
+				     const enum ccs_mac_index type);
+static int ccs_try_alt_exec(struct ccs_request_info *r);
 static void ccs_unescape(unsigned char *dest);
 #endif
 
-#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
-static bool ccs_check_task_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr);
-#endif
-
 /***** SECTION4: Standalone functions section *****/
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
@@ -661,8 +513,8 @@
 /* The list for "struct ccs_domain_info". */
 LIST_HEAD(ccs_domain_list);
 
-/* The list for inverse mode. */
-LIST_HEAD(ccs_inversed_acl_list);
+/* The list for ACL policy. */
+struct list_head ccs_acl_list[CCS_MAX_MAC_INDEX];
 
 /***** SECTION6: Dependent functions section *****/
 
@@ -680,8 +532,6 @@
 				   const struct ccs_group *group)
 {
 	struct ccs_path_group *member;
-	if (group == &ccs_group_any)
-		return true;
 	list_for_each_entry_srcu(member, &group->member_list, head.list,
 				 &ccs_ss) {
 		if (member->head.is_deleted)
@@ -710,14 +560,11 @@
 {
 	struct ccs_number_group *member;
 	bool matched = false;
-	if (group == &ccs_group_any)
-		return true;
 	list_for_each_entry_srcu(member, &group->member_list, head.list,
 				 &ccs_ss) {
 		if (member->head.is_deleted)
 			continue;
-		if (min > member->number.values[1] ||
-		    max < member->number.values[0])
+		if (min > member->value[1] || max < member->value[0])
 			continue;
 		matched = true;
 		break;
@@ -726,32 +573,6 @@
 }
 
 /**
- * ccs_check_use_group_acl - Do recursive permission check.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true on match, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static bool ccs_check_use_group_acl(struct ccs_request_info *r,
-				    struct ccs_acl_info *ptr)
-{
-	const struct ccs_use_group_acl *acl = container_of(ptr, typeof(*acl),
-							   head);
-	const struct list_head *list = &acl->group->member_list;
-	list_for_each_entry_srcu(ptr, list, list, &ccs_ss) {
-		if (!ptr->type == CCS_TYPE_USE_GROUP_ACL)
-			continue;
-		if (!ccs_check_entry(r, ptr) || !ccs_condition(r, ptr->cond))
-			continue;
-		return !acl->is_not;
-	}
-	return acl->is_not;
-}
-
-/**
  * ccs_check_entry - Do permission check.
  *
  * @r:   Pointer to "struct ccs_request_info".
@@ -764,51 +585,11 @@
 static bool ccs_check_entry(struct ccs_request_info *r,
 			    struct ccs_acl_info *ptr)
 {
-	if (ptr->is_deleted || ptr->type != r->param_type)
-		return false;
-	switch (r->param_type) {
-	case CCS_TYPE_EXECUTE_ACL:
-		return ccs_check_execute_acl(r, ptr);
-	case CCS_TYPE_PATH_ACL:
-		return ccs_check_path_acl(r, ptr);
-	case CCS_TYPE_PATH2_ACL:
-		return ccs_check_path2_acl(r, ptr);
-	case CCS_TYPE_PATH_NUMBER_ACL:
-		return ccs_check_path_number_acl(r, ptr);
-	case CCS_TYPE_MKDEV_ACL:
-		return ccs_check_mkdev_acl(r, ptr);
-	case CCS_TYPE_MOUNT_ACL:
-		return ccs_check_mount_acl(r, ptr);
-#ifdef CONFIG_CCSECURITY_MISC
-	case CCS_TYPE_ENV_ACL:
-		return ccs_check_env_acl(r, ptr);
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-	case CCS_TYPE_CAPABILITY_ACL:
-		return ccs_check_capability_acl(r, ptr);
-#endif
-#ifdef CONFIG_CCSECURITY_NETWORK
-	case CCS_TYPE_INET_ACL:
-		return ccs_check_inet_acl(r, ptr);
-	case CCS_TYPE_UNIX_ACL:
-		return ccs_check_unix_acl(r, ptr);
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-	case CCS_TYPE_PTRACE_ACL:
-		return ccs_check_ptrace_acl(r, ptr);
-#endif
-#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
-	case CCS_TYPE_MANUAL_TASK_ACL:
-		return ccs_check_task_acl(r, ptr);
-#endif
-	case CCS_TYPE_USE_GROUP_ACL:
-		return ccs_check_use_group_acl(r, ptr);
-	}
-	return true;
+	return !ptr->is_deleted && ccs_condition(r, ptr->cond);
 }
 
 /**
- * ccs_check_inverselist - Do permission check.
+ * ccs_check_acl_list - Do permission check.
  *
  * @r: Pointer to "struct ccs_request_info".
  *
@@ -816,179 +597,157 @@
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_check_inverselist(struct ccs_request_info *r)
+static int ccs_check_acl_list(struct ccs_request_info *r)
 {
 	struct ccs_acl_info *ptr;
-	const struct ccs_path_info *self = ccs_current_domain()->domainname;
-retry_all:
-	list_for_each_entry_srcu(ptr, &ccs_inversed_acl_list, list, &ccs_ss) {
-		struct ccs_domain_info *domain;
-		int error;
-		if (ptr->mode == CCS_CONFIG_DISABLED)
+	int error = 0;
+	const struct ccs_path_info *transition = NULL;
+	const struct ccs_path_info *handler_path = NULL;
+	struct list_head * const list = &ccs_acl_list[r->type];
+	r->matched_acl = NULL;
+	list_for_each_entry_srcu(ptr, list, list, &ccs_ss) {
+		struct ccs_acl_info *ptr2;
+retry:
+		if (ptr->mode == CCS_CONFIG_DISABLED ||
+		    !ccs_check_entry(r, ptr))
 			continue;
-		if (!ccs_check_entry(r, ptr))
-			continue;
-		if (!ccs_condition(r, ptr->cond))
-			continue;
+		r->matched_acl = ptr;
 		r->mode = ptr->mode;
-		list_for_each_entry_srcu(domain, &ptr->domain_list, list,
+		r->granted = false;
+		if (0 && r->type == CCS_MAC_FILE_EXECUTE)
+			printk(KERN_INFO "Checking sub ACL for %p\n", ptr);
+		list_for_each_entry_srcu(ptr2, &ptr->acl_info_list, list,
 					 &ccs_ss) {
-			if (!ccs_pathcmp(self, domain->domainname) &&
-			    ccs_condition(r, domain->cond))
-				goto next;
+			if (!ccs_check_entry(r, ptr2))
+				continue;
+			if (ptr2->is_deny) {
+				/* Use enforcing mode for deny lines. */
+				r->mode = CCS_CONFIG_ENFORCING;
+				r->granted = false;
+			} else {
+				r->granted = true;
+			}
+			break;
 		}
-		/* Did not match. */
-		r->granted = false;
+		if (0 && r->type == CCS_MAC_FILE_EXECUTE)
+			printk(KERN_INFO "%s sub ACL for %p\n",
+			       r->granted ? "Matched" : "Not matched", ptr);
 		error = ccs_audit_log(r);
+		if (!error) {
+			/* Use the first matching domain transition entry. */
+			if (!transition)
+				transition = r->transition;
+			else
+				r->transition = transition;
+			/* Use the first matching execute handler entry. */
+			if (!handler_path)
+				handler_path = r->handler_path;
+			else
+				r->handler_path = handler_path;
+			continue;
+		}
 		if (error == CCS_RETRY_REQUEST)
-			goto retry_all;
-		if (error)
-			return error;
-next:
-		r->granted = true;
-		ccs_audit_log(r);
+			goto retry;
+		break;
 	}
-	return 0;
+	return error;
 }
 
 /**
  * ccs_check_acl - Do permission check.
  *
- * @r: Pointer to "struct ccs_request_info".
+ * @r:     Pointer to "struct ccs_request_info".
+ * @clear: True to cleanup @r before return, false otherwise.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_check_acl(struct ccs_request_info *r)
+int ccs_check_acl(struct ccs_request_info *r, const bool clear)
 {
-	const struct ccs_domain_info *domain = ccs_current_domain();
-	struct ccs_acl_info *ptr;
 	int error;
 	const int idx = ccs_read_lock();
-	r->inversed = true;
-	error = ccs_check_inverselist(r);
-	if (error)
-		goto done;
-	r->inversed = false;
-	do {
-		const struct list_head *list = &domain->acl_info_list;
-		list_for_each_entry_srcu(ptr, list, list, &ccs_ss) {
-			if (!ccs_check_entry(r, ptr))
-				continue;
-			if (!ccs_condition(r, ptr->cond))
-				continue;
-			r->matched_acl = ptr;
-			r->granted = true;
-			ccs_audit_log(r);
-			error = 0;
-			goto done;
-		}
-		r->granted = false;
-		error = ccs_audit_log(r);
-	} while (error == CCS_RETRY_REQUEST);
-done:
+	error = ccs_check_acl_list(r);
 	ccs_read_unlock(idx);
+	if (clear)
+		ccs_clear_request_info(r);
 	return error;
 }
 
 /**
- * ccs_transition_type - Get domain transition type.
+ * ccs_find_next_domain - Find a domain.
  *
  * @r: Pointer to "struct ccs_request_info".
  *
- * Returns pointer to "struct ccs_path_info" if found one, NULL otheriwse.
- *
- * Caller holds ccs_read_lock().
- */
-static const struct ccs_path_info *ccs_transition_type
-(struct ccs_request_info *r)
-{
-	const struct list_head * const list = &ccs_current_namespace()->
-		default_transition_list;
-	struct ccs_acl_info *ptr;
-	list_for_each_entry_srcu(ptr, list, list, &ccs_ss) {
-		if (ptr->is_deleted)
-			continue;
-		if (!ccs_check_execute_acl(r, ptr))
-			continue;
-		if (!ccs_condition(r, ptr->cond))
-			continue;
-		return container_of(ptr, struct ccs_execute_acl, head)->
-			transit;
-	}
-	return NULL;
-}
-
-/**
- * ccs_find_next_domain - Find a domain.
- *
- * @ee: Pointer to "struct ccs_execve".
- *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_find_next_domain(struct ccs_execve *ee)
+static int ccs_find_next_domain(struct ccs_request_info *r)
 {
-	struct ccs_request_info *r = &ee->r;
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-	const struct ccs_path_info *handler = ee->handler;
-#endif
 	struct ccs_domain_info *domain = NULL;
 	struct ccs_domain_info * const old_domain = ccs_current_domain();
 	struct ccs_security *task = ccs_current_security();
-	struct ccs_path_info exename;
 	int retval;
 	const char *domainname;
 
-	/* Get symlink's pathname of program. */
-	retval = ccs_execute_path(ee->bprm, &exename);
+	/* Get symlink's dentry/vfsmount. */
+	retval = ccs_execute_path(r->bprm, &r->obj.path[1]);
 	if (retval < 0)
 		return retval;
+	ccs_populate_patharg(r, false);
+	retval = -ENOMEM;
+	if (!r->param.s[1])
+		goto out;
 
+	if (0)
+		printk(KERN_DEBUG "%d %p %p\n",
+		       __LINE__, r->param.s[0], r->param.s[1]);
+
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-	if (handler) {
+	if (r->handler_path) {
 		/* No permission check for execute handler. */
-		if (ccs_pathcmp(&exename, handler)) {
+		if (ccs_pathcmp(r->param.s[1], r->handler_path)) {
 			/* Failed to verify execute handler. */
 			static u8 counter = 20;
 			if (counter) {
 				counter--;
 				printk(KERN_WARNING "Failed to verify: %s\n",
-				       handler->name);
+				       r->handler_path->name);
 			}
+			retval = -EINVAL;
 			goto out;
 		}
 	} else
 #endif
 	{
 		/* Check execute permission. */
-		retval = ccs_execute_permission(r, &exename);
+		r->type = CCS_MAC_FILE_EXECUTE;
+		retval = ccs_check_acl(r, false);
 		if (retval < 0)
 			goto out;
 	}
-	if (!ee->transition)
-		ee->transition = ccs_transition_type(r);
-	if (!ee->transition)
-		ee->transition = old_domain->default_transition;
-	BUG_ON(!ee->transition);
-	domainname = ee->transition->name;
+
+	if (0)
+		printk(KERN_DEBUG "%d %p %p %p\n",
+		       __LINE__, r->param.s[0], r->param.s[1],
+		       r->transition);
+
+	if (r->transition)
+		domainname = r->transition->name;
+	else
+		domainname = "child";
 	if (!strcmp(domainname, "keep"))
 		/* Keep current domain. */
 		domain = old_domain;
 	else if (!strcmp(domainname, "child"))
 		/* Normal domain transition. */
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%s %s",
-			 old_domain->domainname->name, exename.name);
-	else if (*domainname == '<')
-		/* Transit to the specified domain. */
-		strncpy(ee->tmp, domainname, CCS_EXEC_TMPSIZE - 1);
+		snprintf(r->tmp, CCS_EXEC_TMPSIZE - 1, "%s\\_%s",
+			 old_domain->domainname->name, r->param.s[1]->name);
 	else if (old_domain == &ccs_kernel_domain && !ccs_policy_loaded)
 		/* Do not transit before starting /sbin/init. */
 		domain = old_domain;
 	else
-		/* Transit to the child domain. */
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%s %s",
-			 old_domain->domainname->name, exename.name);
+		/* Transit to the specified domain. */
+		strncpy(r->tmp, domainname, CCS_EXEC_TMPSIZE - 1);
 	/*
 	 * Tell GC that I started execve().
 	 * Also, tell open_exec() to check read permission.
@@ -1006,15 +765,20 @@
 	 * enforcing mode.
 	 */
 	if (!domain)
-		domain = ccs_assign_domain(ee->tmp, true);
+		domain = ccs_assign_domain(r->tmp);
 	if (domain) {
 		retval = 0;
+		ccs_clear_request_info(r);
 		goto out;
 	}
-	printk(KERN_WARNING "ERROR: Domain '%s' not ready.\n", ee->tmp);
+	printk(KERN_WARNING "ERROR: Domain '%s' not ready.\n", r->tmp);
 	retval = -ENOMEM;
 out:
-	kfree(exename.name);
+	/* Drop refcount obtained by ccs_execute_path(). */
+	if (r->obj.path[1].dentry) {
+		path_put(&r->obj.path[1]);
+		r->obj.path[1].dentry = NULL;
+	}
 	return retval;
 }
 
@@ -1042,10 +806,6 @@
 			continue;
 		}
 		c = *src++;
-		if (c == '\\') {
-			*dest++ = c;
-			continue;
-		}
 		if (c < '0' || c > '3')
 			break;
 		d = *src++;
@@ -1062,11 +822,11 @@
 /**
  * ccs_try_alt_exec - Try to start execute handler.
  *
- * @ee: Pointer to "struct ccs_execve".
+ * @r: Pointer to "struct ccs_request_info".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_try_alt_exec(struct ccs_execve *ee)
+static int ccs_try_alt_exec(struct ccs_request_info *r)
 {
 	/*
 	 * Contents of modified bprm.
@@ -1104,22 +864,24 @@
 	 * modified bprm->argv[bprm->envc + bprm->argc + 6]
 	 *     = original bprm->envp[bprm->envc - 1]
 	 */
-	struct linux_binprm *bprm = ee->bprm;
+	struct linux_binprm *bprm = r->bprm;
 	struct file *filp;
 	int retval;
 	const int original_argc = bprm->argc;
 	const int original_envc = bprm->envc;
 
+	ccs_clear_request_info(r);
+
 	/* Close the requested program's dentry. */
-	ee->obj.path1.dentry = NULL;
-	ee->obj.path1.mnt = NULL;
-	ee->obj.validate_done = false;
+	r->obj.path[0].dentry = NULL;
+	r->obj.path[0].mnt = NULL;
+	r->obj.validate_done = false;
 	allow_write_access(bprm->file);
 	fput(bprm->file);
 	bprm->file = NULL;
 
 	/* Invalidate page dump cache. */
-	ee->dump.page = NULL;
+	r->dump.page = NULL;
 
 	/* Move envp[] to argv[] */
 	bprm->argc += bprm->envc;
@@ -1127,16 +889,16 @@
 
 	/* Set argv[6] */
 	{
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%d", original_envc);
-		retval = ccs_copy_argv(ee->tmp, bprm);
+		snprintf(r->tmp, CCS_EXEC_TMPSIZE - 1, "%d", original_envc);
+		retval = ccs_copy_argv(r->tmp, bprm);
 		if (retval < 0)
 			goto out;
 	}
 
 	/* Set argv[5] */
 	{
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%d", original_argc);
-		retval = ccs_copy_argv(ee->tmp, bprm);
+		snprintf(r->tmp, CCS_EXEC_TMPSIZE - 1, "%d", original_argc);
+		retval = ccs_copy_argv(r->tmp, bprm);
 		if (retval < 0)
 			goto out;
 	}
@@ -1150,13 +912,13 @@
 
 	/* Set argv[3] */
 	{
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1,
+		snprintf(r->tmp, CCS_EXEC_TMPSIZE - 1,
 			 "pid=%d uid=%d gid=%d euid=%d egid=%d suid=%d "
 			 "sgid=%d fsuid=%d fsgid=%d", ccs_sys_getpid(),
 			 current_uid(), current_gid(), current_euid(),
 			 current_egid(), current_suid(), current_sgid(),
 			 current_fsuid(), current_fsgid());
-		retval = ccs_copy_argv(ee->tmp, bprm);
+		retval = ccs_copy_argv(r->tmp, bprm);
 		if (retval < 0)
 			goto out;
 	}
@@ -1171,8 +933,8 @@
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
 			retval = ccs_copy_argv("<unknown>", bprm);
 #else
-			snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "<unknown>");
-			retval = ccs_copy_argv(ee->tmp, bprm);
+			snprintf(r->tmp, CCS_EXEC_TMPSIZE - 1, "<unknown>");
+			retval = ccs_copy_argv(r->tmp, bprm);
 #endif
 		}
 		if (retval < 0)
@@ -1185,9 +947,9 @@
 		retval = ccs_copy_argv(ccs_current_domain()->domainname->name,
 				       bprm);
 #else
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%s",
+		snprintf(r->tmp, CCS_EXEC_TMPSIZE - 1, "%s",
 			 ccs_current_domain()->domainname->name);
-		retval = ccs_copy_argv(ee->tmp, bprm);
+		retval = ccs_copy_argv(r->tmp, bprm);
 #endif
 		if (retval < 0)
 			goto out;
@@ -1207,29 +969,28 @@
 			goto out;
 		}
 		root_len = strlen(cp);
-		retval = strncmp(ee->handler->name, cp, root_len);
+		retval = strncmp(r->handler_path->name, cp, root_len);
 		root_len--;
 		kfree(cp);
 		if (retval) {
 			retval = -ENOENT;
 			goto out;
 		}
-		handler_len = ee->handler->total_len + 1;
-		cp = kmalloc(handler_len, CCS_GFP_FLAGS);
-		if (!cp) {
+		handler_len = r->handler_path->total_len + 1;
+		/* r->handler is released by ccs_finish_execve(). */
+		r->handler = kmalloc(handler_len, CCS_GFP_FLAGS);
+		if (!r->handler) {
 			retval = -ENOMEM;
 			goto out;
 		}
-		/* ee->handler_path is released by ccs_finish_execve(). */
-		ee->handler_path = cp;
 		/* Adjust root directory for open_exec(). */
-		memmove(cp, ee->handler->name + root_len,
+		memmove(r->handler, r->handler_path->name + root_len,
 			handler_len - root_len);
-		ccs_unescape(cp);
+		ccs_unescape(r->handler);
 		retval = -ENOENT;
-		if (*cp != '/')
+		if (*r->handler != '/')
 			goto out;
-		retval = ccs_copy_argv(cp, bprm);
+		retval = ccs_copy_argv(r->handler, bprm);
 		if (retval < 0)
 			goto out;
 	}
@@ -1242,24 +1003,22 @@
 	/*
 	 * OK, now restart the process with execute handler program's dentry.
 	 */
-	filp = open_exec(ee->handler_path);
+	filp = open_exec(r->handler);
 	if (IS_ERR(filp)) {
 		retval = PTR_ERR(filp);
 		goto out;
 	}
-	ee->obj.path1.dentry = filp->f_dentry;
-	ee->obj.path1.mnt = filp->f_vfsmnt;
+	r->obj.path[0].dentry = filp->f_dentry;
+	r->obj.path[0].mnt = filp->f_vfsmnt;
 	bprm->file = filp;
-	bprm->filename = ee->handler_path;
+	bprm->filename = r->handler;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 	bprm->interp = bprm->filename;
 #endif
 	retval = prepare_binprm(bprm);
 	if (retval < 0)
 		goto out;
-	ee->r.dont_sleep_on_enforce_error = true;
-	retval = ccs_find_next_domain(ee);
-	ee->r.dont_sleep_on_enforce_error = false;
+	retval = ccs_find_next_domain(r);
 out:
 	return retval;
 }
@@ -1267,31 +1026,25 @@
 /**
  * ccs_find_execute_handler - Find an execute handler.
  *
- * @ee:   Pointer to "struct ccs_execve".
+ * @r:    Pointer to "struct ccs_request_info".
  * @type: Type of execute handler.
  *
  * Returns true if found, false otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_find_execute_handler(struct ccs_execve *ee, const u8 type)
+static bool ccs_find_execute_handler(struct ccs_request_info *r,
+				     const enum ccs_mac_index type)
 {
-	struct ccs_request_info *r = &ee->r;
 	/*
 	 * To avoid infinite execute handler loop, don't use execute handler
 	 * if the current process is marked as execute handler.
 	 */
 	if (ccs_current_flags() & CCS_TASK_IS_EXECUTE_HANDLER)
 		return false;
-	r->param_type = type;
-	ccs_check_acl(r);
-	if (!r->granted)
-		return false;
-	ee->handler = container_of(r->matched_acl, struct ccs_handler_acl,
-				   head)->handler;
-	ee->transition = container_of(r->matched_acl, struct ccs_handler_acl,
-				      head)->transit;
-	return true;
+	r->type = type;
+	ccs_check_acl(r, false);
+	return r->granted && r->matched_acl;
 }
 
 #endif
@@ -1356,68 +1109,66 @@
  * ccs_start_execve - Prepare for execve() operation.
  *
  * @bprm: Pointer to "struct linux_binprm".
- * @eep:  Pointer to "struct ccs_execve *".
+ * @rp:   Pointer to "struct ccs_request_info *".
  *
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_start_execve(struct linux_binprm *bprm,
-			    struct ccs_execve **eep)
+			    struct ccs_request_info **rp)
 {
 	int retval;
 	struct ccs_security *task = ccs_current_security();
-	struct ccs_execve *ee;
+	struct ccs_request_info *r;
 	int idx;
-	*eep = NULL;
+	*rp = NULL;
 	ccs_check_auto_domain_transition();
-	ee = kzalloc(sizeof(*ee), CCS_GFP_FLAGS);
-	if (!ee)
+	r = kzalloc(sizeof(*r), CCS_GFP_FLAGS);
+	if (!r)
 		return -ENOMEM;
-	ee->tmp = kzalloc(CCS_EXEC_TMPSIZE, CCS_GFP_FLAGS);
-	if (!ee->tmp) {
-		kfree(ee);
+	r->tmp = kzalloc(CCS_EXEC_TMPSIZE, CCS_GFP_FLAGS);
+	if (!r->tmp) {
+		kfree(r);
 		return -ENOMEM;
 	}
 	idx = ccs_read_lock();
-	/* ee->dump->data is allocated by ccs_dump_page(). */
-	ee->previous_domain = task->ccs_domain_info;
+	/* r->dump->data is allocated by ccs_dump_page(). */
+	r->previous_domain = task->ccs_domain_info;
 	/* Clear manager flag. */
 	task->ccs_flags &= ~CCS_TASK_IS_MANAGER;
-	*eep = ee;
-	ee->r.ee = ee;
-	ee->bprm = bprm;
-	ee->r.obj = &ee->obj;
-	ee->obj.path1.dentry = bprm->file->f_dentry;
-	ee->obj.path1.mnt = bprm->file->f_vfsmnt;
+	*rp = r;
+	r->bprm = bprm;
+	r->obj.path[0].dentry = bprm->file->f_dentry;
+	r->obj.path[0].mnt = bprm->file->f_vfsmnt;
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 	/*
 	 * No need to call ccs_environ() for execute handler because envp[] is
 	 * moved to argv[].
 	 */
-	if (ccs_find_execute_handler(ee, CCS_TYPE_AUTO_EXECUTE_HANDLER)) {
-		retval = ccs_try_alt_exec(ee);
+	if (ccs_find_execute_handler(r, CCS_MAC_AUTO_EXECUTE_HANDLER)) {
+		retval = ccs_try_alt_exec(r);
 		goto done;
 	}
 #endif
-	retval = ccs_find_next_domain(ee);
+	retval = ccs_find_next_domain(r);
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 	if (retval == -EPERM &&
-	    ccs_find_execute_handler(ee, CCS_TYPE_DENIED_EXECUTE_HANDLER)) {
-		retval = ccs_try_alt_exec(ee);
+	    ccs_find_execute_handler(r, CCS_MAC_DENIED_EXECUTE_HANDLER)) {
+		retval = ccs_try_alt_exec(r);
 		goto done;
 	}
 #endif
 #ifdef CONFIG_CCSECURITY_MISC
 	if (!retval && bprm->envc)
-		retval = ccs_environ(ee);
+		retval = ccs_environ(r);
 #endif
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 done:
 #endif
 	ccs_read_unlock(idx);
-	kfree(ee->tmp);
-	ee->tmp = NULL;
-	kfree(ee->dump.data);
-	ee->dump.data = NULL;
+	kfree(r->tmp);
+	r->tmp = NULL;
+	kfree(r->dump.data);
+	r->dump.data = NULL;
 	return retval;
 }
 
@@ -1425,17 +1176,18 @@
  * ccs_finish_execve - Clean up execve() operation.
  *
  * @retval: Return code of an execve() operation.
- * @ee:     Pointer to "struct ccs_execve".
+ * @r:      Pointer to "struct ccs_request_info".
  *
  * Returns nothing.
  */
-static void ccs_finish_execve(int retval, struct ccs_execve *ee)
+static void ccs_finish_execve(int retval, struct ccs_request_info *r)
 {
-	struct ccs_security *task = ccs_current_security();
-	if (!ee)
+	struct ccs_security *task;
+	if (!r)
 		return;
+	task = ccs_current_security();
 	if (retval < 0) {
-		task->ccs_domain_info = ee->previous_domain;
+		task->ccs_domain_info = r->previous_domain;
 		/*
 		 * Make task->ccs_domain_info visible to GC before changing
 		 * task->ccs_flags.
@@ -1443,7 +1195,7 @@
 		smp_wmb();
 	} else {
 		/* Mark the current process as execute handler. */
-		if (ee->handler)
+		if (r->handler)
 			task->ccs_flags |= CCS_TASK_IS_EXECUTE_HANDLER;
 		/* Mark the current process as normal process. */
 		else
@@ -1451,8 +1203,9 @@
 	}
 	/* Tell GC that I finished execve(). */
 	task->ccs_flags &= ~CCS_TASK_IS_IN_EXECVE;
-	kfree(ee->handler_path);
-	kfree(ee);
+	ccs_clear_request_info(r);
+	kfree(r->handler_path);
+	kfree(r);
 }
 
 /**
@@ -1473,16 +1226,16 @@
 static int __ccs_search_binary_handler(struct linux_binprm *bprm,
 				       struct pt_regs *regs)
 {
-	struct ccs_execve *ee;
+	struct ccs_request_info *r;
 	int retval;
 #ifndef CONFIG_CCSECURITY_OMIT_USERSPACE_LOADER
 	if (!ccs_policy_loaded)
 		ccsecurity_exports.load_policy(bprm->filename);
 #endif
-	retval = ccs_start_execve(bprm, &ee);
+	retval = ccs_start_execve(bprm, &r);
 	if (!retval)
 		retval = search_binary_handler(bprm, regs);
-	ccs_finish_execve(retval, ee);
+	ccs_finish_execve(retval, r);
 	return retval;
 }
 
@@ -1609,76 +1362,33 @@
 }
 
 /**
- * ccs_execute_path - Get program's pathname.
+ * ccs_execute_path - Get dentry/vfsmount of a program.
  *
  * @bprm: Pointer to "struct linux_binprm".
- * @name: Pointer to "struct ccs_path_info".
+ * @path: Pointer to "struct path".
  *
  * Returns 0 on success, negative value otherwise.
- *
- * This function uses kzalloc(), so caller must kfree() if this function
- * didn't return NULL.
  */
-static int ccs_execute_path(struct linux_binprm *bprm,
-			    struct ccs_path_info *name)
+static int ccs_execute_path(struct linux_binprm *bprm, struct path *path)
 {
-	char *buf;
 	/*
 	 * Follow symlinks if the requested pathname is on procfs, for
 	 * /proc/\$/exe is meaningless.
 	 */
-	/*
-	 * Force use of normal pathnames in order to use this pathname for
-	 * making domainnames.
-	 */
-	if (bprm->file->f_dentry->d_sb->s_magic == PROC_SUPER_MAGIC) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
-		struct path path = { bprm->file->f_vfsmnt,
-				     bprm->file->f_dentry };
-		buf = ccs_realpath2(&path, true);
-#else
-		buf = ccs_realpath2(&bprm->file->f_path, true);
-#endif
-	} else {
-		struct path path;
+	const unsigned int follow =
+		(bprm->file->f_dentry->d_sb->s_magic == PROC_SUPER_MAGIC) ?
+		LOOKUP_FOLLOW : 0;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
-		if (ccs_kern_path(bprm->filename, 0, &path))
-			return -ENOENT;
+	if (ccs_kern_path(bprm->filename, follow, path))
+		return -ENOENT;
 #else
-		if (ccs_kern_path(bprm->filename, LOOKUP_POSITIVE, &path))
-			return -ENOENT;
+	if (ccs_kern_path(bprm->filename, follow | LOOKUP_POSITIVE, path))
+		return -ENOENT;
 #endif
-		buf = ccs_realpath2(&path, true);
-		path_put(&path);
-	}
-	if (!buf)
-		return -ENOMEM;
-	name->name = buf;
-	ccs_fill_path_info(name);
 	return 0;
 }
 
 /**
- * ccs_check_mount_acl - Check permission for path path path number operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_mount_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr)
-{
-	const struct ccs_mount_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return ccs_compare_number_union(r->param.mount.flags, &acl->flags) &&
-		ccs_compare_name_union(r->param.mount.type, &acl->fs_type) &&
-		ccs_compare_name_union(r->param.mount.dir, &acl->dir_name) &&
-		(!r->param.mount.need_dev ||
-		 ccs_compare_name_union(r->param.mount.dev, &acl->dev_name));
-}
-
-/**
  * ccs_mount_acl - Check permission for mount() operation.
  *
  * @dev_name: Name of device file. Maybe NULL.
@@ -1692,96 +1402,58 @@
 			 unsigned long flags)
 {
 	struct ccs_request_info r = { };
-	struct ccs_obj_info obj = { };
-	struct file_system_type *fstype = NULL;
-	const char *requested_type = NULL;
-	const char *requested_dir_name = NULL;
-	const char *requested_dev_name = NULL;
 	struct ccs_path_info rtype;
-	struct ccs_path_info rdev;
-	struct ccs_path_info rdir;
 	int need_dev = 0;
 	int error = -ENOMEM;
-	r.obj = &obj;
 
-	/* Get fstype. */
-	requested_type = ccs_encode(type);
-	if (!requested_type)
-		goto out;
-	rtype.name = requested_type;
-	ccs_fill_path_info(&rtype);
-
-	/* Get mount point. */
-	obj.path2 = *dir;
-	requested_dir_name = ccs_realpath(dir);
-	if (!requested_dir_name) {
-		error = -ENOMEM;
-		goto out;
-	}
-	rdir.name = requested_dir_name;
-	ccs_fill_path_info(&rdir);
-
-	/* Compare fs name. */
-	if (type == ccs_mounts[CCS_MOUNT_REMOUNT]) {
+	/* Compare fstype in order to determine type of dev_name argument. */
+	if (type == ccs_mounts[CCS_MOUNT_REMOUNT] ||
+	    type == ccs_mounts[CCS_MOUNT_MAKE_UNBINDABLE] ||
+	    type == ccs_mounts[CCS_MOUNT_MAKE_PRIVATE] ||
+	    type == ccs_mounts[CCS_MOUNT_MAKE_SLAVE] ||
+	    type == ccs_mounts[CCS_MOUNT_MAKE_SHARED]) {
 		/* dev_name is ignored. */
-	} else if (type == ccs_mounts[CCS_MOUNT_MAKE_UNBINDABLE] ||
-		   type == ccs_mounts[CCS_MOUNT_MAKE_PRIVATE] ||
-		   type == ccs_mounts[CCS_MOUNT_MAKE_SLAVE] ||
-		   type == ccs_mounts[CCS_MOUNT_MAKE_SHARED]) {
-		/* dev_name is ignored. */
 	} else if (type == ccs_mounts[CCS_MOUNT_BIND] ||
 		   type == ccs_mounts[CCS_MOUNT_MOVE]) {
 		need_dev = -1; /* dev_name is a directory */
 	} else {
-		fstype = get_fs_type(type);
-		if (!fstype) {
-			error = -ENODEV;
-			goto out;
-		}
+		struct file_system_type *fstype = get_fs_type(type);
+		if (!fstype)
+			return -ENODEV;
 		if (fstype->fs_flags & FS_REQUIRES_DEV)
-			/* dev_name is a block device file. */
-			need_dev = 1;
+			need_dev = 1; /* dev_name is a block device file. */
+		ccs_put_filesystem(fstype);
 	}
 	if (need_dev) {
 		/* Get mount point or device file. */
-		if (ccs_get_path(dev_name, &obj.path1)) {
-			error = -ENOENT;
-			goto out;
-		}
-		requested_dev_name = ccs_realpath(&obj.path1);
-		if (!requested_dev_name) {
-			error = -ENOENT;
-			goto out;
-		}
+		if (ccs_get_path(dev_name, &r.obj.path[0]))
+			return -ENOENT;
 	} else {
 		/* Map dev_name to "<NULL>" if no dev_name given. */
 		if (!dev_name)
 			dev_name = "<NULL>";
-		requested_dev_name = ccs_encode(dev_name);
-		if (!requested_dev_name) {
-			error = -ENOMEM;
-			goto out;
-		}
+		r.obj.pathname[0].name = ccs_encode(dev_name);
+		if (!r.obj.pathname[0].name)
+			return -ENOMEM;
+		ccs_fill_path_info(&r.obj.pathname[0]);
 	}
-	rdev.name = requested_dev_name;
-	ccs_fill_path_info(&rdev);
-	r.type = CCS_MAC_FILE_MOUNT;
-	r.param_type = CCS_TYPE_MOUNT_ACL;
-	r.param.mount.need_dev = need_dev;
-	r.param.mount.dev = &rdev;
-	r.param.mount.dir = &rdir;
-	r.param.mount.type = &rtype;
-	r.param.mount.flags = flags;
-	error = ccs_check_acl(&r);
-out:
-	kfree(requested_dev_name);
-	kfree(requested_dir_name);
-	if (fstype)
-		ccs_put_filesystem(fstype);
-	kfree(requested_type);
+	/* Remember mount point. */
+	r.obj.path[1] = *dir;
+	/* Remember fstype. */
+	rtype.name = ccs_encode(type);
+	if (rtype.name) {
+		ccs_fill_path_info(&rtype);
+		r.type = CCS_MAC_FILE_MOUNT;
+		r.param.s[2] = &rtype;
+		r.param.i[0] = flags;
+		r.param.i[1] = need_dev;
+		error = ccs_check_acl(&r, false);
+		kfree(rtype.name);
+	}
+	ccs_clear_request_info(&r);
 	/* Drop refcount obtained by ccs_get_path(). */
-	if (obj.path1.dentry)
-		path_put(&obj.path1);
+	if (need_dev)
+		path_put(&r.obj.path[0]);
 	return error;
 }
 
@@ -1858,207 +1530,6 @@
 
 #endif
 
-/**
- * ccs_compare_number_union - Check whether a value matches "struct ccs_number_union" or not.
- *
- * @value: Number to check.
- * @ptr:   Pointer to "struct ccs_number_union".
- *
- * Returns true if @value matches @ptr, false otherwise.
- */
-static bool ccs_compare_number_union(const unsigned long value,
-				     const struct ccs_number_union *ptr)
-{
-	if (ptr->group)
-		return ccs_number_matches_group(value, value, ptr->group) !=
-			ptr->is_not;
-	return value >= ptr->values[0] && value <= ptr->values[1];
-}
-
-/**
- * ccs_compare_name_union - Check whether a name matches "struct ccs_name_union" or not.
- *
- * @name: Pointer to "struct ccs_path_info".
- * @ptr:  Pointer to "struct ccs_name_union".
- *
- * Returns true if @name matches @ptr, false otherwise.
- */
-static bool ccs_compare_name_union(const struct ccs_path_info *name,
-				   const struct ccs_name_union *ptr)
-{
-	if (ptr->group)
-		return ccs_path_matches_group(name, ptr->group) !=
-			ptr->is_not;
-	return ccs_path_matches_pattern(name, ptr->filename);
-}
-
-/**
- * ccs_add_slash - Add trailing '/' if needed.
- *
- * @buf: Pointer to "struct ccs_path_info".
- *
- * Returns nothing.
- *
- * @buf must be generated by ccs_encode() because this function does not
- * allocate memory for adding '/'.
- */
-static void ccs_add_slash(struct ccs_path_info *buf)
-{
-	if (buf->is_dir)
-		return;
-	/* This is OK because ccs_encode() reserves space for appending "/". */
-	strcat((char *) buf->name, "/");
-	ccs_fill_path_info(buf);
-}
-
-/**
- * ccs_get_realpath - Get realpath.
- *
- * @buf:  Pointer to "struct ccs_path_info".
- * @path: Pointer to "struct path". @path->mnt may be NULL.
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_get_realpath(struct ccs_path_info *buf, struct path *path)
-{
-	buf->name = ccs_realpath(path);
-	if (buf->name) {
-		ccs_fill_path_info(buf);
-		return true;
-	}
-	return false;
-}
-
-/**
- * ccs_check_execute_acl - Check permission for execute operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_execute_acl(struct ccs_request_info *r,
-				  const struct ccs_acl_info *ptr)
-{
-	const struct ccs_execute_acl *acl = container_of(ptr, typeof(*acl),
-							 head);
-	return ccs_compare_name_union(r->param.execute.program, &acl->program);
-}
-
-/**
- * ccs_check_path_acl - Check permission for path operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_path_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr)
-{
-	const struct ccs_path_acl *acl = container_of(ptr, typeof(*acl), head);
-	return (ptr->perm & (1 << r->param.path.operation)) &&
-		ccs_compare_name_union(r->param.path.filename, &acl->name);
-}
-
-/**
- * ccs_check_path_number_acl - Check permission for path number operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_path_number_acl(struct ccs_request_info *r,
-				      const struct ccs_acl_info *ptr)
-{
-	const struct ccs_path_number_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return (ptr->perm & (1 << r->param.path_number.operation)) &&
-		ccs_compare_number_union(r->param.path_number.number,
-					 &acl->number) &&
-		ccs_compare_name_union(r->param.path_number.filename,
-				       &acl->name);
-}
-
-/**
- * ccs_check_path2_acl - Check permission for path path operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_path2_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr)
-{
-	const struct ccs_path2_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return (ptr->perm & (1 << r->param.path2.operation)) &&
-		ccs_compare_name_union(r->param.path2.filename1, &acl->name1)
-		&& ccs_compare_name_union(r->param.path2.filename2,
-					  &acl->name2);
-}
-
-/**
- * ccs_check_mkdev_acl - Check permission for path number number number operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_mkdev_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr)
-{
-	const struct ccs_mkdev_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return (ptr->perm & (1 << r->param.mkdev.operation)) &&
-		ccs_compare_number_union(r->param.mkdev.mode, &acl->mode) &&
-		ccs_compare_number_union(r->param.mkdev.major, &acl->major) &&
-		ccs_compare_number_union(r->param.mkdev.minor, &acl->minor) &&
-		ccs_compare_name_union(r->param.mkdev.filename, &acl->name);
-}
-
-/**
- * ccs_path_permission - Check permission for path operation.
- *
- * @operation: Type of operation.
- * @filename:  Filename to check.
- * @obj:       Pointer to "struct ccs_obj_info". Maybe NULL.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_path_permission(u8 operation,
-			       const struct ccs_path_info *filename,
-			       struct ccs_obj_info *obj)
-{
-	struct ccs_request_info r = { };
-	r.type = ccs_p2mac[operation];
-	r.obj = obj;
-	r.param_type = CCS_TYPE_PATH_ACL;
-	r.param.path.filename = filename;
-	r.param.path.operation = operation;
-	return ccs_check_acl(&r);
-}
-
-/**
- * ccs_execute_permission - Check permission for execute operation.
- *
- * @r:        Pointer to "struct ccs_request_info".
- * @filename: Filename to check.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_execute_permission(struct ccs_request_info *r,
-				  const struct ccs_path_info *filename)
-{
-	r->type = CCS_MAC_FILE_EXECUTE;
-	r->param_type = CCS_TYPE_EXECUTE_ACL;
-	r->param.execute.program = filename;
-	return ccs_check_acl(r);
-}
-
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
 
 /**
@@ -2113,10 +1584,7 @@
 static int __ccs_open_permission(struct dentry *dentry, struct vfsmount *mnt,
 				 const int flag)
 {
-	struct ccs_obj_info obj = {
-		.path1.dentry = dentry,
-		.path1.mnt = mnt,
-	};
+	struct ccs_request_info r = { };
 	const u32 ccs_flags = ccs_current_flags();
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
 	const u8 acc_mode = (flag & 3) == 3 ? 0 : ACC_MODE(flag);
@@ -2128,7 +1596,6 @@
 		ACC_MODE(flag);
 #endif
 	int error = 0;
-	struct ccs_path_info buf;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
 	if (current->in_execve && !(ccs_flags & CCS_TASK_IS_IN_EXECVE))
 		return 0;
@@ -2137,38 +1604,26 @@
 	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode))
 		return 0;
 #endif
-	buf.name = NULL;
+	r.obj.path[0].dentry = dentry;
+	r.obj.path[0].mnt = mnt;
 	if (!(ccs_flags & CCS_TASK_IS_IN_EXECVE))
 		ccs_check_auto_domain_transition();
 	if (acc_mode & MAY_READ) {
-		if (!ccs_get_realpath(&buf, &obj.path1)) {
-			error = -ENOMEM;
-			goto out;
-		}
-		error = ccs_path_permission(CCS_TYPE_READ, &buf, &obj);
-		if (error)
-			goto out;
+		r.type = CCS_MAC_FILE_READ;
+		error = ccs_check_acl(&r, false);
 	}
-	if (acc_mode & MAY_WRITE) {
-		if (!buf.name && !ccs_get_realpath(&buf, &obj.path1)) {
-			error = -ENOMEM;
-			goto out;
-		}
-		error = ccs_path_permission((flag & O_APPEND) ?
-					    CCS_TYPE_APPEND :
-					    CCS_TYPE_WRITE, &buf, &obj);
+	if (!error && (acc_mode & MAY_WRITE)) {
+		r.type = (flag & O_APPEND) ? CCS_MAC_FILE_APPEND :
+			CCS_MAC_FILE_WRITE;
+		error = ccs_check_acl(&r, false);
 	}
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
 	if (!error && (flag & O_TRUNC)) {
-		if (!buf.name && !ccs_get_realpath(&buf, &obj.path1)) {
-			error = -ENOMEM;
-			goto out;
-		}
-		error = ccs_path_permission(CCS_TYPE_TRUNCATE, &buf, &obj);
+		r.type = CCS_MAC_FILE_TRUNCATE;
+		error = ccs_check_acl(&r, false);
 	}
 #endif
-out:
-	kfree(buf.name);
+	ccs_clear_request_info(&r);
 	return error;
 }
 
@@ -2192,38 +1647,26 @@
 /**
  * ccs_path_perm - Check permission for "unlink", "rmdir", "truncate", "append", "getattr", "chroot" and "unmount".
  *
- * @operation: Type of operation.
+ * @operation: One of values in "enum ccs_mac_index".
  * @dentry:    Pointer to "struct dentry".
  * @mnt:       Pointer to "struct vfsmount". Maybe NULL.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_path_perm(const u8 operation, struct dentry *dentry,
-			 struct vfsmount *mnt)
+static int ccs_path_perm(const enum ccs_mac_index operation,
+			 struct dentry *dentry, struct vfsmount *mnt)
 {
-	struct ccs_obj_info obj = {
-		.path1.dentry = dentry,
-		.path1.mnt = mnt,
-	};
-	int error;
-	struct ccs_path_info buf;
-	if (!ccs_get_realpath(&buf, &obj.path1))
-		return -ENOMEM;
-	switch (operation) {
-	case CCS_TYPE_RMDIR:
-	case CCS_TYPE_CHROOT:
-		ccs_add_slash(&buf);
-		break;
-	}
-	error = ccs_path_permission(operation, &buf, &obj);
-	kfree(buf.name);
-	return error;
+	struct ccs_request_info r = { };
+	r.type = operation;
+	r.obj.path[0].dentry = dentry;
+	r.obj.path[0].mnt = mnt;
+	return ccs_check_acl(&r, true);
 }
 
 /**
  * ccs_mkdev_perm - Check permission for "mkblock" and "mkchar".
  *
- * @operation: Type of operation. (CCS_TYPE_MKCHAR or CCS_TYPE_MKBLOCK)
+ * @operation: Type of operation. (CCS_MAC_FILE_MKCHAR or CCS_MAC_FILE_MKBLOCK)
  * @dentry:    Pointer to "struct dentry".
  * @mnt:       Pointer to "struct vfsmount". Maybe NULL.
  * @mode:      Create mode.
@@ -2235,38 +1678,24 @@
 			  struct vfsmount *mnt, const unsigned int mode,
 			  unsigned int dev)
 {
-	struct ccs_obj_info obj = {
-		.path1.dentry = dentry,
-		.path1.mnt = mnt,
-	};
-	int error;
-	struct ccs_path_info buf;
+	struct ccs_request_info r = { };
 	ccs_check_auto_domain_transition();
-	if (!ccs_get_realpath(&buf, &obj.path1))
-		return -ENOMEM;
+	r.obj.path[0].dentry = dentry;
+	r.obj.path[0].mnt = mnt;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 5, 0)
 	dev = new_decode_dev(dev);
 #endif
-	{
-		struct ccs_request_info r = { };
-		r.type = ccs_pnnn2mac[operation];
-		r.obj = &obj;
-		r.param_type = CCS_TYPE_MKDEV_ACL;
-		r.param.mkdev.filename = &buf;
-		r.param.mkdev.operation = operation;
-		r.param.mkdev.mode = mode;
-		r.param.mkdev.major = MAJOR(dev);
-		r.param.mkdev.minor = MINOR(dev);
-		error = ccs_check_acl(&r);
-	}
-	kfree(buf.name);
-	return error;
+	r.type = operation;
+	r.param.i[0] = mode;
+	r.param.i[1] = MAJOR(dev);
+	r.param.i[2] = MINOR(dev);
+	return ccs_check_acl(&r, true);
 }
 
 /**
  * ccs_path2_perm - Check permission for "rename", "link" and "pivot_root".
  *
- * @operation: Type of operation.
+ * @operation: One of values in "enum ccs_mac_index".
  * @dentry1:   Pointer to "struct dentry".
  * @mnt1:      Pointer to "struct vfsmount". Maybe NULL.
  * @dentry2:   Pointer to "struct dentry".
@@ -2274,50 +1703,18 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_path2_perm(const u8 operation, struct dentry *dentry1,
-			  struct vfsmount *mnt1, struct dentry *dentry2,
-			  struct vfsmount *mnt2)
+static int ccs_path2_perm(const enum ccs_mac_index operation,
+			  struct dentry *dentry1, struct vfsmount *mnt1,
+			  struct dentry *dentry2, struct vfsmount *mnt2)
 {
-	struct ccs_obj_info obj = {
-		.path1.dentry = dentry1,
-		.path1.mnt = mnt1,
-		.path2.dentry = dentry2,
-		.path2.mnt = mnt2,
-	};
-	int error;
-	struct ccs_path_info buf1;
-	struct ccs_path_info buf2;
+	struct ccs_request_info r = { };
 	ccs_check_auto_domain_transition();
-	if (!ccs_get_realpath(&buf1, &obj.path1))
-		return -ENOMEM;
-	if (!ccs_get_realpath(&buf2, &obj.path2)) {
-		kfree(buf1.name);
-		return -ENOMEM;
-	}
-	switch (operation) {
-	case CCS_TYPE_RENAME:
-	case CCS_TYPE_LINK:
-		if (!dentry1->d_inode || !S_ISDIR(dentry1->d_inode->i_mode))
-			break;
-		/* fall through */
-	case CCS_TYPE_PIVOT_ROOT:
-		ccs_add_slash(&buf1);
-		ccs_add_slash(&buf2);
-		break;
-	}
-	{
-		struct ccs_request_info r = { };
-		r.type = ccs_pp2mac[operation];
-		r.obj = &obj;
-		r.param_type = CCS_TYPE_PATH2_ACL;
-		r.param.path2.operation = operation;
-		r.param.path2.filename1 = &buf1;
-		r.param.path2.filename2 = &buf2;
-		error = ccs_check_acl(&r);
-	}
-	kfree(buf1.name);
-	kfree(buf2.name);
-	return error;
+	r.type = operation;
+	r.obj.path[0].dentry = dentry1;
+	r.obj.path[0].mnt = mnt1;
+	r.obj.path[1].dentry = dentry2;
+	r.obj.path[1].mnt = mnt2;
+	return ccs_check_acl(&r, true);
 }
 
 /**
@@ -2332,75 +1729,41 @@
 static int __ccs_symlink_permission(struct dentry *dentry,
 				    struct vfsmount *mnt, const char *target)
 {
-	struct ccs_obj_info obj = {
-		.path1.dentry = dentry,
-		.path1.mnt = mnt,
-	};
-	int error;
-	struct ccs_path_info buf1;
-	struct ccs_path_info buf2;
+	struct ccs_request_info r = { };
 	ccs_check_auto_domain_transition();
-	if (!ccs_get_realpath(&buf1, &obj.path1))
+	r.type = CCS_MAC_FILE_SYMLINK;
+	r.obj.path[0].dentry = dentry;
+	r.obj.path[0].mnt = mnt;
+	r.obj.pathname[1].name = ccs_encode(target);
+	if (!r.obj.pathname[1].name)
 		return -ENOMEM;
-	buf2.name = ccs_encode(target);
-	if (!buf2.name) {
-		kfree(buf1.name);
-		return -ENOMEM;
-	}
-	ccs_fill_path_info(&buf2);
-	{
-		struct ccs_request_info r = { };
-		r.type = CCS_MAC_FILE_SYMLINK;
-		r.obj = &obj;
-		r.param_type = CCS_TYPE_PATH2_ACL;
-		r.param.path2.operation = CCS_TYPE_SYMLINK;
-		r.param.path2.filename1 = &buf1;
-		r.param.path2.filename2 = &buf2;
-		error = ccs_check_acl(&r);
-	}
-	kfree(buf1.name);
-	kfree(buf2.name);
-	return error;
+	ccs_fill_path_info(&r.obj.pathname[1]);
+	return ccs_check_acl(&r, true);
 }
 
 /**
  * ccs_path_number_perm - Check permission for "create", "mkdir", "mkfifo", "mksock", "ioctl", "chmod", "chown", "chgrp".
  *
- * @type:   Type of operation.
+ * @type:   One of values in "enum ccs_mac_index".
  * @dentry: Pointer to "struct dentry".
  * @vfsmnt: Pointer to "struct vfsmount". Maybe NULL.
  * @number: Number.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_path_number_perm(const u8 type, struct dentry *dentry,
-				struct vfsmount *vfsmnt, unsigned long number)
+static int ccs_path_number_perm(const enum ccs_mac_index type,
+				struct dentry *dentry, struct vfsmount *vfsmnt,
+				unsigned long number)
 {
-	struct ccs_obj_info obj = {
-		.path1.dentry = dentry,
-		.path1.mnt = vfsmnt,
-	};
-	int error;
-	struct ccs_path_info buf;
+	struct ccs_request_info r = { };
 	if (!dentry)
 		return 0;
 	ccs_check_auto_domain_transition();
-	if (!ccs_get_realpath(&buf, &obj.path1))
-		return -ENOMEM;
-	if (type == CCS_TYPE_MKDIR)
-		ccs_add_slash(&buf);
-	{
-		struct ccs_request_info r = { };
-		r.type = ccs_pn2mac[type];
-		r.obj = &obj;
-		r.param_type = CCS_TYPE_PATH_NUMBER_ACL;
-		r.param.path_number.operation = type;
-		r.param.path_number.filename = &buf;
-		r.param.path_number.number = number;
-		error = ccs_check_acl(&r);
-	}
-	kfree(buf.name);
-	return error;
+	r.type = type;
+	r.obj.path[0].dentry = dentry;
+	r.obj.path[0].mnt = vfsmnt;
+	r.param.i[0] = number;
+	return ccs_check_acl(&r, true);
 }
 
 /**
@@ -2415,7 +1778,7 @@
 static int __ccs_ioctl_permission(struct file *filp, unsigned int cmd,
 				  unsigned long arg)
 {
-	return ccs_path_number_perm(CCS_TYPE_IOCTL, filp->f_dentry,
+	return ccs_path_number_perm(CCS_MAC_FILE_IOCTL, filp->f_dentry,
 				    filp->f_vfsmnt, cmd);
 }
 
@@ -2433,7 +1796,7 @@
 {
 	if (mode == (mode_t) -1)
 		return 0;
-	return ccs_path_number_perm(CCS_TYPE_CHMOD, dentry, vfsmnt,
+	return ccs_path_number_perm(CCS_MAC_FILE_CHMOD, dentry, vfsmnt,
 				    mode & S_IALLUGO);
 }
 
@@ -2455,11 +1818,11 @@
 	if (user == (uid_t) -1 && group == (gid_t) -1)
 		return 0;
 	if (user != (uid_t) -1)
-		error = ccs_path_number_perm(CCS_TYPE_CHOWN, dentry, vfsmnt,
-					     user);
+		error = ccs_path_number_perm(CCS_MAC_FILE_CHOWN, dentry,
+					     vfsmnt, user);
 	if (!error && group != (gid_t) -1)
-		error = ccs_path_number_perm(CCS_TYPE_CHGRP, dentry, vfsmnt,
-					     group);
+		error = ccs_path_number_perm(CCS_MAC_FILE_CHGRP, dentry,
+					     vfsmnt, group);
 	return error;
 }
 
@@ -2500,7 +1863,7 @@
 static int __ccs_pivot_root_permission(struct path *old_path,
 				       struct path *new_path)
 {
-	return ccs_path2_perm(CCS_TYPE_PIVOT_ROOT, new_path->dentry,
+	return ccs_path2_perm(CCS_MAC_FILE_PIVOT_ROOT, new_path->dentry,
 			      new_path->mnt, old_path->dentry, old_path->mnt);
 }
 
@@ -2513,7 +1876,7 @@
  */
 static int __ccs_chroot_permission(struct path *path)
 {
-	return ccs_path_perm(CCS_TYPE_CHROOT, path->dentry, path->mnt);
+	return ccs_path_perm(CCS_MAC_FILE_CHROOT, path->dentry, path->mnt);
 }
 
 /**
@@ -2526,7 +1889,7 @@
  */
 static int __ccs_umount_permission(struct vfsmount *mnt, int flags)
 {
-	return ccs_path_perm(CCS_TYPE_UMOUNT, mnt->mnt_root, mnt);
+	return ccs_path_perm(CCS_MAC_FILE_UMOUNT, mnt->mnt_root, mnt);
 }
 
 /**
@@ -2546,24 +1909,24 @@
 	const unsigned int perm = mode & S_IALLUGO;
 	switch (mode & S_IFMT) {
 	case S_IFCHR:
-		error = ccs_mkdev_perm(CCS_TYPE_MKCHAR, dentry, mnt, perm,
+		error = ccs_mkdev_perm(CCS_MAC_FILE_MKCHAR, dentry, mnt, perm,
 				       dev);
 		break;
 	case S_IFBLK:
-		error = ccs_mkdev_perm(CCS_TYPE_MKBLOCK, dentry, mnt, perm,
+		error = ccs_mkdev_perm(CCS_MAC_FILE_MKBLOCK, dentry, mnt, perm,
 				       dev);
 		break;
 	case S_IFIFO:
-		error = ccs_path_number_perm(CCS_TYPE_MKFIFO, dentry, mnt,
+		error = ccs_path_number_perm(CCS_MAC_FILE_MKFIFO, dentry, mnt,
 					     perm);
 		break;
 	case S_IFSOCK:
-		error = ccs_path_number_perm(CCS_TYPE_MKSOCK, dentry, mnt,
+		error = ccs_path_number_perm(CCS_MAC_FILE_MKSOCK, dentry, mnt,
 					     perm);
 		break;
 	case 0:
 	case S_IFREG:
-		error = ccs_path_number_perm(CCS_TYPE_CREATE, dentry, mnt,
+		error = ccs_path_number_perm(CCS_MAC_FILE_CREATE, dentry, mnt,
 					     perm);
 		break;
 	}
@@ -2582,7 +1945,7 @@
 static int __ccs_mkdir_permission(struct dentry *dentry, struct vfsmount *mnt,
 				  unsigned int mode)
 {
-	return ccs_path_number_perm(CCS_TYPE_MKDIR, dentry, mnt, mode);
+	return ccs_path_number_perm(CCS_MAC_FILE_MKDIR, dentry, mnt, mode);
 }
 
 /**
@@ -2595,7 +1958,7 @@
  */
 static int __ccs_rmdir_permission(struct dentry *dentry, struct vfsmount *mnt)
 {
-	return ccs_path_perm(CCS_TYPE_RMDIR, dentry, mnt);
+	return ccs_path_perm(CCS_MAC_FILE_RMDIR, dentry, mnt);
 }
 
 /**
@@ -2608,7 +1971,7 @@
  */
 static int __ccs_unlink_permission(struct dentry *dentry, struct vfsmount *mnt)
 {
-	return ccs_path_perm(CCS_TYPE_UNLINK, dentry, mnt);
+	return ccs_path_perm(CCS_MAC_FILE_UNLINK, dentry, mnt);
 }
 
 #ifdef CONFIG_CCSECURITY_FILE_GETATTR
@@ -2624,7 +1987,7 @@
 static int __ccs_getattr_permission(struct vfsmount *mnt,
 				    struct dentry *dentry)
 {
-	return ccs_path_perm(CCS_TYPE_GETATTR, dentry, mnt);
+	return ccs_path_perm(CCS_MAC_FILE_GETATTR, dentry, mnt);
 }
 
 #endif
@@ -2640,7 +2003,7 @@
 static int __ccs_truncate_permission(struct dentry *dentry,
 				     struct vfsmount *mnt)
 {
-	return ccs_path_perm(CCS_TYPE_TRUNCATE, dentry, mnt);
+	return ccs_path_perm(CCS_MAC_FILE_TRUNCATE, dentry, mnt);
 }
 
 /**
@@ -2656,7 +2019,7 @@
 				   struct dentry *new_dentry,
 				   struct vfsmount *mnt)
 {
-	return ccs_path2_perm(CCS_TYPE_RENAME, old_dentry, mnt, new_dentry,
+	return ccs_path2_perm(CCS_MAC_FILE_RENAME, old_dentry, mnt, new_dentry,
 			      mnt);
 }
 
@@ -2673,7 +2036,8 @@
 				 struct dentry *new_dentry,
 				 struct vfsmount *mnt)
 {
-	return ccs_path2_perm(CCS_TYPE_LINK, old_dentry, mnt, new_dentry, mnt);
+	return ccs_path2_perm(CCS_MAC_FILE_LINK, old_dentry, mnt, new_dentry,
+			      mnt);
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
@@ -2711,6 +2075,23 @@
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 18) || (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33) && defined(CONFIG_SYSCTL_SYSCALL))
 
 /**
+ * ccs_sysctl_permission - Check permission for sysctl operation.
+ *
+ * @type:     One of values in "enum ccs_mac_index".
+ * @filename: Filename to check.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_sysctl_permission(enum ccs_mac_index type,
+				 const struct ccs_path_info *filename)
+{
+	struct ccs_request_info r = { };
+	r.type = type;
+	r.param.s[0] = filename;
+	return ccs_check_acl(&r, true);
+}
+
+/**
  * __ccs_parse_table - Check permission for parse_table().
  *
  * @name:   Pointer to "int __user".
@@ -2792,12 +2173,12 @@
 			goto out;
 		ccs_fill_path_info(&buf);
 		if (op & MAY_READ)
-			error = ccs_path_permission(CCS_TYPE_READ, &buf, NULL);
+			error = ccs_sysctl_permission(CCS_MAC_FILE_READ, &buf);
 		else
 			error = 0;
 		if (!error && (op & MAY_WRITE))
-			error = ccs_path_permission(CCS_TYPE_WRITE, &buf,
-						    NULL);
+			error = ccs_sysctl_permission(CCS_MAC_FILE_WRITE,
+						      &buf);
 		kfree(buf.name);
 		if (error)
 			goto out;
@@ -2814,12 +2195,12 @@
 			goto out;
 		ccs_fill_path_info(&buf);
 		if (op & MAY_READ)
-			error = ccs_path_permission(CCS_TYPE_READ, &buf, NULL);
+			error = ccs_sysctl_permission(CCS_MAC_FILE_READ, &buf);
 		else
 			error = 0;
 		if (!error && (op & MAY_WRITE))
-			error = ccs_path_permission(CCS_TYPE_WRITE, &buf,
-						    NULL);
+			error = ccs_sysctl_permission(CCS_MAC_FILE_WRITE,
+						      &buf);
 		kfree(buf.name);
 		goto out;
 	}
@@ -2877,22 +2258,20 @@
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
+static bool ccs_address_matches_group(const bool is_ipv6, const u8 *address,
 				      const struct ccs_group *group)
 {
 	struct ccs_address_group *member;
 	bool matched = false;
 	const u8 size = is_ipv6 ? 16 : 4;
-	if (group == &ccs_group_any)
-		return true;
 	list_for_each_entry_srcu(member, &group->member_list, head.list,
 				 &ccs_ss) {
 		if (member->head.is_deleted)
 			continue;
-		if (member->address.is_ipv6 != is_ipv6)
+		if (member->is_ipv6 != is_ipv6)
 			continue;
-		if (memcmp(&member->address.ip[0], address, size) > 0 ||
-		    memcmp(address, &member->address.ip[1], size) > 0)
+		if (memcmp(&member->ip[0], address, size) > 0 ||
+		    memcmp(address, &member->ip[1], size) > 0)
 			continue;
 		matched = true;
 		break;
@@ -2901,51 +2280,6 @@
 }
 
 /**
- * ccs_check_inet_acl - Check permission for inet domain socket operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_inet_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr)
-{
-	const struct ccs_inet_acl *acl = container_of(ptr, typeof(*acl), head);
-	const u8 size = r->param.inet_network.is_ipv6 ? 16 : 4;
-	if (!(ptr->perm & (1 << r->param.inet_network.operation)) ||
-	    !ccs_compare_number_union(r->param.inet_network.port, &acl->port))
-		return false;
-	if (acl->address.group)
-		return ccs_address_matches_group(r->param.inet_network.is_ipv6,
-						 r->param.inet_network.address,
-						 acl->address.group)
-			!= acl->address.is_not;
-	return acl->address.is_ipv6 == r->param.inet_network.is_ipv6 &&
-		memcmp(&acl->address.ip[0],
-		       r->param.inet_network.address, size) <= 0 &&
-		memcmp(r->param.inet_network.address,
-		       &acl->address.ip[1], size) <= 0;
-}
-
-/**
- * ccs_check_unix_acl - Check permission for unix domain socket operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_unix_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr)
-{
-	const struct ccs_unix_acl *acl = container_of(ptr, typeof(*acl), head);
-	return (ptr->perm & (1 << r->param.unix_network.operation)) &&
-		ccs_compare_name_union(r->param.unix_network.address,
-				       &acl->name);
-}
-
-/**
  * ccs_inet_entry - Check permission for INET network operation.
  *
  * @address: Pointer to "struct ccs_addr_info".
@@ -2954,26 +2288,13 @@
  */
 static int ccs_inet_entry(const struct ccs_addr_info *address)
 {
-	const u8 type = ccs_inet2mac[address->protocol][address->operation];
+	struct ccs_request_info r = { };
 	ccs_check_auto_domain_transition();
-	if (type) {
-		struct ccs_request_info r = { };
-		r.type = type;
-		r.param_type = CCS_TYPE_INET_ACL;
-		r.param.inet_network.protocol = address->protocol;
-		r.param.inet_network.operation = address->operation;
-		r.param.inet_network.is_ipv6 = address->inet.is_ipv6;
-		r.param.inet_network.address = address->inet.address;
-		r.param.inet_network.port = ntohs(address->inet.port);
-		r.dont_sleep_on_enforce_error =
-			address->operation == CCS_NETWORK_ACCEPT
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-			|| address->operation == CCS_NETWORK_RECV
-#endif
-			;
-		return ccs_check_acl(&r);
-	}
-	return 0;
+	r.type = address->operation;
+	r.param.is_ipv6 = address->inet.is_ipv6;
+	r.param.ip = address->inet.address;
+	r.param.i[0] = ntohs(address->inet.port);
+	return ccs_check_acl(&r, true);
 }
 
 /**
@@ -2996,7 +2317,7 @@
 		if (addr_len < SIN6_LEN_RFC2133)
 			goto skip;
 		i->is_ipv6 = true;
-		i->address = (u32 *)
+		i->address =
 			((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;
 		i->port = ((struct sockaddr_in6 *) addr)->sin6_port;
 		break;
@@ -3004,13 +2325,15 @@
 		if (addr_len < sizeof(struct sockaddr_in))
 			goto skip;
 		i->is_ipv6 = false;
-		i->address = (u32 *) &((struct sockaddr_in *) addr)->sin_addr;
+		i->address = (u8 *) &((struct sockaddr_in *) addr)->sin_addr;
 		i->port = ((struct sockaddr_in *) addr)->sin_port;
 		break;
 	default:
 		goto skip;
 	}
-	if (address->protocol == SOCK_RAW)
+	if (address->operation == CCS_MAC_NETWORK_INET_RAW_BIND ||
+	    address->operation == CCS_MAC_NETWORK_INET_RAW_SEND ||
+	    address->operation == CCS_MAC_NETWORK_INET_RAW_RECV)
 		i->port = htons(port);
 	return ccs_inet_entry(address);
 skip:
@@ -3026,39 +2349,27 @@
  */
 static int ccs_unix_entry(const struct ccs_addr_info *address)
 {
-	int error = 0;
-	const u8 type = ccs_unix2mac[address->protocol][address->operation];
-	if (type) {
-		char *buf = address->unix0.addr;
-		int len = address->unix0.addr_len - sizeof(sa_family_t);
-		if (len <= 0) {
-			buf = "anonymous";
-			len = 9;
-		} else if (buf[0]) {
-			len = strnlen(buf, len);
-		}
-		buf = ccs_encode2(buf, len);
-		if (buf) {
-			struct ccs_path_info addr;
-			struct ccs_request_info r = { };
-			addr.name = buf;
-			ccs_fill_path_info(&addr);
-			r.type = type;
-			r.param_type = CCS_TYPE_UNIX_ACL;
-			r.param.unix_network.protocol = address->protocol;
-			r.param.unix_network.operation = address->operation;
-			r.param.unix_network.address = &addr;
-			r.dont_sleep_on_enforce_error =
-				address->operation == CCS_NETWORK_ACCEPT
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-				|| address->operation == CCS_NETWORK_RECV
-#endif
-				;
-			error = ccs_check_acl(&r);
-			kfree(buf);
-		} else
-			error = -ENOMEM;
+	int error;
+	char *buf = address->unix0.addr;
+	int len = address->unix0.addr_len - sizeof(sa_family_t);
+	if (len <= 0) {
+		buf = "anonymous";
+		len = 9;
+	} else if (buf[0]) {
+		len = strnlen(buf, len);
 	}
+	buf = ccs_encode2(buf, len);
+	if (buf) {
+		struct ccs_path_info addr;
+		struct ccs_request_info r = { };
+		addr.name = buf;
+		ccs_fill_path_info(&addr);
+		r.type = address->operation;
+		r.param.s[0] = &addr;
+		error = ccs_check_acl(&r, true);
+		kfree(buf);
+	} else
+		error = -ENOMEM;
 	return error;
 }
 
@@ -3128,8 +2439,12 @@
 		if (error)
 			return error;
 	}
-	address.protocol = type;
-	address.operation = CCS_NETWORK_LISTEN;
+	if (family == PF_INET || family == PF_INET6)
+		address.operation = CCS_MAC_NETWORK_INET_STREAM_LISTEN;
+	else if (type == SOCK_STREAM)
+		address.operation = CCS_MAC_NETWORK_UNIX_STREAM_LISTEN;
+	else
+		address.operation = CCS_MAC_NETWORK_UNIX_SEQPACKET_LISTEN;
 	if (family == PF_UNIX)
 		return ccs_check_unix_address((struct sockaddr *) &addr,
 					      addr_len, &address);
@@ -3151,18 +2466,24 @@
 {
 	struct ccs_addr_info address;
 	const u8 family = ccs_sock_family(sock->sk);
-	const unsigned int type = sock->type;
 	if (!family)
 		return 0;
-	address.protocol = type;
-	switch (type) {
+	switch (sock->type) {
 	case SOCK_DGRAM:
+		address.operation = family == PF_UNIX ?
+			CCS_MAC_NETWORK_UNIX_DGRAM_SEND :
+			CCS_MAC_NETWORK_INET_DGRAM_SEND;
+		break;
 	case SOCK_RAW:
-		address.operation = CCS_NETWORK_SEND;
+		address.operation = CCS_MAC_NETWORK_INET_RAW_SEND;
 		break;
 	case SOCK_STREAM:
+		address.operation = family == PF_UNIX ?
+			CCS_MAC_NETWORK_UNIX_STREAM_CONNECT :
+			CCS_MAC_NETWORK_INET_STREAM_CONNECT;
+		break;
 	case SOCK_SEQPACKET:
-		address.operation = CCS_NETWORK_CONNECT;
+		address.operation = CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT;
 		break;
 	default:
 		return 0;
@@ -3192,11 +2513,20 @@
 		return 0;
 	switch (type) {
 	case SOCK_STREAM:
+		address.operation = family == PF_UNIX ?
+			CCS_MAC_NETWORK_UNIX_STREAM_BIND :
+			CCS_MAC_NETWORK_INET_STREAM_BIND;
+		break;
 	case SOCK_DGRAM:
+		address.operation = family == PF_UNIX ?
+			CCS_MAC_NETWORK_UNIX_DGRAM_BIND :
+			CCS_MAC_NETWORK_INET_DGRAM_BIND;
+		break;
 	case SOCK_RAW:
+		address.operation = CCS_MAC_NETWORK_INET_RAW_BIND;
+		break;
 	case SOCK_SEQPACKET:
-		address.protocol = type;
-		address.operation = CCS_NETWORK_BIND;
+		address.operation = CCS_MAC_NETWORK_UNIX_SEQPACKET_BIND;
 		break;
 	default:
 		return 0;
@@ -3225,9 +2555,13 @@
 	if (!msg->msg_name || !family ||
 	    (type != SOCK_DGRAM && type != SOCK_RAW))
 		return 0;
-	address.protocol = type;
-	address.operation = CCS_NETWORK_SEND;
 	if (family == PF_UNIX)
+		address.operation = CCS_MAC_NETWORK_UNIX_DGRAM_SEND;
+	else if (type == SOCK_DGRAM)
+		address.operation = CCS_MAC_NETWORK_INET_DGRAM_SEND;
+	else
+		address.operation = CCS_MAC_NETWORK_INET_RAW_SEND;
+	if (family == PF_UNIX)
 		return ccs_check_unix_address((struct sockaddr *)
 					      msg->msg_name, msg->msg_namelen,
 					      &address);
@@ -3261,8 +2595,12 @@
 		if (error)
 			return error;
 	}
-	address.protocol = type;
-	address.operation = CCS_NETWORK_ACCEPT;
+	if (family == PF_INET || family == PF_INET6)
+		address.operation = CCS_MAC_NETWORK_INET_STREAM_ACCEPT;
+	else if (type == SOCK_STREAM)
+		address.operation = CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT;
+	else
+		address.operation = CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT;
 	if (family == PF_UNIX)
 		return ccs_check_unix_address((struct sockaddr *) &addr,
 					      addr_len, &address);
@@ -3288,17 +2626,14 @@
 	const u8 family = ccs_sock_family(sk);
 	const unsigned int type = sk->sk_type;
 	struct sockaddr_storage addr;
-	if (!family)
+	if (!family || (type != SOCK_DGRAM && type != SOCK_RAW))
 		return 0;
-	switch (type) {
-	case SOCK_DGRAM:
-	case SOCK_RAW:
-		address.protocol = type;
-		break;
-	default:
-		return 0;
-	}
-	address.operation = CCS_NETWORK_RECV;
+	if (family == PF_UNIX)
+		address.operation = CCS_MAC_NETWORK_UNIX_DGRAM_RECV;
+	else if (type == SOCK_DGRAM)
+		address.operation = CCS_MAC_NETWORK_INET_DGRAM_RECV;
+	else
+		address.operation = CCS_MAC_NETWORK_INET_RAW_RECV;
 	switch (family) {
 	case PF_INET6:
 		{
@@ -3309,7 +2644,7 @@
 				ipv6_addr_set(sin6, 0, 0, htonl(0xffff),
 					      ip_hdr(skb)->saddr);
 			else
-				ipv6_addr_copy(sin6, &ipv6_hdr(skb)->saddr);
+				*sin6 = ipv6_hdr(skb)->saddr;
 			break;
 		}
 	case PF_INET:
@@ -3341,7 +2676,7 @@
 			return 0;
 		}
 	}
-	address.inet.address = (u32 *) &addr;
+	address.inet.address = (u8 *) &addr;
 	if (type == SOCK_DGRAM)
 		address.inet.port = udp_hdr(skb)->source;
 	else
@@ -3399,22 +2734,6 @@
 #ifdef CONFIG_CCSECURITY_CAPABILITY
 
 /**
- * ccs_check_capability_acl - Check permission for capability operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_capability_acl(struct ccs_request_info *r,
-				     const struct ccs_acl_info *ptr)
-{
-	const struct ccs_capability_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return acl->operation == r->param.capability.operation;
-}
-
-/**
  * ccs_capable - Check permission for capability.
  *
  * @operation: Type of operation.
@@ -3425,9 +2744,7 @@
 {
 	struct ccs_request_info r = { };
 	r.type = ccs_c2mac[operation];
-	r.param_type = CCS_TYPE_CAPABILITY_ACL;
-	r.param.capability.operation = operation;
-	return !ccs_check_acl(&r);
+	return !ccs_check_acl(&r, true);
 }
 
 /**
@@ -3452,26 +2769,48 @@
 
 #endif
 
-#ifdef CONFIG_CCSECURITY_IPC
-
 /**
- * ccs_check_ptrace_acl - Check permission for ptrace operation.
+ * ccs_manager - Check whether the current process is a policy manager.
  *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
+ * Returns true if the current process is permitted to modify policy
+ * via /proc/ccs/ interface.
  *
- * Returns true if granted, false otherwise.
+ * Caller holds ccs_read_lock().
  */
-static bool ccs_check_ptrace_acl(struct ccs_request_info *r,
-				 const struct ccs_acl_info *ptr)
+bool ccs_manager(void)
 {
-	const struct ccs_ptrace_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return ccs_compare_number_union(r->param.ptrace.request,
-					&acl->request) &&
-		!strcmp(acl->domainname->name, r->param.ptrace.domainname);
+	struct ccs_security *task;
+	bool allowed;
+	if (!ccs_policy_loaded)
+		return true;
+	task = ccs_current_security();
+	if (task->ccs_flags & CCS_TASK_IS_MANAGER)
+		return true;
+	{
+		struct ccs_request_info r = { };
+		r.type = CCS_MAC_CAPABILITY_MODIFY_POLICY;
+		allowed = !ccs_check_acl(&r, true);
+	}
+	if (allowed) {
+		/* Set manager flag. */
+		task->ccs_flags |= CCS_TASK_IS_MANAGER;
+	} else { /* Reduce error messages. */
+		static pid_t ccs_last_pid;
+		const pid_t pid = current->pid;
+		if (ccs_last_pid != pid) {
+			const char *exe = ccs_get_exe();
+			printk(KERN_WARNING "%s ( %s ) is not permitted to "
+			       "update policies.\n",
+			       task->ccs_domain_info->domainname->name, exe);
+			ccs_last_pid = pid;
+			kfree(exe);
+		}
+	}
+	return allowed;
 }
 
+#ifdef CONFIG_CCSECURITY_IPC
+
 /**
  * __ccs_ptrace_permission - Check permission for ptrace().
  *
@@ -3482,13 +2821,14 @@
  */
 static int __ccs_ptrace_permission(long request, long pid)
 {
-	struct ccs_domain_info *dest = NULL;
-	struct ccs_request_info r = { };
+	struct ccs_domain_info *dest;
 	int error = -ESRCH;
 	const int idx = ccs_read_lock();
 	ccs_check_auto_domain_transition();
-	{
-		struct task_struct *p = NULL;
+	if (request == PTRACE_TRACEME) {
+		dest = ccs_current_domain();
+	} else {
+		struct task_struct *p;
 		ccs_tasklist_lock();
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
 		p = ccsecurity_exports.find_task_by_vpid((pid_t) pid);
@@ -3497,16 +2837,17 @@
 #endif
 		if (p)
 			dest = ccs_task_domain(p);
+		else
+			dest = NULL;
 		ccs_tasklist_unlock();
-		if (!dest)
-			goto out;
 	}
-	r.type = CCS_MAC_PTRACE;
-	r.param_type = CCS_TYPE_PTRACE_ACL;
-	r.param.ptrace.request = request;
-	r.param.ptrace.domainname = dest->domainname->name;
-	error = ccs_check_acl(&r);
-out:
+	if (dest) {
+		struct ccs_request_info r = { };
+		r.type = CCS_MAC_PTRACE;
+		r.param.i[0] = request;
+		r.param.s[0] = dest->domainname;
+		error = ccs_check_acl(&r, true);
+	}
 	ccs_read_unlock(idx);
 	return error;
 }
@@ -3516,21 +2857,6 @@
 #ifdef CONFIG_CCSECURITY_MISC
 
 /**
- * ccs_check_env_acl - Check permission for environment variable's name.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_env_acl(struct ccs_request_info *r,
-			      const struct ccs_acl_info *ptr)
-{
-	const struct ccs_env_acl *acl = container_of(ptr, typeof(*acl), head);
-	return ccs_compare_name_union(r->param.environ.name, &acl->env);
-}
-
-/**
  * ccs_env_perm - Check permission for environment variable's name.
  *
  * @r:   Pointer to "struct ccs_request_info".
@@ -3546,22 +2872,20 @@
 	environ.name = env;
 	ccs_fill_path_info(&environ);
 	r->type = CCS_MAC_ENVIRON;
-	r->param_type = CCS_TYPE_ENV_ACL;
-	r->param.environ.name = &environ;
-	return ccs_check_acl(r);
+	r->param.s[0] = &environ;
+	return ccs_check_acl(r, false);
 }
 
 /**
  * ccs_environ - Check permission for environment variable names.
  *
- * @ee: Pointer to "struct ccs_execve".
+ * @r: Pointer to "struct ccs_request_info".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_environ(struct ccs_execve *ee)
+static int ccs_environ(struct ccs_request_info *r)
 {
-	struct ccs_request_info *r = &ee->r;
-	struct linux_binprm *bprm = ee->bprm;
+	struct linux_binprm *bprm = r->bprm;
 	/* env_page.data is allocated by ccs_dump_page(). */
 	struct ccs_page_dump env_page = { };
 	char *arg_ptr; /* Size is CCS_EXEC_TMPSIZE bytes */
@@ -3592,10 +2916,7 @@
 			if (c && arg_len < CCS_EXEC_TMPSIZE - 10) {
 				if (c == '=') {
 					arg_ptr[arg_len++] = '\0';
-				} else if (c == '\\') {
-					arg_ptr[arg_len++] = '\\';
-					arg_ptr[arg_len++] = '\\';
-				} else if (c > ' ' && c < 127) {
+				} else if (c > ' ' && c < 127 && c != '\\') {
 					arg_ptr[arg_len++] = c;
 				} else {
 					arg_ptr[arg_len++] = '\\';
@@ -3630,129 +2951,100 @@
 #endif
 
 /**
- * ccs_argv - Check argv[] in "struct linux_binbrm".
+ * ccs_check_argv - Check argv[] in "struct linux_binbrm".
  *
- * @index:   Index number of @arg_ptr.
- * @arg_ptr: Contents of argv[@index].
- * @argc:    Length of @argv.
- * @argv:    Pointer to "struct ccs_argv".
- * @checked: Set to true if @argv[@index] was found.
+ * @r:      Pointer to "struct ccs_request_info".
+ * @index:  Index number to check.
+ * @value:  Poiner to "struct ccs_path_info".
+ * @is_not: True if negative match, false otherwise.
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_argv(const unsigned int index, const char *arg_ptr,
-		     const int argc, const struct ccs_argv *argv,
-		     u8 *checked)
+static bool ccs_check_argv(struct ccs_request_info *r, unsigned long index,
+			   const struct ccs_path_info *value,
+			   const bool is_not)
 {
-	int i;
+	struct linux_binprm *bprm = r->bprm;
+	struct ccs_page_dump *dump = &r->dump;
+	char *arg_ptr = r->tmp;
+	int arg_len = 0;
+	unsigned long pos = bprm->p;
+	int offset = pos % PAGE_SIZE;
 	struct ccs_path_info arg;
-	arg.name = arg_ptr;
-	for (i = 0; i < argc; argv++, checked++, i++) {
-		bool result;
-		if (index != argv->index)
-			continue;
-		*checked = 1;
-		ccs_fill_path_info(&arg);
-		result = ccs_path_matches_pattern(&arg, argv->value);
-		if (argv->is_not)
-			result = !result;
-		if (!result)
+	if (index > bprm->argc)
+		return false;
+	while (1) {
+		if (!ccs_dump_page(bprm, pos, dump))
 			return false;
-	}
-	return true;
-}
-
-/**
- * ccs_envp - Check envp[] in "struct linux_binbrm".
- *
- * @env_name:  The name of environment variable.
- * @env_value: The value of environment variable.
- * @envc:      Length of @envp.
- * @envp:      Pointer to "struct ccs_envp".
- * @checked:   Set to true if @envp[@env_name] was found.
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_envp(const char *env_name, const char *env_value,
-		     const int envc, const struct ccs_envp *envp,
-		     u8 *checked)
-{
-	int i;
-	struct ccs_path_info name;
-	struct ccs_path_info value;
-	name.name = env_name;
-	ccs_fill_path_info(&name);
-	value.name = env_value;
-	ccs_fill_path_info(&value);
-	for (i = 0; i < envc; envp++, checked++, i++) {
-		bool result;
-		if (!ccs_path_matches_pattern(&name, envp->name))
-			continue;
-		*checked = 1;
-		if (envp->value) {
-			result = ccs_path_matches_pattern(&value, envp->value);
-			if (envp->is_not)
-				result = !result;
-		} else {
-			result = true;
-			if (!envp->is_not)
-				result = !result;
+		pos += PAGE_SIZE - offset;
+		while (offset < PAGE_SIZE) {
+			const unsigned char c = dump->data[offset++];
+			if (index) {
+				if (!c)
+					index--;
+				continue;
+			}
+			if (c && arg_len < CCS_EXEC_TMPSIZE - 10) {
+				if (c > ' ' && c < 127 && c != '\\') {
+					arg_ptr[arg_len++] = c;
+				} else {
+					arg_ptr[arg_len++] = '\\';
+					arg_ptr[arg_len++] = (c >> 6) + '0';
+					arg_ptr[arg_len++] =
+						((c >> 3) & 7) + '0';
+					arg_ptr[arg_len++] = (c & 7) + '0';
+				}
+				continue;
+			}
+			arg_ptr[arg_len] = '\0';
+			arg.name = arg_ptr;
+			ccs_fill_path_info(&arg);
+			return ccs_path_matches_pattern(&arg, value) != is_not;
 		}
-		if (!result)
-			return false;
+		offset = 0;
 	}
-	return true;
 }
 
 /**
- * ccs_scan_bprm - Scan "struct linux_binprm".
+ * ccs_check_envp - Check envp[] in "struct linux_binbrm".
  *
- * @ee:   Pointer to "struct ccs_execve".
- * @argc: Length of @argc.
- * @argv: Pointer to "struct ccs_argv".
- * @envc: Length of @envp.
- * @envp: Poiner to "struct ccs_envp".
+ * @r:      Pointer to "struct ccs_request_info".
+ * @name:   Pointer to "struct ccs_path_info".
+ * @value:  Pointer to "struct ccs_path_info". Maybe NULL.
+ * @is_not: True if negative match, false othwerwise.
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_scan_bprm(struct ccs_execve *ee,
-			  const u16 argc, const struct ccs_argv *argv,
-			  const u16 envc, const struct ccs_envp *envp)
+static bool ccs_check_envp(struct ccs_request_info *r,
+			   const struct ccs_path_info *name,
+			   const struct ccs_path_info *value,
+			   const bool is_not)
 {
-	struct linux_binprm *bprm = ee->bprm;
-	struct ccs_page_dump *dump = &ee->dump;
-	char *arg_ptr = ee->tmp;
+	struct linux_binprm *bprm = r->bprm;
+	struct ccs_page_dump *dump = &r->dump;
+	char *arg_ptr = r->tmp;
 	int arg_len = 0;
 	unsigned long pos = bprm->p;
 	int offset = pos % PAGE_SIZE;
 	int argv_count = bprm->argc;
 	int envp_count = bprm->envc;
-	bool result = true;
-	u8 local_checked[32];
-	u8 *checked;
-	if (argc + envc <= sizeof(local_checked)) {
-		checked = local_checked;
-		memset(local_checked, 0, sizeof(local_checked));
-	} else {
-		checked = kzalloc(argc + envc, CCS_GFP_FLAGS);
-		if (!checked)
+	bool result = !value == !is_not;
+	struct ccs_path_info n;
+	struct ccs_path_info v;
+	char *cp;
+	while (envp_count) {
+		if (!ccs_dump_page(bprm, pos, dump))
 			return false;
-	}
-	while (argv_count || envp_count) {
-		if (!ccs_dump_page(bprm, pos, dump)) {
-			result = false;
-			goto out;
-		}
 		pos += PAGE_SIZE - offset;
-		while (offset < PAGE_SIZE) {
-			/* Read. */
-			const char *kaddr = dump->data;
-			const unsigned char c = kaddr[offset++];
+		while (envp_count && offset < PAGE_SIZE) {
+			const unsigned char c = dump->data[offset++];
+			if (argv_count) {
+				if (!c)
+					argv_count--;
+				continue;
+			}
 			if (c && arg_len < CCS_EXEC_TMPSIZE - 10) {
-				if (c == '\\') {
-					arg_ptr[arg_len++] = '\\';
-					arg_ptr[arg_len++] = '\\';
-				} else if (c > ' ' && c < 127) {
+				if (c > ' ' && c < 127 && c != '\\') {
 					arg_ptr[arg_len++] = c;
 				} else {
 					arg_ptr[arg_len++] = '\\';
@@ -3766,128 +3058,57 @@
 			}
 			if (c)
 				continue;
-			/* Check. */
-			if (argv_count) {
-				if (!ccs_argv(bprm->argc - argv_count,
-					      arg_ptr, argc, argv,
-					      checked)) {
-					result = false;
-					break;
-				}
-				argv_count--;
-			} else if (envp_count) {
-				char *cp = strchr(arg_ptr, '=');
-				if (cp) {
-					*cp = '\0';
-					if (!ccs_envp(arg_ptr, cp + 1,
-						      envc, envp,
-						      checked + argc)) {
-						result = false;
-						break;
-					}
-				}
-				envp_count--;
-			} else {
-				break;
-			}
 			arg_len = 0;
-		}
-		offset = 0;
-		if (!result)
-			break;
-	}
-out:
-	if (result) {
-		int i;
-		/* Check not-yet-checked entries. */
-		for (i = 0; i < argc; i++) {
-			if (checked[i])
+			envp_count--;
+			/* Check. */
+			cp = strchr(arg_ptr, '=');
+			if (!cp)
 				continue;
-			/*
-			 * Return true only if all unchecked indexes in
-			 * bprm->argv[] are not matched.
-			 */
-			if (argv[i].is_not)
+			*cp++ = '\0';
+			n.name = arg_ptr;
+			ccs_fill_path_info(&n);
+			if (!ccs_path_matches_pattern(&n, name))
 				continue;
-			result = false;
-			break;
-		}
-		for (i = 0; i < envc; envp++, i++) {
-			if (checked[argc + i])
+			result = true;
+			if (!value) {
+				if (!is_not)
+					return false;
 				continue;
-			/*
-			 * Return true only if all unchecked environ variables
-			 * in bprm->envp[] are either undefined or not matched.
-			 */
-			if ((!envp->value && !envp->is_not) ||
-			    (envp->value && envp->is_not))
-				continue;
-			result = false;
-			break;
+			}
+			v.name = cp;
+			ccs_fill_path_info(&v);
+			if (ccs_path_matches_pattern(&v, value) != is_not)
+				return false;
 		}
+		offset = 0;
 	}
-	if (checked != local_checked)
-		kfree(checked);
 	return result;
 }
 
 /**
- * ccs_scan_exec_realpath - Check "exec.realpath" parameter of "struct ccs_condition".
- *
- * @file:  Pointer to "struct file".
- * @ptr:   Pointer to "struct ccs_name_union".
- * @match: True if "exec.realpath=", false if "exec.realpath!=".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_scan_exec_realpath(struct file *file,
-				   const struct ccs_name_union *ptr,
-				   const bool match)
-{
-	bool result;
-	struct ccs_path_info exe;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
-	struct path path;
-#endif
-	if (!file)
-		return false;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 20)
-	exe.name = ccs_realpath(&file->f_path);
-#else
-	path.mnt = file->f_vfsmnt;
-	path.dentry = file->f_dentry;
-	exe.name = ccs_realpath(&path);
-#endif
-	if (!exe.name)
-		return false;
-	ccs_fill_path_info(&exe);
-	result = ccs_compare_name_union(&exe, ptr);
-	kfree(exe.name);
-	return result == match;
-}
-
-/**
  * ccs_get_attributes - Revalidate "struct inode".
  *
- * @obj: Pointer to "struct ccs_obj_info".
+ * @r: Pointer to "struct ccs_request_info".
  *
  * Returns nothing.
  */
-void ccs_get_attributes(struct ccs_obj_info *obj)
+void ccs_get_attributes(struct ccs_request_info *r)
 {
 	u8 i;
 	struct dentry *dentry = NULL;
 
+	if (r->obj.validate_done)
+		return;
 	for (i = 0; i < CCS_MAX_PATH_STAT; i++) {
 		struct inode *inode;
 		switch (i) {
 		case CCS_PATH1:
-			dentry = obj->path1.dentry;
+			dentry = r->obj.path[0].dentry;
 			if (!dentry)
 				continue;
 			break;
 		case CCS_PATH2:
-			dentry = obj->path2.dentry;
+			dentry = r->obj.path[1].dentry;
 			if (!dentry)
 				continue;
 			break;
@@ -3905,7 +3126,7 @@
 		}
 		inode = dentry->d_inode;
 		if (inode) {
-			struct ccs_mini_stat *stat = &obj->stat[i];
+			struct ccs_mini_stat *stat = &r->obj.stat[i];
 			stat->uid  = inode->i_uid;
 			stat->gid  = inode->i_gid;
 			stat->ino  = inode->i_ino;
@@ -3916,14 +3137,365 @@
 			stat->dev  = inode->i_sb->s_dev;
 #endif
 			stat->rdev = inode->i_rdev;
-			obj->stat_valid[i] = true;
+			stat->fsmagic = dentry->d_sb->s_magic;
+			r->obj.stat_valid[i] = true;
 		}
-		if (i & 1) /* i == CCS_PATH1_PARENT || i == CCS_PATH2_PARENT */
+		if (i & 1) /* parent directory */
 			dput(dentry);
 	}
+	r->obj.validate_done = true;
 }
 
+enum ccs_arg_type {
+	CCS_ARG_TYPE_NONE,
+	CCS_ARG_TYPE_NUMBER,
+	CCS_ARG_TYPE_NAME,
+	CCS_ARG_TYPE_DOMAINNAME,
+	CCS_ARG_TYPE_GROUP,
+	CCS_ARG_TYPE_BITOP,
+	CCS_ARG_TYPE_IPV4ADDR,
+	CCS_ARG_TYPE_IPV6ADDR,
+} __packed;
+
+struct ccs_cond_arg {
+	enum ccs_arg_type type;
+	unsigned long value[2];
+	const struct ccs_path_info *name;
+	const struct ccs_path_info *domainname;
+	const struct ccs_group *group;
+	struct in6_addr ip[2];
+};
+
 /**
+ * ccs_populate_patharg - Calculate pathname for permission check and audit logs.
+ *
+ * @r:     Pointer to "struct ccs_request_info".
+ * @first: True for first pathname, false for second pathname.
+ *
+ * Returns nothing.
+ */
+void ccs_populate_patharg(struct ccs_request_info *r, const bool first)
+{
+	struct ccs_path_info *buf = &r->obj.pathname[!first];
+	struct path *path = &r->obj.path[!first];
+	if (!buf->name && path->dentry) {
+		int len;
+		buf->name = ccs_realpath(path);
+		if (!buf->name)
+			return;
+		len = strlen(buf->name) - 1;
+		if (len >= 0 && buf->name[len] != '/' &&
+		    (r->type == CCS_MAC_FILE_MKDIR ||
+		     r->type == CCS_MAC_FILE_RMDIR ||
+		     r->type == CCS_MAC_FILE_CHROOT ||
+		     r->type == CCS_MAC_FILE_PIVOT_ROOT ||
+		     ((r->type == CCS_MAC_FILE_RENAME ||
+		       r->type == CCS_MAC_FILE_LINK) &&
+		      r->obj.path[0].dentry && r->obj.path[0].dentry->d_inode
+		      && S_ISDIR(r->obj.path[0].dentry->d_inode->i_mode)))) {
+			/*
+			 * This is OK because ccs_encode() reserves space for
+			 * appending "/".
+			 */
+			((char *) buf->name)[len++] = '/';
+			((char *) buf->name)[len] = '\0';
+		}
+		ccs_fill_path_info(buf);
+	}
+	if (!r->param.s[!first] && buf->name)
+		r->param.s[!first] = buf;
+}
+
+static bool ccs_cond2arg(struct ccs_cond_arg *arg,
+			 const enum ccs_conditions_index cmd,
+			 const union ccs_condition_element **condp,
+			 struct ccs_request_info *r)
+{
+	struct ccs_mini_stat *stat;
+	unsigned long value;
+	const struct linux_binprm *bprm = r->bprm;
+	const struct ccs_request_param *param = &r->param;
+	arg->type = CCS_ARG_TYPE_NUMBER;
+	switch (cmd) {
+	case CCS_SELF_UID:
+		value = current_uid();
+		break;
+	case CCS_SELF_EUID:
+		value = current_euid();
+		break;
+	case CCS_SELF_SUID:
+		value = current_suid();
+		break;
+	case CCS_SELF_FSUID:
+		value = current_fsuid();
+		break;
+	case CCS_SELF_GID:
+		value = current_gid();
+		break;
+	case CCS_SELF_EGID:
+		value = current_egid();
+		break;
+	case CCS_SELF_SGID:
+		value = current_sgid();
+		break;
+	case CCS_SELF_FSGID:
+		value = current_fsgid();
+		break;
+	case CCS_SELF_PID:
+		value = ccs_sys_getpid();
+		break;
+	case CCS_SELF_PPID:
+		value = ccs_sys_getppid();
+		break;
+	case CCS_OBJ_IS_SOCKET:
+		value = S_IFSOCK;
+		break;
+	case CCS_OBJ_IS_SYMLINK:
+		value = S_IFLNK;
+		break;
+	case CCS_OBJ_IS_FILE:
+		value = S_IFREG;
+		break;
+	case CCS_OBJ_IS_BLOCK_DEV:
+		value = S_IFBLK;
+		break;
+	case CCS_OBJ_IS_DIRECTORY:
+		value = S_IFDIR;
+		break;
+	case CCS_OBJ_IS_CHAR_DEV:
+		value = S_IFCHR;
+		break;
+	case CCS_OBJ_IS_FIFO:
+		value = S_IFIFO;
+		break;
+	case CCS_EXEC_ARGC:
+		if (!bprm)
+			return false;
+		value = bprm->argc;
+		break;
+	case CCS_EXEC_ENVC:
+		if (!bprm)
+			return false;
+		value = bprm->envc;
+		break;
+	case CCS_TASK_TYPE:
+		value = ((u8) ccs_current_flags()) &
+			CCS_TASK_IS_EXECUTE_HANDLER;
+		break;
+	case CCS_TASK_EXECUTE_HANDLER:
+		value = CCS_TASK_IS_EXECUTE_HANDLER;
+		break;
+	case CCS_IMM_NUMBER_ENTRY1:
+		value = (*condp)->value;
+		(*condp)++;
+		break;
+	case CCS_COND_NARG0:
+		value = param->i[0];
+		break;
+	case CCS_COND_NARG1:
+		value = param->i[1];
+		break;
+	case CCS_COND_NARG2:
+		value = param->i[2];
+		break;
+	case CCS_HANDLER_PATH:
+	case CCS_TRANSIT_DOMAIN:
+	case CCS_ARGV_ENTRY:
+	case CCS_ENVP_ENTRY:
+	case CCS_COND_IPARG:
+		/* Values are loaded by caller. Just return a dummy. */
+		arg->type = CCS_ARG_TYPE_NONE;
+		value = 0;
+		break;
+	default:
+		goto not_single_value;
+	}
+	arg->value[0] = value;
+	arg->value[1] = value;
+	return true;
+not_single_value:
+	if (cmd == CCS_IMM_NUMBER_ENTRY2) {
+		arg->value[0] = (*condp)->value;
+		(*condp)++;
+		arg->value[1] = (*condp)->value;
+		(*condp)++;
+		return true;
+	}
+	switch (cmd) {
+	case CCS_COND_SARG0:
+		if (!r->param.s[0])
+			ccs_populate_patharg(r, true);
+		arg->name = r->param.s[0];
+		break;
+	case CCS_COND_SARG1:
+		if (!r->param.s[1])
+			ccs_populate_patharg(r, false);
+		arg->name = r->param.s[1];
+		break;
+	case CCS_COND_SARG2:
+		arg->name = r->param.s[2];
+		break;
+	case CCS_IMM_NAME_ENTRY:
+		arg->name = (*condp)->path;
+		(*condp)++;
+		break;
+	case CCS_SELF_EXE:
+		if (!r->exename.name)
+			ccs_get_exename(&r->exename);
+		arg->name = &r->exename;
+		break;
+	default:
+		goto not_single_name;
+	}
+	if (!arg->name)
+		return false;
+	arg->type = CCS_ARG_TYPE_NAME;
+	return true;
+not_single_name:
+	if (cmd == CCS_COND_DOMAIN || cmd == CCS_IMM_DOMAINNAME_ENTRY) {
+		arg->type = CCS_ARG_TYPE_DOMAINNAME;
+		arg->domainname = (*condp)->path;
+		(*condp)++;
+		return true;
+	}
+	if (cmd == CCS_SELF_DOMAIN) {
+		arg->type = CCS_ARG_TYPE_DOMAINNAME;
+		arg->domainname = ccs_current_domain()->domainname;
+		return true;
+	}
+	if (cmd == CCS_IMM_GROUP) {
+		arg->type = CCS_ARG_TYPE_GROUP;
+		arg->group = (*condp)->group;
+		(*condp)++;
+		return true;
+	}
+	if (cmd == CCS_IMM_IPV4ADDR_ENTRY1) {
+		arg->type = CCS_ARG_TYPE_IPV4ADDR;
+		memmove(&arg->ip[0], &(*condp)->ip, 4);
+		memmove(&arg->ip[1], &(*condp)->ip, 4);
+		(*condp)++;
+		return true;
+	}
+	if (cmd == CCS_IMM_IPV4ADDR_ENTRY2) {
+		arg->type = CCS_ARG_TYPE_IPV4ADDR;
+		memmove(&arg->ip[0], &(*condp)->ip, 4);
+		(*condp)++;
+		memmove(&arg->ip[1], &(*condp)->ip, 4);
+		(*condp)++;
+		return true;
+	}
+	if (cmd == CCS_IMM_IPV6ADDR_ENTRY1) {
+		arg->type = CCS_ARG_TYPE_IPV6ADDR;
+		memmove(&arg->ip[0], &(*condp)->ip, 16);
+		memmove(&arg->ip[1], &(*condp)->ip, 16);
+		*condp = (void *)
+			(((u8 *) *condp) + sizeof(struct in6_addr));
+		return true;
+	}
+	if (cmd == CCS_IMM_IPV6ADDR_ENTRY2) {
+		arg->type = CCS_ARG_TYPE_IPV6ADDR;
+		memmove(&arg->ip[0], &(*condp)->ip, 16);
+		*condp = (void *)
+			(((u8 *) *condp) + sizeof(struct in6_addr));
+		memmove(&arg->ip[1], &(*condp)->ip, 16);
+		*condp = (void *)
+			(((u8 *) *condp) + sizeof(struct in6_addr));
+		return true;
+	}
+	switch (cmd) {
+	case CCS_MODE_SETUID:
+		value = S_ISUID;
+		break;
+	case CCS_MODE_SETGID:
+		value = S_ISGID;
+		break;
+	case CCS_MODE_STICKY:
+		value = S_ISVTX;
+		break;
+	case CCS_MODE_OWNER_READ:
+		value = S_IRUSR;
+		break;
+	case CCS_MODE_OWNER_WRITE:
+		value = S_IWUSR;
+		break;
+	case CCS_MODE_OWNER_EXECUTE:
+		value = S_IXUSR;
+		break;
+	case CCS_MODE_GROUP_READ:
+		value = S_IRGRP;
+		break;
+	case CCS_MODE_GROUP_WRITE:
+		value = S_IWGRP;
+		break;
+	case CCS_MODE_GROUP_EXECUTE:
+		value = S_IXGRP;
+		break;
+	case CCS_MODE_OTHERS_READ:
+		value = S_IROTH;
+		break;
+	case CCS_MODE_OTHERS_WRITE:
+		value = S_IWOTH;
+		break;
+	case CCS_MODE_OTHERS_EXECUTE:
+		value = S_IXOTH;
+		break;
+	default:
+		goto not_bitop;
+	}
+	arg->type = CCS_ARG_TYPE_BITOP;
+	arg->value[0] = value;
+	return true;
+not_bitop:
+	arg->type = CCS_ARG_TYPE_NUMBER;
+	if (!r->obj.path[0].dentry && !r->obj.path[1].dentry)
+		return false;
+	ccs_get_attributes(r);
+	value = (cmd - CCS_PATH_ATTRIBUTE_START) >> 4;
+	if (value > 3)
+		return false;
+	stat = &r->obj.stat[value];
+	if (!stat)
+		return false;
+	switch ((cmd - CCS_PATH_ATTRIBUTE_START) & 0xF) {
+	case CCS_PATH_ATTRIBUTE_UID:
+		value = stat->uid;
+		break;
+	case CCS_PATH_ATTRIBUTE_GID:
+		value = stat->gid;
+		break;
+	case CCS_PATH_ATTRIBUTE_INO:
+		value = stat->ino;
+		break;
+	case CCS_PATH_ATTRIBUTE_MAJOR:
+		value = MAJOR(stat->dev);
+		break;
+	case CCS_PATH_ATTRIBUTE_MINOR:
+		value = MINOR(stat->dev);
+		break;
+	case CCS_PATH_ATTRIBUTE_TYPE:
+		value = stat->mode & S_IFMT;
+		break;
+	case CCS_PATH_ATTRIBUTE_DEV_MAJOR:
+		value = MAJOR(stat->rdev);
+		break;
+	case CCS_PATH_ATTRIBUTE_DEV_MINOR:
+		value = MINOR(stat->rdev);
+		break;
+	case CCS_PATH_ATTRIBUTE_PERM:
+		value = stat->mode & S_IALLUGO;
+		break;
+	case CCS_PATH_ATTRIBUTE_FSMAGIC:
+		value = stat->fsmagic;
+		break;
+	default:
+		return false;
+	}
+	arg->value[0] = value;
+	arg->value[1] = value;
+	return true;
+}
+
+/**
  * ccs_condition - Check condition part.
  *
  * @r:    Pointer to "struct ccs_request_info".
@@ -3936,368 +3508,186 @@
 bool ccs_condition(struct ccs_request_info *r,
 		   const struct ccs_condition *cond)
 {
-	const u32 ccs_flags = ccs_current_flags();
-	u32 i;
-	unsigned long min_v[2] = { 0, 0 };
-	unsigned long max_v[2] = { 0, 0 };
-	const struct ccs_condition_element *condp;
-	const struct ccs_number_union *numbers_p;
-	const struct ccs_name_union *names_p;
-	const struct ccs_argv *argv;
-	const struct ccs_envp *envp;
-	struct ccs_obj_info *obj;
-	u16 condc;
-	u16 argc;
-	u16 envc;
-	struct linux_binprm *bprm = NULL;
+	const union ccs_condition_element *condp;
 	if (!cond)
 		return true;
-	condc = cond->condc;
-	argc = cond->argc;
-	envc = cond->envc;
-	obj = r->obj;
-	if (r->ee)
-		bprm = r->ee->bprm;
-	if (!bprm && (argc || envc))
-		return false;
-	condp = (struct ccs_condition_element *) (cond + 1);
-	numbers_p = (const struct ccs_number_union *) (condp + condc);
-	names_p = (const struct ccs_name_union *)
-		(numbers_p + cond->numbers_count);
-	argv = (const struct ccs_argv *) (names_p + cond->names_count);
-	envp = (const struct ccs_envp *) (argv + argc);
-	for (i = 0; i < condc; i++) {
-		const bool match = condp->equals;
-		const u8 left = condp->left;
-		const u8 right = condp->right;
-		bool is_bitop[2] = { false, false };
-		u8 j;
+	condp = (typeof(condp)) (cond + 1);
+	while ((void *) condp < (void *) ((u8 *) cond) + cond->size) {
+		struct ccs_cond_arg left;
+		struct ccs_cond_arg right;
+		const enum ccs_conditions_index left_op = condp->left;
+		const enum ccs_conditions_index right_op = condp->right;
+		const bool match = !condp->is_not;
 		condp++;
-		/* Check argv[] and envp[] later. */
-		if (left == CCS_ARGV_ENTRY || left == CCS_ENVP_ENTRY)
-			continue;
-		/* Check string expressions. */
-		if (right == CCS_NAME_UNION) {
-			const struct ccs_name_union *ptr = names_p++;
-			if (left == CCS_EXEC_REALPATH) {
-				struct ccs_execve *ee = r->ee;
-				struct file *file = ee ? ee->bprm->file : NULL;
-				if (!ccs_scan_exec_realpath(file, ptr, match))
-					goto out;
+		if (!ccs_cond2arg(&left, left_op, &condp, r)) {
+			printk(KERN_INFO "Failed to decode left_op=%u\n",
+			       left_op);
+			return false;
+		}
+		if (!ccs_cond2arg(&right, right_op, &condp, r)) {
+			printk(KERN_INFO "Failed to decode right_op=%u\n",
+			       right_op);
+			return false;
+		}
+		if (0 && r->type == CCS_MAC_FILE_EXECUTE)
+			printk(KERN_INFO "left_op=%d right_op=%u "
+			       "left.type=%d right.type=%d\n",
+			       left_op, right_op, left.type, right.type);
+		if (left.type == CCS_ARG_TYPE_NUMBER) {
+			if (right.type == CCS_ARG_TYPE_NUMBER) {
+				if ((left.value[0] <= right.value[1] &&
+				     left.value[1] >= right.value[0]) == match)
+					continue;
+				return false;
 			}
-			continue;
+			if (right.type == CCS_ARG_TYPE_GROUP) {
+				if (ccs_number_matches_group
+				    (left.value[0], left.value[1], right.group)
+				    == match)
+					continue;
+				return false;
+			}
+			if (right.type == CCS_ARG_TYPE_BITOP) {
+				if (!(left.value[0] & right.value[0]) ==
+				    !match)
+					continue;
+				return false;
+			}
+			return false;
 		}
-		/* Check numeric or bit-op expressions. */
-		for (j = 0; j < 2; j++) {
-			const u8 index = j ? right : left;
-			unsigned long value = 0;
-			switch (index) {
-			case CCS_TASK_UID:
-				value = current_uid();
-				break;
-			case CCS_TASK_EUID:
-				value = current_euid();
-				break;
-			case CCS_TASK_SUID:
-				value = current_suid();
-				break;
-			case CCS_TASK_FSUID:
-				value = current_fsuid();
-				break;
-			case CCS_TASK_GID:
-				value = current_gid();
-				break;
-			case CCS_TASK_EGID:
-				value = current_egid();
-				break;
-			case CCS_TASK_SGID:
-				value = current_sgid();
-				break;
-			case CCS_TASK_FSGID:
-				value = current_fsgid();
-				break;
-			case CCS_TASK_PID:
-				value = ccs_sys_getpid();
-				break;
-			case CCS_TASK_PPID:
-				value = ccs_sys_getppid();
-				break;
-			case CCS_TYPE_IS_SOCKET:
-				value = S_IFSOCK;
-				break;
-			case CCS_TYPE_IS_SYMLINK:
-				value = S_IFLNK;
-				break;
-			case CCS_TYPE_IS_FILE:
-				value = S_IFREG;
-				break;
-			case CCS_TYPE_IS_BLOCK_DEV:
-				value = S_IFBLK;
-				break;
-			case CCS_TYPE_IS_DIRECTORY:
-				value = S_IFDIR;
-				break;
-			case CCS_TYPE_IS_CHAR_DEV:
-				value = S_IFCHR;
-				break;
-			case CCS_TYPE_IS_FIFO:
-				value = S_IFIFO;
-				break;
-			case CCS_MODE_SETUID:
-				value = S_ISUID;
-				break;
-			case CCS_MODE_SETGID:
-				value = S_ISGID;
-				break;
-			case CCS_MODE_STICKY:
-				value = S_ISVTX;
-				break;
-			case CCS_MODE_OWNER_READ:
-				value = S_IRUSR;
-				break;
-			case CCS_MODE_OWNER_WRITE:
-				value = S_IWUSR;
-				break;
-			case CCS_MODE_OWNER_EXECUTE:
-				value = S_IXUSR;
-				break;
-			case CCS_MODE_GROUP_READ:
-				value = S_IRGRP;
-				break;
-			case CCS_MODE_GROUP_WRITE:
-				value = S_IWGRP;
-				break;
-			case CCS_MODE_GROUP_EXECUTE:
-				value = S_IXGRP;
-				break;
-			case CCS_MODE_OTHERS_READ:
-				value = S_IROTH;
-				break;
-			case CCS_MODE_OTHERS_WRITE:
-				value = S_IWOTH;
-				break;
-			case CCS_MODE_OTHERS_EXECUTE:
-				value = S_IXOTH;
-				break;
-			case CCS_EXEC_ARGC:
-				if (!bprm)
-					goto out;
-				value = bprm->argc;
-				break;
-			case CCS_EXEC_ENVC:
-				if (!bprm)
-					goto out;
-				value = bprm->envc;
-				break;
-			case CCS_TASK_TYPE:
-				value = ((u8) ccs_flags)
-					& CCS_TASK_IS_EXECUTE_HANDLER;
-				break;
-			case CCS_TASK_EXECUTE_HANDLER:
-				value = CCS_TASK_IS_EXECUTE_HANDLER;
-				break;
-			case CCS_NUMBER_UNION:
-				/* Fetch values later. */
-				break;
-			default:
-				if (!obj)
-					goto out;
-				if (!obj->validate_done) {
-					ccs_get_attributes(obj);
-					obj->validate_done = true;
+		if (left.type == CCS_ARG_TYPE_NAME) {
+			if (right.type == CCS_ARG_TYPE_NAME) {
+				if (ccs_path_matches_pattern
+				    (left.name, right.name) == match) {
+					if (0 && r->type == CCS_MAC_FILE_EXECUTE)
+						printk(KERN_INFO
+						       "%u::matched\n",
+						       __LINE__);
+					continue;
 				}
-				{
-					u8 stat_index;
-					struct ccs_mini_stat *stat;
-					switch (index) {
-					case CCS_PATH1_UID:
-					case CCS_PATH1_GID:
-					case CCS_PATH1_INO:
-					case CCS_PATH1_MAJOR:
-					case CCS_PATH1_MINOR:
-					case CCS_PATH1_TYPE:
-					case CCS_PATH1_DEV_MAJOR:
-					case CCS_PATH1_DEV_MINOR:
-					case CCS_PATH1_PERM:
-						stat_index = CCS_PATH1;
-						break;
-					case CCS_PATH2_UID:
-					case CCS_PATH2_GID:
-					case CCS_PATH2_INO:
-					case CCS_PATH2_MAJOR:
-					case CCS_PATH2_MINOR:
-					case CCS_PATH2_TYPE:
-					case CCS_PATH2_DEV_MAJOR:
-					case CCS_PATH2_DEV_MINOR:
-					case CCS_PATH2_PERM:
-						stat_index = CCS_PATH2;
-						break;
-					case CCS_PATH1_PARENT_UID:
-					case CCS_PATH1_PARENT_GID:
-					case CCS_PATH1_PARENT_INO:
-					case CCS_PATH1_PARENT_PERM:
-						stat_index = CCS_PATH1_PARENT;
-						break;
-					case CCS_PATH2_PARENT_UID:
-					case CCS_PATH2_PARENT_GID:
-					case CCS_PATH2_PARENT_INO:
-					case CCS_PATH2_PARENT_PERM:
-						stat_index = CCS_PATH2_PARENT;
-						break;
-					default:
-						goto out;
-					}
-					if (!obj->stat_valid[stat_index])
-						goto out;
-					stat = &obj->stat[stat_index];
-					switch (index) {
-					case CCS_PATH1_UID:
-					case CCS_PATH2_UID:
-					case CCS_PATH1_PARENT_UID:
-					case CCS_PATH2_PARENT_UID:
-						value = stat->uid;
-						break;
-					case CCS_PATH1_GID:
-					case CCS_PATH2_GID:
-					case CCS_PATH1_PARENT_GID:
-					case CCS_PATH2_PARENT_GID:
-						value = stat->gid;
-						break;
-					case CCS_PATH1_INO:
-					case CCS_PATH2_INO:
-					case CCS_PATH1_PARENT_INO:
-					case CCS_PATH2_PARENT_INO:
-						value = stat->ino;
-						break;
-					case CCS_PATH1_MAJOR:
-					case CCS_PATH2_MAJOR:
-						value = MAJOR(stat->dev);
-						break;
-					case CCS_PATH1_MINOR:
-					case CCS_PATH2_MINOR:
-						value = MINOR(stat->dev);
-						break;
-					case CCS_PATH1_TYPE:
-					case CCS_PATH2_TYPE:
-						value = stat->mode & S_IFMT;
-						break;
-					case CCS_PATH1_DEV_MAJOR:
-					case CCS_PATH2_DEV_MAJOR:
-						value = MAJOR(stat->rdev);
-						break;
-					case CCS_PATH1_DEV_MINOR:
-					case CCS_PATH2_DEV_MINOR:
-						value = MINOR(stat->rdev);
-						break;
-					case CCS_PATH1_PERM:
-					case CCS_PATH2_PERM:
-					case CCS_PATH1_PARENT_PERM:
-					case CCS_PATH2_PARENT_PERM:
-						value = stat->mode & S_IALLUGO;
-						break;
-					}
+				if (0 && r->type == CCS_MAC_FILE_EXECUTE)
+					printk(KERN_INFO "%u::not matched\n",
+					       __LINE__);
+				return false;
+			}
+			if (right.type == CCS_ARG_TYPE_GROUP) {
+				if (ccs_path_matches_group
+				    (left.name, right.group) == match) {
+					if (0 && r->type == CCS_MAC_FILE_EXECUTE)
+						printk(KERN_INFO
+						       "%u::matched\n",
+						       __LINE__);
+					continue;
 				}
-				break;
+				if (0 && r->type == CCS_MAC_FILE_EXECUTE)
+					printk(KERN_INFO "%u::not matched\n",
+					       __LINE__);
+				return false;
 			}
-			max_v[j] = value;
-			min_v[j] = value;
-			switch (index) {
-			case CCS_MODE_SETUID:
-			case CCS_MODE_SETGID:
-			case CCS_MODE_STICKY:
-			case CCS_MODE_OWNER_READ:
-			case CCS_MODE_OWNER_WRITE:
-			case CCS_MODE_OWNER_EXECUTE:
-			case CCS_MODE_GROUP_READ:
-			case CCS_MODE_GROUP_WRITE:
-			case CCS_MODE_GROUP_EXECUTE:
-			case CCS_MODE_OTHERS_READ:
-			case CCS_MODE_OTHERS_WRITE:
-			case CCS_MODE_OTHERS_EXECUTE:
-				is_bitop[j] = true;
-			}
+			if (0 && r->type == CCS_MAC_FILE_EXECUTE)
+				printk(KERN_INFO "%u::not matched\n",
+				       __LINE__);
+			return false;
 		}
-		if (left == CCS_NUMBER_UNION) {
-			/* Fetch values now. */
-			const struct ccs_number_union *ptr = numbers_p++;
-			min_v[0] = ptr->values[0];
-			max_v[0] = ptr->values[1];
-		}
-		if (right == CCS_NUMBER_UNION) {
-			/* Fetch values now. */
-			const struct ccs_number_union *ptr = numbers_p++;
-			if (ptr->group) {
-				if ((ccs_number_matches_group(min_v[0],
-							      max_v[0],
-							      ptr->group)
-				     != ptr->is_not) == match)
+		if (left.type == CCS_ARG_TYPE_DOMAINNAME) {
+			const char *l = left.domainname->name;
+			const char *r = right.domainname->name;
+			if (right.type != CCS_ARG_TYPE_DOMAINNAME) {
+				printk(KERN_WARNING "%u: right.type=%u",
+				       __LINE__, right.type);
+				continue;
+			}
+			if (!strcmp(l, r) != match)
+				continue;
+			/*
+			if (comp == CCS_COMPARE_LE) {
+				const int len = left.domainname->total_len;
+				if (!strncmp(l, r, len) &&
+				    (!r[len] || !strncmp("\\_", r + len, 2)))
 					continue;
 			} else {
-				if ((min_v[0] <= ptr->values[1] &&
-				     max_v[0] >= ptr->values[0]) == match)
+				const int len = right.domainname->total_len;
+				if (!strncmp(l, r, len) &&
+				    (!l[len] || !strncmp("\\_", l + len, 2)))
 					continue;
 			}
-			goto out;
+			*/
+			return false;
 		}
-		/*
-		 * Bit operation is valid only when counterpart value
-		 * represents permission.
-		 */
-		if (is_bitop[0] && is_bitop[1]) {
-			goto out;
-		} else if (is_bitop[0]) {
-			switch (right) {
-			case CCS_PATH1_PERM:
-			case CCS_PATH1_PARENT_PERM:
-			case CCS_PATH2_PERM:
-			case CCS_PATH2_PARENT_PERM:
-				if (!(max_v[0] & max_v[1]) == !match)
+		if (left.type != CCS_ARG_TYPE_NONE)
+			return false;
+		/* Check IPv4 or IPv6 address expressions. */
+		if (left_op == CCS_COND_IPARG) {
+#ifdef CONFIG_CCSECURITY_NETWORK
+			if (right.type == CCS_ARG_TYPE_GROUP) {
+				if (ccs_address_matches_group
+				    (r->param.is_ipv6, r->param.ip,
+				     right.group) == match)
 					continue;
-			}
-			goto out;
-		} else if (is_bitop[1]) {
-			switch (left) {
-			case CCS_PATH1_PERM:
-			case CCS_PATH1_PARENT_PERM:
-			case CCS_PATH2_PERM:
-			case CCS_PATH2_PARENT_PERM:
-				if (!(max_v[0] & max_v[1]) == !match)
+			} else if (right.type == CCS_ARG_TYPE_IPV6ADDR) {
+				if (r->param.is_ipv6 &&
+				    (memcmp(r->param.ip, &right.ip[0],
+					    16) >= 0 &&
+				     memcmp(r->param.ip, &right.ip[1],
+					    16) <= 0) == match)
 					continue;
+			} else if (right.type == CCS_ARG_TYPE_IPV4ADDR) {
+				if (!r->param.is_ipv6 &&
+				    (memcmp(r->param.ip, &right.ip[0],
+					    4) >= 0 &&
+				     memcmp(r->param.ip, &right.ip[1],
+					    4) <= 0) == match)
+					continue;
 			}
-			goto out;
+#endif
+			return false;
 		}
-		/* Normal value range comparison. */
-		if ((min_v[0] <= max_v[1] && max_v[0] >= min_v[1]) == match)
+		if (left_op == CCS_HANDLER_PATH) {
+			BUG_ON(right.type != CCS_ARG_TYPE_NAME);
+			r->handler_path = right.name;
+			if (0)
+				printk(KERN_INFO "r->handler_path=%p\n",
+				       r->handler_path);
 			continue;
-out:
+		}
+		if (left_op == CCS_TRANSIT_DOMAIN) {
+			BUG_ON(right.type != CCS_ARG_TYPE_DOMAINNAME);
+			r->transition = right.domainname;
+			if (0)
+				printk(KERN_INFO "r->transition=%p\n",
+				       r->transition);
+			continue;
+		}
+		if (!r->bprm)
+			return false;
+		if (left.type == CCS_ARGV_ENTRY) {
+			unsigned long index;
+			const struct ccs_path_info *value;
+			index = condp->value;
+			condp++;
+			value = condp->path;
+			condp++;
+			if (!ccs_check_argv(r, index, value, !match))
+				return false;
+			continue;
+		}
+		if (left.type == CCS_ENVP_ENTRY) {
+			const struct ccs_path_info *name;
+			const struct ccs_path_info *value;
+			name = condp->path;
+			condp++;
+			value = condp->path;
+			condp++;
+			if (!ccs_check_envp(r, name, value, !match))
+				return false;
+			continue;
+		}
 		return false;
 	}
-	/* Check argv[] and envp[] now. */
-	if (r->ee && (argc || envc))
-		return ccs_scan_bprm(r->ee, argc, argv, envc, envp);
 	return true;
 }
 
-#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
-
 /**
- * ccs_check_task_acl - Check permission for task operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_task_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr)
-{
-	const struct ccs_task_acl *acl = container_of(ptr, typeof(*acl), head);
-	return !ccs_pathcmp(r->param.task.domainname, acl->domainname);
-}
-
-#endif
-
-/**
  * ccs_check_auto_domain_transition - Check "task auto_domain_transition" entry.
  *
  * Returns nothing.
@@ -4312,20 +3702,20 @@
 	u8 i;
 	const char *buf;
 	const int idx = ccs_read_lock();
+	struct ccs_request_info r = { };
 	for (i = 0; i < 255; i++) {
-		struct ccs_request_info r = { };
-		r.param_type = CCS_TYPE_AUTO_TASK_ACL;
-		ccs_check_acl(&r);
+		r.type = CCS_MAC_AUTO_TASK_TRANSITION;
+		ccs_check_acl(&r, false);
 		if (!r.granted)
 			goto done;
-		buf = container_of(r.matched_acl, typeof(struct ccs_task_acl),
-				   head)->domainname->name;
-		if (!ccs_assign_domain(buf, true))
+		buf = r.transition->name;
+		if (!ccs_assign_domain(buf))
 			break;
 	}
 	printk(KERN_WARNING "ERROR: Unable to transit to '%s' domain.\n", buf);
 	force_sig(SIGKILL, current);
 done:
+	ccs_clear_request_info(&r);
 	ccs_read_unlock(idx);
 #endif
 }
@@ -4413,20 +3803,12 @@
 			if (c == '/') {
 				return false;
 			} else if (c == '\\') {
-				if (filename[1] == '\\')
-					filename++;
-				else if (ccs_byte_range(filename + 1))
+				if (ccs_byte_range(filename + 1))
 					filename += 3;
 				else
 					return false;
 			}
 			break;
-		case '\\':
-			if (c != '\\')
-				return false;
-			if (*++filename != '\\')
-				return false;
-			break;
 		case '+':
 			if (!ccs_decimal(c))
 				return false;
@@ -4463,9 +3845,7 @@
 					break;
 				if (c != '\\')
 					continue;
-				if (filename[i + 1] == '\\')
-					i++;
-				else if (ccs_byte_range(filename + i + 1))
+				if (ccs_byte_range(filename + i + 1))
 					i += 3;
 				else
 					break; /* Bad pattern. */
@@ -4646,3 +4026,14 @@
 	p += len;
 	return ccs_path_matches_pattern2(f, p);
 }
+
+static void ccs_clear_request_info(struct ccs_request_info *r)
+{
+	u8 i;
+	for (i = 0; i < 2; i++) {
+		kfree(r->obj.pathname[i].name);
+		r->obj.pathname[i].name = NULL;
+	}
+	kfree(r->exename.name);
+	r->exename.name = NULL;
+}
Index: gc.c
===================================================================
--- gc.c	(revision 5869)
+++ gc.c	(working copy)
@@ -42,7 +42,6 @@
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 int ccs_lock(void);
 #endif
-void ccs_del_acl(struct list_head *element);
 void ccs_del_condition(struct list_head *element);
 void ccs_notify_gc(struct ccs_io_buffer *head, const bool is_register);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
@@ -54,13 +53,11 @@
 static bool ccs_struct_used_by_io_buffer(const struct list_head *element);
 static int ccs_gc_thread(void *unused);
 static void ccs_collect_acl(struct list_head *list);
-static void ccs_collect_domain(struct list_head *list);
 static void ccs_collect_entry(void);
 static void ccs_collect_member(const enum ccs_policy_id id,
 			       struct list_head *member_list);
+static void ccs_del_acl(struct list_head *element);
 static void ccs_memory_free(const void *ptr, const enum ccs_policy_id type);
-static void ccs_put_name_union(struct ccs_name_union *ptr);
-static void ccs_put_number_union(struct ccs_number_union *ptr);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 static void ccs_synchronize_counter(void);
 #endif
@@ -110,49 +107,14 @@
 #endif
 		[CCS_ID_PATH_GROUP] = sizeof(struct ccs_path_group),
 		[CCS_ID_NUMBER_GROUP] = sizeof(struct ccs_number_group),
-		[CCS_ID_MANAGER] = sizeof(struct ccs_manager),
 		/* [CCS_ID_CONDITION] = "struct ccs_condition"->size, */
 		/* [CCS_ID_NAME] = "struct ccs_name"->size, */
-		/* [CCS_ID_ACL] = a["struct ccs_acl_info"->type], */
+		/* [CCS_ID_ACL] = sizeof(struct ccs_acl_info), */
 		[CCS_ID_DOMAIN] = sizeof(struct ccs_domain_info),
 	};
-	/* Size of a domain ACL element. */
-	static const u8 a[] = {
-		[CCS_TYPE_PATH_ACL] = sizeof(struct ccs_path_acl),
-		[CCS_TYPE_PATH2_ACL] = sizeof(struct ccs_path2_acl),
-		[CCS_TYPE_PATH_NUMBER_ACL]
-		= sizeof(struct ccs_path_number_acl),
-		[CCS_TYPE_MKDEV_ACL] = sizeof(struct ccs_mkdev_acl),
-		[CCS_TYPE_MOUNT_ACL] = sizeof(struct ccs_mount_acl),
-#ifdef CONFIG_CCSECURITY_NETWORK
-		[CCS_TYPE_INET_ACL] = sizeof(struct ccs_inet_acl),
-		[CCS_TYPE_UNIX_ACL] = sizeof(struct ccs_unix_acl),
-#endif
-#ifdef CONFIG_CCSECURITY_MISC
-		[CCS_TYPE_ENV_ACL] = sizeof(struct ccs_env_acl),
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-		[CCS_TYPE_CAPABILITY_ACL] = sizeof(struct ccs_capability_acl),
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-		[CCS_TYPE_PTRACE_ACL] = sizeof(struct ccs_ptrace_acl),
-#endif
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-		[CCS_TYPE_AUTO_EXECUTE_HANDLER]
-		= sizeof(struct ccs_handler_acl),
-		[CCS_TYPE_DENIED_EXECUTE_HANDLER]
-		= sizeof(struct ccs_handler_acl),
-#endif
-#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
-		[CCS_TYPE_AUTO_TASK_ACL] = sizeof(struct ccs_task_acl),
-		[CCS_TYPE_MANUAL_TASK_ACL] = sizeof(struct ccs_task_acl),
-#endif
-		[CCS_TYPE_USE_GROUP_ACL] = sizeof(struct ccs_use_group_acl),
-	};
 	size_t size;
 	if (type == CCS_ID_ACL)
-		size = a[container_of(ptr, typeof(struct ccs_acl_info),
-				      list)->type];
+		size = sizeof(struct ccs_acl_info);
 	else if (type == CCS_ID_NAME)
 		size = container_of(ptr, typeof(struct ccs_name),
 				    head.list)->size;
@@ -166,31 +128,6 @@
 }
 
 /**
- * ccs_put_name_union - Drop reference on "struct ccs_name_union".
- *
- * @ptr: Pointer to "struct ccs_name_union".
- *
- * Returns nothing.
- */
-static void ccs_put_name_union(struct ccs_name_union *ptr)
-{
-	ccs_put_group(ptr->group);
-	ccs_put_name(ptr->filename);
-}
-
-/**
- * ccs_put_number_union - Drop reference on "struct ccs_number_union".
- *
- * @ptr: Pointer to "struct ccs_number_union".
- *
- * Returns nothing.
- */
-static void ccs_put_number_union(struct ccs_number_union *ptr)
-{
-	ccs_put_group(ptr->group);
-}
-
-/**
  * ccs_struct_used_by_io_buffer - Check whether the list element is used by /proc/ccs/ users or not.
  *
  * @element: Pointer to "struct list_head".
@@ -206,9 +143,8 @@
 		head->users++;
 		spin_unlock(&ccs_io_buffer_list_lock);
 		mutex_lock(&head->io_sem);
-		if (head->r.domain == element || head->r.group == element ||
-		    head->r.acl == element || &head->w.domain->list == element
-		    || &head->w.acl->list == element)
+		if (head->r.acl == element || head->r.subacl == element ||
+		    head->r.group == element || &head->w.acl->list == element)
 			in_use = true;
 		mutex_unlock(&head->io_sem);
 		spin_lock(&ccs_io_buffer_list_lock);
@@ -256,20 +192,6 @@
 }
 
 /**
- * ccs_del_manager - Delete members in "struct ccs_manager".
- *
- * @element: Pointer to "struct list_head".
- *
- * Returns nothing.
- */
-static inline void ccs_del_manager(struct list_head *element)
-{
-	struct ccs_manager *ptr =
-		container_of(element, typeof(*ptr), head.list);
-	ccs_put_name(ptr->manager);
-}
-
-/**
  * ccs_domain_used_by_task - Check whether the given pointer is referenced by a task.
  *
  * @domain: Pointer to "struct ccs_domain_info".
@@ -343,124 +265,10 @@
  *
  * Returns nothing.
  */
-void ccs_del_acl(struct list_head *element)
+static void ccs_del_acl(struct list_head *element)
 {
 	struct ccs_acl_info *acl = container_of(element, typeof(*acl), list);
 	ccs_put_condition(acl->cond);
-	switch (acl->type) {
-	case CCS_TYPE_PATH_ACL:
-		{
-			struct ccs_path_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->name);
-		}
-		break;
-	case CCS_TYPE_PATH2_ACL:
-		{
-			struct ccs_path2_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->name1);
-			ccs_put_name_union(&entry->name2);
-		}
-		break;
-	case CCS_TYPE_PATH_NUMBER_ACL:
-		{
-			struct ccs_path_number_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->name);
-			ccs_put_number_union(&entry->number);
-		}
-		break;
-	case CCS_TYPE_MKDEV_ACL:
-		{
-			struct ccs_mkdev_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->name);
-			ccs_put_number_union(&entry->mode);
-			ccs_put_number_union(&entry->major);
-			ccs_put_number_union(&entry->minor);
-		}
-		break;
-	case CCS_TYPE_MOUNT_ACL:
-		{
-			struct ccs_mount_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->dev_name);
-			ccs_put_name_union(&entry->dir_name);
-			ccs_put_name_union(&entry->fs_type);
-			ccs_put_number_union(&entry->flags);
-		}
-		break;
-#ifdef CONFIG_CCSECURITY_NETWORK
-	case CCS_TYPE_INET_ACL:
-		{
-			struct ccs_inet_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_group(entry->address.group);
-			ccs_put_number_union(&entry->port);
-		}
-		break;
-	case CCS_TYPE_UNIX_ACL:
-		{
-			struct ccs_unix_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->name);
-		}
-		break;
-#endif
-#ifdef CONFIG_CCSECURITY_MISC
-	case CCS_TYPE_ENV_ACL:
-		{
-			struct ccs_env_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->env);
-		}
-		break;
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-	case CCS_TYPE_CAPABILITY_ACL:
-		{
-			/* Nothing to do. */
-		}
-		break;
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-	case CCS_TYPE_PTRACE_ACL:
-		{
-			struct ccs_ptrace_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_number_union(&entry->request);
-			ccs_put_name(entry->domainname);
-		}
-		break;
-#endif
-#ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
-	case CCS_TYPE_AUTO_EXECUTE_HANDLER:
-	case CCS_TYPE_DENIED_EXECUTE_HANDLER:
-		{
-			struct ccs_handler_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name(entry->handler);
-		}
-		break;
-#endif
-#ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
-	case CCS_TYPE_AUTO_TASK_ACL:
-	case CCS_TYPE_MANUAL_TASK_ACL:
-		{
-			struct ccs_task_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name(entry->domainname);
-		}
-		break;
-#endif
-	case CCS_TYPE_USE_GROUP_ACL:
-		{
-			struct ccs_use_group_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_group(entry->group);
-		}
-	}
 }
 
 /**
@@ -476,20 +284,7 @@
 {
 	struct ccs_domain_info *domain =
 		container_of(element, typeof(*domain), list);
-	struct ccs_acl_info *acl;
-	struct ccs_acl_info *tmp;
-	/*
-	 * Since this domain is referenced from neither "struct ccs_io_buffer"
-	 * nor "struct task_struct", we can delete elements without checking
-	 * for is_deleted flag.
-	 */
-	list_for_each_entry_safe(acl, tmp, &domain->acl_info_list, list) {
-		ccs_del_acl(&acl->list);
-		ccs_memory_free(acl, CCS_ID_ACL);
-	}
-	ccs_put_name(domain->default_transition);
 	ccs_put_name(domain->domainname);
-	ccs_put_condition(domain->cond);
 }
 
 /**
@@ -555,31 +350,34 @@
 {
 	struct ccs_condition *cond = container_of(element, typeof(*cond),
 						  head.list);
-	const u16 condc = cond->condc;
-	const u16 numbers_count = cond->numbers_count;
-	const u16 names_count = cond->names_count;
-	const u16 argc = cond->argc;
-	const u16 envc = cond->envc;
-	unsigned int i;
-	const struct ccs_condition_element *condp
-		= (const struct ccs_condition_element *) (cond + 1);
-	struct ccs_number_union *numbers_p
-		= (struct ccs_number_union *) (condp + condc);
-	struct ccs_name_union *names_p
-		= (struct ccs_name_union *) (numbers_p + numbers_count);
-	const struct ccs_argv *argv
-		= (const struct ccs_argv *) (names_p + names_count);
-	const struct ccs_envp *envp
-		= (const struct ccs_envp *) (argv + argc);
-	for (i = 0; i < numbers_count; i++)
-		ccs_put_number_union(numbers_p++);
-	for (i = 0; i < names_count; i++)
-		ccs_put_name_union(names_p++);
-	for (i = 0; i < argc; argv++, i++)
-		ccs_put_name(argv->value);
-	for (i = 0; i < envc; envp++, i++) {
-		ccs_put_name(envp->name);
-		ccs_put_name(envp->value);
+	const union ccs_condition_element *condp = (typeof(condp)) (cond + 1);
+	while ((void *) condp < (void *) ((u8 *) cond) + cond->size) {
+		const enum ccs_conditions_index left = condp->left;
+		const enum ccs_conditions_index right = condp->right;
+		condp++;
+		if (left == CCS_ARGV_ENTRY)
+			condp++;
+		else if (left == CCS_ENVP_ENTRY) {
+			ccs_put_name(condp->path);
+			condp++;
+		}
+		if (right == CCS_IMM_GROUP) {
+			ccs_put_group(condp->group);
+			condp++;
+		} else if (right == CCS_IMM_NAME_ENTRY ||
+			   right == CCS_IMM_DOMAINNAME_ENTRY) {
+			ccs_put_name(condp->path);
+			condp++;
+		} else if (right == CCS_IMM_NUMBER_ENTRY1)
+			condp++;
+		else if (right == CCS_IMM_NUMBER_ENTRY2)
+			condp += 2;
+		else if (right == CCS_IMM_IPV6ADDR_ENTRY1)
+			condp = (void *)
+				(((u8 *) condp) + sizeof(struct in6_addr));
+		else if (right == CCS_IMM_IPV6ADDR_ENTRY2)
+			condp = (void *)
+				(((u8 *) condp) + sizeof(struct in6_addr) * 2);
 	}
 }
 
@@ -694,9 +492,6 @@
 	if (ccs_struct_used_by_io_buffer(element))
 		goto reinject;
 	switch (type) {
-	case CCS_ID_MANAGER:
-		ccs_del_manager(element);
-		break;
 	case CCS_ID_GROUP:
 		ccs_del_group(element);
 		break;
@@ -806,27 +601,6 @@
 }
 
 /**
- * ccs_collect_domain - Delete domains in "struct ccs_acl_info".
- *
- * @list: Pointer to "struct list_head".
- *
- * Returns nothing.
- *
- * Caller holds ccs_policy_lock mutex.
- */
-static void ccs_collect_domain(struct list_head *list)
-{
-	struct ccs_domain_info *domain;
-	struct ccs_domain_info *tmp;
-	list_for_each_entry_safe(domain, tmp, list, list) {
-		if (!domain->is_deleted)
-			continue;
-		domain->is_deleted = CCS_GC_IN_PROGRESS;
-		ccs_try_to_gc(CCS_ID_DOMAIN, &domain->list);
-	}
-}
-
-/**
  * ccs_collect_entry - Try to kfree() deleted elements.
  *
  * Returns nothing.
@@ -834,30 +608,25 @@
 static void ccs_collect_entry(void)
 {
 	int i;
-	struct ccs_policy_namespace *ns;
 	mutex_lock(&ccs_policy_lock);
 	{
 		struct ccs_domain_info *domain;
 		struct ccs_domain_info *tmp;
 		list_for_each_entry_safe(domain, tmp, &ccs_domain_list, list) {
-			ccs_collect_acl(&domain->acl_info_list);
 			if (!domain->is_deleted ||
 			    ccs_domain_used_by_task(domain))
 				continue;
 			ccs_try_to_gc(CCS_ID_DOMAIN, &domain->list);
 		}
 	}
-	ccs_collect_member(CCS_ID_MANAGER, &ccs_manager_list);
-	list_for_each_entry(ns, &ccs_namespace_list, namespace_list) {
-		ccs_collect_acl(&ns->default_transition_list);
-	}
-	{
+	for (i = 0; i < CCS_MAX_MAC_INDEX; i++) {
 		struct ccs_acl_info *ptr;
 		struct ccs_acl_info *tmp;
-		list_for_each_entry_safe(ptr, tmp, &ccs_inversed_acl_list,
-					  list) {
-			ccs_collect_domain(&ptr->domain_list);
-			if (!ptr->is_deleted || !list_empty(&ptr->domain_list))
+		struct list_head * const list = &ccs_acl_list[i];
+		list_for_each_entry_safe(ptr, tmp, list, list) {
+			ccs_collect_acl(&ptr->acl_info_list);
+			if (!ptr->is_deleted ||
+			    !list_empty(&ptr->acl_info_list))
 				continue;
 			ptr->is_deleted = CCS_GC_IN_PROGRESS;
 			ccs_try_to_gc(CCS_ID_ACL, &ptr->list);
@@ -867,53 +636,56 @@
 		struct ccs_shared_acl_head *ptr;
 		struct ccs_shared_acl_head *tmp;
 		list_for_each_entry_safe(ptr, tmp, &ccs_condition_list, list) {
-			if (atomic_read(&ptr->users) > 0)
+			if (atomic_read(&ptr->users)) {
+				/*
+				printk(KERN_INFO "Users=%u condition=%p\n",
+				     atomic_read(&ptr->users), ptr);
+				*/
 				continue;
+			}
 			atomic_set(&ptr->users, CCS_GC_IN_PROGRESS);
 			ccs_try_to_gc(CCS_ID_CONDITION, &ptr->list);
 		}
 	}
-	list_for_each_entry(ns, &ccs_namespace_list, namespace_list) {
-		for (i = 0; i < CCS_MAX_GROUP; i++) {
-			struct list_head *list = &ns->group_list[i];
-			struct ccs_group *group;
-			struct ccs_group *tmp;
-			enum ccs_policy_id id;
-			if (i == CCS_PATH_GROUP)
-				id = CCS_ID_PATH_GROUP;
-			else if (i == CCS_NUMBER_GROUP)
-				id = CCS_ID_NUMBER_GROUP;
-			else if (i == CCS_ACL_GROUP)
-				id = CCS_ID_ACL;
+	for (i = 0; i < CCS_MAX_GROUP; i++) {
+		struct list_head *list = &ccs_group_list[i];
+		struct ccs_group *group;
+		struct ccs_group *tmp;
+		enum ccs_policy_id id = CCS_ID_PATH_GROUP;
+		if (i == CCS_NUMBER_GROUP)
+			id = CCS_ID_NUMBER_GROUP;
 #ifdef CONFIG_CCSECURITY_NETWORK
-			else
-				id = CCS_ID_ADDRESS_GROUP;
+		else if (i == CCS_NUMBER_GROUP)
+			id = CCS_ID_ADDRESS_GROUP;
 #endif
-			list_for_each_entry_safe(group, tmp, list, head.list) {
-				if (id == CCS_ID_ACL)
-					ccs_collect_acl(&group->member_list);
-				else
-					ccs_collect_member(id, &group->
-							   member_list);
-				if (!list_empty(&group->member_list) ||
-				    atomic_read(&group->head.users) > 0) {
-					/*
-					if (id == CCS_ID_ACL)
-						printk("%s users=%d\n",
-			       __func__, atomic_read(&group->head.users));
-					*/
-					continue;
-				}
-				atomic_set(&group->head.users,
-					   CCS_GC_IN_PROGRESS);
+		list_for_each_entry_safe(group, tmp, list, head.list) {
+			if (id == CCS_ID_ACL)
+				ccs_collect_acl(&group->member_list);
+			else
+				ccs_collect_member(id, &group->
+						   member_list);
+			if (!list_empty(&group->member_list) ||
+			    atomic_read(&group->head.users)) {
 				/*
-				if (id == CCS_ID_ACL)
-					printk("%s trying to gc %s\n",
-					       __func__,
-					       group->group_name->name);
+				  printk(KERN_INFO "Users=%u group=%p\n",
+				  atomic_read(&group->head.users),
+				  group);
 				*/
-				ccs_try_to_gc(CCS_ID_GROUP, &group->head.list);
+				/*
+				  if (id == CCS_ID_ACL)
+				  printk("%s users=%d\n",
+				  __func__, atomic_read(&group->head.users));
+				*/
+				continue;
 			}
+			atomic_set(&group->head.users, CCS_GC_IN_PROGRESS);
+			/*
+			if (id == CCS_ID_ACL)
+				printk("%s trying to gc %s\n",
+				       __func__,
+				       group->group_name->name);
+			*/
+			ccs_try_to_gc(CCS_ID_GROUP, &group->head.list);
 		}
 	}
 	for (i = 0; i < CCS_MAX_HASH; i++) {
@@ -921,8 +693,15 @@
 		struct ccs_shared_acl_head *ptr;
 		struct ccs_shared_acl_head *tmp;
 		list_for_each_entry_safe(ptr, tmp, list, list) {
-			if (atomic_read(&ptr->users) > 0)
+			if (atomic_read(&ptr->users)) {
+				/*
+				  printk(KERN_INFO "Users=%u Name='%s'\n",
+				       atomic_read(&ptr->users),
+				       container_of(ptr, struct ccs_name,
+						    head)->entry.name);
+				*/
 				continue;
+			}
 			atomic_set(&ptr->users, CCS_GC_IN_PROGRESS);
 			ccs_try_to_gc(CCS_ID_NAME, &ptr->list);
 		}
Index: Makefile
===================================================================
--- Makefile	(revision 5869)
+++ Makefile	(working copy)
@@ -16,49 +16,16 @@
 endif
 include $(TOPDIR)/Rules.make
 
-policy/profile.conf:
+policy/policy.conf:
 	@mkdir -p policy/
-	@echo Creating an empty policy/profile.conf
+	@echo Creating an empty policy/policy.conf
 	@touch $@
 
-policy/exception_policy.conf:
-	@mkdir -p policy/
-	@echo Creating a default policy/exception_policy.conf
-	@echo 'default_transition /sbin/modprobe <kernel> /sbin/modprobe' >> $@
-	@echo 'default_transition /sbin/hotplug <kernel> /sbin/hotplug' >> $@
-
-policy/domain_policy.conf:
-	@mkdir -p policy/
-	@echo Creating an empty policy/domain_policy.conf
-	@touch $@
-
-policy/manager.conf:
-	@mkdir -p policy/
-	@echo Creating an empty policy/manager.conf
-	@touch $@
-
-policy/stat.conf:
-	@mkdir -p policy/
-	@echo Creating an empty policy/stat.conf
-	@touch $@
-
-builtin-policy.h: policy/profile.conf policy/exception_policy.conf policy/domain_policy.conf policy/manager.conf policy/stat.conf
+builtin-policy.h: policy/policy.conf
 	@echo Generating built-in policy for TOMOYO 1.8.x.
-	@echo "static char ccs_builtin_profile[] __initdata =" > $@.tmp
-	@sed -e 's/\\/\\\\/g' -e 's/\"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < policy/profile.conf >> $@.tmp
+	@echo "static char ccs_builtin_policy[] __initdata =" > $@.tmp
+	@sed -e 's/\\/\\134/g' -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < policy/policy.conf >> $@.tmp
 	@echo "\"\";" >> $@.tmp
-	@echo "static char ccs_builtin_exception_policy[] __initdata =" >> $@.tmp
-	@sed -e 's/\\/\\\\/g' -e 's/\"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < policy/exception_policy.conf >> $@.tmp
-	@echo "\"\";" >> $@.tmp
-	@echo "static char ccs_builtin_domain_policy[] __initdata =" >> $@.tmp
-	@sed -e 's/\\/\\\\/g' -e 's/\"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < policy/domain_policy.conf >> $@.tmp
-	@echo "\"\";" >> $@.tmp
-	@echo "static char ccs_builtin_manager[] __initdata =" >> $@.tmp
-	@sed -e 's/\\/\\\\/g' -e 's/\"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < policy/manager.conf >> $@.tmp
-	@echo "\"\";" >> $@.tmp
-	@echo "static char ccs_builtin_stat[] __initdata =" >> $@.tmp
-	@sed -e 's/\\/\\\\/g' -e 's/\"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < policy/stat.conf >> $@.tmp
-	@echo "\"\";" >> $@.tmp
 	@mv $@.tmp $@
 
 policy_io.o: builtin-policy.h
@@ -72,49 +39,16 @@
 obj-y += ccsecurity.o
 endif
 
-$(obj)/policy/profile.conf:
+$(obj)/policy/policy.conf:
 	@mkdir -p $(obj)/policy/
-	@echo Creating an empty policy/profile.conf
+	@echo Creating an empty policy/policy.conf
 	@touch $@
 
-$(obj)/policy/exception_policy.conf:
-	@mkdir -p $(obj)/policy/
-	@echo Creating a default policy/exception_policy.conf
-	@echo 'default_transition /sbin/modprobe <kernel> /sbin/modprobe' >> $@
-	@echo 'default_transition /sbin/hotplug <kernel> /sbin/hotplug' >> $@
-
-$(obj)/policy/domain_policy.conf:
-	@mkdir -p $(obj)/policy/
-	@echo Creating an empty policy/domain_policy.conf
-	@touch $@
-
-$(obj)/policy/manager.conf:
-	@mkdir -p $(obj)/policy/
-	@echo Creating an empty policy/manager.conf
-	@touch $@
-
-$(obj)/policy/stat.conf:
-	@mkdir -p $(obj)/policy/
-	@echo Creating an empty policy/stat.conf
-	@touch $@
-
-$(obj)/builtin-policy.h: $(obj)/policy/profile.conf $(obj)/policy/exception_policy.conf $(obj)/policy/domain_policy.conf $(obj)/policy/manager.conf $(obj)/policy/stat.conf
+$(obj)/builtin-policy.h: $(obj)/policy/policy.conf
 	@echo Generating built-in policy for TOMOYO 1.8.x.
-	@echo "static char ccs_builtin_profile[] __initdata =" > $@.tmp
-	@sed -e 's/\\/\\\\/g' -e 's/\"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < $(obj)/policy/profile.conf >> $@.tmp
+	@echo "static char ccs_builtin_policy[] __initdata =" > $@.tmp
+	@sed -e 's/\\/\\134/g' -e 's/"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < $(obj)/policy/policy.conf >> $@.tmp
 	@echo "\"\";" >> $@.tmp
-	@echo "static char ccs_builtin_exception_policy[] __initdata =" >> $@.tmp
-	@sed -e 's/\\/\\\\/g' -e 's/\"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < $(obj)/policy/exception_policy.conf >> $@.tmp
-	@echo "\"\";" >> $@.tmp
-	@echo "static char ccs_builtin_domain_policy[] __initdata =" >> $@.tmp
-	@sed -e 's/\\/\\\\/g' -e 's/\"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < $(obj)/policy/domain_policy.conf >> $@.tmp
-	@echo "\"\";" >> $@.tmp
-	@echo "static char ccs_builtin_manager[] __initdata =" >> $@.tmp
-	@sed -e 's/\\/\\\\/g' -e 's/\"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < $(obj)/policy/manager.conf >> $@.tmp
-	@echo "\"\";" >> $@.tmp
-	@echo "static char ccs_builtin_stat[] __initdata =" >> $@.tmp
-	@sed -e 's/\\/\\\\/g' -e 's/\"/\\"/g' -e 's/\(.*\)/"\1\\n"/' < $(obj)/policy/stat.conf >> $@.tmp
-	@echo "\"\";" >> $@.tmp
 	@mv $@.tmp $@
 
 $(obj)/policy_io.o: $(obj)/builtin-policy.h
