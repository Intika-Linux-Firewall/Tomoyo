Index: internal.h
===================================================================
--- internal.h	(revision 5754)
+++ internal.h	(working copy)
@@ -386,25 +386,6 @@
 
 /* Index numbers for Access Controls. */
 enum ccs_acl_entry_type_index {
-	CCS_TYPE_EXECUTE_ACL,
-	CCS_TYPE_PATH_ACL,
-	CCS_TYPE_PATH2_ACL,
-	CCS_TYPE_PATH_NUMBER_ACL,
-	CCS_TYPE_MKDEV_ACL,
-	CCS_TYPE_MOUNT_ACL,
-#ifdef CONFIG_CCSECURITY_MISC
-	CCS_TYPE_ENV_ACL,
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-	CCS_TYPE_CAPABILITY_ACL,
-#endif
-#ifdef CONFIG_CCSECURITY_NETWORK
-	CCS_TYPE_INET_ACL,
-	CCS_TYPE_UNIX_ACL,
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-	CCS_TYPE_PTRACE_ACL,
-#endif
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 	CCS_TYPE_AUTO_EXECUTE_HANDLER,
 	CCS_TYPE_DENIED_EXECUTE_HANDLER,
@@ -414,7 +395,7 @@
 	CCS_TYPE_MANUAL_TASK_ACL,
 #endif
 	CCS_TYPE_USE_GROUP_ACL,
-};
+} __packed;
 
 /* Index numbers for "struct ccs_condition". */
 enum ccs_conditions_index {
@@ -428,8 +409,35 @@
 	CCS_TASK_FSGID,           /* current_fsgid() */
 	CCS_TASK_PID,             /* sys_getpid()   */
 	CCS_TASK_PPID,            /* sys_getppid()  */
+	CCS_TASK_TYPE,            /* ((u8) task->ccs_flags) &
+				     CCS_TASK_IS_EXECUTE_HANDLER */
 	CCS_EXEC_ARGC,            /* "struct linux_binprm *"->argc */
 	CCS_EXEC_ENVC,            /* "struct linux_binprm *"->envc */
+	CCS_COND_SARG0,
+	CCS_COND_SARG1,
+	CCS_COND_SARG2,
+	CCS_COND_NARG0,
+	CCS_COND_NARG1,
+	CCS_COND_NARG2,
+	//CCS_COND_GROUP,
+	//CCS_COND_IPV4,
+	//CCS_COND_EXEC,
+	//CCS_COND_PERM,
+	//CCS_COND_SYMLINK,
+	//CCS_COND_DEV_MAJOR,
+	//CCS_COND_DEV_MINOR,
+	//CCS_COND_NEW_PERM,
+	//CCS_COND_NEW_UID,
+	//CCS_COND_NEW_GID,
+	//CCS_COND_CMD,
+	//CCS_COND_FSTYPE,
+	//CCS_COND_FLAGS,
+	CCS_COND_IPV6,
+	//CCS_COND_PORT,
+	//CCS_COND_PROTO,
+	//CCS_COND_ADDR,
+	//CCS_COND_NAME,
+	CCS_COND_DOMAIN,
 	CCS_TYPE_IS_SOCKET,       /* S_IFSOCK */
 	CCS_TYPE_IS_SYMLINK,      /* S_IFLNK */
 	CCS_TYPE_IS_FILE,         /* S_IFREG */
@@ -449,43 +457,34 @@
 	CCS_MODE_OTHERS_READ,     /* S_IROTH */
 	CCS_MODE_OTHERS_WRITE,    /* S_IWOTH */
 	CCS_MODE_OTHERS_EXECUTE,  /* S_IXOTH */
-	CCS_TASK_TYPE,            /* ((u8) task->ccs_flags) &
-				     CCS_TASK_IS_EXECUTE_HANDLER */
 	CCS_TASK_EXECUTE_HANDLER, /* CCS_TASK_IS_EXECUTE_HANDLER */
-	CCS_EXEC_REALPATH,
-	CCS_PATH1_UID,
-	CCS_PATH1_GID,
-	CCS_PATH1_INO,
-	CCS_PATH1_MAJOR,
-	CCS_PATH1_MINOR,
-	CCS_PATH1_PERM,
-	CCS_PATH1_TYPE,
-	CCS_PATH1_DEV_MAJOR,
-	CCS_PATH1_DEV_MINOR,
-	CCS_PATH2_UID,
-	CCS_PATH2_GID,
-	CCS_PATH2_INO,
-	CCS_PATH2_MAJOR,
-	CCS_PATH2_MINOR,
-	CCS_PATH2_PERM,
-	CCS_PATH2_TYPE,
-	CCS_PATH2_DEV_MAJOR,
-	CCS_PATH2_DEV_MINOR,
-	CCS_PATH1_PARENT_UID,
-	CCS_PATH1_PARENT_GID,
-	CCS_PATH1_PARENT_INO,
-	CCS_PATH1_PARENT_PERM,
-	CCS_PATH2_PARENT_UID,
-	CCS_PATH2_PARENT_GID,
-	CCS_PATH2_PARENT_INO,
-	CCS_PATH2_PARENT_PERM,
 	CCS_MAX_CONDITION_KEYWORD,
-	CCS_NUMBER_UNION,
-	CCS_NAME_UNION,
+	CCS_IMM_GROUP,
+	CCS_IMM_NAME_ENTRY,
+	CCS_IMM_NUMBER_ENTRY1,
+	CCS_IMM_NUMBER_ENTRY2,
+	CCS_IMM_IPV6ADDR_ENTRY1,
+	CCS_IMM_IPV6ADDR_ENTRY2,
 	CCS_ARGV_ENTRY,
 	CCS_ENVP_ENTRY,
+	CCS_PATH_ATTRIBUTE_START = 192,
+	CCS_PATH_ATTRIBUTE_END = 255,
 };
 
+enum ccs_path_attribute_index {
+	CCS_PATH_ATTRIBUTE_NAME,
+	CCS_PATH_ATTRIBUTE_UID,
+	CCS_PATH_ATTRIBUTE_GID,
+	CCS_PATH_ATTRIBUTE_INO,
+	CCS_PATH_ATTRIBUTE_TYPE,
+	CCS_PATH_ATTRIBUTE_MAJOR,
+	CCS_PATH_ATTRIBUTE_MINOR,
+	CCS_PATH_ATTRIBUTE_PERM,
+	CCS_PATH_ATTRIBUTE_DEV_MAJOR,
+	CCS_PATH_ATTRIBUTE_DEV_MINOR,
+	CCS_MAX_PATH_ATTRIBUTE,
+};
+
 /* Index numbers for audit type. */
 enum ccs_grant_log {
 	/* Follow profile's configuration. */
@@ -611,13 +610,6 @@
 	CCS_MAX_MEMORY_STAT
 };
 
-/* Index numbers for access controls with one pathname and three numbers. */
-enum ccs_mkdev_acl_index {
-	CCS_TYPE_MKBLOCK,
-	CCS_TYPE_MKCHAR,
-	CCS_MAX_MKDEV_OPERATION
-};
-
 /* Index numbers for operation mode. */
 enum ccs_mode_value {
 	CCS_CONFIG_DISABLED,
@@ -630,57 +622,6 @@
 	CCS_CONFIG_USE_DEFAULT     = 255,
 };
 
-/* Index numbers for socket operations. */
-enum ccs_network_acl_index {
-	CCS_NETWORK_BIND,    /* bind() operation. */
-	CCS_NETWORK_LISTEN,  /* listen() operation. */
-	CCS_NETWORK_CONNECT, /* connect() operation. */
-	CCS_NETWORK_ACCEPT,  /* accept() operation. */
-	CCS_NETWORK_SEND,    /* send() operation. */
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-	CCS_NETWORK_RECV,    /* recv() operation. */
-#endif
-	CCS_MAX_NETWORK_OPERATION
-};
-
-/* Index numbers for access controls with two pathnames. */
-enum ccs_path2_acl_index {
-	CCS_TYPE_LINK,
-	CCS_TYPE_RENAME,
-	CCS_TYPE_PIVOT_ROOT,
-	CCS_TYPE_SYMLINK,
-	CCS_MAX_PATH2_OPERATION
-};
-
-/* Index numbers for access controls with one pathname. */
-enum ccs_path_acl_index {
-	CCS_TYPE_READ,
-	CCS_TYPE_WRITE,
-	CCS_TYPE_APPEND,
-	CCS_TYPE_UNLINK,
-#ifdef CONFIG_CCSECURITY_FILE_GETATTR
-	CCS_TYPE_GETATTR,
-#endif
-	CCS_TYPE_RMDIR,
-	CCS_TYPE_TRUNCATE,
-	CCS_TYPE_CHROOT,
-	CCS_TYPE_UMOUNT,
-	CCS_MAX_PATH_OPERATION
-};
-
-/* Index numbers for access controls with one pathname and one number. */
-enum ccs_path_number_acl_index {
-	CCS_TYPE_CREATE,
-	CCS_TYPE_MKDIR,
-	CCS_TYPE_MKFIFO,
-	CCS_TYPE_MKSOCK,
-	CCS_TYPE_IOCTL,
-	CCS_TYPE_CHMOD,
-	CCS_TYPE_CHOWN,
-	CCS_TYPE_CHGRP,
-	CCS_MAX_PATH_NUMBER_OPERATION
-};
-
 /* Index numbers for stat(). */
 enum ccs_path_stat_index {
 	/* Do not change this order. */
@@ -700,7 +641,6 @@
 	CCS_ID_PATH_GROUP,
 	CCS_ID_NUMBER_GROUP,
 	CCS_ID_MANAGER,
-	CCS_ID_CONDITION,
 	CCS_ID_NAME,
 	CCS_ID_ACL,
 	CCS_ID_DOMAIN,
@@ -848,26 +788,16 @@
 	struct list_head domain_list; /* Used by inverse mode. */
 	struct ccs_condition *cond; /* Maybe NULL. */
 	s8 is_deleted; /* true or false or CCS_GC_IN_PROGRESS */
-	u8 type; /* One of values in "enum ccs_acl_entry_type_index". */
+	enum ccs_mac_index type;
 	u8 mode; /* Used by inverse mode. */
-	u16 perm;
 } __packed;
 
-/* Structure for holding a word. */
-struct ccs_name_union {
-	/* Either @filename or @group is NULL. */
-	const struct ccs_path_info *filename;
-	struct ccs_group *group;
-	bool is_not;
-};
-
 /* Structure for holding a number. */
 struct ccs_number_union {
 	unsigned long values[2];
 	struct ccs_group *group; /* Maybe NULL. */
 	/* One of values in "enum ccs_value_type". */
 	u8 value_type[2];
-	bool is_not;
 };
 
 /* Structure for holding an IP address. */
@@ -875,13 +805,12 @@
 	struct in6_addr ip[2]; /* Big endian. */
 	struct ccs_group *group; /* Pointer to address group. */
 	bool is_ipv6; /* Valid only if @group == NULL. */
-	bool is_not;
 };
 
 /* Structure for "path_group"/"number_group"/"address_group" directive. */
 struct ccs_group {
 	struct ccs_shared_acl_head head;
-	/* Name of group (without leading "\\=" or "\\!"). */
+	/* Name of group (without leading "@"). */
 	const struct ccs_path_info *group_name;
 	/*
 	 * List of "struct ccs_path_group" or "struct ccs_number_group" or
@@ -907,7 +836,6 @@
 	struct ccs_acl_head head;
 	/* Structure for holding an IP address. */
 	struct ccs_ipaddr_union address;
-	bool is_not;
 };
 
 /* Subset of "struct stat". Used by conditional ACL and audit logs. */
@@ -944,40 +872,24 @@
 };
 
 /* Structure for entries which follows "struct ccs_condition". */
-struct ccs_condition_element {
-	/*
-	 * Left hand operand. A "struct ccs_argv" for CCS_ARGV_ENTRY, a
-	 * "struct ccs_envp" for CCS_ENVP_ENTRY is attached to the tail
-	 * of the array of this struct.
-	 */
-	u8 left;
-	/*
-	 * Right hand operand. A "struct ccs_number_union" for
-	 * CCS_NUMBER_UNION, a "struct ccs_name_union" for CCS_NAME_UNION is
-	 * attached to the tail of the array of this struct.
-	 */
-	u8 right;
-	/* Equation operator. True if equals or overlaps, false otherwise. */
-	bool equals;
+union ccs_condition_element {
+	struct {
+		u8 left;
+		u8 right;
+		bool equals;
+		u8 radix;
+	};
+	struct ccs_group *group;
+	const struct ccs_path_info *path;
+	u32 *ip; /* Repeat 4 times if IPv6 address. */
+	unsigned long value;
+	u8 grant_log; /* One of values in "enum ccs_grant_log". */
 };
 
 /* Structure for optional arguments. */
 struct ccs_condition {
-	struct ccs_shared_acl_head head;
 	u32 size; /* Memory size allocated for this entry. */
-	u16 condc; /* Number of conditions in this struct. */
-	u16 numbers_count; /* Number of "struct ccs_number_union values". */
-	u16 names_count; /* Number of "struct ccs_name_union names". */
-	u16 argc; /* Number of "struct ccs_argv". */
-	u16 envc; /* Number of "struct ccs_envp". */
-	u8 grant_log; /* One of values in "enum ccs_grant_log". */
-	/*
-	 * struct ccs_condition_element condition[condc];
-	 * struct ccs_number_union values[numbers_count];
-	 * struct ccs_name_union names[names_count];
-	 * struct ccs_argv argv[argc];
-	 * struct ccs_envp envp[envc];
-	 */
+	/* union ccs_condition_element condition[]; */
 };
 
 struct ccs_execve;
@@ -995,80 +907,24 @@
 	 * NULL if not dealing do_execve().
 	 */
 	struct ccs_execve *ee;
-	/* For holding parameters. Pointers in this union are not NULL. */
-	union {
-		struct {
-			const struct ccs_path_info *program;
-		} execute;
-		struct {
-			const struct ccs_path_info *filename;
-			/* One of values in "enum ccs_path_acl_index". */
-			u8 operation;
-		} path;
-		struct {
-			const struct ccs_path_info *filename1;
-			const struct ccs_path_info *filename2;
-			/* One of values in "enum ccs_path2_acl_index". */
-			u8 operation;
-		} path2;
-		struct {
-			const struct ccs_path_info *filename;
-			unsigned int mode;
-			unsigned int major;
-			unsigned int minor;
-			/* One of values in "enum ccs_mkdev_acl_index". */
-			u8 operation;
-		} mkdev;
-		struct {
-			const struct ccs_path_info *filename;
-			unsigned long number;
-			/*
-			 * One of values in "enum ccs_path_number_acl_index".
-			 */
-			u8 operation;
-		} path_number;
+	/* For holding parameters. */
+	struct ccs_request_param {
+		const struct ccs_path_info *s[3];
+		unsigned long i[3];
 #ifdef CONFIG_CCSECURITY_NETWORK
-		struct {
-			const u32 *address; /* Big endian. */
-			u16 port; /* Host endian. */
-			/* One of values smaller than CCS_SOCK_MAX. */
-			u8 protocol;
-			/* One of values in "enum ccs_network_acl_index". */
-			u8 operation;
-			bool is_ipv6;
-		} inet_network;
-		struct {
-			const struct ccs_path_info *address;
-			/* One of values smaller than CCS_SOCK_MAX. */
-			u8 protocol;
-			/* One of values in "enum ccs_network_acl_index". */
-			u8 operation;
-		} unix_network;
+		const u32 *inet_address;
+		const u8 *ipv6; /* Big endian. */
+		u32 ipv4;
+		u16 inet_port; /* Host endian. */
+		bool is_ipv6;
+		const struct ccs_path_info *unix_address;
 #endif
 #ifdef CONFIG_CCSECURITY_MISC
-		struct {
-			const struct ccs_path_info *name;
-		} environ;
+		const struct ccs_path_info *env_name;
 #endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-		struct {
-			/* One of values in "enum ccs_capability_acl_index". */
-			u8 operation;
-		} capability;
-#endif
 #ifdef CONFIG_CCSECURITY_IPC
-		struct {
-			const char *domainname;
-			unsigned long request;
-		} ptrace;
+		const char *domainname;
 #endif
-		struct {
-			const struct ccs_path_info *type;
-			const struct ccs_path_info *dir;
-			const struct ccs_path_info *dev;
-			unsigned long flags;
-			int need_dev;
-		} mount;
 #ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
 		struct {
 			const struct ccs_path_info *domainname;
@@ -1080,7 +936,11 @@
 	 * granted.
 	 */
 	struct ccs_acl_info *matched_acl;
-	u8 param_type; /* One of values in "enum ccs_acl_entry_type_index". */
+	/*
+	 * For holding operation index used for this request.
+	 * One of values in "enum ccs_mac_index".
+	 */
+	enum ccs_mac_index type;
 	bool granted; /* True if granted, false otherwise. */
 	/* True if rejected by inverse mode match, false otherwise. */
 	bool inversed;
@@ -1103,11 +963,6 @@
 	 * CCS_CONFIG_PERMISSIVE, CCS_CONFIG_ENFORCING.
 	 */
 	u8 mode;
-	/*
-	 * For holding operation index used for this request.
-	 * One of values in "enum ccs_mac_index".
-	 */
-	u8 type;
 };
 
 /* Structure for holding a token. */
@@ -1160,20 +1015,6 @@
 	const struct ccs_path_info *manager;
 };
 
-/* Structure for argv[]. */
-struct ccs_argv {
-	unsigned long index;
-	const struct ccs_path_info *value;
-	bool is_not;
-};
-
-/* Structure for envp[]. */
-struct ccs_envp {
-	const struct ccs_path_info *name;
-	const struct ccs_path_info *value;
-	bool is_not;
-};
-
 /*
  * Structure for "task auto_execute_handler" and "task denied_execute_handler"
  * directive.
@@ -1211,62 +1052,14 @@
 /* Structure for "file execute" directive. */
 struct ccs_execute_acl {
 	struct ccs_acl_info head; /* type = CCS_TYPE_EXECUTE_ACL */
-	struct ccs_name_union program;
+	struct ccs_path_info program;
 	const struct ccs_path_info *transit; /* Maybe NULL. */
 };
 
-/*
- * Structure for "file read", "file write", "file append", "file unlink",
- * "file getattr", "file rmdir", "file truncate", "file chroot" and
- * "file unmount" directive.
- */
-struct ccs_path_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_PATH_ACL */
-	struct ccs_name_union name;
-};
-
-/*
- * Structure for "file rename", "file link", "file pivot_root" and
- * "file symlink" directive.
- */
-struct ccs_path2_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_PATH2_ACL */
-	struct ccs_name_union name1;
-	struct ccs_name_union name2;
-};
-
-/*
- * Structure for "file create", "file mkdir", "file mkfifo", "file mksock",
- * "file ioctl", "file chmod", "file chown" and "file chgrp" directive.
- */
-struct ccs_path_number_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_PATH_NUMBER_ACL */
-	struct ccs_name_union name;
-	struct ccs_number_union number;
-};
-
-/* Structure for "file mkblock" and "file mkchar" directive. */
-struct ccs_mkdev_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_MKDEV_ACL */
-	struct ccs_name_union name;
-	struct ccs_number_union mode;
-	struct ccs_number_union major;
-	struct ccs_number_union minor;
-};
-
-/* Structure for "file mount" directive. */
-struct ccs_mount_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_MOUNT_ACL */
-	struct ccs_name_union dev_name;
-	struct ccs_name_union dir_name;
-	struct ccs_name_union fs_type;
-	struct ccs_number_union flags;
-};
-
 /* Structure for "misc env" directive in domain policy. */
 struct ccs_env_acl {
 	struct ccs_acl_info head;  /* type = CCS_TYPE_ENV_ACL  */
-	struct ccs_name_union env; /* environment variable */
+	const struct ccs_path_info *env; /* environment variable */
 };
 
 /* Structure for "capability" directive. */
@@ -1282,26 +1075,10 @@
 	const struct ccs_path_info *domainname;
 };
 
-/* Structure for "network inet" directive. */
-struct ccs_inet_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_INET_ACL */
-	u8 protocol;
-	struct ccs_ipaddr_union address;
-	struct ccs_number_union port;
-};
-
-/* Structure for "network unix" directive. */
-struct ccs_unix_acl {
-	struct ccs_acl_info head; /* type = CCS_TYPE_UNIX_ACL */
-	u8 protocol;
-	struct ccs_name_union name;
-};
-
 /* Structure for "use_group" directive. */
 struct ccs_use_group_acl {
 	struct ccs_acl_info head; /* type = CCS_TYPE_USE_GROUP_ACL */
 	struct ccs_group *group;
-	bool is_not;
 };
 
 /* Structure for holding string data. */
@@ -1321,17 +1098,9 @@
 		struct ccs_acl_info acl_info;
 		struct ccs_handler_acl handler_acl;
 		struct ccs_task_acl task_acl;
-		struct ccs_execute_acl execute_acl;
-		struct ccs_path_acl path_acl;
-		struct ccs_path2_acl path2_acl;
-		struct ccs_path_number_acl path_number_acl;
-		struct ccs_mkdev_acl mkdev_acl;
-		struct ccs_mount_acl mount_acl;
 		struct ccs_env_acl env_acl;
 		struct ccs_capability_acl capability_acl;
 		struct ccs_ptrace_acl ptrace_acl;
-		struct ccs_inet_acl inet_acl;
-		struct ccs_unix_acl unix_acl;
 		struct ccs_use_group_acl use_group_acl;
 		/**/
 		struct ccs_acl_head acl_head;
@@ -1449,7 +1218,7 @@
 					  const bool transit);
 void *ccs_commit_ok(void *data, const unsigned int size);
 void ccs_del_acl(struct list_head *element);
-void ccs_del_condition(struct list_head *element);
+void ccs_del_condition(struct ccs_condition *cond);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
 void ccs_get_attributes(struct ccs_obj_info *obj);
 void ccs_notify_gc(struct ccs_io_buffer *head, const bool is_register);
@@ -1459,11 +1228,6 @@
 /* Variable definition for internal use. */
 
 extern bool ccs_policy_loaded;
-extern const u8 ccs_c2mac[CCS_MAX_CAPABILITY_INDEX];
-extern const u8 ccs_p2mac[CCS_MAX_PATH_OPERATION];
-extern const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION];
-extern const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION];
-extern const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION];
 extern struct ccs_domain_info ccs_kernel_domain;
 extern struct ccs_group ccs_group_any;
 extern struct list_head ccs_condition_list;
@@ -1737,19 +1501,6 @@
 #endif
 
 /**
- * ccs_put_condition - Drop reference on "struct ccs_condition".
- *
- * @cond: Pointer to "struct ccs_condition". Maybe NULL.
- *
- * Returns nothing.
- */
-static inline void ccs_put_condition(struct ccs_condition *cond)
-{
-	if (cond)
-		atomic_dec(&cond->head.users);
-}
-
-/**
  * ccs_put_group - Drop reference on "struct ccs_group".
  *
  * @group: Pointer to "struct ccs_group". Maybe NULL.
Index: policy_io.c
===================================================================
--- policy_io.c	(revision 5754)
+++ policy_io.c	(working copy)
@@ -206,32 +206,6 @@
 #endif
 };
 
-#ifdef CONFIG_CCSECURITY_NETWORK
-
-/* String table for socket's operation. */
-static const char * const ccs_socket_keyword[CCS_MAX_NETWORK_OPERATION] = {
-	[CCS_NETWORK_BIND]    = "bind",
-	[CCS_NETWORK_LISTEN]  = "listen",
-	[CCS_NETWORK_CONNECT] = "connect",
-	[CCS_NETWORK_ACCEPT]  = "accept",
-	[CCS_NETWORK_SEND]    = "send",
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-	[CCS_NETWORK_RECV]    = "recv",
-#endif
-};
-
-/* String table for socket's protocols. */
-static const char * const ccs_proto_keyword[CCS_SOCK_MAX] = {
-	[SOCK_STREAM]    = "stream",
-	[SOCK_DGRAM]     = "dgram",
-	[SOCK_RAW]       = "raw",
-	[SOCK_SEQPACKET] = "seqpacket",
-	[0] = " ", /* Dummy for avoiding NULL pointer dereference. */
-	[4] = " ", /* Dummy for avoiding NULL pointer dereference. */
-};
-
-#endif
-
 /* String table for categories. */
 static const char * const ccs_category_keywords[CCS_MAX_MAC_CATEGORY_INDEX] = {
 	[CCS_MAC_CATEGORY_FILE]       = "file",
@@ -261,8 +235,8 @@
 	[CCS_TASK_FSGID]           = "task.fsgid",
 	[CCS_TASK_PID]             = "task.pid",
 	[CCS_TASK_PPID]            = "task.ppid",
-	[CCS_EXEC_ARGC]            = "exec.argc",
-	[CCS_EXEC_ENVC]            = "exec.envc",
+	[CCS_EXEC_ARGC]            = "argc",
+	[CCS_EXEC_ENVC]            = "envc",
 	[CCS_TYPE_IS_SOCKET]       = "socket",
 	[CCS_TYPE_IS_SYMLINK]      = "symlink",
 	[CCS_TYPE_IS_FILE]         = "file",
@@ -284,35 +258,110 @@
 	[CCS_MODE_OTHERS_EXECUTE]  = "others_execute",
 	[CCS_TASK_TYPE]            = "task.type",
 	[CCS_TASK_EXECUTE_HANDLER] = "execute_handler",
+	/*
 	[CCS_EXEC_REALPATH]        = "exec.realpath",
-	[CCS_PATH1_UID]            = "path1.uid",
-	[CCS_PATH1_GID]            = "path1.gid",
-	[CCS_PATH1_INO]            = "path1.ino",
-	[CCS_PATH1_MAJOR]          = "path1.major",
-	[CCS_PATH1_MINOR]          = "path1.minor",
-	[CCS_PATH1_PERM]           = "path1.perm",
-	[CCS_PATH1_TYPE]           = "path1.type",
-	[CCS_PATH1_DEV_MAJOR]      = "path1.dev_major",
-	[CCS_PATH1_DEV_MINOR]      = "path1.dev_minor",
-	[CCS_PATH2_UID]            = "path2.uid",
-	[CCS_PATH2_GID]            = "path2.gid",
-	[CCS_PATH2_INO]            = "path2.ino",
-	[CCS_PATH2_MAJOR]          = "path2.major",
-	[CCS_PATH2_MINOR]          = "path2.minor",
-	[CCS_PATH2_PERM]           = "path2.perm",
-	[CCS_PATH2_TYPE]           = "path2.type",
-	[CCS_PATH2_DEV_MAJOR]      = "path2.dev_major",
-	[CCS_PATH2_DEV_MINOR]      = "path2.dev_minor",
-	[CCS_PATH1_PARENT_UID]     = "path1.parent.uid",
-	[CCS_PATH1_PARENT_GID]     = "path1.parent.gid",
-	[CCS_PATH1_PARENT_INO]     = "path1.parent.ino",
-	[CCS_PATH1_PARENT_PERM]    = "path1.parent.perm",
-	[CCS_PATH2_PARENT_UID]     = "path2.parent.uid",
-	[CCS_PATH2_PARENT_GID]     = "path2.parent.gid",
-	[CCS_PATH2_PARENT_INO]     = "path2.parent.ino",
-	[CCS_PATH2_PARENT_PERM]    = "path2.parent.perm",
+	[CCS_COND_EXEC] = "exec",
+	[CCS_COND_PERM] = "perm",
+	[CCS_COND_SYMLINK] = "symlink",
+	[CCS_COND_DEV_MAJOR] = "dev_major",
+	[CCS_COND_DEV_MINOR] = "dev_minor",
+	[CCS_COND_NEW_PERM] = "new_perm",
+	[CCS_COND_NEW_UID] = "new_uid",
+	[CCS_COND_NEW_GID] = "new_gid",
+	[CCS_COND_CMD] = "cmd",
+	[CCS_COND_FSTYPE] = "fstype",
+	[CCS_COND_FLAGS] = "flags",
+	[CCS_COND_IP] = "ip",
+	[CCS_COND_PORT] = "port",
+	[CCS_COND_PROTO] = "proto",
+	[CCS_COND_ADDR] = "addr",
+	[CCS_COND_NAME] = "name",
+	*/
+	[CCS_COND_DOMAIN] = "domain",
 };
 
+/*
+#define bit(x) (1 << ((x) % 8))
+#define task_bits (bit(CCS_TASK_UID) | bit(CCS_TASK_EUID) | bit(CCS_TASK_SUID) | bit(CCS_TASK_FSUID) | bit(CCS_TASK_GID) | bit(CCS_TASK_EGID) | bit(CCS_TASK_SGID) | bit(CCS_TASK_FSGID) | bit(CCS_TASK_PID) | bit(CCS_TASK_PPID) | bit(CCS_TASK_TYPE))
+#define exec_bits (bit(CCS_COND_EXEC) | bit(CCS_EXEC_ARGC) | bit(CCS_EXEC_ENVC))
+
+static const u64 ccs_possible_arguments[CCS_MAX_MAC_INDEX] = {
+	[CCS_MAC_FILE_EXECUTE] = task_bits | exec_bits,
+	[CCS_MAC_FILE_READ] =  task_bits,
+	[CCS_MAC_FILE_WRITE] =  task_bits, 
+	[CCS_MAC_FILE_APPEND] =  task_bits,
+	[CCS_MAC_FILE_CREATE] =  bit(CCS_COND_PERM) | task_bits,
+	[CCS_MAC_FILE_UNLINK] =  task_bits,
+#ifdef CONFIG_CCSECURITY_FILE_GETATTR
+	[CCS_MAC_FILE_GETATTR] =  task_bits,
+#endif
+	[CCS_MAC_FILE_MKDIR] =  bit(CCS_COND_PERM) | task_bits,
+	[CCS_MAC_FILE_RMDIR] =  task_bits,
+	[CCS_MAC_FILE_MKFIFO] =  bit(CCS_COND_PERM) | task_bits,
+	[CCS_MAC_FILE_MKSOCK] =  bit(CCS_COND_PERM) | task_bits,
+	[CCS_MAC_FILE_TRUNCATE] =  task_bits,
+	[CCS_MAC_FILE_SYMLINK] =  bit(CCS_COND_SYMLINK) | task_bits,
+	[CCS_MAC_FILE_MKBLOCK] =  bit(CCS_COND_PERM) | bit(CCS_COND_DEV_MAJOR) | bit(CCS_COND_DEV_MINOR) | task_bits,
+	[CCS_MAC_FILE_MKCHAR] =  bit(CCS_COND_PERM) | bit(CCS_COND_DEV_MAJOR) | bit(CCS_COND_DEV_MINOR) | task_bits,
+	[CCS_MAC_FILE_LINK] = task_bits,
+	[CCS_MAC_FILE_RENAME] = task_bits,
+	[CCS_MAC_FILE_CHMOD] =  bit(CCS_COND_NEW_PERM) | task_bits,
+	[CCS_MAC_FILE_CHOWN] =  bit(CCS_COND_NEW_UID) | task_bits,
+	[CCS_MAC_FILE_CHGRP] =  bit(CCS_COND_NEW_GID) | task_bits,
+	[CCS_MAC_FILE_IOCTL] =  bit(CCS_COND_CMD) | task_bits,
+	[CCS_MAC_FILE_CHROOT] = task_bits,
+	[CCS_MAC_FILE_MOUNT] = bit(CCS_COND_FSTYPE) | bit(CCS_COND_FLAGS) | task_bits,
+	[CCS_MAC_FILE_UMOUNT] = task_bits,
+	[CCS_MAC_FILE_PIVOT_ROOT] = task_bits,
+#ifdef CONFIG_CCSECURITY_NETWORK
+	[CCS_MAC_NETWORK_INET_STREAM_BIND] = bit(CCS_COND_IP) | bit(CCS_COND_PORT) | task_bits,
+	[CCS_MAC_NETWORK_INET_STREAM_LISTEN] = bit(CCS_COND_IP) | bit(CCS_COND_PORT) | task_bits,
+	[CCS_MAC_NETWORK_INET_STREAM_CONNECT] = bit(CCS_COND_IP) | bit(CCS_COND_PORT) | task_bits,
+	[CCS_MAC_NETWORK_INET_STREAM_ACCEPT] = bit(CCS_COND_IP) | bit(CCS_COND_PORT) | task_bits,
+	[CCS_MAC_NETWORK_INET_DGRAM_BIND] = bit(CCS_COND_IP) | bit(CCS_COND_PORT) | task_bits,
+	[CCS_MAC_NETWORK_INET_DGRAM_SEND] = bit(CCS_COND_IP) | bit(CCS_COND_PORT) | task_bits,
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+	[CCS_MAC_NETWORK_INET_DGRAM_RECV] = bit(CCS_COND_IP) | bit(CCS_COND_PORT) | task_bits,
+#endif
+	[CCS_MAC_NETWORK_INET_RAW_BIND] = bit(CCS_COND_IP) | bit(CCS_COND_PROTO) | task_bits,
+	[CCS_MAC_NETWORK_INET_RAW_SEND] = bit(CCS_COND_IP) | bit(CCS_COND_PROTO) | task_bits,
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+	[CCS_MAC_NETWORK_INET_RAW_RECV] = bit(CCS_COND_IP) | bit(CCS_COND_PROTO) | task_bits,
+#endif
+	[CCS_MAC_NETWORK_UNIX_STREAM_BIND] = bit(CCS_COND_ADDR) | task_bits,
+	[CCS_MAC_NETWORK_UNIX_STREAM_LISTEN] = bit(CCS_COND_ADDR) | task_bits,
+	[CCS_MAC_NETWORK_UNIX_STREAM_CONNECT] = bit(CCS_COND_ADDR) | task_bits,
+	[CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT] = bit(CCS_COND_ADDR) | task_bits,
+	[CCS_MAC_NETWORK_UNIX_DGRAM_BIND] = bit(CCS_COND_ADDR) | task_bits,
+	[CCS_MAC_NETWORK_UNIX_DGRAM_SEND] = bit(CCS_COND_ADDR) | task_bits,
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+	[CCS_MAC_NETWORK_UNIX_DGRAM_RECV] = bit(CCS_COND_ADDR) | task_bits,
+#endif
+	[CCS_MAC_NETWORK_UNIX_SEQPACKET_BIND] = bit(CCS_COND_ADDR) | task_bits,
+	[CCS_MAC_NETWORK_UNIX_SEQPACKET_LISTEN] = bit(CCS_COND_ADDR) | task_bits,
+	[CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] = bit(CCS_COND_ADDR) | task_bits,
+	[CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT] = bit(CCS_COND_ADDR) | task_bits,
+#endif
+#ifdef CONFIG_CCSECURITY_MISC
+	[CCS_MAC_ENVIRON] = bit(CCS_COND_NAME) | task_bits | exec_bits,
+#endif
+#ifdef CONFIG_CCSECURITY_IPC
+	[CCS_MAC_PTRACE] = bit(CCS_COND_CMD) | bit(CCS_COND_DOMAIN) | task_bits,
+#endif
+#ifdef CONFIG_CCSECURITY_CAPABILITY
+	[CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET] = task_bits,
+	[CCS_MAC_CAPABILITY_USE_PACKET_SOCKET] = task_bits,
+	[CCS_MAC_CAPABILITY_SYS_REBOOT] = task_bits,
+	[CCS_MAC_CAPABILITY_SYS_VHANGUP] = task_bits,
+	[CCS_MAC_CAPABILITY_SYS_SETTIME] = task_bits,
+	[CCS_MAC_CAPABILITY_SYS_NICE] = task_bits,
+	[CCS_MAC_CAPABILITY_SYS_SETHOSTNAME] = task_bits,
+	[CCS_MAC_CAPABILITY_USE_KERNEL_MODULE] = task_bits,
+	[CCS_MAC_CAPABILITY_SYS_KEXEC_LOAD] = task_bits,
+#endif
+};
+*/
+
 /* String table for PREFERENCE keyword. */
 static const char * const ccs_pref_keywords[CCS_MAX_PREF] = {
 	[CCS_PREF_MAX_AUDIT_LOG]      = "max_audit_log",
@@ -388,25 +437,17 @@
 static bool ccs_has_more_namespace(struct ccs_io_buffer *head);
 static bool ccs_manager(void);
 static bool ccs_namespace_jump(const char *domainname);
-static bool ccs_parse_argv(char *left, char *right, struct ccs_argv *argv);
-static bool ccs_parse_envp(char *left, char *right, struct ccs_envp *envp);
-static bool ccs_parse_name_union(struct ccs_acl_param *param,
-				 struct ccs_name_union *ptr);
-static bool ccs_parse_name_union_quoted(struct ccs_acl_param *param,
-					struct ccs_name_union *ptr);
 static bool ccs_parse_number_union(struct ccs_acl_param *param,
 				   struct ccs_number_union *ptr);
-static bool ccs_permstr(const char *string, const char *keyword);
 static bool ccs_print_condition(struct ccs_io_buffer *head,
+				const enum ccs_mac_index type,
 				const struct ccs_condition *cond);
 static bool ccs_print_entry(struct ccs_io_buffer *head,
 			    const struct ccs_acl_info *acl);
-static bool ccs_print_group(struct ccs_io_buffer *head, const bool is_not,
+static bool ccs_print_group(struct ccs_io_buffer *head,
 			    const struct ccs_group *group);
 static bool ccs_read_acl(struct ccs_io_buffer *head, struct list_head *list);
 static bool ccs_read_group(struct ccs_io_buffer *head, const int idx);
-static bool ccs_same_condition(const struct ccs_condition *a,
-			       const struct ccs_condition *b);
 static bool ccs_select_domain(struct ccs_io_buffer *head, const char *data);
 static bool ccs_set_lf(struct ccs_io_buffer *head);
 static bool ccs_str_starts(char **src, const char *find);
@@ -462,7 +503,6 @@
 			     loff_t *ppos);
 static ssize_t ccs_write(struct file *file, const char __user *buf,
 			 size_t count, loff_t *ppos);
-static struct ccs_condition *ccs_commit_condition(struct ccs_condition *entry);
 static struct ccs_condition *ccs_get_condition(struct ccs_acl_param *param);
 static struct ccs_domain_info *ccs_find_domain(const char *domainname);
 static struct ccs_domain_info *ccs_find_domain_by_qid(unsigned int serial);
@@ -477,7 +517,6 @@
 static struct ccs_profile *ccs_profile(const u8 profile);
 static u8 ccs_condition_type(const char *word);
 static u8 ccs_get_config(const u8 profile, const u8 index);
-static u8 ccs_group_type(char **src);
 static u8 ccs_make_byte(const u8 c1, const u8 c2, const u8 c3);
 static u8 ccs_parse_ulong(unsigned long *result, char **str);
 static unsigned int ccs_poll(struct file *file, poll_table *wait);
@@ -498,10 +537,6 @@
 	__printf(2, 3);
 static void ccs_normalize_line(unsigned char *buffer);
 static void ccs_print_config(struct ccs_io_buffer *head, const u8 config);
-static void ccs_print_name_union(struct ccs_io_buffer *head,
-				 const struct ccs_name_union *ptr);
-static void ccs_print_name_union_quoted(struct ccs_io_buffer *head,
-					const struct ccs_name_union *ptr);
 static void ccs_print_namespace(struct ccs_io_buffer *head);
 static void ccs_print_number_union(struct ccs_io_buffer *head,
 				   const struct ccs_number_union *ptr);
@@ -519,7 +554,6 @@
 static void ccs_read_version(struct ccs_io_buffer *head);
 static void ccs_set_group(struct ccs_io_buffer *head, const char *category);
 static void ccs_set_namespace_cursor(struct ccs_io_buffer *head);
-static void ccs_set_slash(struct ccs_io_buffer *head);
 static void ccs_set_space(struct ccs_io_buffer *head);
 static void ccs_set_string(struct ccs_io_buffer *head, const char *string);
 static void ccs_set_uint(unsigned int *i, const char *string,
@@ -1154,6 +1188,30 @@
 
 #endif
 
+/**
+ * ccs_get_objname - Get attribute name of file argument.
+ *
+ * @type:  One of values in "enum ccs_mac_index".
+ * @first: True if first pathname, false otherwise.
+ *
+ * Returns attribute name.
+ */
+static const char *ccs_get_objname(const enum ccs_mac_index type,
+				   const bool first)
+{
+	switch (type) {
+        case CCS_MAC_FILE_LINK:
+        case CCS_MAC_FILE_RENAME:
+		return first ? "old_path" : "new_path";
+	case CCS_MAC_FILE_MOUNT:
+		return first ? "source" : "target";
+	case CCS_MAC_FILE_PIVOT_ROOT:
+		return first ? "new_root" : "put_old";
+	default:
+		return "path";
+	}
+}
+	
 /***** SECTION5: Variables definition section *****/
 
 /* Permit policy management by non-root user? */
@@ -1437,33 +1495,6 @@
 }
 
 /**
- * ccs_parse_name_union - Parse a ccs_name_union.
- *
- * @param: Pointer to "struct ccs_acl_param".
- * @ptr:   Pointer to "struct ccs_name_union".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_name_union(struct ccs_acl_param *param,
-				 struct ccs_name_union *ptr)
-{
-	char *filename;
-	switch (ccs_group_type(&param->data)) {
-	case 2:
-		ptr->is_not = true;
-		/* fall through */
-	case 1:
-		ptr->group = ccs_get_group(param, CCS_PATH_GROUP);
-		return ptr->group != NULL;
-	}
-	filename = ccs_read_token(param);
-	if (!ccs_correct_word(filename))
-		return false;
-	ptr->filename = ccs_get_name(filename);
-	return ptr->filename != NULL;
-}
-
-/**
  * ccs_parse_ulong - Parse an "unsigned long" value.
  *
  * @result: Pointer to "unsigned long".
@@ -1518,11 +1549,7 @@
 	u8 type;
 	unsigned long v;
 	memset(ptr, 0, sizeof(*ptr));
-	switch (ccs_group_type(&param->data)) {
-	case 2:
-		ptr->is_not = true;
-		/* fall through */
-	case 1:
+	if (ccs_str_starts(&param->data, "@")) {
 		ptr->group = ccs_get_group(param, CCS_NUMBER_GROUP);
 		return ptr->group != NULL;
 	}
@@ -1564,11 +1591,7 @@
 	u8 * const max = ptr->ip[1].in6_u.u6_addr8;
 	char *address;
 	const char *end;
-	switch (ccs_group_type(&param->data)) {
-	case 2:
-		ptr->is_not = true;
-		/* fall through */
-	case 1:
+	if (ccs_str_starts(&param->data, "@")) {
 		ptr->group = ccs_get_group(param, CCS_ADDRESS_GROUP);
 		return ptr->group != NULL;
 	}
@@ -1616,99 +1639,6 @@
 }
 
 /**
- * ccs_parse_name_union_quoted - Parse a quoted word.
- *
- * @param: Pointer to "struct ccs_acl_param".
- * @ptr:   Pointer to "struct ccs_name_union".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_name_union_quoted(struct ccs_acl_param *param,
-					struct ccs_name_union *ptr)
-{
-	char *filename = param->data;
-	if (ccs_group_type(&filename))
-		return ccs_parse_name_union(param, ptr);
-	ptr->filename = ccs_get_dqword(filename);
-	return ptr->filename != NULL;
-}
-
-/**
- * ccs_parse_argv - Parse an argv[] condition part.
- *
- * @left:  Lefthand value.
- * @right: Righthand value.
- * @argv:  Pointer to "struct ccs_argv".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_argv(char *left, char *right, struct ccs_argv *argv)
-{
-	if (ccs_parse_ulong(&argv->index, &left) != CCS_VALUE_TYPE_DECIMAL ||
-	    *left++ != ']' || *left)
-		return false;
-	argv->value = ccs_get_dqword(right);
-	return argv->value != NULL;
-}
-
-/**
- * ccs_parse_envp - Parse an envp[] condition part.
- *
- * @left:  Lefthand value.
- * @right: Righthand value.
- * @envp:  Pointer to "struct ccs_envp".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_envp(char *left, char *right, struct ccs_envp *envp)
-{
-	const struct ccs_path_info *name;
-	const struct ccs_path_info *value;
-	char *cp = left + strlen(left) - 1;
-	if (*cp-- != ']' || *cp != '"')
-		goto out;
-	*cp = '\0';
-	if (!ccs_correct_word(left))
-		goto out;
-	name = ccs_get_name(left);
-	if (!name)
-		goto out;
-	if (!strcmp(right, "NULL")) {
-		value = NULL;
-	} else {
-		value = ccs_get_dqword(right);
-		if (!value) {
-			ccs_put_name(name);
-			goto out;
-		}
-	}
-	envp->name = name;
-	envp->value = value;
-	return true;
-out:
-	return false;
-}
-
-/**
- * ccs_same_condition - Check for duplicated "struct ccs_condition" entry.
- *
- * @a: Pointer to "struct ccs_condition".
- * @b: Pointer to "struct ccs_condition".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_condition(const struct ccs_condition *a,
-			       const struct ccs_condition *b)
-{
-	return a->size == b->size && a->condc == b->condc &&
-		a->numbers_count == b->numbers_count &&
-		a->names_count == b->names_count &&
-		a->argc == b->argc && a->envc == b->envc &&
-		a->grant_log == b->grant_log &&
-		!memcmp(a + 1, b + 1, a->size - sizeof(*a));
-}
-
-/**
  * ccs_condition_type - Get condition type.
  *
  * @word: Keyword string.
@@ -1727,54 +1657,6 @@
 }
 
 /**
- * ccs_commit_condition - Commit "struct ccs_condition".
- *
- * @entry: Pointer to "struct ccs_condition".
- *
- * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
- *
- * This function merges duplicated entries. This function returns NULL if
- * @entry is not duplicated but memory quota for policy has exceeded.
- */
-static struct ccs_condition *ccs_commit_condition(struct ccs_condition *entry)
-{
-	struct ccs_condition *ptr;
-	bool found = false;
-	if (mutex_lock_interruptible(&ccs_policy_lock)) {
-		dprintk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);
-		ptr = NULL;
-		found = true;
-		goto out;
-	}
-	list_for_each_entry(ptr, &ccs_condition_list, head.list) {
-		if (!ccs_same_condition(ptr, entry) ||
-		    atomic_read(&ptr->head.users) == CCS_GC_IN_PROGRESS)
-			continue;
-		/* Same entry found. Share this entry. */
-		atomic_inc(&ptr->head.users);
-		found = true;
-		break;
-	}
-	if (!found) {
-		if (ccs_memory_ok(entry, entry->size)) {
-			atomic_set(&entry->head.users, 1);
-			list_add(&entry->head.list, &ccs_condition_list);
-		} else {
-			found = true;
-			ptr = NULL;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
-out:
-	if (found) {
-		ccs_del_condition(&entry->head.list);
-		kfree(entry);
-		entry = ptr;
-	}
-	return entry;
-}
-
-/**
  * ccs_correct_path - Check whether the given pathname follows the naming rules.
  *
  * @filename: The pathname to check.
@@ -1924,6 +1806,173 @@
 	return NULL;
 }
 
+static u8 ccs_find_path_attributes(const enum ccs_mac_index type, char *word)
+{
+	static const char *const k[CCS_MAX_PATH_ATTRIBUTE] = {
+		[CCS_PATH_ATTRIBUTE_NAME]      = "name",	
+		[CCS_PATH_ATTRIBUTE_UID]       = "uid",
+		[CCS_PATH_ATTRIBUTE_GID]       = "gid",
+		[CCS_PATH_ATTRIBUTE_INO]       = "ino",
+		[CCS_PATH_ATTRIBUTE_MAJOR]     = "major",
+		[CCS_PATH_ATTRIBUTE_MINOR]     = "minor",
+		[CCS_PATH_ATTRIBUTE_PERM]      = "perm",
+		[CCS_PATH_ATTRIBUTE_TYPE]      = "type",
+		[CCS_PATH_ATTRIBUTE_DEV_MAJOR] = "dev_major",
+		[CCS_PATH_ATTRIBUTE_DEV_MINOR] = "dev_minor",
+	};
+	u8 i;
+	u8 index;
+	if (ccs_str_starts(&word, ccs_get_objname(type, true)))
+		index = CCS_PATH_ATTRIBUTE_START;
+	else if (ccs_str_starts(&word, ccs_get_objname(type, false)))
+		index = CCS_PATH_ATTRIBUTE_START + 32;
+	else
+		return CCS_MAX_CONDITION_KEYWORD;
+	if (ccs_str_starts(&word, ".parent"))
+		index += 16;
+	if (!*word)
+		return index;
+	if (*word++ == '.')
+		for (i = 0; i < CCS_MAX_PATH_ATTRIBUTE; i++)
+			if (!strcmp(word, k[i]))
+				return index + i;
+	return CCS_MAX_CONDITION_KEYWORD;
+}
+
+struct ccs_cond_tmp {
+	u8 left;
+	u8 right;
+	bool equals;
+	u8 radix;
+	struct ccs_group *group;
+	const struct ccs_path_info *path;
+	struct in6_addr ipv6[2];
+	unsigned long value[2];
+	unsigned long argv;
+	const struct ccs_path_info *envp;
+};
+
+static bool ccs_parse_cond(struct ccs_cond_tmp *tmp,
+			   struct ccs_acl_param *param)
+{
+	char *left = param->data;
+	char *right;
+	char *pos = strchr(left, ' ');
+	memset(tmp, 0, sizeof(*tmp));
+	if (pos)
+		*pos++ = '\0';
+	else
+		pos = "";
+	right = strchr(left, '=');
+	if (!right || right == left)
+		return false;
+	*right++ = '\0';
+	tmp->equals = *(right - 2) != '!';
+	if (!tmp->equals)
+		*(right - 2) = '\0';
+	dprintk(KERN_WARNING "%u: <%s>%s=<%s>\n", __LINE__, left,
+		tmp->equals ? "" : "!", right);
+	if (ccs_str_starts(&left, "argv[")) {
+		tmp->left = CCS_ARGV_ENTRY;
+		if (ccs_parse_ulong(&tmp->argv, &left) !=
+		    CCS_VALUE_TYPE_DECIMAL || *left++ != ']' || *left)
+			goto out;
+		goto check_right;
+	}
+	if (ccs_str_starts(&left, "envp[\"")) {
+		char *cp = left + strlen(left) - 1;
+		tmp->left = CCS_ENVP_ENTRY;
+		if (*cp-- != ']' || *cp != '"')
+			goto out;
+		*cp = '\0';
+		if (!ccs_correct_word(left))
+			goto out;
+		tmp->envp = ccs_get_name(left);
+		if (!tmp->envp)
+			goto out;
+		goto check_right;
+	}
+	tmp->left = ccs_condition_type(left);
+	if (tmp->left == CCS_MAX_CONDITION_KEYWORD)
+		tmp->left = ccs_find_path_attributes(param->e.acl_info.type,
+						     left);
+	if (tmp->left == CCS_MAX_CONDITION_KEYWORD)
+		goto out;
+check_right:
+	if (*right == '@') {
+		tmp->right = CCS_IMM_GROUP;
+		param->data = right;
+		if (tmp->left == CCS_ARGV_ENTRY ||
+		    tmp->left == CCS_ENVP_ENTRY) {
+			tmp->group = ccs_get_group(param, CCS_PATH_GROUP);
+			if (!tmp->group)
+				goto out;
+		}
+	} else if (*right == '"') {
+		tmp->right = CCS_IMM_NAME_ENTRY;
+		tmp->path = ccs_get_dqword(right);
+		if (!tmp->path)
+			goto out;
+	} else if (tmp->left == CCS_ENVP_ENTRY) {
+		tmp->right = CCS_IMM_NAME_ENTRY;
+		if (strcmp(right, "NULL"))
+			goto out;
+	} else if (strchr(right, '-')) {
+		tmp->right = CCS_IMM_NUMBER_ENTRY2;
+		//tmp->right = CCS_IMM_IPV6ADDR_ENTRY2;
+	} else {
+		tmp->right = CCS_IMM_NUMBER_ENTRY1;
+		//tmp->right = CCS_IMM_IPV6ADDR_ENTRY1;
+	}
+	/* TODO: Validate combination. */ 
+	if (tmp->left == CCS_ARGV_ENTRY || tmp->left == CCS_ENVP_ENTRY) {
+		if (tmp->right != CCS_IMM_GROUP &&
+		    tmp->right != CCS_IMM_NAME_ENTRY)
+			goto out;
+		return true;
+	}
+	if (tmp->left == CCS_MAX_CONDITION_KEYWORD) {
+		tmp->left = CCS_IMM_NUMBER_ENTRY1;
+		//param->data = left;
+	}
+	//switch (tmp->left) {
+	//case CCS_PATH_ATTRIBUTE_START:
+	//case CCS_PATH_ATTRIBUTE_START + 32:
+	//case CCS_COND_EXEC:
+	//case CCS_COND_SYMLINK:
+	//case CCS_COND_FSTYPE:
+	//case CCS_COND_ADDR:
+	//case CCS_COND_NAME:
+	/* TODO: Check permissions validity. */
+	//right = CCS_IMM_NAME_ENTRY;
+	//param->data = right_word;
+	//goto store_value;
+	//case CCS_COND_IP:
+	/*
+	 * Only inet socket permissions are allowed to
+	 * have this argument.
+	 */
+	/*
+	if (param->e.acl_info.type <
+	    CCS_MAC_NETWORK_INET_STREAM_BIND ||
+	    param->e.acl_info.type > CCS_MAC_NETWORK_INET_RAW_RECV)
+		goto out;
+	tmp->right = CCS_IMM_IPV6ADDR_ENTRY1;
+	if (!ccs_parse_ipaddr_union(param, tmp->ip))
+		goto out;
+	*/
+	//goto store_value;
+	//case CCS_COND_DOMAIN:
+	//	goto out;
+	//}
+	return true;
+out:
+	ccs_put_name(tmp->envp);
+	ccs_put_name(tmp->path);
+	ccs_put_group(tmp->group);
+	return false;
+}
+
 /**
  * ccs_get_condition - Parse condition part.
  *
@@ -1933,204 +1982,80 @@
  */
 struct ccs_condition *ccs_get_condition(struct ccs_acl_param *param)
 {
-	struct ccs_condition *entry = NULL;
-	struct ccs_condition_element *condp = NULL;
-	struct ccs_number_union *numbers_p = NULL;
-	struct ccs_name_union *names_p = NULL;
-	struct ccs_argv *argv = NULL;
-	struct ccs_envp *envp = NULL;
-	struct ccs_condition e = { };
-	char * const start_of_string = param->data;
-	char * const end_of_string = start_of_string + strlen(start_of_string);
-	char *pos;
-rerun:
-	pos = start_of_string;
+	struct ccs_condition *entry = kmalloc(PAGE_SIZE, CCS_GFP_FLAGS);
+	union ccs_condition_element *condp;
+	struct ccs_cond_tmp tmp;
+	char *pos = param->data;
+	if (!entry)
+		return NULL;
+	entry->size = sizeof(*entry);
+	condp = (union ccs_condition_element *) (entry + 1);
 	while (1) {
-		u8 left = -1;
-		u8 right = -1;
-		char *left_word = pos;
-		char *cp;
-		char *right_word;
-		bool is_not;
-		if (!*left_word)
+		while (*pos == ' ')
+			pos++;
+		if (!*pos)
 			break;
-		/*
-		 * Since left-hand condition does not allow use of "path_group"
-		 * or "number_group" and environment variable's names do not
-		 * accept '=', it is guaranteed that the original line consists
-		 * of one or more repetition of $left$operator$right blocks
-		 * where "$left is free from '=' and ' '" and "$operator is
-		 * either '=' or '!='" and "$right is free from ' '".
-		 * Therefore, we can reconstruct the original line at the end
-		 * of dry run even if we overwrite $operator with '\0'.
-		 */
-		cp = strchr(pos, ' ');
-		if (cp) {
-			*cp = '\0'; /* Will restore later. */
-			pos = cp + 1;
-		} else {
-			pos = "";
+		{
+			char *next = strchr(pos, ' ');
+			if (next)
+				*next++ = '\0';
+			else
+				next = "";
+			param->data = pos;
+			pos = next;
 		}
-		right_word = strchr(left_word, '=');
-		if (!right_word || right_word == left_word)
+		if (!ccs_parse_cond(&tmp, param))
 			goto out;
-		is_not = *(right_word - 1) == '!';
-		if (is_not)
-			*(right_word++ - 1) = '\0'; /* Will restore later. */
-		else if (*(right_word + 1) != '=')
-			*right_word++ = '\0'; /* Will restore later. */
-		else
-			goto out;
-		dprintk(KERN_WARNING "%u: <%s>%s=<%s>\n", __LINE__, left_word,
-			is_not ? "!" : "", right_word);
-		if (!strcmp(left_word, "grant_log")) {
-			if (entry) {
-				if (is_not ||
-				    entry->grant_log != CCS_GRANTLOG_AUTO)
-					goto out;
-				else if (!strcmp(right_word, "yes"))
-					entry->grant_log = CCS_GRANTLOG_YES;
-				else if (!strcmp(right_word, "no"))
-					entry->grant_log = CCS_GRANTLOG_NO;
-				else
-					goto out;
-			}
-			continue;
+		// TODO: reallocate as needed.
+		condp->equals = tmp.equals;
+		condp->left = tmp.left;
+		condp->right = tmp.right;
+		condp->radix = tmp.radix;
+		condp++;
+		if (tmp.left == CCS_ARGV_ENTRY) {
+			condp->value = tmp.argv;
+			condp++;
+		} else if (tmp.left == CCS_ENVP_ENTRY) {
+			condp->path = tmp.envp;
+			condp++;
 		}
-		if (!strncmp(left_word, "exec.argv[", 10)) {
-			if (!argv) {
-				e.argc++;
-				e.condc++;
-			} else {
-				e.argc--;
-				e.condc--;
-				left = CCS_ARGV_ENTRY;
-				argv->is_not = is_not;
-				if (!ccs_parse_argv(left_word + 10,
-						    right_word, argv++))
-					goto out;
-			}
-			goto store_value;
+		if (tmp.right == CCS_IMM_GROUP) {
+			condp->group = tmp.group;
+			condp++;
+		} else if (tmp.right == CCS_IMM_NAME_ENTRY) {
+			condp->path = tmp.envp;
+			condp++;
+		} else if (tmp.right == CCS_IMM_NUMBER_ENTRY1) {
+			condp->value = tmp.value[0];
+			condp++;
+		} else if (tmp.right == CCS_IMM_NUMBER_ENTRY2) {
+			condp->value = tmp.value[0];
+			condp++;
+			condp->value = tmp.value[1];
+			condp++;
+		} else if (tmp.right == CCS_IMM_IPV6ADDR_ENTRY1) {
+			* (struct in6_addr *) condp = tmp.ipv6[0];
+			condp = (void *)
+				(((u8 *) condp) + sizeof(struct in6_addr));
+		} else if (tmp.right == CCS_IMM_IPV6ADDR_ENTRY2) {
+			* (struct in6_addr *) condp = tmp.ipv6[0];
+			condp = (void *)
+				(((u8 *) condp) + sizeof(struct in6_addr));
+			* (struct in6_addr *) condp = tmp.ipv6[1];
+			condp = (void *)
+				(((u8 *) condp) + sizeof(struct in6_addr));
 		}
-		if (!strncmp(left_word, "exec.envp[\"", 11)) {
-			if (!envp) {
-				e.envc++;
-				e.condc++;
-			} else {
-				e.envc--;
-				e.condc--;
-				left = CCS_ENVP_ENTRY;
-				envp->is_not = is_not;
-				if (!ccs_parse_envp(left_word + 11,
-						    right_word, envp++))
-					goto out;
-			}
-			goto store_value;
-		}
-		left = ccs_condition_type(left_word);
-		dprintk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__, left_word,
-			left);
-		if (left == CCS_MAX_CONDITION_KEYWORD) {
-			if (!numbers_p) {
-				e.numbers_count++;
-			} else {
-				e.numbers_count--;
-				left = CCS_NUMBER_UNION;
-				param->data = left_word;
-				if (ccs_group_type(&left_word) ||
-				    !ccs_parse_number_union(param,
-							    numbers_p++))
-					goto out;
-			}
-		}
-		if (!condp)
-			e.condc++;
-		else
-			e.condc--;
-		if (left == CCS_EXEC_REALPATH) {
-			if (!names_p) {
-				e.names_count++;
-			} else {
-				e.names_count--;
-				right = CCS_NAME_UNION;
-				param->data = right_word;
-				if (!ccs_parse_name_union_quoted(param,
-								 names_p++))
-					goto out;
-			}
-			goto store_value;
-		}
-		right = ccs_condition_type(right_word);
-		if (right == CCS_MAX_CONDITION_KEYWORD) {
-			if (!numbers_p) {
-				e.numbers_count++;
-			} else {
-				e.numbers_count--;
-				right = CCS_NUMBER_UNION;
-				param->data = right_word;
-				if (!ccs_parse_number_union(param,
-							    numbers_p++))
-					goto out;
-			}
-		}
-store_value:
-		if (!condp) {
-			dprintk(KERN_WARNING "%u: dry_run left=%u right=%u "
-				"match=%u\n", __LINE__, left, right, !is_not);
-			continue;
-		}
-		condp->left = left;
-		condp->right = right;
-		condp->equals = !is_not;
-		dprintk(KERN_WARNING "%u: left=%u right=%u match=%u\n",
-			__LINE__, condp->left, condp->right,
-			condp->equals);
-		condp++;
 	}
-	dprintk(KERN_INFO "%u: cond=%u numbers=%u names=%u ac=%u ec=%u\n",
-		__LINE__, e.condc, e.numbers_count, e.names_count, e.argc,
-		e.envc);
-	if (entry) {
-		BUG_ON(e.names_count | e.numbers_count | e.argc | e.envc |
-		       e.condc);
-		return ccs_commit_condition(entry);
+	if (mutex_lock_interruptible(&ccs_policy_lock) == 0) {
+		bool ok = ccs_memory_ok(entry, entry->size);
+		mutex_unlock(&ccs_policy_lock);
+		if (ok)
+			return entry;
 	}
-	e.size = sizeof(*entry)
-		+ e.condc * sizeof(struct ccs_condition_element)
-		+ e.numbers_count * sizeof(struct ccs_number_union)
-		+ e.names_count * sizeof(struct ccs_name_union)
-		+ e.argc * sizeof(struct ccs_argv)
-		+ e.envc * sizeof(struct ccs_envp);
-	entry = kzalloc(e.size, CCS_GFP_FLAGS);
-	if (!entry)
-		return NULL;
-	*entry = e;
-	condp = (struct ccs_condition_element *) (entry + 1);
-	numbers_p = (struct ccs_number_union *) (condp + e.condc);
-	names_p = (struct ccs_name_union *) (numbers_p + e.numbers_count);
-	argv = (struct ccs_argv *) (names_p + e.names_count);
-	envp = (struct ccs_envp *) (argv + e.argc);
-	{
-		bool flag = false;
-		for (pos = start_of_string; pos < end_of_string; pos++) {
-			if (*pos)
-				continue;
-			if (flag) /* Restore " ". */
-				*pos = ' ';
-			else if (*(pos + 1) == '=') /* Restore "!=". */
-				*pos = '!';
-			else /* Restore "=". */
-				*pos = '=';
-			flag = !flag;
-		}
-	}
-	goto rerun;
 out:
 	dprintk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);
-	if (entry) {
-		ccs_del_condition(&entry->head.list);
-		kfree(entry);
-	}
+	ccs_del_condition(entry);
+	kfree(entry);
 	return NULL;
 }
 
@@ -2280,18 +2205,6 @@
 }
 
 /**
- * ccs_set_slash - Put a shash to "struct ccs_io_buffer" structure.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns nothing.
- */
-static void ccs_set_slash(struct ccs_io_buffer *head)
-{
-	ccs_set_string(head, "/");
-}
-
-/**
  * ccs_init_policy_namespace - Initialize namespace.
  *
  * @ns: Pointer to "struct ccs_policy_namespace".
@@ -2509,39 +2422,18 @@
 }
 
 /**
- * ccs_group_type - Check whether the given string refers group or not.
- *
- * @src:  Pointer to pointer to the string.
- *
- * Returns 1 if @src refers a group in positive match, 2 if psrc refers a group
- * in negative match, 0 otherwise.
- *
- * The @src is updated to point the first character of a group name if @src
- * refers a group.
- */
-static u8 ccs_group_type(char **src)
-{
-	if (ccs_str_starts(src, "\\="))
-		return 1;
-	if (ccs_str_starts(src, "\\!"))
-		return 2;
-	return 0;
-}
-
-/**
  * ccs_print_group - Print group's name.
  *
  * @head:   Pointer to "struct ccs_io_buffer".
- * @is_not: True if @group is negative match, false otherwise.
  * @group:  Pointer to "struct ccsgroup". Maybe NULL.
  *
  * Returns true if @group is not NULL. false otherwise.
  */
-static bool ccs_print_group(struct ccs_io_buffer *head, const bool is_not,
+static bool ccs_print_group(struct ccs_io_buffer *head,
 			    const struct ccs_group *group)
 {
 	if (group) {
-		ccs_set_string(head, is_not ? "\\!" : "\\=");
+		ccs_set_string(head, "@");
 		ccs_set_string(head, group->group_name->name);
 		return true;
 	}
@@ -3054,7 +2946,7 @@
 	list_for_each_entry_srcu(entry, &ccs_inversed_acl_list, list,
 				 &ccs_ss) {
 		if (entry->is_deleted == CCS_GC_IN_PROGRESS ||
-		    entry->perm != new_entry->perm ||
+		    //entry->perm != new_entry->perm ||
 		    entry->type != new_entry->type ||
 		    entry->cond != new_entry->cond ||
 		    memcmp(entry + 1, new_entry + 1, size - sizeof(*entry)))
@@ -3110,11 +3002,7 @@
 		    entry->cond != new_entry->cond ||
 		    memcmp(entry + 1, new_entry + 1, size - sizeof(*entry)))
 			continue;
-		if (is_delete)
-			entry->perm &= ~new_entry->perm;
-		else
-			entry->perm |= new_entry->perm;
-		entry->is_deleted = !entry->perm;
+		entry->is_deleted = is_delete;
 		error = 0;
 		break;
 	}
@@ -3131,24 +3019,6 @@
 }
 
 /**
- * ccs_permstr - Find permission keywords.
- *
- * @string: String representation for permissions in foo/bar/buz format.
- * @keyword: Keyword to find from @string/
- *
- * Returns ture if @keyword was found in @string, false otherwise.
- *
- * This function assumes that strncmp(w1, w2, strlen(w1)) != 0 if w1 != w2.
- */
-static bool ccs_permstr(const char *string, const char *keyword)
-{
-	const char *cp = strstr(string, keyword);
-	if (cp)
-		return cp == string || *(cp - 1) == '/';
-	return false;
-}
-
-/**
  * ccs_write_task - Update task related list.
  *
  * @param: Pointer to "struct ccs_acl_param".
@@ -3215,29 +3085,16 @@
  */
 static int ccs_write_inet_network(struct ccs_acl_param *param)
 {
-	struct ccs_inet_acl *e = &param->e.inet_acl;
 	u8 type;
-	const char *protocol = ccs_read_token(param);
 	const char *operation = ccs_read_token(param);
-	e->head.type = CCS_TYPE_INET_ACL;
-	for (type = 0; type < CCS_SOCK_MAX; type++)
-		if (!strcmp(protocol, ccs_proto_keyword[type]))
-			break;
-	if (type == CCS_SOCK_MAX)
-		return -EINVAL;
-	e->protocol = type;
-	e->head.perm = 0;
-	for (type = 0; type < CCS_MAX_NETWORK_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_socket_keyword[type]))
-			e->head.perm |= 1 << type;
-	if (!e->head.perm)
-		return -EINVAL;
-	if (!ccs_parse_ipaddr_union(param, &e->address))
-		return -EINVAL;
-	if (!ccs_parse_number_union(param, &e->port) ||
-	    e->port.values[1] > 65535)
-		return -EINVAL;
-	return ccs_update_acl(sizeof(*e), param);
+	for (type = CCS_MAC_NETWORK_INET_STREAM_BIND;
+	     type <= CCS_MAC_NETWORK_INET_RAW_RECV; type++) {
+		if (strcmp(operation, ccs_mac_keywords[type]))
+			continue;
+		param->e.acl_info.type = type;
+		return ccs_update_acl(0, param);
+	}
+	return -EINVAL;
 }
 
 /**
@@ -3249,26 +3106,16 @@
  */
 static int ccs_write_unix_network(struct ccs_acl_param *param)
 {
-	struct ccs_unix_acl *e = &param->e.unix_acl;
 	u8 type;
-	const char *protocol = ccs_read_token(param);
 	const char *operation = ccs_read_token(param);
-	e->head.type = CCS_TYPE_UNIX_ACL;
-	for (type = 0; type < CCS_SOCK_MAX; type++)
-		if (!strcmp(protocol, ccs_proto_keyword[type]))
-			break;
-	if (type == CCS_SOCK_MAX)
-		return -EINVAL;
-	e->protocol = type;
-	e->head.perm = 0;
-	for (type = 0; type < CCS_MAX_NETWORK_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_socket_keyword[type]))
-			e->head.perm |= 1 << type;
-	if (!e->head.perm)
-		return -EINVAL;
-	if (!ccs_parse_name_union(param, &e->name))
-		return -EINVAL;
-	return ccs_update_acl(sizeof(*e), param);
+	for (type = CCS_MAC_NETWORK_UNIX_STREAM_BIND;
+	     type <= CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT; type++) {
+		if (strcmp(operation, ccs_mac_keywords[type]))
+			continue;
+		param->e.acl_info.type = type;
+		return ccs_update_acl(0, param);
+	}
+	return -EINVAL;
 }
 
 #endif
@@ -3284,15 +3131,8 @@
  */
 static int ccs_update_execute_acl(struct ccs_acl_param *param)
 {
-	struct ccs_execute_acl *e = &param->e.execute_acl;
-	e->head.type = CCS_TYPE_EXECUTE_ACL;
-	e->head.perm = 1;
-	if (!ccs_parse_name_union(param, &e->program))
-		return -EINVAL;
-	param->data = ccs_get_transit_preference(param, e);
-	if (!param->data)
-		return -EINVAL;
-	return ccs_update_acl(sizeof(*e), param);
+	//param->data = ccs_get_transit_preference(param, e);
+	return ccs_update_acl(0, param);
 }
 
 /**
@@ -3306,71 +3146,17 @@
  */
 static int ccs_write_file(struct ccs_acl_param *param)
 {
-	u16 perm = 0;
 	u8 type;
 	const char *operation = ccs_read_token(param);
-	if (ccs_permstr(operation, ccs_mac_keywords[CCS_MAC_FILE_EXECUTE]))
+	if (!strcmp(operation, ccs_mac_keywords[CCS_MAC_FILE_EXECUTE]))
 		return ccs_update_execute_acl(param);
-	for (type = 0; type < CCS_MAX_PATH_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_mac_keywords[ccs_p2mac[type]]))
-			perm |= 1 << type;
-	if (perm) {
-		struct ccs_path_acl *e = &param->e.path_acl;
-		e->head.type = CCS_TYPE_PATH_ACL;
-		e->head.perm = perm;
-		if (!ccs_parse_name_union(param, &e->name))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
+	for (type = CCS_MAC_FILE_EXECUTE + 1; type <= CCS_MAC_FILE_PIVOT_ROOT;
+	     type++) {
+		if (strcmp(operation, ccs_mac_keywords[type]))
+			continue;
+		param->e.acl_info.type = type;
+		return ccs_update_acl(0, param);
 	}
-	for (type = 0; type < CCS_MAX_PATH2_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_mac_keywords[ccs_pp2mac[type]]))
-			perm |= 1 << type;
-	if (perm) {
-		struct ccs_path2_acl *e = &param->e.path2_acl;
-		e->head.type = CCS_TYPE_PATH2_ACL;
-		e->head.perm = perm;
-		if (!ccs_parse_name_union(param, &e->name1) ||
-		    !ccs_parse_name_union(param, &e->name2))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-	}
-	for (type = 0; type < CCS_MAX_PATH_NUMBER_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_mac_keywords[ccs_pn2mac[type]]))
-			perm |= 1 << type;
-	if (perm) {
-		struct ccs_path_number_acl *e = &param->e.path_number_acl;
-		e->head.type = CCS_TYPE_PATH_NUMBER_ACL;
-		e->head.perm = perm;
-		if (!ccs_parse_name_union(param, &e->name) ||
-		    !ccs_parse_number_union(param, &e->number))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-	}
-	for (type = 0; type < CCS_MAX_MKDEV_OPERATION; type++)
-		if (ccs_permstr(operation,
-				ccs_mac_keywords[ccs_pnnn2mac[type]]))
-			perm |= 1 << type;
-	if (perm) {
-		struct ccs_mkdev_acl *e = &param->e.mkdev_acl;
-		e->head.type = CCS_TYPE_MKDEV_ACL;
-		e->head.perm = perm;
-		if (!ccs_parse_name_union(param, &e->name) ||
-		    !ccs_parse_number_union(param, &e->mode) ||
-		    !ccs_parse_number_union(param, &e->major) ||
-		    !ccs_parse_number_union(param, &e->minor))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-	}
-	if (ccs_permstr(operation, ccs_mac_keywords[CCS_MAC_FILE_MOUNT])) {
-		struct ccs_mount_acl *e = &param->e.mount_acl;
-		e->head.type = CCS_TYPE_MOUNT_ACL;
-		if (!ccs_parse_name_union(param, &e->dev_name) ||
-		    !ccs_parse_name_union(param, &e->dir_name) ||
-		    !ccs_parse_name_union(param, &e->fs_type) ||
-		    !ccs_parse_number_union(param, &e->flags))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
-	}
 	return -EINVAL;
 }
 
@@ -3386,11 +3172,8 @@
 static int ccs_write_misc(struct ccs_acl_param *param)
 {
 	if (ccs_str_starts(&param->data, "env ")) {
-		struct ccs_env_acl *e = &param->e.env_acl;
-		e->head.type = CCS_TYPE_ENV_ACL;
-		if (!ccs_parse_name_union(param, &e->env))
-			return -EINVAL;
-		return ccs_update_acl(sizeof(*e), param);
+		param->e.acl_info.type = CCS_MAC_ENVIRON;
+		return ccs_update_acl(0, param);
 	}
 	return -EINVAL;
 }
@@ -3408,14 +3191,8 @@
  */
 static int ccs_write_ipc(struct ccs_acl_param *param)
 {
-	struct ccs_ptrace_acl *e = &param->e.ptrace_acl;
-	e->head.type = CCS_TYPE_PTRACE_ACL;
-	if (!ccs_parse_number_union(param, &e->request))
-		return -EINVAL;
-	e->domainname = ccs_get_domainname(param);
-	if (!e->domainname)
-		return -EINVAL;
-	return ccs_update_acl(sizeof(*e), param);
+	param->e.acl_info.type = CCS_MAC_PTRACE;
+	return ccs_update_acl(0, param);
 }
 
 #endif
@@ -3433,15 +3210,13 @@
  */
 static int ccs_write_capability(struct ccs_acl_param *param)
 {
-	struct ccs_capability_acl *e = &param->e.capability_acl;
 	const char *operation = ccs_read_token(param);
 	u8 type;
-	e->head.type = CCS_TYPE_CAPABILITY_ACL;
 	for (type = 0; type < CCS_MAX_CAPABILITY_INDEX; type++) {
-		if (strcmp(operation, ccs_mac_keywords[ccs_c2mac[type]]))
+		if (strcmp(operation, ccs_mac_keywords[type]))
 			continue;
-		e->operation = type;
-		return ccs_update_acl(sizeof(*e), param);
+		param->e.acl_info.type = type;
+		return ccs_update_acl(0, param);
 	}
 	return -EINVAL;
 }
@@ -3461,15 +3236,9 @@
 {
 	struct ccs_use_group_acl *e = &param->e.use_group_acl;
 	e->head.type = CCS_TYPE_USE_GROUP_ACL;
-	switch (ccs_group_type(&param->data)) {
-	case 2:
-		e->is_not = true;
-		/* fall through */
-	case 1:
-		e->group = ccs_get_group(param, CCS_ACL_GROUP);
-		if (e->group)
-			return ccs_update_acl(sizeof(*e), param);
-	}
+	e->group = ccs_get_group(param, CCS_ACL_GROUP);
+	if (e->group)
+		return ccs_update_acl(sizeof(*e), param);
 	return -EINVAL;
 }
 
@@ -3519,7 +3288,6 @@
 	u8 i;
 	/* Forced zero clear for using memcmp() at ccs_update_acl(). */
 	memset(&param.e, 0, sizeof(param.e));
-	param.e.acl_info.perm = 1;
 	for (i = 0; i < ARRAY_SIZE(ccs_callback); i++) {
 		int error;
 		if (!ccs_str_starts(&param.data, ccs_callback[i].keyword))
@@ -3626,40 +3394,6 @@
 }
 
 /**
- * ccs_print_name_union - Print a ccs_name_union.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- * @ptr:  Pointer to "struct ccs_name_union".
- *
- * Returns nothing.
- */
-static void ccs_print_name_union(struct ccs_io_buffer *head,
-				 const struct ccs_name_union *ptr)
-{
-	ccs_set_space(head);
-	if (!ccs_print_group(head, ptr->is_not, ptr->group))
-		ccs_set_string(head, ptr->filename->name);
-}
-
-/**
- * ccs_print_name_union_quoted - Print a ccs_name_union with a quote.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- * @ptr:  Pointer to "struct ccs_name_union".
- *
- * Returns nothing.
- */
-static void ccs_print_name_union_quoted(struct ccs_io_buffer *head,
-					const struct ccs_name_union *ptr)
-{
-	if (!ccs_print_group(head, ptr->is_not, ptr->group)) {
-		ccs_set_string(head, "\"");
-		ccs_set_string(head, ptr->filename->name);
-		ccs_set_string(head, "\"");
-	}
-}
-
-/**
  * ccs_print_number_union_nospace - Print a ccs_number_union without a space.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -3670,7 +3404,7 @@
 static void ccs_print_number_union_nospace(struct ccs_io_buffer *head,
 					   const struct ccs_number_union *ptr)
 {
-	if (!ccs_print_group(head, ptr->is_not, ptr->group)) {
+	if (!ccs_print_group(head, ptr->group)) {
 		int i;
 		unsigned long min = ptr->values[0];
 		const unsigned long max = ptr->values[1];
@@ -3703,6 +3437,22 @@
 	}
 }
 
+static void ccs_print_number(struct ccs_io_buffer *head, const u8 radix,
+			     const unsigned long value)
+{
+	switch (radix) {
+	case CCS_VALUE_TYPE_HEXADECIMAL:
+		ccs_io_printf(head, "0x%lX", value);
+		break;
+	case CCS_VALUE_TYPE_OCTAL:
+		ccs_io_printf(head, "0%lo", value);
+		break;
+	default:
+		ccs_io_printf(head, "%lu", value);
+	}
+}
+
+
 /**
  * ccs_print_number_union - Print a ccs_number_union.
  *
@@ -3719,14 +3469,130 @@
 }
 
 /**
+ * ccs_print_condition_loop - Print condition part.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @type: One of values in "enum ccs_mac_index".
+ * @cond: Pointer to "struct ccs_condition".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_print_condition_loop(struct ccs_io_buffer *head,
+				     const enum ccs_mac_index type,
+				     const struct ccs_condition *cond)
+{
+	const union ccs_condition_element *condp = (typeof(condp)) (cond + 1);
+	while ((void *) condp < (void *) ((u8 *) cond) + cond->size) {
+		const u8 match = condp->equals;
+		const u8 left = condp->left;
+		const u8 right = condp->right;
+		const u8 radix = condp->radix;
+		if (!ccs_flush(head))
+			return false;
+		condp++;
+		head->r.cond_index++;
+		ccs_set_space(head);
+		if (left >= CCS_PATH_ATTRIBUTE_START + 48) {
+			ccs_set_string(head, ccs_get_objname(type, false));
+			ccs_set_string(head, ".parent");
+		} else if (left >= CCS_PATH_ATTRIBUTE_START + 32)
+			ccs_set_string(head, ccs_get_objname(type, false));
+		else if (left >= CCS_PATH_ATTRIBUTE_START + 16) {
+			ccs_set_string(head, ccs_get_objname(type, true));
+			ccs_set_string(head, ".parent");
+		} else if (left >= CCS_PATH_ATTRIBUTE_START) 		
+			ccs_set_string(head, ccs_get_objname(type, true));
+		else if (left == CCS_ARGV_ENTRY) {
+			ccs_io_printf(head, "exec.argv[%lu]%s=\"",
+				      condp->value, !match ? "!" : "");
+			condp++;
+			ccs_set_string(head, condp->path->name);
+			condp++;
+			ccs_set_string(head, "\"");
+			continue;
+		} else if (left == CCS_ENVP_ENTRY) {
+			ccs_set_string(head, "exec.envp[\"");
+			ccs_set_string(head, condp->path->name);
+			condp++;
+			ccs_io_printf(head, "\"]%s=", !match ? "!" : "");
+			if (condp->path) {
+				ccs_set_string(head, "\"");
+				ccs_set_string(head, condp->path->name);
+				ccs_set_string(head, "\"");
+			} else {
+				ccs_set_string(head, "NULL");
+			}
+			condp++;
+			continue;
+		} else
+			ccs_set_string(head, ccs_condition_keyword[left]);
+		ccs_set_string(head, match ? "=" : "!=");
+		if (right == CCS_IMM_GROUP) {
+			ccs_set_string(head, "@");
+			ccs_set_string(head, condp->group->group_name->name);
+			condp++;
+		} else if (right == CCS_IMM_NAME_ENTRY) {
+			ccs_set_string(head, "\"");
+			ccs_set_string(head, condp->path->name);
+			ccs_set_string(head, "\"");
+			condp++;
+		} else if (right == CCS_IMM_NUMBER_ENTRY1) {
+			ccs_print_number(head, radix & 3, condp->value);
+			condp++;
+		} else if (right == CCS_IMM_NUMBER_ENTRY2) {
+			ccs_print_number(head, radix & 3, condp->value);
+			condp++;
+			ccs_set_string(head, "-");
+			ccs_print_number(head, (radix >> 2) & 3, condp->value);
+			condp++;
+		} else if (right == CCS_IMM_IPV6ADDR_ENTRY1) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+			ccs_io_printf(head, "%pI6c", condp->ip);
+#else
+			char addr[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:"
+					 "255.255.255.255")];
+			ip6_compressed_string(addr, (const u8 *) condp->ip);
+			ccs_io_printf(head, "%s", addr);
+#endif
+			condp = (void *)
+				((u8 *) condp) + sizeof(struct in6_addr);
+		} else if (right == CCS_IMM_IPV6ADDR_ENTRY2) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+			ccs_io_printf(head, "%pI6c", condp->ip);
+#else
+			char addr[sizeof("xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:"
+					 "255.255.255.255")];
+			ip6_compressed_string(addr, (const u8 *) condp->ip);
+			ccs_io_printf(head, "%s", addr);
+#endif
+			condp = (void *)
+				((u8 *) condp) + sizeof(struct in6_addr);
+			ccs_set_string(head, "-");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 32)
+			ccs_io_printf(head, "%pI6c", condp->ip);
+#else
+			ip6_compressed_string(addr, (const u8 *) condp->ip);
+			ccs_io_printf(head, "%s", addr);
+#endif
+			condp = (void *)
+				((u8 *) condp) + sizeof(struct in6_addr);
+		} else
+			ccs_set_string(head, ccs_condition_keyword[right]);
+	}
+	return true;
+}
+
+/**
  * ccs_print_condition - Print condition part.
  *
  * @head: Pointer to "struct ccs_io_buffer".
+ * @type: One of values in "enum ccs_mac_index".
  * @cond: Pointer to "struct ccs_condition".
  *
  * Returns true on success, false otherwise.
  */
 static bool ccs_print_condition(struct ccs_io_buffer *head,
+				const enum ccs_mac_index type,
 				const struct ccs_condition *cond)
 {
 	switch (head->r.cond_step) {
@@ -3735,105 +3601,8 @@
 		head->r.cond_step++;
 		/* fall through */
 	case 1:
-		{
-			const u16 condc = cond->condc;
-			const struct ccs_condition_element *condp =
-				(typeof(condp)) (cond + 1);
-			const struct ccs_number_union *numbers_p =
-				(typeof(numbers_p)) (condp + condc);
-			const struct ccs_name_union *names_p =
-				(typeof(names_p))
-				(numbers_p + cond->numbers_count);
-			const struct ccs_argv *argv =
-				(typeof(argv)) (names_p + cond->names_count);
-			const struct ccs_envp *envp =
-				(typeof(envp)) (argv + cond->argc);
-			u16 skip;
-			for (skip = 0; skip < head->r.cond_index; skip++) {
-				const u8 left = condp->left;
-				const u8 right = condp->right;
-				condp++;
-				switch (left) {
-				case CCS_ARGV_ENTRY:
-					argv++;
-					continue;
-				case CCS_ENVP_ENTRY:
-					envp++;
-					continue;
-				case CCS_NUMBER_UNION:
-					numbers_p++;
-					break;
-				}
-				switch (right) {
-				case CCS_NAME_UNION:
-					names_p++;
-					break;
-				case CCS_NUMBER_UNION:
-					numbers_p++;
-					break;
-				}
-			}
-			while (head->r.cond_index < condc) {
-				const u8 match = condp->equals;
-				const u8 left = condp->left;
-				const u8 right = condp->right;
-				if (!ccs_flush(head))
-					return false;
-				condp++;
-				head->r.cond_index++;
-				ccs_set_space(head);
-				switch (left) {
-				case CCS_ARGV_ENTRY:
-					ccs_io_printf(head,
-						      "exec.argv[%lu]%s=\"",
-						      argv->index,
-						      argv->is_not ? "!" : "");
-					ccs_set_string(head,
-						       argv->value->name);
-					ccs_set_string(head, "\"");
-					argv++;
-					continue;
-				case CCS_ENVP_ENTRY:
-					ccs_set_string(head, "exec.envp[\"");
-					ccs_set_string(head, envp->name->name);
-					ccs_io_printf(head, "\"]%s=",
-						      envp->is_not ? "!" : "");
-					if (envp->value) {
-						ccs_set_string(head, "\"");
-						ccs_set_string(head, envp->
-							       value->name);
-						ccs_set_string(head, "\"");
-					} else {
-						ccs_set_string(head, "NULL");
-					}
-					envp++;
-					continue;
-				case CCS_NUMBER_UNION:
-					ccs_print_number_union_nospace
-						(head, numbers_p++);
-					break;
-				default:
-					ccs_set_string(head,
-					       ccs_condition_keyword[left]);
-					break;
-				}
-				ccs_set_string(head, match ? "=" : "!=");
-				switch (right) {
-				case CCS_NAME_UNION:
-					ccs_print_name_union_quoted
-						(head, names_p++);
-					break;
-				case CCS_NUMBER_UNION:
-					ccs_print_number_union_nospace
-						(head, numbers_p++);
-					break;
-				default:
-					ccs_set_string(head,
-					       ccs_condition_keyword[right]);
-					break;
-				}
-			}
-		}
+		if (!ccs_print_condition_loop(head, type, cond))
+			return false;
 		head->r.cond_step++;
 		/* fall through */
 	case 2:
@@ -3842,10 +3611,6 @@
 		head->r.cond_step++;
 		/* fall through */
 	case 3:
-		if (cond->grant_log != CCS_GRANTLOG_AUTO)
-			ccs_io_printf(head, " grant_log=%s",
-				      ccs_yesno(cond->grant_log ==
-						CCS_GRANTLOG_YES));
 		ccs_set_lf(head);
 		return true;
 	}
@@ -3884,9 +3649,7 @@
 static bool ccs_print_entry(struct ccs_io_buffer *head,
 			    const struct ccs_acl_info *acl)
 {
-	const u8 acl_type = acl->type;
-	bool first = true;
-	u8 bit;
+	const enum ccs_mac_index acl_type = acl->type;
 	if (head->r.print_cond_part)
 		goto print_cond_part;
 	if (acl->is_deleted)
@@ -3897,9 +3660,7 @@
 	if (head->type == CCS_EXCEPTION_POLICY && head->r.acl_group_name)
 		printk(KERN_INFO "%s ptr=%p\n", __func__, acl);
 	*/
-	else if (acl_type == CCS_TYPE_EXECUTE_ACL) {
-		struct ccs_execute_acl *ptr
-			= container_of(acl, typeof(*ptr), head);
+	else if (acl_type == CCS_MAC_FILE_EXECUTE) {
 		if (head->r.print_default_transition) {
 			ccs_print_namespace(head);
 			ccs_set_string(head, "default_transition");
@@ -3907,11 +3668,10 @@
 			ccs_set_group(head, "file ");
 			ccs_set_string(head, "execute");
 		}
-		ccs_print_name_union(head, &ptr->program);
-		if (ptr->transit) {
-			ccs_set_space(head);
-			ccs_set_string(head, ptr->transit->name);
-		}
+		//if (ptr->transit) {
+		//ccs_set_space(head);
+		//ccs_set_string(head, ptr->transit->name);
+		//}
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 	} else if (acl_type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
 		   acl_type == CCS_TYPE_DENIED_EXECUTE_HANDLER) {
@@ -3942,166 +3702,94 @@
 		struct ccs_use_group_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
 		ccs_set_group(head, "use_group ");
-		ccs_print_group(head, ptr->is_not, ptr->group);
+		ccs_print_group(head, ptr->group);
 	} else if (head->r.print_transition_related_only) {
 		return true;
-	} else if (acl_type == CCS_TYPE_PATH_ACL) {
-		struct ccs_path_acl *ptr
-			= container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_PATH_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "file ");
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_mac_keywords[ccs_p2mac[bit]]);
-		}
-		if (first)
-			return true;
-		ccs_print_name_union(head, &ptr->name);
-	} else if (acl_type == CCS_TYPE_MKDEV_ACL) {
-		struct ccs_mkdev_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_MKDEV_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "file ");
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_mac_keywords
-				       [ccs_pnnn2mac[bit]]);
-		}
-		if (first)
-			return true;
-		ccs_print_name_union(head, &ptr->name);
-		ccs_print_number_union(head, &ptr->mode);
-		ccs_print_number_union(head, &ptr->major);
-		ccs_print_number_union(head, &ptr->minor);
-	} else if (acl_type == CCS_TYPE_PATH2_ACL) {
-		struct ccs_path2_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_PATH2_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "file ");
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_mac_keywords
-				       [ccs_pp2mac[bit]]);
-		}
-		if (first)
-			return true;
-		ccs_print_name_union(head, &ptr->name1);
-		ccs_print_name_union(head, &ptr->name2);
-	} else if (acl_type == CCS_TYPE_PATH_NUMBER_ACL) {
-		struct ccs_path_number_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_PATH_NUMBER_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "file ");
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_mac_keywords
-				       [ccs_pn2mac[bit]]);
-		}
-		if (first)
-			return true;
-		ccs_print_name_union(head, &ptr->name);
-		ccs_print_number_union(head, &ptr->number);
+	} else if (acl_type == CCS_MAC_FILE_READ ||
+		   acl_type == CCS_MAC_FILE_WRITE ||
+		   acl_type == CCS_MAC_FILE_APPEND ||
+		   acl_type == CCS_MAC_FILE_UNLINK ||
+		   acl_type == CCS_MAC_FILE_GETATTR ||
+		   acl_type == CCS_MAC_FILE_RMDIR ||
+		   acl_type == CCS_MAC_FILE_TRUNCATE ||
+		   acl_type == CCS_MAC_FILE_CHROOT ||
+		   acl_type == CCS_MAC_FILE_UMOUNT ||
+		   acl_type == CCS_MAC_FILE_CREATE ||
+		   acl_type == CCS_MAC_FILE_MKDIR ||
+		   acl_type == CCS_MAC_FILE_MKFIFO ||
+		   acl_type == CCS_MAC_FILE_MKSOCK ||
+		   acl_type == CCS_MAC_FILE_SYMLINK ||
+		   acl_type == CCS_MAC_FILE_MKBLOCK ||
+		   acl_type == CCS_MAC_FILE_MKCHAR ||
+		   acl_type == CCS_MAC_FILE_LINK ||
+		   acl_type == CCS_MAC_FILE_RENAME ||
+		   acl_type == CCS_MAC_FILE_CHMOD ||
+		   acl_type == CCS_MAC_FILE_CHOWN ||
+		   acl_type == CCS_MAC_FILE_CHGRP ||
+		   acl_type == CCS_MAC_FILE_IOCTL ||
+		   acl_type == CCS_MAC_FILE_MOUNT ||
+		   acl_type == CCS_MAC_FILE_PIVOT_ROOT) {
+		ccs_set_group(head, "file ");
+		ccs_set_string(head, ccs_mac_keywords[acl_type]);
 #ifdef CONFIG_CCSECURITY_MISC
-	} else if (acl_type == CCS_TYPE_ENV_ACL) {
-		struct ccs_env_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
+	} else if (acl_type == CCS_MAC_ENVIRON) {
 		ccs_set_group(head, "misc env");
-		ccs_print_name_union(head, &ptr->env);
 #endif
 #ifdef CONFIG_CCSECURITY_CAPABILITY
-	} else if (acl_type == CCS_TYPE_CAPABILITY_ACL) {
-		struct ccs_capability_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
+	} else if (acl_type == CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET ||
+		   acl_type == CCS_MAC_CAPABILITY_USE_PACKET_SOCKET ||
+		   acl_type == CCS_MAC_CAPABILITY_SYS_REBOOT ||
+		   acl_type == CCS_MAC_CAPABILITY_SYS_VHANGUP ||
+		   acl_type == CCS_MAC_CAPABILITY_SYS_SETTIME ||
+		   acl_type == CCS_MAC_CAPABILITY_SYS_NICE ||
+		   acl_type == CCS_MAC_CAPABILITY_SYS_SETHOSTNAME ||
+		   acl_type == CCS_MAC_CAPABILITY_USE_KERNEL_MODULE ||
+		   acl_type == CCS_MAC_CAPABILITY_SYS_KEXEC_LOAD) {
 		ccs_set_group(head, "capability ");
-		ccs_set_string(head, ccs_mac_keywords
-			       [ccs_c2mac[ptr->operation]]);
+		ccs_set_string(head, ccs_mac_keywords[acl_type]);
 #endif
 #ifdef CONFIG_CCSECURITY_NETWORK
-	} else if (acl_type == CCS_TYPE_INET_ACL) {
-		struct ccs_inet_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_NETWORK_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "network inet ");
-				ccs_set_string(head, ccs_proto_keyword
-					       [ptr->protocol]);
-				ccs_set_space(head);
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_socket_keyword[bit]);
-		}
-		if (first)
-			return true;
-		ccs_set_space(head);
-		if (!ccs_print_group(head, ptr->address.is_not,
-				     ptr->address.group)) {
+	} else if (acl_type == CCS_MAC_NETWORK_INET_STREAM_BIND ||
+		   acl_type == CCS_MAC_NETWORK_INET_STREAM_LISTEN ||
+		   acl_type == CCS_MAC_NETWORK_INET_STREAM_CONNECT ||
+		   acl_type == CCS_MAC_NETWORK_INET_STREAM_ACCEPT ||
+		   acl_type == CCS_MAC_NETWORK_INET_DGRAM_BIND ||
+		   acl_type == CCS_MAC_NETWORK_INET_DGRAM_SEND ||
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+		   acl_type == CCS_MAC_NETWORK_INET_DGRAM_RECV ||
+#endif
+		   acl_type == CCS_MAC_NETWORK_INET_RAW_BIND ||
+		   acl_type == CCS_MAC_NETWORK_INET_RAW_SEND ||
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+		   acl_type == CCS_MAC_NETWORK_INET_RAW_RECV ||
+#endif
+		   acl_type == CCS_MAC_NETWORK_UNIX_STREAM_BIND ||
+		   acl_type == CCS_MAC_NETWORK_UNIX_STREAM_LISTEN ||
+		   acl_type == CCS_MAC_NETWORK_UNIX_STREAM_CONNECT ||
+		   acl_type == CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT ||
+		   acl_type == CCS_MAC_NETWORK_UNIX_DGRAM_BIND ||
+		   acl_type == CCS_MAC_NETWORK_UNIX_DGRAM_SEND ||
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+		   acl_type == CCS_MAC_NETWORK_UNIX_DGRAM_RECV ||
+#endif
+		   acl_type == CCS_MAC_NETWORK_UNIX_SEQPACKET_BIND ||
+		   acl_type == CCS_MAC_NETWORK_UNIX_SEQPACKET_LISTEN ||
+		   acl_type == CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT ||
+		   acl_type == CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT) {
+		ccs_set_group(head, "network ");
+		ccs_set_string(head, ccs_mac_keywords[acl_type]);
+		/*
+		if (!ccs_print_group(head, ptr->address.group)) {
 			char buf[128];
 			ccs_print_ip(buf, sizeof(buf), &ptr->address);
 			ccs_io_printf(head, "%s", buf);
 		}
-		ccs_print_number_union(head, &ptr->port);
-	} else if (acl_type == CCS_TYPE_UNIX_ACL) {
-		struct ccs_unix_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		for (bit = 0; bit < CCS_MAX_NETWORK_OPERATION; bit++) {
-			if (!(acl->perm & (1 << bit)))
-				continue;
-			if (first) {
-				ccs_set_group(head, "network unix ");
-				ccs_set_string(head, ccs_proto_keyword
-					       [ptr->protocol]);
-				ccs_set_space(head);
-				first = false;
-			} else {
-				ccs_set_slash(head);
-			}
-			ccs_set_string(head, ccs_socket_keyword[bit]);
-		}
-		if (first)
-			return true;
-		ccs_print_name_union(head, &ptr->name);
+		*/
 #endif
 #ifdef CONFIG_CCSECURITY_IPC
-	} else if (acl_type == CCS_TYPE_PTRACE_ACL) {
-		struct ccs_ptrace_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head, "ipc ptrace ");
-		ccs_print_number_union_nospace(head, &ptr->request);
-		ccs_set_space(head);
-		ccs_set_string(head, ptr->domainname->name);
+	} else if (acl_type == CCS_MAC_PTRACE) {
+		ccs_set_group(head, "ipc ptrace");
 #endif
-	} else if (acl_type == CCS_TYPE_MOUNT_ACL) {
-		struct ccs_mount_acl *ptr =
-			container_of(acl, typeof(*ptr), head);
-		ccs_set_group(head, "file mount");
-		ccs_print_name_union(head, &ptr->dev_name);
-		ccs_print_name_union(head, &ptr->dir_name);
-		ccs_print_name_union(head, &ptr->fs_type);
-		ccs_print_number_union(head, &ptr->flags);
 	}
 	if (acl->cond) {
 		head->r.print_cond_part = true;
@@ -4109,7 +3797,7 @@
 		if (!ccs_flush(head))
 			return false;
 print_cond_part:
-		if (!ccs_print_condition(head, acl->cond))
+		if (!ccs_print_condition(head, acl_type, acl->cond))
 			return false;
 		head->r.print_cond_part = false;
 	} else {
@@ -4279,7 +3967,7 @@
 	struct ccs_group *group = ccs_get_group(param, type);
 	if (!group || group == &ccs_group_any)
 		return -ENOMEM;
-	if (type != CCS_ACL_GROUP && ccs_group_type(&param->data))
+	if (type != CCS_ACL_GROUP && ccs_str_starts(&param->data, "@"))
 		goto out;
 	param->list = &group->member_list;
 	if (type == CCS_PATH_GROUP) {
@@ -4370,7 +4058,7 @@
 	mutex_unlock(&ccs_policy_lock);
 out:
 	ccs_put_name(domain.domainname);
-	ccs_put_condition(domain.cond);
+	ccs_del_condition(domain.cond);
 	return error;
 }
 
@@ -4405,7 +4093,6 @@
 	struct ccs_acl_param param = {
 		.data = head->write_buf,
 		.is_delete = head->w.is_delete,
-		.e.acl_info.perm = 1,
 	};
 	u8 i;
 	if (ccs_str_starts(&param.data, "by ")) {
@@ -4458,7 +4145,6 @@
 	u8 i;
 	/* Forced zero clear for using memcmp() at ccs_update_policy(). */
 	memset(&param.e, 0, sizeof(param.e));
-	param.e.acl_info.perm = 1;
 	if (ccs_str_starts(&param.data, "default_transition "))
 		return ccs_write_transition_control(&param);
 	for (i = 0; i < CCS_MAX_GROUP; i++)
@@ -4665,21 +4351,9 @@
 	if (!domain)
 		return true;
 	list_for_each_entry_srcu(ptr, &domain->acl_info_list, list, &ccs_ss) {
-		u16 perm;
-		u8 i;
 		if (ptr->is_deleted)
 			continue;
 		switch (ptr->type) {
-		case CCS_TYPE_PATH_ACL:
-		case CCS_TYPE_PATH2_ACL:
-		case CCS_TYPE_PATH_NUMBER_ACL:
-		case CCS_TYPE_MKDEV_ACL:
-#ifdef CONFIG_CCSECURITY_NETWORK
-		case CCS_TYPE_INET_ACL:
-		case CCS_TYPE_UNIX_ACL:
-#endif
-			perm = ptr->perm;
-			break;
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 		case CCS_TYPE_AUTO_EXECUTE_HANDLER:
 		case CCS_TYPE_DENIED_EXECUTE_HANDLER:
@@ -4688,14 +4362,10 @@
 		case CCS_TYPE_AUTO_TASK_ACL:
 		case CCS_TYPE_MANUAL_TASK_ACL:
 #endif
-			perm = 0;
 			break;
 		default:
-			perm = 1;
+			count++;
 		}
-		for (i = 0; i < 16; i++)
-			if (perm & (1 << i))
-				count++;
 	}
 	if (count < ccs_profile(r->profile)->pref[CCS_PREF_MAX_LEARNING_ENTRY])
 		return true;
@@ -4839,101 +4509,149 @@
  */
 int ccs_audit_log(struct ccs_request_info *r)
 {
-	switch (r->param_type) {
-		u8 type;
-		char buf[48];
+	const char *keyword = ccs_mac_keywords[r->type];
+	switch (r->type) {
 #ifdef CONFIG_CCSECURITY_NETWORK
 		const u32 *address;
+		char buf[48];
 #endif
-	case CCS_TYPE_EXECUTE_ACL:
-		return ccs_supervisor(r, "file execute %s\n",
-				      r->param.path.filename->name);
-	case CCS_TYPE_PATH_ACL:
-		return ccs_supervisor(r, "file %s %s\n", ccs_mac_keywords
-				      [ccs_p2mac[r->param.path.operation]],
-				      r->param.path.filename->name);
-	case CCS_TYPE_PATH2_ACL:
-		return ccs_supervisor(r, "file %s %s %s\n", ccs_mac_keywords
-				      [ccs_pp2mac[r->param.path2.operation]],
-				      r->param.path2.filename1->name,
-				      r->param.path2.filename2->name);
-	case CCS_TYPE_PATH_NUMBER_ACL:
-		type = r->param.path_number.operation;
-		switch (type) {
-		case CCS_TYPE_CREATE:
-		case CCS_TYPE_MKDIR:
-		case CCS_TYPE_MKFIFO:
-		case CCS_TYPE_MKSOCK:
-		case CCS_TYPE_CHMOD:
-			snprintf(buf, sizeof(buf), "0%lo",
-				 r->param.path_number.number);
-			break;
-		case CCS_TYPE_IOCTL:
-			snprintf(buf, sizeof(buf), "0x%lX",
-				 r->param.path_number.number);
-			break;
-		default:
-			snprintf(buf, sizeof(buf), "%lu",
-				 r->param.path_number.number);
-			break;
-		}
-		return ccs_supervisor(r, "file %s %s %s\n", ccs_mac_keywords
-				      [ccs_pn2mac[type]],
-				      r->param.path_number.filename->name,
-				      buf);
-	case CCS_TYPE_MKDEV_ACL:
-		return ccs_supervisor(r, "file %s %s 0%o %u %u\n",
-				      ccs_mac_keywords
-				      [ccs_pnnn2mac[r->param.mkdev.operation]],
-				      r->param.mkdev.filename->name,
-				      r->param.mkdev.mode,
-				      r->param.mkdev.major,
-				      r->param.mkdev.minor);
-	case CCS_TYPE_MOUNT_ACL:
-		return ccs_supervisor(r, "file mount %s %s %s 0x%lX\n",
-				      r->param.mount.dev->name,
-				      r->param.mount.dir->name,
-				      r->param.mount.type->name,
-				      r->param.mount.flags);
+	case CCS_MAC_FILE_EXECUTE:
+		return ccs_supervisor(r, "file %s exec=\"%s\" path=\"%s\"\n",
+				      keyword, r->param.s[1]->name,
+				      r->param.s[0]->name);
+	case CCS_MAC_FILE_READ:
+	case CCS_MAC_FILE_WRITE:
+	case CCS_MAC_FILE_APPEND:
+	case CCS_MAC_FILE_UNLINK:
+	case CCS_MAC_FILE_GETATTR:
+	case CCS_MAC_FILE_RMDIR:
+	case CCS_MAC_FILE_TRUNCATE:
+	case CCS_MAC_FILE_CHROOT:
+	case CCS_MAC_FILE_UMOUNT:
+		return ccs_supervisor(r, "file %s path=\"%s\"\n", keyword,
+				      r->param.s[0]->name);
+	case CCS_MAC_FILE_CREATE:
+	case CCS_MAC_FILE_MKDIR:
+	case CCS_MAC_FILE_MKFIFO:
+	case CCS_MAC_FILE_MKSOCK:
+		return ccs_supervisor(r, "file %s path=\"%s\" perm=0%lu\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0]);
+	case CCS_MAC_FILE_SYMLINK:
+		return ccs_supervisor(r, "file %s path=\"%s\" symlink=\"%s\""
+				      "\n", keyword, r->param.s[0]->name,
+				      r->param.s[1]->name);
+	case CCS_MAC_FILE_MKBLOCK:
+	case CCS_MAC_FILE_MKCHAR:
+		return ccs_supervisor(r, "file %s path=\"%s\" perm=0%lo "
+				      "dev_major=%lu dev_minor=%lu\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0], r->param.i[1],
+				      r->param.i[2]);
+	case CCS_MAC_FILE_LINK:
+	case CCS_MAC_FILE_RENAME:
+		return ccs_supervisor(r, "file %s old_path=\"%s\" "
+				      "new_path=\"%s\"\n", keyword,
+				      r->param.s[0]->name,
+				      r->param.s[1]->name);
+	case CCS_MAC_FILE_CHMOD:
+		return ccs_supervisor(r, "file %s path=\"%s\" new_perm=0%lu\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0]);
+	case CCS_MAC_FILE_CHOWN:
+		return ccs_supervisor(r, "file %s path=\"%s\" new_uid=%lu\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0]);
+	case CCS_MAC_FILE_CHGRP:
+		return ccs_supervisor(r, "file %s path=\"%s\" new_gid=%lu\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0]);
+	case CCS_MAC_FILE_IOCTL:
+		return ccs_supervisor(r, "file %s path=\"%s\" cmd=0x%lX\n",
+				      keyword, r->param.s[0]->name,
+				      r->param.i[0]);
+	case CCS_MAC_FILE_MOUNT:
+		return ccs_supervisor(r, "file %s source=\"%s\" target=\"%s\" "
+				      "fstype=\"%s\" flags=0x%lX\n", keyword,
+				      r->param.s[0]->name, r->param.s[1]->name,
+				      r->param.s[2]->name, r->param.i[0]);
+	case CCS_MAC_FILE_PIVOT_ROOT:
+		return ccs_supervisor(r, "file %s new_root=\"%s\" "
+				      "put_old=\"%s\"\n", keyword,
+				      r->param.s[0]->name,
+				      r->param.s[1]->name);
 #ifdef CONFIG_CCSECURITY_MISC
-	case CCS_TYPE_ENV_ACL:
-		return ccs_supervisor(r, "misc env %s\n",
-				      r->param.environ.name->name);
+	case CCS_MAC_ENVIRON:
+		return ccs_supervisor(r, "misc %s name=\"%s\"\n", keyword,
+				      r->param.env_name->name);
 #endif
 #ifdef CONFIG_CCSECURITY_CAPABILITY
-	case CCS_TYPE_CAPABILITY_ACL:
-		return ccs_supervisor(r, "capability %s\n", ccs_mac_keywords
-				      [ccs_c2mac[r->param.capability.
-						 operation]]);
+	case CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET:
+	case CCS_MAC_CAPABILITY_USE_PACKET_SOCKET:
+	case CCS_MAC_CAPABILITY_SYS_REBOOT:
+	case CCS_MAC_CAPABILITY_SYS_VHANGUP:
+	case CCS_MAC_CAPABILITY_SYS_SETTIME:
+	case CCS_MAC_CAPABILITY_SYS_NICE:
+	case CCS_MAC_CAPABILITY_SYS_SETHOSTNAME:
+	case CCS_MAC_CAPABILITY_USE_KERNEL_MODULE:
+	case CCS_MAC_CAPABILITY_SYS_KEXEC_LOAD:
+		return ccs_supervisor(r, "capability name=\"%s\"\n", keyword);
 #endif
 #ifdef CONFIG_CCSECURITY_NETWORK
-	case CCS_TYPE_INET_ACL:
-		address = r->param.inet_network.address;
-		if (r->param.inet_network.is_ipv6)
+	case CCS_MAC_NETWORK_INET_STREAM_BIND:
+	case CCS_MAC_NETWORK_INET_STREAM_LISTEN:
+	case CCS_MAC_NETWORK_INET_STREAM_CONNECT:
+	case CCS_MAC_NETWORK_INET_STREAM_ACCEPT:
+	case CCS_MAC_NETWORK_INET_DGRAM_BIND:
+	case CCS_MAC_NETWORK_INET_DGRAM_SEND:
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+	case CCS_MAC_NETWORK_INET_DGRAM_RECV:
+#endif
+		address = r->param.inet_address;
+		if (r->param.is_ipv6)
 			ccs_print_ipv6(buf, sizeof(buf),
 				       (const struct in6_addr *) address);
 		else
 			ccs_print_ipv4(buf, sizeof(buf), address);
-		return ccs_supervisor(r, "network inet %s %s %s %u\n",
-				      ccs_proto_keyword[r->param.inet_network.
-							protocol],
-				      ccs_socket_keyword[r->param.inet_network.
-							 operation],
-				      buf, r->param.inet_network.port);
-	case CCS_TYPE_UNIX_ACL:
-		return ccs_supervisor(r, "network unix %s %s %s\n",
-				      ccs_proto_keyword[r->param.
-							unix_network.protocol],
-				      ccs_socket_keyword[r->param.unix_network.
-							 operation],
-				      r->param.unix_network.address->name);
+		return ccs_supervisor(r, "network %s ip=%s port=%u\n", keyword,
+				      buf, r->param.inet_port);
+	case CCS_MAC_NETWORK_INET_RAW_BIND:
+	case CCS_MAC_NETWORK_INET_RAW_SEND:
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+	case CCS_MAC_NETWORK_INET_RAW_RECV:
 #endif
+		address = r->param.inet_address;
+		if (r->param.is_ipv6)
+			ccs_print_ipv6(buf, sizeof(buf),
+				       (const struct in6_addr *) address);
+		else
+			ccs_print_ipv4(buf, sizeof(buf), address);
+		return ccs_supervisor(r, "network %s ip=%s proto=%u\n",
+				      keyword, buf,
+				      r->param.inet_port);
+	case CCS_MAC_NETWORK_UNIX_STREAM_BIND:
+	case CCS_MAC_NETWORK_UNIX_STREAM_LISTEN:
+	case CCS_MAC_NETWORK_UNIX_STREAM_CONNECT:
+	case CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT:
+	case CCS_MAC_NETWORK_UNIX_DGRAM_BIND:
+	case CCS_MAC_NETWORK_UNIX_DGRAM_SEND:
+#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
+	case CCS_MAC_NETWORK_UNIX_DGRAM_RECV:
+#endif
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_BIND:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_LISTEN:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT:
+	case CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT:
+		return ccs_supervisor(r, "network %s addr=%s\n", keyword,
+				      r->param.unix_address->name);
+#endif
 #ifdef CONFIG_CCSECURITY_IPC
-	case CCS_TYPE_PTRACE_ACL:
-		return ccs_supervisor(r, "ipc ptrace %lu %s\n",
-				      r->param.ptrace.request,
-				      r->param.ptrace.domainname);
+	case CCS_MAC_PTRACE:
+		return ccs_supervisor(r, "ipc %s cmd=%lu domain=%s\n", keyword,
+				      r->param.i[0], r->param.domainname);
 #endif
+	case CCS_MAX_MAC_INDEX:
+		break;
 	}
 	return 0;
 }
@@ -5370,6 +5088,7 @@
 		obj->validate_done = true;
 	}
 	for (i = 0; i < CCS_MAX_PATH_STAT; i++) {
+		const char *objname; 
 		struct ccs_mini_stat *stat;
 		unsigned int dev;
 		mode_t mode;
@@ -5378,17 +5097,18 @@
 		stat = &obj->stat[i];
 		dev = stat->dev;
 		mode = stat->mode;
+		objname = ccs_get_objname(r->type, (i >> 1));
 		if (i & 1) {
 			pos += snprintf(buffer + pos, ccs_buffer_len - 1 - pos,
-					" path%u.parent={ uid=%u gid=%u "
-					"ino=%lu perm=0%o }", (i >> 1) + 1,
-					stat->uid, stat->gid, (unsigned long)
-					stat->ino, stat->mode & S_IALLUGO);
+					" %s.parent={ uid=%u gid=%u ino=%lu "
+					"perm=0%o }", objname, stat->uid,
+					stat->gid, (unsigned long) stat->ino,
+					stat->mode & S_IALLUGO);
 			continue;
 		}
 		pos += snprintf(buffer + pos, ccs_buffer_len - 1 - pos,
-				" path%u={ uid=%u gid=%u ino=%lu major=%u"
-				" minor=%u perm=0%o type=%s", (i >> 1) + 1,
+				" %s={ uid=%u gid=%u ino=%lu major=%u"
+				" minor=%u perm=0%o type=%s", objname,
 				stat->uid, stat->gid, (unsigned long)
 				stat->ino, MAJOR(dev), MINOR(dev),
 				mode & S_IALLUGO, ccs_filetype(mode));
@@ -5488,13 +5208,6 @@
 	p = ccs_profile(profile);
 	if (ccs_log_count >= p->pref[CCS_PREF_MAX_AUDIT_LOG])
 		return false;
-	if (is_granted) {
-		const struct ccs_acl_info *matched_acl = r->matched_acl;
-		if (matched_acl && matched_acl->cond &&
-		    matched_acl->cond->grant_log != CCS_GRANTLOG_AUTO)
-			return matched_acl->cond->grant_log ==
-				CCS_GRANTLOG_YES;
-	}
 	mode = p->config[index];
 	if (mode == CCS_CONFIG_USE_DEFAULT)
 		mode = p->config
@@ -5831,8 +5544,9 @@
 				continue;
 			tmp = *container_of(ptr, typeof(tmp), head);
 			atomic_inc(&tmp.group->head.users);
-			if (tmp.head.cond)
-				atomic_inc(&tmp.head.cond->head.users);
+			// TODO: memdup()
+			//if (tmp.head.cond)
+			//	atomic_inc(&tmp.head.cond->head.users);
 			/*
 			printk(KERN_INFO "Inherit %s\n",
 			       tmp.group->group_name->name);
@@ -6051,7 +5765,8 @@
 			if (!ccs_flush(head))
 				return false;
 			if (domain->cond) {
-				if (!ccs_print_condition(head, domain->cond))
+				if (!ccs_print_condition(head, 0,
+							 domain->cond))
 					return false;
 			} else {
 				ccs_set_lf(head);
@@ -6315,8 +6030,8 @@
 		name.name = data;
 		ccs_fill_path_info(&name);
 		/* Check "task manual_domain_transition" permission. */
-		r.type = CCS_MAC_FILE_EXECUTE;
-		r.param_type = CCS_TYPE_MANUAL_TASK_ACL;
+		//r.type = CCS_MAC_FILE_EXECUTE;
+		r.type = CCS_TYPE_MANUAL_TASK_ACL;
 		r.param.task.domainname = &name;
 		ccs_check_acl(&r);
 		if (!r.granted)
Index: permission.c
===================================================================
--- permission.c	(revision 5754)
+++ permission.c	(working copy)
@@ -42,112 +42,12 @@
 	[CCS_MOUNT_MAKE_SHARED]     = "--make-shared",
 };
 
-/* Mapping table from "enum ccs_path_acl_index" to "enum ccs_mac_index". */
-const u8 ccs_p2mac[CCS_MAX_PATH_OPERATION] = {
-	[CCS_TYPE_READ]       = CCS_MAC_FILE_READ,
-	[CCS_TYPE_WRITE]      = CCS_MAC_FILE_WRITE,
-	[CCS_TYPE_APPEND]     = CCS_MAC_FILE_APPEND,
-	[CCS_TYPE_UNLINK]     = CCS_MAC_FILE_UNLINK,
-#ifdef CONFIG_CCSECURITY_FILE_GETATTR
-	[CCS_TYPE_GETATTR]    = CCS_MAC_FILE_GETATTR,
-#endif
-	[CCS_TYPE_RMDIR]      = CCS_MAC_FILE_RMDIR,
-	[CCS_TYPE_TRUNCATE]   = CCS_MAC_FILE_TRUNCATE,
-	[CCS_TYPE_CHROOT]     = CCS_MAC_FILE_CHROOT,
-	[CCS_TYPE_UMOUNT]     = CCS_MAC_FILE_UMOUNT,
-};
-
-/* Mapping table from "enum ccs_mkdev_acl_index" to "enum ccs_mac_index". */
-const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION] = {
-	[CCS_TYPE_MKBLOCK] = CCS_MAC_FILE_MKBLOCK,
-	[CCS_TYPE_MKCHAR]  = CCS_MAC_FILE_MKCHAR,
-};
-
-/* Mapping table from "enum ccs_path2_acl_index" to "enum ccs_mac_index". */
-const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION] = {
-	[CCS_TYPE_LINK]       = CCS_MAC_FILE_LINK,
-	[CCS_TYPE_RENAME]     = CCS_MAC_FILE_RENAME,
-	[CCS_TYPE_PIVOT_ROOT] = CCS_MAC_FILE_PIVOT_ROOT,
-	[CCS_TYPE_SYMLINK]    = CCS_MAC_FILE_SYMLINK,
-};
-
-/*
- * Mapping table from "enum ccs_path_number_acl_index" to "enum ccs_mac_index".
- */
-const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION] = {
-	[CCS_TYPE_CREATE] = CCS_MAC_FILE_CREATE,
-	[CCS_TYPE_MKDIR]  = CCS_MAC_FILE_MKDIR,
-	[CCS_TYPE_MKFIFO] = CCS_MAC_FILE_MKFIFO,
-	[CCS_TYPE_MKSOCK] = CCS_MAC_FILE_MKSOCK,
-	[CCS_TYPE_IOCTL]  = CCS_MAC_FILE_IOCTL,
-	[CCS_TYPE_CHMOD]  = CCS_MAC_FILE_CHMOD,
-	[CCS_TYPE_CHOWN]  = CCS_MAC_FILE_CHOWN,
-	[CCS_TYPE_CHGRP]  = CCS_MAC_FILE_CHGRP,
-};
-
-#ifdef CONFIG_CCSECURITY_NETWORK
-
-/*
- * Mapping table from "enum ccs_network_acl_index" to "enum ccs_mac_index" for
- * inet domain socket.
- */
-static const u8 ccs_inet2mac[CCS_SOCK_MAX][CCS_MAX_NETWORK_OPERATION] = {
-	[SOCK_STREAM] = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_INET_STREAM_BIND,
-		[CCS_NETWORK_LISTEN]  = CCS_MAC_NETWORK_INET_STREAM_LISTEN,
-		[CCS_NETWORK_CONNECT] = CCS_MAC_NETWORK_INET_STREAM_CONNECT,
-		[CCS_NETWORK_ACCEPT]  = CCS_MAC_NETWORK_INET_STREAM_ACCEPT,
-	},
-	[SOCK_DGRAM] = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_INET_DGRAM_BIND,
-		[CCS_NETWORK_SEND]    = CCS_MAC_NETWORK_INET_DGRAM_SEND,
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-		[CCS_NETWORK_RECV]    = CCS_MAC_NETWORK_INET_DGRAM_RECV,
-#endif
-	},
-	[SOCK_RAW]    = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_INET_RAW_BIND,
-		[CCS_NETWORK_SEND]    = CCS_MAC_NETWORK_INET_RAW_SEND,
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-		[CCS_NETWORK_RECV]    = CCS_MAC_NETWORK_INET_RAW_RECV,
-#endif
-	},
-};
-
-/*
- * Mapping table from "enum ccs_network_acl_index" to "enum ccs_mac_index" for
- * unix domain socket.
- */
-static const u8 ccs_unix2mac[CCS_SOCK_MAX][CCS_MAX_NETWORK_OPERATION] = {
-	[SOCK_STREAM] = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_UNIX_STREAM_BIND,
-		[CCS_NETWORK_LISTEN]  = CCS_MAC_NETWORK_UNIX_STREAM_LISTEN,
-		[CCS_NETWORK_CONNECT] = CCS_MAC_NETWORK_UNIX_STREAM_CONNECT,
-		[CCS_NETWORK_ACCEPT]  = CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT,
-	},
-	[SOCK_DGRAM] = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_UNIX_DGRAM_BIND,
-		[CCS_NETWORK_SEND]    = CCS_MAC_NETWORK_UNIX_DGRAM_SEND,
-#ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-		[CCS_NETWORK_RECV]    = CCS_MAC_NETWORK_UNIX_DGRAM_RECV,
-#endif
-	},
-	[SOCK_SEQPACKET] = {
-		[CCS_NETWORK_BIND]    = CCS_MAC_NETWORK_UNIX_SEQPACKET_BIND,
-		[CCS_NETWORK_LISTEN]  = CCS_MAC_NETWORK_UNIX_SEQPACKET_LISTEN,
-		[CCS_NETWORK_CONNECT] = CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT,
-		[CCS_NETWORK_ACCEPT]  = CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT,
-	},
-};
-
-#endif
-
 #ifdef CONFIG_CCSECURITY_CAPABILITY
 
 /*
  * Mapping table from "enum ccs_capability_acl_index" to "enum ccs_mac_index".
  */
-const u8 ccs_c2mac[CCS_MAX_CAPABILITY_INDEX] = {
+static const u8 ccs_c2mac[CCS_MAX_CAPABILITY_INDEX] = {
 	[CCS_USE_ROUTE_SOCKET]  = CCS_MAC_CAPABILITY_USE_ROUTE_SOCKET,
 	[CCS_USE_PACKET_SOCKET] = CCS_MAC_CAPABILITY_USE_PACKET_SOCKET,
 	[CCS_SYS_REBOOT]        = CCS_MAC_CAPABILITY_SYS_REBOOT,
@@ -178,7 +78,6 @@
 
 /* Structure for holding socket address. */
 struct ccs_addr_info {
-	u8 protocol;
 	u8 operation;
 	struct ccs_inet_addr_info inet;
 	struct ccs_unix_addr_info unix0;
@@ -191,32 +90,14 @@
 void ccs_get_attributes(struct ccs_obj_info *obj);
 
 static bool ccs_alphabet_char(const char c);
-static bool ccs_argv(const unsigned int index, const char *arg_ptr,
-		     const int argc, const struct ccs_argv *argv, u8 *checked);
 static bool ccs_byte_range(const char *str);
 static bool ccs_check_entry(struct ccs_request_info *r,
 			    struct ccs_acl_info *ptr);
-static bool ccs_check_execute_acl(struct ccs_request_info *r,
-				  const struct ccs_acl_info *ptr);
-static bool ccs_check_mkdev_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr);
-static bool ccs_check_mount_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr);
-static bool ccs_check_path2_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr);
-static bool ccs_check_path_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr);
-static bool ccs_check_path_number_acl(struct ccs_request_info *r,
-				      const struct ccs_acl_info *ptr);
 static bool ccs_check_use_group_acl(struct ccs_request_info *r,
 				    struct ccs_acl_info *ptr);
-static bool ccs_compare_number_union(const unsigned long value,
-				     const struct ccs_number_union *ptr);
 static bool ccs_condition(struct ccs_request_info *r,
 			  const struct ccs_condition *cond);
 static bool ccs_decimal(const char c);
-static bool ccs_envp(const char *env_name, const char *env_value,
-		     const int envc, const struct ccs_envp *envp, u8 *checked);
 static bool ccs_file_matches_pattern(const char *filename,
 				     const char *filename_end,
 				     const char *pattern,
@@ -233,14 +114,6 @@
 static bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 				     const struct ccs_path_info *pattern);
 static bool ccs_path_matches_pattern2(const char *f, const char *p);
-static bool ccs_scan_bprm(struct ccs_execve *ee, const u16 argc,
-			  const struct ccs_argv *argv, const u16 envc,
-			  const struct ccs_envp *envp);
-static bool ccs_scan_exec_realpath(struct file *file,
-				   const struct ccs_name_union *ptr,
-				   const bool match);
-static bool ccs_compare_name_union(const struct ccs_path_info *name,
-				   const struct ccs_name_union *ptr);
 static bool ccs_path_matches_group(const struct ccs_path_info *pathname,
 				   const struct ccs_group *group);
 static const struct ccs_path_info *ccs_transition_type
@@ -317,14 +190,15 @@
 static int ccs_old_pivot_root_permission(struct nameidata *old_nd,
 					 struct nameidata *new_nd);
 #endif
-static int ccs_path2_perm(const u8 operation, struct dentry *dentry1,
-			  struct vfsmount *mnt1, struct dentry *dentry2,
-			  struct vfsmount *mnt2);
-static int ccs_path_number_perm(const u8 type, struct dentry *dentry,
-				struct vfsmount *vfsmnt, unsigned long number);
-static int ccs_path_perm(const u8 operation, struct dentry *dentry,
-			 struct vfsmount *mnt);
-static int ccs_path_permission(u8 operation,
+static int ccs_path2_perm(const enum ccs_mac_index operation,
+			  struct dentry *dentry1, struct vfsmount *mnt1,
+			  struct dentry *dentry2, struct vfsmount *mnt2);
+static int ccs_path_number_perm(const enum ccs_mac_index type,
+				struct dentry *dentry, struct vfsmount *vfsmnt,
+				unsigned long number);
+static int ccs_path_perm(const enum ccs_mac_index operation,
+			 struct dentry *dentry, struct vfsmount *mnt);
+static int ccs_path_permission(enum ccs_mac_index type,
 			       const struct ccs_path_info *filename,
 			       struct ccs_obj_info *obj);
 static int ccs_start_execve(struct linux_binprm *bprm,
@@ -338,16 +212,12 @@
 static void ccs_finish_execve(int retval, struct ccs_execve *ee);
 
 #ifdef CONFIG_CCSECURITY_MISC
-static bool ccs_check_env_acl(struct ccs_request_info *r,
-			      const struct ccs_acl_info *ptr);
 static int ccs_env_perm(struct ccs_request_info *r, const char *env);
 static int ccs_environ(struct ccs_execve *ee);
 #endif
 
 #ifdef CONFIG_CCSECURITY_CAPABILITY
 static bool __ccs_capable(const u8 operation);
-static bool ccs_check_capability_acl(struct ccs_request_info *r,
-				     const struct ccs_acl_info *ptr);
 static bool ccs_kernel_service(void);
 static int __ccs_ptrace_permission(long request, long pid);
 static int __ccs_socket_create_permission(int family, int type, int protocol);
@@ -356,10 +226,6 @@
 #ifdef CONFIG_CCSECURITY_NETWORK
 static bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
 				      const struct ccs_group *group);
-static bool ccs_check_inet_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr);
-static bool ccs_check_unix_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr);
 static bool ccs_kernel_service(void);
 static int __ccs_socket_bind_permission(struct socket *sock,
 					struct sockaddr *addr, int addr_len);
@@ -389,8 +255,6 @@
 #endif
 
 #ifdef CONFIG_CCSECURITY_IPC
-static bool ccs_check_ptrace_acl(struct ccs_request_info *r,
-				 const struct ccs_acl_info *ptr);
 static int __ccs_ptrace_permission(long request, long pid);
 #endif
 
@@ -746,9 +610,9 @@
 			continue;
 		if (!ccs_check_entry(r, ptr) || !ccs_condition(r, ptr->cond))
 			continue;
-		return !acl->is_not;
+		return true;
 	}
-	return acl->is_not;
+	return false;
 }
 
 /**
@@ -764,47 +628,18 @@
 static bool ccs_check_entry(struct ccs_request_info *r,
 			    struct ccs_acl_info *ptr)
 {
-	if (ptr->is_deleted || ptr->type != r->param_type)
+	if (ptr->is_deleted || ptr->type != r->type)
 		return false;
-	switch (r->param_type) {
-	case CCS_TYPE_EXECUTE_ACL:
-		return ccs_check_execute_acl(r, ptr);
-	case CCS_TYPE_PATH_ACL:
-		return ccs_check_path_acl(r, ptr);
-	case CCS_TYPE_PATH2_ACL:
-		return ccs_check_path2_acl(r, ptr);
-	case CCS_TYPE_PATH_NUMBER_ACL:
-		return ccs_check_path_number_acl(r, ptr);
-	case CCS_TYPE_MKDEV_ACL:
-		return ccs_check_mkdev_acl(r, ptr);
-	case CCS_TYPE_MOUNT_ACL:
-		return ccs_check_mount_acl(r, ptr);
-#ifdef CONFIG_CCSECURITY_MISC
-	case CCS_TYPE_ENV_ACL:
-		return ccs_check_env_acl(r, ptr);
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-	case CCS_TYPE_CAPABILITY_ACL:
-		return ccs_check_capability_acl(r, ptr);
-#endif
-#ifdef CONFIG_CCSECURITY_NETWORK
-	case CCS_TYPE_INET_ACL:
-		return ccs_check_inet_acl(r, ptr);
-	case CCS_TYPE_UNIX_ACL:
-		return ccs_check_unix_acl(r, ptr);
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-	case CCS_TYPE_PTRACE_ACL:
-		return ccs_check_ptrace_acl(r, ptr);
-#endif
+	switch (r->type) {
 #ifdef CONFIG_CCSECURITY_TASK_DOMAIN_TRANSITION
 	case CCS_TYPE_MANUAL_TASK_ACL:
 		return ccs_check_task_acl(r, ptr);
 #endif
 	case CCS_TYPE_USE_GROUP_ACL:
 		return ccs_check_use_group_acl(r, ptr);
+	default:
+		return true;
 	}
-	return true;
 }
 
 /**
@@ -908,8 +743,8 @@
 	list_for_each_entry_srcu(ptr, list, list, &ccs_ss) {
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_check_execute_acl(r, ptr))
-			continue;
+		//if (!ccs_check_execute_acl(r, ptr))
+		//continue;
 		if (!ccs_condition(r, ptr->cond))
 			continue;
 		return container_of(ptr, struct ccs_execute_acl, head)->
@@ -1283,7 +1118,7 @@
 	 */
 	if (ccs_current_flags() & CCS_TASK_IS_EXECUTE_HANDLER)
 		return false;
-	r->param_type = type;
+	//r->type = type;
 	ccs_check_acl(r);
 	if (!r->granted)
 		return false;
@@ -1659,26 +1494,6 @@
 }
 
 /**
- * ccs_check_mount_acl - Check permission for path path path number operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_mount_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr)
-{
-	const struct ccs_mount_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return ccs_compare_number_union(r->param.mount.flags, &acl->flags) &&
-		ccs_compare_name_union(r->param.mount.type, &acl->fs_type) &&
-		ccs_compare_name_union(r->param.mount.dir, &acl->dir_name) &&
-		(!r->param.mount.need_dev ||
-		 ccs_compare_name_union(r->param.mount.dev, &acl->dev_name));
-}
-
-/**
  * ccs_mount_acl - Check permission for mount() operation.
  *
  * @dev_name: Name of device file. Maybe NULL.
@@ -1766,12 +1581,11 @@
 	rdev.name = requested_dev_name;
 	ccs_fill_path_info(&rdev);
 	r.type = CCS_MAC_FILE_MOUNT;
-	r.param_type = CCS_TYPE_MOUNT_ACL;
-	r.param.mount.need_dev = need_dev;
-	r.param.mount.dev = &rdev;
-	r.param.mount.dir = &rdir;
-	r.param.mount.type = &rtype;
-	r.param.mount.flags = flags;
+	r.param.s[0] = &rdev;
+	r.param.s[1] = &rdir;
+	r.param.s[2] = &rtype;
+	r.param.i[0] = flags;
+	r.param.i[1] = need_dev;
 	error = ccs_check_acl(&r);
 out:
 	kfree(requested_dev_name);
@@ -1859,40 +1673,6 @@
 #endif
 
 /**
- * ccs_compare_number_union - Check whether a value matches "struct ccs_number_union" or not.
- *
- * @value: Number to check.
- * @ptr:   Pointer to "struct ccs_number_union".
- *
- * Returns true if @value matches @ptr, false otherwise.
- */
-static bool ccs_compare_number_union(const unsigned long value,
-				     const struct ccs_number_union *ptr)
-{
-	if (ptr->group)
-		return ccs_number_matches_group(value, value, ptr->group) !=
-			ptr->is_not;
-	return value >= ptr->values[0] && value <= ptr->values[1];
-}
-
-/**
- * ccs_compare_name_union - Check whether a name matches "struct ccs_name_union" or not.
- *
- * @name: Pointer to "struct ccs_path_info".
- * @ptr:  Pointer to "struct ccs_name_union".
- *
- * Returns true if @name matches @ptr, false otherwise.
- */
-static bool ccs_compare_name_union(const struct ccs_path_info *name,
-				   const struct ccs_name_union *ptr)
-{
-	if (ptr->group)
-		return ccs_path_matches_group(name, ptr->group) !=
-			ptr->is_not;
-	return ccs_path_matches_pattern(name, ptr->filename);
-}
-
-/**
  * ccs_add_slash - Add trailing '/' if needed.
  *
  * @buf: Pointer to "struct ccs_path_info".
@@ -1930,115 +1710,22 @@
 }
 
 /**
- * ccs_check_execute_acl - Check permission for execute operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_execute_acl(struct ccs_request_info *r,
-				  const struct ccs_acl_info *ptr)
-{
-	const struct ccs_execute_acl *acl = container_of(ptr, typeof(*acl),
-							 head);
-	return ccs_compare_name_union(r->param.execute.program, &acl->program);
-}
-
-/**
- * ccs_check_path_acl - Check permission for path operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_path_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr)
-{
-	const struct ccs_path_acl *acl = container_of(ptr, typeof(*acl), head);
-	return (ptr->perm & (1 << r->param.path.operation)) &&
-		ccs_compare_name_union(r->param.path.filename, &acl->name);
-}
-
-/**
- * ccs_check_path_number_acl - Check permission for path number operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_path_number_acl(struct ccs_request_info *r,
-				      const struct ccs_acl_info *ptr)
-{
-	const struct ccs_path_number_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return (ptr->perm & (1 << r->param.path_number.operation)) &&
-		ccs_compare_number_union(r->param.path_number.number,
-					 &acl->number) &&
-		ccs_compare_name_union(r->param.path_number.filename,
-				       &acl->name);
-}
-
-/**
- * ccs_check_path2_acl - Check permission for path path operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_path2_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr)
-{
-	const struct ccs_path2_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return (ptr->perm & (1 << r->param.path2.operation)) &&
-		ccs_compare_name_union(r->param.path2.filename1, &acl->name1)
-		&& ccs_compare_name_union(r->param.path2.filename2,
-					  &acl->name2);
-}
-
-/**
- * ccs_check_mkdev_acl - Check permission for path number number number operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_mkdev_acl(struct ccs_request_info *r,
-				const struct ccs_acl_info *ptr)
-{
-	const struct ccs_mkdev_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return (ptr->perm & (1 << r->param.mkdev.operation)) &&
-		ccs_compare_number_union(r->param.mkdev.mode, &acl->mode) &&
-		ccs_compare_number_union(r->param.mkdev.major, &acl->major) &&
-		ccs_compare_number_union(r->param.mkdev.minor, &acl->minor) &&
-		ccs_compare_name_union(r->param.mkdev.filename, &acl->name);
-}
-
-/**
  * ccs_path_permission - Check permission for path operation.
  *
- * @operation: Type of operation.
- * @filename:  Filename to check.
- * @obj:       Pointer to "struct ccs_obj_info". Maybe NULL.
+ * @type:     One of values in "enum ccs_mac_index".
+ * @filename: Filename to check.
+ * @obj:      Pointer to "struct ccs_obj_info". Maybe NULL.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_path_permission(u8 operation,
+static int ccs_path_permission(enum ccs_mac_index type,
 			       const struct ccs_path_info *filename,
 			       struct ccs_obj_info *obj)
 {
 	struct ccs_request_info r = { };
-	r.type = ccs_p2mac[operation];
+	r.type = type;
 	r.obj = obj;
-	r.param_type = CCS_TYPE_PATH_ACL;
-	r.param.path.filename = filename;
-	r.param.path.operation = operation;
+	r.param.s[0] = filename;
 	return ccs_check_acl(&r);
 }
 
@@ -2054,8 +1741,7 @@
 				  const struct ccs_path_info *filename)
 {
 	r->type = CCS_MAC_FILE_EXECUTE;
-	r->param_type = CCS_TYPE_EXECUTE_ACL;
-	r->param.execute.program = filename;
+	r->param.s[0] = filename;
 	return ccs_check_acl(r);
 }
 
@@ -2145,7 +1831,7 @@
 			error = -ENOMEM;
 			goto out;
 		}
-		error = ccs_path_permission(CCS_TYPE_READ, &buf, &obj);
+		error = ccs_path_permission(CCS_MAC_FILE_READ, &buf, &obj);
 		if (error)
 			goto out;
 	}
@@ -2155,8 +1841,8 @@
 			goto out;
 		}
 		error = ccs_path_permission((flag & O_APPEND) ?
-					    CCS_TYPE_APPEND :
-					    CCS_TYPE_WRITE, &buf, &obj);
+					    CCS_MAC_FILE_APPEND :
+					    CCS_MAC_FILE_WRITE, &buf, &obj);
 	}
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
 	if (!error && (flag & O_TRUNC)) {
@@ -2164,7 +1850,7 @@
 			error = -ENOMEM;
 			goto out;
 		}
-		error = ccs_path_permission(CCS_TYPE_TRUNCATE, &buf, &obj);
+		error = ccs_path_permission(CCS_MAC_FILE_TRUNCATE, &buf, &obj);
 	}
 #endif
 out:
@@ -2192,14 +1878,14 @@
 /**
  * ccs_path_perm - Check permission for "unlink", "rmdir", "truncate", "append", "getattr", "chroot" and "unmount".
  *
- * @operation: Type of operation.
+ * @operation: One of values in "enum ccs_mac_index".
  * @dentry:    Pointer to "struct dentry".
  * @mnt:       Pointer to "struct vfsmount". Maybe NULL.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_path_perm(const u8 operation, struct dentry *dentry,
-			 struct vfsmount *mnt)
+static int ccs_path_perm(const enum ccs_mac_index operation,
+			 struct dentry *dentry, struct vfsmount *mnt)
 {
 	struct ccs_obj_info obj = {
 		.path1.dentry = dentry,
@@ -2210,10 +1896,12 @@
 	if (!ccs_get_realpath(&buf, &obj.path1))
 		return -ENOMEM;
 	switch (operation) {
-	case CCS_TYPE_RMDIR:
-	case CCS_TYPE_CHROOT:
+	case CCS_MAC_FILE_RMDIR:
+	case CCS_MAC_FILE_CHROOT:
 		ccs_add_slash(&buf);
 		break;
+	default:
+		break;
 	}
 	error = ccs_path_permission(operation, &buf, &obj);
 	kfree(buf.name);
@@ -2223,7 +1911,7 @@
 /**
  * ccs_mkdev_perm - Check permission for "mkblock" and "mkchar".
  *
- * @operation: Type of operation. (CCS_TYPE_MKCHAR or CCS_TYPE_MKBLOCK)
+ * @operation: Type of operation. (CCS_MAC_FILE_MKCHAR or CCS_MAC_FILE_MKBLOCK)
  * @dentry:    Pointer to "struct dentry".
  * @mnt:       Pointer to "struct vfsmount". Maybe NULL.
  * @mode:      Create mode.
@@ -2249,14 +1937,12 @@
 #endif
 	{
 		struct ccs_request_info r = { };
-		r.type = ccs_pnnn2mac[operation];
+		r.type = operation;
 		r.obj = &obj;
-		r.param_type = CCS_TYPE_MKDEV_ACL;
-		r.param.mkdev.filename = &buf;
-		r.param.mkdev.operation = operation;
-		r.param.mkdev.mode = mode;
-		r.param.mkdev.major = MAJOR(dev);
-		r.param.mkdev.minor = MINOR(dev);
+		r.param.s[0] = &buf;
+		r.param.i[0] = mode;
+		r.param.i[1] = MAJOR(dev);
+		r.param.i[2] = MINOR(dev);
 		error = ccs_check_acl(&r);
 	}
 	kfree(buf.name);
@@ -2266,7 +1952,7 @@
 /**
  * ccs_path2_perm - Check permission for "rename", "link" and "pivot_root".
  *
- * @operation: Type of operation.
+ * @operation: One of values in "enum ccs_mac_index".
  * @dentry1:   Pointer to "struct dentry".
  * @mnt1:      Pointer to "struct vfsmount". Maybe NULL.
  * @dentry2:   Pointer to "struct dentry".
@@ -2274,9 +1960,9 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_path2_perm(const u8 operation, struct dentry *dentry1,
-			  struct vfsmount *mnt1, struct dentry *dentry2,
-			  struct vfsmount *mnt2)
+static int ccs_path2_perm(const enum ccs_mac_index operation,
+			  struct dentry *dentry1, struct vfsmount *mnt1,
+			  struct dentry *dentry2, struct vfsmount *mnt2)
 {
 	struct ccs_obj_info obj = {
 		.path1.dentry = dentry1,
@@ -2295,24 +1981,24 @@
 		return -ENOMEM;
 	}
 	switch (operation) {
-	case CCS_TYPE_RENAME:
-	case CCS_TYPE_LINK:
+	case CCS_MAC_FILE_RENAME:
+	case CCS_MAC_FILE_LINK:
 		if (!dentry1->d_inode || !S_ISDIR(dentry1->d_inode->i_mode))
 			break;
 		/* fall through */
-	case CCS_TYPE_PIVOT_ROOT:
+	case CCS_MAC_FILE_PIVOT_ROOT:
 		ccs_add_slash(&buf1);
 		ccs_add_slash(&buf2);
 		break;
+	default:
+		break;
 	}
 	{
 		struct ccs_request_info r = { };
-		r.type = ccs_pp2mac[operation];
+		r.type = operation;
 		r.obj = &obj;
-		r.param_type = CCS_TYPE_PATH2_ACL;
-		r.param.path2.operation = operation;
-		r.param.path2.filename1 = &buf1;
-		r.param.path2.filename2 = &buf2;
+		r.param.s[0] = &buf1;
+		r.param.s[1] = &buf2;
 		error = ccs_check_acl(&r);
 	}
 	kfree(buf1.name);
@@ -2352,10 +2038,8 @@
 		struct ccs_request_info r = { };
 		r.type = CCS_MAC_FILE_SYMLINK;
 		r.obj = &obj;
-		r.param_type = CCS_TYPE_PATH2_ACL;
-		r.param.path2.operation = CCS_TYPE_SYMLINK;
-		r.param.path2.filename1 = &buf1;
-		r.param.path2.filename2 = &buf2;
+		r.param.s[0] = &buf1;
+		r.param.s[1] = &buf2;
 		error = ccs_check_acl(&r);
 	}
 	kfree(buf1.name);
@@ -2366,15 +2050,16 @@
 /**
  * ccs_path_number_perm - Check permission for "create", "mkdir", "mkfifo", "mksock", "ioctl", "chmod", "chown", "chgrp".
  *
- * @type:   Type of operation.
+ * @type:   One of values in "enum ccs_mac_index".
  * @dentry: Pointer to "struct dentry".
  * @vfsmnt: Pointer to "struct vfsmount". Maybe NULL.
  * @number: Number.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_path_number_perm(const u8 type, struct dentry *dentry,
-				struct vfsmount *vfsmnt, unsigned long number)
+static int ccs_path_number_perm(const enum ccs_mac_index type,
+				struct dentry *dentry, struct vfsmount *vfsmnt,
+				unsigned long number)
 {
 	struct ccs_obj_info obj = {
 		.path1.dentry = dentry,
@@ -2387,16 +2072,14 @@
 	ccs_check_auto_domain_transition();
 	if (!ccs_get_realpath(&buf, &obj.path1))
 		return -ENOMEM;
-	if (type == CCS_TYPE_MKDIR)
+	if (type == CCS_MAC_FILE_MKDIR)
 		ccs_add_slash(&buf);
 	{
 		struct ccs_request_info r = { };
-		r.type = ccs_pn2mac[type];
+		r.type = type;
 		r.obj = &obj;
-		r.param_type = CCS_TYPE_PATH_NUMBER_ACL;
-		r.param.path_number.operation = type;
-		r.param.path_number.filename = &buf;
-		r.param.path_number.number = number;
+		r.param.s[0] = &buf;
+		r.param.i[0] = number;
 		error = ccs_check_acl(&r);
 	}
 	kfree(buf.name);
@@ -2415,7 +2098,7 @@
 static int __ccs_ioctl_permission(struct file *filp, unsigned int cmd,
 				  unsigned long arg)
 {
-	return ccs_path_number_perm(CCS_TYPE_IOCTL, filp->f_dentry,
+	return ccs_path_number_perm(CCS_MAC_FILE_IOCTL, filp->f_dentry,
 				    filp->f_vfsmnt, cmd);
 }
 
@@ -2433,7 +2116,7 @@
 {
 	if (mode == (mode_t) -1)
 		return 0;
-	return ccs_path_number_perm(CCS_TYPE_CHMOD, dentry, vfsmnt,
+	return ccs_path_number_perm(CCS_MAC_FILE_CHMOD, dentry, vfsmnt,
 				    mode & S_IALLUGO);
 }
 
@@ -2455,11 +2138,11 @@
 	if (user == (uid_t) -1 && group == (gid_t) -1)
 		return 0;
 	if (user != (uid_t) -1)
-		error = ccs_path_number_perm(CCS_TYPE_CHOWN, dentry, vfsmnt,
-					     user);
+		error = ccs_path_number_perm(CCS_MAC_FILE_CHOWN, dentry,
+					     vfsmnt, user);
 	if (!error && group != (gid_t) -1)
-		error = ccs_path_number_perm(CCS_TYPE_CHGRP, dentry, vfsmnt,
-					     group);
+		error = ccs_path_number_perm(CCS_MAC_FILE_CHGRP, dentry,
+					     vfsmnt, group);
 	return error;
 }
 
@@ -2500,7 +2183,7 @@
 static int __ccs_pivot_root_permission(struct path *old_path,
 				       struct path *new_path)
 {
-	return ccs_path2_perm(CCS_TYPE_PIVOT_ROOT, new_path->dentry,
+	return ccs_path2_perm(CCS_MAC_FILE_PIVOT_ROOT, new_path->dentry,
 			      new_path->mnt, old_path->dentry, old_path->mnt);
 }
 
@@ -2513,7 +2196,7 @@
  */
 static int __ccs_chroot_permission(struct path *path)
 {
-	return ccs_path_perm(CCS_TYPE_CHROOT, path->dentry, path->mnt);
+	return ccs_path_perm(CCS_MAC_FILE_CHROOT, path->dentry, path->mnt);
 }
 
 /**
@@ -2526,7 +2209,7 @@
  */
 static int __ccs_umount_permission(struct vfsmount *mnt, int flags)
 {
-	return ccs_path_perm(CCS_TYPE_UMOUNT, mnt->mnt_root, mnt);
+	return ccs_path_perm(CCS_MAC_FILE_UMOUNT, mnt->mnt_root, mnt);
 }
 
 /**
@@ -2546,24 +2229,24 @@
 	const unsigned int perm = mode & S_IALLUGO;
 	switch (mode & S_IFMT) {
 	case S_IFCHR:
-		error = ccs_mkdev_perm(CCS_TYPE_MKCHAR, dentry, mnt, perm,
+		error = ccs_mkdev_perm(CCS_MAC_FILE_MKCHAR, dentry, mnt, perm,
 				       dev);
 		break;
 	case S_IFBLK:
-		error = ccs_mkdev_perm(CCS_TYPE_MKBLOCK, dentry, mnt, perm,
+		error = ccs_mkdev_perm(CCS_MAC_FILE_MKBLOCK, dentry, mnt, perm,
 				       dev);
 		break;
 	case S_IFIFO:
-		error = ccs_path_number_perm(CCS_TYPE_MKFIFO, dentry, mnt,
+		error = ccs_path_number_perm(CCS_MAC_FILE_MKFIFO, dentry, mnt,
 					     perm);
 		break;
 	case S_IFSOCK:
-		error = ccs_path_number_perm(CCS_TYPE_MKSOCK, dentry, mnt,
+		error = ccs_path_number_perm(CCS_MAC_FILE_MKSOCK, dentry, mnt,
 					     perm);
 		break;
 	case 0:
 	case S_IFREG:
-		error = ccs_path_number_perm(CCS_TYPE_CREATE, dentry, mnt,
+		error = ccs_path_number_perm(CCS_MAC_FILE_CREATE, dentry, mnt,
 					     perm);
 		break;
 	}
@@ -2582,7 +2265,7 @@
 static int __ccs_mkdir_permission(struct dentry *dentry, struct vfsmount *mnt,
 				  unsigned int mode)
 {
-	return ccs_path_number_perm(CCS_TYPE_MKDIR, dentry, mnt, mode);
+	return ccs_path_number_perm(CCS_MAC_FILE_MKDIR, dentry, mnt, mode);
 }
 
 /**
@@ -2595,7 +2278,7 @@
  */
 static int __ccs_rmdir_permission(struct dentry *dentry, struct vfsmount *mnt)
 {
-	return ccs_path_perm(CCS_TYPE_RMDIR, dentry, mnt);
+	return ccs_path_perm(CCS_MAC_FILE_RMDIR, dentry, mnt);
 }
 
 /**
@@ -2608,7 +2291,7 @@
  */
 static int __ccs_unlink_permission(struct dentry *dentry, struct vfsmount *mnt)
 {
-	return ccs_path_perm(CCS_TYPE_UNLINK, dentry, mnt);
+	return ccs_path_perm(CCS_MAC_FILE_UNLINK, dentry, mnt);
 }
 
 #ifdef CONFIG_CCSECURITY_FILE_GETATTR
@@ -2624,7 +2307,7 @@
 static int __ccs_getattr_permission(struct vfsmount *mnt,
 				    struct dentry *dentry)
 {
-	return ccs_path_perm(CCS_TYPE_GETATTR, dentry, mnt);
+	return ccs_path_perm(CCS_MAC_FILE_GETATTR, dentry, mnt);
 }
 
 #endif
@@ -2640,7 +2323,7 @@
 static int __ccs_truncate_permission(struct dentry *dentry,
 				     struct vfsmount *mnt)
 {
-	return ccs_path_perm(CCS_TYPE_TRUNCATE, dentry, mnt);
+	return ccs_path_perm(CCS_MAC_FILE_TRUNCATE, dentry, mnt);
 }
 
 /**
@@ -2656,7 +2339,7 @@
 				   struct dentry *new_dentry,
 				   struct vfsmount *mnt)
 {
-	return ccs_path2_perm(CCS_TYPE_RENAME, old_dentry, mnt, new_dentry,
+	return ccs_path2_perm(CCS_MAC_FILE_RENAME, old_dentry, mnt, new_dentry,
 			      mnt);
 }
 
@@ -2673,7 +2356,8 @@
 				 struct dentry *new_dentry,
 				 struct vfsmount *mnt)
 {
-	return ccs_path2_perm(CCS_TYPE_LINK, old_dentry, mnt, new_dentry, mnt);
+	return ccs_path2_perm(CCS_MAC_FILE_LINK, old_dentry, mnt, new_dentry,
+			      mnt);
 }
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 30)
@@ -2792,11 +2476,12 @@
 			goto out;
 		ccs_fill_path_info(&buf);
 		if (op & MAY_READ)
-			error = ccs_path_permission(CCS_TYPE_READ, &buf, NULL);
+			error = ccs_path_permission(CCS_MAC_FILE_READ, &buf,
+						    NULL);
 		else
 			error = 0;
 		if (!error && (op & MAY_WRITE))
-			error = ccs_path_permission(CCS_TYPE_WRITE, &buf,
+			error = ccs_path_permission(CCS_MAC_FILE_WRITE, &buf,
 						    NULL);
 		kfree(buf.name);
 		if (error)
@@ -2814,11 +2499,12 @@
 			goto out;
 		ccs_fill_path_info(&buf);
 		if (op & MAY_READ)
-			error = ccs_path_permission(CCS_TYPE_READ, &buf, NULL);
+			error = ccs_path_permission(CCS_MAC_FILE_READ, &buf,
+						    NULL);
 		else
 			error = 0;
 		if (!error && (op & MAY_WRITE))
-			error = ccs_path_permission(CCS_TYPE_WRITE, &buf,
+			error = ccs_path_permission(CCS_MAC_FILE_WRITE, &buf,
 						    NULL);
 		kfree(buf.name);
 		goto out;
@@ -2901,51 +2587,29 @@
 }
 
 /**
- * ccs_check_inet_acl - Check permission for inet domain socket operation.
+ * ccs_compare_inet_address - Compare IPv4 or IPv6 address.
  *
  * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
+ * @acl: Pointer to "struct ccs_ipaddr_union".
  *
- * Returns true if granted, false otherwise.
+ * Returns true on match, false otherwise.
  */
-static bool ccs_check_inet_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr)
+/*
+static bool ccs_compare_inet_address(const struct ccs_request_info *r,
+				     const struct ccs_ipaddr_union *acl)
 {
-	const struct ccs_inet_acl *acl = container_of(ptr, typeof(*acl), head);
-	const u8 size = r->param.inet_network.is_ipv6 ? 16 : 4;
-	if (!(ptr->perm & (1 << r->param.inet_network.operation)) ||
-	    !ccs_compare_number_union(r->param.inet_network.port, &acl->port))
-		return false;
-	if (acl->address.group)
-		return ccs_address_matches_group(r->param.inet_network.is_ipv6,
-						 r->param.inet_network.address,
-						 acl->address.group)
-			!= acl->address.is_not;
-	return acl->address.is_ipv6 == r->param.inet_network.is_ipv6 &&
-		memcmp(&acl->address.ip[0],
-		       r->param.inet_network.address, size) <= 0 &&
-		memcmp(r->param.inet_network.address,
-		       &acl->address.ip[1], size) <= 0;
+	const u8 size = r->param.is_ipv6 ? 16 : 4;
+	if (acl->group)
+		return ccs_address_matches_group(r->param.is_ipv6,
+						 r->param.inet_address,
+						 acl->group);
+	return acl->is_ipv6 == r->param.is_ipv6 &&
+		memcmp(&acl->ip[0], r->param.inet_address, size) <= 0 &&
+		memcmp(r->param.inet_address, &acl->ip[1], size) <= 0;
 }
+*/
 
 /**
- * ccs_check_unix_acl - Check permission for unix domain socket operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_unix_acl(struct ccs_request_info *r,
-			       const struct ccs_acl_info *ptr)
-{
-	const struct ccs_unix_acl *acl = container_of(ptr, typeof(*acl), head);
-	return (ptr->perm & (1 << r->param.unix_network.operation)) &&
-		ccs_compare_name_union(r->param.unix_network.address,
-				       &acl->name);
-}
-
-/**
  * ccs_inet_entry - Check permission for INET network operation.
  *
  * @address: Pointer to "struct ccs_addr_info".
@@ -2954,26 +2618,20 @@
  */
 static int ccs_inet_entry(const struct ccs_addr_info *address)
 {
-	const u8 type = ccs_inet2mac[address->protocol][address->operation];
+	struct ccs_request_info r = { };
 	ccs_check_auto_domain_transition();
-	if (type) {
-		struct ccs_request_info r = { };
-		r.type = type;
-		r.param_type = CCS_TYPE_INET_ACL;
-		r.param.inet_network.protocol = address->protocol;
-		r.param.inet_network.operation = address->operation;
-		r.param.inet_network.is_ipv6 = address->inet.is_ipv6;
-		r.param.inet_network.address = address->inet.address;
-		r.param.inet_network.port = ntohs(address->inet.port);
-		r.dont_sleep_on_enforce_error =
-			address->operation == CCS_NETWORK_ACCEPT
+	r.type = address->operation;
+	r.param.is_ipv6 = address->inet.is_ipv6;
+	r.param.inet_address = address->inet.address;
+	r.param.inet_port = ntohs(address->inet.port);
+	r.dont_sleep_on_enforce_error =
+		r.type == CCS_MAC_NETWORK_INET_STREAM_ACCEPT
 #ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-			|| address->operation == CCS_NETWORK_RECV
+		|| r.type == CCS_MAC_NETWORK_INET_DGRAM_RECV ||
+		r.type == CCS_MAC_NETWORK_INET_RAW_RECV;
 #endif
-			;
-		return ccs_check_acl(&r);
-	}
-	return 0;
+		;
+	return ccs_check_acl(&r);
 }
 
 /**
@@ -3010,7 +2668,9 @@
 	default:
 		goto skip;
 	}
-	if (address->protocol == SOCK_RAW)
+	if (address->operation == CCS_MAC_NETWORK_INET_RAW_BIND ||
+	    address->operation == CCS_MAC_NETWORK_INET_RAW_SEND ||
+	    address->operation == CCS_MAC_NETWORK_INET_RAW_RECV)
 		i->port = htons(port);
 	return ccs_inet_entry(address);
 skip:
@@ -3026,39 +2686,34 @@
  */
 static int ccs_unix_entry(const struct ccs_addr_info *address)
 {
-	int error = 0;
-	const u8 type = ccs_unix2mac[address->protocol][address->operation];
-	if (type) {
-		char *buf = address->unix0.addr;
-		int len = address->unix0.addr_len - sizeof(sa_family_t);
-		if (len <= 0) {
-			buf = "anonymous";
-			len = 9;
-		} else if (buf[0]) {
-			len = strnlen(buf, len);
-		}
-		buf = ccs_encode2(buf, len);
-		if (buf) {
-			struct ccs_path_info addr;
-			struct ccs_request_info r = { };
-			addr.name = buf;
-			ccs_fill_path_info(&addr);
-			r.type = type;
-			r.param_type = CCS_TYPE_UNIX_ACL;
-			r.param.unix_network.protocol = address->protocol;
-			r.param.unix_network.operation = address->operation;
-			r.param.unix_network.address = &addr;
-			r.dont_sleep_on_enforce_error =
-				address->operation == CCS_NETWORK_ACCEPT
+	int error;
+	char *buf = address->unix0.addr;
+	int len = address->unix0.addr_len - sizeof(sa_family_t);
+	if (len <= 0) {
+		buf = "anonymous";
+		len = 9;
+	} else if (buf[0]) {
+		len = strnlen(buf, len);
+	}
+	buf = ccs_encode2(buf, len);
+	if (buf) {
+		struct ccs_path_info addr;
+		struct ccs_request_info r = { };
+		addr.name = buf;
+		ccs_fill_path_info(&addr);
+		r.type = address->operation;
+		r.param.unix_address = &addr;
+		r.dont_sleep_on_enforce_error =
+			r.type == CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT ||
+			r.type == CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT
 #ifdef CONFIG_CCSECURITY_NETWORK_RECVMSG
-				|| address->operation == CCS_NETWORK_RECV
+			|| r.type == CCS_MAC_NETWORK_UNIX_DGRAM_RECV
 #endif
-				;
-			error = ccs_check_acl(&r);
-			kfree(buf);
-		} else
-			error = -ENOMEM;
-	}
+			;
+		error = ccs_check_acl(&r);
+		kfree(buf);
+	} else
+		error = -ENOMEM;
 	return error;
 }
 
@@ -3128,8 +2783,12 @@
 		if (error)
 			return error;
 	}
-	address.protocol = type;
-	address.operation = CCS_NETWORK_LISTEN;
+	if (family == PF_INET || family == PF_INET6)
+		address.operation = CCS_MAC_NETWORK_INET_STREAM_LISTEN;
+	else if (type == SOCK_STREAM)
+		address.operation = CCS_MAC_NETWORK_UNIX_STREAM_LISTEN;
+	else
+		address.operation = CCS_MAC_NETWORK_UNIX_SEQPACKET_LISTEN;
 	if (family == PF_UNIX)
 		return ccs_check_unix_address((struct sockaddr *) &addr,
 					      addr_len, &address);
@@ -3151,18 +2810,24 @@
 {
 	struct ccs_addr_info address;
 	const u8 family = ccs_sock_family(sock->sk);
-	const unsigned int type = sock->type;
 	if (!family)
 		return 0;
-	address.protocol = type;
-	switch (type) {
+	switch (sock->type) {
 	case SOCK_DGRAM:
+		address.operation = family == PF_UNIX ?
+			CCS_MAC_NETWORK_UNIX_DGRAM_SEND :
+			CCS_MAC_NETWORK_INET_DGRAM_SEND;
+		break;
 	case SOCK_RAW:
-		address.operation = CCS_NETWORK_SEND;
+		address.operation = CCS_MAC_NETWORK_INET_RAW_SEND;
 		break;
 	case SOCK_STREAM:
+		address.operation = family == PF_UNIX ?
+			CCS_MAC_NETWORK_UNIX_STREAM_CONNECT :
+			CCS_MAC_NETWORK_INET_STREAM_CONNECT;
+		break;
 	case SOCK_SEQPACKET:
-		address.operation = CCS_NETWORK_CONNECT;
+		address.operation = CCS_MAC_NETWORK_UNIX_SEQPACKET_CONNECT;
 		break;
 	default:
 		return 0;
@@ -3192,11 +2857,20 @@
 		return 0;
 	switch (type) {
 	case SOCK_STREAM:
+		address.operation = family == PF_UNIX ?
+			CCS_MAC_NETWORK_UNIX_STREAM_BIND :
+			CCS_MAC_NETWORK_INET_STREAM_BIND;
+		break;
 	case SOCK_DGRAM:
+		address.operation = family == PF_UNIX ?
+			CCS_MAC_NETWORK_UNIX_DGRAM_BIND :
+			CCS_MAC_NETWORK_INET_DGRAM_BIND;
+		break;
 	case SOCK_RAW:
+		address.operation = CCS_MAC_NETWORK_INET_RAW_BIND;
+		break;
 	case SOCK_SEQPACKET:
-		address.protocol = type;
-		address.operation = CCS_NETWORK_BIND;
+		address.operation = CCS_MAC_NETWORK_UNIX_SEQPACKET_BIND;
 		break;
 	default:
 		return 0;
@@ -3225,9 +2899,13 @@
 	if (!msg->msg_name || !family ||
 	    (type != SOCK_DGRAM && type != SOCK_RAW))
 		return 0;
-	address.protocol = type;
-	address.operation = CCS_NETWORK_SEND;
 	if (family == PF_UNIX)
+		address.operation = CCS_MAC_NETWORK_UNIX_DGRAM_SEND;
+	else if (type == SOCK_DGRAM)
+		address.operation = CCS_MAC_NETWORK_INET_DGRAM_SEND;
+	else
+		address.operation = CCS_MAC_NETWORK_INET_RAW_SEND;
+	if (family == PF_UNIX)
 		return ccs_check_unix_address((struct sockaddr *)
 					      msg->msg_name, msg->msg_namelen,
 					      &address);
@@ -3261,8 +2939,12 @@
 		if (error)
 			return error;
 	}
-	address.protocol = type;
-	address.operation = CCS_NETWORK_ACCEPT;
+	if (family == PF_INET || family == PF_INET6)
+		address.operation = CCS_MAC_NETWORK_INET_STREAM_ACCEPT;
+	else if (type == SOCK_STREAM)
+		address.operation = CCS_MAC_NETWORK_UNIX_STREAM_ACCEPT;
+	else
+		address.operation = CCS_MAC_NETWORK_UNIX_SEQPACKET_ACCEPT;
 	if (family == PF_UNIX)
 		return ccs_check_unix_address((struct sockaddr *) &addr,
 					      addr_len, &address);
@@ -3288,17 +2970,14 @@
 	const u8 family = ccs_sock_family(sk);
 	const unsigned int type = sk->sk_type;
 	struct sockaddr_storage addr;
-	if (!family)
+	if (!family || (type != SOCK_DGRAM && type != SOCK_RAW))
 		return 0;
-	switch (type) {
-	case SOCK_DGRAM:
-	case SOCK_RAW:
-		address.protocol = type;
-		break;
-	default:
-		return 0;
-	}
-	address.operation = CCS_NETWORK_RECV;
+	if (family == PF_UNIX)
+		address.operation = CCS_MAC_NETWORK_UNIX_DGRAM_RECV;
+	else if (type == SOCK_DGRAM)
+		address.operation = CCS_MAC_NETWORK_INET_DGRAM_RECV;
+	else
+		address.operation = CCS_MAC_NETWORK_INET_RAW_RECV;
 	switch (family) {
 	case PF_INET6:
 		{
@@ -3309,7 +2988,7 @@
 				ipv6_addr_set(sin6, 0, 0, htonl(0xffff),
 					      ip_hdr(skb)->saddr);
 			else
-				ipv6_addr_copy(sin6, &ipv6_hdr(skb)->saddr);
+				*sin6 = ipv6_hdr(skb)->saddr;
 			break;
 		}
 	case PF_INET:
@@ -3399,22 +3078,6 @@
 #ifdef CONFIG_CCSECURITY_CAPABILITY
 
 /**
- * ccs_check_capability_acl - Check permission for capability operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_capability_acl(struct ccs_request_info *r,
-				     const struct ccs_acl_info *ptr)
-{
-	const struct ccs_capability_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return acl->operation == r->param.capability.operation;
-}
-
-/**
  * ccs_capable - Check permission for capability.
  *
  * @operation: Type of operation.
@@ -3425,8 +3088,6 @@
 {
 	struct ccs_request_info r = { };
 	r.type = ccs_c2mac[operation];
-	r.param_type = CCS_TYPE_CAPABILITY_ACL;
-	r.param.capability.operation = operation;
 	return !ccs_check_acl(&r);
 }
 
@@ -3455,24 +3116,6 @@
 #ifdef CONFIG_CCSECURITY_IPC
 
 /**
- * ccs_check_ptrace_acl - Check permission for ptrace operation.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_ptrace_acl(struct ccs_request_info *r,
-				 const struct ccs_acl_info *ptr)
-{
-	const struct ccs_ptrace_acl *acl =
-		container_of(ptr, typeof(*acl), head);
-	return ccs_compare_number_union(r->param.ptrace.request,
-					&acl->request) &&
-		!strcmp(acl->domainname->name, r->param.ptrace.domainname);
-}
-
-/**
  * __ccs_ptrace_permission - Check permission for ptrace().
  *
  * @request: Command number.
@@ -3502,9 +3145,8 @@
 			goto out;
 	}
 	r.type = CCS_MAC_PTRACE;
-	r.param_type = CCS_TYPE_PTRACE_ACL;
-	r.param.ptrace.request = request;
-	r.param.ptrace.domainname = dest->domainname->name;
+	r.param.i[0] = request;
+	r.param.domainname = dest->domainname->name;
 	error = ccs_check_acl(&r);
 out:
 	ccs_read_unlock(idx);
@@ -3516,21 +3158,6 @@
 #ifdef CONFIG_CCSECURITY_MISC
 
 /**
- * ccs_check_env_acl - Check permission for environment variable's name.
- *
- * @r:   Pointer to "struct ccs_request_info".
- * @ptr: Pointer to "struct ccs_acl_info".
- *
- * Returns true if granted, false otherwise.
- */
-static bool ccs_check_env_acl(struct ccs_request_info *r,
-			      const struct ccs_acl_info *ptr)
-{
-	const struct ccs_env_acl *acl = container_of(ptr, typeof(*acl), head);
-	return ccs_compare_name_union(r->param.environ.name, &acl->env);
-}
-
-/**
  * ccs_env_perm - Check permission for environment variable's name.
  *
  * @r:   Pointer to "struct ccs_request_info".
@@ -3546,8 +3173,7 @@
 	environ.name = env;
 	ccs_fill_path_info(&environ);
 	r->type = CCS_MAC_ENVIRON;
-	r->param_type = CCS_TYPE_ENV_ACL;
-	r->param.environ.name = &environ;
+	r->param.env_name = &environ;
 	return ccs_check_acl(r);
 }
 
@@ -3630,94 +3256,77 @@
 #endif
 
 /**
- * ccs_argv - Check argv[] in "struct linux_binbrm".
+ * ccs_check_argv - Check argv[] in "struct linux_binbrm".
  *
- * @index:   Index number of @arg_ptr.
- * @arg_ptr: Contents of argv[@index].
- * @argc:    Length of @argv.
- * @argv:    Pointer to "struct ccs_argv".
- * @checked: Set to true if @argv[@index] was found.
+ * @ee:     Pointer to "struct ccs_execve".
+ * @index:  Index number to check.
+ * @value:  Poiner to "struct ccs_path_info".
+ * @is_not: True if negative match, false otherwise.
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_argv(const unsigned int index, const char *arg_ptr,
-		     const int argc, const struct ccs_argv *argv,
-		     u8 *checked)
+static bool ccs_check_argv(struct ccs_execve *ee, unsigned long index,
+			   const struct ccs_path_info *value,
+			   const bool is_not)
 {
-	int i;
+	struct linux_binprm *bprm = ee->bprm;
+	struct ccs_page_dump *dump = &ee->dump;
+	char *arg_ptr = ee->tmp;
+	int arg_len = 0;
+	unsigned long pos = bprm->p;
+	int offset = pos % PAGE_SIZE;
 	struct ccs_path_info arg;
-	arg.name = arg_ptr;
-	for (i = 0; i < argc; argv++, checked++, i++) {
-		bool result;
-		if (index != argv->index)
-			continue;
-		*checked = 1;
-		ccs_fill_path_info(&arg);
-		result = ccs_path_matches_pattern(&arg, argv->value);
-		if (argv->is_not)
-			result = !result;
-		if (!result)
+	if (index > bprm->argc)
+		return false;
+	while (1) {
+		if (!ccs_dump_page(bprm, pos, dump))
 			return false;
-	}
-	return true;
-}
-
-/**
- * ccs_envp - Check envp[] in "struct linux_binbrm".
- *
- * @env_name:  The name of environment variable.
- * @env_value: The value of environment variable.
- * @envc:      Length of @envp.
- * @envp:      Pointer to "struct ccs_envp".
- * @checked:   Set to true if @envp[@env_name] was found.
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_envp(const char *env_name, const char *env_value,
-		     const int envc, const struct ccs_envp *envp,
-		     u8 *checked)
-{
-	int i;
-	struct ccs_path_info name;
-	struct ccs_path_info value;
-	name.name = env_name;
-	ccs_fill_path_info(&name);
-	value.name = env_value;
-	ccs_fill_path_info(&value);
-	for (i = 0; i < envc; envp++, checked++, i++) {
-		bool result;
-		if (!ccs_path_matches_pattern(&name, envp->name))
-			continue;
-		*checked = 1;
-		if (envp->value) {
-			result = ccs_path_matches_pattern(&value, envp->value);
-			if (envp->is_not)
-				result = !result;
-		} else {
-			result = true;
-			if (!envp->is_not)
-				result = !result;
+		pos += PAGE_SIZE - offset;
+		while (offset < PAGE_SIZE) {
+			const unsigned char c = dump->data[offset++];
+			if (index) {
+				if (!c)
+					index--;
+				continue;
+			}
+			if (c && arg_len < CCS_EXEC_TMPSIZE - 10) {
+				if (c == '\\') {
+					arg_ptr[arg_len++] = '\\';
+					arg_ptr[arg_len++] = '\\';
+				} else if (c > ' ' && c < 127) {
+					arg_ptr[arg_len++] = c;
+				} else {
+					arg_ptr[arg_len++] = '\\';
+					arg_ptr[arg_len++] = (c >> 6) + '0';
+					arg_ptr[arg_len++] =
+						((c >> 3) & 7) + '0';
+					arg_ptr[arg_len++] = (c & 7) + '0';
+				}
+				continue;
+			}
+			arg_ptr[arg_len] = '\0';
+			arg.name = arg_ptr;
+			ccs_fill_path_info(&arg);
+			return ccs_path_matches_pattern(&arg, value) != is_not;
 		}
-		if (!result)
-			return false;
+		offset = 0;
 	}
-	return true;
 }
 
 /**
- * ccs_scan_bprm - Scan "struct linux_binprm".
+ * ccs_check_envp - Check envp[] in "struct linux_binbrm".
  *
- * @ee:   Pointer to "struct ccs_execve".
- * @argc: Length of @argc.
- * @argv: Pointer to "struct ccs_argv".
- * @envc: Length of @envp.
- * @envp: Poiner to "struct ccs_envp".
+ * @ee:     Pointer to "struct ccs_execve".
+ * @name:   Pointer to "struct ccs_path_info".
+ * @value:  Pointer to "struct ccs_path_info". Maybe NULL.
+ * @is_not: True if negative match, false othwerwise.
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_scan_bprm(struct ccs_execve *ee,
-			  const u16 argc, const struct ccs_argv *argv,
-			  const u16 envc, const struct ccs_envp *envp)
+static bool ccs_check_envp(struct ccs_execve *ee,
+			   const struct ccs_path_info *name,
+			   const struct ccs_path_info *value,
+			   const bool is_not)
 {
 	struct linux_binprm *bprm = ee->bprm;
 	struct ccs_page_dump *dump = &ee->dump;
@@ -3727,27 +3336,21 @@
 	int offset = pos % PAGE_SIZE;
 	int argv_count = bprm->argc;
 	int envp_count = bprm->envc;
-	bool result = true;
-	u8 local_checked[32];
-	u8 *checked;
-	if (argc + envc <= sizeof(local_checked)) {
-		checked = local_checked;
-		memset(local_checked, 0, sizeof(local_checked));
-	} else {
-		checked = kzalloc(argc + envc, CCS_GFP_FLAGS);
-		if (!checked)
+	bool result = !value == !is_not;
+	struct ccs_path_info n;
+	struct ccs_path_info v;
+	char *cp;
+	while (envp_count) {
+		if (!ccs_dump_page(bprm, pos, dump))
 			return false;
-	}
-	while (argv_count || envp_count) {
-		if (!ccs_dump_page(bprm, pos, dump)) {
-			result = false;
-			goto out;
-		}
 		pos += PAGE_SIZE - offset;
-		while (offset < PAGE_SIZE) {
-			/* Read. */
-			const char *kaddr = dump->data;
-			const unsigned char c = kaddr[offset++];
+		while (envp_count && offset < PAGE_SIZE) {
+			const unsigned char c = dump->data[offset++];
+			if (argv_count) {
+				if (!c)
+					argv_count--;
+				continue;
+			}
 			if (c && arg_len < CCS_EXEC_TMPSIZE - 10) {
 				if (c == '\\') {
 					arg_ptr[arg_len++] = '\\';
@@ -3766,83 +3369,35 @@
 			}
 			if (c)
 				continue;
-			/* Check. */
-			if (argv_count) {
-				if (!ccs_argv(bprm->argc - argv_count,
-					      arg_ptr, argc, argv,
-					      checked)) {
-					result = false;
-					break;
-				}
-				argv_count--;
-			} else if (envp_count) {
-				char *cp = strchr(arg_ptr, '=');
-				if (cp) {
-					*cp = '\0';
-					if (!ccs_envp(arg_ptr, cp + 1,
-						      envc, envp,
-						      checked + argc)) {
-						result = false;
-						break;
-					}
-				}
-				envp_count--;
-			} else {
-				break;
-			}
 			arg_len = 0;
-		}
-		offset = 0;
-		if (!result)
-			break;
-	}
-out:
-	if (result) {
-		int i;
-		/* Check not-yet-checked entries. */
-		for (i = 0; i < argc; i++) {
-			if (checked[i])
+			envp_count--;
+			/* Check. */
+			cp = strchr(arg_ptr, '=');
+			if (!cp)
 				continue;
-			/*
-			 * Return true only if all unchecked indexes in
-			 * bprm->argv[] are not matched.
-			 */
-			if (argv[i].is_not)
+			*cp++ = '\0';
+			n.name = arg_ptr;
+			ccs_fill_path_info(&n);
+			if (!ccs_path_matches_pattern(&n, name))
 				continue;
-			result = false;
-			break;
-		}
-		for (i = 0; i < envc; envp++, i++) {
-			if (checked[argc + i])
+			result = true;
+			if (!value) {
+				if (!is_not)
+					return false;
 				continue;
-			/*
-			 * Return true only if all unchecked environ variables
-			 * in bprm->envp[] are either undefined or not matched.
-			 */
-			if ((!envp->value && !envp->is_not) ||
-			    (envp->value && envp->is_not))
-				continue;
-			result = false;
-			break;
+			}
+			v.name = cp;
+			ccs_fill_path_info(&v);
+			if (ccs_path_matches_pattern(&v, value) != is_not)
+				return false;
 		}
+		offset = 0;
 	}
-	if (checked != local_checked)
-		kfree(checked);
 	return result;
 }
 
-/**
- * ccs_scan_exec_realpath - Check "exec.realpath" parameter of "struct ccs_condition".
- *
- * @file:  Pointer to "struct file".
- * @ptr:   Pointer to "struct ccs_name_union".
- * @match: True if "exec.realpath=", false if "exec.realpath!=".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_scan_exec_realpath(struct file *file,
-				   const struct ccs_name_union *ptr,
-				   const bool match)
+/*
+static bool ccs_scan_exec_realpath(struct file *file, const bool match)
 {
 	bool result;
 	struct ccs_path_info exe;
@@ -3861,10 +3416,10 @@
 	if (!exe.name)
 		return false;
 	ccs_fill_path_info(&exe);
-	result = ccs_compare_name_union(&exe, ptr);
 	kfree(exe.name);
 	return result == match;
 }
+*/
 
 /**
  * ccs_get_attributes - Revalidate "struct inode".
@@ -3918,11 +3473,255 @@
 			stat->rdev = inode->i_rdev;
 			obj->stat_valid[i] = true;
 		}
-		if (i & 1) /* i == CCS_PATH1_PARENT || i == CCS_PATH2_PARENT */
+		if (i & 1) /* parent directory */
 			dput(dentry);
 	}
 }
 
+enum ccs_arg_type {
+	CCS_ARG_TYPE_NUMBER,
+	CCS_ARG_TYPE_NAME,
+	CCS_ARG_TYPE_GROUP,
+	CCS_ARG_TYPE_BITOP,
+	CCS_ARG_TYPE_IPV6ADDR,
+} __packed;
+
+struct ccs_cond_arg {
+	enum ccs_arg_type type;
+	unsigned long value[2];
+	const struct ccs_path_info *name;
+	const struct ccs_group *group;
+	struct in6_addr ipv6[2];
+};
+
+static bool ccs_cond2arg(struct ccs_cond_arg *arg, const u8 cmd,
+			 const union ccs_condition_element **condp,
+			 struct ccs_request_info *r)
+{
+	struct ccs_mini_stat *stat;
+	unsigned long value;
+	struct ccs_obj_info *obj = r->obj;
+	const struct linux_binprm *bprm = r->ee ? r->ee->bprm : NULL;
+	const struct ccs_request_param *param = &r->param;
+	arg->type = CCS_ARG_TYPE_NUMBER;
+	switch (cmd) {
+	case CCS_TASK_UID:
+		value = current_uid();
+		break;
+	case CCS_TASK_EUID:
+		value = current_euid();
+		break;
+	case CCS_TASK_SUID:
+		value = current_suid();
+		break;
+	case CCS_TASK_FSUID:
+		value = current_fsuid();
+		break;
+	case CCS_TASK_GID:
+		value = current_gid();
+		break;
+	case CCS_TASK_EGID:
+		value = current_egid();
+		break;
+	case CCS_TASK_SGID:
+		value = current_sgid();
+		break;
+	case CCS_TASK_FSGID:
+		value = current_fsgid();
+		break;
+	case CCS_TASK_PID:
+		value = ccs_sys_getpid();
+		break;
+	case CCS_TASK_PPID:
+		value = ccs_sys_getppid();
+		break;
+	case CCS_TYPE_IS_SOCKET:
+		value = S_IFSOCK;
+		break;
+	case CCS_TYPE_IS_SYMLINK:
+		value = S_IFLNK;
+		break;
+	case CCS_TYPE_IS_FILE:
+		value = S_IFREG;
+		break;
+	case CCS_TYPE_IS_BLOCK_DEV:
+		value = S_IFBLK;
+		break;
+	case CCS_TYPE_IS_DIRECTORY:
+		value = S_IFDIR;
+		break;
+	case CCS_TYPE_IS_CHAR_DEV:
+		value = S_IFCHR;
+		break;
+	case CCS_TYPE_IS_FIFO:
+		value = S_IFIFO;
+		break;
+	case CCS_EXEC_ARGC:
+		if (!bprm)
+			return false;
+		value = bprm->argc;
+		break;
+	case CCS_EXEC_ENVC:
+		if (!bprm)
+			return false;
+		value = bprm->envc;
+		break;
+	case CCS_TASK_TYPE:
+		value = ((u8) ccs_current_flags()) &
+			CCS_TASK_IS_EXECUTE_HANDLER;
+		break;
+	case CCS_TASK_EXECUTE_HANDLER:
+		value = CCS_TASK_IS_EXECUTE_HANDLER;
+		break;
+	case CCS_IMM_NUMBER_ENTRY1:
+		value = (*condp)->value;
+		(*condp)++;
+		break;
+	case CCS_COND_NARG0:
+		value = param->i[0];
+		break;
+	case CCS_COND_NARG1:
+		value = param->i[1];
+		break;
+	case CCS_COND_NARG2:
+		value = param->i[2];
+		break;
+	default:
+		goto not_single_value;
+	}
+	arg->value[0] = value;
+	arg->value[1] = value;
+	return true;
+not_single_value:
+	if (cmd == CCS_IMM_NUMBER_ENTRY2) {
+		arg->value[0] = (*condp)->value;
+		(*condp)++;
+		arg->value[1] = (*condp)->value;
+		(*condp)++;
+		return true;
+	}
+	switch (cmd) {
+	case CCS_COND_SARG0:
+		arg->name = r->param.s[0];
+		break;
+	case CCS_COND_SARG1:
+		arg->name = r->param.s[1];
+		break;
+	case CCS_COND_SARG2:
+		arg->name = r->param.s[2];
+		break;
+	default:
+		goto not_single_name;
+	}
+	if (!arg->name)
+		return false;
+	arg->type = CCS_ARG_TYPE_NAME;
+	return true;
+not_single_name:
+	if (cmd == CCS_IMM_GROUP) {
+		arg->type = CCS_ARG_TYPE_GROUP;
+		arg->group = (*condp)->group;
+		(*condp)++;
+		return true;
+	}
+	switch (cmd) {
+	case CCS_MODE_SETUID:
+		value = S_ISUID;
+		break;
+	case CCS_MODE_SETGID:
+		value = S_ISGID;
+		break;
+	case CCS_MODE_STICKY:
+		value = S_ISVTX;
+		break;
+	case CCS_MODE_OWNER_READ:
+		value = S_IRUSR;
+		break;
+	case CCS_MODE_OWNER_WRITE:
+		value = S_IWUSR;
+		break;
+	case CCS_MODE_OWNER_EXECUTE:
+		value = S_IXUSR;
+		break;
+	case CCS_MODE_GROUP_READ:
+		value = S_IRGRP;
+		break;
+	case CCS_MODE_GROUP_WRITE:
+		value = S_IWGRP;
+		break;
+	case CCS_MODE_GROUP_EXECUTE:
+		value = S_IXGRP;
+		break;
+	case CCS_MODE_OTHERS_READ:
+		value = S_IROTH;
+		break;
+	case CCS_MODE_OTHERS_WRITE:
+		value = S_IWOTH;
+		break;
+	case CCS_MODE_OTHERS_EXECUTE:
+		value = S_IXOTH;
+		break;
+	default:
+		goto not_bitop;
+	}
+	arg->type = CCS_ARG_TYPE_BITOP;
+	arg->value[0] = value;
+	return true;
+not_bitop:
+	/*	
+	struct file *file = ee ? ee->bprm->file : NULL;
+	if (!ccs_scan_exec_realpath(file, ptr, match))
+	goto out;
+	*/
+	arg->type = CCS_ARG_TYPE_NUMBER;
+	if (!obj)
+		return false;
+	if (!obj->validate_done) {
+		ccs_get_attributes(obj);
+		obj->validate_done = true;
+	}
+	value = (cmd - CCS_PATH_ATTRIBUTE_START) >> 4;
+	if (value > 3)
+		return false;
+	stat = &obj->stat[value];
+	if (!stat)
+		return false;
+	switch ((cmd - CCS_PATH_ATTRIBUTE_START) & 0xF) {
+	case CCS_PATH_ATTRIBUTE_UID:
+		value = stat->uid;
+		break;
+	case CCS_PATH_ATTRIBUTE_GID:
+		value = stat->gid;
+		break;
+	case CCS_PATH_ATTRIBUTE_INO:
+		value = stat->ino;
+		break;
+	case CCS_PATH_ATTRIBUTE_MAJOR:
+		value = MAJOR(stat->dev);
+		break;
+	case CCS_PATH_ATTRIBUTE_MINOR:
+		value = MINOR(stat->dev);
+		break;
+	case CCS_PATH_ATTRIBUTE_TYPE:
+		value = stat->mode & S_IFMT;
+		break;
+	case CCS_PATH_ATTRIBUTE_DEV_MAJOR:
+		value = MAJOR(stat->rdev);
+		break;
+	case CCS_PATH_ATTRIBUTE_DEV_MINOR:
+		value = MINOR(stat->rdev);
+		break;
+	case CCS_PATH_ATTRIBUTE_PERM:
+		value = stat->mode & S_IALLUGO;
+		break;
+	default:
+		return false;
+	}
+	arg->value[0] = value;
+	arg->value[1] = value;
+	return true;
+}
+
 /**
  * ccs_condition - Check condition part.
  *
@@ -3936,345 +3735,122 @@
 bool ccs_condition(struct ccs_request_info *r,
 		   const struct ccs_condition *cond)
 {
-	const u32 ccs_flags = ccs_current_flags();
-	u32 i;
-	unsigned long min_v[2] = { 0, 0 };
-	unsigned long max_v[2] = { 0, 0 };
-	const struct ccs_condition_element *condp;
-	const struct ccs_number_union *numbers_p;
-	const struct ccs_name_union *names_p;
-	const struct ccs_argv *argv;
-	const struct ccs_envp *envp;
+	const union ccs_condition_element *condp;
 	struct ccs_obj_info *obj;
-	u16 condc;
-	u16 argc;
-	u16 envc;
-	struct linux_binprm *bprm = NULL;
+	struct linux_binprm *bprm;
 	if (!cond)
 		return true;
-	condc = cond->condc;
-	argc = cond->argc;
-	envc = cond->envc;
 	obj = r->obj;
-	if (r->ee)
-		bprm = r->ee->bprm;
-	if (!bprm && (argc || envc))
-		return false;
-	condp = (struct ccs_condition_element *) (cond + 1);
-	numbers_p = (const struct ccs_number_union *) (condp + condc);
-	names_p = (const struct ccs_name_union *)
-		(numbers_p + cond->numbers_count);
-	argv = (const struct ccs_argv *) (names_p + cond->names_count);
-	envp = (const struct ccs_envp *) (argv + argc);
-	for (i = 0; i < condc; i++) {
+	bprm = r->ee ? r->ee->bprm : NULL;
+	condp = (typeof(condp)) (cond + 1);
+	while ((void *) condp < (void *) ((u8 *) cond) + cond->size) {
+		struct ccs_cond_arg left;
+		struct ccs_cond_arg right;
+		const u8 left_op = condp->left;
+		const u8 right_op = condp->right;
 		const bool match = condp->equals;
-		const u8 left = condp->left;
-		const u8 right = condp->right;
-		bool is_bitop[2] = { false, false };
-		u8 j;
 		condp++;
-		/* Check argv[] and envp[] later. */
-		if (left == CCS_ARGV_ENTRY || left == CCS_ENVP_ENTRY)
-			continue;
-		/* Check string expressions. */
-		if (right == CCS_NAME_UNION) {
-			const struct ccs_name_union *ptr = names_p++;
-			if (left == CCS_EXEC_REALPATH) {
-				struct ccs_execve *ee = r->ee;
-				struct file *file = ee ? ee->bprm->file : NULL;
-				if (!ccs_scan_exec_realpath(file, ptr, match))
-					goto out;
+		if (!ccs_cond2arg(&left, left_op, &condp, r))
+			return false;
+		if (!ccs_cond2arg(&right, right_op, &condp, r))
+			return false;
+		if (left.type == CCS_ARG_TYPE_NUMBER) {
+			if (right.type == CCS_ARG_TYPE_NUMBER) {
+				if ((left.value[0] <= right.value[1] &&
+				     left.value[1] >= right.value[0]) == match)
+					continue;
+				return false;
 			}
-			continue;
-		}
-		/* Check numeric or bit-op expressions. */
-		for (j = 0; j < 2; j++) {
-			const u8 index = j ? right : left;
-			unsigned long value = 0;
-			switch (index) {
-			case CCS_TASK_UID:
-				value = current_uid();
-				break;
-			case CCS_TASK_EUID:
-				value = current_euid();
-				break;
-			case CCS_TASK_SUID:
-				value = current_suid();
-				break;
-			case CCS_TASK_FSUID:
-				value = current_fsuid();
-				break;
-			case CCS_TASK_GID:
-				value = current_gid();
-				break;
-			case CCS_TASK_EGID:
-				value = current_egid();
-				break;
-			case CCS_TASK_SGID:
-				value = current_sgid();
-				break;
-			case CCS_TASK_FSGID:
-				value = current_fsgid();
-				break;
-			case CCS_TASK_PID:
-				value = ccs_sys_getpid();
-				break;
-			case CCS_TASK_PPID:
-				value = ccs_sys_getppid();
-				break;
-			case CCS_TYPE_IS_SOCKET:
-				value = S_IFSOCK;
-				break;
-			case CCS_TYPE_IS_SYMLINK:
-				value = S_IFLNK;
-				break;
-			case CCS_TYPE_IS_FILE:
-				value = S_IFREG;
-				break;
-			case CCS_TYPE_IS_BLOCK_DEV:
-				value = S_IFBLK;
-				break;
-			case CCS_TYPE_IS_DIRECTORY:
-				value = S_IFDIR;
-				break;
-			case CCS_TYPE_IS_CHAR_DEV:
-				value = S_IFCHR;
-				break;
-			case CCS_TYPE_IS_FIFO:
-				value = S_IFIFO;
-				break;
-			case CCS_MODE_SETUID:
-				value = S_ISUID;
-				break;
-			case CCS_MODE_SETGID:
-				value = S_ISGID;
-				break;
-			case CCS_MODE_STICKY:
-				value = S_ISVTX;
-				break;
-			case CCS_MODE_OWNER_READ:
-				value = S_IRUSR;
-				break;
-			case CCS_MODE_OWNER_WRITE:
-				value = S_IWUSR;
-				break;
-			case CCS_MODE_OWNER_EXECUTE:
-				value = S_IXUSR;
-				break;
-			case CCS_MODE_GROUP_READ:
-				value = S_IRGRP;
-				break;
-			case CCS_MODE_GROUP_WRITE:
-				value = S_IWGRP;
-				break;
-			case CCS_MODE_GROUP_EXECUTE:
-				value = S_IXGRP;
-				break;
-			case CCS_MODE_OTHERS_READ:
-				value = S_IROTH;
-				break;
-			case CCS_MODE_OTHERS_WRITE:
-				value = S_IWOTH;
-				break;
-			case CCS_MODE_OTHERS_EXECUTE:
-				value = S_IXOTH;
-				break;
-			case CCS_EXEC_ARGC:
-				if (!bprm)
-					goto out;
-				value = bprm->argc;
-				break;
-			case CCS_EXEC_ENVC:
-				if (!bprm)
-					goto out;
-				value = bprm->envc;
-				break;
-			case CCS_TASK_TYPE:
-				value = ((u8) ccs_flags)
-					& CCS_TASK_IS_EXECUTE_HANDLER;
-				break;
-			case CCS_TASK_EXECUTE_HANDLER:
-				value = CCS_TASK_IS_EXECUTE_HANDLER;
-				break;
-			case CCS_NUMBER_UNION:
-				/* Fetch values later. */
-				break;
-			default:
-				if (!obj)
-					goto out;
-				if (!obj->validate_done) {
-					ccs_get_attributes(obj);
-					obj->validate_done = true;
-				}
-				{
-					u8 stat_index;
-					struct ccs_mini_stat *stat;
-					switch (index) {
-					case CCS_PATH1_UID:
-					case CCS_PATH1_GID:
-					case CCS_PATH1_INO:
-					case CCS_PATH1_MAJOR:
-					case CCS_PATH1_MINOR:
-					case CCS_PATH1_TYPE:
-					case CCS_PATH1_DEV_MAJOR:
-					case CCS_PATH1_DEV_MINOR:
-					case CCS_PATH1_PERM:
-						stat_index = CCS_PATH1;
-						break;
-					case CCS_PATH2_UID:
-					case CCS_PATH2_GID:
-					case CCS_PATH2_INO:
-					case CCS_PATH2_MAJOR:
-					case CCS_PATH2_MINOR:
-					case CCS_PATH2_TYPE:
-					case CCS_PATH2_DEV_MAJOR:
-					case CCS_PATH2_DEV_MINOR:
-					case CCS_PATH2_PERM:
-						stat_index = CCS_PATH2;
-						break;
-					case CCS_PATH1_PARENT_UID:
-					case CCS_PATH1_PARENT_GID:
-					case CCS_PATH1_PARENT_INO:
-					case CCS_PATH1_PARENT_PERM:
-						stat_index = CCS_PATH1_PARENT;
-						break;
-					case CCS_PATH2_PARENT_UID:
-					case CCS_PATH2_PARENT_GID:
-					case CCS_PATH2_PARENT_INO:
-					case CCS_PATH2_PARENT_PERM:
-						stat_index = CCS_PATH2_PARENT;
-						break;
-					default:
-						goto out;
-					}
-					if (!obj->stat_valid[stat_index])
-						goto out;
-					stat = &obj->stat[stat_index];
-					switch (index) {
-					case CCS_PATH1_UID:
-					case CCS_PATH2_UID:
-					case CCS_PATH1_PARENT_UID:
-					case CCS_PATH2_PARENT_UID:
-						value = stat->uid;
-						break;
-					case CCS_PATH1_GID:
-					case CCS_PATH2_GID:
-					case CCS_PATH1_PARENT_GID:
-					case CCS_PATH2_PARENT_GID:
-						value = stat->gid;
-						break;
-					case CCS_PATH1_INO:
-					case CCS_PATH2_INO:
-					case CCS_PATH1_PARENT_INO:
-					case CCS_PATH2_PARENT_INO:
-						value = stat->ino;
-						break;
-					case CCS_PATH1_MAJOR:
-					case CCS_PATH2_MAJOR:
-						value = MAJOR(stat->dev);
-						break;
-					case CCS_PATH1_MINOR:
-					case CCS_PATH2_MINOR:
-						value = MINOR(stat->dev);
-						break;
-					case CCS_PATH1_TYPE:
-					case CCS_PATH2_TYPE:
-						value = stat->mode & S_IFMT;
-						break;
-					case CCS_PATH1_DEV_MAJOR:
-					case CCS_PATH2_DEV_MAJOR:
-						value = MAJOR(stat->rdev);
-						break;
-					case CCS_PATH1_DEV_MINOR:
-					case CCS_PATH2_DEV_MINOR:
-						value = MINOR(stat->rdev);
-						break;
-					case CCS_PATH1_PERM:
-					case CCS_PATH2_PERM:
-					case CCS_PATH1_PARENT_PERM:
-					case CCS_PATH2_PARENT_PERM:
-						value = stat->mode & S_IALLUGO;
-						break;
-					}
-				}
-				break;
+			if (right.type == CCS_ARG_TYPE_GROUP) {
+				if (ccs_number_matches_group
+				    (left.value[0], left.value[1], right.group)
+				    == match)
+					continue;
+				return false;
 			}
-			max_v[j] = value;
-			min_v[j] = value;
-			switch (index) {
-			case CCS_MODE_SETUID:
-			case CCS_MODE_SETGID:
-			case CCS_MODE_STICKY:
-			case CCS_MODE_OWNER_READ:
-			case CCS_MODE_OWNER_WRITE:
-			case CCS_MODE_OWNER_EXECUTE:
-			case CCS_MODE_GROUP_READ:
-			case CCS_MODE_GROUP_WRITE:
-			case CCS_MODE_GROUP_EXECUTE:
-			case CCS_MODE_OTHERS_READ:
-			case CCS_MODE_OTHERS_WRITE:
-			case CCS_MODE_OTHERS_EXECUTE:
-				is_bitop[j] = true;
+			if (right.type == CCS_ARG_TYPE_BITOP) {
+				if (!(left.value[0] & right.value[0]) ==
+				    !match)
+					continue;
+				return false;
 			}
+			return false;
 		}
-		if (left == CCS_NUMBER_UNION) {
-			/* Fetch values now. */
-			const struct ccs_number_union *ptr = numbers_p++;
-			min_v[0] = ptr->values[0];
-			max_v[0] = ptr->values[1];
-		}
-		if (right == CCS_NUMBER_UNION) {
-			/* Fetch values now. */
-			const struct ccs_number_union *ptr = numbers_p++;
-			if (ptr->group) {
-				if ((ccs_number_matches_group(min_v[0],
-							      max_v[0],
-							      ptr->group)
-				     != ptr->is_not) == match)
+		if (left.type == CCS_ARG_TYPE_NAME) {
+			if (right.type == CCS_ARG_TYPE_NAME) {
+				if (ccs_path_matches_pattern
+				    (left.name, right.name) == match)
 					continue;
-			} else {
-				if ((min_v[0] <= ptr->values[1] &&
-				     max_v[0] >= ptr->values[0]) == match)
+				return false;
+			}
+			if (right.type == CCS_ARG_TYPE_GROUP) {
+				if (ccs_path_matches_group
+				    (left.name, right.group) == match)
 					continue;
+				return false;
 			}
-			goto out;
+			return false;
 		}
-		/*
-		 * Bit operation is valid only when counterpart value
-		 * represents permission.
-		 */
-		if (is_bitop[0] && is_bitop[1]) {
-			goto out;
-		} else if (is_bitop[0]) {
-			switch (right) {
-			case CCS_PATH1_PERM:
-			case CCS_PATH1_PARENT_PERM:
-			case CCS_PATH2_PERM:
-			case CCS_PATH2_PARENT_PERM:
-				if (!(max_v[0] & max_v[1]) == !match)
+		/* Check IPv6 address expressions. */
+		if (left.type == CCS_COND_IPV6) {
+			if (right.type == CCS_IMM_GROUP) {
+				if (ccs_address_matches_group
+				    (true, r->param.inet_address, right.group)
+				    == match)
 					continue;
+				return false;
 			}
-			goto out;
-		} else if (is_bitop[1]) {
-			switch (left) {
-			case CCS_PATH1_PERM:
-			case CCS_PATH1_PARENT_PERM:
-			case CCS_PATH2_PERM:
-			case CCS_PATH2_PARENT_PERM:
-				if (!(max_v[0] & max_v[1]) == !match)
+			if (right.type == CCS_IMM_IPV6ADDR_ENTRY1) {
+				if (!memcmp(&left.ipv6[0], &right.ipv6[0], 16)
+				    == !match)
 					continue;
+				return false;
 			}
-			goto out;
+			if (right.type == CCS_IMM_IPV6ADDR_ENTRY2) {
+				struct in6_addr *ip = &left.ipv6[0];
+				if ((memcmp(ip, &right.ipv6[0], 16) >= 0 &&
+				     memcmp(ip, &right.ipv6[1], 16) <= 0)
+				    == match)
+					continue;
+				return false;
+			}
+			return false;
 		}
-		/* Normal value range comparison. */
-		if ((min_v[0] <= max_v[1] && max_v[0] >= min_v[1]) == match)
+		if (!bprm)
+			return false;
+		//if (left == CCS_EXEC_REALPATH) {
+		//	struct file *file = r->ee->bprm->file;
+		//	const struct ccs_path_info *value;
+		//	value = condp->path;
+		//	condp++;
+		//	if (!ccs_scan_exec_realpath(file, ptr, match))
+		//		return false;
+		//	continue;
+		//}
+		if (left.type == CCS_ARGV_ENTRY) {
+			unsigned long index;
+			const struct ccs_path_info *value;
+			index = condp->value;
+			condp++;
+			value = condp->path;
+			condp++;
+			if (!ccs_check_argv(r->ee, index, value, !match))
+				return false;
 			continue;
-out:
+		}
+		if (left.type == CCS_ENVP_ENTRY) {
+			const struct ccs_path_info *name;
+			const struct ccs_path_info *value;
+			name = condp->path;
+			condp++;
+			value = condp->path;
+			condp++;
+			if (!ccs_check_envp(r->ee, name, value, !match))
+				return false;
+			continue;
+		}
 		return false;
 	}
-	/* Check argv[] and envp[] now. */
-	if (r->ee && (argc || envc))
-		return ccs_scan_bprm(r->ee, argc, argv, envc, envp);
 	return true;
 }
 
@@ -4314,7 +3890,7 @@
 	const int idx = ccs_read_lock();
 	for (i = 0; i < 255; i++) {
 		struct ccs_request_info r = { };
-		r.param_type = CCS_TYPE_AUTO_TASK_ACL;
+		//r.type = CCS_TYPE_AUTO_TASK_ACL;
 		ccs_check_acl(&r);
 		if (!r.granted)
 			goto done;
Index: gc.c
===================================================================
--- gc.c	(revision 5754)
+++ gc.c	(working copy)
@@ -43,7 +43,7 @@
 int ccs_lock(void);
 #endif
 void ccs_del_acl(struct list_head *element);
-void ccs_del_condition(struct list_head *element);
+void ccs_del_condition(struct ccs_condition *cond);
 void ccs_notify_gc(struct ccs_io_buffer *head, const bool is_register);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 void ccs_unlock(const int idx);
@@ -59,8 +59,8 @@
 static void ccs_collect_member(const enum ccs_policy_id id,
 			       struct list_head *member_list);
 static void ccs_memory_free(const void *ptr, const enum ccs_policy_id type);
-static void ccs_put_name_union(struct ccs_name_union *ptr);
-static void ccs_put_number_union(struct ccs_number_union *ptr);
+//static void ccs_put_ipaddr_union(struct ccs_ipaddr_union *ptr);
+//static void ccs_put_number_union(struct ccs_number_union *ptr);
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 static void ccs_synchronize_counter(void);
 #endif
@@ -111,32 +111,12 @@
 		[CCS_ID_PATH_GROUP] = sizeof(struct ccs_path_group),
 		[CCS_ID_NUMBER_GROUP] = sizeof(struct ccs_number_group),
 		[CCS_ID_MANAGER] = sizeof(struct ccs_manager),
-		/* [CCS_ID_CONDITION] = "struct ccs_condition"->size, */
 		/* [CCS_ID_NAME] = "struct ccs_name"->size, */
 		/* [CCS_ID_ACL] = a["struct ccs_acl_info"->type], */
 		[CCS_ID_DOMAIN] = sizeof(struct ccs_domain_info),
 	};
 	/* Size of a domain ACL element. */
 	static const u8 a[] = {
-		[CCS_TYPE_PATH_ACL] = sizeof(struct ccs_path_acl),
-		[CCS_TYPE_PATH2_ACL] = sizeof(struct ccs_path2_acl),
-		[CCS_TYPE_PATH_NUMBER_ACL]
-		= sizeof(struct ccs_path_number_acl),
-		[CCS_TYPE_MKDEV_ACL] = sizeof(struct ccs_mkdev_acl),
-		[CCS_TYPE_MOUNT_ACL] = sizeof(struct ccs_mount_acl),
-#ifdef CONFIG_CCSECURITY_NETWORK
-		[CCS_TYPE_INET_ACL] = sizeof(struct ccs_inet_acl),
-		[CCS_TYPE_UNIX_ACL] = sizeof(struct ccs_unix_acl),
-#endif
-#ifdef CONFIG_CCSECURITY_MISC
-		[CCS_TYPE_ENV_ACL] = sizeof(struct ccs_env_acl),
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-		[CCS_TYPE_CAPABILITY_ACL] = sizeof(struct ccs_capability_acl),
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-		[CCS_TYPE_PTRACE_ACL] = sizeof(struct ccs_ptrace_acl),
-#endif
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 		[CCS_TYPE_AUTO_EXECUTE_HANDLER]
 		= sizeof(struct ccs_handler_acl),
@@ -156,9 +136,6 @@
 	else if (type == CCS_ID_NAME)
 		size = container_of(ptr, typeof(struct ccs_name),
 				    head.list)->size;
-	else if (type == CCS_ID_CONDITION)
-		size = container_of(ptr, typeof(struct ccs_condition),
-				    head.list)->size;
 	else
 		size = e[type];
 	ccs_memory_used[CCS_MEMORY_POLICY] -= ccs_round2(size);
@@ -166,17 +143,16 @@
 }
 
 /**
- * ccs_put_name_union - Drop reference on "struct ccs_name_union".
+ * ccs_put_ipaddr_union - Drop reference on "struct ccs_ipaddr_union".
  *
- * @ptr: Pointer to "struct ccs_name_union".
+ * @ptr: Pointer to "struct ccs_ipaddr_union".
  *
  * Returns nothing.
  */
-static void ccs_put_name_union(struct ccs_name_union *ptr)
-{
-	ccs_put_group(ptr->group);
-	ccs_put_name(ptr->filename);
-}
+//static void ccs_put_ipaddr_union(struct ccs_ipaddr_union *ptr)
+//{
+//	ccs_put_group(ptr->group);
+//}
 
 /**
  * ccs_put_number_union - Drop reference on "struct ccs_number_union".
@@ -185,10 +161,10 @@
  *
  * Returns nothing.
  */
-static void ccs_put_number_union(struct ccs_number_union *ptr)
-{
-	ccs_put_group(ptr->group);
-}
+//static void ccs_put_number_union(struct ccs_number_union *ptr)
+//{
+//	ccs_put_group(ptr->group);
+//}
 
 /**
  * ccs_struct_used_by_io_buffer - Check whether the list element is used by /proc/ccs/ users or not.
@@ -346,94 +322,8 @@
 void ccs_del_acl(struct list_head *element)
 {
 	struct ccs_acl_info *acl = container_of(element, typeof(*acl), list);
-	ccs_put_condition(acl->cond);
+	ccs_del_condition(acl->cond);
 	switch (acl->type) {
-	case CCS_TYPE_PATH_ACL:
-		{
-			struct ccs_path_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->name);
-		}
-		break;
-	case CCS_TYPE_PATH2_ACL:
-		{
-			struct ccs_path2_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->name1);
-			ccs_put_name_union(&entry->name2);
-		}
-		break;
-	case CCS_TYPE_PATH_NUMBER_ACL:
-		{
-			struct ccs_path_number_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->name);
-			ccs_put_number_union(&entry->number);
-		}
-		break;
-	case CCS_TYPE_MKDEV_ACL:
-		{
-			struct ccs_mkdev_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->name);
-			ccs_put_number_union(&entry->mode);
-			ccs_put_number_union(&entry->major);
-			ccs_put_number_union(&entry->minor);
-		}
-		break;
-	case CCS_TYPE_MOUNT_ACL:
-		{
-			struct ccs_mount_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->dev_name);
-			ccs_put_name_union(&entry->dir_name);
-			ccs_put_name_union(&entry->fs_type);
-			ccs_put_number_union(&entry->flags);
-		}
-		break;
-#ifdef CONFIG_CCSECURITY_NETWORK
-	case CCS_TYPE_INET_ACL:
-		{
-			struct ccs_inet_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_group(entry->address.group);
-			ccs_put_number_union(&entry->port);
-		}
-		break;
-	case CCS_TYPE_UNIX_ACL:
-		{
-			struct ccs_unix_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->name);
-		}
-		break;
-#endif
-#ifdef CONFIG_CCSECURITY_MISC
-	case CCS_TYPE_ENV_ACL:
-		{
-			struct ccs_env_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_name_union(&entry->env);
-		}
-		break;
-#endif
-#ifdef CONFIG_CCSECURITY_CAPABILITY
-	case CCS_TYPE_CAPABILITY_ACL:
-		{
-			/* Nothing to do. */
-		}
-		break;
-#endif
-#ifdef CONFIG_CCSECURITY_IPC
-	case CCS_TYPE_PTRACE_ACL:
-		{
-			struct ccs_ptrace_acl *entry =
-				container_of(acl, typeof(*entry), head);
-			ccs_put_number_union(&entry->request);
-			ccs_put_name(entry->domainname);
-		}
-		break;
-#endif
 #ifdef CONFIG_CCSECURITY_TASK_EXECUTE_HANDLER
 	case CCS_TYPE_AUTO_EXECUTE_HANDLER:
 	case CCS_TYPE_DENIED_EXECUTE_HANDLER:
@@ -460,6 +350,9 @@
 				container_of(acl, typeof(*entry), head);
 			ccs_put_group(entry->group);
 		}
+		break;
+	default:
+		break;
 	}
 }
 
@@ -489,7 +382,7 @@
 	}
 	ccs_put_name(domain->default_transition);
 	ccs_put_name(domain->domainname);
-	ccs_put_condition(domain->cond);
+	ccs_del_condition(domain->cond);
 }
 
 /**
@@ -547,40 +440,14 @@
 /**
  * ccs_del_condition - Delete members in "struct ccs_condition".
  *
- * @element: Pointer to "struct list_head".
+ * @cond: Pointer to "struct ccs_condition".
  *
  * Returns nothing.
  */
-void ccs_del_condition(struct list_head *element)
+void ccs_del_condition(struct ccs_condition *cond)
 {
-	struct ccs_condition *cond = container_of(element, typeof(*cond),
-						  head.list);
-	const u16 condc = cond->condc;
-	const u16 numbers_count = cond->numbers_count;
-	const u16 names_count = cond->names_count;
-	const u16 argc = cond->argc;
-	const u16 envc = cond->envc;
-	unsigned int i;
-	const struct ccs_condition_element *condp
-		= (const struct ccs_condition_element *) (cond + 1);
-	struct ccs_number_union *numbers_p
-		= (struct ccs_number_union *) (condp + condc);
-	struct ccs_name_union *names_p
-		= (struct ccs_name_union *) (numbers_p + numbers_count);
-	const struct ccs_argv *argv
-		= (const struct ccs_argv *) (names_p + names_count);
-	const struct ccs_envp *envp
-		= (const struct ccs_envp *) (argv + argc);
-	for (i = 0; i < numbers_count; i++)
-		ccs_put_number_union(numbers_p++);
-	for (i = 0; i < names_count; i++)
-		ccs_put_name_union(names_p++);
-	for (i = 0; i < argc; argv++, i++)
-		ccs_put_name(argv->value);
-	for (i = 0; i < envc; envp++, i++) {
-		ccs_put_name(envp->name);
-		ccs_put_name(envp->value);
-	}
+	const union ccs_condition_element *condp = (typeof(condp)) (cond + 1);
+	/**/
 }
 
 /**
@@ -711,9 +578,6 @@
 	case CCS_ID_NUMBER_GROUP:
 		ccs_del_number_group(element);
 		break;
-	case CCS_ID_CONDITION:
-		ccs_del_condition(element);
-		break;
 	case CCS_ID_NAME:
 		/*
 		 * Don't kfree() until all "struct ccs_io_buffer"->r.w[] forget
@@ -863,16 +727,6 @@
 			ccs_try_to_gc(CCS_ID_ACL, &ptr->list);
 		}
 	}
-	{
-		struct ccs_shared_acl_head *ptr;
-		struct ccs_shared_acl_head *tmp;
-		list_for_each_entry_safe(ptr, tmp, &ccs_condition_list, list) {
-			if (atomic_read(&ptr->users) > 0)
-				continue;
-			atomic_set(&ptr->users, CCS_GC_IN_PROGRESS);
-			ccs_try_to_gc(CCS_ID_CONDITION, &ptr->list);
-		}
-	}
 	list_for_each_entry(ns, &ccs_namespace_list, namespace_list) {
 		for (i = 0; i < CCS_MAX_GROUP; i++) {
 			struct list_head *list = &ns->group_list[i];
