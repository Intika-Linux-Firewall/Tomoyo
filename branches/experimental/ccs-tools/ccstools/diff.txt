Index: usr_sbin/ccstools.h
===================================================================
--- usr_sbin/ccstools.h	(revision 5869)
+++ usr_sbin/ccstools.h	(working copy)
@@ -51,16 +51,11 @@
 
 /***** CONSTANTS DEFINITION START *****/
 
-#define CCS_PROC_POLICY_DIR              "/proc/ccs/"
-#define CCS_PROC_POLICY_DOMAIN_POLICY    "/proc/ccs/domain_policy"
-#define CCS_PROC_POLICY_ACL_POLICY       "/proc/ccs/acl_policy"
-#define CCS_PROC_POLICY_EXCEPTION_POLICY "/proc/ccs/exception_policy"
-#define CCS_PROC_POLICY_AUDIT            "/proc/ccs/audit"
-#define CCS_PROC_POLICY_MANAGER          "/proc/ccs/manager"
-#define CCS_PROC_POLICY_STAT             "/proc/ccs/stat"
-#define CCS_PROC_POLICY_PROCESS_STATUS   "/proc/ccs/.process_status"
-#define CCS_PROC_POLICY_PROFILE          "/proc/ccs/profile"
-#define CCS_PROC_POLICY_QUERY            "/proc/ccs/query"
+#define CCS_PROC_POLICY_DIR            "/proc/ccs/"
+#define CCS_PROC_POLICY_POLICY         "/proc/ccs/policy"
+#define CCS_PROC_POLICY_AUDIT          "/proc/ccs/audit"
+#define CCS_PROC_POLICY_PROCESS_STATUS "/proc/ccs/.process_status"
+#define CCS_PROC_POLICY_QUERY          "/proc/ccs/query"
 
 /***** CONSTANTS DEFINITION END *****/
 
@@ -90,8 +85,6 @@
 	const struct ccs_path_info *domainname;
 	const struct ccs_path_info **string_ptr;
 	int string_count;
-	u8 profile;
-	_Bool profile_assigned;
 };
 
 struct ccs_domain_policy {
@@ -105,7 +98,6 @@
 	pid_t ppid;
 	char *name;
 	char *domain;
-	u8 profile;
 	_Bool selected;
 	int index;
 	int depth;
Index: usr_sbin/ccs-diffpolicy.c
===================================================================
--- usr_sbin/ccs-diffpolicy.c	(revision 5869)
+++ usr_sbin/ccs-diffpolicy.c	(working copy)
@@ -68,9 +68,6 @@
 			continue;
 		/* This domain was added. */
 		printf("%s\n\n", domainname->name);
-		if (new_policy.list[new_index].profile_assigned)
-			printf("use_profile %u\n",
-			       new_policy.list[new_index].profile);
 		new_string_ptr = new_policy.list[new_index].string_ptr;
 		new_string_count = new_policy.list[new_index].string_count;
 		for (i = 0; i < new_string_count; i++)
@@ -112,15 +109,6 @@
 			first = false;
 			printf("delete %s\n", old_string_ptr[i]->name);
 		}
-		if (old_policy.list[old_index].profile !=
-		    new_policy.list[new_index].profile) {
-			if (first)
-				printf("%s\n\n", domainname->name);
-			first = false;
-			if (new_policy.list[new_index].profile_assigned)
-				printf("use_profile %u\n",
-				       new_policy.list[new_index].profile);
-		}
 		if (!first)
 			printf("\n");
 	}
Index: usr_sbin/ccs-loadpolicy.c
===================================================================
--- usr_sbin/ccs-loadpolicy.c	(revision 5869)
+++ usr_sbin/ccs-loadpolicy.c	(working copy)
@@ -45,169 +45,25 @@
 	return result;
 }
 
-static _Bool ccs_delete_proc_policy(const char *name)
-{
-	FILE *fp_in;
-	FILE *fp_out;
-	_Bool result = false;
-	if (ccs_network_mode) {
-		fp_in = ccs_open_read(name);
-		fp_out = ccs_open_write(name);
-	} else {
-		fp_in = fopen(name, "r");
-		fp_out = fopen(name, "w");
-	}
-	if (!fp_in || !fp_out) {
-		fprintf(stderr, "Can't open %s for reading and writing.\n",
-			name);
-		if (fp_in)
-			fclose(fp_in);
-		if (fp_out)
-			fclose(fp_out);
-		return false;
-	}
-	ccs_get();
-	while (true) {
-		char *line = ccs_freadline(fp_in);
-		if (!line)
-			break;
-		if (fprintf(fp_out, "delete %s\n", line) < 0)
-			result = false;
-	}
-	ccs_put();
-	if (fclose(fp_in))
-		result = false;
-	if (!ccs_close_write(fp_out))
-		result = false;
-	return result;
-}
-
-static _Bool ccs_update_domain_policy(struct ccs_domain_policy *proc_policy,
-				      struct ccs_domain_policy *file_policy,
-				      const char *src, const char *dest)
-{
-	int file_index;
-	int proc_index;
-	FILE *proc_fp;
-	_Bool result = true;
-	_Bool nm = ccs_network_mode;
-	/* Load disk policy to file_policy->list. */
-	ccs_network_mode = false;
-	ccs_read_domain_policy(file_policy, src);
-	ccs_network_mode = nm;
-	/* Load proc policy to proc_policy->list. */
-	ccs_read_domain_policy(proc_policy, dest);
-	proc_fp = ccs_open_write(dest);
-	if (!proc_fp) {
-		fprintf(stderr, "Can't open %s for writing.\n", dest);
-		return false;
-	}
-	for (file_index = 0; file_index < file_policy->list_len;
-	     file_index++) {
-		int i;
-		int j;
-		const struct ccs_path_info *domainname
-			= file_policy->list[file_index].domainname;
-		const struct ccs_path_info **file_string_ptr
-			= file_policy->list[file_index].string_ptr;
-		const int file_string_count
-			= file_policy->list[file_index].string_count;
-		const struct ccs_path_info **proc_string_ptr;
-		int proc_string_count;
-		proc_index = ccs_find_domain_by_ptr(proc_policy, domainname);
-		if (fprintf(proc_fp, "%s\n", domainname->name) < 0)
-			result = false;
-		if (proc_index == EOF)
-			goto not_found;
-
-		/* Proc policy for this domain found. */
-		proc_string_ptr = proc_policy->list[proc_index].string_ptr;
-		proc_string_count = proc_policy->list[proc_index].string_count;
-		for (j = 0; j < proc_string_count; j++) {
-			for (i = 0; i < file_string_count; i++) {
-				if (file_string_ptr[i] == proc_string_ptr[j])
-					break;
-			}
-			/* Delete this entry from proc policy if not found
-			   in disk policy. */
-			if (i == file_string_count)
-				if (fprintf(proc_fp, "delete %s\n",
-					    proc_string_ptr[j]->name) < 0)
-					result = false;
-		}
-		ccs_delete_domain(proc_policy, proc_index);
-not_found:
-		/* Append entries defined in disk policy. */
-		for (i = 0; i < file_string_count; i++)
-			if (fprintf(proc_fp, "%s\n", file_string_ptr[i]->name)
-			    < 0)
-				result = false;
-		if (file_policy->list[file_index].profile_assigned)
-			if (fprintf(proc_fp, "use_profile %u\n",
-				    file_policy->list[file_index].profile)
-			    < 0)
-				result = false;
-	}
-	/* Delete all domains that are not defined in disk policy. */
-	for (proc_index = 0; proc_index < proc_policy->list_len;
-	     proc_index++)
-		if (fprintf(proc_fp, "delete %s\n",
-			    proc_policy->list[proc_index].domainname->name)
-		    < 0)
-			result = false;
-	if (!ccs_close_write(proc_fp))
-		result = false;
-	return result;
-}
-
 int main(int argc, char *argv[])
 {
-	struct ccs_domain_policy proc_policy = { NULL, 0, NULL };
-	struct ccs_domain_policy file_policy = { NULL, 0, NULL };
-	_Bool refresh_policy = false;
-	_Bool result = true;
-	char target = 0;
 	int i;
 	for (i = 1; i < argc; i++) {
 		char *ptr = argv[i];
 		char *cp = strchr(ptr, ':');
-		if (cp) {
-			*cp++ = '\0';
-			ccs_network_ip = inet_addr(ptr);
-			ccs_network_port = htons(atoi(cp));
-			if (ccs_network_mode) {
-				fprintf(stderr, "You cannot specify multiple "
-					"%s at the same time.\n\n",
-					"remote agents");
-				goto usage;
-			}
-			ccs_network_mode = true;
-		} else {
-			if (target) {
-				fprintf(stderr, "You cannot specify multiple "
-					"%s at the same time.\n\n",
-					"policies");
-				goto usage;
-			}
-			if (*ptr++ != '-')
-				goto usage;
-			target = *ptr++;
-			if (target != 'e' && target != 'a' && target != 'd' &&
-			    target != 'p' && target != 'm' && target != 's')
-				goto usage;
-			if (*ptr) {
-				if ((target != 'e' && target != 'd') ||
-				    strcmp(ptr, "f"))
-					goto usage;
-				refresh_policy = true;
-			}
+		if (!cp)
+			goto usage;
+		*cp++ = '\0';
+		ccs_network_ip = inet_addr(ptr);
+		ccs_network_port = htons(atoi(cp));
+		if (ccs_network_mode) {
+			fprintf(stderr, "You cannot specify multiple "
+				"%s at the same time.\n\n",
+				"remote agents");
+			goto usage;
 		}
+		ccs_network_mode = true;
 	}
-	if (!target) {
-		fprintf(stderr, "You need to specify %s.\n\n",
-			"policy to load");
-		goto usage;
-	}
 	if (ccs_network_mode) {
 		if (!ccs_check_remote_host())
 			return 1;
@@ -216,58 +72,9 @@
 			"You can't run this program for this kernel.\n");
 		return 1;
 	}
-	switch (target) {
-	case 'p':
-		result = ccs_move_file_to_proc(CCS_PROC_POLICY_PROFILE);
-		break;
-	case 'm':
-		result = ccs_move_file_to_proc(CCS_PROC_POLICY_MANAGER);
-		break;
-	case 's':
-		result = ccs_move_file_to_proc(CCS_PROC_POLICY_STAT);
-		break;
-	case 'e':
-		if (refresh_policy)
-			result = ccs_delete_proc_policy
-				(CCS_PROC_POLICY_EXCEPTION_POLICY);
-		result = ccs_move_file_to_proc
-			(CCS_PROC_POLICY_EXCEPTION_POLICY);
-		break;
-	case 'a':
-		if (refresh_policy)
-			result = ccs_delete_proc_policy
-				(CCS_PROC_POLICY_ACL_POLICY);
-		result = ccs_move_file_to_proc(CCS_PROC_POLICY_ACL_POLICY);
-		break;
-	case 'd':
-		if (!refresh_policy) {
-			result = ccs_move_file_to_proc
-				(CCS_PROC_POLICY_DOMAIN_POLICY);
-			break;
-		}
-		result = ccs_update_domain_policy
-			(&proc_policy, &file_policy, NULL,
-			 CCS_PROC_POLICY_DOMAIN_POLICY);
-		ccs_clear_domain_policy(&proc_policy);
-		ccs_clear_domain_policy(&file_policy);
-		break;
-	}
-	return !result;
+	return !ccs_move_file_to_proc(CCS_PROC_POLICY_POLICY);
 usage:
-	printf("%s {-e|-ef|-a|-af|-d|-df|-m|-p|-s} [remote_ip:remote_port]\n\n"
-	       "-e  : Read from stdin and append to "
-	       "/proc/ccs/exception_policy .\n"
-	       "-ef : Read from stdin and overwrite "
-	       "/proc/ccs/exception_policy .\n"
-	       "-a  : Read from stdin and append to /proc/ccs/acl_policy .\n"
-	       "-af : Read from stdin and overwrite /proc/ccs/acl_policy .\n"
-	       "-d  : Read from stdin and append to /proc/ccs/domain_policy "
-	       ".\n"
-	       "-df : Read from stdin and overwrite /proc/ccs/domain_policy "
-	       ".\n"
-	       "-m  : Read from stdin and append to /proc/ccs/manager .\n"
-	       "-p  : Read from stdin and append to /proc/ccs/profile .\n"
-	       "-s  : Read from stdin and append to /proc/ccs/stat .\n"
+	printf("%s [remote_ip:remote_port]\n\n"
 	       "remote_ip:remote_port : Write to ccs-editpolicy-agent "
 	       "listening at remote_ip:remote_port rather than /proc/ccs/ "
 	       "directory.\n", argv[0]);
Index: usr_sbin/ccs-pstree.c
===================================================================
--- usr_sbin/ccs-pstree.c	(revision 5869)
+++ usr_sbin/ccs-pstree.c	(working copy)
@@ -29,7 +29,6 @@
 		int j;
 		if (pid != ccs_task_list[i].pid)
 			continue;
-		printf("%3d", ccs_task_list[i].profile);
 		for (j = 0; j < depth - 1; j++)
 			printf("    ");
 		for (; j < depth; j++)
@@ -85,8 +84,7 @@
 	for (i = 0; i < ccs_task_list_len; i++) {
 		if (ccs_task_list[i].selected)
 			continue;
-		printf("%3d %s (%u) %s\n",
-		       ccs_task_list[i].profile, ccs_task_list[i].name,
+		printf(" %s (%u) %s\n", ccs_task_list[i].name,
 		       ccs_task_list[i].pid, ccs_task_list[i].domain);
 		ccs_task_list[i].selected = true;
 	}
Index: usr_sbin/ccs-queryd.c
===================================================================
--- usr_sbin/ccs-queryd.c	(revision 5869)
+++ usr_sbin/ccs-queryd.c	(working copy)
@@ -66,8 +66,8 @@
 
 static unsigned short int ccs_retries = 0;
 
-static FILE *ccs_domain_fp = NULL;
-static int ccs_domain_policy_fd = EOF;
+static FILE *ccs_policy_fp = NULL;
+static int ccs_policy_fd = EOF;
 #define CCS_MAX_READLINE_HISTORY 20
 static const char **ccs_readline_history = NULL;
 static int ccs_readline_history_count = 0;
@@ -121,25 +121,24 @@
 
 	if (c == 'S' || c == 's') {
 		if (ccs_network_mode) {
-			fprintf(ccs_domain_fp, "%s", pidbuf);
-			fputc(0, ccs_domain_fp);
-			fflush(ccs_domain_fp);
-			rewind(ccs_domain_fp);
+			fprintf(ccs_policy_fp, "%s", pidbuf);
+			fputc(0, ccs_policy_fp);
+			fflush(ccs_policy_fp);
+			rewind(ccs_policy_fp);
 			while (1) {
 				char c;
-				if (fread(&c, 1, 1, ccs_domain_fp) != 1 || !c)
+				if (fread(&c, 1, 1, ccs_policy_fp) != 1 || !c)
 					break;
 				addch(c);
 				refresh();
 				ccs_send_keepalive();
 			}
 		} else {
-			ret_ignored = write(ccs_domain_policy_fd, pidbuf,
+			ret_ignored = write(ccs_policy_fd, pidbuf,
 					    strlen(pidbuf));
 			while (1) {
 				int i;
-				int len = read(ccs_domain_policy_fd,
-					       ccs_buffer,
+				int len = read(ccs_policy_fd, ccs_buffer,
 					       sizeof(ccs_buffer) - 1);
 				if (len <= 0)
 					break;
@@ -180,13 +179,12 @@
 				ccs_readline_history_count,
 				CCS_MAX_READLINE_HISTORY);
 	if (ccs_network_mode) {
-		fprintf(ccs_domain_fp, "%s%s\n", pidbuf, line);
-		fflush(ccs_domain_fp);
+		fprintf(ccs_policy_fp, "%s%s\n", pidbuf, line);
+		fflush(ccs_policy_fp);
 	} else {
-		ret_ignored = write(ccs_domain_policy_fd, pidbuf,
-				    strlen(pidbuf));
-		ret_ignored = write(ccs_domain_policy_fd, line, strlen(line));
-		ret_ignored = write(ccs_domain_policy_fd, "\n", 1);
+		ret_ignored = write(ccs_policy_fd, pidbuf, strlen(pidbuf));
+		ret_ignored = write(ccs_policy_fd, line, strlen(line));
+		ret_ignored = write(ccs_policy_fd, "\n", 1);
 	}
 	ccs_printw("Added '%s'.\n", line);
 not_append:
@@ -247,11 +245,10 @@
 ok:
 	if (ccs_network_mode) {
 		ccs_query_fd = ccs_open_stream("proc:query");
-		ccs_domain_fp = ccs_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
+		ccs_policy_fp = ccs_open_write(CCS_PROC_POLICY_POLICY);
 	} else {
 		ccs_query_fd = open(CCS_PROC_POLICY_QUERY, O_RDWR);
-		ccs_domain_policy_fd = open(CCS_PROC_POLICY_DOMAIN_POLICY,
-					    O_RDWR);
+		ccs_policy_fd = open(CCS_PROC_POLICY_POLICY, O_RDWR);
 	}
 	if (ccs_query_fd == EOF) {
 		fprintf(stderr,
@@ -259,7 +256,7 @@
 		return 1;
 	} else if (!ccs_network_mode && write(ccs_query_fd, "", 0) != 0) {
 		fprintf(stderr, "You need to register this program to %s to "
-			"run this program.\n", CCS_PROC_POLICY_MANAGER);
+			"run this program.\n", CCS_PROC_POLICY_POLICY);
 		return 1;
 	}
 	ccs_readline_history = ccs_malloc(CCS_MAX_READLINE_HISTORY *
Index: usr_sbin/ccs-setprofile.c
===================================================================
--- usr_sbin/ccs-setprofile.c	(revision 5869)
+++ usr_sbin/ccs-setprofile.c	(working copy)
@@ -1,107 +0,0 @@
-/*
- * ccs-setprofile.c
- *
- * TOMOYO Linux's utilities.
- *
- * Copyright (C) 2005-2011  NTT DATA CORPORATION
- *
- * Version: 1.8.3   2011/09/29
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License v2 as published by the
- * Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
- */
-#include "ccstools.h"
-
-int main(int argc, char *argv[])
-{
-	unsigned int profile = 0;
-	_Bool recursive = false;
-	int try;
-	int i;
-	int start = 2;
-	if (argc > 1 && !strcmp(argv[1], "-r")) {
-		recursive = true;
-		start = 3;
-	}
-	if (argc <= start || sscanf(argv[start - 1], "%u", &profile) != 1) {
-		fprintf(stderr,
-			"%s [-r] profile domainname [domainname ...]\n",
-			argv[0]);
-		return 0;
-	}
-	for (i = start; i < argc; i++)
-		ccs_normalize_line(argv[i]);
-	{
-		const int fd = open(CCS_PROC_POLICY_DOMAIN_POLICY, O_RDWR);
-		if (fd == EOF) {
-			fprintf(stderr, "You can't run this command for this "
-				"kernel.\n");
-			return 1;
-		} else if (write(fd, "", 0) != 0) {
-			fprintf(stderr, "You need to register this program to "
-				"%s to run this program.\n",
-				CCS_PROC_POLICY_MANAGER);
-			return 1;
-		}
-		close(fd);
-	}
-	for (try = 0; try < 2; try++) {
-		FILE *fp_in = fopen(CCS_PROC_POLICY_DOMAIN_POLICY, "r");
-		FILE *fp_out = fopen(CCS_PROC_POLICY_DOMAIN_POLICY, "w");
-		char *domainname = NULL;
-		if (!fp_in || !fp_out) {
-			fprintf(stderr, "Can't open policy file.\n");
-			exit(1);
-		}
-		ccs_get();
-		while (true) {
-			char *line = ccs_freadline(fp_in);
-			if (!line)
-				break;
-			if (domainname) {
-				if (sscanf(line, "use_profile %u", &profile)
-				    != 1)
-					continue;
-				printf("%u %s\n", profile, domainname);
-				free(domainname);
-				domainname = NULL;
-				continue;
-			}
-			if (*line != '<')
-				continue;
-			for (i = start; i < argc; i++) {
-				const int len = strlen(argv[i]);
-				if (strncmp(line, argv[i], len))
-					continue;
-				if (!recursive) {
-					if (line[len])
-						continue;
-				} else {
-					if (line[len] && line[len] != ' ')
-						continue;
-				}
-				if (try) {
-					domainname = ccs_strdup(line);
-					break;
-				}
-				fprintf(fp_out, "select %s\nuse_profile %u\n",
-					line, profile);
-				break;
-			}
-		}
-		ccs_put();
-		fclose(fp_in);
-		fclose(fp_out);
-	}
-	return 0;
-}
Index: usr_sbin/ccs-savepolicy.c
===================================================================
--- usr_sbin/ccs-savepolicy.c	(revision 5869)
+++ usr_sbin/ccs-savepolicy.c	(working copy)
@@ -65,23 +65,9 @@
 			return false;
 		}
 	}
-	if ((symlink("policy/current/profile.conf", "../profile.conf") &&
-	     errno != EEXIST) ||
-	    (symlink("policy/current/manager.conf", "../manager.conf") &&
-	     errno != EEXIST) ||
-	    (symlink("policy/current/exception_policy.conf",
-		     "../exception_policy.conf") && errno != EEXIST) ||
-	    (symlink("policy/current/domain_policy.conf",
-		     "../domain_policy.conf") && errno != EEXIST) ||
-	    chdir(stamp) ||
-	    !ccs_move_proc_to_file(CCS_PROC_POLICY_PROFILE, "profile.conf") ||
-	    !ccs_move_proc_to_file(CCS_PROC_POLICY_MANAGER, "manager.conf") ||
-	    !ccs_move_proc_to_file(CCS_PROC_POLICY_EXCEPTION_POLICY,
-				   "exception_policy.conf") ||
-	    !ccs_move_proc_to_file(CCS_PROC_POLICY_ACL_POLICY,
-				   "acl_policy.conf") ||
-	    !ccs_move_proc_to_file(CCS_PROC_POLICY_DOMAIN_POLICY,
-				   "domain_policy.conf") ||
+	if ((symlink("policy/current/policy.conf", "../policy.conf") &&
+	     errno != EEXIST) || chdir(stamp) ||
+	    !ccs_move_proc_to_file(CCS_PROC_POLICY_POLICY, "policy.conf") ||
 	    chdir("..") ||
 	    (rename("current", "previous") && errno != ENOENT) ||
 	    symlink(stamp, "current")) {
@@ -93,18 +79,14 @@
 
 int main(int argc, char *argv[])
 {
-	char target = 0;
+	_Bool use_stdout = false;
 	int i;
 	for (i = 1; i < argc; i++) {
 		char *ptr = argv[i];
 		char *cp = strchr(ptr, ':');
 		if (*ptr == '/') {
-			if (ccs_policy_dir || target) {
-				fprintf(stderr, "You cannot specify multiple "
-					"%s at the same time.\n\n",
-					"policy directories");
+			if (ccs_policy_dir || use_stdout)
 				goto usage;
-			}
 			ccs_policy_dir = ptr;
 		} else if (cp) {
 			*cp++ = '\0';
@@ -117,17 +99,10 @@
 				goto usage;
 			}
 			ccs_network_mode = true;
-		} else if (*ptr++ == '-' && !target) {
-			target = *ptr++;
-			if (target != 'e' && target != 'a' && target != 'd' &&
-			    target != 'p' && target != 'm' && target != 's')
+		} else if (*ptr++ == '-' && !*ptr) {
+			if (ccs_policy_dir || use_stdout)
 				goto usage;
-			if (*ptr || ccs_policy_dir) {
-				fprintf(stderr, "You cannot specify multiple "
-					"%s at the same time.\n\n",
-					"policies");
-				goto usage;
-			}
+			use_stdout = true;
 		} else
 			goto usage;
 	}
@@ -139,32 +114,10 @@
 			"You can't run this program for this kernel.\n");
 		return 1;
 	}
-	if (target) {
-		const char *file;
-		switch (target) {
-		case 'p':
-			file = CCS_PROC_POLICY_PROFILE;
-			break;
-		case 'm':
-			file = CCS_PROC_POLICY_MANAGER;
-			break;
-		case 'e':
-			file = CCS_PROC_POLICY_EXCEPTION_POLICY;
-			break;
-		case 'a':
-			file = CCS_PROC_POLICY_ACL_POLICY;
-			break;
-		case 'd':
-			file = CCS_PROC_POLICY_DOMAIN_POLICY;
-			break;
-		default:
-			file = CCS_PROC_POLICY_STAT;
-			break;
-		}
-		return !ccs_cat_file(file);
-	}
+	if (use_stdout)
+		return !ccs_cat_file(CCS_PROC_POLICY_POLICY);
 	if (!ccs_policy_dir) {
-		if (ccs_network_mode && !target) {
+		if (ccs_network_mode && !use_stdout) {
 			fprintf(stderr, "You need to specify %s.\n\n",
 				"policy directory");
 			goto usage;
@@ -178,18 +131,11 @@
 	}
 	return !ccs_save_policy();
 usage:
-	printf("%s [policy_dir [remote_ip:remote_port]]\n"
-	       "%s [{-e|-a|-d|-p|-m|-s} [remote_ip:remote_port]]\n\n"
+	printf("%s [policy_dir|-] [remote_ip:remote_port]]\n\n"
 	       "policy_dir : Use policy_dir rather than /etc/ccs/ directory.\n"
+	       "- : Print /proc/ccs/policy to stdout.\n"
 	       "remote_ip:remote_port : Read from ccs-editpolicy-agent "
 	       "listening at remote_ip:remote_port rather than /proc/ccs/ "
-	       "directory.\n"
-	       "-e : Print /proc/ccs/exception_policy to stdout.\n"
-	       "-a : Print /proc/ccs/acl_policy to stdout.\n"
-	       "-d : Print /proc/ccs/domain_policy to stdout.\n"
-	       "-p : Print /proc/ccs/profile to stdout.\n"
-	       "-m : Print /proc/ccs/manager to stdout.\n"
-	       "-s : Print /proc/ccs/stat to stdout.\n",
-	       argv[0], argv[0]);
+	       "directory.\n", argv[0]);
 	return 1;
 }
Index: usr_sbin/ccs-setlevel.c
===================================================================
--- usr_sbin/ccs-setlevel.c	(revision 5869)
+++ usr_sbin/ccs-setlevel.c	(working copy)
@@ -1,80 +0,0 @@
-/*
- * ccs-setlevel.c
- *
- * TOMOYO Linux's utilities.
- *
- * Copyright (C) 2005-2011  NTT DATA CORPORATION
- *
- * Version: 1.8.3   2011/09/29
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License v2 as published by the
- * Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
- */
-#include "ccstools.h"
-
-int main(int argc, char *argv[])
-{
-	const char *policy_file = CCS_PROC_POLICY_PROFILE;
-	int i;
-	int fd;
-	char c;
-	if (access(CCS_PROC_POLICY_DIR, F_OK)) {
-		fprintf(stderr, "You can't use this command for this "
-			"kernel.\n");
-		return 1;
-	}
-	fd = open(policy_file, O_RDWR);
-	if (fd == EOF) {
-		fprintf(stderr, "Can't open %s\n", policy_file);
-		return 1;
-	} else if (write(fd, "", 0) != 0) {
-		fprintf(stderr, "You need to register this program to %s to "
-			"run this program.\n", CCS_PROC_POLICY_MANAGER);
-		return 1;
-	}
-	if (argc == 1) {
-		printf("<<< Access Control Status >>>\n");
-		while (read(fd, &c, 1) == 1)
-			putchar(c);
-	} else {
-		FILE *fp = fdopen(fd, "r+");
-		if (!fp) {
-			fprintf(stderr, "Can't open %s\n", policy_file);
-			close(fd);
-			return 1;
-		}
-		for (i = 1; i < argc; i++) {
-			char *cp = strchr(argv[i], '=');
-			fprintf(fp, "%s\n", argv[i]);
-			if (cp)
-				*(cp + 1) = '\0';
-		}
-		fflush(fp);
-		ccs_get();
-		while (true) {
-			char *line = ccs_freadline(fp);
-			if (!line)
-				break;
-			for (i = 1; i < argc; i++) {
-				if (strncmp(line, argv[i], strlen(argv[i])))
-					continue;
-				printf("%s\n", line);
-				break;
-			}
-		}
-		ccs_put();
-		fclose(fp);
-	}
-	close(fd);
-	return 0;
-}
Index: usr_sbin/ccstools.c
===================================================================
--- usr_sbin/ccstools.c	(revision 5869)
+++ usr_sbin/ccstools.c	(working copy)
@@ -1417,7 +1417,7 @@
 /**
  * ccs_add_process_entry - Add entry for running processes.
  *
- * @line:    A line containing PID and profile and domainname.
+ * @line:    A line containing PID and domainname.
  * @ppid:    Parent PID.
  * @name:    Comm name (allocated by strdup()).
  *
@@ -1430,9 +1430,8 @@
 {
 	int index;
 	unsigned int pid = 0;
-	int profile = -1;
 	char *domain;
-	if (!line || sscanf(line, "%u %u", &pid, &profile) != 2) {
+	if (!line || sscanf(line, "%u", &pid) != 1) {
 		free(name);
 		return;
 	}
@@ -1447,7 +1446,6 @@
 	memset(&ccs_task_list[index], 0, sizeof(ccs_task_list[0]));
 	ccs_task_list[index].pid = pid;
 	ccs_task_list[index].ppid = ppid;
-	ccs_task_list[index].profile = profile;
 	ccs_task_list[index].name = name;
 	ccs_task_list[index].domain = domain;
 }
@@ -1823,14 +1821,7 @@
 		ret_ignored = write(fd, dp->list[i].domainname->name,
 				    dp->list[i].domainname->total_len);
 		ret_ignored = write(fd, "\n", 1);
-		if (dp->list[i].profile_assigned) {
-			char buf[128];
-			memset(buf, 0, sizeof(buf));
-			snprintf(buf, sizeof(buf) - 1, "use_profile %u\n\n",
-				 dp->list[i].profile);
-			ret_ignored = write(fd, buf, strlen(buf));
-		} else
-			ret_ignored = write(fd, "\n", 1);
+		ret_ignored = write(fd, "\n", 1);
 		for (j = 0; j < string_count; j++) {
 			ret_ignored = write(fd, string_ptr[j]->name,
 					    string_ptr[j]->total_len);
@@ -1961,7 +1952,6 @@
 		char *line = ccs_freadline_unpack(fp);
 		_Bool is_delete = false;
 		_Bool is_select = false;
-		unsigned int profile;
 		if (!line)
 			break;
 		if (ccs_str_starts(line, "delete "))
@@ -1986,10 +1976,7 @@
 		}
 		if (index == EOF || !line[0])
 			continue;
-		if (sscanf(line, "use_profile %u", &profile) == 1) {
-			dp->list[index].profile = (u8) profile;
-			dp->list[index].profile_assigned = 1;
-		} else if (is_delete)
+		if (is_delete)
 			ccs_del_string_entry(dp, line, index);
 		else
 			ccs_add_string_entry(dp, line, index);
@@ -2002,8 +1989,6 @@
 			= dp->list[i].string_ptr;
 		const int string_count = dp->list[i].string_count;
 		fprintf(fp, "%s\n", ccs_domain_name(dp, i));
-		if (dp->list[i].profile_assigned)
-			fprintf(fp, "use_profile %u\n", dp->list[i].profile);
 		fprintf(fp, "\n");
 		for (j = 0; j < string_count; j++)
 			fprintf(fp, "%s\n", string_ptr[j]->name);
Index: usr_sbin/ccs-domainmatch.c
===================================================================
--- usr_sbin/ccs-domainmatch.c	(revision 5869)
+++ usr_sbin/ccs-domainmatch.c	(working copy)
@@ -32,7 +32,7 @@
 		printf("%s string_to_find\n\n", argv[0]);
 		return 0;
 	}
-	fp = fopen(CCS_PROC_POLICY_DOMAIN_POLICY, "r");
+	fp = fopen(CCS_PROC_POLICY_POLICY, "r");
 	if (!fp) {
 		fprintf(stderr,
 			"You can't run this program for this kernel.\n");
Index: usr_sbin/Makefile
===================================================================
--- usr_sbin/Makefile	(revision 5869)
+++ usr_sbin/Makefile	(working copy)
@@ -1,9 +1,8 @@
 include ../Include.make
 
 BUILD_FILES := ccs-auditd ccs-checkpolicy ccs-diffpolicy ccs-domainmatch \
-	ccs-editpolicy ccs-findtemp ccs-loadpolicy ccs-notifyd ccs-patternize \
-	ccs-pstree ccs-queryd ccs-savepolicy ccs-selectpolicy ccs-setlevel \
-	ccs-setprofile ccs-sortpolicy
+	ccs-findtemp ccs-loadpolicy ccs-notifyd ccs-patternize ccs-pstree \
+	ccs-queryd ccs-savepolicy ccs-selectpolicy ccs-sortpolicy
 
 all: libccstools.so $(BUILD_FILES)
 
@@ -21,9 +20,6 @@
 .c:
 	$(CC) $(CFLAGS) -o $@ $< -lccstools -L. 
 
-ccs-editpolicy: ccstools.h editpolicy*.c readline.h /usr/include/curses.h libccstools.so editpolicy.h
-	$(CC) $(CFLAGS) -o ccs-editpolicy editpolicy*.c -lncurses -lccstools -L. -DCOLOR_ON
-
 ccs-queryd: ccstools.h ccs-queryd.c readline.h /usr/include/curses.h libccstools.so
 	$(CC) $(CFLAGS) -o ccs-queryd ccs-queryd.c -lncurses -lccstools -L.
 
Index: usr_lib_ccs/init_policy.c
===================================================================
--- usr_lib_ccs/init_policy.c	(revision 5869)
+++ usr_lib_ccs/init_policy.c	(working copy)
@@ -145,23 +145,6 @@
 }
 
 /**
- * scandir_symlink_and_dir_filter - Callback for scandir().
- *
- * @buf: Pointer to "const struct dirent".
- *
- * Returns non 0 if @buf seems to be a symlink or a directory, 0 otherwise.
- *
- * Since several kernels have a bug that leaves @buf->d_type == DT_UNKNOWN,
- * we allow it for now and recheck it later.
- */
-static int scandir_symlink_and_dir_filter(const struct dirent *buf)
-{
-	return (buf->d_type == DT_LNK || buf->d_type == DT_DIR ||
-		buf->d_type == DT_UNKNOWN) &&
-		strcmp(buf->d_name, ".") && strcmp(buf->d_name, "..");
-}
-
-/**
  * revalidate_path - Recheck file's attribute.
  *
  * @path: Pathname to check.
@@ -185,39 +168,20 @@
 	return type;
 }
 
-/* File handle to /etc/ccs/current/policy/exception_policy.conf . */
+/* File handle to /etc/ccs/policy/current/policy.conf . */
 static FILE *filp = NULL;
 
 /**
- * echo - Print a line to the policy file, without escaping.
+ * printf_encoded - Print a word to the policy file, with escaping as needed.
  *
- * @str: Line to print. Must follow TOMOYO's escape rules.
+ * @str: Word to print. Needn't to follow TOMOYO's escape rules.
  *
  * Returns nothing.
- */
-static inline void echo(const char *str)
-{
-	fprintf(filp, "%s\n", str);
-}
-
-/* Keyword before printing a line. */
-static const char *keyword = NULL;
-
-/**
- * printf_encoded - Print a line to the policy file, with escaping as needed.
  *
- * @str: Line to print. Needn't to follow TOMOYO's escape rules.
- *
- * Returns nothing.
- *
  * If @str starts with "/proc/", it is converted with "proc:/".
- * If keyword is not NULL, keyword is printed before printing @str.
  */
 static void printf_encoded(const char *str)
 {
-	const char *str0 = str;
-	if (keyword)
-		fprintf(filp, "%s ", keyword);
 	if (!strncmp(str, "/proc/", 6)) {
 		fprintf(filp, "proc:");
 		str += 5;
@@ -226,131 +190,29 @@
 		const char c = *str++;
 		if (!c)
 			break;
-		if (c == '\\') {
-			fputc('\\', filp);
-			fputc('\\', filp);
-		} else if (c > ' ' && c < 127) {
+		if (c > ' ' && c < 127 && c != '\\')
 			fputc(c, filp);
-		} else {
+		else
 			fprintf(filp, "\\%c%c%c", (c >> 6) + '0',
 				((c >> 3) & 7) + '0', (c & 7) + '0');
-		}
 	}
-	if (keyword && !strcmp(keyword, "default_transition")) {
-		str = str0;
-		fprintf(filp, " <kernel> ");
-		while (1) {
-			const char c = *str++;
-			if (!c)
-				break;
-			if (c == '\\') {
-				fputc('\\', filp);
-				fputc('\\', filp);
-			} else if (c > ' ' && c < 127) {
-				fputc(c, filp);
-			} else {
-				fprintf(filp, "\\%c%c%c", (c >> 6) + '0',
-					((c >> 3) & 7) + '0', (c & 7) + '0');
-			}
-		}
-	}
-	if (keyword)
-		fputc('\n', filp);
 }
 
-/* Shared buffer for scandir(). */
-static char path[8192];
-
-/**
- * scan_init_scripts - Scan /etc/rc\?.d/ directories for default_transition entries.
- *
- * Returns nothing.
- */
-static void scan_init_scripts(void)
+static void make_default_domain_transition(const char *path)
 {
-	struct dirent **namelist;
-	int n = scandir(path, &namelist, scandir_symlink_and_dir_filter, 0);
-	int len;
-	int i;
-	if (n < 0)
-		return;
-	len = strlen(path);
-	for (i = 0; i < n; i++) {
-		const char *name = namelist[i]->d_name;
-		unsigned char type = namelist[i]->d_type;
-		snprintf(path + len, sizeof(path) - len - 1, "/%s", name);
-		if (type == DT_UNKNOWN)
-			type = revalidate_path(path);
-		if (type == DT_DIR)
-			scan_init_scripts();
-		else if (type == DT_LNK
-			 && (name[0] == 'S' || name[0] == 'K')
-			 && (name[1] >= '0' && name[1] <= '9')
-			 && (name[2] >= '0' && name[2] <= '9')
-			 && !access(path, X_OK)) {
-			char *entity = get_realpath(path);
-			path[len] = '\0';
-			if (entity) {
-				char *cp = strrchr(path, '/');
-				fprintf(filp, "default_transition ");
-				/*
-				 * Use /rc\?.d/ rather than /rc0.d/ /rc1.d/
-				 * /rc2.d/ /rc3.d/ /rc4.d/ /rc5.d/ /rc6.d/
-				 * /rcS.d/ .
-				 */
-				if (cp && !strncmp(cp, "/rc", 3) &&
-				    ((cp[3] >= '0' && cp[3] <= '6') ||
-				     cp[3] == 'S') && !strcmp(cp + 4, ".d")) {
-					*cp = '\0';
-					printf_encoded(path);
-					fprintf(filp, "/rc\\?.d");
-					*cp = '/';
-				} else
-					printf_encoded(path);
-				fprintf(filp, "/\\?\\+\\+");
-				printf_encoded(name + 3);
-				fputc(' ', filp);
-				fprintf(filp, "<kernel> ");
-				printf_encoded(entity);
-				fputc('\n', filp);
-				free(entity);
-			}
-		}
-		free(namelist[i]);
-	}
-	free(namelist);
+	fprintf(filp, "10000 acl file execute path=\"");
+	printf_encoded(path);
+	fprintf(filp, "\" transition=\"");
+	printf_encoded(path);
+	fprintf(filp, "\"\n");
+	fprintf(filp, "    config mode=permissive grant_log=0 reject_log=0\n");
+	fprintf(filp, "\n");
 }
 
-/**
- * make_init_scripts_as_default_transitions - Use realpath for startup/shutdown scripts in /etc/ directory.
- *
- * Returns nothing.
- */
-static void make_init_scripts_as_default_transitions(void)
-{
-	/* Mark symlinks under /etc/rc\?.d/ directory as default_transition. */
-	static const char * const dirs[] = {
-		"/etc/boot.d", "/etc/rc.d/boot.d", "/etc/init.d/boot.d",
-		"/etc/rc0.d", "/etc/rd1.d", "/etc/rc2.d", "/etc/rc3.d",
-		"/etc/rc4.d", "/etc/rc5.d", "/etc/rc6.d", "/etc/rcS.d",
-		"/etc/rc.d/rc0.d", "/etc/rc.d/rc1.d", "/etc/rc.d/rc2.d",
-		"/etc/rc.d/rc3.d", "/etc/rc.d/rc4.d", "/etc/rc.d/rc5.d",
-		"/etc/rc.d/rc6.d",
-	};
-	int i;
-	keyword = NULL;
-	memset(path, 0, sizeof(path));
-	for (i = 0; i < elementof(dirs); i++) {
-		char *dir = get_realpath(dirs[i]);
-		if (!dir)
-			continue;
-		strncpy(path, dir, sizeof(path) - 1);
-		free(dir);
-		if (!strcmp(path, dirs[i]))
-			scan_init_scripts();
-	}
-}
 
+/* Shared buffer for scandir(). */
+static char path[8192];
+
 /**
  * scan_executable_files - Find executable files in the specific directory.
  *
@@ -372,14 +234,14 @@
 		if (type == DT_UNKNOWN)
 			type = revalidate_path(path);
 		if (type == DT_REG && !access(path, X_OK))
-			printf_encoded(path);
+			make_default_domain_transition(path);
 		free(namelist[i]);
 	}
 	free(namelist);
 }
 
 /**
- * scan_modprobe_and_hotplug - Mark modprobe and hotplug as default_transition entries.
+ * scan_modprobe_and_hotplug - Mark modprobe and hotplug as domain_transition entries.
  *
  * Returns nothing.
  */
@@ -408,156 +270,32 @@
 		if (!cp)
 			continue;
 		/* We ignore /bin/true if /proc/sys/kernel/modprobe said so. */
-		if (strcmp(cp, "/bin/true") && !access(cp, X_OK)) {
-			keyword = "default_transition";
-			printf_encoded(cp);
-		}
+		if (strcmp(cp, "/bin/true") && !access(cp, X_OK))
+			make_default_domain_transition(cp);
 		free(cp);
 	}
 }
 
 /**
- * make_globally_readable_files - Mark some files as globally readable.
+ * scan_init_dir - Mark programs under /etc/init.d/ directory as default domain transition entries.
  *
  * Returns nothing.
  */
-static void make_globally_readable_files(void)
+static void scan_init_dir(void)
 {
-	/* Allow reading some data files. */
-	static const char * const files[] = {
-		"/etc/ld.so.cache", "/proc/meminfo",
-		"/proc/sys/kernel/version", "/etc/localtime",
-		"/usr/lib/gconv/gconv-modules.cache",
-		"/usr/lib32/gconv/gconv-modules.cache",
-		"/usr/lib64/gconv/gconv-modules.cache",
-		"/usr/share/locale/locale.alias"
-	};
-	int i;
-	keyword = "acl_group GLOBALLY_GRANTED_PERMISSIONS file read";
-	for (i = 0; i < elementof(files); i++) {
-		char *cp = get_realpath(files[i]);
-		if (!cp)
-			continue;
-		printf_encoded(cp);
-		free(cp);
-	}
-}
-
-/**
- * make_self_readable_files - Mark /proc/self/ files as globally readable.
- *
- * Returns nothing.
- */
-static void make_self_readable_files(void)
-{
-	/* Allow reading information for current process. */
-	echo("acl_group GLOBALLY_GRANTED_PERMISSIONS file read "
-	     "proc:/self/\\*");
-	echo("acl_group GLOBALLY_GRANTED_PERMISSIONS file read "
-	     "proc:/self/\\{\\*\\}/\\*");
-}
-
-/**
- * make_ldconfig_readable_files - Mark shared library files as globally readable.
- *
- * Returns nothing.
- *
- * We don't scan predefined directories if ldconfig does not exist (e.g.
- * embedded environment).
- */
-static void make_ldconfig_readable_files(void)
-{
-	/* Allow reading DLL files registered with ldconfig(8). */
-	static const char * const dirs[] = {
-		"/lib/", "/lib/i486/", "/lib/i586/", "/lib/i686/",
-		"/lib/i686/cmov/", "/lib/tls/", "/lib/tls/i486/",
-		"/lib/tls/i586/", "/lib/tls/i686/", "/lib/tls/i686/cmov/",
-		"/lib/i686/nosegneg/", "/usr/lib/", "/usr/lib/i486/",
-		"/usr/lib/i586/", "/usr/lib/i686/", "/usr/lib/i686/cmov/",
-		"/usr/lib/tls/", "/usr/lib/tls/i486/", "/usr/lib/tls/i586/",
-		"/usr/lib/tls/i686/", "/usr/lib/tls/i686/cmov/",
-		"/usr/lib/sse2/", "/usr/X11R6/lib/", "/usr/lib32/",
-		"/usr/lib64/", "/lib64/", "/lib64/tls/",
-	};
-	int i;
-	FILE *fp = !access("/sbin/ldconfig", X_OK) ||
-		!access("/bin/ldconfig", X_OK)
-		? popen("ldconfig -NXp", "r") : NULL;
-	if (!fp)
-		return;
-	keyword = NULL;
-	for (i = 0; i < elementof(dirs); i++) {
-		char *cp = get_realpath(dirs[i]);
-		if (!cp)
-			continue;
-		fprintf(filp, "acl_group GLOBALLY_GRANTED_PERMISSIONS "
-			"file read ");
-		printf_encoded(cp);
-		fprintf(filp, "/lib\\*.so\\*\n");
-		free(cp);
-	}
-	while (memset(path, 0, sizeof(path)) &&
-	       fgets(path, sizeof(path) - 1, fp)) {
-		char *cp = strchr(path, '\n');
-		if (!cp)
-			break;
-		*cp = '\0';
-		cp = strstr(path, " => ");
-		if (!cp)
-			continue;
-		cp = get_realpath(cp + 4);
-		if (!cp)
-			continue;
-		for (i = 0; i < elementof(dirs); i++) {
-			const int len = strlen(dirs[i]);
-			if (!strncmp(cp, dirs[i], len) &&
-			    !strncmp(cp + len, "lib", 3) &&
-			    strstr(cp + len + 3, ".so"))
-				break;
-		}
-		if (i == elementof(dirs)) {
-			char *cp2 = strrchr(cp, '/');
-			const int len = strlen(cp);
-			char buf[16];
-			memset(buf, 0, sizeof(buf));
-			fprintf(filp, "acl_group GLOBALLY_GRANTED_PERMISSIONS "
-				"file read ");
-			if (cp2 && !strncmp(cp2, "/ld-2.", 6) &&
-			    len > 3 && !strcmp(cp + len - 3, ".so"))
-				*(cp2 + 6) = '\0';
-			else
-				cp2 = NULL;
-			printf_encoded(cp);
-			if (cp2)
-				fprintf(filp, "\\*.so");
-			fputc('\n', filp);
-		}
-		free(cp);
-	}
-	pclose(fp);
-}
-
-/**
- * make_init_dir_as_default_transitions - Mark programs under /etc/init.d/ directory as default_transition entries.
- *
- * Returns nothing.
- */
-static void make_init_dir_as_default_transitions(void)
-{
 	char *dir = get_realpath("/etc/init.d/");
 	if (!dir)
 		return;
-	keyword = "default_transition";
 	scan_executable_files(dir);
 	free(dir);
 }
 
 /**
- * make_daemons_as_default_transitions - Mark daemon programs as default_transition entries.
+ * scan_daemons - Mark daemon programs as default domain transition entries.
  *
  * Returns nothing.
  */
-static void make_daemons_as_default_transitions(void)
+static void scan_daemons(void)
 {
 	static const char * const files[] = {
 		"/sbin/cardmgr",
@@ -612,13 +350,12 @@
 		"/usr/sbin/xinetd"
 	};
 	int i;
-	keyword = "default_transition";
 	for (i = 0; i < elementof(files); i++) {
 		char *cp = get_realpath(files[i]);
 		if (!cp)
 			continue;
 		if (!access(cp, X_OK))
-			printf_encoded(cp);
+			make_default_domain_transition(cp);
 		free(cp);
 	}
 }
@@ -680,12 +417,7 @@
 		*(dir - 1) = '/';
 	}
 	if (mkdir2(policy_dir, 0700) || chdir(policy_dir) ||
-	    symlink2("policy/current/exception_policy.conf",
-		     "exception_policy.conf") ||
-	    symlink2("policy/current/domain_policy.conf",
-		     "domain_policy.conf") ||
-	    symlink2("policy/current/profile.conf", "profile.conf") ||
-	    symlink2("policy/current/manager.conf", "manager.conf") ||
+	    symlink2("policy/current/policy.conf", "policy.conf") ||
 	    mkdir2("policy", 0700) || chdir("policy") || mkdir2(stamp, 0700) ||
 	    symlink2(stamp, "previous") || symlink2(stamp, "current") ||
 	    chdir(policy_dir) || chdir("policy/current/")) {
@@ -708,48 +440,6 @@
 }
 
 /**
- * make_number_group - Make number_group entries.
- *
- * Returns nothing.
- */
-static void make_number_group(void)
-{
-	echo("number_group COMMON_IOCTL_CMDS 0x5401");
-}
-
-/**
- * make_ioctl - Allow ioctl with common ioctl numbers.
- *
- * Returns nothing.
- */
-static void make_ioctl(void)
-{
-	echo("acl_group GLOBALLY_GRANTED_PERMISSIONS file ioctl \\=any "
-	     "@COMMON_IOCTL_CMDS");
-}
-
-/**
- * make_getattr - Allow getting attributes.
- *
- * Returns nothing.
- */
-static void make_getattr(void)
-{
-	echo("acl_group GLOBALLY_GRANTED_PERMISSIONS file getattr \\=any");
-}
-
-/**
- * make_readdir - Allow reading directories.
- *
- * Returns nothing.
- */
-static void make_readdir(void)
-{
-	echo("acl_group GLOBALLY_GRANTED_PERMISSIONS file read \\=any "
-	     "path1.type=directory");
-}
-
-/**
  * chdir_policy - Change to policy directory.
  *
  * Returns 1 on success, 0 otherwise.
@@ -784,178 +474,42 @@
 }
 
 /**
- * make_exception_policy - Make /etc/ccs/policy/current/exception_policy.conf .
+ * make_policy - Make /etc/ccs/policy/current/policy.conf .
  *
  * Returns nothing.
  */
-static void make_exception_policy(void)
+static void make_policy(void)
 {
 	if (!chdir_policy())
 		return;
-	if (!access("exception_policy.conf", R_OK))
+	if (!access("policy.conf", R_OK))
 		return;
-	filp = fopen("exception_policy.tmp", "w");
+	filp = fopen("policy.tmp", "w");
 	if (!filp) {
-		fprintf(stderr, "ERROR: Can't create exception policy.\n");
+		fprintf(stderr, "ERROR: Can't create policy.\n");
 		return;
 	}
-	fprintf(stderr, "Creating exception policy... ");
-	make_globally_readable_files();
-	make_self_readable_files();
-	make_ldconfig_readable_files();
-	make_number_group();
-	make_ioctl();
-	make_readdir();
-	make_getattr();
+	fprintf(stderr, "Creating default policy... ");
+	fprintf(filp, "POLICY_VERSION=20100903\n");
+	fprintf(filp, "\n");
+	fprintf(filp, "memory quota audit 16777216\n");
+	fprintf(filp, "memory quota query 1048576\n");
+	fprintf(filp, "\n");
 	scan_modprobe_and_hotplug();
-	make_daemons_as_default_transitions();
-	make_init_dir_as_default_transitions();
-	make_init_scripts_as_default_transitions();
-	close_file(filp, chdir_policy(), "exception_policy.tmp",
-		   "exception_policy.conf");
+	scan_daemons();
+	scan_init_dir();
+	{
+		char *tools_dir = get_realpath("/usr/sbin");
+		fprintf(filp, "0 acl capability modify_policy\n"
+			"    config mode=enforcing grant_log=0 reject_log=0\n"
+			"    allow task.exe=\"%s/ccs-loadpolicy\"\n"
+			"    allow task.exe=\"%s/ccs-queryd\"\n\n", tools_dir,
+			tools_dir);
+	}
+	close_file(filp, chdir_policy(), "policy.tmp", "policy.conf");
 	filp = NULL;
 }
 
-/**
- * make_manager - Make /etc/ccs/policy/current/manager.conf .
- *
- * Returns nothing.
- */
-static void make_manager(void)
-{
-	char *tools_dir;
-	FILE *fp;
-	if (!chdir_policy())
-		return;
-	if (!access("manager.conf", R_OK))
-		return;
-	fp = fopen("manager.tmp", "w");
-	if (!fp) {
-		fprintf(stderr, "ERROR: Can't create manager policy.\n");
-		return;
-	}
-	fprintf(stderr, "Creating manager policy... ");
-	tools_dir = get_realpath("/usr/sbin");
-	fprintf(fp, "%s/ccs-loadpolicy\n", tools_dir);
-	fprintf(fp, "%s/ccs-editpolicy\n", tools_dir);
-	fprintf(fp, "%s/ccs-setlevel\n", tools_dir);
-	fprintf(fp, "%s/ccs-setprofile\n", tools_dir);
-	fprintf(fp, "%s/ccs-queryd\n", tools_dir);
-	close_file(fp, 1, "manager.tmp", "manager.conf");
-}
-
-/* Should we create profiles that restricts file only? */
-static _Bool file_only_profile = 0;
-/* Should we audit access granted logs? */
-static const char *grant_log = "no";
-/* Should we audit access rejected logs? */
-static const char *reject_log = "yes";
-/* How many audit log entries to spool in the kenrel memory? */
-static unsigned int max_audit_log = 1024;
-/* How many ACL entries to add automatically by learning mode? */
-static unsigned int max_learning_entry = 2048;
-/* How long should we carry sleep penalty? */
-static unsigned int enforcing_penalty = 0;
-
-/**
- * make_profile - Make /etc/ccs/policy/current/profile.conf .
- *
- * Returns nothing.
- */
-static void make_profile(void)
-{
-	static const char *file_only = "";
-	FILE *fp;
-	if (!chdir_policy())
-		return;
-	if (!access("profile.conf", R_OK))
-		return;
-	fp = fopen("profile.tmp", "w");
-	if (!fp) {
-		fprintf(stderr, "ERROR: Can't create profile policy.\n");
-		return;
-	}
-	fprintf(stderr, "Creating default profile... ");
-	if (file_only_profile)
-		file_only = "::file";
-	fprintf(fp, "PROFILE_VERSION=20100903\n");
-	fprintf(fp, "0-COMMENT=-----Disabled Mode-----\n"
-		"0-PREFERENCE={ max_audit_log=%u max_learning_entry=%u "
-		"enforcing_penalty=%u }\n"
-		"0-CONFIG%s={ mode=disabled grant_log=%s reject_log=%s }\n",
-		max_audit_log, max_learning_entry, enforcing_penalty,
-		file_only, grant_log, reject_log);
-	fprintf(fp, "1-COMMENT=-----Learning Mode-----\n"
-		"1-PREFERENCE={ max_audit_log=%u max_learning_entry=%u "
-		"enforcing_penalty=%u }\n"
-		"1-CONFIG%s={ mode=learning grant_log=%s reject_log=%s }\n",
-		max_audit_log, max_learning_entry, enforcing_penalty,
-		file_only, grant_log, reject_log);
-	fprintf(fp, "2-COMMENT=-----Permissive Mode-----\n"
-		"2-PREFERENCE={ max_audit_log=%u max_learning_entry=%u "
-		"enforcing_penalty=%u }\n"
-		"2-CONFIG%s={ mode=permissive grant_log=%s reject_log=%s }\n",
-		max_audit_log, max_learning_entry, enforcing_penalty,
-		file_only, grant_log, reject_log);
-	fprintf(fp, "3-COMMENT=-----Enforcing Mode-----\n"
-		"3-PREFERENCE={ max_audit_log=%u max_learning_entry=%u "
-		"enforcing_penalty=%u }\n"
-		"3-CONFIG%s={ mode=enforcing grant_log=%s reject_log=%s }\n",
-		max_audit_log, max_learning_entry, enforcing_penalty,
-		file_only, grant_log, reject_log);
-	close_file(fp, 1, "profile.tmp", "profile.conf");
-}
-
-/* Which profile number does <kernel> domain use? */
-static unsigned char default_profile = 0;
-
-/**
- * make_domain_policy - Make /etc/ccs/policy/current/domain_policy.conf .
- *
- * Returns nothing.
- */
-static void make_domain_policy(void)
-{
-	FILE *fp;
-	if (!chdir_policy())
-		return;
-	if (!access("domain_policy.conf", R_OK))
-		return;
-	fp = fopen("domain_policy.tmp", "w");
-	if (!fp) {
-		fprintf(stderr, "ERROR: Can't create domain policy.\n");
-		return;
-	}
-	fprintf(stderr, "Creating domain policy... ");
-	fprintf(fp, "<kernel>\nuse_profile %u\n"
-		"use_group \\=GLOBALLY_GRANTED_PERMISSIONS\n",
-		default_profile);
-	close_file(fp, 1, "domain_policy.tmp", "domain_policy.conf");
-}
-
-/**
- * make_stat - Make /etc/ccs/stat.conf .
- *
- * Returns nothing.
- */
-static void make_stat(void)
-{
-	FILE *fp;
-	if (chdir(policy_dir) || !access("stat.conf", R_OK))
-		return;
-	fp = fopen("stat.tmp", "w");
-	if (!fp) {
-		fprintf(stderr, "ERROR: Can't create stat policy.\n");
-		return;
-	}
-	fprintf(stderr, "Creating stat policy... ");
-	fprintf(fp, "# Memory quota (byte). 0 means no quota.\n");
-	fprintf(fp, "Memory used by policy:               0\n");
-	fprintf(fp, "Memory used by audit log:     16777216\n");
-	fprintf(fp, "Memory used by query message:  1048576\n");
-	close_file(fp, 1, "stat.tmp", "stat.conf");
-}
-
 /* The name of loadable kernel module to load. */
 static const char *module_name = "ccsecurity";
 
@@ -983,92 +537,6 @@
 		   "ccs-load-module.tmp", "ccs-load-module");
 }
 
-/* Content of /etc/ccs/tools/editpolicy.conf . */
-static const char editpolicy_data[] =
-"# This file contains configuration used by ccs-editpolicy command.\n"
-"\n"
-"# Keyword alias. ( directive-name = display-name )\n"
-"keyword_alias acl_group                     = acl_group\n"
-"keyword_alias address_group                 = address_group\n"
-"keyword_alias capability                    = capability\n"
-"keyword_alias default_transition            = default_transition\n"
-"keyword_alias file append                   = file append\n"
-"keyword_alias file chgrp                    = file chgrp\n"
-"keyword_alias file chmod                    = file chmod\n"
-"keyword_alias file chown                    = file chown\n"
-"keyword_alias file chroot                   = file chroot\n"
-"keyword_alias file create                   = file create\n"
-"keyword_alias file execute                  = file execute\n"
-"keyword_alias file getattr                  = file getattr\n"
-"keyword_alias file ioctl                    = file ioctl\n"
-"keyword_alias file link                     = file link\n"
-"keyword_alias file mkblock                  = file mkblock\n"
-"keyword_alias file mkchar                   = file mkchar\n"
-"keyword_alias file mkdir                    = file mkdir\n"
-"keyword_alias file mkfifo                   = file mkfifo\n"
-"keyword_alias file mksock                   = file mksock\n"
-"keyword_alias file mount                    = file mount\n"
-"keyword_alias file pivot_root               = file pivot_root\n"
-"keyword_alias file read                     = file read\n"
-"keyword_alias file rename                   = file rename\n"
-"keyword_alias file rmdir                    = file rmdir\n"
-"keyword_alias file symlink                  = file symlink\n"
-"keyword_alias file truncate                 = file truncate\n"
-"keyword_alias file unlink                   = file unlink\n"
-"keyword_alias file unmount                  = file unmount\n"
-"keyword_alias file write                    = file write\n"
-"keyword_alias ipc ptrace                    = ipc ptrace\n"
-"keyword_alias misc env                      = misc env\n"
-"keyword_alias network inet                  = network inet\n"
-"keyword_alias network unix                  = network unix\n"
-"keyword_alias number_group                  = number_group\n"
-"keyword_alias path_group                    = path_group\n"
-"keyword_alias quota_exceeded                = quota_exceeded\n"
-"keyword_alias task auto_domain_transition   = task auto_domain_transition\n"
-"keyword_alias task auto_execute_handler     = task auto_execute_handler\n"
-"keyword_alias task denied_execute_handler   = task denied_execute_handler\n"
-"keyword_alias task manual_domain_transition = task manual_domain_transition\n"
-"keyword_alias use_group                     = use_group\n"
-"keyword_alias use_profile                   = use_profile\n"
-"\n"
-"# Line color. 0 = BLACK, 1 = RED, 2 = GREEN, 3 = YELLOW, 4 = BLUE, "
-"5 = MAGENTA, 6 = CYAN, 7 = WHITE\n"
-"line_color ACL_CURSOR       = 03\n"
-"line_color ACL_HEAD         = 03\n"
-"line_color DOMAIN_CURSOR    = 02\n"
-"line_color DOMAIN_HEAD      = 02\n"
-"line_color EXCEPTION_CURSOR = 06\n"
-"line_color EXCEPTION_HEAD   = 06\n"
-"line_color MANAGER_CURSOR   = 72\n"
-"line_color MANAGER_HEAD     = 72\n"
-"line_color STAT_CURSOR      = 03\n"
-"line_color STAT_HEAD        = 03\n"
-"line_color PROFILE_CURSOR   = 71\n"
-"line_color PROFILE_HEAD     = 71\n"
-"line_color DEFAULT_COLOR    = 70\n";
-
-/**
- * make_editpolicy_conf - Make /etc/ccs/tools/editpolicy.conf .
- *
- * Returns nothing.
- */
-static void make_editpolicy_conf(void)
-{
-	FILE *fp;
-	if (chdir(policy_dir) || chdir("tools") ||
-	    !access("editpolicy.conf", R_OK))
-		return;
-	fp = fopen("editpolicy.tmp", "w");
-	if (!fp) {
-		fprintf(stderr, "ERROR: Can't create configuration file.\n");
-		return;
-	}
-	fprintf(stderr, "Creating configuration file for ccs-editpolicy ... ");
-	fprintf(fp, "%s", editpolicy_data);
-	close_file(fp, !chmod("editpolicy.tmp", 0644), "editpolicy.tmp",
-		   "editpolicy.conf");
-}
-
 /* Content of /etc/ccs/tools/auditd.conf . */
 static const char auditd_data[] =
 "# This file contains sorting rules used by ccs-auditd command.\n"
@@ -1097,13 +565,13 @@
 "# More specific matches should be placed before less specific matches.\n"
 "# For example:\n"
 "#\n"
-"# header.contains profile=3\n"
+"# header.contains mode=enforcing\n"
 "# domain.contains /usr/sbin/httpd\n"
-"# destination     /var/log/tomoyo/reject_003_httpd.log\n"
+"# destination     /var/log/tomoyo/reject_enforcing_httpd.log\n"
 "#\n"
 "# This chunk should be placed before the chunk that matches logs with\n"
-"# profile=3. If placed after, the audit logs for /usr/sbin/httpd will be\n"
-"# sent to /var/log/tomoyo/reject_003.log .\n"
+"# mode=enforcing. If placed after, the audit logs for /usr/sbin/httpd will "
+"# be sent to /var/log/tomoyo/reject_enforcing.log .\n"
 "\n"
 "# Please use TOMOYO Linux's escape rule (e.g. '\\040' rather than '\\ ' for\n"
 "# representing a ' ' in a word).\n"
@@ -1112,38 +580,17 @@
 "header.contains granted=yes\n"
 "destination     /dev/null\n"
 "\n"
-"# Save rejected logs with profile=acl mode=learning to\n"
-"# /var/log/tomoyo/reject_learning_acl.log\n"
-"header.contains profile=acl\n"
-"header.contains mode=learning\n"
-"destination     /var/log/tomoyo/reject_learning_acl.log\n"
-"# Save rejected logs with profile=acl mode=permissive to\n"
-"# /var/log/tomoyo/reject_permissive_acl.log\n"
-"header.contains profile=acl\n"
+"# Save rejected logs with mode=disabled to /var/log/tomoyo/reject_disabled.log\n"
+"header.contains mode=disabled\n"
+"destination     /var/log/tomoyo/reject_disabled.log\n"
+"\n"
+"# Save rejected logs with mode=permissive to /var/log/tomoyo/reject_permissive.log\n"
 "header.contains mode=permissive\n"
-"destination     /var/log/tomoyo/reject_permissive_acl.log\n"
+"destination     /var/log/tomoyo/reject_permissive.log\n"
 "\n"
-"# Save rejected logs with profile=acl mode=enforcing to\n"
-"# /var/log/tomoyo/reject_acl.log\n"
-"header.contains profile=acl\n"
+"# Save rejected logs with mode=enforcing to /var/log/tomoyo/reject_enforcing.log\n"
 "header.contains mode=enforcing\n"
-"destination     /var/log/tomoyo/reject_enforcing_acl.log\n"
-"\n"
-"# Save rejected logs with profile=0 to /var/log/tomoyo/reject_000.log\n"
-"header.contains profile=0\n"
-"destination     /var/log/tomoyo/reject_000.log\n"
-"\n"
-"# Save rejected logs with profile=1 to /var/log/tomoyo/reject_001.log\n"
-"header.contains profile=1\n"
-"destination     /var/log/tomoyo/reject_001.log\n"
-"\n"
-"# Save rejected logs with profile=2 to /var/log/tomoyo/reject_002.log\n"
-"header.contains profile=2\n"
-"destination     /var/log/tomoyo/reject_002.log\n"
-"\n"
-"# Save rejected logs with profile=3 to /var/log/tomoyo/reject_003.log\n"
-"header.contains profile=3\n"
-"destination     /var/log/tomoyo/reject_003.log\n"
+"destination     /var/log/tomoyo/reject_enforcing.log\n"
 "\n";
 
 /**
@@ -1228,10 +675,7 @@
 "\n"
 "# Files on / partition.\n"
 "rewrite tail_pattern /etc/mtab~\\$\n"
-"rewrite tail_pattern /etc/ccs/policy/\\*/domain_policy.conf\n"
-"rewrite tail_pattern /etc/ccs/policy/\\*/exception_policy.conf\n"
-"rewrite tail_pattern /etc/ccs/policy/\\*/manager.conf\n"
-"rewrite tail_pattern /etc/ccs/policy/\\*/profile.conf\n"
+"rewrite tail_pattern /etc/ccs/policy/\\*/policy.conf\n"
 "rewrite tail_pattern /etc/ccs/policy/\\*/\n"
 "\n"
 "# Files on /tmp/ partition.\n"
@@ -1300,7 +744,7 @@
 "# 30, you will be given 30 seconds for starting ccs-queryd command and\n"
 "# responding to the policy violation event.\n"
 "# If you specify non 0 value, you need to register ccs-notifyd command to\n"
-"# /proc/ccs/manager as well as ccs-queryd command, for ccs-notifyd needs to\n"
+"# /proc/ccs/policy as well as ccs-queryd command, for ccs-notifyd needs to\n"
 "# behave as if ccs-queryd command is running.\n"
 "# Also, you should avoid specifying too large value (e.g. 3600) because\n"
 "# the request will remain pending for that period if you can't respond.\n"
@@ -1381,23 +825,9 @@
 			}
 		} else if (!strncmp(arg, "policy_dir=", 11)) {
 			dir = arg + 11;
-		} else if (!strcmp(arg, "file-only-profile")) {
-			file_only_profile = 1;
-		} else if (!strcmp(arg, "full-profile")) {
-			file_only_profile = 0;
 		} else if (!strncmp(arg, "module_name=", 12)) {
 			module_name = arg + 12;
-		} else if (!strncmp(arg, "use_profile=", 12)) {
-			default_profile = atoi(arg + 12);
-		} else if (!strncmp(arg, "grant_log=", 10)) {
-			grant_log = arg + 10;
-		} else if (!strncmp(arg, "reject_log=", 11)) {
-			reject_log = arg + 11;
-		} else if (!sscanf(arg, "max_audit_log=%u", &max_audit_log) &&
-			   !sscanf(arg, "max_learning_entry=%u",
-				   &max_learning_entry) &&
-			   !sscanf(arg, "enforcing_penalty=%u",
-				   &enforcing_penalty)) {
+		} else {
 			fprintf(stderr, "Unknown option: '%s'\n", argv[i]);
 			return 1;
 		}
@@ -1407,13 +837,8 @@
 	policy_dir = strdup(dir);
 	memset(path, 0, sizeof(path));
 	make_policy_dir();
-	make_exception_policy();
-	make_domain_policy();
-	make_manager();
-	make_profile();
-	make_stat();
+	make_policy();
 	make_module_loader();
-	make_editpolicy_conf();
 	make_auditd_conf();
 	make_patternize_conf();
 	make_notifyd_conf();
Index: usr_lib_ccs/Makefile
===================================================================
--- usr_lib_ccs/Makefile	(revision 5869)
+++ usr_lib_ccs/Makefile	(working copy)
@@ -1,7 +1,6 @@
 include ../Include.make
 
-BUILD_FILES = audit-exec-param ccs-editpolicy-agent convert-audit-log \
-	convert-exec-param init_policy
+BUILD_FILES = audit-exec-param ccs-editpolicy-agent init_policy
 
 all: $(BUILD_FILES)
 
Index: sbin/ccs-init.c
===================================================================
--- sbin/ccs-init.c	(revision 5869)
+++ sbin/ccs-init.c	(working copy)
@@ -48,13 +48,8 @@
 		sleep(100);
 }
 
-#define policy_dir            "/etc/ccs/"
-#define proc_manager          "/proc/ccs/manager"
-#define proc_acl_policy       "/proc/ccs/acl_policy"
-#define proc_exception_policy "/proc/ccs/exception_policy"
-#define proc_domain_policy    "/proc/ccs/domain_policy"
-#define proc_profile          "/proc/ccs/profile"
-#define proc_stat             "/proc/ccs/stat"
+#define policy_dir  "/etc/ccs/"
+#define proc_policy "/proc/ccs/policy"
 static _Bool proc_unmount = 0;
 
 static char buffer[8192];
@@ -82,44 +77,27 @@
 	close(dfd);
 }
 
-static void show_domain_usage(void)
+static void show_stat(void)
 {
-	unsigned int domain = 0;
 	unsigned int acl = 0;
-	FILE *fp = fopen(proc_domain_policy, "r");
+	unsigned int size = -1;
+	FILE *fp = fopen(proc_policy, "r");
 	if (!fp)
 		return;
 	while (memset(buffer, 0, sizeof(buffer)) &&
 	       fgets(buffer, sizeof(buffer) - 1, fp)) {
-		if (buffer[0] == '<')
-			domain++;
-		else if (buffer[0] > ' ' && strncmp(buffer, "use_", 4))
+		if (!strncmp(buffer, "acl ", 4))
 			acl++;
+		else if (size == -1)
+			sscanf(buffer, "stat Memory used by policy: %u",
+			       &size);
 	}
 	fclose(fp);
-	printf("%u domain%s. %u ACL entr%s.\n", domain, domain > 1 ? "s" : "",
-	       acl, acl > 1 ? "ies" : "y");
+	printf("%u ACL entr%s.\n", acl, acl > 1 ? "ies" : "y");
+	if (size != -1)
+		printf("%u KB used by policy.\n", (size + 1023) / 1024);
 }
 
-static void show_memory_usage(void)
-{
-	FILE *fp = fopen(proc_stat, "r");
-	if (!fp)
-		return;
-	while (memset(buffer, 0, sizeof(buffer)) &&
-	       fgets(buffer, sizeof(buffer) - 1, fp)) {
-		unsigned int size;
-		if (sscanf(buffer, "Shared: %u", &size) == 1)
-			printf("%u KB shared. ", (size + 1023) / 1024);
-		else if (sscanf(buffer, "Private: %u", &size) == 1)
-			printf("%u KB private. ", (size + 1023) / 1024);
-		else if (sscanf(buffer, "Policy: %u", &size) == 1)
-			printf("%u KB used by policy.", (size + 1023) / 1024);
-	}
-	fclose(fp);
-	putchar('\n');
-}
-
 int main(int argc, char *argv[])
 {
 	struct stat buf;
@@ -187,14 +165,8 @@
 	}
 
 	/* Load policy. */
-	if (!chdir(policy_dir)) {
-		copy_files("manager.conf", proc_manager);
-		copy_files("acl_policy.conf", proc_acl_policy);
-		copy_files("exception_policy.conf", proc_exception_policy);
-		copy_files("domain_policy.conf", proc_domain_policy);
-		copy_files("profile.conf", proc_profile);
-		copy_files("stat.conf", proc_stat);
-	}
+	if (!chdir(policy_dir))
+		copy_files("policy.conf", proc_policy);
 
 	/* Do additional initialization. */
 	if (!access("/etc/ccs/ccs-post-init", X_OK)) {
@@ -211,11 +183,8 @@
 		       errno == EINTR);
 	}
 
-	show_domain_usage();
+	show_stat();
 
-	/* Show memory usage. */
-	show_memory_usage();
-
 	if (proc_unmount)
 		umount("/proc");
 
