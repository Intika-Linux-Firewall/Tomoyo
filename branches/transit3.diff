Index: README.ccs
===================================================================
--- README.ccs	(revision 3433)
+++ README.ccs	(working copy)
@@ -2326,3 +2326,32 @@
 
       Since 1.6.7 , /proc/ccs/grant_log was by error using next domain's name
       when auditing current domain's "execute_handler" line.
+
+Fix 2010/02/03
+
+    @ Allow domain transition without execve().
+
+      To be able to split permissions for Apache's CGI programs which are
+      executed without execve(), I added special domain transition which is
+      performed by atomically writing '\0'-terminated binary string to
+      /proc/ccs/.transition interface. For example, a process which belongs to
+      "<kernel> /usr/sbin/httpd" domain will transit to
+      "<kernel> /usr/sbin/httpd //app=cgi1\040id=10000" domain by atomically
+      writing "app=cgi1 id=10000" + '\0' to /proc/ccs/.transition using
+      Apache's ap_hook_handler() functionality.
+
+      Note that '\0'-terminated binary string is converted to TOMOYO's string
+      inside kernel and prefix "//" is automatically added to the string so
+      that domainname does not confclict with domainnames created by execve().
+      Without this prefix, if "<kernel> /usr/sbin/sshd /bin/bash" domain is
+      allowed to open /proc/ccs/.transition for writing and
+      "<kernel> /usr/sbin/sshd /bin/bash /usr/bin/passwd" domain is allowed to
+      access /etc/shadow , /bin/bash will be able to access /etc/shadow by
+      atomically writing "/usr/bin/passwd" + '\0' to /proc/ccs/.transition .
+      Allowing /bin/bash to access /etc/shadow is not what people want.
+
+      Permission for this operation is checked by "allow_transit" keyword.
+      Unlike "allow_execute" keyword, the string parameter for "allow_transit"
+      keyword does not refer a real file on filesystem's namespace. Therefore,
+      you can store any combination of parameters like LDAP's DN entry in the
+      string parameter for "allow_transit" keyword.
Index: security/ccsecurity/file.c
===================================================================
--- security/ccsecurity/file.c	(revision 3433)
+++ security/ccsecurity/file.c	(working copy)
@@ -42,6 +42,7 @@
 	[CCS_TYPE_REWRITE]    = "rewrite",
 	[CCS_TYPE_CHROOT]     = "chroot",
 	[CCS_TYPE_UMOUNT]     = "unmount",
+	[CCS_TYPE_TRANSIT]    = "transit",
 };
 
 static const char *ccs_path_number3_keyword[CCS_MAX_PATH_NUMBER3_OPERATION] = {
@@ -78,6 +79,7 @@
 	[CCS_TYPE_REWRITE]    = CCS_MAC_FILE_REWRITE,
 	[CCS_TYPE_CHROOT]     = CCS_MAC_FILE_CHROOT,
 	[CCS_TYPE_UMOUNT]     = CCS_MAC_FILE_UMOUNT,
+	[CCS_TYPE_TRANSIT]    = CCS_MAC_FILE_TRANSIT,
 };
 
 static const u8 ccs_pnnn2mac[CCS_MAX_PATH_NUMBER3_OPERATION] = {
@@ -1503,7 +1505,8 @@
 	if (r->mode == CCS_CONFIG_DISABLED)
 		return 0;
 	do {
-		error = ccs_path_acl(r, filename, 1 << operation, 1);
+		error = ccs_path_acl(r, filename, 1 << operation,
+				     operation != CCS_TYPE_TRANSIT);
 		msg = ccs_path2keyword(operation);
 		ccs_audit_path_log(r, msg, filename->name, !error);
 		if (!error)
@@ -2618,3 +2621,42 @@
 }
 #endif
 #endif
+
+/**
+ * ccs_may_transit - Check permission and do domain transition without execve().
+ *
+ * @domainname: Domainname to transit to.
+ * @pathname: Pathname to check.
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+int ccs_may_transit(const char *domainname, const char *pathname) {
+	struct ccs_path_info name;
+	struct ccs_request_info r;
+	struct ccs_domain_info *domain;
+	int error;
+	name.name = pathname;
+	ccs_fill_path_info(&name);
+	/* Check allow_transit permission. */
+	ccs_init_request_info(&r, NULL, CCS_MAC_FILE_TRANSIT);
+	error = ccs_path_permission(&r, CCS_TYPE_TRANSIT, &name);
+	printk(KERN_INFO "%s: transit '%s' = %d\n", __func__, pathname, error);
+	if (error)
+		return error;
+	/* Check destination domain. */
+	domain = ccs_find_domain(domainname);
+	if (!domain && strlen(domainname) < CCS_EXEC_TMPSIZE - 10) {
+		domain = ccs_find_or_assign_new_domain(domainname, r.profile);
+		//if (domain)
+		//	ccs_audit_domain_creation_log(domain);
+	}
+	if (domain) {
+		error = 0;
+		current->ccs_domain_info = domain;
+	} else {
+		error = -ENOENT;
+	}
+	return error;
+}
Index: security/ccsecurity/internal.h
===================================================================
--- security/ccsecurity/internal.h	(revision 3433)
+++ security/ccsecurity/internal.h	(working copy)
@@ -75,6 +75,7 @@
 	CCS_TYPE_REWRITE,
 	CCS_TYPE_CHROOT,
 	CCS_TYPE_UMOUNT,
+	CCS_TYPE_TRANSIT,
 	CCS_MAX_PATH_OPERATION
 };
 
@@ -162,6 +163,7 @@
 	CCS_MAC_FILE_MOUNT,
 	CCS_MAC_FILE_UMOUNT,
 	CCS_MAC_FILE_PIVOT_ROOT,
+	CCS_MAC_FILE_TRANSIT,
 	CCS_MAC_NETWORK_UDP_BIND,
 	CCS_MAC_NETWORK_UDP_CONNECT,
 	CCS_MAC_NETWORK_TCP_BIND,
@@ -916,6 +918,7 @@
 int ccs_get_path(const char *pathname, struct path *path);
 int ccs_init_request_info(struct ccs_request_info *r,
 			  struct ccs_domain_info *domain, const u8 index);
+int ccs_may_transit(const char *domainname, const char *pathname);
 int ccs_open_control(const u8 type, struct file *file);
 int ccs_parse_ip_address(char *address, u16 *min, u16 *max);
 int ccs_poll_control(struct file *file, poll_table *wait);
Index: security/ccsecurity/proc_if.c
===================================================================
--- security/ccsecurity/proc_if.c	(revision 3433)
+++ security/ccsecurity/proc_if.c	(working copy)
@@ -18,6 +18,86 @@
 #include <linux/version.h>
 #include "internal.h"
 
+/**
+ * ccs_write_transition - write() for /proc/ccs/.transition interface.
+ *
+ * @file:  Pointer to "struct file".
+ * @buf:   Domainname to transit to. Must ends with '\0'.
+ * @count: Size of @buf.
+ * @ppos:  Unused.
+ *
+ * Returns @count on success, negative value otherwise.
+ */
+static ssize_t ccs_write_transition(struct file *file, const char __user *buf,
+				    size_t count, loff_t *ppos)
+{
+	const char *self_domain = ccs_current_domain()->domainname->name;
+	const int self_domain_len = strlen(self_domain);
+	char *data;
+	int data_len;
+	char *tmp;
+	int idx;
+	int error = -ENOMEM;
+	if (!count || count + self_domain_len >= CCS_EXEC_TMPSIZE - 10) {
+		printk(KERN_INFO "%s: Invalid length (%u)\n", __func__, count);
+		return -ENOMEM;
+	}
+	data = kmalloc(count, GFP_KERNEL);
+	if (!data) {
+		printk(KERN_INFO "%s: Out of memory (%u)\n", __func__, count);
+		return -ENOMEM;
+	}
+	if (copy_from_user(data, buf, count)) {
+		printk(KERN_INFO "%s: Bad userspace address\n", __func__);
+		error = -EFAULT;
+		goto out;
+	}
+	if (memchr(data, '\0', count) != data + count - 1) {
+		printk(KERN_INFO "%s: Invalid line\n", __func__);
+		error = -EINVAL;
+		goto out;
+	}
+	tmp = ccs_encode(data);
+	kfree(data);
+	data = tmp;
+	if (!data) {
+		printk(KERN_INFO "%s: Out of memory\n", __func__);
+		goto out;
+	}
+	data_len = strlen(data);
+	tmp = kzalloc(self_domain_len + data_len + 4, GFP_KERNEL);
+	if (!tmp) {
+		printk(KERN_INFO "%s: Out of memory (%u)\n", __func__,
+		       self_domain_len + data_len + 4);
+		goto out;
+	}
+	/*
+	 * Add "//" prefix to requested name in order to distinguish domain
+	 * transitions with execve().
+	 */
+	snprintf(tmp, self_domain_len + data_len + 4, "%s //%s", self_domain,
+		 data);
+	kfree(data);
+	data = tmp;
+	idx = ccs_read_lock();
+	error = ccs_may_transit(data, data + self_domain_len + 1);
+	ccs_read_unlock(idx);
+	printk(KERN_INFO "%s: Transition to '%s' domain = %d\n", __func__,
+	       data, error);
+ out:
+	kfree(data);
+	return error ? error : count;
+}
+
+/* Operations for /proc/ccs/.transition interface. */
+static
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 17)
+const
+#endif
+struct file_operations ccs_transition_operations = {
+	.write = ccs_write_transition,
+};
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 23)
 #if !defined(RHEL_VERSION) || RHEL_VERSION != 3 || !defined(RHEL_UPDATE) || RHEL_UPDATE != 9
 /**
@@ -223,6 +303,12 @@
 	ccs_create_entry("version",          0400, ccs_dir, CCS_VERSION);
 	ccs_create_entry(".execute_handler", 0666, ccs_dir,
 			 CCS_EXECUTE_HANDLER);
+	{
+		struct proc_dir_entry *e = create_proc_entry(".transition",
+							     0222, ccs_dir);
+		if (e)
+			e->proc_fops = &ccs_transition_operations;
+	}
 	return 0;
 }
 
Index: security/ccsecurity/policy_io.c
===================================================================
--- security/ccsecurity/policy_io.c	(revision 3433)
+++ security/ccsecurity/policy_io.c	(working copy)
@@ -94,6 +94,8 @@
 	= "file::umount",
 	[CCS_MAC_FILE_PIVOT_ROOT]
 	= "file::pivot_root",
+	[CCS_MAC_FILE_TRANSIT]
+	= "file::transit",
 	[CCS_MAC_ENVIRON]
 	= "misc::env",
 	[CCS_MAC_NETWORK_UDP_BIND]
@@ -1227,7 +1229,8 @@
 	for (bit = head->read_bit; bit < CCS_MAX_PATH_OPERATION; bit++) {
 		if (!(perm & (1 << bit)))
 			continue;
-		if (head->read_execute_only && bit != CCS_TYPE_EXECUTE)
+		if (head->read_execute_only && bit != CCS_TYPE_EXECUTE
+		    && bit != CCS_TYPE_TRANSIT)
 			continue;
 		/* Print "read/write" instead of "read" and "write". */
 		if ((bit == CCS_TYPE_READ || bit == CCS_TYPE_WRITE)
