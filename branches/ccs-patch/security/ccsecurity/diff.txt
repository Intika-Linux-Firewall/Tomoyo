Index: audit.c
===================================================================
--- audit.c	(revision 3773)
+++ audit.c	(working copy)
@@ -479,12 +479,12 @@
 {
 	struct ccs_log_entry *ptr = NULL;
 	const bool is_granted = head->type == CCS_GRANTLOG;
-	if (head->read_avail)
+	if (head->r.w_pos)
 		return;
 	if (head->read_buf) {
 		kfree(head->read_buf);
 		head->read_buf = NULL;
-		head->readbuf_size = 0;
+		//head->readbuf_size = 0;
 	}
 	spin_lock(&ccs_log_lock);
 	if (!list_empty(&ccs_log[is_granted])) {
@@ -497,8 +497,8 @@
 	spin_unlock(&ccs_log_lock);
 	if (ptr) {
 		head->read_buf = ptr->log;
-		head->read_avail = strlen(ptr->log) + 1;
-		head->readbuf_size = head->read_avail;
+		head->r.w[head->r.w_pos++] = head->read_buf;
+		//head->readbuf_size = head->r.avail;
 		kfree(ptr);
 	}
 }
Index: memory.c
===================================================================
--- memory.c	(revision 3773)
+++ memory.c	(working copy)
@@ -300,7 +300,7 @@
 	};
 	unsigned int total = 0;
 	int i;
-	if (head->read_eof)
+	if (head->r.eof)
 		return;
 	for (i = 0; i < 3; i++) {
 		total += usage[i];
@@ -310,7 +310,7 @@
 		ccs_io_printf(head, "\n");
 	}
 	ccs_io_printf(head, "%s %10u\n", header[3], total);
-	head->read_eof = true;
+	head->r.eof = true;
 }
 
 /**
Index: internal.h
===================================================================
--- internal.h	(revision 3773)
+++ internal.h	(working copy)
@@ -43,26 +43,20 @@
 /**
  * list_for_each_cookie - iterate over a list with cookie.
  * @pos:        the &struct list_head to use as a loop cursor.
- * @cookie:     the &struct list_head to use as a cookie.
  * @head:       the head for your list.
- *
- * Same with list_for_each_rcu() except that this primitive uses @cookie
- * so that we can continue iteration.
- * @cookie must be NULL when iteration starts, and @cookie will become
- * NULL when iteration finishes.
  */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 34)
-#define list_for_each_cookie(pos, cookie, head)				\
-	if (!cookie)							\
-		cookie = rcu_dereference((head)->next);			\
-	for (pos = (cookie); pos != (head) || ((cookie) = NULL);	\
-	     pos = rcu_dereference(pos->next), (cookie) = pos)
+#define list_for_each_cookie(pos, head)			\
+	if (!pos)					\
+		pos = rcu_dereference((head)->next);	\
+	for ( ; pos != (head);				\
+	      pos = rcu_dereference(pos->next))
 #else
-#define list_for_each_cookie(pos, cookie, head)				\
-	if (!cookie)							\
-		cookie = srcu_dereference((head)->next, &ccs_ss);	\
-	for (pos = (cookie); pos != (head) || ((cookie) = NULL);	\
-	     pos = srcu_dereference(pos->next, &ccs_ss), (cookie) = pos)
+#define list_for_each_cookie(pos, head)				\
+	if (!pos)						\
+		pos = srcu_dereference((head)->next, &ccs_ss);	\
+	for ( ; pos != (head);					\
+	      pos = srcu_dereference(pos->next, &ccs_ss))
 #endif
 
 enum ccs_transition_type {
@@ -900,6 +894,8 @@
 	struct ccs_path_info entry;
 };
 
+#define CCS_MAX_IO_READ_QUEUE 32
+
 /* Structure for reading/writing policy via /proc interfaces. */
 struct ccs_io_buffer {
 	void (*read) (struct ccs_io_buffer *);
@@ -909,35 +905,38 @@
 	struct mutex io_sem;
 	/* Index returned by ccs_lock().        */
 	int reader_idx;
-	/* The position currently reading from. */
-	struct list_head *read_var1;
-	/* Extra variables for reading.         */
-	struct list_head *read_var2;
-	/* The position currently writing to.   */
-	struct ccs_domain_info *write_var1;
-	/* The step for reading.                */
-	int read_step;
+	char __user *read_user_buf;
+	int read_user_buf_avail;
+	struct {
+		struct list_head *domain;
+		struct list_head *group;
+		struct list_head *acl;
+		int avail;
+		int step;
+		int query_index;
+		u16 index;
+		u16 cond_index;
+		u8 cond_step;
+		u8 bit;
+		u8 w_pos;
+		bool eof;
+		bool print_this_domain_only;
+		bool print_execute_only;
+		bool print_cond_part;
+		const char *w[CCS_MAX_IO_READ_QUEUE];
+	} r;
+	struct {
+		struct ccs_domain_info *domain;
+		int avail;
+	} w;
 	/* Buffer for reading.                  */
 	char *read_buf;
-	/* EOF flag for reading.                */
-	bool read_eof;
-	/* Read domain ACL of specified PID?    */
-	bool read_single_domain;
-	/* Read allow_execute entry only?       */
-	bool read_execute_only;
-	/* Extra variable for reading.          */
-	u8 read_bit;
-	/* Bytes available for reading.         */
-	int read_avail;
 	/* Size of read buffer.                 */
 	int readbuf_size;
 	/* Buffer for writing.                  */
 	char *write_buf;
-	/* Bytes available for writing.         */
-	int write_avail;
 	/* Size of write buffer.                */
 	int writebuf_size;
-	bool read_cond;
 	/* Type of this interface.              */
 	u8 type;
 };
@@ -1000,7 +999,7 @@
 bool ccs_domain_quota_ok(struct ccs_request_info *r);
 bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos,
 		   struct ccs_page_dump *dump);
-bool ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
+void ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
 bool ccs_memory_ok(const void *ptr, const unsigned int size);
 bool ccs_number_matches_group(const unsigned long min, const unsigned long max,
Index: policy_io.c
===================================================================
--- policy_io.c	(revision 3773)
+++ policy_io.c	(working copy)
@@ -221,33 +221,86 @@
 	return value ? "yes" : "no";
 }
 
+static void ccs_addprintf(char *buffer, int len, const char *fmt, ...)
+{
+	va_list args;
+	const int pos = strlen(buffer);
+	va_start(args, fmt);
+	vsnprintf(buffer + pos, len - pos - 1, fmt, args);
+	va_end(args);
+}
+
+static bool ccs_flush(struct ccs_io_buffer *head)
+{
+	while (head->r.w_pos) {
+		const char *w = head->r.w[0];
+		int len = strlen(w);
+		if (len) {
+			if (len > head->read_user_buf_avail)
+				len = head->read_user_buf_avail;
+			if (!len)
+				return false;
+			if (copy_to_user(head->read_user_buf, w, len))
+				return false;
+			head->read_user_buf_avail -= len;
+			head->read_user_buf += len;
+			w += len;
+		}
+		if (*w) {
+			head->r.w[0] = w;
+			return false;
+		}
+		head->r.w_pos--;
+		for (len = 0; len < head->r.w_pos; len++)
+			head->r.w[len] = head->r.w[len + 1];
+	}
+	head->r.avail = 0;
+	return true;
+}
+
+static void ccs_set_string(struct ccs_io_buffer *head, const char *string)
+{
+	if (head->r.w_pos < CCS_MAX_IO_READ_QUEUE) {
+		head->r.w[head->r.w_pos++] = string;
+		ccs_flush(head);
+	} else
+		WARN_ON(1);
+}
+
 /**
- * ccs_io_printf - Transactional printf() to "struct ccs_io_buffer" structure.
+ * ccs_io_printf - printf() to "struct ccs_io_buffer" structure.
  *
  * @head: Pointer to "struct ccs_io_buffer".
  * @fmt:  The printf()'s format string, followed by parameters.
- *
- * Returns true on success, false otherwise.
- *
- * The snprintf() will truncate, but ccs_io_printf() won't.
  */
-bool ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
+void ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
 {
 	va_list args;
 	int len;
-	int pos = head->read_avail;
+	int pos = head->r.avail;
 	int size = head->readbuf_size - pos;
 	if (size <= 0)
-		return false;
+		return;
 	va_start(args, fmt);
-	len = vsnprintf(head->read_buf + pos, size, fmt, args);
+	len = vsnprintf(head->read_buf + pos, size, fmt, args) + 1;
 	va_end(args);
 	if (pos + len >= head->readbuf_size)
-		return false;
-	head->read_avail += len;
-	return true;
+		return;
+	head->r.avail += len;
+	ccs_set_string(head, head->read_buf + pos);
 }
 
+static inline void ccs_set_space(struct ccs_io_buffer *head)
+{
+	ccs_set_string(head, " ");
+}
+
+static bool ccs_set_lf(struct ccs_io_buffer *head)
+{
+	ccs_set_string(head, "\n");
+	return !head->r.w_pos;
+}
+
 /**
  * ccs_assign_profile - Create a new profile.
  *
@@ -539,7 +592,7 @@
 	return ccs_set_mode(data, cp, use_default, profile);
 }
 
-static bool ccs_print_preference(struct ccs_io_buffer *head, const int idx)
+static void ccs_print_preference(struct ccs_io_buffer *head, const int idx)
 {
 	struct ccs_preference *pref = &ccs_default_profile.preference;
 	const struct ccs_profile *profile = idx >= 0 ?
@@ -552,56 +605,67 @@
 	if (profile) {
 		pref = profile->audit;
 		if (pref == &ccs_default_profile.preference)
-			pref = NULL;
+			goto skip0;
 	}
-	if (pref && !ccs_io_printf(head, "%sPREFERENCE::%s={ "
+	ccs_io_printf(head, "%sPREFERENCE::%s={ "
 #ifdef CONFIG_CCSECURITY_AUDIT
-				   "max_grant_log=%u max_reject_log=%u "
+		      "max_grant_log=%u max_reject_log=%u "
 #endif
-				   "task_info=%s path_info=%s }\n", buffer,
-				   "audit",
+		      "task_info=%s path_info=%s }\n", buffer,
+		      "audit",
 #ifdef CONFIG_CCSECURITY_AUDIT
-				   pref->audit_max_grant_log,
-				   pref->audit_max_reject_log,
+		      pref->audit_max_grant_log,
+		      pref->audit_max_reject_log,
 #endif
-				   ccs_yesno(pref->audit_task_info),
-				   ccs_yesno(pref->audit_path_info)))
-		return false;
+		      ccs_yesno(pref->audit_task_info),
+		      ccs_yesno(pref->audit_path_info));
+ skip0:
 	if (profile) {
 		pref = profile->learning;
 		if (pref == &ccs_default_profile.preference)
-			pref = NULL;
+			goto skip1;
 	}
-	if (pref && !ccs_io_printf(head, "%sPREFERENCE::%s={ "
-				   "verbose=%s max_entry=%u exec.realpath=%s "
-				   "exec.argv0=%s symlink.target=%s }\n",
-				   buffer, "learning",
-				   ccs_yesno(pref->learning_verbose),
-				   pref->learning_max_entry,
-				   ccs_yesno(pref->learning_exec_realpath),
-				   ccs_yesno(pref->learning_exec_argv0),
-				   ccs_yesno(pref->learning_symlink_target)))
-		return false;
+	ccs_io_printf(head, "%sPREFERENCE::%s={ "
+		      "verbose=%s max_entry=%u exec.realpath=%s "
+		      "exec.argv0=%s symlink.target=%s }\n",
+		      buffer, "learning",
+		      ccs_yesno(pref->learning_verbose),
+		      pref->learning_max_entry,
+		      ccs_yesno(pref->learning_exec_realpath),
+		      ccs_yesno(pref->learning_exec_argv0),
+		      ccs_yesno(pref->learning_symlink_target));
+ skip1:
 	if (profile) {
 		pref = profile->permissive;
 		if (pref == &ccs_default_profile.preference)
-			pref = NULL;
+			goto skip2;
 	}
-	if (pref && !ccs_io_printf(head, "%sPREFERENCE::%s={ verbose=%s }\n",
-				   buffer, "permissive",
-				   ccs_yesno(pref->permissive_verbose)))
-		return false;
+	ccs_io_printf(head, "%sPREFERENCE::%s={ verbose=%s }\n",
+		      buffer, "permissive",
+		      ccs_yesno(pref->permissive_verbose));
+ skip2:
 	if (profile) {
 		pref = profile->enforcing;
 		if (pref == &ccs_default_profile.preference)
-			pref = NULL;
+			return;
 	}
-	return !pref || ccs_io_printf(head, "%sPREFERENCE::%s={ verbose=%s "
-				      "penalty=%u }\n", buffer, "enforcing",
-				      ccs_yesno(pref->enforcing_verbose),
-				      pref->enforcing_penalty);
+	ccs_io_printf(head, "%sPREFERENCE::%s={ verbose=%s "
+		      "penalty=%u }\n", buffer, "enforcing",
+		      ccs_yesno(pref->enforcing_verbose),
+		      pref->enforcing_penalty);
 }
 
+static void ccs_print_config(struct ccs_io_buffer *head, const u8 config)
+{
+	ccs_io_printf(head, "={ mode=%s", ccs_mode[config & 3]);
+#ifdef CONFIG_CCSECURITY_AUDIT
+	ccs_io_printf(head, " grant_log=%s reject_log=%s",
+		      ccs_yesno(config & CCS_CONFIG_WANT_GRANT_LOG),
+		      ccs_yesno(config & CCS_CONFIG_WANT_REJECT_LOG));
+#endif
+	ccs_set_string(head, " }\n");
+}
+
 /**
  * ccs_read_profile - Read profile table.
  *
@@ -609,81 +673,68 @@
  */
 static void ccs_read_profile(struct ccs_io_buffer *head)
 {
-	int index;
-	if (head->read_eof)
-		return;
-	if (head->read_bit)
-		goto body;
-	ccs_io_printf(head, "PROFILE_VERSION=%s\n", "20090903");
-	ccs_print_preference(head, -1);
-	head->read_bit = 1;
- body:
-	for (index = head->read_step; index < CCS_MAX_PROFILES; index++) {
-		bool done;
-		u8 config;
-		int i;
-		int pos;
-		const struct ccs_profile *profile = ccs_profile_ptr[index];
-		const struct ccs_path_info *comment;
-		head->read_step = index;
-		if (!profile)
-			continue;
-		pos = head->read_avail;
-		comment = profile->comment;
-		done = ccs_io_printf(head, "%u-COMMENT=%s\n", index,
-				     comment ? comment->name : "");
-		if (!done)
-			goto out;
-		config = profile->default_config;
-#ifdef CONFIG_CCSECURITY_AUDIT
-		if (!ccs_io_printf(head, "%u-%s%s={ mode=%s "
-				   "grant_log=%s reject_log=%s }\n", index,
-				   "CONFIG", "", ccs_mode[config & 3],
-				   ccs_yesno(config &
-					     CCS_CONFIG_WANT_GRANT_LOG),
-				   ccs_yesno(config &
-					     CCS_CONFIG_WANT_REJECT_LOG)))
-			goto out;
-#else
-		if (!ccs_io_printf(head, "%u-%s%s={ mode=%s }\n", index,
-				   "CONFIG", "", ccs_mode[config & 3]))
-			goto out;
-#endif
-		for (i = 0; i < CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
-			     + CCS_MAX_MAC_CATEGORY_INDEX; i++) {
-#ifdef CONFIG_CCSECURITY_AUDIT
-			const char *g;
-			const char *r;
-#endif
-			config = profile->config[i];
+	u8 index;
+	const struct ccs_profile *profile;
+ next:
+	index = head->r.index;
+	profile = ccs_profile_ptr[index];
+	switch (head->r.step) {
+	case 0:
+		ccs_io_printf(head, "PROFILE_VERSION=%s\n", "20090903");
+		ccs_print_preference(head, -1);
+		head->r.step++;
+		break;
+	case 1: 
+		for ( ; head->r.index < CCS_MAX_PROFILES;
+		      head->r.index++)
+			if (ccs_profile_ptr[head->r.index])
+				break;
+		if (head->r.index == CCS_MAX_PROFILES)
+			return;
+		head->r.step++;
+		break;
+	case 2:
+		{
+			const struct ccs_path_info *comment = profile->comment;
+			ccs_io_printf(head, "%u-COMMENT=", index);
+			ccs_set_string(head, comment ? comment->name : "");
+			ccs_set_lf(head);
+			head->r.step++;
+		}
+		break;
+	case 3:
+		{
+			ccs_io_printf(head, "%u-%s", index, "CONFIG");
+			ccs_print_config(head, profile->default_config);
+			head->r.bit = 0;
+			head->r.step++;
+		}
+		break;
+	case 4:
+		for ( ; head->r.bit < CCS_MAX_MAC_INDEX
+			      + CCS_MAX_CAPABILITY_INDEX
+			      + CCS_MAX_MAC_CATEGORY_INDEX; head->r.bit++) {
+			const u8 i = head->r.bit;
+			const u8 config = profile->config[i];
 			if (config == CCS_CONFIG_USE_DEFAULT)
 				continue;
-#ifdef CONFIG_CCSECURITY_AUDIT
-			g = ccs_yesno(config & CCS_CONFIG_WANT_GRANT_LOG);
-			r = ccs_yesno(config & CCS_CONFIG_WANT_REJECT_LOG);
-			if (!ccs_io_printf(head, "%u-%s%s={ mode=%s "
-					   "grant_log=%s reject_log=%s }\n",
-					   index, "CONFIG::",
-					   ccs_mac_keywords[i],
-					   ccs_mode[config & 3], g, r))
-				goto out;
-#else
-			if (!ccs_io_printf(head, "%u-%s%s={ mode=%s }\n",
-					   index, "CONFIG::",
-					   ccs_mac_keywords[i],
-					   ccs_mode[config & 3]))
-				goto out;
-#endif
+			ccs_io_printf(head, "%u-%s%s", index, "CONFIG::",
+				      ccs_mac_keywords[i]);
+			ccs_print_config(head, config);
+			head->r.bit++;
+			break;
 		}
-		if (!ccs_print_preference(head, index))
-			goto out;
-		continue;
- out:
-		head->read_avail = pos;
+		if (head->r.bit == CCS_MAX_MAC_INDEX
+		    + CCS_MAX_CAPABILITY_INDEX
+		    + CCS_MAX_MAC_CATEGORY_INDEX) {
+			ccs_print_preference(head, index);
+			head->r.index++;
+			head->r.step = 1;
+		}
 		break;
 	}
-	if (index == CCS_MAX_PROFILES)
-		head->read_eof = true;
+	if (ccs_flush(head))
+		goto next;
 }
 
 static bool ccs_same_manager_entry(const struct ccs_acl_head *a,
@@ -750,19 +801,20 @@
  */
 static void ccs_read_manager(struct ccs_io_buffer *head)
 {
-	struct list_head *pos;
-	if (head->read_eof)
+	if (head->r.eof)
 		return;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_policy_list[CCS_ID_MANAGER]) {
+	list_for_each_cookie(head->r.acl, &ccs_policy_list[CCS_ID_MANAGER]) {
 		struct ccs_manager *ptr
-			= list_entry(pos, typeof(*ptr), head.list);
+			= list_entry(head->r.acl, typeof(*ptr), head.list);
 		if (ptr->head.is_deleted)
 			continue;
-		if (!ccs_io_printf(head, "%s\n", ptr->manager->name))
+		if (!ccs_flush(head))
 			return;
+		ccs_set_string(head, ptr->manager->name);
+		ccs_set_lf(head);
 	}
-	head->read_eof = true;
+	head->r.acl = NULL;
+	head->r.eof = true;
 }
 
 /**
@@ -851,7 +903,8 @@
 	struct ccs_domain_info *domain = NULL;
 	bool global_pid = false;
 	if (!strcmp(data, "allow_execute")) {
-		head->read_execute_only = true;
+		//memset(&head->r, 0, sizeof(head->r));
+		head->r.print_execute_only = true;
 		return true;
 	}
 	if (sscanf(data, "pid=%u", &pid) == 1 ||
@@ -875,21 +928,17 @@
 			domain = ccs_find_domain(data + 7);
 	} else
 		return false;
-	head->write_var1 = domain;
+	head->w.domain = domain;
 	/* Accessing read_buf is safe because head->io_sem is held. */
 	if (!head->read_buf)
 		return true; /* Do nothing if open(O_WRONLY). */
-	head->read_avail = 0;
-	head->read_cond = false;
+	memset(&head->r, 0, sizeof(head->r));
+	head->r.print_this_domain_only = true;
+	head->r.eof = !domain;
+	head->r.domain = &domain->list;
 	ccs_io_printf(head, "# select %s\n", data);
-	head->read_single_domain = true;
-	head->read_eof = !domain;
-	head->read_var1 = &domain->list;
-	head->read_var2 = NULL;
-	head->read_bit = 0;
-	head->read_step = 0;
 	if (domain && domain->is_deleted)
-		ccs_io_printf(head, "# This is a deleted domain.\n");
+		ccs_set_string(head, "# This is a deleted domain.\n");
 	return true;
 }
 
@@ -950,7 +999,7 @@
 static int ccs_write_domain(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
-	struct ccs_domain_info *domain = head->write_var1;
+	struct ccs_domain_info *domain = head->w.domain;
 	bool is_delete = false;
 	bool is_select = false;
 	unsigned int profile;
@@ -971,7 +1020,7 @@
 			domain = ccs_find_domain(data);
 		else
 			domain = ccs_assign_domain(data, 0);
-		head->write_var1 = domain;
+		head->w.domain = domain;
 		return 0;
 	}
 	if (!domain)
@@ -998,19 +1047,18 @@
  *
  * @head: Pointer to "struct ccs_io_buffer".
  * @ptr:  Pointer to "struct ccs_name_union".
- *
- * Returns true on success, false otherwise.
  */
-static bool ccs_print_name_union(struct ccs_io_buffer *head,
+static void ccs_print_name_union(struct ccs_io_buffer *head,
 				 const struct ccs_name_union *ptr)
 {
-	int pos = head->read_avail;
-	if (pos && head->read_buf[pos - 1] == ' ')
-		head->read_avail--;
-	if (ptr->is_group)
-		return ccs_io_printf(head, " @%s",
-				     ptr->group->group_name->name);
-	return ccs_io_printf(head, " %s", ptr->filename->name);
+	if (!head->r.print_cond_part)
+		ccs_set_space(head);
+	if (ptr->is_group) {
+		ccs_set_string(head, "@");
+		ccs_set_string(head, ptr->group->group_name->name);
+	} else {
+		ccs_set_string(head, ptr->filename->name);
+	}
 }
 
 /**
@@ -1018,104 +1066,68 @@
  *
  * @head: Pointer to "struct ccs_io_buffer".
  * @ptr:  Pointer to "struct ccs_name_union".
- *
- * Returns true on success, false otherwise.
  */
-static bool ccs_print_name_union_quoted(struct ccs_io_buffer *head,
+static void ccs_print_name_union_quoted(struct ccs_io_buffer *head,
 					const struct ccs_name_union *ptr)
 {
-	if (ptr->is_group)
-		return ccs_io_printf(head, "@%s",
-				     ptr->group->group_name->name);
-	return ccs_io_printf(head, "\"%s\"", ptr->filename->name);
-}
-
-static void ccs_print_number(char *buffer, int buffer_len,
-			     const struct ccs_number_union *ptr)
-{
-	int i;
-	unsigned long min = ptr->values[0];
-	const unsigned long max = ptr->values[1];
-	u8 min_type = ptr->value_type[0];
-	const u8 max_type = ptr->value_type[1];
-	memset(buffer, 0, buffer_len);
-	buffer_len -= 2;
-	for (i = 0; i < 2; i++) {
-		int len;
-		switch (min_type) {
-		case CCS_VALUE_TYPE_HEXADECIMAL:
-			snprintf(buffer, buffer_len, "0x%lX", min);
-			break;
-		case CCS_VALUE_TYPE_OCTAL:
-			snprintf(buffer, buffer_len, "0%lo", min);
-			break;
-		default:
-			snprintf(buffer, buffer_len, "%lu", min);
-			break;
-		}
-		if (min == max && min_type == max_type)
-			break;
-		len = strlen(buffer);
-		buffer[len++] = '-';
-		buffer += len;
-		buffer_len -= len;
-		min_type = max_type;
-		min = max;
+	if (ptr->is_group) {
+		ccs_set_string(head, "@");
+		ccs_set_string(head, ptr->group->group_name->name);
+	} else {
+		ccs_set_string(head, "\"");
+		ccs_set_string(head, ptr->filename->name);
+		ccs_set_string(head, "\"");
 	}
 }
 
 /**
- * ccs_print_number_union_common - Print a ccs_number_union.
- *
- * @head:       Pointer to "struct ccs_io_buffer".
- * @ptr:        Pointer to "struct ccs_number_union".
- * @need_space: True if a space character is needed.
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_print_number_union_common(struct ccs_io_buffer *head,
-					  const struct ccs_number_union *ptr,
-					  const bool need_space)
-{
-	char buffer[128];
-	if (need_space && !ccs_io_printf(head, " "))
-		return false;
-	if (ptr->is_group)
-		return ccs_io_printf(head, "@%s",
-				     ptr->group->group_name->name);
-	ccs_print_number(buffer, sizeof(buffer), ptr);
-	return ccs_io_printf(head, "%s", buffer);
-}
-
-/**
  * ccs_print_number_union - Print a ccs_number_union.
  *
- * @head:       Pointer to "struct ccs_io_buffer".
- * @ptr:        Pointer to "struct ccs_number_union".
- *
- * Returns true on success, false otherwise.
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ccs_number_union".
  */
-static bool ccs_print_number_union(struct ccs_io_buffer *head,
+static void ccs_print_number_union(struct ccs_io_buffer *head,
 				   const struct ccs_number_union *ptr)
 {
-	return ccs_print_number_union_common(head, ptr, true);
+	if (!head->r.print_cond_part)
+		ccs_set_space(head);
+	if (ptr->is_group) {
+		ccs_set_string(head, "@");
+		ccs_set_string(head, ptr->group->group_name->name);
+	} else {
+		int i;
+		unsigned long min = ptr->values[0];
+		const unsigned long max = ptr->values[1];
+		u8 min_type = ptr->value_type[0];
+		const u8 max_type = ptr->value_type[1];
+		char buffer[128];
+		buffer[0] = '\0';
+		for (i = 0; i < 2; i++) {
+			switch (min_type) {
+			case CCS_VALUE_TYPE_HEXADECIMAL:
+				ccs_addprintf(buffer, sizeof(buffer), "0x%lX",
+					      min);
+				break;
+			case CCS_VALUE_TYPE_OCTAL:
+				ccs_addprintf(buffer, sizeof(buffer), "0%lo",
+					      min);
+				break;
+			default:
+				ccs_addprintf(buffer, sizeof(buffer), "%lu",
+					      min);
+				break;
+			}
+			if (min == max && min_type == max_type)
+				break;
+			ccs_addprintf(buffer, sizeof(buffer), "-");
+			min_type = max_type;
+			min = max;
+		}
+		ccs_io_printf(head, "%s", buffer);
+	}
 }
 
 /**
- * ccs_print_number_union_nospace - Print a ccs_number_union without a space character.
- *
- * @head:       Pointer to "struct ccs_io_buffer".
- * @ptr:        Pointer to "struct ccs_number_union".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_print_number_union_nospace(struct ccs_io_buffer *head,
-					   const struct ccs_number_union *ptr)
-{
-	return ccs_print_number_union_common(head, ptr, false);
-}
-
-/**
  * ccs_print_condition - Print condition part.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -1126,111 +1138,154 @@
 static bool ccs_print_condition(struct ccs_io_buffer *head,
 				const struct ccs_condition *cond)
 {
-	const struct ccs_condition_element *condp;
-	const struct ccs_number_union *numbers_p;
-	const struct ccs_name_union *names_p;
-	const struct ccs_argv *argv;
-	const struct ccs_envp *envp;
-	u16 condc;
-	u16 i;
-	u16 j;
-	char buffer[32];
-	if (!cond)
-		goto no_condition;
-	condc = cond->condc;
-	condp = (const struct ccs_condition_element *) (cond + 1);
-	numbers_p = (const struct ccs_number_union *) (condp + condc);
-	names_p = (const struct ccs_name_union *)
-		(numbers_p + cond->numbers_count);
-	argv = (const struct ccs_argv *) (names_p + cond->names_count);
-	envp = (const struct ccs_envp *) (argv + cond->argc);
-	memset(buffer, 0, sizeof(buffer));
-	if (condc && !ccs_io_printf(head, "%s", " if"))
-		goto out;
-	for (i = 0; i < condc; i++) {
-		const u8 match = condp->equals;
-		const u8 left = condp->left;
-		const u8 right = condp->right;
-		condp++;
-		switch (left) {
-		case CCS_ARGV_ENTRY:
-			if (!ccs_io_printf(head, " exec.argv[%u]%s\"%s\"",
-					   argv->index, argv->is_not ?
-					   "!=" : "=", argv->value->name))
-				goto out;
-			argv++;
-			continue;
-		case CCS_ENVP_ENTRY:
-			if (!ccs_io_printf(head, " exec.envp[\"%s\"]%s",
-					   envp->name->name, envp->is_not ?
-					   "!=" : "="))
-				goto out;
-			if (envp->value) {
-				if (!ccs_io_printf(head, "\"%s\"",
-						   envp->value->name))
-					goto out;
-			} else {
-				if (!ccs_io_printf(head, "NULL"))
-					goto out;
+	const struct ccs_condition_element *condp = NULL;
+	const struct ccs_number_union *numbers_p = NULL;
+	const struct ccs_name_union *names_p = NULL;
+	const struct ccs_argv *argv = NULL;
+	const struct ccs_envp *envp = NULL;
+	u16 condc = 0;
+	if (cond) {
+		condc = cond->condc;
+		condp = (const struct ccs_condition_element *) (cond + 1);
+		numbers_p = (const struct ccs_number_union *) (condp + condc);
+		names_p = (const struct ccs_name_union *)
+			(numbers_p + cond->numbers_count);
+		argv = (const struct ccs_argv *) (names_p + cond->names_count);
+		envp = (const struct ccs_envp *) (argv + cond->argc);
+	} else {
+		head->r.cond_step = 4;
+	}
+	switch (head->r.cond_step) {
+	case 0:
+		{ 
+			if (condc)
+				ccs_set_string(head, " if");
+			head->r.cond_index = 0;
+			head->r.cond_step++;
+		}
+		/* fall through */
+	case 1:
+		{
+			u16 skip = head->r.cond_index;
+			while (skip--) {
+				const u8 left = condp->left;
+				const u8 right = condp->right;
+				condp++;
+				switch (left) {
+				case CCS_ARGV_ENTRY:
+					argv++;
+					continue;
+				case CCS_ENVP_ENTRY:
+					envp++;
+					continue;
+				case CCS_NUMBER_UNION:
+					numbers_p++;
+					break;
+				}
+				switch (right) {
+				case CCS_NAME_UNION:
+					names_p++;
+					break;
+				case CCS_NUMBER_UNION:
+					numbers_p++;
+					break;
+				}
 			}
-			envp++;
-			continue;
-		case CCS_NUMBER_UNION:
-			if (!ccs_print_number_union(head, numbers_p++))
-				goto out;
-			break;
-		default:
-			if (left >= CCS_MAX_CONDITION_KEYWORD)
-				goto out;
-			if (!ccs_io_printf(head, " %s",
-					   ccs_condition_keyword[left]))
-				goto out;
-			break;
 		}
-		if (!ccs_io_printf(head, "%s", match ? "=" : "!="))
-			goto out;
-		switch (right) {
-		case CCS_NAME_UNION:
-			if (!ccs_print_name_union_quoted(head, names_p++))
-				goto out;
+		while (head->r.cond_index < condc) {
+			const u8 match = condp->equals;
+			const u8 left = condp->left;
+			const u8 right = condp->right;
+			if (!ccs_flush(head))
+				return false;
+			condp++;
+			head->r.cond_index++;
+			switch (left) {
+			case CCS_ARGV_ENTRY:
+				ccs_io_printf(head, " exec.argv[%u]%s\"%s\"",
+					      argv->index, argv->is_not ?
+					      "!=" : "=", argv->value->name);
+				argv++;
+				continue;
+			case CCS_ENVP_ENTRY:
+				ccs_io_printf(head, " exec.envp[\"%s\"]%s",
+					      envp->name->name, envp->is_not ?
+					      "!=" : "=");
+				if (envp->value) {
+					ccs_set_string(head, "\"");
+					ccs_set_string(head,
+						       envp->value->name);
+					ccs_set_string(head, "\"");
+				} else {
+					ccs_set_string(head, "NULL");
+				}
+				envp++;
+				continue;
+			case CCS_NUMBER_UNION:
+				ccs_print_number_union(head, numbers_p++);
+				break;
+			default:
+				ccs_set_space(head);
+				ccs_set_string(head,
+					       ccs_condition_keyword[left]);
+				break;
+			}
+			ccs_set_string(head, match ? "=" : "!=");
+			switch (right) {
+			case CCS_NAME_UNION:
+				ccs_print_name_union_quoted(head, names_p++);
+				break;
+			case CCS_NUMBER_UNION:
+				ccs_print_number_union(head, numbers_p++);
+				break;
+			default:
+				ccs_set_string(head,
+					       ccs_condition_keyword[right]);
+				break;
+			}
+		}
+		head->r.cond_step++;
+		/* fall through */
+	case 2:
+		if (!ccs_flush(head))
 			break;
-		case CCS_NUMBER_UNION:
-			if (!ccs_print_number_union_nospace(head, numbers_p++))
-				goto out;
-			break;
-		default:
-			if (right >= CCS_MAX_CONDITION_KEYWORD)
-				goto out;
-			if (!ccs_io_printf(head, "%s",
-					   ccs_condition_keyword[right]))
-				goto out;
-			break;
+		head->r.cond_step++;
+		/* fall through */
+	case 3:
+		{
+			u8 j;
+			const u8 i = cond->post_state[3];
+			if (i)
+				ccs_set_string(head, " ; set");
+			for (j = 0; j < 3; j++)
+				if ((i & (1 << j)))
+					ccs_io_printf(head, 
+						      " task.state[%u]=%u", j,
+						      cond->post_state[j]);
+			if (i & (1 << 4))
+				ccs_io_printf(head, " audit=%s",
+					      ccs_yesno(cond->post_state[4]));
 		}
+		head->r.cond_step++;
+		/* fall through */
+	case 4:
+		ccs_set_lf(head);
+		head->r.cond_step++;
+		/* fall through */
+	case 5:
+		return ccs_flush(head);
 	}
-	i = cond->post_state[3];
-	if (!i)
-		goto no_condition;
-	if (!ccs_io_printf(head, " ; set"))
-		goto out;
-	for (j = 0; j < 3; j++) {
-		if (!(i & (1 << j)))
-			continue;
-		if (!ccs_io_printf(head, " task.state[%u]=%u", j,
-				   cond->post_state[j]))
-			goto out;
-	}
-	if (i & (1 << 4)) {
-		if (!ccs_io_printf(head, " audit=%s",
-				   ccs_yesno(cond->post_state[4])))
-			goto out;
-	}
- no_condition:
-	if (ccs_io_printf(head, "\n"))
-		return true;
- out:
 	return false;
 }
 
+static u8 ccs_fns(const u8 perm, u8 bit)
+{
+	for ( ; bit < 8; bit++)
+		if (perm & (1 << bit))
+			break;
+	return bit;
+}
+
 /**
  * ccs_print_entry - Print an ACL entry.
  *
@@ -1242,15 +1297,13 @@
 static bool ccs_print_entry(struct ccs_io_buffer *head,
 			    const struct ccs_acl_info *acl)
 {
-	int pos;
 	const u8 acl_type = acl->type;
-	u8 bit = head->read_bit;
-	if (head->read_cond)
-		goto print_cond;
+	u8 bit = head->r.bit;
+	if (head->r.print_cond_part)
+		goto print_cond_part;
 	if (acl->is_deleted)
 		return true;
  next:
-	pos = head->read_avail;
 	if (acl_type == CCS_TYPE_PATH_ACL) {
 		struct ccs_path_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
@@ -1258,8 +1311,8 @@
 		for ( ; bit < CCS_MAX_PATH_OPERATION; bit++) {
 			if (!(perm & (1 << bit)))
 				continue;
-			if (head->read_execute_only && bit != CCS_TYPE_EXECUTE
-			    && bit != CCS_TYPE_TRANSIT)
+			if (head->r.print_execute_only &&
+			    bit != CCS_TYPE_EXECUTE && bit != CCS_TYPE_TRANSIT)
 				continue;
 			/* Print "read/write" instead of "read" and "write". */
 			if ((bit == CCS_TYPE_READ || bit == CCS_TYPE_WRITE)
@@ -1269,137 +1322,109 @@
 		}
 		if (bit == CCS_MAX_PATH_OPERATION)
 			goto done;
-		if (!ccs_io_printf(head, "allow_%s", ccs_path_keyword[bit]) ||
-		    !ccs_print_name_union(head, &ptr->name))
-			goto fail;
+		ccs_io_printf(head, "allow_%s", ccs_path_keyword[bit]);
+		ccs_print_name_union(head, &ptr->name);
 	} else if (acl_type == CCS_TYPE_EXECUTE_HANDLER ||
 		   acl_type == CCS_TYPE_DENIED_EXECUTE_HANDLER) {
 		struct ccs_execute_handler *ptr
 			= container_of(acl, typeof(*ptr), head);
-		if (!ccs_io_printf(head, "%s %s",
-				   acl_type == CCS_TYPE_EXECUTE_HANDLER ?
-				   CCS_KEYWORD_EXECUTE_HANDLER :
-				   CCS_KEYWORD_DENIED_EXECUTE_HANDLER,
-				   ptr->handler->name))
-			goto fail;
-	} if (head->read_execute_only) {
+		ccs_io_printf(head, "%s ",
+			      acl_type == CCS_TYPE_EXECUTE_HANDLER ?
+			      CCS_KEYWORD_EXECUTE_HANDLER :
+			      CCS_KEYWORD_DENIED_EXECUTE_HANDLER);
+		ccs_set_string(head, ptr->handler->name);
+	} else if (head->r.print_execute_only) {
 		return true;
 	} else if (acl_type == CCS_TYPE_MKDEV_ACL) {
 		struct ccs_mkdev_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		const u8 perm = ptr->perm;
-		for ( ; bit < CCS_MAX_MKDEV_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
-				continue;
-			break;
-		}
-		if (bit == CCS_MAX_MKDEV_OPERATION)
+		bit = ccs_fns(ptr->perm, bit);
+		if (bit >= CCS_MAX_MKDEV_OPERATION)
 			goto done;
-		if (!ccs_io_printf(head, "allow_%s", ccs_mkdev_keyword[bit]) ||
-		    !ccs_print_name_union(head, &ptr->name) ||
-		    !ccs_print_number_union(head, &ptr->mode) ||
-		    !ccs_print_number_union(head, &ptr->major) ||
-		    !ccs_print_number_union(head, &ptr->minor))
-			goto fail;
+		ccs_io_printf(head, "allow_%s", ccs_mkdev_keyword[bit]);
+		ccs_print_name_union(head, &ptr->name);
+		ccs_print_number_union(head, &ptr->mode);
+		ccs_print_number_union(head, &ptr->major);
+		ccs_print_number_union(head, &ptr->minor);
 	} else if (acl_type == CCS_TYPE_PATH2_ACL) {
 		struct ccs_path2_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		const u8 perm = ptr->perm;
-		for ( ; bit < CCS_MAX_PATH2_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
-				continue;
-			break;
-		}
-		if (bit == CCS_MAX_PATH2_OPERATION)
+		bit = ccs_fns(ptr->perm, bit);
+		if (bit >= CCS_MAX_PATH2_OPERATION)
 			goto done;
-		if (!ccs_io_printf(head, "allow_%s", ccs_path2_keyword[bit]) ||
-		    !ccs_print_name_union(head, &ptr->name1) ||
-		    !ccs_print_name_union(head, &ptr->name2))
-			goto fail;
+		ccs_io_printf(head, "allow_%s", ccs_path2_keyword[bit]);
+		ccs_print_name_union(head, &ptr->name1);
+		ccs_print_name_union(head, &ptr->name2);
 	} else if (acl_type == CCS_TYPE_PATH_NUMBER_ACL) {
 		struct ccs_path_number_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		const u8 perm = ptr->perm;
-		for ( ; bit < CCS_MAX_PATH_NUMBER_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
-				continue;
-			break;
-		}
-		if (bit == CCS_MAX_PATH_NUMBER_OPERATION)
+		bit = ccs_fns(ptr->perm, bit);
+		if (bit >= CCS_MAX_PATH_NUMBER_OPERATION)
 			goto done;
-		if (!ccs_io_printf(head, "allow_%s",
-				   ccs_path_number_keyword[bit]) ||
-		    !ccs_print_name_union(head, &ptr->name) ||
-		    !ccs_print_number_union(head, &ptr->number))
-			goto fail;
+		ccs_io_printf(head, "allow_%s",
+			      ccs_path_number_keyword[bit]);
+		ccs_print_name_union(head, &ptr->name);
+		ccs_print_number_union(head, &ptr->number);
 	} else if (acl_type == CCS_TYPE_ENV_ACL) {
 		struct ccs_env_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		if (!ccs_io_printf(head, CCS_KEYWORD_ALLOW_ENV "%s",
-				   ptr->env->name))
-			goto fail;
+		ccs_set_string(head, CCS_KEYWORD_ALLOW_ENV);
+		ccs_set_string(head, ptr->env->name);
 	} else if (acl_type == CCS_TYPE_CAPABILITY_ACL) {
 		struct ccs_capability_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		if (!ccs_io_printf(head, CCS_KEYWORD_ALLOW_CAPABILITY "%s",
-				   ccs_cap2keyword(ptr->operation)))
-			goto fail;
+		ccs_set_string(head, CCS_KEYWORD_ALLOW_CAPABILITY);
+		ccs_set_string(head, ccs_cap2keyword(ptr->operation));
 	} else if (acl_type == CCS_TYPE_IP_NETWORK_ACL) {
 		struct ccs_ip_network_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		char buf[128];
-		const char *w[2] = { buf, "" };
-		const u8 perm = ptr->perm;
-		for ( ; bit < CCS_MAX_NETWORK_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
-				continue;
-			break;
-		}
-		if (bit == CCS_MAX_NETWORK_OPERATION)
+		bit = ccs_fns(ptr->perm, bit);
+		if (bit >= CCS_MAX_NETWORK_OPERATION)
 			goto done;
+		ccs_io_printf(head, CCS_KEYWORD_ALLOW_NETWORK "%s ",
+			      ccs_net_keyword[bit]);
 		switch (ptr->address_type) {
+			char buf[128];
 		case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
-			w[0] = "@";
-			w[1] = ptr->address.group->group_name->name;
+			ccs_set_string(head, "@");
+			ccs_set_string(head,
+				       ptr->address.group->group_name->name);
 			break;
 		case CCS_IP_ADDRESS_TYPE_IPv4:
 			ccs_print_ipv4(buf, sizeof(buf), ptr->address.ipv4.min,
 				       ptr->address.ipv4.max);
+			ccs_io_printf(head, "%s", buf);
 			break;
 		case CCS_IP_ADDRESS_TYPE_IPv6:
 			ccs_print_ipv6(buf, sizeof(buf), ptr->address.ipv6.min,
 				       ptr->address.ipv6.max);
+			ccs_io_printf(head, "%s", buf);
 			break;
 		}
-		if (!ccs_io_printf(head, CCS_KEYWORD_ALLOW_NETWORK "%s %s%s",
-				   ccs_net_keyword[bit], w[0], w[1]) ||
-		    !ccs_print_number_union(head, &ptr->port))
-			goto fail;
+		ccs_print_number_union(head, &ptr->port);
 	} else if (acl_type == CCS_TYPE_SIGNAL_ACL) {
 		struct ccs_signal_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		if (!ccs_io_printf(head, CCS_KEYWORD_ALLOW_SIGNAL "%u %s",
-				   ptr->sig, ptr->domainname->name))
-			goto fail;
+		ccs_io_printf(head, CCS_KEYWORD_ALLOW_SIGNAL "%u ", ptr->sig);
+		ccs_set_string(head, ptr->domainname->name);
 	} else if (acl_type == CCS_TYPE_MOUNT_ACL) {
 		struct ccs_mount_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		if (!ccs_io_printf(head, CCS_KEYWORD_ALLOW_MOUNT) ||
-		    !ccs_print_name_union(head, &ptr->dev_name) ||
-		    !ccs_print_name_union(head, &ptr->dir_name) ||
-		    !ccs_print_name_union(head, &ptr->fs_type) ||
-		    !ccs_print_number_union(head, &ptr->flags))
-			goto fail;
+		ccs_io_printf(head, CCS_KEYWORD_ALLOW_MOUNT);
+		ccs_print_name_union(head, &ptr->dev_name);
+		ccs_print_name_union(head, &ptr->dir_name);
+		ccs_print_name_union(head, &ptr->fs_type);
+		ccs_print_number_union(head, &ptr->flags);
 	}
-	head->read_bit = bit;
-	head->read_cond = true;
- print_cond:
-	pos = head->read_avail;
-	if (!ccs_print_condition(head, acl->cond)) {
-		head->read_avail = pos;
+	head->r.bit = bit;
+	head->r.print_cond_part = true;
+	head->r.cond_step = 0;
+	if (!ccs_flush(head))
 		return false;
-	}
-	head->read_cond = false;
+ print_cond_part:
+	if (!ccs_print_condition(head, acl->cond))
+		return false;
+	head->r.print_cond_part = false;
 	switch (acl_type) {
 	case CCS_TYPE_PATH_ACL:
 	case CCS_TYPE_MKDEV_ACL:
@@ -1410,12 +1435,8 @@
 		goto next;
 	}
  done:
-	head->read_bit = 0;
+	head->r.bit = 0;
 	return true;
- fail:
-	head->read_bit = bit;
- 	head->read_avail = pos;
-	return false;
 }
 
 /**
@@ -1431,14 +1452,13 @@
 static bool ccs_read_domain2(struct ccs_io_buffer *head,
 			     struct ccs_domain_info *domain)
 {
-	struct list_head *pos;
-	/* Print ACL entries in the domain. */
-	list_for_each_cookie(pos, head->read_var2, &domain->acl_info_list) {
+	list_for_each_cookie(head->r.acl, &domain->acl_info_list) {
 		struct ccs_acl_info *ptr
-			= list_entry(pos, struct ccs_acl_info, list);
+			= list_entry(head->r.acl, struct ccs_acl_info, list);
 		if (!ccs_print_entry(head, ptr))
 			return false;
 	}
+	head->r.acl = NULL;
 	return true;
 }
 
@@ -1451,48 +1471,46 @@
  */
 static void ccs_read_domain(struct ccs_io_buffer *head)
 {
-	struct list_head *pos;
-	if (head->read_eof)
+	if (head->r.eof)
 		return;
-	list_for_each_cookie(pos, head->read_var1, &ccs_domain_list) {
+	list_for_each_cookie(head->r.domain, &ccs_domain_list) {
 		struct ccs_domain_info *domain =
-			list_entry(pos, struct ccs_domain_info, list);
-		switch (head->read_step) {
+			list_entry(head->r.domain, struct ccs_domain_info,
+				   list);
+		switch (head->r.step) {
 			u8 i;
-			const char *w[CCS_MAX_DOMAIN_INFO_FLAGS];
 		case 0:
-			if (domain->is_deleted && !head->read_single_domain)
+			if (domain->is_deleted &&
+			    !head->r.print_this_domain_only)
 				continue;
 			/* Print domainname and flags. */
+			ccs_set_string(head, domain->domainname->name);
+			ccs_set_lf(head);
+			ccs_io_printf(head, CCS_KEYWORD_USE_PROFILE "%u\n",
+				      domain->profile);
 			for (i = 0; i < CCS_MAX_DOMAIN_INFO_FLAGS; i++)
-				w[i] = domain->flags[i] ? ccs_dif[i] : "";
-			if (!ccs_io_printf(head, "%s\n" CCS_KEYWORD_USE_PROFILE
-					   "%u\n%s%s%s%s%s\n",
-					   domain->domainname->name,
-					   domain->profile,
-					   w[CCS_DIF_QUOTA_WARNED],
-					   w[CCS_DIF_IGNORE_GLOBAL],
-					   w[CCS_DIF_IGNORE_GLOBAL_ALLOW_READ],
-					   w[CCS_DIF_IGNORE_GLOBAL_ALLOW_ENV],
-					   w[CCS_DIF_TRANSITION_FAILED]))
+				if (domain->flags[i])
+					ccs_set_string(head, ccs_dif[i]);
+			head->r.step++;
+			if (!ccs_set_lf(head))
 				return;
-			head->read_step++;
 			/* fall through */
 		case 1:
 			if (!ccs_read_domain2(head, domain))
 				return;
-			head->read_step++;
+			head->r.step++;
+			if (!ccs_set_lf(head))
+				return;
 			/* fall through */
 		case 2:
-			if (!ccs_io_printf(head, "\n"))
-				return;
-			head->read_step = 0;
-			if (head->read_single_domain)
+			head->r.step = 0;
+			if (head->r.print_this_domain_only)
 				goto out;
 		}
 	}
+	head->r.domain = NULL;
  out:
-	head->read_eof = true;
+	head->r.eof = true;
 }
 
 /**
@@ -1543,19 +1561,22 @@
  */
 static void ccs_read_domain_profile(struct ccs_io_buffer *head)
 {
-	struct list_head *pos;
-	if (head->read_eof)
+	if (head->r.eof)
 		return;
-	list_for_each_cookie(pos, head->read_var1, &ccs_domain_list) {
-		struct ccs_domain_info *domain;
-		domain = list_entry(pos, struct ccs_domain_info, list);
+	list_for_each_cookie(head->r.domain, &ccs_domain_list) {
+		struct ccs_domain_info *domain =
+			list_entry(head->r.domain, struct ccs_domain_info,
+				   list);
 		if (domain->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, "%u %s\n", domain->profile,
-				   domain->domainname->name))
+		if (!ccs_flush(head))
 			return;
+		ccs_io_printf(head, "%u ", domain->profile);
+		ccs_set_string(head, domain->domainname->name);
+		ccs_set_lf(head);
 	}
-	head->read_eof = true;
+	head->r.domain = NULL;
+	head->r.eof = true;
 }
 
 /**
@@ -1567,7 +1588,7 @@
  */
 static int ccs_write_pid(struct ccs_io_buffer *head)
 {
-	head->read_eof = false;
+	head->r.eof = false;
 	return 0;
 }
 
@@ -1593,12 +1614,12 @@
 	u32 ccs_flags = 0;
 	/* Accessing write_buf is safe because head->io_sem is held. */
 	if (!buf) {
-		head->read_eof = true;
+		head->r.eof = true;
 		return; /* Do nothing if open(O_RDONLY). */
 	}
-	if (head->read_avail || head->read_eof)
+	if (head->r.w_pos || head->r.eof)
 		return;
-	head->read_eof = true;
+	head->r.eof = true;
 	if (ccs_str_starts(&buf, "info "))
 		task_info = true;
 	if (ccs_str_starts(&buf, "global-pid "))
@@ -1620,10 +1641,10 @@
 	ccs_tasklist_unlock();
 	if (!domain)
 		return;
-	if (!task_info)
-		ccs_io_printf(head, "%u %u %s", pid, domain->profile,
-			      domain->domainname->name);
-	else
+	if (!task_info) {
+		ccs_io_printf(head, "%u %u ", pid, domain->profile);
+		ccs_set_string(head, domain->domainname->name);
+	} else {
 		ccs_io_printf(head, "%u manager=%s execute_handler=%s "
 			      "state[0]=%u state[1]=%u state[2]=%u", pid,
 			      ccs_yesno(ccs_flags &
@@ -1633,6 +1654,7 @@
 			      (u8) (ccs_flags >> 24),
 			      (u8) (ccs_flags >> 16),
 			      (u8) (ccs_flags >> 8));
+	}
 }
 
 static const char *ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
@@ -1698,31 +1720,30 @@
  */
 static bool ccs_read_group(struct ccs_io_buffer *head, const int idx)
 {
-	struct list_head *gpos;
-	struct list_head *mpos;
-	const char *w[3] = { "", "", "" };
-	w[0] = ccs_group_name[idx];
-	list_for_each_cookie(gpos, head->read_var1, &ccs_group_list[idx]) {
+	list_for_each_cookie(head->r.group, &ccs_group_list[idx]) {
 		struct ccs_group *group =
-			list_entry(gpos, struct ccs_group, head.list);
-		w[1] = group->group_name->name;
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			char buffer[128];
+			list_entry(head->r.group, struct ccs_group, head.list);
+		list_for_each_cookie(head->r.acl, &group->member_list) {
 			struct ccs_acl_head *ptr =
-				list_entry(mpos, struct ccs_acl_head, list);
+				list_entry(head->r.acl, struct ccs_acl_head,
+					   list);
 			if (ptr->is_deleted)
 				continue;
-			w[2] = buffer;
+			if (!ccs_flush(head))
+				return false;
+			ccs_set_string(head, ccs_group_name[idx]);
+			ccs_set_string(head, group->group_name->name);
 			if (idx == CCS_PATH_GROUP) {
-				w[2] = container_of(ptr, struct ccs_path_group,
-						    head)->member_name->name;
+				ccs_set_space(head);
+				ccs_set_string(head, container_of
+					       (ptr, struct ccs_path_group,
+						head)->member_name->name);
 			} else if (idx == CCS_NUMBER_GROUP) {
-				ccs_print_number(buffer, sizeof(buffer),
-						 &container_of
-						 (ptr, struct ccs_number_group,
-						  head)->number);
+				ccs_print_number_union(head, &container_of
+						       (ptr, struct ccs_number_group,
+							head)->number);
 			} else if (idx == CCS_ADDRESS_GROUP) {
+				char buffer[128];
 				struct ccs_address_group *member =
 					container_of(ptr, typeof(*member),
 						     head);
@@ -1734,12 +1755,13 @@
 					ccs_print_ipv4(buffer, sizeof(buffer),
 						       member->min.ipv4,
 						       member->max.ipv4);
+				ccs_io_printf(head, " %s", buffer);
 			}
-			if (!ccs_io_printf(head, "%s%s %s\n", w[0], w[1],
-					   w[2]))
-				return false;
+			ccs_set_lf(head);
 		}
+		head->r.acl = NULL;
 	}
+	head->r.group = NULL;
 	return true;
 }
 
@@ -1755,51 +1777,52 @@
  */
 static bool ccs_read_policy(struct ccs_io_buffer *head, const int idx)
 {
-	struct list_head *pos;
-	list_for_each_cookie(pos, head->read_var2, &ccs_policy_list[idx]) {
-		const char *w[4] = { "", "", "", "" };
-		char buffer[16];
-		struct ccs_acl_head *acl = container_of(pos, typeof(*acl),
-							list);
+	list_for_each_cookie(head->r.acl, &ccs_policy_list[idx]) {
+		struct ccs_acl_head *acl =
+			container_of(head->r.acl, typeof(*acl), list);
 		if (acl->is_deleted)
 			continue;
+		if (!ccs_flush(head))
+			return false;
 		switch (idx) {
 		case CCS_ID_TRANSITION_CONTROL:
 			{
 				struct ccs_transition_control *ptr =
 					container_of(acl, typeof(*ptr), head);
-				w[0] = ccs_transition_type[ptr->type];
-				w[1] = ptr->program ? ptr->program->name
-					: "any";
-				w[2] = " from ";
-				w[3] = ptr->domainname ? ptr->domainname->name
-					: "any";
+				ccs_set_string(head,
+					       ccs_transition_type[ptr->type]);
+				ccs_set_string(head, ptr->program ?
+					       ptr->program->name : "any");
+				ccs_set_string(head, " from ");
+				ccs_set_string(head, ptr->domainname ?
+					       ptr->domainname->name : "any");
 			}
 			break;
 		case CCS_ID_AGGREGATOR:
 			{
 				struct ccs_aggregator *ptr =
 					container_of(acl, typeof(*ptr), head);
-				w[0] = CCS_KEYWORD_AGGREGATOR;
-				w[1] = ptr->original_name->name;
-				w[2] = " ";
-				w[3] = ptr->aggregated_name->name;
+				ccs_set_string(head, CCS_KEYWORD_AGGREGATOR);
+				ccs_set_string(head, ptr->original_name->name);
+				ccs_set_space(head);
+				ccs_set_string(head,
+					       ptr->aggregated_name->name);
 			}
 			break;
 		case CCS_ID_PATTERN:
 			{
 				struct ccs_pattern *ptr =
 					container_of(acl, typeof(*ptr), head);
-				w[0] = CCS_KEYWORD_FILE_PATTERN;
-				w[1] = ptr->pattern->name;
+				ccs_set_string(head, CCS_KEYWORD_FILE_PATTERN);
+				ccs_set_string(head, ptr->pattern->name);
 			}
 			break;
 		case CCS_ID_NO_REWRITE:
 			{
 				struct ccs_no_rewrite *ptr =
 					container_of(acl, typeof(*ptr), head);
-				w[0] = CCS_KEYWORD_DENY_REWRITE;
-				w[1] = ptr->pattern->name;
+				ccs_set_string(head, CCS_KEYWORD_DENY_REWRITE);
+				ccs_set_string(head, ptr->pattern->name);
 			}
 			break;
 		case CCS_ID_RESERVEDPORT:
@@ -1808,27 +1831,26 @@
 					container_of(acl, typeof(*ptr), head);
 				const u16 min_port = ptr->min_port;
 				const u16 max_port = ptr->max_port;
-				w[0] = CCS_KEYWORD_DENY_AUTOBIND;
-				snprintf(buffer, sizeof(buffer) - 1, "%u%c%u",
-					 min_port, min_port != max_port ?
-					 '-' : '\0', max_port);
-				buffer[sizeof(buffer) - 1] = '\0';
-				w[1] = buffer;
+				ccs_set_string(head,
+					       CCS_KEYWORD_DENY_AUTOBIND);
+				ccs_io_printf(head, "%u", min_port);
+				if (min_port != max_port)
+					ccs_io_printf(head, "-%u", max_port);
 			}
 			break;
 		default:
 			continue;
 		}
-		if (!ccs_io_printf(head, "%s%s%s%s\n", w[0], w[1], w[2], w[3]))
-			return false;
+		ccs_set_lf(head);
 	}
+	head->r.acl = NULL;
 	return true;
 }
 
 static void ccs_read_global_domain(struct ccs_io_buffer *head)
 {
-	if (!head->read_eof)
-		head->read_eof = ccs_read_domain2(head, &ccs_global_domain);
+	if (!head->r.eof)
+		head->r.eof = ccs_read_domain2(head, &ccs_global_domain);
 }
 
 /**
@@ -1840,17 +1862,17 @@
  */
 static void ccs_read_exception(struct ccs_io_buffer *head)
 {
-	if (head->read_eof)
+	if (head->r.eof)
 		return;
-	while (head->read_step < CCS_MAX_POLICY &&
-	       ccs_read_policy(head, head->read_step))
-		head->read_step++;
-	if (head->read_step < CCS_MAX_POLICY)
+	while (head->r.step < CCS_MAX_POLICY &&
+	       ccs_read_policy(head, head->r.step))
+		head->r.step++;
+	if (head->r.step < CCS_MAX_POLICY)
 		return;
-	while (head->read_step < CCS_MAX_POLICY + CCS_MAX_GROUP &&
-	       ccs_read_group(head, head->read_step - CCS_MAX_POLICY))
-		head->read_step++;
-	if (head->read_step < CCS_MAX_POLICY + CCS_MAX_GROUP)
+	while (head->r.step < CCS_MAX_POLICY + CCS_MAX_GROUP &&
+	       ccs_read_group(head, head->r.step - CCS_MAX_POLICY))
+		head->r.step++;
+	if (head->r.step < CCS_MAX_POLICY + CCS_MAX_GROUP)
 		return;
 	head->read = ccs_read_global_domain;
 }
@@ -1877,15 +1899,6 @@
 /* Number of "struct file" referring /proc/ccs/query interface. */
 static atomic_t ccs_query_observers = ATOMIC_INIT(0);
 
-static void ccs_addprintf(char *buffer, int len, const char *fmt, ...)
-{
-	va_list args;
-	const int pos = strlen(buffer);
-	va_start(args, fmt);
-	vsnprintf(buffer + pos, len - pos - 1, fmt, args);
-	va_end(args);
-}
-
 static void ccs_truncate(char *str)
 {
 	while (* (unsigned char *) str > (unsigned char) ' ')
@@ -2115,12 +2128,12 @@
 	int pos = 0;
 	int len = 0;
 	char *buf;
-	if (head->read_avail)
+	if (head->r.w_pos)
 		return;
 	if (head->read_buf) {
 		kfree(head->read_buf);
 		head->read_buf = NULL;
-		head->readbuf_size = 0;
+		//head->readbuf_size = 0;
 	}
 	spin_lock(&ccs_query_list_lock);
 	list_for_each(tmp, &ccs_query_list) {
@@ -2128,14 +2141,14 @@
 			= list_entry(tmp, struct ccs_query_entry, list);
 		if (ptr->answer)
 			continue;
-		if (pos++ != head->read_step)
+		if (pos++ != head->r.query_index)
 			continue;
 		len = ptr->query_len;
 		break;
 	}
 	spin_unlock(&ccs_query_list_lock);
 	if (!len) {
-		head->read_step = 0;
+		head->r.query_index = 0;
 		return;
 	}
 	buf = kzalloc(len, CCS_GFP_FLAGS);
@@ -2148,7 +2161,7 @@
 			= list_entry(tmp, struct ccs_query_entry, list);
 		if (ptr->answer)
 			continue;
-		if (pos++ != head->read_step)
+		if (pos++ != head->r.query_index)
 			continue;
 		/*
 		 * Some query can be skipped because ccs_query_list
@@ -2160,10 +2173,11 @@
 	}
 	spin_unlock(&ccs_query_list_lock);
 	if (buf[0]) {
-		head->read_avail = len;
-		head->readbuf_size = head->read_avail;
+		//head->r.avail = len;
+		//head->readbuf_size = head->r.avail;
 		head->read_buf = buf;
-		head->read_step++;
+		head->r.w[head->r.w_pos++] = buf;
+		head->r.query_index++;
 	} else {
 		kfree(buf);
 	}
@@ -2212,10 +2226,10 @@
  */
 static void ccs_read_version(struct ccs_io_buffer *head)
 {
-	if (head->read_eof)
+	if (head->r.eof)
 		return;
-	ccs_io_printf(head, "1.7.2");
-	head->read_eof = true;
+	ccs_set_string(head, "1.7.2");
+	head->r.eof = true;
 }
 
 /**
@@ -2225,14 +2239,14 @@
  */
 static void ccs_read_self_domain(struct ccs_io_buffer *head)
 {
-	if (head->read_eof)
+	if (head->r.eof)
 		return;
 	/*
 	 * ccs_current_domain()->domainname != NULL because every process
 	 * belongs to a domain and the domain's name cannot be NULL.
 	 */
 	ccs_io_printf(head, "%s", ccs_current_domain()->domainname->name);
-	head->read_eof = true;
+	head->r.eof = true;
 }
 
 /**
@@ -2391,9 +2405,8 @@
 int ccs_read_control(struct file *file, char __user *buffer,
 		     const int buffer_len)
 {
-	int len = 0;
+	int len;
 	struct ccs_io_buffer *head = file->private_data;
-	char *cp;
 	int idx;
 	if (!head->read)
 		return -ENOSYS;
@@ -2401,38 +2414,15 @@
 		return -EFAULT;
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
+	head->read_user_buf = buffer;
+	head->read_user_buf_avail = buffer_len;
 	idx = ccs_read_lock();
-	while (1) {
+	if (ccs_flush(head))
 		/* Call the policy handler. */
 		head->read(head);
-		/* Write to buffer. */
-		len = head->read_avail;
-		if (len || head->poll || head->read_eof)
-			break;
-		len = head->readbuf_size * 2;
-		cp = kzalloc(len, CCS_GFP_FLAGS);
-		if (!cp) {
-			len = -ENOMEM;
-			goto out;
-		}
-		kfree(head->read_buf);
-		head->read_buf = cp;
-		head->readbuf_size = len;
-	}
-	if (len > buffer_len)
-		len = buffer_len;
-	if (!len)
-		goto out;
-	/* head->read_buf changes by some functions. */
-	cp = head->read_buf;
-	if (copy_to_user(buffer, cp, len)) {
-		len = -EFAULT;
-		goto out;
-	}
-	head->read_avail -= len;
-	memmove(cp, cp + len, head->read_avail);
- out:
+	ccs_flush(head);
 	ccs_read_unlock(idx);
+	len = head->read_user_buf - buffer;
 	mutex_unlock(&head->io_sem);
 	return len;
 }
@@ -2471,14 +2461,14 @@
 	/* Read a line and dispatch it to the policy handler. */
 	while (avail_len > 0) {
 		char c;
-		if (head->write_avail >= head->writebuf_size - 1) {
+		if (head->w.avail >= head->writebuf_size - 1) {
 			const int len = head->writebuf_size * 2;
 			char *cp = kzalloc(len, CCS_GFP_FLAGS);
 			if (!cp) {
 				error = -ENOMEM;
 				break;
 			}
-			memmove(cp, cp0, head->write_avail);
+			memmove(cp, cp0, head->w.avail);
 			kfree(cp0);
 			head->write_buf = cp;
 			cp0 = cp;
@@ -2490,11 +2480,11 @@
 		}
 		buffer++;
 		avail_len--;
-		cp0[head->write_avail++] = c;
+		cp0[head->w.avail++] = c;
 		if (c != '\n')
 			continue;
-		cp0[head->write_avail - 1] = '\0';
-		head->write_avail = 0;
+		cp0[head->w.avail - 1] = '\0';
+		head->w.avail = 0;
 		ccs_normalize_line(cp0);
 		head->write(head);
 	}
