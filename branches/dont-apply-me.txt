Index: trunk/1.6.x/ccs-patch/include/linux/ccs_compat.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_compat.h	(revision 2535)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_compat.h	(working copy)
@@ -83,47 +83,20 @@
 			ret; })
 #endif
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
-#define smp_read_barrier_depends smp_rmb
+/*
+#ifndef list_for_each
+#define list_for_each(pos, head) \
+	for (pos = (head)->next; prefetch(pos->next), pos != (head); \
+	     pos = pos->next)
 #endif
 
-#ifndef ACCESS_ONCE
-#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
-#endif
-
-#ifndef rcu_dereference
-#define rcu_dereference(p)     ({ \
-				typeof(p) _________p1 = ACCESS_ONCE(p); \
-				smp_read_barrier_depends(); /* see RCU */ \
-				(_________p1); \
-				})
-#endif
-
-#ifndef rcu_assign_pointer
-#define rcu_assign_pointer(p, v) \
-	({ \
-		if (!__builtin_constant_p(v) || \
-		    ((v) != NULL)) \
-			smp_wmb(); /* see RCU */ \
-		(p) = (v); \
-	})
-#endif
-
-#ifndef list_for_each_rcu
-#define list_for_each_rcu(pos, head) \
-	for (pos = rcu_dereference((head)->next); \
-		prefetch(pos->next), pos != (head); \
-		pos = rcu_dereference(pos->next))
-#endif
-
-#ifndef list_for_each_entry_rcu
-#define list_for_each_entry_rcu(pos, head, member) \
-	for (pos = list_entry(rcu_dereference((head)->next), typeof(*pos), \
-		member); \
+#ifndef list_for_each_entry
+#define list_for_each_entry(pos, head, member) \
+	for (pos = list_entry((head)->next, typeof(*pos), member); \
 		prefetch(pos->member.next), &pos->member != (head); \
-		pos = list_entry(rcu_dereference(pos->member.next), \
-		typeof(*pos), member))
+		pos = list_entry(pos->member.next, typeof(*pos), member))
 #endif
+*/
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 #define s_fs_info u.generic_sbp
Index: trunk/1.6.x/ccs-patch/include/linux/ccs_common.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(revision 2535)
+++ trunk/1.6.x/ccs-patch/include/linux/ccs_common.h	(working copy)
@@ -37,6 +37,7 @@
 #else
 #include <linux/hardirq.h>
 #endif
+#include <linux/in6.h>
 
 struct dentry;
 struct vfsmount;
@@ -44,80 +45,38 @@
 extern asmlinkage long sys_getpid(void);
 extern asmlinkage long sys_getppid(void);
 
-#include <linux/ccs_compat.h>
-
-/*
- * Singly linked list.
- *
- * This list holds ACL entries used for access control.
- * Since TOMOYO Linux performs string pattern matching which takes long time,
- * I don't want to take any locks which disable preemption.
- * Threfore, I use singly linked list that cannot delete an element
- * but can make the code read-lock free.
- * This is OK because ACL entries in this list are seldom deleted.
- * You don't append garbage ACL entries without reasons, do you?
- */
-struct list1_head {
-	struct list1_head *next;
+struct ccs_domain_info;
+struct ccs_path_info;
+struct ccs_cookie {
+	struct list_head list;
+	union {
+		const void *ptr;
+		struct list_head *list;
+		struct ccs_domain_info *domain;
+		const struct ccs_path_info *path;
+	} u;
 };
 
-#define LIST1_HEAD_INIT(name) { &(name) }
-#define LIST1_HEAD(name) struct list1_head name = LIST1_HEAD_INIT(name)
+#include <linux/ccs_compat.h>
 
-static inline void INIT_LIST1_HEAD(struct list1_head *list)
-{
-	list->next = list;
-}
-
-/* Reuse list_entry because it doesn't use "->prev" pointer. */
-#define list1_entry list_entry
-
-/* Reuse list_for_each_rcu because it doesn't use "->prev" pointer. */
-#define list1_for_each list_for_each_rcu
-
-/* Reuse list_for_each_entry_rcu because it doesn't use "->prev" pointer. */
-#define list1_for_each_entry list_for_each_entry_rcu
-
 /**
- * list1_for_each_cookie - iterate over a list with cookie.
- * @pos:        the &struct list1_head to use as a loop cursor.
- * @cookie:     the &struct list1_head to use as a cookie.
+ * list_for_each_cookie - iterate over a list with cookie.
+ * @pos:        the &struct list_head to use as a loop cursor.
+ * @cookie:     the &struct list_head to use as a cookie.
  * @head:       the head for your list.
  *
- * Same with list_for_each_rcu() except that this primitive uses @cookie
+ * Same with list_for_each() except that this primitive uses @cookie
  * so that we can continue iteration.
  * @cookie must be NULL when iteration starts, and @cookie will become
  * NULL when iteration finishes.
- *
- * Since list elements are never removed, we don't need to get a lock
- * or a reference count.
  */
-#define list1_for_each_cookie(pos, cookie, head)                      \
+#define list_for_each_cookie(pos, cookie, head)                       \
 	for (({ if (!cookie)                                          \
 				     cookie = head; }),               \
-	     pos = rcu_dereference((cookie)->next);                   \
+	     pos = (cookie)->next;                                    \
 	     prefetch(pos->next), pos != (head) || ((cookie) = NULL); \
-	     (cookie) = pos, pos = rcu_dereference(pos->next))
+	     (cookie) = pos, pos = pos->next)
 
-/**
- * list_add_tail_mb - add a new entry with memory barrier.
- * @new: new entry to be added.
- * @head: list head to add it before.
- *
- * Same with list_add_tail_rcu() except that this primitive uses mb()
- * so that we can traverse forwards using list1_for_each() and
- * list1_for_each_cookie().
- */
-static inline void list1_add_tail_mb(struct list1_head *new,
-				     struct list1_head *head)
-{
-	struct list1_head *prev = head;
-	new->next = head;
-	while (prev->next != head)
-		prev = prev->next;
-	rcu_assign_pointer(prev->next, new);
-}
-
 /* Subset of "struct stat". */
 struct ccs_mini_stat {
 	uid_t uid;
@@ -153,12 +112,15 @@
 
 /* Structure for " if " and "; set" part. */
 struct ccs_condition_list {
-	struct list1_head list;
-	u16 condc;
-	u16 argc;
-	u16 envc;
-	u16 symlinkc;
-	u8 post_state[4];
+	struct list_head list;
+	atomic_t users;
+	struct {
+		u16 condc;
+		u16 argc;
+		u16 envc;
+		u16 symlinkc;
+		u8 post_state[4];
+	} head;
 	/* "unsigned long condition[condc]" follows here. */
 	/* "struct ccs_argv_entry argv[argc]" follows here. */
 	/* "struct ccs_envp_entry envp[envc]" follows here. */
@@ -169,7 +131,8 @@
 
 /* Structure for request info. */
 struct ccs_request_info {
-	struct ccs_domain_info *domain;
+	struct ccs_cookie cookie;
+	//struct ccs_domain_info *domain;
 	struct ccs_obj_info *obj;
 	struct ccs_execve_entry *ee;
 	const struct ccs_condition_list *cond;
@@ -207,10 +170,9 @@
 	struct ccs_request_info r;
 	struct ccs_obj_info obj;
 	struct linux_binprm *bprm;
+	struct ccs_cookie cookie;
 	/* For execute_handler */
 	const struct ccs_path_info *handler;
-	/* For calculating domain to transit to. */
-	struct ccs_domain_info *next_domain; /* Initialized to NULL. */
 	char *program_path; /* Size is CCS_MAX_PATHNAME_LEN bytes */
 	/* For dumping argv[] and envp[]. */
 	struct ccs_page_dump dump;
@@ -220,21 +182,22 @@
 
 /* Structure for "path_group" directive. */
 struct ccs_path_group_member {
-	struct list1_head list;
+	struct list_head list;
 	const struct ccs_path_info *member_name;
 	bool is_deleted;
 };
 
 /* Structure for "path_group" directive. */
 struct ccs_path_group_entry {
-	struct list1_head list;
+	struct list_head list;
 	const struct ccs_path_info *group_name;
-	struct list1_head path_group_member_list;
+	struct list_head path_group_member_list;
+	atomic_t users;
 };
 
 /* Structure for "address_group" directive. */
 struct ccs_address_group_member {
-	struct list1_head list;
+	struct list_head list;
 	union {
 		u32 ipv4;                    /* Host byte order    */
 		const struct in6_addr *ipv6; /* Network byte order */
@@ -245,9 +208,10 @@
 
 /* Structure for "address_group" directive. */
 struct ccs_address_group_entry {
-	struct list1_head list;
+	struct list_head list;
 	const struct ccs_path_info *group_name;
-	struct list1_head address_group_member_list;
+	struct list_head address_group_member_list;
+	atomic_t users;
 };
 
 /* Structure for holding requested pathname. */
@@ -261,18 +225,12 @@
 
 /* Common header for holding ACL entries. */
 struct ccs_acl_info {
+	struct list_head list;
+	const struct ccs_condition_list *cond;
 	/*
-	 * Keep "access_me_via_ccs_get_condition_part" first, for
-	 * memory for this filed is not allocated if
-	 * (type & ACL_WITH_CONDITION) == 0.
-	 */
-	const struct ccs_condition_list *access_me_via_ccs_get_condition_part;
-	struct list1_head list;
-	/*
 	 * Type of this ACL entry.
 	 *
 	 * MSB is is_deleted flag.
-	 * Next bit is with_condition flag.
 	 */
 	u8 type;
 } __attribute__((__packed__));
@@ -293,42 +251,144 @@
 
 /* This ACL entry is deleted.           */
 #define ACL_DELETED        0x80
-/* This ACL entry has conditional part. */
-#define ACL_WITH_CONDITION 0x40
 
 /* Structure for domain information. */
 struct ccs_domain_info {
-	struct list1_head list;
-	struct list1_head acl_info_list;
+	struct list_head list;
+	struct list_head acl_info_list;
 	/* Name of this domain. Never NULL.          */
 	const struct ccs_path_info *domainname;
 	u8 profile;        /* Profile number to use. */
 	bool is_deleted;   /* Delete flag.           */
 	bool quota_warned; /* Quota warnning flag.   */
-	/* DOMAIN_FLAGS_*. Use ccs_set_domain_flag() to modify. */
-	u8 flags;
+	/* Ignore "allow_read" directive in exception policy. */
+	bool ignore_global_allow_read;
+	/* Ignore "allow_env" directive in exception policy.  */
+	bool ignore_global_allow_env;
+	/*
+	 * This domain was unable to create a new domain at
+	 * ccs_find_next_domain() because the name of the domain to be created
+	 * was too long or it could not allocate memory.
+	 * More than one process continued execve() without domain transition.
+	 */
+	bool domain_transition_failed;
 };
 
 /* Profile number is an integer between 0 and 255. */
 #define MAX_PROFILES 256
 
-/* Ignore "allow_read" directive in exception policy. */
-#define DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ 1
-/* Ignore "allow_env" directive in exception policy.  */
-#define DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV  2
-/*
- * This domain was unable to create a new domain at ccs_find_next_domain()
- * because the name of the domain to be created was too long or
- * it could not allocate memory.
- * More than one process continued execve() without domain transition.
- */
-#define DOMAIN_FLAGS_TRANSITION_FAILED        4
-
 #define CCS_CHECK_READ_FOR_OPEN_EXEC    1
 #define CCS_DONT_SLEEP_ON_ENFORCE_ERROR 2
 #define CCS_TASK_IS_EXECUTE_HANDLER     4
 #define CCS_TASK_IS_POLICY_MANAGER      8
 
+/* Structure for "allow_read" keyword. */
+struct ccs_globally_readable_file_entry {
+	struct list_head list;
+	const struct ccs_path_info *filename;
+	bool is_deleted;
+};
+
+/* Structure for "file_pattern" keyword. */
+struct ccs_pattern_entry {
+	struct list_head list;
+	const struct ccs_path_info *pattern;
+	bool is_deleted;
+};
+
+/* Structure for "deny_rewrite" keyword. */
+struct ccs_no_rewrite_entry {
+	struct list_head list;
+	const struct ccs_path_info *pattern;
+	bool is_deleted;
+};
+
+/* Structure for "allow_env" keyword. */
+struct ccs_globally_usable_env_entry {
+	struct list_head list;
+	const struct ccs_path_info *env;
+	bool is_deleted;
+};
+
+/* Structure for "initialize_domain" and "no_initialize_domain" keyword. */
+struct ccs_domain_initializer_entry {
+	struct list_head list;
+	const struct ccs_path_info *domainname;    /* This may be NULL */
+	const struct ccs_path_info *program;
+	bool is_deleted;
+	bool is_not;       /* True if this entry is "no_initialize_domain".  */
+	bool is_last_name; /* True if the domainname is ccs_get_last_name(). */
+};
+
+/* Structure for "keep_domain" and "no_keep_domain" keyword. */
+struct ccs_domain_keeper_entry {
+	struct list_head list;
+	const struct ccs_path_info *domainname;
+	const struct ccs_path_info *program;       /* This may be NULL */
+	bool is_deleted;
+	bool is_not;       /* True if this entry is "no_keep_domain".        */
+	bool is_last_name; /* True if the domainname is ccs_get_last_name(). */
+};
+
+/* Structure for "aggregator" keyword. */
+struct ccs_aggregator_entry {
+	struct list_head list;
+	const struct ccs_path_info *original_name;
+	const struct ccs_path_info *aggregated_name;
+	bool is_deleted;
+};
+
+/* Structure for "alias" keyword. */
+struct ccs_alias_entry {
+	struct list_head list;
+	const struct ccs_path_info *original_name;
+	const struct ccs_path_info *aliased_name;
+	bool is_deleted;
+};
+
+/* Structure for "deny_unmount" keyword. */
+struct ccs_no_umount_entry {
+	struct list_head list;
+	const struct ccs_path_info *dir;
+	bool is_deleted;
+};
+
+/* Structure for "allow_pivot_root" keyword. */
+struct ccs_pivot_root_entry {
+	struct list_head list;
+	const struct ccs_path_info *old_root;
+	const struct ccs_path_info *new_root;
+	bool is_deleted;
+};
+
+/* Structure for "allow_mount" keyword. */
+struct ccs_mount_entry {
+	struct list_head list;
+	const struct ccs_path_info *dev_name;
+	const struct ccs_path_info *dir_name;
+	const struct ccs_path_info *fs_type;
+	unsigned long flags;
+	bool is_deleted;
+};
+
+/* Structure for "allow_chroot" keyword. */
+struct ccs_chroot_entry {
+	struct list_head list;
+	const struct ccs_path_info *dir;
+	bool is_deleted;
+};
+
+/* Structure for policy manager. */
+struct ccs_policy_manager_entry {
+	struct list_head list;
+	/* A path to program or a domainname. */
+	const struct ccs_path_info *manager;
+	bool is_domain;  /* True if manager is a domainname. */
+	bool is_deleted; /* True if this entry is deleted. */
+};
+
+///
+
 /*
  * Structure for "execute_handler" and "denied_execute_handler" directive.
  * These directives can exist only one entry in a domain.
@@ -363,10 +423,11 @@
 	bool u_is_group; /* True if u points to "path_group" directive. */
 	u16 perm;
 	union {
+		const void *ptr;
 		/* Pointer to single pathname. */
 		const struct ccs_path_info *filename;
 		/* Pointer to pathname group. */
-		const struct ccs_path_group_entry *group;
+		struct ccs_path_group_entry *group;
 	} u;
 };
 
@@ -377,16 +438,18 @@
 	bool u1_is_group; /* True if u1 points to "path_group" directive. */
 	bool u2_is_group; /* True if u2 points to "path_group" directive. */
 	union {
+		const void *ptr;
 		/* Pointer to single pathname. */
 		const struct ccs_path_info *filename1;
 		/* Pointer to pathname group. */
-		const struct ccs_path_group_entry *group1;
+		struct ccs_path_group_entry *group1;
 	} u1;
 	union {
+		const void *ptr;
 		/* Pointer to single pathname. */
 		const struct ccs_path_info *filename2;
 		/* Pointer to pathname group. */
-		const struct ccs_path_group_entry *group2;
+		struct ccs_path_group_entry *group2;
 	} u2;
 };
 
@@ -397,10 +460,11 @@
 	unsigned int cmd_max;
 	bool u_is_group; /* True if u points to "path_group" directive. */
 	union {
+		const void *ptr;
 		/* Pointer to single pathname. */
 		const struct ccs_path_info *filename;
 		/* Pointer to pathname group. */
-		const struct ccs_path_group_entry *group;
+		struct ccs_path_group_entry *group;
 	} u;
 };
 
@@ -431,6 +495,12 @@
 	const struct ccs_path_info *domainname;
 };
 
+struct ccs_addr_entry {
+	struct list_head list;
+	atomic_t users;
+	struct in6_addr addr;
+};
+
 /* Structure for "allow_network" directive. */
 struct ccs_ip_network_acl_record {
 	struct ccs_acl_info head; /* type = TYPE_IP_NETWORK_ACL */
@@ -476,7 +546,7 @@
 			const struct in6_addr *max;
 		} ipv6;
 		/* Pointer to address group. */
-		const struct ccs_address_group_entry *group;
+		struct ccs_address_group_entry *group;
 	} u;
 };
 
@@ -604,11 +674,11 @@
 	/* Exclusive lock for this structure.   */
 	struct mutex io_sem;
 	/* The position currently reading from. */
-	struct list1_head *read_var1;
+	struct ccs_cookie read_var1;
 	/* Extra variables for reading.         */
-	struct list1_head *read_var2;
+	struct ccs_cookie read_var2;
 	/* The position currently writing to.   */
-	struct ccs_domain_info *write_var1;
+	struct ccs_cookie write_var1;
 	/* The step for reading.                */
 	int read_step;
 	/* Buffer for reading.                  */
@@ -828,18 +898,15 @@
 int ccs_write_control(struct file *file, const char __user *buffer,
 		      const int buffer_len);
 /* Find a domain by the given name. */
-struct ccs_domain_info *ccs_find_domain(const char *domainname);
+bool ccs_find_domain(const char *domainname, struct ccs_cookie *cookie);
 /* Find or create a domain by the given name. */
-struct ccs_domain_info *ccs_find_or_assign_new_domain(const char *domainname,
-						  const u8 profile);
+bool ccs_find_or_assign_new_domain(const char *domainname, const u8 profile,
+				   struct ccs_cookie *cookie);
 /* Check mode for specified functionality. */
 unsigned int ccs_check_flags(const struct ccs_domain_info *domain,
 			     const u8 index);
 /* Check whether it is safe to sleep. */
 bool ccs_can_sleep(void);
-/* Allocate memory for structures. */
-void *ccs_alloc_acl_element(const u8 acl_type,
-			    const struct ccs_condition_list *condition);
 /* Fill in "struct ccs_path_info" members. */
 void ccs_fill_path_info(struct ccs_path_info *ptr);
 /* Fill in "struct ccs_request_info" members. */
@@ -850,9 +917,6 @@
 /* Print an IPv6 address. */
 void ccs_print_ipv6(char *buffer, const int buffer_len,
 		    const struct in6_addr *ip);
-/* Change "struct ccs_domain_info"->flags. */
-void ccs_set_domain_flag(struct ccs_domain_info *domain, const bool is_delete,
-			 const u8 flags);
 /* Update the policy change counter. */
 void ccs_update_counter(const unsigned char index);
 
@@ -866,6 +930,11 @@
 int ccs_check_exec_perm(struct ccs_request_info *r,
 			const struct ccs_path_info *filename);
 
+/* Delete memory for "struct ccs_path_group_entry". */
+void ccs_put_path_group(struct ccs_path_group_entry *group);
+/* Delete memory for "struct ccs_address_group_entry". */
+void ccs_put_address_group(struct ccs_address_group_entry *group);
+
 /* strcmp() for "struct ccs_path_info" structure. */
 static inline bool ccs_pathcmp(const struct ccs_path_info *a,
 			       const struct ccs_path_info *b)
@@ -876,13 +945,13 @@
 /* Get type of an ACL entry. */
 static inline u8 ccs_acl_type1(struct ccs_acl_info *ptr)
 {
-	return ptr->type & ~(ACL_DELETED | ACL_WITH_CONDITION);
+	return ptr->type & ~ACL_DELETED;
 }
 
 /* Get type of an ACL entry. */
 static inline u8 ccs_acl_type2(struct ccs_acl_info *ptr)
 {
-	return ptr->type & ~ACL_WITH_CONDITION;
+	return ptr->type;
 }
 
 /**
@@ -895,12 +964,32 @@
 static inline const struct ccs_condition_list *
 ccs_get_condition_part(const struct ccs_acl_info *acl)
 {
-	return (acl->type & ACL_WITH_CONDITION) ?
-		acl->access_me_via_ccs_get_condition_part : NULL;
+	return acl->cond;
 }
 
+/* Lock for protecting policy. */
+extern struct rw_semaphore ccs_policy_lock;
 /* A linked list of domains. */
-extern struct list1_head ccs_domain_list;
+extern struct list_head ccs_domain_list;
+
+extern struct list_head ccs_mount_list;
+extern struct list_head ccs_address_group_list;
+extern struct list_head ccs_globally_readable_list;
+extern struct list_head ccs_path_group_list;
+extern struct list_head ccs_pattern_list;
+extern struct list_head ccs_no_rewrite_list;
+extern struct list_head ccs_globally_usable_env_list;
+extern struct list_head ccs_domain_initializer_list;
+extern struct list_head ccs_domain_keeper_list;
+extern struct list_head ccs_alias_list;
+extern struct list_head ccs_aggregator_list;
+extern struct list_head ccs_condition_list;
+extern struct list_head ccs_no_umount_list;
+extern struct list_head ccs_pivot_root_list;
+extern struct list_head ccs_chroot_list;
+extern struct list_head ccs_reservedport_list;
+extern struct list_head ccs_policy_manager_list;
+
 /* Has /sbin/init started? */
 extern bool ccs_policy_loaded;
 /* Log level for printk(). */
Index: trunk/1.6.x/ccs-patch/include/linux/realpath.h
===================================================================
--- trunk/1.6.x/ccs-patch/include/linux/realpath.h	(revision 2535)
+++ trunk/1.6.x/ccs-patch/include/linux/realpath.h	(working copy)
@@ -39,21 +39,21 @@
 /* Encode binary string to ascii string. */
 char *ccs_encode(const char *str);
 
-/*
- * Allocate memory for ACL entry.
- * The RAM is chunked, so NEVER try to kfree() the returned pointer.
- */
-void *ccs_alloc_element(const unsigned int size);
+/*  Check memory quota. */
+bool ccs_memory_ok(const void *ptr);
 
-/*
- * Keep the given name on the RAM.
- * The RAM is shared, so NEVER try to modify or kfree() the returned name.
- */
-const struct ccs_path_info *ccs_save_name(const char *name);
+/* Allocate memory for the given name. */
+const struct ccs_path_info *ccs_get_name(const char *name);
+/* Delete memory for the given name. */
+void ccs_put_name(const struct ccs_path_info *name);
 
+/* Allocate memory for the given IPv6 address. */
+const struct in6_addr *ccs_get_ipv6_address(const struct in6_addr *addr);
+/* Delete memory for the given IPv6 address. */
+void ccs_put_ipv6_address(const struct in6_addr *addr);
+
 /* Allocate memory for temporary use (e.g. permission checks). */
 void *ccs_alloc(const size_t size, const _Bool check_quota);
-
 /* Free memory allocated by ccs_alloc(). */
 void ccs_free(const void *p);
 
@@ -63,4 +63,27 @@
 /* Set memory quota. */
 int ccs_write_memory_quota(struct ccs_io_buffer *head);
 
+/* Add a cookie to cookie list. */
+void ccs_add_cookie(struct ccs_cookie *cookie, const void *ptr);
+/**
+ * ccs_update_cookie - Assign the given pointer to a cookie.
+ *
+ * @cookie: Pointer to "struct ccs_cookie".
+ * @ptr:    Pointer to assign.
+ *
+ * Caller must hold ccs_policy_lock for reading unless either
+ *   (a) @ptr is NULL
+ *   (b) @ptr is already in cookie list
+ *   (c) @ptr is not in memory for the policy
+ *   (d) in the initialization phase
+ * is true.
+ */
+static inline void ccs_update_cookie(struct ccs_cookie *cookie,
+				     const void *ptr)
+{
+	cookie->u.ptr = ptr;
+}
+/* Delete a cookie from cookie list. */
+void ccs_del_cookie(struct ccs_cookie *cookie);
+
 #endif
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_env.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_env.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_env.c	(working copy)
@@ -32,15 +32,8 @@
 				   env);
 }
 
-/* Structure for "allow_env" keyword. */
-struct ccs_globally_usable_env_entry {
-	struct list1_head list;
-	const struct ccs_path_info *env;
-	bool is_deleted;
-};
-
 /* The list for "struct ccs_globally_usable_env_entry". */
-static LIST1_HEAD(ccs_globally_usable_env_list);
+LIST_HEAD(ccs_globally_usable_env_list);
 
 /**
  * ccs_update_globally_usable_env_entry - Update "struct ccs_globally_usable_env_entry" list.
@@ -53,36 +46,37 @@
 static int ccs_update_globally_usable_env_entry(const char *env,
 						const bool is_delete)
 {
-	struct ccs_globally_usable_env_entry *new_entry;
+	struct ccs_globally_usable_env_entry *entry = NULL;
 	struct ccs_globally_usable_env_entry *ptr;
-	static DEFINE_MUTEX(lock);
 	const struct ccs_path_info *saved_env;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(env, 0, 0, 0, __func__) || strchr(env, '='))
 		return -EINVAL;
-	saved_env = ccs_save_name(env);
+	saved_env = ccs_get_name(env);
 	if (!saved_env)
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_globally_usable_env_list, list) {
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_globally_usable_env_list, list) {
 		if (ptr->env != saved_env)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->env = saved_env;
+		saved_env = NULL;
+		list_add_tail(&entry->list, &ccs_globally_usable_env_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->env = saved_env;
-	list1_add_tail_mb(&new_entry->list, &ccs_globally_usable_env_list);
-	error = 0;
- out:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_env);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
@@ -98,11 +92,18 @@
 static bool ccs_is_globally_usable_env(const struct ccs_path_info *env)
 {
 	struct ccs_globally_usable_env_entry *ptr;
-	list1_for_each_entry(ptr, &ccs_globally_usable_env_list, list) {
-		if (!ptr->is_deleted && ccs_path_matches_pattern(env, ptr->env))
-			return true;
+	bool found = false;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_globally_usable_env_list, list) {
+		if (ptr->is_deleted || !ccs_path_matches_pattern(env, ptr->env))
+			continue;
+		found = true;
+		break;
 	}
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return found;
 }
 
 /**
@@ -127,21 +128,25 @@
  */
 bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2,
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list,
 			      &ccs_globally_usable_env_list) {
 		struct ccs_globally_usable_env_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_globally_usable_env_entry,
+		ptr = list_entry(pos, struct ccs_globally_usable_env_entry,
 				  list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, KEYWORD_ALLOW_ENV "%s\n",
-				   ptr->env->name))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_ALLOW_ENV "%s\n",
+				     ptr->env->name);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
 
 /**
@@ -158,21 +163,23 @@
 				const struct ccs_condition_list *condition,
 				const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
+	struct ccs_env_acl_record *entry = NULL;
 	struct ccs_acl_info *ptr;
-	struct ccs_env_acl_record *acl;
 	const struct ccs_path_info *saved_env;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(env, 0, 0, 0, __func__) || strchr(env, '='))
 		return -EINVAL;
-	saved_env = ccs_save_name(env);
+	saved_env = ccs_get_name(env);
 	if (!saved_env)
 		return -ENOMEM;
 
-	mutex_lock(&lock);
 	if (is_delete)
 		goto delete;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_env_acl_record *acl;
 		if (ccs_acl_type1(ptr) != TYPE_ENV_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
@@ -181,18 +188,24 @@
 		if (acl->env != saved_env)
 			continue;
 		error = ccs_add_domain_acl(NULL, ptr);
-		goto out;
+		break;
 	}
-	/* Not found. Append it to the tail. */
-	acl = ccs_alloc_acl_element(TYPE_ENV_ACL, condition);
-	if (!acl)
-		goto out;
-	acl->env = saved_env;
-	error = ccs_add_domain_acl(domain, &acl->head);
+	if (error && ccs_memory_ok(entry)) {
+		entry->head.type = TYPE_ENV_ACL;
+		entry->head.cond = condition;
+		entry->env = saved_env;
+		saved_env = NULL;
+		error = ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	goto out;
  delete:
-	error = -ENOENT;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_env_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_ENV_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
@@ -203,8 +216,11 @@
 		error = ccs_del_domain_acl(ptr);
 		break;
 	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	ccs_put_name(saved_env);
+	kfree(entry);
 	return error;
 }
 
@@ -218,13 +234,14 @@
  */
 static int ccs_check_env_acl(struct ccs_request_info *r, const char *environ)
 {
-	const struct ccs_domain_info *domain = r->domain;
+	const struct ccs_domain_info *domain = r->cookie.u.domain;
 	int error = -EPERM;
 	struct ccs_acl_info *ptr;
 	struct ccs_path_info env;
 	env.name = environ;
 	ccs_fill_path_info(&env);
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct ccs_env_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_ENV_ACL)
 			continue;
@@ -236,8 +253,8 @@
 		error = 0;
 		break;
 	}
-	if (error &&
-	    (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV) == 0 &&
+	up_read(&ccs_policy_lock);
+	if (error && !domain->ignore_global_allow_env &&
 	    ccs_is_globally_usable_env(&env))
 		error = 0;
 	return error;
@@ -264,18 +281,19 @@
 	ccs_audit_env_log(r, env, !error);
 	if (!error)
 		return 0;
-	if (ccs_verbose_mode(r->domain))
+	if (ccs_verbose_mode(r->cookie.u.domain))
 		printk(KERN_WARNING "TOMOYO-%s: Environ %s denied for %s\n",
 		       ccs_get_msg(is_enforce), env,
-		       ccs_get_last_name(r->domain));
+		       ccs_get_last_name(r->cookie.u.domain));
 	if (is_enforce) {
 		error = ccs_check_supervisor(r, KEYWORD_ALLOW_ENV "%s\n", env);
 		if (error == 1)
 			goto retry;
 		return error;
 	}
-	if (r->mode == 1 && ccs_domain_quota_ok(r->domain))
-		ccs_update_env_entry(env, r->domain, ccs_handler_cond(), false);
+	if (r->mode == 1 && ccs_domain_quota_ok(r->cookie.u.domain))
+		ccs_update_env_entry(env, r->cookie.u.domain,
+				     ccs_handler_cond(), false);
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_network.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_network.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_network.c	(working copy)
@@ -55,55 +55,57 @@
 				   "%s %s %u\n", operation, address, port);
 }
 
+/* The list for "struct ccs_address_group_entry". */
+LIST_HEAD(ccs_address_group_list);
+
 /**
- * ccs_save_ipv6_address - Keep the given IPv6 address on the RAM.
+ * ccs_get_address_group - Allocate memory for "struct ccs_address_group_entry".
  *
- * @addr: Pointer to "struct in6_addr".
+ * @group_name: The name of address group.
  *
- * Returns pointer to "struct in6_addr" on success, NULL otherwise.
- *
- * The RAM is shared, so NEVER try to modify or kfree() the returned address.
+ * Returns pointer to "struct ccs_address_group_entry" on success,
+ * NULL otherwise.
  */
-static const struct in6_addr *ccs_save_ipv6_address(const struct in6_addr *addr)
+static struct ccs_address_group_entry *ccs_get_address_group(const char *
+							     group_name)
 {
-	static const u8 ccs_block_size = 16;
-	struct ccs_addr_list {
-		/* Workaround for gcc 4.3's bug. */
-		struct in6_addr addr[16]; /* = ccs_block_size */
-		struct list1_head list;
-		u32 in_use_count;
-	};
-	static LIST1_HEAD(ccs_address_list);
-	struct ccs_addr_list *ptr;
-	static DEFINE_MUTEX(lock);
-	u8 i = ccs_block_size;
-	if (!addr)
+	struct ccs_address_group_entry *entry = NULL;
+	struct ccs_address_group_entry *group;
+	const struct ccs_path_info *saved_group_name;
+	int error = -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0, __func__) ||
+	    !group_name[0])
 		return NULL;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_address_list, list) {
-		for (i = 0; i < ptr->in_use_count; i++) {
-			if (!memcmp(&ptr->addr[i], addr, sizeof(*addr)))
-				goto ok;
-		}
-		if (i < ccs_block_size)
-			break;
+	saved_group_name = ccs_get_name(group_name);
+	if (!saved_group_name)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(group, &ccs_address_group_list, list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		atomic_inc(&group->users);
+		error = 0;
+		break;
 	}
-	if (i == ccs_block_size) {
-		ptr = ccs_alloc_element(sizeof(*ptr));
-		if (!ptr)
-			goto ok;
-		list1_add_tail_mb(&ptr->list, &ccs_address_list);
-		i = 0;
+	if (error && ccs_memory_ok(entry)) {
+		INIT_LIST_HEAD(&entry->address_group_member_list);
+		entry->group_name = saved_group_name;
+		saved_group_name = NULL;
+		atomic_set(&entry->users, 1);
+		list_add_tail(&entry->list, &ccs_address_group_list);
+		group = entry;
+		entry = NULL;
+		error = 0;
 	}
-	ptr->addr[ptr->in_use_count++] = *addr;
- ok:
-	mutex_unlock(&lock);
-	return ptr ? &ptr->addr[i] : NULL;
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_group_name);
+	kfree(entry);
+	return !error ? group : NULL;
 }
 
-/* The list for "struct ccs_address_group_entry". */
-static LIST1_HEAD(ccs_address_group_list);
-
 /**
  * ccs_update_address_group_entry - Update "struct ccs_address_group_entry" list.
  *
@@ -121,85 +123,67 @@
 					  const u16 *max_address,
 					  const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
-	struct ccs_address_group_entry *new_group;
 	struct ccs_address_group_entry *group;
-	struct ccs_address_group_member *new_member;
+	struct ccs_address_group_member *entry = NULL;
 	struct ccs_address_group_member *member;
-	const struct ccs_path_info *saved_group_name;
 	const struct in6_addr *saved_min_address = NULL;
 	const struct in6_addr *saved_max_address = NULL;
-	int error = -ENOMEM;
-	bool found = false;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	const u32 min_ipv4_address = ntohl(*(u32 *) min_address);
 	const u32 max_ipv4_address = ntohl(*(u32 *) max_address);
-	if (!ccs_is_correct_path(group_name, 0, 0, 0, __func__) ||
-	    !group_name[0])
-		return -EINVAL;
-	saved_group_name = ccs_save_name(group_name);
-	if (!saved_group_name)
+	group = ccs_get_address_group(group_name);
+	if (!group)
 		return -ENOMEM;
 	if (!is_ipv6)
 		goto not_ipv6;
 	saved_min_address
-		= ccs_save_ipv6_address((struct in6_addr *) min_address);
+		= ccs_get_ipv6_address((struct in6_addr *) min_address);
 	saved_max_address
-		= ccs_save_ipv6_address((struct in6_addr *) max_address);
+		= ccs_get_ipv6_address((struct in6_addr *) max_address);
 	if (!saved_min_address || !saved_max_address)
-		return -ENOMEM;
+		goto out;
  not_ipv6:
-	mutex_lock(&lock);
-	list1_for_each_entry(group, &ccs_address_group_list, list) {
-		if (saved_group_name != group->group_name)
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(member, &group->address_group_member_list, list) {
+		if (member->is_ipv6 != is_ipv6)
 			continue;
-		list1_for_each_entry(member, &group->address_group_member_list,
-				     list) {
-			if (member->is_ipv6 != is_ipv6)
+		if (is_ipv6) {
+			if (member->min.ipv6 != saved_min_address ||
+			    member->max.ipv6 != saved_max_address)
 				continue;
-			if (is_ipv6) {
-				if (member->min.ipv6 != saved_min_address ||
-				    member->max.ipv6 != saved_max_address)
-					continue;
-			} else {
-				if (member->min.ipv4 != min_ipv4_address ||
-				    member->max.ipv4 != max_ipv4_address)
-					continue;
-			}
-			member->is_deleted = is_delete;
-			error = 0;
-			goto out;
+		} else {
+			if (member->min.ipv4 != min_ipv4_address ||
+			    member->max.ipv4 != max_ipv4_address)
+				continue;
 		}
-		found = true;
+		member->is_deleted = is_delete;
+		error = 0;
 		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->is_ipv6 = is_ipv6;
+		if (is_ipv6) {
+			entry->min.ipv6 = saved_min_address;
+			saved_min_address = NULL;
+			entry->max.ipv6 = saved_max_address;
+			saved_max_address = NULL;
+		} else {
+			entry->min.ipv4 = min_ipv4_address;
+			entry->max.ipv4 = max_ipv4_address;
+		}
+		list_add_tail(&entry->list, &group->address_group_member_list);
+		entry = NULL;
+		error = 0;
 	}
-	if (!found) {
-		new_group = ccs_alloc_element(sizeof(*new_group));
-		if (!new_group)
-			goto out;
-		INIT_LIST1_HEAD(&new_group->address_group_member_list);
-		new_group->group_name = saved_group_name;
-		list1_add_tail_mb(&new_group->list, &ccs_address_group_list);
-		group = new_group;
-	}
-	new_member = ccs_alloc_element(sizeof(*new_member));
-	if (!new_member)
-		goto out;
-	new_member->is_ipv6 = is_ipv6;
-	if (is_ipv6) {
-		new_member->min.ipv6 = saved_min_address;
-		new_member->max.ipv6 = saved_max_address;
-	} else {
-		new_member->min.ipv4 = min_ipv4_address;
-		new_member->max.ipv4 = max_ipv4_address;
-	}
-	list1_add_tail_mb(&new_member->list, &group->address_group_member_list);
-	error = 0;
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	ccs_put_ipv6_address(saved_min_address);
+	ccs_put_ipv6_address(saved_max_address);
+	ccs_put_address_group(group);
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
@@ -279,35 +263,6 @@
 }
 
 /**
- * ccs_find_or_assign_new_address_group - Create address group.
- *
- * @group_name: The name of address group.
- *
- * Returns pointer to "struct ccs_address_group_entry" on success,
- * NULL otherwise.
- */
-static struct ccs_address_group_entry *
-ccs_find_or_assign_new_address_group(const char *group_name)
-{
-	u8 i;
-	struct ccs_address_group_entry *group;
-	for (i = 0; i <= 1; i++) {
-		list1_for_each_entry(group, &ccs_address_group_list, list) {
-			if (!strcmp(group_name, group->group_name->name))
-				return group;
-		}
-		if (!i) {
-			const u16 dummy[2] = { 0, 0 };
-			ccs_update_address_group_entry(group_name, false,
-						       dummy, dummy, false);
-			ccs_update_address_group_entry(group_name, false,
-						       dummy, dummy, true);
-		}
-	}
-	return NULL;
-}
-
-/**
  * ccs_address_matches_group - Check whether the given address matches members of the given address group.
  *
  * @is_ipv6: True if @address is an IPv6 address.
@@ -315,6 +270,8 @@
  * @group:   Pointer to "struct ccs_address_group_entry".
  *
  * Returns true if @address matches addresses in @group group, false otherwise.
+ *
+ * Caller holds ccs_policy_lockfor reading.
  */
 static bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
 				      const struct ccs_address_group_entry *
@@ -322,21 +279,26 @@
 {
 	struct ccs_address_group_member *member;
 	const u32 ip = ntohl(*address);
-	list1_for_each_entry(member, &group->address_group_member_list, list) {
+	bool matched = false;
+	list_for_each_entry(member, &group->address_group_member_list, list) {
 		if (member->is_deleted)
 			continue;
 		if (member->is_ipv6) {
 			if (is_ipv6 &&
 			    memcmp(member->min.ipv6, address, 16) <= 0 &&
-			    memcmp(address, member->max.ipv6, 16) <= 0)
-				return true;
+			    memcmp(address, member->max.ipv6, 16) <= 0) {
+				matched = true;
+				break;
+			}
 		} else {
 			if (!is_ipv6 &&
-			    member->min.ipv4 <= ip && ip <= member->max.ipv4)
-				return true;
+			    member->min.ipv4 <= ip && ip <= member->max.ipv4) {
+				matched = true;
+				break;
+			}
 		}
 	}
-	return false;
+	return matched;
 }
 
 /**
@@ -348,16 +310,20 @@
  */
 bool ccs_read_address_group_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *gpos;
-	struct list1_head *mpos;
-	list1_for_each_cookie(gpos, head->read_var1, &ccs_address_group_list) {
+	struct list_head *gpos;
+	struct list_head *mpos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(gpos, head->read_var1.u.list,
+			      &ccs_address_group_list) {
 		struct ccs_address_group_entry *group;
-		group = list1_entry(gpos, struct ccs_address_group_entry, list);
-		list1_for_each_cookie(mpos, head->read_var2,
+		group = list_entry(gpos, struct ccs_address_group_entry, list);
+		list_for_each_cookie(mpos, head->read_var2.u.list,
 				      &group->address_group_member_list) {
 			char buf[128];
 			struct ccs_address_group_member *member;
-			member = list1_entry(mpos,
+			member = list_entry(mpos,
 					     struct ccs_address_group_member,
 					     list);
 			if (member->is_deleted)
@@ -390,15 +356,18 @@
 						 HIPQUAD(max_address));
 				}
 			}
-			if (!ccs_io_printf(head, KEYWORD_ADDRESS_GROUP
-					   "%s %s\n", group->group_name->name,
-					   buf))
-				goto out;
+			done = ccs_io_printf(head, KEYWORD_ADDRESS_GROUP
+					     "%s %s\n", group->group_name->name,
+					     buf);
+			if (!done)
+				break;
 		}
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
 
 #if !defined(NIP6)
@@ -469,7 +438,7 @@
  *
  * @operation:   Type of operation.
  * @record_type: Type of address.
- * @group:       Pointer to "struct ccs_address_group_entry". May be NULL.
+ * @group:       Name of group. May be NULL.
  * @min_address: Start of IPv4 or IPv6 address range.
  * @max_address: End of IPv4 or IPv6 address range.
  * @min_port:    Start of port number range.
@@ -481,7 +450,7 @@
  * Returns 0 on success, negative value otherwise.
  */
 static int ccs_update_network_entry(const u8 operation, const u8 record_type,
-				    const struct ccs_address_group_entry *group,
+				    const char *group_name,
 				    const u32 *min_address,
 				    const u32 *max_address,
 				    const u16 min_port, const u16 max_port,
@@ -489,30 +458,36 @@
 				    const struct ccs_condition_list *condition,
 				    const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
+	struct ccs_ip_network_acl_record *entry = NULL;
 	struct ccs_acl_info *ptr;
-	struct ccs_ip_network_acl_record *acl;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	/* using host byte order to allow u32 comparison than memcmp().*/
 	const u32 min_ip = ntohl(*min_address);
 	const u32 max_ip = ntohl(*max_address);
 	const struct in6_addr *saved_min_address = NULL;
 	const struct in6_addr *saved_max_address = NULL;
+	struct ccs_address_group_entry *group = NULL;
 	if (!domain)
 		return -EINVAL;
-	if (record_type != IP_RECORD_TYPE_IPv6)
-		goto not_ipv6;
-	saved_min_address = ccs_save_ipv6_address((struct in6_addr *)
-						  min_address);
-	saved_max_address = ccs_save_ipv6_address((struct in6_addr *)
-						  max_address);
-	if (!saved_min_address || !saved_max_address)
-		return -ENOMEM;
- not_ipv6:
-	mutex_lock(&lock);
+	if (group_name) {
+		group = ccs_get_address_group(group_name);
+		if (!group)
+			return -ENOMEM;
+	} else if (record_type == IP_RECORD_TYPE_IPv6) {
+		saved_min_address = ccs_get_ipv6_address((struct in6_addr *)
+							 min_address);
+		saved_max_address = ccs_get_ipv6_address((struct in6_addr *)
+							 max_address);
+		if (!saved_min_address || !saved_max_address)
+			goto out;
+	}
 	if (is_delete)
 		goto delete;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_ip_network_acl_record *acl;
 		if (ccs_acl_type1(ptr) != TYPE_IP_NETWORK_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
@@ -535,30 +510,38 @@
 				continue;
 		}
 		error = ccs_add_domain_acl(NULL, ptr);
-		goto out;
+		break;
 	}
-	/* Not found. Append it to the tail. */
-	acl = ccs_alloc_acl_element(TYPE_IP_NETWORK_ACL, condition);
-	if (!acl)
-		goto out;
-	acl->operation_type = operation;
-	acl->record_type = record_type;
-	if (record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
-		acl->u.group = group;
-	} else if (record_type == IP_RECORD_TYPE_IPv4) {
-		acl->u.ipv4.min = min_ip;
-		acl->u.ipv4.max = max_ip;
-	} else {
-		acl->u.ipv6.min = saved_min_address;
-		acl->u.ipv6.max = saved_max_address;
+	if (error && ccs_memory_ok(entry)) {
+		entry->head.type = TYPE_IP_NETWORK_ACL;
+		entry->head.cond = condition;
+		entry->operation_type = operation;
+		entry->record_type = record_type;
+		if (record_type == IP_RECORD_TYPE_ADDRESS_GROUP) {
+			entry->u.group = group;
+			group = NULL;
+		} else if (record_type == IP_RECORD_TYPE_IPv4) {
+			entry->u.ipv4.min = min_ip;
+			entry->u.ipv4.max = max_ip;
+		} else {
+			entry->u.ipv6.min = saved_min_address;
+			saved_min_address = NULL;
+			entry->u.ipv6.max = saved_max_address;
+			saved_max_address = NULL;
+		}
+		entry->min_port = min_port;
+		entry->max_port = max_port;
+		error = ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
 	}
-	acl->min_port = min_port;
-	acl->max_port = max_port;
-	error = ccs_add_domain_acl(domain, &acl->head);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	goto out;
  delete:
-	error = -ENOENT;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_ip_network_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_IP_NETWORK_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
@@ -583,8 +566,13 @@
 		error = ccs_del_domain_acl(ptr);
 		break;
 	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	ccs_put_ipv6_address(saved_min_address);
+	ccs_put_ipv6_address(saved_max_address);
+	ccs_put_address_group(group);
+	kfree(entry);
 	return error;
 }
 
@@ -616,7 +604,9 @@
 	if (!r.mode)
 		return 0;
  retry:
-	list1_for_each_entry(ptr, &r.domain->acl_info_list, list) {
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &r.cookie.u.domain->acl_info_list, list) {
 		struct ccs_ip_network_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_IP_NETWORK_ACL)
 			continue;
@@ -642,6 +632,8 @@
 		found = true;
 		break;
 	}
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
 	memset(buf, 0, sizeof(buf));
 	if (is_ipv6)
 		ccs_print_ipv6(buf, sizeof(buf),
@@ -651,10 +643,10 @@
 	ccs_audit_network_log(&r, keyword, buf, port, found);
 	if (found)
 		return 0;
-	if (ccs_verbose_mode(r.domain))
+	if (ccs_verbose_mode(r.cookie.u.domain))
 		printk(KERN_WARNING "TOMOYO-%s: %s to %s %u denied for %s\n",
 		       ccs_get_msg(is_enforce), keyword, buf, port,
-		       ccs_get_last_name(r.domain));
+		       ccs_get_last_name(r.cookie.u.domain));
 	if (is_enforce) {
 		int error = ccs_check_supervisor(&r, KEYWORD_ALLOW_NETWORK
 						 "%s %s %u\n", keyword, buf,
@@ -663,12 +655,13 @@
 			goto retry;
 		return error;
 	}
-	if (r.mode == 1 && ccs_domain_quota_ok(r.domain))
+	if (r.mode == 1 && ccs_domain_quota_ok(r.cookie.u.domain))
 		ccs_update_network_entry(operation, is_ipv6 ?
 					 IP_RECORD_TYPE_IPv6 :
 					 IP_RECORD_TYPE_IPv4,
 					 NULL, address, address, port, port,
-					 r.domain, ccs_handler_cond(), 0);
+					 r.cookie.u.domain, ccs_handler_cond(),
+					 false);
 	return 0;
 }
 
@@ -691,7 +684,7 @@
 	u8 record_type;
 	u16 min_address[8];
 	u16 max_address[8];
-	struct ccs_address_group_entry *group = NULL;
+	const char *group_name = NULL;
 	u16 min_port;
 	u16 max_port;
 	u8 count;
@@ -754,9 +747,7 @@
 	default:
 		if (*cp2 != '@')
 			goto out;
-		group = ccs_find_or_assign_new_address_group(cp2 + 1);
-		if (!group)
-			return -ENOMEM;
+		group_name = cp2 + 1;
 		record_type = IP_RECORD_TYPE_ADDRESS_GROUP;
 		break;
 	}
@@ -767,7 +758,7 @@
 		goto out;
 	if (count == 1)
 		max_port = min_port;
-	return ccs_update_network_entry(operation, record_type, group,
+	return ccs_update_network_entry(operation, record_type, group_name,
 					(u32 *) min_address,
 					(u32 *) max_address,
 					min_port, max_port, domain, condition,
Index: trunk/1.6.x/ccs-patch/fs/realpath.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/realpath.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/realpath.c	(working copy)
@@ -28,9 +28,9 @@
 #else
 static const int ccs_lookup_flags = LOOKUP_FOLLOW | LOOKUP_POSITIVE;
 #endif
-#include <linux/realpath.h>
 #include <linux/proc_fs.h>
 #include <linux/ccs_common.h>
+#include <linux/realpath.h>
 #include <net/sock.h>
 
 /**
@@ -443,58 +443,213 @@
 			/ sizeof(long)) * sizeof(long);
 }
 
+
+static DEFINE_MUTEX(ccs_element_lock);
 static unsigned int ccs_allocated_memory_for_elements;
 static unsigned int ccs_quota_for_elements;
 
 /**
- * ccs_alloc_element - Allocate permanent memory for structures.
+ * ccs_memory_ok - Check memory quota.
  *
- * @size: Size in bytes.
+ * @ptr: Pointer to allocated memory.
  *
- * Returns pointer to allocated memory on success, NULL otherwise.
+ * Returns true if @ptr is not NULL and quota not exceeded, false otehrwise.
+ */
+bool ccs_memory_ok(const void *ptr)
+{
+	const unsigned int len = ptr ? ksize(ptr) : 0;
+	if (len && (!ccs_quota_for_elements ||
+		    ccs_allocated_memory_for_elements + len
+		    <= ccs_quota_for_elements)) {
+		ccs_allocated_memory_for_elements += len;
+		return true;
+	}
+	printk(KERN_WARNING "ERROR: Out of memory. (%s)\n", __func__);
+	if (!ccs_policy_loaded)
+		panic("MAC Initialization failed.\n");
+	return false;
+}
+
+/**
+ * ccs_memory_free - Free memory for elements.
  *
- * The RAM is chunked, so NEVER try to kfree() the returned pointer.
+ * @ptr: Pointer to allocated memory.
  */
-void *ccs_alloc_element(const unsigned int size)
+static void ccs_memory_free(const void *ptr)
 {
-	static DEFINE_MUTEX(lock);
-	static char *ccs_buf;
-	static unsigned int ccs_buf_used_len = PAGE_SIZE;
-	char *ptr = NULL;
-	const unsigned int word_aligned_size = ccs_round_up(size);
-	if (word_aligned_size > PAGE_SIZE)
-		return NULL;
-	mutex_lock(&lock);
-	if (ccs_buf_used_len + word_aligned_size > PAGE_SIZE) {
-		if (!ccs_quota_for_elements || ccs_allocated_memory_for_elements
-		    + PAGE_SIZE <= ccs_quota_for_elements)
-			ptr = kzalloc(PAGE_SIZE, GFP_KERNEL);
-		if (!ptr) {
-			printk(KERN_WARNING "ERROR: Out of memory "
-			       "for ccs_alloc_element().\n");
-			if (!ccs_policy_loaded)
-				panic("MAC Initialization failed.\n");
-		} else {
-			ccs_buf = ptr;
-			ccs_allocated_memory_for_elements += PAGE_SIZE;
-			ccs_buf_used_len = word_aligned_size;
+	ccs_allocated_memory_for_elements -= ksize(ptr);
+	kfree(ptr);
+}
+
+/**
+ * ccs_free_element - Delete memory for structures.
+ *
+ * @ptr: Memory to release.
+ */
+static void ccs_free_element(void *ptr)
+{
+	int len;
+	if (!ptr)
+		return;
+	len = ksize(ptr);
+	kfree(ptr);
+	/***** EXCLUSIVE SECTION START *****/
+	mutex_lock(&ccs_element_lock);
+	ccs_allocated_memory_for_elements -= len;
+	mutex_unlock(&ccs_element_lock);
+	/***** EXCLUSIVE SECTION END *****/
+}
+
+/**
+ * ccs_put_path_group - Delete memory for "struct ccs_path_group_entry".
+ *
+ * @group: Pointer to "struct ccs_path_group_entry".
+ */
+void ccs_put_path_group(struct ccs_path_group_entry *group)
+{
+	struct ccs_path_group_member *member;
+	struct ccs_path_group_member *next_member;
+	LIST_HEAD(q);
+	bool can_delete_group = false;
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	if (atomic_dec_and_test(&group->users)) {
+		list_for_each_entry_safe(member, next_member,
+					 &group->path_group_member_list,
+					 list) {
+			if (!member->is_deleted)
+				break;
+			list_del(&member->list);
+			list_add(&member->list, &q);
 		}
-	} else if (word_aligned_size) {
-		int i;
-		ptr = ccs_buf + ccs_buf_used_len;
-		ccs_buf_used_len += word_aligned_size;
-		for (i = 0; i < word_aligned_size; i++) {
-			if (!ptr[i])
-				continue;
-			printk(KERN_ERR "WARNING: Reserved memory was tainted! "
-			       "The system might go wrong.\n");
-			ptr[i] = '\0';
+		if (list_empty(&group->path_group_member_list)) {
+			list_del(&group->list);
+			can_delete_group = true;
 		}
 	}
-	mutex_unlock(&lock);
-	return ptr;
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(member, next_member, &q, list) {
+		list_del(&member->list);
+		ccs_put_name(member->member_name);
+		ccs_free_element(member);
+	}
+	if (can_delete_group) {
+		ccs_put_name(group->group_name);
+		ccs_free_element(group);
+	}
 }
 
+/**
+ * ccs_put_address_group - Delete memory for "struct ccs_address_group_entry".
+ *
+ * @group: Pointer to "struct ccs_address_group_entry".
+ */
+void ccs_put_address_group(struct ccs_address_group_entry *group)
+{
+	struct ccs_address_group_member *member;
+	struct ccs_address_group_member *next_member;
+	LIST_HEAD(q);
+	bool can_delete_group = false;
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	if (atomic_dec_and_test(&group->users)) {
+		list_for_each_entry_safe(member, next_member,
+					 &group->address_group_member_list,
+					 list) {
+			if (!member->is_deleted)
+				break;
+			list_del(&member->list);
+			list_add(&member->list, &q);
+		}
+		if (list_empty(&group->address_group_member_list)) {
+			list_del(&group->list);
+			can_delete_group = true;
+		}
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(member, next_member, &q, list) {
+		list_del(&member->list);
+		if (member->is_ipv6) {
+			ccs_put_ipv6_address(member->min.ipv6);
+			ccs_put_ipv6_address(member->max.ipv6);
+		}
+		ccs_free_element(member);
+	}
+	if (can_delete_group) {
+		ccs_put_name(group->group_name);
+		ccs_free_element(group);
+	}
+}
+
+static LIST_HEAD(ccs_address_list);
+
+/**
+ * ccs_get_ipv6_address - Keep the given IPv6 address on the RAM.
+ *
+ * @addr: Pointer to "struct in6_addr".
+ *
+ * Returns pointer to "struct in6_addr" on success, NULL otherwise.
+ *
+ * The RAM is shared, so NEVER try to modify or kfree() the returned address.
+ */
+const struct in6_addr *ccs_get_ipv6_address(const struct in6_addr *addr)
+{
+	struct ccs_addr_entry *entry;
+	struct ccs_addr_entry *ptr;
+	int error = -ENOMEM;
+	if (!addr)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_address_list, list) {
+		if (memcmp(&ptr->addr, addr, sizeof(*addr)))
+			continue;
+		atomic_inc(&ptr->users);
+		error = 0;
+		break;
+	}
+	if (error && ccs_memory_ok(entry)) {
+		ptr = entry;
+		ptr->addr = *addr;
+		atomic_set(&ptr->users, 1);
+		list_add_tail(&ptr->list, &ccs_address_list);
+		entry = NULL;
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	kfree(entry);
+	return ptr ? &ptr->addr : NULL;
+}
+
+/**
+ * ccs_put_ipv6_address - Delete the given IPv6 address on the RAM.
+ *
+ * @addr: Pointer to "struct in6_addr".
+ */
+void ccs_put_ipv6_address(const struct in6_addr *addr)
+{
+	struct ccs_addr_entry *ptr;
+	bool can_delete = false;
+	if (!addr)
+		return;
+	ptr = container_of(addr, struct ccs_addr_entry, addr);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	if (atomic_dec_and_test(&ptr->users)) {
+		list_del(&ptr->list);
+		can_delete = true;
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	if (can_delete) {
+		ccs_allocated_memory_for_elements -= ksize(ptr);
+		ccs_free(ptr);
+	}
+}
+
 static unsigned int ccs_allocated_memory_for_savename;
 static unsigned int ccs_quota_for_savename;
 
@@ -502,7 +657,8 @@
 
 /* Structure for string data. */
 struct ccs_name_entry {
-	struct list1_head list;
+	struct list_head list;
+	atomic_t users;
 	struct ccs_path_info entry;
 };
 
@@ -514,84 +670,92 @@
 };
 
 /* The list for "struct ccs_name_entry". */
-static struct list1_head ccs_name_list[MAX_HASH];
+static struct list_head ccs_name_list[MAX_HASH];
+static DEFINE_MUTEX(ccs_name_list_lock);
 
 /**
- * ccs_save_name - Allocate permanent memory for string data.
+ * ccs_get_name - Allocate memory for string data.
  *
  * @name: The string to store into the permernent memory.
  *
  * Returns pointer to "struct ccs_path_info" on success, NULL otherwise.
- *
- * The RAM is shared, so NEVER try to modify or kfree() the returned name.
  */
-const struct ccs_path_info *ccs_save_name(const char *name)
+const struct ccs_path_info *ccs_get_name(const char *name)
 {
-	static LIST_HEAD(ccs_fmb_list);
-	static DEFINE_MUTEX(lock);
 	struct ccs_name_entry *ptr;
 	unsigned int hash;
-	struct ccs_free_memory_block_list *fmb;
 	int len;
-	char *cp;
+	int allocated_len;
+
 	if (!name)
 		return NULL;
 	len = strlen(name) + 1;
 	if (len > CCS_MAX_PATHNAME_LEN) {
 		printk(KERN_WARNING "ERROR: Name too long "
-		       "for ccs_save_name().\n");
+		       "for %s().\n", __func__);
 		return NULL;
 	}
 	hash = full_name_hash((const unsigned char *) name, len - 1);
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_name_list[hash % MAX_HASH], list) {
-		if (hash == ptr->entry.hash && !strcmp(name, ptr->entry.name))
-			goto out;
+	/***** EXCLUSIVE SECTION START *****/
+	mutex_lock(&ccs_name_list_lock);
+	list_for_each_entry(ptr, &ccs_name_list[hash % MAX_HASH], list) {
+		if (hash != ptr->entry.hash || strcmp(name, ptr->entry.name))
+			continue;
+		atomic_inc(&ptr->users);
+		goto out;
 	}
-	list_for_each_entry(fmb, &ccs_fmb_list, list) {
-		if (len <= fmb->len)
-			goto ready;
-	}
-	if (!ccs_quota_for_savename ||
-	    ccs_allocated_memory_for_savename + PAGE_SIZE
-	    <= ccs_quota_for_savename)
-		cp = kzalloc(PAGE_SIZE, GFP_KERNEL);
-	else
-		cp = NULL;
-	fmb = kzalloc(sizeof(*fmb), GFP_KERNEL);
-	if (!cp || !fmb) {
-		kfree(cp);
-		kfree(fmb);
-		printk(KERN_WARNING "ERROR: Out of memory "
-		       "for ccs_save_name().\n");
+	ptr = kmalloc(sizeof(*ptr) + len, GFP_KERNEL);
+	allocated_len = ptr ? ksize(ptr) : 0;
+	if (!allocated_len ||
+	    (ccs_quota_for_savename &&
+	     ccs_allocated_memory_for_savename + allocated_len
+	     > ccs_quota_for_savename)) {
+		kfree(ptr);
+		ptr = NULL;
+		printk(KERN_WARNING "ERROR: Out of memory for %s().\n",
+		       __func__);
 		if (!ccs_policy_loaded)
 			panic("MAC Initialization failed.\n");
-		ptr = NULL;
 		goto out;
 	}
-	ccs_allocated_memory_for_savename += PAGE_SIZE;
-	list_add(&fmb->list, &ccs_fmb_list);
-	fmb->ptr = cp;
-	fmb->len = PAGE_SIZE;
- ready:
-	ptr = ccs_alloc_element(sizeof(*ptr));
-	if (!ptr)
-		goto out;
-	ptr->entry.name = fmb->ptr;
-	memmove(fmb->ptr, name, len);
+	ccs_allocated_memory_for_savename += allocated_len;
+	ptr->entry.name = ((char *) ptr) + sizeof(*ptr);
+	memmove((char *) ptr->entry.name, name, len);
+	atomic_set(&ptr->users, 1);
 	ccs_fill_path_info(&ptr->entry);
-	fmb->ptr += len;
-	fmb->len -= len;
-	list1_add_tail_mb(&ptr->list, &ccs_name_list[hash % MAX_HASH]);
-	if (fmb->len == 0) {
-		list_del(&fmb->list);
-		kfree(fmb);
-	}
+	list_add_tail(&ptr->list, &ccs_name_list[hash % MAX_HASH]);
  out:
-	mutex_unlock(&lock);
+	mutex_unlock(&ccs_name_list_lock);
+	/***** EXCLUSIVE SECTION END *****/
 	return ptr ? &ptr->entry : NULL;
 }
 
+/**
+ * ccs_put_name - Delete shared memory for string data.
+ *
+ * @name: Pointer to "struct ccs_path_info".
+ */
+void ccs_put_name(const struct ccs_path_info *name)
+{
+	struct ccs_name_entry *ptr;
+	bool can_delete = false;
+	if (!name)
+		return;
+	ptr = container_of(name, struct ccs_name_entry, entry);
+	/***** EXCLUSIVE SECTION START *****/
+	mutex_lock(&ccs_name_list_lock);
+	if (atomic_dec_and_test(&ptr->users)) {
+		list_del(&ptr->list);
+		can_delete = true;
+	}
+	mutex_unlock(&ccs_name_list_lock);
+	/***** EXCLUSIVE SECTION END *****/
+	if (can_delete) {
+		ccs_allocated_memory_for_savename -= ksize(ptr);
+		kfree(ptr);
+	}
+}
+
 /* Structure for temporarily allocated memory. */
 struct ccs_cache_entry {
 	struct list_head list;
@@ -613,7 +777,8 @@
 static int __init ccs_realpath_init(void)
 {
 	int i;
-	/* Constraint for ccs_save_name(). */
+	struct ccs_cookie cookie;
+	/* Constraint for ccs_get_name(). */
 	if (CCS_MAX_PATHNAME_LEN > PAGE_SIZE)
 		panic("Bad size.");
 	/* Constraint for "struct ccs_execve_entry"->tmp users. */
@@ -631,11 +796,12 @@
 	if (!ccs_cachep)
 		panic("Can't create cache.\n");
 	for (i = 0; i < MAX_HASH; i++)
-		INIT_LIST1_HEAD(&ccs_name_list[i]);
-	INIT_LIST1_HEAD(&ccs_kernel_domain.acl_info_list);
-	ccs_kernel_domain.domainname = ccs_save_name(ROOT_NAME);
-	list1_add_tail_mb(&ccs_kernel_domain.list, &ccs_domain_list);
-	if (ccs_find_domain(ROOT_NAME) != &ccs_kernel_domain)
+		INIT_LIST_HEAD(&ccs_name_list[i]);
+	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list);
+	ccs_kernel_domain.domainname = ccs_get_name(ROOT_NAME);
+	list_add_tail(&ccs_kernel_domain.list, &ccs_domain_list);
+	if (!ccs_find_domain(ROOT_NAME, &cookie) ||
+	    cookie.u.domain != &ccs_kernel_domain)
 		panic("Can't register ccs_kernel_domain");
 #ifdef CONFIG_TOMOYO_BUILTIN_INITIALIZERS
 	{
@@ -850,3 +1016,476 @@
 		ccs_quota_for_dynamic = size;
 	return 0;
 }
+
+/* List of pointers referenced by cookies. */
+static LIST_HEAD(ccs_cookie_list);
+static DEFINE_RWLOCK(ccs_cookie_list_lock);
+
+/**
+ * ccs_add_cookie - Add a cookie to cookie list.
+ *
+ * @cookie: Pointer to "struct ccs_cookie".
+ * @ptr:    Pointer to assign.
+ */
+void ccs_add_cookie(struct ccs_cookie *cookie, const void *ptr)
+{
+	if (!cookie)
+		return;
+	ccs_update_cookie(cookie, ptr);
+	write_lock(&ccs_cookie_list_lock);
+	list_add_tail(&cookie->list, &ccs_cookie_list);
+	write_unlock(&ccs_cookie_list_lock);
+}
+
+/**
+ * ccs_del_cookie - Delete a cookie from cookie list.
+ *
+ * @cookie: Pointer to "struct ccs_cookie".
+ */
+void ccs_del_cookie(struct ccs_cookie *cookie)
+{
+	if (!cookie)
+		return;
+	write_lock(&ccs_cookie_list_lock);
+	list_del(&cookie->list);
+	write_unlock(&ccs_cookie_list_lock);
+}
+
+/**
+ * ccs_used_by_cookie - Check whether the given pointer is referenced by a cookie or not.
+ *
+ * @ptr: Pointer to check.
+ *
+ * Returns true if @ptr is in use, false otherwise.
+ *
+ * Caller must hold ccs_policy_lock for writing.
+ */
+static bool ccs_used_by_cookie(const void *ptr)
+{
+	struct ccs_cookie *cookie;
+	bool in_use = false;
+	read_lock(&ccs_cookie_list_lock);
+	list_for_each_entry(cookie, &ccs_cookie_list, list) {
+		if (ptr != cookie->u.ptr)
+			continue;
+		in_use = true;
+		break;
+	}
+	read_unlock(&ccs_cookie_list_lock);
+	return in_use;
+}
+
+/**
+ * ccs_cleanup_allow_read - Clean up deleted "struct ccs_globally_readable_file_entry".
+ */
+static void ccs_cleanup_allow_read(void)
+{
+	struct ccs_globally_readable_file_entry *ptr;
+	struct ccs_globally_readable_file_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry_safe(ptr, tmp, &ccs_globally_readable_list,
+				 list) {
+		if (!ptr->is_deleted || ccs_used_by_cookie(ptr))
+			continue;
+		list_del(&ptr->list);
+		list_add(&ptr->list, &q);
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, list) {
+		ccs_put_name(ptr->filename);
+		list_del(&ptr->list);
+		ccs_memory_free(ptr);
+	}
+}
+
+/**
+ * ccs_cleanup_allow_env - Clean up deleted "struct ccs_globally_usable_env_entry".
+ */
+static void ccs_cleanup_allow_env(void)
+{
+	struct ccs_globally_usable_env_entry *ptr;
+	struct ccs_globally_usable_env_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry_safe(ptr, tmp, &ccs_globally_usable_env_list,
+				 list) {
+		if (!ptr->is_deleted || ccs_used_by_cookie(ptr))
+			continue;
+		list_del(&ptr->list);
+		list_add(&ptr->list, &q);
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, list) {
+		ccs_put_name(ptr->env);
+		list_del(&ptr->list);
+		ccs_memory_free(ptr);
+	}
+}
+
+/**
+ * ccs_cleanup_file_pattern - Clean up deleted "struct ccs_pattern_entry".
+ */
+static void ccs_cleanup_file_pattern(void)
+{
+	struct ccs_pattern_entry *ptr;
+	struct ccs_pattern_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry_safe(ptr, tmp, &ccs_pattern_list, list) {
+		if (!ptr->is_deleted || ccs_used_by_cookie(ptr))
+			continue;
+		list_del(&ptr->list);
+		list_add(&ptr->list, &q);
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, list) {
+		ccs_put_name(ptr->pattern);
+		list_del(&ptr->list);
+		ccs_memory_free(ptr);
+	}
+}
+
+/**
+ * ccs_cleanup_no_rewrite - Clean up deleted "struct ccs_no_rewrite_entry".
+ */
+static void ccs_cleanup_no_rewrite(void)
+{
+	struct ccs_no_rewrite_entry *ptr;
+	struct ccs_no_rewrite_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry_safe(ptr, tmp, &ccs_no_rewrite_list, list) {
+		if (!ptr->is_deleted || ccs_used_by_cookie(ptr))
+			continue;
+		list_del(&ptr->list);
+		list_add(&ptr->list, &q);
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, list) {
+		ccs_put_name(ptr->pattern);
+		list_del(&ptr->list);
+		ccs_memory_free(ptr);
+	}
+}
+
+/**
+ * ccs_cleanup_initializer - Clean up deleted "struct ccs_domain_initializer_entry".
+ */
+static void ccs_cleanup_initializer(void)
+{
+	struct ccs_domain_initializer_entry *ptr;
+	struct ccs_domain_initializer_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry_safe(ptr, tmp, &ccs_domain_initializer_list,
+				 list) {
+		if (!ptr->is_deleted || ccs_used_by_cookie(ptr))
+			continue;
+		list_del(&ptr->list);
+		list_add(&ptr->list, &q);
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, list) {
+		ccs_put_name(ptr->domainname);
+		ccs_put_name(ptr->program);
+		list_del(&ptr->list);
+		ccs_memory_free(ptr);
+	}
+}
+
+/**
+ * ccs_cleanup_keep_domain - Clean up deleted "struct ccs_domain_keeper_entry".
+ */
+static void ccs_cleanup_keep_domain(void)
+{
+	struct ccs_domain_keeper_entry *ptr;
+	struct ccs_domain_keeper_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry_safe(ptr, tmp, &ccs_domain_keeper_list, list) {
+		if (!ptr->is_deleted || ccs_used_by_cookie(ptr))
+			continue;
+		list_del(&ptr->list);
+		list_add(&ptr->list, &q);
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, list) {
+		ccs_put_name(ptr->domainname);
+		ccs_put_name(ptr->program);
+		list_del(&ptr->list);
+		ccs_memory_free(ptr);
+	}
+}
+
+/**
+ * ccs_cleanup_alias - Clean up deleted "struct ccs_alias_entry".
+ */
+static void ccs_cleanup_alias(void)
+{
+	struct ccs_alias_entry *ptr;
+	struct ccs_alias_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry_safe(ptr, tmp, &ccs_alias_list, list) {
+		if (!ptr->is_deleted || ccs_used_by_cookie(ptr))
+			continue;
+		list_del(&ptr->list);
+		list_add(&ptr->list, &q);
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, list) {
+		ccs_put_name(ptr->original_name);
+		ccs_put_name(ptr->aliased_name);
+		list_del(&ptr->list);
+		ccs_memory_free(ptr);
+	}
+}
+
+/**
+ * ccs_cleanup_aggregator - Clean up deleted "struct ccs_aggregator_entry".
+ */
+static void ccs_cleanup_aggregator(void)
+{
+	struct ccs_aggregator_entry *ptr;
+	struct ccs_aggregator_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry_safe(ptr, tmp, &ccs_aggregator_list, list) {
+		if (!ptr->is_deleted || ccs_used_by_cookie(ptr))
+			continue;
+		list_del(&ptr->list);
+		list_add(&ptr->list, &q);
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, list) {
+		ccs_put_name(ptr->original_name);
+		ccs_put_name(ptr->aggregated_name);
+		list_del(&ptr->list);
+		ccs_memory_free(ptr);
+	}
+}
+
+/**
+ * ccs_cleanup_manager - Clean up deleted "struct ccs_policy_manager_entry".
+ */
+static void ccs_cleanup_manager(void)
+{
+	struct ccs_policy_manager_entry *ptr;
+	struct ccs_policy_manager_entry *tmp;
+	LIST_HEAD(q);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry_safe(ptr, tmp, &ccs_policy_manager_list, list) {
+		if (!ptr->is_deleted || ccs_used_by_cookie(ptr))
+			continue;
+		list_del(&ptr->list);
+		list_add(&ptr->list, &q);
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(ptr, tmp, &q, list) {
+		ccs_put_name(ptr->manager);
+		list_del(&ptr->list);
+		ccs_memory_free(ptr);
+	}
+}
+
+/* For compatibility with older kernels. */
+#ifndef for_each_process
+#define for_each_process for_each_task
+#endif
+
+/**
+ * ccs_used_by_task - Check whether the given pointer is referenced by a task.
+ *
+ * @domain: Pointer to "struct ccs_domain_info".
+ *
+ * Returns true if @ptr is in use, false otherwise.
+ */
+static bool ccs_used_by_task(struct ccs_domain_info *domain)
+{
+	bool in_use = false;
+	struct task_struct *p;
+	/***** CRITICAL SECTION START *****/
+	read_lock(&tasklist_lock);
+	for_each_process(p) {
+		if (p->ccs_domain_info != domain)
+			continue;
+		in_use = true;
+		break;
+	}
+	read_unlock(&tasklist_lock);
+	/***** CRITICAL SECTION END *****/
+	return in_use;
+}
+
+/**
+ * ccs_cleanup_domain_policy - Clean up deleted domain policy.
+ */
+static void ccs_cleanup_domain_policy(void)
+{
+	struct ccs_domain_info *domain;
+	struct ccs_domain_info *next_domain;
+	struct ccs_acl_info *acl;
+	struct ccs_acl_info *next_acl;
+	LIST_HEAD(q_domain);
+	LIST_HEAD(q_acl);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry_safe(domain, next_domain, &ccs_domain_list,
+				 list) {
+		const bool can_delete_domain = domain->is_deleted &&
+			!ccs_used_by_cookie(domain) &&
+			!ccs_used_by_task(domain);
+		if (can_delete_domain) {
+			list_for_each_entry(acl, &domain->acl_info_list, list)
+				acl->type |= ACL_DELETED;
+		}
+		list_for_each_entry_safe(acl, next_acl, &domain->acl_info_list,
+					 list) {
+			if (!(acl->type & ACL_DELETED)
+			    || ccs_used_by_cookie(acl))
+				continue;
+			list_del(&acl->list);
+			list_add(&acl->list, &q_acl);
+		}
+		if (can_delete_domain && list_empty(&domain->acl_info_list)) {
+			list_del(&domain->list);
+			list_add(&domain->list, &q_domain);
+		}
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	list_for_each_entry_safe(acl, next_acl, &q_acl, list) {
+		switch (ccs_acl_type1(acl)) {
+			struct ccs_single_path_acl_record *acl1;
+			struct ccs_double_path_acl_record *acl2;
+			struct ccs_ip_network_acl_record *acl3;
+			struct ccs_ioctl_acl_record *acl4;
+			struct ccs_argv0_acl_record *acl5;
+			struct ccs_env_acl_record *acl6;
+			struct ccs_capability_acl_record *acl7;
+			struct ccs_signal_acl_record *acl8;
+			struct ccs_execute_handler_record *acl9;
+		case TYPE_SINGLE_PATH_ACL:
+			acl1 = container_of(acl,
+					    struct ccs_single_path_acl_record,
+					    head);
+			if (acl1->u_is_group)
+				ccs_put_path_group(acl1->u.group);
+			else
+				ccs_put_name(acl1->u.filename);
+			break;
+		case TYPE_DOUBLE_PATH_ACL:
+			acl2 = container_of(acl,
+					    struct ccs_double_path_acl_record,
+					    head);
+			if (acl2->u1_is_group)
+				ccs_put_path_group(acl2->u1.group1);
+			else
+				ccs_put_name(acl2->u1.filename1);
+			if (acl2->u2_is_group)
+				ccs_put_path_group(acl2->u2.group2);
+			else
+				ccs_put_name(acl2->u2.filename2);
+			break;
+		case TYPE_IP_NETWORK_ACL:
+			acl3 = container_of(acl,
+					    struct ccs_ip_network_acl_record,
+					    head);
+			if (acl3->record_type == IP_RECORD_TYPE_ADDRESS_GROUP)
+				ccs_put_address_group(acl3->u.group);
+			else if (acl3->record_type == IP_RECORD_TYPE_IPv6) {
+				ccs_put_ipv6_address(acl3->u.ipv6.min);
+				ccs_put_ipv6_address(acl3->u.ipv6.max);
+			}
+			break;
+		case TYPE_IOCTL_ACL:
+			acl4 = container_of(acl, struct ccs_ioctl_acl_record,
+					    head);
+			if (acl4->u_is_group)
+				ccs_put_path_group(acl4->u.group);
+			else
+				ccs_put_name(acl4->u.filename);
+			break;
+		case TYPE_ARGV0_ACL:
+			acl5 = container_of(acl, struct ccs_argv0_acl_record,
+					    head);
+			ccs_put_name(acl5->argv0);
+			break;
+		case TYPE_ENV_ACL:
+			acl6 = container_of(acl, struct ccs_env_acl_record,
+					    head);
+			ccs_put_name(acl6->env);
+			break;
+		case TYPE_CAPABILITY_ACL:
+			acl7 = container_of(acl,
+					    struct ccs_capability_acl_record,
+					    head);
+			break;
+		case TYPE_SIGNAL_ACL:
+			acl8 = container_of(acl, struct ccs_signal_acl_record,
+					    head);
+			ccs_put_name(acl8->domainname);
+			break;
+		case TYPE_EXECUTE_HANDLER:
+		case TYPE_DENIED_EXECUTE_HANDLER:
+			acl9 = container_of(acl,
+					    struct ccs_execute_handler_record,
+					    head);
+			ccs_put_name(acl9->handler);
+			break;
+		}
+		list_del(&acl->list);
+		ccs_memory_free(acl);
+	}
+	list_for_each_entry_safe(domain, next_domain, &q_domain, list) {
+		ccs_put_name(domain->domainname);
+		list_del(&domain->list);
+		ccs_memory_free(domain);
+	}
+}
+
+/**
+ * ccs_run_garbage_collector - Run garbage collector.
+ */
+void ccs_run_garbage_collector(void)
+{
+	ccs_cleanup_allow_read();
+	ccs_cleanup_allow_env();
+	ccs_cleanup_file_pattern();
+	ccs_cleanup_no_rewrite();
+	ccs_cleanup_initializer();
+	ccs_cleanup_keep_domain();
+	ccs_cleanup_alias();
+	ccs_cleanup_aggregator();
+	ccs_cleanup_manager();
+	ccs_cleanup_domain_policy();
+}
+/*
+extern struct list_head ccs_address_group_list;
+extern struct list_head ccs_path_group_list;
+extern struct list_head ccs_condition_list;
+extern struct list_head ccs_mount_list;
+extern struct list_head ccs_no_umount_list;
+extern struct list_head ccs_pivot_root_list;
+extern struct list_head ccs_chroot_list;
+extern struct list_head ccs_reservedport_list;
+*/
Index: trunk/1.6.x/ccs-patch/fs/sakura_chroot.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_chroot.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/sakura_chroot.c	(working copy)
@@ -21,15 +21,8 @@
 #include <linux/fs.h>
 #endif
 
-/* Structure for "allow_chroot" keyword. */
-struct ccs_chroot_entry {
-	struct list1_head list;
-	const struct ccs_path_info *dir;
-	bool is_deleted;
-};
-
 /* The list for "struct ccs_chroot_entry". */
-static LIST1_HEAD(ccs_chroot_list);
+LIST_HEAD(ccs_chroot_list);
 
 /**
  * ccs_update_chroot_acl - Update "struct ccs_chroot_entry" list.
@@ -41,37 +34,40 @@
  */
 static int ccs_update_chroot_acl(const char *dir, const bool is_delete)
 {
-	struct ccs_chroot_entry *new_entry;
+	struct ccs_chroot_entry *entry = NULL;
 	struct ccs_chroot_entry *ptr;
 	const struct ccs_path_info *saved_dir;
-	static DEFINE_MUTEX(lock);
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(dir, 1, 0, 1, __func__))
 		return -EINVAL;
-	saved_dir = ccs_save_name(dir);
+	saved_dir = ccs_get_name(dir);
 	if (!saved_dir)
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_chroot_list, list) {
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_chroot_list, list) {
 		if (ptr->dir != saved_dir)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->dir = saved_dir;
+		saved_dir = NULL;
+		list_add_tail(&entry->list, &ccs_chroot_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->dir = saved_dir;
-	list1_add_tail_mb(&new_entry->list, &ccs_chroot_list);
-	error = 0;
-	printk(KERN_CONT "%sAllow chroot() to %s\n", ccs_log_level, dir);
- out:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	if (!is_delete && !error)
+		printk(KERN_CONT "%sAllow chroot() to %s\n", ccs_log_level,
+		       dir);
+	ccs_put_name(saved_dir);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 	return error;
 }
@@ -142,7 +138,7 @@
 		ccs_fill_path_info(&dir);
 		if (dir.is_dir) {
 			struct ccs_chroot_entry *ptr;
-			list1_for_each_entry(ptr, &ccs_chroot_list, list) {
+			list_for_each_entry(ptr, &ccs_chroot_list, list) {
 				if (ptr->is_deleted)
 					continue;
 				if (!ccs_path_matches_pattern(&dir, ptr->dir))
@@ -182,17 +178,21 @@
  */
 bool ccs_read_chroot_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &ccs_chroot_list) {
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list, &ccs_chroot_list) {
 		struct ccs_chroot_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_chroot_entry, list);
+		ptr = list_entry(pos, struct ccs_chroot_entry, list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, KEYWORD_ALLOW_CHROOT "%s\n",
-				   ptr->dir->name))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_ALLOW_CHROOT "%s\n",
+				     ptr->dir->name);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
Index: trunk/1.6.x/ccs-patch/fs/sakura_pivot.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_pivot.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/sakura_pivot.c	(working copy)
@@ -21,16 +21,8 @@
 #include <linux/fs.h>
 #endif
 
-/* Structure for "allow_pivot_root" keyword. */
-struct ccs_pivot_root_entry {
-	struct list1_head list;
-	const struct ccs_path_info *old_root;
-	const struct ccs_path_info *new_root;
-	bool is_deleted;
-};
-
 /* The list for "struct ccs_pivot_root_entry". */
-static LIST1_HEAD(ccs_pivot_root_list);
+LIST_HEAD(ccs_pivot_root_list);
 
 /**
  * ccs_update_pivot_root_acl - Update "struct ccs_pivot_root_entry" list.
@@ -44,43 +36,48 @@
 static int ccs_update_pivot_root_acl(const char *old_root, const char *new_root,
 				     const bool is_delete)
 {
-	struct ccs_pivot_root_entry *new_entry;
+	struct ccs_pivot_root_entry *entry = NULL;
 	struct ccs_pivot_root_entry *ptr;
 	const struct ccs_path_info *saved_old_root;
 	const struct ccs_path_info *saved_new_root;
-	static DEFINE_MUTEX(lock);
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(old_root, 1, 0, 1, __func__) ||
 	    !ccs_is_correct_path(new_root, 1, 0, 1, __func__))
 		return -EINVAL;
-	saved_old_root = ccs_save_name(old_root);
-	saved_new_root = ccs_save_name(new_root);
+	saved_old_root = ccs_get_name(old_root);
+	saved_new_root = ccs_get_name(new_root);
 	if (!saved_old_root || !saved_new_root)
-		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_pivot_root_list, list) {
+		goto out;
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_pivot_root_list, list) {
 		if (ptr->old_root != saved_old_root ||
 		    ptr->new_root != saved_new_root)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->old_root = saved_old_root;
+		saved_old_root = NULL;
+		entry->new_root = saved_new_root;
+		saved_new_root = NULL;
+		list_add_tail(&entry->list, &ccs_pivot_root_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->old_root = saved_old_root;
-	new_entry->new_root = saved_new_root;
-	list1_add_tail_mb(&new_entry->list, &ccs_pivot_root_list);
-	error = 0;
-	printk(KERN_CONT "%sAllow pivot_root(%s, %s)\n", ccs_log_level,
-	       new_root, old_root);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	if (!is_delete && !error)
+		printk(KERN_CONT "%sAllow pivot_root(%s, %s)\n", ccs_log_level,
+		       new_root, old_root);
  out:
-	mutex_unlock(&lock);
+	ccs_put_name(saved_old_root);
+	ccs_put_name(saved_new_root);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 	return error;
 }
@@ -132,7 +129,7 @@
 		ccs_fill_path_info(&new_root_dir);
 		if (old_root_dir.is_dir && new_root_dir.is_dir) {
 			struct ccs_pivot_root_entry *ptr;
-			list1_for_each_entry(ptr, &ccs_pivot_root_list, list) {
+			list_for_each_entry(ptr, &ccs_pivot_root_list, list) {
 				if (ptr->is_deleted)
 					continue;
 				if (!ccs_path_matches_pattern(&old_root_dir,
@@ -197,17 +194,22 @@
  */
 bool ccs_read_pivot_root_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &ccs_pivot_root_list) {
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list,
+			     &ccs_pivot_root_list) {
 		struct ccs_pivot_root_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_pivot_root_entry, list);
+		ptr = list_entry(pos, struct ccs_pivot_root_entry, list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, KEYWORD_ALLOW_PIVOT_ROOT "%s %s\n",
-				   ptr->new_root->name, ptr->old_root->name))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_ALLOW_PIVOT_ROOT "%s %s\n",
+				     ptr->new_root->name, ptr->old_root->name);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
Index: trunk/1.6.x/ccs-patch/fs/sakura_mount.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_mount.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/sakura_mount.c	(working copy)
@@ -54,16 +54,6 @@
 /* Allow to call 'mount --make-shared /dir'           */
 #define MOUNT_MAKE_SHARED_KEYWORD                        "--make-shared"
 
-/* Structure for "allow_mount" keyword. */
-struct ccs_mount_entry {
-	struct list1_head list;
-	const struct ccs_path_info *dev_name;
-	const struct ccs_path_info *dir_name;
-	const struct ccs_path_info *fs_type;
-	unsigned long flags;
-	bool is_deleted;
-};
-
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 /* For compatibility with older kernels. */
 static void put_filesystem(struct file_system_type *fs)
@@ -73,7 +63,7 @@
 #endif
 
 /* The list for "struct ccs_mount_entry". */
-static LIST1_HEAD(ccs_mount_list);
+LIST_HEAD(ccs_mount_list);
 
 /**
  * ccs_update_mount_acl - Update "struct ccs_mount_entry" list.
@@ -90,99 +80,97 @@
 				const char *fs_type, const unsigned long flags,
 				const bool is_delete)
 {
-	struct file_system_type *type = NULL;
-	struct ccs_mount_entry *new_entry;
+	struct ccs_mount_entry *entry = NULL;
 	struct ccs_mount_entry *ptr;
-	const struct ccs_path_info *fs;
-	const struct ccs_path_info *dev;
-	const struct ccs_path_info *dir;
-	static DEFINE_MUTEX(lock);
-	int error = -ENOMEM;
+	const struct ccs_path_info *saved_fs;
+	const struct ccs_path_info *saved_dev;
+	const struct ccs_path_info *saved_dir;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(fs_type, 0, 0, 0, __func__))
 		return -EINVAL;
-	fs = ccs_save_name(fs_type);
-	if (!fs)
-		return -EINVAL;
+	saved_fs = ccs_get_name(fs_type);
+	if (!saved_fs)
+		return -ENOMEM;
 	if (!dev_name)
 		dev_name = "<NULL>";
-	if (!strcmp(fs->name, MOUNT_REMOUNT_KEYWORD))
+	if (!strcmp(saved_fs->name, MOUNT_REMOUNT_KEYWORD))
 		/* Fix dev_name to "any" for remount permission. */
 		dev_name = "any";
-	if (!strcmp(fs->name, MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
-	    !strcmp(fs->name, MOUNT_MAKE_PRIVATE_KEYWORD) ||
-	    !strcmp(fs->name, MOUNT_MAKE_SLAVE_KEYWORD) ||
-	    !strcmp(fs->name, MOUNT_MAKE_SHARED_KEYWORD))
+	if (!strcmp(saved_fs->name, MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
+	    !strcmp(saved_fs->name, MOUNT_MAKE_PRIVATE_KEYWORD) ||
+	    !strcmp(saved_fs->name, MOUNT_MAKE_SLAVE_KEYWORD) ||
+	    !strcmp(saved_fs->name, MOUNT_MAKE_SHARED_KEYWORD))
 		dev_name = "any";
 	if (!ccs_is_correct_path(dev_name, 0, 0, 0, __func__) ||
-	    !ccs_is_correct_path(dir_name, 0, 0, 0, __func__))
+	    !ccs_is_correct_path(dir_name, 0, 0, 0, __func__)) {
+		ccs_put_name(saved_fs);
 		return -EINVAL;
-	dev = ccs_save_name(dev_name);
-	dir = ccs_save_name(dir_name);
-	if (!dev || !dir)
-		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_mount_list, list) {
+	}
+	saved_dev = ccs_get_name(dev_name);
+	saved_dir = ccs_get_name(dir_name);
+	if (!saved_dev || !saved_dir)
+		goto out;
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_mount_list, list) {
 		if (ptr->flags != flags ||
-		    ccs_pathcmp(ptr->dev_name, dev) ||
-		    ccs_pathcmp(ptr->dir_name, dir) ||
-		    ccs_pathcmp(ptr->fs_type, fs))
+		    ccs_pathcmp(ptr->dev_name, saved_dev) ||
+		    ccs_pathcmp(ptr->dir_name, saved_dir) ||
+		    ccs_pathcmp(ptr->fs_type, saved_fs))
 			continue;
+		ptr->is_deleted = is_delete;
 		error = 0;
-		if (is_delete) {
-			ptr->is_deleted = true;
-			goto out;
-		} else {
-			if (ptr->is_deleted) {
-				ptr->is_deleted = false;
-				goto update;
-			}
-			goto out; /* No changes. */
-		}
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->dev_name = saved_dev;
+		saved_dev = NULL;
+		entry->dir_name = saved_dir;
+		saved_dir = NULL;
+		entry->fs_type = saved_fs;
+		saved_fs = NULL;
+		entry->flags = flags;
+		list_add_tail(&entry->list, &ccs_mount_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	if (is_delete || error)
 		goto out;
-	new_entry->dev_name = dev;
-	new_entry->dir_name = dir;
-	new_entry->fs_type = fs;
-	new_entry->flags = flags;
-	list1_add_tail_mb(&new_entry->list, &ccs_mount_list);
-	error = 0;
-	ptr = new_entry;
- update:
-	if (!strcmp(fs->name, MOUNT_REMOUNT_KEYWORD)) {
+	if (!strcmp(fs_type, MOUNT_REMOUNT_KEYWORD))
 		printk(KERN_CONT "%sAllow remount %s with options 0x%lX.\n",
-		       ccs_log_level, dir->name, ptr->flags);
-	} else if (!strcmp(fs->name, MOUNT_BIND_KEYWORD)
-		   || !strcmp(fs->name, MOUNT_MOVE_KEYWORD)) {
+		       ccs_log_level, dir_name, flags);
+	else if (!strcmp(fs_type, MOUNT_BIND_KEYWORD)
+		 || !strcmp(fs_type, MOUNT_MOVE_KEYWORD))
 		printk(KERN_CONT "%sAllow mount %s %s %s with options 0x%lX\n",
-		       ccs_log_level, fs->name, dev->name, dir->name,
-		       ptr->flags);
-	} else if (!strcmp(fs->name, MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
-		   !strcmp(fs->name, MOUNT_MAKE_PRIVATE_KEYWORD) ||
-		   !strcmp(fs->name, MOUNT_MAKE_SLAVE_KEYWORD) ||
-		   !strcmp(fs->name, MOUNT_MAKE_SHARED_KEYWORD)) {
+		       ccs_log_level, fs_type, dev_name, dir_name, flags);
+	else if (!strcmp(fs_type, MOUNT_MAKE_UNBINDABLE_KEYWORD) ||
+		 !strcmp(fs_type, MOUNT_MAKE_PRIVATE_KEYWORD) ||
+		 !strcmp(fs_type, MOUNT_MAKE_SLAVE_KEYWORD) ||
+		 !strcmp(fs_type, MOUNT_MAKE_SHARED_KEYWORD))
 		printk(KERN_CONT "%sAllow mount %s %s with options 0x%lX.\n",
-		       ccs_log_level, fs->name, dir->name, ptr->flags);
-	} else {
-		type = get_fs_type(fs->name);
+		       ccs_log_level, fs_type, dir_name, flags);
+	else {
+		struct file_system_type *type = get_fs_type(fs_type);
 		if (type && (type->fs_flags & FS_REQUIRES_DEV) != 0)
 			printk(KERN_CONT "%sAllow mount -t %s %s %s "
 			       "with options 0x%lX.\n", ccs_log_level,
-			       fs->name, dev->name, dir->name, ptr->flags);
+			       fs_type, dev_name, dir_name, flags);
 		else
 			printk(KERN_CONT "%sAllow mount %s on %s "
 			       "with options 0x%lX.\n", ccs_log_level,
-			       fs->name, dir->name, ptr->flags);
+			       fs_type, dir_name, flags);
+		if (type)
+			put_filesystem(type);
 	}
-	if (type)
-		put_filesystem(type);
  out:
-	mutex_unlock(&lock);
+	ccs_put_name(saved_dev);
+	ccs_put_name(saved_dir);
+	ccs_put_name(saved_fs);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 	return error;
 }
@@ -440,7 +428,9 @@
 		}
 		rdev.name = requested_dev_name;
 		ccs_fill_path_info(&rdev);
-		list1_for_each_entry(ptr, &ccs_mount_list, list) {
+		/***** READER SECTION START *****/
+		down_read(&ccs_policy_lock);
+		list_for_each_entry(ptr, &ccs_mount_list, list) {
 			if (ptr->is_deleted)
 				continue;
 
@@ -468,6 +458,8 @@
 					  requested_type, flags, need_dev);
 			break;
 		}
+		up_read(&ccs_policy_lock);
+		/***** READER SECTION END *****/
 		if (error)
 			error = ccs_print_error(r, requested_dev_name,
 						requested_dir_name,
@@ -561,18 +553,22 @@
  */
 bool ccs_read_mount_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &ccs_mount_list) {
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list, &ccs_mount_list) {
 		struct ccs_mount_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_mount_entry, list);
+		ptr = list_entry(pos, struct ccs_mount_entry, list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, KEYWORD_ALLOW_MOUNT "%s %s %s 0x%lX\n",
-				   ptr->dev_name->name, ptr->dir_name->name,
-				   ptr->fs_type->name, ptr->flags))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_ALLOW_MOUNT "%s %s %s 0x%lX\n",
+				     ptr->dev_name->name, ptr->dir_name->name,
+				     ptr->fs_type->name, ptr->flags);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_audit.c	(working copy)
@@ -137,9 +137,9 @@
 	struct timeval tv;
 	u32 ccs_flags = current->ccs_flags;
 	const char *domainname;
-	if (!r->domain)
-		r->domain = ccs_current_domain();
-	domainname = r->domain->domainname->name;
+	if (!r->cookie.u.domain)
+		r->cookie.u.domain = ccs_current_domain();
+	domainname = r->cookie.u.domain->domainname->name;
 	do_gettimeofday(&tv);
 	*len += strlen(domainname) + 256;
 	if (r->ee) {
@@ -188,19 +188,19 @@
 	const struct ccs_condition_list *ptr = r->cond;
 	if (ptr) {
 		struct task_struct *task = current;
-		const u8 flags = ptr->post_state[3];
+		const u8 flags = ptr->head.post_state[3];
 		u32 ccs_flags = task->ccs_flags;
 		if (flags & 1) {
 			ccs_flags &= ~0xFF000000;
-			ccs_flags |= ptr->post_state[0] << 24;
+			ccs_flags |= ptr->head.post_state[0] << 24;
 		}
 		if (flags & 2) {
 			ccs_flags &= ~0x00FF0000;
-			ccs_flags |= ptr->post_state[1] << 16;
+			ccs_flags |= ptr->head.post_state[1] << 16;
 		}
 		if (flags & 4) {
 			ccs_flags &= ~0x0000FF00;
-			ccs_flags |= ptr->post_state[2] << 8;
+			ccs_flags |= ptr->head.post_state[2] << 8;
 		}
 		task->ccs_flags = ccs_flags;
 		r->cond = NULL;
@@ -284,9 +284,9 @@
 	int len;
 	char *buf;
 	struct ccs_log_entry *new_entry;
-	if (!r->domain)
-		r->domain = ccs_current_domain();
-	if (!ccs_can_save_audit_log(r->domain, is_granted))
+	if (!r->cookie.u.domain)
+		r->cookie.u.domain = ccs_current_domain();
+	if (!ccs_can_save_audit_log(r->cookie.u.domain, is_granted))
 		goto out;
 	va_start(args, fmt);
 	len = vsnprintf((char *) &pos, sizeof(pos) - 1, fmt, args) + 32;
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_domain.c	(working copy)
@@ -35,74 +35,11 @@
 struct ccs_domain_info ccs_kernel_domain;
 
 /* The list for "struct ccs_domain_info". */
-LIST1_HEAD(ccs_domain_list);
+LIST_HEAD(ccs_domain_list);
 
 #ifdef CONFIG_TOMOYO
 
-/* Domain creation lock. */
-static DEFINE_MUTEX(ccs_domain_list_lock);
-
-/* Structure for "initialize_domain" and "no_initialize_domain" keyword. */
-struct ccs_domain_initializer_entry {
-	struct list1_head list;
-	const struct ccs_path_info *domainname;    /* This may be NULL */
-	const struct ccs_path_info *program;
-	bool is_deleted;
-	bool is_not;       /* True if this entry is "no_initialize_domain".  */
-	bool is_last_name; /* True if the domainname is ccs_get_last_name(). */
-};
-
-/* Structure for "keep_domain" and "no_keep_domain" keyword. */
-struct ccs_domain_keeper_entry {
-	struct list1_head list;
-	const struct ccs_path_info *domainname;
-	const struct ccs_path_info *program;       /* This may be NULL */
-	bool is_deleted;
-	bool is_not;       /* True if this entry is "no_keep_domain".        */
-	bool is_last_name; /* True if the domainname is ccs_get_last_name(). */
-};
-
-/* Structure for "aggregator" keyword. */
-struct ccs_aggregator_entry {
-	struct list1_head list;
-	const struct ccs_path_info *original_name;
-	const struct ccs_path_info *aggregated_name;
-	bool is_deleted;
-};
-
-/* Structure for "alias" keyword. */
-struct ccs_alias_entry {
-	struct list1_head list;
-	const struct ccs_path_info *original_name;
-	const struct ccs_path_info *aliased_name;
-	bool is_deleted;
-};
-
 /**
- * ccs_set_domain_flag - Set or clear domain's attribute flags.
- *
- * @domain:    Pointer to "struct ccs_domain_info".
- * @is_delete: True if it is a delete request.
- * @flags:     Flags to set or clear.
- *
- * Returns nothing.
- */
-void ccs_set_domain_flag(struct ccs_domain_info *domain, const bool is_delete,
-			 const u8 flags)
-{
-	/* We need to serialize because this is bitfield operation. */
-	static DEFINE_SPINLOCK(lock);
-	/***** CRITICAL SECTION START *****/
-	spin_lock(&lock);
-	if (!is_delete)
-		domain->flags |= flags;
-	else
-		domain->flags &= ~flags;
-	spin_unlock(&lock);
-	/***** CRITICAL SECTION END *****/
-}
-
-/**
  * ccs_get_last_name - Get last component of a domainname.
  *
  * @domain: Pointer to "struct ccs_domain_info".
@@ -129,16 +66,7 @@
 int ccs_add_domain_acl(struct ccs_domain_info *domain, struct ccs_acl_info *acl)
 {
 	if (domain) {
-		/*
-		 * We need to serialize because this function is called by
-		 * various update functions.
-		 */
-		static DEFINE_SPINLOCK(lock);
-		/***** CRITICAL SECTION START *****/
-		spin_lock(&lock);
-		list1_add_tail_mb(&acl->list, &domain->acl_info_list);
-		spin_unlock(&lock);
-		/***** CRITICAL SECTION END *****/
+		list_add_tail(&acl->list, &domain->acl_info_list);
 	} else {
 		acl->type &= ~ACL_DELETED;
 	}
@@ -174,7 +102,7 @@
 {
 	struct ccs_request_info *r = &ee->r;
 	const char *handler = ee->handler->name;
-	r->mode = ccs_check_flags(r->domain, CCS_MAC_FOR_FILE);
+	r->mode = ccs_check_flags(r->cookie.u.domain, CCS_MAC_FOR_FILE);
 	return ccs_write_audit_log(true, r, "%s %s\n",
 				   is_default ? KEYWORD_EXECUTE_HANDLER :
 				   KEYWORD_DENIED_EXECUTE_HANDLER, handler);
@@ -195,7 +123,7 @@
 }
 
 /* The list for "struct ccs_domain_initializer_entry". */
-static LIST1_HEAD(ccs_domain_initializer_list);
+LIST_HEAD(ccs_domain_initializer_list);
 
 /**
  * ccs_update_domain_initializer_entry - Update "struct ccs_domain_initializer_entry" list.
@@ -212,12 +140,11 @@
 					       const bool is_not,
 					       const bool is_delete)
 {
-	struct ccs_domain_initializer_entry *new_entry;
+	struct ccs_domain_initializer_entry *entry = NULL;
 	struct ccs_domain_initializer_entry *ptr;
-	static DEFINE_MUTEX(lock);
 	const struct ccs_path_info *saved_program;
 	const struct ccs_path_info *saved_domainname = NULL;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	bool is_last_name = false;
 	if (!ccs_is_correct_path(program, 1, -1, -1, __func__))
 		return -EINVAL; /* No patterns allowed. */
@@ -227,38 +154,44 @@
 			is_last_name = true;
 		else if (!ccs_is_correct_domain(domainname, __func__))
 			return -EINVAL;
-		saved_domainname = ccs_save_name(domainname);
+		saved_domainname = ccs_get_name(domainname);
 		if (!saved_domainname)
 			return -ENOMEM;
 	}
-	saved_program = ccs_save_name(program);
-	if (!saved_program)
+	saved_program = ccs_get_name(program);
+	if (!saved_program) {
+		ccs_put_name(saved_domainname);
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_domain_initializer_list, list) {
+	}
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_domain_initializer_list, list) {
 		if (ptr->is_not != is_not ||
 		    ptr->domainname != saved_domainname ||
 		    ptr->program != saved_program)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->domainname = saved_domainname;
+		saved_domainname = NULL;
+		entry->program = saved_program;
+		saved_program = NULL;
+		entry->is_not = is_not;
+		entry->is_last_name = is_last_name;
+		list_add_tail(&entry->list, &ccs_domain_initializer_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->domainname = saved_domainname;
-	new_entry->program = saved_program;
-	new_entry->is_not = is_not;
-	new_entry->is_last_name = is_last_name;
-	list1_add_tail_mb(&new_entry->list, &ccs_domain_initializer_list);
-	error = 0;
- out:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_domainname);
+	ccs_put_name(saved_program);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
@@ -272,14 +205,17 @@
  */
 bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2,
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list,
 			      &ccs_domain_initializer_list) {
 		const char *no;
 		const char *from = "";
 		const char *domain = "";
 		struct ccs_domain_initializer_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_domain_initializer_entry,
+		ptr = list_entry(pos, struct ccs_domain_initializer_entry,
 				  list);
 		if (ptr->is_deleted)
 			continue;
@@ -288,14 +224,15 @@
 			from = " from ";
 			domain = ptr->domainname->name;
 		}
-		if (!ccs_io_printf(head,
-				   "%s" KEYWORD_INITIALIZE_DOMAIN "%s%s%s\n",
-				   no, ptr->program->name, from, domain))
-			goto out;
+		done = ccs_io_printf(head,
+				     "%s" KEYWORD_INITIALIZE_DOMAIN "%s%s%s\n",
+				     no, ptr->program->name, from, domain);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
 
 /**
@@ -336,7 +273,9 @@
 {
 	struct ccs_domain_initializer_entry *ptr;
 	bool flag = false;
-	list1_for_each_entry(ptr, &ccs_domain_initializer_list, list) {
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_domain_initializer_list, list) {
 		if (ptr->is_deleted)
 			continue;
 		if (ptr->domainname) {
@@ -350,15 +289,19 @@
 		}
 		if (ccs_pathcmp(ptr->program, program))
 			continue;
-		if (ptr->is_not)
-			return false;
+		if (ptr->is_not) {
+			flag = false;
+			break;
+		}
 		flag = true;
 	}
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
 	return flag;
 }
 
 /* The list for "struct ccs_domain_keeper_entry". */
-static LIST1_HEAD(ccs_domain_keeper_list);
+LIST_HEAD(ccs_domain_keeper_list);
 
 /**
  * ccs_update_domain_keeper_entry - Update "struct ccs_domain_keeper_entry" list.
@@ -375,12 +318,11 @@
 					  const bool is_not,
 					  const bool is_delete)
 {
-	struct ccs_domain_keeper_entry *new_entry;
+	struct ccs_domain_keeper_entry *entry = NULL;
 	struct ccs_domain_keeper_entry *ptr;
 	const struct ccs_path_info *saved_domainname;
 	const struct ccs_path_info *saved_program = NULL;
-	static DEFINE_MUTEX(lock);
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	bool is_last_name = false;
 	if (!ccs_is_domain_def(domainname) &&
 	    ccs_is_correct_path(domainname, 1, -1, -1, __func__))
@@ -390,38 +332,44 @@
 	if (program) {
 		if (!ccs_is_correct_path(program, 1, -1, -1, __func__))
 			return -EINVAL;
-		saved_program = ccs_save_name(program);
+		saved_program = ccs_get_name(program);
 		if (!saved_program)
 			return -ENOMEM;
 	}
-	saved_domainname = ccs_save_name(domainname);
-	if (!saved_domainname)
+	saved_domainname = ccs_get_name(domainname);
+	if (!saved_domainname) {
+		ccs_put_name(saved_program);
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_domain_keeper_list, list) {
+	}
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_domain_keeper_list, list) {
 		if (ptr->is_not != is_not ||
 		    ptr->domainname != saved_domainname ||
 		    ptr->program != saved_program)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->domainname = saved_domainname;
+		saved_domainname = NULL;
+		entry->program = saved_program;
+		saved_program = NULL;
+		entry->is_not = is_not;
+		entry->is_last_name = is_last_name;
+		list_add_tail(&entry->list, &ccs_domain_keeper_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->domainname = saved_domainname;
-	new_entry->program = saved_program;
-	new_entry->is_not = is_not;
-	new_entry->is_last_name = is_last_name;
-	list1_add_tail_mb(&new_entry->list, &ccs_domain_keeper_list);
-	error = 0;
- out:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_domainname);
+	ccs_put_name(saved_program);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
@@ -455,13 +403,17 @@
  */
 bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &ccs_domain_keeper_list) {
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list,
+			      &ccs_domain_keeper_list) {
 		struct ccs_domain_keeper_entry *ptr;
 		const char *no;
 		const char *from = "";
 		const char *program = "";
-		ptr = list1_entry(pos, struct ccs_domain_keeper_entry, list);
+		ptr = list_entry(pos, struct ccs_domain_keeper_entry, list);
 		if (ptr->is_deleted)
 			continue;
 		no = ptr->is_not ? "no_" : "";
@@ -469,14 +421,15 @@
 			from = " from ";
 			program = ptr->program->name;
 		}
-		if (!ccs_io_printf(head,
-				   "%s" KEYWORD_KEEP_DOMAIN "%s%s%s\n", no,
-				   program, from, ptr->domainname->name))
-			goto out;
+		done = ccs_io_printf(head,
+				     "%s" KEYWORD_KEEP_DOMAIN "%s%s%s\n", no,
+				     program, from, ptr->domainname->name);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
 
 /**
@@ -495,7 +448,9 @@
 {
 	struct ccs_domain_keeper_entry *ptr;
 	bool flag = false;
-	list1_for_each_entry(ptr, &ccs_domain_keeper_list, list) {
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_domain_keeper_list, list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!ptr->is_last_name) {
@@ -507,15 +462,19 @@
 		}
 		if (ptr->program && ccs_pathcmp(ptr->program, program))
 			continue;
-		if (ptr->is_not)
-			return false;
+		if (ptr->is_not) {
+			flag = false;
+			break;
+		}
 		flag = true;
 	}
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
 	return flag;
 }
 
 /* The list for "struct ccs_alias_entry". */
-static LIST1_HEAD(ccs_alias_list);
+LIST_HEAD(ccs_alias_list);
 
 /**
  * ccs_update_alias_entry - Update "struct ccs_alias_entry" list.
@@ -530,41 +489,47 @@
 				  const char *aliased_name,
 				  const bool is_delete)
 {
-	struct ccs_alias_entry *new_entry;
+	struct ccs_alias_entry *entry = NULL;
 	struct ccs_alias_entry *ptr;
-	static DEFINE_MUTEX(lock);
 	const struct ccs_path_info *saved_original_name;
 	const struct ccs_path_info *saved_aliased_name;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(original_name, 1, -1, -1, __func__) ||
 	    !ccs_is_correct_path(aliased_name, 1, -1, -1, __func__))
 		return -EINVAL; /* No patterns allowed. */
-	saved_original_name = ccs_save_name(original_name);
-	saved_aliased_name = ccs_save_name(aliased_name);
-	if (!saved_original_name || !saved_aliased_name)
+	saved_original_name = ccs_get_name(original_name);
+	saved_aliased_name = ccs_get_name(aliased_name);
+	if (!saved_original_name || !saved_aliased_name) {
+		ccs_put_name(saved_original_name);
+		ccs_put_name(saved_aliased_name);
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_alias_list, list) {
+	}
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_alias_list, list) {
 		if (ptr->original_name != saved_original_name ||
 		    ptr->aliased_name != saved_aliased_name)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->original_name = saved_original_name;
+		saved_original_name = NULL;
+		entry->aliased_name = saved_aliased_name;
+		saved_aliased_name = NULL;
+		list_add_tail(&entry->list, &ccs_alias_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->original_name = saved_original_name;
-	new_entry->aliased_name = saved_aliased_name;
-	list1_add_tail_mb(&new_entry->list, &ccs_alias_list);
-	error = 0;
- out:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_original_name);
+	ccs_put_name(saved_aliased_name);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
@@ -578,20 +543,24 @@
  */
 bool ccs_read_alias_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &ccs_alias_list) {
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list, &ccs_alias_list) {
 		struct ccs_alias_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_alias_entry, list);
+		ptr = list_entry(pos, struct ccs_alias_entry, list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, KEYWORD_ALIAS "%s %s\n",
-				   ptr->original_name->name,
-				   ptr->aliased_name->name))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_ALIAS "%s %s\n",
+				     ptr->original_name->name,
+				     ptr->aliased_name->name);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
 
 /**
@@ -612,7 +581,7 @@
 }
 
 /* The list for "struct ccs_aggregator_entry". */
-static LIST1_HEAD(ccs_aggregator_list);
+LIST_HEAD(ccs_aggregator_list);
 
 /**
  * ccs_update_aggregator_entry - Update "struct ccs_aggregator_entry" list.
@@ -627,41 +596,47 @@
 				       const char *aggregated_name,
 				       const bool is_delete)
 {
-	struct ccs_aggregator_entry *new_entry;
+	struct ccs_aggregator_entry *entry = NULL;
 	struct ccs_aggregator_entry *ptr;
-	static DEFINE_MUTEX(lock);
 	const struct ccs_path_info *saved_original_name;
 	const struct ccs_path_info *saved_aggregated_name;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(original_name, 1, 0, -1, __func__) ||
 	    !ccs_is_correct_path(aggregated_name, 1, -1, -1, __func__))
 		return -EINVAL;
-	saved_original_name = ccs_save_name(original_name);
-	saved_aggregated_name = ccs_save_name(aggregated_name);
-	if (!saved_original_name || !saved_aggregated_name)
+	saved_original_name = ccs_get_name(original_name);
+	saved_aggregated_name = ccs_get_name(aggregated_name);
+	if (!saved_original_name || !saved_aggregated_name) {
+		ccs_put_name(saved_original_name);
+		ccs_put_name(saved_aggregated_name);
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_aggregator_list, list) {
+	}
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_aggregator_list, list) {
 		if (ptr->original_name != saved_original_name ||
 		    ptr->aggregated_name != saved_aggregated_name)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->original_name = saved_original_name;
+		saved_original_name = NULL;
+		entry->aggregated_name = saved_aggregated_name;
+		saved_aggregated_name = NULL;
+		list_add_tail(&entry->list, &ccs_aggregator_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->original_name = saved_original_name;
-	new_entry->aggregated_name = saved_aggregated_name;
-	list1_add_tail_mb(&new_entry->list, &ccs_aggregator_list);
-	error = 0;
- out:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_original_name);
+	ccs_put_name(saved_aggregated_name);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
@@ -675,20 +650,25 @@
  */
 bool ccs_read_aggregator_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &ccs_aggregator_list) {
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list,
+			      &ccs_aggregator_list) {
 		struct ccs_aggregator_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_aggregator_entry, list);
+		ptr = list_entry(pos, struct ccs_aggregator_entry, list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, KEYWORD_AGGREGATOR "%s %s\n",
-				   ptr->original_name->name,
-				   ptr->aggregated_name->name))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_AGGREGATOR "%s %s\n",
+				     ptr->original_name->name,
+				     ptr->aggregated_name->name);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
 
 /**
@@ -723,9 +703,10 @@
 	struct ccs_path_info name;
 	name.name = domainname;
 	ccs_fill_path_info(&name);
-	mutex_lock(&ccs_domain_list_lock);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
 	/* Is there an active domain? */
-	list1_for_each_entry(domain, &ccs_domain_list, list) {
+	list_for_each_entry(domain, &ccs_domain_list, list) {
 		/* Never delete ccs_kernel_domain */
 		if (domain == &ccs_kernel_domain)
 			continue;
@@ -735,7 +716,8 @@
 		domain->is_deleted = true;
 		break;
 	}
-	mutex_unlock(&ccs_domain_list_lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	return 0;
 }
 
@@ -744,65 +726,36 @@
  *
  * @domainname: The name of domain.
  * @profile:    Profile number to assign if the domain was newly created.
+ * @cookie:     Pointer to "struct ccs_cookie".
  *
- * Returns pointer to "struct ccs_domain_info" on success, NULL otherwise.
+ * Returns true on success, false otherwise.
  */
-struct ccs_domain_info *ccs_find_or_assign_new_domain(const char *domainname,
-						  const u8 profile)
+bool ccs_find_or_assign_new_domain(const char *domainname, const u8 profile,
+				   struct ccs_cookie *cookie)
 {
-	struct ccs_domain_info *domain = NULL;
-	const struct ccs_path_info *saved_domainname;
-	mutex_lock(&ccs_domain_list_lock);
-	domain = ccs_find_domain(domainname);
-	if (domain)
+	struct ccs_domain_info *domain = kzalloc(sizeof(*domain), GFP_KERNEL);
+	const struct ccs_path_info *saved_domainname = ccs_get_name(domainname);
+	if (!domain || !saved_domainname)
 		goto out;
-	if (!ccs_is_correct_domain(domainname, __func__))
-		goto out;
-	saved_domainname = ccs_save_name(domainname);
-	if (!saved_domainname)
-		goto out;
-	/* Can I reuse memory of deleted domain? */
-	list1_for_each_entry(domain, &ccs_domain_list, list) {
-		struct task_struct *p;
-		struct ccs_acl_info *ptr;
-		bool flag;
-		if (!domain->is_deleted ||
-		    domain->domainname != saved_domainname)
-			continue;
-		flag = false;
-		/***** CRITICAL SECTION START *****/
-		read_lock(&tasklist_lock);
-		for_each_process(p) {
-			if (ccs_task_domain(p) != domain)
-				continue;
-			flag = true;
-			break;
-		}
-		read_unlock(&tasklist_lock);
-		/***** CRITICAL SECTION END *****/
-		if (flag)
-			continue;
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-			ptr->type |= ACL_DELETED;
-		}
-		ccs_set_domain_flag(domain, true, domain->flags);
-		domain->profile = profile;
-		domain->quota_warned = false;
-		mb(); /* Avoid out-of-order execution. */
-		domain->is_deleted = false;
-		goto out;
-	}
-	/* No memory reusable. Create using new memory. */
-	domain = ccs_alloc_element(sizeof(*domain));
-	if (domain) {
-		INIT_LIST1_HEAD(&domain->acl_info_list);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	if (!ccs_find_domain(domainname, cookie) &&
+	    ccs_is_correct_domain(domainname, __func__) &&
+	    ccs_memory_ok(domain)) {
+		INIT_LIST_HEAD(&domain->acl_info_list);
 		domain->domainname = saved_domainname;
+		saved_domainname = NULL;
 		domain->profile = profile;
-		list1_add_tail_mb(&domain->list, &ccs_domain_list);
+		list_add_tail(&domain->list, &ccs_domain_list);
+		cookie->u.domain = domain;
+		domain = NULL;
 	}
  out:
-	mutex_unlock(&ccs_domain_list_lock);
-	return domain;
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_domainname);
+	kfree(domain);
+	return cookie->u.domain != NULL;
 }
 
 /**
@@ -872,7 +825,7 @@
 	struct ccs_request_info *r = &ee->r;
 	const struct ccs_path_info *handler = ee->handler;
 	struct ccs_domain_info *domain = NULL;
-	const char *old_domain_name = r->domain->domainname->name;
+	const char *old_domain_name = r->cookie.u.domain->domainname->name;
 	struct linux_binprm *bprm = ee->bprm;
 	const u8 mode = r->mode;
 	const bool is_enforce = (mode == 3);
@@ -882,6 +835,7 @@
 	struct ccs_path_info sn; /* symlink name */
 	struct ccs_path_info ln; /* last name */
 	int retval;
+	bool found = false;
  retry:
 	current->ccs_flags = ccs_flags;
 	r->cond = NULL;
@@ -894,7 +848,7 @@
 	ccs_fill_path_info(&rn);
 	sn.name = ee->tmp;
 	ccs_fill_path_info(&sn);
-	ln.name = ccs_get_last_name(r->domain);
+	ln.name = ccs_get_last_name(r->cookie.u.domain);
 	ccs_fill_path_info(&ln);
 
 	if (handler) {
@@ -915,7 +869,9 @@
 	if (ccs_pathcmp(&rn, &sn)) {
 		struct ccs_alias_entry *ptr;
 		/* Is this program allowed to be called via symbolic links? */
-		list1_for_each_entry(ptr, &ccs_alias_list, list) {
+		/***** READER SECTION START *****/
+		down_read(&ccs_policy_lock);
+		list_for_each_entry(ptr, &ccs_alias_list, list) {
 			if (ptr->is_deleted ||
 			    ccs_pathcmp(&rn, ptr->original_name) ||
 			    ccs_pathcmp(&sn, ptr->aliased_name))
@@ -925,11 +881,13 @@
 			ccs_fill_path_info(&rn);
 			break;
 		}
+		up_read(&ccs_policy_lock);
+		/***** READER SECTION END *****/
 	}
 	/* sn will be overwritten after here. */
 
 	/* Compare basename of program_path and argv[0] */
-	r->mode = ccs_check_flags(r->domain, CCS_MAC_FOR_ARGV0);
+	r->mode = ccs_check_flags(r->cookie.u.domain, CCS_MAC_FOR_ARGV0);
 	if (bprm->argc > 0 && r->mode) {
 		char *base_argv0 = ee->tmp;
 		const char *base_filename;
@@ -954,7 +912,9 @@
 	{
 		struct ccs_aggregator_entry *ptr;
 		/* Is this program allowed to be aggregated? */
-		list1_for_each_entry(ptr, &ccs_aggregator_list, list) {
+		/***** READER SECTION START *****/
+		down_read(&ccs_policy_lock);
+		list_for_each_entry(ptr, &ccs_aggregator_list, list) {
 			if (ptr->is_deleted ||
 			    !ccs_path_matches_pattern(&rn, ptr->original_name))
 				continue;
@@ -963,6 +923,8 @@
 			ccs_fill_path_info(&rn);
 			break;
 		}
+		up_read(&ccs_policy_lock);
+		/***** READER SECTION END *****/
 	}
 
 	/* Check execute permission. */
@@ -975,29 +937,35 @@
 
  calculate_domain:
 	new_domain_name = ee->tmp;
-	if (ccs_is_domain_initializer(r->domain->domainname, &rn, &ln)) {
+	if (ccs_is_domain_initializer(r->cookie.u.domain->domainname, &rn,
+				      &ln)) {
 		/* Transit to the child of ccs_kernel_domain domain. */
 		snprintf(new_domain_name, CCS_EXEC_TMPSIZE - 1,
 			 ROOT_NAME " " "%s", ee->program_path);
-	} else if (r->domain == &ccs_kernel_domain && !ccs_policy_loaded) {
+	} else if (r->cookie.u.domain == &ccs_kernel_domain &&
+		   !ccs_policy_loaded) {
 		/*
 		 * Needn't to transit from kernel domain before starting
 		 * /sbin/init. But transit from kernel domain if executing
 		 * initializers because they might start before /sbin/init.
 		 */
-		domain = r->domain;
-	} else if (ccs_is_domain_keeper(r->domain->domainname, &rn, &ln)) {
+		found = true;
+	} else if (ccs_is_domain_keeper(r->cookie.u.domain->domainname, &rn, &ln)) {
 		/* Keep current domain. */
-		domain = r->domain;
+		found = true;
 	} else {
 		/* Normal domain transition. */
 		snprintf(new_domain_name, CCS_EXEC_TMPSIZE - 1,
 			 "%s %s", old_domain_name, ee->program_path);
 	}
-	if (domain || strlen(new_domain_name) >= CCS_MAX_PATHNAME_LEN)
+	if (found || strlen(new_domain_name) >= CCS_MAX_PATHNAME_LEN)
 		goto done;
-	domain = ccs_find_domain(new_domain_name);
-	if (domain)
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	found = ccs_find_domain(new_domain_name, &r->cookie);
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	if (found)
 		goto done;
 	if (is_enforce) {
 		int error = ccs_check_supervisor(r,
@@ -1008,26 +976,24 @@
 		if (error < 0)
 			goto done;
 	}
-	domain = ccs_find_or_assign_new_domain(new_domain_name, r->profile);
-	if (domain)
+	found = ccs_find_or_assign_new_domain(new_domain_name, r->profile,
+					      &r->cookie);
+	if (found)
 		ccs_audit_domain_creation_log(domain);
  done:
-	if (!domain) {
-		printk(KERN_WARNING "TOMOYO-ERROR: Domain '%s' not defined.\n",
-		       new_domain_name);
-		if (is_enforce)
-			retval = -EPERM;
-		else {
-			retval = 0;
-			ccs_set_domain_flag(r->domain, false,
-					    DOMAIN_FLAGS_TRANSITION_FAILED);
-		}
-	} else {
+	if (found) {
 		retval = 0;
+		goto out;
 	}
+	printk(KERN_WARNING "TOMOYO-ERROR: Domain '%s' not defined.\n",
+	       new_domain_name);
+	if (is_enforce)
+		retval = -EPERM;
+	else {
+		retval = 0;
+		r->cookie.u.domain->domain_transition_failed = true;
+	}
  out:
-	if (domain)
-		r->domain = domain;
 	return retval;
 }
 
@@ -1236,6 +1202,7 @@
 	}
 	/* ee->dump->data is allocated by ccs_dump_page(). */
 	ee->task = current;
+	ccs_add_cookie(&ee->r.cookie, current->ccs_domain_info);
 	/***** CRITICAL SECTION START *****/
 	spin_lock(&ccs_execve_list_lock);
 	list_add(&ee->list, &ccs_execve_list);
@@ -1284,6 +1251,7 @@
 	ccs_free(ee->program_path);
 	ccs_free(ee->tmp);
 	kfree(ee->dump.data);
+	ccs_del_cookie(&ee->r.cookie);
 	ccs_free(ee);
 }
 
@@ -1513,22 +1481,28 @@
 	struct task_struct *task = current;
 	const struct ccs_domain_info *domain = ccs_current_domain();
 	struct ccs_acl_info *ptr;
+	bool found = false;
 	/*
 	 * Don't use execute handler if the current process is
 	 * marked as execute handler to avoid infinite execute handler loop.
 	 */
 	if (task->ccs_flags & CCS_TASK_IS_EXECUTE_HANDLER)
 		return false;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct ccs_execute_handler_record *acl;
 		if (ptr->type != type)
 			continue;
 		acl = container_of(ptr, struct ccs_execute_handler_record,
 				   head);
 		ee->handler = acl->handler;
-		return true;
+		found = true;
+		break;
 	}
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return found;
 }
 
 /**
@@ -1592,7 +1566,7 @@
 	struct ccs_execve_entry *ee = ccs_find_execve_entry();
 	struct ccs_domain_info *next_domain = NULL;
 	if (ee)
-		next_domain = ee->next_domain;
+		next_domain = ee->r.cookie.u.domain;
 	if (!next_domain)
 		next_domain = ccs_current_domain();
 	return next_domain;
@@ -1639,11 +1613,10 @@
  ok:
 	if (retval < 0)
 		goto out;
-	ee->r.mode = ccs_check_flags(ee->r.domain, CCS_MAC_FOR_ENV);
+	ee->r.mode = ccs_check_flags(ee->r.cookie.u.domain, CCS_MAC_FOR_ENV);
 	retval = ccs_check_environ(ee);
 	if (retval < 0)
 		goto out;
-	ee->next_domain = ee->r.domain;
 	task->ccs_flags |= CCS_CHECK_READ_FOR_OPEN_EXEC;
 	retval = 0;
  out:
@@ -1666,9 +1639,12 @@
 		return;
 	if (retval < 0)
 		goto out;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
 	/* Proceed to next domain if execution suceeded. */
-	task->ccs_domain_info = ee->r.domain;
-	mb(); /* Make domain transition visible to other CPUs. */
+	task->ccs_domain_info = ee->r.cookie.u.domain;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
 	/* Mark the current process as execute handler. */
 	if (ee->handler)
 		task->ccs_flags |= CCS_TASK_IS_EXECUTE_HANDLER;
Index: trunk/1.6.x/ccs-patch/fs/ccs_common.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/ccs_common.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/ccs_common.c	(working copy)
@@ -31,8 +31,8 @@
 #else
 static const int ccs_lookup_flags = LOOKUP_FOLLOW | LOOKUP_POSITIVE;
 #endif
-#include <linux/realpath.h>
 #include <linux/ccs_common.h>
+#include <linux/realpath.h>
 #include <linux/ccs_proc.h>
 #include <linux/tomoyo.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
@@ -55,6 +55,8 @@
 #define MAX_REJECT_LOG   0
 #endif
 
+DECLARE_RWSEM(ccs_policy_lock);
+
 /* Has /sbin/init started? */
 bool ccs_policy_loaded;
 
@@ -467,21 +469,28 @@
  * ccs_find_domain - Find a domain by the given name.
  *
  * @domainname: The domainname to find.
+ * @cookie:     Pointer to "struct ccs_cookie".
  *
- * Returns pointer to "struct ccs_domain_info" if found, NULL otherwise.
+ * Caller holds	ccs_policy_lock for reading or writing.
+ *
+ * Returns true if found, false otherwise.
  */
-struct ccs_domain_info *ccs_find_domain(const char *domainname)
+bool ccs_find_domain(const char *domainname, struct ccs_cookie *cookie)
 {
+	/***** READER SECTION START *****/
 	struct ccs_domain_info *domain;
 	struct ccs_path_info name;
 	name.name = domainname;
 	ccs_fill_path_info(&name);
-	list1_for_each_entry(domain, &ccs_domain_list, list) {
-		if (!domain->is_deleted &&
-		    !ccs_pathcmp(&name, domain->domainname))
-			return domain;
+	list_for_each_entry(domain, &ccs_domain_list, list) {
+		if (domain->is_deleted ||
+		    ccs_pathcmp(&name, domain->domainname))
+			continue;
+		ccs_update_cookie(cookie, domain);
+		return true;
 	}
-	return NULL;
+	return false;
+	/***** READER SECTION END *****/
 }
 
 /**
@@ -964,7 +973,7 @@
 	memset(r, 0, sizeof(*r));
 	if (!domain)
 		domain = ccs_current_domain();
-	r->domain = domain;
+	r->cookie.u.domain = domain;
 	r->profile = domain->profile;
 	if (index < CCS_MAX_CONTROL_INDEX)
 		r->mode = ccs_check_flags(domain, index);
@@ -999,12 +1008,15 @@
 {
 	unsigned int count = 0;
 	struct ccs_acl_info *ptr;
+	bool quota_ok = false;
 	if (!domain)
 		return true;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 		if (ptr->type & ACL_DELETED)
 			continue;
-		switch (ccs_acl_type2(ptr)) {
+		switch (ptr->type) {
 			struct ccs_single_path_acl_record *acl1;
 			struct ccs_double_path_acl_record *acl2;
 			u16 perm;
@@ -1059,14 +1071,16 @@
 		}
 	}
 	if (count < ccs_check_flags(domain, CCS_MAX_ACCEPT_ENTRY))
-		return true;
-	if (!domain->quota_warned) {
+		quota_ok = true;
+	else if (!domain->quota_warned) {
 		domain->quota_warned = true;
 		printk(KERN_WARNING "TOMOYO-WARNING: "
 		       "Domain '%s' has so many ACLs to hold. "
 		       "Stopped learning mode.\n", domain->domainname->name);
 	}
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return quota_ok;
 }
 
 /**
@@ -1079,29 +1093,30 @@
 static struct ccs_profile *ccs_find_or_assign_new_profile(const unsigned int
 							  profile)
 {
-	static DEFINE_MUTEX(lock);
-	struct ccs_profile *ptr = NULL;
-	mutex_lock(&lock);
-	if (profile < MAX_PROFILES) {
-		ptr = ccs_profile_ptr[profile];
-		if (ptr)
-			goto ok;
-		ptr = ccs_alloc_element(sizeof(*ptr));
-		if (ptr) {
-			int i;
-			for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++)
-				ptr->value[i]
-					= ccs_control_array[i].current_value;
-			/*
-			 * Needn't to initialize "ptr->capability_value"
-			 * because they are always 0.
-			 */
-			mb(); /* Avoid out-of-order execution. */
-			ccs_profile_ptr[profile] = ptr;
-		}
+	struct ccs_profile *ptr;
+	struct ccs_profile *entry;
+	int i;
+	if (profile >= MAX_PROFILES)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	ptr = ccs_profile_ptr[profile];
+	if (!ptr && ccs_memory_ok(entry)) {
+		ptr = entry;
+		for (i = 0; i < CCS_MAX_CONTROL_INDEX; i++)
+			ptr->value[i] = ccs_control_array[i].current_value;
+		/*
+		 * Needn't to initialize "ptr->capability_value"
+		 * because they are always 0.
+		 */
+		mb(); /* Avoid out-of-order execution. */
+		ccs_profile_ptr[profile] = ptr;
+		entry = NULL;
 	}
- ok:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	kfree(entry);
 	return ptr;
 }
 
@@ -1134,7 +1149,7 @@
 	*cp = '\0';
 	ccs_update_counter(CCS_UPDATES_COUNTER_PROFILE);
 	if (!strcmp(data, "COMMENT")) {
-		ccs_profile->comment = ccs_save_name(cp + 1);
+		ccs_profile->comment = ccs_get_name(cp + 1);
 		ccs_profile_entry_used[0] = true;
 		return 0;
 	}
@@ -1295,17 +1310,8 @@
 	return 0;
 }
 
-/* Structure for policy manager. */
-struct ccs_policy_manager_entry {
-	struct list1_head list;
-	/* A path to program or a domainname. */
-	const struct ccs_path_info *manager;
-	bool is_domain;  /* True if manager is a domainname. */
-	bool is_deleted; /* True if this entry is deleted. */
-};
-
 /* The list for "struct ccs_policy_manager_entry". */
-static LIST1_HEAD(ccs_policy_manager_list);
+LIST_HEAD(ccs_policy_manager_list);
 
 /**
  * ccs_update_manager_entry - Add a manager entry.
@@ -1317,11 +1323,10 @@
  */
 static int ccs_update_manager_entry(const char *manager, const bool is_delete)
 {
-	struct ccs_policy_manager_entry *new_entry;
+	struct ccs_policy_manager_entry *entry = NULL;
 	struct ccs_policy_manager_entry *ptr;
-	static DEFINE_MUTEX(lock);
 	const struct ccs_path_info *saved_manager;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	bool is_domain = false;
 	if (ccs_is_domain_def(manager)) {
 		if (!ccs_is_correct_domain(manager, __func__))
@@ -1331,30 +1336,32 @@
 		if (!ccs_is_correct_path(manager, 1, -1, -1, __func__))
 			return -EINVAL;
 	}
-	saved_manager = ccs_save_name(manager);
+	saved_manager = ccs_get_name(manager);
 	if (!saved_manager)
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_policy_manager_list, list) {
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_policy_manager_list, list) {
 		if (ptr->manager != saved_manager)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->manager = saved_manager;
+		saved_manager = NULL;
+		entry->is_domain = is_domain;
+		list_add_tail(&entry->list, &ccs_policy_manager_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->manager = saved_manager;
-	new_entry->is_domain = is_domain;
-	list1_add_tail_mb(&new_entry->list, &ccs_policy_manager_list);
-	error = 0;
- out:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_manager);
+	kfree(entry);
 	if (!error)
 		ccs_update_counter(CCS_UPDATES_COUNTER_MANAGER);
 	return error;
@@ -1387,18 +1394,25 @@
  */
 static int ccs_read_manager_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
+	struct list_head *pos;
+	bool done = true;
 	if (head->read_eof)
 		return 0;
-	list1_for_each_cookie(pos, head->read_var2, &ccs_policy_manager_list) {
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list,
+			      &ccs_policy_manager_list) {
 		struct ccs_policy_manager_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_policy_manager_entry, list);
+		ptr = list_entry(pos, struct ccs_policy_manager_entry, list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, "%s\n", ptr->manager->name))
-			return 0;
+		done = ccs_io_printf(head, "%s\n", ptr->manager->name);
+		if (!done)
+			break;
 	}
-	head->read_eof = true;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	head->read_eof = done;
 	return 0;
 }
 
@@ -1422,7 +1436,7 @@
 		return true;
 	if (!ccs_manage_by_non_root && (current_uid() || current_euid()))
 		return false;
-	list1_for_each_entry(ptr, &ccs_policy_manager_list, list) {
+	list_for_each_entry(ptr, &ccs_policy_manager_list, list) {
 		if (!ptr->is_deleted && ptr->is_domain
 		    && !ccs_pathcmp(domainname, ptr->manager)) {
 			/* Set manager flag. */
@@ -1433,7 +1447,7 @@
 	exe = ccs_get_exe();
 	if (!exe)
 		return false;
-	list1_for_each_entry(ptr, &ccs_policy_manager_list, list) {
+	list_for_each_entry(ptr, &ccs_policy_manager_list, list) {
 		if (!ptr->is_deleted && !ptr->is_domain
 		    && !strcmp(exe, ptr->manager->name)) {
 			found = true;
@@ -1496,12 +1510,15 @@
 {
 	unsigned int pid;
 	struct ccs_domain_info *domain = NULL;
+	struct ccs_cookie *cookie = &head->write_var1;
 	if (!strcmp(data, "allow_execute")) {
 		head->read_execute_only = true;
 		return true;
 	}
 	if (sscanf(data, "pid=%u", &pid) == 1) {
 		struct task_struct *p;
+		/***** READER SECTION START *****/
+		down_read(&ccs_policy_lock);
 		/***** CRITICAL SECTION START *****/
 		read_lock(&tasklist_lock);
 		p = find_task_by_pid(pid);
@@ -1509,12 +1526,21 @@
 			domain = ccs_task_domain(p);
 		read_unlock(&tasklist_lock);
 		/***** CRITICAL SECTION END *****/
+		if (domain)
+			ccs_update_cookie(cookie, domain);
+		up_read(&ccs_policy_lock);
+		/***** READER SECTION END *****/
 	} else if (!strncmp(data, "domain=", 7)) {
-		if (ccs_is_domain_def(data + 7))
-			domain = ccs_find_domain(data + 7);
+		if (ccs_is_domain_def(data + 7)) {
+			/***** READER SECTION START *****/
+			down_read(&ccs_policy_lock);
+			if (ccs_find_domain(data + 7, cookie))
+				domain = cookie->u.domain;
+			up_read(&ccs_policy_lock);
+			/***** READER SECTION END *****/
+		}
 	} else
 		return false;
-	head->write_var1 = domain;
 	/* Accessing read_buf is safe because head->io_sem is held. */
 	if (!head->read_buf)
 		return true; /* Do nothing if open(O_WRONLY). */
@@ -1524,13 +1550,18 @@
 	head->read_eof = !domain;
 	if (domain) {
 		struct ccs_domain_info *d;
-		head->read_var1 = NULL;
-		list1_for_each_entry(d, &ccs_domain_list, list) {
-			if (d == domain)
-				break;
-			head->read_var1 = &d->list;
+		head->read_var1.u.list = NULL;
+		/***** READER SECTION START *****/
+		down_read(&ccs_policy_lock);
+		list_for_each_entry(d, &ccs_domain_list, list) {
+			if (d->list.next != &domain->list)
+				continue;
+			ccs_update_cookie(&head->read_var1, &d->list);
+			break;
 		}
-		head->read_var2 = NULL;
+		up_read(&ccs_policy_lock);
+		/***** READER SECTION END *****/
+		head->read_var2.u.list = NULL;
 		head->read_bit = 0;
 		head->read_step = 0;
 		if (domain->is_deleted)
@@ -1549,7 +1580,7 @@
 static int ccs_write_domain_policy(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
-	struct ccs_domain_info *domain = head->write_var1;
+	struct ccs_domain_info *domain = head->write_var1.u.domain;
 	bool is_delete = false;
 	bool is_select = false;
 	unsigned int profile;
@@ -1565,14 +1596,18 @@
 	if (!ccs_is_policy_manager())
 		return -EPERM;
 	if (ccs_is_domain_def(data)) {
-		domain = NULL;
-		if (is_delete)
+		struct ccs_cookie *cookie = &head->write_var1;
+		if (is_delete) {
 			ccs_delete_domain(data);
-		else if (is_select)
-			domain = ccs_find_domain(data);
-		else
-			domain = ccs_find_or_assign_new_domain(data, 0);
-		head->write_var1 = domain;
+			ccs_update_cookie(cookie, NULL);
+		} else if (is_select) {
+			/***** READER SECTION START *****/
+			down_read(&ccs_policy_lock);
+			ccs_find_domain(data, cookie);
+			up_read(&ccs_policy_lock);
+			/***** READER SECTION END *****/
+		} else
+			ccs_find_or_assign_new_domain(data, 0, cookie);
 		ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 		return 0;
 	}
@@ -1586,13 +1621,11 @@
 		return 0;
 	}
 	if (!strcmp(data, KEYWORD_IGNORE_GLOBAL_ALLOW_READ)) {
-		ccs_set_domain_flag(domain, is_delete,
-				    DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ);
+		domain->ignore_global_allow_read = !is_delete;
 		return 0;
 	}
 	if (!strcmp(data, KEYWORD_IGNORE_GLOBAL_ALLOW_ENV)) {
-		ccs_set_domain_flag(domain, is_delete,
-				    DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV);
+		domain->ignore_global_allow_env = !is_delete;
 		return 0;
 	}
 	cp = ccs_find_condition_part(data);
@@ -1991,7 +2024,7 @@
 			    struct ccs_acl_info *ptr)
 {
 	const struct ccs_condition_list *cond = ccs_get_condition_part(ptr);
-	const u8 acl_type = ccs_acl_type2(ptr);
+	const u8 acl_type = ptr->type;
 	if (acl_type & ACL_DELETED)
 		return true;
 	if (acl_type == TYPE_SINGLE_PATH_ACL) {
@@ -2070,19 +2103,19 @@
  */
 static int ccs_read_domain_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *dpos;
-	struct list1_head *apos;
+	struct list_head *dpos;
+	struct list_head *apos;
 	if (head->read_eof)
 		return 0;
 	if (head->read_step == 0)
 		head->read_step = 1;
-	list1_for_each_cookie(dpos, head->read_var1, &ccs_domain_list) {
+	list_for_each_cookie(dpos, head->read_var1.u.list, &ccs_domain_list) {
 		struct ccs_domain_info *domain;
 		const char *quota_exceeded = "";
 		const char *transition_failed = "";
 		const char *ignore_global_allow_read = "";
 		const char *ignore_global_allow_env = "";
-		domain = list1_entry(dpos, struct ccs_domain_info, list);
+		domain = list_entry(dpos, struct ccs_domain_info, list);
 		if (head->read_step != 1)
 			goto acl_loop;
 		if (domain->is_deleted && !head->read_single_domain)
@@ -2090,12 +2123,12 @@
 		/* Print domainname and flags. */
 		if (domain->quota_warned)
 			quota_exceeded = "quota_exceeded\n";
-		if (domain->flags & DOMAIN_FLAGS_TRANSITION_FAILED)
+		if (domain->domain_transition_failed)
 			transition_failed = "transition_failed\n";
-		if (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ)
+		if (domain->ignore_global_allow_read)
 			ignore_global_allow_read
 				= KEYWORD_IGNORE_GLOBAL_ALLOW_READ "\n";
-		if (domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_ENV)
+		if (domain->ignore_global_allow_env)
 			ignore_global_allow_env
 				= KEYWORD_IGNORE_GLOBAL_ALLOW_ENV "\n";
 		if (!ccs_io_printf(head, "%s\n" KEYWORD_USE_PROFILE "%u\n"
@@ -2110,10 +2143,10 @@
 		if (head->read_step == 3)
 			goto tail_mark;
 		/* Print ACL entries in the domain. */
-		list1_for_each_cookie(apos, head->read_var2,
+		list_for_each_cookie(apos, head->read_var2.u.list,
 				      &domain->acl_info_list) {
 			struct ccs_acl_info *ptr
-				= list1_entry(apos, struct ccs_acl_info, list);
+				= list_entry(apos, struct ccs_acl_info, list);
 			if (!ccs_print_entry(head, ptr))
 				return 0;
 		}
@@ -2137,26 +2170,26 @@
  * @head: Pointer to "struct ccs_io_buffer".
  *
  * Returns 0 on success, -EINVAL otherwise.
- *
- * This is equivalent to doing
- *
- *     ( echo "select " $domainname; echo "use_profile " $profile ) |
- *     /usr/lib/ccs/loadpolicy -d
  */
 static int ccs_write_domain_profile(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
 	char *cp = strchr(data, ' ');
-	struct ccs_domain_info *domain;
+	struct ccs_cookie cookie;
 	unsigned int profile;
 	if (!cp)
 		return -EINVAL;
 	*cp = '\0';
-	domain = ccs_find_domain(cp + 1);
 	profile = simple_strtoul(data, NULL, 10);
-	if (domain && profile < MAX_PROFILES
-	    && (ccs_profile_ptr[profile] || !ccs_policy_loaded))
-		domain->profile = (u8) profile;
+	if (profile >= MAX_PROFILES)
+		return -EINVAL;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	if (ccs_find_domain(cp + 1, &cookie) &&
+	    (ccs_profile_ptr[profile] || !ccs_policy_loaded))
+		cookie.u.domain->profile = (u8) profile;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
 	ccs_update_counter(CCS_UPDATES_COUNTER_DOMAIN_POLICY);
 	return 0;
 }
@@ -2167,22 +2200,15 @@
  * @head: Pointer to "struct ccs_io_buffer".
  *
  * Returns list of profile number and domainname pairs.
- *
- * This is equivalent to doing
- *
- *     grep -A 1 '^<kernel>' /proc/ccs/domain_policy |
- *     awk ' { if ( domainname == "" ) { if ( $1 == "<kernel>" )
- *     domainname = $0; } else if ( $1 == "use_profile" ) {
- *     print $2 " " domainname; domainname = ""; } } ; '
  */
 static int ccs_read_domain_profile(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
+	struct list_head *pos;
 	if (head->read_eof)
 		return 0;
-	list1_for_each_cookie(pos, head->read_var1, &ccs_domain_list) {
+	list_for_each_cookie(pos, head->read_var1.u.list, &ccs_domain_list) {
 		struct ccs_domain_info *domain;
-		domain = list1_entry(pos, struct ccs_domain_info, list);
+		domain = list_entry(pos, struct ccs_domain_info, list);
 		if (domain->is_deleted)
 			continue;
 		if (!ccs_io_printf(head, "%u %s\n", domain->profile,
@@ -2232,6 +2258,8 @@
 	if (ccs_str_starts(&buf, "info "))
 		task_info = true;
 	pid = (unsigned int) simple_strtoul(buf, NULL, 10);
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
 	/***** CRITICAL SECTION START *****/
 	read_lock(&tasklist_lock);
 	p = find_task_by_pid(pid);
@@ -2241,6 +2269,8 @@
 	}
 	read_unlock(&tasklist_lock);
 	/***** CRITICAL SECTION END *****/
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
 	if (!domain)
 		goto done;
 	if (!task_info)
@@ -2314,53 +2344,53 @@
 	if (!head->read_eof) {
 		switch (head->read_step) {
 		case 0:
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 1;
 		case 1:
 			if (!ccs_read_domain_keeper_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 2;
 		case 2:
 			if (!ccs_read_globally_readable_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 3;
 		case 3:
 			if (!ccs_read_globally_usable_env_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 4;
 		case 4:
 			if (!ccs_read_domain_initializer_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 5;
 		case 5:
 			if (!ccs_read_alias_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 6;
 		case 6:
 			if (!ccs_read_aggregator_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 7;
 		case 7:
 			if (!ccs_read_file_pattern(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 8;
 		case 8:
 			if (!ccs_read_no_rewrite_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 9;
 		case 9:
 			if (!ccs_read_path_group_policy(head))
 				break;
-			head->read_var1 = NULL;
-			head->read_var2 = NULL;
+			head->read_var1.u.list = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 10;
 		case 10:
 			if (!ccs_read_address_group_policy(head))
@@ -2416,27 +2446,27 @@
 	if (!head->read_eof) {
 		switch (head->read_step) {
 		case 0:
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 1;
 		case 1:
 			if (!ccs_read_mount_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 2;
 		case 2:
 			if (!ccs_read_no_umount_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 3;
 		case 3:
 			if (!ccs_read_chroot_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 4;
 		case 4:
 			if (!ccs_read_pivot_root_policy(head))
 				break;
-			head->read_var2 = NULL;
+			head->read_var2.u.list = NULL;
 			head->read_step = 5;
 		case 5:
 			if (!ccs_read_reserved_port_policy(head))
@@ -2614,7 +2644,7 @@
 	ccs_log_level = KERN_WARNING;
 	{ /* Check all profiles currently assigned to domains are defined. */
 		struct ccs_domain_info *domain;
-		list1_for_each_entry(domain, &ccs_domain_list, list) {
+		list_for_each_entry(domain, &ccs_domain_list, list) {
 			const u8 profile = domain->profile;
 			if (ccs_profile_ptr[profile])
 				continue;
@@ -2666,14 +2696,14 @@
 	static unsigned int ccs_serial;
 	struct ccs_query_entry *ccs_query_entry = NULL;
 	char *header;
-	if (!r->domain)
-		r->domain = ccs_current_domain();
+	if (!r->cookie.u.domain)
+		r->cookie.u.domain = ccs_current_domain();
 	if (!atomic_read(&ccs_query_observers)) {
 		int i;
 		if (current->ccs_flags & CCS_DONT_SLEEP_ON_ENFORCE_ERROR)
 			return -EPERM;
-		for (i = 0; i < ccs_check_flags(r->domain, CCS_SLEEP_PERIOD);
-		     i++) {
+		for (i = 0; i < ccs_check_flags(r->cookie.u.domain,
+						CCS_SLEEP_PERIOD); i++) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule_timeout(HZ / 10);
 		}
@@ -3200,6 +3230,9 @@
 			return -ENOMEM;
 		}
 	}
+	ccs_add_cookie(&head->read_var1, NULL);
+	ccs_add_cookie(&head->read_var2, NULL);
+	ccs_add_cookie(&head->write_var1, NULL);
 	file->private_data = head;
 	/*
 	 * Call the handler now if the file is /proc/ccs/self_domain
@@ -3355,78 +3388,11 @@
 	head->read_buf = NULL;
 	ccs_free(head->write_buf);
 	head->write_buf = NULL;
+	ccs_del_cookie(&head->read_var1);
+	ccs_del_cookie(&head->read_var2);
+	ccs_del_cookie(&head->write_var1);
 	ccs_free(head);
 	head = NULL;
 	file->private_data = NULL;
 	return 0;
 }
-
-/**
- * ccs_alloc_acl_element - Allocate permanent memory for ACL entry.
- *
- * @acl_type:  Type of ACL entry.
- * @condition: Pointer to condition part of the ACL entry. May be NULL.
- *
- * Returns pointer to the ACL entry on success, NULL otherwise.
- */
-void *ccs_alloc_acl_element(const u8 acl_type,
-			    const struct ccs_condition_list *condition)
-{
-	int len;
-	struct ccs_acl_info *ptr;
-	switch (acl_type) {
-	case TYPE_SINGLE_PATH_ACL:
-		len = sizeof(struct ccs_single_path_acl_record);
-		break;
-	case TYPE_DOUBLE_PATH_ACL:
-		len = sizeof(struct ccs_double_path_acl_record);
-		break;
-	case TYPE_IOCTL_ACL:
-		len = sizeof(struct ccs_ioctl_acl_record);
-		break;
-	case TYPE_ARGV0_ACL:
-		len = sizeof(struct ccs_argv0_acl_record);
-		break;
-	case TYPE_ENV_ACL:
-		len = sizeof(struct ccs_env_acl_record);
-		break;
-	case TYPE_CAPABILITY_ACL:
-		len = sizeof(struct ccs_capability_acl_record);
-		break;
-	case TYPE_IP_NETWORK_ACL:
-		len = sizeof(struct ccs_ip_network_acl_record);
-		break;
-	case TYPE_SIGNAL_ACL:
-		len = sizeof(struct ccs_signal_acl_record);
-		break;
-	case TYPE_EXECUTE_HANDLER:
-	case TYPE_DENIED_EXECUTE_HANDLER:
-		len = sizeof(struct ccs_execute_handler_record);
-		break;
-	default:
-		return NULL;
-	}
-	/*
-	 * If the ACL doesn't have condition part, reduce memory usage
-	 * by eliminating sizeof(struct ccs_condition_list *).
-	 */
-	if (!condition)
-		len -= sizeof(ptr->access_me_via_ccs_get_condition_part);
-	ptr = ccs_alloc_element(len);
-	if (!ptr)
-		return NULL;
-	if (condition) {
-		ptr->access_me_via_ccs_get_condition_part = condition;
-		ptr->type = acl_type | ACL_WITH_CONDITION;
-		return ptr;
-	}
-	/*
-	 * Substract sizeof(struct ccs_condition_list *) because I eliminated
-	 * sizeof(struct ccs_condition_list *) from "struct ccs_acl_info"
-	 * but I must return the start address of "struct ccs_acl_info".
-	 */
-	ptr = (void *) (((u8 *) ptr)
-			- sizeof(ptr->access_me_via_ccs_get_condition_part));
-	ptr->type = acl_type;
-	return ptr;
-}
Index: trunk/1.6.x/ccs-patch/fs/sakura_bind.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_bind.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/sakura_bind.c	(working copy)
@@ -18,15 +18,17 @@
 
 /* Structure for "deny_autobind" keyword. */
 struct ccs_reserved_entry {
-	struct list1_head list;
+	struct list_head list;
 	bool is_deleted;             /* Delete flag.                         */
 	u16 min_port;                /* Start of port number range.          */
 	u16 max_port;                /* End of port number range.            */
 };
 
 /* The list for "struct ccs_reserved_entry". */
-static LIST1_HEAD(ccs_reservedport_list);
+LIST_HEAD(ccs_reservedport_list);
 
+static u8 ccs_reserved_port_map[8192];
+
 /**
  * ccs_update_reserved_entry - Update "struct ccs_reserved_entry" list.
  *
@@ -39,31 +41,46 @@
 static int ccs_update_reserved_entry(const u16 min_port, const u16 max_port,
 				     const bool is_delete)
 {
-	struct ccs_reserved_entry *new_entry;
 	struct ccs_reserved_entry *ptr;
-	static DEFINE_MUTEX(lock);
 	int error = -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_reservedport_list, list) {
+	u8 *ccs_tmp_map = ccs_alloc(8192, false);
+	struct ccs_reserved_entry *entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!ccs_tmp_map || !entry) {
+		kfree(entry);
+		ccs_free(ccs_tmp_map);
+		return -ENOMEM;
+	}
+	if (is_delete)
+		error = -ENOENT;
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_reservedport_list, list) {
 		if (ptr->min_port != min_port || max_port != ptr->max_port)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->min_port = min_port;
+		entry->max_port = max_port;
+		list_add_tail(&entry->list, &ccs_reservedport_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->min_port = min_port;
-	new_entry->max_port = max_port;
-	list1_add_tail_mb(&new_entry->list, &ccs_reservedport_list);
-	error = 0;
- out:
-	mutex_unlock(&lock);
+	list_for_each_entry(ptr, &ccs_reservedport_list, list) {
+		unsigned int port;
+		if (ptr->is_deleted)
+			continue;
+		for (port = ptr->min_port; port <= ptr->max_port; port++)
+			ccs_tmp_map[port >> 8] |= 1 << (port & 7);
+	}
+	memmove(ccs_reserved_port_map, ccs_tmp_map,
+		sizeof(ccs_reserved_port_map));
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	kfree(entry);
+	ccs_free(ccs_tmp_map);
 	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 	return error;
 }
@@ -78,15 +95,10 @@
 bool ccs_lport_reserved(const u16 port)
 {
 	/***** CRITICAL SECTION START *****/
-	struct ccs_reserved_entry *ptr;
 	if (!ccs_check_flags(NULL, CCS_RESTRICT_AUTOBIND))
 		return false;
-	list1_for_each_entry(ptr, &ccs_reservedport_list, list) {
-		if (ptr->min_port <= port && port <= ptr->max_port &&
-		    !ptr->is_deleted)
-			return true;
-	}
-	return false;
+	return ccs_reserved_port_map[port >> 8] & (1 << (port & 7))
+		? true : false;
 	/***** CRITICAL SECTION END *****/
 }
 EXPORT_SYMBOL(ccs_lport_reserved); /* for net/ipv4/ and net/ipv6/ */
@@ -127,24 +139,29 @@
  */
 bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
+	bool done = true;
+	struct list_head *pos;
 	char buffer[16];
 	memset(buffer, 0, sizeof(buffer));
-	list1_for_each_cookie(pos, head->read_var2, &ccs_reservedport_list) {
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list,
+			      &ccs_reservedport_list) {
 		u16 min_port;
 		u16 max_port;
 		struct ccs_reserved_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_reserved_entry, list);
+		ptr = list_entry(pos, struct ccs_reserved_entry, list);
 		if (ptr->is_deleted)
 			continue;
 		min_port = ptr->min_port;
 		max_port = ptr->max_port;
 		snprintf(buffer, sizeof(buffer) - 1, "%u%c%u", min_port,
 			 min_port != max_port ? '-' : '\0', max_port);
-		if (!ccs_io_printf(head, KEYWORD_DENY_AUTOBIND "%s\n", buffer))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_DENY_AUTOBIND "%s\n", buffer);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_signal.c	(working copy)
@@ -55,23 +55,25 @@
 				 const struct ccs_condition_list *condition,
 				 const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
+	struct ccs_signal_acl_record *entry = NULL;
 	struct ccs_acl_info *ptr;
-	struct ccs_signal_acl_record *acl;
 	const struct ccs_path_info *saved_dest_pattern;
 	const u16 hash = sig;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!domain)
 		return -EINVAL;
 	if (!dest_pattern || !ccs_is_correct_domain(dest_pattern, __func__))
 		return -EINVAL;
-	saved_dest_pattern = ccs_save_name(dest_pattern);
+	saved_dest_pattern = ccs_get_name(dest_pattern);
 	if (!saved_dest_pattern)
 		return -ENOMEM;
-	mutex_lock(&lock);
 	if (is_delete)
 		goto delete;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_signal_acl_record *acl;
 		if (ccs_acl_type1(ptr) != TYPE_SIGNAL_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
@@ -81,19 +83,25 @@
 		    ccs_pathcmp(acl->domainname, saved_dest_pattern))
 			continue;
 		error = ccs_add_domain_acl(NULL, ptr);
-		goto out;
+		break;
 	}
-	/* Not found. Append it to the tail. */
-	acl = ccs_alloc_acl_element(TYPE_SIGNAL_ACL, condition);
-	if (!acl)
-		goto out;
-	acl->sig = hash;
-	acl->domainname = saved_dest_pattern;
-	error = ccs_add_domain_acl(domain, &acl->head);
+	if (error && ccs_memory_ok(entry)) {
+		entry->head.type = TYPE_SIGNAL_ACL;
+		entry->head.cond = condition;
+		entry->sig = hash;
+		entry->domainname = saved_dest_pattern;
+		saved_dest_pattern = NULL;
+		error = ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	goto out;
  delete:
-	error = -ENOENT;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_signal_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_SIGNAL_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
@@ -105,8 +113,11 @@
 		error = ccs_del_domain_acl(ptr);
 		break;
 	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	ccs_put_name(saved_dest_pattern);
+	kfree(entry);
 	return error;
 }
 
@@ -121,12 +132,13 @@
 int ccs_check_signal_acl(const int sig, const int pid)
 {
 	struct ccs_request_info r;
-	struct ccs_domain_info *dest = NULL;
+	struct ccs_cookie dest;
 	const char *dest_pattern;
 	struct ccs_acl_info *ptr;
 	const u16 hash = sig;
 	bool is_enforce;
 	bool found = false;
+	int error = -EPERM;
 	if (!ccs_can_sleep())
 		return 0;
 	ccs_init_request_info(&r, NULL, CCS_MAC_FOR_SIGNAL);
@@ -135,12 +147,19 @@
 		return 0;
 	if (!sig)
 		return 0;                /* No check for NULL signal. */
+	ccs_add_cookie(&r.cookie, ccs_current_domain());
+	ccs_add_cookie(&dest, NULL);
 	if (sys_getpid() == pid) {
-		ccs_audit_signal_log(&r, sig, r.domain->domainname->name, true);
-		return 0;                /* No check for self process. */
+		ccs_audit_signal_log(&r, sig,
+				     r.cookie.u.domain->domainname->name,
+				     true);
+		error = 0;
+		goto done;               /* No check for self process. */
 	}
 	{ /* Simplified checking. */
 		struct task_struct *p = NULL;
+		/***** READER SECTION START *****/
+		down_read(&ccs_policy_lock);
 		/***** CRITICAL SECTION START *****/
 		read_lock(&tasklist_lock);
 		if (pid > 0)
@@ -148,23 +167,32 @@
 		else if (pid == 0)
 			p = current;
 		else if (pid == -1)
-			dest = &ccs_kernel_domain;
+			dest.u.domain = &ccs_kernel_domain;
 		else
 			p = find_task_by_pid((pid_t) -pid);
 		if (p)
-			dest = ccs_task_domain(p);
+			dest.u.domain = ccs_task_domain(p);
 		read_unlock(&tasklist_lock);
 		/***** CRITICAL SECTION END *****/
+		up_read(&ccs_policy_lock);
+		/***** READER SECTION END *****/
 	}
-	if (!dest)
-		return 0; /* I can't find destinatioin. */
-	if (r.domain == dest) {
-		ccs_audit_signal_log(&r, sig, r.domain->domainname->name, true);
-		return 0;                /* No check for self domain. */
+	if (!dest.u.domain) {
+		error = 0;
+		goto done; /* I can't find destinatioin. */
 	}
-	dest_pattern = dest->domainname->name;
+	if (r.cookie.u.domain == dest.u.domain) {
+		ccs_audit_signal_log(&r, sig,
+				     r.cookie.u.domain->domainname->name,
+				     true);
+		error = 0;
+		goto done; /* No check for self domain. */
+	}
+	dest_pattern = dest.u.domain->domainname->name;
  retry:
-	list1_for_each_entry(ptr, &r.domain->acl_info_list, list) {
+	/***** READER SECTION END *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &r.cookie.u.domain->acl_info_list, list) {
 		struct ccs_signal_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_SIGNAL_ACL)
 			continue;
@@ -185,24 +213,33 @@
 			break;
 		}
 	}
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
 	ccs_audit_signal_log(&r, sig, dest_pattern, found);
-	if (found)
-		return 0;
-	if (ccs_verbose_mode(r.domain))
+	if (found) {
+		error = 0;
+		goto done;
+	}
+	if (ccs_verbose_mode(r.cookie.u.domain))
 		printk(KERN_WARNING "TOMOYO-%s: Signal %d "
 		       "to %s denied for %s\n", ccs_get_msg(is_enforce), sig,
-		       ccs_get_last_name(dest), ccs_get_last_name(r.domain));
+		       ccs_get_last_name(dest.u.domain),
+		       ccs_get_last_name(r.cookie.u.domain));
 	if (is_enforce) {
-		int error = ccs_check_supervisor(&r, KEYWORD_ALLOW_SIGNAL
-						 "%d %s\n", sig, dest_pattern);
-		if (error == 1)
+		int err = ccs_check_supervisor(&r, KEYWORD_ALLOW_SIGNAL
+					       "%d %s\n", sig, dest_pattern);
+		if (err == 1)
 			goto retry;
-		return error;
+		goto done;
 	}
-	if (r.mode == 1 && ccs_domain_quota_ok(r.domain))
-		ccs_update_signal_acl(sig, dest_pattern, r.domain,
+	if (r.mode == 1 && ccs_domain_quota_ok(r.cookie.u.domain))
+		ccs_update_signal_acl(sig, dest_pattern, r.cookie.u.domain,
 				      ccs_handler_cond(), false);
-	return 0;
+	error = 0;
+ done:
+	ccs_del_cookie(&dest);
+	ccs_del_cookie(&r.cookie);
+	return error;
 }
 
 /**
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_file.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_file.c	(working copy)
@@ -18,27 +18,6 @@
 #include <linux/binfmts.h>
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
 
-/* Structure for "allow_read" keyword. */
-struct ccs_globally_readable_file_entry {
-	struct list1_head list;
-	const struct ccs_path_info *filename;
-	bool is_deleted;
-};
-
-/* Structure for "file_pattern" keyword. */
-struct ccs_pattern_entry {
-	struct list1_head list;
-	const struct ccs_path_info *pattern;
-	bool is_deleted;
-};
-
-/* Structure for "deny_rewrite" keyword. */
-struct ccs_no_rewrite_entry {
-	struct list1_head list;
-	const struct ccs_path_info *pattern;
-	bool is_deleted;
-};
-
 /* Keyword array for single path operations. */
 static const char *ccs_sp_keyword[MAX_SINGLE_PATH_OPERATION] = {
 	[TYPE_READ_WRITE_ACL] = "read/write",
@@ -169,7 +148,7 @@
 }
 
 /* The list for "struct ccs_globally_readable_file_entry". */
-static LIST1_HEAD(ccs_globally_readable_list);
+LIST_HEAD(ccs_globally_readable_list);
 
 /**
  * ccs_update_globally_readable_entry - Update "struct ccs_globally_readable_file_entry" list.
@@ -182,36 +161,37 @@
 static int ccs_update_globally_readable_entry(const char *filename,
 					      const bool is_delete)
 {
-	struct ccs_globally_readable_file_entry *new_entry;
+	struct ccs_globally_readable_file_entry *entry = NULL;
 	struct ccs_globally_readable_file_entry *ptr;
-	static DEFINE_MUTEX(lock);
 	const struct ccs_path_info *saved_filename;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(filename, 1, 0, -1, __func__))
 		return -EINVAL;
-	saved_filename = ccs_save_name(filename);
+	saved_filename = ccs_get_name(filename);
 	if (!saved_filename)
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_globally_readable_list, list) {
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_globally_readable_list, list) {
 		if (ptr->filename != saved_filename)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->filename = saved_filename;
+		saved_filename = NULL;
+		list_add_tail(&entry->list, &ccs_globally_readable_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->filename = saved_filename;
-	list1_add_tail_mb(&new_entry->list, &ccs_globally_readable_list);
-	error = 0;
- out:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_filename);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
@@ -226,12 +206,19 @@
 static bool ccs_is_globally_readable_file(const struct ccs_path_info *filename)
 {
 	struct ccs_globally_readable_file_entry *ptr;
-	list1_for_each_entry(ptr, &ccs_globally_readable_list, list) {
-		if (!ptr->is_deleted &&
-		    ccs_path_matches_pattern(filename, ptr->filename))
-			return true;
+	bool found = false;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_globally_readable_list, list) {
+		if (ptr->is_deleted ||
+		    !ccs_path_matches_pattern(filename, ptr->filename))
+			continue;
+		found = true;
+		break;
 	}
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return found;
 }
 
 /**
@@ -256,27 +243,77 @@
  */
 bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2,
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list,
 			      &ccs_globally_readable_list) {
 		struct ccs_globally_readable_file_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_globally_readable_file_entry,
+		ptr = list_entry(pos, struct ccs_globally_readable_file_entry,
 				  list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, KEYWORD_ALLOW_READ "%s\n",
-				   ptr->filename->name))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_ALLOW_READ "%s\n",
+				     ptr->filename->name);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
 
 /* The list for "struct ccs_path_group_entry". */
-static LIST1_HEAD(ccs_path_group_list);
+LIST_HEAD(ccs_path_group_list);
 
 /**
+ * ccs_get_path_group - Allocate memory for "struct ccs_path_group_entry".
+ *
+ * @group_name: The name of pathname group.
+ *
+ * Returns pointer to "struct ccs_path_group_entry" on success, NULL otherwise.
+ */
+static struct ccs_path_group_entry *ccs_get_path_group(const char *group_name)
+{
+	struct ccs_path_group_entry *entry = NULL;
+	struct ccs_path_group_entry *group;
+	const struct ccs_path_info *saved_group_name;
+	int error = -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0, __func__) ||
+	    !group_name[0])
+		return NULL;
+	saved_group_name = ccs_get_name(group_name);
+	if (!saved_group_name)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(group, &ccs_path_group_list, list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		atomic_inc(&group->users);
+		error = 0;
+		break;
+	}
+	if (error && ccs_memory_ok(entry)) {
+		INIT_LIST_HEAD(&entry->path_group_member_list);
+		entry->group_name = saved_group_name;
+		saved_group_name = NULL;
+		atomic_set(&entry->users, 1);
+		list_add_tail(&entry->list, &ccs_path_group_list);
+		group = entry;
+		entry = NULL;
+		error = 0;
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_group_name);
+	kfree(entry);
+	return !error ? group : NULL;
+}
+
+/**
  * ccs_update_path_group_entry - Update "struct ccs_path_group_entry" list.
  *
  * @group_name:  The name of pathname group.
@@ -289,64 +326,48 @@
 				       const char *member_name,
 				       const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
-	struct ccs_path_group_entry *new_group;
 	struct ccs_path_group_entry *group;
-	struct ccs_path_group_member *new_member;
+	struct ccs_path_group_member *entry = NULL;
 	struct ccs_path_group_member *member;
-	const struct ccs_path_info *saved_group_name;
 	const struct ccs_path_info *saved_member_name;
-	int error = -ENOMEM;
-	bool found = false;
-	if (!ccs_is_correct_path(group_name, 0, 0, 0, __func__) ||
-	    !group_name[0] ||
-	    !ccs_is_correct_path(member_name, 0, 0, 0, __func__) ||
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(member_name, 0, 0, 0, __func__) ||
 	    !member_name[0])
 		return -EINVAL;
-	saved_group_name = ccs_save_name(group_name);
+	group = ccs_get_path_group(group_name);
+	if (!group)
+		return -ENOMEM;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
 	if (!strcmp(member_name, "pipe:"))
 		member_name = "pipe:[\\$]";
 #endif
-	saved_member_name = ccs_save_name(member_name);
-	if (!saved_group_name || !saved_member_name)
-		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(group, &ccs_path_group_list, list) {
-		if (saved_group_name != group->group_name)
+	saved_member_name = ccs_get_name(member_name);
+	if (saved_member_name)
+		goto out;
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(member, &group->path_group_member_list, list) {
+		if (member->member_name != saved_member_name)
 			continue;
-		list1_for_each_entry(member, &group->path_group_member_list,
-				     list) {
-			if (member->member_name != saved_member_name)
-				continue;
-			member->is_deleted = is_delete;
-			error = 0;
-			goto out;
-		}
-		found = true;
+		member->is_deleted = is_delete;
+		error = 0;
 		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->member_name = saved_member_name;
+		saved_member_name = NULL;
+		list_add_tail(&entry->list, &group->path_group_member_list);
+		entry = NULL;
+		error = 0;
 	}
-	if (!found) {
-		new_group = ccs_alloc_element(sizeof(*new_group));
-		if (!new_group)
-			goto out;
-		INIT_LIST1_HEAD(&new_group->path_group_member_list);
-		new_group->group_name = saved_group_name;
-		list1_add_tail_mb(&new_group->list, &ccs_path_group_list);
-		group = new_group;
-	}
-	new_member = ccs_alloc_element(sizeof(*new_member));
-	if (!new_member)
-		goto out;
-	new_member->member_name = saved_member_name;
-	list1_add_tail_mb(&new_member->list, &group->path_group_member_list);
-	error = 0;
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	ccs_put_name(saved_member_name);
+	ccs_put_path_group(group);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
@@ -369,31 +390,6 @@
 }
 
 /**
- * ccs_find_or_assign_new_path_group - Create pathname group.
- *
- * @group_name: The name of pathname group.
- *
- * Returns pointer to "struct ccs_path_group_entry" if found, NULL otherwise.
- */
-static struct ccs_path_group_entry *
-ccs_find_or_assign_new_path_group(const char *group_name)
-{
-	u8 i;
-	struct ccs_path_group_entry *group;
-	for (i = 0; i <= 1; i++) {
-		list1_for_each_entry(group, &ccs_path_group_list, list) {
-			if (!strcmp(group_name, group->group_name->name))
-				return group;
-		}
-		if (!i) {
-			ccs_update_path_group_entry(group_name, "/", false);
-			ccs_update_path_group_entry(group_name, "/", true);
-		}
-	}
-	return NULL;
-}
-
-/**
  * ccs_path_matches_group - Check whether the given pathname matches members of the given pathname group.
  *
  * @pathname:        The name of pathname.
@@ -401,25 +397,31 @@
  * @may_use_pattern: True if wild card is permitted.
  *
  * Returns true if @pathname matches pathnames in @group, false otherwise.
+ *
+ * Caller holds ccs_policy_lock for reading.
  */
 static bool ccs_path_matches_group(const struct ccs_path_info *pathname,
 				   const struct ccs_path_group_entry *group,
 				   const bool may_use_pattern)
 {
 	struct ccs_path_group_member *member;
-	list1_for_each_entry(member, &group->path_group_member_list, list) {
+	bool matched = false;
+	list_for_each_entry(member, &group->path_group_member_list, list) {
 		if (member->is_deleted)
 			continue;
 		if (!member->member_name->is_patterned) {
-			if (!ccs_pathcmp(pathname, member->member_name))
-				return true;
+			if (ccs_pathcmp(pathname, member->member_name))
+				continue;
 		} else if (may_use_pattern) {
-			if (ccs_path_matches_pattern(pathname,
-						     member->member_name))
-				return true;
-		}
+			if (!ccs_path_matches_pattern(pathname,
+						      member->member_name))
+				continue;
+		} else
+			continue;
+		matched = true;
+		break;
 	}
-	return false;
+	return matched;
 }
 
 /**
@@ -431,31 +433,36 @@
  */
 bool ccs_read_path_group_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *gpos;
-	struct list1_head *mpos;
-	list1_for_each_cookie(gpos, head->read_var1, &ccs_path_group_list) {
+	struct list_head *gpos;
+	struct list_head *mpos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(gpos, head->read_var1.u.list,
+			      &ccs_path_group_list) {
 		struct ccs_path_group_entry *group;
-		group = list1_entry(gpos, struct ccs_path_group_entry, list);
-		list1_for_each_cookie(mpos, head->read_var2,
+		group = list_entry(gpos, struct ccs_path_group_entry, list);
+		list_for_each_cookie(mpos, head->read_var2.u.list,
 				      &group->path_group_member_list) {
 			struct ccs_path_group_member *member;
-			member = list1_entry(mpos, struct ccs_path_group_member,
+			member = list_entry(mpos, struct ccs_path_group_member,
 					     list);
 			if (member->is_deleted)
 				continue;
-			if (!ccs_io_printf(head, KEYWORD_PATH_GROUP "%s %s\n",
-					   group->group_name->name,
-					   member->member_name->name))
-				goto out;
+			done = ccs_io_printf(head, KEYWORD_PATH_GROUP "%s %s\n",
+					     group->group_name->name,
+					     member->member_name->name);
+			if (!done)
+				break;
 		}
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
 
 /* The list for "struct ccs_pattern_entry". */
-static LIST1_HEAD(ccs_pattern_list);
+LIST_HEAD(ccs_pattern_list);
 
 /**
  * ccs_update_file_pattern_entry - Update "struct ccs_pattern_entry" list.
@@ -468,36 +475,37 @@
 static int ccs_update_file_pattern_entry(const char *pattern,
 					 const bool is_delete)
 {
-	struct ccs_pattern_entry *new_entry;
+	struct ccs_pattern_entry *entry = NULL;
 	struct ccs_pattern_entry *ptr;
-	static DEFINE_MUTEX(lock);
 	const struct ccs_path_info *saved_pattern;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(pattern, 0, 1, 0, __func__))
 		return -EINVAL;
-	saved_pattern = ccs_save_name(pattern);
+	saved_pattern = ccs_get_name(pattern);
 	if (!saved_pattern)
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_pattern_list, list) {
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_pattern_list, list) {
 		if (saved_pattern != ptr->pattern)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->pattern = saved_pattern;
+		saved_pattern = NULL;
+		list_add_tail(&entry->list, &ccs_pattern_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->pattern = saved_pattern;
-	list1_add_tail_mb(&new_entry->list, &ccs_pattern_list);
-	error = 0;
- out:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_pattern);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
@@ -505,15 +513,16 @@
 /**
  * ccs_get_file_pattern - Get patterned pathname.
  *
- * @filename: The filename to find patterned pathname.
- *
- * Returns pointer to pathname pattern if matched, @filename->name otherwise.
+ * @cookie: Pointer to "struct ccs_cookie".
  */
-static const char *ccs_get_file_pattern(const struct ccs_path_info *filename)
+static void ccs_get_file_pattern(struct ccs_cookie *cookie)
 {
 	struct ccs_pattern_entry *ptr;
 	const struct ccs_path_info *pattern = NULL;
-	list1_for_each_entry(ptr, &ccs_pattern_list, list) {
+	const struct ccs_path_info *filename = cookie->u.path;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_pattern_list, list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!ccs_path_matches_pattern(filename, ptr->pattern))
@@ -527,8 +536,9 @@
 		}
 	}
 	if (pattern)
-		filename = pattern;
-	return filename->name;
+		ccs_update_cookie(cookie, pattern);
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
 }
 
 /**
@@ -553,23 +563,27 @@
  */
 bool ccs_read_file_pattern(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &ccs_pattern_list) {
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list, &ccs_pattern_list) {
 		struct ccs_pattern_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_pattern_entry, list);
+		ptr = list_entry(pos, struct ccs_pattern_entry, list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, KEYWORD_FILE_PATTERN "%s\n",
-				   ptr->pattern->name))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_FILE_PATTERN "%s\n",
+				     ptr->pattern->name);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
 
 /* The list for "struct ccs_no_rewrite_entry". */
-static LIST1_HEAD(ccs_no_rewrite_list);
+LIST_HEAD(ccs_no_rewrite_list);
 
 /**
  * ccs_update_no_rewrite_entry - Update "struct ccs_no_rewrite_entry" list.
@@ -582,36 +596,37 @@
 static int ccs_update_no_rewrite_entry(const char *pattern,
 				       const bool is_delete)
 {
-	struct ccs_no_rewrite_entry *new_entry;
+	struct ccs_no_rewrite_entry *entry = NULL;
 	struct ccs_no_rewrite_entry *ptr;
-	static DEFINE_MUTEX(lock);
 	const struct ccs_path_info *saved_pattern;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(pattern, 0, 0, 0, __func__))
 		return -EINVAL;
-	saved_pattern = ccs_save_name(pattern);
+	saved_pattern = ccs_get_name(pattern);
 	if (!saved_pattern)
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_no_rewrite_list, list) {
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_no_rewrite_list, list) {
 		if (ptr->pattern != saved_pattern)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->pattern = saved_pattern;
+		saved_pattern = NULL;
+		list_add_tail(&entry->list, &ccs_no_rewrite_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
-		goto out;
-	new_entry->pattern = saved_pattern;
-	list1_add_tail_mb(&new_entry->list, &ccs_no_rewrite_list);
-	error = 0;
- out:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	ccs_put_name(saved_pattern);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_EXCEPTION_POLICY);
 	return error;
 }
@@ -627,14 +642,20 @@
 static bool ccs_is_no_rewrite_file(const struct ccs_path_info *filename)
 {
 	struct ccs_no_rewrite_entry *ptr;
-	list1_for_each_entry(ptr, &ccs_no_rewrite_list, list) {
+	bool matched = false;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_no_rewrite_list, list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!ccs_path_matches_pattern(filename, ptr->pattern))
 			continue;
-		return true;
+		matched = true;
+		break;
 	}
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return matched;
 }
 
 /**
@@ -659,19 +680,24 @@
  */
 bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &ccs_no_rewrite_list) {
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list,
+			      &ccs_no_rewrite_list) {
 		struct ccs_no_rewrite_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_no_rewrite_entry, list);
+		ptr = list_entry(pos, struct ccs_no_rewrite_entry, list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, KEYWORD_DENY_REWRITE "%s\n",
-				   ptr->pattern->name))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_DENY_REWRITE "%s\n",
+				     ptr->pattern->name);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
 
 /**
@@ -733,9 +759,12 @@
 				      const u16 perm,
 				      const bool may_use_pattern)
 {
-	struct ccs_domain_info *domain = r->domain;
+	struct ccs_domain_info *domain = r->cookie.u.domain;
 	struct ccs_acl_info *ptr;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	int error = -EPERM;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct ccs_single_path_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_SINGLE_PATH_ACL)
 			continue;
@@ -755,9 +784,12 @@
 			continue;
 		}
 		r->cond = ccs_get_condition_part(ptr);
-		return 0;
+		error = 0;
+		break;
 	}
-	return -EPERM;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return error;
 }
 
 /**
@@ -818,17 +850,16 @@
 		BUG();
  retry:
 	error = ccs_check_file_acl(r, filename, perm);
-	if (error && perm == 4 &&
-	    (r->domain->flags & DOMAIN_FLAGS_IGNORE_GLOBAL_ALLOW_READ) == 0 &&
-	    ccs_is_globally_readable_file(filename))
+	if (error && perm == 4 && !r->cookie.u.domain->ignore_global_allow_read
+	    && ccs_is_globally_readable_file(filename))
 		error = 0;
 	ccs_audit_file_log(r, msg, filename->name, NULL, !error);
 	if (!error)
 		return 0;
-	if (ccs_verbose_mode(r->domain))
+	if (ccs_verbose_mode(r->cookie.u.domain))
 		printk(KERN_WARNING "TOMOYO-%s: Access '%s(%s) %s' denied "
 		       "for %s\n", ccs_get_msg(is_enforce), msg, operation,
-		       filename->name, ccs_get_last_name(r->domain));
+		       filename->name, ccs_get_last_name(r->cookie.u.domain));
 	if (is_enforce) {
 		int err = ccs_check_supervisor(r, "allow_%s %s\n",
 					       msg, filename->name);
@@ -836,12 +867,21 @@
 			goto retry;
 		return err;
 	}
-	if (r->mode == 1 && ccs_domain_quota_ok(r->domain)) {
+	if (r->mode == 1 && ccs_domain_quota_ok(r->cookie.u.domain)) {
 		/* Don't use patterns for execute permission. */
-		const char *patterned_file = (perm != 1) ?
-			ccs_get_file_pattern(filename) : filename->name;
-		ccs_update_file_acl(patterned_file, perm, r->domain,
-				    ccs_handler_cond(), false);
+		if (perm == 1) {
+			ccs_update_file_acl(filename->name, perm,
+					    r->cookie.u.domain,
+					    ccs_handler_cond(), false);
+		} else {
+			struct ccs_cookie cookie;
+			ccs_add_cookie(&cookie, filename);
+			ccs_get_file_pattern(&cookie);
+			ccs_update_file_acl(cookie.u.path->name, perm,
+					    r->cookie.u.domain,
+					    ccs_handler_cond(), false);
+			ccs_del_cookie(&cookie);
+		}
 	}
 	return 0;
 }
@@ -860,22 +900,24 @@
 				      struct ccs_domain_info * const domain,
 				      const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
 	const struct ccs_path_info *saved_filename;
 	struct ccs_acl_info *ptr;
-	struct ccs_execute_handler_record *acl;
-	int error = -ENOMEM;
+	struct ccs_execute_handler_record *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!domain)
 		return -EINVAL;
 	if (!ccs_is_correct_path(filename, 1, -1, -1, __func__))
 		return -EINVAL;
-	saved_filename = ccs_save_name(filename);
+	saved_filename = ccs_get_name(filename);
 	if (!saved_filename)
 		return -ENOMEM;
-	mutex_lock(&lock);
 	if (is_delete)
 		goto delete;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_execute_handler_record *acl;
 		if (ccs_acl_type1(ptr) != type)
 			continue;
 		/* Condition not supported. */
@@ -884,28 +926,32 @@
 		if (acl->handler != saved_filename)
 			continue;
 		/* Only one entry can exist in a domain. */
-		list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+		list_for_each_entry(ptr, &domain->acl_info_list, list) {
 			if (ptr->type == type)
 				ptr->type |= ACL_DELETED;
 		}
 		error = ccs_add_domain_acl(NULL, &acl->head);
-		goto out;
+		break;
 	}
-	/* Not found. Append it to the tail. */
-	acl = ccs_alloc_acl_element(type, NULL);
-	if (!acl)
-		goto out;
-	acl->handler = saved_filename;
-	/* Only one entry can exist in a domain. */
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
-		if (ptr->type == type)
-			ptr->type |= ACL_DELETED;
+	if (error && ccs_memory_ok(entry)) {
+		entry->handler = saved_filename;
+		saved_filename = NULL;
+		/* Only one entry can exist in a domain. */
+		list_for_each_entry(ptr, &domain->acl_info_list, list) {
+			if (ptr->type == type)
+				ptr->type |= ACL_DELETED;
+		}
+		error = ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
 	}
-	error = ccs_add_domain_acl(domain, &acl->head);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	goto out;
  delete:
-	error = -ENOENT;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_execute_handler_record *acl;
 		if (ccs_acl_type2(ptr) != type)
 			continue;
 		/* Condition not supported. */
@@ -916,8 +962,11 @@
 		error = ccs_del_domain_acl(ptr);
 		break;
 	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	ccs_put_name(saved_filename);
+	kfree(entry);
 	return error;
 }
 
@@ -993,13 +1042,12 @@
 				      condition,
 				      const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
 	static const u16 ccs_rw_mask =
 		(1 << TYPE_READ_ACL) | (1 << TYPE_WRITE_ACL);
-	const struct ccs_path_info *saved_filename;
+	const void *saved_ptr;
 	struct ccs_acl_info *ptr;
-	struct ccs_single_path_acl_record *acl;
-	int error = -ENOMEM;
+	struct ccs_single_path_acl_record *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	bool is_group = false;
 	const u16 perm = 1 << type;
 	if (!domain)
@@ -1007,33 +1055,31 @@
 	if (!ccs_is_correct_path(filename, 0, 0, 0, __func__))
 		return -EINVAL;
 	if (filename[0] == '@') {
-		/*
-		 * This cast is OK because I don't dereference
-		 * in this function.
-		 */
-		saved_filename = (struct ccs_path_info *)
-			ccs_find_or_assign_new_path_group(filename + 1);
+		saved_ptr = ccs_get_path_group(filename + 1);
 		is_group = true;
 	} else {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
 		if (!strcmp(filename, "pipe:"))
 			filename = "pipe:[\\$]";
 #endif
-		saved_filename = ccs_save_name(filename);
+		saved_ptr = ccs_get_name(filename);
 	}
-	if (!saved_filename)
+	if (!saved_ptr)
 		return -ENOMEM;
-	mutex_lock(&lock);
 	if (is_delete)
 		goto delete;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_single_path_acl_record *acl;
 		if (ccs_acl_type1(ptr) != TYPE_SINGLE_PATH_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
 			continue;
 		acl = container_of(ptr, struct ccs_single_path_acl_record,
 				   head);
-		if (acl->u.filename != saved_filename)
+		if (acl->u.ptr != saved_ptr)
 			continue;
 		/* Special case. Clear all bits if marked as deleted. */
 		if (ptr->type & ACL_DELETED)
@@ -1044,29 +1090,35 @@
 		else if (acl->perm & (1 << TYPE_READ_WRITE_ACL))
 			acl->perm |= ccs_rw_mask;
 		error = ccs_add_domain_acl(NULL, ptr);
-		goto out;
+		break;
 	}
-	/* Not found. Append it to the tail. */
-	acl = ccs_alloc_acl_element(TYPE_SINGLE_PATH_ACL, condition);
-	if (!acl)
-		goto out;
-	acl->perm = perm;
-	if (perm == (1 << TYPE_READ_WRITE_ACL))
-		acl->perm |= ccs_rw_mask;
-	acl->u_is_group = is_group;
-	acl->u.filename = saved_filename;
-	error = ccs_add_domain_acl(domain, &acl->head);
+	if (error && ccs_memory_ok(entry)) {
+		entry->head.type = TYPE_SINGLE_PATH_ACL;
+		entry->head.cond = condition;
+		entry->perm = perm;
+		if (perm == (1 << TYPE_READ_WRITE_ACL))
+			entry->perm |= ccs_rw_mask;
+		entry->u_is_group = is_group;
+		entry->u.filename = saved_ptr;
+		saved_ptr = NULL;
+		error = ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	goto out;
  delete:
-	error = -ENOENT;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_single_path_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_SINGLE_PATH_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
 			continue;
 		acl = container_of(ptr, struct ccs_single_path_acl_record,
 				   head);
-		if (acl->u.filename != saved_filename)
+		if (acl->u.ptr != saved_ptr)
 			continue;
 		acl->perm &= ~perm;
 		if ((acl->perm & ccs_rw_mask) != ccs_rw_mask)
@@ -1076,8 +1128,14 @@
 		error = ccs_del_domain_acl(acl->perm ? NULL : ptr);
 		break;
 	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	if (is_group)
+		ccs_put_path_group((struct ccs_path_group_entry *) saved_ptr);
+	else
+		ccs_put_name((struct ccs_path_info *) saved_ptr);
+	kfree(entry);
 	return error;
 }
 
@@ -1100,12 +1158,11 @@
 				      condition,
 				      const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
-	const struct ccs_path_info *saved_filename1;
-	const struct ccs_path_info *saved_filename2;
+	const void *saved_ptr1;
+	const void *saved_ptr2;
 	struct ccs_acl_info *ptr;
-	struct ccs_double_path_acl_record *acl;
-	int error = -ENOMEM;
+	struct ccs_double_path_acl_record *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	bool is_group1 = false;
 	bool is_group2 = false;
 	const u8 perm = 1 << type;
@@ -1115,78 +1172,86 @@
 	    !ccs_is_correct_path(filename2, 0, 0, 0, __func__))
 		return -EINVAL;
 	if (filename1[0] == '@') {
-		/*
-		 * This cast is OK because I don't dereference
-		 * in this function.
-		 */
-		saved_filename1 = (struct ccs_path_info *)
-			ccs_find_or_assign_new_path_group(filename1 + 1);
+		saved_ptr1 = ccs_get_path_group(filename1 + 1);
 		is_group1 = true;
 	} else {
-		saved_filename1 = ccs_save_name(filename1);
+		saved_ptr1 = ccs_get_name(filename1);
 	}
 	if (filename2[0] == '@') {
-		/*
-		 * This cast is OK because I don't dereference
-		 * in this function.
-		 */
-		saved_filename2 = (struct ccs_path_info *)
-			ccs_find_or_assign_new_path_group(filename2 + 1);
+		saved_ptr2 = ccs_get_path_group(filename2 + 1);
 		is_group2 = true;
 	} else {
-		saved_filename2 = ccs_save_name(filename2);
+		saved_ptr2 = ccs_get_name(filename2);
 	}
-	if (!saved_filename1 || !saved_filename2)
-		return -ENOMEM;
-	mutex_lock(&lock);
+	if (!saved_ptr1 || !saved_ptr2)
+		goto out;
 	if (is_delete)
 		goto delete;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_double_path_acl_record *acl;
 		if (ccs_acl_type1(ptr) != TYPE_DOUBLE_PATH_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
 			continue;
 		acl = container_of(ptr, struct ccs_double_path_acl_record,
 				   head);
-		if (acl->u1.filename1 != saved_filename1 ||
-		    acl->u2.filename2 != saved_filename2)
+		if (acl->u1.ptr != saved_ptr1 || acl->u2.ptr != saved_ptr2)
 			continue;
 		/* Special case. Clear all bits if marked as deleted. */
 		if (ptr->type & ACL_DELETED)
 			acl->perm = 0;
 		acl->perm |= perm;
 		error = ccs_add_domain_acl(NULL, ptr);
-		goto out;
+		break;
 	}
-	/* Not found. Append it to the tail. */
-	acl = ccs_alloc_acl_element(TYPE_DOUBLE_PATH_ACL, condition);
-	if (!acl)
-		goto out;
-	acl->perm = perm;
-	acl->u1_is_group = is_group1;
-	acl->u2_is_group = is_group2;
-	acl->u1.filename1 = saved_filename1;
-	acl->u2.filename2 = saved_filename2;
-	error = ccs_add_domain_acl(domain, &acl->head);
+	if (error && ccs_memory_ok(entry)) {
+		entry->head.type = TYPE_DOUBLE_PATH_ACL;
+		entry->head.cond = condition;
+		entry->perm = perm;
+		entry->u1_is_group = is_group1;
+		entry->u2_is_group = is_group2;
+		entry->u1.ptr = saved_ptr1;
+		saved_ptr1 = NULL;
+		entry->u2.ptr = saved_ptr2;
+		saved_ptr2 = NULL;
+		error = ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	goto out;
  delete:
-	error = -ENOENT;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_double_path_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_DOUBLE_PATH_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
 			continue;
 		acl = container_of(ptr, struct ccs_double_path_acl_record,
 				   head);
-		if (acl->u1.filename1 != saved_filename1 ||
-		    acl->u2.filename2 != saved_filename2)
+		if (acl->u1.ptr != saved_ptr1 || acl->u2.ptr != saved_ptr2)
 			continue;
 		acl->perm &= ~perm;
 		error = ccs_del_domain_acl(acl->perm ? NULL : ptr);
 		break;
 	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	if (is_group1)
+		ccs_put_path_group((struct ccs_path_group_entry *) saved_ptr1);
+	else
+		ccs_put_name((struct ccs_path_info *) saved_ptr1);
+	if (is_group2)
+		ccs_put_path_group((struct ccs_path_group_entry *) saved_ptr2);
+	else
+		ccs_put_name((struct ccs_path_info *) saved_ptr2);
+	kfree(entry);
 	return error;
 }
 
@@ -1221,10 +1286,13 @@
 				     const struct ccs_path_info *filename1,
 				     const struct ccs_path_info *filename2)
 {
-	const struct ccs_domain_info *domain = r->domain;
+	const struct ccs_domain_info *domain = r->cookie.u.domain;
 	struct ccs_acl_info *ptr;
 	const u8 perm = 1 << type;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	int error = -EPERM;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct ccs_double_path_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_DOUBLE_PATH_ACL)
 			continue;
@@ -1251,9 +1319,12 @@
 				continue;
 		}
 		r->cond = ccs_get_condition_part(ptr);
-		return 0;
+		error = 0;
+		break;
 	}
-	return -EPERM;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return error;
 }
 
 /**
@@ -1281,21 +1352,25 @@
 	ccs_audit_file_log(r, msg, filename->name, NULL, !error);
 	if (!error)
 		goto ok;
-	if (ccs_verbose_mode(r->domain))
+	if (ccs_verbose_mode(r->cookie.u.domain))
 		printk(KERN_WARNING "TOMOYO-%s: Access '%s %s' denied for %s\n",
 		       ccs_get_msg(is_enforce), msg, filename->name,
-		       ccs_get_last_name(r->domain));
+		       ccs_get_last_name(r->cookie.u.domain));
 	if (is_enforce) {
 		error = ccs_check_supervisor(r, "allow_%s %s\n",
 					     msg, filename->name);
 		if (error == 1)
 			goto retry;
 	}
-	if (r->mode == 1 && ccs_domain_quota_ok(r->domain))
-		ccs_update_single_path_acl(operation,
-					   ccs_get_file_pattern(filename),
-					   r->domain, ccs_handler_cond(),
-					   false);
+	if (r->mode == 1 && ccs_domain_quota_ok(r->cookie.u.domain)) {
+		struct ccs_cookie cookie;
+		ccs_add_cookie(&cookie, filename);
+		ccs_get_file_pattern(&cookie);
+		ccs_update_single_path_acl(operation, cookie.u.path->name,
+					   r->cookie.u.domain,
+					   ccs_handler_cond(), false);
+		ccs_del_cookie(&cookie);
+	}
 	if (!is_enforce)
 		error = 0;
  ok:
@@ -1537,23 +1612,31 @@
 	ccs_audit_file_log(&r, msg, buf1->name, buf2->name, !error);
 	if (!error)
 		goto out;
-	if (ccs_verbose_mode(r.domain))
+	if (ccs_verbose_mode(r.cookie.u.domain))
 		printk(KERN_WARNING "TOMOYO-%s: Access '%s %s %s' "
 		       "denied for %s\n", ccs_get_msg(is_enforce),
 		       msg, buf1->name, buf2->name,
-		       ccs_get_last_name(r.domain));
+		       ccs_get_last_name(r.cookie.u.domain));
 	if (is_enforce) {
 		error = ccs_check_supervisor(&r, "allow_%s %s %s\n",
 					     msg, buf1->name, buf2->name);
 		if (error == 1)
 			goto retry;
 	}
-	if (r.mode == 1 && ccs_domain_quota_ok(r.domain))
-		ccs_update_double_path_acl(operation,
-					   ccs_get_file_pattern(buf1),
-					   ccs_get_file_pattern(buf2),
-					   r.domain, ccs_handler_cond(),
-					   false);
+	if (r.mode == 1 && ccs_domain_quota_ok(r.cookie.u.domain)) {
+		struct ccs_cookie cookie1;
+		struct ccs_cookie cookie2;
+		ccs_add_cookie(&cookie1, buf1);
+		ccs_add_cookie(&cookie2, buf2);
+		ccs_get_file_pattern(&cookie1);
+		ccs_get_file_pattern(&cookie2);
+		ccs_update_double_path_acl(operation, cookie1.u.path->name,
+					   cookie2.u.path->name,
+					   r.cookie.u.domain,
+					   ccs_handler_cond(), false);
+		ccs_del_cookie(&cookie1);
+		ccs_del_cookie(&cookie2);
+	}
  out:
 	ccs_free(buf1);
 	ccs_free(buf2);
@@ -1600,74 +1683,83 @@
 				const struct ccs_condition_list *condition,
 				const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
-	const struct ccs_path_info *saved_filename;
+	const void *saved_ptr;
 	struct ccs_acl_info *ptr;
-	struct ccs_ioctl_acl_record *acl;
-	int error = -ENOMEM;
+	struct ccs_ioctl_acl_record *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	bool is_group = false;
 	if (!domain)
 		return -EINVAL;
 	if (!ccs_is_correct_path(filename, 0, 0, 0, __func__))
 		return -EINVAL;
 	if (filename[0] == '@') {
-		/*
-		 * This cast is OK because I don't dereference
-		 * in this function.
-		 */
-		saved_filename = (struct ccs_path_info *)
-			ccs_find_or_assign_new_path_group(filename + 1);
+		saved_ptr = ccs_get_path_group(filename + 1);
 		is_group = true;
 	} else {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
 		if (!strcmp(filename, "pipe:"))
 			filename = "pipe:[\\$]";
 #endif
-		saved_filename = ccs_save_name(filename);
+		saved_ptr = ccs_get_name(filename);
 	}
-	if (!saved_filename)
+	if (!saved_ptr)
 		return -ENOMEM;
-	mutex_lock(&lock);
 	if (is_delete)
 		goto delete;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_ioctl_acl_record *acl;
 		if (ccs_acl_type1(ptr) != TYPE_IOCTL_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
 			continue;
 		acl = container_of(ptr, struct ccs_ioctl_acl_record, head);
-		if (acl->u.filename != saved_filename ||
+		if (acl->u.ptr != saved_ptr ||
 		    acl->cmd_min != cmd_min || acl->cmd_max != cmd_max)
 			continue;
 		error = ccs_add_domain_acl(NULL, ptr);
-		goto out;
+		break;
 	}
-	/* Not found. Append it to the tail. */
-	acl = ccs_alloc_acl_element(TYPE_IOCTL_ACL, condition);
-	if (!acl)
-		goto out;
-	acl->u_is_group = is_group;
-	acl->u.filename = saved_filename;
-	acl->cmd_min = cmd_min;
-	acl->cmd_max = cmd_max;
-	error = ccs_add_domain_acl(domain, &acl->head);
+	if (error && ccs_memory_ok(entry)) {
+		entry->head.type = TYPE_IOCTL_ACL;
+		entry->head.cond = condition;
+		entry->u_is_group = is_group;
+		entry->u.ptr = saved_ptr;
+		saved_ptr = NULL;
+		entry->cmd_min = cmd_min;
+		entry->cmd_max = cmd_max;
+		error = ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	goto out;
  delete:
-	error = -ENOENT;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_ioctl_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_IOCTL_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
 			continue;
 		acl = container_of(ptr, struct ccs_ioctl_acl_record, head);
-		if (acl->u.filename != saved_filename ||
+		if (acl->u.ptr != saved_ptr ||
 		    acl->cmd_min != cmd_min || acl->cmd_max != cmd_max)
 			continue;
 		error = ccs_del_domain_acl(ptr);
 		break;
 	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	if (is_group)
+		ccs_put_path_group((struct ccs_path_group_entry *) saved_ptr);
+	else
+		ccs_put_name((struct ccs_path_info *) saved_ptr);
+	kfree(entry);
 	return error;
 }
 
@@ -1684,9 +1776,12 @@
 			       const struct ccs_path_info *filename,
 			       const unsigned int cmd)
 {
-	struct ccs_domain_info *domain = r->domain;
+	struct ccs_domain_info *domain = r->cookie.u.domain;
 	struct ccs_acl_info *ptr;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	int error = -EPERM;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct ccs_ioctl_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_IOCTL_ACL)
 			continue;
@@ -1704,9 +1799,12 @@
 				continue;
 		}
 		r->cond = ccs_get_condition_part(ptr);
-		return 0;
+		error = 0;
+		break;
 	}
-	return -EPERM;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return error;
 }
 
 /**
@@ -1731,10 +1829,10 @@
 	ccs_audit_ioctl_log(r, cmd, filename->name, !error);
 	if (!error)
 		return 0;
-	if (ccs_verbose_mode(r->domain))
+	if (ccs_verbose_mode(r->cookie.u.domain))
 		printk(KERN_WARNING "TOMOYO-%s: Access 'ioctl %s %u' denied "
 		       "for %s\n", ccs_get_msg(is_enforce), filename->name,
-		       cmd, ccs_get_last_name(r->domain));
+		       cmd, ccs_get_last_name(r->cookie.u.domain));
 	if (is_enforce) {
 		int err = ccs_check_supervisor(r, "allow_ioctl %s %u\n",
 					       filename->name, cmd);
@@ -1742,9 +1840,15 @@
 			goto retry;
 		return err;
 	}
-	if (r->mode == 1 && ccs_domain_quota_ok(r->domain))
-		ccs_update_ioctl_acl(ccs_get_file_pattern(filename), cmd, cmd,
-				     r->domain, ccs_handler_cond(), false);
+	if (r->mode == 1 && ccs_domain_quota_ok(r->cookie.u.domain)) {
+		struct ccs_cookie cookie;
+		ccs_add_cookie(&cookie, filename);
+		ccs_get_file_pattern(&cookie);
+		ccs_update_ioctl_acl(cookie.u.path->name, cmd, cmd,
+				     r->cookie.u.domain, ccs_handler_cond(),
+				     false);
+		ccs_del_cookie(&cookie);
+	}
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_capability.c	(working copy)
@@ -99,16 +99,18 @@
 				     const struct ccs_condition_list *condition,
 				     const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
+	struct ccs_capability_acl_record *entry = NULL;
 	struct ccs_acl_info *ptr;
-	struct ccs_capability_acl_record *acl;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!domain)
 		return -EINVAL;
-	mutex_lock(&lock);
 	if (is_delete)
 		goto delete;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_capability_acl_record *acl;
 		if (ccs_acl_type1(ptr) != TYPE_CAPABILITY_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
@@ -117,18 +119,23 @@
 		if (acl->operation != operation)
 			continue;
 		error = ccs_add_domain_acl(NULL, ptr);
-		goto out;
+		break;
 	}
-	/* Not found. Append it to the tail. */
-	acl = ccs_alloc_acl_element(TYPE_CAPABILITY_ACL, condition);
-	if (!acl)
-		goto out;
-	acl->operation = operation;
-	error = ccs_add_domain_acl(domain, &acl->head);
+	if (error && ccs_memory_ok(entry)) {
+		entry->head.type = TYPE_CAPABILITY_ACL;
+		entry->head.cond = condition;
+		entry->operation = operation;
+		error = ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	goto out;
  delete:
-	error = -ENOENT;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_capability_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_CAPABILITY_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
@@ -139,8 +146,10 @@
 		error = ccs_del_domain_acl(ptr);
 		break;
 	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	kfree(entry);
 	return error;
 }
 
@@ -164,7 +173,9 @@
 	if (!r.mode)
 		return true;
  retry:
-	list1_for_each_entry(ptr, &r.domain->acl_info_list, list) {
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &r.cookie.u.domain->acl_info_list, list) {
 		struct ccs_capability_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_CAPABILITY_ACL)
 			continue;
@@ -176,13 +187,15 @@
 		found = true;
 		break;
 	}
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION START *****/
 	ccs_audit_capability_log(&r, operation, found);
 	if (found)
 		return true;
-	if (ccs_verbose_mode(r.domain))
+	if (ccs_verbose_mode(r.cookie.u.domain))
 		printk(KERN_WARNING "TOMOYO-%s: %s denied for %s\n",
 		       ccs_get_msg(is_enforce), ccs_cap2name(operation),
-		       ccs_get_last_name(r.domain));
+		       ccs_get_last_name(r.cookie.u.domain));
 	if (is_enforce) {
 		int error = ccs_check_supervisor(&r, KEYWORD_ALLOW_CAPABILITY
 						 "%s\n",
@@ -191,8 +204,8 @@
 			goto retry;
 		return !error;
 	}
-	if (r.mode == 1 && ccs_domain_quota_ok(r.domain))
-		ccs_update_capability_acl(operation, r.domain,
+	if (r.mode == 1 && ccs_domain_quota_ok(r.cookie.u.domain))
+		ccs_update_capability_acl(operation, r.cookie.u.domain,
 					  ccs_handler_cond(), false);
 	return true;
 }
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_cond.c	(working copy)
@@ -391,7 +391,7 @@
 	*cp = '\0';
 	if (!ccs_is_correct_path(start, 0, 0, 0, __func__))
 		goto out;
-	value = ccs_save_name(start);
+	value = ccs_get_name(start);
 	if (!value)
 		goto out;
 	argv->index = index;
@@ -440,7 +440,7 @@
 	}
 	if (!*cp || !ccs_is_correct_path(cp, 0, 0, 0, __func__))
 		goto out;
-	name = ccs_save_name(cp);
+	name = ccs_get_name(cp);
 	if (!name)
 		goto out;
 	if (!strcmp(start, "NULL")) {
@@ -454,7 +454,7 @@
 		*cp = '\0';
 		if (!ccs_is_correct_path(start, 0, 0, 0, __func__))
 			goto out;
-		value = ccs_save_name(start);
+		value = ccs_get_name(start);
 		if (!value)
 			goto out;
 	}
@@ -496,7 +496,7 @@
 	*cp = '\0';
 	if (!ccs_is_correct_path(start, 0, 0, 0, __func__))
 		goto out;
-	value = ccs_save_name(start);
+	value = ccs_get_name(start);
 	if (!value)
 		goto out;
 	symlinkp->is_not = is_not;
@@ -507,7 +507,7 @@
 }
 
 /* The list for "struct ccs_condition_list". */
-static LIST1_HEAD(ccs_condition_list);
+LIST_HEAD(ccs_condition_list);
 
 enum ccs_conditions_index {
 	TASK_UID,             /* current_uid()   */
@@ -678,40 +678,27 @@
 static struct ccs_condition_list *
 ccs_find_same_condition(struct ccs_condition_list *new_ptr, const u32 size)
 {
-	static DEFINE_MUTEX(lock);
 	struct ccs_condition_list *ptr;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_condition_list, list) {
-		/* Don't compare if size differs. */
-		if (ptr->condc != new_ptr->condc ||
-		    ptr->argc != new_ptr->argc ||
-		    ptr->envc != new_ptr->envc ||
-		    ptr->symlinkc != new_ptr->symlinkc)
+	int error = -ENOMEM;
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_condition_list, list) {
+		if (memcmp(&ptr->head, &new_ptr->head, sizeof(ptr->head)) ||
+		    memcmp(ptr + 1, new_ptr + 1, size - sizeof(ptr)))
 			continue;
-		/*
-		 * Compare ptr and new_ptr
-		 * except ptr->list and new_ptr->list.
-		 */
-		if (memcmp(((u8 *) ptr) + sizeof(ptr->list),
-			   ((u8 *) new_ptr) + sizeof(new_ptr->list),
-			   size - sizeof(ptr->list)))
-			continue;
 		/* Same entry found. Share this entry. */
-		ccs_free(new_ptr);
+		atomic_inc(&ptr->users);
+		kfree(new_ptr);
 		new_ptr = ptr;
-		goto ok;
+		error = 0;
+		break;
 	}
-	/* Same entry not found. Save this entry. */
-	ptr = ccs_alloc_element(size);
-	if (ptr) {
-		memmove(ptr, new_ptr, size);
-		/* Append to chain. */
-		list1_add_tail_mb(&ptr->list, &ccs_condition_list);
+	if (error && !ccs_memory_ok(new_ptr)) {
+		kfree(new_ptr);
+		new_ptr = NULL;
 	}
-	ccs_free(new_ptr);
-	new_ptr = ptr;
- ok:
-	mutex_unlock(&lock);
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	return new_ptr;
 }
 
@@ -837,15 +824,16 @@
 		+ argc * sizeof(struct ccs_argv_entry)
 		+ envc * sizeof(struct ccs_envp_entry)
 		+ symlinkc * sizeof(struct ccs_symlinkp_entry);
-	new_ptr = ccs_alloc(size, false);
+	new_ptr = kzalloc(size, GFP_KERNEL);
 	if (!new_ptr)
 		return NULL;
 	for (i = 0; i < 4; i++)
-		new_ptr->post_state[i] = post_state[i];
-	new_ptr->condc = condc;
-	new_ptr->argc = argc;
-	new_ptr->envc = envc;
-	new_ptr->symlinkc = symlinkc;
+		new_ptr->head.post_state[i] = post_state[i];
+	atomic_set(&new_ptr->users, 1);
+	new_ptr->head.condc = condc;
+	new_ptr->head.argc = argc;
+	new_ptr->head.envc = envc;
+	new_ptr->head.symlinkc = symlinkc;
 	ptr = (unsigned long *) (new_ptr + 1);
 	argv = (struct ccs_argv_entry *) (ptr + condc);
 	envp = (struct ccs_envp_entry *) (argv + argc);
@@ -992,7 +980,7 @@
 	BUG_ON(condc);
 	return ccs_find_same_condition(new_ptr, size);
  out:
-	ccs_free(new_ptr);
+	kfree(new_ptr);
 	return NULL;
 }
 
@@ -1166,10 +1154,10 @@
 	struct linux_binprm *bprm = NULL;
 	if (!cond)
 		return true;
-	condc = cond->condc;
-	argc = cond->argc;
-	envc = cond->envc;
-	symlinkc = cond->symlinkc;
+	condc = cond->head.condc;
+	argc = cond->head.argc;
+	envc = cond->head.envc;
+	symlinkc = cond->head.symlinkc;
 	obj = r->obj;
 	if (r->ee)
 		bprm = r->ee->bprm;
@@ -1521,10 +1509,10 @@
 	char buffer[32];
 	if (!cond)
 		goto no_condition;
-	condc = cond->condc;
-	argc = cond->argc;
-	envc = cond->envc;
-	symlinkc = cond->symlinkc;
+	condc = cond->head.condc;
+	argc = cond->head.argc;
+	envc = cond->head.envc;
+	symlinkc = cond->head.symlinkc;
 	ptr = (const unsigned long *) (cond + 1);
 	argv = (const struct ccs_argv_entry *) (ptr + condc);
 	envp = (const struct ccs_envp_entry *) (argv + argc);
@@ -1617,7 +1605,7 @@
 			goto out;
 	}
  post_condition:
-	i = cond->post_state[3];
+	i = cond->head.post_state[3];
 	if (!i)
 		goto no_condition;
 	if (!ccs_io_printf(head, " ; set"))
@@ -1626,7 +1614,7 @@
 		if (!(i & (1 << j)))
 			continue;
 		if (!ccs_io_printf(head, " task.state[%u]=%u", j,
-				   cond->post_state[j]))
+				   cond->head.post_state[j]))
 			goto out;
 	}
  no_condition:
Index: trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/tomoyo_exec.c	(working copy)
@@ -49,24 +49,29 @@
 				  const struct ccs_condition_list *condition,
 				  const bool is_delete)
 {
-	static DEFINE_MUTEX(lock);
+	struct ccs_argv0_acl_record *entry = NULL;
 	struct ccs_acl_info *ptr;
-	struct ccs_argv0_acl_record *acl;
 	const struct ccs_path_info *saved_filename;
 	const struct ccs_path_info *saved_argv0;
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(filename, 1, 0, -1, __func__) ||
 	    !ccs_is_correct_path(argv0, -1, 0, -1, __func__) ||
 	    strchr(argv0, '/'))
 		return -EINVAL;
-	saved_filename = ccs_save_name(filename);
-	saved_argv0 = ccs_save_name(argv0);
-	if (!saved_filename || !saved_argv0)
+	saved_filename = ccs_get_name(filename);
+	saved_argv0 = ccs_get_name(argv0);
+	if (!saved_filename || !saved_argv0) {
+		ccs_put_name(saved_filename);
+		ccs_put_name(saved_argv0);
 		return -ENOMEM;
-	mutex_lock(&lock);
+	}
 	if (is_delete)
 		goto delete;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_argv0_acl_record *acl;
 		if (ccs_acl_type1(ptr) != TYPE_ARGV0_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
@@ -76,19 +81,26 @@
 		    acl->argv0 != saved_argv0)
 			continue;
 		error = ccs_add_domain_acl(NULL, ptr);
-		goto out;
+		break;
 	}
-	/* Not found. Append it to the tail. */
-	acl = ccs_alloc_acl_element(TYPE_ARGV0_ACL, condition);
-	if (!acl)
-		goto out;
-	acl->filename = saved_filename;
-	acl->argv0 = saved_argv0;
-	error = ccs_add_domain_acl(domain, &acl->head);
+	if (error && ccs_memory_ok(entry)) {
+		entry->head.type = TYPE_ARGV0_ACL;
+		entry->head.cond = condition;	
+		entry->filename = saved_filename;
+		saved_filename = NULL;
+		entry->argv0 = saved_argv0;
+		saved_argv0 = NULL;
+		error = ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
 	goto out;
  delete:
-	error = -ENOENT;
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+		struct ccs_argv0_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_ARGV0_ACL)
 			continue;
 		if (ccs_get_condition_part(ptr) != condition)
@@ -100,8 +112,12 @@
 		error = ccs_del_domain_acl(ptr);
 		break;
 	}
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
  out:
-	mutex_unlock(&lock);
+	ccs_put_name(saved_filename);
+	ccs_put_name(saved_argv0);
+	kfree(entry);
 	return error;
 }
 
@@ -119,12 +135,14 @@
 			       const char *argv0)
 {
 	int error = -EPERM;
-	struct ccs_domain_info *domain = r->domain;
+	struct ccs_domain_info *domain = r->cookie.u.domain;
 	struct ccs_acl_info *ptr;
 	struct ccs_path_info argv_0;
 	argv_0.name = argv0;
 	ccs_fill_path_info(&argv_0);
-	list1_for_each_entry(ptr, &domain->acl_info_list, list) {
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_entry(ptr, &domain->acl_info_list, list) {
 		struct ccs_argv0_acl_record *acl;
 		if (ccs_acl_type2(ptr) != TYPE_ARGV0_ACL)
 			continue;
@@ -137,6 +155,8 @@
 		error = 0;
 		break;
 	}
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
 	return error;
 }
 
@@ -163,16 +183,17 @@
 	ccs_audit_argv0_log(r, filename->name, argv0, !error);
 	if (!error)
 		return 0;
-	if (ccs_verbose_mode(r->domain))
+	if (ccs_verbose_mode(r->cookie.u.domain))
 		printk(KERN_WARNING "TOMOYO-%s: Run %s as %s denied for %s\n",
 		       ccs_get_msg(is_enforce), filename->name, argv0,
-		       ccs_get_last_name(r->domain));
+		       ccs_get_last_name(r->cookie.u.domain));
 	if (is_enforce)
 		return ccs_check_supervisor(r, KEYWORD_ALLOW_ARGV0 "%s %s\n",
 					    filename->name, argv0);
-	if (r->mode == 1 && ccs_domain_quota_ok(r->domain))
-		ccs_update_argv0_entry(filename->name, argv0, r->domain,
-				       ccs_handler_cond(), false);
+	if (r->mode == 1 && ccs_domain_quota_ok(r->cookie.u.domain))
+		ccs_update_argv0_entry(filename->name, argv0,
+				       r->cookie.u.domain, ccs_handler_cond(),
+				       false);
 	return 0;
 }
 
Index: trunk/1.6.x/ccs-patch/fs/sakura_umount.c
===================================================================
--- trunk/1.6.x/ccs-patch/fs/sakura_umount.c	(revision 2535)
+++ trunk/1.6.x/ccs-patch/fs/sakura_umount.c	(working copy)
@@ -21,15 +21,8 @@
 #include <linux/namespace.h>
 #endif
 
-/* Structure for "deny_unmount" keyword. */
-struct ccs_no_umount_entry {
-	struct list1_head list;
-	const struct ccs_path_info *dir;
-	bool is_deleted;
-};
-
 /* The list for "struct ccs_no_umount_entry". */
-static LIST1_HEAD(ccs_no_umount_list);
+LIST_HEAD(ccs_no_umount_list);
 
 /**
  * ccs_update_no_umount_acl - Update "struct ccs_no_umount_entry" list.
@@ -41,37 +34,41 @@
  */
 static int ccs_update_no_umount_acl(const char *dir, const bool is_delete)
 {
-	struct ccs_no_umount_entry *new_entry;
+	struct ccs_no_umount_entry *entry = NULL;
 	struct ccs_no_umount_entry *ptr;
 	const struct ccs_path_info *saved_dir;
-	static DEFINE_MUTEX(lock);
-	int error = -ENOMEM;
+	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(dir, 1, 0, 1, __func__))
 		return -EINVAL;
-	saved_dir = ccs_save_name(dir);
+	saved_dir = ccs_get_name(dir);
 	if (!saved_dir)
 		return -ENOMEM;
-	mutex_lock(&lock);
-	list1_for_each_entry(ptr, &ccs_no_umount_list, list) {
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	/***** WRITER SECTION START *****/
+	down_write(&ccs_policy_lock);
+	list_for_each_entry(ptr, &ccs_no_umount_list, list) {
 		if (ptr->dir != saved_dir)
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
-		goto out;
+		break;
 	}
-	if (is_delete) {
-		error = -ENOENT;
-		goto out;
+	if (!is_delete && error && ccs_memory_ok(entry)) {
+		entry->dir = saved_dir;
+		saved_dir = NULL;
+		list_add_tail(&entry->list, &ccs_no_umount_list);
+		entry = NULL;
+		error = 0;
 	}
-	new_entry = ccs_alloc_element(sizeof(*new_entry));
-	if (!new_entry)
+	up_write(&ccs_policy_lock);
+	/***** WRITER SECTION END *****/
+	if (is_delete)
 		goto out;
-	new_entry->dir = saved_dir;
-	list1_add_tail_mb(&new_entry->list, &ccs_no_umount_list);
-	error = 0;
 	printk(KERN_CONT "%sDon't allow umount %s\n", ccs_log_level, dir);
  out:
-	mutex_unlock(&lock);
+	ccs_put_name(saved_dir);
+	kfree(entry);
 	ccs_update_counter(CCS_UPDATES_COUNTER_SYSTEM_POLICY);
 	return error;
 }
@@ -105,7 +102,7 @@
 		goto out;
 	dir.name = dir0;
 	ccs_fill_path_info(&dir);
-	list1_for_each_entry(ptr, &ccs_no_umount_list, list) {
+	list_for_each_entry(ptr, &ccs_no_umount_list, list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!ccs_path_matches_pattern(&dir, ptr->dir))
@@ -157,17 +154,22 @@
  */
 bool ccs_read_no_umount_policy(struct ccs_io_buffer *head)
 {
-	struct list1_head *pos;
-	list1_for_each_cookie(pos, head->read_var2, &ccs_no_umount_list) {
+	struct list_head *pos;
+	bool done = true;
+	/***** READER SECTION START *****/
+	down_read(&ccs_policy_lock);
+	list_for_each_cookie(pos, head->read_var2.u.list,
+			     &ccs_no_umount_list) {
 		struct ccs_no_umount_entry *ptr;
-		ptr = list1_entry(pos, struct ccs_no_umount_entry, list);
+		ptr = list_entry(pos, struct ccs_no_umount_entry, list);
 		if (ptr->is_deleted)
 			continue;
-		if (!ccs_io_printf(head, KEYWORD_DENY_UNMOUNT "%s\n",
-				   ptr->dir->name))
-			goto out;
+		done = ccs_io_printf(head, KEYWORD_DENY_UNMOUNT "%s\n",
+				     ptr->dir->name);
+		if (!done)
+			break;
 	}
-	return true;
- out:
-	return false;
+	up_read(&ccs_policy_lock);
+	/***** READER SECTION END *****/
+	return done;
 }
