Index: include/linux/ccs_common.h
===================================================================
--- include/linux/ccs_common.h	(revision 2823)
+++ include/linux/ccs_common.h	(working copy)
@@ -105,16 +105,20 @@
 	atomic_t users;
 	u32 size;
 	u16 condc;
-	u16 exepathc;
+	u16 ulong_count;
+	u16 number_group_count;
+	u16 path_info_count;
+	u16 path_group_count;
 	u16 argc;
 	u16 envc;
-	u16 symlinkc;
 	u8 post_state[4];
-	/* "unsigned long condition[condc]" follows here. */
-	/* "struct ccs_exepath_entry exepathp[exepathc]" follows here. */
-	/* "struct ccs_argv_entry argv[argc]" follows here. */
-	/* "struct ccs_envp_entry envp[envc]" follows here. */
-	/* "struct ccs_symlinkp_entry symlinkp[symlinkc]" follows here. */
+	/* "u32 condition[condc]" follows. */
+	/* "unsigned long values[ulong_count]" follows. */
+	/* "struct ccs_number_group_entry *ng[number_group_count] follows. */
+	/* "struct ccs_path_info *pi[path_info_count] follows. */
+	/* "struct ccs_path_group_entry *pg[path_group_count] follows. */
+	/* "struct ccs_argv_entry argv[argc]" follows. */
+	/* "struct ccs_envp_entry envp[envc]" follows. */
 };
 
 struct ccs_execve_entry;
@@ -184,6 +188,22 @@
 	atomic_t users;
 };
 
+/* Structure for "number_group" directive. */
+struct ccs_number_group_member {
+	struct list_head list;
+	unsigned long min;
+	unsigned long max;
+	bool is_deleted;
+};
+
+/* Structure for "number_group" directive. */
+struct ccs_number_group_entry {
+	struct list_head list;
+	const struct ccs_path_info *group_name;
+	struct list_head number_group_member_list;
+	atomic_t users;
+};
+
 /* Structure for "address_group" directive. */
 struct ccs_address_group_member {
 	struct list_head list;
@@ -391,18 +411,6 @@
 	bool is_not;
 };
 
-/* Structure for symlink's target. */
-struct ccs_symlinkp_entry {
-	const struct ccs_path_info *value;
-	bool is_not;
-};
-
-/* Structure for executable's pathname. */
-struct ccs_exepath_entry {
-	const struct ccs_path_info *value;
-	bool is_not;
-};
-
 /*
  * Structure for "execute_handler" and "denied_execute_handler" directive.
  * These directives can exist only one entry in a domain.
@@ -651,6 +659,7 @@
 #define KEYWORD_NO_INITIALIZE_DOMAIN      "no_initialize_domain "
 #define KEYWORD_NO_KEEP_DOMAIN            "no_keep_domain "
 #define KEYWORD_PATH_GROUP                "path_group "
+#define KEYWORD_NUMBER_GROUP              "number_group "
 #define KEYWORD_SELECT                    "select "
 #define KEYWORD_USE_PROFILE               "use_profile "
 #define KEYWORD_IGNORE_GLOBAL_ALLOW_READ  "ignore_global_allow_read"
@@ -997,6 +1006,12 @@
 /* Start garbage collector thread. */
 void ccs_run_gc(void);
 
+struct ccs_path_group_entry *ccs_get_path_group(const char *group_name);
+struct ccs_number_group_entry *ccs_get_number_group(const char *group_name);
+void ccs_put_number_group(struct ccs_number_group_entry *group);
+bool ccs_read_number_group_policy(struct ccs_io_buffer *head);
+int ccs_write_number_group_policy(char *data, const bool is_delete);
+
 /* strcmp() for "struct ccs_path_info" structure. */
 static inline bool ccs_pathcmp(const struct ccs_path_info *a,
 			       const struct ccs_path_info *b)
@@ -1024,6 +1039,7 @@
 extern struct list_head ccs_address_group_list;
 extern struct list_head ccs_globally_readable_list;
 extern struct list_head ccs_path_group_list;
+extern struct list_head ccs_number_group_list;
 extern struct list_head ccs_pattern_list;
 extern struct list_head ccs_no_rewrite_list;
 extern struct list_head ccs_globally_usable_env_list;
Index: fs/realpath.c
===================================================================
--- fs/realpath.c	(revision 2823)
+++ fs/realpath.c	(working copy)
@@ -522,6 +522,45 @@
 	}
 }
 
+/**
+ * ccs_put_number_group - Delete memory for "struct ccs_number_group_entry".
+ *
+ * @group: Pointer to "struct ccs_number_group_entry".
+ */
+void ccs_put_number_group(struct ccs_number_group_entry *group)
+{
+	struct ccs_number_group_member *member;
+	struct ccs_number_group_member *next_member;
+	LIST_HEAD(q);
+	bool can_delete_group = false;
+	if (!group)
+		return;
+	mutex_lock(&ccs_policy_lock);
+	if (atomic_dec_and_test(&group->users)) {
+		list_for_each_entry_safe(member, next_member,
+					 &group->number_group_member_list,
+					 list) {
+			if (!member->is_deleted)
+				break;
+			list_del(&member->list);
+			list_add(&member->list, &q);
+		}
+		if (list_empty(&group->number_group_member_list)) {
+			list_del(&group->list);
+			can_delete_group = true;
+		}
+	}
+	mutex_unlock(&ccs_policy_lock);
+	list_for_each_entry_safe(member, next_member, &q, list) {
+		list_del(&member->list);
+		ccs_memory_free(member, sizeof(*member));
+	}
+	if (can_delete_group) {
+		ccs_put_name(group->group_name);
+		ccs_memory_free(group, sizeof(*group));
+	}
+}
+
 static LIST_HEAD(ccs_address_list);
 
 /**
@@ -583,6 +622,13 @@
 		ccs_memory_free(ptr, sizeof(*ptr));
 }
 
+struct ccs_condition_element {
+	u8 left;
+	u8 right;
+	u8 equals;
+	u8 type;
+};
+
 /**
  * ccs_put_condition - Delete memory for "struct ccs_condition".
  *
@@ -590,14 +636,19 @@
  */
 void ccs_put_condition(struct ccs_condition *cond)
 {
-	const unsigned long *ptr;
+	const struct ccs_condition_element *condp;
+	const unsigned long *ulong_p;
+	struct ccs_number_group_entry **number_group_p;
+	const struct ccs_path_info **path_info_p;
+	struct ccs_path_group_entry **path_group_p;
 	const struct ccs_argv_entry *argv;
 	const struct ccs_envp_entry *envp;
-	const struct ccs_symlinkp_entry *symlinkp;
 	u16 condc;
+	u16 number_group_count;
+	u16 path_info_count;
+	u16 path_group_count;
 	u16 argc;
 	u16 envc;
-	u16 symlinkc;
 	u16 i;
 	bool can_delete = false;
 	if (!cond)
@@ -611,21 +662,34 @@
 	if (!can_delete)
 		return;
 	condc = cond->condc;
+	number_group_count = cond->number_group_count;
+	path_info_count = cond->path_info_count;
+	path_group_count = cond->path_group_count;
 	argc = cond->argc;
 	envc = cond->envc;
-	symlinkc = cond->symlinkc;
-	ptr = (const unsigned long *) (cond + 1);
-	argv = (const struct ccs_argv_entry *) (ptr + condc);
+	condp = (const struct ccs_condition_element *) (cond + 1);
+	ulong_p = (unsigned long *) (condp + condc);
+	number_group_p = (struct ccs_number_group_entry **)
+		(ulong_p + cond->ulong_count);
+	path_info_p = (const struct ccs_path_info **)
+		(number_group_p + number_group_count);
+	path_group_p = (struct ccs_path_group_entry **)
+		(path_info_p + path_info_count);
+	argv = (const struct ccs_argv_entry *)
+		(path_group_p + path_group_count);
 	envp = (const struct ccs_envp_entry *) (argv + argc);
-	symlinkp = (const struct ccs_symlinkp_entry *) (envp + envc);
+	for (i = 0; i < cond->number_group_count; i++)
+		ccs_put_number_group(*number_group_p++);
+	for (i = 0; i < cond->path_info_count; i++)
+		ccs_put_name(*path_info_p++);
+	for (i = 0; i < cond->path_group_count; i++)
+		ccs_put_path_group(*path_group_p++);
 	for (i = 0; i < argc; argv++, i++)
 		ccs_put_name(argv->value);
 	for (i = 0; i < envc; envp++, i++) {
 		ccs_put_name(envp->name);
 		ccs_put_name(envp->value);
 	}
-	for (i = 0; i < symlinkc; symlinkp++, i++)
-		ccs_put_name(symlinkp->value);
 	ccs_memory_free(cond, cond->size);
 }
 
@@ -866,6 +930,8 @@
 	CCS_ID_ADDRESS_GROUP_MEMBER,
 	CCS_ID_PATH_GROUP,
 	CCS_ID_PATH_GROUP_MEMBER,
+	CCS_ID_NUMBER_GROUP,
+	CCS_ID_NUMBER_GROUP_MEMBER,
 	CCS_ID_GLOBAL_ENV,
 	CCS_ID_AGGREGATOR,
 	CCS_ID_DOMAIN_INITIALIZER,
@@ -1167,6 +1233,18 @@
 	return sizeof(*group);
 }
 
+static size_t ccs_del_number_group_member
+(struct ccs_number_group_member *member)
+{
+	return sizeof(*member);
+}
+
+static size_t ccs_del_number_group(struct ccs_number_group_entry *group)
+{
+	ccs_put_name(group->group_name);
+	return sizeof(*group);
+}
+
 static size_t ccs_del_reservedport(struct ccs_reserved_entry *ptr)
 {
 	return sizeof(*ptr);
@@ -1174,25 +1252,9 @@
 
 static size_t ccs_del_condition(struct ccs_condition *ptr)
 {
-	int i;
-	u16 condc = ptr->condc;
-	u16 argc = ptr->argc;
-	u16 envc = ptr->envc;
-	u16 symlinkc = ptr->symlinkc;
-	unsigned long *ptr2 = (unsigned long *) (ptr + 1);
-	struct ccs_argv_entry *argv = (struct ccs_argv_entry *) (ptr2 + condc);
-	struct ccs_envp_entry *envp = (struct ccs_envp_entry *) (argv + argc);
-	struct ccs_symlinkp_entry *symlinkp
-		= (struct ccs_symlinkp_entry *) (envp + envc);
-	for (i = 0; i < argc; i++)
-		ccs_put_name(argv[i].value);
-	for (i = 0; i < envc; i++) {
-		ccs_put_name(envp[i].name);
-		ccs_put_name(envp[i].value);
-	}
-	for (i = 0; i < symlinkc; i++)
-		ccs_put_name(symlinkp[i].value);
-	return ptr->size;
+	const size_t size = ptr->size;
+	ccs_put_condition(ptr);
+	return size;
 }
 
 static int ccs_gc_thread(void *unused)
@@ -1374,6 +1436,32 @@
 		}
 	}
 	{
+		struct ccs_number_group_entry *group;
+		list_for_each_entry_rcu(group, &ccs_number_group_list, list) {
+			struct ccs_number_group_member *member;
+			list_for_each_entry_rcu(member,
+						&group->
+						number_group_member_list,
+						list) {
+				if (!member->is_deleted)
+					continue;
+				if (ccs_add_to_gc(CCS_ID_NUMBER_GROUP_MEMBER,
+						  member, &ccs_gc_queue))
+					list_del_rcu(&member->list);
+				else
+					break;
+			}
+			if (!list_empty(&group->number_group_member_list) ||
+			    atomic_read(&group->users))
+				continue;
+			if (ccs_add_to_gc(CCS_ID_NUMBER_GROUP, group,
+					  &ccs_gc_queue))
+				list_del_rcu(&group->list);
+			else
+				break;
+		}
+	}
+	{
 		struct ccs_reserved_entry *ptr;
 		list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
 			if (!ptr->is_deleted)
@@ -1442,6 +1530,12 @@
 			case CCS_ID_ADDRESS_GROUP:
 				size = ccs_del_address_group(p->element);
 				break;
+			case CCS_ID_NUMBER_GROUP_MEMBER:
+				size = ccs_del_number_group_member(p->element);
+				break;
+			case CCS_ID_NUMBER_GROUP:
+				size = ccs_del_number_group(p->element);
+				break;
 			case CCS_ID_RESERVEDPORT:
 				size = ccs_del_reservedport(p->element);
 				break;
Index: fs/ccs_common.c
===================================================================
--- fs/ccs_common.c	(revision 2823)
+++ fs/ccs_common.c	(working copy)
@@ -2450,6 +2450,8 @@
 		return ccs_write_pattern_policy(data, is_delete);
 	if (ccs_str_starts(&data, KEYWORD_PATH_GROUP))
 		return ccs_write_path_group_policy(data, is_delete);
+	if (ccs_str_starts(&data, KEYWORD_NUMBER_GROUP))
+		return ccs_write_number_group_policy(data, is_delete);
 	if (ccs_str_starts(&data, KEYWORD_DENY_REWRITE))
 		return ccs_write_no_rewrite_policy(data, is_delete);
 	if (ccs_str_starts(&data, KEYWORD_ADDRESS_GROUP))
@@ -2517,11 +2519,17 @@
 			head->read_var2 = NULL;
 			head->read_step = 10;
 		case 10:
-			if (!ccs_read_address_group_policy(head))
+			if (!ccs_read_number_group_policy(head))
 				break;
+			head->read_var1 = NULL;
 			head->read_var2 = NULL;
 			head->read_step = 11;
 		case 11:
+			if (!ccs_read_address_group_policy(head))
+				break;
+			head->read_var2 = NULL;
+			head->read_step = 12;
+		case 12:
 			if (!ccs_read_reserved_port_policy(head))
 				break;
 			head->read_eof = true;
Index: fs/tomoyo_file.c
===================================================================
--- fs/tomoyo_file.c	(revision 2823)
+++ fs/tomoyo_file.c	(working copy)
@@ -121,8 +121,6 @@
 	return false;
 }
 
-static struct ccs_path_group_entry *ccs_get_path_group(const char *group_name);
-
 static bool ccs_check_and_save_path(const char *filename, bool *is_group,
 				    const void **saved_ptr)
 {
@@ -376,7 +374,7 @@
  *
  * Returns pointer to "struct ccs_path_group_entry" on success, NULL otherwise.
  */
-static struct ccs_path_group_entry *ccs_get_path_group(const char *group_name)
+struct ccs_path_group_entry *ccs_get_path_group(const char *group_name)
 {
 	struct ccs_path_group_entry *entry = NULL;
 	struct ccs_path_group_entry *group;
Index: fs/tomoyo_cond.c
===================================================================
--- fs/tomoyo_cond.c	(revision 2823)
+++ fs/tomoyo_cond.c	(working copy)
@@ -240,65 +240,45 @@
 	return result;
 }
 
-/**
- * ccs_scan_symlink - Scan symlink's target.
- *
- * @target:   Pointer to "struct ccs_path_info".
- * @symlinkc: Length of @symlinkp.
- * @symlinkp: Poiner to "struct ccs_symlinkp_entry".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_scan_symlink(struct ccs_path_info *target,
-			     u16 symlinkc,
-			     const struct ccs_symlinkp_entry *symlinkp)
-{
-	if (!target)
-		return false;
-	while (symlinkc) {
-		const bool bool1 =
-			ccs_path_matches_pattern(target, symlinkp->value);
-		const bool bool2 = symlinkp->is_not;
-		if (bool1 == bool2)
-			return false;
-		symlinkp++;
-		symlinkc--;
-	}
-	return true;
-}
+struct ccs_condition_element {
+	/*
+	 * Left hand operand. An "unsigned long" for CONSTANT_VALUE, two
+	 * "unsigned long" for CONSTANT_VALUE_RANGE, a "struct ccs_path_info *"
+	 * for EXEC_REALPATH, a "struct ccs_argv_entry" for ARGV_ENTRY, a
+	 * "struct ccs_envp_entry" for ENVP_ENTRY is attached to the tail of
+	 * the array of this struct.
+	 */
+	u8 left;
+	/*
+	 * Right hand operand.  An "unsigned long" for CONSTANT_VALUE, two
+	 * "unsigned long" for CONSTANT_VALUE_RANGE,
+	 * a "struct ccs_number_group *"
+	 a "struct ccs_path_info *"
+	 or a "struct ccs_group_info *" or
+	 * a "struct ccs_number_group *"
+	 * for EXEC_REALPATH, a "struct ccs_argv_entry" for ARGV_ENTRY, a
+	 * "struct ccs_envp_entry" for ENVP_ENTRY is attached to the tail of
+	 * the array of this struct.
+	 * PATH_INFO for a pathname, PATH_GROUP for a pathname group,
+	 * NUMBER_GROUP for a number group.
+	 */
+	u8 right;
+	/* Equation operator. 1 if equals or overlaps, 0 otherwise. */
+	u8 equals;
+	/*
+	 * Radix types for constant value .
+	 * 
+	 * Bit 7 and 6: Left hand operand's min value
+	 * Bit 5 and 4: Left hand operand's max value
+	 * Bit 3 and 2: Right hand operand's min value
+	 * Bit 1 and 0: Right hand operand's max value
+	 *
+	 * 01 is for decimal, 10 is for octal, 11 is for hexadecimal,
+	 * 00 is for invalid (i.e. not a value) expression.
+	 */
+	u8 type;
+};
 
-/**
- * ccs_scan_exepath - Scan executable's pathname.
- *
- * @file:     Pointer to "struct file".
- * @exepathc: Length of @exepathp.
- * @exepathp: Poiner to "struct ccs_exepath_entry".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_scan_exepath(struct file *file, u16 exepathc,
-			     const struct ccs_exepath_entry *exepathp)
-{
-	struct ccs_path_info path;
-	if (!file)
-		return false;
-	path.name = ccs_realpath_from_dentry(file->f_dentry, file->f_vfsmnt);
-	if (!path.name)
-		return false;
-	ccs_fill_path_info(&path);
-	while (exepathc) {
-		const bool bool1 =
-			ccs_path_matches_pattern(&path, exepathp->value);
-		const bool bool2 = exepathp->is_not;
-		if (bool1 == bool2)
-			break;
-		exepathp++;
-		exepathc--;
-	}
-	kfree(path.name);
-	return !exepathc;
-}
-
 /* Value type definition. */
 #define VALUE_TYPE_DECIMAL     1
 #define VALUE_TYPE_OCTAL       2
@@ -366,6 +346,36 @@
 }
 
 /**
+ * ccs_get_dqword - ccs_get_name() for a quoted string.
+ *
+ * @start: String to save.
+ *
+ * Returns pointer to "struct ccs_path_info" on success, NULL otherwise.
+ */
+static const struct ccs_path_info *ccs_get_dqword(char *start)
+{
+	char *cp;
+	if (*start++ != '"')
+		return NULL;
+	cp = start;
+	while (1) {
+		char c = *cp++;
+		if (!c)
+			return NULL;
+		if (c != '"')
+			continue;
+		c = *cp;
+		if (c && c != ' ')
+			continue;
+		*(cp - 1) = '\0';
+		break;
+	}
+	if (!ccs_is_correct_path(start, 0, 0, 0))
+		return NULL;
+	return ccs_get_name(start);
+}
+
+/**
  * ccs_parse_argv - Parse an argv[] condition part.
  *
  * @start: String to parse.
@@ -379,8 +389,6 @@
 	const struct ccs_path_info *value;
 	bool is_not;
 	char c;
-	char *cp;
-	start += 10;
 	if (ccs_parse_ulong(&index, &start) != VALUE_TYPE_DECIMAL)
 		goto out;
 	if (*start++ != ']')
@@ -392,15 +400,7 @@
 		is_not = true;
 	else
 		goto out;
-	if (*start++ != '"')
-		goto out;
-	cp = start + strlen(start) - 1;
-	if (cp < start || *cp != '"')
-		goto out;
-	*cp = '\0';
-	if (!ccs_is_correct_path(start, 0, 0, 0))
-		goto out;
-	value = ccs_get_name(start);
+	value = ccs_get_dqword(start);
 	if (!value)
 		goto out;
 	argv->index = index;
@@ -424,9 +424,7 @@
 	const struct ccs_path_info *name;
 	const struct ccs_path_info *value;
 	bool is_not;
-	char *cp;
-	start += 11;
-	cp = start;
+	char *cp = start;
 	/*
 	 * Since environment variable names don't
 	 * contain '=', I can treat '"]=' and '"]!='
@@ -455,15 +453,7 @@
 	if (!strcmp(start, "NULL")) {
 		value = NULL;
 	} else {
-		if (*start++ != '"')
-			goto out;
-		cp = start + strlen(start) - 1;
-		if (cp < start || *cp != '"')
-			goto out;
-		*cp = '\0';
-		if (!ccs_is_correct_path(start, 0, 0, 0))
-			goto out;
-		value = ccs_get_name(start);
+		value = ccs_get_dqword(start);
 		if (!value)
 			goto out;
 	}
@@ -475,86 +465,6 @@
 	return false;
 }
 
-/**
- * ccs_parse_symlinkp - Parse an symlink.target condition part.
- *
- * @start:    String to parse.
- * @symlinkp: Pointer to "struct ccs_symlinkp_entry".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_symlinkp(char *start, struct ccs_symlinkp_entry *symlinkp)
-{
-	const struct ccs_path_info *value;
-	bool is_not;
-	char c;
-	char *cp;
-	start += 14;
-	c = *start++;
-	if (c == '=')
-		is_not = false;
-	else if (c == '!' && *start++ == '=')
-		is_not = true;
-	else
-		goto out;
-	if (*start++ != '"')
-		goto out;
-	cp = start + strlen(start) - 1;
-	if (cp < start || *cp != '"')
-		goto out;
-	*cp = '\0';
-	if (!ccs_is_correct_path(start, 0, 0, 0))
-		goto out;
-	value = ccs_get_name(start);
-	if (!value)
-		goto out;
-	symlinkp->is_not = is_not;
-	symlinkp->value = value;
-	return true;
- out:
-	return false;
-}
-
-/**
- * ccs_parse_exepathp - Parse an executable's pathname condition part.
- *
- * @start:    String to parse.
- * @exepathp: Pointer to "struct ccs_exepath_entry".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_exepathp(char *start, struct ccs_exepath_entry *exepathp)
-{
-	const struct ccs_path_info *value;
-	bool is_not;
-	char c;
-	char *cp;
-	start += 13;
-	c = *start++;
-	if (c == '=')
-		is_not = false;
-	else if (c == '!' && *start++ == '=')
-		is_not = true;
-	else
-		goto out;
-	if (*start++ != '"')
-		goto out;
-	cp = start + strlen(start) - 1;
-	if (cp < start || *cp != '"')
-		goto out;
-	*cp = '\0';
-	if (!ccs_is_correct_path(start, 1, 0, 0))
-		goto out;
-	value = ccs_get_name(start);
-	if (!value)
-		goto out;
-	exepathp->is_not = is_not;
-	exepathp->value = value;
-	return true;
- out:
-	return false;
-}
-
 /* The list for "struct ccs_condition". */
 LIST_HEAD(ccs_condition_list);
 
@@ -596,6 +506,8 @@
 	TASK_TYPE,            /* ((u8) task->ccs_flags) &
 				 CCS_TASK_IS_EXECUTE_HANDLER */
 	TASK_EXECUTE_HANDLER, /* CCS_TASK_IS_EXECUTE_HANDLER */
+	EXEC_REALPATH,
+	SYMLINK_TARGET,
 	PATH1_UID,
 	PATH1_GID,
 	PATH1_INO,
@@ -613,7 +525,14 @@
 	PATH2_PARENT_GID,
 	PATH2_PARENT_INO,
 	PATH2_PARENT_PERM,
-	MAX_KEYWORD
+	MAX_KEYWORD,
+	CONSTANT_VALUE,
+	CONSTANT_VALUE_RANGE,
+	ARGV_ENTRY,
+	ENVP_ENTRY,
+	PATH_INFO,
+	PATH_GROUP,
+	NUMBER_GROUP,
 };
 
 static const char *ccs_condition_control_keyword[MAX_KEYWORD] = {
@@ -653,6 +572,8 @@
 	[MODE_OTHERS_EXECUTE]  = "others_execute",
 	[TASK_TYPE]            = "task.type",
 	[TASK_EXECUTE_HANDLER] = "execute_handler",
+	[EXEC_REALPATH]        = "exec.realpath",
+	[SYMLINK_TARGET]       = "symlink.target",
 	[PATH1_UID]            = "path1.uid",
 	[PATH1_GID]            = "path1.gid",
 	[PATH1_INO]            = "path1.ino",
@@ -724,18 +645,19 @@
  */
 struct ccs_condition *ccs_get_condition(char * const condition)
 {
+	static const bool debug = 0;
 	static const u8 offset = offsetof(struct ccs_condition, size);
 	char *start = condition;
 	struct ccs_condition *entry = NULL;
 	struct ccs_condition *ptr;
-	unsigned long *condp;
-	struct ccs_exepath_entry *exepathp;
+	struct ccs_condition_element *condp;
+	unsigned long *ulong_p;
+	struct ccs_number_group_entry **number_group_p;
+	const struct ccs_path_info **path_info_p;
+	struct ccs_path_group_entry **path_group_p;
 	struct ccs_argv_entry *argv;
 	struct ccs_envp_entry *envp;
-	struct ccs_symlinkp_entry *symlinkp;
 	u32 size;
-	u8 left;
-	u8 right;
 	u8 i;
 	bool found = false;
 	unsigned long left_min = 0;
@@ -743,10 +665,12 @@
 	unsigned long right_min = 0;
 	unsigned long right_max = 0;
 	u16 condc = 0;
-	u16 exepathc = 0;
+	u16 ulong_count = 0;
+	u16 number_group_count = 0;
+	u16 path_info_count = 0;
+	u16 path_group_count = 0;
 	u16 argc = 0;
 	u16 envc = 0;
-	u16 symlinkc = 0;
 	u8 post_state[4] = { 0, 0, 0, 0 };
 	/* Calculate at runtime. */
 	static u8 ccs_condition_control_keyword_len[MAX_KEYWORD];
@@ -763,55 +687,54 @@
 	else if (*start)
 		return NULL;
 	while (1) {
+		u8 left;
+		u8 right;
 		while (*start == ' ')
 			start++;
 		if (!*start)
 			break;
+		if (debug)
+			printk(KERN_WARNING "%u: start=<%s>\n", __LINE__,
+			       start);
 		if (!strncmp(start, "exec.argv[", 10)) {
 			argc++;
+			condc++;
 			start = strchr(start + 10, ' ');
 			if (!start)
 				break;
 			continue;
 		} else if (!strncmp(start, "exec.envp[\"", 11)) {
 			envc++;
+			condc++;
 			start = strchr(start + 11, ' ');
 			if (!start)
 				break;
 			continue;
-		} else if (!strncmp(start, "symlink.target", 14)) {
-			symlinkc++;
-			start = strchr(start + 14, ' ');
-			if (!start)
-				break;
-			continue;
-		} else if (!strncmp(start, "exec.realpath", 13)) {
-			exepathc++;
-			start = strchr(start + 13, ' ');
-			if (!start)
-				break;
-			continue;
 		}
 		for (left = 0; left < MAX_KEYWORD; left++) {
 			const int len =
 				ccs_condition_control_keyword_len[left];
 			if (strncmp(start, ccs_condition_control_keyword[left],
-				    len))
+				    len) ||
+			    (start[len] != '!' && start[len] != '='))
 				continue;
 			start += len;
 			break;
 		}
+		if (debug)
+			printk(KERN_WARNING "%u: start=<%s> left=%u\n",
+			       __LINE__, start, left);
 		if (left < MAX_KEYWORD)
 			goto check_operator_1;
 		if (!ccs_parse_ulong(&left_min, &start))
 			goto out;
-		condc++; /* body */
+		ulong_count++;
 		if (*start != '-')
 			goto check_operator_1;
 		start++;
 		if (!ccs_parse_ulong(&left_max, &start) || left_min > left_max)
 			goto out;
-		condc++; /* body */
+		ulong_count++;
  check_operator_1:
 		if (strncmp(start, "!=", 2) == 0)
 			start += 2;
@@ -819,128 +742,145 @@
 			start++;
 		else
 			goto out;
-		condc++; /* header */
+		condc++;
+		if (debug)
+			printk(KERN_WARNING "%u: start=<%s> left=%u\n",
+			       __LINE__, start, left);
+		if (*start == '@') {
+			while (*start && *start != ' ')
+				start++;
+			if (left == EXEC_REALPATH || left == SYMLINK_TARGET)
+				path_group_count++;
+			else
+				number_group_count++;
+			continue;
+		} else if (*start == '"') {
+			while (*start && *start != ' ')
+				start++;
+			if (left != EXEC_REALPATH && left != SYMLINK_TARGET)
+				goto out;
+			path_info_count++;
+			continue;
+		}
 		for (right = 0; right < MAX_KEYWORD; right++) {
 			const int len =
 				ccs_condition_control_keyword_len[right];
 			if (strncmp(start, ccs_condition_control_keyword[right],
-				    len))
+				    len) || (!start[len] && start[len] != ' '))
 				continue;
 			start += len;
 			break;
 		}
+		if (debug)
+			printk(KERN_WARNING "%u: start=<%s> right=%u\n",
+			       __LINE__, start, right);
 		if (right < MAX_KEYWORD)
 			continue;
 		if (!ccs_parse_ulong(&right_min, &start))
 			goto out;
-		condc++; /* body */
+		ulong_count++;
 		if (*start != '-')
 			continue;
 		start++;
 		if (!ccs_parse_ulong(&right_max, &start) ||
 		    right_min > right_max)
 			goto out;
-		condc++; /* body */
+		ulong_count++;
 	}
+	if (debug)
+		printk(KERN_DEBUG "%u: cond=%u ul=%u ng=%u pi=%i pg=%u ac=%u "
+		       "ec=%u\n", __LINE__, condc, ulong_count,
+		       number_group_count, path_info_count, path_group_count,
+		       argc, envc);
 	size = sizeof(*entry)
-		+ condc * sizeof(unsigned long)
-		+ exepathc * sizeof(struct ccs_exepath_entry)
+		+ condc * sizeof(struct ccs_condition_element)
+		+ ulong_count * sizeof(unsigned long)
+		+ number_group_count * sizeof(struct ccs_number_group_entry *)
+		+ path_info_count * sizeof(struct ccs_path_info *)
+		+ path_group_count * sizeof(struct ccs_path_group_entry *)
 		+ argc * sizeof(struct ccs_argv_entry)
-		+ envc * sizeof(struct ccs_envp_entry)
-		+ symlinkc * sizeof(struct ccs_symlinkp_entry);
+		+ envc * sizeof(struct ccs_envp_entry);
 	entry = kzalloc(size, GFP_KERNEL);
 	if (!entry)
 		return NULL;
+	atomic_set(&entry->users, 1);
+	INIT_LIST_HEAD(&entry->list);
 	entry->size = size;
 	for (i = 0; i < 4; i++)
 		entry->post_state[i] = post_state[i];
 	entry->condc = condc;
-	entry->exepathc = exepathc;
+	entry->ulong_count = ulong_count;
+	entry->number_group_count = number_group_count;
+	entry->path_info_count = path_info_count;
+	entry->path_group_count = path_group_count;
 	entry->argc = argc;
 	entry->envc = envc;
-	entry->symlinkc = symlinkc;
-	condp = (unsigned long *) (entry + 1);
-	exepathp = (struct ccs_exepath_entry *) (condp + condc);
-	argv = (struct ccs_argv_entry *) (exepathp + exepathc);
+	condp = (struct ccs_condition_element *) (entry + 1);
+	ulong_p = (unsigned long *) (condp + condc);
+	number_group_p = (struct ccs_number_group_entry **)
+		(ulong_p + ulong_count);
+	path_info_p = (const struct ccs_path_info **)
+		(number_group_p + number_group_count);
+	path_group_p = (struct ccs_path_group_entry **)
+		(path_info_p + path_info_count);
+	argv = (struct ccs_argv_entry *) (path_group_p + path_group_count);
 	envp = (struct ccs_envp_entry *) (argv + argc);
-	symlinkp = (struct ccs_symlinkp_entry *) (envp + envc);
 	start = condition;
 	if (!strncmp(start, "if ", 3))
 		start += 3;
 	else if (*start)
 		goto out;
 	while (1) {
+		u8 left = 0;
+		u8 right = 0;
 		u8 match = 0;
 		u8 left_1_type = 0;
 		u8 left_2_type = 0;
 		u8 right_1_type = 0;
 		u8 right_2_type = 0;
+		struct ccs_number_group_entry *number_group = NULL;
+		const struct ccs_path_info *path_info = NULL;
+		struct ccs_path_group_entry *path_group = NULL;
 		while (*start == ' ')
 			start++;
 		if (!*start)
 			break;
+		if (debug)
+			printk(KERN_WARNING "%u: start=<%s>\n", __LINE__,
+			       start);
 		if (!strncmp(start, "exec.argv[", 10)) {
 			char *cp = strchr(start + 10, ' ');
-			if (cp)
-				*cp = '\0';
-			if (!ccs_parse_argv(start, argv))
+			if (!ccs_parse_argv(start + 10, argv))
 				goto out;
 			argv++;
 			argc--;
+			condc--;
 			if (cp)
-				*cp = ' ';
+				start = cp;
 			else
-				break;
-			start = cp;
-			continue;
+				start = "";
+			left = ARGV_ENTRY;
+			goto store_value;
 		} else if (!strncmp(start, "exec.envp[\"", 11)) {
 			char *cp = strchr(start + 11, ' ');
-			if (cp)
-				*cp = '\0';
-			if (!ccs_parse_envp(start, envp))
+			if (!ccs_parse_envp(start + 11, envp))
 				goto out;
 			envp++;
 			envc--;
+			condc--;
 			if (cp)
-				*cp = ' ';
+				start = cp;
 			else
-				break;
-			start = cp;
-			continue;
-		} else if (!strncmp(start, "symlink.target", 14)) {
-			char *cp = strchr(start + 14, ' ');
-			if (cp)
-				*cp = '\0';
-			if (!ccs_parse_symlinkp(start, symlinkp))
-				goto out;
-			symlinkp++;
-			symlinkc--;
-			if (cp)
-				*cp = ' ';
-			else
-				break;
-			start = cp;
-			continue;
-		} else if (!strncmp(start, "exec.realpath", 13)) {
-			char *cp = strchr(start + 13, ' ');
-			if (cp)
-				*cp = '\0';
-			if (!ccs_parse_exepathp(start, exepathp))
-				goto out;
-			exepathp++;
-			exepathc--;
-			if (cp)
-				*cp = ' ';
-			else
-				break;
-			start = cp;
-			continue;
+				start = "";
+			left = ENVP_ENTRY;
+			goto store_value;
 		}
 		for (left = 0; left < MAX_KEYWORD; left++) {
 			const int len =
 				ccs_condition_control_keyword_len[left];
 			if (strncmp(start, ccs_condition_control_keyword[left],
-				    len))
+				    len) ||
+			    (start[len] != '!' && start[len] != '='))
 				continue;
 			start += len;
 			break;
@@ -948,28 +888,59 @@
 		if (left < MAX_KEYWORD)
 			goto check_operator_2;
 		left_1_type = ccs_parse_ulong(&left_min, &start);
-		condc--; /* body */
+		left = CONSTANT_VALUE;
 		if (*start != '-')
 			goto check_operator_2;
 		start++;
 		left_2_type = ccs_parse_ulong(&left_max, &start);
-		condc--; /* body */
-		left++;
+		left = CONSTANT_VALUE_RANGE;
  check_operator_2:
 		if (!strncmp(start, "!=", 2)) {
 			start += 2;
 		} else if (*start == '=') {
-			match |= 1;
+			match = 1;
 			start++;
 		} else {
 			break; /* This shouldn't happen. */
 		}
-		condc--; /* header */
+		condc--;
+		if (*start == '@') {
+			char *cp = strchr(start + 1, ' ');
+			if (cp)
+				*cp = '\0';
+			if (left == EXEC_REALPATH || left == SYMLINK_TARGET) {
+				right = PATH_GROUP;
+				path_group = ccs_get_path_group(start + 1);
+				if (!path_group)
+					goto out;
+			} else {
+				right = NUMBER_GROUP;
+				number_group = ccs_get_number_group(start + 1);
+				if (!number_group)
+					goto out;
+			}
+			if (cp)
+				start = cp + 1;
+			else
+				start = "";
+			goto store_value;
+		} else if (*start == '"') {
+			char *cp = strchr(start + 1, ' ');
+			path_info = ccs_get_dqword(start);
+			if (!path_info)
+				goto out;
+			if (cp)
+				start = cp;
+			else
+				start = "";
+			right = PATH_INFO;
+			goto store_value;
+		}
 		for (right = 0; right < MAX_KEYWORD; right++) {
 			const int len =
 				ccs_condition_control_keyword_len[right];
 			if (strncmp(start, ccs_condition_control_keyword[right],
-				    len))
+				    len) || (!start[len] && start[len] != ' '))
 				continue;
 			start += len;
 			break;
@@ -977,47 +948,63 @@
 		if (right < MAX_KEYWORD)
 			goto store_value;
 		right_1_type = ccs_parse_ulong(&right_min, &start);
-		condc--; /* body */
+		right = CONSTANT_VALUE;
 		if (*start != '-')
 			goto store_value;
 		start++;
 		right_2_type = ccs_parse_ulong(&right_max, &start);
-		condc--; /* body */
-		right++;
+		right = CONSTANT_VALUE_RANGE;
  store_value:
-		*condp = (((u32) match) << 16) |
-			(((u32) left_1_type) << 18) |
-			(((u32) left_2_type) << 20) |
-			(((u32) right_1_type) << 22) |
-			(((u32) right_2_type) << 24) |
-			(((u32) left) << 8) |
-			((u32) right);
+		condp->left = left;
+		condp->right = right;
+		condp->equals = match;
+		condp->type = (left_1_type << 6) | (left_2_type << 4)
+			| (right_1_type << 2) | right_2_type;
+		if (debug)
+			printk(KERN_WARNING "%u: left=%u right=%u match=%u "
+			       "type=%u\n", __LINE__, condp->left,
+			       condp->right, condp->equals, condp->type);
 		condp++;
-		if (left >= MAX_KEYWORD) {
-			*condp = left_min;
-			condp++;
+		if (left_1_type) {
+			*ulong_p++ = left_min;
+			ulong_count--;
 		}
-		if (left == MAX_KEYWORD + 1) {
-			*condp = left_max;
-			condp++;
+		if (left_2_type) {
+			*ulong_p++ = left_max;
+			ulong_count--;
 		}
-		if (right >= MAX_KEYWORD) {
-			*condp = right_min;
-			condp++;
+		if (right_1_type) {
+			*ulong_p++ = right_min;
+			ulong_count--;
 		}
-		if (right == MAX_KEYWORD + 1) {
-			*condp = right_max;
-			condp++;
+		if (right_2_type) {
+			*ulong_p++ = right_max;
+			ulong_count--;
 		}
+		if (number_group) {
+			*number_group_p++ = number_group;
+			number_group_count--;
+		}
+		if (path_info) {
+			*path_info_p++ = path_info;
+			path_info_count--;
+		}
+		if (path_group) {
+			*path_group_p++ = path_group;
+			path_group_count--;
+		}
 	}
-	/*
-	  printk(KERN_DEBUG "argc=%u envc=%u symlinkc=%u condc=%u\n",
-	  argc, envc, symlinkc, condc);
-	*/
-	BUG_ON(exepathc);
+	if (debug)
+		printk(KERN_DEBUG "%u: cond=%u ul=%u ng=%u pi=%i pg=%u ac=%u "
+		       "ec=%u\n", __LINE__, condc, ulong_count,
+		       number_group_count, path_info_count, path_group_count,
+		       argc, envc);
+	BUG_ON(path_group_count);
+	BUG_ON(number_group_count);
+	BUG_ON(path_info_count);
+	BUG_ON(ulong_count);
 	BUG_ON(argc);
 	BUG_ON(envc);
-	BUG_ON(symlinkc);
 	BUG_ON(condc);
 	mutex_lock(&ccs_policy_lock);
 	list_for_each_entry_rcu(ptr, &ccs_condition_list, list) {
@@ -1031,7 +1018,6 @@
 	}
 	if (!found) {
 		if (ccs_memory_ok(entry, size)) {
-			atomic_set(&entry->users, 1);
 			list_add_rcu(&entry->list, &ccs_condition_list);
 		} else {
 			found = true;
@@ -1040,12 +1026,14 @@
 	}
 	mutex_unlock(&ccs_policy_lock);
 	if (found) {
-		kfree(entry);
+		ccs_put_condition(entry);
 		entry = ptr;
 	}
 	return entry;
  out:
-	kfree(entry);
+	if (debug)
+		printk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);
+	ccs_put_condition(entry);
 	return NULL;
 }
 
@@ -1208,45 +1196,76 @@
 	unsigned long left_max = 0;
 	unsigned long right_min = 0;
 	unsigned long right_max = 0;
-	const unsigned long *ptr;
-	const struct ccs_exepath_entry *exepathp;
+	const struct ccs_condition_element *condp;
+	const unsigned long *ulong_p;
+	const struct ccs_number_group_entry **number_group_p;
+	const struct ccs_path_info **path_info_p;
+	const struct ccs_path_group_entry **path_group_p;
 	const struct ccs_argv_entry *argv;
 	const struct ccs_envp_entry *envp;
-	const struct ccs_symlinkp_entry *symlinkp;
 	struct ccs_obj_info *obj;
 	u16 condc;
-	u16 exepathc;
 	u16 argc;
 	u16 envc;
-	u16 symlinkc;
 	struct linux_binprm *bprm = NULL;
 	const struct ccs_condition *cond = acl->cond;
 	if (!cond)
 		return true;
 	condc = cond->condc;
-	exepathc = cond->exepathc;
 	argc = cond->argc;
 	envc = cond->envc;
-	symlinkc = cond->symlinkc;
 	obj = r->obj;
 	if (r->ee)
 		bprm = r->ee->bprm;
 	if (!bprm && (argc || envc))
 		return false;
-	ptr = (unsigned long *) (cond + 1);
-	exepathp = (const struct ccs_exepath_entry *) (ptr + condc);
-	argv = (const struct ccs_argv_entry *) (exepathp + exepathc);
+	condp = (struct ccs_condition_element *) (cond + 1);
+	ulong_p = (const unsigned long *) (condp + condc);
+	number_group_p = (const struct ccs_number_group_entry **)
+		(ulong_p + cond->number_group_count);
+	path_info_p = (const struct ccs_path_info **)
+		(number_group_p + cond->number_group_count);
+	path_group_p = (const struct ccs_path_group_entry **)
+		(path_info_p + cond->path_info_count);
+	argv = (const struct ccs_argv_entry *)
+		(path_group_p + cond->path_group_count);
 	envp = (const struct ccs_envp_entry *) (argv + argc);
-	symlinkp = (const struct ccs_symlinkp_entry *) (envp + envc); 
 	for (i = 0; i < condc; i++) {
-		const u32 header = *ptr;
-		const bool match = (header >> 16) & 1;
-		const u8 left = header >> 8;
-		const u8 right = header;
+		const bool match = condp->equals;
+		const u8 left = condp->left;
+		const u8 right = condp->right;
 		bool left_is_bitop = false;
 		bool right_is_bitop = false;
 		u8 j;
-		ptr++;
+		condp++;
+		/* Check argv[] and envp[] later. */
+		if (left == ARGV_ENTRY || left == ENVP_ENTRY)
+			continue;
+		if (right == PATH_INFO || right == PATH_GROUP) {
+			if (left == SYMLINK_TARGET) {
+				//ccs_path_matches_pattern(obj->symlink_target,
+				//		 path_info);
+				continue;
+			}
+			if (left == EXEC_REALPATH) {
+				struct file *file = r->ee->bprm->file;
+				struct ccs_path_info path;
+				if (!file)
+					return false;
+				path.name = ccs_realpath_from_dentry(file->f_dentry, file->f_vfsmnt);
+				if (!path.name)
+					return false;
+				ccs_fill_path_info(&path);
+				//ccs_path_matches_pattern(&path,
+				//exepathp->value);
+				kfree(path.name);
+				continue;
+			}
+			continue;
+		}
+		//if (right == NUMBER_GROUP) {
+		//continue;
+		//}
 		for (j = 0; j < 2; j++) {
 			const u8 index = j ? right : left;
 			unsigned long min_v = 0;
@@ -1380,16 +1399,13 @@
 			case TASK_EXECUTE_HANDLER:
 				max_v = CCS_TASK_IS_EXECUTE_HANDLER;
 				break;
-			case MAX_KEYWORD:
-				max_v = *ptr;
-				ptr++;
+			case CONSTANT_VALUE:
+				max_v = *ulong_p++;
 				i++;
 				break;
-			case MAX_KEYWORD + 1:
-				min_v = *ptr;
-				ptr++;
-				max_v = *ptr;
-				ptr++;
+			case CONSTANT_VALUE_RANGE:
+				min_v = *ulong_p++;
+				max_v = *ulong_p++;
 				i += 2;
 				break;
 			default:
@@ -1491,7 +1507,7 @@
 				}
 				break;
 			}
-			if (index != MAX_KEYWORD + 1)
+			if (index != CONSTANT_VALUE_RANGE)
 				min_v = max_v;
 			if (j) {
 				right_max = max_v;
@@ -1546,15 +1562,6 @@
  out:
 		return false;
 	}
-	if (symlinkc) {
-		if (!obj || !ccs_scan_symlink(obj->symlink_target,
-					      symlinkc, symlinkp))
-			return false;
-	}
-	if (r->ee && exepathc) {
-		if (!ccs_scan_exepath(r->ee->bprm->file, exepathc, exepathp))
-			return false;
-	}
 	if (r->ee && (argc || envc))
 		return ccs_scan_bprm(r->ee, argc, argv, envc, envp);
 	return true;
@@ -1571,42 +1578,41 @@
 bool ccs_print_condition(struct ccs_io_buffer *head,
 			 const struct ccs_condition *cond)
 {
-	const unsigned long *ptr;
-	const struct ccs_exepath_entry *exepathp;
+	const struct ccs_condition_element *condp;
+	const unsigned long *ulong_p;
+	const struct ccs_number_group_entry **number_group_p;
+	const struct ccs_path_info **path_info_p;
+	const struct ccs_path_group_entry **path_group_p;
 	const struct ccs_argv_entry *argv;
 	const struct ccs_envp_entry *envp;
-	const struct ccs_symlinkp_entry *symlinkp;
 	u16 condc;
-	u16 exepathc;
-	u16 argc;
-	u16 envc;
-	u16 symlinkc;
 	u16 i;
 	u16 j;
 	char buffer[32];
 	if (!cond)
 		goto no_condition;
 	condc = cond->condc;
-	exepathc = cond->exepathc;
-	argc = cond->argc;
-	envc = cond->envc;
-	symlinkc = cond->symlinkc;
-	ptr = (const unsigned long *) (cond + 1);
-	exepathp = (const struct ccs_exepath_entry *) (ptr + condc);
-	argv = (const struct ccs_argv_entry *) (exepathp + exepathc);
-	envp = (const struct ccs_envp_entry *) (argv + argc);
-	symlinkp = (const struct ccs_symlinkp_entry *) (envp + envc);
+	condp = (const struct ccs_condition_element *) (cond + 1);
+	ulong_p = (const unsigned long *) (condp + condc);
+	number_group_p = (const struct ccs_number_group_entry **)
+		(ulong_p + cond->ulong_count);
+	path_info_p = (const struct ccs_path_info **)
+		(number_group_p + cond->number_group_count);
+	path_group_p = (const struct ccs_path_group_entry **)
+		(path_info_p + cond->path_info_count);
+	argv = (const struct ccs_argv_entry *)
+		(path_group_p + cond->path_group_count);
+	envp = (const struct ccs_envp_entry *) (argv + cond->argc);
 	memset(buffer, 0, sizeof(buffer));
 	for (i = 0; i < condc; i++) {
-		const u32 header = *ptr;
-		const u8 match = (header >> 16) & 1;
-		const u8 left_1_type = (header >> 18) & 3;
-		const u8 left_2_type = (header >> 20) & 3;
-		const u8 right_1_type = (header >> 22) & 3;
-		const u8 right_2_type = (header >> 24) & 3;
-		const u8 left = header >> 8;
-		const u8 right = header;
-		ptr++;
+		const u8 match = condp->equals;
+		const u8 left_1_type = condp->type >> 6;
+		const u8 left_2_type = (condp->type >> 4) & 3;
+		const u8 right_1_type = (condp->type >> 2) & 3;
+		const u8 right_2_type = condp->type & 3;
+		const u8 left = condp->left;
+		const u8 right = condp->right;
+		condp++;
 		if (!ccs_io_printf(head, "%s", i ? " " : " if "))
 			goto out;
 		if (left < MAX_KEYWORD) {
@@ -1616,18 +1622,40 @@
 				goto out;
 			goto print_operator;
 		}
-		ccs_print_ulong(buffer, sizeof(buffer) - 1, *ptr, left_1_type);
-		ptr++;
+		if (left == ARGV_ENTRY) {
+			if (!ccs_io_printf(head, "exec.argv[%u]%s\"%s\"",
+					   argv->index, argv->is_not ?
+					   "!=" : "=", argv->value->name))
+				goto out;
+			argv++;
+			continue;
+		}
+		if (left == ENVP_ENTRY) {
+			if (!ccs_io_printf(head, "exec.envp[\"%s\"]%s",
+					   envp->name->name, envp->is_not ?
+					   "!=" : "="))
+				goto out;
+			if (envp->value) {
+				if (!ccs_io_printf(head, "\"%s\"",
+						   envp->value->name))
+					goto out;
+			} else {
+				if (!ccs_io_printf(head, "NULL"))
+					goto out;
+			}
+			envp++;
+			continue;
+		}
+		ccs_print_ulong(buffer, sizeof(buffer) - 1,
+				*ulong_p++, left_1_type);
 		if (!ccs_io_printf(head, "%s", buffer))
 			goto out;
-		i++;
-		if (left == MAX_KEYWORD)
+		if (left != CONSTANT_VALUE_RANGE)
 			goto print_operator;
-		ccs_print_ulong(buffer, sizeof(buffer) - 1, *ptr, left_2_type);
-		ptr++;
+		ccs_print_ulong(buffer, sizeof(buffer) - 1,
+				*ulong_p++, left_2_type);
 		if (!ccs_io_printf(head, "-%s", buffer))
 			goto out;
-		i++;
  print_operator:
 		if (!ccs_io_printf(head, "%s", match ? "=" : "!="))
 			goto out;
@@ -1638,58 +1666,37 @@
 				goto out;
 			continue;
 		}
-		ccs_print_ulong(buffer, sizeof(buffer) - 1, *ptr, right_1_type);
-		ptr++;
+		switch (right) {
+		case PATH_INFO:
+			if (!ccs_io_printf(head, "\"%s\"",
+					   (*path_info_p)->name))
+				goto out;
+			path_info_p++;
+			continue;
+		case PATH_GROUP:
+			if (!ccs_io_printf(head, "@%s", (*path_group_p)->
+					   group_name->name))
+				goto out;
+			path_group_p++;
+			continue;
+		case NUMBER_GROUP:
+			if (!ccs_io_printf(head, "@%s", (*number_group_p)->
+					   group_name->name))
+				goto out;
+			number_group_p++;
+			continue;
+		}
+		ccs_print_ulong(buffer, sizeof(buffer) - 1,
+				*ulong_p++, right_1_type);
 		if (!ccs_io_printf(head, "%s", buffer))
 			goto out;
-		i++;
-		if (right == MAX_KEYWORD)
+		if (right != CONSTANT_VALUE_RANGE)
 			continue;
-		ccs_print_ulong(buffer, sizeof(buffer) - 1, *ptr, right_2_type);
-		ptr++;
+		ccs_print_ulong(buffer, sizeof(buffer) - 1,
+				*ulong_p++, right_2_type);
 		if (!ccs_io_printf(head, "-%s", buffer))
 			goto out;
-		i++;
 	}
-
-	if (!exepathc && !argc && !envc && !symlinkc)
-		goto post_condition;
-	if (!condc && !ccs_io_printf(head, " if"))
-		goto out;
-	for (i = 0; i < exepathc; exepathp++, i++) {
-		const char *op = exepathp->is_not ? "!=" : "=";
-		if (!ccs_io_printf(head, " exec.realpath%s\"%s\"",
-				   op, exepathp->value->name))
-			goto out;
-	}
-	for (i = 0; i < argc; argv++, i++) {
-		const char *op = argv->is_not ? "!=" : "=";
-		if (!ccs_io_printf(head, " exec.argv[%u]%s\"%s\"", argv->index,
-				   op, argv->value->name))
-			goto out;
-	}
-	/* buffer[1] = '\0'; */
-	for (i = 0; i < envc; envp++, i++) {
-		const char *op = envp->is_not ? "!=" : "=";
-		const char *value = envp->value ? envp->value->name : NULL;
-		if (!ccs_io_printf(head, " exec.envp[\"%s\"]%s",
-				   envp->name->name, op))
-			goto out;
-		if (value) {
-			if (!ccs_io_printf(head, "\"%s\"", value))
-				goto out;
-		} else {
-			if (!ccs_io_printf(head, "NULL"))
-				goto out;
-		}
-	}
-	for (i = 0; i < symlinkc; symlinkp++, i++) {
-		const char *op = symlinkp->is_not ? "!=" : "=";
-		if (!ccs_io_printf(head, " symlink.target%s\"%s\"", op,
-				   symlinkp->value->name))
-			goto out;
-	}
- post_condition:
 	i = cond->post_state[3];
 	if (!i)
 		goto no_condition;
@@ -1722,3 +1729,196 @@
 		return NULL;
 	return ccs_get_condition(str);
 }
+
+/* The list for "struct ccs_number_group_entry". */
+LIST_HEAD(ccs_number_group_list);
+
+/**
+ * ccs_get_number_group - Allocate memory for "struct ccs_number_group_entry".
+ *
+ * @group_name: The name of number group.
+ *
+ * Returns pointer to "struct ccs_number_group_entry" on success,
+ * NULL otherwise.
+ */
+struct ccs_number_group_entry *ccs_get_number_group(const char *group_name)
+{
+	struct ccs_number_group_entry *entry = NULL;
+	struct ccs_number_group_entry *group;
+	const struct ccs_path_info *saved_group_name;
+	int error = -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
+	    !group_name[0])
+		return NULL;
+	saved_group_name = ccs_get_name(group_name);
+	if (!saved_group_name)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(group, &ccs_number_group_list, list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		atomic_inc(&group->users);
+		error = 0;
+		break;
+	}
+	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
+		INIT_LIST_HEAD(&entry->number_group_member_list);
+		entry->group_name = saved_group_name;
+		saved_group_name = NULL;
+		atomic_set(&entry->users, 1);
+		list_add_tail_rcu(&entry->list, &ccs_number_group_list);
+		group = entry;
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name(saved_group_name);
+	kfree(entry);
+	return !error ? group : NULL;
+}
+
+/**
+ * ccs_update_number_group_entry - Update "struct ccs_number_group_entry" list.
+ *
+ * @group_name: The name of pathname group.
+ * @min:        Min value.
+ * @max:        Max value.
+ * @is_delete:  True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_number_group_entry(const char *group_name,
+					 unsigned long min, unsigned long max,
+					 const bool is_delete)
+{
+	struct ccs_number_group_entry *group;
+	struct ccs_number_group_member *entry = NULL;
+	struct ccs_number_group_member *member;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (min > max)
+		return -EINVAL;
+	group = ccs_get_number_group(group_name);
+	if (!group)
+		return -ENOMEM;
+	if (!is_delete)
+		entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(member, &group->number_group_member_list,
+				list) {
+		if (member->min != min || member->max != max)
+			continue;
+		member->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_memory_ok(entry, sizeof(*entry))) {
+		entry->min = min;
+		entry->max = max;
+		list_add_tail_rcu(&entry->list,
+				  &group->number_group_member_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_number_group(group);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_number_group_policy - Write "struct ccs_number_group_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, nagative value otherwise.
+ */
+int ccs_write_number_group_policy(char *data, const bool is_delete)
+{
+	char *w[2];
+	unsigned long min;
+	unsigned long max;
+	if (!ccs_tokenize(data, w, sizeof(w)))
+		return -EINVAL;
+	switch(sscanf(w[1], "%lu-%lu", &min, &max)) {
+	case 1:
+		max = min;
+		break;
+	case 2:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return ccs_update_number_group_entry(w[0], min, max, is_delete);
+}
+
+/**
+ * ccs_read_number_group_policy - Read "struct ccs_number_group_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds srcu_read_lock(&ccs_ss).
+ */
+bool ccs_read_number_group_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *gpos;
+	struct list_head *mpos;
+	bool done = true;
+	list_for_each_cookie(gpos, head->read_var1, &ccs_number_group_list) {
+		struct ccs_number_group_entry *group;
+		const char *name;
+		group = list_entry(gpos, struct ccs_number_group_entry, list);
+		name = group->group_name->name;
+		list_for_each_cookie(mpos, head->read_var2,
+				     &group->number_group_member_list) {
+			const struct ccs_number_group_member *member
+				= list_entry(mpos,
+					     struct ccs_number_group_member,
+					     list);
+			const unsigned long min = member->min;
+			const unsigned long max = member->max;
+			if (member->is_deleted)
+				continue;
+			if (min == max)
+				done = ccs_io_printf(head, KEYWORD_NUMBER_GROUP
+						     "%s %lu\n", name, min);
+			else
+				done = ccs_io_printf(head, KEYWORD_NUMBER_GROUP
+						     "%s %lu-%lu\n", name,
+						     min, max);
+			if (!done)
+				break;
+		}
+	}
+	return done;
+}
+
+/**
+ * ccs_number_matches_group - Check whether the given number matches members of the given number group.
+ *
+ * @number: The number to check.
+ * @group:  Pointer to "struct ccs_number_group_entry".
+ *
+ * Returns true if @number matches numbers in @group, false otherwise.
+ *
+ * Caller holds srcu_read_lock(&ccs_ss).
+ */
+static bool ccs_number_matches_group(const unsigned long number,
+				     const struct ccs_number_group_entry *group)
+{
+	struct ccs_number_group_member *member;
+	bool matched = false;
+	list_for_each_entry_rcu(member, &group->number_group_member_list,
+				list) {
+		if (member->is_deleted)
+			continue;
+		if (number < member->min || number > member->max)
+			continue;
+		matched = true;
+		break;
+	}
+	return matched;
+}
