Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(revision 2335)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(working copy)
@@ -296,6 +296,9 @@
 struct task_entry {
 	pid_t pid;
 	pid_t ppid;
+	char *name;
+	char *domain;
+	u8 profile;
 	_Bool done;
 };
 
@@ -342,6 +345,7 @@
 _Bool move_proc_to_file(const char *src, const char *base, const char *dest);
 _Bool is_identical_file(const char *file1, const char *file2);
 FILE *open_read(const char *filename);
+FILE *open_write(const char *filename);
 void clear_domain_policy(struct domain_policy *dp);
 _Bool save_domain_policy_with_diff(struct domain_policy *dp,
 				   struct domain_policy *bp,
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/loadpolicy.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/loadpolicy.c	(revision 2335)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/loadpolicy.c	(working copy)
@@ -299,34 +299,6 @@
 
 /***** loadpolicy start *****/
 
-static FILE *open_write(const char *filename)
-{
-	if (network_mode) {
-		const int fd = socket(AF_INET, SOCK_STREAM, 0);
-		struct sockaddr_in addr;
-		FILE *fp;
-		memset(&addr, 0, sizeof(addr));
-		addr.sin_family = AF_INET;
-		addr.sin_addr.s_addr = network_ip;
-		addr.sin_port = network_port;
-		if (connect(fd, (struct sockaddr *) &addr, sizeof(addr))) {
-			close(fd);
-			return NULL;
-		}
-		fp = fdopen(fd, "r+");
-		fprintf(fp, "%s", filename);
-		fputc(0, fp);
-		fflush(fp);
-		if (fgetc(fp) != 0) {
-			fclose(fp);
-			return NULL;
-		}
-		return fp;
-	} else {
-		return fopen(filename, "w+");
-	}
-}
-
 static void move_file_to_proc(const char *base, const char *src,
 			      const char *dest)
 {
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(revision 2335)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(working copy)
@@ -31,7 +31,6 @@
 is_domain_keeper(const struct path_info *domainname, const char *program);
 static const struct domain_initializer_entry *
 is_domain_initializer(const struct path_info *domainname, const char *program);
-static FILE *open_write(const char *filename);
 static int generic_acl_compare(const void *a, const void *b);
 static int generic_acl_compare0(const void *a, const void *b);
 static int string_acl_compare(const void *a, const void *b);
@@ -753,7 +752,7 @@
 	return flag;
 }
 
-static FILE *open_write(const char *filename)
+FILE *open_write(const char *filename)
 {
 	if (network_mode) {
 		const int fd = socket(AF_INET, SOCK_STREAM, 0);
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstree.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstree.c	(revision 2335)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstree.c	(working copy)
@@ -57,26 +57,6 @@
 	return NULL;
 }
 
-static int status_fd = EOF;
-
-static const char *read_info(const pid_t pid, int *profile)
-{
-	char *cp; /* caller must use get()/put(). */
-	shprintf("%d\n", pid);
-	write(status_fd, shared_buffer, strlen(shared_buffer));
-	memset(shared_buffer, 0, sizeof(shared_buffer));
-	read(status_fd, shared_buffer, sizeof(shared_buffer) - 1);
-	cp = strchr(shared_buffer, ' ');
-	if (cp) {
-		*profile = atoi(cp + 1);
-		cp = strchr(cp + 1, ' ');
-		if (cp)
-			return cp + 1;
-	}
-	*profile = -1;
-	return "<UNKNOWN>";
-}
-
 static struct task_entry *task_list = NULL;
 static int task_list_len = 0;
 
@@ -84,23 +64,16 @@
 {
 	int i;
 	for (i = 0; i < task_list_len; i++) {
-		const char *info;
-		char *name;
 		int j;
-		int profile;
 		if (pid != task_list[i].pid)
 			continue;
-		name = get_name(pid);
-		get();
-		info = read_info(pid, &profile);
-		printf("%3d", profile);
+		printf("%3d", task_list[i].profile);
 		for (j = 0; j < depth - 1; j++)
 			printf("    ");
 		for (; j < depth; j++)
 			printf("  +-");
-		printf(" %s (%u) %s\n", name, pid, info);
-		put();
-		free(name);
+		printf(" %s (%u) %s\n", task_list[i].name, task_list[i].pid,
+		       task_list[i].domain);
 		task_list[i].done = true;
 	}
 	for (i = 0; i < task_list_len; i++) {
@@ -114,18 +87,11 @@
 {
 	int i;
 	for (i = 0; i < task_list_len; i++) {
-		const char *info;
-		char *name;
-		int profile;
-		const pid_t pid = task_list[i].pid;
 		if (task_list[i].done)
 			continue;
-		name = get_name(task_list[i].pid);
-		get();
-		info = read_info(pid, &profile);
-		printf("%3d %s (%u) %s\n", profile, name, pid, info);
-		put();
-		free(name);
+		printf("%3d %s (%u) %s\n", task_list[i].profile,
+		       task_list[i].name, task_list[i].pid,
+		       task_list[i].domain);
 		task_list[i].done = true;
 	}
 }
@@ -134,30 +100,85 @@
 {
 	const char *policy_file = proc_policy_process_status;
 	static _Bool show_all = false;
-	if (access(proc_policy_dir, F_OK)) {
-		fprintf(stderr, "You can't use this command "
-			"for this kernel.\n");
-		return 1;
-	}
 	if (argc > 1) {
-		if (!strcmp(argv[1], "-a")) {
+		char *ptr = argv[1];
+		char *cp = strchr(ptr, ':');
+		if (cp) {
+			*cp++ = '\0';
+			network_ip = inet_addr(ptr);
+			network_port = htons(atoi(cp));
+			network_mode = true;
+		} else if (!strcmp(ptr, "-a")) {
 			show_all = true;
 		} else {
-			fprintf(stderr, "Usage: %s [-a]\n", argv[0]);
+			fprintf(stderr, "Usage: %s "
+				"[{-a|remote_ip:remote_port}]}\n", argv[0]);
 			return 0;
 		}
 	}
-	status_fd = open(policy_file, O_RDWR);
-	if (status_fd == EOF) {
-		fprintf(stderr, "Can't open %s\n", policy_file);
-		return 1;
-	}
-	{
+	if (network_mode) {
+		FILE *fp = open_read("ccstree");
+		if (!fp) {
+			fprintf(stderr, "Can't connect.\n");
+			return 1;
+		}
+		get();
+		while (freadline(fp)) {
+			unsigned int pid = 0;
+			unsigned int ppid = 0;
+			int profile = -1;
+			char *name;
+			char *domain;
+			sscanf(shared_buffer, "PID=%u PPID=%u", &pid, &ppid);
+			name = strstr(shared_buffer, "NAME=");
+			if (name)
+				name = strdup(name + 5);
+			if (!name)
+				name = "<UNKNOWN>";
+			if (!freadline(fp))
+				break;
+			sscanf(shared_buffer, "%u %u", &pid, &profile);
+			domain = strchr(shared_buffer, '<');
+			if (domain)
+				domain = strdup(domain);
+			if (!domain)
+				domain = "<UNKNOWN>";
+			task_list = realloc(task_list,
+					    (task_list_len + 1) *
+					    sizeof(struct task_entry));
+			if (!task_list)
+				out_of_memory();
+			task_list[task_list_len].pid = pid;
+			task_list[task_list_len].ppid = ppid;
+			task_list[task_list_len].profile = profile;
+			task_list[task_list_len].name = name;
+			task_list[task_list_len].domain = domain;
+			task_list[task_list_len].done = false;
+			task_list_len++;
+		}
+		put();
+		fclose(fp);
+	} else {
 		struct dirent **namelist;
 		int i;
-		int n = scandir("/proc/", &namelist, 0, 0);
+		int n;
+		int status_fd;
+		if (access(proc_policy_dir, F_OK)) {
+			fprintf(stderr, "You can't use this command "
+				"for this kernel.\n");
+			return 1;
+		}
+		status_fd = open(policy_file, O_RDWR);
+		if (status_fd == EOF) {
+			fprintf(stderr, "Can't open %s\n", policy_file);
+			return 1;
+		}
+		n = scandir("/proc/", &namelist, 0, 0);
 		for (i = 0; i < n; i++) {
-			pid_t pid;
+			char *name;
+			char *domain;
+			int profile = -1;
+			unsigned int pid = 0;
 			char buffer[128];
 			char test[16];
 			if (sscanf(namelist[i]->d_name, "%u", &pid) != 1)
@@ -165,26 +186,44 @@
 			memset(buffer, 0, sizeof(buffer));
 			snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/exe",
 				 pid);
-			if (show_all ||
-			    readlink(buffer, test, sizeof(test)) > 0) {
-				task_list = realloc(task_list,
-						    (task_list_len + 1) *
-						    sizeof(struct task_entry));
-				if (!task_list)
-					out_of_memory();
-				task_list[task_list_len].pid = pid;
-				task_list[task_list_len].ppid = get_ppid(pid);
-				task_list[task_list_len].done = false;
-				task_list_len++;
-			}
+			if (!show_all &&
+			    readlink(buffer, test, sizeof(test)) <= 0)
+				goto skip;
+			name = get_name(pid);
+			if (!name)
+				name = "<UNKNOWN>";
+			snprintf(buffer, sizeof(buffer) - 1, "%u\n", pid);
+			write(status_fd, buffer, strlen(buffer));
+			get();
+			memset(shared_buffer, 0, sizeof(shared_buffer));
+			read(status_fd, shared_buffer,
+			     sizeof(shared_buffer) - 1);
+			sscanf(shared_buffer, "%u %u", &pid, &profile);
+			domain = strchr(shared_buffer, '<');
+			if (domain)
+				domain = strdup(domain);
+			if (!domain)
+				domain = "<UNKNOWN>";
+			put();
+			task_list = realloc(task_list, (task_list_len + 1) *
+					    sizeof(struct task_entry));
+			if (!task_list)
+				out_of_memory();
+			task_list[task_list_len].pid = pid;
+			task_list[task_list_len].ppid = get_ppid(pid);
+			task_list[task_list_len].profile = profile;
+			task_list[task_list_len].name = name;
+			task_list[task_list_len].domain = domain;
+			task_list[task_list_len].done = false;
+			task_list_len++;
 skip:
 			free((void *) namelist[i]);
 		}
 		if (n >= 0)
 			free((void *) namelist);
+		close(status_fd);
 	}
 	dump(1, 0);
 	dump_unprocessed();
-	close(status_fd);
 	return 0;
 }
Index: trunk/1.6.x/ccs-tools/ccstools/ccs-editpolicy-agent.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccs-editpolicy-agent.c	(revision 2335)
+++ trunk/1.6.x/ccs-tools/ccstools/ccs-editpolicy-agent.c	(working copy)
@@ -9,58 +9,139 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <signal.h>
+#include <dirent.h>
 
+static void show_tasklist(const int fd)
+{
+	int status_fd = open(".process_status", O_RDWR);
+	DIR *dir = opendir("/proc/");
+	if (!dir)
+		return;
+	write(fd, "", 1);
+	while (1) {
+		FILE *fp;
+		pid_t ppid = 1;
+		char *name = NULL;
+		char buffer[1024];
+		unsigned int pid;
+		struct dirent *dent = readdir(dir);
+		const char *cp;
+		if (!dent)
+			break;
+		cp = dent->d_name;
+		if (dent->d_type != DT_DIR || sscanf(cp, "%u", &pid) != 1)
+			continue;
+		memset(buffer, 0, sizeof(buffer));
+		snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
+		fp = fopen(buffer, "r");
+		if (fp) {
+			while (memset(buffer, 0, sizeof(buffer)),
+			       fgets(buffer, sizeof(buffer) - 1, fp)) {
+				if (!strncmp(buffer, "Name:", 5)) {
+					char *cp = buffer + 5;
+					while (*cp == ' ' || *cp == '\t')
+						cp++;
+					memmove(buffer, cp, strlen(cp) + 1);
+					cp = strchr(buffer, '\n');
+					if (cp)
+						*cp = '\0';
+					name = strdup(buffer);
+				}
+				if (sscanf(buffer, "PPid: %u", &ppid) == 1)
+					break;
+			}
+			fclose(fp);
+		}
+		snprintf(buffer, sizeof(buffer) - 1, "PID=%u PPID=%u NAME=",
+			 pid, ppid);
+		write(fd, buffer, strlen(buffer));
+		if (name) {
+			write(fd, name, strlen(name));
+			free(name);
+		} else {
+			write(fd, "<UNKNOWN>", 9);
+		}
+		write(fd, "\n", 1);
+		snprintf(buffer, sizeof(buffer) - 1, "%u\n", pid);
+		write(status_fd, buffer, strlen(buffer));
+		memset(buffer, 0, sizeof(buffer));
+		while (1) {
+			int len = read(status_fd, buffer, sizeof(buffer));
+			if (len <= 0)
+				break;
+			write(fd, buffer, len);
+		}
+		write(fd, "\n", 1);
+	}
+	write(fd, "", 1);
+	closedir(dir);
+	close(status_fd);
+}
+
 static void do_child(const int client)
 {
 	int i;
 	int fd = EOF;
 	char buffer[1024];
-	while (1) {
-		/* Read filename. */
-		for (i = 0; i < sizeof(buffer) - 1; i++) {
-			if (read(client, buffer + i, 1) != 1)
-				goto out;
-			if (!buffer[i]) {
-				char *cp = strrchr(buffer, '/');
-				if (!cp)
-					cp = buffer;
-				else
-					cp++;
+	/* Read filename. */
+	for (i = 0; i < sizeof(buffer) - 1; i++) {
+		if (read(client, buffer + i, 1) != 1)
+			goto out;
+		if (!buffer[i]) {
+			unsigned int pid;
+			char *cp = strrchr(buffer, '/');
+			if (!strcmp(buffer, "ccstree")) {
+				char c;
+				/* Open /proc/\$/ for reading. */
+				show_tasklist(client);
+				read(client, &c, 1); /* Wait. */
+				break;
+			}
+			if (!cp)
+				cp = buffer;
+			else
+				cp++;
+			if (sscanf(buffer, "/proc/%u/status", &pid) == 1) {
+				/* Open /proc/\$/status for reading. */
+				snprintf(buffer, sizeof(buffer) - 1,
+					 "/proc/%u/status", pid);
+				fd = open(buffer, O_RDONLY);
+			} else {
 				/* Open for read/write. */
 				fd = open(cp, O_RDWR);
-				break;
 			}
+			break;
 		}
-		if (fd == EOF) 
+	}
+	if (fd == EOF) 
+		goto out;
+	/* Return \0 to indicate success. */
+	if (write(client, "", 1) != 1)
+		goto out;
+	while (1) {
+		char c;
+		/* Read a byte. */
+		if (read(client, &c, 1) != 1)
 			goto out;
-		/* Return \0 to indicate success. */
-		if (write(client, "", 1) != 1)
-			goto out;
+		if (c) {
+			/* Write that byte. */
+			if (write(fd, &c, 1) != 1)
+				goto out;
+			continue;
+		}
+		/* Read until EOF. */
 		while (1) {
-			char c;
-			/* Read a byte. */
-			if (read(client, &c, 1) != 1)
+			int len = read(fd, buffer, sizeof(buffer));
+			if (len == 0)
+				break;
+			/* Don't send \0 because it is EOF marker. */
+			if (len < 0 || memchr(buffer, '\0', len) ||
+			    write(client, buffer, len) != len)
 				goto out;
-			if (c) {
-				/* Write that byte. */
-				if (write(fd, &c, 1) != 1)
-					goto out;
-				continue;
-			}
-			/* Read until EOF. */
-			while (1) {
-				int len = read(fd, buffer, sizeof(buffer));
-				if (len == 0)
-					break;
-				/* Don't send \0 because it is EOF marker. */
-				if (len < 0 || memchr(buffer, '\0', len) ||
-				    write(client, buffer, len) != len)
-					goto out;
-			}
-			/* Return \0 to indicate EOF. */
-			if (write(client, "", 1) != 1)
-				goto out;
 		}
+		/* Return \0 to indicate EOF. */
+		if (write(client, "", 1) != 1)
+			goto out;
 	}
  out:
 	close(fd);
