Index: address_group.c
===================================================================
--- address_group.c	(revision 3685)
+++ address_group.c	(working copy)
@@ -13,54 +13,16 @@
 #include <linux/slab.h>
 #include "internal.h"
 
-/* The list for "struct ccs_address_group". */
-LIST_HEAD(ccs_address_group_list);
-
-/**
- * ccs_get_address_group - Allocate memory for "struct ccs_address_group".
- *
- * @group_name: The name of address group.
- *
- * Returns pointer to "struct ccs_address_group" on success,
- * NULL otherwise.
- */
-struct ccs_address_group *ccs_get_address_group(const char *group_name)
+static bool ccs_is_same_address_group(const struct ccs_acl_head *a,
+				      const struct ccs_acl_head *b)
 {
-	struct ccs_address_group *entry = NULL;
-	struct ccs_address_group *group = NULL;
-	const struct ccs_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
-	    !group_name[0])
-		return NULL;
-	saved_group_name = ccs_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(group, &ccs_address_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &ccs_address_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
+	const struct ccs_address_group *p1 = container_of(a, typeof(*p1),
+							  head);
+	const struct ccs_address_group *p2 = container_of(b, typeof(*p2),
+							  head);
+	return p1->is_ipv6 == p2->is_ipv6 &&
+		p1->min.ipv4 == p2->min.ipv4 && p1->min.ipv6 == p2->min.ipv6 &&
+		p1->max.ipv4 == p2->max.ipv4 && p1->max.ipv6 == p2->max.ipv6;
 }
 
 /**
@@ -73,10 +35,9 @@
  */
 int ccs_write_address_group_policy(char *data, const bool is_delete)
 {
-	struct ccs_address_group *group;
-	struct ccs_address_group_member *member;
-	struct ccs_address_group_member e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct ccs_group *group;
+	struct ccs_address_group e = { };
+	int error = -ENOMEM;
 	u16 min_address[8];
 	u16 max_address[8];
 	char *w[2];
@@ -86,7 +47,7 @@
 	if (!group)
 		return -ENOMEM;
 	switch (ccs_parse_ip_address(w[1], min_address, max_address)) {
-	case 2:
+	case CCS_IP_ADDRESS_TYPE_IPv6:
 		e.is_ipv6 = true;
 		e.min.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
 						  min_address);
@@ -95,103 +56,25 @@
 		if (!e.min.ipv6 || !e.max.ipv6)
 			goto out;
 		break;
-	case 1:
+	case CCS_IP_ADDRESS_TYPE_IPv4:
 		e.min.ipv4 = ntohl(*(u32 *) min_address);
 		e.max.ipv4 = ntohl(*(u32 *) max_address);
 		break;
 	default:
 		goto out;
 	}
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (!ccs_is_same_address_group_member(member, &e))
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_address_group_member *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list, &group->member_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
+	error = ccs_update_group(&e.head, sizeof(e), is_delete, group,
+				 ccs_is_same_address_group);
  out:
 	if (e.is_ipv6) {
 		ccs_put_ipv6_address(e.min.ipv6);
 		ccs_put_ipv6_address(e.max.ipv6);
 	}
-	ccs_put_address_group(group);
+	ccs_put_group(group);
 	return error;
 }
 
 /**
- * ccs_read_address_group_policy - Read "struct ccs_address_group" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_address_group_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &ccs_address_group_list) {
-		struct ccs_address_group *group;
-		group = list_entry(gpos, struct ccs_address_group, list);
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			char buf[128];
-			struct ccs_address_group_member *member;
-			member = list_entry(mpos,
-					    struct ccs_address_group_member,
-					    list);
-			if (member->is_deleted)
-				continue;
-			if (member->is_ipv6) {
-				const struct in6_addr *min_address
-					= member->min.ipv6;
-				const struct in6_addr *max_address
-					= member->max.ipv6;
-				ccs_print_ipv6(buf, sizeof(buf), min_address);
-				if (min_address != max_address) {
-					int len;
-					char *cp = buf + strlen(buf);
-					*cp++ = '-';
-					len = strlen(buf);
-					ccs_print_ipv6(cp, sizeof(buf) - len,
-						       max_address);
-				}
-			} else {
-				const u32 min_address = member->min.ipv4;
-				const u32 max_address = member->max.ipv4;
-				memset(buf, 0, sizeof(buf));
-				snprintf(buf, sizeof(buf) - 1, "%u.%u.%u.%u",
-					 HIPQUAD(min_address));
-				if (min_address != max_address) {
-					const int len = strlen(buf);
-					snprintf(buf + len,
-						 sizeof(buf) - 1 - len,
-						 "-%u.%u.%u.%u",
-						 HIPQUAD(max_address));
-				}
-			}
-			if (!ccs_io_printf(head, CCS_KEYWORD_ADDRESS_GROUP
-					   "%s %s\n", group->group_name->name,
-					   buf))
-				return false;
-		}
-	}
-	return true;
-}
-
-/**
  * ccs_address_matches_group - Check whether the given address matches members of the given address group.
  *
  * @is_ipv6: True if @address is an IPv6 address.
@@ -203,13 +86,13 @@
  * Caller holds ccs_read_lock().
  */
 bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
-			       const struct ccs_address_group *group)
+			       const struct ccs_group *group)
 {
-	struct ccs_address_group_member *member;
+	struct ccs_address_group *member;
 	const u32 ip = ntohl(*address);
 	bool matched = false;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->is_deleted)
+	list_for_each_entry_rcu(member, &group->member_list, head.list) {
+		if (member->head.is_deleted)
 			continue;
 		if (member->is_ipv6) {
 			if (is_ipv6 &&
Index: mount.c
===================================================================
--- mount.c	(revision 3685)
+++ mount.c	(working copy)
@@ -332,6 +332,18 @@
 	return error;
 }
 
+static bool ccs_is_same_mount_acl(const struct ccs_acl_info *a,
+				  const struct ccs_acl_info *b)
+{
+	const struct ccs_mount_acl *p1 = container_of(a, typeof(*p1), head);
+	const struct ccs_mount_acl *p2 = container_of(b, typeof(*p2), head);
+	return ccs_is_same_acl_head(&p1->head, &p2->head) &&
+		ccs_is_same_name_union(&p1->dev_name, &p2->dev_name) &&
+		ccs_is_same_name_union(&p1->dir_name, &p2->dir_name) &&
+		ccs_is_same_name_union(&p1->fs_type, &p2->fs_type) &&
+		ccs_is_same_number_union(&p1->flags, &p2->flags);
+}
+
 /**
  * ccs_write_mount_policy - Write "struct ccs_mount_acl" list.
  *
@@ -346,7 +358,6 @@
 			   struct ccs_condition *condition,
 			   const bool is_delete)
 {
-	struct ccs_acl_info *ptr;
 	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL,
 				   .head.cond = condition };
 	int error = is_delete ? -ENOENT : -ENOMEM;
@@ -358,25 +369,8 @@
 	    !ccs_parse_name_union(w[2], &e.fs_type) ||
 	    !ccs_parse_number_union(w[3], &e.flags))
 		goto out;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_mount_acl *acl =
-			container_of(ptr, struct ccs_mount_acl, head);
-		if (!ccs_is_same_mount_acl(acl, &e))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_mount_acl *entry = ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			ccs_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
+	error = ccs_update_domain_policy(&e.head, sizeof(e), is_delete, domain,
+					 ccs_is_same_mount_acl, NULL);
  out:
 	ccs_put_name_union(&e.dev_name);
 	ccs_put_name_union(&e.dir_name);
Index: number_group.c
===================================================================
--- number_group.c	(revision 3685)
+++ number_group.c	(working copy)
@@ -13,54 +13,13 @@
 #include <linux/slab.h>
 #include "internal.h"
 
-/* The list for "struct ccs_number_group". */
-LIST_HEAD(ccs_number_group_list);
-
-/**
- * ccs_get_number_group - Allocate memory for "struct ccs_number_group".
- *
- * @group_name: The name of number group.
- *
- * Returns pointer to "struct ccs_number_group" on success,
- * NULL otherwise.
- */
-struct ccs_number_group *ccs_get_number_group(const char *group_name)
+static bool ccs_is_same_number_group(const struct ccs_acl_head *a,
+				     const struct ccs_acl_head *b)
 {
-	struct ccs_number_group *entry = NULL;
-	struct ccs_number_group *group = NULL;
-	const struct ccs_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
-	    !group_name[0])
-		return NULL;
-	saved_group_name = ccs_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(group, &ccs_number_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &ccs_number_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
+	return !memcmp(&container_of(a, struct ccs_number_group, head)->number,
+		       &container_of(b, struct ccs_number_group, head)->number,
+		       sizeof(container_of(a, struct ccs_number_group, head)
+			      ->number));
 }
 
 /**
@@ -73,10 +32,9 @@
  */
 int ccs_write_number_group_policy(char *data, const bool is_delete)
 {
-	struct ccs_number_group *group;
-	struct ccs_number_group_member e = { };
-	struct ccs_number_group_member *member;
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct ccs_group *group;
+	struct ccs_number_group e = { };
+	int error;
 	char *w[2];
 	if (!ccs_tokenize(data, w, sizeof(w)))
 		return -EINVAL;
@@ -89,70 +47,13 @@
 	group = ccs_get_number_group(w[0]);
 	if (!group)
 		return -ENOMEM;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (memcmp(&member->number, &e.number, sizeof(e.number)))
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_number_group_member *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list, &group->member_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_number_group(group);
+	error = ccs_update_group(&e.head, sizeof(e), is_delete, group,
+				 ccs_is_same_number_group);
+	ccs_put_group(group);
 	return error;
 }
 
 /**
- * ccs_read_number_group_policy - Read "struct ccs_number_group" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_number_group_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &ccs_number_group_list) {
-		struct ccs_number_group *group;
-		const char *name;
-		group = list_entry(gpos, struct ccs_number_group, list);
-		name = group->group_name->name;
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			int pos;
-			const struct ccs_number_group_member *member
-				= list_entry(mpos,
-					     struct ccs_number_group_member,
-					     list);
-			if (member->is_deleted)
-				continue;
-			pos = head->read_avail;
-			if (!ccs_io_printf(head, CCS_KEYWORD_NUMBER_GROUP "%s",
-					   name) ||
-			    !ccs_print_number_union(head, &member->number) ||
-			    !ccs_io_printf(head, "\n")) {
-				head->read_avail = pos;
-				return false;
-			}
-		}
-	}
-	return true;
-}
-
-/**
  * ccs_number_matches_group - Check whether the given number matches members of the given number group.
  *
  * @min:   Min number.
@@ -164,12 +65,12 @@
  * Caller holds ccs_read_lock().
  */
 bool ccs_number_matches_group(const unsigned long min, const unsigned long max,
-			      const struct ccs_number_group *group)
+			      const struct ccs_group *group)
 {
-	struct ccs_number_group_member *member;
+	struct ccs_number_group *member;
 	bool matched = false;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->is_deleted)
+	list_for_each_entry_rcu(member, &group->member_list, head.list) {
+		if (member->head.is_deleted)
 			continue;
 		if (min > member->number.values[1] ||
 		    max < member->number.values[0])
Index: autobind.c
===================================================================
--- autobind.c	(revision 3685)
+++ autobind.c	(working copy)
@@ -12,9 +12,6 @@
 
 #include "internal.h"
 
-/* The list for "struct ccs_reserved_entry". */
-LIST_HEAD(ccs_reservedport_list);
-
 static u8 ccs_reserved_port_map[8192];
 
 /**
@@ -30,6 +27,16 @@
 		? true : false;
 }
 
+static bool ccs_is_same_reserved_entry(const struct ccs_acl_head *a,
+				       const struct ccs_acl_head *b)
+{
+	const struct ccs_reserved_entry *p1 = container_of(a, typeof(*p1),
+							   head);
+	const struct ccs_reserved_entry *p2 = container_of(b, typeof(*p2),
+							   head);
+	return p1->min_port == p2->min_port && p1->max_port == p2->max_port;
+}
+
 /**
  * ccs_update_reserved_entry - Update "struct ccs_reserved_entry" list.
  *
@@ -47,46 +54,32 @@
 		.min_port = min_port,
 		.max_port = max_port
 	};
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	u8 *ccs_tmp_map = kzalloc(8192, CCS_GFP_FLAGS);
+	const int error = ccs_update_policy(&e.head, sizeof(e), is_delete,
+					    CCS_ID_RESERVEDPORT,
+					    ccs_is_same_reserved_entry);
+	u8 *ccs_tmp_map;
+	if (error)
+		return error;
+	ccs_tmp_map = kzalloc(8192, CCS_GFP_FLAGS);
 	if (!ccs_tmp_map)
 		return -ENOMEM;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
-		if (ptr->min_port != min_port || ptr->max_port != max_port)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_reserved_entry *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &ccs_reservedport_list);
-			error = 0;
-		}
-	}
-	list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
+	list_for_each_entry_rcu(ptr, &ccs_policy_list[CCS_ID_RESERVEDPORT],
+				head.list) {
 		unsigned int port;
-		if (ptr->is_deleted)
+		if (ptr->head.is_deleted)
 			continue;
 		for (port = ptr->min_port; port <= ptr->max_port; port++)
 			ccs_tmp_map[port >> 3] |= 1 << (port & 7);
 	}
 	memmove(ccs_reserved_port_map, ccs_tmp_map,
 		sizeof(ccs_reserved_port_map));
+	kfree(ccs_tmp_map);
 	/*
 	 * Since this feature is no-op by default, we don't need to register
 	 * this callback hook unless the first entry is added.
 	 */
 	ccsecurity_ops.lport_reserved = __ccs_lport_reserved;
-	mutex_unlock(&ccs_policy_lock);
- out:
-	kfree(ccs_tmp_map);
-	return error;
+	return 0;
 }
 
 /**
@@ -103,46 +96,16 @@
 	unsigned int to;
 	if (strchr(data, ' '))
 		goto out;
-	if (sscanf(data, "%u-%u", &from, &to) == 2) {
+	switch (sscanf(data, "%u-%u", &from, &to)) {
+	case 1:
+		to = from;
+		/* fall through */
+	case 2:
 		if (from <= to && to < 65536)
-			return ccs_update_reserved_entry(from, to, is_delete);
-	} else if (sscanf(data, "%u", &from) == 1) {
-		if (from < 65536)
-			return ccs_update_reserved_entry(from, from,
+			return ccs_update_reserved_entry(from, to,
 							 is_delete);
+		break;
 	}
  out:
 	return -EINVAL;
 }
-
-/**
- * ccs_read_reserved_port_policy - Read "struct ccs_reserved_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	char buffer[16];
-	memset(buffer, 0, sizeof(buffer));
-	list_for_each_cookie(pos, head->read_var2, &ccs_reservedport_list) {
-		u16 min_port;
-		u16 max_port;
-		struct ccs_reserved_entry *ptr;
-		ptr = list_entry(pos, struct ccs_reserved_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		min_port = ptr->min_port;
-		max_port = ptr->max_port;
-		snprintf(buffer, sizeof(buffer) - 1, "%u%c%u", min_port,
-			 min_port != max_port ? '-' : '\0', max_port);
-		if (!ccs_io_printf(head, CCS_KEYWORD_DENY_AUTOBIND "%s\n",
-				   buffer))
-			return false;
-	}
-	return true;
-}
Index: domain.c
===================================================================
--- domain.c	(revision 3685)
+++ domain.c	(working copy)
@@ -30,6 +30,10 @@
 /* The list for "struct ccs_domain_info". */
 LIST_HEAD(ccs_domain_list);
 
+struct list_head ccs_policy_list[CCS_MAX_POLICY];
+struct list_head ccs_group_list[CCS_MAX_GROUP];
+struct list_head ccs_shared_list[CCS_MAX_LIST];
+
 /**
  * ccs_audit_execute_handler_log - Audit execute_handler log.
  *
@@ -61,9 +65,107 @@
 	return ccs_write_audit_log(false, &r, "use_profile %u\n", r.profile);
 }
 
-/* The list for "struct ccs_domain_initializer_entry". */
-LIST_HEAD(ccs_domain_initializer_list);
+int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
+		      bool is_delete, const int idx, bool (*check_duplicate)
+		      (const struct ccs_acl_head *,
+		       const struct ccs_acl_head *))
+{
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct ccs_acl_head *entry;
+	if (mutex_lock_interruptible(&ccs_policy_lock))
+		return -ENOMEM;
+	list_for_each_entry_rcu(entry, &ccs_policy_list[idx], list) {
+		if (!check_duplicate(entry, new_entry))
+			continue;
+		entry->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (error && !is_delete) {
+		entry = ccs_commit_ok(new_entry, size);
+		if (entry) {
+			list_add_tail_rcu(&entry->list, &ccs_policy_list[idx]);
+			error = 0;
+		}
+	}
+	mutex_unlock(&ccs_policy_lock);
+	return error;
+}
 
+int ccs_update_group(struct ccs_acl_head *new_entry, const int size,
+		     bool is_delete, struct ccs_group *group,
+		     bool (*check_duplicate) (const struct ccs_acl_head *,
+					      const struct ccs_acl_head *))
+{
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct ccs_acl_head *entry;
+	if (mutex_lock_interruptible(&ccs_policy_lock))
+		return -ENOMEM;
+	list_for_each_entry_rcu(entry, &group->member_list, list) {
+		if (!check_duplicate(entry, new_entry))
+			continue;
+		entry->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error) {
+		entry = ccs_commit_ok(new_entry, size);
+		if (entry) {
+			list_add_tail_rcu(&entry->list, &group->member_list);
+			error = 0;
+		}
+	}
+	mutex_unlock(&ccs_policy_lock);
+	return error;
+}
+
+int ccs_update_domain_policy(struct ccs_acl_info *new_entry, const int size,
+			     bool is_delete, struct ccs_domain_info *domain,
+			     bool (*check_duplicate)
+			     (const struct ccs_acl_info *,
+			      const struct ccs_acl_info *),
+			     bool (*merge_duplicate) (struct ccs_acl_info *,
+						      struct ccs_acl_info *,
+						      const bool))
+{
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct ccs_acl_info *entry;
+	if (mutex_lock_interruptible(&ccs_policy_lock))
+		return error;
+	list_for_each_entry_rcu(entry, &domain->acl_info_list, list) {
+		if (!check_duplicate(entry, new_entry))
+			continue;
+		if (merge_duplicate)
+			entry->is_deleted = merge_duplicate(entry, new_entry,
+							    is_delete);
+		else
+			entry->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (error && !is_delete) {
+		entry = ccs_commit_ok(new_entry, size);
+		if (entry) {
+			ccs_add_domain_acl(domain, entry);
+			error = 0;
+		}
+	}
+	mutex_unlock(&ccs_policy_lock);
+	return error;
+}
+
+static bool ccs_is_same_domain_initializer_entry(const struct ccs_acl_head *a,
+						 const struct ccs_acl_head *b)
+{
+	const struct ccs_domain_initializer_entry *p1 =
+		container_of(a, typeof(*p1), head);
+	const struct ccs_domain_initializer_entry *p2 =
+		container_of(b, typeof(*p2), head);
+	return p1->is_not == p2->is_not && p1->is_last_name == p2->is_last_name
+		&& p1->domainname == p2->domainname
+		&& p1->program == p2->program;
+}
+
 /**
  * ccs_update_domain_initializer_entry - Update "struct ccs_domain_initializer_entry" list.
  *
@@ -79,7 +181,6 @@
 					       const bool is_not,
 					       const bool is_delete)
 {
-	struct ccs_domain_initializer_entry *ptr;
 	struct ccs_domain_initializer_entry e = { .is_not = is_not };
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(program, 1, -1, -1))
@@ -97,25 +198,9 @@
 	e.program = ccs_get_name(program);
 	if (!e.program)
 		goto out;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &ccs_domain_initializer_list, list) {
-		if (!ccs_is_same_domain_initializer_entry(ptr, &e))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_domain_initializer_entry *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &ccs_domain_initializer_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
+	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
+				  CCS_ID_DOMAIN_INITIALIZER,
+				  ccs_is_same_domain_initializer_entry);
  out:
 	ccs_put_name(e.domainname);
 	ccs_put_name(e.program);
@@ -123,43 +208,6 @@
 }
 
 /**
- * ccs_read_domain_initializer_policy - Read "struct ccs_domain_initializer_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_domain_initializer_list) {
-		const char *no;
-		const char *from = "";
-		const char *domain = "";
-		struct ccs_domain_initializer_entry *ptr;
-		ptr = list_entry(pos, struct ccs_domain_initializer_entry,
-				 list);
-		if (ptr->is_deleted)
-			continue;
-		no = ptr->is_not ? "no_" : "";
-		if (ptr->domainname) {
-			from = " from ";
-			domain = ptr->domainname->name;
-		}
-		done = ccs_io_printf(head, "%s" CCS_KEYWORD_INITIALIZE_DOMAIN
-				     "%s%s%s\n", no, ptr->program->name, from,
-				     domain);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
  * ccs_write_domain_initializer_policy - Write "struct ccs_domain_initializer_entry" list.
  *
  * @data:      String to parse.
@@ -199,8 +247,9 @@
 {
 	struct ccs_domain_initializer_entry *ptr;
 	bool flag = false;
-	list_for_each_entry_rcu(ptr, &ccs_domain_initializer_list, list) {
-		if (ptr->is_deleted)
+	list_for_each_entry_rcu(ptr, &ccs_policy_list
+				[CCS_ID_DOMAIN_INITIALIZER], head.list) {
+		if (ptr->head.is_deleted)
 			continue;
 		if (ptr->domainname) {
 			if (!ptr->is_last_name) {
@@ -222,8 +271,17 @@
 	return flag;
 }
 
-/* The list for "struct ccs_domain_keeper_entry". */
-LIST_HEAD(ccs_domain_keeper_list);
+static bool ccs_is_same_domain_keeper_entry(const struct ccs_acl_head *a,
+					    const struct ccs_acl_head *b)
+{
+	const struct ccs_domain_keeper_entry *p1 =
+		container_of(a, typeof(*p1), head);
+	const struct ccs_domain_keeper_entry *p2 =
+		container_of(b, typeof(*p2), head);
+	return p1->is_not == p2->is_not && p1->is_last_name == p2->is_last_name
+		&& p1->domainname == p2->domainname
+		&& p1->program == p2->program;
+}
 
 /**
  * ccs_update_domain_keeper_entry - Update "struct ccs_domain_keeper_entry" list.
@@ -240,7 +298,6 @@
 					  const bool is_not,
 					  const bool is_delete)
 {
-	struct ccs_domain_keeper_entry *ptr;
 	struct ccs_domain_keeper_entry e = { .is_not = is_not };
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_domain_def(domainname) &&
@@ -258,25 +315,9 @@
 	e.domainname = ccs_get_name(domainname);
 	if (!e.domainname)
 		goto out;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &ccs_domain_keeper_list, list) {
-		if (!ccs_is_same_domain_keeper_entry(ptr, &e))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_domain_keeper_entry *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &ccs_domain_keeper_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
+	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
+				  CCS_ID_DOMAIN_KEEPER,
+				  ccs_is_same_domain_keeper_entry);
  out:
 	ccs_put_name(e.domainname);
 	ccs_put_name(e.program);
@@ -304,42 +345,6 @@
 }
 
 /**
- * ccs_read_domain_keeper_policy - Read "struct ccs_domain_keeper_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_domain_keeper_list) {
-		struct ccs_domain_keeper_entry *ptr;
-		const char *no;
-		const char *from = "";
-		const char *program = "";
-		ptr = list_entry(pos, struct ccs_domain_keeper_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		no = ptr->is_not ? "no_" : "";
-		if (ptr->program) {
-			from = " from ";
-			program = ptr->program->name;
-		}
-		done = ccs_io_printf(head, "%s" CCS_KEYWORD_KEEP_DOMAIN
-				     "%s%s%s\n", no, program, from,
-				     ptr->domainname->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
  * ccs_is_domain_keeper - Check whether the given program causes domain transition suppression.
  *
  * @domainname: The name of domain.
@@ -357,8 +362,9 @@
 {
 	struct ccs_domain_keeper_entry *ptr;
 	bool flag = false;
-	list_for_each_entry_rcu(ptr, &ccs_domain_keeper_list, list) {
-		if (ptr->is_deleted)
+	list_for_each_entry_rcu(ptr, &ccs_policy_list[CCS_ID_DOMAIN_KEEPER],
+				head.list) {
+		if (ptr->head.is_deleted)
 			continue;
 		if (!ptr->is_last_name) {
 			if (ptr->domainname != domainname)
@@ -378,8 +384,16 @@
 	return flag;
 }
 
-/* The list for "struct ccs_aggregator_entry". */
-LIST_HEAD(ccs_aggregator_list);
+static bool ccs_is_same_aggregator_entry(const struct ccs_acl_head *a,
+					 const struct ccs_acl_head *b)
+{
+	const struct ccs_aggregator_entry *p1 =
+		container_of(a, typeof(*p1), head);
+	const struct ccs_aggregator_entry *p2 =
+		container_of(b, typeof(*p2), head);
+	return p1->original_name == p2->original_name &&
+		p1->aggregated_name == p2->aggregated_name;
+}
 
 /**
  * ccs_update_aggregator_entry - Update "struct ccs_aggregator_entry" list.
@@ -394,7 +408,6 @@
 				       const char *aggregated_name,
 				       const bool is_delete)
 {
-	struct ccs_aggregator_entry *ptr;
 	struct ccs_aggregator_entry e = { };
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(original_name, 1, 0, -1) ||
@@ -404,24 +417,9 @@
 	e.aggregated_name = ccs_get_name(aggregated_name);
 	if (!e.original_name || !e.aggregated_name)
 		goto out;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &ccs_aggregator_list, list) {
-		if (!ccs_is_same_aggregator_entry(ptr, &e))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_aggregator_entry *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list, &ccs_aggregator_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
+	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
+				  CCS_ID_AGGREGATOR,
+				  ccs_is_same_aggregator_entry);
  out:
 	ccs_put_name(e.original_name);
 	ccs_put_name(e.aggregated_name);
@@ -429,33 +427,6 @@
 }
 
 /**
- * ccs_read_aggregator_policy - Read "struct ccs_aggregator_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_aggregator_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2, &ccs_aggregator_list) {
-		struct ccs_aggregator_entry *ptr;
-		ptr = list_entry(pos, struct ccs_aggregator_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_AGGREGATOR "%s %s\n",
-				     ptr->original_name->name,
-				     ptr->aggregated_name->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
  * ccs_write_aggregator_policy - Write "struct ccs_aggregator_entry" list.
  *
  * @data:      String to parse.
@@ -605,8 +576,10 @@
 	} else {
 		struct ccs_aggregator_entry *ptr;
 		/* Check 'aggregator' directive. */
-		list_for_each_entry_rcu(ptr, &ccs_aggregator_list, list) {
-			if (ptr->is_deleted ||
+		list_for_each_entry_rcu(ptr,
+					&ccs_policy_list[CCS_ID_AGGREGATOR],
+					head.list) {
+			if (ptr->head.is_deleted ||
 			    !ccs_path_matches_pattern(&rn, ptr->original_name))
 				continue;
 			kfree(rn.name);
Index: memory.c
===================================================================
--- memory.c	(revision 3685)
+++ memory.c	(working copy)
@@ -94,8 +94,52 @@
 	kfree(ptr);
 }
 
-/* Lis of IPv6 address. */
-LIST_HEAD(ccs_address_list);
+/**
+ * ccs_get_group - Allocate memory for "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group".
+ *
+ * @group_name: The name of address group.
+ * @idx:        Index number.
+ *
+ * Returns pointer to "struct ccs_group" on success, NULL otherwise.
+ */
+struct ccs_group *ccs_get_group(const char *group_name, const u8 idx)
+{
+	struct ccs_group *entry = NULL;
+	struct ccs_group *group = NULL;
+	const struct ccs_path_info *saved_group_name;
+	int error = -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
+	    !group_name[0] || idx >= CCS_MAX_GROUP)
+		return NULL;
+	saved_group_name = ccs_get_name(group_name);
+	if (!saved_group_name)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
+	if (mutex_lock_interruptible(&ccs_policy_lock))
+		goto out;
+	list_for_each_entry_rcu(group, &ccs_group_list[idx], head.list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		atomic_inc(&group->head.users);
+		error = 0;
+		break;
+	}
+	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
+		INIT_LIST_HEAD(&entry->member_list);
+		entry->group_name = saved_group_name;
+		saved_group_name = NULL;
+		atomic_set(&entry->head.users, 1);
+		list_add_tail_rcu(&entry->head.list, &ccs_group_list[idx]);
+		group = entry;
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	ccs_put_name(saved_group_name);
+	kfree(entry);
+	return !error ? group : NULL;
+}
 
 /**
  * ccs_get_ipv6_address - Keep the given IPv6 address on the RAM.
@@ -116,18 +160,20 @@
 	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list_for_each_entry(ptr, &ccs_address_list, list) {
+	list_for_each_entry(ptr, &ccs_shared_list[CCS_IPV6ADDRESS_LIST],
+			    head.list) {
 		if (memcmp(&ptr->addr, addr, sizeof(*addr)))
 			continue;
-		atomic_inc(&ptr->users);
+		atomic_inc(&ptr->head.users);
 		error = 0;
 		break;
 	}
 	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
 		ptr = entry;
 		ptr->addr = *addr;
-		atomic_set(&ptr->users, 1);
-		list_add_tail(&ptr->list, &ccs_address_list);
+		atomic_set(&ptr->head.users, 1);
+		list_add_tail(&ptr->head.list,
+			      &ccs_shared_list[CCS_IPV6ADDRESS_LIST]);
 		entry = NULL;
 		error = 0;
 	}
@@ -166,10 +212,10 @@
 #endif
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return NULL;
-	list_for_each_entry(ptr, head, list) {
+	list_for_each_entry(ptr, head, head.list) {
 		if (hash != ptr->entry.hash || strcmp(name, ptr->entry.name))
 			continue;
-		atomic_inc(&ptr->users);
+		atomic_inc(&ptr->head.users);
 		goto out;
 	}
 	allocated_len = ccs_round2(sizeof(*ptr) + len);
@@ -185,10 +231,10 @@
 	atomic_add(allocated_len, &ccs_policy_memory_size);
 	ptr->entry.name = ((char *) ptr) + sizeof(*ptr);
 	memmove((char *) ptr->entry.name, name, len);
-	atomic_set(&ptr->users, 1);
+	atomic_set(&ptr->head.users, 1);
 	ccs_fill_path_info(&ptr->entry);
 	ptr->size = allocated_len;
-	list_add_tail(&ptr->list, head);
+	list_add_tail(&ptr->head.list, head);
  out:
 	mutex_unlock(&ccs_policy_lock);
 	return ptr ? &ptr->entry : NULL;
Index: path_group.c
===================================================================
--- path_group.c	(revision 3685)
+++ path_group.c	(working copy)
@@ -11,53 +11,12 @@
  */
 
 #include "internal.h"
-/* The list for "struct ccs_path_group". */
-LIST_HEAD(ccs_path_group_list);
 
-/**
- * ccs_get_path_group - Allocate memory for "struct ccs_path_group".
- *
- * @group_name: The name of pathname group.
- *
- * Returns pointer to "struct ccs_path_group" on success, NULL otherwise.
- */
-struct ccs_path_group *ccs_get_path_group(const char *group_name)
+static bool ccs_is_same_path_group(const struct ccs_acl_head *a,
+				   const struct ccs_acl_head *b)
 {
-	struct ccs_path_group *entry = NULL;
-	struct ccs_path_group *group = NULL;
-	const struct ccs_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
-	    !group_name[0])
-		return NULL;
-	saved_group_name = ccs_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(group, &ccs_path_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &ccs_path_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
+	return container_of(a, struct ccs_path_group, head)->member_name ==
+		container_of(b, struct ccs_path_group, head)->member_name;
 }
 
 /**
@@ -70,10 +29,9 @@
  */
 int ccs_write_path_group_policy(char *data, const bool is_delete)
 {
-	struct ccs_path_group *group;
-	struct ccs_path_group_member *member;
-	struct ccs_path_group_member e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct ccs_group *group;
+	struct ccs_path_group e = { };
+	int error;
 	char *w[2];
 	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
 		return -EINVAL;
@@ -81,66 +39,17 @@
 	if (!group)
 		return -ENOMEM;
 	e.member_name = ccs_get_name(w[1]);
-	if (!e.member_name)
-		goto out;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->member_name != e.member_name)
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_path_group_member *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list, &group->member_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.member_name);
-	ccs_put_path_group(group);
+	if (e.member_name)
+		error = ccs_update_group(&e.head, sizeof(e), is_delete, group,
+					 ccs_is_same_path_group);
+	else
+		error = -ENOMEM;
+ 	ccs_put_name(e.member_name);
+	ccs_put_group(group);
 	return error;
 }
 
 /**
- * ccs_read_path_group_policy - Read "struct ccs_path_group" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_path_group_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &ccs_path_group_list) {
-		struct ccs_path_group *group;
-		group = list_entry(gpos, struct ccs_path_group, list);
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			struct ccs_path_group_member *member;
-			member = list_entry(mpos, struct ccs_path_group_member,
-					    list);
-			if (member->is_deleted)
-				continue;
-			if (!ccs_io_printf(head, CCS_KEYWORD_PATH_GROUP
-					   "%s %s\n",
-					   group->group_name->name,
-					   member->member_name->name))
-				return false;
-		}
-	}
-	return true;
-}
-
-/**
  * ccs_path_matches_group - Check whether the given pathname matches members of the given pathname group.
  *
  * @pathname:        The name of pathname.
@@ -152,13 +61,13 @@
  * Caller holds ccs_read_lock().
  */
 bool ccs_path_matches_group(const struct ccs_path_info *pathname,
-			    const struct ccs_path_group *group,
+			    const struct ccs_group *group,
 			    const bool may_use_pattern)
 {
-	struct ccs_path_group_member *member;
+	struct ccs_path_group *member;
 	bool matched = false;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->is_deleted)
+	list_for_each_entry_rcu(member, &group->member_list, head.list) {
+		if (member->head.is_deleted)
 			continue;
 		if (!member->member_name->is_patterned) {
 			if (ccs_pathcmp(pathname, member->member_name))
Index: signal.c
===================================================================
--- signal.c	(revision 3685)
+++ signal.c	(working copy)
@@ -137,6 +137,16 @@
 	return error;
 }
 
+static bool ccs_is_same_signal_entry(const struct ccs_acl_info *a,
+				     const struct ccs_acl_info *b)
+{
+	const struct ccs_signal_acl *p1 = container_of(a, typeof(*p1), head);
+	const struct ccs_signal_acl *p2 = container_of(b, typeof(*p2), head);
+	return p1->head.type == p2->head.type && p1->head.cond == p2->head.cond
+		&& p1->head.type == CCS_TYPE_SIGNAL_ACL && p1->sig == p2->sig
+		&& p1->domainname == p2->domainname;
+}
+
 /**
  * ccs_write_signal_policy - Write "struct ccs_signal_acl" list.
  *
@@ -151,10 +161,9 @@
 			    struct ccs_condition *condition,
 			    const bool is_delete)
 {
-	struct ccs_acl_info *ptr;
 	struct ccs_signal_acl e = { .head.type = CCS_TYPE_SIGNAL_ACL,
 				    .head.cond = condition };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error;
 	int sig;
 	char *domainname = strchr(data, ' ');
 	if (sscanf(data, "%d", &sig) != 1 || !domainname ||
@@ -164,27 +173,8 @@
 	e.domainname = ccs_get_name(domainname + 1);
 	if (!e.domainname)
 		return -ENOMEM;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_signal_acl *acl =
-			container_of(ptr, struct ccs_signal_acl, head);
-		if (ptr->type != CCS_TYPE_SIGNAL_ACL || ptr->cond != condition
-		    || acl->sig != sig || acl->domainname != e.domainname)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_signal_acl *entry = ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			ccs_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
+	error = ccs_update_domain_policy(&e.head, sizeof(e), is_delete, domain,
+					 ccs_is_same_signal_entry, NULL);
 	ccs_put_name(e.domainname);
 	return error;
 }
Index: file.c
===================================================================
--- file.c	(revision 3685)
+++ file.c	(working copy)
@@ -459,7 +459,7 @@
 	if (!ptr)
 		return;
 	if (ptr->is_group)
-		ccs_put_path_group(ptr->group);
+		ccs_put_group(ptr->group);
 	else
 		ccs_put_name(ptr->filename);
 }
@@ -467,7 +467,7 @@
 void ccs_put_number_union(struct ccs_number_union *ptr)
 {
 	if (ptr && ptr->is_group)
-		ccs_put_number_group(ptr->group);
+		ccs_put_group(ptr->group);
 }
 
 bool ccs_compare_number_union(const unsigned long value,
@@ -693,9 +693,6 @@
 				   operation, filename, value);
 }
 
-/* The list for "struct ccs_globally_readable_file_entry". */
-LIST_HEAD(ccs_globally_readable_list);
-
 /**
  * ccs_is_globally_readable_file - Check if the file is unconditionnaly permitted to be open()ed for reading.
  *
@@ -709,8 +706,9 @@
 {
 	struct ccs_globally_readable_file_entry *ptr;
 	bool found = false;
-	list_for_each_entry_rcu(ptr, &ccs_globally_readable_list, list) {
-		if (ptr->is_deleted ||
+	list_for_each_entry_rcu(ptr, &ccs_policy_list
+				[CCS_ID_GLOBALLY_READABLE], head.list) {
+		if (ptr->head.is_deleted ||
 		    !ccs_path_matches_pattern(filename, ptr->filename))
 			continue;
 		found = true;
@@ -719,6 +717,15 @@
 	return found;
 }
 
+static bool ccs_is_same_globally_readable_entry(const struct ccs_acl_head *a,
+						const struct ccs_acl_head *b)
+{
+	return container_of(a, struct ccs_globally_readable_file_entry, head)
+		->filename ==
+		container_of(b, struct ccs_globally_readable_file_entry, head)
+		->filename;
+}
+
 /**
  * ccs_write_globally_readable_policy - Write "struct ccs_globally_readable_file_entry" list.
  *
@@ -729,70 +736,21 @@
  */
 int ccs_write_globally_readable_policy(char *data, const bool is_delete)
 {
-	struct ccs_globally_readable_file_entry *ptr;
 	struct ccs_globally_readable_file_entry e = { };
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(data, 1, 0, -1))
 		return -EINVAL;
 	e.filename = ccs_get_name(data);
 	if (!e.filename)
-		return -ENOMEM;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &ccs_globally_readable_list, list) {
-		if (ptr->filename != e.filename)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_globally_readable_file_entry *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &ccs_globally_readable_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
+		return error;
+	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
+				  CCS_ID_GLOBALLY_READABLE,
+				  ccs_is_same_globally_readable_entry);
 	ccs_put_name(e.filename);
 	return error;
 }
 
 /**
- * ccs_read_globally_readable_policy - Read "struct ccs_globally_readable_file_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_globally_readable_list) {
-		struct ccs_globally_readable_file_entry *ptr;
-		ptr = list_entry(pos, struct ccs_globally_readable_file_entry,
-				 list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_READ "%s\n",
-				     ptr->filename->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/* The list for "struct ccs_pattern_entry". */
-LIST_HEAD(ccs_pattern_list);
-
-/**
  * ccs_file_pattern - Get patterned pathname.
  *
  * @filename: Pointer to "struct ccs_path_info".
@@ -805,8 +763,9 @@
 {
 	struct ccs_pattern_entry *ptr;
 	const struct ccs_path_info *pattern = NULL;
-	list_for_each_entry_rcu(ptr, &ccs_pattern_list, list) {
-		if (ptr->is_deleted)
+	list_for_each_entry_rcu(ptr, &ccs_policy_list[CCS_ID_PATTERN],
+				head.list) {
+		if (ptr->head.is_deleted)
 			continue;
 		if (!ccs_path_matches_pattern(filename, ptr->pattern))
 			continue;
@@ -821,6 +780,13 @@
 	return pattern ? pattern->name : filename->name;
 }
 
+static bool ccs_is_same_pattern_entry(const struct ccs_acl_head *a,
+				      const struct ccs_acl_head *b)
+{
+	return container_of(a, struct ccs_pattern_entry, head)->pattern ==
+		container_of(b, struct ccs_pattern_entry, head)->pattern;
+}
+
 /**
  * ccs_write_pattern_policy - Write "struct ccs_pattern_entry" list.
  *
@@ -831,65 +797,20 @@
  */
 int ccs_write_pattern_policy(char *data, const bool is_delete)
 {
-	struct ccs_pattern_entry *ptr;
-	struct ccs_pattern_entry e = { .pattern = ccs_get_name(data) };
+	struct ccs_pattern_entry e = { };
 	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(data, 0, 1, 0))
+		return -EINVAL;
+	e.pattern = ccs_get_name(data);
 	if (!e.pattern)
 		return error;
-	if (!e.pattern->is_patterned)
-		goto out;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &ccs_pattern_list, list) {
-		if (e.pattern != ptr->pattern)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_pattern_entry *entry = ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list, &ccs_pattern_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
+	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
+				  CCS_ID_PATTERN, ccs_is_same_pattern_entry);
 	ccs_put_name(e.pattern);
 	return error;
 }
 
 /**
- * ccs_read_file_pattern - Read "struct ccs_pattern_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_file_pattern(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2, &ccs_pattern_list) {
-		struct ccs_pattern_entry *ptr;
-		ptr = list_entry(pos, struct ccs_pattern_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_FILE_PATTERN "%s\n",
-				     ptr->pattern->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/* The list for "struct ccs_no_rewrite_entry". */
-LIST_HEAD(ccs_no_rewrite_list);
-
-/**
  * ccs_is_no_rewrite_file - Check if the given pathname is not permitted to be rewrited.
  *
  * @filename: Filename to check.
@@ -903,8 +824,9 @@
 {
 	struct ccs_no_rewrite_entry *ptr;
 	bool matched = false;
-	list_for_each_entry_rcu(ptr, &ccs_no_rewrite_list, list) {
-		if (ptr->is_deleted)
+	list_for_each_entry_rcu(ptr, &ccs_policy_list[CCS_ID_NO_REWRITE],
+				head.list) {
+		if (ptr->head.is_deleted)
 			continue;
 		if (!ccs_path_matches_pattern(filename, ptr->pattern))
 			continue;
@@ -914,6 +836,13 @@
 	return matched;
 }
 
+static bool ccs_is_same_rewrite_entry(const struct ccs_acl_head *a,
+				      const struct ccs_acl_head *b)
+{
+	return container_of(a, struct ccs_no_rewrite_entry, head)->pattern ==
+		container_of(b, struct ccs_no_rewrite_entry, head)->pattern;
+}
+
 /**
  * ccs_write_no_rewrite_policy - Write "struct ccs_no_rewrite_entry" list.
  *
@@ -924,7 +853,6 @@
  */
 int ccs_write_no_rewrite_policy(char *data, const bool is_delete)
 {
-	struct ccs_no_rewrite_entry *ptr;
 	struct ccs_no_rewrite_entry e = { };
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(data, 0, 0, 0))
@@ -932,56 +860,14 @@
 	e.pattern = ccs_get_name(data);
 	if (!e.pattern)
 		return error;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &ccs_no_rewrite_list, list) {
-		if (ptr->pattern != e.pattern)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_no_rewrite_entry *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list, &ccs_no_rewrite_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
+	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
+				  CCS_ID_NO_REWRITE,
+				  ccs_is_same_rewrite_entry);
 	ccs_put_name(e.pattern);
 	return error;
 }
 
 /**
- * ccs_read_no_rewrite_policy - Read "struct ccs_no_rewrite_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2, &ccs_no_rewrite_list) {
-		struct ccs_no_rewrite_entry *ptr;
-		ptr = list_entry(pos, struct ccs_no_rewrite_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_DENY_REWRITE "%s\n",
-				     ptr->pattern->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
  * ccs_update_file_acl - Update file's read/write/execute ACL.
  *
  * @perm:      Permission (between 1 to 7).
@@ -1225,6 +1111,40 @@
 	return error;
 }
 
+static bool ccs_is_same_path_acl(const struct ccs_acl_info *a,
+				 const struct ccs_acl_info *b)
+{
+	const struct ccs_path_acl *p1 = container_of(a, typeof(*p1), head);
+	const struct ccs_path_acl *p2 = container_of(b, typeof(*p2), head);
+	return ccs_is_same_acl_head(&p1->head, &p2->head) &&
+		ccs_is_same_name_union(&p1->name, &p2->name);
+}
+
+static bool ccs_merge_path_acl(struct ccs_acl_info *a, struct ccs_acl_info *b,
+			       const bool is_delete)
+{
+	static const u16 ccs_rw_mask =
+		(1 << CCS_TYPE_READ) | (1 << CCS_TYPE_WRITE);
+	struct ccs_path_acl *p1 = container_of(a, typeof(*p1), head);
+	const u16 perm = container_of(b, typeof(*p1), head)->perm;
+	if (is_delete) {
+		p1->perm &= ~perm;
+		if ((p1->perm & ccs_rw_mask) != ccs_rw_mask)
+			p1->perm &= ~(1 << CCS_TYPE_READ_WRITE);
+		else if (!(p1->perm & (1 << CCS_TYPE_READ_WRITE)))
+			p1->perm &= ~ccs_rw_mask;
+	} else {
+		if (p1->head.is_deleted)
+			p1->perm = 0;
+		p1->perm |= perm;
+		if ((p1->perm & ccs_rw_mask) == ccs_rw_mask)
+			p1->perm |= 1 << CCS_TYPE_READ_WRITE;
+		else if (p1->perm & (1 << CCS_TYPE_READ_WRITE))
+			p1->perm |= ccs_rw_mask;
+	}
+	return !p1->perm;
+}
+
 /**
  * ccs_update_path_acl - Update "struct ccs_path_acl" list.
  *
@@ -1243,59 +1163,53 @@
 {
 	static const u16 ccs_rw_mask =
 		(1 << CCS_TYPE_READ) | (1 << CCS_TYPE_WRITE);
-	const u16 perm = 1 << type;
-	struct ccs_acl_info *ptr;
 	struct ccs_path_acl e = {
 		.head.type = CCS_TYPE_PATH_ACL,
 		.head.cond = condition,
-		.perm = perm
+		.perm = 1 << type
 	};
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error;
 	if (type == CCS_TYPE_READ_WRITE)
 		e.perm |= ccs_rw_mask;
 	if (!ccs_parse_name_union(filename, &e.name))
 		return -EINVAL;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path_acl *acl =
-			container_of(ptr, struct ccs_path_acl, head);
-		if (!ccs_is_same_path_acl(acl, &e))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if ((acl->perm & ccs_rw_mask) != ccs_rw_mask)
-				acl->perm &= ~(1 << CCS_TYPE_READ_WRITE);
-			else if (!(acl->perm & (1 << CCS_TYPE_READ_WRITE)))
-				acl->perm &= ~ccs_rw_mask;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			if ((acl->perm & ccs_rw_mask) == ccs_rw_mask)
-				acl->perm |= 1 << CCS_TYPE_READ_WRITE;
-			else if (acl->perm & (1 << CCS_TYPE_READ_WRITE))
-				acl->perm |= ccs_rw_mask;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_path_acl *entry = ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			ccs_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
+	error = ccs_update_domain_policy(&e.head, sizeof(e), is_delete, domain,
+					 ccs_is_same_path_acl,
+					 ccs_merge_path_acl);
 	ccs_put_name_union(&e.name);
 	return error;
 }
 
+static bool ccs_is_same_path_number3_acl(const struct ccs_acl_info *a,
+					 const struct ccs_acl_info *b)
+{
+	const struct ccs_path_number3_acl *p1 = container_of(a, typeof(*p1),
+							     head);
+	const struct ccs_path_number3_acl *p2 = container_of(b, typeof(*p2),
+							     head);
+	return ccs_is_same_acl_head(&p1->head, &p2->head)
+		&& ccs_is_same_name_union(&p1->name, &p2->name)
+		&& ccs_is_same_number_union(&p1->mode, &p2->mode)
+		&& ccs_is_same_number_union(&p1->major, &p2->major)
+		&& ccs_is_same_number_union(&p1->minor, &p2->minor);
+}
+
+static bool ccs_merge_path_number3_acl(struct ccs_acl_info *a,
+				       struct ccs_acl_info *b,
+				       const bool is_delete)
+{
+	struct ccs_path_number3_acl *p1 = container_of(a, typeof(*p1), head);
+	const u8 perm = container_of(b, typeof(*p1), head)->perm;
+	if (is_delete) {
+		p1->perm &= ~perm;
+	} else {
+		if (p1->head.is_deleted)
+			p1->perm = 0;
+		p1->perm |= perm;
+	}
+	return !p1->perm;
+}
+
 /**
  * ccs_update_path_number3_acl - Update "struct ccs_path_number3_acl" list.
  *
@@ -1316,12 +1230,10 @@
 				       struct ccs_condition *condition,
 				       const bool is_delete)
 {
-	const u8 perm = 1 << type;
-	struct ccs_acl_info *ptr;
 	struct ccs_path_number3_acl e = {
 		.head.type = CCS_TYPE_PATH_NUMBER3_ACL,
 		.head.cond = condition,
-		.perm = perm
+		.perm = 1 << type
 	};
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_parse_name_union(filename, &e.name) ||
@@ -1329,35 +1241,9 @@
 	    !ccs_parse_number_union(major, &e.major) ||
 	    !ccs_parse_number_union(minor, &e.minor))
 		goto out;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path_number3_acl *acl =
-			container_of(ptr, struct ccs_path_number3_acl, head);
-		if (!ccs_is_same_path_number3_acl(acl, &e))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_path_number3_acl *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			ccs_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
+	error = ccs_update_domain_policy(&e.head, sizeof(e), is_delete, domain,
+					 ccs_is_same_path_number3_acl,
+					 ccs_merge_path_number3_acl);
  out:
 	ccs_put_name_union(&e.name);
 	ccs_put_number_union(&e.mode);
@@ -1366,6 +1252,31 @@
 	return error;
 }
 
+static bool ccs_is_same_path2_acl(const struct ccs_acl_info *a,
+				  const struct ccs_acl_info *b)
+{
+	const struct ccs_path2_acl *p1 = container_of(a, typeof(*p1), head);
+	const struct ccs_path2_acl *p2 = container_of(b, typeof(*p2), head);
+	return ccs_is_same_acl_head(&p1->head, &p2->head)
+		&& ccs_is_same_name_union(&p1->name1, &p2->name1)
+		&& ccs_is_same_name_union(&p1->name2, &p2->name2);
+}
+
+static bool ccs_merge_path2_acl(struct ccs_acl_info *a,
+				struct ccs_acl_info *b, const bool is_delete)
+{
+	struct ccs_path2_acl *p1 = container_of(a, typeof(*p1), head);
+	const u8 perm = container_of(b, typeof(*p1), head)->perm;
+	if (is_delete) {
+		p1->perm &= ~perm;
+	} else {
+		if (p1->head.is_deleted)
+			p1->perm = 0;
+		p1->perm |= perm;
+	}
+	return !p1->perm;
+}
+
 /**
  * ccs_update_path2_acl - Update "struct ccs_path2_acl" list.
  *
@@ -1384,45 +1295,18 @@
 				struct ccs_condition *condition,
 				const bool is_delete)
 {
-	const u8 perm = 1 << type;
-	struct ccs_acl_info *ptr;
 	struct ccs_path2_acl e = {
 		.head.type = CCS_TYPE_PATH2_ACL,
 		.head.cond = condition,
-		.perm = perm
+		.perm = 1 << type
 	};
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_parse_name_union(filename1, &e.name1) ||
 	    !ccs_parse_name_union(filename2, &e.name2))
 		goto out;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path2_acl *acl =
-			container_of(ptr, struct ccs_path2_acl, head);
-		if (!ccs_is_same_path2_acl(acl, &e))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_path2_acl *entry = ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			ccs_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
+	error = ccs_update_domain_policy(&e.head, sizeof(e), is_delete, domain,
+					 ccs_is_same_path2_acl,
+					 ccs_merge_path2_acl);
  out:
 	ccs_put_name_union(&e.name1);
 	ccs_put_name_union(&e.name2);
@@ -1944,6 +1828,34 @@
 	return error;
 }
 
+static bool ccs_is_same_path_number_acl(const struct ccs_acl_info *a,
+					const struct ccs_acl_info *b)
+{
+	const struct ccs_path_number_acl *p1 = container_of(a, typeof(*p1),
+							    head);
+	const struct ccs_path_number_acl *p2 = container_of(b, typeof(*p2),
+							    head);
+	return ccs_is_same_acl_head(&p1->head, &p2->head)
+		&& ccs_is_same_name_union(&p1->name, &p2->name)
+		&& ccs_is_same_number_union(&p1->number, &p2->number);
+}
+
+static bool ccs_merge_path_number_acl(struct ccs_acl_info *a,
+				      struct ccs_acl_info *b,
+				      const bool is_delete)
+{
+	struct ccs_path_number_acl *p1 = container_of(a, typeof(*p1), head);
+	const u8 perm = container_of(b, typeof(*p1), head)->perm;
+	if (is_delete) {
+		p1->perm &= ~perm;
+	} else {
+		if (p1->head.is_deleted)
+			p1->perm = 0;
+		p1->perm |= perm;
+	}
+	return !p1->perm;
+}
+
 /**
  * ccs_update_path_number_acl - Update ioctl/chmod/chown/chgrp ACL.
  *
@@ -1962,12 +1874,10 @@
 				      struct ccs_condition *condition,
 				      const bool is_delete)
 {
-	const u8 perm = 1 << type;
-	struct ccs_acl_info *ptr;
 	struct ccs_path_number_acl e = {
 		.head.type = CCS_TYPE_PATH_NUMBER_ACL,
 		.head.cond = condition,
-		.perm = perm
+		.perm = 1 << type
 	};
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!domain)
@@ -1976,35 +1886,9 @@
 		return -EINVAL;
 	if (!ccs_parse_number_union(number, &e.number))
 		goto out;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path_number_acl *acl =
-			container_of(ptr, struct ccs_path_number_acl, head);
-		if (!ccs_is_same_path_number_acl(acl, &e))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_path_number_acl *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			ccs_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
+	error = ccs_update_domain_policy(&e.head, sizeof(e), is_delete, domain,
+					 ccs_is_same_path_number_acl,
+					 ccs_merge_path_number_acl);
  out:
 	ccs_put_name_union(&e.name);
 	ccs_put_number_union(&e.number);
Index: environ.c
===================================================================
--- environ.c	(revision 3685)
+++ environ.c	(working copy)
@@ -30,9 +30,6 @@
 				   env);
 }
 
-/* The list for "struct ccs_globally_usable_env_entry". */
-LIST_HEAD(ccs_globally_usable_env_list);
-
 /**
  * ccs_is_globally_usable_env - Check whether the given environment variable is acceptable for all domains.
  *
@@ -47,8 +44,9 @@
 {
 	struct ccs_globally_usable_env_entry *ptr;
 	bool found = false;
-	list_for_each_entry_rcu(ptr, &ccs_globally_usable_env_list, list) {
-		if (ptr->is_deleted ||
+	list_for_each_entry_rcu(ptr, &ccs_policy_list[CCS_ID_GLOBAL_ENV],
+				head.list) {
+		if (ptr->head.is_deleted ||
 		    !ccs_path_matches_pattern(env, ptr->env))
 			continue;
 		found = true;
@@ -57,6 +55,14 @@
 	return found;
 }
 
+static bool ccs_is_same_global_env(const struct ccs_acl_head *a,
+				   const struct ccs_acl_head *b)
+{
+	return container_of(a, struct ccs_globally_usable_env_entry, head)->env
+		== container_of(b, struct ccs_globally_usable_env_entry, head)
+		->env;
+}
+
 /**
  * ccs_write_globally_usable_env_policy - Write "struct ccs_globally_usable_env_entry" list.
  *
@@ -68,66 +74,19 @@
 int ccs_write_globally_usable_env_policy(char *data, const bool is_delete)
 {
 	struct ccs_globally_usable_env_entry e = { };
-	struct ccs_globally_usable_env_entry *ptr;
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_is_correct_path(data, 0, 0, 0) || strchr(data, '='))
 		return -EINVAL;
 	e.env = ccs_get_name(data);
 	if (!e.env)
 		return error;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &ccs_globally_usable_env_list, list) {
-		if (ptr->env != e.env)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_globally_usable_env_entry *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &ccs_globally_usable_env_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
+	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
+				  CCS_ID_GLOBAL_ENV, ccs_is_same_global_env);
 	ccs_put_name(e.env);
 	return error;
 }
 
 /**
- * ccs_read_globally_usable_env_policy - Read "struct ccs_globally_usable_env_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0 on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_globally_usable_env_list) {
-		struct ccs_globally_usable_env_entry *ptr;
-		ptr = list_entry(pos, struct ccs_globally_usable_env_entry,
-				 list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_ENV "%s\n",
-				     ptr->env->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
  * ccs_env_acl - Check permission for environment variable's name.
  *
  * @r:       Pointer to "struct ccs_request_info".
@@ -188,6 +147,15 @@
 	return error;
 }
 
+static bool ccs_is_same_env_entry(const struct ccs_acl_info *a,
+				  const struct ccs_acl_info *b)
+{
+	const struct ccs_env_acl *p1 = container_of(a, typeof(*p1), head);
+	const struct ccs_env_acl *p2 = container_of(b, typeof(*p2), head);
+	return p1->head.type == p2->head.type && p1->head.cond == p2->head.cond
+		&& p1->head.type == CCS_TYPE_ENV_ACL && p1->env == p2->env;
+}
+
 /**
  * ccs_write_env_policy - Write "struct ccs_env_acl" list.
  *
@@ -202,7 +170,6 @@
 			 struct ccs_condition *condition,
 			 const bool is_delete)
 {
-	struct ccs_acl_info *ptr;
 	struct ccs_env_acl e = {
 		.head.type = CCS_TYPE_ENV_ACL,
 		.head.cond = condition
@@ -213,27 +180,8 @@
 	e.env = ccs_get_name(data);
 	if (!e.env)
 		return error;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_env_acl *acl =
-			container_of(ptr, struct ccs_env_acl, head);
-		if (ptr->type != CCS_TYPE_ENV_ACL || ptr->cond != condition ||
-		    acl->env != e.env)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_env_acl *entry = ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			ccs_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
+	error = ccs_update_domain_policy(&e.head, sizeof(e), is_delete, domain,
+					 ccs_is_same_env_entry, NULL);
 	ccs_put_name(e.env);
 	return error;
 }
Index: internal.h
===================================================================
--- internal.h	(revision 3685)
+++ internal.h	(working copy)
@@ -365,62 +365,67 @@
 	     (cookie) = pos, pos = srcu_dereference(pos->next, &ccs_ss))
 #endif
 
+enum ccs_shared_acl_id {
+	CCS_NAME_LIST,
+	CCS_CONDITION_LIST,
+	CCS_IPV6ADDRESS_LIST,
+	CCS_MAX_LIST
+};
+
+struct ccs_shared_acl_head {
+	struct list_head list;
+	atomic_t users;
+} __attribute__((__packed__));
+
+/* Structure for "path_group"/"number_group"/"address_group" directive. */
+struct ccs_group {
+	struct ccs_shared_acl_head head;
+	const struct ccs_path_info *group_name;
+	struct list_head member_list;
+};
+
 struct ccs_name_union {
 	const struct ccs_path_info *filename;
-	struct ccs_path_group *group;
+	struct ccs_group *group;
 	u8 is_group;
 };
 
 struct ccs_number_union {
 	unsigned long values[2];
-	struct ccs_number_group *group;
+	struct ccs_group *group;
 	u8 min_type;
 	u8 max_type;
 	u8 is_group;
 };
 
-/* Structure for "path_group" directive. */
-struct ccs_path_group {
-	struct list_head list;
-	const struct ccs_path_info *group_name;
-	struct list_head member_list;
-	atomic_t users;
+enum ccs_group_id {
+	CCS_PATH_GROUP,
+	CCS_NUMBER_GROUP,
+	CCS_ADDRESS_GROUP,
+	CCS_MAX_GROUP
 };
 
-/* Structure for "number_group" directive. */
-struct ccs_number_group {
+/* Common header for holding ACL entries. */
+struct ccs_acl_head {
 	struct list_head list;
-	const struct ccs_path_info *group_name;
-	struct list_head member_list;
-	atomic_t users;
-};
+	bool is_deleted;
+} __attribute__((__packed__));
 
-/* Structure for "address_group" directive. */
-struct ccs_address_group {
-	struct list_head list;
-	const struct ccs_path_info *group_name;
-	struct list_head member_list;
-	atomic_t users;
-};
-
 /* Structure for "path_group" directive. */
-struct ccs_path_group_member {
-	struct list_head list;
-	bool is_deleted;
+struct ccs_path_group {
+	struct ccs_acl_head head;
 	const struct ccs_path_info *member_name;
 };
 
 /* Structure for "number_group" directive. */
-struct ccs_number_group_member {
-	struct list_head list;
-	bool is_deleted;
+struct ccs_number_group {
+	struct ccs_acl_head head;
 	struct ccs_number_union number;
 };
 
 /* Structure for "address_group" directive. */
-struct ccs_address_group_member {
-	struct list_head list;
-	bool is_deleted;
+struct ccs_address_group {
+	struct ccs_acl_head head;
 	bool is_ipv6;
 	union {
 		u32 ipv4;                    /* Host byte order    */
@@ -428,7 +433,6 @@
 	} min, max;
 };
 
-
 /* Subset of "struct stat". */
 struct ccs_mini_stat {
 	uid_t uid;
@@ -482,8 +486,7 @@
 
 /* Structure for " if " and "; set" part. */
 struct ccs_condition {
-	struct list_head list;
-	atomic_t users;
+	struct ccs_shared_acl_head head;
 	u32 size;
 	u16 condc;
 	u16 numbers_count;
@@ -606,36 +609,31 @@
 
 /* Structure for "allow_read" keyword. */
 struct ccs_globally_readable_file_entry {
-	struct list_head list;
-	bool is_deleted;
+	struct ccs_acl_head head;
 	const struct ccs_path_info *filename;
 };
 
 /* Structure for "file_pattern" keyword. */
 struct ccs_pattern_entry {
-	struct list_head list;
-	bool is_deleted;
+	struct ccs_acl_head head;
 	const struct ccs_path_info *pattern;
 };
 
 /* Structure for "deny_rewrite" keyword. */
 struct ccs_no_rewrite_entry {
-	struct list_head list;
-	bool is_deleted;
+	struct ccs_acl_head head;
 	const struct ccs_path_info *pattern;
 };
 
 /* Structure for "allow_env" keyword. */
 struct ccs_globally_usable_env_entry {
-	struct list_head list;
-	bool is_deleted;
+	struct ccs_acl_head head;
 	const struct ccs_path_info *env;
 };
 
 /* Structure for "initialize_domain" and "no_initialize_domain" keyword. */
 struct ccs_domain_initializer_entry {
-	struct list_head list;
-	bool is_deleted;
+	struct ccs_acl_head head;
 	bool is_not;       /* True if this entry is "no_initialize_domain". */
 	bool is_last_name; /* True if the domainname is ccs_last_word(). */
 	const struct ccs_path_info *domainname;    /* This may be NULL */
@@ -644,8 +642,7 @@
 
 /* Structure for "keep_domain" and "no_keep_domain" keyword. */
 struct ccs_domain_keeper_entry {
-	struct list_head list;
-	bool is_deleted;
+	struct ccs_acl_head head;
 	bool is_not;       /* True if this entry is "no_keep_domain". */
 	bool is_last_name; /* True if the domainname is ccs_last_word(). */
 	const struct ccs_path_info *domainname;
@@ -654,8 +651,7 @@
 
 /* Structure for "aggregator" keyword. */
 struct ccs_aggregator_entry {
-	struct list_head list;
-	bool is_deleted;
+	struct ccs_acl_head head;
 	const struct ccs_path_info *original_name;
 	const struct ccs_path_info *aggregated_name;
 };
@@ -671,16 +667,14 @@
 
 /* Structure for "deny_autobind" keyword. */
 struct ccs_reserved_entry {
-	struct list_head list;
-	bool is_deleted;             /* Delete flag.                         */
+	struct ccs_acl_head head;
 	u16 min_port;                /* Start of port number range.          */
 	u16 max_port;                /* End of port number range.            */
 };
 
 /* Structure for policy manager. */
 struct ccs_policy_manager_entry {
-	struct list_head list;
-	bool is_deleted; /* True if this entry is deleted. */
+	struct ccs_acl_head head;
 	bool is_domain;  /* True if manager is a domainname. */
 	/* A path to program or a domainname. */
 	const struct ccs_path_info *manager;
@@ -787,8 +781,7 @@
 };
 
 struct ccs_ipv6addr_entry {
-	struct list_head list;
-	atomic_t users;
+	struct ccs_shared_acl_head head;
 	struct in6_addr addr;
 };
 
@@ -820,15 +813,14 @@
 			const struct in6_addr *max;
 		} ipv6;
 		/* Pointer to address group. */
-		struct ccs_address_group *group;
+		struct ccs_group *group;
 	} address;
 	struct ccs_number_union port;
 };
 
 /* Structure for string data. */
 struct ccs_name_entry {
-	struct list_head list;
-	atomic_t users;
+	struct ccs_shared_acl_head head;
 	int size;
 	struct ccs_path_info entry;
 };
@@ -906,7 +898,7 @@
 /* Prototype definition for internal use. */
 
 bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
-			       const struct ccs_address_group *group);
+			       const struct ccs_group *group);
 bool ccs_compare_name_union(const struct ccs_path_info *name,
 			    const struct ccs_name_union *ptr);
 bool ccs_compare_number_union(const unsigned long value,
@@ -924,29 +916,34 @@
 bool ccs_is_domain_def(const unsigned char *buffer);
 bool ccs_memory_ok(const void *ptr, const unsigned int size);
 bool ccs_number_matches_group(const unsigned long min, const unsigned long max,
-			      const struct ccs_number_group *group);
+			      const struct ccs_group *group);
 bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr);
 bool ccs_parse_number_union(char *data, struct ccs_number_union *num);
 bool ccs_path_matches_group(const struct ccs_path_info *pathname,
-			    const struct ccs_path_group *group,
+			    const struct ccs_group *group,
 			    const bool may_use_pattern);
 bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 			      const struct ccs_path_info *pattern);
 bool ccs_print_number_union(struct ccs_io_buffer *head,
 			    const struct ccs_number_union *ptr);
-bool ccs_read_address_group_policy(struct ccs_io_buffer *head);
-bool ccs_read_aggregator_policy(struct ccs_io_buffer *head);
-bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head);
-bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head);
-bool ccs_read_file_pattern(struct ccs_io_buffer *head);
-bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head);
-bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head);
-bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head);
-bool ccs_read_number_group_policy(struct ccs_io_buffer *head);
-bool ccs_read_path_group_policy(struct ccs_io_buffer *head);
-bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head);
 bool ccs_str_starts(char **src, const char *find);
 bool ccs_tokenize(char *buffer, char *w[], size_t size);
+int ccs_update_domain_policy(struct ccs_acl_info *new_entry, const int size,
+			     bool is_delete, struct ccs_domain_info *domain,
+			     bool (*check_duplicate)
+			     (const struct ccs_acl_info *,
+			      const struct ccs_acl_info *),
+			     bool (*merge_duplicate) (struct ccs_acl_info *,
+						      struct ccs_acl_info *,
+						      const bool));
+int ccs_update_group(struct ccs_acl_head *new_entry, const int size,
+		     bool is_delete, struct ccs_group *group,
+		     bool (*check_duplicate) (const struct ccs_acl_head *,
+					      const struct ccs_acl_head *));
+int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
+		      bool is_delete, const int idx, bool (*check_duplicate)
+		      (const struct ccs_acl_head *,
+		       const struct ccs_acl_head *));
 char *ccs_encode(const char *str);
 char *ccs_init_audit_log(int *len, struct ccs_request_info *r);
 char *ccs_realpath_from_path(struct path *path);
@@ -1019,14 +1016,12 @@
 int ccs_write_signal_policy(char *data, struct ccs_domain_info *domain,
 			    struct ccs_condition *condition,
 			    const bool is_delete);
-size_t ccs_del_condition(struct ccs_condition *cond);
-struct ccs_address_group *ccs_get_address_group(const char *group_name);
+size_t ccs_del_condition(struct list_head *element);
 struct ccs_condition *ccs_get_condition(char * const condition);
 struct ccs_domain_info *ccs_find_domain(const char *domainname);
 struct ccs_domain_info *ccs_find_or_assign_new_domain(const char *domainname,
 						      const u8 profile);
-struct ccs_number_group *ccs_get_number_group(const char *group_name);
-struct ccs_path_group *ccs_get_path_group(const char *group_name);
+struct ccs_group *ccs_get_group(const char *group_name, const u8 idx);
 struct ccs_profile *ccs_profile(const u8 profile);
 u8 ccs_parse_ulong(unsigned long *result, char **str);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
@@ -1076,134 +1071,41 @@
 		p1->max_type == p2->max_type && p1->is_group == p2->is_group;
 }
 
-static inline bool ccs_is_same_path_acl(const struct ccs_path_acl *p1,
-					const struct ccs_path_acl *p2)
-{
-	return ccs_is_same_acl_head(&p1->head, &p2->head) &&
-		ccs_is_same_name_union(&p1->name, &p2->name);
-}
-
-static inline bool ccs_is_same_path_number3_acl
-(const struct ccs_path_number3_acl *p1,
- const struct ccs_path_number3_acl *p2)
-{
-	return ccs_is_same_acl_head(&p1->head, &p2->head)
-		&& ccs_is_same_name_union(&p1->name, &p2->name)
-		&& ccs_is_same_number_union(&p1->mode, &p2->mode)
-		&& ccs_is_same_number_union(&p1->major, &p2->major)
-		&& ccs_is_same_number_union(&p1->minor, &p2->minor);
-}
-
-static inline bool ccs_is_same_path2_acl(const struct ccs_path2_acl *p1,
-					 const struct ccs_path2_acl *p2)
-{
-	return ccs_is_same_acl_head(&p1->head, &p2->head)
-		&& ccs_is_same_name_union(&p1->name1, &p2->name1)
-		&& ccs_is_same_name_union(&p1->name2, &p2->name2);
-}
-
-static inline bool ccs_is_same_path_number_acl
-(const struct ccs_path_number_acl *p1, const struct ccs_path_number_acl *p2)
-{
-	return ccs_is_same_acl_head(&p1->head, &p2->head)
-		&& ccs_is_same_name_union(&p1->name, &p2->name)
-		&& ccs_is_same_number_union(&p1->number, &p2->number);
-}
-
-static inline bool ccs_is_same_mount_acl(const struct ccs_mount_acl *p1,
-					 const struct ccs_mount_acl *p2)
-{
-	return ccs_is_same_acl_head(&p1->head, &p2->head) &&
-		ccs_is_same_name_union(&p1->dev_name, &p2->dev_name) &&
-		ccs_is_same_name_union(&p1->dir_name, &p2->dir_name) &&
-		ccs_is_same_name_union(&p1->fs_type, &p2->fs_type) &&
-		ccs_is_same_number_union(&p1->flags, &p2->flags);
-}
-
-static inline bool ccs_is_same_ip_network_acl
-(const struct ccs_ip_network_acl *p1, const struct ccs_ip_network_acl *p2)
-{
-	return ccs_is_same_acl_head(&p1->head, &p2->head)
-		&& p1->address_type == p2->address_type &&
-		p1->address.ipv4.min == p2->address.ipv4.min &&
-		p1->address.ipv6.min == p2->address.ipv6.min &&
-		p1->address.ipv4.max == p2->address.ipv4.max &&
-		p1->address.ipv6.max == p2->address.ipv6.max &&
-		p1->address.group == p2->address.group &&
-		ccs_is_same_number_union(&p1->port, &p2->port);
-}
-
-static inline bool ccs_is_same_address_group_member
-(const struct ccs_address_group_member *p1,
- const struct ccs_address_group_member *p2)
-{
-	return p1->is_ipv6 == p2->is_ipv6 &&
-		p1->min.ipv4 == p2->min.ipv4 && p1->min.ipv6 == p2->min.ipv6 &&
-		p1->max.ipv4 == p2->max.ipv4 && p1->max.ipv6 == p2->max.ipv6;
-}
-
-static inline bool ccs_is_same_domain_initializer_entry
-(const struct ccs_domain_initializer_entry *p1,
- const struct ccs_domain_initializer_entry *p2)
-{
-	return p1->is_not == p2->is_not && p1->is_last_name == p2->is_last_name
-		&& p1->domainname == p2->domainname
-		&& p1->program == p2->program;
-}
-
-static inline bool ccs_is_same_domain_keeper_entry
-(const struct ccs_domain_keeper_entry *p1,
- const struct ccs_domain_keeper_entry *p2)
-{
-	return p1->is_not == p2->is_not && p1->is_last_name == p2->is_last_name
-		&& p1->domainname == p2->domainname
-		&& p1->program == p2->program;
-}
-
-static inline bool ccs_is_same_aggregator_entry
-(const struct ccs_aggregator_entry *p1,
- const struct ccs_aggregator_entry *p2)
-{
-	return p1->original_name == p2->original_name &&
-		p1->aggregated_name == p2->aggregated_name;
-}
-
-static inline bool ccs_is_same_condition(const struct ccs_condition *p1,
-					 const struct ccs_condition *p2)
-{
-	return p1->size == p2->size && p1->condc == p2->condc &&
-		p1->numbers_count == p2->numbers_count &&
-		p1->names_count == p2->names_count &&
-		p1->argc == p2->argc && p1->envc == p2->envc &&
-		p1->post_state[0] == p2->post_state[0] &&
-		p1->post_state[1] == p2->post_state[1] &&
-		p1->post_state[2] == p2->post_state[2] &&
-		p1->post_state[3] == p2->post_state[3] &&
-		!memcmp(p1 + 1, p2 + 1, p1->size - sizeof(*p1));
-}
-
 #define CCS_HASH_BITS 8
 #define CCS_MAX_HASH (1 << CCS_HASH_BITS)
 
+/* Index numbers for garbage collection. */
+enum ccs_gc_id {
+	CCS_ID_RESERVEDPORT,
+	CCS_ID_GROUP,
+	CCS_ID_ADDRESS_GROUP,
+	CCS_ID_PATH_GROUP,
+	CCS_ID_NUMBER_GROUP,
+	CCS_ID_GLOBAL_ENV,
+	CCS_ID_AGGREGATOR,
+	CCS_ID_DOMAIN_INITIALIZER,
+	CCS_ID_DOMAIN_KEEPER,
+	CCS_ID_GLOBALLY_READABLE,
+	CCS_ID_PATTERN,
+	CCS_ID_NO_REWRITE,
+	CCS_ID_MANAGER,
+	CCS_ID_IPV6_ADDRESS,
+	CCS_ID_CONDITION,
+	CCS_ID_NAME,
+	CCS_ID_ACL,
+	CCS_ID_DOMAIN,
+	CCS_MAX_POLICY
+};
+
 extern struct mutex ccs_policy_lock;
 extern struct list_head ccs_domain_list;
-extern struct list_head ccs_address_group_list;
-extern struct list_head ccs_globally_readable_list;
-extern struct list_head ccs_path_group_list;
-extern struct list_head ccs_number_group_list;
-extern struct list_head ccs_pattern_list;
-extern struct list_head ccs_no_rewrite_list;
-extern struct list_head ccs_globally_usable_env_list;
-extern struct list_head ccs_domain_initializer_list;
-extern struct list_head ccs_domain_keeper_list;
-extern struct list_head ccs_aggregator_list;
-extern struct list_head ccs_reservedport_list;
-extern struct list_head ccs_policy_manager_list;
-extern struct list_head ccs_address_list;
-extern struct list_head ccs_condition_list;
+extern struct list_head ccs_policy_list[CCS_MAX_POLICY];
+extern struct list_head ccs_group_list[CCS_MAX_GROUP];
+extern struct list_head ccs_shared_list[CCS_MAX_LIST];
 extern struct list_head ccs_name_list[CCS_MAX_HASH];
 extern bool ccs_policy_loaded;
 extern struct ccs_domain_info ccs_kernel_domain;
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
 extern struct srcu_struct ccs_ss;
 
@@ -1317,7 +1219,7 @@
 				      struct ccs_acl_info *acl)
 {
 	if (acl->cond)
-		atomic_inc(&acl->cond->users);
+		atomic_inc(&acl->cond->head.users);
 	list_add_tail_rcu(&acl->list, &domain->acl_info_list);
 }
 
@@ -1342,22 +1244,25 @@
 }
 #endif
 
-static inline void ccs_put_path_group(struct ccs_path_group *group)
+static inline struct ccs_group *ccs_get_path_group(const char *group_name)
 {
-	if (group)
-		atomic_dec(&group->users);
+	return ccs_get_group(group_name, CCS_PATH_GROUP);
 }
 
-static inline void ccs_put_number_group(struct ccs_number_group *group)
+static inline struct ccs_group *ccs_get_number_group(const char *group_name)
 {
-	if (group)
-		atomic_dec(&group->users);
+	return ccs_get_group(group_name, CCS_NUMBER_GROUP);
 }
 
-static inline void ccs_put_address_group(struct ccs_address_group *group)
+static inline struct ccs_group *ccs_get_address_group(const char *group_name)
 {
+	return ccs_get_group(group_name, CCS_ADDRESS_GROUP);
+}
+
+static inline void ccs_put_group(struct ccs_group *group)
+{
 	if (group)
-		atomic_dec(&group->users);
+		atomic_dec(&group->head.users);
 }
 
 static inline void ccs_put_ipv6_address(const struct in6_addr *addr)
@@ -1365,14 +1270,14 @@
 	if (addr) {
 		struct ccs_ipv6addr_entry *ptr =
 			container_of(addr, struct ccs_ipv6addr_entry, addr);
-		atomic_dec(&ptr->users);
+		atomic_dec(&ptr->head.users);
 	}
 }
 
 static inline void ccs_put_condition(struct ccs_condition *cond)
 {
 	if (cond)
-		atomic_dec(&cond->users);
+		atomic_dec(&cond->head.users);
 }
 
 static inline void ccs_put_name(const struct ccs_path_info *name)
@@ -1380,7 +1285,7 @@
 	if (name) {
 		struct ccs_name_entry *ptr =
 			container_of(name, struct ccs_name_entry, entry);
-		atomic_dec(&ptr->users);
+		atomic_dec(&ptr->head.users);
 	}
 }
 
Index: capability.c
===================================================================
--- capability.c	(revision 3685)
+++ capability.c	(working copy)
@@ -93,6 +93,18 @@
 	return !__ccs_capable(CCS_SYS_PTRACE);
 }
 
+static bool ccs_is_same_capability_entry(const struct ccs_acl_info *a,
+					 const struct ccs_acl_info *b)
+{
+	const struct ccs_capability_acl *p1 = container_of(a, typeof(*p1),
+							   head);
+	const struct ccs_capability_acl *p2 = container_of(b, typeof(*p2),
+							   head);
+	return p1->head.type == p2->head.type && p1->head.cond == p2->head.cond
+		&& p1->head.type == CCS_TYPE_CAPABILITY_ACL
+		&& p1->operation == p2->operation;
+}
+
 /**
  * ccs_write_capability_policy - Write "struct ccs_capability_acl" list.
  *
@@ -111,8 +123,6 @@
 		.head.type = CCS_TYPE_CAPABILITY_ACL,
 		.head.cond = condition,
 	};
-	struct ccs_acl_info *ptr;
-	int error = is_delete ? -ENOENT : -ENOMEM;
 	u8 capability;
 	for (capability = 0; capability < CCS_MAX_CAPABILITY_INDEX;
 	     capability++) {
@@ -123,28 +133,8 @@
 	if (capability == CCS_MAX_CAPABILITY_INDEX)
 		return -EINVAL;
 	e.operation = capability;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		return error;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_capability_acl *acl =
-			container_of(ptr, struct ccs_capability_acl, head);
-		if (ptr->type != CCS_TYPE_CAPABILITY_ACL ||
-		    ptr->cond != condition || acl->operation != capability)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_capability_acl *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			ccs_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
-	return error;
+	return ccs_update_domain_policy(&e.head, sizeof(e), is_delete, domain,
+					ccs_is_same_capability_entry, NULL);
 }
 
 void __init ccs_capability_init(void)
Index: proc_if.c
===================================================================
--- proc_if.c	(revision 3685)
+++ proc_if.c	(working copy)
@@ -305,6 +305,13 @@
 
 static int __init ccs_init_module(void)
 {
+	int i;
+	for (i = 0; i < CCS_MAX_POLICY; i++)
+		INIT_LIST_HEAD(&ccs_policy_list[i]);
+	for (i = 0; i < CCS_MAX_GROUP; i++)
+		INIT_LIST_HEAD(&ccs_group_list[i]);
+	for (i = 0; i < CCS_MAX_LIST; i++)
+		INIT_LIST_HEAD(&ccs_shared_list[i]);
 	if (ccsecurity_ops.disabled)
 		return -EINVAL;
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 0)
Index: condition.c
===================================================================
--- condition.c	(revision 3685)
+++ condition.c	(working copy)
@@ -398,9 +398,6 @@
 	return false;
 }
 
-/* The list for "struct ccs_condition". */
-LIST_HEAD(ccs_condition_list);
-
 const char *ccs_condition_keyword[CCS_MAX_CONDITION_KEYWORD] = {
 	[CCS_TASK_UID]             = "task.uid",
 	[CCS_TASK_EUID]            = "task.euid",
@@ -511,6 +508,20 @@
 	return false;
 }
 
+static inline bool ccs_is_same_condition(const struct ccs_condition *p1,
+					 const struct ccs_condition *p2)
+{
+	return p1->size == p2->size && p1->condc == p2->condc &&
+		p1->numbers_count == p2->numbers_count &&
+		p1->names_count == p2->names_count &&
+		p1->argc == p2->argc && p1->envc == p2->envc &&
+		p1->post_state[0] == p2->post_state[0] &&
+		p1->post_state[1] == p2->post_state[1] &&
+		p1->post_state[2] == p2->post_state[2] &&
+		p1->post_state[3] == p2->post_state[3] &&
+		!memcmp(p1 + 1, p2 + 1, p1->size - sizeof(*p1));
+}
+
 /**
  * ccs_get_condition - Parse condition part.
  *
@@ -628,7 +639,7 @@
 	entry = kzalloc(size, CCS_GFP_FLAGS);
 	if (!entry)
 		return NULL;
-	INIT_LIST_HEAD(&entry->list);
+	INIT_LIST_HEAD(&entry->head.list);
 	for (i = 0; i < 4; i++)
 		entry->post_state[i] = post_state[i];
 	entry->condc = condc;
@@ -767,18 +778,20 @@
 	entry->size = size;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list_for_each_entry_rcu(ptr, &ccs_condition_list, list) {
+	list_for_each_entry_rcu(ptr, &ccs_shared_list[CCS_CONDITION_LIST],
+				head.list) {
 		if (!ccs_is_same_condition(ptr, entry))
 			continue;
 		/* Same entry found. Share this entry. */
-		atomic_inc(&ptr->users);
+		atomic_inc(&ptr->head.users);
 		found = true;
 		break;
 	}
 	if (!found) {
 		if (ccs_memory_ok(entry, size)) {
-			atomic_set(&entry->users, 1);
-			list_add_rcu(&entry->list, &ccs_condition_list);
+			atomic_set(&entry->head.users, 1);
+			list_add_rcu(&entry->head.list,
+				     &ccs_shared_list[CCS_CONDITION_LIST]);
 		} else {
 			found = true;
 			ptr = NULL;
@@ -786,7 +799,7 @@
 	}
 	mutex_unlock(&ccs_policy_lock);
 	if (found) {
-		ccs_del_condition(entry);
+		ccs_del_condition(&entry->head.list);
 		kfree(entry);
 		entry = ptr;
 	}
@@ -795,7 +808,7 @@
 	if (debug)
 		printk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);
 	if (entry) {
-		ccs_del_condition(entry);
+		ccs_del_condition(&entry->head.list);
 		kfree(entry);
 	}
 	return NULL;
Index: policy_io.c
===================================================================
--- policy_io.c	(revision 3685)
+++ policy_io.c	(working copy)
@@ -660,8 +660,13 @@
 		head->read_eof = true;
 }
 
-/* The list for "struct ccs_policy_manager_entry". */
-LIST_HEAD(ccs_policy_manager_list);
+static bool ccs_is_same_manager_entry(const struct ccs_acl_head *a,
+				      const struct ccs_acl_head *b)
+{
+	return container_of(a, struct ccs_policy_manager_entry, head)->manager
+		== container_of(b, struct ccs_policy_manager_entry, head)
+		->manager;
+}
 
 /**
  * ccs_update_manager_entry - Add a manager entry.
@@ -673,7 +678,6 @@
  */
 static int ccs_update_manager_entry(const char *manager, const bool is_delete)
 {
-	struct ccs_policy_manager_entry *ptr;
 	struct ccs_policy_manager_entry e = { };
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (ccs_is_domain_def(manager)) {
@@ -686,27 +690,9 @@
 	}
 	e.manager = ccs_get_name(manager);
 	if (!e.manager)
-		return -ENOMEM;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &ccs_policy_manager_list, list) {
-		if (ptr->manager != e.manager)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_policy_manager_entry *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &ccs_policy_manager_list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
+		return error;
+	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
+				  CCS_ID_MANAGER, ccs_is_same_manager_entry);
 	ccs_put_name(e.manager);
 	return error;
 }
@@ -741,10 +727,12 @@
 	struct list_head *pos;
 	if (head->read_eof)
 		return;
-	list_for_each_cookie(pos, head->read_var2, &ccs_policy_manager_list) {
+	list_for_each_cookie(pos, head->read_var2,
+			     &ccs_policy_list[CCS_ID_MANAGER]) {
 		struct ccs_policy_manager_entry *ptr;
-		ptr = list_entry(pos, struct ccs_policy_manager_entry, list);
-		if (ptr->is_deleted)
+		ptr = list_entry(pos, struct ccs_policy_manager_entry,
+				 head.list);
+		if (ptr->head.is_deleted)
 			continue;
 		if (!ccs_io_printf(head, "%s\n", ptr->manager->name))
 			return;
@@ -774,8 +762,9 @@
 		return true;
 	if (!ccs_manage_by_non_root && (current_uid() || current_euid()))
 		return false;
-	list_for_each_entry_rcu(ptr, &ccs_policy_manager_list, list) {
-		if (!ptr->is_deleted && ptr->is_domain
+	list_for_each_entry_rcu(ptr, &ccs_policy_list[CCS_ID_MANAGER],
+				head.list) {
+		if (!ptr->head.is_deleted && ptr->is_domain
 		    && !ccs_pathcmp(domainname, ptr->manager)) {
 			/* Set manager flag. */
 			task->ccs_flags |= CCS_TASK_IS_POLICY_MANAGER;
@@ -785,8 +774,9 @@
 	exe = ccs_get_exe();
 	if (!exe)
 		return false;
-	list_for_each_entry_rcu(ptr, &ccs_policy_manager_list, list) {
-		if (!ptr->is_deleted && !ptr->is_domain
+	list_for_each_entry_rcu(ptr, &ccs_policy_list[CCS_ID_MANAGER],
+				head.list) {
+		if (!ptr->head.is_deleted && !ptr->is_domain
 		    && !strcmp(exe, ptr->manager->name)) {
 			found = true;
 			/* Set manager flag. */
@@ -1901,80 +1891,234 @@
 }
 
 /**
- * ccs_read_exception_policy - Read exception policy.
+ * ccs_read_group - Read "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group" list.
  *
  * @head: Pointer to "struct ccs_io_buffer".
+ * @idx:  Index number.
  *
+ * Returns true on success, false otherwise.
+ *
  * Caller holds ccs_read_lock().
  */
-static void ccs_read_exception_policy(struct ccs_io_buffer *head)
+static bool ccs_read_group(struct ccs_io_buffer *head, const int idx)
 {
-	if (head->read_eof)
-		return;
-	switch (head->read_step) {
-	case 0:
-		head->read_var2 = NULL;
-		head->read_step = 1;
-	case 1:
-		if (!ccs_read_domain_keeper_policy(head))
+	struct list_head *gpos;
+	struct list_head *mpos;
+	list_for_each_cookie(gpos, head->read_var1, &ccs_group_list[idx]) {
+		struct ccs_group *group =
+			list_entry(gpos, struct ccs_group, head.list);
+		const char *name = group->group_name->name;
+		list_for_each_cookie(mpos, head->read_var2,
+				     &group->member_list) {
+			struct ccs_acl_head *ptr =
+				list_entry(mpos, struct ccs_acl_head, list);
+			if (ptr->is_deleted)
+				continue;
+			if (idx == CCS_PATH_GROUP) {
+				struct ccs_path_group *member =
+					container_of(ptr, typeof(*member),
+						     head);
+				if (!ccs_io_printf(head, CCS_KEYWORD_PATH_GROUP
+						   "%s %s\n", name,
+						   member->member_name->name))
+					return false;
+			} else if (idx == CCS_NUMBER_GROUP) {
+				const int pos = head->read_avail;
+				const struct ccs_number_group *member =
+					container_of(ptr, typeof(*member),
+						     head);
+				if (!ccs_io_printf(head,
+						   CCS_KEYWORD_NUMBER_GROUP
+						   "%s", name) ||
+				    !ccs_print_number_union(head,
+							    &member->number) ||
+				    !ccs_io_printf(head, "\n")) {
+					head->read_avail = pos;
+					return false;
+				}
+			} else if (idx == CCS_ADDRESS_GROUP) {
+				char buf[128];
+				struct ccs_address_group *member =
+					container_of(ptr, typeof(*member),
+						     head);
+				if (member->is_ipv6) {
+					const struct in6_addr *min_address
+						= member->min.ipv6;
+					const struct in6_addr *max_address
+						= member->max.ipv6;
+					ccs_print_ipv6(buf, sizeof(buf),
+						       min_address);
+					if (min_address != max_address) {
+						int len;
+						char *cp = buf + strlen(buf);
+						*cp++ = '-';
+						len = strlen(buf);
+						ccs_print_ipv6(cp, sizeof(buf)
+							       - len,
+							       max_address);
+					}
+				} else {
+					const u32 min_address
+						= member->min.ipv4;
+					const u32 max_address
+						= member->max.ipv4;
+					memset(buf, 0, sizeof(buf));
+					snprintf(buf, sizeof(buf) - 1,
+						 "%u.%u.%u.%u",
+						 HIPQUAD(min_address));
+					if (min_address != max_address) {
+						const int len = strlen(buf);
+						snprintf(buf + len,
+							 sizeof(buf) - 1 - len,
+							 "-%u.%u.%u.%u",
+							 HIPQUAD(max_address));
+					}
+				}
+				if (!ccs_io_printf(head,
+						   CCS_KEYWORD_ADDRESS_GROUP
+						   "%s %s\n", name, buf))
+					return false;
+			}
+		}
+	}
+	return true;
+}
+
+/**
+ * ccs_read_policy - Read "struct ccs_..._entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @idx:  Index number.
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_policy(struct ccs_io_buffer *head, const int idx)
+{
+	struct list_head *pos;
+	list_for_each_cookie(pos, head->read_var2, &ccs_policy_list[idx]) {
+		const char *w[4] = { "", "", "", "" };
+		char buffer[16];
+		struct ccs_acl_head *acl = container_of(pos, typeof(*acl),
+							list);
+		if (acl->is_deleted)
+			continue;
+		switch (idx) {
+		case CCS_ID_DOMAIN_KEEPER:
+			{
+				struct ccs_domain_keeper_entry *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = ptr->is_not ?
+					"no_" CCS_KEYWORD_KEEP_DOMAIN :
+					CCS_KEYWORD_KEEP_DOMAIN;
+				if (ptr->program) {
+					w[1] = ptr->program->name;
+					w[2] = " from ";
+				}
+				w[3] = ptr->domainname->name;
+			}
 			break;
-		head->read_var2 = NULL;
-		head->read_step = 2;
-	case 2:
-		if (!ccs_read_globally_readable_policy(head))
+		case CCS_ID_DOMAIN_INITIALIZER:
+			{
+				struct ccs_domain_initializer_entry *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = ptr->is_not ?
+					"no_" CCS_KEYWORD_INITIALIZE_DOMAIN :
+					CCS_KEYWORD_INITIALIZE_DOMAIN;
+				w[1] = ptr->program->name;
+				if (ptr->domainname) {
+					w[2] = " from ";
+					w[3] = ptr->domainname->name;
+				}
+			}
 			break;
-		head->read_var2 = NULL;
-		head->read_step = 3;
-	case 3:
-		if (!ccs_read_globally_usable_env_policy(head))
+		case CCS_ID_AGGREGATOR:
+			{
+				struct ccs_aggregator_entry *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = CCS_KEYWORD_AGGREGATOR;
+				w[1] = ptr->original_name->name;
+				w[2] = " ";
+				w[3] = ptr->aggregated_name->name;
+			}
 			break;
-		head->read_var2 = NULL;
-		head->read_step = 4;
-	case 4:
-		if (!ccs_read_domain_initializer_policy(head))
+		case CCS_ID_GLOBALLY_READABLE:
+			{
+				struct ccs_globally_readable_file_entry *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = CCS_KEYWORD_ALLOW_READ;
+				w[1] = ptr->filename->name;
+			}
 			break;
-		head->read_var2 = NULL;
-		head->read_step = 6;
-	case 6:
-		if (!ccs_read_aggregator_policy(head))
+		case CCS_ID_PATTERN:
+			{
+				struct ccs_pattern_entry *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = CCS_KEYWORD_FILE_PATTERN;
+				w[1] = ptr->pattern->name;
+			}
 			break;
-		head->read_var2 = NULL;
-		head->read_step = 7;
-	case 7:
-		if (!ccs_read_file_pattern(head))
+		case CCS_ID_NO_REWRITE:
+			{
+				struct ccs_no_rewrite_entry *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = CCS_KEYWORD_DENY_REWRITE;
+				w[1] = ptr->pattern->name;
+			}
 			break;
-		head->read_var2 = NULL;
-		head->read_step = 8;
-	case 8:
-		if (!ccs_read_no_rewrite_policy(head))
+		case CCS_ID_GLOBAL_ENV:
+			{
+				struct ccs_globally_usable_env_entry *ptr =
+					container_of(acl, typeof(*ptr), head);
+				w[0] = CCS_KEYWORD_ALLOW_ENV;
+				w[1] = ptr->env->name;
+			}
 			break;
-		head->read_var2 = NULL;
-		head->read_step = 9;
-	case 9:
-		if (!ccs_read_path_group_policy(head))
+		case CCS_ID_RESERVEDPORT:
+			{
+				struct ccs_reserved_entry *ptr =
+					container_of(acl, typeof(*ptr), head);
+				const u16 min_port = ptr->min_port;
+				const u16 max_port = ptr->max_port;
+				w[0] = CCS_KEYWORD_DENY_AUTOBIND;
+				snprintf(buffer, sizeof(buffer) - 1, "%u%c%u",
+					 min_port, min_port != max_port ?
+					 '-' : '\0', max_port);
+				buffer[sizeof(buffer) - 1] = '\0';
+				w[1] = buffer;
+			}
 			break;
-		head->read_var1 = NULL;
-		head->read_var2 = NULL;
-		head->read_step = 10;
-	case 10:
-		if (!ccs_read_number_group_policy(head))
-			break;
-		head->read_var1 = NULL;
-		head->read_var2 = NULL;
-		head->read_step = 11;
-	case 11:
-		if (!ccs_read_address_group_policy(head))
-			break;
-		head->read_var2 = NULL;
-		head->read_step = 12;
-	case 12:
-		if (!ccs_read_reserved_port_policy(head))
-			break;
-		head->read_eof = true;
+		}
+		if (!ccs_io_printf(head, "%s%s%s%s\n", w[0], w[1], w[2], w[3]))
+			return false;
 	}
+	return true;
 }
 
 /**
+ * ccs_read_exception_policy - Read exception policy.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Caller holds ccs_read_lock().
+ */
+static void ccs_read_exception_policy(struct ccs_io_buffer *head)
+{
+	if (head->read_eof)
+		return;
+	while (head->read_step < CCS_MAX_POLICY &&
+	       ccs_read_policy(head, head->read_step))
+		head->read_step++;
+	if (head->read_step < CCS_MAX_POLICY)
+		return;
+	while (head->read_step < CCS_MAX_POLICY + CCS_MAX_GROUP &&
+	       ccs_read_group(head, head->read_step - CCS_MAX_POLICY))
+		head->read_step++;
+	head->read_eof = head->read_step == CCS_MAX_POLICY + CCS_MAX_GROUP;
+}
+
+/**
  * ccs_get_argv0 - Get argv[0].
  *
  * @ee: Pointer to "struct ccs_execve_entry".
Index: gc.c
===================================================================
--- gc.c	(revision 3685)
+++ gc.c	(working copy)
@@ -16,30 +16,6 @@
 #include <linux/kthread.h>
 #endif
 
-/* Index numbers for garbage collection. */
-enum ccs_gc_id {
-	CCS_ID_RESERVEDPORT,
-	CCS_ID_ADDRESS_GROUP,
-	CCS_ID_ADDRESS_GROUP_MEMBER,
-	CCS_ID_PATH_GROUP,
-	CCS_ID_PATH_GROUP_MEMBER,
-	CCS_ID_NUMBER_GROUP,
-	CCS_ID_NUMBER_GROUP_MEMBER,
-	CCS_ID_GLOBAL_ENV,
-	CCS_ID_AGGREGATOR,
-	CCS_ID_DOMAIN_INITIALIZER,
-	CCS_ID_DOMAIN_KEEPER,
-	CCS_ID_GLOBALLY_READABLE,
-	CCS_ID_PATTERN,
-	CCS_ID_NO_REWRITE,
-	CCS_ID_MANAGER,
-	CCS_ID_IPV6_ADDRESS,
-	CCS_ID_CONDITION,
-	CCS_ID_NAME,
-	CCS_ID_ACL,
-	CCS_ID_DOMAIN
-};
-
 /* Structure for garbage collection. */
 struct ccs_gc_entry {
 	struct list_head list;
@@ -91,7 +67,7 @@
 static size_t ccs_del_allow_read(struct list_head *element)
 {
 	struct ccs_globally_readable_file_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	ccs_put_name(ptr->filename);
 	return sizeof(*ptr);
 }
@@ -106,7 +82,7 @@
 static size_t ccs_del_allow_env(struct list_head *element)
 {
 	struct ccs_globally_usable_env_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	ccs_put_name(ptr->env);
 	return sizeof(*ptr);
 }
@@ -121,7 +97,7 @@
 static size_t ccs_del_file_pattern(struct list_head *element)
 {
 	struct ccs_pattern_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	ccs_put_name(ptr->pattern);
 	return sizeof(*ptr);
 }
@@ -136,7 +112,7 @@
 static size_t ccs_del_no_rewrite(struct list_head *element)
 {
 	struct ccs_no_rewrite_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	ccs_put_name(ptr->pattern);
 	return sizeof(*ptr);
 }
@@ -151,7 +127,7 @@
 static size_t ccs_del_domain_initializer(struct list_head *element)
 {
 	struct ccs_domain_initializer_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	ccs_put_name(ptr->domainname);
 	ccs_put_name(ptr->program);
 	return sizeof(*ptr);
@@ -167,7 +143,7 @@
 static size_t ccs_del_domain_keeper(struct list_head *element)
 {
 	struct ccs_domain_keeper_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	ccs_put_name(ptr->domainname);
 	ccs_put_name(ptr->program);
 	return sizeof(*ptr);
@@ -183,7 +159,7 @@
 static size_t ccs_del_aggregator(struct list_head *element)
 {
 	struct ccs_aggregator_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	ccs_put_name(ptr->original_name);
 	ccs_put_name(ptr->aggregated_name);
 	return sizeof(*ptr);
@@ -199,7 +175,7 @@
 static size_t ccs_del_manager(struct list_head *element)
 {
 	struct ccs_policy_manager_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	ccs_put_name(ptr->manager);
 	return sizeof(*ptr);
 }
@@ -306,7 +282,7 @@
 			entry = container_of(acl, typeof(*entry), head);
 			switch (entry->address_type) {
 			case CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP:
-				ccs_put_address_group(entry->address.group);
+				ccs_put_group(entry->address.group);
 				break;
 			case CCS_IP_ADDRESS_TYPE_IPv6:
 				ccs_put_ipv6_address(entry->address.ipv6.min);
@@ -416,46 +392,46 @@
 }
 
 /**
- * ccs_del_path_group_member - Delete members in "struct ccs_path_group_member".
+ * ccs_del_path_group - Delete members in "struct ccs_path_group".
  *
  * @element: Pointer to "struct list_head".
  *
  * Returns size of @element (for later kfree()).
  */
-static size_t ccs_del_path_group_member(struct list_head *element)
+static size_t ccs_del_path_group(struct list_head *element)
 {
-	struct ccs_path_group_member *member =
-		container_of(element, typeof(*member), list);
+	struct ccs_path_group *member =
+		container_of(element, typeof(*member), head.list);
 	ccs_put_name(member->member_name);
 	return sizeof(*member);
 }
 
 /**
- * ccs_del_path_group - Delete members in "struct ccs_path_group".
+ * ccs_del_group - Delete "struct ccs_group".
  *
  * @element: Pointer to "struct list_head".
  *
  * Returns size of @element (for later kfree()).
  */
-static size_t ccs_del_path_group(struct list_head *element)
+static size_t ccs_del_group(struct list_head *element)
 {
-	struct ccs_path_group *group =
-		container_of(element, typeof(*group), list);
+	struct ccs_group *group =
+		container_of(element, typeof(*group), head.list);
 	ccs_put_name(group->group_name);
 	return sizeof(*group);
 }
 
 /**
- * ccs_del_address_group_member - Delete members in "struct ccs_address_group_member".
+ * ccs_del_address_group - Delete members in "struct ccs_address_group".
  *
  * @element: Pointer to "struct list_head".
  *
  * Returns size of @element (for later kfree()).
  */
-static size_t ccs_del_address_group_member(struct list_head *element)
+static size_t ccs_del_address_group(struct list_head *element)
 {
-	struct ccs_address_group_member *member =
-		container_of(element, typeof(*member), list);
+	struct ccs_address_group *member =
+		container_of(element, typeof(*member), head.list);
 	if (member->is_ipv6) {
 		ccs_put_ipv6_address(member->min.ipv6);
 		ccs_put_ipv6_address(member->max.ipv6);
@@ -464,35 +440,6 @@
 }
 
 /**
- * ccs_del_address_group - Delete members in "struct ccs_address_group".
- *
- * @element: Pointer to "struct list_head".
- *
- * Returns size of @element (for later kfree()).
- */
-static size_t ccs_del_address_group(struct list_head *element)
-{
-	struct ccs_address_group *group =
-		container_of(element, typeof(*group), list);
-	ccs_put_name(group->group_name);
-	return sizeof(*group);
-}
-
-/**
- * ccs_del_number_group_member - Delete members in "struct ccs_number_group_member".
- *
- * @element: Pointer to "struct list_head".
- *
- * Returns size of @element (for later kfree()).
- */
-static size_t ccs_del_number_group_member(struct list_head *element)
-{
-	struct ccs_number_group_member *member =
-		container_of(element, typeof(*member), list);
-	return sizeof(*member);
-}
-
-/**
  * ccs_del_number_group - Delete members in "struct ccs_number_group".
  *
  * @element: Pointer to "struct list_head".
@@ -501,10 +448,9 @@
  */
 static size_t ccs_del_number_group(struct list_head *element)
 {
-	struct ccs_number_group *group =
-		container_of(element, typeof(*group), list);
-	ccs_put_name(group->group_name);
-	return sizeof(*group);
+	struct ccs_number_group *member =
+		container_of(element, typeof(*member), head.list);
+	return sizeof(*member);
 }
 
 /**
@@ -517,7 +463,7 @@
 static size_t ccs_del_reservedport(struct list_head *element)
 {
 	struct ccs_reserved_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	return sizeof(*ptr);
 }
 
@@ -531,19 +477,21 @@
 static size_t ccs_del_ipv6_address(struct list_head *element)
 {
 	struct ccs_ipv6addr_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	return sizeof(*ptr);
 }
 
 /**
  * ccs_del_conditiopn - Delete members in "struct ccs_condition".
  *
- * @cond: Pointer to "struct ccs_condition".
+ * @element: Pointer to "struct list_head".
  *
- * Returns size of @cond (for later kfree()).
+ * Returns size of condition (for later kfree()).
  */
-size_t ccs_del_condition(struct ccs_condition *cond)
+size_t ccs_del_condition(struct list_head *element)
 {
+	struct ccs_condition *cond = container_of(element, typeof(*cond),
+						  head.list);
 	const u16 condc = cond->condc;
 	const u16 numbers_count = cond->numbers_count;
 	const u16 names_count = cond->names_count;
@@ -583,7 +531,7 @@
 static size_t ccs_del_name(struct list_head *element)
 {
 	const struct ccs_name_entry *ptr =
-		container_of(element, typeof(*ptr), list);
+		container_of(element, typeof(*ptr), head.list);
 	return ptr->size;
 }
 
@@ -658,6 +606,18 @@
 	}
 }
 
+static bool ccs_collect_member(struct list_head *member_list, int id)
+{
+	struct ccs_acl_head *member;
+	list_for_each_entry_rcu(member, member_list, list) {
+		if (!member->is_deleted)
+			continue;
+		if (!ccs_add_to_gc(id, &member->list))
+			return false;
+	}
+	return true;
+}
+
 /**
  * ccs_collect_entry - Scan lists for deleted elements.
  */
@@ -668,84 +628,11 @@
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return;
 	idx = ccs_read_lock();
-	{
-		struct ccs_globally_readable_file_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_globally_readable_list,
-					list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_GLOBALLY_READABLE,
-					   &ptr->list))
-				goto unlock;
-		}
+	for (i = 0; i < CCS_MAX_POLICY; i++) {
+		if (!ccs_collect_member(&ccs_policy_list[i], i))
+			goto unlock;
 	}
 	{
-		struct ccs_globally_usable_env_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_globally_usable_env_list,
-					list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_GLOBAL_ENV, &ptr->list))
-				goto unlock;
-		}
-	}
-	{
-		struct ccs_pattern_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_pattern_list, list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_PATTERN, &ptr->list))
-				goto unlock;
-		}
-	}
-	{
-		struct ccs_no_rewrite_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_no_rewrite_list, list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_NO_REWRITE, &ptr->list))
-				goto unlock;
-		}
-	}
-	{
-		struct ccs_domain_initializer_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_domain_initializer_list,
-					list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_DOMAIN_INITIALIZER,
-					   &ptr->list))
-				goto unlock;
-		}
-	}
-	{
-		struct ccs_domain_keeper_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_domain_keeper_list, list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_DOMAIN_KEEPER, &ptr->list))
-				goto unlock;
-		}
-	}
-	{
-		struct ccs_policy_manager_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_policy_manager_list, list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_MANAGER, &ptr->list))
-				goto unlock;
-		}
-	}
-	{
-		struct ccs_aggregator_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_aggregator_list, list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_AGGREGATOR, &ptr->list))
-				goto unlock;
-		}
-	}
-	{
 		struct ccs_domain_info *domain;
 		list_for_each_entry_rcu(domain, &ccs_domain_list, list) {
 			struct ccs_acl_info *acl;
@@ -763,99 +650,49 @@
 				goto unlock;
 		}
 	}
-	{
-		struct ccs_path_group *group;
-		list_for_each_entry_rcu(group, &ccs_path_group_list, list) {
-			struct ccs_path_group_member *member;
-			list_for_each_entry_rcu(member, &group->member_list,
-						list) {
-				if (!member->is_deleted)
-					continue;
-				if (!ccs_add_to_gc(CCS_ID_PATH_GROUP_MEMBER,
-						   &member->list))
-					goto unlock;
-			}
-			if (!list_empty(&group->member_list) ||
-			    atomic_read(&group->users))
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_PATH_GROUP, &group->list))
-				goto unlock;
+	for (i = 0; i < CCS_MAX_GROUP; i++) {
+		struct list_head *list = &ccs_group_list[i];
+		int id;
+		struct ccs_group *group;
+		switch (i) {
+		case 0:
+			id = CCS_ID_PATH_GROUP;
+			break;
+		case 1:
+			id = CCS_ID_NUMBER_GROUP;
+			break;
+		default:
+			id = CCS_ID_ADDRESS_GROUP;
+			break;
 		}
-	}
-	{
-		struct ccs_address_group *group;
-		list_for_each_entry_rcu(group, &ccs_address_group_list, list) {
-			struct ccs_address_group_member *member;
-			list_for_each_entry_rcu(member, &group->member_list,
-						list) {
-				if (!member->is_deleted)
-					continue;
-				if (!ccs_add_to_gc(CCS_ID_ADDRESS_GROUP_MEMBER,
-						   &member->list))
-					goto unlock;
-			}
-			if (!list_empty(&group->member_list) ||
-			    atomic_read(&group->users))
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_ADDRESS_GROUP, &group->list))
+		list_for_each_entry_rcu(group, list, head.list) {
+			if (!ccs_collect_member(&group->member_list, id))
 				goto unlock;
-		}
-	}
-	{
-		struct ccs_number_group *group;
-		list_for_each_entry_rcu(group, &ccs_number_group_list, list) {
-			struct ccs_number_group_member *member;
-			list_for_each_entry_rcu(member, &group->member_list,
-						list) {
-				if (!member->is_deleted)
-					continue;
-				if (!ccs_add_to_gc(CCS_ID_NUMBER_GROUP_MEMBER,
-						   &member->list))
-					goto unlock;
-			}
 			if (!list_empty(&group->member_list) ||
-			    atomic_read(&group->users))
+			    atomic_read(&group->head.users))
 				continue;
-			if (!ccs_add_to_gc(CCS_ID_NUMBER_GROUP, &group->list))
+			if (!ccs_add_to_gc(CCS_ID_GROUP, &group->head.list))
 				goto unlock;
 		}
 	}
-	{
-		struct ccs_reserved_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
-			if (!ptr->is_deleted)
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_RESERVEDPORT, &ptr->list))
-				goto unlock;
-		}
-	}
-	{
-		struct ccs_ipv6addr_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_address_list, list) {
+	for (i = 0; i < CCS_MAX_LIST + CCS_MAX_HASH; i++) {
+		struct list_head *list = i < 2 ? &ccs_shared_list[i] :
+			&ccs_name_list[i];
+		int id;
+		struct ccs_shared_acl_head *ptr;
+		if (i == 0)
+			id = CCS_ID_IPV6_ADDRESS;
+		else if (i == 1)
+			id = CCS_ID_CONDITION;
+		else
+			id = CCS_ID_NAME;
+		list_for_each_entry_rcu(ptr, list, list) {
 			if (atomic_read(&ptr->users))
 				continue;
-			if (!ccs_add_to_gc(CCS_ID_IPV6_ADDRESS, &ptr->list))
+			if (!ccs_add_to_gc(id, &ptr->list))
 				goto unlock;
 		}
 	}
-	{
-		struct ccs_condition *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_condition_list, list) {
-			if (atomic_read(&ptr->users))
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_CONDITION, &ptr->list))
-				goto unlock;
-		}
-	}
-	for (i = 0; i < CCS_MAX_HASH; i++) {
-		struct ccs_name_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_name_list[i], list) {
-			if (atomic_read(&ptr->users))
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_NAME, &ptr->list))
-				goto unlock;
-		}
-	}
  unlock:
 	ccs_read_unlock(idx);
 	mutex_unlock(&ccs_policy_lock);
@@ -898,21 +735,15 @@
 		case CCS_ID_AGGREGATOR:
 			size = ccs_del_aggregator(p->element);
 			break;
-		case CCS_ID_PATH_GROUP_MEMBER:
-			size = ccs_del_path_group_member(p->element);
+		case CCS_ID_GROUP:
+			size = ccs_del_group(p->element);
 			break;
 		case CCS_ID_PATH_GROUP:
 			size = ccs_del_path_group(p->element);
 			break;
-		case CCS_ID_ADDRESS_GROUP_MEMBER:
-			size = ccs_del_address_group_member(p->element);
-			break;
 		case CCS_ID_ADDRESS_GROUP:
 			size = ccs_del_address_group(p->element);
 			break;
-		case CCS_ID_NUMBER_GROUP_MEMBER:
-			size = ccs_del_number_group_member(p->element);
-			break;
 		case CCS_ID_NUMBER_GROUP:
 			size = ccs_del_number_group(p->element);
 			break;
@@ -923,10 +754,7 @@
 			size = ccs_del_ipv6_address(p->element);
 			break;
 		case CCS_ID_CONDITION:
-			size = ccs_del_condition(container_of(p->element,
-							      struct
-							      ccs_condition,
-							      list));
+			size = ccs_del_condition(p->element);
 			break;
 		case CCS_ID_NAME:
 			size = ccs_del_name(p->element);
Index: network.c
===================================================================
--- network.c	(revision 3685)
+++ network.c	(working copy)
@@ -47,7 +47,9 @@
  * @min:     Pointer to store min address.
  * @max:     Pointer to store max address.
  *
- * Returns 2 if @address is an IPv6, 1 if @address is an IPv4, 0 otherwise.
+ * Returns CCS_IP_ADDRESS_TYPE_IPv6 if @address is an IPv6,
+ * CCS_IP_ADDRESS_TYPE_IPv4 if @address is an IPv4,
+ * CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP otherwise.
  */
 int ccs_parse_ip_address(char *address, u16 *min, u16 *max)
 {
@@ -65,7 +67,7 @@
 			min[i] = htons(min[i]);
 			max[i] = htons(max[i]);
 		}
-		return 2;
+		return CCS_IP_ADDRESS_TYPE_IPv6;
 	}
 	count = sscanf(address, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
 		       &min[0], &min[1], &min[2], &min[3],
@@ -79,9 +81,9 @@
 				   + (((u8) max[1]) << 16)
 				   + (((u8) max[2]) << 8) + (u8) max[3]);
 		memmove(max, &ip, sizeof(ip));
-		return 1;
+		return CCS_IP_ADDRESS_TYPE_IPv4;
 	}
-	return 0;
+	return CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
 }
 
 #if !defined(NIP6)
@@ -251,6 +253,39 @@
 	return error;
 }
 
+static bool ccs_is_same_ip_network_acl(const struct ccs_acl_info *a,
+				       const struct ccs_acl_info *b)
+{
+	const struct ccs_ip_network_acl *p1 = container_of(a, typeof(*p1),
+							   head);
+	const struct ccs_ip_network_acl *p2 = container_of(b, typeof(*p2),
+							   head);
+	return ccs_is_same_acl_head(&p1->head, &p2->head)
+		&& p1->address_type == p2->address_type &&
+		p1->address.ipv4.min == p2->address.ipv4.min &&
+		p1->address.ipv6.min == p2->address.ipv6.min &&
+		p1->address.ipv4.max == p2->address.ipv4.max &&
+		p1->address.ipv6.max == p2->address.ipv6.max &&
+		p1->address.group == p2->address.group &&
+		ccs_is_same_number_union(&p1->port, &p2->port);
+}
+
+static bool ccs_merge_ip_network_acl(struct ccs_acl_info *a,
+				     struct ccs_acl_info *b,
+				     const bool is_delete)
+{
+	struct ccs_ip_network_acl *p1 = container_of(a, typeof(*p1), head);
+	const u16 perm = container_of(b, typeof(*p1), head)->perm;
+	if (is_delete) {
+		p1->perm &= ~perm;
+	} else {
+		if (p1->head.is_deleted)
+			p1->perm = 0;
+		p1->perm |= perm;
+	}
+	return !p1->perm;
+}
+
 /**
  * ccs_write_network_policy - Write "struct ccs_ip_network_acl" list.
  *
@@ -265,7 +300,6 @@
 			     struct ccs_condition *condition,
 			     const bool is_delete)
 {
-	struct ccs_acl_info *ptr;
 	struct ccs_ip_network_acl e = {
 		.head.type = CCS_TYPE_IP_NETWORK_ACL,
 		.head.cond = condition,
@@ -316,7 +350,7 @@
 	else
 		return -EINVAL;
 	switch (ccs_parse_ip_address(w[2], min_address, max_address)) {
-	case 2:
+	case CCS_IP_ADDRESS_TYPE_IPv6:
 		e.address_type = CCS_IP_ADDRESS_TYPE_IPv6;
 		e.address.ipv6.min = ccs_get_ipv6_address((struct in6_addr *)
 							  min_address);
@@ -325,7 +359,7 @@
 		if (!e.address.ipv6.min || !e.address.ipv6.max)
 			goto out;
 		break;
-	case 1:
+	case CCS_IP_ADDRESS_TYPE_IPv4:
 		e.address_type = CCS_IP_ADDRESS_TYPE_IPv4;
 		/* use host byte order to allow u32 comparison.*/
 		e.address.ipv4.min = ntohl(*(u32 *) min_address);
@@ -342,38 +376,12 @@
 	}
 	if (!ccs_parse_number_union(w[3], &e.port))
 		goto out;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_ip_network_acl *acl =
-			container_of(ptr, struct ccs_ip_network_acl, head);
-		if (!ccs_is_same_ip_network_acl(acl, &e))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~e.perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= e.perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error) {
-		struct ccs_ip_network_acl *entry =
-			ccs_commit_ok(&e, sizeof(e));
-		if (entry) {
-			ccs_add_domain_acl(domain, &entry->head);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
+	error = ccs_update_domain_policy(&e.head, sizeof(e), is_delete, domain,
+					 ccs_is_same_ip_network_acl,
+					 ccs_merge_ip_network_acl);
  out:
 	if (w[2][0] == '@')
-		ccs_put_address_group(e.address.group);
+		ccs_put_group(e.address.group);
 	else if (e.address_type == CCS_IP_ADDRESS_TYPE_IPv6) {
 		ccs_put_ipv6_address(e.address.ipv6.min);
 		ccs_put_ipv6_address(e.address.ipv6.max);
