@@ -1331,13 +1579,39 @@
 		}
 	}
 
-	dp->list_selected = realloc(dp->list_selected, dp->list_len);
+	if (!offline_mode) /* read process information */
+		read_process_list(true);
+
+	dp->list_selected = realloc(dp->list_selected, dp->list_len
+				    + generic_acl_list_count);
 	if (dp->list_len && !dp->list_selected)
 		out_of_memory();
-	memset(dp->list_selected, 0, dp->list_len);
+	memset(dp->list_selected, 0, dp->list_len + generic_acl_list_count);
 }
 
 static void show_list(struct domain_policy *dp)
 {
 	const int offset = current_item_index[current_screen];
@@ -1360,9 +1634,10 @@
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		int i = list_item_count[SCREEN_DOMAIN_LIST]
 			- unnumbered_domain_count;
+		int j = task_list_len;
 		printw("<<< Domain Transition Editor >>>"
-		       "      %d domain%c    '?' for help",
-		       i, i > 1 ? 's' : ' ');
+		       "      %d domain%c    %d process%s   '?' for help",
+		       i, i > 1 ? 's' : ' ', j, j > 1 ? "es" : "");
 	} else {
 		int i = list_item_count[current_screen];
 		printw("<<< %s >>>"
@@ -1397,13 +1672,22 @@
 	}
 	for (i = 0; i < body_lines; i++) {
 		const int index = offset + i;
+		const int count = list_item_count[current_screen];
 		eat_col = max_eat_col[current_screen];
-		if (index >= list_item_count[current_screen])
-			break;
+		if (current_screen == SCREEN_DOMAIN_LIST) {
+			if (index >= count + task_list_len)
+				break;
+		} else {
+			if (index >= count)
+				break;
+		}
 		move(header_lines + i, 0);
 		switch (current_screen) {
 		case SCREEN_DOMAIN_LIST:
-			tmp_col = show_domain_line(dp, index);
+			if (index < count)
+				tmp_col = show_domain_line(dp, index);
+			else
+				tmp_col = show_process_line(index - count);
 			break;
 		case SCREEN_SYSTEM_LIST:
 		case SCREEN_EXCEPTION_LIST:
@@ -1451,80 +1735,103 @@
 
 static void show_current(struct domain_policy *dp)
 {
 	if (current_screen == SCREEN_DOMAIN_LIST) {
+		int index = editpolicy_get_current();
+		int count = list_item_count[SCREEN_DOMAIN_LIST];
 		get();
 		eat_col = max_eat_col[current_screen];
-		shprintf("%s", eat(domain_name(dp, editpolicy_get_current())));
+		if (index < count)
+			shprintf("%s", eat(domain_name(dp, index)));
+		else
+			shprintf("%s", eat(task_list[index - count].name));
 		if (window_width < sizeof(shared_buffer))
 			shared_buffer[window_width] = '\0';
 		move(2, 0);
@@ -1788,13 +2105,14 @@
 	show_list(dp);
 }
 
-static void set_profile(struct domain_policy *dp, int current)
+static void set_profile(struct domain_policy *dp, const int current)
 {
 	int index;
 	FILE *fp;
 	char *line;
+
 	if (!count(dp->list_selected, dp->list_len) &&
-	    !select_item(dp, current)) {
+	    !count3(task_list, task_list_len) && !select_item(dp, current)) {
 		move(1, 0);
 		printw("Select domain using Space key first.");
 		clrtoeol();
@@ -1906,8 +2271,9 @@
 	printw("e     <<< Exception Policy Editor >>>\n");
 	printw("d     <<< Domain Transition Editor >>>\n");
 	if (current_screen == SCREEN_DOMAIN_LIST &&
-	    !is_initializer_source(dp, current) &&
-	    !is_deleted_domain(dp, current))
+	    (current > dp->list_len ||
+	     (!is_initializer_source(dp, current) &&
+	      !is_deleted_domain(dp, current))))
 		printw("a     <<< Domain Policy Editor >>>\n");
 	printw("p     <<< Profile Editor >>>\n");
 	printw("m     <<< Manager Policy Editor >>>\n");
@@ -2003,7 +2422,7 @@
 start:
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		read_domain_and_exception_policy(dp);
-		adjust_cursor_pos(dp->list_len);
+		adjust_cursor_pos(dp->list_len + task_list_len);
 	} else {
 		read_generic_policy();
 		adjust_cursor_pos(generic_acl_list_count);
