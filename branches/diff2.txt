Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(revision 2496)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(working copy)
@@ -299,7 +299,9 @@
 	char *name;
 	char *domain;
 	u8 profile;
-	_Bool done;
+	_Bool selected;
+	int index;
+	int depth;
 };
 
 /***** STRUCTURES DEFINITION END *****/
@@ -367,6 +369,7 @@
 			      const _Bool is_dis, const _Bool is_dd);
 const char *domain_name(const struct domain_policy *dp, const int index);
 void send_fd(char *data, int *fd);
+void read_process_list(_Bool show_all);
 void editpolicy_offline_daemon(void);
 void editpolicy_init_keyword_map(void);
 void editpolicy_line_draw(const int screen);
@@ -416,6 +419,8 @@
 extern int current_y[MAXSCREEN];
 extern int list_item_count[MAXSCREEN];
 extern struct editpolicy_directive directives[MAX_DIRECTIVE_INDEX];
+extern struct task_entry *task_list;
+extern int task_list_len;
 
 extern const char *proc_policy_dir,
 	*disk_policy_dir,
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(revision 2496)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(working copy)
@@ -53,31 +53,30 @@
 static void read_domain_and_exception_policy(struct domain_policy *dp);
 static void show_current(struct domain_policy *dp);
 static const char *eat(const char *str);
-static int show_domain_line(struct domain_policy *dp, int index);
-static int show_acl_line(int index, int list_indent);
-static int show_profile_line(int index);
-static int show_literal_line(int index);
-static int show_meminfo_line(int index);
+static int show_domain_line(struct domain_policy *dp, const int index);
+static int show_acl_line(const int index, const int list_indent);
+static int show_profile_line(const int index);
+static int show_literal_line(const int index);
+static int show_meminfo_line(const int index);
 static void show_list(struct domain_policy *dp);
 static void resize_window(void);
 static void up_arrow_key(struct domain_policy *dp);
 static void down_arrow_key(struct domain_policy *dp);
 static void page_up_key(struct domain_policy *dp);
 static void page_down_key(struct domain_policy *dp);
-static void show_current(struct domain_policy *dp);
 static void adjust_cursor_pos(const int item_count);
 static void set_cursor_pos(const int index);
 static int count(const unsigned char *array, const int len);
 static int count2(const struct generic_acl *array, int len);
-static int select_item(struct domain_policy *dp, const int current);
+static _Bool select_item(struct domain_policy *dp, const int index);
 static int generic_acl_compare(const void *a, const void *b);
-static void delete_entry(struct domain_policy *dp, int current);
+static void delete_entry(struct domain_policy *dp, const int index);
 static void add_entry(struct readline_data *rl);
 static void find_entry(struct domain_policy *dp, _Bool input, _Bool forward,
-		       int current, struct readline_data *rl);
-static void set_profile(struct domain_policy *dp, int current);
-static void set_level(struct domain_policy *dp, int current);
-static void set_quota(struct domain_policy *dp, int current);
+		       const int current, struct readline_data *rl);
+static void set_profile(struct domain_policy *dp, const int current);
+static void set_level(struct domain_policy *dp, const int current);
+static void set_quota(struct domain_policy *dp, const int current);
 static int select_window(struct domain_policy *dp, const int current);
 static _Bool show_command_key(const int screen, const _Bool readonly);
 static int generic_list_loop(struct domain_policy *dp);
@@ -352,7 +351,7 @@
 }
 
 
-static int show_domain_line(struct domain_policy *dp, int index)
+static int show_domain_line(struct domain_policy *dp, const int index)
 {
 	int tmp_col = 0;
 	const struct domain_initializer_entry *domain_initializer;
@@ -437,7 +436,7 @@
 	return tmp_col;
 }
 
-static int show_acl_line(int index, int list_indent)
+static int show_acl_line(const int index, const int list_indent)
 {
 	u8 directive = generic_acl_list[index].directive;
 	const char *cp1 = directives[directive].alias;
@@ -452,7 +451,7 @@
 	return strlen(cp1) + strlen(cp2) + 8 + list_indent;
 }
 
-static int show_profile_line(int index)
+static int show_profile_line(const int index)
 {
 	const char *cp = generic_acl_list[index].operand;
 	const u8 profile = generic_acl_list[index].directive;
@@ -464,7 +463,7 @@
 	return strlen(number) + strlen(cp) + 8;
 }
 
-static int show_literal_line(int index)
+static int show_literal_line(const int index)
 {
 	const char *cp = generic_acl_list[index].operand;
 	printw("%c%4d: %s ",
@@ -473,7 +472,7 @@
 	return strlen(cp) + 8;
 }
 
-static int show_meminfo_line(int index)
+static int show_meminfo_line(const int index)
 {
 	unsigned int now = 0;
 	unsigned int quota = 0;
@@ -608,12 +607,17 @@
 static const char *policy_file = NULL;
 static const char *list_caption = NULL;
 static char *current_domain = NULL;
+static unsigned int current_pid = 0;
 
 static int current_screen = SCREEN_DOMAIN_LIST;
 
 struct generic_acl *generic_acl_list = NULL;
 int generic_acl_list_count = 0;
 
+struct task_entry *task_list = NULL;
+int task_list_len = 0;
+static int dump_index = 0;
+
 static struct domain_keeper_entry *domain_keeper_list = NULL;
 static int domain_keeper_list_len = 0;
 static struct domain_initializer_entry *domain_initializer_list = NULL;
@@ -882,7 +886,11 @@
 			/* Don't set error message if failed. */
 			fp = fopen(policy_file, "r+");
 		if (fp) {
-			fprintf(fp, "select domain=%s\n", current_domain);
+			if (current_pid)
+				fprintf(fp, "select pid=%u\n", current_pid);
+			else
+				fprintf(fp, "select domain=%s\n",
+					current_domain);
 			if (network_mode)
 				fputc(0, fp);
 			fflush(fp);
@@ -965,6 +973,236 @@
 	}
 }
 
+static pid_t get_ppid(const pid_t pid)
+{
+	char buffer[1024];
+	FILE *fp;
+	pid_t ppid = 1;
+	memset(buffer, 0, sizeof(buffer));
+	snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
+	fp = fopen(buffer, "r");
+	if (fp) {
+		while (memset(buffer, 0, sizeof(buffer)),
+		       fgets(buffer, sizeof(buffer) - 1, fp)) {
+			if (sscanf(buffer, "PPid: %u", &ppid) == 1)
+				break;
+		}
+		fclose(fp);
+	}
+	return ppid;
+}
+
+static char *get_name(const pid_t pid)
+{
+	char buffer[1024];
+	FILE *fp;
+	memset(buffer, 0, sizeof(buffer));
+	snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
+	fp = fopen(buffer, "r");
+	if (fp) {
+		static const int offset = sizeof(buffer) / 6;
+		while (memset(buffer, 0, sizeof(buffer)),
+		       fgets(buffer, sizeof(buffer) - 1, fp)) {
+			if (!strncmp(buffer, "Name:\t", 6)) {
+				char *cp = buffer + 6;
+				memmove(buffer, cp, strlen(cp) + 1);
+				cp = strchr(buffer, '\n');
+				if (cp)
+					*cp = '\0';
+				break;
+			}
+		}
+		fclose(fp);
+		if (buffer[0] && strlen(buffer) < offset - 1) {
+			const char *src = buffer;
+			char *dest = buffer + offset;
+			while (1) {
+				unsigned char c = *src++;
+				if (!c) {
+					*dest = '\0';
+					break;
+				}
+				if (c == '\\') {
+					c = *src++;
+					if (c == '\\') {
+						memmove(dest, "\\\\", 2);
+						dest += 2;
+					} else if (c == 'n') {
+						memmove(dest, "\\012", 4);
+						dest += 4;
+					} else {
+						break;
+					}
+				} else if (c > ' ' && c <= 126) {
+					*dest++ = c;
+				} else {
+					*dest++ = '\\';
+					*dest++ = (c >> 6) + '0';
+					*dest++ = ((c >> 3) & 7) + '0';
+					*dest++ = (c & 7) + '0';
+				}
+			}
+			return strdup(buffer + offset);
+		}
+	}
+	return NULL;
+}
+
+static void sort_process_entry(const pid_t pid, const int depth)
+{
+	int i;
+	for (i = 0; i < task_list_len; i++) {
+		if (pid != task_list[i].pid)
+			continue;
+		task_list[i].index = dump_index++;
+		task_list[i].depth = depth;
+		task_list[i].selected = true;
+	}
+	for (i = 0; i < task_list_len; i++) {
+		if (pid != task_list[i].ppid)
+			continue;
+		sort_process_entry(task_list[i].pid, depth + 1);
+	}
+}
+
+static int task_entry_compare(const void *a, const void *b)
+{
+	const struct task_entry *a0 = (struct task_entry *) a;
+	const struct task_entry *b0 = (struct task_entry *) b;
+	return a0->index - b0->index;
+}
+
+void read_process_list(_Bool show_all)
+{
+	int i;
+	while (task_list_len) {
+		task_list_len--;
+		free((void *) task_list[task_list_len].name);
+		free((void *) task_list[task_list_len].domain);
+	}
+	dump_index = 0;
+	if (network_mode) {
+		FILE *fp = open_write(show_all ? "proc:all_process_status" :
+				      "proc:process_status");
+		if (!fp)
+			return;
+		get();
+		while (freadline(fp)) {
+			unsigned int pid = 0;
+			unsigned int ppid = 0;
+			int profile = -1;
+			char *name;
+			char *domain;
+			sscanf(shared_buffer, "PID=%u PPID=%u", &pid, &ppid);
+			name = strstr(shared_buffer, "NAME=");
+			if (name)
+				name = strdup(name + 5);
+			if (!name)
+				name = strdup("<UNKNOWN>");
+			if (!name)
+				out_of_memory();
+			if (!freadline(fp))
+				break;
+			sscanf(shared_buffer, "%u %u", &pid, &profile);
+			domain = strchr(shared_buffer, '<');
+			if (domain)
+				domain = strdup(domain);
+			if (!domain)
+				domain = strdup("<UNKNOWN>");
+			if (!domain)
+				out_of_memory();
+			task_list = realloc(task_list,
+					    (task_list_len + 1) *
+					    sizeof(struct task_entry));
+			if (!task_list)
+				out_of_memory();
+			memset(&task_list[task_list_len], 0,
+			       sizeof(task_list[0]));
+			task_list[task_list_len].pid = pid;
+			task_list[task_list_len].ppid = ppid;
+			task_list[task_list_len].profile = profile;
+			task_list[task_list_len].name = name;
+			task_list[task_list_len].domain = domain;
+			task_list_len++;
+		}
+		put();
+		fclose(fp);
+	} else {
+		struct dirent **namelist;
+		int i;
+		int n;
+		int status_fd = open(proc_policy_process_status, O_RDWR);
+		if (status_fd == EOF)
+			return;
+		n = scandir("/proc/", &namelist, 0, 0);
+		for (i = 0; i < n; i++) {
+			char *name;
+			char *domain;
+			int profile = -1;
+			unsigned int pid = 0;
+			char buffer[128];
+			char test[16];
+			if (sscanf(namelist[i]->d_name, "%u", &pid) != 1)
+				goto skip;
+			memset(buffer, 0, sizeof(buffer));
+			if (!show_all) {
+				snprintf(buffer, sizeof(buffer) - 1,
+					 "/proc/%u/exe", pid);
+				if (readlink(buffer, test, sizeof(test)) <= 0)
+					goto skip;
+			}
+			name = get_name(pid);
+			if (!name)
+				name = strdup("<UNKNOWN>");
+			if (!name)
+				out_of_memory();
+			snprintf(buffer, sizeof(buffer) - 1, "%u\n", pid);
+			write(status_fd, buffer, strlen(buffer));
+			get();
+			memset(shared_buffer, 0, sizeof(shared_buffer));
+			read(status_fd, shared_buffer,
+			     sizeof(shared_buffer) - 1);
+			sscanf(shared_buffer, "%u %u", &pid, &profile);
+			domain = strchr(shared_buffer, '<');
+			if (domain)
+				domain = strdup(domain);
+			if (!domain)
+				domain = strdup("<UNKNOWN>");
+			if (!domain)
+				out_of_memory();
+			put();
+			task_list = realloc(task_list, (task_list_len + 1) *
+					    sizeof(struct task_entry));
+			if (!task_list)
+				out_of_memory();
+			memset(&task_list[task_list_len], 0,
+			       sizeof(task_list[0]));
+			task_list[task_list_len].pid = pid;
+			task_list[task_list_len].ppid = get_ppid(pid);
+			task_list[task_list_len].profile = profile;
+			task_list[task_list_len].name = name;
+			task_list[task_list_len].domain = domain;
+			task_list_len++;
+skip:
+			free((void *) namelist[i]);
+		}
+		if (n >= 0)
+			free((void *) namelist);
+		close(status_fd);
+	}
+	sort_process_entry(1, 0);
+	for (i = 0; i < task_list_len; i++) {
+		if (task_list[i].selected) {
+			task_list[i].selected = false;
+			continue;
+		}
+		task_list[i].index = dump_index++;
+		task_list[i].depth = 0;
+	}
+	qsort(task_list, task_list_len, sizeof(struct task_entry),
+	      task_entry_compare);
+}
+
 static int add_domain_initializer_entry(const char *domainname,
 					const char *program, const _Bool is_not)
 {
@@ -1331,13 +1569,39 @@
 		}
 	}
 
-	dp->list_selected = realloc(dp->list_selected, dp->list_len);
+	if (!offline_mode) /* read process information */
+		read_process_list(true);
+
+	dp->list_selected = realloc(dp->list_selected, dp->list_len
+				    + generic_acl_list_count);
 	if (dp->list_len && !dp->list_selected)
 		out_of_memory();
-	memset(dp->list_selected, 0, dp->list_len);
+	memset(dp->list_selected, 0, dp->list_len + generic_acl_list_count);
 }
 
+static int show_process_line(const int index)
+{
+	int tmp_col = 0;
+	int i;
+	printw("%c%4d:%3u ",
+	       task_list[index].selected ? '&' : ' ',
+	       index, task_list[index].profile);
+	tmp_col += 10;
+	for (i = 0; i < task_list[index].depth - 1; i++) {
+		printw("%s", eat("    "));
+		tmp_col += 4;
+	}
+	get();
+	shprintf("%s%s (%u) %s", task_list[index].depth ?
+		 " +- " : "", task_list[index].name,
+		 task_list[index].pid, task_list[index].domain);
+	printw("%s", eat(shared_buffer));
+	tmp_col += strlen(shared_buffer);
+	put();
+	return tmp_col;
+}
 
+
 static void show_list(struct domain_policy *dp)
 {
 	const int offset = current_item_index[current_screen];
@@ -1360,9 +1624,10 @@
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		int i = list_item_count[SCREEN_DOMAIN_LIST]
 			- unnumbered_domain_count;
+		int j = task_list_len;
 		printw("<<< Domain Transition Editor >>>"
-		       "      %d domain%c    '?' for help",
-		       i, i > 1 ? 's' : ' ');
+		       "      %d domain%c    %d process%s   '?' for help",
+		       i, i > 1 ? 's' : ' ', j, j > 1 ? "es" : "");
 	} else {
 		int i = list_item_count[current_screen];
 		printw("<<< %s >>>"
@@ -1397,13 +1662,22 @@
 	}
 	for (i = 0; i < body_lines; i++) {
 		const int index = offset + i;
+		const int count = list_item_count[current_screen];
 		eat_col = max_eat_col[current_screen];
-		if (index >= list_item_count[current_screen])
-			break;
+		if (current_screen == SCREEN_DOMAIN_LIST) {
+			if (index >= count + task_list_len)
+				break;
+		} else {
+			if (index >= count)
+				break;
+		}
 		move(header_lines + i, 0);
 		switch (current_screen) {
 		case SCREEN_DOMAIN_LIST:
-			tmp_col = show_domain_line(dp, index);
+			if (index < count)
+				tmp_col = show_domain_line(dp, index);
+			else
+				tmp_col = show_process_line(index - count);
 			break;
 		case SCREEN_SYSTEM_LIST:
 		case SCREEN_EXCEPTION_LIST:
@@ -1451,80 +1725,103 @@
 
 static void down_arrow_key(struct domain_policy *dp)
 {
-	if (current_y[current_screen] < body_lines - 1) {
-		if (current_item_index[current_screen]
-		    + current_y[current_screen]
-		    < list_item_count[current_screen] - 1) {
+	int count = list_item_count[current_screen] - 1;
+	const int p0 = current_item_index[current_screen];
+	const int p1 = current_y[current_screen];
+	if (current_screen == SCREEN_DOMAIN_LIST)
+		count += task_list_len;
+	if (p0 + p1 < count) {
+		if (p1 < body_lines - 1) {
 			current_y[current_screen]++;
 			show_current(dp);
+		} else {
+			current_item_index[current_screen]++;
+			show_list(dp);
 		}
-	} else if (current_item_index[current_screen]
-		   + current_y[current_screen]
-		   < list_item_count[current_screen] - 1) {
-		current_item_index[current_screen]++;
-		show_list(dp);
 	}
 }
 
 static void page_up_key(struct domain_policy *dp)
 {
-	if (current_item_index[current_screen] + current_y[current_screen]
-	    > body_lines) {
-		current_item_index[current_screen] -= body_lines;
-		if (current_item_index[current_screen] < 0)
-			current_item_index[current_screen] = 0;
+	int p0 = current_item_index[current_screen];
+	int p1 = current_y[current_screen];
+	_Bool refresh;
+	if (p0 + p1 > body_lines) {
+		p0 -= body_lines;
+		if (p0 < 0)
+			p0 = 0;
+	} else if (p0 + p1 > 0) {
+		p0 = 0;
+		p1 = 0;
+	} else {
+		return;
+	}
+	refresh = (current_item_index[current_screen] != p0);
+	current_item_index[current_screen] = p0;
+	current_y[current_screen] = p1;
+	if (refresh)
 		show_list(dp);
-	} else if (current_item_index[current_screen]
-		   + current_y[current_screen] > 0) {
-		current_item_index[current_screen] = 0;
-		current_y[current_screen] = 0;
-		show_list(dp);
-	}
+	else
+		show_current(dp);
 }
 
 static void page_down_key(struct domain_policy *dp)
 {
-	if (list_item_count[current_screen] - current_item_index[current_screen]
-	    > body_lines) {
-		current_item_index[current_screen] += body_lines;
-		if (current_item_index[current_screen]
-		    + current_y[current_screen]
-		    > list_item_count[current_screen] - 1)
-			current_y[current_screen]
-				= list_item_count[current_screen] - 1
-				- current_item_index[current_screen];
+	int count = list_item_count[current_screen] - 1;
+	int p0 = current_item_index[current_screen];
+	int p1 = current_y[current_screen];
+	_Bool refresh;
+	if (current_screen == SCREEN_DOMAIN_LIST)
+		count += task_list_len;
+	if (p0 + p1 + body_lines < count) {
+		p0 += body_lines;
+	} else if (p0 + p1 < count) {
+		while (p0 + p1 < count) {
+			if (p1 + 1 < body_lines)
+				p1++;
+			else
+				p0++;
+		}
+	} else {
+		return;
+	}
+	refresh = (current_item_index[current_screen] != p0);
+	current_item_index[current_screen] = p0;
+	current_y[current_screen] = p1;
+	if (refresh)
 		show_list(dp);
-	} else if (current_item_index[current_screen]
-		   + current_y[current_screen]
-		   < list_item_count[current_screen] - 1) {
-		current_y[current_screen]
-			= list_item_count[current_screen]
-			- current_item_index[current_screen] - 1;
+	else
 		show_current(dp);
-	}
 }
 
 int editpolicy_get_current(void)
 {
-	if (list_item_count[current_screen] == 0)
+	int count = list_item_count[current_screen];
+	const int p0 = current_item_index[current_screen];
+	const int p1 = current_y[current_screen];
+	if (current_screen == SCREEN_DOMAIN_LIST)
+		count += task_list_len;
+	if (!count)
 		return EOF;
-	if (current_item_index[current_screen] + current_y[current_screen] < 0
-	    || current_item_index[current_screen] + current_y[current_screen]
-	    >= list_item_count[current_screen]) {
+	if (p0 + p1 < 0 || p0 + p1 >= count) {
 		fprintf(stderr, "ERROR: current_item_index=%d current_y=%d\n",
-			current_item_index[current_screen],
-			current_y[current_screen]);
+			p0, p1);
 		exit(127);
 	}
-	return current_item_index[current_screen] + current_y[current_screen];
+	return p0 + p1;
 }
 
 static void show_current(struct domain_policy *dp)
 {
 	if (current_screen == SCREEN_DOMAIN_LIST) {
+		int index = editpolicy_get_current();
+		int count = list_item_count[SCREEN_DOMAIN_LIST];
 		get();
 		eat_col = max_eat_col[current_screen];
-		shprintf("%s", eat(domain_name(dp, editpolicy_get_current())));
+		if (index < count)
+			shprintf("%s", eat(domain_name(dp, index)));
+		else
+			shprintf("%s", eat(task_list[index - count].name));
 		if (window_width < sizeof(shared_buffer))
 			shared_buffer[window_width] = '\0';
 		move(2, 0);
@@ -1573,27 +1870,29 @@
 	}
 }
 
-static int select_item(struct domain_policy *dp, const int current)
+static _Bool select_item(struct domain_policy *dp, const int index)
 {
-	if (current >= 0) {
-		int x;
-		int y;
-		if (current_screen == SCREEN_DOMAIN_LIST) {
-			if (is_deleted_domain(dp, current) ||
-			    is_initializer_source(dp, current))
-				return 0;
-			dp->list_selected[current] ^= 1;
-		} else {
-			generic_acl_list[current].selected ^= 1;
-		}
-		getyx(stdscr, y, x);
-		editpolicy_sttr_save();    /* add color */
-		show_list(dp);
-		editpolicy_sttr_restore(); /* add color */
-		move(y, x);
-		return 1;
+	int x;
+	int y;
+	if (index < 0)
+		return false;
+	if (current_screen == SCREEN_DOMAIN_LIST) {
+		if (index < dp->list_len) {
+			if (is_deleted_domain(dp, index) ||
+			    is_initializer_source(dp, index))
+				return false;
+			dp->list_selected[index] ^= 1;
+		} else
+			task_list[index - dp->list_len].selected ^= 1;
+	} else {
+		generic_acl_list[index].selected ^= 1;
 	}
-	return 0;
+	getyx(stdscr, y, x);
+	editpolicy_sttr_save();    /* add color */
+	show_list(dp);
+	editpolicy_sttr_restore(); /* add color */
+	move(y, x);
+	return true;
 }
 
 static int generic_acl_compare(const void *a, const void *b)
@@ -1617,16 +1916,16 @@
 	}
 }
 
-static void delete_entry(struct domain_policy *dp, int current)
+static void delete_entry(struct domain_policy *dp, const int index)
 {
 	int c;
 	move(1, 0);
 	editpolicy_color_change(DISP_ERR, true);	/* add color */
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		c = count(dp->list_selected, dp->list_len);
+		if (!c && index < dp->list_len)
+			c = select_item(dp, index);
 		if (!c)
-			c = select_item(dp, current);
-		if (!c)
 			printw("Select domain using Space key first.");
 		else
 			printw("Delete selected domain%s? ('Y'es/'N'o)",
@@ -1634,7 +1933,7 @@
 	} else {
 		c = count2(generic_acl_list, generic_acl_list_count);
 		if (!c)
-			c = select_item(dp, current);
+			c = select_item(dp, index);
 		if (!c)
 			printw("Select entry using Space key first.");
 		else
@@ -1655,31 +1954,35 @@
 		return;
 	}
 	if (current_screen == SCREEN_DOMAIN_LIST) {
-		int index;
+		int i;
 		FILE *fp = open_write(proc_policy_domain_policy);
 		if (!fp)
 			return;
-		for (index = 1; index < dp->list_len; index++) {
-			if (!dp->list_selected[index])
+		for (i = 1; i < dp->list_len; i++) {
+			if (!dp->list_selected[i])
 				continue;
-			fprintf(fp, "delete %s\n", domain_name(dp, index));
+			fprintf(fp, "delete %s\n", domain_name(dp, i));
 		}
 		close_write(fp);
 	} else {
-		int index;
+		int i;
 		FILE *fp = open_write(policy_file);
 		if (!fp)
 			return;
-		if (current_screen == SCREEN_ACL_LIST)
-			fprintf(fp, "select %s\n", current_domain);
-		for (index = 0; index < generic_acl_list_count; index++) {
+		if (current_screen == SCREEN_ACL_LIST) {
+			if (current_pid)
+				fprintf(fp, "select pid=%u\n", current_pid);
+			else
+				fprintf(fp, "select %s\n", current_domain);
+		}
+		for (i = 0; i < generic_acl_list_count; i++) {
 			u8 directive;
-			if (!generic_acl_list[index].selected)
+			if (!generic_acl_list[i].selected)
 				continue;
-			directive = generic_acl_list[index].directive;
+			directive = generic_acl_list[i].directive;
 			fprintf(fp, "delete %s %s\n",
 				directives[directive].original,
-				generic_acl_list[index].operand);
+				generic_acl_list[i].operand);
 		}
 		close_write(fp);
 	}
@@ -1714,7 +2017,10 @@
 		}
 		break;
 	case SCREEN_ACL_LIST:
-		fprintf(fp, "select %s\n", current_domain);
+		if (current_pid)
+			fprintf(fp, "select pid=%u\n", current_pid);
+		else
+			fprintf(fp, "select %s\n", current_domain);
 		/* Fall through. */
 	case SCREEN_SYSTEM_LIST:
 	case SCREEN_EXCEPTION_LIST:
@@ -1735,7 +2041,7 @@
 }
 
 static void find_entry(struct domain_policy *dp, _Bool input, _Bool forward,
-		       int current, struct readline_data *rl)
+		       const int current, struct readline_data *rl)
 {
 	int index = current;
 	char *line = NULL;
@@ -1788,7 +2094,7 @@
 	show_list(dp);
 }
 
-static void set_profile(struct domain_policy *dp, int current)
+static void set_profile(struct domain_policy *dp, const int current)
 {
 	int index;
 	FILE *fp;
@@ -1816,12 +2122,18 @@
 		fprintf(fp, "select %s\n" KEYWORD_USE_PROFILE "%s\n",
 			domain_name(dp, index), line);
 	}
+	for (index = 0; index < task_list_len; index++) {
+		if (!task_list[index].selected)
+			continue;
+		fprintf(fp, "select pid=%u\n" KEYWORD_USE_PROFILE "%s\n",
+			task_list[index].pid, line);
+	}
 	close_write(fp);
 out:
 	free(line);
 }
 
-static void set_level(struct domain_policy *dp, int current)
+static void set_level(struct domain_policy *dp, const int current)
 {
 	int index;
 	FILE *fp;
@@ -1855,7 +2167,7 @@
 	free(line);
 }
 
-static void set_quota(struct domain_policy *dp, int current)
+static void set_quota(struct domain_policy *dp, const int current)
 {
 	int index;
 	FILE *fp;
@@ -1888,6 +2200,44 @@
 	free(line);
 }
 
+static _Bool select_acl_window(struct domain_policy *dp, const int current,
+			       const _Bool may_refresh)
+{
+	int index;
+	if (current_screen != SCREEN_DOMAIN_LIST)
+		return false;
+	current_pid = 0;
+	index = list_item_count[current_screen];
+	if (current >= index) {
+		current_pid = task_list[current - index].pid;
+	} else if (is_initializer_source(dp, current)) {
+		int redirect_index;
+		if (!may_refresh)
+			return false;
+		get();
+		shprintf(ROOT_NAME "%s",
+			 strrchr(domain_name(dp, current), ' '));
+		redirect_index = find_domain(dp, shared_buffer, false, false);
+		put();
+		if (redirect_index == EOF)
+			return false;
+		current_item_index[current_screen]
+			= redirect_index - current_y[current_screen];
+		while (current_item_index[current_screen] < 0) {
+			current_item_index[current_screen]++;
+			current_y[current_screen]--;
+		}
+		show_list(dp);
+	} else if (is_deleted_domain(dp, current)) {
+		return false;
+	}
+	free(current_domain);
+	current_domain = strdup(domain_name(dp, current));
+	if (!current_domain)
+		out_of_memory();
+	return true;
+}
+
 static int select_window(struct domain_policy *dp, const int current)
 {
 	const _Bool s_ok = offline_mode ||
@@ -1906,8 +2256,9 @@
 	if (d_ok)
 		printw("d     <<< Domain Transition Editor >>>\n");
 	if (d_ok && current_screen == SCREEN_DOMAIN_LIST &&
-	    !is_initializer_source(dp, current) &&
-	    !is_deleted_domain(dp, current))
+	    (current > dp->list_len ||
+	     (!is_initializer_source(dp, current) &&
+	      !is_deleted_domain(dp, current))))
 		printw("a     <<< Domain Policy Editor >>>\n");
 	printw("p     <<< Profile Editor >>>\n");
 	printw("m     <<< Manager Policy Editor >>>\n");
@@ -1927,16 +2278,8 @@
 		if (d_ok && (c == 'D' || c == 'd'))
 			return SCREEN_DOMAIN_LIST;
 		if (d_ok && (c == 'A' || c == 'a')) {
-			if (current_screen == SCREEN_DOMAIN_LIST &&
-			    !is_initializer_source(dp, current) &&
-			    !is_deleted_domain(dp, current)) {
-				free(current_domain);
-				current_domain = strdup(domain_name(dp,
-								    current));
-				if (!current_domain)
-					out_of_memory();
+			if (select_acl_window(dp, current, false))
 				return SCREEN_ACL_LIST;
-			}
 		}
 		if (c == 'P' || c == 'p')
 			return SCREEN_PROFILE_LIST;
@@ -1957,6 +2300,67 @@
 	}
 }
 
+static void copy_mark_state(struct domain_policy *dp, const int current)
+{
+	int index = list_item_count[current_screen];
+	if (current_screen == SCREEN_DOMAIN_LIST) {
+		if (current >= index) {
+			const u8 selected = task_list[current - index].selected;
+			for (index = current - index; index < task_list_len;
+			     index++)
+				task_list[index].selected = selected;
+		} else {
+			const u8 selected = dp->list_selected[current];
+			if (is_deleted_domain(dp, current) ||
+			    is_initializer_source(dp, current))
+				return;
+			for (index = current;
+			     index < dp->list_len; index++) {
+				if (is_deleted_domain(dp, index) ||
+				    is_initializer_source(dp, index))
+					continue;
+				dp->list_selected[index] = selected;
+			}
+		}
+	} else {
+		const u8 selected = generic_acl_list[current].selected;
+		for (index = current; index < generic_acl_list_count; index++)
+			generic_acl_list[index].selected = selected;
+	}
+	show_list(dp);
+}
+
+static void copy_to_history(struct domain_policy *dp, const int current,
+			    struct readline_data *rl)
+{
+	const char *line;
+	if (current == EOF)
+		return;
+	get();
+	switch (current_screen) {
+		u8 directive;
+	case SCREEN_DOMAIN_LIST:
+		line = domain_name(dp, current);
+		break;
+	case SCREEN_SYSTEM_LIST:
+	case SCREEN_EXCEPTION_LIST:
+	case SCREEN_ACL_LIST:
+		directive = generic_acl_list[current].directive;
+		shprintf("%s %s", directives[directive].alias,
+			 generic_acl_list[current].operand);
+		line = shared_buffer;
+		break;
+	case SCREEN_MEMINFO_LIST:
+		line = NULL;
+		break;
+	default:
+		shprintf("%s", generic_acl_list[current].operand);
+		line = shared_buffer;
+	}
+	rl->count = simple_add_history(line, rl->history, rl->count, rl->max);
+	put();
+}
+
 static int generic_list_loop(struct domain_policy *dp)
 {
 	static struct readline_data rl;
@@ -2003,7 +2407,7 @@
 start:
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		read_domain_and_exception_policy(dp);
-		adjust_cursor_pos(dp->list_len);
+		adjust_cursor_pos(dp->list_len + task_list_len);
 	} else {
 		read_generic_policy();
 		adjust_cursor_pos(generic_acl_list_count);
@@ -2032,7 +2436,7 @@
 		if (c == '\t') {
 			if (current_screen == SCREEN_DOMAIN_LIST) {
 				if (ccs_major == 2 && ccs_minor == 2)
-					return SCREEN_EXCEPTION_LIST; 
+					return SCREEN_EXCEPTION_LIST;
 				return SCREEN_SYSTEM_LIST;
 			} else if (current_screen == SCREEN_SYSTEM_LIST) {
 				return SCREEN_EXCEPTION_LIST;
@@ -2047,8 +2451,6 @@
 		if (c == ERR)
 			continue; /* Ignore invalid key. */
 		switch (c) {
-			int index;
-			const char *line;
 		case KEY_RESIZE:
 			resize_window();
 			show_list(dp);
@@ -2072,30 +2474,7 @@
 		case 'C':
 			if (current == EOF)
 				break;
-			if (current_screen == SCREEN_DOMAIN_LIST) {
-				const u8 selected
-					= dp->list_selected[current];
-				if (is_deleted_domain(dp, current) ||
-				    is_initializer_source(dp, current))
-					break;
-				for (index = current;
-				     index < dp->list_len; index++) {
-					if (is_deleted_domain(dp, index) ||
-					    is_initializer_source(dp, index))
-						continue;
-					dp->list_selected[index]
-						= selected;
-				}
-			} else {
-				const u8 selected
-					= generic_acl_list[current].selected;
-				for (index = current;
-				     index < generic_acl_list_count; index++) {
-					generic_acl_list[index].selected
-						= selected;
-				}
-			}
-			show_list(dp);
+			copy_mark_state(dp, current);
 			break;
 		case 'f':
 		case 'F':
@@ -2151,35 +2530,8 @@
 			break;
 		case '\r':
 		case '\n':
-			if (current_screen != SCREEN_DOMAIN_LIST)
-				break;
-			if (is_initializer_source(dp, current)) {
-				int redirect_index;
-				get();
-				shprintf(ROOT_NAME "%s",
-					 strrchr(domain_name(dp, current),
-						 ' '));
-				redirect_index = find_domain(dp, shared_buffer,
-							     false, false);
-				put();
-				if (redirect_index == EOF)
-					break;
-				current_item_index[current_screen]
-					= redirect_index
-					- current_y[current_screen];
-				while (current_item_index[current_screen] < 0) {
-					current_item_index[current_screen]++;
-					current_y[current_screen]--;
-				}
-				show_list(dp);
-			} else if (!is_deleted_domain(dp, current)) {
-				free(current_domain);
-				current_domain = strdup(domain_name(dp,
-								    current));
-				if (!current_domain)
-					out_of_memory();
+			if (select_acl_window(dp, current, true))
 				return SCREEN_ACL_LIST;
-			}
 			break;
 		case 's':
 		case 'S':
@@ -2215,33 +2567,7 @@
 			max_eat_col[current_screen] = max_col;
 			goto start2;
 		case KEY_IC:
-			if (current == EOF)
-				break;
-			get();
-			switch (current_screen) {
-				u8 directive;
-			case SCREEN_DOMAIN_LIST:
-				line = domain_name(dp, current);
-				break;
-			case SCREEN_SYSTEM_LIST:
-			case SCREEN_EXCEPTION_LIST:
-			case SCREEN_ACL_LIST:
-				directive = generic_acl_list[current].directive;
-				shprintf("%s %s", directives[directive].alias,
-					 generic_acl_list[current].operand);
-				line = shared_buffer;
-				break;
-			case SCREEN_MEMINFO_LIST:
-				line = NULL;
-				break;
-			default:
-				shprintf("%s",
-					 generic_acl_list[current].operand);
-				line = shared_buffer;
-			}
-			rl.count = simple_add_history(line, rl.history,
-						      rl.count, rl.max);
-			put();
+			copy_to_history(dp, current, &rl);
 			break;
 		case 'o':
 		case 'O':
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstree.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstree.c	(revision 2496)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstree.c	(working copy)
@@ -10,84 +10,6 @@
  */
 #include "ccstools.h"
 
-static pid_t get_ppid(const pid_t pid)
-{
-	char buffer[1024];
-	FILE *fp;
-	pid_t ppid = 1;
-	memset(buffer, 0, sizeof(buffer));
-	snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
-	fp = fopen(buffer, "r");
-	if (fp) {
-		while (memset(buffer, 0, sizeof(buffer)),
-		       fgets(buffer, sizeof(buffer) - 1, fp)) {
-			if (sscanf(buffer, "PPid: %u", &ppid) == 1)
-				break;
-		}
-		fclose(fp);
-	}
-	return ppid;
-}
-
-static char *get_name(const pid_t pid)
-{
-	char buffer[1024];
-	FILE *fp;
-	memset(buffer, 0, sizeof(buffer));
-	snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
-	fp = fopen(buffer, "r");
-	if (fp) {
-		static const int offset = sizeof(buffer) / 6;
-		while (memset(buffer, 0, sizeof(buffer)),
-		       fgets(buffer, sizeof(buffer) - 1, fp)) {
-			if (!strncmp(buffer, "Name:\t", 6)) {
-				char *cp = buffer + 6;
-				memmove(buffer, cp, strlen(cp) + 1);
-				cp = strchr(buffer, '\n');
-				if (cp)
-					*cp = '\0';
-				break;
-			}
-		}
-		fclose(fp);
-		if (buffer[0] && strlen(buffer) < offset - 1) {
-			const char *src = buffer;
-			char *dest = buffer + offset;
-			while (1) {
-				unsigned char c = *src++;
-				if (!c) {
-					*dest = '\0';
-					break;
-				}
-				if (c == '\\') {
-					c = *src++;
-					if (c == '\\') {
-						memmove(dest, "\\\\", 2);
-						dest += 2;
-					} else if (c == 'n') {
-						memmove(dest, "\\012", 4);
-						dest += 4;
-					} else {
-						break;
-					}
-				} else if (c > ' ' && c <= 126) {
-					*dest++ = c;
-				} else {
-					*dest++ = '\\';
-					*dest++ = (c >> 6) + '0';
-					*dest++ = ((c >> 3) & 7) + '0';
-					*dest++ = (c & 7) + '0';
-				}
-			}
-			return strdup(buffer + offset);
-		}
-	}
-	return NULL;
-}
-
-static struct task_entry *task_list = NULL;
-static int task_list_len = 0;
-
 static void dump(const pid_t pid, const int depth)
 {
 	int i;
@@ -102,7 +24,7 @@
 			printf("  +-");
 		printf(" %s (%u) %s\n", task_list[i].name,
 		       task_list[i].pid, task_list[i].domain);
-		task_list[i].done = true;
+		task_list[i].selected = true;
 	}
 	for (i = 0; i < task_list_len; i++) {
 		if (pid != task_list[i].ppid)
@@ -111,22 +33,8 @@
 	}
 }
 
-static void dump_unprocessed(void)
-{
-	int i;
-	for (i = 0; i < task_list_len; i++) {
-		if (task_list[i].done)
-			continue;
-		printf("%3d %s (%u) %s\n",
-		       task_list[i].profile, task_list[i].name,
-		       task_list[i].pid, task_list[i].domain);
-		task_list[i].done = true;
-	}
-}
-
 int ccstree_main(int argc, char *argv[])
 {
-	const char *policy_file = proc_policy_process_status;
 	static _Bool show_all = false;
 	int i;
 	for (i = 1; i < argc; i++) {
@@ -150,115 +58,32 @@
 			return 0;
 		}
 	}
-	if (network_mode) {
-		FILE *fp = open_write(show_all ? "proc:all_process_status" :
-				      "proc:process_status");
-		if (!fp) {
+	read_process_list(show_all);
+	if (!task_list_len) {
+		if (network_mode) {
 			fprintf(stderr, "Can't connect.\n");
 			return 1;
-		}
-		get();
-		while (freadline(fp)) {
-			unsigned int pid = 0;
-			unsigned int ppid = 0;
-			int profile = -1;
-			char *name;
-			char *domain;
-			sscanf(shared_buffer, "PID=%u PPID=%u", &pid, &ppid);
-			name = strstr(shared_buffer, "NAME=");
-			if (name)
-				name = strdup(name + 5);
-			if (!name)
-				name = "<UNKNOWN>";
-			if (!freadline(fp))
-				break;
-			sscanf(shared_buffer, "%u %u", &pid, &profile);
-			domain = strchr(shared_buffer, '<');
-			if (domain)
-				domain = strdup(domain);
-			if (!domain)
-				domain = "<UNKNOWN>";
-			task_list = realloc(task_list,
-					    (task_list_len + 1) *
-					    sizeof(struct task_entry));
-			if (!task_list)
-				out_of_memory();
-			task_list[task_list_len].pid = pid;
-			task_list[task_list_len].ppid = ppid;
-			task_list[task_list_len].profile = profile;
-			task_list[task_list_len].name = name;
-			task_list[task_list_len].domain = domain;
-			task_list[task_list_len].done = false;
-			task_list_len++;
-		}
-		put();
-		fclose(fp);
-	} else {
-		struct dirent **namelist;
-		int i;
-		int n;
-		int status_fd;
-		if (access(proc_policy_dir, F_OK)) {
+		} else {
 			fprintf(stderr, "You can't use this command "
 				"for this kernel.\n");
 			return 1;
 		}
-		status_fd = open(policy_file, O_RDWR);
-		if (status_fd == EOF) {
-			fprintf(stderr, "Can't open %s\n", policy_file);
-			return 1;
-		}
-		n = scandir("/proc/", &namelist, 0, 0);
-		for (i = 0; i < n; i++) {
-			char *name;
-			char *domain;
-			int profile = -1;
-			unsigned int pid = 0;
-			char buffer[128];
-			char test[16];
-			if (sscanf(namelist[i]->d_name, "%u", &pid) != 1)
-				goto skip;
-			memset(buffer, 0, sizeof(buffer));
-			snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/exe",
-				 pid);
-			if (!show_all &&
-			    readlink(buffer, test, sizeof(test)) <= 0)
-				goto skip;
-			name = get_name(pid);
-			if (!name)
-				name = "<UNKNOWN>";
-			snprintf(buffer, sizeof(buffer) - 1, "%u\n", pid);
-			write(status_fd, buffer, strlen(buffer));
-			get();
-			memset(shared_buffer, 0, sizeof(shared_buffer));
-			read(status_fd, shared_buffer,
-			     sizeof(shared_buffer) - 1);
-			sscanf(shared_buffer, "%u %u", &pid, &profile);
-			domain = strchr(shared_buffer, '<');
-			if (domain)
-				domain = strdup(domain);
-			if (!domain)
-				domain = "<UNKNOWN>";
-			put();
-			task_list = realloc(task_list, (task_list_len + 1) *
-					    sizeof(struct task_entry));
-			if (!task_list)
-				out_of_memory();
-			task_list[task_list_len].pid = pid;
-			task_list[task_list_len].ppid = get_ppid(pid);
-			task_list[task_list_len].profile = profile;
-			task_list[task_list_len].name = name;
-			task_list[task_list_len].domain = domain;
-			task_list[task_list_len].done = false;
-			task_list_len++;
-skip:
-			free((void *) namelist[i]);
-		}
-		if (n >= 0)
-			free((void *) namelist);
-		close(status_fd);
 	}
 	dump(1, 0);
-	dump_unprocessed();
+	for (i = 0; i < task_list_len; i++) {
+		if (task_list[i].selected)
+			continue;
+		printf("%3d %s (%u) %s\n",
+		       task_list[i].profile, task_list[i].name,
+		       task_list[i].pid, task_list[i].domain);
+		task_list[i].selected = true;
+	}
+	while (task_list_len) {
+		task_list_len--;
+		free((void *) task_list[task_list_len].name);
+		free((void *) task_list[task_list_len].domain);
+	}
+	free(task_list);
+	task_list = NULL;
 	return 0;
 }
Index: trunk/1.6.x/ccs-tools/ccstools/Makefile
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/Makefile	(revision 2496)
+++ trunk/1.6.x/ccs-tools/ccstools/Makefile	(working copy)
@@ -31,7 +31,7 @@
 
 CC=gcc
 
-CFLAGS=-Wall -O2 ${shell $(CC) -Wno-pointer-sign -S -o /dev/null -x c - < /dev/null > /dev/null 2>&1 && echo "-Wno-pointer-sign"}
+CFLAGS=-Wall -O0 -g ${shell $(CC) -Wno-pointer-sign -S -o /dev/null -x c - < /dev/null > /dev/null 2>&1 && echo "-Wno-pointer-sign"}
 
 /usr/include/curses.h:
 	@echo "/usr/include/curses.h is missing."
