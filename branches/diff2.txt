Index: trunk/1.7.x/ccs-patch/security/ccsecurity/load_policy.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/load_policy.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/load_policy.c	(working copy)
@@ -85,6 +85,25 @@
 #endif
 
 /**
+ * ccs_check_profile - Check all profiles currently assigned to domains are defined.
+ */
+static void ccs_check_profile(void)
+{
+	struct ccs_domain_info *domain;
+	ccs_policy_loaded = true;
+	list_for_each_entry_rcu(domain, &ccsecurity.domain, list) {
+		const u8 profile = domain->profile;
+		if (ccs_profile_ptr[profile])
+			continue;
+		panic("Profile %u (used by '%s') not defined.\n",
+		      profile, domain->domainname->name);
+	}
+	if (ccs_profile_version != 20090903)
+		panic("Profile version %u is not supported.\n",
+		      ccs_profile_version);
+}
+
+/**
  * ccs_load_policy - Run external policy loader to load policy.
  *
  * @filename: The program about to start.
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/address_group.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/address_group.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/address_group.c	(working copy)
@@ -1,229 +0,0 @@
-/*
- * security/ccsecurity/address_group.c
- *
- * Copyright (C) 2005-2009  NTT DATA CORPORATION
- *
- * Version: 1.7.1   2009/11/11
- *
- * This file is applicable to both 2.4.30 and 2.6.11 and later.
- * See README.ccs for ChangeLog.
- *
- */
-
-#include <linux/slab.h>
-#include "internal.h"
-
-/* The list for "struct ccs_address_group". */
-LIST_HEAD(ccs_address_group_list);
-
-/**
- * ccs_get_address_group - Allocate memory for "struct ccs_address_group".
- *
- * @group_name: The name of address group.
- *
- * Returns pointer to "struct ccs_address_group" on success,
- * NULL otherwise.
- */
-struct ccs_address_group *ccs_get_address_group(const char *group_name)
-{
-	struct ccs_address_group *entry = NULL;
-	struct ccs_address_group *group;
-	const struct ccs_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
-	    !group_name[0])
-		return NULL;
-	saved_group_name = ccs_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(group, &ccs_address_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &ccs_address_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
-}
-
-/**
- * ccs_write_address_group_policy - Write "struct ccs_address_group" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_address_group_policy(char *data, const bool is_delete)
-{
-	struct ccs_address_group *group;
-	struct ccs_address_group_member *entry = NULL;
-	struct ccs_address_group_member *member;
-	struct ccs_address_group_member e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	u16 min_address[8];
-	u16 max_address[8];
-	char *w[2];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	group = ccs_get_address_group(w[0]);
-	if (!group)
-		return -ENOMEM;
-	switch (ccs_parse_ip_address(w[1], min_address, max_address)) {
-	case 2:
-		e.is_ipv6 = true;
-		e.min.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
-						  min_address);
-		e.max.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
-						  max_address);
-		if (!e.min.ipv6 || !e.max.ipv6)
-			goto out;
-		break;
-	case 1:
-		e.min.ipv4 = ntohl(*(u32 *) min_address);
-		e.max.ipv4 = ntohl(*(u32 *) max_address);
-		break;
-	default:
-		goto out;
-	}
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (ccs_memcmp(member, &e, offsetof(typeof(e), is_ipv6),
-			       sizeof(e)))
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &group->member_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	if (e.is_ipv6) {
-		ccs_put_ipv6_address(e.min.ipv6);
-		ccs_put_ipv6_address(e.max.ipv6);
-	}
-	ccs_put_address_group(group);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_address_group_policy - Read "struct ccs_address_group" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_address_group_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &ccs_address_group_list) {
-		struct ccs_address_group *group;
-		group = list_entry(gpos, struct ccs_address_group, list);
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			char buf[128];
-			struct ccs_address_group_member *member;
-			member = list_entry(mpos,
-					    struct ccs_address_group_member,
-					    list);
-			if (member->is_deleted)
-				continue;
-			if (member->is_ipv6) {
-				const struct in6_addr *min_address
-					= member->min.ipv6;
-				const struct in6_addr *max_address
-					= member->max.ipv6;
-				ccs_print_ipv6(buf, sizeof(buf), min_address);
-				if (min_address != max_address) {
-					int len;
-					char *cp = buf + strlen(buf);
-					*cp++ = '-';
-					len = strlen(buf);
-					ccs_print_ipv6(cp, sizeof(buf) - len,
-						       max_address);
-				}
-			} else {
-				const u32 min_address = member->min.ipv4;
-				const u32 max_address = member->max.ipv4;
-				memset(buf, 0, sizeof(buf));
-				snprintf(buf, sizeof(buf) - 1, "%u.%u.%u.%u",
-					 HIPQUAD(min_address));
-				if (min_address != max_address) {
-					const int len = strlen(buf);
-					snprintf(buf + len,
-						 sizeof(buf) - 1 - len,
-						 "-%u.%u.%u.%u",
-						 HIPQUAD(max_address));
-				}
-			}
-			if (!ccs_io_printf(head, CCS_KEYWORD_ADDRESS_GROUP
-					   "%s %s\n", group->group_name->name,
-					   buf))
-				return false;
-		}
-	}
-	return true;
-}
-
-/**
- * ccs_address_matches_group - Check whether the given address matches members of the given address group.
- *
- * @is_ipv6: True if @address is an IPv6 address.
- * @address: An IPv4 or IPv6 address.
- * @group:   Pointer to "struct ccs_address_group".
- *
- * Returns true if @address matches addresses in @group group, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
-			       const struct ccs_address_group *group)
-{
-	struct ccs_address_group_member *member;
-	const u32 ip = ntohl(*address);
-	bool matched = false;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->is_deleted)
-			continue;
-		if (member->is_ipv6) {
-			if (is_ipv6 &&
-			    memcmp(member->min.ipv6, address, 16) <= 0 &&
-			    memcmp(address, member->max.ipv6, 16) <= 0) {
-				matched = true;
-				break;
-			}
-		} else {
-			if (!is_ipv6 &&
-			    member->min.ipv4 <= ip && ip <= member->max.ipv4) {
-				matched = true;
-				break;
-			}
-		}
-	}
-	return matched;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/mount.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/mount.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/mount.c	(working copy)
@@ -96,7 +96,7 @@
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 /* For compatibility with older kernels. */
-static void put_filesystem(struct file_system_type *fs)
+static inline void put_filesystem(struct file_system_type *fs)
 {
 	module_put(fs->owner);
 }
@@ -346,59 +346,3 @@
 	ccs_read_unlock(idx);
 	return error;
 }
-
-/**
- * ccs_write_mount_policy - Write "struct ccs_mount_acl" list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_mount_policy(char *data, struct ccs_domain_info *domain,
-			   struct ccs_condition *condition,
-			   const bool is_delete)
-{
-	struct ccs_mount_acl *entry = NULL;
-	struct ccs_acl_info *ptr;
-	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL,
-				   .head.cond = condition };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	char *w[4];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[3][0])
-		return -EINVAL;
-	if (!ccs_parse_name_union(w[0], &e.dev_name) ||
-	    !ccs_parse_name_union(w[1], &e.dir_name) ||
-	    !ccs_parse_name_union(w[2], &e.fs_type) ||
-	    !ccs_parse_number_union(w[3], &e.flags))
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_mount_acl *acl =
-			container_of(ptr, struct ccs_mount_acl, head);
-		if (ptr->type != CCS_TYPE_MOUNT_ACL || ptr->cond != condition
-		    || ccs_memcmp(acl, &e, offsetof(typeof(e), dev_name),
-				  sizeof(e)))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name_union(&e.dev_name);
-	ccs_put_name_union(&e.dir_name);
-	ccs_put_name_union(&e.fs_type);
-	ccs_put_number_union(&e.flags);
-	kfree(entry);
-	return error;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/number_group.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/number_group.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/number_group.c	(working copy)
@@ -13,143 +13,7 @@
 #include <linux/slab.h>
 #include "internal.h"
 
-/* The list for "struct ccs_number_group". */
-LIST_HEAD(ccs_number_group_list);
-
 /**
- * ccs_get_number_group - Allocate memory for "struct ccs_number_group".
- *
- * @group_name: The name of number group.
- *
- * Returns pointer to "struct ccs_number_group" on success,
- * NULL otherwise.
- */
-struct ccs_number_group *ccs_get_number_group(const char *group_name)
-{
-	struct ccs_number_group *entry = NULL;
-	struct ccs_number_group *group;
-	const struct ccs_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
-	    !group_name[0])
-		return NULL;
-	saved_group_name = ccs_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(group, &ccs_number_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &ccs_number_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
-}
-
-/**
- * ccs_write_number_group_policy - Write "struct ccs_number_group" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, nagative value otherwise.
- */
-int ccs_write_number_group_policy(char *data, const bool is_delete)
-{
-	struct ccs_number_group *group;
-	struct ccs_number_group_member *entry = NULL;
-	struct ccs_number_group_member e = { };
-	struct ccs_number_group_member *member;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	char *w[2];
-	if (!ccs_tokenize(data, w, sizeof(w)))
-		return -EINVAL;
-	if (!ccs_parse_number_union(w[1], &e.number))
-		return -EINVAL;
-	if (e.number.is_group || e.number.values[0] > e.number.values[1]) {
-		ccs_put_number_union(&e.number);
-		return -EINVAL;
-	}
-	group = ccs_get_number_group(w[0]);
-	if (!group)
-		return -ENOMEM;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (memcmp(&member->number, &e.number, sizeof(e.number)))
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &group->member_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_number_group(group);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_number_group_policy - Read "struct ccs_number_group" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_number_group_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &ccs_number_group_list) {
-		struct ccs_number_group *group;
-		const char *name;
-		group = list_entry(gpos, struct ccs_number_group, list);
-		name = group->group_name->name;
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			int pos;
-			const struct ccs_number_group_member *member
-				= list_entry(mpos,
-					     struct ccs_number_group_member,
-					     list);
-			if (member->is_deleted)
-				continue;
-			pos = head->read_avail;
-			if (!ccs_io_printf(head, CCS_KEYWORD_NUMBER_GROUP "%s",
-					   name) ||
-			    !ccs_print_number_union(head, &member->number) ||
-			    !ccs_io_printf(head, "\n")) {
-				head->read_avail = pos;
-				return false;
-			}
-		}
-	}
-	return true;
-}
-
-/**
  * ccs_number_matches_group - Check whether the given number matches members of the given number group.
  *
  * @min:   Min number.
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/autobind.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/autobind.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/autobind.c	(working copy)
@@ -12,67 +12,9 @@
 
 #include "internal.h"
 
-/* The list for "struct ccs_reserved_entry". */
-LIST_HEAD(ccs_reservedport_list);
+u8 ccs_reserved_port_map[8192];
 
-static u8 ccs_reserved_port_map[8192];
-
 /**
- * ccs_update_reserved_entry - Update "struct ccs_reserved_entry" list.
- *
- * @min_port: Start of port number range.
- * @max_port: End of port number range.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_reserved_entry(const u16 min_port, const u16 max_port,
-				     const bool is_delete)
-{
-	struct ccs_reserved_entry *ptr;
-	struct ccs_reserved_entry e = {
-		.min_port = min_port,
-		.max_port = max_port
-	};
-	int error = -ENOMEM;
-	u8 *ccs_tmp_map = kzalloc(8192, GFP_KERNEL);
-	struct ccs_reserved_entry *entry = kmalloc(sizeof(e), GFP_KERNEL);
-	if (!ccs_tmp_map || !entry) {
-		kfree(entry);
-		kfree(ccs_tmp_map);
-		return -ENOMEM;
-	}
-	if (is_delete)
-		error = -ENOENT;
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
-		if (ptr->min_port != min_port || ptr->max_port != max_port)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_reservedport_list);
-		entry = NULL;
-		error = 0;
-	}
-	list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
-		unsigned int port;
-		if (ptr->is_deleted)
-			continue;
-		for (port = ptr->min_port; port <= ptr->max_port; port++)
-			ccs_tmp_map[port >> 8] |= 1 << (port & 7);
-	}
-	memmove(ccs_reserved_port_map, ccs_tmp_map,
-		sizeof(ccs_reserved_port_map));
-	mutex_unlock(&ccs_policy_lock);
-	kfree(entry);
-	kfree(ccs_tmp_map);
-	return error;
-}
-
-/**
  * ccs_lport_reserved - Check permission for bind()'s automatic port number selection.
  *
  * @port: Port number.
@@ -85,60 +27,3 @@
 		? true : false;
 }
 EXPORT_SYMBOL(ccs_lport_reserved); /* for net/ipv4/ and net/ipv6/ */
-
-/**
- * ccs_write_reserved_port_policy - Write "struct ccs_reserved_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_reserved_port_policy(char *data, const bool is_delete)
-{
-	unsigned int from;
-	unsigned int to;
-	if (strchr(data, ' '))
-		goto out;
-	if (sscanf(data, "%u-%u", &from, &to) == 2) {
-		if (from <= to && to < 65536)
-			return ccs_update_reserved_entry(from, to, is_delete);
-	} else if (sscanf(data, "%u", &from) == 1) {
-		if (from < 65536)
-			return ccs_update_reserved_entry(from, from, is_delete);
-	}
- out:
-	return -EINVAL;
-}
-
-/**
- * ccs_read_reserved_port_policy - Read "struct ccs_reserved_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	char buffer[16];
-	memset(buffer, 0, sizeof(buffer));
-	list_for_each_cookie(pos, head->read_var2, &ccs_reservedport_list) {
-		u16 min_port;
-		u16 max_port;
-		struct ccs_reserved_entry *ptr;
-		ptr = list_entry(pos, struct ccs_reserved_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		min_port = ptr->min_port;
-		max_port = ptr->max_port;
-		snprintf(buffer, sizeof(buffer) - 1, "%u%c%u", min_port,
-			 min_port != max_port ? '-' : '\0', max_port);
-		if (!ccs_io_printf(head, CCS_KEYWORD_DENY_AUTOBIND "%s\n",
-				   buffer))
-			return false;
-	}
-	return true;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/audit.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/audit.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/audit.c	(working copy)
@@ -395,6 +395,33 @@
 static unsigned int ccs_audit_log_count[2];
 
 /**
+ * ccs_get_audit - Get audit mode.
+ *
+ * @profile:    Profile number.
+ * @index:      Index number of functionality.
+ * @is_granted: True if granted log, false otherwise.
+ *
+ * Returns mode.
+ */
+static bool ccs_get_audit(const u8 profile, const u8 index,
+			  const bool is_granted)
+{
+	u8 mode;
+	const u8 category = ccs_index2category[index] + CCS_MAX_MAC_INDEX
+		+ CCS_MAX_CAPABILITY_INDEX;
+	if (!ccs_policy_loaded)
+		return false;
+	mode = ccs_profile(profile)->config[index];
+	if (mode == CCS_CONFIG_USE_DEFAULT)
+		mode = ccs_profile(profile)->config[category];
+	if (mode == CCS_CONFIG_USE_DEFAULT)
+		mode = ccs_profile(profile)->default_config;
+	if (is_granted)
+		return mode & CCS_CONFIG_WANT_GRANT_LOG;
+	return mode & CCS_CONFIG_WANT_REJECT_LOG;
+}
+
+/**
  * ccs_write_audit_log - Write audit log.
  *
  * @is_granted: True if this is a granted log.
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c	(working copy)
@@ -24,12 +24,6 @@
 
 /* Variables definitions.*/
 
-/* The initial domain. */
-struct ccs_domain_info ccs_kernel_domain;
-
-/* The list for "struct ccs_domain_info". */
-LIST_HEAD(ccs_domain_list);
-
 /**
  * ccs_audit_execute_handler_log - Audit execute_handler log.
  *
@@ -69,127 +63,7 @@
 	return ccs_write_audit_log(false, &r, "use_profile %u\n", r.profile);
 }
 
-/* The list for "struct ccs_domain_initializer_entry". */
-LIST_HEAD(ccs_domain_initializer_list);
-
 /**
- * ccs_update_domain_initializer_entry - Update "struct ccs_domain_initializer_entry" list.
- *
- * @domainname: The name of domain. May be NULL.
- * @program:    The name of program.
- * @is_not:     True if it is "no_initialize_domain" entry.
- * @is_delete:  True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_domain_initializer_entry(const char *domainname,
-					       const char *program,
-					       const bool is_not,
-					       const bool is_delete)
-{
-	struct ccs_domain_initializer_entry *entry = NULL;
-	struct ccs_domain_initializer_entry *ptr;
-	struct ccs_domain_initializer_entry e = { .is_not = is_not };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(program, 1, -1, -1))
-		return -EINVAL; /* No patterns allowed. */
-	if (domainname) {
-		if (!ccs_is_domain_def(domainname) &&
-		    ccs_is_correct_path(domainname, 1, -1, -1))
-			e.is_last_name = true;
-		else if (!ccs_is_correct_domain(domainname))
-			return -EINVAL;
-		e.domainname = ccs_get_name(domainname);
-		if (!e.domainname)
-			goto out;
-	}
-	e.program = ccs_get_name(program);
-	if (!e.program)
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_domain_initializer_list, list) {
-		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), is_not),
-			       sizeof(e)))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_domain_initializer_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.domainname);
-	ccs_put_name(e.program);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_domain_initializer_policy - Read "struct ccs_domain_initializer_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_domain_initializer_list) {
-		const char *no;
-		const char *from = "";
-		const char *domain = "";
-		struct ccs_domain_initializer_entry *ptr;
-		ptr = list_entry(pos, struct ccs_domain_initializer_entry,
-				 list);
-		if (ptr->is_deleted)
-			continue;
-		no = ptr->is_not ? "no_" : "";
-		if (ptr->domainname) {
-			from = " from ";
-			domain = ptr->domainname->name;
-		}
-		done = ccs_io_printf(head, "%s" CCS_KEYWORD_INITIALIZE_DOMAIN
-				     "%s%s%s\n", no, ptr->program->name, from,
-				     domain);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
- * ccs_write_domain_initializer_policy - Write "struct ccs_domain_initializer_entry" list.
- *
- * @data:      String to parse.
- * @is_not:    True if it is "no_initialize_domain" entry.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_domain_initializer_policy(char *data, const bool is_not,
-					const bool is_delete)
-{
-	char *cp = strstr(data, " from ");
-	if (cp) {
-		*cp = '\0';
-		return ccs_update_domain_initializer_entry(cp + 6, data,
-							   is_not, is_delete);
-	}
-	return ccs_update_domain_initializer_entry(NULL, data, is_not,
-						   is_delete);
-}
-
-/**
  * ccs_is_domain_initializer - Check whether the given program causes domainname reinitialization.
  *
  * @domainname: The name of domain.
@@ -207,7 +81,7 @@
 {
 	struct ccs_domain_initializer_entry *ptr;
 	bool flag = false;
-	list_for_each_entry_rcu(ptr, &ccs_domain_initializer_list, list) {
+	list_for_each_entry_rcu(ptr, &ccsecurity.domain_initializer, list) {
 		if (ptr->is_deleted)
 			continue;
 		if (ptr->domainname) {
@@ -230,124 +104,7 @@
 	return flag;
 }
 
-/* The list for "struct ccs_domain_keeper_entry". */
-LIST_HEAD(ccs_domain_keeper_list);
-
 /**
- * ccs_update_domain_keeper_entry - Update "struct ccs_domain_keeper_entry" list.
- *
- * @domainname: The name of domain.
- * @program:    The name of program. May be NULL.
- * @is_not:     True if it is "no_keep_domain" entry.
- * @is_delete:  True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_domain_keeper_entry(const char *domainname,
-					  const char *program,
-					  const bool is_not,
-					  const bool is_delete)
-{
-	struct ccs_domain_keeper_entry *entry = NULL;
-	struct ccs_domain_keeper_entry *ptr;
-	struct ccs_domain_keeper_entry e = { .is_not = is_not };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_domain_def(domainname) &&
-	    ccs_is_correct_path(domainname, 1, -1, -1))
-		e.is_last_name = true;
-	else if (!ccs_is_correct_domain(domainname))
-		return -EINVAL;
-	if (program) {
-		if (!ccs_is_correct_path(program, 1, -1, -1))
-			return -EINVAL;
-		e.program = ccs_get_name(program);
-		if (!e.program)
-			goto out;
-	}
-	e.domainname = ccs_get_name(domainname);
-	if (!e.domainname)
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_domain_keeper_list, list) {
-		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), is_not),
-			       sizeof(e)))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_domain_keeper_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.domainname);
-	ccs_put_name(e.program);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_write_domain_keeper_policy - Write "struct ccs_domain_keeper_entry" list.
- *
- * @data:      String to parse.
- * @is_not:    True if it is "no_keep_domain" entry.
- * @is_delete: True if it is a delete request.
- *
- */
-int ccs_write_domain_keeper_policy(char *data, const bool is_not,
-				   const bool is_delete)
-{
-	char *cp = strstr(data, " from ");
-	if (cp) {
-		*cp = '\0';
-		return ccs_update_domain_keeper_entry(cp + 6, data,
-						      is_not, is_delete);
-	}
-	return ccs_update_domain_keeper_entry(data, NULL, is_not, is_delete);
-}
-
-/**
- * ccs_read_domain_keeper_policy - Read "struct ccs_domain_keeper_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_domain_keeper_list) {
-		struct ccs_domain_keeper_entry *ptr;
-		const char *no;
-		const char *from = "";
-		const char *program = "";
-		ptr = list_entry(pos, struct ccs_domain_keeper_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		no = ptr->is_not ? "no_" : "";
-		if (ptr->program) {
-			from = " from ";
-			program = ptr->program->name;
-		}
-		done = ccs_io_printf(head, "%s" CCS_KEYWORD_KEEP_DOMAIN
-				     "%s%s%s\n", no, program, from,
-				     ptr->domainname->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
  * ccs_is_domain_keeper - Check whether the given program causes domain transition suppression.
  *
  * @domainname: The name of domain.
@@ -365,7 +122,7 @@
 {
 	struct ccs_domain_keeper_entry *ptr;
 	bool flag = false;
-	list_for_each_entry_rcu(ptr, &ccs_domain_keeper_list, list) {
+	list_for_each_entry_rcu(ptr, &ccsecurity.domain_keeper, list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!ptr->is_last_name) {
@@ -386,100 +143,6 @@
 	return flag;
 }
 
-/* The list for "struct ccs_aggregator_entry". */
-LIST_HEAD(ccs_aggregator_list);
-
-/**
- * ccs_update_aggregator_entry - Update "struct ccs_aggregator_entry" list.
- *
- * @original_name:   The original program's name.
- * @aggregated_name: The aggregated program's name.
- * @is_delete:       True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_aggregator_entry(const char *original_name,
-				       const char *aggregated_name,
-				       const bool is_delete)
-{
-	struct ccs_aggregator_entry *entry = NULL;
-	struct ccs_aggregator_entry *ptr;
-	struct ccs_aggregator_entry e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(original_name, 1, 0, -1) ||
-	    !ccs_is_correct_path(aggregated_name, 1, -1, -1))
-		return -EINVAL;
-	e.original_name = ccs_get_name(original_name);
-	e.aggregated_name = ccs_get_name(aggregated_name);
-	if (!e.original_name || !e.aggregated_name)
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_aggregator_list, list) {
-		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), original_name),
-			       sizeof(e)))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_aggregator_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.original_name);
-	ccs_put_name(e.aggregated_name);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_aggregator_policy - Read "struct ccs_aggregator_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_aggregator_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2, &ccs_aggregator_list) {
-		struct ccs_aggregator_entry *ptr;
-		ptr = list_entry(pos, struct ccs_aggregator_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_AGGREGATOR "%s %s\n",
-				     ptr->original_name->name,
-				     ptr->aggregated_name->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
- * ccs_write_aggregator_policy - Write "struct ccs_aggregator_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_aggregator_policy(char *data, const bool is_delete)
-{
-	char *w[2];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	return ccs_update_aggregator_entry(w[0], w[1], is_delete);
-}
-
 /* Domain create/delete handler. */
 
 /**
@@ -495,9 +158,9 @@
 	struct ccs_path_info name;
 	name.name = domainname;
 	ccs_fill_path_info(&name);
-	mutex_lock(&ccs_policy_lock);
+	mutex_lock(&ccsecurity.policy_lock);
 	/* Is there an active domain? */
-	list_for_each_entry_rcu(domain, &ccs_domain_list, list) {
+	list_for_each_entry_rcu(domain, &ccsecurity.domain, list) {
 		/* Never delete ccs_kernel_domain */
 		if (domain == &ccs_kernel_domain)
 			continue;
@@ -507,7 +170,7 @@
 		domain->is_deleted = true;
 		break;
 	}
-	mutex_unlock(&ccs_policy_lock);
+	mutex_unlock(&ccsecurity.policy_lock);
 	return 0;
 }
 
@@ -533,8 +196,8 @@
 	if (!saved_domainname)
 		return NULL;
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(domain, &ccs_domain_list, list) {
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(domain, &ccsecurity.domain, list) {
 		if (domain->is_deleted ||
 		    ccs_pathcmp(saved_domainname, domain->domainname))
 			continue;
@@ -546,12 +209,12 @@
 		entry->domainname = saved_domainname;
 		saved_domainname = NULL;
 		entry->profile = profile;
-		list_add_tail_rcu(&entry->list, &ccs_domain_list);
+		list_add_tail_rcu(&entry->list, &ccsecurity.domain);
 		domain = entry;
 		entry = NULL;
 		found = true;
 	}
-	mutex_unlock(&ccs_policy_lock);
+	mutex_unlock(&ccsecurity.policy_lock);
 	ccs_put_name(saved_domainname);
 	kfree(entry);
 	return found ? domain : NULL;
@@ -608,7 +271,7 @@
 	} else {
 		struct ccs_aggregator_entry *ptr;
 		/* Check 'aggregator' directive. */
-		list_for_each_entry_rcu(ptr, &ccs_aggregator_list, list) {
+		list_for_each_entry_rcu(ptr, &ccsecurity.aggregator, list) {
 			if (ptr->is_deleted ||
 			    !ccs_path_matches_pattern(&rn, ptr->original_name))
 				continue;
@@ -813,7 +476,7 @@
  *
  * Returns number of directories to strip.
  */
-static inline int ccs_root_depth(struct dentry *dentry, struct vfsmount *vfsmnt)
+static int ccs_root_depth(struct dentry *dentry, struct vfsmount *vfsmnt)
 {
 	int depth = 0;
 	ccs_realpath_lock();
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/path_group.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/path_group.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/path_group.c	(working copy)
@@ -11,134 +11,8 @@
  */
 
 #include "internal.h"
-/* The list for "struct ccs_path_group". */
-LIST_HEAD(ccs_path_group_list);
 
 /**
- * ccs_get_path_group - Allocate memory for "struct ccs_path_group".
- *
- * @group_name: The name of pathname group.
- *
- * Returns pointer to "struct ccs_path_group" on success, NULL otherwise.
- */
-struct ccs_path_group *ccs_get_path_group(const char *group_name)
-{
-	struct ccs_path_group *entry = NULL;
-	struct ccs_path_group *group;
-	const struct ccs_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
-	    !group_name[0])
-		return NULL;
-	saved_group_name = ccs_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(group, &ccs_path_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &ccs_path_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
-}
-
-/**
- * ccs_write_path_group_policy - Write "struct ccs_path_group" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, nagative value otherwise.
- */
-int ccs_write_path_group_policy(char *data, const bool is_delete)
-{
-	struct ccs_path_group *group;
-	struct ccs_path_group_member *entry = NULL;
-	struct ccs_path_group_member *member;
-	struct ccs_path_group_member e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	char *w[2];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	group = ccs_get_path_group(w[0]);
-	if (!group)
-		return -ENOMEM;
-	e.member_name = ccs_get_name(w[1]);
-	if (!e.member_name)
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->member_name != e.member_name)
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &group->member_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.member_name);
-	ccs_put_path_group(group);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_path_group_policy - Read "struct ccs_path_group" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_path_group_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &ccs_path_group_list) {
-		struct ccs_path_group *group;
-		group = list_entry(gpos, struct ccs_path_group, list);
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			struct ccs_path_group_member *member;
-			member = list_entry(mpos, struct ccs_path_group_member,
-					    list);
-			if (member->is_deleted)
-				continue;
-			if (!ccs_io_printf(head, CCS_KEYWORD_PATH_GROUP
-					   "%s %s\n",
-					   group->group_name->name,
-					   member->member_name->name))
-				return false;
-		}
-	}
-	return true;
-}
-
-/**
  * ccs_path_matches_group - Check whether the given pathname matches members of the given pathname group.
  *
  * @pathname:        The name of pathname.
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/memory.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/memory.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/memory.c	(working copy)
@@ -15,23 +15,9 @@
 #include <linux/hash.h>
 #endif
 
-void ccs_warn_oom(const char *function)
-{
-	/* Reduce error messages. */
-	static pid_t ccs_last_pid;
-	const pid_t pid = current->pid;
-	if (ccs_last_pid != pid) {
-		printk(KERN_WARNING "ERROR: Out of memory at %s.\n",
-		       function);
-		ccs_last_pid = pid;
-	}
-	if (!ccs_policy_loaded)
-		panic("MAC Initialization failed.\n");
-}
+atomic_t ccs_policy_memory_size;
+unsigned int ccs_quota_for_policy;
 
-static atomic_t ccs_policy_memory_size;
-static unsigned int ccs_quota_for_policy;
-
 /**
  * ccs_memory_ok - Check memory quota.
  *
@@ -54,26 +40,6 @@
 }
 
 /**
- * ccs_commit_ok - Check memory quota.
- *
- * @ptr:    Pointer to allocated memory.
- * @data:   Data to copy from.
- * @size:   Size in byte.
- *
- * Returns true if @ptr is not NULL and quota not exceeded, false otherwise.
- */
-bool ccs_commit_ok(void *ptr, void *data, const unsigned int size)
-{
-	if (ccs_memory_ok(ptr, size)) {
-		memmove(ptr, data, size);
-		memset(data, 0, size);
-		return true;
-	}
-	return false;
-}
-
-
-/**
  * ccs_memory_free - Free memory for elements.
  *
  * @ptr:  Pointer to allocated memory.
@@ -85,8 +51,6 @@
 	kfree(ptr);
 }
 
-LIST_HEAD(ccs_address_list);
-
 /**
  * ccs_get_ipv6_address - Keep the given IPv6 address on the RAM.
  *
@@ -104,8 +68,8 @@
 	if (!addr)
 		return NULL;
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry(ptr, &ccs_address_list, list) {
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry(ptr, &ccsecurity.ipv6addr, list) {
 		if (memcmp(&ptr->addr, addr, sizeof(*addr)))
 			continue;
 		atomic_inc(&ptr->users);
@@ -116,10 +80,10 @@
 		ptr = entry;
 		ptr->addr = *addr;
 		atomic_set(&ptr->users, 1);
-		list_add_tail(&ptr->list, &ccs_address_list);
+		list_add_tail(&ptr->list, &ccsecurity.ipv6addr);
 		entry = NULL;
 	}
-	mutex_unlock(&ccs_policy_lock);
+	mutex_unlock(&ccsecurity.policy_lock);
 	kfree(entry);
 	return ptr ? &ptr->addr : NULL;
 }
@@ -193,7 +157,7 @@
 		INIT_LIST_HEAD(&ccs_name_list[i]);
 	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list);
 	ccs_kernel_domain.domainname = ccs_get_name(ROOT_NAME);
-	list_add_tail_rcu(&ccs_kernel_domain.list, &ccs_domain_list);
+	list_add_tail_rcu(&ccs_kernel_domain.list, &ccsecurity.domain);
 	if (ccs_find_domain(ROOT_NAME) != &ccs_kernel_domain)
 		panic("Can't register ccs_kernel_domain");
 	{
@@ -206,7 +170,7 @@
 			char *cp2 = strchr(cp, ' ');
 			if (cp2)
 				*cp2++ = '\0';
-			ccs_write_domain_initializer_policy(cp, false, false);
+			//ccs_write_domain_initializer_policy(cp, false, false);
 			cp = cp2;
 		}
 	}
@@ -224,61 +188,3 @@
 
 unsigned int ccs_query_memory_size;
 unsigned int ccs_quota_for_query;
-
-/**
- * ccs_read_memory_counter - Check for memory usage.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- */
-void ccs_read_memory_counter(struct ccs_io_buffer *head)
-{
-	const unsigned int usage[3] = {
-		atomic_read(&ccs_policy_memory_size),
-		ccs_audit_log_memory_size,
-		ccs_query_memory_size
-	};
-	const unsigned int quota[3] = {
-		ccs_quota_for_policy,
-		ccs_quota_for_audit_log,
-		ccs_quota_for_query
-	};
-	static const char *header[4] = {
-		"Policy:     ",
-		"Audit logs: ",
-		"Query lists:",
-		"Total:      "
-	};
-	unsigned int total = 0;
-	int i;
-	if (head->read_eof)
-		return;
-	for (i = 0; i < 3; i++) {
-		total += usage[i];
-		ccs_io_printf(head, "%s %10u", header[i], usage[i]);
-		if (quota[i])
-			ccs_io_printf(head, "   (Quota: %10u)", quota[i]);
-		ccs_io_printf(head, "\n");
-	}
-	ccs_io_printf(head, "%s %10u\n", header[3], total);
-	head->read_eof = true;
-}
-
-/**
- * ccs_write_memory_quota - Set memory quota.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0.
- */
-int ccs_write_memory_quota(struct ccs_io_buffer *head)
-{
-	char *data = head->write_buf;
-	unsigned int size;
-	if (sscanf(data, "Policy: %u", &size) == 1)
-		ccs_quota_for_policy = size;
-	else if (sscanf(data, "Audit logs: %u", &size) == 1)
-		ccs_quota_for_audit_log = size;
-	else if (sscanf(data, "Query lists: %u", &size) == 1)
-		ccs_quota_for_query = size;
-	return 0;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/util.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/util.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/util.c	(working copy)
@@ -12,15 +12,415 @@
 
 #include "internal.h"
 
-/* Lock for protecting policy. */
-DEFINE_MUTEX(ccs_policy_lock);
+struct ccsecurity_policy ccsecurity = {
+	.policy_lock = __MUTEX_INITIALIZER(ccsecurity.policy_lock),
+	.domain = LIST_HEAD_INIT(ccsecurity.domain),
+	.address_group = LIST_HEAD_INIT(ccsecurity.address_group),
+	.global_read = LIST_HEAD_INIT(ccsecurity.global_read),
+	.path_group = LIST_HEAD_INIT(ccsecurity.path_group),
+	.number_group = LIST_HEAD_INIT(ccsecurity.number_group),
+	.pattern = LIST_HEAD_INIT(ccsecurity.pattern),
+	.no_rewrite = LIST_HEAD_INIT(ccsecurity.no_rewrite),
+	.global_env = LIST_HEAD_INIT(ccsecurity.global_env),
+	.domain_initializer = LIST_HEAD_INIT(ccsecurity.domain_initializer),
+	.domain_keeper = LIST_HEAD_INIT(ccsecurity.domain_keeper),
+	.aggregator = LIST_HEAD_INIT(ccsecurity.aggregator),
+	.reservedport = LIST_HEAD_INIT(ccsecurity.reservedport),
+	.policy_manager = LIST_HEAD_INIT(ccsecurity.policy_manager),
+	.ipv6addr = LIST_HEAD_INIT(ccsecurity.ipv6addr),
+	.condition = LIST_HEAD_INIT(ccsecurity.condition),
+};
+EXPORT_SYMBOL(ccsecurity);
 
+int ccs_supervisor(struct ccs_request_info *r, const char *fmt, ...)
+{
+	return -EPERM;
+}
+int ccs_write_audit_log(const bool is_granted, struct ccs_request_info *r,
+			const char *fmt, ...)
+{
+	return -ENOMEM;
+}
+
+int ccs_start_execve(struct linux_binprm *bprm, struct ccs_execve_entry **eep)
+{
+	if (!ccs_policy_loaded)
+		ccs_load_policy(bprm->filename);
+	return 0;
+}
+
+void ccs_finish_execve(int retval, struct ccs_execve_entry *ee)
+{
+}
+
+/* The initial domain. */
+struct ccs_domain_info ccs_kernel_domain;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
+
+/* Lock for GC. */
+static struct srcu_struct ccs_ss;
+
+int ccs_read_lock(void)
+{
+	/*
+	 * Kernel might try to populate root fs before processing initcalls.
+	 * Thus, I can't use core_initcall() for initializing ccs_ss.
+	 */
+	if (!ccs_ss.per_cpu_ref) {
+		mutex_lock(&ccsecurity.policy_lock);
+		if (!ccs_ss.per_cpu_ref && init_srcu_struct(&ccs_ss))
+			panic("Out of memory.");
+		mutex_unlock(&ccsecurity.policy_lock);
+	}
+	return srcu_read_lock(&ccs_ss);
+}
+
+void ccs_read_unlock(const int idx)
+{
+	srcu_read_unlock(&ccs_ss, idx);
+}
+
+#else
+
+/* Lock for GC. */
+static struct {
+	int counter_idx;
+	int counter[2];
+} ccs_gc;
+static DEFINE_SPINLOCK(ccs_counter_lock);
+
+int ccs_read_lock(void)
+{
+	int idx;
+	spin_lock(&ccs_counter_lock);
+	idx = ccs_gc.counter_idx;
+	ccs_gc.counter[idx]++;
+	spin_unlock(&ccs_counter_lock);
+	return idx;
+}
+
+void ccs_read_unlock(const int idx)
+{
+	spin_lock(&ccs_counter_lock);
+	ccs_gc.counter[idx]--;
+	spin_unlock(&ccs_counter_lock);
+}
+
+#endif
+
+void ccs_warn_oom(const char *function)
+{
+	/* Reduce error messages. */
+	static pid_t ccs_last_pid;
+	const pid_t pid = current->pid;
+	if (ccs_last_pid != pid) {
+		printk(KERN_WARNING "ERROR: Out of memory at %s.\n",
+		       function);
+		ccs_last_pid = pid;
+	}
+	if (!ccs_policy_loaded)
+		panic("MAC Initialization failed.\n");
+}
+
+/* String table for /proc/ccs/profile */
+const char *ccs_mac_keywords[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX +
+			     CCS_MAX_MAC_CATEGORY_INDEX] = {
+	[CCS_MAC_FILE_EXECUTE]
+	= "file::execute",
+	[CCS_MAC_FILE_OPEN]
+	= "file::open",
+	[CCS_MAC_FILE_CREATE]
+	= "file::create",
+	[CCS_MAC_FILE_UNLINK]
+	= "file::unlink",
+	[CCS_MAC_FILE_MKDIR]
+	= "file::mkdir",
+	[CCS_MAC_FILE_RMDIR]
+	= "file::rmdir",
+	[CCS_MAC_FILE_MKFIFO]
+	= "file::mkfifo",
+	[CCS_MAC_FILE_MKSOCK]
+	= "file::mksock",
+	[CCS_MAC_FILE_TRUNCATE]
+	= "file::truncate",
+	[CCS_MAC_FILE_SYMLINK]
+	= "file::symlink",
+	[CCS_MAC_FILE_REWRITE]
+	= "file::rewrite",
+	[CCS_MAC_FILE_MKBLOCK]
+	= "file::mkblock",
+	[CCS_MAC_FILE_MKCHAR]
+	= "file::mkchar",
+	[CCS_MAC_FILE_LINK]
+	= "file::link",
+	[CCS_MAC_FILE_RENAME]
+	= "file::rename",
+	[CCS_MAC_FILE_CHMOD]
+	= "file::chmod",
+	[CCS_MAC_FILE_CHOWN]
+	= "file::chown",
+	[CCS_MAC_FILE_CHGRP]
+	= "file::chgrp",
+	[CCS_MAC_FILE_IOCTL]
+	= "file::ioctl",
+	[CCS_MAC_FILE_CHROOT]
+	= "file::chroot",
+	[CCS_MAC_FILE_MOUNT]
+	= "file::mount",
+	[CCS_MAC_FILE_UMOUNT]
+	= "file::umount",
+	[CCS_MAC_FILE_PIVOT_ROOT]
+	= "file::pivot_root",
+	[CCS_MAC_FILE_TRANSIT]
+	= "file::transit",
+	[CCS_MAC_ENVIRON]
+	= "misc::env",
+	[CCS_MAC_NETWORK_UDP_BIND]
+	= "network::inet_udp_bind",
+	[CCS_MAC_NETWORK_UDP_CONNECT]
+	= "network::inet_udp_connect",
+	[CCS_MAC_NETWORK_TCP_BIND]
+	= "network::inet_tcp_bind",
+	[CCS_MAC_NETWORK_TCP_LISTEN]
+	= "network::inet_tcp_listen",
+	[CCS_MAC_NETWORK_TCP_CONNECT]
+	= "network::inet_tcp_connect",
+	[CCS_MAC_NETWORK_TCP_ACCEPT]
+	= "network::inet_tcp_accept",
+	[CCS_MAC_NETWORK_RAW_BIND]
+	= "network::inet_raw_bind",
+	[CCS_MAC_NETWORK_RAW_CONNECT]
+	= "network::inet_raw_connect",
+	[CCS_MAC_SIGNAL]
+	= "ipc::signal",
+	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_CREATE]
+	= "capability::inet_tcp_create",
+	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_LISTEN]
+	= "capability::inet_tcp_listen",
+	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_CONNECT]
+	= "capability::inet_tcp_connect",
+	[CCS_MAX_MAC_INDEX + CCS_USE_INET_DGRAM_SOCKET]
+	= "capability::use_inet_udp",
+	[CCS_MAX_MAC_INDEX + CCS_USE_INET_RAW_SOCKET]
+	= "capability::use_inet_ip",
+	[CCS_MAX_MAC_INDEX + CCS_USE_ROUTE_SOCKET]
+	= "capability::use_route",
+	[CCS_MAX_MAC_INDEX + CCS_USE_PACKET_SOCKET]
+	= "capability::use_packet",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_MOUNT]
+	= "capability::SYS_MOUNT",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_UMOUNT]
+	= "capability::SYS_UMOUNT",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_REBOOT]
+	= "capability::SYS_REBOOT",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_CHROOT]
+	= "capability::SYS_CHROOT",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_KILL]
+	= "capability::SYS_KILL",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_VHANGUP]
+	= "capability::SYS_VHANGUP",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_SETTIME]
+	= "capability::SYS_TIME",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_NICE]
+	= "capability::SYS_NICE",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_SETHOSTNAME]
+	= "capability::SYS_SETHOSTNAME",
+	[CCS_MAX_MAC_INDEX + CCS_USE_KERNEL_MODULE]
+	= "capability::use_kernel_module",
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_FIFO]
+	= "capability::create_fifo",
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_BLOCK_DEV]
+	= "capability::create_block_dev",
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_CHAR_DEV]
+	= "capability::create_char_dev",
+	[CCS_MAX_MAC_INDEX + CCS_CREATE_UNIX_SOCKET]
+	= "capability::create_unix_socket",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_LINK]
+	= "capability::SYS_LINK",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_SYMLINK]
+	= "capability::SYS_SYMLINK",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_RENAME]
+	= "capability::SYS_RENAME",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_UNLINK]
+	= "capability::SYS_UNLINK",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_CHMOD]
+	= "capability::SYS_CHMOD",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_CHOWN]
+	= "capability::SYS_CHOWN",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_IOCTL]
+	= "capability::SYS_IOCTL",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_KEXEC_LOAD]
+	= "capability::SYS_KEXEC_LOAD",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_PIVOT_ROOT]
+	= "capability::SYS_PIVOT_ROOT",
+	[CCS_MAX_MAC_INDEX + CCS_SYS_PTRACE]
+	= "capability::SYS_PTRACE",
+	[CCS_MAX_MAC_INDEX + CCS_CONCEAL_MOUNT]
+	= "capability::conceal_mount",
+	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+	 + CCS_MAC_CATEGORY_FILE] = "file",
+	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+	 + CCS_MAC_CATEGORY_NETWORK] = "network",
+	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+	 + CCS_MAC_CATEGORY_MISC] = "misc",
+	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+	 + CCS_MAC_CATEGORY_IPC] = "ipc",
+	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
+	 + CCS_MAC_CATEGORY_CAPABILITY] = "capability",
+};
+
+const char *ccs_path_keyword[CCS_MAX_PATH_OPERATION] = {
+	[CCS_TYPE_READ_WRITE] = "read/write",
+	[CCS_TYPE_EXECUTE]    = "execute",
+	[CCS_TYPE_READ]       = "read",
+	[CCS_TYPE_WRITE]      = "write",
+	[CCS_TYPE_UNLINK]     = "unlink",
+	[CCS_TYPE_RMDIR]      = "rmdir",
+	[CCS_TYPE_TRUNCATE]   = "truncate",
+	[CCS_TYPE_SYMLINK]    = "symlink",
+	[CCS_TYPE_REWRITE]    = "rewrite",
+	[CCS_TYPE_CHROOT]     = "chroot",
+	[CCS_TYPE_UMOUNT]     = "unmount",
+	[CCS_TYPE_TRANSIT]    = "transit",
+};
+
+const char *ccs_path_number3_keyword[CCS_MAX_PATH_NUMBER3_OPERATION] = {
+	[CCS_TYPE_MKBLOCK]    = "mkblock",
+	[CCS_TYPE_MKCHAR]     = "mkchar",
+};
+
+const char *ccs_path2_keyword[CCS_MAX_PATH2_OPERATION] = {
+	[CCS_TYPE_LINK]       = "link",
+	[CCS_TYPE_RENAME]     = "rename",
+	[CCS_TYPE_PIVOT_ROOT] = "pivot_root",
+};
+
+const char *ccs_path_number_keyword[CCS_MAX_PATH_NUMBER_OPERATION] = {
+	[CCS_TYPE_CREATE] = "create",
+	[CCS_TYPE_MKDIR]  = "mkdir",
+	[CCS_TYPE_MKFIFO] = "mkfifo",
+	[CCS_TYPE_MKSOCK] = "mksock",
+	[CCS_TYPE_IOCTL]  = "ioctl",
+	[CCS_TYPE_CHMOD]  = "chmod",
+	[CCS_TYPE_CHOWN]  = "chown",
+	[CCS_TYPE_CHGRP]  = "chgrp",
+};
+
+/**
+ * ccs_path2keyword - Get the name of path operations.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of path operation.
+ */
+const char *ccs_path2keyword(const u8 operation)
+{
+	return (operation < CCS_MAX_PATH_OPERATION)
+		? ccs_path_keyword[operation] : NULL;
+}
+
+/**
+ * ccs_path_number32keyword - Get the name of path/number/number/number operations.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of path/number/number/number operation.
+ */
+const char *ccs_path_number32keyword(const u8 operation)
+{
+	return (operation < CCS_MAX_PATH_NUMBER3_OPERATION)
+		? ccs_path_number3_keyword[operation] : NULL;
+}
+
+/**
+ * ccs_path22keyword - Get the name of path/path operations.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of path/path operation.
+ */
+const char *ccs_path22keyword(const u8 operation)
+{
+	return (operation < CCS_MAX_PATH2_OPERATION)
+		? ccs_path2_keyword[operation] : NULL;
+}
+
+/**
+ * ccs_path_number2keyword - Get the name of path/number operations.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of path/number operation.
+ */
+const char *ccs_path_number2keyword(const u8 operation)
+{
+	return (operation < CCS_MAX_PATH_NUMBER_OPERATION)
+		? ccs_path_number_keyword[operation] : NULL;
+}
+
+/**
+ * ccs_cap2keyword - Convert capability operation to capability name.
+ *
+ * @operation: The capability index.
+ *
+ * Returns the name of the specified capability's name.
+ */
+const char *ccs_cap2keyword(const u8 operation)
+{
+	return operation < CCS_MAX_CAPABILITY_INDEX
+		? ccs_mac_keywords[CCS_MAX_MAC_INDEX + operation] + 12 : NULL;
+}
+
+/* Profile table. Memory is allocated as needed. */
+struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
+
+/* Profile version. Currently only 20090903 is defined. */
+unsigned int ccs_profile_version;
+
+struct ccs_profile ccs_default_profile = {
+	.learning = &ccs_default_profile.preference,
+	.permissive = &ccs_default_profile.preference,
+	.enforcing = &ccs_default_profile.preference,
+	.audit = &ccs_default_profile.preference,
+#ifdef CONFIG_CCSECURITY_AUDIT
+	.preference.audit_max_grant_log = CONFIG_CCSECURITY_MAX_GRANT_LOG,
+	.preference.audit_max_reject_log = CONFIG_CCSECURITY_MAX_REJECT_LOG,
+#endif
+	.preference.audit_task_info = true,
+	.preference.audit_path_info = true,
+	.preference.enforcing_penalty = 0,
+	.preference.enforcing_verbose = true,
+	.preference.learning_max_entry = CONFIG_CCSECURITY_MAX_ACCEPT_ENTRY,
+	.preference.learning_verbose = false,
+	.preference.learning_exec_realpath = true,
+	.preference.learning_exec_argv0 = true,
+	.preference.learning_symlink_target = true,
+	.preference.permissive_verbose = true
+};
+
+
+/**
+ * ccs_profile - Find a profile.
+ *
+ * @profile: Profile number to find.
+ *
+ * Returns pointer to "struct ccs_profile".
+ */
+struct ccs_profile *ccs_profile(const u8 profile)
+{
+	struct ccs_profile *ptr = ccs_profile_ptr[profile];
+	if (!ccs_policy_loaded)
+		return &ccs_default_profile;
+	BUG_ON(!ptr);
+	return ptr;
+}
+
 /* Has /sbin/init started? */
 bool ccs_policy_loaded;
 
 /* Index table for searching parent category. */
-static const u8 ccs_index2category[CCS_MAX_MAC_INDEX +
-				   CCS_MAX_CAPABILITY_INDEX] = {
+const u8 ccs_index2category[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX] = {
 	[CCS_MAC_FILE_EXECUTE]    = CCS_MAC_CATEGORY_FILE,
 	[CCS_MAC_FILE_OPEN]       = CCS_MAC_CATEGORY_FILE,
 	[CCS_MAC_FILE_CREATE]     = CCS_MAC_CATEGORY_FILE,
@@ -123,138 +523,13 @@
 /* Utility functions. */
 
 /**
- * ccs_parse_ulong - Parse an "unsigned long" value.
- *
- * @result: Pointer to "unsigned long".
- * @str:    Pointer to string to parse.
- *
- * Returns value type on success, 0 otherwise.
- *
- * The @src is updated to point the first character after the value
- * on success.
- */
-u8 ccs_parse_ulong(unsigned long *result, char **str)
-{
-	const char *cp = *str;
-	char *ep;
-	int base = 10;
-	if (*cp == '0') {
-		char c = *(cp + 1);
-		if (c == 'x' || c == 'X') {
-			base = 16;
-			cp += 2;
-		} else if (c >= '0' && c <= '7') {
-			base = 8;
-			cp++;
-		}
-	}
-	*result = simple_strtoul(cp, &ep, base);
-	if (cp == ep)
-		return 0;
-	*str = ep;
-	switch (base) {
-	case 16:
-		return CCS_VALUE_TYPE_HEXADECIMAL;
-	case 8:
-		return CCS_VALUE_TYPE_OCTAL;
-	default:
-		return CCS_VALUE_TYPE_DECIMAL;
-	}
-}
-
-/**
- * ccs_print_ulong - Print an "unsigned long" value.
- *
- * @buffer:     Pointer to buffer.
- * @buffer_len: Size of @buffer.
- * @value:      An "unsigned long" value.
- * @type:       Type of @value.
- *
- * Returns nothing.
- */
-void ccs_print_ulong(char *buffer, const int buffer_len,
-		     const unsigned long value, const u8 type)
-{
-	if (type == CCS_VALUE_TYPE_DECIMAL)
-		snprintf(buffer, buffer_len, "%lu", value);
-	else if (type == CCS_VALUE_TYPE_OCTAL)
-		snprintf(buffer, buffer_len, "0%lo", value);
-	else if (type == CCS_VALUE_TYPE_HEXADECIMAL)
-		snprintf(buffer, buffer_len, "0x%lX", value);
-	else
-		snprintf(buffer, buffer_len, "type(%u)", type);
-}
-
-/**
- * ccs_parse_name_union - Parse a ccs_name_union.
- *
- * @filename: Name or name group.
- * @ptr:      Pointer to "struct ccs_name_union".
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr)
-{
-	if (!ccs_is_correct_path(filename, 0, 0, 0))
-		return false;
-	if (filename[0] == '@') {
-		ptr->group = ccs_get_path_group(filename + 1);
-		ptr->is_group = true;
-		return ptr->group != NULL;
-	}
-	ptr->filename = ccs_get_name(filename);
-	ptr->is_group = false;
-	return ptr->filename != NULL;
-}
-
-/**
- * ccs_parse_number_union - Parse a ccs_number_union.
- *
- * @data: Number or number range or number group.
- * @ptr:  Pointer to "struct ccs_number_union".
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_parse_number_union(char *data, struct ccs_number_union *num)
-{
-	u8 type;
-	unsigned long v;
-	memset(num, 0, sizeof(*num));
-	if (data[0] == '@') {
-		if (!ccs_is_correct_path(data, 0, 0, 0))
-			return false;
-		num->group = ccs_get_number_group(data + 1);
-		num->is_group = true;
-		return num->group != NULL;
-	}
-	type = ccs_parse_ulong(&v, &data);
-	if (!type)
-		return false;
-	num->values[0] = v;
-	num->min_type = type;
-	if (!*data) {
-		num->values[1] = v;
-		num->max_type = type;
-		return true;
-	}
-	if (*data++ != '-')
-		return false;
-	type = ccs_parse_ulong(&v, &data);
-	if (!type || *data)
-		return false;
-	num->values[1] = v;
-	num->max_type = type;
-	return true;
-}
-
-/**
  * ccs_is_byte_range - Check whether the string isa \ooo style octal value.
  *
  * @str: Pointer to the string.
  *
  * Returns true if @str is a \ooo style octal value, false otherwise.
  */
-static inline bool ccs_is_byte_range(const char *str)
+static bool ccs_is_byte_range(const char *str)
 {
 	return *str >= '0' && *str++ <= '3' &&
 		*str >= '0' && *str++ <= '7' &&
@@ -268,7 +543,7 @@
  *
  * Returns true if @c is a decimal character, false otherwise.
  */
-static inline bool ccs_is_decimal(const char c)
+static bool ccs_is_decimal(const char c)
 {
 	return c >= '0' && c <= '9';
 }
@@ -280,7 +555,7 @@
  *
  * Returns true if @c is a hexadecimal character, false otherwise.
  */
-static inline bool ccs_is_hexadecimal(const char c)
+static bool ccs_is_hexadecimal(const char c)
 {
 	return (c >= '0' && c <= '9') ||
 		(c >= 'A' && c <= 'F') ||
@@ -294,7 +569,7 @@
  *
  * Returns true if @c is an alphabet character, false otherwise.
  */
-static inline bool ccs_is_alphabet_char(const char c)
+static bool ccs_is_alphabet_char(const char c)
 {
 	return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
 }
@@ -308,34 +583,12 @@
  *
  * Returns byte value.
  */
-static inline u8 ccs_make_byte(const u8 c1, const u8 c2, const u8 c3)
+static u8 ccs_make_byte(const u8 c1, const u8 c2, const u8 c3)
 {
 	return ((c1 - '0') << 6) + ((c2 - '0') << 3) + (c3 - '0');
 }
 
 /**
- * ccs_str_starts - Check whether the given string starts with the given keyword.
- *
- * @src:  Pointer to pointer to the string.
- * @find: Pointer to the keyword.
- *
- * Returns true if @src starts with @find, false otherwise.
- *
- * The @src is updated to point the first character after the @find
- * if @src starts with @find.
- */
-bool ccs_str_starts(char **src, const char *find)
-{
-	const int len = strlen(find);
-	char *tmp = *src;
-	if (strncmp(tmp, find, len))
-		return false;
-	tmp += len;
-	*src = tmp;
-	return true;
-}
-
-/**
  * ccs_normalize_line - Format string.
  *
  * @buffer: The line to normalize.
@@ -365,33 +618,6 @@
 }
 
 /**
- * ccs_tokenize - Tokenize string.
- *
- * @buffer: The line to tokenize.
- * @w:      Pointer to "char *".
- * @size:   Sizeof @w .
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_tokenize(char *buffer, char *w[], size_t size)
-{
-	int count = size / sizeof(char *);
-	int i;
-	for (i = 0; i < count; i++)
-		w[i] = "";
-	for (i = 0; i < count; i++) {
-		char *cp = strchr(buffer, ' ');
-		if (cp)
-			*cp = '\0';
-		w[i] = buffer;
-		if (!cp)
-			break;
-		buffer = cp + 1;
-	}
-	return i < count || !*buffer;
-}
-
-/**
  * ccs_is_correct_path - Validate a pathname.
  *
  * @filename:     The pathname to check.
@@ -589,7 +815,7 @@
 	struct ccs_path_info name;
 	name.name = domainname;
 	ccs_fill_path_info(&name);
-	list_for_each_entry_rcu(domain, &ccs_domain_list, list) {
+	list_for_each_entry_rcu(domain, &ccsecurity.domain, list) {
 		if (!domain->is_deleted &&
 		    !ccs_pathcmp(&name, domain->domainname))
 			return domain;
@@ -957,32 +1183,6 @@
 }
 
 /**
- * ccs_get_audit - Get audit mode.
- *
- * @profile:    Profile number.
- * @index:      Index number of functionality.
- * @is_granted: True if granted log, false otherwise.
- *
- * Returns mode.
- */
-bool ccs_get_audit(const u8 profile, const u8 index, const bool is_granted)
-{
-	u8 mode;
-	const u8 category = ccs_index2category[index] + CCS_MAX_MAC_INDEX
-		+ CCS_MAX_CAPABILITY_INDEX;
-	if (!ccs_policy_loaded)
-		return false;
-	mode = ccs_profile(profile)->config[index];
-	if (mode == CCS_CONFIG_USE_DEFAULT)
-		mode = ccs_profile(profile)->config[category];
-	if (mode == CCS_CONFIG_USE_DEFAULT)
-		mode = ccs_profile(profile)->default_config;
-	if (is_granted)
-		return mode & CCS_CONFIG_WANT_GRANT_LOG;
-	return mode & CCS_CONFIG_WANT_REJECT_LOG;
-}
-
-/**
  * ccs_get_mode - Get MAC mode.
  *
  * @profile: Profile number.
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/signal.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/signal.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/signal.c	(working copy)
@@ -137,58 +137,6 @@
 }
 
 /**
- * ccs_write_signal_policy - Write "struct ccs_signal_acl" list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_signal_policy(char *data, struct ccs_domain_info *domain,
-			    struct ccs_condition *condition,
-			    const bool is_delete)
-{
-	struct ccs_signal_acl *entry = NULL;
-	struct ccs_acl_info *ptr;
-	struct ccs_signal_acl e = { .head.type = CCS_TYPE_SIGNAL_ACL,
-				    .head.cond = condition };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	int sig;
-	char *domainname = strchr(data, ' ');
-	if (sscanf(data, "%d", &sig) != 1 || !domainname ||
-	    !ccs_is_correct_domain(domainname + 1))
-		return -EINVAL;
-	e.sig = sig;
-	e.domainname = ccs_get_name(domainname + 1);
-	if (!e.domainname)
-		return -ENOMEM;
-	if (!is_delete)
-		entry = kmalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_signal_acl *acl =
-			container_of(ptr, struct ccs_signal_acl, head);
-		if (ptr->type != CCS_TYPE_SIGNAL_ACL || ptr->cond != condition
-		    || acl->sig != sig || acl->domainname != e.domainname)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.domainname);
-	kfree(entry);
-	return error;
-}
-
-/**
  * ccs_kill_permission - Permission check for kill().
  *
  * @pid: PID
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/file.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/file.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/file.c	(working copy)
@@ -30,43 +30,6 @@
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
 #endif
 
-static const char *ccs_path_keyword[CCS_MAX_PATH_OPERATION] = {
-	[CCS_TYPE_READ_WRITE] = "read/write",
-	[CCS_TYPE_EXECUTE]    = "execute",
-	[CCS_TYPE_READ]       = "read",
-	[CCS_TYPE_WRITE]      = "write",
-	[CCS_TYPE_UNLINK]     = "unlink",
-	[CCS_TYPE_RMDIR]      = "rmdir",
-	[CCS_TYPE_TRUNCATE]   = "truncate",
-	[CCS_TYPE_SYMLINK]    = "symlink",
-	[CCS_TYPE_REWRITE]    = "rewrite",
-	[CCS_TYPE_CHROOT]     = "chroot",
-	[CCS_TYPE_UMOUNT]     = "unmount",
-	[CCS_TYPE_TRANSIT]    = "transit",
-};
-
-static const char *ccs_path_number3_keyword[CCS_MAX_PATH_NUMBER3_OPERATION] = {
-	[CCS_TYPE_MKBLOCK]    = "mkblock",
-	[CCS_TYPE_MKCHAR]     = "mkchar",
-};
-
-static const char *ccs_path2_keyword[CCS_MAX_PATH2_OPERATION] = {
-	[CCS_TYPE_LINK]       = "link",
-	[CCS_TYPE_RENAME]     = "rename",
-	[CCS_TYPE_PIVOT_ROOT] = "pivot_root",
-};
-
-static const char *ccs_path_number_keyword[CCS_MAX_PATH_NUMBER_OPERATION] = {
-	[CCS_TYPE_CREATE] = "create",
-	[CCS_TYPE_MKDIR]  = "mkdir",
-	[CCS_TYPE_MKFIFO] = "mkfifo",
-	[CCS_TYPE_MKSOCK] = "mksock",
-	[CCS_TYPE_IOCTL]  = "ioctl",
-	[CCS_TYPE_CHMOD]  = "chmod",
-	[CCS_TYPE_CHOWN]  = "chown",
-	[CCS_TYPE_CHGRP]  = "chgrp",
-};
-
 static const u8 ccs_p2mac[CCS_MAX_PATH_OPERATION] = {
 	[CCS_TYPE_READ_WRITE] = CCS_MAC_FILE_OPEN,
 	[CCS_TYPE_EXECUTE]    = CCS_MAC_FILE_EXECUTE,
@@ -104,6 +67,29 @@
 	[CCS_TYPE_CHGRP]  = CCS_MAC_FILE_CHGRP,
 };
 
+/**
+ * ccs_print_ulong - Print an "unsigned long" value.
+ *
+ * @buffer:     Pointer to buffer.
+ * @buffer_len: Size of @buffer.
+ * @value:      An "unsigned long" value.
+ * @type:       Type of @value.
+ *
+ * Returns nothing.
+ */
+static void ccs_print_ulong(char *buffer, const int buffer_len,
+			    const unsigned long value, const u8 type)
+{
+	if (type == CCS_VALUE_TYPE_DECIMAL)
+		snprintf(buffer, buffer_len, "%lu", value);
+	else if (type == CCS_VALUE_TYPE_OCTAL)
+		snprintf(buffer, buffer_len, "0%lo", value);
+	else if (type == CCS_VALUE_TYPE_HEXADECIMAL)
+		snprintf(buffer, buffer_len, "0x%lX", value);
+	else
+		snprintf(buffer, buffer_len, "type(%u)", type);
+}
+
 /*
  * Below part contains copy of some of VFS helper functions.
  *
@@ -119,7 +105,7 @@
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 
 /* Permission checks from vfs_create(). */
-static inline int ccs_pre_vfs_create(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_create(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	down(&dir->i_zombie);
@@ -143,7 +129,7 @@
 }
 
 /* Permission checks from vfs_mkdir(). */
-static inline int ccs_pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	down(&dir->i_zombie);
@@ -155,7 +141,7 @@
 }
 
 /* Permission checks from vfs_rmdir(). */
-static inline int ccs_pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_delete(dir, dentry, 1);
 	if (!error && (!dir->i_op || !dir->i_op->rmdir))
@@ -164,7 +150,7 @@
 }
 
 /* Permission checks from vfs_unlink(). */
-static inline int ccs_pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 33)
 	int error;
@@ -193,7 +179,7 @@
 }
 
 /* Permission checks from vfs_symlink(). */
-static inline int ccs_pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	down(&dir->i_zombie);
@@ -208,9 +194,8 @@
 }
 
 /* Permission checks from vfs_link(). */
-static inline int ccs_pre_vfs_link(struct dentry *old_dentry,
-				   struct inode *dir,
-				   struct dentry *new_dentry)
+static int ccs_pre_vfs_link(struct dentry *old_dentry, struct inode *dir,
+			    struct dentry *new_dentry)
 {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 33)
 	struct inode *inode;
@@ -263,10 +248,10 @@
 }
 
 /* Permission checks from vfs_rename_dir(). */
-static inline int ccs_pre_vfs_rename_dir(struct inode *old_dir,
-					 struct dentry *old_dentry,
-					 struct inode *new_dir,
-					 struct dentry *new_dentry)
+static int ccs_pre_vfs_rename_dir(struct inode *old_dir,
+				  struct dentry *old_dentry,
+				  struct inode *new_dir,
+				  struct dentry *new_dentry)
 {
 	int error;
 	if (old_dentry->d_inode == new_dentry->d_inode)
@@ -290,10 +275,10 @@
 }
 
 /* Permission checks from vfs_rename_other(). */
-static inline int ccs_pre_vfs_rename_other(struct inode *old_dir,
-					   struct dentry *old_dentry,
-					   struct inode *new_dir,
-					   struct dentry *new_dentry)
+static int ccs_pre_vfs_rename_other(struct inode *old_dir,
+				    struct dentry *old_dentry,
+				    struct inode *new_dir,
+				    struct dentry *new_dentry)
 {
 	int error;
 	if (old_dentry->d_inode == new_dentry->d_inode)
@@ -315,10 +300,8 @@
 }
 
 /* Permission checks from vfs_rename(). */
-static inline int ccs_pre_vfs_rename(struct inode *old_dir,
-				     struct dentry *old_dentry,
-				     struct inode *new_dir,
-				     struct dentry *new_dentry)
+static int ccs_pre_vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			      struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error;
 	lock_kernel(); /* From do_rename(). */
@@ -335,7 +318,7 @@
 #else
 
 /* Permission checks from vfs_create(). */
-static inline int ccs_pre_vfs_create(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_create(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_create(dir, dentry, 0);
 	if (error)
@@ -357,7 +340,7 @@
 }
 
 /* Permission checks from vfs_mkdir(). */
-static inline int ccs_pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_create(dir, dentry, 1);
 	if (error)
@@ -368,7 +351,7 @@
 }
 
 /* Permission checks from vfs_rmdir(). */
-static inline int ccs_pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_delete(dir, dentry, 1);
 	if (error)
@@ -379,7 +362,7 @@
 }
 
 /* Permission checks from vfs_unlink(). */
-static inline int ccs_pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_delete(dir, dentry, 0);
 	if (error)
@@ -390,9 +373,8 @@
 }
 
 /* Permission checks from vfs_link(). */
-static inline int ccs_pre_vfs_link(struct dentry *old_dentry,
-				   struct inode *dir,
-				   struct dentry *new_dentry)
+static int ccs_pre_vfs_link(struct dentry *old_dentry, struct inode *dir,
+			    struct dentry *new_dentry)
 {
 	struct inode *inode = old_dentry->d_inode;
 	int error;
@@ -413,7 +395,7 @@
 }
 
 /* Permission checks from vfs_symlink(). */
-static inline int ccs_pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_create(dir, dentry, 0);
 	if (error)
@@ -424,10 +406,8 @@
 }
 
 /* Permission checks from vfs_rename(). */
-static inline int ccs_pre_vfs_rename(struct inode *old_dir,
-				     struct dentry *old_dentry,
-				     struct inode *new_dir,
-				     struct dentry *new_dentry)
+static int ccs_pre_vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			      struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error;
 	const int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
@@ -458,22 +438,6 @@
 
 /* Main functions. */
 
-void ccs_put_name_union(struct ccs_name_union *ptr)
-{
-	if (!ptr)
-		return;
-	if (ptr->is_group)
-		ccs_put_path_group(ptr->group);
-	else
-		ccs_put_name(ptr->filename);
-}
-
-void ccs_put_number_union(struct ccs_number_union *ptr)
-{
-	if (ptr && ptr->is_group)
-		ccs_put_number_group(ptr->group);
-}
-
 bool ccs_compare_number_union(const unsigned long value,
 			      const struct ccs_number_union *ptr)
 {
@@ -502,58 +466,6 @@
 	return false;
 }
 
-/**
- * ccs_path2keyword - Get the name of path operations.
- *
- * @operation: Type of operation.
- *
- * Returns the name of path operation.
- */
-const char *ccs_path2keyword(const u8 operation)
-{
-	return (operation < CCS_MAX_PATH_OPERATION)
-		? ccs_path_keyword[operation] : NULL;
-}
-
-/**
- * ccs_path_number32keyword - Get the name of path/number/number/number operations.
- *
- * @operation: Type of operation.
- *
- * Returns the name of path/number/number/number operation.
- */
-const char *ccs_path_number32keyword(const u8 operation)
-{
-	return (operation < CCS_MAX_PATH_NUMBER3_OPERATION)
-		? ccs_path_number3_keyword[operation] : NULL;
-}
-
-/**
- * ccs_path22keyword - Get the name of path/path operations.
- *
- * @operation: Type of operation.
- *
- * Returns the name of path/path operation.
- */
-const char *ccs_path22keyword(const u8 operation)
-{
-	return (operation < CCS_MAX_PATH2_OPERATION)
-		? ccs_path2_keyword[operation] : NULL;
-}
-
-/**
- * ccs_path_number2keyword - Get the name of path/number operations.
- *
- * @operation: Type of operation.
- *
- * Returns the name of path/number operation.
- */
-const char *ccs_path_number2keyword(const u8 operation)
-{
-	return (operation < CCS_MAX_PATH_NUMBER_OPERATION)
-		? ccs_path_number_keyword[operation] : NULL;
-}
-
 static void ccs_add_slash(struct ccs_path_info *buf)
 {
 	if (buf->is_dir)
@@ -571,7 +483,7 @@
  *
  * Returns true if @name ends with @tail, false otherwise.
  */
-static bool ccs_strendswith(const char *name, const char *tail)
+bool ccs_strendswith(const char *name, const char *tail)
 {
 	int len;
 	if (!name || !tail)
@@ -601,11 +513,6 @@
 	return false;
 }
 
-static int ccs_update_path_acl(const u8 type, const char *filename,
-			       struct ccs_domain_info * const domain,
-			       struct ccs_condition *condition,
-			       const bool is_delete);
-
 /**
  * ccs_audit_path_log - Audit path request log.
  *
@@ -697,9 +604,6 @@
 				   operation, filename, value);
 }
 
-/* The list for "struct ccs_globally_readable_file_entry". */
-LIST_HEAD(ccs_globally_readable_list);
-
 /**
  * ccs_is_globally_readable_file - Check if the file is unconditionnaly permitted to be open()ed for reading.
  *
@@ -713,7 +617,7 @@
 {
 	struct ccs_globally_readable_file_entry *ptr;
 	bool found = false;
-	list_for_each_entry_rcu(ptr, &ccs_globally_readable_list, list) {
+	list_for_each_entry_rcu(ptr, &ccsecurity.global_read, list) {
 		if (ptr->is_deleted ||
 		    !ccs_path_matches_pattern(filename, ptr->filename))
 			continue;
@@ -724,77 +628,6 @@
 }
 
 /**
- * ccs_write_globally_readable_policy - Write "struct ccs_globally_readable_file_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_globally_readable_policy(char *data, const bool is_delete)
-{
-	struct ccs_globally_readable_file_entry *entry = NULL;
-	struct ccs_globally_readable_file_entry *ptr;
-	struct ccs_globally_readable_file_entry e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(data, 1, 0, -1))
-		return -EINVAL;
-	e.filename = ccs_get_name(data);
-	if (!e.filename)
-		return -ENOMEM;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_globally_readable_list, list) {
-		if (ptr->filename != e.filename)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_globally_readable_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.filename);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_globally_readable_policy - Read "struct ccs_globally_readable_file_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_globally_readable_list) {
-		struct ccs_globally_readable_file_entry *ptr;
-		ptr = list_entry(pos, struct ccs_globally_readable_file_entry,
-				 list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_READ "%s\n",
-				     ptr->filename->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/* The list for "struct ccs_pattern_entry". */
-LIST_HEAD(ccs_pattern_list);
-
-/**
  * ccs_file_pattern - Get patterned pathname.
  *
  * @filename: Pointer to "struct ccs_path_info".
@@ -807,7 +640,7 @@
 {
 	struct ccs_pattern_entry *ptr;
 	const struct ccs_path_info *pattern = NULL;
-	list_for_each_entry_rcu(ptr, &ccs_pattern_list, list) {
+	list_for_each_entry_rcu(ptr, &ccsecurity.pattern, list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!ccs_path_matches_pattern(filename, ptr->pattern))
@@ -824,75 +657,6 @@
 }
 
 /**
- * ccs_write_pattern_policy - Write "struct ccs_pattern_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_pattern_policy(char *data, const bool is_delete)
-{
-	struct ccs_pattern_entry *entry = NULL;
-	struct ccs_pattern_entry *ptr;
-	struct ccs_pattern_entry e = { .pattern = ccs_get_name(data) };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!e.pattern)
-		return error;
-	if (!e.pattern->is_patterned)
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_pattern_list, list) {
-		if (e.pattern != ptr->pattern)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_pattern_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.pattern);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_file_pattern - Read "struct ccs_pattern_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_file_pattern(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2, &ccs_pattern_list) {
-		struct ccs_pattern_entry *ptr;
-		ptr = list_entry(pos, struct ccs_pattern_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_FILE_PATTERN "%s\n",
-				     ptr->pattern->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/* The list for "struct ccs_no_rewrite_entry". */
-LIST_HEAD(ccs_no_rewrite_list);
-
-/**
  * ccs_is_no_rewrite_file - Check if the given pathname is not permitted to be rewrited.
  *
  * @filename: Filename to check.
@@ -906,7 +670,7 @@
 {
 	struct ccs_no_rewrite_entry *ptr;
 	bool matched = false;
-	list_for_each_entry_rcu(ptr, &ccs_no_rewrite_list, list) {
+	list_for_each_entry_rcu(ptr, &ccsecurity.no_rewrite, list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!ccs_path_matches_pattern(filename, ptr->pattern))
@@ -918,113 +682,6 @@
 }
 
 /**
- * ccs_write_no_rewrite_policy - Write "struct ccs_no_rewrite_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_no_rewrite_policy(char *data, const bool is_delete)
-{
-	struct ccs_no_rewrite_entry *entry = NULL;
-	struct ccs_no_rewrite_entry *ptr;
-	struct ccs_no_rewrite_entry e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(data, 0, 0, 0))
-		return -EINVAL;
-	e.pattern = ccs_get_name(data);
-	if (!e.pattern)
-		return error;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_no_rewrite_list, list) {
-		if (ptr->pattern != e.pattern)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_no_rewrite_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.pattern);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_no_rewrite_policy - Read "struct ccs_no_rewrite_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2, &ccs_no_rewrite_list) {
-		struct ccs_no_rewrite_entry *ptr;
-		ptr = list_entry(pos, struct ccs_no_rewrite_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_DENY_REWRITE "%s\n",
-				     ptr->pattern->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
- * ccs_update_file_acl - Update file's read/write/execute ACL.
- *
- * @perm:      Permission (between 1 to 7).
- * @filename:  Filename.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- *
- * This is legacy support interface for older policy syntax.
- * Current policy syntax uses "allow_read/write" instead of "6",
- * "allow_read" instead of "4", "allow_write" instead of "2",
- * "allow_execute" instead of "1".
- */
-static inline int ccs_update_file_acl(u8 perm, const char *filename,
-				      struct ccs_domain_info * const domain,
-				      struct ccs_condition *condition,
-				      const bool is_delete)
-{
-	if (perm > 7 || !perm)
-		return -EINVAL;
-	if (filename[0] != '@' && ccs_strendswith(filename, "/"))
-		/*
-		 * Only 'allow_mkdir' and 'allow_rmdir' are valid for
-		 * directory permissions.
-		 */
-		return 0;
-	if (perm & 4)
-		ccs_update_path_acl(CCS_TYPE_READ, filename, domain,
-				    condition, is_delete);
-	if (perm & 2)
-		ccs_update_path_acl(CCS_TYPE_WRITE, filename,
-				    domain, condition, is_delete);
-	if (perm & 1)
-		ccs_update_path_acl(CCS_TYPE_EXECUTE, filename,
-				    domain, condition, is_delete);
-	return 0;
-}
-
-/**
  * ccs_path_acl - Check permission for path operation.
  *
  * @r:               Pointer to "struct ccs_request_info".
@@ -1159,288 +816,6 @@
 }
 
 /**
- * ccs_update_execute_handler - Update "struct ccs_execute_handler_record" list.
- *
- * @type:      Type of execute handler.
- * @filename:  Pathname to the execute handler.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static inline int ccs_update_execute_handler(const u8 type,
-					     const char *filename,
-					     struct ccs_domain_info * const
-					     domain, const bool is_delete)
-{
-	struct ccs_acl_info *ptr;
-	struct ccs_execute_handler_record e = { .head.type = type };
-	struct ccs_execute_handler_record *entry = NULL;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!domain)
-		return -EINVAL;
-	if (!ccs_is_correct_path(filename, 1, -1, -1))
-		return -EINVAL;
-	e.handler = ccs_get_name(filename);
-	if (!e.handler)
-		return -ENOMEM;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_execute_handler_record *acl;
-		if (ptr->type != type)
-			continue;
-		/* Condition not supported. */
-		acl = container_of(ptr, struct ccs_execute_handler_record,
-				   head);
-		if (acl->handler != e.handler)
-			continue;
-		if (!is_delete) {
-			/* Only one entry can exist in a domain. */
-			struct ccs_acl_info *ptr2;
-			list_for_each_entry_rcu(ptr2, &domain->acl_info_list,
-						list) {
-				if (ptr2->type == type)
-					ptr2->is_deleted = true;
-			}
-		}
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		/* Only one entry can exist in a domain. */
-		list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-			if (ptr->type == type)
-				ptr->is_deleted = true;
-		}
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.handler);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_update_path_acl - Update "struct ccs_path_acl" list.
- *
- * @type:      Type of operation.
- * @filename:  Filename.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_path_acl(const u8 type, const char *filename,
-			       struct ccs_domain_info * const domain,
-			       struct ccs_condition *condition,
-			       const bool is_delete)
-{
-	static const u16 ccs_rw_mask =
-		(1 << CCS_TYPE_READ) | (1 << CCS_TYPE_WRITE);
-	const u16 perm = 1 << type;
-	struct ccs_acl_info *ptr;
-	struct ccs_path_acl e = {
-		.head.type = CCS_TYPE_PATH_ACL,
-		.head.cond = condition,
-		.perm = perm
-	};
-	struct ccs_path_acl *entry = NULL;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (type == CCS_TYPE_READ_WRITE)
-		e.perm |= ccs_rw_mask;
-	if (!ccs_parse_name_union(filename, &e.name))
-		return -EINVAL;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path_acl *acl =
-			container_of(ptr, struct ccs_path_acl, head);
-		if (ptr->type != CCS_TYPE_PATH_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if ((acl->perm & ccs_rw_mask) != ccs_rw_mask)
-				acl->perm &= ~(1 << CCS_TYPE_READ_WRITE);
-			else if (!(acl->perm & (1 << CCS_TYPE_READ_WRITE)))
-				acl->perm &= ~ccs_rw_mask;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			if ((acl->perm & ccs_rw_mask) == ccs_rw_mask)
-				acl->perm |= 1 << CCS_TYPE_READ_WRITE;
-			else if (acl->perm & (1 << CCS_TYPE_READ_WRITE))
-				acl->perm |= ccs_rw_mask;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name_union(&e.name);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_update_path_number3_acl - Update "struct ccs_path_number3_acl" list.
- *
- * @type:      Type of operation.
- * @filename:  Filename.
- * @mode:      Create mode.
- * @major:     Device major number.
- * @minor:     Device minor number.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static inline int ccs_update_path_number3_acl(const u8 type,
-					      const char *filename, char *mode,
-					      char *major, char *minor,
-					      struct ccs_domain_info * const
-					      domain,
-					      struct ccs_condition *condition,
-					      const bool is_delete)
-{
-	const u8 perm = 1 << type;
-	struct ccs_acl_info *ptr;
-	struct ccs_path_number3_acl e = {
-		.head.type = CCS_TYPE_PATH_NUMBER3_ACL,
-		.head.cond = condition,
-		.perm = perm
-	};
-	struct ccs_path_number3_acl *entry = NULL;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_parse_name_union(filename, &e.name) ||
-	    !ccs_parse_number_union(mode, &e.mode) ||
-	    !ccs_parse_number_union(major, &e.major) ||
-	    !ccs_parse_number_union(minor, &e.minor))
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path_number3_acl *acl =
-			container_of(ptr, struct ccs_path_number3_acl, head);
-		if (ptr->type != CCS_TYPE_PATH_NUMBER3_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name_union(&e.name);
-	ccs_put_number_union(&e.mode);
-	ccs_put_number_union(&e.major);
-	ccs_put_number_union(&e.minor);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_update_path2_acl - Update "struct ccs_path2_acl" list.
- *
- * @type:      Type of operation.
- * @filename1: First filename.
- * @filename2: Second filename.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static inline int ccs_update_path2_acl(const u8 type,
-				       const char *filename1,
-				       const char *filename2,
-				       struct ccs_domain_info * const
-				       domain,
-				       struct ccs_condition *condition,
-				       const bool is_delete)
-{
-	const u8 perm = 1 << type;
-	struct ccs_acl_info *ptr;
-	struct ccs_path2_acl e = {
-		.head.type = CCS_TYPE_PATH2_ACL,
-		.head.cond = condition,
-		.perm = perm
-	};
-	struct ccs_path2_acl *entry = NULL;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_parse_name_union(filename1, &e.name1) ||
-	    !ccs_parse_name_union(filename2, &e.name2))
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path2_acl *acl =
-			container_of(ptr, struct ccs_path2_acl, head);
-		if (ptr->type != CCS_TYPE_PATH2_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name1), sizeof(e)))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name_union(&e.name1);
-	ccs_put_name_union(&e.name2);
-	kfree(entry);
-	return error;
-}
-
-/**
  * ccs_path2_acl - Check permission for path/path operation.
  *
  * @r:         Pointer to "struct ccs_request_info".
@@ -1955,77 +1330,6 @@
 }
 
 /**
- * ccs_update_path_number_acl - Update ioctl/chmod/chown/chgrp ACL.
- *
- * @type:      Type of operation.
- * @filename:  Filename.
- * @number:    Number.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static inline int ccs_update_path_number_acl(const u8 type,
-					     const char *filename,
-					     char *number,
-					     struct ccs_domain_info * const
-					     domain,
-					     struct ccs_condition *condition,
-					     const bool is_delete)
-{
-	const u8 perm = 1 << type;
-	struct ccs_acl_info *ptr;
-	struct ccs_path_number_acl e = {
-		.head.type = CCS_TYPE_PATH_NUMBER_ACL,
-		.head.cond = condition,
-		.perm = perm
-	};
-	struct ccs_path_number_acl *entry = NULL;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!domain)
-		return -EINVAL;
-	if (!ccs_parse_name_union(filename, &e.name))
-		return -EINVAL;
-	if (!ccs_parse_number_union(number, &e.number))
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path_number_acl *acl =
-			container_of(ptr, struct ccs_path_number_acl, head);
-		if (ptr->type != CCS_TYPE_PATH_NUMBER_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name_union(&e.name);
-	ccs_put_number_union(&e.number);
-	kfree(entry);
-	return error;
-}
-
-/**
  * ccs_path_number_acl - Check permission for ioctl/chmod/chown/chgrp operation.
  *
  * @r:        Pointer to "struct ccs_request_info".
@@ -2283,72 +1587,6 @@
 	return ccs_path_perm(CCS_TYPE_UMOUNT, NULL, mnt->mnt_root, mnt, NULL);
 }
 
-/**
- * ccs_write_file_policy - Update file related list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_file_policy(char *data, struct ccs_domain_info *domain,
-			  struct ccs_condition *condition,
-			  const bool is_delete)
-{
-	char *w[5];
-	u8 type;
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	if (strncmp(w[0], "allow_", 6)) {
-		unsigned int perm;
-		if (sscanf(w[0], "%u", &perm) == 1)
-			return ccs_update_file_acl((u8) perm, w[1], domain,
-						   condition, is_delete);
-		if (!strcmp(w[0], CCS_KEYWORD_EXECUTE_HANDLER))
-			type = CCS_TYPE_EXECUTE_HANDLER;
-		else if (!strcmp(w[0], CCS_KEYWORD_DENIED_EXECUTE_HANDLER))
-			type = CCS_TYPE_DENIED_EXECUTE_HANDLER;
-		else
-			goto out;
-		return ccs_update_execute_handler(type, w[1], domain,
-						  is_delete);
-	}
-	w[0] += 6;
-	for (type = 0; type < CCS_MAX_PATH_OPERATION; type++) {
-		if (strcmp(w[0], ccs_path_keyword[type]))
-			continue;
-		return ccs_update_path_acl(type, w[1], domain, condition,
-					   is_delete);
-	}
-	if (!w[2][0])
-		goto out;
-	for (type = 0; type < CCS_MAX_PATH2_OPERATION; type++) {
-		if (strcmp(w[0], ccs_path2_keyword[type]))
-			continue;
-		return ccs_update_path2_acl(type, w[1], w[2], domain,
-					    condition, is_delete);
-	}
-	for (type = 0; type < CCS_MAX_PATH_NUMBER_OPERATION; type++) {
-		if (strcmp(w[0], ccs_path_number_keyword[type]))
-			continue;
-		return ccs_update_path_number_acl(type, w[1], w[2], domain,
-						  condition, is_delete);
-	}
-	if (!w[3][0] || !w[4][0])
-		goto out;
-	for (type = 0; type < CCS_MAX_PATH_NUMBER3_OPERATION; type++) {
-		if (strcmp(w[0], ccs_path_number3_keyword[type]))
-			continue;
-		return ccs_update_path_number3_acl(type, w[1], w[2], w[3],
-						   w[4], domain, condition,
-						   is_delete);
-	}
- out:
-	return -EINVAL;
-}
-
 /*
  * Permission checks from vfs_mknod().
  *
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/environ.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/environ.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/environ.c	(working copy)
@@ -30,9 +30,6 @@
 				   env);
 }
 
-/* The list for "struct ccs_globally_usable_env_entry". */
-LIST_HEAD(ccs_globally_usable_env_list);
-
 /**
  * ccs_is_globally_usable_env - Check whether the given environment variable is acceptable for all domains.
  *
@@ -47,7 +44,7 @@
 {
 	struct ccs_globally_usable_env_entry *ptr;
 	bool found = false;
-	list_for_each_entry_rcu(ptr, &ccs_globally_usable_env_list, list) {
+	list_for_each_entry_rcu(ptr, &ccsecurity.global_env, list) {
 		if (ptr->is_deleted || !ccs_path_matches_pattern(env, ptr->env))
 			continue;
 		found = true;
@@ -57,74 +54,6 @@
 }
 
 /**
- * ccs_write_globally_usable_env_policy - Write "struct ccs_globally_usable_env_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_globally_usable_env_policy(char *data, const bool is_delete)
-{
-	struct ccs_globally_usable_env_entry *entry = NULL;
-	struct ccs_globally_usable_env_entry e = { };
-	struct ccs_globally_usable_env_entry *ptr;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(data, 0, 0, 0) || strchr(data, '='))
-		return -EINVAL;
-	e.env = ccs_get_name(data);
-	if (!e.env)
-		return error;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_globally_usable_env_list, list) {
-		if (ptr->env != e.env)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_globally_usable_env_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.env);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_globally_usable_env_policy - Read "struct ccs_globally_usable_env_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0 on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_globally_usable_env_list) {
-		struct ccs_globally_usable_env_entry *ptr;
-		ptr = list_entry(pos, struct ccs_globally_usable_env_entry,
-				 list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_ENV "%s\n",
-				     ptr->env->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
  * ccs_env_acl - Check permission for environment variable's name.
  *
  * @r:       Pointer to "struct ccs_request_info".
@@ -184,53 +113,3 @@
 	} while (error == CCS_RETRY_REQUEST);
 	return error;
 }
-
-/**
- * ccs_write_env_policy - Write "struct ccs_env_acl" list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_env_policy(char *data, struct ccs_domain_info *domain,
-			 struct ccs_condition *condition,
-			 const bool is_delete)
-{
-	struct ccs_env_acl *entry = NULL;
-	struct ccs_acl_info *ptr;
-	struct ccs_env_acl e = {
-		.head.type = CCS_TYPE_ENV_ACL,
-		.head.cond = condition
-	};
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(data, 0, 0, 0) || strchr(data, '='))
-		return -EINVAL;
-	e.env = ccs_get_name(data);
-	if (!e.env)
-		return error;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_env_acl *acl =
-			container_of(ptr, struct ccs_env_acl, head);
-		if (ptr->type != CCS_TYPE_ENV_ACL || ptr->cond != condition ||
-		    acl->env != e.env)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.env);
-	kfree(entry);
-	return error;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -858,9 +858,6 @@
 
 /* Prototype definition. */
 
-bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
-			       const struct ccs_address_group *group);
-bool ccs_commit_ok(void *ptr, void *data, const unsigned int size);
 bool ccs_compare_name_union(const struct ccs_path_info *name,
 			    const struct ccs_name_union *ptr);
 bool ccs_compare_number_union(const unsigned long value,
@@ -869,7 +866,6 @@
 bool ccs_domain_quota_ok(struct ccs_request_info *r);
 bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos,
 		   struct ccs_page_dump *dump);
-bool ccs_get_audit(const u8 profile, const u8 index, const bool is_granted);
 bool ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
 bool ccs_is_correct_domain(const unsigned char *domainname);
@@ -879,28 +875,12 @@
 bool ccs_memory_ok(const void *ptr, const unsigned int size);
 bool ccs_number_matches_group(const unsigned long min, const unsigned long max,
 			      const struct ccs_number_group *group);
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr);
-bool ccs_parse_number_union(char *data, struct ccs_number_union *num);
 bool ccs_path_matches_group(const struct ccs_path_info *pathname,
 			    const struct ccs_path_group *group,
 			    const bool may_use_pattern);
 bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 			      const struct ccs_path_info *pattern);
-bool ccs_print_number_union(struct ccs_io_buffer *head,
-			    const struct ccs_number_union *ptr);
-bool ccs_read_address_group_policy(struct ccs_io_buffer *head);
-bool ccs_read_aggregator_policy(struct ccs_io_buffer *head);
-bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head);
-bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head);
-bool ccs_read_file_pattern(struct ccs_io_buffer *head);
-bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head);
-bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head);
-bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head);
-bool ccs_read_number_group_policy(struct ccs_io_buffer *head);
-bool ccs_read_path_group_policy(struct ccs_io_buffer *head);
-bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head);
-bool ccs_str_starts(char **src, const char *find);
-bool ccs_tokenize(char *buffer, char *w[], size_t size);
+bool ccs_strendswith(const char *name, const char *tail);
 char *ccs_encode(const char *str);
 char *ccs_init_audit_log(int *len, struct ccs_request_info *r);
 char *ccs_realpath_from_path(struct path *path);
@@ -926,65 +906,26 @@
 			  struct ccs_domain_info *domain, const u8 index);
 int ccs_may_transit(const char *domainname, const char *pathname);
 int ccs_open_control(const u8 type, struct file *file);
-int ccs_parse_ip_address(char *address, u16 *min, u16 *max);
 int ccs_path_permission(struct ccs_request_info *r, u8 operation,
 			const struct ccs_path_info *filename);
-int ccs_poll_control(struct file *file, poll_table *wait);
 int ccs_poll_audit_log(struct file *file, poll_table *wait);
+int ccs_poll_control(struct file *file, poll_table *wait);
 int ccs_read_control(struct file *file, char __user *buffer,
 		     const int buffer_len);
 int ccs_read_lock(void);
 int ccs_supervisor(struct ccs_request_info *r, const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
 int ccs_symlink_path(const char *pathname, struct ccs_path_info *name);
-int ccs_write_address_group_policy(char *data, const bool is_delete);
-int ccs_write_aggregator_policy(char *data, const bool is_delete);
 int ccs_write_audit_log(const bool is_granted, struct ccs_request_info *r,
 			const char *fmt, ...)
      __attribute__ ((format(printf, 3, 4)));
-int ccs_write_capability_policy(char *data, struct ccs_domain_info *domain,
-				struct ccs_condition *condition,
-				const bool is_delete);
 int ccs_write_control(struct file *file, const char __user *buffer,
 		      const int buffer_len);
-int ccs_write_domain_initializer_policy(char *data, const bool is_not,
-					const bool is_delete);
-int ccs_write_domain_keeper_policy(char *data, const bool is_not,
-				   const bool is_delete);
-int ccs_write_env_policy(char *data, struct ccs_domain_info *domain,
-			 struct ccs_condition *condition,
-			 const bool is_delete);
-int ccs_write_file_policy(char *data, struct ccs_domain_info *domain,
-			  struct ccs_condition *condition,
-			  const bool is_delete);
-int ccs_write_globally_readable_policy(char *data, const bool is_delete);
-int ccs_write_globally_usable_env_policy(char *data, const bool is_delete);
-int ccs_write_memory_quota(struct ccs_io_buffer *head);
-int ccs_write_mount_policy(char *data, struct ccs_domain_info *domain,
-			   struct ccs_condition *condition,
-			   const bool is_delete);
-int ccs_write_network_policy(char *data, struct ccs_domain_info *domain,
-			     struct ccs_condition *condition,
-			     const bool is_delete);
-int ccs_write_no_rewrite_policy(char *data, const bool is_delete);
-int ccs_write_number_group_policy(char *data, const bool is_delete);
-int ccs_write_path_group_policy(char *data, const bool is_delete);
-int ccs_write_pattern_policy(char *data, const bool is_delete);
-int ccs_write_reserved_port_policy(char *data, const bool is_delete);
-int ccs_write_signal_policy(char *data, struct ccs_domain_info *domain,
-			    struct ccs_condition *condition,
-			    const bool is_delete);
 size_t ccs_del_condition(struct ccs_condition *cond);
-struct ccs_address_group *ccs_get_address_group(const char *group_name);
-struct ccs_condition *ccs_get_condition(char * const condition);
 struct ccs_domain_info *ccs_find_domain(const char *domainname);
 struct ccs_domain_info *ccs_find_or_assign_new_domain(const char *domainname,
 						      const u8 profile);
-struct ccs_number_group *ccs_get_number_group(const char *group_name);
-struct ccs_path_group *ccs_get_path_group(const char *group_name);
 struct ccs_profile *ccs_profile(const u8 profile);
-u8 ccs_parse_ulong(unsigned long *result, char **str);
-void ccs_check_profile(void);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
 void ccs_get_attributes(struct ccs_obj_info *obj);
 void ccs_load_policy(const char *filename);
@@ -992,12 +933,7 @@
 void ccs_normalize_line(unsigned char *buffer);
 void ccs_print_ipv6(char *buffer, const int buffer_len,
 		    const struct in6_addr *ip);
-void ccs_print_ulong(char *buffer, const int buffer_len,
-		     const unsigned long value, const u8 type);
-void ccs_put_name_union(struct ccs_name_union *ptr);
-void ccs_put_number_union(struct ccs_number_union *ptr);
 void ccs_read_audit_log(struct ccs_io_buffer *head);
-void ccs_read_memory_counter(struct ccs_io_buffer *head);
 void ccs_read_unlock(const int idx);
 void ccs_run_gc(void);
 void ccs_warn_log(struct ccs_request_info *r, const char *fmt, ...)
@@ -1021,30 +957,48 @@
 #define CCS_HASH_BITS 8
 #define CCS_MAX_HASH (1 << CCS_HASH_BITS)
 
-extern struct mutex ccs_policy_lock;
-extern struct list_head ccs_domain_list;
-extern struct list_head ccs_address_group_list;
-extern struct list_head ccs_globally_readable_list;
-extern struct list_head ccs_path_group_list;
-extern struct list_head ccs_number_group_list;
-extern struct list_head ccs_pattern_list;
-extern struct list_head ccs_no_rewrite_list;
-extern struct list_head ccs_globally_usable_env_list;
-extern struct list_head ccs_domain_initializer_list;
-extern struct list_head ccs_domain_keeper_list;
-extern struct list_head ccs_aggregator_list;
-extern struct list_head ccs_reservedport_list;
-extern struct list_head ccs_policy_manager_list;
-extern struct list_head ccs_address_list;
-extern struct list_head ccs_condition_list;
+struct ccsecurity_policy {
+	struct mutex policy_lock;
+	struct list_head domain;
+	struct list_head address_group;
+	struct list_head global_read;
+	struct list_head path_group;
+	struct list_head number_group;
+	struct list_head pattern;
+	struct list_head no_rewrite;
+	struct list_head global_env;
+	struct list_head domain_initializer;
+	struct list_head domain_keeper;
+	struct list_head aggregator;
+	struct list_head reservedport;
+	struct list_head policy_manager;
+	struct list_head ipv6addr;
+	struct list_head condition;
+};
+extern struct ccsecurity_policy ccsecurity;
 extern struct mutex ccs_name_list_lock;
 extern struct list_head ccs_name_list[CCS_MAX_HASH];
+extern u8 ccs_reserved_port_map[8192];
+extern const u8 ccs_index2category[CCS_MAX_MAC_INDEX
+				   + CCS_MAX_CAPABILITY_INDEX];
+extern const char *ccs_mac_keywords[CCS_MAX_MAC_INDEX
+				    + CCS_MAX_CAPABILITY_INDEX
+				    + CCS_MAX_MAC_CATEGORY_INDEX];
+extern const char *ccs_path_keyword[CCS_MAX_PATH_OPERATION];
+extern const char *ccs_path_number3_keyword[CCS_MAX_PATH_NUMBER3_OPERATION];
+extern const char *ccs_path2_keyword[CCS_MAX_PATH2_OPERATION];
+extern const char *ccs_path_number_keyword[CCS_MAX_PATH_NUMBER_OPERATION];
+extern struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
+extern struct ccs_profile ccs_default_profile;
+extern unsigned int ccs_profile_version;
 
 extern bool ccs_policy_loaded;
 extern struct ccs_domain_info ccs_kernel_domain;
 
 extern const char *ccs_condition_keyword[CCS_MAX_CONDITION_KEYWORD];
 
+extern atomic_t ccs_policy_memory_size;
+extern unsigned int ccs_quota_for_policy;
 extern unsigned int ccs_audit_log_memory_size;
 extern unsigned int ccs_quota_for_audit_log;
 extern unsigned int ccs_query_memory_size;
@@ -1201,4 +1155,20 @@
 	}
 }
 
+static inline void ccs_put_name_union(struct ccs_name_union *ptr)
+{
+	if (!ptr)
+		return;
+	if (ptr->is_group)
+		ccs_put_path_group(ptr->group);
+	else
+		ccs_put_name(ptr->filename);
+}
+
+static inline void ccs_put_number_union(struct ccs_number_union *ptr)
+{
+	if (ptr && ptr->is_group)
+		ccs_put_number_group(ptr->group);
+}
+
 #endif
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/capability.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/capability.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/capability.c	(working copy)
@@ -86,57 +86,3 @@
 	ccs_read_unlock(idx);
 	return error;
 }
-
-/**
- * ccs_write_capability_policy - Write "struct ccs_capability_acl" list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_capability_policy(char *data, struct ccs_domain_info *domain,
-				struct ccs_condition *condition,
-				const bool is_delete)
-{
-	struct ccs_capability_acl e = {
-		.head.type = CCS_TYPE_CAPABILITY_ACL,
-		.head.cond = condition,
-	};
-	struct ccs_capability_acl *entry = NULL;
-	struct ccs_acl_info *ptr;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	u8 capability;
-	for (capability = 0; capability < CCS_MAX_CAPABILITY_INDEX;
-	     capability++) {
-		if (strcmp(data, ccs_cap2keyword(capability)))
-			continue;
-		break;
-	}
-	if (capability == CCS_MAX_CAPABILITY_INDEX)
-		return -EINVAL;
-	e.operation = capability;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_capability_acl *acl =
-			container_of(ptr, struct ccs_capability_acl, head);
-		if (ptr->type != CCS_TYPE_CAPABILITY_ACL ||
-		    ptr->cond != condition || acl->operation != capability)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	kfree(entry);
-	return error;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/condition.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/condition.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/condition.c	(working copy)
@@ -263,144 +263,6 @@
 	return result == match;
 }
 
-static bool ccs_parse_name_union_quoted(char *filename,
-					struct ccs_name_union *ptr)
-{
-	bool result;
-	char *cp = NULL;
-	if (*filename == '"') {
-		cp = filename + strlen(filename) - 1;
-		if (*cp != '"')
-			return false;
-		*cp = '\0';
-		filename++;
-	}
-	result = ccs_parse_name_union(filename, ptr);
-	if (cp)
-		*cp = '"';
-	return result;
-}
-
-/**
- * ccs_get_dqword - ccs_get_name() for a quoted string.
- *
- * @start: String to save.
- *
- * Returns pointer to "struct ccs_path_info" on success, NULL otherwise.
- */
-static const struct ccs_path_info *ccs_get_dqword(char *start)
-{
-	char *cp;
-	if (*start++ != '"')
-		return NULL;
-	cp = start;
-	while (1) {
-		const char c = *cp++;
-		if (!c)
-			return NULL;
-		if (c != '"' || *cp)
-			continue;
-		*(cp - 1) = '\0';
-		break;
-	}
-	if (!ccs_is_correct_path(start, 0, 0, 0))
-		return NULL;
-	return ccs_get_name(start);
-}
-
-/**
- * ccs_parse_argv - Parse an argv[] condition part.
- *
- * @start: String to parse.
- * @argv:  Pointer to "struct ccs_argv_entry".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_argv(char *start, struct ccs_argv_entry *argv)
-{
-	unsigned long index;
-	const struct ccs_path_info *value;
-	bool is_not;
-	char c;
-	if (ccs_parse_ulong(&index, &start) != CCS_VALUE_TYPE_DECIMAL)
-		goto out;
-	if (*start++ != ']')
-		goto out;
-	c = *start++;
-	if (c == '=')
-		is_not = false;
-	else if (c == '!' && *start++ == '=')
-		is_not = true;
-	else
-		goto out;
-	value = ccs_get_dqword(start);
-	if (!value)
-		goto out;
-	argv->index = index;
-	argv->is_not = is_not;
-	argv->value = value;
-	return true;
- out:
-	return false;
-}
-
-/**
- * ccs_parse_envp - Parse an envp[] condition part.
- *
- * @start: String to parse.
- * @envp:  Pointer to "struct ccs_envp_entry".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_envp(char *start, struct ccs_envp_entry *envp)
-{
-	const struct ccs_path_info *name;
-	const struct ccs_path_info *value;
-	bool is_not;
-	char *cp = start;
-	/*
-	 * Since environment variable names don't
-	 * contain '=', I can treat '"]=' and '"]!='
-	 * sequences as delimiters.
-	 */
-	while (1) {
-		if (!strncmp(start, "\"]=", 3)) {
-			is_not = false;
-			*start = '\0';
-			start += 3;
-			break;
-		} else if (!strncmp(start, "\"]!=", 4)) {
-			is_not = true;
-			*start = '\0';
-			start += 4;
-			break;
-		} else if (!*start++) {
-			goto out;
-		}
-	}
-	if (!*cp || !ccs_is_correct_path(cp, 0, 0, 0))
-		goto out;
-	name = ccs_get_name(cp);
-	if (!name)
-		goto out;
-	if (!strcmp(start, "NULL")) {
-		value = NULL;
-	} else {
-		value = ccs_get_dqword(start);
-		if (!value)
-			goto out;
-	}
-	envp->name = name;
-	envp->is_not = is_not;
-	envp->value = value;
-	return true;
- out:
-	return false;
-}
-
-/* The list for "struct ccs_condition". */
-LIST_HEAD(ccs_condition_list);
-
 const char *ccs_condition_keyword[CCS_MAX_CONDITION_KEYWORD] = {
 	[CCS_TASK_UID]             = "task.uid",
 	[CCS_TASK_EUID]            = "task.euid",
@@ -469,339 +331,6 @@
 };
 
 /**
- * ccs_parse_post_condition - Parse post-condition part.
- *
- * @condition:  String to parse.
- * @post_state: Buffer to store post-condition part.
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_post_condition(char * const condition, u8 post_state[4])
-{
-	char *start = strstr(condition, "; set ");
-	if (!start)
-		return true;
-	*start = '\0';
-	start += 6;
-	while (1) {
-		int i;
-		unsigned long value;
-		while (*start == ' ')
-			start++;
-		if (!*start)
-			break;
-		if (!strncmp(start, "task.state[0]=", 14))
-			i = 0;
-		else if (!strncmp(start, "task.state[1]=", 14))
-			i = 1;
-		else if (!strncmp(start, "task.state[2]=", 14))
-			i = 2;
-		else
-			goto out;
-		start += 14;
-		if (post_state[3] & (1 << i))
-			goto out;
-		post_state[3] |= 1 << i;
-		if (!ccs_parse_ulong(&value, &start) || value > 255)
-			goto out;
-		post_state[i] = (u8) value;
-	}
-	return true;
- out:
-	return false;
-}
-
-/**
- * ccs_get_condition - Parse condition part.
- *
- * @condition: Pointer to string to parse.
- *
- * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
- */
-struct ccs_condition *ccs_get_condition(char * const condition)
-{
-	static const bool debug;
-	char *start = condition;
-	struct ccs_condition *entry = NULL;
-	struct ccs_condition *ptr;
-	struct ccs_condition_element *condp;
-	struct ccs_number_union *numbers_p;
-	struct ccs_name_union *names_p;
-	struct ccs_argv_entry *argv;
-	struct ccs_envp_entry *envp;
-	u32 size;
-	u8 i;
-	bool found = false;
-	u16 condc = 0;
-	u16 numbers_count = 0;
-	u16 names_count = 0;
-	u16 argc = 0;
-	u16 envc = 0;
-	u8 post_state[4] = { 0, 0, 0, 0 };
-	char *end_of_string;
-	if (!ccs_parse_post_condition(start, post_state))
-		goto out;
-	start = condition;
-	if (!strncmp(start, "if ", 3))
-		start += 3;
-	else if (*start)
-		return NULL;
-	end_of_string = start + strlen(start);
-	while (1) {
-		u8 left;
-		u8 right;
-		char *word = start;
-		char *cp;
-		char *eq;
-		bool is_not = false;
-		if (!*word)
-			break;
-		cp = strchr(start, ' ');
-		if (cp) {
-			*cp = '\0';
-			start = cp + 1;
-		} else {
-			start = "";
-		}
-		if (debug)
-			printk(KERN_WARNING "%u: <%s>\n", __LINE__, word);
-		if (!strncmp(word, "exec.argv[", 10)) {
-			argc++;
-			condc++;
-			continue;
-		} else if (!strncmp(word, "exec.envp[\"", 11)) {
-			envc++;
-			condc++;
-			continue;
-		}
-		eq = strchr(word, '=');
-		if (!eq)
-			goto out;
-		if (eq > word && *(eq - 1) == '!') {
-			is_not = true;
-			eq--;
-		}
-		*eq = '\0';
-		for (left = 0; left < CCS_MAX_CONDITION_KEYWORD; left++) {
-			if (strcmp(word, ccs_condition_keyword[left]))
-				continue;
-			break;
-		}
-		if (debug)
-			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
-			       word, left);
-		if (left == CCS_MAX_CONDITION_KEYWORD)
-			numbers_count++;
-		*eq = is_not ? '!' : '=';
-		word = eq + 1;
-		if (is_not)
-			word++;
-		condc++;
-		if (debug)
-			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
-			       word, left);
-		if (left == CCS_EXEC_REALPATH || left == CCS_SYMLINK_TARGET) {
-			names_count++;
-			continue;
-		}
-		for (right = 0; right < CCS_MAX_CONDITION_KEYWORD; right++) {
-			if (strcmp(word, ccs_condition_keyword[right]))
-				continue;
-			break;
-		}
-		if (debug)
-			printk(KERN_WARNING "%u: <%s> right=%u\n", __LINE__,
-			       word, right);
-		if (right == CCS_MAX_CONDITION_KEYWORD)
-			numbers_count++;
-	}
-	if (debug)
-		printk(KERN_DEBUG "%u: cond=%u numbers=%u names=%u ac=%u "
-		       "ec=%u\n", __LINE__, condc, numbers_count, names_count,
-		       argc, envc);
-	size = sizeof(*entry)
-		+ condc * sizeof(struct ccs_condition_element)
-		+ numbers_count * sizeof(struct ccs_number_union)
-		+ names_count * sizeof(struct ccs_name_union)
-		+ argc * sizeof(struct ccs_argv_entry)
-		+ envc * sizeof(struct ccs_envp_entry);
-	entry = kzalloc(size, GFP_KERNEL);
-	if (!entry)
-		return NULL;
-	INIT_LIST_HEAD(&entry->list);
-	for (i = 0; i < 4; i++)
-		entry->post_state[i] = post_state[i];
-	entry->condc = condc;
-	entry->numbers_count = numbers_count;
-	entry->names_count = names_count;
-	entry->argc = argc;
-	entry->envc = envc;
-	condp = (struct ccs_condition_element *) (entry + 1);
-	numbers_p = (struct ccs_number_union *) (condp + condc);
-	names_p = (struct ccs_name_union *) (numbers_p + numbers_count);
-	argv = (struct ccs_argv_entry *) (names_p + names_count);
-	envp = (struct ccs_envp_entry *) (argv + argc);
-	for (start = condition; start < end_of_string; start++)
-		if (!*start)
-			*start = ' ';
-	start = condition;
-	if (!strncmp(start, "if ", 3))
-		start += 3;
-	else if (*start)
-		goto out;
-	while (1) {
-		u8 left;
-		u8 right;
-		char *word = start;
-		char *cp;
-		char *eq;
-		bool is_not = false;
-		if (!*word)
-			break;
-		cp = strchr(start, ' ');
-		if (cp) {
-			*cp = '\0';
-			start = cp + 1;
-		} else {
-			start = "";
-		}
-		if (debug)
-			printk(KERN_WARNING "%u: <%s>\n", __LINE__, word);
-		if (!strncmp(word, "exec.argv[", 10)) {
-			if (!ccs_parse_argv(word + 10, argv))
-				goto out;
-			argv++;
-			argc--;
-			condc--;
-			left = CCS_ARGV_ENTRY;
-			right = -1;
-			goto store_value;
-		} else if (!strncmp(word, "exec.envp[\"", 11)) {
-			if (!ccs_parse_envp(word + 11, envp))
-				goto out;
-			envp++;
-			envc--;
-			condc--;
-			left = CCS_ENVP_ENTRY;
-			right = -1;
-			goto store_value;
-		}
-		eq = strchr(word, '=');
-		if (!eq) {
-			if (debug)
-				printk(KERN_WARNING "%u: No operator.\n",
-				       __LINE__);
-			goto out;
-		}
-		if (eq > word && *(eq - 1) == '!') {
-			is_not = true;
-			eq--;
-		}
-		*eq = '\0';
-		for (left = 0; left < CCS_MAX_CONDITION_KEYWORD; left++) {
-			if (strcmp(word, ccs_condition_keyword[left]))
-				continue;
-			break;
-		}
-		if (debug)
-			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
-			       word, left);
-		if (left == CCS_MAX_CONDITION_KEYWORD) {
-			left = CCS_NUMBER_UNION;
-			if (!ccs_parse_number_union(word, numbers_p))
-				goto out;
-			if (numbers_p->is_group)
-				goto out;
-			numbers_p++;
-			numbers_count--;
-		}
-		*eq = is_not ? '!' : '=';
-		word = eq + 1;
-		if (is_not)
-			word++;
-		condc--;
-		if (debug)
-			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
-			       word, left);
-		if (left == CCS_EXEC_REALPATH || left == CCS_SYMLINK_TARGET) {
-			right = CCS_NAME_UNION;
-			if (!ccs_parse_name_union_quoted(word, names_p++))
-				goto out;
-			names_count--;
-			goto store_value;
-		}
-		for (right = 0; right < CCS_MAX_CONDITION_KEYWORD; right++) {
-			if (strcmp(word, ccs_condition_keyword[right]))
-				continue;
-			break;
-		}
-		if (right == CCS_MAX_CONDITION_KEYWORD) {
-			right = CCS_NUMBER_UNION;
-			if (!ccs_parse_number_union(word, numbers_p++))
-				goto out;
-			numbers_count--;
-		}
- store_value:
-		condp->left = left;
-		condp->right = right;
-		condp->equals = !is_not;
-		if (debug)
-			printk(KERN_WARNING "%u: left=%u right=%u match=%u\n",
-			       __LINE__, condp->left, condp->right,
-			       condp->equals);
-		condp++;
-	}
-	if (debug) {
-		for (start = condition; start < end_of_string; start++)
-			if (!*start)
-				*start = ' ';
-		printk(KERN_DEBUG "%u: <%s> cond=%u numbers=%u names=%u ac=%u "
-		       "ec=%u\n", __LINE__, condition, condc, numbers_count,
-		       names_count, argc, envc);
-	}
-	BUG_ON(names_count);
-	BUG_ON(numbers_count);
-	BUG_ON(argc);
-	BUG_ON(envc);
-	BUG_ON(condc);
-	entry->size = size;
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_condition_list, list) {
-		if (ccs_memcmp(ptr, entry, offsetof(typeof(*entry), size),
-			       size))
-			continue;
-		/* Same entry found. Share this entry. */
-		atomic_inc(&ptr->users);
-		found = true;
-		break;
-	}
-	if (!found) {
-		if (ccs_memory_ok(entry, size)) {
-			atomic_set(&entry->users, 1);
-			list_add_rcu(&entry->list, &ccs_condition_list);
-		} else {
-			found = true;
-			ptr = NULL;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
-	if (found) {
-		ccs_del_condition(entry);
-		kfree(entry);
-		entry = ptr;
-	}
-	return entry;
- out:
-	if (debug)
-		printk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);
-	if (entry) {
-		ccs_del_condition(entry);
-		kfree(entry);
-	}
-	return NULL;
-}
-
-/**
  * ccs_get_attributes - Revalidate "struct inode".
  *
  * @obj: Pointer to "struct ccs_obj_info".
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/policy_io.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -10,205 +10,93 @@
  *
  */
 
+#include <linux/net.h>
+#include <linux/inet.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/udp.h>
 #include "internal.h"
 
-static struct ccs_profile ccs_default_profile = {
-	.learning = &ccs_default_profile.preference,
-	.permissive = &ccs_default_profile.preference,
-	.enforcing = &ccs_default_profile.preference,
-	.audit = &ccs_default_profile.preference,
-#ifdef CONFIG_CCSECURITY_AUDIT
-	.preference.audit_max_grant_log = CONFIG_CCSECURITY_MAX_GRANT_LOG,
-	.preference.audit_max_reject_log = CONFIG_CCSECURITY_MAX_REJECT_LOG,
-#endif
-	.preference.audit_task_info = true,
-	.preference.audit_path_info = true,
-	.preference.enforcing_penalty = 0,
-	.preference.enforcing_verbose = true,
-	.preference.learning_max_entry = CONFIG_CCSECURITY_MAX_ACCEPT_ENTRY,
-	.preference.learning_verbose = false,
-	.preference.learning_exec_realpath = true,
-	.preference.learning_exec_argv0 = true,
-	.preference.learning_symlink_target = true,
-	.preference.permissive_verbose = true
-};
-
-/* Profile version. Currently only 20090903 is defined. */
-static unsigned int ccs_profile_version;
-
-/* Profile table. Memory is allocated as needed. */
-static struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
-
 /* String table for functionality that takes 4 modes. */
 static const char *ccs_mode_4[4] = {
 	"disabled", "learning", "permissive", "enforcing"
 };
 
-/* String table for /proc/ccs/profile */
-static const char *ccs_mac_keywords[CCS_MAX_MAC_INDEX +
-				    CCS_MAX_CAPABILITY_INDEX +
-				    CCS_MAX_MAC_CATEGORY_INDEX] = {
-	[CCS_MAC_FILE_EXECUTE]
-	= "file::execute",
-	[CCS_MAC_FILE_OPEN]
-	= "file::open",
-	[CCS_MAC_FILE_CREATE]
-	= "file::create",
-	[CCS_MAC_FILE_UNLINK]
-	= "file::unlink",
-	[CCS_MAC_FILE_MKDIR]
-	= "file::mkdir",
-	[CCS_MAC_FILE_RMDIR]
-	= "file::rmdir",
-	[CCS_MAC_FILE_MKFIFO]
-	= "file::mkfifo",
-	[CCS_MAC_FILE_MKSOCK]
-	= "file::mksock",
-	[CCS_MAC_FILE_TRUNCATE]
-	= "file::truncate",
-	[CCS_MAC_FILE_SYMLINK]
-	= "file::symlink",
-	[CCS_MAC_FILE_REWRITE]
-	= "file::rewrite",
-	[CCS_MAC_FILE_MKBLOCK]
-	= "file::mkblock",
-	[CCS_MAC_FILE_MKCHAR]
-	= "file::mkchar",
-	[CCS_MAC_FILE_LINK]
-	= "file::link",
-	[CCS_MAC_FILE_RENAME]
-	= "file::rename",
-	[CCS_MAC_FILE_CHMOD]
-	= "file::chmod",
-	[CCS_MAC_FILE_CHOWN]
-	= "file::chown",
-	[CCS_MAC_FILE_CHGRP]
-	= "file::chgrp",
-	[CCS_MAC_FILE_IOCTL]
-	= "file::ioctl",
-	[CCS_MAC_FILE_CHROOT]
-	= "file::chroot",
-	[CCS_MAC_FILE_MOUNT]
-	= "file::mount",
-	[CCS_MAC_FILE_UMOUNT]
-	= "file::umount",
-	[CCS_MAC_FILE_PIVOT_ROOT]
-	= "file::pivot_root",
-	[CCS_MAC_FILE_TRANSIT]
-	= "file::transit",
-	[CCS_MAC_ENVIRON]
-	= "misc::env",
-	[CCS_MAC_NETWORK_UDP_BIND]
-	= "network::inet_udp_bind",
-	[CCS_MAC_NETWORK_UDP_CONNECT]
-	= "network::inet_udp_connect",
-	[CCS_MAC_NETWORK_TCP_BIND]
-	= "network::inet_tcp_bind",
-	[CCS_MAC_NETWORK_TCP_LISTEN]
-	= "network::inet_tcp_listen",
-	[CCS_MAC_NETWORK_TCP_CONNECT]
-	= "network::inet_tcp_connect",
-	[CCS_MAC_NETWORK_TCP_ACCEPT]
-	= "network::inet_tcp_accept",
-	[CCS_MAC_NETWORK_RAW_BIND]
-	= "network::inet_raw_bind",
-	[CCS_MAC_NETWORK_RAW_CONNECT]
-	= "network::inet_raw_connect",
-	[CCS_MAC_SIGNAL]
-	= "ipc::signal",
-	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_CREATE]
-	= "capability::inet_tcp_create",
-	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_LISTEN]
-	= "capability::inet_tcp_listen",
-	[CCS_MAX_MAC_INDEX + CCS_INET_STREAM_SOCKET_CONNECT]
-	= "capability::inet_tcp_connect",
-	[CCS_MAX_MAC_INDEX + CCS_USE_INET_DGRAM_SOCKET]
-	= "capability::use_inet_udp",
-	[CCS_MAX_MAC_INDEX + CCS_USE_INET_RAW_SOCKET]
-	= "capability::use_inet_ip",
-	[CCS_MAX_MAC_INDEX + CCS_USE_ROUTE_SOCKET]
-	= "capability::use_route",
-	[CCS_MAX_MAC_INDEX + CCS_USE_PACKET_SOCKET]
-	= "capability::use_packet",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_MOUNT]
-	= "capability::SYS_MOUNT",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_UMOUNT]
-	= "capability::SYS_UMOUNT",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_REBOOT]
-	= "capability::SYS_REBOOT",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_CHROOT]
-	= "capability::SYS_CHROOT",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_KILL]
-	= "capability::SYS_KILL",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_VHANGUP]
-	= "capability::SYS_VHANGUP",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_SETTIME]
-	= "capability::SYS_TIME",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_NICE]
-	= "capability::SYS_NICE",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_SETHOSTNAME]
-	= "capability::SYS_SETHOSTNAME",
-	[CCS_MAX_MAC_INDEX + CCS_USE_KERNEL_MODULE]
-	= "capability::use_kernel_module",
-	[CCS_MAX_MAC_INDEX + CCS_CREATE_FIFO]
-	= "capability::create_fifo",
-	[CCS_MAX_MAC_INDEX + CCS_CREATE_BLOCK_DEV]
-	= "capability::create_block_dev",
-	[CCS_MAX_MAC_INDEX + CCS_CREATE_CHAR_DEV]
-	= "capability::create_char_dev",
-	[CCS_MAX_MAC_INDEX + CCS_CREATE_UNIX_SOCKET]
-	= "capability::create_unix_socket",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_LINK]
-	= "capability::SYS_LINK",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_SYMLINK]
-	= "capability::SYS_SYMLINK",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_RENAME]
-	= "capability::SYS_RENAME",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_UNLINK]
-	= "capability::SYS_UNLINK",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_CHMOD]
-	= "capability::SYS_CHMOD",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_CHOWN]
-	= "capability::SYS_CHOWN",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_IOCTL]
-	= "capability::SYS_IOCTL",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_KEXEC_LOAD]
-	= "capability::SYS_KEXEC_LOAD",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_PIVOT_ROOT]
-	= "capability::SYS_PIVOT_ROOT",
-	[CCS_MAX_MAC_INDEX + CCS_SYS_PTRACE]
-	= "capability::SYS_PTRACE",
-	[CCS_MAX_MAC_INDEX + CCS_CONCEAL_MOUNT]
-	= "capability::conceal_mount",
-	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
-	 + CCS_MAC_CATEGORY_FILE] = "file",
-	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
-	 + CCS_MAC_CATEGORY_NETWORK] = "network",
-	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
-	 + CCS_MAC_CATEGORY_MISC] = "misc",
-	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
-	 + CCS_MAC_CATEGORY_IPC] = "ipc",
-	[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX
-	 + CCS_MAC_CATEGORY_CAPABILITY] = "capability",
-};
-
 /* Permit policy management by non-root user? */
 static bool ccs_manage_by_non_root;
 
 /**
- * ccs_cap2keyword - Convert capability operation to capability name.
+ * ccs_commit_ok - Check memory quota.
  *
- * @operation: The capability index.
+ * @ptr:    Pointer to allocated memory.
+ * @data:   Data to copy from.
+ * @size:   Size in byte.
  *
- * Returns the name of the specified capability's name.
+ * Returns true if @ptr is not NULL and quota not exceeded, false otherwise.
  */
-const char *ccs_cap2keyword(const u8 operation)
+static bool ccs_commit_ok(void *ptr, void *data, const unsigned int size)
 {
-	return operation < CCS_MAX_CAPABILITY_INDEX
-		? ccs_mac_keywords[CCS_MAX_MAC_INDEX + operation] + 12 : NULL;
+	if (ccs_memory_ok(ptr, size)) {
+		memmove(ptr, data, size);
+		memset(data, 0, size);
+		return true;
+	}
+	return false;
 }
 
 /**
+ * ccs_tokenize - Tokenize string.
+ *
+ * @buffer: The line to tokenize.
+ * @w:      Pointer to "char *".
+ * @size:   Sizeof @w .
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_tokenize(char *buffer, char *w[], size_t size)
+{
+	int count = size / sizeof(char *);
+	int i;
+	for (i = 0; i < count; i++)
+		w[i] = "";
+	for (i = 0; i < count; i++) {
+		char *cp = strchr(buffer, ' ');
+		if (cp)
+			*cp = '\0';
+		w[i] = buffer;
+		if (!cp)
+			break;
+		buffer = cp + 1;
+	}
+	return i < count || !*buffer;
+}
+
+/**
+ * ccs_str_starts - Check whether the given string starts with the given keyword.
+ *
+ * @src:  Pointer to pointer to the string.
+ * @find: Pointer to the keyword.
+ *
+ * Returns true if @src starts with @find, false otherwise.
+ *
+ * The @src is updated to point the first character after the @find
+ * if @src starts with @find.
+ */
+static bool ccs_str_starts(char **src, const char *find)
+{
+	const int len = strlen(find);
+	char *tmp = *src;
+	if (strncmp(tmp, find, len))
+		return false;
+	tmp += len;
+	*src = tmp;
+	return true;
+}
+
+
+/**
  * ccs_yesno - Return "yes" or "no".
  *
  * @value: Bool value.
@@ -263,7 +151,7 @@
 	if (ptr)
 		return ptr;
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
+	mutex_lock(&ccsecurity.policy_lock);
 	ptr = ccs_profile_ptr[profile];
 	if (!ptr && ccs_memory_ok(entry, sizeof(*entry))) {
 		ptr = entry;
@@ -279,47 +167,12 @@
 		ccs_profile_ptr[profile] = ptr;
 		entry = NULL;
 	}
-	mutex_unlock(&ccs_policy_lock);
+	mutex_unlock(&ccsecurity.policy_lock);
 	kfree(entry);
 	return ptr;
 }
 
 /**
- * ccs_check_profile - Check all profiles currently assigned to domains are defined.
- */
-void ccs_check_profile(void)
-{
-	struct ccs_domain_info *domain;
-	ccs_policy_loaded = true;
-	list_for_each_entry_rcu(domain, &ccs_domain_list, list) {
-		const u8 profile = domain->profile;
-		if (ccs_profile_ptr[profile])
-			continue;
-		panic("Profile %u (used by '%s') not defined.\n",
-		      profile, domain->domainname->name);
-	}
-	if (ccs_profile_version != 20090903)
-		panic("Profile version %u is not supported.\n",
-		      ccs_profile_version);
-}
-
-/**
- * ccs_profile - Find a profile.
- *
- * @profile: Profile number to find.
- *
- * Returns pointer to "struct ccs_profile".
- */
-struct ccs_profile *ccs_profile(const u8 profile)
-{
-	struct ccs_profile *ptr = ccs_profile_ptr[profile];
-	if (!ccs_policy_loaded)
-		return &ccs_default_profile;
-	BUG_ON(!ptr);
-	return ptr;
-}
-
-/**
  * ccs_write_profile - Write profile table.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -654,9 +507,6 @@
 		head->read_eof = true;
 }
 
-/* The list for "struct ccs_policy_manager_entry". */
-LIST_HEAD(ccs_policy_manager_list);
-
 /**
  * ccs_update_manager_entry - Add a manager entry.
  *
@@ -684,8 +534,8 @@
 		return -ENOMEM;
 	if (!is_delete)
 		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_policy_manager_list, list) {
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &ccsecurity.policy_manager, list) {
 		if (ptr->manager != e.manager)
 			continue;
 		ptr->is_deleted = is_delete;
@@ -693,11 +543,11 @@
 		break;
 	}
 	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_policy_manager_list);
+		list_add_tail_rcu(&entry->list, &ccsecurity.policy_manager);
 		entry = NULL;
 		error = 0;
 	}
-	mutex_unlock(&ccs_policy_lock);
+	mutex_unlock(&ccsecurity.policy_lock);
 	ccs_put_name(e.manager);
 	kfree(entry);
 	return error;
@@ -733,7 +583,7 @@
 	struct list_head *pos;
 	if (head->read_eof)
 		return;
-	list_for_each_cookie(pos, head->read_var2, &ccs_policy_manager_list) {
+	list_for_each_cookie(pos, head->read_var2, &ccsecurity.policy_manager) {
 		struct ccs_policy_manager_entry *ptr;
 		ptr = list_entry(pos, struct ccs_policy_manager_entry, list);
 		if (ptr->is_deleted)
@@ -766,7 +616,7 @@
 		return true;
 	if (!ccs_manage_by_non_root && (current_uid() || current_euid()))
 		return false;
-	list_for_each_entry_rcu(ptr, &ccs_policy_manager_list, list) {
+	list_for_each_entry_rcu(ptr, &ccsecurity.policy_manager, list) {
 		if (!ptr->is_deleted && ptr->is_domain
 		    && !ccs_pathcmp(domainname, ptr->manager)) {
 			/* Set manager flag. */
@@ -777,7 +627,7 @@
 	exe = ccs_get_exe();
 	if (!exe)
 		return false;
-	list_for_each_entry_rcu(ptr, &ccs_policy_manager_list, list) {
+	list_for_each_entry_rcu(ptr, &ccsecurity.policy_manager, list) {
 		if (!ptr->is_deleted && !ptr->is_domain
 		    && !strcmp(exe, ptr->manager->name)) {
 			found = true;
@@ -800,6 +650,198 @@
 }
 
 /**
+ * ccs_get_path_group - Allocate memory for "struct ccs_path_group".
+ *
+ * @group_name: The name of pathname group.
+ *
+ * Returns pointer to "struct ccs_path_group" on success, NULL otherwise.
+ */
+static struct ccs_path_group *ccs_get_path_group(const char *group_name)
+{
+	struct ccs_path_group *entry = NULL;
+	struct ccs_path_group *group;
+	const struct ccs_path_info *saved_group_name;
+	int error = -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
+	    !group_name[0])
+		return NULL;
+	saved_group_name = ccs_get_name(group_name);
+	if (!saved_group_name)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(group, &ccsecurity.path_group, list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		atomic_inc(&group->users);
+		error = 0;
+		break;
+	}
+	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
+		INIT_LIST_HEAD(&entry->member_list);
+		entry->group_name = saved_group_name;
+		saved_group_name = NULL;
+		atomic_set(&entry->users, 1);
+		list_add_tail_rcu(&entry->list, &ccsecurity.path_group);
+		group = entry;
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_name(saved_group_name);
+	kfree(entry);
+	return !error ? group : NULL;
+}
+
+/**
+ * ccs_parse_name_union - Parse a ccs_name_union.
+ *
+ * @filename: Name or name group.
+ * @ptr:      Pointer to "struct ccs_name_union".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_parse_name_union(const char *filename,
+				 struct ccs_name_union *ptr)
+{
+	if (!ccs_is_correct_path(filename, 0, 0, 0))
+		return false;
+	if (filename[0] == '@') {
+		ptr->group = ccs_get_path_group(filename + 1);
+		ptr->is_group = true;
+		return ptr->group != NULL;
+	}
+	ptr->filename = ccs_get_name(filename);
+	ptr->is_group = false;
+	return ptr->filename != NULL;
+}
+
+/**
+ * ccs_get_number_group - Allocate memory for "struct ccs_number_group".
+ *
+ * @group_name: The name of number group.
+ *
+ * Returns pointer to "struct ccs_number_group" on success,
+ * NULL otherwise.
+ */
+static struct ccs_number_group *ccs_get_number_group(const char *group_name)
+{
+	struct ccs_number_group *entry = NULL;
+	struct ccs_number_group *group;
+	const struct ccs_path_info *saved_group_name;
+	int error = -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
+	    !group_name[0])
+		return NULL;
+	saved_group_name = ccs_get_name(group_name);
+	if (!saved_group_name)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(group, &ccsecurity.number_group, list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		atomic_inc(&group->users);
+		error = 0;
+		break;
+	}
+	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
+		INIT_LIST_HEAD(&entry->member_list);
+		entry->group_name = saved_group_name;
+		saved_group_name = NULL;
+		atomic_set(&entry->users, 1);
+		list_add_tail_rcu(&entry->list, &ccsecurity.number_group);
+		group = entry;
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_name(saved_group_name);
+	kfree(entry);
+	return !error ? group : NULL;
+}
+
+/**
+ * ccs_parse_ulong - Parse an "unsigned long" value.
+ *
+ * @result: Pointer to "unsigned long".
+ * @str:    Pointer to string to parse.
+ *
+ * Returns value type on success, 0 otherwise.
+ *
+ * The @src is updated to point the first character after the value
+ * on success.
+ */
+static u8 ccs_parse_ulong(unsigned long *result, char **str)
+{
+	const char *cp = *str;
+	char *ep;
+	int base = 10;
+	if (*cp == '0') {
+		char c = *(cp + 1);
+		if (c == 'x' || c == 'X') {
+			base = 16;
+			cp += 2;
+		} else if (c >= '0' && c <= '7') {
+			base = 8;
+			cp++;
+		}
+	}
+	*result = simple_strtoul(cp, &ep, base);
+	if (cp == ep)
+		return 0;
+	*str = ep;
+	switch (base) {
+	case 16:
+		return CCS_VALUE_TYPE_HEXADECIMAL;
+	case 8:
+		return CCS_VALUE_TYPE_OCTAL;
+	default:
+		return CCS_VALUE_TYPE_DECIMAL;
+	}
+}
+
+/**
+ * ccs_parse_number_union - Parse a ccs_number_union.
+ *
+ * @data: Number or number range or number group.
+ * @ptr:  Pointer to "struct ccs_number_union".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_parse_number_union(char *data, struct ccs_number_union *num)
+{
+	u8 type;
+	unsigned long v;
+	memset(num, 0, sizeof(*num));
+	if (data[0] == '@') {
+		if (!ccs_is_correct_path(data, 0, 0, 0))
+			return false;
+		num->group = ccs_get_number_group(data + 1);
+		num->is_group = true;
+		return num->group != NULL;
+	}
+	type = ccs_parse_ulong(&v, &data);
+	if (!type)
+		return false;
+	num->values[0] = v;
+	num->min_type = type;
+	if (!*data) {
+		num->values[1] = v;
+		num->max_type = type;
+		return true;
+	}
+	if (*data++ != '-')
+		return false;
+	type = ccs_parse_ulong(&v, &data);
+	if (!type || *data)
+		return false;
+	num->values[1] = v;
+	num->max_type = type;
+	return true;
+}
+
+/**
  * ccs_find_condition_part - Find condition part from the statement.
  *
  * @data: String to parse.
@@ -876,7 +918,7 @@
 	if (domain) {
 		struct ccs_domain_info *d;
 		head->read_var1 = NULL;
-		list_for_each_entry_rcu(d, &ccs_domain_list, list) {
+		list_for_each_entry_rcu(d, &ccsecurity.domain, list) {
 			if (d == domain)
 				break;
 			head->read_var1 = &d->list;
@@ -890,6 +932,893 @@
 	return true;
 }
 
+/**
+ * ccs_write_capability_policy - Write "struct ccs_capability_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_capability_policy(char *data, struct ccs_domain_info *domain,
+				       struct ccs_condition *condition,
+				       const bool is_delete)
+{
+	struct ccs_capability_acl e = {
+		.head.type = CCS_TYPE_CAPABILITY_ACL,
+		.head.cond = condition,
+	};
+	struct ccs_capability_acl *entry = NULL;
+	struct ccs_acl_info *ptr;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	u8 capability;
+	for (capability = 0; capability < CCS_MAX_CAPABILITY_INDEX;
+	     capability++) {
+		if (strcmp(data, ccs_cap2keyword(capability)))
+			continue;
+		break;
+	}
+	if (capability == CCS_MAX_CAPABILITY_INDEX)
+		return -EINVAL;
+	e.operation = capability;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_capability_acl *acl =
+			container_of(ptr, struct ccs_capability_acl, head);
+		if (ptr->type != CCS_TYPE_CAPABILITY_ACL ||
+		    ptr->cond != condition || acl->operation != capability)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_get_address_group - Allocate memory for "struct ccs_address_group".
+ *
+ * @group_name: The name of address group.
+ *
+ * Returns pointer to "struct ccs_address_group" on success,
+ * NULL otherwise.
+ */
+static struct ccs_address_group *ccs_get_address_group(const char *group_name)
+{
+	struct ccs_address_group *entry = NULL;
+	struct ccs_address_group *group;
+	const struct ccs_path_info *saved_group_name;
+	int error = -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
+	    !group_name[0])
+		return NULL;
+	saved_group_name = ccs_get_name(group_name);
+	if (!saved_group_name)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(group, &ccsecurity.address_group, list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		atomic_inc(&group->users);
+		error = 0;
+		break;
+	}
+	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
+		INIT_LIST_HEAD(&entry->member_list);
+		entry->group_name = saved_group_name;
+		saved_group_name = NULL;
+		atomic_set(&entry->users, 1);
+		list_add_tail_rcu(&entry->list, &ccsecurity.address_group);
+		group = entry;
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_name(saved_group_name);
+	kfree(entry);
+	return !error ? group : NULL;
+}
+
+/**
+ * ccs_parse_ip_address - Parse an IP address.
+ *
+ * @address: String to parse.
+ * @min:     Pointer to store min address.
+ * @max:     Pointer to store max address.
+ *
+ * Returns 2 if @address is an IPv6, 1 if @address is an IPv4, 0 otherwise.
+ */
+static int ccs_parse_ip_address(char *address, u16 *min, u16 *max)
+{
+	int count = sscanf(address, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx"
+			   "-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
+			   &min[0], &min[1], &min[2], &min[3],
+			   &min[4], &min[5], &min[6], &min[7],
+			   &max[0], &max[1], &max[2], &max[3],
+			   &max[4], &max[5], &max[6], &max[7]);
+	if (count == 8 || count == 16) {
+		u8 i;
+		if (count == 8)
+			memmove(max, min, sizeof(u16) * 8);
+		for (i = 0; i < 8; i++) {
+			min[i] = htons(min[i]);
+			max[i] = htons(max[i]);
+		}
+		return 2;
+	}
+	count = sscanf(address, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
+		       &min[0], &min[1], &min[2], &min[3],
+		       &max[0], &max[1], &max[2], &max[3]);
+	if (count == 4 || count == 8) {
+		u32 ip = htonl((((u8) min[0]) << 24) + (((u8) min[1]) << 16)
+			       + (((u8) min[2]) << 8) + (u8) min[3]);
+		memmove(min, &ip, sizeof(ip));
+		if (count == 8)
+			ip = htonl((((u8) max[0]) << 24) + (((u8) max[1]) << 16)
+				   + (((u8) max[2]) << 8) + (u8) max[3]);
+		memmove(max, &ip, sizeof(ip));
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * ccs_write_network_policy - Write "struct ccs_ip_network_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_network_policy(char *data, struct ccs_domain_info *domain,
+				    struct ccs_condition *condition,
+				    const bool is_delete)
+{
+	struct ccs_ip_network_acl *entry = NULL;
+	struct ccs_acl_info *ptr;
+	struct ccs_ip_network_acl e = {
+		.head.type = CCS_TYPE_IP_NETWORK_ACL,
+		.head.cond = condition,
+	};
+	u16 min_address[8];
+	u16 max_address[8];
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	u8 sock_type;
+	char *w[4];
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[3][0])
+		return -EINVAL;
+	if (!strcmp(w[0], "TCP"))
+		sock_type = SOCK_STREAM;
+	else if (!strcmp(w[0], "UDP"))
+		sock_type = SOCK_DGRAM;
+	else if (!strcmp(w[0], "RAW"))
+		sock_type = SOCK_RAW;
+	else
+		return -EINVAL;
+	if (!strcmp(w[1], "bind"))
+		switch (sock_type) {
+		case SOCK_STREAM:
+			e.perm = 1 << CCS_NETWORK_TCP_BIND;
+			break;
+		case SOCK_DGRAM:
+			e.perm = 1 << CCS_NETWORK_UDP_BIND;
+			break;
+		default:
+			e.perm = 1 << CCS_NETWORK_RAW_BIND;
+			break;
+		}
+	else if (!strcmp(w[1], "connect"))
+		switch (sock_type) {
+		case SOCK_STREAM:
+			e.perm = 1 << CCS_NETWORK_TCP_CONNECT;
+			break;
+		case SOCK_DGRAM:
+			e.perm = 1 << CCS_NETWORK_UDP_CONNECT;
+			break;
+		default:
+			e.perm = 1 << CCS_NETWORK_RAW_CONNECT;
+			break;
+		}
+	else if (sock_type == SOCK_STREAM && !strcmp(w[1], "listen"))
+		e.perm = 1 << CCS_NETWORK_TCP_LISTEN;
+	else if (sock_type == SOCK_STREAM && !strcmp(w[1], "accept"))
+		e.perm = 1 << CCS_NETWORK_TCP_ACCEPT;
+	else
+		return -EINVAL;
+	switch (ccs_parse_ip_address(w[2], min_address, max_address)) {
+	case 2:
+		e.address_type = CCS_IP_ADDRESS_TYPE_IPv6;
+		e.address.ipv6.min = ccs_get_ipv6_address((struct in6_addr *)
+							  min_address);
+		e.address.ipv6.max = ccs_get_ipv6_address((struct in6_addr *)
+							  max_address);
+		if (!e.address.ipv6.min || !e.address.ipv6.max)
+			goto out;
+		break;
+	case 1:
+		e.address_type = CCS_IP_ADDRESS_TYPE_IPv4;
+		/* use host byte order to allow u32 comparison.*/
+		e.address.ipv4.min = ntohl(*(u32 *) min_address);
+		e.address.ipv4.max = ntohl(*(u32 *) max_address);
+		break;
+	default:
+		if (w[2][0] != '@')
+			return -EINVAL;
+		e.address_type = CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
+		e.address.group = ccs_get_address_group(w[2] + 1);
+		if (!e.address.group)
+			return -ENOMEM;
+		break;
+	}
+	if (!ccs_parse_number_union(w[3], &e.port))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_ip_network_acl *acl =
+			container_of(ptr, struct ccs_ip_network_acl, head);
+		if (ptr->type != CCS_TYPE_IP_NETWORK_ACL ||
+		    ptr->cond != condition ||
+		    ccs_memcmp(acl, &e, offsetof(typeof(e), address_type),
+			       sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~e.perm;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= e.perm;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	if (w[2][0] == '@')
+		ccs_put_address_group(e.address.group);
+	else if (e.address_type == CCS_IP_ADDRESS_TYPE_IPv6) {
+		ccs_put_ipv6_address(e.address.ipv6.min);
+		ccs_put_ipv6_address(e.address.ipv6.max);
+	}
+	ccs_put_number_union(&e.port);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_signal_policy - Write "struct ccs_signal_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_signal_policy(char *data, struct ccs_domain_info *domain,
+				   struct ccs_condition *condition,
+				   const bool is_delete)
+{
+	struct ccs_signal_acl *entry = NULL;
+	struct ccs_acl_info *ptr;
+	struct ccs_signal_acl e = { .head.type = CCS_TYPE_SIGNAL_ACL,
+				    .head.cond = condition };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	int sig;
+	char *domainname = strchr(data, ' ');
+	if (sscanf(data, "%d", &sig) != 1 || !domainname ||
+	    !ccs_is_correct_domain(domainname + 1))
+		return -EINVAL;
+	e.sig = sig;
+	e.domainname = ccs_get_name(domainname + 1);
+	if (!e.domainname)
+		return -ENOMEM;
+	if (!is_delete)
+		entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_signal_acl *acl =
+			container_of(ptr, struct ccs_signal_acl, head);
+		if (ptr->type != CCS_TYPE_SIGNAL_ACL || ptr->cond != condition
+		    || acl->sig != sig || acl->domainname != e.domainname)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_name(e.domainname);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_env_policy - Write "struct ccs_env_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_env_policy(char *data, struct ccs_domain_info *domain,
+				struct ccs_condition *condition,
+				const bool is_delete)
+{
+	struct ccs_env_acl *entry = NULL;
+	struct ccs_acl_info *ptr;
+	struct ccs_env_acl e = {
+		.head.type = CCS_TYPE_ENV_ACL,
+		.head.cond = condition
+	};
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(data, 0, 0, 0) || strchr(data, '='))
+		return -EINVAL;
+	e.env = ccs_get_name(data);
+	if (!e.env)
+		return error;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_env_acl *acl =
+			container_of(ptr, struct ccs_env_acl, head);
+		if (ptr->type != CCS_TYPE_ENV_ACL || ptr->cond != condition ||
+		    acl->env != e.env)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_name(e.env);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_mount_policy - Write "struct ccs_mount_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_mount_policy(char *data, struct ccs_domain_info *domain,
+				  struct ccs_condition *condition,
+				  const bool is_delete)
+{
+	struct ccs_mount_acl *entry = NULL;
+	struct ccs_acl_info *ptr;
+	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL,
+				   .head.cond = condition };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	char *w[4];
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[3][0])
+		return -EINVAL;
+	if (!ccs_parse_name_union(w[0], &e.dev_name) ||
+	    !ccs_parse_name_union(w[1], &e.dir_name) ||
+	    !ccs_parse_name_union(w[2], &e.fs_type) ||
+	    !ccs_parse_number_union(w[3], &e.flags))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_mount_acl *acl =
+			container_of(ptr, struct ccs_mount_acl, head);
+		if (ptr->type != CCS_TYPE_MOUNT_ACL || ptr->cond != condition
+		    || ccs_memcmp(acl, &e, offsetof(typeof(e), dev_name),
+				  sizeof(e)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	ccs_put_name_union(&e.dev_name);
+	ccs_put_name_union(&e.dir_name);
+	ccs_put_name_union(&e.fs_type);
+	ccs_put_number_union(&e.flags);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_execute_handler - Update "struct ccs_execute_handler_record" list.
+ *
+ * @type:      Type of execute handler.
+ * @filename:  Pathname to the execute handler.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_execute_handler(const u8 type, const char *filename,
+				      struct ccs_domain_info * const domain,
+				      const bool is_delete)
+{
+	struct ccs_acl_info *ptr;
+	struct ccs_execute_handler_record e = { .head.type = type };
+	struct ccs_execute_handler_record *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!domain)
+		return -EINVAL;
+	if (!ccs_is_correct_path(filename, 1, -1, -1))
+		return -EINVAL;
+	e.handler = ccs_get_name(filename);
+	if (!e.handler)
+		return -ENOMEM;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_execute_handler_record *acl;
+		if (ptr->type != type)
+			continue;
+		/* Condition not supported. */
+		acl = container_of(ptr, struct ccs_execute_handler_record,
+				   head);
+		if (acl->handler != e.handler)
+			continue;
+		if (!is_delete) {
+			/* Only one entry can exist in a domain. */
+			struct ccs_acl_info *ptr2;
+			list_for_each_entry_rcu(ptr2, &domain->acl_info_list,
+						list) {
+				if (ptr2->type == type)
+					ptr2->is_deleted = true;
+			}
+		}
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		/* Only one entry can exist in a domain. */
+		list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+			if (ptr->type == type)
+				ptr->is_deleted = true;
+		}
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_name(e.handler);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_path_acl - Update "struct ccs_path_acl" list.
+ *
+ * @type:      Type of operation.
+ * @filename:  Filename.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_path_acl(const u8 type, const char *filename,
+			       struct ccs_domain_info * const domain,
+			       struct ccs_condition *condition,
+			       const bool is_delete)
+{
+	static const u16 ccs_rw_mask =
+		(1 << CCS_TYPE_READ) | (1 << CCS_TYPE_WRITE);
+	const u16 perm = 1 << type;
+	struct ccs_acl_info *ptr;
+	struct ccs_path_acl e = {
+		.head.type = CCS_TYPE_PATH_ACL,
+		.head.cond = condition,
+		.perm = perm
+	};
+	struct ccs_path_acl *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (type == CCS_TYPE_READ_WRITE)
+		e.perm |= ccs_rw_mask;
+	if (!ccs_parse_name_union(filename, &e.name))
+		return -EINVAL;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_path_acl *acl =
+			container_of(ptr, struct ccs_path_acl, head);
+		if (ptr->type != CCS_TYPE_PATH_ACL ||
+		    ptr->cond != condition ||
+		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~perm;
+			if ((acl->perm & ccs_rw_mask) != ccs_rw_mask)
+				acl->perm &= ~(1 << CCS_TYPE_READ_WRITE);
+			else if (!(acl->perm & (1 << CCS_TYPE_READ_WRITE)))
+				acl->perm &= ~ccs_rw_mask;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= perm;
+			if ((acl->perm & ccs_rw_mask) == ccs_rw_mask)
+				acl->perm |= 1 << CCS_TYPE_READ_WRITE;
+			else if (acl->perm & (1 << CCS_TYPE_READ_WRITE))
+				acl->perm |= ccs_rw_mask;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_name_union(&e.name);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_path_number3_acl - Update "struct ccs_path_number3_acl" list.
+ *
+ * @type:      Type of operation.
+ * @filename:  Filename.
+ * @mode:      Create mode.
+ * @major:     Device major number.
+ * @minor:     Device minor number.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_path_number3_acl(const u8 type, const char *filename,
+				       char *mode, char *major, char *minor,
+				       struct ccs_domain_info * const domain,
+				       struct ccs_condition *condition,
+				       const bool is_delete)
+{
+	const u8 perm = 1 << type;
+	struct ccs_acl_info *ptr;
+	struct ccs_path_number3_acl e = {
+		.head.type = CCS_TYPE_PATH_NUMBER3_ACL,
+		.head.cond = condition,
+		.perm = perm
+	};
+	struct ccs_path_number3_acl *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_parse_name_union(filename, &e.name) ||
+	    !ccs_parse_number_union(mode, &e.mode) ||
+	    !ccs_parse_number_union(major, &e.major) ||
+	    !ccs_parse_number_union(minor, &e.minor))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_path_number3_acl *acl =
+			container_of(ptr, struct ccs_path_number3_acl, head);
+		if (ptr->type != CCS_TYPE_PATH_NUMBER3_ACL ||
+		    ptr->cond != condition ||
+		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~perm;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= perm;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	ccs_put_name_union(&e.name);
+	ccs_put_number_union(&e.mode);
+	ccs_put_number_union(&e.major);
+	ccs_put_number_union(&e.minor);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_path2_acl - Update "struct ccs_path2_acl" list.
+ *
+ * @type:      Type of operation.
+ * @filename1: First filename.
+ * @filename2: Second filename.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_path2_acl(const u8 type, const char *filename1,
+				const char *filename2,
+				struct ccs_domain_info * const domain,
+				struct ccs_condition *condition,
+				const bool is_delete)
+{
+	const u8 perm = 1 << type;
+	struct ccs_acl_info *ptr;
+	struct ccs_path2_acl e = {
+		.head.type = CCS_TYPE_PATH2_ACL,
+		.head.cond = condition,
+		.perm = perm
+	};
+	struct ccs_path2_acl *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_parse_name_union(filename1, &e.name1) ||
+	    !ccs_parse_name_union(filename2, &e.name2))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_path2_acl *acl =
+			container_of(ptr, struct ccs_path2_acl, head);
+		if (ptr->type != CCS_TYPE_PATH2_ACL ||
+		    ptr->cond != condition ||
+		    ccs_memcmp(acl, &e, offsetof(typeof(e), name1), sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~perm;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= perm;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	ccs_put_name_union(&e.name1);
+	ccs_put_name_union(&e.name2);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_path_number_acl - Update ioctl/chmod/chown/chgrp ACL.
+ *
+ * @type:      Type of operation.
+ * @filename:  Filename.
+ * @number:    Number.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_path_number_acl(const u8 type, const char *filename,
+				      char *number,
+				      struct ccs_domain_info * const domain,
+				      struct ccs_condition *condition,
+				      const bool is_delete)
+{
+	const u8 perm = 1 << type;
+	struct ccs_acl_info *ptr;
+	struct ccs_path_number_acl e = {
+		.head.type = CCS_TYPE_PATH_NUMBER_ACL,
+		.head.cond = condition,
+		.perm = perm
+	};
+	struct ccs_path_number_acl *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!domain)
+		return -EINVAL;
+	if (!ccs_parse_name_union(filename, &e.name))
+		return -EINVAL;
+	if (!ccs_parse_number_union(number, &e.number))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_path_number_acl *acl =
+			container_of(ptr, struct ccs_path_number_acl, head);
+		if (ptr->type != CCS_TYPE_PATH_NUMBER_ACL ||
+		    ptr->cond != condition ||
+		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~perm;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= perm;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	ccs_put_name_union(&e.name);
+	ccs_put_number_union(&e.number);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_file_acl - Update file's read/write/execute ACL.
+ *
+ * @perm:      Permission (between 1 to 7).
+ * @filename:  Filename.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * This is legacy support interface for older policy syntax.
+ * Current policy syntax uses "allow_read/write" instead of "6",
+ * "allow_read" instead of "4", "allow_write" instead of "2",
+ * "allow_execute" instead of "1".
+ */
+static int ccs_update_file_acl(u8 perm, const char *filename,
+			       struct ccs_domain_info * const domain,
+			       struct ccs_condition *condition,
+			       const bool is_delete)
+{
+	if (perm > 7 || !perm)
+		return -EINVAL;
+	if (filename[0] != '@' && ccs_strendswith(filename, "/"))
+		/*
+		 * Only 'allow_mkdir' and 'allow_rmdir' are valid for
+		 * directory permissions.
+		 */
+		return 0;
+	if (perm & 4)
+		ccs_update_path_acl(CCS_TYPE_READ, filename, domain,
+				    condition, is_delete);
+	if (perm & 2)
+		ccs_update_path_acl(CCS_TYPE_WRITE, filename,
+				    domain, condition, is_delete);
+	if (perm & 1)
+		ccs_update_path_acl(CCS_TYPE_EXECUTE, filename,
+				    domain, condition, is_delete);
+	return 0;
+}
+
+/**
+ * ccs_write_file_policy - Update file related list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_file_policy(char *data, struct ccs_domain_info *domain,
+				 struct ccs_condition *condition,
+				 const bool is_delete)
+{
+	char *w[5];
+	u8 type;
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
+		return -EINVAL;
+	if (strncmp(w[0], "allow_", 6)) {
+		unsigned int perm;
+		if (sscanf(w[0], "%u", &perm) == 1)
+			return ccs_update_file_acl((u8) perm, w[1], domain,
+						   condition, is_delete);
+		if (!strcmp(w[0], CCS_KEYWORD_EXECUTE_HANDLER))
+			type = CCS_TYPE_EXECUTE_HANDLER;
+		else if (!strcmp(w[0], CCS_KEYWORD_DENIED_EXECUTE_HANDLER))
+			type = CCS_TYPE_DENIED_EXECUTE_HANDLER;
+		else
+			goto out;
+		return ccs_update_execute_handler(type, w[1], domain,
+						  is_delete);
+	}
+	w[0] += 6;
+	for (type = 0; type < CCS_MAX_PATH_OPERATION; type++) {
+		if (strcmp(w[0], ccs_path_keyword[type]))
+			continue;
+		return ccs_update_path_acl(type, w[1], domain, condition,
+					   is_delete);
+	}
+	if (!w[2][0])
+		goto out;
+	for (type = 0; type < CCS_MAX_PATH2_OPERATION; type++) {
+		if (strcmp(w[0], ccs_path2_keyword[type]))
+			continue;
+		return ccs_update_path2_acl(type, w[1], w[2], domain,
+					    condition, is_delete);
+	}
+	for (type = 0; type < CCS_MAX_PATH_NUMBER_OPERATION; type++) {
+		if (strcmp(w[0], ccs_path_number_keyword[type]))
+			continue;
+		return ccs_update_path_number_acl(type, w[1], w[2], domain,
+						  condition, is_delete);
+	}
+	if (!w[3][0] || !w[4][0])
+		goto out;
+	for (type = 0; type < CCS_MAX_PATH_NUMBER3_OPERATION; type++) {
+		if (strcmp(w[0], ccs_path_number3_keyword[type]))
+			continue;
+		return ccs_update_path_number3_acl(type, w[1], w[2], w[3],
+						   w[4], domain, condition,
+						   is_delete);
+	}
+ out:
+	return -EINVAL;
+}
+
 static int ccs_write_domain_policy2(char *data, struct ccs_domain_info *domain,
 				    struct ccs_condition *cond,
 				    const bool is_delete)
@@ -908,7 +1837,475 @@
 	return ccs_write_file_policy(data, domain, cond, is_delete);
 }
 
+static bool ccs_parse_name_union_quoted(char *filename,
+					struct ccs_name_union *ptr)
+{
+	bool result;
+	char *cp = NULL;
+	if (*filename == '"') {
+		cp = filename + strlen(filename) - 1;
+		if (*cp != '"')
+			return false;
+		*cp = '\0';
+		filename++;
+	}
+	result = ccs_parse_name_union(filename, ptr);
+	if (cp)
+		*cp = '"';
+	return result;
+}
+
 /**
+ * ccs_get_dqword - ccs_get_name() for a quoted string.
+ *
+ * @start: String to save.
+ *
+ * Returns pointer to "struct ccs_path_info" on success, NULL otherwise.
+ */
+static const struct ccs_path_info *ccs_get_dqword(char *start)
+{
+	char *cp;
+	if (*start++ != '"')
+		return NULL;
+	cp = start;
+	while (1) {
+		const char c = *cp++;
+		if (!c)
+			return NULL;
+		if (c != '"' || *cp)
+			continue;
+		*(cp - 1) = '\0';
+		break;
+	}
+	if (!ccs_is_correct_path(start, 0, 0, 0))
+		return NULL;
+	return ccs_get_name(start);
+}
+
+/**
+ * ccs_parse_argv - Parse an argv[] condition part.
+ *
+ * @start: String to parse.
+ * @argv:  Pointer to "struct ccs_argv_entry".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_parse_argv(char *start, struct ccs_argv_entry *argv)
+{
+	unsigned long index;
+	const struct ccs_path_info *value;
+	bool is_not;
+	char c;
+	if (ccs_parse_ulong(&index, &start) != CCS_VALUE_TYPE_DECIMAL)
+		goto out;
+	if (*start++ != ']')
+		goto out;
+	c = *start++;
+	if (c == '=')
+		is_not = false;
+	else if (c == '!' && *start++ == '=')
+		is_not = true;
+	else
+		goto out;
+	value = ccs_get_dqword(start);
+	if (!value)
+		goto out;
+	argv->index = index;
+	argv->is_not = is_not;
+	argv->value = value;
+	return true;
+ out:
+	return false;
+}
+
+/**
+ * ccs_parse_envp - Parse an envp[] condition part.
+ *
+ * @start: String to parse.
+ * @envp:  Pointer to "struct ccs_envp_entry".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_parse_envp(char *start, struct ccs_envp_entry *envp)
+{
+	const struct ccs_path_info *name;
+	const struct ccs_path_info *value;
+	bool is_not;
+	char *cp = start;
+	/*
+	 * Since environment variable names don't
+	 * contain '=', I can treat '"]=' and '"]!='
+	 * sequences as delimiters.
+	 */
+	while (1) {
+		if (!strncmp(start, "\"]=", 3)) {
+			is_not = false;
+			*start = '\0';
+			start += 3;
+			break;
+		} else if (!strncmp(start, "\"]!=", 4)) {
+			is_not = true;
+			*start = '\0';
+			start += 4;
+			break;
+		} else if (!*start++) {
+			goto out;
+		}
+	}
+	if (!*cp || !ccs_is_correct_path(cp, 0, 0, 0))
+		goto out;
+	name = ccs_get_name(cp);
+	if (!name)
+		goto out;
+	if (!strcmp(start, "NULL")) {
+		value = NULL;
+	} else {
+		value = ccs_get_dqword(start);
+		if (!value)
+			goto out;
+	}
+	envp->name = name;
+	envp->is_not = is_not;
+	envp->value = value;
+	return true;
+ out:
+	return false;
+}
+
+/**
+ * ccs_parse_post_condition - Parse post-condition part.
+ *
+ * @condition:  String to parse.
+ * @post_state: Buffer to store post-condition part.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_parse_post_condition(char * const condition, u8 post_state[4])
+{
+	char *start = strstr(condition, "; set ");
+	if (!start)
+		return true;
+	*start = '\0';
+	start += 6;
+	while (1) {
+		int i;
+		unsigned long value;
+		while (*start == ' ')
+			start++;
+		if (!*start)
+			break;
+		if (!strncmp(start, "task.state[0]=", 14))
+			i = 0;
+		else if (!strncmp(start, "task.state[1]=", 14))
+			i = 1;
+		else if (!strncmp(start, "task.state[2]=", 14))
+			i = 2;
+		else
+			goto out;
+		start += 14;
+		if (post_state[3] & (1 << i))
+			goto out;
+		post_state[3] |= 1 << i;
+		if (!ccs_parse_ulong(&value, &start) || value > 255)
+			goto out;
+		post_state[i] = (u8) value;
+	}
+	return true;
+ out:
+	return false;
+}
+
+/**
+ * ccs_get_condition - Parse condition part.
+ *
+ * @condition: Pointer to string to parse.
+ *
+ * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
+ */
+static struct ccs_condition *ccs_get_condition(char * const condition)
+{
+	static const bool debug;
+	char *start = condition;
+	struct ccs_condition *entry = NULL;
+	struct ccs_condition *ptr;
+	struct ccs_condition_element *condp;
+	struct ccs_number_union *numbers_p;
+	struct ccs_name_union *names_p;
+	struct ccs_argv_entry *argv;
+	struct ccs_envp_entry *envp;
+	u32 size;
+	u8 i;
+	bool found = false;
+	u16 condc = 0;
+	u16 numbers_count = 0;
+	u16 names_count = 0;
+	u16 argc = 0;
+	u16 envc = 0;
+	u8 post_state[4] = { 0, 0, 0, 0 };
+	char *end_of_string;
+	if (!ccs_parse_post_condition(start, post_state))
+		goto out;
+	start = condition;
+	if (!strncmp(start, "if ", 3))
+		start += 3;
+	else if (*start)
+		return NULL;
+	end_of_string = start + strlen(start);
+	while (1) {
+		u8 left;
+		u8 right;
+		char *word = start;
+		char *cp;
+		char *eq;
+		bool is_not = false;
+		if (!*word)
+			break;
+		cp = strchr(start, ' ');
+		if (cp) {
+			*cp = '\0';
+			start = cp + 1;
+		} else {
+			start = "";
+		}
+		if (debug)
+			printk(KERN_WARNING "%u: <%s>\n", __LINE__, word);
+		if (!strncmp(word, "exec.argv[", 10)) {
+			argc++;
+			condc++;
+			continue;
+		} else if (!strncmp(word, "exec.envp[\"", 11)) {
+			envc++;
+			condc++;
+			continue;
+		}
+		eq = strchr(word, '=');
+		if (!eq)
+			goto out;
+		if (eq > word && *(eq - 1) == '!') {
+			is_not = true;
+			eq--;
+		}
+		*eq = '\0';
+		for (left = 0; left < CCS_MAX_CONDITION_KEYWORD; left++) {
+			if (strcmp(word, ccs_condition_keyword[left]))
+				continue;
+			break;
+		}
+		if (debug)
+			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
+			       word, left);
+		if (left == CCS_MAX_CONDITION_KEYWORD)
+			numbers_count++;
+		*eq = is_not ? '!' : '=';
+		word = eq + 1;
+		if (is_not)
+			word++;
+		condc++;
+		if (debug)
+			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
+			       word, left);
+		if (left == CCS_EXEC_REALPATH || left == CCS_SYMLINK_TARGET) {
+			names_count++;
+			continue;
+		}
+		for (right = 0; right < CCS_MAX_CONDITION_KEYWORD; right++) {
+			if (strcmp(word, ccs_condition_keyword[right]))
+				continue;
+			break;
+		}
+		if (debug)
+			printk(KERN_WARNING "%u: <%s> right=%u\n", __LINE__,
+			       word, right);
+		if (right == CCS_MAX_CONDITION_KEYWORD)
+			numbers_count++;
+	}
+	if (debug)
+		printk(KERN_DEBUG "%u: cond=%u numbers=%u names=%u ac=%u "
+		       "ec=%u\n", __LINE__, condc, numbers_count, names_count,
+		       argc, envc);
+	size = sizeof(*entry)
+		+ condc * sizeof(struct ccs_condition_element)
+		+ numbers_count * sizeof(struct ccs_number_union)
+		+ names_count * sizeof(struct ccs_name_union)
+		+ argc * sizeof(struct ccs_argv_entry)
+		+ envc * sizeof(struct ccs_envp_entry);
+	entry = kzalloc(size, GFP_KERNEL);
+	if (!entry)
+		return NULL;
+	INIT_LIST_HEAD(&entry->list);
+	for (i = 0; i < 4; i++)
+		entry->post_state[i] = post_state[i];
+	entry->condc = condc;
+	entry->numbers_count = numbers_count;
+	entry->names_count = names_count;
+	entry->argc = argc;
+	entry->envc = envc;
+	condp = (struct ccs_condition_element *) (entry + 1);
+	numbers_p = (struct ccs_number_union *) (condp + condc);
+	names_p = (struct ccs_name_union *) (numbers_p + numbers_count);
+	argv = (struct ccs_argv_entry *) (names_p + names_count);
+	envp = (struct ccs_envp_entry *) (argv + argc);
+	for (start = condition; start < end_of_string; start++)
+		if (!*start)
+			*start = ' ';
+	start = condition;
+	if (!strncmp(start, "if ", 3))
+		start += 3;
+	else if (*start)
+		goto out;
+	while (1) {
+		u8 left;
+		u8 right;
+		char *word = start;
+		char *cp;
+		char *eq;
+		bool is_not = false;
+		if (!*word)
+			break;
+		cp = strchr(start, ' ');
+		if (cp) {
+			*cp = '\0';
+			start = cp + 1;
+		} else {
+			start = "";
+		}
+		if (debug)
+			printk(KERN_WARNING "%u: <%s>\n", __LINE__, word);
+		if (!strncmp(word, "exec.argv[", 10)) {
+			if (!ccs_parse_argv(word + 10, argv))
+				goto out;
+			argv++;
+			argc--;
+			condc--;
+			left = CCS_ARGV_ENTRY;
+			right = -1;
+			goto store_value;
+		} else if (!strncmp(word, "exec.envp[\"", 11)) {
+			if (!ccs_parse_envp(word + 11, envp))
+				goto out;
+			envp++;
+			envc--;
+			condc--;
+			left = CCS_ENVP_ENTRY;
+			right = -1;
+			goto store_value;
+		}
+		eq = strchr(word, '=');
+		if (!eq) {
+			if (debug)
+				printk(KERN_WARNING "%u: No operator.\n",
+				       __LINE__);
+			goto out;
+		}
+		if (eq > word && *(eq - 1) == '!') {
+			is_not = true;
+			eq--;
+		}
+		*eq = '\0';
+		for (left = 0; left < CCS_MAX_CONDITION_KEYWORD; left++) {
+			if (strcmp(word, ccs_condition_keyword[left]))
+				continue;
+			break;
+		}
+		if (debug)
+			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
+			       word, left);
+		if (left == CCS_MAX_CONDITION_KEYWORD) {
+			left = CCS_NUMBER_UNION;
+			if (!ccs_parse_number_union(word, numbers_p))
+				goto out;
+			if (numbers_p->is_group)
+				goto out;
+			numbers_p++;
+			numbers_count--;
+		}
+		*eq = is_not ? '!' : '=';
+		word = eq + 1;
+		if (is_not)
+			word++;
+		condc--;
+		if (debug)
+			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
+			       word, left);
+		if (left == CCS_EXEC_REALPATH || left == CCS_SYMLINK_TARGET) {
+			right = CCS_NAME_UNION;
+			if (!ccs_parse_name_union_quoted(word, names_p++))
+				goto out;
+			names_count--;
+			goto store_value;
+		}
+		for (right = 0; right < CCS_MAX_CONDITION_KEYWORD; right++) {
+			if (strcmp(word, ccs_condition_keyword[right]))
+				continue;
+			break;
+		}
+		if (right == CCS_MAX_CONDITION_KEYWORD) {
+			right = CCS_NUMBER_UNION;
+			if (!ccs_parse_number_union(word, numbers_p++))
+				goto out;
+			numbers_count--;
+		}
+ store_value:
+		condp->left = left;
+		condp->right = right;
+		condp->equals = !is_not;
+		if (debug)
+			printk(KERN_WARNING "%u: left=%u right=%u match=%u\n",
+			       __LINE__, condp->left, condp->right,
+			       condp->equals);
+		condp++;
+	}
+	if (debug) {
+		for (start = condition; start < end_of_string; start++)
+			if (!*start)
+				*start = ' ';
+		printk(KERN_DEBUG "%u: <%s> cond=%u numbers=%u names=%u ac=%u "
+		       "ec=%u\n", __LINE__, condition, condc, numbers_count,
+		       names_count, argc, envc);
+	}
+	BUG_ON(names_count);
+	BUG_ON(numbers_count);
+	BUG_ON(argc);
+	BUG_ON(envc);
+	BUG_ON(condc);
+	entry->size = size;
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &ccsecurity.condition, list) {
+		if (ccs_memcmp(ptr, entry, offsetof(typeof(*entry), size),
+			       size))
+			continue;
+		/* Same entry found. Share this entry. */
+		atomic_inc(&ptr->users);
+		found = true;
+		break;
+	}
+	if (!found) {
+		if (ccs_memory_ok(entry, size)) {
+			atomic_set(&entry->users, 1);
+			list_add_rcu(&entry->list, &ccsecurity.condition);
+		} else {
+			found = true;
+			ptr = NULL;
+		}
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	if (found) {
+		ccs_del_condition(entry);
+		kfree(entry);
+		entry = ptr;
+	}
+	return entry;
+ out:
+	if (debug)
+		printk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);
+	if (entry) {
+		ccs_del_condition(entry);
+		kfree(entry);
+	}
+	return NULL;
+}
+
+/**
  * ccs_write_domain_policy - Write domain policy.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -1079,7 +2476,7 @@
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_print_number_union(struct ccs_io_buffer *head,
+static bool ccs_print_number_union(struct ccs_io_buffer *head,
 			    const struct ccs_number_union *ptr)
 {
 	return ccs_print_number_union_common(head, ptr, true);
@@ -1657,7 +3054,7 @@
 		return;
 	if (head->read_step == 0)
 		head->read_step = 1;
-	list_for_each_cookie(dpos, head->read_var1, &ccs_domain_list) {
+	list_for_each_cookie(dpos, head->read_var1, &ccsecurity.domain) {
 		struct ccs_domain_info *domain;
 		const char *quota_exceeded = "";
 		const char *transition_failed = "";
@@ -1760,7 +3157,7 @@
 	struct list_head *pos;
 	if (head->read_eof)
 		return;
-	list_for_each_cookie(pos, head->read_var1, &ccs_domain_list) {
+	list_for_each_cookie(pos, head->read_var1, &ccsecurity.domain) {
 		struct ccs_domain_info *domain;
 		domain = list_entry(pos, struct ccs_domain_info, list);
 		if (domain->is_deleted)
@@ -1849,7 +3246,633 @@
 			      (u8) (ccs_flags >> 8));
 }
 
+
 /**
+ * ccs_update_domain_initializer_entry - Update "struct ccs_domain_initializer_entry" list.
+ *
+ * @domainname: The name of domain. May be NULL.
+ * @program:    The name of program.
+ * @is_not:     True if it is "no_initialize_domain" entry.
+ * @is_delete:  True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_domain_initializer_entry(const char *domainname,
+					       const char *program,
+					       const bool is_not,
+					       const bool is_delete)
+{
+	struct ccs_domain_initializer_entry *entry = NULL;
+	struct ccs_domain_initializer_entry *ptr;
+	struct ccs_domain_initializer_entry e = { .is_not = is_not };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(program, 1, -1, -1))
+		return -EINVAL; /* No patterns allowed. */
+	if (domainname) {
+		if (!ccs_is_domain_def(domainname) &&
+		    ccs_is_correct_path(domainname, 1, -1, -1))
+			e.is_last_name = true;
+		else if (!ccs_is_correct_domain(domainname))
+			return -EINVAL;
+		e.domainname = ccs_get_name(domainname);
+		if (!e.domainname)
+			goto out;
+	}
+	e.program = ccs_get_name(program);
+	if (!e.program)
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &ccsecurity.domain_initializer, list) {
+		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), is_not),
+			       sizeof(e)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccsecurity.domain_initializer);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	ccs_put_name(e.domainname);
+	ccs_put_name(e.program);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_domain_keeper_entry - Update "struct ccs_domain_keeper_entry" list.
+ *
+ * @domainname: The name of domain.
+ * @program:    The name of program. May be NULL.
+ * @is_not:     True if it is "no_keep_domain" entry.
+ * @is_delete:  True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_domain_keeper_entry(const char *domainname,
+					  const char *program,
+					  const bool is_not,
+					  const bool is_delete)
+{
+	struct ccs_domain_keeper_entry *entry = NULL;
+	struct ccs_domain_keeper_entry *ptr;
+	struct ccs_domain_keeper_entry e = { .is_not = is_not };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_domain_def(domainname) &&
+	    ccs_is_correct_path(domainname, 1, -1, -1))
+		e.is_last_name = true;
+	else if (!ccs_is_correct_domain(domainname))
+		return -EINVAL;
+	if (program) {
+		if (!ccs_is_correct_path(program, 1, -1, -1))
+			return -EINVAL;
+		e.program = ccs_get_name(program);
+		if (!e.program)
+			goto out;
+	}
+	e.domainname = ccs_get_name(domainname);
+	if (!e.domainname)
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &ccsecurity.domain_keeper, list) {
+		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), is_not),
+			       sizeof(e)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccsecurity.domain_keeper);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	ccs_put_name(e.domainname);
+	ccs_put_name(e.program);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_domain_keeper_policy - Write "struct ccs_domain_keeper_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_not:    True if it is "no_keep_domain" entry.
+ * @is_delete: True if it is a delete request.
+ *
+ */
+static int ccs_write_domain_keeper_policy(char *data, const bool is_not,
+					  const bool is_delete)
+{
+	char *cp = strstr(data, " from ");
+	if (cp) {
+		*cp = '\0';
+		return ccs_update_domain_keeper_entry(cp + 6, data,
+						      is_not, is_delete);
+	}
+	return ccs_update_domain_keeper_entry(data, NULL, is_not, is_delete);
+}
+
+/**
+ * ccs_write_domain_initializer_policy - Write "struct ccs_domain_initializer_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_not:    True if it is "no_initialize_domain" entry.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_domain_initializer_policy(char *data, const bool is_not,
+					       const bool is_delete)
+{
+	char *cp = strstr(data, " from ");
+	if (cp) {
+		*cp = '\0';
+		return ccs_update_domain_initializer_entry(cp + 6, data,
+							   is_not, is_delete);
+	}
+	return ccs_update_domain_initializer_entry(NULL, data, is_not,
+						   is_delete);
+}
+
+/**
+ * ccs_update_aggregator_entry - Update "struct ccs_aggregator_entry" list.
+ *
+ * @original_name:   The original program's name.
+ * @aggregated_name: The aggregated program's name.
+ * @is_delete:       True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_aggregator_entry(const char *original_name,
+				       const char *aggregated_name,
+				       const bool is_delete)
+{
+	struct ccs_aggregator_entry *entry = NULL;
+	struct ccs_aggregator_entry *ptr;
+	struct ccs_aggregator_entry e = { };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(original_name, 1, 0, -1) ||
+	    !ccs_is_correct_path(aggregated_name, 1, -1, -1))
+		return -EINVAL;
+	e.original_name = ccs_get_name(original_name);
+	e.aggregated_name = ccs_get_name(aggregated_name);
+	if (!e.original_name || !e.aggregated_name)
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &ccsecurity.aggregator, list) {
+		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), original_name),
+			       sizeof(e)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccsecurity.aggregator);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	ccs_put_name(e.original_name);
+	ccs_put_name(e.aggregated_name);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_aggregator_policy - Write "struct ccs_aggregator_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_aggregator_policy(char *data, const bool is_delete)
+{
+	char *w[2];
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
+		return -EINVAL;
+	return ccs_update_aggregator_entry(w[0], w[1], is_delete);
+}
+
+/**
+ * ccs_write_globally_readable_policy - Write "struct ccs_globally_readable_file_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_globally_readable_policy(char *data, const bool is_delete)
+{
+	struct ccs_globally_readable_file_entry *entry = NULL;
+	struct ccs_globally_readable_file_entry *ptr;
+	struct ccs_globally_readable_file_entry e = { };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(data, 1, 0, -1))
+		return -EINVAL;
+	e.filename = ccs_get_name(data);
+	if (!e.filename)
+		return -ENOMEM;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &ccsecurity.global_read, list) {
+		if (ptr->filename != e.filename)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccsecurity.global_read);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_name(e.filename);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_globally_usable_env_policy - Write "struct ccs_globally_usable_env_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_globally_usable_env_policy(char *data,
+						const bool is_delete)
+{
+	struct ccs_globally_usable_env_entry *entry = NULL;
+	struct ccs_globally_usable_env_entry e = { };
+	struct ccs_globally_usable_env_entry *ptr;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(data, 0, 0, 0) || strchr(data, '='))
+		return -EINVAL;
+	e.env = ccs_get_name(data);
+	if (!e.env)
+		return error;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &ccsecurity.global_env, list) {
+		if (ptr->env != e.env)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccsecurity.global_env);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_name(e.env);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_pattern_policy - Write "struct ccs_pattern_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_pattern_policy(char *data, const bool is_delete)
+{
+	struct ccs_pattern_entry *entry = NULL;
+	struct ccs_pattern_entry *ptr;
+	struct ccs_pattern_entry e = { .pattern = ccs_get_name(data) };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!e.pattern)
+		return error;
+	if (!e.pattern->is_patterned)
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &ccsecurity.pattern, list) {
+		if (e.pattern != ptr->pattern)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccsecurity.pattern);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	ccs_put_name(e.pattern);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_path_group_policy - Write "struct ccs_path_group" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, nagative value otherwise.
+ */
+static int ccs_write_path_group_policy(char *data, const bool is_delete)
+{
+	struct ccs_path_group *group;
+	struct ccs_path_group_member *entry = NULL;
+	struct ccs_path_group_member *member;
+	struct ccs_path_group_member e = { };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	char *w[2];
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
+		return -EINVAL;
+	group = ccs_get_path_group(w[0]);
+	if (!group)
+		return -ENOMEM;
+	e.member_name = ccs_get_name(w[1]);
+	if (!e.member_name)
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(member, &group->member_list, list) {
+		if (member->member_name != e.member_name)
+			continue;
+		member->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &group->member_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	ccs_put_name(e.member_name);
+	ccs_put_path_group(group);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_number_group_policy - Write "struct ccs_number_group" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, nagative value otherwise.
+ */
+static int ccs_write_number_group_policy(char *data, const bool is_delete)
+{
+	struct ccs_number_group *group;
+	struct ccs_number_group_member *entry = NULL;
+	struct ccs_number_group_member e = { };
+	struct ccs_number_group_member *member;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	char *w[2];
+	if (!ccs_tokenize(data, w, sizeof(w)))
+		return -EINVAL;
+	if (!ccs_parse_number_union(w[1], &e.number))
+		return -EINVAL;
+	if (e.number.is_group || e.number.values[0] > e.number.values[1]) {
+		ccs_put_number_union(&e.number);
+		return -EINVAL;
+	}
+	group = ccs_get_number_group(w[0]);
+	if (!group)
+		return -ENOMEM;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(member, &group->member_list, list) {
+		if (memcmp(&member->number, &e.number, sizeof(e.number)))
+			continue;
+		member->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &group->member_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_number_group(group);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_no_rewrite_policy - Write "struct ccs_no_rewrite_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_no_rewrite_policy(char *data, const bool is_delete)
+{
+	struct ccs_no_rewrite_entry *entry = NULL;
+	struct ccs_no_rewrite_entry *ptr;
+	struct ccs_no_rewrite_entry e = { };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(data, 0, 0, 0))
+		return -EINVAL;
+	e.pattern = ccs_get_name(data);
+	if (!e.pattern)
+		return error;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &ccsecurity.no_rewrite, list) {
+		if (ptr->pattern != e.pattern)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccsecurity.no_rewrite);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+	ccs_put_name(e.pattern);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_address_group_policy - Write "struct ccs_address_group" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_address_group_policy(char *data, const bool is_delete)
+{
+	struct ccs_address_group *group;
+	struct ccs_address_group_member *entry = NULL;
+	struct ccs_address_group_member *member;
+	struct ccs_address_group_member e = { };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	u16 min_address[8];
+	u16 max_address[8];
+	char *w[2];
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
+		return -EINVAL;
+	group = ccs_get_address_group(w[0]);
+	if (!group)
+		return -ENOMEM;
+	switch (ccs_parse_ip_address(w[1], min_address, max_address)) {
+	case 2:
+		e.is_ipv6 = true;
+		e.min.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
+						  min_address);
+		e.max.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
+						  max_address);
+		if (!e.min.ipv6 || !e.max.ipv6)
+			goto out;
+		break;
+	case 1:
+		e.min.ipv4 = ntohl(*(u32 *) min_address);
+		e.max.ipv4 = ntohl(*(u32 *) max_address);
+		break;
+	default:
+		goto out;
+	}
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(member, &group->member_list, list) {
+		if (ccs_memcmp(member, &e, offsetof(typeof(e), is_ipv6),
+			       sizeof(e)))
+			continue;
+		member->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &group->member_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccsecurity.policy_lock);
+ out:
+	if (e.is_ipv6) {
+		ccs_put_ipv6_address(e.min.ipv6);
+		ccs_put_ipv6_address(e.max.ipv6);
+	}
+	ccs_put_address_group(group);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_reserved_entry - Update "struct ccs_reserved_entry" list.
+ *
+ * @min_port: Start of port number range.
+ * @max_port: End of port number range.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_reserved_entry(const u16 min_port, const u16 max_port,
+				     const bool is_delete)
+{
+	struct ccs_reserved_entry *ptr;
+	struct ccs_reserved_entry e = {
+		.min_port = min_port,
+		.max_port = max_port
+	};
+	int error = -ENOMEM;
+	u8 *ccs_tmp_map = kzalloc(8192, GFP_KERNEL);
+	struct ccs_reserved_entry *entry = kmalloc(sizeof(e), GFP_KERNEL);
+	if (!ccs_tmp_map || !entry) {
+		kfree(entry);
+		kfree(ccs_tmp_map);
+		return -ENOMEM;
+	}
+	if (is_delete)
+		error = -ENOENT;
+	mutex_lock(&ccsecurity.policy_lock);
+	list_for_each_entry_rcu(ptr, &ccsecurity.reservedport, list) {
+		if (ptr->min_port != min_port || ptr->max_port != max_port)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccsecurity.reservedport);
+		entry = NULL;
+		error = 0;
+	}
+	list_for_each_entry_rcu(ptr, &ccsecurity.reservedport, list) {
+		unsigned int port;
+		if (ptr->is_deleted)
+			continue;
+		for (port = ptr->min_port; port <= ptr->max_port; port++)
+			ccs_tmp_map[port >> 8] |= 1 << (port & 7);
+	}
+	memmove(ccs_reserved_port_map, ccs_tmp_map,
+		sizeof(ccs_reserved_port_map));
+	mutex_unlock(&ccsecurity.policy_lock);
+	kfree(entry);
+	kfree(ccs_tmp_map);
+	return error;
+}
+
+/**
+ * ccs_write_reserved_port_policy - Write "struct ccs_reserved_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_reserved_port_policy(char *data, const bool is_delete)
+{
+	unsigned int from;
+	unsigned int to;
+	if (strchr(data, ' '))
+		goto out;
+	if (sscanf(data, "%u-%u", &from, &to) == 2) {
+		if (from <= to && to < 65536)
+			return ccs_update_reserved_entry(from, to, is_delete);
+	} else if (sscanf(data, "%u", &from) == 1) {
+		if (from < 65536)
+			return ccs_update_reserved_entry(from, from, is_delete);
+	}
+ out:
+	return -EINVAL;
+}
+
+/**
  * ccs_write_exception_policy - Write exception policy.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -1892,6 +3915,381 @@
 }
 
 /**
+ * ccs_read_domain_keeper_policy - Read "struct ccs_domain_keeper_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2,
+			     &ccsecurity.domain_keeper) {
+		struct ccs_domain_keeper_entry *ptr;
+		const char *no;
+		const char *from = "";
+		const char *program = "";
+		ptr = list_entry(pos, struct ccs_domain_keeper_entry, list);
+		if (ptr->is_deleted)
+			continue;
+		no = ptr->is_not ? "no_" : "";
+		if (ptr->program) {
+			from = " from ";
+			program = ptr->program->name;
+		}
+		done = ccs_io_printf(head, "%s" CCS_KEYWORD_KEEP_DOMAIN
+				     "%s%s%s\n", no, program, from,
+				     ptr->domainname->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_globally_readable_policy - Read "struct ccs_globally_readable_file_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2,
+			     &ccsecurity.global_read) {
+		struct ccs_globally_readable_file_entry *ptr;
+		ptr = list_entry(pos, struct ccs_globally_readable_file_entry,
+				 list);
+		if (ptr->is_deleted)
+			continue;
+		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_READ "%s\n",
+				     ptr->filename->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_globally_usable_env_policy - Read "struct ccs_globally_usable_env_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2,
+			     &ccsecurity.global_env) {
+		struct ccs_globally_usable_env_entry *ptr;
+		ptr = list_entry(pos, struct ccs_globally_usable_env_entry,
+				 list);
+		if (ptr->is_deleted)
+			continue;
+		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_ENV "%s\n",
+				     ptr->env->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_domain_initializer_policy - Read "struct ccs_domain_initializer_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2,
+			     &ccsecurity.domain_initializer) {
+		const char *no;
+		const char *from = "";
+		const char *domain = "";
+		struct ccs_domain_initializer_entry *ptr;
+		ptr = list_entry(pos, struct ccs_domain_initializer_entry,
+				 list);
+		if (ptr->is_deleted)
+			continue;
+		no = ptr->is_not ? "no_" : "";
+		if (ptr->domainname) {
+			from = " from ";
+			domain = ptr->domainname->name;
+		}
+		done = ccs_io_printf(head, "%s" CCS_KEYWORD_INITIALIZE_DOMAIN
+				     "%s%s%s\n", no, ptr->program->name, from,
+				     domain);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_aggregator_policy - Read "struct ccs_aggregator_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_aggregator_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2, &ccsecurity.aggregator) {
+		struct ccs_aggregator_entry *ptr;
+		ptr = list_entry(pos, struct ccs_aggregator_entry, list);
+		if (ptr->is_deleted)
+			continue;
+		done = ccs_io_printf(head, CCS_KEYWORD_AGGREGATOR "%s %s\n",
+				     ptr->original_name->name,
+				     ptr->aggregated_name->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_file_pattern - Read "struct ccs_pattern_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_file_pattern(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2, &ccsecurity.pattern) {
+		struct ccs_pattern_entry *ptr;
+		ptr = list_entry(pos, struct ccs_pattern_entry, list);
+		if (ptr->is_deleted)
+			continue;
+		done = ccs_io_printf(head, CCS_KEYWORD_FILE_PATTERN "%s\n",
+				     ptr->pattern->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_no_rewrite_policy - Read "struct ccs_no_rewrite_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2, &ccsecurity.no_rewrite) {
+		struct ccs_no_rewrite_entry *ptr;
+		ptr = list_entry(pos, struct ccs_no_rewrite_entry, list);
+		if (ptr->is_deleted)
+			continue;
+		done = ccs_io_printf(head, CCS_KEYWORD_DENY_REWRITE "%s\n",
+				     ptr->pattern->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_path_group_policy - Read "struct ccs_path_group" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_path_group_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *gpos;
+	struct list_head *mpos;
+	list_for_each_cookie(gpos, head->read_var1, &ccsecurity.path_group) {
+		struct ccs_path_group *group;
+		group = list_entry(gpos, struct ccs_path_group, list);
+		list_for_each_cookie(mpos, head->read_var2,
+				     &group->member_list) {
+			struct ccs_path_group_member *member;
+			member = list_entry(mpos, struct ccs_path_group_member,
+					    list);
+			if (member->is_deleted)
+				continue;
+			if (!ccs_io_printf(head, CCS_KEYWORD_PATH_GROUP
+					   "%s %s\n",
+					   group->group_name->name,
+					   member->member_name->name))
+				return false;
+		}
+	}
+	return true;
+}
+
+/**
+ * ccs_read_number_group_policy - Read "struct ccs_number_group" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_number_group_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *gpos;
+	struct list_head *mpos;
+	list_for_each_cookie(gpos, head->read_var1, &ccsecurity.number_group) {
+		struct ccs_number_group *group;
+		const char *name;
+		group = list_entry(gpos, struct ccs_number_group, list);
+		name = group->group_name->name;
+		list_for_each_cookie(mpos, head->read_var2,
+				     &group->member_list) {
+			int pos;
+			const struct ccs_number_group_member *member
+				= list_entry(mpos,
+					     struct ccs_number_group_member,
+					     list);
+			if (member->is_deleted)
+				continue;
+			pos = head->read_avail;
+			if (!ccs_io_printf(head, CCS_KEYWORD_NUMBER_GROUP "%s",
+					   name) ||
+			    !ccs_print_number_union(head, &member->number) ||
+			    !ccs_io_printf(head, "\n")) {
+				head->read_avail = pos;
+				return false;
+			}
+		}
+	}
+	return true;
+}
+
+/**
+ * ccs_read_address_group_policy - Read "struct ccs_address_group" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_address_group_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *gpos;
+	struct list_head *mpos;
+	list_for_each_cookie(gpos, head->read_var1, &ccsecurity.address_group) {
+		struct ccs_address_group *group;
+		group = list_entry(gpos, struct ccs_address_group, list);
+		list_for_each_cookie(mpos, head->read_var2,
+				     &group->member_list) {
+			char buf[128];
+			struct ccs_address_group_member *member;
+			member = list_entry(mpos,
+					    struct ccs_address_group_member,
+					    list);
+			if (member->is_deleted)
+				continue;
+			if (member->is_ipv6) {
+				const struct in6_addr *min_address
+					= member->min.ipv6;
+				const struct in6_addr *max_address
+					= member->max.ipv6;
+				ccs_print_ipv6(buf, sizeof(buf), min_address);
+				if (min_address != max_address) {
+					int len;
+					char *cp = buf + strlen(buf);
+					*cp++ = '-';
+					len = strlen(buf);
+					ccs_print_ipv6(cp, sizeof(buf) - len,
+						       max_address);
+				}
+			} else {
+				const u32 min_address = member->min.ipv4;
+				const u32 max_address = member->max.ipv4;
+				memset(buf, 0, sizeof(buf));
+				snprintf(buf, sizeof(buf) - 1, "%u.%u.%u.%u",
+					 HIPQUAD(min_address));
+				if (min_address != max_address) {
+					const int len = strlen(buf);
+					snprintf(buf + len,
+						 sizeof(buf) - 1 - len,
+						 "-%u.%u.%u.%u",
+						 HIPQUAD(max_address));
+				}
+			}
+			if (!ccs_io_printf(head, CCS_KEYWORD_ADDRESS_GROUP
+					   "%s %s\n", group->group_name->name,
+					   buf))
+				return false;
+		}
+	}
+	return true;
+}
+
+/**
+ * ccs_read_reserved_port_policy - Read "struct ccs_reserved_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	char buffer[16];
+	memset(buffer, 0, sizeof(buffer));
+	list_for_each_cookie(pos, head->read_var2, &ccsecurity.reservedport) {
+		u16 min_port;
+		u16 max_port;
+		struct ccs_reserved_entry *ptr;
+		ptr = list_entry(pos, struct ccs_reserved_entry, list);
+		if (ptr->is_deleted)
+			continue;
+		min_port = ptr->min_port;
+		max_port = ptr->max_port;
+		snprintf(buffer, sizeof(buffer) - 1, "%u%c%u", min_port,
+			 min_port != max_port ? '-' : '\0', max_port);
+		if (!ccs_io_printf(head, CCS_KEYWORD_DENY_AUTOBIND "%s\n",
+				   buffer))
+			return false;
+	}
+	return true;
+}
+
+/**
  * ccs_read_exception_policy - Read exception policy.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -2445,6 +4843,64 @@
 }
 
 /**
+ * ccs_read_memory_counter - Check for memory usage.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ */
+static void ccs_read_memory_counter(struct ccs_io_buffer *head)
+{
+	const unsigned int usage[3] = {
+		atomic_read(&ccs_policy_memory_size),
+		ccs_audit_log_memory_size,
+		ccs_query_memory_size
+	};
+	const unsigned int quota[3] = {
+		ccs_quota_for_policy,
+		ccs_quota_for_audit_log,
+		ccs_quota_for_query
+	};
+	static const char *header[4] = {
+		"Policy:     ",
+		"Audit logs: ",
+		"Query lists:",
+		"Total:      "
+	};
+	unsigned int total = 0;
+	int i;
+	if (head->read_eof)
+		return;
+	for (i = 0; i < 3; i++) {
+		total += usage[i];
+		ccs_io_printf(head, "%s %10u", header[i], usage[i]);
+		if (quota[i])
+			ccs_io_printf(head, "   (Quota: %10u)", quota[i]);
+		ccs_io_printf(head, "\n");
+	}
+	ccs_io_printf(head, "%s %10u\n", header[3], total);
+	head->read_eof = true;
+}
+
+/**
+ * ccs_write_memory_quota - Set memory quota.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0.
+ */
+static int ccs_write_memory_quota(struct ccs_io_buffer *head)
+{
+	char *data = head->write_buf;
+	unsigned int size;
+	if (sscanf(data, "Policy: %u", &size) == 1)
+		ccs_quota_for_policy = size;
+	else if (sscanf(data, "Audit logs: %u", &size) == 1)
+		ccs_quota_for_audit_log = size;
+	else if (sscanf(data, "Query lists: %u", &size) == 1)
+		ccs_quota_for_query = size;
+	return 0;
+}
+
+/**
  * ccs_open_control - open() for /proc/ccs/ interface.
  *
  * @type: Type of interface.
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/gc.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/gc.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/gc.c	(working copy)
@@ -47,7 +47,7 @@
 static LIST_HEAD(ccs_gc_queue);
 static DEFINE_MUTEX(ccs_gc_mutex);
 
-/* Caller holds ccs_policy_lock mutex. */
+/* Caller holds ccsecurity.policy_lock mutex. */
 static bool ccs_add_to_gc(const int type, void *element)
 {
 	struct ccs_gc_entry *entry = kzalloc(sizeof(*entry), GFP_ATOMIC);
@@ -385,59 +385,14 @@
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
 
 /* Lock for GC. */
-static struct srcu_struct ccs_ss;
 
-int ccs_read_lock(void)
-{
-	/*
-	 * Kernel might try to populate root fs before processing initcalls.
-	 * Thus, I can't use core_initcall() for initializing ccs_ss.
-	 */
-	if (!ccs_ss.per_cpu_ref) {
-		mutex_lock(&ccs_policy_lock);
-		if (!ccs_ss.per_cpu_ref && init_srcu_struct(&ccs_ss))
-			panic("Out of memory.");
-		mutex_unlock(&ccs_policy_lock);
-	}
-	return srcu_read_lock(&ccs_ss);
-}
-
-void ccs_read_unlock(const int idx)
-{
-	srcu_read_unlock(&ccs_ss, idx);
-}
-
 static inline void ccs_synchronize_srcu(void)
 {
-	synchronize_srcu(&ccs_ss);
+	//synchronize_srcu(&ccs_ss);
 }
 
 #else
 
-/* Lock for GC. */
-static struct {
-	int counter_idx;
-	int counter[2];
-} ccs_gc;
-static DEFINE_SPINLOCK(ccs_counter_lock);
-
-int ccs_read_lock(void)
-{
-	int idx;
-	spin_lock(&ccs_counter_lock);
-	idx = ccs_gc.counter_idx;
-	ccs_gc.counter[idx]++;
-	spin_unlock(&ccs_counter_lock);
-	return idx;
-}
-
-void ccs_read_unlock(const int idx)
-{
-	spin_lock(&ccs_counter_lock);
-	ccs_gc.counter[idx]--;
-	spin_unlock(&ccs_counter_lock);
-}
-
 static void ccs_synchronize_srcu(void)
 {
 	int idx;
@@ -459,10 +414,10 @@
 
 static void ccs_collect_entry(void)
 {
-	mutex_lock(&ccs_policy_lock);
+	mutex_lock(&ccsecurity.policy_lock);
 	{
 		struct ccs_globally_readable_file_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_globally_readable_list,
+		list_for_each_entry_rcu(ptr, &ccsecurity.global_read,
 					list) {
 			if (!ptr->is_deleted)
 				continue;
@@ -474,7 +429,7 @@
 	}
 	{
 		struct ccs_globally_usable_env_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_globally_usable_env_list,
+		list_for_each_entry_rcu(ptr, &ccsecurity.global_env,
 					list) {
 			if (!ptr->is_deleted)
 				continue;
@@ -486,7 +441,7 @@
 	}
 	{
 		struct ccs_pattern_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_pattern_list, list) {
+		list_for_each_entry_rcu(ptr, &ccsecurity.pattern, list) {
 			if (!ptr->is_deleted)
 				continue;
 			if (ccs_add_to_gc(CCS_ID_PATTERN, ptr))
@@ -497,7 +452,7 @@
 	}
 	{
 		struct ccs_no_rewrite_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_no_rewrite_list, list) {
+		list_for_each_entry_rcu(ptr, &ccsecurity.no_rewrite, list) {
 			if (!ptr->is_deleted)
 				continue;
 			if (ccs_add_to_gc(CCS_ID_NO_REWRITE, ptr))
@@ -508,7 +463,7 @@
 	}
 	{
 		struct ccs_domain_initializer_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_domain_initializer_list,
+		list_for_each_entry_rcu(ptr, &ccsecurity.domain_initializer,
 					list) {
 			if (!ptr->is_deleted)
 				continue;
@@ -520,7 +475,7 @@
 	}
 	{
 		struct ccs_domain_keeper_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_domain_keeper_list, list) {
+		list_for_each_entry_rcu(ptr, &ccsecurity.domain_keeper, list) {
 			if (!ptr->is_deleted)
 				continue;
 			if (ccs_add_to_gc(CCS_ID_DOMAIN_KEEPER, ptr))
@@ -531,7 +486,7 @@
 	}
 	{
 		struct ccs_policy_manager_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_policy_manager_list, list) {
+		list_for_each_entry_rcu(ptr, &ccsecurity.policy_manager, list) {
 			if (!ptr->is_deleted)
 				continue;
 			if (ccs_add_to_gc(CCS_ID_MANAGER, ptr))
@@ -542,7 +497,7 @@
 	}
 	{
 		struct ccs_aggregator_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_aggregator_list, list) {
+		list_for_each_entry_rcu(ptr, &ccsecurity.aggregator, list) {
 			if (!ptr->is_deleted)
 				continue;
 			if (ccs_add_to_gc(CCS_ID_AGGREGATOR, ptr))
@@ -553,7 +508,7 @@
 	}
 	{
 		struct ccs_domain_info *domain;
-		list_for_each_entry_rcu(domain, &ccs_domain_list, list) {
+		list_for_each_entry_rcu(domain, &ccsecurity.domain, list) {
 			struct ccs_acl_info *acl;
 			list_for_each_entry_rcu(acl, &domain->acl_info_list,
 						list) {
@@ -575,7 +530,7 @@
 	}
 	{
 		struct ccs_path_group *group;
-		list_for_each_entry_rcu(group, &ccs_path_group_list, list) {
+		list_for_each_entry_rcu(group, &ccsecurity.path_group, list) {
 			struct ccs_path_group_member *member;
 			list_for_each_entry_rcu(member, &group->member_list,
 						list) {
@@ -598,7 +553,7 @@
 	}
 	{
 		struct ccs_address_group *group;
-		list_for_each_entry_rcu(group, &ccs_address_group_list, list) {
+		list_for_each_entry_rcu(group, &ccsecurity.address_group, list) {
 			struct ccs_address_group_member *member;
 			list_for_each_entry_rcu(member, &group->member_list,
 						list) {
@@ -621,7 +576,7 @@
 	}
 	{
 		struct ccs_number_group *group;
-		list_for_each_entry_rcu(group, &ccs_number_group_list, list) {
+		list_for_each_entry_rcu(group, &ccsecurity.number_group, list) {
 			struct ccs_number_group_member *member;
 			list_for_each_entry_rcu(member, &group->member_list,
 						list) {
@@ -644,7 +599,7 @@
 	}
 	{
 		struct ccs_reserved_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
+		list_for_each_entry_rcu(ptr, &ccsecurity.reservedport, list) {
 			if (!ptr->is_deleted)
 				continue;
 			if (ccs_add_to_gc(CCS_ID_RESERVEDPORT, ptr))
@@ -655,7 +610,7 @@
 	}
 	{
 		struct ccs_ipv6addr_entry *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_address_list, list) {
+		list_for_each_entry_rcu(ptr, &ccsecurity.ipv6addr, list) {
 			if (atomic_read(&ptr->users))
 				continue;
 			if (ccs_add_to_gc(CCS_ID_IPV6_ADDRESS, ptr))
@@ -666,7 +621,7 @@
 	}
 	{
 		struct ccs_condition *ptr;
-		list_for_each_entry_rcu(ptr, &ccs_condition_list, list) {
+		list_for_each_entry_rcu(ptr, &ccsecurity.condition, list) {
 			if (atomic_read(&ptr->users))
 				continue;
 			if (ccs_add_to_gc(CCS_ID_CONDITION, ptr))
@@ -675,7 +630,7 @@
 				break;
 		}
 	}
-	mutex_unlock(&ccs_policy_lock);
+	mutex_unlock(&ccsecurity.policy_lock);
 	mutex_lock(&ccs_name_list_lock);
 	{
 		int i;
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/network.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/network.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/network.c	(working copy)
@@ -40,49 +40,6 @@
 				   "%s %s %u\n", operation, address, port);
 }
 
-/**
- * ccs_parse_ip_address - Parse an IP address.
- *
- * @address: String to parse.
- * @min:     Pointer to store min address.
- * @max:     Pointer to store max address.
- *
- * Returns 2 if @address is an IPv6, 1 if @address is an IPv4, 0 otherwise.
- */
-int ccs_parse_ip_address(char *address, u16 *min, u16 *max)
-{
-	int count = sscanf(address, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx"
-			   "-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
-			   &min[0], &min[1], &min[2], &min[3],
-			   &min[4], &min[5], &min[6], &min[7],
-			   &max[0], &max[1], &max[2], &max[3],
-			   &max[4], &max[5], &max[6], &max[7]);
-	if (count == 8 || count == 16) {
-		u8 i;
-		if (count == 8)
-			memmove(max, min, sizeof(u16) * 8);
-		for (i = 0; i < 8; i++) {
-			min[i] = htons(min[i]);
-			max[i] = htons(max[i]);
-		}
-		return 2;
-	}
-	count = sscanf(address, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
-		       &min[0], &min[1], &min[2], &min[3],
-		       &max[0], &max[1], &max[2], &max[3]);
-	if (count == 4 || count == 8) {
-		u32 ip = htonl((((u8) min[0]) << 24) + (((u8) min[1]) << 16)
-			       + (((u8) min[2]) << 8) + (u8) min[3]);
-		memmove(min, &ip, sizeof(ip));
-		if (count == 8)
-			ip = htonl((((u8) max[0]) << 24) + (((u8) max[1]) << 16)
-				   + (((u8) max[2]) << 8) + (u8) max[3]);
-		memmove(max, &ip, sizeof(ip));
-		return 1;
-	}
-	return 0;
-}
-
 #if !defined(NIP6)
 #define NIP6(addr)							\
 	ntohs((addr).s6_addr16[0]), ntohs((addr).s6_addr16[1]),		\
@@ -147,6 +104,44 @@
 }
 
 /**
+ * ccs_address_matches_group - Check whether the given address matches members of the given address group.
+ *
+ * @is_ipv6: True if @address is an IPv6 address.
+ * @address: An IPv4 or IPv6 address.
+ * @group:   Pointer to "struct ccs_address_group".
+ *
+ * Returns true if @address matches addresses in @group group, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
+				      const struct ccs_address_group *group)
+{
+	struct ccs_address_group_member *member;
+	const u32 ip = ntohl(*address);
+	bool matched = false;
+	list_for_each_entry_rcu(member, &group->member_list, list) {
+		if (member->is_deleted)
+			continue;
+		if (member->is_ipv6) {
+			if (is_ipv6 &&
+			    memcmp(member->min.ipv6, address, 16) <= 0 &&
+			    memcmp(address, member->max.ipv6, 16) <= 0) {
+				matched = true;
+				break;
+			}
+		} else {
+			if (!is_ipv6 &&
+			    member->min.ipv4 <= ip && ip <= member->max.ipv4) {
+				matched = true;
+				break;
+			}
+		}
+	}
+	return matched;
+}
+
+/**
  * ccs_network_entry2 - Check permission for network operation.
  *
  * @is_ipv6:   True if @address is an IPv6 address.
@@ -251,140 +246,6 @@
 }
 
 /**
- * ccs_write_network_policy - Write "struct ccs_ip_network_acl" list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_network_policy(char *data, struct ccs_domain_info *domain,
-			     struct ccs_condition *condition,
-			     const bool is_delete)
-{
-	struct ccs_ip_network_acl *entry = NULL;
-	struct ccs_acl_info *ptr;
-	struct ccs_ip_network_acl e = {
-		.head.type = CCS_TYPE_IP_NETWORK_ACL,
-		.head.cond = condition,
-	};
-	u16 min_address[8];
-	u16 max_address[8];
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	u8 sock_type;
-	char *w[4];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[3][0])
-		return -EINVAL;
-	if (!strcmp(w[0], "TCP"))
-		sock_type = SOCK_STREAM;
-	else if (!strcmp(w[0], "UDP"))
-		sock_type = SOCK_DGRAM;
-	else if (!strcmp(w[0], "RAW"))
-		sock_type = SOCK_RAW;
-	else
-		return -EINVAL;
-	if (!strcmp(w[1], "bind"))
-		switch (sock_type) {
-		case SOCK_STREAM:
-			e.perm = 1 << CCS_NETWORK_TCP_BIND;
-			break;
-		case SOCK_DGRAM:
-			e.perm = 1 << CCS_NETWORK_UDP_BIND;
-			break;
-		default:
-			e.perm = 1 << CCS_NETWORK_RAW_BIND;
-			break;
-		}
-	else if (!strcmp(w[1], "connect"))
-		switch (sock_type) {
-		case SOCK_STREAM:
-			e.perm = 1 << CCS_NETWORK_TCP_CONNECT;
-			break;
-		case SOCK_DGRAM:
-			e.perm = 1 << CCS_NETWORK_UDP_CONNECT;
-			break;
-		default:
-			e.perm = 1 << CCS_NETWORK_RAW_CONNECT;
-			break;
-		}
-	else if (sock_type == SOCK_STREAM && !strcmp(w[1], "listen"))
-		e.perm = 1 << CCS_NETWORK_TCP_LISTEN;
-	else if (sock_type == SOCK_STREAM && !strcmp(w[1], "accept"))
-		e.perm = 1 << CCS_NETWORK_TCP_ACCEPT;
-	else
-		return -EINVAL;
-	switch (ccs_parse_ip_address(w[2], min_address, max_address)) {
-	case 2:
-		e.address_type = CCS_IP_ADDRESS_TYPE_IPv6;
-		e.address.ipv6.min = ccs_get_ipv6_address((struct in6_addr *)
-							  min_address);
-		e.address.ipv6.max = ccs_get_ipv6_address((struct in6_addr *)
-							  max_address);
-		if (!e.address.ipv6.min || !e.address.ipv6.max)
-			goto out;
-		break;
-	case 1:
-		e.address_type = CCS_IP_ADDRESS_TYPE_IPv4;
-		/* use host byte order to allow u32 comparison.*/
-		e.address.ipv4.min = ntohl(*(u32 *) min_address);
-		e.address.ipv4.max = ntohl(*(u32 *) max_address);
-		break;
-	default:
-		if (w[2][0] != '@')
-			return -EINVAL;
-		e.address_type = CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
-		e.address.group = ccs_get_address_group(w[2] + 1);
-		if (!e.address.group)
-			return -ENOMEM;
-		break;
-	}
-	if (!ccs_parse_number_union(w[3], &e.port))
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_ip_network_acl *acl =
-			container_of(ptr, struct ccs_ip_network_acl, head);
-		if (ptr->type != CCS_TYPE_IP_NETWORK_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), address_type),
-			       sizeof(e)))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~e.perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= e.perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	if (w[2][0] == '@')
-		ccs_put_address_group(e.address.group);
-	else if (e.address_type == CCS_IP_ADDRESS_TYPE_IPv6) {
-		ccs_put_ipv6_address(e.address.ipv6.min);
-		ccs_put_ipv6_address(e.address.ipv6.max);
-	}
-	ccs_put_number_union(&e.port);
-	kfree(entry);
-	return error;
-}
-
-/**
  * ccs_network_listen_acl - Check permission for listen() operation.
  *
  * @is_ipv6: True if @address is an IPv6 address.
@@ -393,8 +254,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int ccs_network_listen_acl(const bool is_ipv6, const u8 *address,
-					 const u16 port)
+static int ccs_network_listen_acl(const bool is_ipv6, const u8 *address,
+				  const u16 port)
 {
 	return ccs_network_entry(is_ipv6, CCS_NETWORK_TCP_LISTEN,
 				 (const u32 *) address, ntohs(port));
@@ -410,9 +271,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int ccs_network_connect_acl(const bool is_ipv6,
-					  const int sock_type,
-					  const u8 *address, const u16 port)
+static int ccs_network_connect_acl(const bool is_ipv6, const int sock_type,
+				   const u8 *address, const u16 port)
 {
 	u8 operation;
 	switch (sock_type) {
@@ -466,8 +326,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int ccs_network_accept_acl(const bool is_ipv6, const u8 *address,
-					 const u16 port)
+static int ccs_network_accept_acl(const bool is_ipv6, const u8 *address,
+				  const u16 port)
 {
 	int retval;
 	current->ccs_flags |= CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
@@ -487,9 +347,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int ccs_network_sendmsg_acl(const bool is_ipv6,
-					  const int sock_type,
-					  const u8 *address, const u16 port)
+static int ccs_network_sendmsg_acl(const bool is_ipv6, const int sock_type,
+				   const u8 *address, const u16 port)
 {
 	u8 operation;
 	if (sock_type == SOCK_DGRAM)
@@ -510,9 +369,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int ccs_network_recvmsg_acl(const bool is_ipv6,
-					  const int sock_type,
-					  const u8 *address, const u16 port)
+static int ccs_network_recvmsg_acl(const bool is_ipv6, const int sock_type,
+				   const u8 *address, const u16 port)
 {
 	int retval;
 	const u8 operation
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/Makefile
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/Makefile	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/Makefile	(working copy)
@@ -1,5 +1,10 @@
-obj-y += address_group.o audit.o autobind.o capability.o condition.o domain.o environ.o file.o gc.o load_policy.o maymount.o memory.o mount.o network.o number_group.o path_group.o policy_io.o proc_if.o realpath.o signal.o util.o
+#obj-y += address_group.o audit.o autobind.o capability.o condition.o domain.o environ.o file.o gc.o load_policy.o maymount.o memory.o mount.o network.o number_group.o path_group.o policy_io.o proc_if.o realpath.o signal.o util.o
 
+obj-y += autobind.o capability.o condition.o environ.o file.o load_policy.o maymount.o mount.o network.o number_group.o path_group.o realpath.o signal.o util.o
+
+#obj-m += ccsecurity.o
+#ccsecurity-objs := domain.o memory.o audit.o policy_io.o gc.o proc_if.o
+
 ifeq ($(PATCHLEVEL),4)
 O_TARGET := ccsecurity.o
 export-objs += autobind.o file.o network.o
