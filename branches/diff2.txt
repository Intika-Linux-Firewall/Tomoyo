Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(revision 2335)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(working copy)
@@ -342,6 +342,7 @@
 _Bool move_proc_to_file(const char *src, const char *base, const char *dest);
 _Bool is_identical_file(const char *file1, const char *file2);
 FILE *open_read(const char *filename);
+FILE *open_write(const char *filename);
 void clear_domain_policy(struct domain_policy *dp);
 _Bool save_domain_policy_with_diff(struct domain_policy *dp,
 				   struct domain_policy *bp,
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/loadpolicy.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/loadpolicy.c	(revision 2335)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/loadpolicy.c	(working copy)
@@ -299,34 +299,6 @@
 
 /***** loadpolicy start *****/
 
-static FILE *open_write(const char *filename)
-{
-	if (network_mode) {
-		const int fd = socket(AF_INET, SOCK_STREAM, 0);
-		struct sockaddr_in addr;
-		FILE *fp;
-		memset(&addr, 0, sizeof(addr));
-		addr.sin_family = AF_INET;
-		addr.sin_addr.s_addr = network_ip;
-		addr.sin_port = network_port;
-		if (connect(fd, (struct sockaddr *) &addr, sizeof(addr))) {
-			close(fd);
-			return NULL;
-		}
-		fp = fdopen(fd, "r+");
-		fprintf(fp, "%s", filename);
-		fputc(0, fp);
-		fflush(fp);
-		if (fgetc(fp) != 0) {
-			fclose(fp);
-			return NULL;
-		}
-		return fp;
-	} else {
-		return fopen(filename, "w+");
-	}
-}
-
 static void move_file_to_proc(const char *base, const char *src,
 			      const char *dest)
 {
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(revision 2335)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(working copy)
@@ -31,7 +31,6 @@
 is_domain_keeper(const struct path_info *domainname, const char *program);
 static const struct domain_initializer_entry *
 is_domain_initializer(const struct path_info *domainname, const char *program);
-static FILE *open_write(const char *filename);
 static int generic_acl_compare(const void *a, const void *b);
 static int generic_acl_compare0(const void *a, const void *b);
 static int string_acl_compare(const void *a, const void *b);
@@ -753,7 +752,7 @@
 	return flag;
 }
 
-static FILE *open_write(const char *filename)
+FILE *open_write(const char *filename)
 {
 	if (network_mode) {
 		const int fd = socket(AF_INET, SOCK_STREAM, 0);
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstree.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstree.c	(revision 2335)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstree.c	(working copy)
@@ -17,7 +17,7 @@
 	pid_t ppid = 1;
 	memset(buffer, 0, sizeof(buffer));
 	snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
-	fp = fopen(buffer, "r");
+	fp = open_read(buffer);
 	if (fp) {
 		while (memset(buffer, 0, sizeof(buffer)),
 		       fgets(buffer, sizeof(buffer) - 1, fp)) {
@@ -35,7 +35,7 @@
 	FILE *fp;
 	memset(buffer, 0, sizeof(buffer));
 	snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
-	fp = fopen(buffer, "r");
+	fp = open_read(buffer);
 	if (fp) {
 		while (memset(buffer, 0, sizeof(buffer)),
 		       fgets(buffer, sizeof(buffer) - 1, fp)) {
@@ -57,15 +57,23 @@
 	return NULL;
 }
 
+static FILE *status_fp = NULL;
 static int status_fd = EOF;
 
 static const char *read_info(const pid_t pid, int *profile)
 {
 	char *cp; /* caller must use get()/put(). */
-	shprintf("%d\n", pid);
-	write(status_fd, shared_buffer, strlen(shared_buffer));
-	memset(shared_buffer, 0, sizeof(shared_buffer));
-	read(status_fd, shared_buffer, sizeof(shared_buffer) - 1);
+	if (network_mode) {
+		fprintf(status_fp, "%d\n", pid);
+		fputc(0, status_fp);
+		fflush(status_fp);
+		freadline(status_fp); /* Not '\n' terminated. */
+	} else {
+		shprintf("%d\n", pid);
+		write(status_fd, shared_buffer, strlen(shared_buffer));
+		memset(shared_buffer, 0, sizeof(shared_buffer));
+		read(status_fd, shared_buffer, sizeof(shared_buffer) - 1);
+	}
 	cp = strchr(shared_buffer, ' ');
 	if (cp) {
 		*profile = atoi(cp + 1);
@@ -73,6 +81,7 @@
 		if (cp)
 			return cp + 1;
 	}
+ out:
 	*profile = -1;
 	return "<UNKNOWN>";
 }
@@ -134,28 +143,62 @@
 {
 	const char *policy_file = proc_policy_process_status;
 	static _Bool show_all = false;
-	if (access(proc_policy_dir, F_OK)) {
-		fprintf(stderr, "You can't use this command "
-			"for this kernel.\n");
-		return 1;
-	}
 	if (argc > 1) {
-		if (!strcmp(argv[1], "-a")) {
+		char *ptr = argv[1];
+		char *cp = strchr(ptr, ':');
+		if (cp) {
+			*cp++ = '\0';
+			network_ip = inet_addr(ptr);
+			network_port = htons(atoi(cp));
+			network_mode = true;
+		} else if (!strcmp(ptr, "-a")) {
 			show_all = true;
 		} else {
-			fprintf(stderr, "Usage: %s [-a]\n", argv[0]);
+			fprintf(stderr, "Usage: %s "
+				"[{-a|remote_ip:remote_port}]}\n", argv[0]);
 			return 0;
 		}
 	}
-	status_fd = open(policy_file, O_RDWR);
-	if (status_fd == EOF) {
-		fprintf(stderr, "Can't open %s\n", policy_file);
-		return 1;
-	}
-	{
+	if (network_mode) {
+		unsigned int pid;
+		FILE *fp = open_read("/proc/");
+		if (!fp) {
+out:
+			fprintf(stderr, "Can't connect.\n");
+			return 1;
+		}
+		get();
+		while (fscanf(fp, "%u", &pid) == 1) {
+			task_list = realloc(task_list,
+					    (task_list_len + 1) *
+					    sizeof(struct task_entry));
+			if (!task_list)
+				out_of_memory();
+			task_list[task_list_len].pid = pid;
+			task_list[task_list_len].ppid = get_ppid(pid);
+			task_list[task_list_len].done = false;
+			task_list_len++;
+		}
+		put();
+		fclose(fp);
+		status_fp = open_write(policy_file);
+		if (!status_fp)
+			goto out;
+	} else {
 		struct dirent **namelist;
 		int i;
-		int n = scandir("/proc/", &namelist, 0, 0);
+		int n;
+		if (access(proc_policy_dir, F_OK)) {
+			fprintf(stderr, "You can't use this command "
+				"for this kernel.\n");
+			return 1;
+		}
+		status_fd = open(policy_file, O_RDWR);
+		if (status_fd == EOF) {
+			fprintf(stderr, "Can't open %s\n", policy_file);
+			return 1;
+		}
+		n = scandir("/proc/", &namelist, 0, 0);
 		for (i = 0; i < n; i++) {
 			pid_t pid;
 			char buffer[128];
@@ -185,6 +228,12 @@
 	}
 	dump(1, 0);
 	dump_unprocessed();
-	close(status_fd);
+	if (status_fp) {
+		fclose(status_fp);
+		status_fp = NULL;
+	} else {
+		close(status_fd);
+		status_fd = EOF;
+	}
 	return 0;
 }
Index: trunk/1.6.x/ccs-tools/ccstools/ccs-editpolicy-agent.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccs-editpolicy-agent.c	(revision 2335)
+++ trunk/1.6.x/ccs-tools/ccstools/ccs-editpolicy-agent.c	(working copy)
@@ -9,58 +9,94 @@
 #include <fcntl.h>
 #include <unistd.h>
 #include <signal.h>
+#include <dirent.h>
 
+static void show_tasklist(const int fd)
+{
+	DIR *dir = opendir("/proc/");
+	if (!dir)
+		return;
+	write(fd, "", 1);
+	while (1) {
+		unsigned int pid;
+		struct dirent *dent = readdir(dir);
+		const char *cp;
+		if (!dent)
+			break;
+		cp = dent->d_name;
+		if (dent->d_type != DT_DIR || sscanf(cp, "%u", &pid) != 1)
+			continue;
+		write(fd, cp, strlen(cp));
+		write(fd, " ", 1);
+	}
+	write(fd, "", 1);
+	closedir(dir);
+}
+
 static void do_child(const int client)
 {
 	int i;
 	int fd = EOF;
 	char buffer[1024];
-	while (1) {
-		/* Read filename. */
-		for (i = 0; i < sizeof(buffer) - 1; i++) {
-			if (read(client, buffer + i, 1) != 1)
-				goto out;
-			if (!buffer[i]) {
-				char *cp = strrchr(buffer, '/');
-				if (!cp)
-					cp = buffer;
-				else
-					cp++;
+	/* Read filename. */
+	for (i = 0; i < sizeof(buffer) - 1; i++) {
+		if (read(client, buffer + i, 1) != 1)
+			goto out;
+		if (!buffer[i]) {
+			unsigned int pid;
+			char *cp = strrchr(buffer, '/');
+			if (!strcmp(buffer, "/proc/")) {
+				char c;
+				/* Open /proc/\$/ for reading. */
+				show_tasklist(client);
+				read(client, &c, 1); /* Wait. */
+				break;
+			}
+			if (!cp)
+				cp = buffer;
+			else
+				cp++;
+			if (sscanf(buffer, "/proc/%u/status", &pid) == 1) {
+				/* Open /proc/\$/status for reading. */
+				snprintf(buffer, sizeof(buffer) - 1,
+					 "/proc/%u/status", pid);
+				fd = open(buffer, O_RDONLY);
+			} else {
 				/* Open for read/write. */
 				fd = open(cp, O_RDWR);
-				break;
 			}
+			break;
 		}
-		if (fd == EOF) 
+	}
+	if (fd == EOF) 
+		goto out;
+	/* Return \0 to indicate success. */
+	if (write(client, "", 1) != 1)
+		goto out;
+	while (1) {
+		char c;
+		/* Read a byte. */
+		if (read(client, &c, 1) != 1)
 			goto out;
-		/* Return \0 to indicate success. */
-		if (write(client, "", 1) != 1)
-			goto out;
+		if (c) {
+			/* Write that byte. */
+			if (write(fd, &c, 1) != 1)
+				goto out;
+			continue;
+		}
+		/* Read until EOF. */
 		while (1) {
-			char c;
-			/* Read a byte. */
-			if (read(client, &c, 1) != 1)
+			int len = read(fd, buffer, sizeof(buffer));
+			if (len == 0)
+				break;
+			/* Don't send \0 because it is EOF marker. */
+			if (len < 0 || memchr(buffer, '\0', len) ||
+			    write(client, buffer, len) != len)
 				goto out;
-			if (c) {
-				/* Write that byte. */
-				if (write(fd, &c, 1) != 1)
-					goto out;
-				continue;
-			}
-			/* Read until EOF. */
-			while (1) {
-				int len = read(fd, buffer, sizeof(buffer));
-				if (len == 0)
-					break;
-				/* Don't send \0 because it is EOF marker. */
-				if (len < 0 || memchr(buffer, '\0', len) ||
-				    write(client, buffer, len) != len)
-					goto out;
-			}
-			/* Return \0 to indicate EOF. */
-			if (write(client, "", 1) != 1)
-				goto out;
 		}
+		/* Return \0 to indicate EOF. */
+		if (write(client, "", 1) != 1)
+			goto out;
 	}
  out:
 	close(fd);
