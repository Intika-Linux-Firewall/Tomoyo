Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(revision 2496)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(working copy)
@@ -300,6 +300,8 @@
 	char *domain;
 	u8 profile;
 	_Bool done;
+	int index;
+	int depth;
 };
 
 /***** STRUCTURES DEFINITION END *****/
Index: trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(revision 2496)
+++ trunk/1.6.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(working copy)
@@ -64,7 +64,6 @@
 static void down_arrow_key(struct domain_policy *dp);
 static void page_up_key(struct domain_policy *dp);
 static void page_down_key(struct domain_policy *dp);
-static void show_current(struct domain_policy *dp);
 static void adjust_cursor_pos(const int item_count);
 static void set_cursor_pos(const int index);
 static int count(const unsigned char *array, const int len);
@@ -608,12 +607,17 @@
 static const char *policy_file = NULL;
 static const char *list_caption = NULL;
 static char *current_domain = NULL;
+static unsigned int current_pid = 0;
 
 static int current_screen = SCREEN_DOMAIN_LIST;
 
 struct generic_acl *generic_acl_list = NULL;
 int generic_acl_list_count = 0;
 
+static struct task_entry *task_list = NULL;
+static int task_list_len = 0;
+static int dump_index = 0; 
+
 static struct domain_keeper_entry *domain_keeper_list = NULL;
 static int domain_keeper_list_len = 0;
 static struct domain_initializer_entry *domain_initializer_list = NULL;
@@ -882,7 +886,11 @@
 			/* Don't set error message if failed. */
 			fp = fopen(policy_file, "r+");
 		if (fp) {
-			fprintf(fp, "select domain=%s\n", current_domain);
+			if (current_pid)
+				fprintf(fp, "select pid=%u\n", current_pid);
+			else
+				fprintf(fp, "select domain=%s\n",
+					current_domain);
 			if (network_mode)
 				fputc(0, fp);
 			fflush(fp);
@@ -965,6 +973,218 @@
 	}
 }
 
+static pid_t get_ppid(const pid_t pid)
+{
+	char buffer[1024];
+	FILE *fp;
+	pid_t ppid = 1;
+	memset(buffer, 0, sizeof(buffer));
+	snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
+	fp = fopen(buffer, "r");
+	if (fp) {
+		while (memset(buffer, 0, sizeof(buffer)),
+		       fgets(buffer, sizeof(buffer) - 1, fp)) {
+			if (sscanf(buffer, "PPid: %u", &ppid) == 1)
+				break;
+		}
+		fclose(fp);
+	}
+	return ppid;
+}
+
+static char *get_name(const pid_t pid)
+{
+	char buffer[1024];
+	FILE *fp;
+	memset(buffer, 0, sizeof(buffer));
+	snprintf(buffer, sizeof(buffer) - 1, "/proc/%u/status", pid);
+	fp = fopen(buffer, "r");
+	if (fp) {
+		static const int offset = sizeof(buffer) / 6;
+		while (memset(buffer, 0, sizeof(buffer)),
+		       fgets(buffer, sizeof(buffer) - 1, fp)) {
+			if (!strncmp(buffer, "Name:\t", 6)) {
+				char *cp = buffer + 6;
+				memmove(buffer, cp, strlen(cp) + 1);
+				cp = strchr(buffer, '\n');
+				if (cp)
+					*cp = '\0';
+				break;
+			}
+		}
+		fclose(fp);
+		if (buffer[0] && strlen(buffer) < offset - 1) {
+			const char *src = buffer;
+			char *dest = buffer + offset;
+			while (1) {
+				unsigned char c = *src++;
+				if (!c) {
+					*dest = '\0';
+					break;
+				}
+				if (c == '\\') {
+					c = *src++;
+					if (c == '\\') {
+						memmove(dest, "\\\\", 2);
+						dest += 2;
+					} else if (c == 'n') {
+						memmove(dest, "\\012", 4);
+						dest += 4;
+					} else {
+						break;
+					}
+				} else if (c > ' ' && c <= 126) {
+					*dest++ = c;
+				} else {
+					*dest++ = '\\';
+					*dest++ = (c >> 6) + '0';
+					*dest++ = ((c >> 3) & 7) + '0';
+					*dest++ = (c & 7) + '0';
+				}
+			}
+			return strdup(buffer + offset);
+		}
+	}
+	return NULL;
+}
+
+static void sort_process_entry(const pid_t pid, const int depth)
+{
+	int i;
+	for (i = 0; i < task_list_len; i++) {
+		if (pid != task_list[i].pid)
+			continue;
+		task_list[i].index = dump_index++;
+		task_list[i].depth = depth; 
+		task_list[i].done = true;
+	}
+	for (i = 0; i < task_list_len; i++) {
+		if (pid != task_list[i].ppid)
+			continue;
+		sort_process_entry(task_list[i].pid, depth + 1);
+	}
+}
+
+static int task_entry_compare(const void *a, const void *b)
+{
+	const struct task_entry *a0 = (struct task_entry *) a;
+	const struct task_entry *b0 = (struct task_entry *) b;
+	return a0->index - b0->index;
+}
+
+static void read_process_list(void)
+{
+	int i;
+	while (task_list_len) {
+		task_list_len--;
+		free((void *) task_list[task_list_len].name);
+		free((void *) task_list[task_list_len].domain);
+	}
+	dump_index = 0;
+	if (network_mode) {
+		FILE *fp = open_write("proc:all_process_status");
+		if (!fp)
+			return;
+		get();
+		while (freadline(fp)) {
+			unsigned int pid = 0;
+			unsigned int ppid = 0;
+			int profile = -1;
+			char *name;
+			char *domain;
+			sscanf(shared_buffer, "PID=%u PPID=%u", &pid, &ppid);
+			name = strstr(shared_buffer, "NAME=");
+			if (name)
+				name = strdup(name + 5);
+			if (!name)
+				name = strdup("<UNKNOWN>");
+			if (!freadline(fp))
+				break;
+			sscanf(shared_buffer, "%u %u", &pid, &profile);
+			domain = strchr(shared_buffer, '<');
+			if (domain)
+				domain = strdup(domain);
+			if (!domain)
+				domain = strdup("<UNKNOWN>");
+			task_list = realloc(task_list,
+					    (task_list_len + 1) *
+					    sizeof(struct task_entry));
+			if (!task_list)
+				out_of_memory();
+			task_list[task_list_len].pid = pid;
+			task_list[task_list_len].ppid = ppid;
+			task_list[task_list_len].profile = profile;
+			task_list[task_list_len].name = name;
+			task_list[task_list_len].domain = domain;
+			task_list[task_list_len].done = false;
+			task_list_len++;
+		}
+		put();
+		fclose(fp);
+	} else {
+		struct dirent **namelist;
+		int i;
+		int n;
+		int status_fd = open(proc_policy_process_status, O_RDWR);
+		if (status_fd == EOF)
+			return;
+		n = scandir("/proc/", &namelist, 0, 0);
+		for (i = 0; i < n; i++) {
+			char *name;
+			char *domain;
+			int profile = -1;
+			unsigned int pid = 0;
+			char buffer[128];
+			if (sscanf(namelist[i]->d_name, "%u", &pid) != 1)
+				goto skip;
+			memset(buffer, 0, sizeof(buffer));
+			name = get_name(pid);
+			if (!name)
+				name = strdup("<UNKNOWN>");
+			snprintf(buffer, sizeof(buffer) - 1, "%u\n", pid);
+			write(status_fd, buffer, strlen(buffer));
+			get();
+			memset(shared_buffer, 0, sizeof(shared_buffer));
+			read(status_fd, shared_buffer,
+			     sizeof(shared_buffer) - 1);
+			sscanf(shared_buffer, "%u %u", &pid, &profile);
+			domain = strchr(shared_buffer, '<');
+			if (domain)
+				domain = strdup(domain);
+			if (!domain)
+				domain = strdup("<UNKNOWN>");
+			put();
+			task_list = realloc(task_list, (task_list_len + 1) *
+					    sizeof(struct task_entry));
+			if (!task_list)
+				out_of_memory();
+			task_list[task_list_len].pid = pid;
+			task_list[task_list_len].ppid = get_ppid(pid);
+			task_list[task_list_len].profile = profile;
+			task_list[task_list_len].name = name;
+			task_list[task_list_len].domain = domain;
+			task_list[task_list_len].done = false;
+			task_list_len++;
+skip:
+			free((void *) namelist[i]);
+		}
+		if (n >= 0)
+			free((void *) namelist);
+		close(status_fd);
+	}
+	sort_process_entry(1, 0);
+	for (i = 0; i < task_list_len; i++) {
+		if (task_list[i].done) {
+			task_list[i].done = false;
+			continue;
+		}
+		task_list[i].index = dump_index++;
+		task_list[i].depth = 0;
+	}
+	qsort(task_list, task_list_len, sizeof(struct task_entry),
+	      task_entry_compare);
+}
+
 static int add_domain_initializer_entry(const char *domainname,
 					const char *program, const _Bool is_not)
 {
@@ -1331,13 +1551,39 @@
 		}
 	}
 
-	dp->list_selected = realloc(dp->list_selected, dp->list_len);
+	if (!offline_mode) /* read process information */
+		read_process_list();
+
+	dp->list_selected = realloc(dp->list_selected, dp->list_len
+				    + generic_acl_list_count);
 	if (dp->list_len && !dp->list_selected)
 		out_of_memory();
-	memset(dp->list_selected, 0, dp->list_len);
+	memset(dp->list_selected, 0, dp->list_len + generic_acl_list_count);
 }
 
+static int show_process_line(int index)
+{
+	int tmp_col = 0;
+	int i;
+	printw("%c%4d:%3u ",
+	       task_list[index].done ? '&' : ' ',
+	       index, task_list[index].profile);
+	tmp_col += 10;
+	for (i = 0; i < task_list[index].depth - 1; i++) {
+		printw("%s", eat("    "));
+		tmp_col += 4;
+	}
+	get();
+	shprintf("%s%s (%u) %s", task_list[index].depth ?
+		 " +- " : "", task_list[index].name,
+		 task_list[index].pid, task_list[index].domain);
+	printw("%s", eat(shared_buffer));
+	tmp_col += strlen(shared_buffer);
+	put();
+	return tmp_col;
+}
 
+
 static void show_list(struct domain_policy *dp)
 {
 	const int offset = current_item_index[current_screen];
@@ -1360,9 +1606,10 @@
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		int i = list_item_count[SCREEN_DOMAIN_LIST]
 			- unnumbered_domain_count;
+		int j = task_list_len;
 		printw("<<< Domain Transition Editor >>>"
-		       "      %d domain%c    '?' for help",
-		       i, i > 1 ? 's' : ' ');
+		       "      %d domain%c    %d process%s   '?' for help",
+		       i, i > 1 ? 's' : ' ', j, j > 1 ? "es" : "");
 	} else {
 		int i = list_item_count[current_screen];
 		printw("<<< %s >>>"
@@ -1397,13 +1644,22 @@
 	}
 	for (i = 0; i < body_lines; i++) {
 		const int index = offset + i;
+		const int count = list_item_count[current_screen];
 		eat_col = max_eat_col[current_screen];
-		if (index >= list_item_count[current_screen])
-			break;
+		if (current_screen == SCREEN_DOMAIN_LIST) {
+			if (index >= count + task_list_len)
+				break;
+		} else {
+			if (index >= count)
+				break;
+		}
 		move(header_lines + i, 0);
 		switch (current_screen) {
 		case SCREEN_DOMAIN_LIST:
-			tmp_col = show_domain_line(dp, index);
+			if (index < count)
+				tmp_col = show_domain_line(dp, index);
+			else
+				tmp_col = show_process_line(index - count);
 			break;
 		case SCREEN_SYSTEM_LIST:
 		case SCREEN_EXCEPTION_LIST:
@@ -1451,16 +1707,17 @@
 
 static void down_arrow_key(struct domain_policy *dp)
 {
+	int count = list_item_count[current_screen] - 1;
+	if (current_screen == SCREEN_DOMAIN_LIST)
+		count += task_list_len;
 	if (current_y[current_screen] < body_lines - 1) {
 		if (current_item_index[current_screen]
-		    + current_y[current_screen]
-		    < list_item_count[current_screen] - 1) {
+		    + current_y[current_screen] <  count) {
 			current_y[current_screen]++;
 			show_current(dp);
 		}
 	} else if (current_item_index[current_screen]
-		   + current_y[current_screen]
-		   < list_item_count[current_screen] - 1) {
+		   + current_y[current_screen] < count) {
 		current_item_index[current_screen]++;
 		show_list(dp);
 	}
@@ -1484,33 +1741,34 @@
 
 static void page_down_key(struct domain_policy *dp)
 {
-	if (list_item_count[current_screen] - current_item_index[current_screen]
-	    > body_lines) {
+	int count = list_item_count[current_screen] - 1;
+	if (current_screen == SCREEN_DOMAIN_LIST)
+		count += task_list_len;
+	if (count + 1 - current_item_index[current_screen] > body_lines) {
 		current_item_index[current_screen] += body_lines;
 		if (current_item_index[current_screen]
-		    + current_y[current_screen]
-		    > list_item_count[current_screen] - 1)
+		    + current_y[current_screen] > count)
 			current_y[current_screen]
-				= list_item_count[current_screen] - 1
-				- current_item_index[current_screen];
+				= count - current_item_index[current_screen];
 		show_list(dp);
 	} else if (current_item_index[current_screen]
-		   + current_y[current_screen]
-		   < list_item_count[current_screen] - 1) {
+		   + current_y[current_screen] < count) {
 		current_y[current_screen]
-			= list_item_count[current_screen]
-			- current_item_index[current_screen] - 1;
+			= list_item_count[current_screen] - count;
 		show_current(dp);
 	}
 }
 
 int editpolicy_get_current(void)
 {
-	if (list_item_count[current_screen] == 0)
+	int count = list_item_count[current_screen];
+	if (current_screen == SCREEN_DOMAIN_LIST)
+		count += task_list_len;
+	if (!count)
 		return EOF;
 	if (current_item_index[current_screen] + current_y[current_screen] < 0
 	    || current_item_index[current_screen] + current_y[current_screen]
-	    >= list_item_count[current_screen]) {
+	    >= count) {
 		fprintf(stderr, "ERROR: current_item_index=%d current_y=%d\n",
 			current_item_index[current_screen],
 			current_y[current_screen]);
@@ -1522,9 +1780,14 @@
 static void show_current(struct domain_policy *dp)
 {
 	if (current_screen == SCREEN_DOMAIN_LIST) {
+		int index = editpolicy_get_current();
+		int count = list_item_count[SCREEN_DOMAIN_LIST];
 		get();
 		eat_col = max_eat_col[current_screen];
-		shprintf("%s", eat(domain_name(dp, editpolicy_get_current())));
+		if (index < count)
+			shprintf("%s", eat(domain_name(dp, index)));
+		else
+			shprintf("%s", eat(task_list[index - count].name));
 		if (window_width < sizeof(shared_buffer))
 			shared_buffer[window_width] = '\0';
 		move(2, 0);
@@ -1579,10 +1842,13 @@
 		int x;
 		int y;
 		if (current_screen == SCREEN_DOMAIN_LIST) {
-			if (is_deleted_domain(dp, current) ||
-			    is_initializer_source(dp, current))
-				return 0;
-			dp->list_selected[current] ^= 1;
+			if (current < dp->list_len) {
+				if (is_deleted_domain(dp, current) ||
+				    is_initializer_source(dp, current))
+					return 0;
+				dp->list_selected[current] ^= 1;
+			} else
+				task_list[current - dp->list_len].done ^= 1;
 		} else {
 			generic_acl_list[current].selected ^= 1;
 		}
@@ -1816,6 +2082,12 @@
 		fprintf(fp, "select %s\n" KEYWORD_USE_PROFILE "%s\n",
 			domain_name(dp, index), line);
 	}
+	for (index = 0; index < task_list_len; index++) {
+		if (!task_list[index].done)
+			continue;
+		fprintf(fp, "select pid=%u\n" KEYWORD_USE_PROFILE "%s\n",
+			task_list[index].pid, line);
+	}
 	close_write(fp);
 out:
 	free(line);
@@ -2003,7 +2275,7 @@
 start:
 	if (current_screen == SCREEN_DOMAIN_LIST) {
 		read_domain_and_exception_policy(dp);
-		adjust_cursor_pos(dp->list_len);
+		adjust_cursor_pos(dp->list_len + task_list_len);
 	} else {
 		read_generic_policy();
 		adjust_cursor_pos(generic_acl_list_count);
@@ -2072,19 +2344,28 @@
 		case 'C':
 			if (current == EOF)
 				break;
+			index = list_item_count[current_screen];
 			if (current_screen == SCREEN_DOMAIN_LIST) {
-				const u8 selected
-					= dp->list_selected[current];
-				if (is_deleted_domain(dp, current) ||
-				    is_initializer_source(dp, current))
-					break;
-				for (index = current;
-				     index < dp->list_len; index++) {
-					if (is_deleted_domain(dp, index) ||
+				if (current >= index) {
+					const u8 selected =
+						task_list[current - index].done;
+					for (index = current;
+					     index < task_list_len; index++)
+						task_list[index].done = selected;
+				} else {
+					const u8 selected
+						= dp->list_selected[current];
+					if (is_deleted_domain(dp, current) ||
+					    is_initializer_source(dp, current))
+						break;
+					for (index = current;
+					     index < dp->list_len; index++) {
+						if (is_deleted_domain(dp, index) ||
 					    is_initializer_source(dp, index))
-						continue;
-					dp->list_selected[index]
-						= selected;
+							continue;
+						dp->list_selected[index]
+							= selected;
+					}
 				}
 			} else {
 				const u8 selected
@@ -2153,6 +2434,18 @@
 		case '\n':
 			if (current_screen != SCREEN_DOMAIN_LIST)
 				break;
+			current_pid = 0;
+			index = list_item_count[current_screen];
+			if (current >= index) {
+				current_pid = task_list[current - index].pid;
+				free(current_domain);
+				current_domain =
+					strdup(task_list[current
+							 - index].domain);
+				if (!current_domain)
+					out_of_memory();
+				return SCREEN_ACL_LIST;
+			}
 			if (is_initializer_source(dp, current)) {
 				int redirect_index;
 				get();
Index: trunk/1.6.x/ccs-tools/ccstools/Makefile
===================================================================
--- trunk/1.6.x/ccs-tools/ccstools/Makefile	(revision 2496)
+++ trunk/1.6.x/ccs-tools/ccstools/Makefile	(working copy)
@@ -31,7 +31,7 @@
 
 CC=gcc
 
-CFLAGS=-Wall -O2 ${shell $(CC) -Wno-pointer-sign -S -o /dev/null -x c - < /dev/null > /dev/null 2>&1 && echo "-Wno-pointer-sign"}
+CFLAGS=-Wall -O0 -g ${shell $(CC) -Wno-pointer-sign -S -o /dev/null -x c - < /dev/null > /dev/null 2>&1 && echo "-Wno-pointer-sign"}
 
 /usr/include/curses.h:
 	@echo "/usr/include/curses.h is missing."
