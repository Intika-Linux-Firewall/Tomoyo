Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.c
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.c	(revision 6399)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.c	(working copy)
@@ -31,56 +31,55 @@
 static struct ccs_readline_data ccs_rl = { };
 
 /* Array of "path_group" entries. */
-struct ccs_path_group_entry *ccs_path_group_list = NULL;
-/* Length of ccs_path_group_list array. */
-int ccs_path_group_list_len = 0;
+struct path_group_entry *path_group_list = NULL;
+/* Length of path_group_list array. */
+int path_group_list_len = 0;
 /* Array of "number_group" entry. */
-struct ccs_number_group_entry *ccs_number_group_list = NULL;
-/* Length of ccs_number_group_list array. */
-int ccs_number_group_list_len = 0;
+struct number_group_entry *number_group_list = NULL;
+/* Length of number_group_list array. */
+int number_group_list_len = 0;
 /* Array of "address_group" entry. */
-struct ccs_address_group_entry *ccs_address_group_list = NULL;
-/* Length of ccs_address_group_list array. */
-int ccs_address_group_list_len = 0;
+struct address_group_entry *address_group_list = NULL;
+/* Length of address_group_list array. */
+int address_group_list_len = 0;
 /* Array of "acl_group" entry. */
 char **acl_group_list[256];
 /* Length of acl_group_list array.*/
 int acl_group_list_len[256];
-
 /* Array of string ACL entries. */
-struct ccs_generic_acl *ccs_gacl_list = NULL;
-/* Length of ccs_generic_list array. */
-static int ccs_gacl_list_count = 0;
+struct generic_entry *generic_list = NULL;
+/* Length of generic_list array. */
+int generic_list_len = 0;
 
 /* Policy directory. */
-static const char *ccs_policy_dir = NULL;
+static const char *policy_dir = NULL;
 /* Use ccs-editpolicy-agent program? */
-static _Bool ccs_offline_mode = false;
+static _Bool offline_mode = false;
 /* Use readonly mode? */
-static _Bool ccs_readonly_mode = false;
+static _Bool readonly_mode = false;
 /* Refresh interval in second. 0 means no auto refresh. */
-static unsigned int ccs_refresh_interval = 0;
+static unsigned int refresh_interval = 0;
 /* Need to reload the screen due to auto refresh? */
-static _Bool ccs_need_reload = false;
+static _Bool need_reload = false;
 /* Policy file's name. */
-static const char *ccs_policy_file = NULL;
+static const char *policy_file = NULL;
 /* Caption of the current screen. */
-static const char *ccs_list_caption = NULL;
+static const char *list_caption = NULL;
 /* Currently selected domain. */
-static char *ccs_current_domain = NULL;
+static char *current_domain = NULL;
 /* Currently selected PID. */
-static unsigned int ccs_current_pid = 0;
+static unsigned int current_pid = 0;
 /* Currently active screen's index. */
-enum ccs_screen_type ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
+enum screen_type current_screen = SCREEN_DOMAIN_LIST;
 /* Previously active screen's index. */
-static enum ccs_screen_type ccs_previous_screen = CCS_SCREEN_DOMAIN_LIST;
+static enum screen_type previous_screen = SCREEN_DOMAIN_LIST;
 /*
- * Array of "initialize_domain"/"no_initialize_domain"/"keep_domain"/
- * "no_keep_domain" entries.
+ * Array of "reset_domain"/"no_reset_domain"/"initialize_domain"/
+ * "no_initialize_domain"/"keep_domain"/"no_keep_domain" entries.
  */
-static struct ccs_transition_control_entry *ccs_transition_control_list = NULL;
-/* Length of ccs_transition_control_list array. */
-static int ccs_transition_control_list_len = 0;
+static struct transition_entry *transition_list = NULL;
+/* Length of transition_list array. */
+static int transition_list_len = 0;
 /* Sort profiles by value? */
 static _Bool ccs_profile_sort_type = false;
 /* Number of domain jump source domains. */
@@ -90,9 +89,9 @@
 /* Height of CUI screen. */
 static int ccs_window_height = 0;
 /* Cursor info for CUI screen. */
-struct ccs_screen ccs_screen[CCS_MAXSCREEN] = { };
+struct ccs_screen ccs_screen[MAX_SCREEN_TYPE] = { };
 /* Number of entries available on current screen. */
-int ccs_list_item_count = 0;
+static int ccs_list_item_count = 0;
 /* Lines available for displaying ACL entries. */
 static int ccs_body_lines = 0;
 /* Columns to shift. */
@@ -113,55 +112,51 @@
 const struct ccs_path_info *ccs_current_ns = NULL;
 
 /* Domain transition coltrol keywords. */
-static const char *ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
-	[CCS_TRANSITION_CONTROL_RESET]         = "reset_domain ",
-	[CCS_TRANSITION_CONTROL_NO_RESET]      = "no_reset_domain ",
-	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
-	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
-	[CCS_TRANSITION_CONTROL_KEEP]          = "keep_domain ",
-	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
+static const char *transition_type[MAX_TRANSITION_TYPE] = {
+	[TRANSITION_RESET]         = "reset_domain ",
+	[TRANSITION_NO_RESET]      = "no_reset_domain ",
+	[TRANSITION_INITIALIZE]    = "initialize_domain ",
+	[TRANSITION_NO_INITIALIZE] = "no_initialize_domain ",
+	[TRANSITION_KEEP]          = "keep_domain ",
+	[TRANSITION_NO_KEEP]       = "no_keep_domain ",
 };
 
-static FILE *ccs_editpolicy_open_write(const char *filename);
+static FILE *editpolicy_open_write(const char *filename);
 static _Bool ccs_deleted_domain(const int index);
 static _Bool ccs_domain_unreachable(const int index);
 static _Bool ccs_jump_source(const int index);
 static _Bool ccs_jump_target(const int index);
 static _Bool ccs_keeper_domain(const int index);
 static _Bool ccs_select_item(const int index);
-static _Bool ccs_show_command_key(const enum ccs_screen_type screen,
+static _Bool ccs_show_command_key(const enum screen_type screen,
 				  const _Bool readonly);
 static const char *ccs_eat(const char *str);
 static const char *ccs_get_last_name(const int index);
-static const struct ccs_transition_control_entry *ccs_transition_control
+static const struct transition_entry *find_transition
 (const struct ccs_path_info *ns, const char *domainname, const char *program);
-static enum ccs_screen_type ccs_generic_list_loop(void);
-static enum ccs_screen_type ccs_select_window(const int current);
-static int ccs_add_path_group_entry(const struct ccs_path_info *ns,
-				    const char *group_name,
-				    const char *member_name);
-static int ccs_add_path_group_policy(const struct ccs_path_info *ns,
-				     char *data);
-static int ccs_add_number_group_entry(const char *group_name,
-				      const char *member_name);
-static int ccs_add_number_group_policy(char *data);
-static int ccs_add_address_group_entry(const char *group_name,
-				       const char *member_name);
-static int ccs_add_address_group_policy(char *data);
-static void ccs_add_acl_group_policy(const int group, const char *data);
-static void ccs_editpolicy_clear_groups(void);
-static int ccs_add_transition_control_entry(const struct ccs_path_info *ns,
-					    const char *domainname,
-					    const char *program, const enum
-					    ccs_transition_type type);
-static int ccs_add_transition_control_policy(const struct ccs_path_info *ns,
-					     char *data, const enum
-					     ccs_transition_type type);
+static enum screen_type ccs_generic_list_loop(void);
+static enum screen_type ccs_select_window(const int current);
+static int add_path_group_entry(const struct ccs_path_info *ns,
+				const char *group_name,
+				const char *member_name);
+static int add_path_group_policy(const struct ccs_path_info *ns, char *data);
+static int add_number_group_entry(const char *group_name,
+				  const char *member_name);
+static int add_number_group_policy(char *data);
+static int add_address_group_entry(const char *group_name,
+				   const char *member_name);
+static int add_address_group_policy(char *data);
+static void add_acl_group_policy(const int group, const char *data);
+static void editpolicy_clear_groups(void);
+static int add_transition_entry(const struct ccs_path_info *ns,
+				const char *domainname, const char *program,
+				const enum transition_type type);
+static int add_transition_policy(const struct ccs_path_info *ns,
+				 char *data, const enum transition_type type);
 static int ccs_count(const unsigned char *array, const int len);
-static int ccs_count2(const struct ccs_generic_acl *array, int len);
+static int ccs_count2(const struct generic_entry *array, int len);
 static int ccs_domainname_attribute_compare(const void *a, const void *b);
 static int ccs_gacl_compare(const void *a, const void *b);
-static int ccs_gacl_compare0(const void *a, const void *b);
 static int ccs_profile_entry_compare(const void *a, const void *b);
 static int ccs_show_acl_line(const int index, const int list_indent);
 static int ccs_show_domain_line(const int index);
@@ -268,14 +263,14 @@
 }
 
 /**
- * ccs_add_string_entry - Add string entry to a domain.
+ * add_string_entry - Add string entry to a domain.
  *
  * @entry: String to add.
  * @index: Index in the @dp array.
  *
  * Returns 0 if successfully added or already exists, -EINVAL otherwise.
  */
-static int ccs_add_string_entry3(const char *entry, const int index)
+static int add_string_entry3(const char *entry, const int index)
 {
 	const struct ccs_path_info **acl_ptr;
 	int acl_count;
@@ -359,7 +354,7 @@
 static void ccs_copy_file(const char *source, const char *dest)
 {
 	FILE *fp_in = fopen(source, "r");
-	FILE *fp_out = fp_in ? ccs_editpolicy_open_write(dest) : NULL;
+	FILE *fp_out = fp_in ? editpolicy_open_write(dest) : NULL;
 	while (fp_in && fp_out) {
 		int c = fgetc(fp_in);
 		if (c == EOF)
@@ -438,14 +433,14 @@
 }
 
 /**
- * ccs_count2 - Count non-zero elements in a "struct ccs_generic_acl" array.
+ * ccs_count2 - Count non-zero elements in a "struct generic_entry" array.
  *
- * @array: Pointer to "const struct ccs_generic_acl".
+ * @array: Pointer to "const struct generic_entry".
  * @len:   Length of @array array.
  *
  * Returns number of non-zero elements.
  */
-static int ccs_count2(const struct ccs_generic_acl *array, int len)
+static int ccs_count2(const struct generic_entry *array, int len)
 {
 	int i;
 	int c = 0;
@@ -536,36 +531,6 @@
 }
 
 /**
- * ccs_gacl_compare0 - strcmp() for qsort() callback.
- *
- * @a: Pointer to "void".
- * @b: Pointer to "void".
- *
- * Returns return value of strcmp().
- */
-static int ccs_gacl_compare0(const void *a, const void *b)
-{
-	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
-	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
-	const enum ccs_editpolicy_directives a0_d = a0->directive;
-	const enum ccs_editpolicy_directives b0_d = b0->directive;
-	const char *a1 = ccs_directives[a0_d].alias;
-	const char *b1 = ccs_directives[b0_d].alias;
-	const char *a2 = a0->operand;
-	const char *b2 = b0->operand;
-	int ret;
-	if (a0_d >= CCS_DIRECTIVE_ACL_GROUP_000 &&
-	    a0_d <= CCS_DIRECTIVE_ACL_GROUP_255 && 
-	    b0_d >= CCS_DIRECTIVE_ACL_GROUP_000 &&
-	    b0_d <= CCS_DIRECTIVE_ACL_GROUP_255 && a0_d != b0_d)
-		return a0_d - b0_d;
-	ret = strcmp(a1, b1);
-	if (ret)
-		return ret;
-	return strcmp(a2, b2);
-}
-
-/**
  * ccs_string_acl_compare - strcmp() for qsort() callback.
  *
  * @a: Pointer to "void".
@@ -575,97 +540,94 @@
  */
 static int ccs_string_acl_compare(const void *a, const void *b)
 {
-	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
-	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
+	const struct generic_entry *a0 = (struct generic_entry *) a;
+	const struct generic_entry *b0 = (struct generic_entry *) b;
 	const char *a1 = a0->operand;
 	const char *b1 = b0->operand;
 	return strcmp(a1, b1);
 }
 
 /**
- * ccs_add_transition_control_policy - Add "reset_domain"/"no_reset_domain"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/"no_keep_domain" entries.
+ * add_transition_policy - Add "reset_domain"/"no_reset_domain"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/"no_keep_domain" entries.
  *
  * @ns:   Pointer to "const struct ccs_path_info".
  * @data: Line to parse.
- * @type: One of values in "enum ccs_transition_type".
+ * @type: One of values in "enum transition_type".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_transition_control_policy
-(const struct ccs_path_info *ns, char *data,
- const enum ccs_transition_type type)
+static int add_transition_policy
+(const struct ccs_path_info *ns, char *data, const enum transition_type type)
 {
 	char *domainname = strstr(data, " from ");
 	if (domainname) {
 		*domainname = '\0';
 		domainname += 6;
-	} else if (type == CCS_TRANSITION_CONTROL_NO_KEEP ||
-		   type == CCS_TRANSITION_CONTROL_KEEP) {
+	} else if (type == TRANSITION_NO_KEEP || type == TRANSITION_KEEP) {
 		domainname = data;
 		data = NULL;
 	}
-	return ccs_add_transition_control_entry(ns, domainname, data, type);
+	return add_transition_entry(ns, domainname, data, type);
 }
 
 /**
- * ccs_add_path_group_policy - Add "path_group" entry.
+ * add_path_group_policy - Add "path_group" entry.
  *
  * @ns:   Pointer to "const struct ccs_path_info".
  * @data: Line to parse.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_path_group_policy(const struct ccs_path_info *ns,
-				     char *data)
+static int add_path_group_policy(const struct ccs_path_info *ns, char *data)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return ccs_add_path_group_entry(ns, data, cp);
+	return add_path_group_entry(ns, data, cp);
 }
 
 /**
- * ccs_add_number_group_policy - Add "number_group" entry.
+ * add_number_group_policy - Add "number_group" entry.
  *
  * @data: Line to parse.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_number_group_policy(char *data)
+static int add_number_group_policy(char *data)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return ccs_add_number_group_entry(data, cp);
+	return add_number_group_entry(data, cp);
 }
 
 /**
- * ccs_add_address_group_policy - Add "address_group" entry.
+ * add_address_group_policy - Add "address_group" entry.
  *
  * @data: Line to parse.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_address_group_policy(char *data)
+static int add_address_group_policy(char *data)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return ccs_add_address_group_entry(data, cp);
+	return add_address_group_entry(data, cp);
 }
 
 /**
- * ccs_add_acl_group_policys - Add "acl_group" entry.
+ * add_acl_group_policys - Add "acl_group" entry.
  *
  * @group: Group number.
  * @data:  Line to parse.
  *
  * Returns nothing.
  */
-static void ccs_add_acl_group_policy(const int group, const char *data)
+static void add_acl_group_policy(const int group, const char *data)
 {
 	char **ptr = acl_group_list[group];
 	const int len = acl_group_list_len[group];
@@ -678,44 +640,41 @@
 }
 
 /**
- * ccs_editpolicy_clear_groups - Clear path_group/number_group/address_group/acl_group for reloading policy.
+ * editpolicy_clear_groups - Clear path_group/number_group/address_group/acl_group for reloading policy.
  *
  * Returns nothing.
  */
-static void ccs_editpolicy_clear_groups(void)
+static void editpolicy_clear_groups(void)
 {
 	int i;
 	for (i = 0; i < 256; i++)
 		while (acl_group_list_len[i])
 			free(acl_group_list[i][--acl_group_list_len[i]]);
-	while (ccs_path_group_list_len)
-		free(ccs_path_group_list[--ccs_path_group_list_len].
+	while (path_group_list_len)
+		free(path_group_list[--path_group_list_len].
 		     member_name);
-	while (ccs_number_group_list_len)
-		free(ccs_number_group_list[--ccs_number_group_list_len].
-		     member_name);
-	while (ccs_address_group_list_len)
-		free(ccs_address_group_list[--ccs_address_group_list_len].
-		     member_name);
+	while (number_group_list_len)
+		free(number_group_list[--number_group_list_len].member_name);
+	while (address_group_list_len)
+		free(address_group_list[--address_group_list_len].member_name);
 }
 
 /**
- * ccs_find_path_group_ns - Find "path_group" entry.
+ * find_path_group_ns - Find "path_group" entry.
  *
  * @ns:         Pointer to "const struct ccs_path_info".
  * @group_name: Name of path group.
  *
- * Returns pointer to "struct ccs_path_group_entry" if found, NULL otherwise.
+ * Returns pointer to "struct path_group_entry" if found, NULL otherwise.
  */
-struct ccs_path_group_entry *ccs_find_path_group_ns
+struct path_group_entry *find_path_group_ns
 (const struct ccs_path_info *ns, const char *group_name)
 {
 	int i;
-	for (i = 0; i < ccs_path_group_list_len; i++)
-		if (!ccs_pathcmp(ccs_path_group_list[i].ns, ns) &&
-		    !strcmp(group_name,
-			    ccs_path_group_list[i].group_name->name))
-			return &ccs_path_group_list[i];
+	for (i = 0; i < path_group_list_len; i++)
+		if (!ccs_pathcmp(path_group_list[i].ns, ns) &&
+		    !strcmp(group_name, path_group_list[i].group_name->name))
+			return &path_group_list[i];
 	return NULL;
 }
 
@@ -729,22 +688,22 @@
 static void ccs_assign_djs(const struct ccs_path_info *ns,
 			   const char *domainname, const char *program)
 {
-	const struct ccs_transition_control_entry *d_t =
-		ccs_transition_control(ns, domainname, program);
+	const struct transition_entry *d_t =
+		find_transition(ns, domainname, program);
 	if (!d_t)
 		return;
-	if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE ||
-	    d_t->type == CCS_TRANSITION_CONTROL_RESET) {
+	if (d_t->type == TRANSITION_INITIALIZE ||
+	    d_t->type == TRANSITION_RESET) {
 		char *line;
 		char *cp;
 		ccs_get();
-		if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE)
+		if (d_t->type == TRANSITION_INITIALIZE)
 			line = ccs_shprintf("%s %s", domainname, program);
 		else
 			line = ccs_shprintf("%s <%s>", domainname, program);
 		ccs_normalize_line(line);
 		cp = ccs_strdup(line);
-		if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE)
+		if (d_t->type == TRANSITION_INITIALIZE)
 			line = ccs_shprintf("%s %s", ns->name, program);
 		else
 			line = ccs_shprintf("<%s>", program);
@@ -838,7 +797,7 @@
 static int ccs_show_domain_line(const int index)
 {
 	int tmp_col = 0;
-	const struct ccs_transition_control_entry *transition_control;
+	const struct transition_entry *transition;
 	char *line;
 	const char *sp;
 	const int number = ccs_dp.list[index].number;
@@ -882,16 +841,16 @@
 		printw("%s", ccs_eat(" )"));
 		tmp_col += 2;
 	}
-	transition_control = ccs_dp.list[index].d_t;
-	if (!transition_control || is_djs)
+	transition = ccs_dp.list[index].d_t;
+	if (!transition || is_djs)
 		goto no_transition_control;
 	ccs_get();
 	line = ccs_shprintf(" ( %s%s from %s )",
-			    ccs_transition_type[transition_control->type],
-			    transition_control->program ?
-			    transition_control->program->name : "any",
-			    transition_control->domainname ?
-			    transition_control->domainname->name : "any");
+			    transition_type[transition->type],
+			    transition->program ?
+			    transition->program->name : "any",
+			    transition->domainname ?
+			    transition->domainname->name : "any");
 	printw("%s", ccs_eat(line));
 	tmp_col += strlen(line);
 	ccs_put();
@@ -925,13 +884,13 @@
  */
 static int ccs_show_acl_line(const int index, const int list_indent)
 {
-	const enum ccs_editpolicy_directives directive =
-		ccs_gacl_list[index].directive;
-	const char *cp1 = ccs_directives[directive].alias;
-	const char *cp2 = ccs_gacl_list[index].operand;
-	int len = list_indent - ccs_directives[directive].alias_len;
+	const enum directive_type directive =
+		generic_list[index].directive;
+	const char *cp1 = directive_map[directive].alias;
+	const char *cp2 = generic_list[index].operand;
+	int len = list_indent - directive_map[directive].alias_len;
 	printw("%c%4d: %s ",
-	       ccs_gacl_list[index].selected ? '&' : ' ',
+	       generic_list[index].selected ? '&' : ' ',
 	       index, ccs_eat(cp1));
 	while (len-- > 0)
 		printw("%s", ccs_eat(" "));
@@ -948,12 +907,12 @@
  */
 static int ccs_show_profile_line(const int index)
 {
-	const char *cp = ccs_gacl_list[index].operand;
-	const u16 profile = ccs_gacl_list[index].directive;
+	const char *cp = generic_list[index].operand;
+	const u16 profile = generic_list[index].directive;
 	char number[8] = "";
 	if (profile <= 256)
 		snprintf(number, sizeof(number) - 1, "%3u-", profile);
-	printw("%c%4d: %s", ccs_gacl_list[index].selected ? '&' : ' ',
+	printw("%c%4d: %s", generic_list[index].selected ? '&' : ' ',
 	       index, ccs_eat(number));
 	printw("%s ", ccs_eat(cp));
 	return strlen(number) + strlen(cp) + 8;
@@ -968,9 +927,9 @@
  */
 static int ccs_show_literal_line(const int index)
 {
-	const char *cp = ccs_gacl_list[index].operand;
+	const char *cp = generic_list[index].operand;
 	printw("%c%4d: %s ",
-	       ccs_gacl_list[index].selected ? '&' : ' ',
+	       generic_list[index].selected ? '&' : ' ',
 	       index, ccs_eat(cp));
 	return strlen(cp) + 8;
 }
@@ -987,7 +946,7 @@
 	char *line;
 	unsigned int now;
 	ccs_get();
-	line = ccs_shprintf("%s", ccs_gacl_list[index].operand);
+	line = ccs_shprintf("%s", generic_list[index].operand);
 	if (line[0])
 		printw("%s", ccs_eat(line));
 	now = strlen(line);
@@ -1003,7 +962,7 @@
  *
  * Returns true to continue, false to quit.
  */
-static _Bool ccs_show_command_key(const enum ccs_screen_type screen,
+static _Bool ccs_show_command_key(const enum screen_type screen,
 				  const _Bool readonly)
 {
 	int c;
@@ -1012,7 +971,7 @@
 	printw("Q/q        Quit this editor.\n");
 	printw("R/r        Refresh to the latest information.\n");
 	switch (screen) {
-	case CCS_SCREEN_STAT_LIST:
+	case SCREEN_STAT_LIST:
 		break;
 	default:
 		printw("F/f        Find first.\n");
@@ -1022,7 +981,7 @@
 	printw("W/w        Switch to selected screen.\n");
 	/* printw("Tab        Switch to next screen.\n"); */
 	switch (screen) {
-	case CCS_SCREEN_STAT_LIST:
+	case SCREEN_STAT_LIST:
 		break;
 	default:
 		printw("Insert     Copy an entry at the cursor position to "
@@ -1034,11 +993,11 @@
 		       "position.\n");
 	}
 	switch (screen) {
-	case CCS_SCREEN_NS_LIST:
+	case SCREEN_NS_LIST:
 		if (!readonly)
 			printw("A/a        Add a new namespace.\n");
 		break;
-	case CCS_SCREEN_DOMAIN_LIST:
+	case SCREEN_DOMAIN_LIST:
 		if (ccs_domain_sort_type) {
 			printw("S/s        Set profile number of selected "
 			       "processes.\n");
@@ -1056,12 +1015,12 @@
 			       "cursor position.\n");
 		}
 		break;
-	case CCS_SCREEN_STAT_LIST:
+	case SCREEN_STAT_LIST:
 		if (!readonly)
 			printw("S/s        Set memory quota of selected "
 			       "items.\n");
 		break;
-	case CCS_SCREEN_PROFILE_LIST:
+	case SCREEN_PROFILE_LIST:
 		if (!readonly)
 			printw("S/s        Set mode of selected items.\n");
 		break;
@@ -1069,9 +1028,9 @@
 		break;
 	}
 	switch (screen) {
-	case CCS_SCREEN_EXCEPTION_LIST:
-	case CCS_SCREEN_ACL_LIST:
-	case CCS_SCREEN_MANAGER_LIST:
+	case SCREEN_EXCEPTION_LIST:
+	case SCREEN_ACL_LIST:
+	case SCREEN_MANAGER_LIST:
 		if (!readonly) {
 			printw("A/a        Add a new entry.\n");
 			printw("D/d        Delete selected entries.\n");
@@ -1080,22 +1039,22 @@
 		break;
 	}
 	switch (screen) {
-	case CCS_SCREEN_PROFILE_LIST:
+	case SCREEN_PROFILE_LIST:
 		if (!readonly)
 			printw("A/a        Define a new profile.\n");
 	default:
 		break;
 	}
 	switch (screen) {
-	case CCS_SCREEN_ACL_LIST:
+	case SCREEN_ACL_LIST:
 		printw("O/o        Set selection state to other entries "
 		       "included in an entry at the cursor position.\n");
 		/* Fall through. */
-	case CCS_SCREEN_PROFILE_LIST:
+	case SCREEN_PROFILE_LIST:
 		printw("@          Switch sort type.\n");
 		break;
-	case CCS_SCREEN_DOMAIN_LIST:
-		if (!ccs_offline_mode)
+	case SCREEN_DOMAIN_LIST:
+		if (!offline_mode)
 			printw("@          Switch domain/process list.\n");
 	default:
 		break;
@@ -1134,7 +1093,7 @@
 }
 
 /**
- * ccs_editpolicy_open_write - Wrapper for ccs_open_write().
+ * editpolicy_open_write - Wrapper for ccs_open_write().
  *
  * @filename: File to open for writing.
  *
@@ -1144,7 +1103,7 @@
  * this function sets error line if failed. Also, this function returns NULL if
  * readonly mode.
  */
-static FILE *ccs_editpolicy_open_write(const char *filename)
+static FILE *editpolicy_open_write(const char *filename)
 {
 	FILE *fp = ccs_open_write(filename);
 	if (!fp)
@@ -1153,7 +1112,7 @@
 }
 
 /**
- * ccs_editpolicy_open_read - Wrapper for ccs_open_read().
+ * editpolicy_open_read - Wrapper for ccs_open_read().
  *
  * @filename: File to open for reading.
  *
@@ -1162,7 +1121,7 @@
  * Since CUI policy editor screen provides a line for printing error message,
  * this function sets error line if failed.
  */
-static FILE *ccs_editpolicy_open_read(const char *filename)
+static FILE *editpolicy_open_read(const char *filename)
 {
 	FILE *fp = ccs_open_read(filename);
 	if (!fp)
@@ -1196,13 +1155,13 @@
  *
  * Returns nothing.
  *
- * This function is called when ccs_refresh_interval is non-zero. This function
+ * This function is called when refresh_interval is non-zero. This function
  * marks current screen to reload. Also, this function reenables timer event.
  */
 static void ccs_sigalrm_handler(int sig)
 {
-	ccs_need_reload = true;
-	alarm(ccs_refresh_interval);
+	need_reload = true;
+	alarm(refresh_interval);
 }
 
 /**
@@ -1222,16 +1181,16 @@
 }
 
 /**
- * ccs_transition_control - Find domain transition control.
+ * transition_control - Find domain transition control.
  *
  * @ns:         Pointer to "const struct ccs_path_info".
  * @domainname: Domainname.
  * @program:    Program name.
  *
- * Returns pointer to "const struct ccs_transition_control_entry" if found one,
+ * Returns pointer to "const struct ccs_transition_entry" if found one,
  * NULL otherwise.
  */
-static const struct ccs_transition_control_entry *ccs_transition_control
+static const struct transition_entry *find_transition
 (const struct ccs_path_info *ns, const char *domainname, const char *program)
 {
 	int i;
@@ -1242,11 +1201,10 @@
 	last_name.name = ccs_get_last_word(domainname);
 	ccs_fill_path_info(&domain);
 	ccs_fill_path_info(&last_name);
-	for (type = 0; type < CCS_MAX_TRANSITION_TYPE; type++) {
+	for (type = 0; type < MAX_TRANSITION_TYPE; type++) {
 next:
-		for (i = 0; i < ccs_transition_control_list_len; i++) {
-			struct ccs_transition_control_entry *ptr
-				= &ccs_transition_control_list[i];
+		for (i = 0; i < transition_list_len; i++) {
+			struct transition_entry *ptr = &transition_list[i];
 			if (ptr->type != type)
 				continue;
 			if (ccs_pathcmp(ptr->ns, ns))
@@ -1258,25 +1216,25 @@
 			if (ptr->program &&
 			    strcmp(ptr->program->name, program))
 				continue;
-			if (type == CCS_TRANSITION_CONTROL_NO_RESET) {
+			if (type == TRANSITION_NO_RESET) {
 				/*
 				 * Do not check for reset_domain if
 				 * no_reset_domain matched.
 				 */
-				type = CCS_TRANSITION_CONTROL_NO_INITIALIZE;
+				type = TRANSITION_NO_INITIALIZE;
 				goto next;
 			}
-			if (type == CCS_TRANSITION_CONTROL_NO_INITIALIZE) {
+			if (type == TRANSITION_NO_INITIALIZE) {
 				/*
 				 * Do not check for initialize_domain if
 				 * no_initialize_domain matched.
 				 */
-				type = CCS_TRANSITION_CONTROL_NO_KEEP;
+				type = TRANSITION_NO_KEEP;
 				goto next;
 			}
-			if (type == CCS_TRANSITION_CONTROL_RESET ||
-			    type == CCS_TRANSITION_CONTROL_INITIALIZE ||
-			    type == CCS_TRANSITION_CONTROL_KEEP)
+			if (type == TRANSITION_RESET ||
+			    type == TRANSITION_INITIALIZE ||
+			    type == TRANSITION_KEEP)
 				return ptr;
 			else
 				return NULL;
@@ -1295,14 +1253,14 @@
  */
 static int ccs_profile_entry_compare(const void *a, const void *b)
 {
-	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
-	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
-	const enum ccs_editpolicy_directives a0_d = a0->directive;
-	const enum ccs_editpolicy_directives b0_d = b0->directive;
+	const struct generic_entry *a0 = (struct generic_entry *) a;
+	const struct generic_entry *b0 = (struct generic_entry *) b;
+	const enum directive_type a0_d = a0->directive;
+	const enum directive_type b0_d = b0->directive;
 	const char *a1 = a0->operand;
 	const char *b1 = b0->operand;
-	if (a0_d >= CCS_DIRECTIVE_ADDRESS_GROUP ||
-	    b0_d >= CCS_DIRECTIVE_ADDRESS_GROUP) {
+	if (a0_d >= DIRECTIVE_ADDRESS_GROUP ||
+	    b0_d >= DIRECTIVE_ADDRESS_GROUP) {
 		if (a1[0] == 'P')
 			return -1;
 		if (b1[0] == 'P')
@@ -1327,23 +1285,23 @@
 }
 
 /**
- * ccs_add_generic_entry - Add text lines.
+ * add_generic_entry - Add text lines.
  *
  * @line:      Line to add.
- * @directive: One of values in "enum ccs_editpolicy_directives".
+ * @directive: One of values in "enum directive_type".
  *
  * Returns nothing.
  */
-static void ccs_add_generic_entry(const char *line, const enum
-				  ccs_editpolicy_directives directive)
+static void add_generic_entry(const char *line, const enum directive_type
+			      directive)
 {
-	struct ccs_generic_acl *ptr;
+	struct generic_entry *ptr;
 	int i;
-	for (i = 0; i < ccs_gacl_list_count; i++)
-		if (ccs_gacl_list[i].directive == directive &&
-		    !strcmp(line, ccs_gacl_list[i].operand))
+	for (i = 0; i < generic_list_len; i++)
+		if (generic_list[i].directive == directive &&
+		    !strcmp(line, generic_list[i].operand))
 			return;
-	ptr = ccs_alloc(ccs_gacl_list, sizeof(*ptr), ccs_gacl_list_count);
+	ptr = ccs_alloc(generic_list, sizeof(*ptr), generic_list_len);
 	ptr->directive = directive;
 	ptr->operand = ccs_strdup(line);
 }
@@ -1358,46 +1316,46 @@
 	FILE *fp = NULL;
 	_Bool flag = false;
 	const _Bool is_kernel_ns = !strcmp(ccs_current_ns->name, "<kernel>");
-	while (ccs_gacl_list_count)
-		free((void *) ccs_gacl_list[--ccs_gacl_list_count].operand);
-	if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+	while (generic_list_len)
+		free((void *) generic_list[--generic_list_len].operand);
+	if (current_screen == SCREEN_ACL_LIST) {
 		if (ccs_network_mode)
 			/* We can read after write. */
-			fp = ccs_editpolicy_open_write(ccs_policy_file);
+			fp = editpolicy_open_write(policy_file);
 		else
 			/* Don't set error message if failed. */
-			fp = fopen(ccs_policy_file, "r+");
+			fp = fopen(policy_file, "r+");
 		if (fp) {
 			if (ccs_domain_sort_type)
 				fprintf(fp, "select pid=%u\n",
-					ccs_current_pid);
+					current_pid);
 			else
 				fprintf(fp, "select domain=%s\n",
-					ccs_current_domain);
+					current_domain);
 			if (ccs_network_mode)
 				fputc(0, fp);
 			fflush(fp);
 		}
-	} else if (ccs_current_screen == CCS_SCREEN_NS_LIST) {
-		ccs_add_generic_entry("<kernel>", CCS_DIRECTIVE_NONE);
+	} else if (current_screen == SCREEN_NS_LIST) {
+		add_generic_entry("<kernel>", DIRECTIVE_NONE);
 	}
 	if (!fp)
-		fp = ccs_editpolicy_open_read(ccs_policy_file);
+		fp = editpolicy_open_read(policy_file);
 	if (!fp) {
-		ccs_set_error(ccs_policy_file);
+		ccs_set_error(policy_file);
 		return;
 	}
-	ccs_freadline_raw = ccs_current_screen == CCS_SCREEN_STAT_LIST;
+	ccs_freadline_raw = current_screen == SCREEN_STAT_LIST;
 	ccs_get();
 	while (true) {
 		char *line = ccs_freadline_unpack(fp);
-		enum ccs_editpolicy_directives directive;
+		enum directive_type directive;
 		char *cp;
 		if (!line)
 			break;
-		if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+		if (current_screen == SCREEN_ACL_LIST) {
 			if (ccs_domain_def(line)) {
-				flag = !strcmp(line, ccs_current_domain);
+				flag = !strcmp(line, current_domain);
 				continue;
 			}
 			if (!flag || !line[0] ||
@@ -1407,8 +1365,8 @@
 			if (!line[0])
 				continue;
 		}
-		if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST ||
-		    ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
+		if (current_screen == SCREEN_EXCEPTION_LIST ||
+		    current_screen == SCREEN_PROFILE_LIST) {
 			if (*line == '<') {
 				cp = strchr(line, ' ');
 				if (!cp++ || !ccs_is_current_namespace(line))
@@ -1417,37 +1375,37 @@
 			} else if (!is_kernel_ns)
 				continue;
 		}
-		switch (ccs_current_screen) {
-		case CCS_SCREEN_EXCEPTION_LIST:
-			directive = ccs_find_directive(true, line);
-			if (directive == CCS_DIRECTIVE_NONE)
+		switch (current_screen) {
+		case SCREEN_EXCEPTION_LIST:
+			directive = find_directive(true, line);
+			if (directive == DIRECTIVE_NONE)
 				continue;
-			/* Remember groups for ccs_editpolicy_optimize(). */
-			if (directive != CCS_DIRECTIVE_PATH_GROUP &&
-			    directive != CCS_DIRECTIVE_NUMBER_GROUP &&
-			    directive != CCS_DIRECTIVE_ADDRESS_GROUP &&
-			    (directive < CCS_DIRECTIVE_ACL_GROUP_000 ||
-			     directive > CCS_DIRECTIVE_ACL_GROUP_255))
+			/* Remember groups for editpolicy_optimize(). */
+			if (directive != DIRECTIVE_PATH_GROUP &&
+			    directive != DIRECTIVE_NUMBER_GROUP &&
+			    directive != DIRECTIVE_ADDRESS_GROUP &&
+			    (directive < DIRECTIVE_ACL_GROUP_000 ||
+			     directive > DIRECTIVE_ACL_GROUP_255))
 				break;
 			cp = ccs_strdup(line);
-			if (directive == CCS_DIRECTIVE_PATH_GROUP)
-				ccs_add_path_group_policy(ccs_current_ns, cp);
-			else if (directive == CCS_DIRECTIVE_NUMBER_GROUP)
-				ccs_add_number_group_policy(cp);
-			else if (directive == CCS_DIRECTIVE_ADDRESS_GROUP)
-				ccs_add_address_group_policy(cp);
+			if (directive == DIRECTIVE_PATH_GROUP)
+				add_path_group_policy(ccs_current_ns, cp);
+			else if (directive == DIRECTIVE_NUMBER_GROUP)
+				add_number_group_policy(cp);
+			else if (directive == DIRECTIVE_ADDRESS_GROUP)
+				add_address_group_policy(cp);
 			else
-				ccs_add_acl_group_policy
-					(directive -
-					 CCS_DIRECTIVE_ACL_GROUP_000, cp);
+				add_acl_group_policy
+					(directive - DIRECTIVE_ACL_GROUP_000,
+					 cp);
 			free(cp);
 			break;
-		case CCS_SCREEN_ACL_LIST:
-			directive = ccs_find_directive(true, line);
-			if (directive == CCS_DIRECTIVE_NONE)
+		case SCREEN_ACL_LIST:
+			directive = find_directive(true, line);
+			if (directive == DIRECTIVE_NONE)
 				continue;
 			break;
-		case CCS_SCREEN_PROFILE_LIST:
+		case SCREEN_PROFILE_LIST:
 			cp = strchr(line, '-');
 			if (cp) {
 				*cp++ = '\0';
@@ -1456,7 +1414,7 @@
 			} else
 				directive = (u16) -1;
 			break;
-		case CCS_SCREEN_NS_LIST:
+		case SCREEN_NS_LIST:
 			if (*line != '<')
 				continue;
 			cp = strchr(line, ' ');
@@ -1467,52 +1425,47 @@
 				continue;
 			/* Fall through. */
 		default:
-			directive = CCS_DIRECTIVE_NONE;
+			directive = DIRECTIVE_NONE;
 			break;
 		}
-		ccs_add_generic_entry(line, directive);
+		add_generic_entry(line, directive);
 	}
 	ccs_put();
 	ccs_freadline_raw = false;
 	fclose(fp);
-	switch (ccs_current_screen) {
-	case CCS_SCREEN_ACL_LIST:
-		qsort(ccs_gacl_list, ccs_gacl_list_count,
-		      sizeof(struct ccs_generic_acl), ccs_gacl_compare);
+	switch (current_screen) {
+	case SCREEN_ACL_LIST:
+	case SCREEN_EXCEPTION_LIST:
+		qsort(generic_list, generic_list_len,
+		      sizeof(struct generic_entry), ccs_gacl_compare);
 		break;
-	case CCS_SCREEN_EXCEPTION_LIST:
-		qsort(ccs_gacl_list, ccs_gacl_list_count,
-		      sizeof(struct ccs_generic_acl),
-		      ccs_gacl_compare0);
+	case SCREEN_PROFILE_LIST:
+		qsort(generic_list, generic_list_len,
+		      sizeof(struct generic_entry), ccs_profile_entry_compare);
 		break;
-	case CCS_SCREEN_PROFILE_LIST:
-		qsort(ccs_gacl_list, ccs_gacl_list_count,
-		      sizeof(struct ccs_generic_acl),
-		      ccs_profile_entry_compare);
+	case SCREEN_STAT_LIST:
 		break;
-	case CCS_SCREEN_STAT_LIST:
-		break;
 	default:
-		qsort(ccs_gacl_list, ccs_gacl_list_count,
-		      sizeof(struct ccs_generic_acl), ccs_string_acl_compare);
+		qsort(generic_list, generic_list_len,
+		      sizeof(struct generic_entry), ccs_string_acl_compare);
 	}
 }
 
 /**
- * ccs_add_transition_control_entry - Add "reset_domain"/"no_reset_domain"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/ "no_keep_domain" entries.
+ * add_transition_entry - Add "reset_domain"/"no_reset_domain"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/ "no_keep_domain" entries.
  *
  * @ns:         Pointer to "const struct ccs_path_info".
  * @domainname: Domainname.
  * @program:    Program name.
- * @type:       One of values in "enum ccs_transition_type".
+ * @type:       One of values in "enum transition_type".
  *
  * Returns 0 on success, -EINVAL otherwise.
  */
-static int ccs_add_transition_control_entry
+static int add_transition_entry
 (const struct ccs_path_info *ns, const char *domainname, const char *program,
- const enum ccs_transition_type type)
+ const enum transition_type type)
 {
-	struct ccs_transition_control_entry *ptr;
+	struct transition_entry *ptr;
 	if (program && strcmp(program, "any"))
 		if (!ccs_correct_path(program))
 			return -EINVAL;
@@ -1520,8 +1473,7 @@
 		if (!ccs_correct_domain(domainname))
 			if (!ccs_correct_path(domainname))
 				return -EINVAL;
-	ptr = ccs_alloc(ccs_transition_control_list, sizeof(*ptr),
-			ccs_transition_control_list_len);
+	ptr = ccs_alloc(transition_list, sizeof(*ptr), transition_list_len);
 	ptr->ns = ns;
 	if (program && strcmp(program, "any"))
 		ptr->program = ccs_savename(program);
@@ -1532,7 +1484,7 @@
 }
 
 /**
- * ccs_add_path_group_entry - Add "path_group" entry.
+ * add_path_group_entry - Add "path_group" entry.
  *
  * @ns:          Pointer to "const struct ccs_path_info".
  * @group_name:  Name of address group.
@@ -1540,21 +1492,21 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_path_group_entry(const struct ccs_path_info *ns,
-				    const char *group_name,
-				    const char *member_name)
+static int add_path_group_entry(const struct ccs_path_info *ns,
+				const char *group_name,
+				const char *member_name)
 {
 	const struct ccs_path_info *saved_group_name;
 	const struct ccs_path_info *saved_member_name;
 	int i;
 	int j;
-	struct ccs_path_group_entry *group = NULL;
+	struct path_group_entry *group = NULL;
 	if (!ccs_correct_word(group_name) || !ccs_correct_word(member_name))
 		return -EINVAL;
 	saved_group_name = ccs_savename(group_name);
 	saved_member_name = ccs_savename(member_name);
-	for (i = 0; i < ccs_path_group_list_len; i++) {
-		group = &ccs_path_group_list[i];
+	for (i = 0; i < path_group_list_len; i++) {
+		group = &path_group_list[i];
 		if (group->ns != ns)
 			continue;
 		if (saved_group_name != group->group_name)
@@ -1564,9 +1516,9 @@
 				return 0;
 		break;
 	}
-	if (i == ccs_path_group_list_len) {
-		group = ccs_alloc(ccs_path_group_list, sizeof(*group),
-				  ccs_path_group_list_len);
+	if (i == path_group_list_len) {
+		group = ccs_alloc(path_group_list, sizeof(*group),
+				  path_group_list_len);
 		group->ns = ns;
 		group->group_name = saved_group_name;
 	}
@@ -1576,28 +1528,28 @@
 }
 
 /**
- * ccs_add_number_group_entry - Add "number_group" entry.
+ * add_number_group_entry - Add "number_group" entry.
  *
  * @group_name:  Name of number group.
  * @member_name: Number string.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_number_group_entry(const char *group_name,
-				      const char *member_name)
+static int add_number_group_entry(const char *group_name,
+				  const char *member_name)
 {
 	const struct ccs_path_info *saved_group_name;
 	int i;
 	int j;
 	struct ccs_number_entry entry;
-	struct ccs_number_group_entry *group = NULL;
+	struct number_group_entry *group = NULL;
 	if (ccs_parse_number(member_name, &entry))
 		return -EINVAL;
 	if (!ccs_correct_word(group_name))
 		return -EINVAL;
 	saved_group_name = ccs_savename(group_name);
-	for (i = 0; i < ccs_number_group_list_len; i++) {
-		group = &ccs_number_group_list[i];
+	for (i = 0; i < number_group_list_len; i++) {
+		group = &number_group_list[i];
 		if (saved_group_name != group->group_name)
 			continue;
 		for (j = 0; j < group->member_name_len; j++)
@@ -1606,9 +1558,9 @@
 				return 0;
 		break;
 	}
-	if (i == ccs_number_group_list_len) {
-		group = ccs_alloc(ccs_number_group_list, sizeof(*group),
-				  ccs_number_group_list_len);
+	if (i == number_group_list_len) {
+		group = ccs_alloc(number_group_list, sizeof(*group),
+				  number_group_list_len);
 		group->group_name = saved_group_name;
 	}
 	*ccs_alloc(group->member_name, sizeof(entry), group->member_name_len) =
@@ -1617,28 +1569,28 @@
 }
 
 /**
- * ccs_add_address_group_entry - Add "address_group" entry.
+ * add_address_group_entry - Add "address_group" entry.
  *
  * @group_name:  Name of address group.
  * @member_name: Address string.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_address_group_entry(const char *group_name,
-				       const char *member_name)
+static int add_address_group_entry(const char *group_name,
+				   const char *member_name)
 {
 	const struct ccs_path_info *saved_group_name;
 	int i;
 	int j;
 	struct ccs_ip_address_entry entry;
-	struct ccs_address_group_entry *group = NULL;
+	struct address_group_entry *group = NULL;
 	if (ccs_parse_ip(member_name, &entry))
 		return -EINVAL;
 	if (!ccs_correct_word(group_name))
 		return -EINVAL;
 	saved_group_name = ccs_savename(group_name);
-	for (i = 0; i < ccs_address_group_list_len; i++) {
-		group = &ccs_address_group_list[i];
+	for (i = 0; i < address_group_list_len; i++) {
+		group = &address_group_list[i];
 		if (saved_group_name != group->group_name)
 			continue;
 		for (j = 0; j < group->member_name_len; j++)
@@ -1647,9 +1599,9 @@
 				return 0;
 		break;
 	}
-	if (i == ccs_address_group_list_len) {
-		group = ccs_alloc(ccs_address_group_list, sizeof(*group),
-				  ccs_address_group_list_len);
+	if (i == address_group_list_len) {
+		group = ccs_alloc(address_group_list, sizeof(*group),
+				  address_group_list_len);
 		group->group_name = saved_group_name;
 	}
 	*ccs_alloc(group->member_name, sizeof(entry), group->member_name_len) =
@@ -1665,14 +1617,14 @@
 static int ccs_jump_list_len = 0;
 
 /**
- * ccs_add_condition_domain_transition - Add auto_domain_transition= part.
+ * add_condition_domain_transition - Add auto_domain_transition= part.
  *
  * @line:  Line to parse.
  * @index: Current domain's index.
  *
  * Returns nothing.
  */
-static void ccs_add_condition_domain_transition(char *line, const int index)
+static void add_condition_domain_transition(char *line, const int index)
 {
 	static char domainname[4096];
 	int source;
@@ -1697,14 +1649,14 @@
 }
 
 /**
- * ccs_add_acl_domain_transition - Add task acl.
+ * add_acl_domain_transition - Add task acl.
  *
  * @line:  Line to parse.
  * @index: Current domain's index.
  *
  * Returns nothing.
  */
-static void ccs_add_acl_domain_transition(char *line, const int index)
+static void add_acl_domain_transition(char *line, const int index)
 {
 	static char domainname[4096];
 	int pos;
@@ -1726,12 +1678,8 @@
 }
 
 /* Structure for holding domain transition preference. */
-static struct ccs_transition_preference {
-	int index;
-	char *program;
-	char *domainname;
-} *ccs_transition_preference_list = NULL;
-static int ccs_transition_preference_list_len = 0;
+static struct transition_preference *transition_preference_list = NULL;
+static int transition_preference_list_len = 0;
 
 /**
  * ccs_parse_transition_preference - Parse transition preference.
@@ -1745,7 +1693,7 @@
 static _Bool ccs_parse_transition_preference(char *program, char *domainname,
 					     const int index)
 {
-	struct ccs_transition_preference *ptr;
+	struct transition_preference *ptr;
 	char *cp = strchr(domainname, ' ');
 	if (*domainname == '<')
 		goto add;
@@ -1757,8 +1705,8 @@
 		goto add;
 	return false;
 add:
-	ptr = ccs_alloc(ccs_transition_preference_list, sizeof(*ptr),
-			ccs_transition_preference_list_len);
+	ptr = ccs_alloc(transition_preference_list, sizeof(*ptr),
+			transition_preference_list_len);
 	ptr->index = index;
 	ptr->domainname = ccs_strdup(domainname);
 	ptr->program = ccs_strdup(program);
@@ -1767,7 +1715,7 @@
 }
 
 /**
- * ccs_make_transition_preference - Create transition preference.
+ * make_transition_preference - Create transition preference.
  *
  * @program:    Pathname or path_group.
  * @domainname: Domainname or transition preference.
@@ -1775,14 +1723,14 @@
  *
  * Returns nothing.
  */
-static void ccs_make_transition_preference(char *program, char *domainname,
-					   const int index)
+static void make_transition_preference(char *program, char *domainname,
+				       const int index)
 {
 	static char buffer[4096];
 	const char *self = ccs_dp.list[index].domainname->name;
 	int i;
-	struct ccs_path_group_entry *group = *program == '@' ?
-		ccs_find_path_group_ns(ccs_get_ns(self), program + 1) : NULL;
+	struct path_group_entry *group = *program == '@' ?
+		find_path_group_ns(ccs_get_ns(self), program + 1) : NULL;
 	const int j = group ? group->member_name_len : 0;
 	buffer[sizeof(buffer) - 1] = '\0';
 	if (*domainname == '<')
@@ -1794,7 +1742,7 @@
 			for (i = 0; i < j; i++) {
 				snprintf(buffer, sizeof(buffer) - 1, "<%s>",
 					 group->member_name[i]->name);
-				ccs_add_acl_domain_transition(buffer, index);
+				add_acl_domain_transition(buffer, index);
 			}
 			return;
 		}
@@ -1811,7 +1759,7 @@
 					continue;
 				snprintf(buffer, sizeof(buffer) - 1, "%s %s",
 					 tmp, cp2);
-				ccs_add_acl_domain_transition(buffer, index);
+				add_acl_domain_transition(buffer, index);
 			}
 			free(tmp);
 			return;
@@ -1826,7 +1774,7 @@
 					continue;
 				snprintf(buffer, sizeof(buffer) - 1, "%s %s",
 					 self, cp);
-				ccs_add_acl_domain_transition(buffer, index);
+				add_acl_domain_transition(buffer, index);
 			}
 			return;
 		}
@@ -1840,7 +1788,7 @@
 	} else
 		snprintf(buffer, sizeof(buffer) - 1, "%s %s", self,
 			 domainname);
-	ccs_add_acl_domain_transition(buffer, index);
+	add_acl_domain_transition(buffer, index);
 }
 
 /**
@@ -1858,7 +1806,7 @@
 				  const int index, const bool parse_flags)
 {
 	_Bool exec = false;
-	ccs_add_condition_domain_transition(line, index);
+	add_condition_domain_transition(line, index);
 	if (ccs_str_starts(line, "task auto_execute_handler ") ||
 	    ccs_str_starts(line, "task denied_execute_handler ") ||
 	    (exec = true, ccs_str_starts(line, "file execute "))) {
@@ -1873,10 +1821,10 @@
 				return;
 		}
 		if ((exec && *line == '@') || ccs_correct_path(line))
-			ccs_add_string_entry3(line, index);
+			add_string_entry3(line, index);
 	} else if (ccs_str_starts(line, "task auto_domain_transition ") ||
 		   ccs_str_starts(line, "task manual_domain_transition ")) {
-		ccs_add_acl_domain_transition(line, index);
+		add_acl_domain_transition(line, index);
 	} else if (parse_flags) {
 		unsigned int idx;
 		if (sscanf(line, "use_profile %u", &idx) == 1 && idx < 256)
@@ -1897,25 +1845,26 @@
 static void ccs_parse_exception_line(const struct ccs_path_info *ns,
 				     char *line)
 {
+	int index;
 	unsigned int group;
-	for (group = 0; group < CCS_MAX_TRANSITION_TYPE; group++) {
-		if (!ccs_str_starts(line, ccs_transition_type[group]))
+	for (index = 0; index < MAX_TRANSITION_TYPE; index++) {
+		if (!ccs_str_starts(line, transition_type[index]))
 			continue;
-		ccs_add_transition_control_policy(ns, line, group);
+		add_transition_policy(ns, line, index);
 		return;
 	}
 	if (ccs_str_starts(line, "path_group "))
-		ccs_add_path_group_policy(ns, line);
+		add_path_group_policy(ns, line);
 	else if (ccs_str_starts(line, "address_group "))
-		ccs_add_address_group_policy(line);
+		add_address_group_policy(line);
 	else if (ccs_str_starts(line, "number_group "))
-		ccs_add_number_group_policy(line);
+		add_number_group_policy(line);
 	else if (sscanf(line, "acl_group %u", &group) == 1 && group < 256) {
 		int index;
 		line = strchr(line + 10, ' ');
 		if (!line++)
 			return;
-		ccs_add_acl_group_policy(group, line);
+		add_acl_group_policy(group, line);
 		for (index = 0; index < ccs_dp.list_len; index++) {
 			char *cp;
 			const struct ccs_domain *ptr = &ccs_dp.list[index];
@@ -1950,8 +1899,8 @@
 	while (ccs_jump_list_len)
 		free(ccs_jump_list[--ccs_jump_list_len]);
 	ccs_clear_domain_policy3();
-	ccs_transition_control_list_len = 0;
-	ccs_editpolicy_clear_groups();
+	transition_list_len = 0;
+	editpolicy_clear_groups();
 	if (!ccs_kernel_ns)
 		ccs_kernel_ns = ccs_savename("<kernel>");
 	ns = ccs_kernel_ns;
@@ -1960,7 +1909,7 @@
 	fp = NULL;
 	if (ccs_network_mode)
 		/* We can read after write. */
-		fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
+		fp = editpolicy_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
 	else
 		/* Don't set error message if failed. */
 		fp = fopen(CCS_PROC_POLICY_DOMAIN_POLICY, "r+");
@@ -1970,7 +1919,7 @@
 			fputc(0, fp);
 		fflush(fp);
 	} else {
-		fp = ccs_editpolicy_open_read(CCS_PROC_POLICY_DOMAIN_POLICY);
+		fp = editpolicy_open_read(CCS_PROC_POLICY_DOMAIN_POLICY);
 	}
 	if (fp) {
 		index = EOF;
@@ -1993,7 +1942,7 @@
 	}
 
 	/* Load domain transition related entries and group entries. */
-	fp = ccs_editpolicy_open_read(CCS_PROC_POLICY_EXCEPTION_POLICY);
+	fp = editpolicy_open_read(CCS_PROC_POLICY_EXCEPTION_POLICY);
 	if (fp) {
 		ccs_get();
 		while (true) {
@@ -2016,17 +1965,17 @@
 	}
 
 	/* Create domain transition preference. */
-	for (i = 0; i < ccs_transition_preference_list_len; i++) {
-		struct ccs_transition_preference *ptr =
-			&ccs_transition_preference_list[i];
-		ccs_make_transition_preference(ptr->program, ptr->domainname,
-					       ptr->index);
+	for (i = 0; i < transition_preference_list_len; i++) {
+		struct transition_preference *ptr =
+			&transition_preference_list[i];
+		make_transition_preference(ptr->program, ptr->domainname,
+					   ptr->index);
 		free(ptr->domainname);
 		free(ptr->program);
 	}
-	free(ccs_transition_preference_list);
-	ccs_transition_preference_list= NULL;
-	ccs_transition_preference_list_len = 0;
+	free(transition_preference_list);
+	transition_preference_list= NULL;
+	transition_preference_list_len = 0;
 
 	/*
 	 * Domain jump sources by "task manual_domain_transition" keyword or
@@ -2053,12 +2002,12 @@
 		ns = ccs_get_ns(domainname);
 		for (i = 0; i < max_count; i++) {
 			const char *name = string_ptr[i]->name;
-			struct ccs_path_group_entry *group;
+			struct path_group_entry *group;
 			if (name[0] != '@') {
 				ccs_assign_djs(ns, domainname, name);
 				continue;
 			}
-			group = ccs_find_path_group_ns(ns, name + 1);
+			group = find_path_group_ns(ns, name + 1);
 			if (!group)
 				continue;
 			for (j = 0; j < group->member_name_len; j++) {
@@ -2124,10 +2073,9 @@
 		if (!cp++ || strchr(cp, ' '))
 			continue;
 		/* Check "no_initialize_domain $program from any" entry. */
-		for (i = 0; i < ccs_transition_control_list_len; i++) {
-			struct ccs_transition_control_entry *ptr
-				= &ccs_transition_control_list[i];
-			if (ptr->type != CCS_TRANSITION_CONTROL_NO_INITIALIZE)
+		for (i = 0; i < transition_list_len; i++) {
+			struct transition_entry *ptr = &transition_list[i];
+			if (ptr->type != TRANSITION_NO_INITIALIZE)
 				continue;
 			if (!ccs_is_same_namespace(domainname, ptr->ns))
 				continue;
@@ -2137,15 +2085,14 @@
 				continue;
 			break;
 		}
-		if (i < ccs_transition_control_list_len)
+		if (i < transition_list_len)
 			continue;
 		/*
 		 * Check "initialize_domain $program from $domainname" entry.
 		 */
-		for (i = 0; i < ccs_transition_control_list_len; i++) {
-			struct ccs_transition_control_entry *ptr
-				= &ccs_transition_control_list[i];
-			if (ptr->type != CCS_TRANSITION_CONTROL_INITIALIZE)
+		for (i = 0; i < transition_list_len; i++) {
+			struct transition_entry *ptr = &transition_list[i];
+			if (ptr->type != TRANSITION_INITIALIZE)
 				continue;
 			if (!ccs_is_same_namespace(domainname, ptr->ns))
 				continue;
@@ -2153,7 +2100,7 @@
 				continue;
 			break;
 		}
-		if (i < ccs_transition_control_list_len)
+		if (i < transition_list_len)
 			ccs_dp.list[index].is_djt = true;
 	}
 
@@ -2169,10 +2116,9 @@
 		if (domain->target)
 			continue;
 		/* Check "no_keep_domain any from $domainname" entry. */
-		for (i = 0; i < ccs_transition_control_list_len; i++) {
-			struct ccs_transition_control_entry *ptr
-				= &ccs_transition_control_list[i];
-			if (ptr->type != CCS_TRANSITION_CONTROL_NO_KEEP)
+		for (i = 0; i < transition_list_len; i++) {
+			struct transition_entry *ptr = &transition_list[i];
+			if (ptr->type != TRANSITION_NO_KEEP)
 				continue;
 			if (!ccs_is_same_namespace(name->name, ptr->ns))
 				continue;
@@ -2183,13 +2129,12 @@
 			    !strcmp(ptr->domainname->name, last_name))
 				break;
 		}
-		if (i < ccs_transition_control_list_len)
+		if (i < transition_list_len)
 			continue;
 		/* Check "keep_domain $program from $domainname" entry. */
-		for (i = 0; i < ccs_transition_control_list_len; i++) {
-			struct ccs_transition_control_entry *ptr
-				= &ccs_transition_control_list[i];
-			if (ptr->type != CCS_TRANSITION_CONTROL_KEEP)
+		for (i = 0; i < transition_list_len; i++) {
+			struct transition_entry *ptr = &transition_list[i];
+			if (ptr->type != TRANSITION_KEEP)
 				continue;
 			if (!ccs_is_same_namespace(name->name, ptr->ns))
 				continue;
@@ -2198,7 +2143,7 @@
 			    !strcmp(ptr->domainname->name, last_name))
 				break;
 		}
-		if (i < ccs_transition_control_list_len)
+		if (i < transition_list_len)
 			ccs_dp.list[index].is_dk = true;
 	}
 
@@ -2233,7 +2178,7 @@
 		while (true) {
 			const struct ccs_domain *ptr =
 				ccs_find_domain3_by_name(line);
-			const struct ccs_transition_control_entry *d_t;
+			const struct transition_entry *d_t;
 			char *cp;
 			/* Stop traversal if current is domain jump target. */
 			if (ptr && ptr->is_djt)
@@ -2243,7 +2188,7 @@
 				*cp++ = '\0';
 			else
 				break;
-			d_t = ccs_transition_control(ns, line, cp);
+			d_t = find_transition(ns, line, cp);
 			if (d_t)
 				domain->d_t = d_t;
 		}
@@ -2331,16 +2276,16 @@
  */
 static void ccs_show_list(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
 	int ccs_list_indent;
 	const int offset = ptr->current;
 	int i;
 	int tmp_col;
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST)
+	if (current_screen == SCREEN_DOMAIN_LIST)
 		ccs_list_item_count = ccs_domain_sort_type ?
 			ccs_task_list_len : ccs_dp.list_len;
 	else
-		ccs_list_item_count = ccs_gacl_list_count;
+		ccs_list_item_count = generic_list_len;
 	clear();
 	move(0, 0);
 	if (ccs_window_height < CCS_HEADER_LINES + 1) {
@@ -2350,8 +2295,8 @@
 		return;
 	}
 	/* add color */
-	ccs_editpolicy_color_change(ccs_editpolicy_color_head(), true);
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+	editpolicy_color_change(editpolicy_color_head(), true);
+	if (current_screen == SCREEN_DOMAIN_LIST) {
 		if (ccs_domain_sort_type) {
 			i = ccs_task_list_len;
 			printw("<<< Process State Viewer >>>"
@@ -2365,35 +2310,35 @@
 		}
 	} else {
 		i = ccs_list_item_count;
-		printw("<<< %s >>>      %d entr%s ", ccs_list_caption,
+		printw("<<< %s >>>      %d entr%s ", list_caption,
 		       i, i > 1 ? "ies" : "y");
-		i = ccs_count2(ccs_gacl_list, ccs_gacl_list_count);
+		i = ccs_count2(generic_list, generic_list_len);
 	}
 	if (i)
 		printw("(%u selected)", i);
 	printw("   '?' for help");
 	/* add color */
-	ccs_editpolicy_color_change(ccs_editpolicy_color_head(), false);
+	editpolicy_color_change(editpolicy_color_head(), false);
 	ccs_eat_col = ptr->x;
 	ccs_max_col = 0;
-	if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+	if (current_screen == SCREEN_ACL_LIST) {
 		char *line;
 		ccs_get();
-		line = ccs_shprintf("%s", ccs_eat(ccs_current_domain));
-		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		line = ccs_shprintf("%s", ccs_eat(current_domain));
+		editpolicy_attr_change(A_REVERSE, true);  /* add color */
 		move(2, 0);
 		printw("%s", line);
-		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		editpolicy_attr_change(A_REVERSE, false); /* add color */
 		ccs_put();
 	}
 	ccs_list_indent = 0;
-	switch (ccs_current_screen) {
-	case CCS_SCREEN_EXCEPTION_LIST:
-	case CCS_SCREEN_ACL_LIST:
+	switch (current_screen) {
+	case SCREEN_EXCEPTION_LIST:
+	case SCREEN_ACL_LIST:
 		for (i = 0; i < ccs_list_item_count; i++) {
-			const enum ccs_editpolicy_directives directive =
-				ccs_gacl_list[i].directive;
-			const int len = ccs_directives[directive].alias_len;
+			const enum directive_type directive =
+				generic_list[i].directive;
+			const int len = directive_map[directive].alias_len;
 			if (len > ccs_list_indent)
 				ccs_list_indent = len;
 		}
@@ -2407,21 +2352,21 @@
 		if (index >= ccs_list_item_count)
 			break;
 		move(CCS_HEADER_LINES + i, 0);
-		switch (ccs_current_screen) {
-		case CCS_SCREEN_DOMAIN_LIST:
+		switch (current_screen) {
+		case SCREEN_DOMAIN_LIST:
 			if (!ccs_domain_sort_type)
 				tmp_col = ccs_show_domain_line(index);
 			else
 				tmp_col = ccs_show_process_line(index);
 			break;
-		case CCS_SCREEN_EXCEPTION_LIST:
-		case CCS_SCREEN_ACL_LIST:
+		case SCREEN_EXCEPTION_LIST:
+		case SCREEN_ACL_LIST:
 			tmp_col = ccs_show_acl_line(index, ccs_list_indent);
 			break;
-		case CCS_SCREEN_PROFILE_LIST:
+		case SCREEN_PROFILE_LIST:
 			tmp_col = ccs_show_profile_line(index);
 			break;
-		case CCS_SCREEN_STAT_LIST:
+		case SCREEN_STAT_LIST:
 			tmp_col = ccs_show_stat_line(index);
 			break;
 		default:
@@ -2443,7 +2388,7 @@
  */
 static void ccs_resize_window(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
 	getmaxyx(stdscr, ccs_window_height, ccs_window_width);
 	ccs_body_lines = ccs_window_height - CCS_HEADER_LINES;
 	if (ccs_body_lines <= ptr->y)
@@ -2459,7 +2404,7 @@
  */
 static void ccs_up_arrow_key(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
 	if (ptr->y > 0) {
 		ptr->y--;
 		ccs_show_current();
@@ -2476,7 +2421,7 @@
  */
 static void ccs_down_arrow_key(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
 	if (ptr->y < ccs_body_lines - 1) {
 		if (ptr->current + ptr->y < ccs_list_item_count - 1) {
 			ptr->y++;
@@ -2495,7 +2440,7 @@
  */
 static void ccs_page_up_key(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
 	int p0 = ptr->current;
 	int p1 = ptr->y;
 	_Bool refresh;
@@ -2525,7 +2470,7 @@
  */
 static void ccs_page_down_key(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
 	int ccs_count = ccs_list_item_count - 1;
 	int p0 = ptr->current;
 	int p1 = ptr->y;
@@ -2552,15 +2497,15 @@
 }
 
 /**
- * ccs_editpolicy_get_current - Get currently selected line's index.
+ * editpolicy_get_current - Get currently selected line's index.
  *
  * Returns index for currently selected line on success, EOF otherwise.
  *
  * If current screen has no entry, this function returns EOF.
  */
-int ccs_editpolicy_get_current(void)
+int editpolicy_get_current(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
 	int ccs_count = ccs_list_item_count;
 	const int p0 = ptr->current;
 	const int p1 = ptr->y;
@@ -2582,11 +2527,11 @@
  */
 static void ccs_show_current(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST &&
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
+	if (current_screen == SCREEN_DOMAIN_LIST &&
 	    !ccs_domain_sort_type) {
 		char *line;
-		const int index = ccs_editpolicy_get_current();
+		const int index = editpolicy_get_current();
 		ccs_get();
 		ccs_eat_col = ptr->x;
 		if (index >= 0) {
@@ -2604,13 +2549,13 @@
 			line[ccs_window_width] = '\0';
 		move(2, 0);
 		clrtoeol();
-		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		editpolicy_attr_change(A_REVERSE, true);  /* add color */
 		printw("%s", line);
-		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		editpolicy_attr_change(A_REVERSE, false); /* add color */
 		ccs_put();
 	}
-	if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST ||
-	    ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
+	if (current_screen == SCREEN_EXCEPTION_LIST ||
+	    current_screen == SCREEN_PROFILE_LIST) {
 		char *line;
 		ccs_get();
 		ccs_eat_col = ptr->x;
@@ -2619,13 +2564,13 @@
 			line[ccs_window_width] = '\0';
 		move(2, 0);
 		clrtoeol();
-		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		editpolicy_attr_change(A_REVERSE, true);  /* add color */
 		printw("%s", line);
-		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		editpolicy_attr_change(A_REVERSE, false); /* add color */
 		ccs_put();
 	}
 	move(CCS_HEADER_LINES + ptr->y, 0);
-	ccs_editpolicy_line_draw();     /* add color */
+	editpolicy_line_draw();     /* add color */
 	refresh();
 }
 
@@ -2638,7 +2583,7 @@
  */
 static void ccs_adjust_cursor_pos(const int item_count)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
 	if (item_count == 0) {
 		ptr->current = 0;
 		ptr->y = 0;
@@ -2662,7 +2607,7 @@
  */
 static void ccs_set_cursor_pos(const int index)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
 	while (index < ptr->y + ptr->current) {
 		if (ptr->y > 0)
 			ptr->y--;
@@ -2693,7 +2638,7 @@
 	int y;
 	if (index < 0)
 		return false;
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+	if (current_screen == SCREEN_DOMAIN_LIST) {
 		if (!ccs_domain_sort_type) {
 			if (ccs_deleted_domain(index) ||
 			    ccs_jump_source(index))
@@ -2703,12 +2648,12 @@
 			ccs_task_list[index].selected ^= 1;
 		}
 	} else {
-		ccs_gacl_list[index].selected ^= 1;
+		generic_list[index].selected ^= 1;
 	}
 	getyx(stdscr, y, x);
-	ccs_editpolicy_sttr_save();    /* add color */
+	editpolicy_sttr_save();    /* add color */
 	ccs_show_list();
-	ccs_editpolicy_sttr_restore(); /* add color */
+	editpolicy_sttr_restore(); /* add color */
 	move(y, x);
 	return true;
 }
@@ -2723,32 +2668,44 @@
  */
 static int ccs_gacl_compare(const void *a, const void *b)
 {
-	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
-	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
-	const enum ccs_editpolicy_directives a0_d = a0->directive;
-	const enum ccs_editpolicy_directives b0_d = b0->directive;
-	const char *a1 = ccs_directives[a0_d].alias;
-	const char *b1 = ccs_directives[b0_d].alias;
+	const struct generic_entry *a0 = (struct generic_entry *) a;
+	const struct generic_entry *b0 = (struct generic_entry *) b;
+	const enum directive_type a0_d = a0->directive;
+	const enum directive_type b0_d = b0->directive;
+	const char *a1 = directive_map[a0_d].alias;
+	const char *b1 = directive_map[b0_d].alias;
 	const char *a2 = a0->operand;
 	const char *b2 = b0->operand;
-	if (a0_d == CCS_DIRECTIVE_USE_GROUP && b0_d == CCS_DIRECTIVE_USE_GROUP)
+	if (current_screen == SCREEN_EXCEPTION_LIST) {
+		int ret;
+		if (a0_d >= DIRECTIVE_ACL_GROUP_000 &&
+		    a0_d <= DIRECTIVE_ACL_GROUP_255 &&
+		    b0_d >= DIRECTIVE_ACL_GROUP_000 &&
+		    b0_d <= DIRECTIVE_ACL_GROUP_255 && a0_d != b0_d)
+			return a0_d - b0_d;
+		ret = strcmp(a1, b1);
+		if (ret)
+			return ret;
+		return strcmp(a2, b2);
+	}
+	if (a0_d == DIRECTIVE_USE_GROUP && b0_d == DIRECTIVE_USE_GROUP)
 		return atoi(a2) - atoi(b2);
 	if (!ccs_acl_sort_type) {
 		const int ret = strcmp(a1, b1);
 		if (ret)
 			return ret;
 		return strcmp(a2, b2);
-	} else if (a0_d == CCS_DIRECTIVE_USE_GROUP) {
+	} else if (a0_d == DIRECTIVE_USE_GROUP) {
 		return 1;
-	} else if (b0_d == CCS_DIRECTIVE_USE_GROUP) {
+	} else if (b0_d == DIRECTIVE_USE_GROUP) {
 		return -1;
-	} else if (a0_d == CCS_DIRECTIVE_TRANSITION_FAILED) {
+	} else if (a0_d == DIRECTIVE_TRANSITION_FAILED) {
 		return 2;
-	} else if (b0_d == CCS_DIRECTIVE_TRANSITION_FAILED) {
+	} else if (b0_d == DIRECTIVE_TRANSITION_FAILED) {
 		return -2;
-	} else if (a0_d == CCS_DIRECTIVE_QUOTA_EXCEEDED) {
+	} else if (a0_d == DIRECTIVE_QUOTA_EXCEEDED) {
 		return 3;
-	} else if (b0_d == CCS_DIRECTIVE_QUOTA_EXCEEDED) {
+	} else if (b0_d == DIRECTIVE_QUOTA_EXCEEDED) {
 		return -3;
 	} else {
 		const int ret = strcmp(a2, b2);
@@ -2769,8 +2726,8 @@
 {
 	int c;
 	move(1, 0);
-	ccs_editpolicy_color_change(CCS_DISP_ERR, true);	/* add color */
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+	editpolicy_color_change(COLOR_DISP_ERR, true);	/* add color */
+	if (current_screen == SCREEN_DOMAIN_LIST) {
 		c = ccs_count(ccs_dp.list_selected, ccs_dp.list_len);
 		if (!c && index < ccs_dp.list_len)
 			c = ccs_select_item(index);
@@ -2780,8 +2737,7 @@
 			printw("Delete selected domain%s? ('Y'es/'N'o)",
 			       c > 1 ? "s" : "");
 	} else {
-		c = ccs_count2(ccs_gacl_list,
-			       ccs_gacl_list_count);
+		c = ccs_count2(generic_list, generic_list_len);
 		if (!c)
 			c = ccs_select_item(index);
 		if (!c)
@@ -2790,7 +2746,7 @@
 			printw("Delete selected entr%s? ('Y'es/'N'o)",
 			       c > 1 ? "ies" : "y");
 	}
-	ccs_editpolicy_color_change(CCS_DISP_ERR, false);	/* add color */
+	editpolicy_color_change(COLOR_DISP_ERR, false);	/* add color */
 	clrtoeol();
 	refresh();
 	if (!c)
@@ -2803,9 +2759,9 @@
 		ccs_show_list();
 		return;
 	}
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+	if (current_screen == SCREEN_DOMAIN_LIST) {
 		int i;
-		FILE *fp = ccs_editpolicy_open_write
+		FILE *fp = editpolicy_open_write
 			(CCS_PROC_POLICY_DOMAIN_POLICY);
 		if (!fp)
 			return;
@@ -2820,27 +2776,27 @@
 		int i;
 		const _Bool is_kernel_ns = !strcmp(ccs_current_ns->name,
 						   "<kernel>");
-		FILE *fp = ccs_editpolicy_open_write(ccs_policy_file);
+		FILE *fp = editpolicy_open_write(policy_file);
 		if (!fp)
 			return;
-		if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+		if (current_screen == SCREEN_ACL_LIST) {
 			if (ccs_domain_sort_type)
 				fprintf(fp, "select pid=%u\n",
-					ccs_current_pid);
+					current_pid);
 			else
 				fprintf(fp, "select domain=%s\n",
-					ccs_current_domain);
+					current_domain);
 		}
-		for (i = 0; i < ccs_gacl_list_count; i++) {
-			enum ccs_editpolicy_directives directive;
-			if (!ccs_gacl_list[i].selected)
+		for (i = 0; i < generic_list_len; i++) {
+			enum directive_type directive;
+			if (!generic_list[i].selected)
 				continue;
-			directive = ccs_gacl_list[i].directive;
+			directive = generic_list[i].directive;
 			fprintf(fp, "delete %s %s %s\n",
-				ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST
+				current_screen == SCREEN_EXCEPTION_LIST
 				&& !is_kernel_ns ? ccs_current_ns->name : "",
-				ccs_directives[directive].original,
-				ccs_gacl_list[i].operand);
+				directive_map[directive].original,
+				generic_list[i].operand);
 		}
 		ccs_close_write(fp);
 	}
@@ -2856,20 +2812,20 @@
 	FILE *fp;
 	char *line;
 	const _Bool is_kernel_ns = !strcmp(ccs_current_ns->name, "<kernel>");
-	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
 	line = ccs_readline(ccs_window_height - 1, 0, "Enter new entry> ",
 			    ccs_rl.history, ccs_rl.count, 128000, 8);
-	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
 	ccs_rl.count = ccs_add_history(line, ccs_rl.history, ccs_rl.count,
 				       ccs_rl.max);
-	fp = ccs_editpolicy_open_write(ccs_policy_file);
+	fp = editpolicy_open_write(policy_file);
 	if (!fp)
 		goto out;
-	switch (ccs_current_screen) {
-		enum ccs_editpolicy_directives directive;
-	case CCS_SCREEN_DOMAIN_LIST:
+	switch (current_screen) {
+		enum directive_type directive;
+	case SCREEN_DOMAIN_LIST:
 		if (!ccs_correct_domain(line)) {
 			const int len = strlen(line) + 128;
 			ccs_last_error = ccs_realloc2(ccs_last_error, len);
@@ -2878,21 +2834,21 @@
 			line[0] = '\0';
 		}
 		break;
-	case CCS_SCREEN_ACL_LIST:
+	case SCREEN_ACL_LIST:
 		if (ccs_domain_sort_type)
-			fprintf(fp, "select pid=%u\n", ccs_current_pid);
+			fprintf(fp, "select pid=%u\n", current_pid);
 		else
-			fprintf(fp, "select domain=%s\n", ccs_current_domain);
+			fprintf(fp, "select domain=%s\n", current_domain);
 		/* Fall through. */
-	case CCS_SCREEN_EXCEPTION_LIST:
-		if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST &&
+	case SCREEN_EXCEPTION_LIST:
+		if (current_screen == SCREEN_EXCEPTION_LIST &&
 		    !is_kernel_ns)
 			fprintf(fp, "%s ", ccs_current_ns->name);
-		directive = ccs_find_directive(false, line);
-		if (directive != CCS_DIRECTIVE_NONE)
-			fprintf(fp, "%s ", ccs_directives[directive].original);
+		directive = find_directive(false, line);
+		if (directive != DIRECTIVE_NONE)
+			fprintf(fp, "%s ", directive_map[directive].original);
 		break;
-	case CCS_SCREEN_PROFILE_LIST:
+	case SCREEN_PROFILE_LIST:
 		if (!strchr(line, '='))
 			fprintf(fp, "%s %s-COMMENT=\n",
 				!is_kernel_ns ? ccs_current_ns->name : "",
@@ -2900,7 +2856,7 @@
 		if (!is_kernel_ns)
 			fprintf(fp, "%s ", ccs_current_ns->name);
 		break;
-	case CCS_SCREEN_NS_LIST:
+	case SCREEN_NS_LIST:
 		fprintf(fp, "%s PROFILE_VERSION=20100903\n", line);
 		line[0] = '\0';
 		break;
@@ -2931,16 +2887,16 @@
 		return;
 	if (!input)
 		goto start_search;
-	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
 	line = ccs_readline(ccs_window_height - 1, 0, "Search> ",
 			    ccs_rl.history, ccs_rl.count, 128000, 8);
-	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
 	ccs_rl.count = ccs_add_history(line, ccs_rl.history, ccs_rl.count,
 				       ccs_rl.max);
-	free(ccs_rl.search_buffer[ccs_current_screen]);
-	ccs_rl.search_buffer[ccs_current_screen] = line;
+	free(ccs_rl.search_buffer[current_screen]);
+	ccs_rl.search_buffer[current_screen] = line;
 	line = NULL;
 	index = -1;
 start_search:
@@ -2954,23 +2910,23 @@
 			if (--index < 0)
 				break;
 		}
-		if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+		if (current_screen == SCREEN_DOMAIN_LIST) {
 			if (ccs_domain_sort_type)
 				cp = ccs_task_list[index].name;
 			else
 				cp = ccs_get_last_name(index);
-		} else if (ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
+		} else if (current_screen == SCREEN_PROFILE_LIST) {
 			cp = ccs_shprintf("%u-%s",
-					  ccs_gacl_list[index].directive,
-					  ccs_gacl_list[index].operand);
+					  generic_list[index].directive,
+					  generic_list[index].operand);
 		} else {
-			const enum ccs_editpolicy_directives directive =
-				ccs_gacl_list[index].directive;
+			const enum directive_type directive =
+				generic_list[index].directive;
 			cp = ccs_shprintf("%s %s",
-					  ccs_directives[directive].alias,
-					  ccs_gacl_list[index].operand);
+					  directive_map[directive].alias,
+					  generic_list[index].operand);
 		}
-		if (!strstr(cp, ccs_rl.search_buffer[ccs_current_screen]))
+		if (!strstr(cp, ccs_rl.search_buffer[current_screen]))
 			continue;
 		ccs_set_cursor_pos(index);
 		break;
@@ -3012,13 +2968,13 @@
 			return;
 		}
 	}
-	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
 	line = ccs_readline(ccs_window_height - 1, 0, "Enter profile number> ",
 			    NULL, 0, 8, 1);
-	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
+	fp = editpolicy_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
 	if (!fp)
 		goto out;
 	if (!ccs_domain_sort_type) {
@@ -3053,15 +3009,15 @@
 	int index;
 	FILE *fp;
 	char *line;
-	if (!ccs_count2(ccs_gacl_list, ccs_gacl_list_count))
+	if (!ccs_count2(generic_list, generic_list_len))
 		ccs_select_item(current);
-	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
 	ccs_initial_readline_data = NULL;
-	for (index = 0; index < ccs_gacl_list_count; index++) {
+	for (index = 0; index < generic_list_len; index++) {
 		char *cp;
-		if (!ccs_gacl_list[index].selected)
+		if (!generic_list[index].selected)
 			continue;
-		cp = strchr(ccs_gacl_list[index].operand, '=');
+		cp = strchr(generic_list[index].operand, '=');
 		if (!cp)
 			continue;
 		ccs_initial_readline_data = cp + 1;
@@ -3070,24 +3026,24 @@
 	line = ccs_readline(ccs_window_height - 1, 0, "Enter new value> ",
 			    NULL, 0, 128000, 1);
 	ccs_initial_readline_data = NULL;
-	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_PROFILE);
+	fp = editpolicy_open_write(CCS_PROC_POLICY_PROFILE);
 	if (!fp)
 		goto out;
-	for (index = 0; index < ccs_gacl_list_count; index++) {
+	for (index = 0; index < generic_list_len; index++) {
 		char *buf;
 		char *cp;
-		enum ccs_editpolicy_directives directive;
-		if (!ccs_gacl_list[index].selected)
+		enum directive_type directive;
+		if (!generic_list[index].selected)
 			continue;
 		ccs_get();
-		buf = ccs_shprintf("%s", ccs_gacl_list[index].operand);
+		buf = ccs_shprintf("%s", generic_list[index].operand);
 		cp = strchr(buf, '=');
 		if (cp)
 			*cp = '\0';
-		directive = ccs_gacl_list[index].directive;
+		directive = generic_list[index].directive;
 		fprintf(fp, "%s ", ccs_current_ns->name);
 		if (directive < 256)
 			fprintf(fp, "%u-", directive);
@@ -3111,24 +3067,24 @@
 	int index;
 	FILE *fp;
 	char *line;
-	if (!ccs_count2(ccs_gacl_list, ccs_gacl_list_count))
+	if (!ccs_count2(generic_list, generic_list_len))
 		ccs_select_item(current);
-	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
 	line = ccs_readline(ccs_window_height - 1, 0, "Enter new value> ",
 			    NULL, 0, 20, 1);
-	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_STAT);
+	fp = editpolicy_open_write(CCS_PROC_POLICY_STAT);
 	if (!fp)
 		goto out;
-	for (index = 0; index < ccs_gacl_list_count; index++) {
+	for (index = 0; index < generic_list_len; index++) {
 		char *buf;
 		char *cp;
-		if (!ccs_gacl_list[index].selected)
+		if (!generic_list[index].selected)
 			continue;
 		ccs_get();
-		buf = ccs_shprintf("%s", ccs_gacl_list[index].operand);
+		buf = ccs_shprintf("%s", generic_list[index].operand);
 		cp = strchr(buf, ':');
 		if (cp)
 			*cp = '\0';
@@ -3152,22 +3108,22 @@
 	char *old_domain;
 	if (current == EOF)
 		return false;
-	if (ccs_current_screen == CCS_SCREEN_NS_LIST) {
-		const char *namespace = ccs_gacl_list[current].operand;
-		if (ccs_previous_screen == CCS_SCREEN_ACL_LIST &&
+	if (current_screen == SCREEN_NS_LIST) {
+		const char *namespace = generic_list[current].operand;
+		if (previous_screen == SCREEN_ACL_LIST &&
 		    strcmp(ccs_current_ns->name, namespace))
-			ccs_previous_screen = CCS_SCREEN_DOMAIN_LIST;
+			previous_screen = SCREEN_DOMAIN_LIST;
 		ccs_current_ns = ccs_savename(namespace);
-		ccs_current_screen = ccs_previous_screen;
+		current_screen = previous_screen;
 		return true;
 	}
-	if (ccs_current_screen != CCS_SCREEN_DOMAIN_LIST)
+	if (current_screen != SCREEN_DOMAIN_LIST)
 		return false;
-	ccs_current_pid = 0;
+	current_pid = 0;
 	if (ccs_domain_sort_type) {
-		ccs_current_pid = ccs_task_list[current].pid;
+		current_pid = ccs_task_list[current].pid;
 	} else if (ccs_jump_source(current)) {
-		struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+		struct ccs_screen *ptr = &ccs_screen[current_screen];
 		const int redirect_index = ccs_find_target_domain(current);
 		if (redirect_index >= 0) {
 			ptr->current = redirect_index - ptr->y;
@@ -3181,9 +3137,9 @@
 			const char *domainname =
 				ccs_dp.list[current].target->name;
 			ccs_current_ns = ccs_get_ns(domainname);
-			free(ccs_current_domain);
-			ccs_current_domain = ccs_strdup(domainname);
-			ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
+			free(current_domain);
+			current_domain = ccs_strdup(domainname);
+			current_screen = SCREEN_DOMAIN_LIST;
 			ccs_force_move_cursor = true;
 			return true;
 		}
@@ -3191,16 +3147,16 @@
 	} else if (ccs_deleted_domain(current)) {
 		return false;
 	}
-	old_domain = ccs_current_domain;
+	old_domain = current_domain;
 	if (ccs_domain_sort_type)
-		ccs_current_domain = ccs_strdup(ccs_task_list[current].domain);
+		current_domain = ccs_strdup(ccs_task_list[current].domain);
 	else
-		ccs_current_domain = ccs_strdup(ccs_dp.list[current].
+		current_domain = ccs_strdup(ccs_dp.list[current].
 						domainname->name);
 	ccs_no_restore_cursor = old_domain &&
-		strcmp(old_domain, ccs_current_domain);
+		strcmp(old_domain, current_domain);
 	free(old_domain);
-	ccs_current_screen = CCS_SCREEN_ACL_LIST;
+	current_screen = SCREEN_ACL_LIST;
 	return true;
 }
 
@@ -3211,19 +3167,19 @@
  *
  * Returns next window to display.
  */
-static enum ccs_screen_type ccs_select_window(const int current)
+static enum screen_type ccs_select_window(const int current)
 {
 	move(0, 0);
 	printw("Press one of below keys to switch window.\n\n");
 	printw("e     <<< Exception Policy Editor >>>\n");
 	printw("d     <<< Domain Transition Editor >>>\n");
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST && current != EOF &&
+	if (current_screen == SCREEN_DOMAIN_LIST && current != EOF &&
 	    !ccs_jump_source(current) && !ccs_deleted_domain(current))
 		printw("a     <<< Domain Policy Editor >>>\n");
 	printw("p     <<< Profile Editor >>>\n");
 	printw("m     <<< Manager Policy Editor >>>\n");
 	printw("n     <<< Namespace Selector >>>\n");
-	if (!ccs_offline_mode) {
+	if (!offline_mode) {
 		/* printw("i     <<< Interactive Enforcing Mode >>>\n"); */
 		printw("s     <<< Statistics >>>\n");
 	}
@@ -3233,32 +3189,32 @@
 	while (true) {
 		int c = ccs_getch2();
 		if (c == 'E' || c == 'e')
-			return CCS_SCREEN_EXCEPTION_LIST;
+			return SCREEN_EXCEPTION_LIST;
 		if (c == 'D' || c == 'd')
-			return CCS_SCREEN_DOMAIN_LIST;
+			return SCREEN_DOMAIN_LIST;
 		if (c == 'A' || c == 'a')
 			if (ccs_select_acl_window(current))
-				return ccs_current_screen;
+				return current_screen;
 		if (c == 'P' || c == 'p')
-			return CCS_SCREEN_PROFILE_LIST;
+			return SCREEN_PROFILE_LIST;
 		if (c == 'M' || c == 'm')
-			return CCS_SCREEN_MANAGER_LIST;
+			return SCREEN_MANAGER_LIST;
 		if (c == 'N' || c == 'n') {
-			ccs_previous_screen = ccs_current_screen;
-			return CCS_SCREEN_NS_LIST;
+			previous_screen = current_screen;
+			return SCREEN_NS_LIST;
 		}
-		if (!ccs_offline_mode) {
+		if (!offline_mode) {
 			/*
 			if (c == 'I' || c == 'i')
-				return CCS_SCREEN_QUERY_LIST;
+				return SCREEN_QUERY_LIST;
 			*/
 			if (c == 'S' || c == 's')
-				return CCS_SCREEN_STAT_LIST;
+				return SCREEN_STAT_LIST;
 		}
 		if (c == 'Q' || c == 'q')
-			return CCS_MAXSCREEN;
+			return MAX_SCREEN_TYPE;
 		if (c == EOF)
-			return CCS_MAXSCREEN;
+			return MAX_SCREEN_TYPE;
 	}
 }
 
@@ -3272,7 +3228,7 @@
 static void ccs_copy_mark_state(const int current)
 {
 	int index;
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+	if (current_screen == SCREEN_DOMAIN_LIST) {
 		if (ccs_domain_sort_type) {
 			const u8 selected = ccs_task_list[current].selected;
 			for (index = current; index < ccs_task_list_len;
@@ -3292,10 +3248,9 @@
 			}
 		}
 	} else {
-		const u8 selected = ccs_gacl_list[current].selected;
-		for (index = current; index < ccs_gacl_list_count;
-		     index++)
-			ccs_gacl_list[index].selected = selected;
+		const _Bool selected = generic_list[current].selected;
+		for (index = current; index < generic_list_len; index++)
+			generic_list[index].selected = selected;
 	}
 	ccs_show_list();
 }
@@ -3313,9 +3268,9 @@
 	if (current == EOF)
 		return;
 	ccs_get();
-	switch (ccs_current_screen) {
-		enum ccs_editpolicy_directives directive;
-	case CCS_SCREEN_DOMAIN_LIST:
+	switch (current_screen) {
+		enum directive_type directive;
+	case SCREEN_DOMAIN_LIST:
 		if (!ccs_domain_sort_type) {
 			const struct ccs_domain *domain =
 				&ccs_dp.list[current];
@@ -3326,18 +3281,17 @@
 		} else
 			line = ccs_task_list[current].domain;
 		break;
-	case CCS_SCREEN_EXCEPTION_LIST:
-	case CCS_SCREEN_ACL_LIST:
-		directive = ccs_gacl_list[current].directive;
-		line = ccs_shprintf("%s %s", ccs_directives[directive].alias,
-				ccs_gacl_list[current].operand);
+	case SCREEN_EXCEPTION_LIST:
+	case SCREEN_ACL_LIST:
+		directive = generic_list[current].directive;
+		line = ccs_shprintf("%s %s", directive_map[directive].alias,
+				    generic_list[current].operand);
 		break;
-	case CCS_SCREEN_STAT_LIST:
+	case SCREEN_STAT_LIST:
 		line = NULL;
 		break;
 	default:
-		line = ccs_shprintf("%s",
-				    ccs_gacl_list[current].operand);
+		line = ccs_shprintf("%s", generic_list[current].operand);
 	}
 	ccs_rl.count = ccs_add_history(line, ccs_rl.history, ccs_rl.count,
 				       ccs_rl.max);
@@ -3349,57 +3303,57 @@
  *
  * Returns next screen to display.
  */
-static enum ccs_screen_type ccs_generic_list_loop(void)
+static enum screen_type ccs_generic_list_loop(void)
 {
 	struct ccs_screen *ptr;
 	static struct {
 		int y;
 		int current;
-	} saved_cursor[CCS_MAXSCREEN] = { };
-	if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_EXCEPTION_POLICY;
-		ccs_list_caption = "Exception Policy Editor";
-	} else if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
-		ccs_list_caption = "Domain Policy Editor";
+	} saved_cursor[MAX_SCREEN_TYPE] = { };
+	if (current_screen == SCREEN_EXCEPTION_LIST) {
+		policy_file = CCS_PROC_POLICY_EXCEPTION_POLICY;
+		list_caption = "Exception Policy Editor";
+	} else if (current_screen == SCREEN_ACL_LIST) {
+		policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
+		list_caption = "Domain Policy Editor";
 		/*
-	} else if (ccs_current_screen == CCS_SCREEN_QUERY_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_QUERY;
-		ccs_list_caption = "Interactive Enforcing Mode";
+	} else if (current_screen == SCREEN_QUERY_LIST) {
+		policy_file = CCS_PROC_POLICY_QUERY;
+		list_caption = "Interactive Enforcing Mode";
 		*/
-	} else if (ccs_current_screen == CCS_SCREEN_NS_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_PROFILE;
-		ccs_list_caption = "Namespace Selector";
-	} else if (ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_PROFILE;
-		ccs_list_caption = "Profile Editor";
-	} else if (ccs_current_screen == CCS_SCREEN_MANAGER_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_MANAGER;
-		ccs_list_caption = "Manager Policy Editor";
-	} else if (ccs_current_screen == CCS_SCREEN_STAT_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_STAT;
-		ccs_list_caption = "Statistics";
+	} else if (current_screen == SCREEN_NS_LIST) {
+		policy_file = CCS_PROC_POLICY_PROFILE;
+		list_caption = "Namespace Selector";
+	} else if (current_screen == SCREEN_PROFILE_LIST) {
+		policy_file = CCS_PROC_POLICY_PROFILE;
+		list_caption = "Profile Editor";
+	} else if (current_screen == SCREEN_MANAGER_LIST) {
+		policy_file = CCS_PROC_POLICY_MANAGER;
+		list_caption = "Manager Policy Editor";
+	} else if (current_screen == SCREEN_STAT_LIST) {
+		policy_file = CCS_PROC_POLICY_STAT;
+		list_caption = "Statistics";
 	} else {
-		ccs_policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
-		/* ccs_list_caption = "Domain Transition Editor"; */
+		policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
+		/* list_caption = "Domain Transition Editor"; */
 	}
-	ptr = &ccs_screen[ccs_current_screen];
+	ptr = &ccs_screen[current_screen];
 	if (ccs_no_restore_cursor || ccs_force_move_cursor) {
 		ptr->current = 0;
 		ptr->y = 0;
 		ccs_no_restore_cursor = false;
 	} else {
-		ptr->current = saved_cursor[ccs_current_screen].current;
-		ptr->y = saved_cursor[ccs_current_screen].y;
+		ptr->current = saved_cursor[current_screen].current;
+		ptr->y = saved_cursor[current_screen].y;
 	}
 start:
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+	if (current_screen == SCREEN_DOMAIN_LIST) {
 		if (!ccs_domain_sort_type) {
 			ccs_read_domain_and_exception_policy();
 			if (ccs_force_move_cursor) {
 				const int redirect_index =
-					ccs_find_domain3(ccs_current_domain,
-							 NULL, false);
+					ccs_find_domain3(current_domain, NULL,
+							 false);
 				if (redirect_index >= 0) {
 					ptr->current = redirect_index - ptr->y;
 					while (ptr->current < 0) {
@@ -3416,7 +3370,7 @@
 		}
 	} else {
 		ccs_read_generic_policy();
-		ccs_adjust_cursor_pos(ccs_gacl_list_count);
+		ccs_adjust_cursor_pos(generic_list_len);
 	}
 start2:
 	ccs_show_list();
@@ -3429,23 +3383,23 @@
 		ccs_last_error = NULL;
 	}
 	while (true) {
-		const int current = ccs_editpolicy_get_current();
+		const int current = editpolicy_get_current();
 		const int c = ccs_getch2();
-		saved_cursor[ccs_current_screen].current = ptr->current;
-		saved_cursor[ccs_current_screen].y = ptr->y;
+		saved_cursor[current_screen].current = ptr->current;
+		saved_cursor[current_screen].y = ptr->y;
 		if (c == 'q' || c == 'Q')
-			return CCS_MAXSCREEN;
+			return MAX_SCREEN_TYPE;
 		if ((c == '\r' || c == '\n') &&
-		    ccs_current_screen == CCS_SCREEN_ACL_LIST)
-			return CCS_SCREEN_DOMAIN_LIST;
+		    current_screen == SCREEN_ACL_LIST)
+			return SCREEN_DOMAIN_LIST;
 		if (c == '\t') {
-			if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST)
-				return CCS_SCREEN_EXCEPTION_LIST;
+			if (current_screen == SCREEN_DOMAIN_LIST)
+				return SCREEN_EXCEPTION_LIST;
 			else
-				return CCS_SCREEN_DOMAIN_LIST;
+				return SCREEN_DOMAIN_LIST;
 		}
-		if (ccs_need_reload) {
-			ccs_need_reload = false;
+		if (need_reload) {
+			need_reload = false;
 			goto start;
 		}
 		if (c == ERR)
@@ -3479,38 +3433,38 @@
 			break;
 		case 'f':
 		case 'F':
-			if (ccs_current_screen != CCS_SCREEN_STAT_LIST)
+			if (current_screen != SCREEN_STAT_LIST)
 				ccs_find_entry(true, true, current);
 			break;
 		case 'p':
 		case 'P':
-			if (ccs_current_screen == CCS_SCREEN_STAT_LIST)
+			if (current_screen == SCREEN_STAT_LIST)
 				break;
-			if (!ccs_rl.search_buffer[ccs_current_screen])
+			if (!ccs_rl.search_buffer[current_screen])
 				ccs_find_entry(true, false, current);
 			else
 				ccs_find_entry(false, false, current);
 			break;
 		case 'n':
 		case 'N':
-			if (ccs_current_screen == CCS_SCREEN_STAT_LIST)
+			if (current_screen == SCREEN_STAT_LIST)
 				break;
-			if (!ccs_rl.search_buffer[ccs_current_screen])
+			if (!ccs_rl.search_buffer[current_screen])
 				ccs_find_entry(true, true, current);
 			else
 				ccs_find_entry(false, true, current);
 			break;
 		case 'd':
 		case 'D':
-			if (ccs_readonly_mode)
+			if (readonly_mode)
 				break;
-			switch (ccs_current_screen) {
-			case CCS_SCREEN_DOMAIN_LIST:
+			switch (current_screen) {
+			case SCREEN_DOMAIN_LIST:
 				if (ccs_domain_sort_type)
 					break;
-			case CCS_SCREEN_EXCEPTION_LIST:
-			case CCS_SCREEN_ACL_LIST:
-			case CCS_SCREEN_MANAGER_LIST:
+			case SCREEN_EXCEPTION_LIST:
+			case SCREEN_ACL_LIST:
+			case SCREEN_MANAGER_LIST:
 				ccs_delete_entry(current);
 				goto start;
 			default:
@@ -3519,17 +3473,17 @@
 			break;
 		case 'a':
 		case 'A':
-			if (ccs_readonly_mode)
+			if (readonly_mode)
 				break;
-			switch (ccs_current_screen) {
-			case CCS_SCREEN_DOMAIN_LIST:
+			switch (current_screen) {
+			case SCREEN_DOMAIN_LIST:
 				if (ccs_domain_sort_type)
 					break;
-			case CCS_SCREEN_EXCEPTION_LIST:
-			case CCS_SCREEN_ACL_LIST:
-			case CCS_SCREEN_PROFILE_LIST:
-			case CCS_SCREEN_MANAGER_LIST:
-			case CCS_SCREEN_NS_LIST:
+			case SCREEN_EXCEPTION_LIST:
+			case SCREEN_ACL_LIST:
+			case SCREEN_PROFILE_LIST:
+			case SCREEN_MANAGER_LIST:
+			case SCREEN_NS_LIST:
 				ccs_add_entry();
 				goto start;
 			default:
@@ -3539,20 +3493,20 @@
 		case '\r':
 		case '\n':
 			if (ccs_select_acl_window(current))
-				return ccs_current_screen;
+				return current_screen;
 			break;
 		case 's':
 		case 'S':
-			if (ccs_readonly_mode)
+			if (readonly_mode)
 				break;
-			switch (ccs_current_screen) {
-			case CCS_SCREEN_DOMAIN_LIST:
+			switch (current_screen) {
+			case SCREEN_DOMAIN_LIST:
 				ccs_set_profile(current);
 				goto start;
-			case CCS_SCREEN_PROFILE_LIST:
+			case SCREEN_PROFILE_LIST:
 				ccs_set_level(current);
 				goto start;
-			case CCS_SCREEN_STAT_LIST:
+			case SCREEN_STAT_LIST:
 				ccs_set_quota(current);
 				goto start;
 			default:
@@ -3581,22 +3535,22 @@
 			break;
 		case 'o':
 		case 'O':
-			if (ccs_current_screen == CCS_SCREEN_ACL_LIST ||
-			    ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST) {
-				ccs_editpolicy_optimize(current);
+			if (current_screen == SCREEN_ACL_LIST ||
+			    current_screen == SCREEN_EXCEPTION_LIST) {
+				editpolicy_optimize(current);
 				ccs_show_list();
 			}
 			break;
 		case '@':
-			switch (ccs_current_screen) {
-			case CCS_SCREEN_ACL_LIST:
+			switch (current_screen) {
+			case SCREEN_ACL_LIST:
 				ccs_acl_sort_type = !ccs_acl_sort_type;
 				goto start;
-			case CCS_SCREEN_PROFILE_LIST:
+			case SCREEN_PROFILE_LIST:
 				ccs_profile_sort_type = !ccs_profile_sort_type;
 				goto start;
-			case CCS_SCREEN_DOMAIN_LIST:
-				if (ccs_offline_mode)
+			case SCREEN_DOMAIN_LIST:
+				if (offline_mode)
 					break;
 				ccs_domain_sort_type = !ccs_domain_sort_type;
 				goto start;
@@ -3608,10 +3562,10 @@
 		case 'W':
 			return ccs_select_window(current);
 		case '?':
-			if (ccs_show_command_key(ccs_current_screen,
-						 ccs_readonly_mode))
+			if (ccs_show_command_key(current_screen,
+						 readonly_mode))
 				goto start;
-			return CCS_MAXSCREEN;
+			return MAX_SCREEN_TYPE;
 		}
 	}
 }
@@ -3626,7 +3580,7 @@
  */
 static _Bool ccs_save_to_file(const char *src, const char *dest)
 {
-	FILE *proc_fp = ccs_editpolicy_open_read(src);
+	FILE *proc_fp = editpolicy_open_read(src);
 	FILE *file_fp = fopen(dest, "w");
 	int c;
 	if (!file_fp || !proc_fp) {
@@ -3666,10 +3620,10 @@
 		char *ptr = argv[i];
 		char *cp = strchr(ptr, ':');
 		if (*ptr == '/') {
-			if (ccs_network_mode || ccs_offline_mode)
+			if (ccs_network_mode || offline_mode)
 				goto usage;
-			ccs_policy_dir = ptr;
-			ccs_offline_mode = true;
+			policy_dir = ptr;
+			offline_mode = true;
 		} else if (*ptr == '<') {
 			if (ccs_current_ns || strchr(ptr, ' ') ||
 			    !ccs_domain_def(ptr))
@@ -3677,7 +3631,7 @@
 			ccs_current_ns = ccs_savename(ptr);
 		} else if (cp) {
 			*cp++ = '\0';
-			if (ccs_network_mode || ccs_offline_mode)
+			if (ccs_network_mode || offline_mode)
 				goto usage;
 			ccs_network_ip = inet_addr(ptr);
 			ccs_network_port = htons(atoi(cp));
@@ -3685,20 +3639,20 @@
 			if (!ccs_check_remote_host())
 				exit(1);
 		} else if (!strcmp(ptr, "e"))
-			ccs_current_screen = CCS_SCREEN_EXCEPTION_LIST;
+			current_screen = SCREEN_EXCEPTION_LIST;
 		else if (!strcmp(ptr, "d"))
-			ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
+			current_screen = SCREEN_DOMAIN_LIST;
 		else if (!strcmp(ptr, "p"))
-			ccs_current_screen = CCS_SCREEN_PROFILE_LIST;
+			current_screen = SCREEN_PROFILE_LIST;
 		else if (!strcmp(ptr, "m"))
-			ccs_current_screen = CCS_SCREEN_MANAGER_LIST;
+			current_screen = SCREEN_MANAGER_LIST;
 		else if (!strcmp(ptr, "s"))
-			ccs_current_screen = CCS_SCREEN_STAT_LIST;
+			current_screen = SCREEN_STAT_LIST;
 		else if (!strcmp(ptr, "n"))
-			ccs_current_screen = CCS_SCREEN_NS_LIST;
+			current_screen = SCREEN_NS_LIST;
 		else if (!strcmp(ptr, "readonly"))
-			ccs_readonly_mode = true;
-		else if (sscanf(ptr, "refresh=%u", &ccs_refresh_interval)
+			readonly_mode = true;
+		else if (sscanf(ptr, "refresh=%u", &refresh_interval)
 			 != 1) {
 usage:
 			printf("Usage: %s [e|d|p|m|s|n] [readonly] "
@@ -3730,9 +3684,9 @@
 	 */
 	addr.sin_family = AF_INET;
 	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-	if (chdir(ccs_policy_dir) || chdir("policy/current/")) {
+	if (chdir(policy_dir) || chdir("policy/current/")) {
 		fprintf(stderr, "Directory %s/policy/current/ doesn't "
-			"exist.\n", ccs_policy_dir);
+			"exist.\n", policy_dir);
 		exit(1);
 	}
 	if (bind(fd, (struct sockaddr *) &addr, sizeof(addr)) || listen(fd, 5)
@@ -3761,7 +3715,7 @@
 		if (close(pipe_fd[1]) ||
 		    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NONBLOCK))
 			_exit(1);
-		ccs_editpolicy_offline_daemon(fd, pipe_fd[0]);
+		editpolicy_offline_daemon(fd, pipe_fd[0]);
 		_exit(1);
 	case -1:
 		fprintf(stderr, "fork()\n");
@@ -3776,7 +3730,7 @@
 	ccs_copy_file("manager.conf", CCS_PROC_POLICY_MANAGER);
 	if (chdir("..")) {
 		fprintf(stderr, "Directory %s/policy/ doesn't exist.\n",
-			ccs_policy_dir);
+			policy_dir);
 		exit(1);
 	}
 }
@@ -3821,8 +3775,8 @@
 		else if (errno == EEXIST)
 			now++;
 		else {
-			fprintf(stderr, "Can't create %s/%s .\n",
-				ccs_policy_dir, stamp);
+			fprintf(stderr, "Can't create %s/%s .\n", policy_dir,
+				stamp);
 			exit(1);
 		}
 	}
@@ -3854,8 +3808,8 @@
 	memset(acl_group_list, 0, sizeof(acl_group_list));
 	memset(acl_group_list_len, 0, sizeof(acl_group_list_len));
 	ccs_parse_args(argc, argv);
-	ccs_editpolicy_init_keyword_map();
-	if (ccs_offline_mode)
+	editpolicy_init_keyword_map();
+	if (offline_mode)
 		ccs_load_offline();
 	if (ccs_network_mode)
 		goto start;
@@ -3864,34 +3818,34 @@
 			"You can't use this editor for this kernel.\n");
 		return 1;
 	}
-	if (!ccs_readonly_mode)
+	if (!readonly_mode)
 		ccs_load_readwrite();
 start:
 	initscr();
-	ccs_editpolicy_color_init();
+	editpolicy_color_init();
 	cbreak();
 	noecho();
 	nonl();
 	intrflush(stdscr, FALSE);
 	keypad(stdscr, TRUE);
 	getmaxyx(stdscr, ccs_window_height, ccs_window_width);
-	if (ccs_refresh_interval) {
+	if (refresh_interval) {
 		signal(SIGALRM, ccs_sigalrm_handler);
-		alarm(ccs_refresh_interval);
+		alarm(refresh_interval);
 		timeout(1000);
 	}
 	ccs_rl.max = 20;
 	ccs_rl.history = ccs_malloc(ccs_rl.max * sizeof(const char *));
-	while (ccs_current_screen < CCS_MAXSCREEN) {
+	while (current_screen < MAX_SCREEN_TYPE) {
 		ccs_resize_window();
-		ccs_current_screen = ccs_generic_list_loop();
+		current_screen = ccs_generic_list_loop();
 	}
 	alarm(0);
 	clear();
 	move(0, 0);
 	refresh();
 	endwin();
-	if (ccs_offline_mode && !ccs_readonly_mode)
+	if (offline_mode && !readonly_mode)
 		ccs_save_offline();
 	ccs_clear_domain_policy3();
 	return 0;
Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.h
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.h	(revision 6399)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.h	(working copy)
@@ -23,396 +23,397 @@
 #include <signal.h>
 #include <curses.h>
 
-enum ccs_screen_type {
-	CCS_SCREEN_EXCEPTION_LIST,
-	CCS_SCREEN_DOMAIN_LIST,
-	CCS_SCREEN_ACL_LIST,
-	CCS_SCREEN_PROFILE_LIST,
-	CCS_SCREEN_MANAGER_LIST,
-	/* CCS_SCREEN_QUERY_LIST, */
-	CCS_SCREEN_NS_LIST,
-	CCS_SCREEN_STAT_LIST,
-	CCS_MAXSCREEN
+enum screen_type {
+	SCREEN_EXCEPTION_LIST,
+	SCREEN_DOMAIN_LIST,
+	SCREEN_ACL_LIST,
+	SCREEN_PROFILE_LIST,
+	SCREEN_MANAGER_LIST,
+	/* SCREEN_QUERY_LIST, */
+	SCREEN_NS_LIST,
+	SCREEN_STAT_LIST,
+	MAX_SCREEN_TYPE
 };
 
-enum ccs_transition_type {
+enum transition_type {
 	/* Do not change this order, */
-	CCS_TRANSITION_CONTROL_NO_RESET,
-	CCS_TRANSITION_CONTROL_RESET,
-	CCS_TRANSITION_CONTROL_NO_INITIALIZE,
-	CCS_TRANSITION_CONTROL_INITIALIZE,
-	CCS_TRANSITION_CONTROL_NO_KEEP,
-	CCS_TRANSITION_CONTROL_KEEP,
-	CCS_MAX_TRANSITION_TYPE
+	TRANSITION_NO_RESET,
+	TRANSITION_RESET,
+	TRANSITION_NO_INITIALIZE,
+	TRANSITION_INITIALIZE,
+	TRANSITION_NO_KEEP,
+	TRANSITION_KEEP,
+	MAX_TRANSITION_TYPE
 };
 
-enum ccs_editpolicy_directives {
-	CCS_DIRECTIVE_NONE,
-	CCS_DIRECTIVE_ACL_GROUP_000,
-	CCS_DIRECTIVE_ACL_GROUP_001,
-	CCS_DIRECTIVE_ACL_GROUP_002,
-	CCS_DIRECTIVE_ACL_GROUP_003,
-	CCS_DIRECTIVE_ACL_GROUP_004,
-	CCS_DIRECTIVE_ACL_GROUP_005,
-	CCS_DIRECTIVE_ACL_GROUP_006,
-	CCS_DIRECTIVE_ACL_GROUP_007,
-	CCS_DIRECTIVE_ACL_GROUP_008,
-	CCS_DIRECTIVE_ACL_GROUP_009,
-	CCS_DIRECTIVE_ACL_GROUP_010,
-	CCS_DIRECTIVE_ACL_GROUP_011,
-	CCS_DIRECTIVE_ACL_GROUP_012,
-	CCS_DIRECTIVE_ACL_GROUP_013,
-	CCS_DIRECTIVE_ACL_GROUP_014,
-	CCS_DIRECTIVE_ACL_GROUP_015,
-	CCS_DIRECTIVE_ACL_GROUP_016,
-	CCS_DIRECTIVE_ACL_GROUP_017,
-	CCS_DIRECTIVE_ACL_GROUP_018,
-	CCS_DIRECTIVE_ACL_GROUP_019,
-	CCS_DIRECTIVE_ACL_GROUP_020,
-	CCS_DIRECTIVE_ACL_GROUP_021,
-	CCS_DIRECTIVE_ACL_GROUP_022,
-	CCS_DIRECTIVE_ACL_GROUP_023,
-	CCS_DIRECTIVE_ACL_GROUP_024,
-	CCS_DIRECTIVE_ACL_GROUP_025,
-	CCS_DIRECTIVE_ACL_GROUP_026,
-	CCS_DIRECTIVE_ACL_GROUP_027,
-	CCS_DIRECTIVE_ACL_GROUP_028,
-	CCS_DIRECTIVE_ACL_GROUP_029,
-	CCS_DIRECTIVE_ACL_GROUP_030,
-	CCS_DIRECTIVE_ACL_GROUP_031,
-	CCS_DIRECTIVE_ACL_GROUP_032,
-	CCS_DIRECTIVE_ACL_GROUP_033,
-	CCS_DIRECTIVE_ACL_GROUP_034,
-	CCS_DIRECTIVE_ACL_GROUP_035,
-	CCS_DIRECTIVE_ACL_GROUP_036,
-	CCS_DIRECTIVE_ACL_GROUP_037,
-	CCS_DIRECTIVE_ACL_GROUP_038,
-	CCS_DIRECTIVE_ACL_GROUP_039,
-	CCS_DIRECTIVE_ACL_GROUP_040,
-	CCS_DIRECTIVE_ACL_GROUP_041,
-	CCS_DIRECTIVE_ACL_GROUP_042,
-	CCS_DIRECTIVE_ACL_GROUP_043,
-	CCS_DIRECTIVE_ACL_GROUP_044,
-	CCS_DIRECTIVE_ACL_GROUP_045,
-	CCS_DIRECTIVE_ACL_GROUP_046,
-	CCS_DIRECTIVE_ACL_GROUP_047,
-	CCS_DIRECTIVE_ACL_GROUP_048,
-	CCS_DIRECTIVE_ACL_GROUP_049,
-	CCS_DIRECTIVE_ACL_GROUP_050,
-	CCS_DIRECTIVE_ACL_GROUP_051,
-	CCS_DIRECTIVE_ACL_GROUP_052,
-	CCS_DIRECTIVE_ACL_GROUP_053,
-	CCS_DIRECTIVE_ACL_GROUP_054,
-	CCS_DIRECTIVE_ACL_GROUP_055,
-	CCS_DIRECTIVE_ACL_GROUP_056,
-	CCS_DIRECTIVE_ACL_GROUP_057,
-	CCS_DIRECTIVE_ACL_GROUP_058,
-	CCS_DIRECTIVE_ACL_GROUP_059,
-	CCS_DIRECTIVE_ACL_GROUP_060,
-	CCS_DIRECTIVE_ACL_GROUP_061,
-	CCS_DIRECTIVE_ACL_GROUP_062,
-	CCS_DIRECTIVE_ACL_GROUP_063,
-	CCS_DIRECTIVE_ACL_GROUP_064,
-	CCS_DIRECTIVE_ACL_GROUP_065,
-	CCS_DIRECTIVE_ACL_GROUP_066,
-	CCS_DIRECTIVE_ACL_GROUP_067,
-	CCS_DIRECTIVE_ACL_GROUP_068,
-	CCS_DIRECTIVE_ACL_GROUP_069,
-	CCS_DIRECTIVE_ACL_GROUP_070,
-	CCS_DIRECTIVE_ACL_GROUP_071,
-	CCS_DIRECTIVE_ACL_GROUP_072,
-	CCS_DIRECTIVE_ACL_GROUP_073,
-	CCS_DIRECTIVE_ACL_GROUP_074,
-	CCS_DIRECTIVE_ACL_GROUP_075,
-	CCS_DIRECTIVE_ACL_GROUP_076,
-	CCS_DIRECTIVE_ACL_GROUP_077,
-	CCS_DIRECTIVE_ACL_GROUP_078,
-	CCS_DIRECTIVE_ACL_GROUP_079,
-	CCS_DIRECTIVE_ACL_GROUP_080,
-	CCS_DIRECTIVE_ACL_GROUP_081,
-	CCS_DIRECTIVE_ACL_GROUP_082,
-	CCS_DIRECTIVE_ACL_GROUP_083,
-	CCS_DIRECTIVE_ACL_GROUP_084,
-	CCS_DIRECTIVE_ACL_GROUP_085,
-	CCS_DIRECTIVE_ACL_GROUP_086,
-	CCS_DIRECTIVE_ACL_GROUP_087,
-	CCS_DIRECTIVE_ACL_GROUP_088,
-	CCS_DIRECTIVE_ACL_GROUP_089,
-	CCS_DIRECTIVE_ACL_GROUP_090,
-	CCS_DIRECTIVE_ACL_GROUP_091,
-	CCS_DIRECTIVE_ACL_GROUP_092,
-	CCS_DIRECTIVE_ACL_GROUP_093,
-	CCS_DIRECTIVE_ACL_GROUP_094,
-	CCS_DIRECTIVE_ACL_GROUP_095,
-	CCS_DIRECTIVE_ACL_GROUP_096,
-	CCS_DIRECTIVE_ACL_GROUP_097,
-	CCS_DIRECTIVE_ACL_GROUP_098,
-	CCS_DIRECTIVE_ACL_GROUP_099,
-	CCS_DIRECTIVE_ACL_GROUP_100,
-	CCS_DIRECTIVE_ACL_GROUP_101,
-	CCS_DIRECTIVE_ACL_GROUP_102,
-	CCS_DIRECTIVE_ACL_GROUP_103,
-	CCS_DIRECTIVE_ACL_GROUP_104,
-	CCS_DIRECTIVE_ACL_GROUP_105,
-	CCS_DIRECTIVE_ACL_GROUP_106,
-	CCS_DIRECTIVE_ACL_GROUP_107,
-	CCS_DIRECTIVE_ACL_GROUP_108,
-	CCS_DIRECTIVE_ACL_GROUP_109,
-	CCS_DIRECTIVE_ACL_GROUP_110,
-	CCS_DIRECTIVE_ACL_GROUP_111,
-	CCS_DIRECTIVE_ACL_GROUP_112,
-	CCS_DIRECTIVE_ACL_GROUP_113,
-	CCS_DIRECTIVE_ACL_GROUP_114,
-	CCS_DIRECTIVE_ACL_GROUP_115,
-	CCS_DIRECTIVE_ACL_GROUP_116,
-	CCS_DIRECTIVE_ACL_GROUP_117,
-	CCS_DIRECTIVE_ACL_GROUP_118,
-	CCS_DIRECTIVE_ACL_GROUP_119,
-	CCS_DIRECTIVE_ACL_GROUP_120,
-	CCS_DIRECTIVE_ACL_GROUP_121,
-	CCS_DIRECTIVE_ACL_GROUP_122,
-	CCS_DIRECTIVE_ACL_GROUP_123,
-	CCS_DIRECTIVE_ACL_GROUP_124,
-	CCS_DIRECTIVE_ACL_GROUP_125,
-	CCS_DIRECTIVE_ACL_GROUP_126,
-	CCS_DIRECTIVE_ACL_GROUP_127,
-	CCS_DIRECTIVE_ACL_GROUP_128,
-	CCS_DIRECTIVE_ACL_GROUP_129,
-	CCS_DIRECTIVE_ACL_GROUP_130,
-	CCS_DIRECTIVE_ACL_GROUP_131,
-	CCS_DIRECTIVE_ACL_GROUP_132,
-	CCS_DIRECTIVE_ACL_GROUP_133,
-	CCS_DIRECTIVE_ACL_GROUP_134,
-	CCS_DIRECTIVE_ACL_GROUP_135,
-	CCS_DIRECTIVE_ACL_GROUP_136,
-	CCS_DIRECTIVE_ACL_GROUP_137,
-	CCS_DIRECTIVE_ACL_GROUP_138,
-	CCS_DIRECTIVE_ACL_GROUP_139,
-	CCS_DIRECTIVE_ACL_GROUP_140,
-	CCS_DIRECTIVE_ACL_GROUP_141,
-	CCS_DIRECTIVE_ACL_GROUP_142,
-	CCS_DIRECTIVE_ACL_GROUP_143,
-	CCS_DIRECTIVE_ACL_GROUP_144,
-	CCS_DIRECTIVE_ACL_GROUP_145,
-	CCS_DIRECTIVE_ACL_GROUP_146,
-	CCS_DIRECTIVE_ACL_GROUP_147,
-	CCS_DIRECTIVE_ACL_GROUP_148,
-	CCS_DIRECTIVE_ACL_GROUP_149,
-	CCS_DIRECTIVE_ACL_GROUP_150,
-	CCS_DIRECTIVE_ACL_GROUP_151,
-	CCS_DIRECTIVE_ACL_GROUP_152,
-	CCS_DIRECTIVE_ACL_GROUP_153,
-	CCS_DIRECTIVE_ACL_GROUP_154,
-	CCS_DIRECTIVE_ACL_GROUP_155,
-	CCS_DIRECTIVE_ACL_GROUP_156,
-	CCS_DIRECTIVE_ACL_GROUP_157,
-	CCS_DIRECTIVE_ACL_GROUP_158,
-	CCS_DIRECTIVE_ACL_GROUP_159,
-	CCS_DIRECTIVE_ACL_GROUP_160,
-	CCS_DIRECTIVE_ACL_GROUP_161,
-	CCS_DIRECTIVE_ACL_GROUP_162,
-	CCS_DIRECTIVE_ACL_GROUP_163,
-	CCS_DIRECTIVE_ACL_GROUP_164,
-	CCS_DIRECTIVE_ACL_GROUP_165,
-	CCS_DIRECTIVE_ACL_GROUP_166,
-	CCS_DIRECTIVE_ACL_GROUP_167,
-	CCS_DIRECTIVE_ACL_GROUP_168,
-	CCS_DIRECTIVE_ACL_GROUP_169,
-	CCS_DIRECTIVE_ACL_GROUP_170,
-	CCS_DIRECTIVE_ACL_GROUP_171,
-	CCS_DIRECTIVE_ACL_GROUP_172,
-	CCS_DIRECTIVE_ACL_GROUP_173,
-	CCS_DIRECTIVE_ACL_GROUP_174,
-	CCS_DIRECTIVE_ACL_GROUP_175,
-	CCS_DIRECTIVE_ACL_GROUP_176,
-	CCS_DIRECTIVE_ACL_GROUP_177,
-	CCS_DIRECTIVE_ACL_GROUP_178,
-	CCS_DIRECTIVE_ACL_GROUP_179,
-	CCS_DIRECTIVE_ACL_GROUP_180,
-	CCS_DIRECTIVE_ACL_GROUP_181,
-	CCS_DIRECTIVE_ACL_GROUP_182,
-	CCS_DIRECTIVE_ACL_GROUP_183,
-	CCS_DIRECTIVE_ACL_GROUP_184,
-	CCS_DIRECTIVE_ACL_GROUP_185,
-	CCS_DIRECTIVE_ACL_GROUP_186,
-	CCS_DIRECTIVE_ACL_GROUP_187,
-	CCS_DIRECTIVE_ACL_GROUP_188,
-	CCS_DIRECTIVE_ACL_GROUP_189,
-	CCS_DIRECTIVE_ACL_GROUP_190,
-	CCS_DIRECTIVE_ACL_GROUP_191,
-	CCS_DIRECTIVE_ACL_GROUP_192,
-	CCS_DIRECTIVE_ACL_GROUP_193,
-	CCS_DIRECTIVE_ACL_GROUP_194,
-	CCS_DIRECTIVE_ACL_GROUP_195,
-	CCS_DIRECTIVE_ACL_GROUP_196,
-	CCS_DIRECTIVE_ACL_GROUP_197,
-	CCS_DIRECTIVE_ACL_GROUP_198,
-	CCS_DIRECTIVE_ACL_GROUP_199,
-	CCS_DIRECTIVE_ACL_GROUP_200,
-	CCS_DIRECTIVE_ACL_GROUP_201,
-	CCS_DIRECTIVE_ACL_GROUP_202,
-	CCS_DIRECTIVE_ACL_GROUP_203,
-	CCS_DIRECTIVE_ACL_GROUP_204,
-	CCS_DIRECTIVE_ACL_GROUP_205,
-	CCS_DIRECTIVE_ACL_GROUP_206,
-	CCS_DIRECTIVE_ACL_GROUP_207,
-	CCS_DIRECTIVE_ACL_GROUP_208,
-	CCS_DIRECTIVE_ACL_GROUP_209,
-	CCS_DIRECTIVE_ACL_GROUP_210,
-	CCS_DIRECTIVE_ACL_GROUP_211,
-	CCS_DIRECTIVE_ACL_GROUP_212,
-	CCS_DIRECTIVE_ACL_GROUP_213,
-	CCS_DIRECTIVE_ACL_GROUP_214,
-	CCS_DIRECTIVE_ACL_GROUP_215,
-	CCS_DIRECTIVE_ACL_GROUP_216,
-	CCS_DIRECTIVE_ACL_GROUP_217,
-	CCS_DIRECTIVE_ACL_GROUP_218,
-	CCS_DIRECTIVE_ACL_GROUP_219,
-	CCS_DIRECTIVE_ACL_GROUP_220,
-	CCS_DIRECTIVE_ACL_GROUP_221,
-	CCS_DIRECTIVE_ACL_GROUP_222,
-	CCS_DIRECTIVE_ACL_GROUP_223,
-	CCS_DIRECTIVE_ACL_GROUP_224,
-	CCS_DIRECTIVE_ACL_GROUP_225,
-	CCS_DIRECTIVE_ACL_GROUP_226,
-	CCS_DIRECTIVE_ACL_GROUP_227,
-	CCS_DIRECTIVE_ACL_GROUP_228,
-	CCS_DIRECTIVE_ACL_GROUP_229,
-	CCS_DIRECTIVE_ACL_GROUP_230,
-	CCS_DIRECTIVE_ACL_GROUP_231,
-	CCS_DIRECTIVE_ACL_GROUP_232,
-	CCS_DIRECTIVE_ACL_GROUP_233,
-	CCS_DIRECTIVE_ACL_GROUP_234,
-	CCS_DIRECTIVE_ACL_GROUP_235,
-	CCS_DIRECTIVE_ACL_GROUP_236,
-	CCS_DIRECTIVE_ACL_GROUP_237,
-	CCS_DIRECTIVE_ACL_GROUP_238,
-	CCS_DIRECTIVE_ACL_GROUP_239,
-	CCS_DIRECTIVE_ACL_GROUP_240,
-	CCS_DIRECTIVE_ACL_GROUP_241,
-	CCS_DIRECTIVE_ACL_GROUP_242,
-	CCS_DIRECTIVE_ACL_GROUP_243,
-	CCS_DIRECTIVE_ACL_GROUP_244,
-	CCS_DIRECTIVE_ACL_GROUP_245,
-	CCS_DIRECTIVE_ACL_GROUP_246,
-	CCS_DIRECTIVE_ACL_GROUP_247,
-	CCS_DIRECTIVE_ACL_GROUP_248,
-	CCS_DIRECTIVE_ACL_GROUP_249,
-	CCS_DIRECTIVE_ACL_GROUP_250,
-	CCS_DIRECTIVE_ACL_GROUP_251,
-	CCS_DIRECTIVE_ACL_GROUP_252,
-	CCS_DIRECTIVE_ACL_GROUP_253,
-	CCS_DIRECTIVE_ACL_GROUP_254,
-	CCS_DIRECTIVE_ACL_GROUP_255,
-	CCS_DIRECTIVE_ADDRESS_GROUP,
-	CCS_DIRECTIVE_AGGREGATOR,
-	CCS_DIRECTIVE_CAPABILITY,
-	CCS_DIRECTIVE_DENY_AUTOBIND,
-	CCS_DIRECTIVE_FILE_APPEND,
-	CCS_DIRECTIVE_FILE_CHGRP,
-	CCS_DIRECTIVE_FILE_CHMOD,
-	CCS_DIRECTIVE_FILE_CHOWN,
-	CCS_DIRECTIVE_FILE_CHROOT,
-	CCS_DIRECTIVE_FILE_CREATE,
-	CCS_DIRECTIVE_FILE_EXECUTE,
-	CCS_DIRECTIVE_FILE_GETATTR,
-	CCS_DIRECTIVE_FILE_IOCTL,
-	CCS_DIRECTIVE_FILE_LINK,
-	CCS_DIRECTIVE_FILE_MKBLOCK,
-	CCS_DIRECTIVE_FILE_MKCHAR,
-	CCS_DIRECTIVE_FILE_MKDIR,
-	CCS_DIRECTIVE_FILE_MKFIFO,
-	CCS_DIRECTIVE_FILE_MKSOCK,
-	CCS_DIRECTIVE_FILE_MOUNT,
-	CCS_DIRECTIVE_FILE_PIVOT_ROOT,
-	CCS_DIRECTIVE_FILE_READ,
-	CCS_DIRECTIVE_FILE_RENAME,
-	CCS_DIRECTIVE_FILE_RMDIR,
-	CCS_DIRECTIVE_FILE_SYMLINK,
-	CCS_DIRECTIVE_FILE_TRUNCATE,
-	CCS_DIRECTIVE_FILE_UNLINK,
-	CCS_DIRECTIVE_FILE_UNMOUNT,
-	CCS_DIRECTIVE_FILE_WRITE,
-	CCS_DIRECTIVE_INITIALIZE_DOMAIN,
-	CCS_DIRECTIVE_IPC_SIGNAL,
-	CCS_DIRECTIVE_KEEP_DOMAIN,
-	CCS_DIRECTIVE_MISC_ENV,
-	CCS_DIRECTIVE_NETWORK_INET,
-	CCS_DIRECTIVE_NETWORK_UNIX,
-	CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN,
-	CCS_DIRECTIVE_NO_KEEP_DOMAIN,
-	CCS_DIRECTIVE_NO_RESET_DOMAIN,
-	CCS_DIRECTIVE_NUMBER_GROUP,
-	CCS_DIRECTIVE_PATH_GROUP,
-	CCS_DIRECTIVE_QUOTA_EXCEEDED,
-	CCS_DIRECTIVE_RESET_DOMAIN,
-	CCS_DIRECTIVE_TASK_AUTO_DOMAIN_TRANSITION,
-	CCS_DIRECTIVE_TASK_AUTO_EXECUTE_HANDLER,
-	CCS_DIRECTIVE_TASK_DENIED_EXECUTE_HANDLER,
-	CCS_DIRECTIVE_TASK_MANUAL_DOMAIN_TRANSITION,
-	CCS_DIRECTIVE_TRANSITION_FAILED,
-	CCS_DIRECTIVE_USE_GROUP,
-	CCS_DIRECTIVE_USE_PROFILE,
-	CCS_MAX_DIRECTIVE_INDEX
+enum directive_type {
+	DIRECTIVE_NONE,
+	DIRECTIVE_ACL_GROUP_000,
+	DIRECTIVE_ACL_GROUP_001,
+	DIRECTIVE_ACL_GROUP_002,
+	DIRECTIVE_ACL_GROUP_003,
+	DIRECTIVE_ACL_GROUP_004,
+	DIRECTIVE_ACL_GROUP_005,
+	DIRECTIVE_ACL_GROUP_006,
+	DIRECTIVE_ACL_GROUP_007,
+	DIRECTIVE_ACL_GROUP_008,
+	DIRECTIVE_ACL_GROUP_009,
+	DIRECTIVE_ACL_GROUP_010,
+	DIRECTIVE_ACL_GROUP_011,
+	DIRECTIVE_ACL_GROUP_012,
+	DIRECTIVE_ACL_GROUP_013,
+	DIRECTIVE_ACL_GROUP_014,
+	DIRECTIVE_ACL_GROUP_015,
+	DIRECTIVE_ACL_GROUP_016,
+	DIRECTIVE_ACL_GROUP_017,
+	DIRECTIVE_ACL_GROUP_018,
+	DIRECTIVE_ACL_GROUP_019,
+	DIRECTIVE_ACL_GROUP_020,
+	DIRECTIVE_ACL_GROUP_021,
+	DIRECTIVE_ACL_GROUP_022,
+	DIRECTIVE_ACL_GROUP_023,
+	DIRECTIVE_ACL_GROUP_024,
+	DIRECTIVE_ACL_GROUP_025,
+	DIRECTIVE_ACL_GROUP_026,
+	DIRECTIVE_ACL_GROUP_027,
+	DIRECTIVE_ACL_GROUP_028,
+	DIRECTIVE_ACL_GROUP_029,
+	DIRECTIVE_ACL_GROUP_030,
+	DIRECTIVE_ACL_GROUP_031,
+	DIRECTIVE_ACL_GROUP_032,
+	DIRECTIVE_ACL_GROUP_033,
+	DIRECTIVE_ACL_GROUP_034,
+	DIRECTIVE_ACL_GROUP_035,
+	DIRECTIVE_ACL_GROUP_036,
+	DIRECTIVE_ACL_GROUP_037,
+	DIRECTIVE_ACL_GROUP_038,
+	DIRECTIVE_ACL_GROUP_039,
+	DIRECTIVE_ACL_GROUP_040,
+	DIRECTIVE_ACL_GROUP_041,
+	DIRECTIVE_ACL_GROUP_042,
+	DIRECTIVE_ACL_GROUP_043,
+	DIRECTIVE_ACL_GROUP_044,
+	DIRECTIVE_ACL_GROUP_045,
+	DIRECTIVE_ACL_GROUP_046,
+	DIRECTIVE_ACL_GROUP_047,
+	DIRECTIVE_ACL_GROUP_048,
+	DIRECTIVE_ACL_GROUP_049,
+	DIRECTIVE_ACL_GROUP_050,
+	DIRECTIVE_ACL_GROUP_051,
+	DIRECTIVE_ACL_GROUP_052,
+	DIRECTIVE_ACL_GROUP_053,
+	DIRECTIVE_ACL_GROUP_054,
+	DIRECTIVE_ACL_GROUP_055,
+	DIRECTIVE_ACL_GROUP_056,
+	DIRECTIVE_ACL_GROUP_057,
+	DIRECTIVE_ACL_GROUP_058,
+	DIRECTIVE_ACL_GROUP_059,
+	DIRECTIVE_ACL_GROUP_060,
+	DIRECTIVE_ACL_GROUP_061,
+	DIRECTIVE_ACL_GROUP_062,
+	DIRECTIVE_ACL_GROUP_063,
+	DIRECTIVE_ACL_GROUP_064,
+	DIRECTIVE_ACL_GROUP_065,
+	DIRECTIVE_ACL_GROUP_066,
+	DIRECTIVE_ACL_GROUP_067,
+	DIRECTIVE_ACL_GROUP_068,
+	DIRECTIVE_ACL_GROUP_069,
+	DIRECTIVE_ACL_GROUP_070,
+	DIRECTIVE_ACL_GROUP_071,
+	DIRECTIVE_ACL_GROUP_072,
+	DIRECTIVE_ACL_GROUP_073,
+	DIRECTIVE_ACL_GROUP_074,
+	DIRECTIVE_ACL_GROUP_075,
+	DIRECTIVE_ACL_GROUP_076,
+	DIRECTIVE_ACL_GROUP_077,
+	DIRECTIVE_ACL_GROUP_078,
+	DIRECTIVE_ACL_GROUP_079,
+	DIRECTIVE_ACL_GROUP_080,
+	DIRECTIVE_ACL_GROUP_081,
+	DIRECTIVE_ACL_GROUP_082,
+	DIRECTIVE_ACL_GROUP_083,
+	DIRECTIVE_ACL_GROUP_084,
+	DIRECTIVE_ACL_GROUP_085,
+	DIRECTIVE_ACL_GROUP_086,
+	DIRECTIVE_ACL_GROUP_087,
+	DIRECTIVE_ACL_GROUP_088,
+	DIRECTIVE_ACL_GROUP_089,
+	DIRECTIVE_ACL_GROUP_090,
+	DIRECTIVE_ACL_GROUP_091,
+	DIRECTIVE_ACL_GROUP_092,
+	DIRECTIVE_ACL_GROUP_093,
+	DIRECTIVE_ACL_GROUP_094,
+	DIRECTIVE_ACL_GROUP_095,
+	DIRECTIVE_ACL_GROUP_096,
+	DIRECTIVE_ACL_GROUP_097,
+	DIRECTIVE_ACL_GROUP_098,
+	DIRECTIVE_ACL_GROUP_099,
+	DIRECTIVE_ACL_GROUP_100,
+	DIRECTIVE_ACL_GROUP_101,
+	DIRECTIVE_ACL_GROUP_102,
+	DIRECTIVE_ACL_GROUP_103,
+	DIRECTIVE_ACL_GROUP_104,
+	DIRECTIVE_ACL_GROUP_105,
+	DIRECTIVE_ACL_GROUP_106,
+	DIRECTIVE_ACL_GROUP_107,
+	DIRECTIVE_ACL_GROUP_108,
+	DIRECTIVE_ACL_GROUP_109,
+	DIRECTIVE_ACL_GROUP_110,
+	DIRECTIVE_ACL_GROUP_111,
+	DIRECTIVE_ACL_GROUP_112,
+	DIRECTIVE_ACL_GROUP_113,
+	DIRECTIVE_ACL_GROUP_114,
+	DIRECTIVE_ACL_GROUP_115,
+	DIRECTIVE_ACL_GROUP_116,
+	DIRECTIVE_ACL_GROUP_117,
+	DIRECTIVE_ACL_GROUP_118,
+	DIRECTIVE_ACL_GROUP_119,
+	DIRECTIVE_ACL_GROUP_120,
+	DIRECTIVE_ACL_GROUP_121,
+	DIRECTIVE_ACL_GROUP_122,
+	DIRECTIVE_ACL_GROUP_123,
+	DIRECTIVE_ACL_GROUP_124,
+	DIRECTIVE_ACL_GROUP_125,
+	DIRECTIVE_ACL_GROUP_126,
+	DIRECTIVE_ACL_GROUP_127,
+	DIRECTIVE_ACL_GROUP_128,
+	DIRECTIVE_ACL_GROUP_129,
+	DIRECTIVE_ACL_GROUP_130,
+	DIRECTIVE_ACL_GROUP_131,
+	DIRECTIVE_ACL_GROUP_132,
+	DIRECTIVE_ACL_GROUP_133,
+	DIRECTIVE_ACL_GROUP_134,
+	DIRECTIVE_ACL_GROUP_135,
+	DIRECTIVE_ACL_GROUP_136,
+	DIRECTIVE_ACL_GROUP_137,
+	DIRECTIVE_ACL_GROUP_138,
+	DIRECTIVE_ACL_GROUP_139,
+	DIRECTIVE_ACL_GROUP_140,
+	DIRECTIVE_ACL_GROUP_141,
+	DIRECTIVE_ACL_GROUP_142,
+	DIRECTIVE_ACL_GROUP_143,
+	DIRECTIVE_ACL_GROUP_144,
+	DIRECTIVE_ACL_GROUP_145,
+	DIRECTIVE_ACL_GROUP_146,
+	DIRECTIVE_ACL_GROUP_147,
+	DIRECTIVE_ACL_GROUP_148,
+	DIRECTIVE_ACL_GROUP_149,
+	DIRECTIVE_ACL_GROUP_150,
+	DIRECTIVE_ACL_GROUP_151,
+	DIRECTIVE_ACL_GROUP_152,
+	DIRECTIVE_ACL_GROUP_153,
+	DIRECTIVE_ACL_GROUP_154,
+	DIRECTIVE_ACL_GROUP_155,
+	DIRECTIVE_ACL_GROUP_156,
+	DIRECTIVE_ACL_GROUP_157,
+	DIRECTIVE_ACL_GROUP_158,
+	DIRECTIVE_ACL_GROUP_159,
+	DIRECTIVE_ACL_GROUP_160,
+	DIRECTIVE_ACL_GROUP_161,
+	DIRECTIVE_ACL_GROUP_162,
+	DIRECTIVE_ACL_GROUP_163,
+	DIRECTIVE_ACL_GROUP_164,
+	DIRECTIVE_ACL_GROUP_165,
+	DIRECTIVE_ACL_GROUP_166,
+	DIRECTIVE_ACL_GROUP_167,
+	DIRECTIVE_ACL_GROUP_168,
+	DIRECTIVE_ACL_GROUP_169,
+	DIRECTIVE_ACL_GROUP_170,
+	DIRECTIVE_ACL_GROUP_171,
+	DIRECTIVE_ACL_GROUP_172,
+	DIRECTIVE_ACL_GROUP_173,
+	DIRECTIVE_ACL_GROUP_174,
+	DIRECTIVE_ACL_GROUP_175,
+	DIRECTIVE_ACL_GROUP_176,
+	DIRECTIVE_ACL_GROUP_177,
+	DIRECTIVE_ACL_GROUP_178,
+	DIRECTIVE_ACL_GROUP_179,
+	DIRECTIVE_ACL_GROUP_180,
+	DIRECTIVE_ACL_GROUP_181,
+	DIRECTIVE_ACL_GROUP_182,
+	DIRECTIVE_ACL_GROUP_183,
+	DIRECTIVE_ACL_GROUP_184,
+	DIRECTIVE_ACL_GROUP_185,
+	DIRECTIVE_ACL_GROUP_186,
+	DIRECTIVE_ACL_GROUP_187,
+	DIRECTIVE_ACL_GROUP_188,
+	DIRECTIVE_ACL_GROUP_189,
+	DIRECTIVE_ACL_GROUP_190,
+	DIRECTIVE_ACL_GROUP_191,
+	DIRECTIVE_ACL_GROUP_192,
+	DIRECTIVE_ACL_GROUP_193,
+	DIRECTIVE_ACL_GROUP_194,
+	DIRECTIVE_ACL_GROUP_195,
+	DIRECTIVE_ACL_GROUP_196,
+	DIRECTIVE_ACL_GROUP_197,
+	DIRECTIVE_ACL_GROUP_198,
+	DIRECTIVE_ACL_GROUP_199,
+	DIRECTIVE_ACL_GROUP_200,
+	DIRECTIVE_ACL_GROUP_201,
+	DIRECTIVE_ACL_GROUP_202,
+	DIRECTIVE_ACL_GROUP_203,
+	DIRECTIVE_ACL_GROUP_204,
+	DIRECTIVE_ACL_GROUP_205,
+	DIRECTIVE_ACL_GROUP_206,
+	DIRECTIVE_ACL_GROUP_207,
+	DIRECTIVE_ACL_GROUP_208,
+	DIRECTIVE_ACL_GROUP_209,
+	DIRECTIVE_ACL_GROUP_210,
+	DIRECTIVE_ACL_GROUP_211,
+	DIRECTIVE_ACL_GROUP_212,
+	DIRECTIVE_ACL_GROUP_213,
+	DIRECTIVE_ACL_GROUP_214,
+	DIRECTIVE_ACL_GROUP_215,
+	DIRECTIVE_ACL_GROUP_216,
+	DIRECTIVE_ACL_GROUP_217,
+	DIRECTIVE_ACL_GROUP_218,
+	DIRECTIVE_ACL_GROUP_219,
+	DIRECTIVE_ACL_GROUP_220,
+	DIRECTIVE_ACL_GROUP_221,
+	DIRECTIVE_ACL_GROUP_222,
+	DIRECTIVE_ACL_GROUP_223,
+	DIRECTIVE_ACL_GROUP_224,
+	DIRECTIVE_ACL_GROUP_225,
+	DIRECTIVE_ACL_GROUP_226,
+	DIRECTIVE_ACL_GROUP_227,
+	DIRECTIVE_ACL_GROUP_228,
+	DIRECTIVE_ACL_GROUP_229,
+	DIRECTIVE_ACL_GROUP_230,
+	DIRECTIVE_ACL_GROUP_231,
+	DIRECTIVE_ACL_GROUP_232,
+	DIRECTIVE_ACL_GROUP_233,
+	DIRECTIVE_ACL_GROUP_234,
+	DIRECTIVE_ACL_GROUP_235,
+	DIRECTIVE_ACL_GROUP_236,
+	DIRECTIVE_ACL_GROUP_237,
+	DIRECTIVE_ACL_GROUP_238,
+	DIRECTIVE_ACL_GROUP_239,
+	DIRECTIVE_ACL_GROUP_240,
+	DIRECTIVE_ACL_GROUP_241,
+	DIRECTIVE_ACL_GROUP_242,
+	DIRECTIVE_ACL_GROUP_243,
+	DIRECTIVE_ACL_GROUP_244,
+	DIRECTIVE_ACL_GROUP_245,
+	DIRECTIVE_ACL_GROUP_246,
+	DIRECTIVE_ACL_GROUP_247,
+	DIRECTIVE_ACL_GROUP_248,
+	DIRECTIVE_ACL_GROUP_249,
+	DIRECTIVE_ACL_GROUP_250,
+	DIRECTIVE_ACL_GROUP_251,
+	DIRECTIVE_ACL_GROUP_252,
+	DIRECTIVE_ACL_GROUP_253,
+	DIRECTIVE_ACL_GROUP_254,
+	DIRECTIVE_ACL_GROUP_255,
+	DIRECTIVE_ADDRESS_GROUP,
+	DIRECTIVE_AGGREGATOR,
+	DIRECTIVE_CAPABILITY,
+	DIRECTIVE_DENY_AUTOBIND,
+	DIRECTIVE_FILE_APPEND,
+	DIRECTIVE_FILE_CHGRP,
+	DIRECTIVE_FILE_CHMOD,
+	DIRECTIVE_FILE_CHOWN,
+	DIRECTIVE_FILE_CHROOT,
+	DIRECTIVE_FILE_CREATE,
+	DIRECTIVE_FILE_EXECUTE,
+	DIRECTIVE_FILE_GETATTR,
+	DIRECTIVE_FILE_IOCTL,
+	DIRECTIVE_FILE_LINK,
+	DIRECTIVE_FILE_MKBLOCK,
+	DIRECTIVE_FILE_MKCHAR,
+	DIRECTIVE_FILE_MKDIR,
+	DIRECTIVE_FILE_MKFIFO,
+	DIRECTIVE_FILE_MKSOCK,
+	DIRECTIVE_FILE_MOUNT,
+	DIRECTIVE_FILE_PIVOT_ROOT,
+	DIRECTIVE_FILE_READ,
+	DIRECTIVE_FILE_RENAME,
+	DIRECTIVE_FILE_RMDIR,
+	DIRECTIVE_FILE_SYMLINK,
+	DIRECTIVE_FILE_TRUNCATE,
+	DIRECTIVE_FILE_UNLINK,
+	DIRECTIVE_FILE_UNMOUNT,
+	DIRECTIVE_FILE_WRITE,
+	DIRECTIVE_INITIALIZE_DOMAIN,
+	DIRECTIVE_IPC_SIGNAL,
+	DIRECTIVE_KEEP_DOMAIN,
+	DIRECTIVE_MISC_ENV,
+	DIRECTIVE_NETWORK_INET,
+	DIRECTIVE_NETWORK_UNIX,
+	DIRECTIVE_NO_INITIALIZE_DOMAIN,
+	DIRECTIVE_NO_KEEP_DOMAIN,
+	DIRECTIVE_NO_RESET_DOMAIN,
+	DIRECTIVE_NUMBER_GROUP,
+	DIRECTIVE_PATH_GROUP,
+	DIRECTIVE_QUOTA_EXCEEDED,
+	DIRECTIVE_RESET_DOMAIN,
+	DIRECTIVE_TASK_AUTO_DOMAIN_TRANSITION,
+	DIRECTIVE_TASK_AUTO_EXECUTE_HANDLER,
+	DIRECTIVE_TASK_DENIED_EXECUTE_HANDLER,
+	DIRECTIVE_TASK_MANUAL_DOMAIN_TRANSITION,
+	DIRECTIVE_TRANSITION_FAILED,
+	DIRECTIVE_USE_GROUP,
+	DIRECTIVE_USE_PROFILE,
+	MAX_DIRECTIVE_TYPE
 };
 
-enum ccs_color_pair {
-	CCS_NORMAL,
-	CCS_DOMAIN_HEAD,
-	CCS_DOMAIN_CURSOR,
-	CCS_EXCEPTION_HEAD,
-	CCS_EXCEPTION_CURSOR,
-	CCS_ACL_HEAD,
-	CCS_ACL_CURSOR,
-	CCS_PROFILE_HEAD,
-	CCS_PROFILE_CURSOR,
-	CCS_MANAGER_HEAD,
-	CCS_MANAGER_CURSOR,
-	CCS_STAT_HEAD,
-	CCS_STAT_CURSOR,
-	CCS_DEFAULT_COLOR,
-	CCS_DISP_ERR
+enum color_type {
+	COLOR_NORMAL,
+	COLOR_DOMAIN_HEAD,
+	COLOR_DOMAIN_CURSOR,
+	COLOR_EXCEPTION_HEAD,
+	COLOR_EXCEPTION_CURSOR,
+	COLOR_ACL_HEAD,
+	COLOR_ACL_CURSOR,
+	COLOR_PROFILE_HEAD,
+	COLOR_PROFILE_CURSOR,
+	COLOR_MANAGER_HEAD,
+	COLOR_MANAGER_CURSOR,
+	COLOR_STAT_HEAD,
+	COLOR_STAT_CURSOR,
+	COLOR_DEFAULT_COLOR,
+	COLOR_DISP_ERR
 };
 
-struct ccs_transition_control_entry {
+struct transition_entry {
 	const struct ccs_path_info *ns;
 	const struct ccs_path_info *domainname;    /* This may be NULL */
 	const struct ccs_path_info *program;       /* This may be NULL */
-	u8 type;
+	enum transition_type type;
 };
 
-struct ccs_generic_acl {
-	enum ccs_editpolicy_directives directive;
-	u8 selected;
+struct transition_preference {
+	int index;
+	char *program;
+	char *domainname;
+};
+
+struct generic_entry {
+	enum directive_type directive;
+	_Bool selected;
 	const char *operand;
 };
 
-struct ccs_editpolicy_directive {
+struct editpolicy_directive {
 	const char *original;
 	const char *alias;
 	int original_len;
 	int alias_len;
 };
 
-struct ccs_misc_policy {
-	const struct ccs_path_info **list;
-	int list_len;
-};
-
-struct ccs_path_group_entry {
+struct path_group_entry {
 	const struct ccs_path_info *ns;
 	const struct ccs_path_info *group_name;
 	const struct ccs_path_info **member_name;
 	int member_name_len;
 };
 
-struct ccs_address_group_entry {
+struct address_group_entry {
 	const struct ccs_path_info *group_name;
 	struct ccs_ip_address_entry *member_name;
 	int member_name_len;
 };
 
-struct ccs_number_group_entry {
+struct number_group_entry {
 	const struct ccs_path_info *group_name;
 	struct ccs_number_entry *member_name;
 	int member_name_len;
@@ -422,7 +423,7 @@
 	const char **history;
 	int count;
 	int max;
-	char *search_buffer[CCS_MAXSCREEN];
+	char *search_buffer[MAX_SCREEN_TYPE];
 };
 
 struct ccs_screen {
@@ -432,7 +433,7 @@
 	int y;
 	/* Columns to shift when displaying. */
 	int x;
-	/* For ccs_editpolicy_line_draw(). */
+	/* For editpolicy_line_draw(). */
 	int saved_color_current; /* Initialized to -1 */
 	int saved_color_y;
 };
@@ -441,26 +442,25 @@
 
 #define CCS_EDITPOLICY_CONF "/etc/ccs/tools/editpolicy.conf"
 
-enum ccs_color_pair ccs_editpolicy_color_head(void);
-enum ccs_editpolicy_directives ccs_find_directive(const _Bool forward,
-						  char *line);
-int ccs_editpolicy_get_current(void);
-void ccs_editpolicy_attr_change(const attr_t attr, const _Bool flg);
-void ccs_editpolicy_color_change(const attr_t attr, const _Bool flg);
-void ccs_editpolicy_color_init(void);
-void ccs_editpolicy_init_keyword_map(void);
-void ccs_editpolicy_line_draw(void);
-void ccs_editpolicy_offline_daemon(const int listener, const int notifier);
-void ccs_editpolicy_optimize(const int current);
-void ccs_editpolicy_sttr_restore(void);
-void ccs_editpolicy_sttr_save(void);
-struct ccs_path_group_entry *ccs_find_path_group_ns
+enum color_type editpolicy_color_head(void);
+enum directive_type find_directive(const _Bool forward, char *line);
+int editpolicy_get_current(void);
+void editpolicy_attr_change(const attr_t attr, const _Bool flg);
+void editpolicy_color_change(const attr_t attr, const _Bool flg);
+void editpolicy_color_init(void);
+void editpolicy_init_keyword_map(void);
+void editpolicy_line_draw(void);
+void editpolicy_offline_daemon(const int listener, const int notifier);
+void editpolicy_optimize(const int current);
+void editpolicy_sttr_restore(void);
+void editpolicy_sttr_save(void);
+struct path_group_entry *find_path_group_ns
 (const struct ccs_path_info *ns, const char *group_name);
 
 struct ccs_domain {
 	const struct ccs_path_info *domainname;
 	const struct ccs_path_info *target; /* This may be NULL */
-	const struct ccs_transition_control_entry *d_t; /* This may be NULL */
+	const struct transition_entry *d_t; /* This may be NULL */
 	const struct ccs_path_info **string_ptr;
 	int string_count;
 	int number;   /* domain number (-1 if target or is_dd) */
@@ -478,18 +478,18 @@
 	unsigned char *list_selected;
 };
 
-extern enum ccs_screen_type ccs_current_screen;
-extern int ccs_list_item_count;
-extern int ccs_path_group_list_len;
-extern int ccs_number_group_list_len;
-extern int ccs_address_group_list_len;
+extern enum screen_type current_screen;
+extern int generic_list_len;
+extern int path_group_list_len;
+extern int number_group_list_len;
+extern int address_group_list_len;
 extern int acl_group_list_len[256];
 extern struct ccs_domain_policy3 ccs_dp;
-extern struct ccs_editpolicy_directive ccs_directives[CCS_MAX_DIRECTIVE_INDEX];
-extern struct ccs_generic_acl *ccs_gacl_list;
-extern struct ccs_path_group_entry *ccs_path_group_list;
-extern struct ccs_number_group_entry *ccs_number_group_list;
-extern struct ccs_address_group_entry *ccs_address_group_list;
+extern struct editpolicy_directive directive_map[MAX_DIRECTIVE_TYPE];
+extern struct generic_entry *generic_list;
+extern struct path_group_entry *path_group_list;
+extern struct number_group_entry *number_group_list;
+extern struct address_group_entry *address_group_list;
 extern char **acl_group_list[256];
-extern struct ccs_screen ccs_screen[CCS_MAXSCREEN];
+extern struct ccs_screen ccs_screen[MAX_SCREEN_TYPE];
 extern const struct ccs_path_info *ccs_current_ns;
Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_color.c
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_color.c	(revision 6399)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_color.c	(working copy)
@@ -26,45 +26,45 @@
 #ifdef COLOR_ON
 
 /**
- * ccs_editpolicy_color_init - Initialize line coloring table.
+ * editpolicy_color_init - Initialize line coloring table.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_color_init(void)
+void editpolicy_color_init(void)
 {
 	static struct ccs_color_env_t {
-		enum ccs_color_pair tag;
+		enum color_type tag;
 		short int fore;
 		short int back;
 		const char *name;
 	} color_env[] = {
-		{ CCS_DOMAIN_HEAD,      COLOR_BLACK,
+		{ COLOR_DOMAIN_HEAD,      COLOR_BLACK,
 		  COLOR_GREEN,      "DOMAIN_HEAD" },
-		{ CCS_DOMAIN_CURSOR,    COLOR_BLACK,
+		{ COLOR_DOMAIN_CURSOR,    COLOR_BLACK,
 		  COLOR_GREEN,      "DOMAIN_CURSOR" },
-		{ CCS_EXCEPTION_HEAD,   COLOR_BLACK,
+		{ COLOR_EXCEPTION_HEAD,   COLOR_BLACK,
 		  COLOR_CYAN,       "EXCEPTION_HEAD" },
-		{ CCS_EXCEPTION_CURSOR, COLOR_BLACK,
+		{ COLOR_EXCEPTION_CURSOR, COLOR_BLACK,
 		  COLOR_CYAN,       "EXCEPTION_CURSOR" },
-		{ CCS_ACL_HEAD,         COLOR_BLACK,
+		{ COLOR_ACL_HEAD,         COLOR_BLACK,
 		  COLOR_YELLOW,     "ACL_HEAD" },
-		{ CCS_ACL_CURSOR,       COLOR_BLACK,
+		{ COLOR_ACL_CURSOR,       COLOR_BLACK,
 		  COLOR_YELLOW,     "ACL_CURSOR" },
-		{ CCS_PROFILE_HEAD,     COLOR_WHITE,
+		{ COLOR_PROFILE_HEAD,     COLOR_WHITE,
 		  COLOR_RED,        "PROFILE_HEAD" },
-		{ CCS_PROFILE_CURSOR,   COLOR_WHITE,
+		{ COLOR_PROFILE_CURSOR,   COLOR_WHITE,
 		  COLOR_RED,        "PROFILE_CURSOR" },
-		{ CCS_MANAGER_HEAD,     COLOR_WHITE,
+		{ COLOR_MANAGER_HEAD,     COLOR_WHITE,
 		  COLOR_GREEN,      "MANAGER_HEAD" },
-		{ CCS_MANAGER_CURSOR,   COLOR_WHITE,
+		{ COLOR_MANAGER_CURSOR,   COLOR_WHITE,
 		  COLOR_GREEN,      "MANAGER_CURSOR" },
-		{ CCS_STAT_HEAD,        COLOR_BLACK,
+		{ COLOR_STAT_HEAD,        COLOR_BLACK,
 		  COLOR_YELLOW,     "STAT_HEAD" },
-		{ CCS_STAT_CURSOR,      COLOR_BLACK,
+		{ COLOR_STAT_CURSOR,      COLOR_BLACK,
 		  COLOR_YELLOW,     "STAT_CURSOR" },
-		{ CCS_DEFAULT_COLOR,    COLOR_WHITE,
+		{ COLOR_DEFAULT_COLOR,    COLOR_WHITE,
 		  COLOR_BLACK,      "DEFAULT_COLOR" },
-		{ CCS_NORMAL,           COLOR_WHITE,
+		{ COLOR_NORMAL,           COLOR_WHITE,
 		  COLOR_BLACK,      NULL }
 	};
 	FILE *fp = fopen(CCS_EDITPOLICY_CONF, "r");
@@ -111,22 +111,22 @@
 		struct ccs_color_env_t *colorp = &color_env[i];
 		init_pair(colorp->tag, colorp->fore, colorp->back);
 	}
-	init_pair(CCS_DISP_ERR, COLOR_RED, COLOR_BLACK); /* error message */
-	bkgdset(A_NORMAL | COLOR_PAIR(CCS_DEFAULT_COLOR) | ' ');
-	for (i = 0; i < CCS_MAXSCREEN; i++)
+	init_pair(COLOR_DISP_ERR, COLOR_RED, COLOR_BLACK); /* error message */
+	bkgdset(A_NORMAL | COLOR_PAIR(COLOR_DEFAULT_COLOR) | ' ');
+	for (i = 0; i < MAX_SCREEN_TYPE; i++)
 		ccs_screen[i].saved_color_current = -1;
 }
 
 /**
- * ccs_editpolicy_color_save - Save or load current color.
+ * editpolicy_color_save - Save or load current color.
  *
  * @flg: True if save request, false otherwise.
  *
  * Returns nothing.
  */
-static void ccs_editpolicy_color_save(const _Bool flg)
+static void editpolicy_color_save(const _Bool flg)
 {
-	static attr_t save_color = CCS_DEFAULT_COLOR;
+	static attr_t save_color = COLOR_DEFAULT_COLOR;
 	if (flg)
 		save_color = getattrs(stdscr);
 	else
@@ -134,14 +134,14 @@
 }
 
 /**
- * ccs_editpolicy_color_change - Change current color.
+ * editpolicy_color_change - Change current color.
  *
  * @attr: Coloe to use.
  * @flg:  True if turn on, false otherwise.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_color_change(const attr_t attr, const _Bool flg)
+void editpolicy_color_change(const attr_t attr, const _Bool flg)
 {
 	if (flg)
 		attron(COLOR_PAIR(attr));
@@ -150,14 +150,14 @@
 }
 
 /**
- * ccs_editpolicy_attr_change - Change current attribute.
+ * editpolicy_attr_change - Change current attribute.
  *
  * @attr: Coloe to use.
  * @flg:  True if turn on, false otherwise.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_attr_change(const attr_t attr, const _Bool flg)
+void editpolicy_attr_change(const attr_t attr, const _Bool flg)
 {
 	if (flg)
 		attron(attr);
@@ -166,80 +166,80 @@
 }
 
 /**
- * ccs_editpolicy_sttr_save - Save current color.
+ * editpolicy_sttr_save - Save current color.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_sttr_save(void)
+void editpolicy_sttr_save(void)
 {
-	ccs_editpolicy_color_save(true);
+	editpolicy_color_save(true);
 }
 
 /**
- * ccs_editpolicy_sttr_restore - Load current color.
+ * editpolicy_sttr_restore - Load current color.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_sttr_restore(void)
+void editpolicy_sttr_restore(void)
 {
-	ccs_editpolicy_color_save(false);
+	editpolicy_color_save(false);
 }
 
 /**
- * ccs_editpolicy_color_head - Get color to use for header line.
+ * editpolicy_color_head - Get color to use for header line.
  *
- * Returns one of values in "enum ccs_color_pair".
+ * Returns one of values in "enum color_type".
  */
-enum ccs_color_pair ccs_editpolicy_color_head(void)
+enum color_type editpolicy_color_head(void)
 {
-	switch (ccs_current_screen) {
-	case CCS_SCREEN_DOMAIN_LIST:
-		return CCS_DOMAIN_HEAD;
-	case CCS_SCREEN_EXCEPTION_LIST:
-		return CCS_EXCEPTION_HEAD;
-	case CCS_SCREEN_PROFILE_LIST:
-		return CCS_PROFILE_HEAD;
-	case CCS_SCREEN_MANAGER_LIST:
-		return CCS_MANAGER_HEAD;
-	case CCS_SCREEN_STAT_LIST:
-		return CCS_STAT_HEAD;
+	switch (current_screen) {
+	case SCREEN_DOMAIN_LIST:
+		return COLOR_DOMAIN_HEAD;
+	case SCREEN_EXCEPTION_LIST:
+		return COLOR_EXCEPTION_HEAD;
+	case SCREEN_PROFILE_LIST:
+		return COLOR_PROFILE_HEAD;
+	case SCREEN_MANAGER_LIST:
+		return COLOR_MANAGER_HEAD;
+	case SCREEN_STAT_LIST:
+		return COLOR_STAT_HEAD;
 	default:
-		return CCS_ACL_HEAD;
+		return COLOR_ACL_HEAD;
 	}
 }
 
 /**
- * ccs_editpolicy_color_cursor - Get color to use for cursor line.
+ * editpolicy_color_cursor - Get color to use for cursor line.
  *
- * Returns one of values in "enum ccs_color_pair".
+ * Returns one of values in "enum color_type".
  */
-static inline enum ccs_color_pair ccs_editpolicy_color_cursor(void)
+static inline enum color_type editpolicy_color_cursor(void)
 {
-	switch (ccs_current_screen) {
-	case CCS_SCREEN_DOMAIN_LIST:
-		return CCS_DOMAIN_CURSOR;
-	case CCS_SCREEN_EXCEPTION_LIST:
-		return CCS_EXCEPTION_CURSOR;
-	case CCS_SCREEN_PROFILE_LIST:
-		return CCS_PROFILE_CURSOR;
-	case CCS_SCREEN_MANAGER_LIST:
-		return CCS_MANAGER_CURSOR;
-	case CCS_SCREEN_STAT_LIST:
-		return CCS_STAT_CURSOR;
+	switch (current_screen) {
+	case SCREEN_DOMAIN_LIST:
+		return COLOR_DOMAIN_CURSOR;
+	case SCREEN_EXCEPTION_LIST:
+		return COLOR_EXCEPTION_CURSOR;
+	case SCREEN_PROFILE_LIST:
+		return COLOR_PROFILE_CURSOR;
+	case SCREEN_MANAGER_LIST:
+		return COLOR_MANAGER_CURSOR;
+	case SCREEN_STAT_LIST:
+		return COLOR_STAT_CURSOR;
 	default:
-		return CCS_ACL_CURSOR;
+		return COLOR_ACL_CURSOR;
 	}
 }
 
 /**
- * ccs_editpolicy_line_draw - Update colored line.
+ * editpolicy_line_draw - Update colored line.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_line_draw(void)
+void editpolicy_line_draw(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
-	const int current = ccs_editpolicy_get_current();
+	struct ccs_screen *ptr = &ccs_screen[current_screen];
+	const int current = editpolicy_get_current();
 	int y;
 	int x;
 
@@ -250,11 +250,11 @@
 	if (-1 < ptr->saved_color_current &&
 	    current != ptr->saved_color_current) {
 		move(CCS_HEADER_LINES + ptr->saved_color_y, 0);
-		chgat(-1, A_NORMAL, CCS_DEFAULT_COLOR, NULL);
+		chgat(-1, A_NORMAL, COLOR_DEFAULT_COLOR, NULL);
 	}
 
 	move(y, x);
-	chgat(-1, A_NORMAL, ccs_editpolicy_color_cursor(), NULL);
+	chgat(-1, A_NORMAL, editpolicy_color_cursor(), NULL);
 	touchwin(stdscr);
 
 	ptr->saved_color_current = current;
@@ -264,72 +264,72 @@
 #else
 
 /**
- * ccs_editpolicy_color_init - Initialize line coloring table.
+ * editpolicy_color_init - Initialize line coloring table.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_color_init(void)
+void editpolicy_color_init(void)
 {
 }
 
 /**
- * ccs_editpolicy_color_change - Change current color.
+ * editpolicy_color_change - Change current color.
  *
  * @attr: Coloe to use.
  * @flg:  True if turn on, false otherwise.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_color_change(const attr_t attr, const _Bool flg)
+void editpolicy_color_change(const attr_t attr, const _Bool flg)
 {
 }
 
 /**
- * ccs_editpolicy_attr_change - Change current attribute.
+ * editpolicy_attr_change - Change current attribute.
  *
  * @attr: Coloe to use.
  * @flg:  True if turn on, false otherwise.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_attr_change(const attr_t attr, const _Bool flg)
+void editpolicy_attr_change(const attr_t attr, const _Bool flg)
 {
 }
 
 /**
- * ccs_editpolicy_sttr_save - Save current color.
+ * editpolicy_sttr_save - Save current color.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_sttr_save(void)
+void editpolicy_sttr_save(void)
 {
 }
 
 /**
- * ccs_editpolicy_sttr_restore - Load current color.
+ * editpolicy_sttr_restore - Load current color.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_sttr_restore(void)
+void editpolicy_sttr_restore(void)
 {
 }
 
 /**
- * ccs_editpolicy_color_head - Get color to use for header line.
+ * editpolicy_color_head - Get color to use for header line.
  *
- * Returns one of values in "enum ccs_color_pair".
+ * Returns one of values in "enum color_type".
  */
-enum ccs_color_pair ccs_editpolicy_color_head(void)
+enum color_type editpolicy_color_head(void)
 {
-	return CCS_DEFAULT_COLOR;
+	return COLOR_DEFAULT_COLOR;
 }
 
 /**
- * ccs_editpolicy_line_draw - Update colored line.
+ * editpolicy_line_draw - Update colored line.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_line_draw(void)
+void editpolicy_line_draw(void)
 {
 }
 
Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_keyword.c
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_keyword.c	(revision 6399)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_keyword.c	(working copy)
@@ -24,338 +24,337 @@
 #include "editpolicy.h"
 
 /* keyword array for rewriting keywords upon display. */
-struct ccs_editpolicy_directive ccs_directives[CCS_MAX_DIRECTIVE_INDEX] = {
-	[CCS_DIRECTIVE_ACL_GROUP_000] = { "acl_group 0", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_001] = { "acl_group 1", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_002] = { "acl_group 2", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_003] = { "acl_group 3", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_004] = { "acl_group 4", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_005] = { "acl_group 5", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_006] = { "acl_group 6", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_007] = { "acl_group 7", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_008] = { "acl_group 8", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_009] = { "acl_group 9", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_010] = { "acl_group 10", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_011] = { "acl_group 11", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_012] = { "acl_group 12", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_013] = { "acl_group 13", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_014] = { "acl_group 14", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_015] = { "acl_group 15", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_016] = { "acl_group 16", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_017] = { "acl_group 17", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_018] = { "acl_group 18", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_019] = { "acl_group 19", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_020] = { "acl_group 20", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_021] = { "acl_group 21", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_022] = { "acl_group 22", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_023] = { "acl_group 23", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_024] = { "acl_group 24", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_025] = { "acl_group 25", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_026] = { "acl_group 26", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_027] = { "acl_group 27", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_028] = { "acl_group 28", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_029] = { "acl_group 29", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_030] = { "acl_group 30", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_031] = { "acl_group 31", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_032] = { "acl_group 32", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_033] = { "acl_group 33", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_034] = { "acl_group 34", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_035] = { "acl_group 35", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_036] = { "acl_group 36", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_037] = { "acl_group 37", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_038] = { "acl_group 38", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_039] = { "acl_group 39", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_040] = { "acl_group 40", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_041] = { "acl_group 41", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_042] = { "acl_group 42", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_043] = { "acl_group 43", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_044] = { "acl_group 44", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_045] = { "acl_group 45", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_046] = { "acl_group 46", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_047] = { "acl_group 47", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_048] = { "acl_group 48", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_049] = { "acl_group 49", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_050] = { "acl_group 50", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_051] = { "acl_group 51", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_052] = { "acl_group 52", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_053] = { "acl_group 53", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_054] = { "acl_group 54", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_055] = { "acl_group 55", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_056] = { "acl_group 56", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_057] = { "acl_group 57", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_058] = { "acl_group 58", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_059] = { "acl_group 59", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_060] = { "acl_group 60", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_061] = { "acl_group 61", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_062] = { "acl_group 62", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_063] = { "acl_group 63", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_064] = { "acl_group 64", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_065] = { "acl_group 65", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_066] = { "acl_group 66", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_067] = { "acl_group 67", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_068] = { "acl_group 68", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_069] = { "acl_group 69", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_070] = { "acl_group 70", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_071] = { "acl_group 71", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_072] = { "acl_group 72", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_073] = { "acl_group 73", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_074] = { "acl_group 74", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_075] = { "acl_group 75", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_076] = { "acl_group 76", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_077] = { "acl_group 77", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_078] = { "acl_group 78", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_079] = { "acl_group 79", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_080] = { "acl_group 80", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_081] = { "acl_group 81", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_082] = { "acl_group 82", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_083] = { "acl_group 83", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_084] = { "acl_group 84", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_085] = { "acl_group 85", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_086] = { "acl_group 86", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_087] = { "acl_group 87", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_088] = { "acl_group 88", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_089] = { "acl_group 89", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_090] = { "acl_group 90", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_091] = { "acl_group 91", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_092] = { "acl_group 92", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_093] = { "acl_group 93", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_094] = { "acl_group 94", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_095] = { "acl_group 95", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_096] = { "acl_group 96", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_097] = { "acl_group 97", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_098] = { "acl_group 98", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_099] = { "acl_group 99", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_100] = { "acl_group 100", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_101] = { "acl_group 101", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_102] = { "acl_group 102", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_103] = { "acl_group 103", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_104] = { "acl_group 104", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_105] = { "acl_group 105", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_106] = { "acl_group 106", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_107] = { "acl_group 107", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_108] = { "acl_group 108", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_109] = { "acl_group 109", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_110] = { "acl_group 110", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_111] = { "acl_group 111", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_112] = { "acl_group 112", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_113] = { "acl_group 113", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_114] = { "acl_group 114", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_115] = { "acl_group 115", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_116] = { "acl_group 116", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_117] = { "acl_group 117", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_118] = { "acl_group 118", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_119] = { "acl_group 119", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_120] = { "acl_group 120", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_121] = { "acl_group 121", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_122] = { "acl_group 122", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_123] = { "acl_group 123", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_124] = { "acl_group 124", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_125] = { "acl_group 125", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_126] = { "acl_group 126", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_127] = { "acl_group 127", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_128] = { "acl_group 128", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_129] = { "acl_group 129", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_130] = { "acl_group 130", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_131] = { "acl_group 131", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_132] = { "acl_group 132", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_133] = { "acl_group 133", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_134] = { "acl_group 134", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_135] = { "acl_group 135", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_136] = { "acl_group 136", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_137] = { "acl_group 137", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_138] = { "acl_group 138", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_139] = { "acl_group 139", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_140] = { "acl_group 140", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_141] = { "acl_group 141", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_142] = { "acl_group 142", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_143] = { "acl_group 143", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_144] = { "acl_group 144", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_145] = { "acl_group 145", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_146] = { "acl_group 146", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_147] = { "acl_group 147", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_148] = { "acl_group 148", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_149] = { "acl_group 149", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_150] = { "acl_group 150", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_151] = { "acl_group 151", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_152] = { "acl_group 152", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_153] = { "acl_group 153", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_154] = { "acl_group 154", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_155] = { "acl_group 155", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_156] = { "acl_group 156", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_157] = { "acl_group 157", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_158] = { "acl_group 158", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_159] = { "acl_group 159", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_160] = { "acl_group 160", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_161] = { "acl_group 161", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_162] = { "acl_group 162", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_163] = { "acl_group 163", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_164] = { "acl_group 164", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_165] = { "acl_group 165", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_166] = { "acl_group 166", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_167] = { "acl_group 167", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_168] = { "acl_group 168", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_169] = { "acl_group 169", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_170] = { "acl_group 170", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_171] = { "acl_group 171", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_172] = { "acl_group 172", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_173] = { "acl_group 173", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_174] = { "acl_group 174", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_175] = { "acl_group 175", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_176] = { "acl_group 176", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_177] = { "acl_group 177", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_178] = { "acl_group 178", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_179] = { "acl_group 179", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_180] = { "acl_group 180", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_181] = { "acl_group 181", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_182] = { "acl_group 182", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_183] = { "acl_group 183", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_184] = { "acl_group 184", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_185] = { "acl_group 185", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_186] = { "acl_group 186", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_187] = { "acl_group 187", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_188] = { "acl_group 188", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_189] = { "acl_group 189", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_190] = { "acl_group 190", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_191] = { "acl_group 191", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_192] = { "acl_group 192", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_193] = { "acl_group 193", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_194] = { "acl_group 194", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_195] = { "acl_group 195", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_196] = { "acl_group 196", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_197] = { "acl_group 197", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_198] = { "acl_group 198", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_199] = { "acl_group 199", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_200] = { "acl_group 200", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_201] = { "acl_group 201", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_202] = { "acl_group 202", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_203] = { "acl_group 203", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_204] = { "acl_group 204", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_205] = { "acl_group 205", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_206] = { "acl_group 206", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_207] = { "acl_group 207", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_208] = { "acl_group 208", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_209] = { "acl_group 209", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_210] = { "acl_group 210", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_211] = { "acl_group 211", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_212] = { "acl_group 212", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_213] = { "acl_group 213", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_214] = { "acl_group 214", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_215] = { "acl_group 215", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_216] = { "acl_group 216", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_217] = { "acl_group 217", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_218] = { "acl_group 218", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_219] = { "acl_group 219", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_220] = { "acl_group 220", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_221] = { "acl_group 221", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_222] = { "acl_group 222", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_223] = { "acl_group 223", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_224] = { "acl_group 224", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_225] = { "acl_group 225", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_226] = { "acl_group 226", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_227] = { "acl_group 227", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_228] = { "acl_group 228", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_229] = { "acl_group 229", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_230] = { "acl_group 230", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_231] = { "acl_group 231", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_232] = { "acl_group 232", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_233] = { "acl_group 233", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_234] = { "acl_group 234", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_235] = { "acl_group 235", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_236] = { "acl_group 236", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_237] = { "acl_group 237", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_238] = { "acl_group 238", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_239] = { "acl_group 239", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_240] = { "acl_group 240", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_241] = { "acl_group 241", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_242] = { "acl_group 242", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_243] = { "acl_group 243", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_244] = { "acl_group 244", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_245] = { "acl_group 245", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_246] = { "acl_group 246", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_247] = { "acl_group 247", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_248] = { "acl_group 248", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_249] = { "acl_group 249", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_250] = { "acl_group 250", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_251] = { "acl_group 251", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_252] = { "acl_group 252", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_253] = { "acl_group 253", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_254] = { "acl_group 254", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_255] = { "acl_group 255", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ADDRESS_GROUP] = { "address_group", NULL, 0, 0 },
-	[CCS_DIRECTIVE_AGGREGATOR]    = { "aggregator", NULL, 0, 0 },
-	[CCS_DIRECTIVE_CAPABILITY]    = { "capability", NULL, 0, 0 },
-	[CCS_DIRECTIVE_DENY_AUTOBIND] = { "deny_autobind", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_APPEND]   = { "file append", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_CHGRP]    = { "file chgrp", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_CHMOD]    = { "file chmod", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_CHOWN]    = { "file chown", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_CHROOT]   = { "file chroot", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_CREATE]   = { "file create", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_EXECUTE]  = { "file execute", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_GETATTR]  = { "file getattr", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_IOCTL]    = { "file ioctl", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_LINK]     = { "file link", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MKBLOCK]  = { "file mkblock", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MKCHAR]   = { "file mkchar", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MKDIR]    = { "file mkdir", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MKFIFO]   = { "file mkfifo", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MKSOCK]   = { "file mksock", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MOUNT]    = { "file mount", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_PIVOT_ROOT] = { "file pivot_root", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_READ]     = { "file read", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_RENAME]   = { "file rename", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_RMDIR]    = { "file rmdir", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_SYMLINK]  = { "file symlink", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_TRUNCATE] = { "file truncate", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_UNLINK]   = { "file unlink", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_UNMOUNT]  = { "file unmount", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_WRITE]    = { "file write", NULL, 0, 0 },
-	[CCS_DIRECTIVE_INITIALIZE_DOMAIN]
+struct editpolicy_directive directive_map[MAX_DIRECTIVE_TYPE] = {
+	[DIRECTIVE_ACL_GROUP_000] = { "acl_group 0", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_001] = { "acl_group 1", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_002] = { "acl_group 2", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_003] = { "acl_group 3", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_004] = { "acl_group 4", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_005] = { "acl_group 5", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_006] = { "acl_group 6", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_007] = { "acl_group 7", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_008] = { "acl_group 8", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_009] = { "acl_group 9", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_010] = { "acl_group 10", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_011] = { "acl_group 11", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_012] = { "acl_group 12", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_013] = { "acl_group 13", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_014] = { "acl_group 14", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_015] = { "acl_group 15", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_016] = { "acl_group 16", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_017] = { "acl_group 17", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_018] = { "acl_group 18", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_019] = { "acl_group 19", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_020] = { "acl_group 20", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_021] = { "acl_group 21", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_022] = { "acl_group 22", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_023] = { "acl_group 23", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_024] = { "acl_group 24", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_025] = { "acl_group 25", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_026] = { "acl_group 26", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_027] = { "acl_group 27", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_028] = { "acl_group 28", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_029] = { "acl_group 29", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_030] = { "acl_group 30", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_031] = { "acl_group 31", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_032] = { "acl_group 32", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_033] = { "acl_group 33", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_034] = { "acl_group 34", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_035] = { "acl_group 35", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_036] = { "acl_group 36", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_037] = { "acl_group 37", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_038] = { "acl_group 38", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_039] = { "acl_group 39", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_040] = { "acl_group 40", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_041] = { "acl_group 41", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_042] = { "acl_group 42", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_043] = { "acl_group 43", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_044] = { "acl_group 44", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_045] = { "acl_group 45", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_046] = { "acl_group 46", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_047] = { "acl_group 47", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_048] = { "acl_group 48", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_049] = { "acl_group 49", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_050] = { "acl_group 50", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_051] = { "acl_group 51", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_052] = { "acl_group 52", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_053] = { "acl_group 53", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_054] = { "acl_group 54", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_055] = { "acl_group 55", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_056] = { "acl_group 56", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_057] = { "acl_group 57", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_058] = { "acl_group 58", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_059] = { "acl_group 59", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_060] = { "acl_group 60", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_061] = { "acl_group 61", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_062] = { "acl_group 62", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_063] = { "acl_group 63", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_064] = { "acl_group 64", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_065] = { "acl_group 65", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_066] = { "acl_group 66", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_067] = { "acl_group 67", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_068] = { "acl_group 68", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_069] = { "acl_group 69", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_070] = { "acl_group 70", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_071] = { "acl_group 71", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_072] = { "acl_group 72", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_073] = { "acl_group 73", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_074] = { "acl_group 74", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_075] = { "acl_group 75", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_076] = { "acl_group 76", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_077] = { "acl_group 77", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_078] = { "acl_group 78", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_079] = { "acl_group 79", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_080] = { "acl_group 80", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_081] = { "acl_group 81", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_082] = { "acl_group 82", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_083] = { "acl_group 83", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_084] = { "acl_group 84", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_085] = { "acl_group 85", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_086] = { "acl_group 86", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_087] = { "acl_group 87", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_088] = { "acl_group 88", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_089] = { "acl_group 89", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_090] = { "acl_group 90", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_091] = { "acl_group 91", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_092] = { "acl_group 92", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_093] = { "acl_group 93", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_094] = { "acl_group 94", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_095] = { "acl_group 95", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_096] = { "acl_group 96", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_097] = { "acl_group 97", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_098] = { "acl_group 98", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_099] = { "acl_group 99", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_100] = { "acl_group 100", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_101] = { "acl_group 101", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_102] = { "acl_group 102", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_103] = { "acl_group 103", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_104] = { "acl_group 104", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_105] = { "acl_group 105", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_106] = { "acl_group 106", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_107] = { "acl_group 107", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_108] = { "acl_group 108", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_109] = { "acl_group 109", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_110] = { "acl_group 110", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_111] = { "acl_group 111", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_112] = { "acl_group 112", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_113] = { "acl_group 113", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_114] = { "acl_group 114", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_115] = { "acl_group 115", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_116] = { "acl_group 116", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_117] = { "acl_group 117", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_118] = { "acl_group 118", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_119] = { "acl_group 119", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_120] = { "acl_group 120", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_121] = { "acl_group 121", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_122] = { "acl_group 122", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_123] = { "acl_group 123", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_124] = { "acl_group 124", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_125] = { "acl_group 125", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_126] = { "acl_group 126", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_127] = { "acl_group 127", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_128] = { "acl_group 128", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_129] = { "acl_group 129", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_130] = { "acl_group 130", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_131] = { "acl_group 131", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_132] = { "acl_group 132", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_133] = { "acl_group 133", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_134] = { "acl_group 134", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_135] = { "acl_group 135", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_136] = { "acl_group 136", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_137] = { "acl_group 137", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_138] = { "acl_group 138", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_139] = { "acl_group 139", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_140] = { "acl_group 140", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_141] = { "acl_group 141", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_142] = { "acl_group 142", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_143] = { "acl_group 143", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_144] = { "acl_group 144", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_145] = { "acl_group 145", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_146] = { "acl_group 146", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_147] = { "acl_group 147", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_148] = { "acl_group 148", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_149] = { "acl_group 149", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_150] = { "acl_group 150", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_151] = { "acl_group 151", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_152] = { "acl_group 152", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_153] = { "acl_group 153", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_154] = { "acl_group 154", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_155] = { "acl_group 155", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_156] = { "acl_group 156", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_157] = { "acl_group 157", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_158] = { "acl_group 158", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_159] = { "acl_group 159", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_160] = { "acl_group 160", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_161] = { "acl_group 161", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_162] = { "acl_group 162", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_163] = { "acl_group 163", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_164] = { "acl_group 164", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_165] = { "acl_group 165", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_166] = { "acl_group 166", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_167] = { "acl_group 167", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_168] = { "acl_group 168", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_169] = { "acl_group 169", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_170] = { "acl_group 170", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_171] = { "acl_group 171", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_172] = { "acl_group 172", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_173] = { "acl_group 173", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_174] = { "acl_group 174", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_175] = { "acl_group 175", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_176] = { "acl_group 176", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_177] = { "acl_group 177", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_178] = { "acl_group 178", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_179] = { "acl_group 179", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_180] = { "acl_group 180", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_181] = { "acl_group 181", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_182] = { "acl_group 182", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_183] = { "acl_group 183", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_184] = { "acl_group 184", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_185] = { "acl_group 185", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_186] = { "acl_group 186", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_187] = { "acl_group 187", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_188] = { "acl_group 188", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_189] = { "acl_group 189", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_190] = { "acl_group 190", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_191] = { "acl_group 191", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_192] = { "acl_group 192", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_193] = { "acl_group 193", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_194] = { "acl_group 194", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_195] = { "acl_group 195", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_196] = { "acl_group 196", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_197] = { "acl_group 197", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_198] = { "acl_group 198", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_199] = { "acl_group 199", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_200] = { "acl_group 200", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_201] = { "acl_group 201", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_202] = { "acl_group 202", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_203] = { "acl_group 203", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_204] = { "acl_group 204", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_205] = { "acl_group 205", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_206] = { "acl_group 206", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_207] = { "acl_group 207", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_208] = { "acl_group 208", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_209] = { "acl_group 209", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_210] = { "acl_group 210", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_211] = { "acl_group 211", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_212] = { "acl_group 212", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_213] = { "acl_group 213", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_214] = { "acl_group 214", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_215] = { "acl_group 215", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_216] = { "acl_group 216", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_217] = { "acl_group 217", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_218] = { "acl_group 218", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_219] = { "acl_group 219", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_220] = { "acl_group 220", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_221] = { "acl_group 221", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_222] = { "acl_group 222", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_223] = { "acl_group 223", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_224] = { "acl_group 224", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_225] = { "acl_group 225", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_226] = { "acl_group 226", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_227] = { "acl_group 227", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_228] = { "acl_group 228", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_229] = { "acl_group 229", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_230] = { "acl_group 230", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_231] = { "acl_group 231", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_232] = { "acl_group 232", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_233] = { "acl_group 233", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_234] = { "acl_group 234", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_235] = { "acl_group 235", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_236] = { "acl_group 236", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_237] = { "acl_group 237", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_238] = { "acl_group 238", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_239] = { "acl_group 239", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_240] = { "acl_group 240", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_241] = { "acl_group 241", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_242] = { "acl_group 242", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_243] = { "acl_group 243", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_244] = { "acl_group 244", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_245] = { "acl_group 245", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_246] = { "acl_group 246", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_247] = { "acl_group 247", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_248] = { "acl_group 248", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_249] = { "acl_group 249", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_250] = { "acl_group 250", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_251] = { "acl_group 251", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_252] = { "acl_group 252", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_253] = { "acl_group 253", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_254] = { "acl_group 254", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_255] = { "acl_group 255", NULL, 0, 0 },
+	[DIRECTIVE_ADDRESS_GROUP] = { "address_group", NULL, 0, 0 },
+	[DIRECTIVE_AGGREGATOR]    = { "aggregator", NULL, 0, 0 },
+	[DIRECTIVE_CAPABILITY]    = { "capability", NULL, 0, 0 },
+	[DIRECTIVE_DENY_AUTOBIND] = { "deny_autobind", NULL, 0, 0 },
+	[DIRECTIVE_FILE_APPEND]   = { "file append", NULL, 0, 0 },
+	[DIRECTIVE_FILE_CHGRP]    = { "file chgrp", NULL, 0, 0 },
+	[DIRECTIVE_FILE_CHMOD]    = { "file chmod", NULL, 0, 0 },
+	[DIRECTIVE_FILE_CHOWN]    = { "file chown", NULL, 0, 0 },
+	[DIRECTIVE_FILE_CHROOT]   = { "file chroot", NULL, 0, 0 },
+	[DIRECTIVE_FILE_CREATE]   = { "file create", NULL, 0, 0 },
+	[DIRECTIVE_FILE_EXECUTE]  = { "file execute", NULL, 0, 0 },
+	[DIRECTIVE_FILE_GETATTR]  = { "file getattr", NULL, 0, 0 },
+	[DIRECTIVE_FILE_IOCTL]    = { "file ioctl", NULL, 0, 0 },
+	[DIRECTIVE_FILE_LINK]     = { "file link", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MKBLOCK]  = { "file mkblock", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MKCHAR]   = { "file mkchar", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MKDIR]    = { "file mkdir", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MKFIFO]   = { "file mkfifo", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MKSOCK]   = { "file mksock", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MOUNT]    = { "file mount", NULL, 0, 0 },
+	[DIRECTIVE_FILE_PIVOT_ROOT] = { "file pivot_root", NULL, 0, 0 },
+	[DIRECTIVE_FILE_READ]     = { "file read", NULL, 0, 0 },
+	[DIRECTIVE_FILE_RENAME]   = { "file rename", NULL, 0, 0 },
+	[DIRECTIVE_FILE_RMDIR]    = { "file rmdir", NULL, 0, 0 },
+	[DIRECTIVE_FILE_SYMLINK]  = { "file symlink", NULL, 0, 0 },
+	[DIRECTIVE_FILE_TRUNCATE] = { "file truncate", NULL, 0, 0 },
+	[DIRECTIVE_FILE_UNLINK]   = { "file unlink", NULL, 0, 0 },
+	[DIRECTIVE_FILE_UNMOUNT]  = { "file unmount", NULL, 0, 0 },
+	[DIRECTIVE_FILE_WRITE]    = { "file write", NULL, 0, 0 },
+	[DIRECTIVE_INITIALIZE_DOMAIN]
 	= { "initialize_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_IPC_SIGNAL]    = { "ipc signal", NULL, 0, 0 },
-	[CCS_DIRECTIVE_KEEP_DOMAIN]   = { "keep_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_MISC_ENV]      = { "misc env", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NETWORK_INET]  = { "network inet", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NETWORK_UNIX]  = { "network unix", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NONE]          = { "", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN]
+	[DIRECTIVE_IPC_SIGNAL]    = { "ipc signal", NULL, 0, 0 },
+	[DIRECTIVE_KEEP_DOMAIN]   = { "keep_domain", NULL, 0, 0 },
+	[DIRECTIVE_MISC_ENV]      = { "misc env", NULL, 0, 0 },
+	[DIRECTIVE_NETWORK_INET]  = { "network inet", NULL, 0, 0 },
+	[DIRECTIVE_NETWORK_UNIX]  = { "network unix", NULL, 0, 0 },
+	[DIRECTIVE_NONE]          = { "", NULL, 0, 0 },
+	[DIRECTIVE_NO_INITIALIZE_DOMAIN]
 	= { "no_initialize_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NO_KEEP_DOMAIN] = { "no_keep_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NO_RESET_DOMAIN] = { "no_reset_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NUMBER_GROUP]  = { "number_group", NULL, 0, 0 },
-	[CCS_DIRECTIVE_PATH_GROUP]    = { "path_group", NULL, 0, 0 },
-	[CCS_DIRECTIVE_QUOTA_EXCEEDED] = { "quota_exceeded", NULL, 0, 0 },
-	[CCS_DIRECTIVE_RESET_DOMAIN]  = { "reset_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_TASK_AUTO_DOMAIN_TRANSITION]
+	[DIRECTIVE_NO_KEEP_DOMAIN] = { "no_keep_domain", NULL, 0, 0 },
+	[DIRECTIVE_NO_RESET_DOMAIN] = { "no_reset_domain", NULL, 0, 0 },
+	[DIRECTIVE_NUMBER_GROUP]  = { "number_group", NULL, 0, 0 },
+	[DIRECTIVE_PATH_GROUP]    = { "path_group", NULL, 0, 0 },
+	[DIRECTIVE_QUOTA_EXCEEDED] = { "quota_exceeded", NULL, 0, 0 },
+	[DIRECTIVE_RESET_DOMAIN]  = { "reset_domain", NULL, 0, 0 },
+	[DIRECTIVE_TASK_AUTO_DOMAIN_TRANSITION]
 	= { "task auto_domain_transition", NULL, 0, 0 },
-	[CCS_DIRECTIVE_TASK_AUTO_EXECUTE_HANDLER]
+	[DIRECTIVE_TASK_AUTO_EXECUTE_HANDLER]
 	= { "task auto_execute_handler", NULL, 0, 0 },
-	[CCS_DIRECTIVE_TASK_DENIED_EXECUTE_HANDLER]
+	[DIRECTIVE_TASK_DENIED_EXECUTE_HANDLER]
 	= { "task denied_execute_handler", NULL, 0, 0 },
-	[CCS_DIRECTIVE_TASK_MANUAL_DOMAIN_TRANSITION]
+	[DIRECTIVE_TASK_MANUAL_DOMAIN_TRANSITION]
 	= { "task manual_domain_transition", NULL, 0, 0 },
-	[CCS_DIRECTIVE_TRANSITION_FAILED]
+	[DIRECTIVE_TRANSITION_FAILED]
 	= { "transition_failed", NULL, 0, 0 },
-	[CCS_DIRECTIVE_USE_GROUP]     = { "use_group", NULL, 0, 0 },
-	[CCS_DIRECTIVE_USE_PROFILE]   = { "use_profile", NULL, 0, 0 },
+	[DIRECTIVE_USE_GROUP]     = { "use_group", NULL, 0, 0 },
+	[DIRECTIVE_USE_PROFILE]   = { "use_profile", NULL, 0, 0 },
 };
 
 /**
- * ccs_find_directive - Find keyword index.
+ * find_directive - Find keyword index.
  *
  * @forward: True if original -> alias conversion, false otherwise.
  * @line: A line containing keyword and operand.
  *
- * Returns one of values in "enum ccs_editpolicy_directives".
+ * Returns one of values in "enum directive_type".
  */
-enum ccs_editpolicy_directives ccs_find_directive(const _Bool forward,
-						  char *line)
+enum directive_type find_directive(const _Bool forward, char *line)
 {
-	u16 i;
-	for (i = 1; i < CCS_MAX_DIRECTIVE_INDEX; i++) {
+	enum directive_type i;
+	for (i = 1; i < MAX_DIRECTIVE_TYPE; i++) {
 		if (forward) {
-			const int len = ccs_directives[i].original_len;
-			if (strncmp(line, ccs_directives[i].original, len) ||
+			const int len = directive_map[i].original_len;
+			if (strncmp(line, directive_map[i].original, len) ||
 			    (line[len] != ' ' && line[len]))
 				continue;
 			if (line[len])
@@ -365,8 +364,8 @@
 				line[0] = '\0';
 			return i;
 		} else {
-			const int len = ccs_directives[i].alias_len;
-			if (strncmp(line, ccs_directives[i].alias, len) ||
+			const int len = directive_map[i].alias_len;
+			if (strncmp(line, directive_map[i].alias, len) ||
 			    (line[len] != ' ' && line[len]))
 				continue;
 			if (line[len])
@@ -377,15 +376,15 @@
 			return i;
 		}
 	}
-	return CCS_DIRECTIVE_NONE;
+	return DIRECTIVE_NONE;
 }
 
 /**
- * ccs_editpolicy_init_keyword_map - Initialize keyword mapping table.
+ * editpolicy_init_keyword_map - Initialize keyword mapping table.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_init_keyword_map(void)
+void editpolicy_init_keyword_map(void)
 {
 	FILE *fp = fopen(CCS_EDITPOLICY_CONF, "r");
 	int i;
@@ -407,24 +406,24 @@
 		ccs_normalize_line(cp);
 		if (!*line || !*cp)
 			continue;
-		for (i = 1; i < CCS_MAX_DIRECTIVE_INDEX; i++) {
-			if (strcmp(line, ccs_directives[i].original))
+		for (i = 1; i < MAX_DIRECTIVE_TYPE; i++) {
+			if (strcmp(line, directive_map[i].original))
 				continue;
-			free((void *) ccs_directives[i].alias);
+			free((void *) directive_map[i].alias);
 			cp = ccs_strdup(cp);
-			ccs_directives[i].alias = cp;
-			ccs_directives[i].alias_len = strlen(cp);
+			directive_map[i].alias = cp;
+			directive_map[i].alias_len = strlen(cp);
 			break;
 		}
 	}
 	ccs_put();
 	fclose(fp);
 use_default:
-	for (i = 1; i < CCS_MAX_DIRECTIVE_INDEX; i++) {
-		if (!ccs_directives[i].alias)
-			ccs_directives[i].alias = ccs_directives[i].original;
-		ccs_directives[i].original_len =
-			strlen(ccs_directives[i].original);
-		ccs_directives[i].alias_len = strlen(ccs_directives[i].alias);
+	for (i = 1; i < MAX_DIRECTIVE_TYPE; i++) {
+		if (!directive_map[i].alias)
+			directive_map[i].alias = directive_map[i].original;
+		directive_map[i].original_len =
+			strlen(directive_map[i].original);
+		directive_map[i].alias_len = strlen(directive_map[i].alias);
 	}
 }
Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_offline.c
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_offline.c	(revision 6399)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_offline.c	(working copy)
@@ -1129,13 +1129,13 @@
 };
 
 /* String table for domain transition control keywords. */
-static const char * const ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
-	[CCS_TRANSITION_CONTROL_NO_RESET]      = "no_reset_domain ",
-	[CCS_TRANSITION_CONTROL_RESET]         = "reset_domain ",
-	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
-	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
-	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
-	[CCS_TRANSITION_CONTROL_KEEP]          = "keep_domain ",
+static const char * const ccs_transition_type[MAX_TRANSITION_TYPE] = {
+	[TRANSITION_NO_RESET]      = "no_reset_domain ",
+	[TRANSITION_RESET]         = "reset_domain ",
+	[TRANSITION_NO_INITIALIZE] = "no_initialize_domain ",
+	[TRANSITION_INITIALIZE]    = "initialize_domain ",
+	[TRANSITION_NO_KEEP]       = "no_keep_domain ",
+	[TRANSITION_KEEP]          = "keep_domain ",
 };
 
 /* String table for grouping keywords. */
@@ -2353,8 +2353,8 @@
 	if (domainname) {
 		*domainname = '\0';
 		domainname += 6;
-	} else if (type == CCS_TRANSITION_CONTROL_NO_KEEP ||
-		   type == CCS_TRANSITION_CONTROL_KEEP) {
+	} else if (type == TRANSITION_NO_KEEP ||
+		   type == TRANSITION_KEEP) {
 		domainname = program;
 		program = NULL;
 	}
@@ -4471,7 +4471,7 @@
 		return ccs_write_aggregator(&param);
 	if (ccs_str_starts(param.data, "deny_autobind "))
 		return ccs_write_reserved_port(&param);
-	for (i = 0; i < CCS_MAX_TRANSITION_TYPE; i++)
+	for (i = 0; i < MAX_TRANSITION_TYPE; i++)
 		if (ccs_str_starts(param.data, ccs_transition_type[i]))
 			return ccs_write_transition_control(&param, i);
 	for (i = 0; i < CCS_MAX_GROUP; i++)
@@ -4743,11 +4743,11 @@
 }
 
 /**
- * ccs_editpolicy_offline_init - Initialize variables for offline daemon.
+ * editpolicy_offline_init - Initialize variables for offline daemon.
  *
  * Returns nothing.
  */
-static void ccs_editpolicy_offline_init(void)
+static void editpolicy_offline_init(void)
 {
 	static _Bool first = true;
 	int i;
@@ -4772,17 +4772,17 @@
 }
 
 /**
- * ccs_editpolicy_offline_main - Read request and handle policy I/O.
+ * editpolicy_offline_main - Read request and handle policy I/O.
  *
  * @fd: Socket file descriptor. 
  *
  * Returns nothing.
  */
-static void ccs_editpolicy_offline_main(const int fd)
+static void editpolicy_offline_main(const int fd)
 {
 	int i;
 	static char buffer[4096];
-	ccs_editpolicy_offline_init();
+	editpolicy_offline_init();
 	/* Read filename. */
 	for (i = 0; i < sizeof(buffer); i++) {
 		if (read(fd, buffer + i, 1) != 1)
@@ -4857,14 +4857,14 @@
 }
 
 /**
- * ccs_editpolicy_offline_daemon - Emulate /proc/ccs/ interface.
+ * editpolicy_offline_daemon - Emulate /proc/ccs/ interface.
  *
  * @listener: Listener fd. This is a listening PF_INET socket.
  * @notifier: Notifier fd. This is a pipe's reader side.
  *
  * This function does not return.
  */
-void ccs_editpolicy_offline_daemon(const int listener, const int notifier)
+void editpolicy_offline_daemon(const int listener, const int notifier)
 {
 	while (1) {
 		struct pollfd pfd[2] = {
@@ -4880,7 +4880,7 @@
 		fd = accept(listener, (struct sockaddr *) &addr, &size);
 		if (fd == EOF)
 			continue;
-		ccs_editpolicy_offline_main(fd);
+		editpolicy_offline_main(fd);
 		close(fd);
 	}
 }
Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_optimizer.c
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_optimizer.c	(revision 6399)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_optimizer.c	(working copy)
@@ -23,64 +23,59 @@
 #include "ccstools.h"
 #include "editpolicy.h"
 
-static struct ccs_address_group_entry *ccs_find_address_group
-(const char *group_name);
-static struct ccs_number_group_entry *ccs_find_number_group
-(const char *group_name);
-static _Bool ccs_compare_address(const char *sarg, const char *darg);
-static _Bool ccs_compare_number(const char *sarg, const char *darg);
-static _Bool ccs_compare_path(const char *sarg, const char *darg);
+static struct address_group_entry *find_address_group(const char *group_name);
+static struct number_group_entry *find_number_group(const char *group_name);
+static _Bool compare_address(const char *sarg, const char *darg);
+static _Bool compare_number(const char *sarg, const char *darg);
+static _Bool compare_path(const char *sarg, const char *darg);
 
 /**
- * ccs_find_address_group - Find an "address_group" by name.
+ * find_address_group - Find an "address_group" by name.
  *
  * @group_name: Group name to find.
  *
- * Returns pointer to "struct ccs_address_group_entry" if found,
+ * Returns pointer to "struct address_group_entry" if found,
  * NULL otherwise.
  */
-static struct ccs_address_group_entry *ccs_find_address_group
-(const char *group_name)
+static struct address_group_entry *find_address_group(const char *group_name)
 {
 	int i;
-	for (i = 0; i < ccs_address_group_list_len; i++)
+	for (i = 0; i < address_group_list_len; i++)
 		if (!strcmp(group_name,
-			    ccs_address_group_list[i].group_name->name))
-			return &ccs_address_group_list[i];
+			    address_group_list[i].group_name->name))
+			return &address_group_list[i];
 	return NULL;
 }
 
 /**
- * ccs_find_number_group - Find an "number_group" by name.
+ * find_number_group - Find an "number_group" by name.
  *
  * @group_name: Group name to find.
  *
- * Returns pointer to "struct ccs_number_group_entry" if found,
+ * Returns pointer to "struct number_group_entry" if found,
  * NULL otherwise.
  */
-static struct ccs_number_group_entry *ccs_find_number_group
-(const char *group_name)
+static struct number_group_entry *find_number_group(const char *group_name)
 {
 	int i;
-	for (i = 0; i < ccs_number_group_list_len; i++)
-		if (!strcmp(group_name,
-			    ccs_number_group_list[i].group_name->name))
-			return &ccs_number_group_list[i];
+	for (i = 0; i < number_group_list_len; i++)
+		if (!strcmp(group_name, number_group_list[i].group_name->name))
+			return &number_group_list[i];
 	return NULL;
 }
 
 /**
- * ccs_compare_path - Compare two pathnames.
+ * compare_path - Compare two pathnames.
  *
  * @sarg: First pathname. Maybe wildcard.
  * @darg: Second pathname.
  *
  * Returns true if @darg is included in @sarg, false otherwise.
  */
-static _Bool ccs_compare_path(const char *sarg, const char *darg)
+static _Bool compare_path(const char *sarg, const char *darg)
 {
 	int i;
-	struct ccs_path_group_entry *group;
+	struct path_group_entry *group;
 	struct ccs_path_info s;
 	struct ccs_path_info d;
 	s.name = sarg;
@@ -95,7 +90,7 @@
 		/* Pathname component. */
 		return ccs_path_matches_pattern(&d, &s);
 	/* path_group component. */
-	group = ccs_find_path_group_ns(ccs_current_ns, s.name + 1);
+	group = find_path_group_ns(ccs_current_ns, s.name + 1);
 	if (!group)
 		return false;
 	for (i = 0; i < group->member_name_len; i++) {
@@ -110,19 +105,19 @@
 }
 
 /**
- * ccs_compare_address - Compare two IPv4/v6 addresses.
+ * compare_address - Compare two IPv4/v6 addresses.
  *
  * @sarg: First address.
  * @darg: Second address.
  *
  * Returns true if @darg is included in @sarg, false otherwise.
  */
-static _Bool ccs_compare_address(const char *sarg, const char *darg)
+static _Bool compare_address(const char *sarg, const char *darg)
 {
 	int i;
 	struct ccs_ip_address_entry sentry;
 	struct ccs_ip_address_entry dentry;
-	struct ccs_address_group_entry *group;
+	struct address_group_entry *group;
 	if (ccs_parse_ip(darg, &dentry))
 		return false;
 	if (sarg[0] != '@') {
@@ -136,7 +131,7 @@
 		return true;
 	}
 	/* IP address group component. */
-	group = ccs_find_address_group(sarg + 1);
+	group = find_address_group(sarg + 1);
 	if (!group)
 		return false;
 	for (i = 0; i < group->member_name_len; i++) {
@@ -154,51 +149,51 @@
  *
  * @buffer: Line to tokenize.
  * @w:      A "char *" array with 5 elements.
- * @index:  One of values in "enum ccs_editpolicy_directives".
+ * @index:  One of values in "enum directive_type".
  *
  * Returns nothing.
  */
 static void ccs_tokenize(char *buffer, char *w[5],
-			 enum ccs_editpolicy_directives index)
+			 enum directive_type index)
 {
 	u8 i;
 	u8 words;
 	switch (index) {
-	case CCS_DIRECTIVE_FILE_MKBLOCK:
-	case CCS_DIRECTIVE_FILE_MKCHAR:
-	case CCS_DIRECTIVE_FILE_MOUNT:
-	case CCS_DIRECTIVE_NETWORK_INET:
+	case DIRECTIVE_FILE_MKBLOCK:
+	case DIRECTIVE_FILE_MKCHAR:
+	case DIRECTIVE_FILE_MOUNT:
+	case DIRECTIVE_NETWORK_INET:
 		words = 4;
 		break;
-	case CCS_DIRECTIVE_NETWORK_UNIX:
+	case DIRECTIVE_NETWORK_UNIX:
 		words = 3;
 		break;
-	case CCS_DIRECTIVE_FILE_CREATE:
-	case CCS_DIRECTIVE_FILE_MKDIR:
-	case CCS_DIRECTIVE_FILE_MKFIFO:
-	case CCS_DIRECTIVE_FILE_MKSOCK:
-	case CCS_DIRECTIVE_FILE_IOCTL:
-	case CCS_DIRECTIVE_FILE_CHMOD:
-	case CCS_DIRECTIVE_FILE_CHOWN:
-	case CCS_DIRECTIVE_FILE_CHGRP:
-	case CCS_DIRECTIVE_FILE_LINK:
-	case CCS_DIRECTIVE_FILE_RENAME:
-	case CCS_DIRECTIVE_FILE_PIVOT_ROOT:
-	case CCS_DIRECTIVE_IPC_SIGNAL:
+	case DIRECTIVE_FILE_CREATE:
+	case DIRECTIVE_FILE_MKDIR:
+	case DIRECTIVE_FILE_MKFIFO:
+	case DIRECTIVE_FILE_MKSOCK:
+	case DIRECTIVE_FILE_IOCTL:
+	case DIRECTIVE_FILE_CHMOD:
+	case DIRECTIVE_FILE_CHOWN:
+	case DIRECTIVE_FILE_CHGRP:
+	case DIRECTIVE_FILE_LINK:
+	case DIRECTIVE_FILE_RENAME:
+	case DIRECTIVE_FILE_PIVOT_ROOT:
+	case DIRECTIVE_IPC_SIGNAL:
 		words = 2;
 		break;
-	case CCS_DIRECTIVE_FILE_EXECUTE:
-	case CCS_DIRECTIVE_FILE_READ:
-	case CCS_DIRECTIVE_FILE_WRITE:
-	case CCS_DIRECTIVE_FILE_UNLINK:
-	case CCS_DIRECTIVE_FILE_GETATTR:
-	case CCS_DIRECTIVE_FILE_RMDIR:
-	case CCS_DIRECTIVE_FILE_TRUNCATE:
-	case CCS_DIRECTIVE_FILE_APPEND:
-	case CCS_DIRECTIVE_FILE_UNMOUNT:
-	case CCS_DIRECTIVE_FILE_CHROOT:
-	case CCS_DIRECTIVE_FILE_SYMLINK:
-	case CCS_DIRECTIVE_MISC_ENV:
+	case DIRECTIVE_FILE_EXECUTE:
+	case DIRECTIVE_FILE_READ:
+	case DIRECTIVE_FILE_WRITE:
+	case DIRECTIVE_FILE_UNLINK:
+	case DIRECTIVE_FILE_GETATTR:
+	case DIRECTIVE_FILE_RMDIR:
+	case DIRECTIVE_FILE_TRUNCATE:
+	case DIRECTIVE_FILE_APPEND:
+	case DIRECTIVE_FILE_UNMOUNT:
+	case DIRECTIVE_FILE_CHROOT:
+	case DIRECTIVE_FILE_SYMLINK:
+	case DIRECTIVE_MISC_ENV:
 		words = 1;
 		break;
 	default:
@@ -212,7 +207,7 @@
 		w[i] = buffer;
 		if (!cp)
 			return;
-		if (index == CCS_DIRECTIVE_IPC_SIGNAL && i == 1 &&
+		if (index == DIRECTIVE_IPC_SIGNAL && i == 1 &&
 		    ccs_domain_def(buffer)) {
 			cp = strchr(buffer, ' ');
 			if (!cp)
@@ -230,7 +225,7 @@
 		buffer = cp + 1;
 	}
 	w[4] = buffer;
-	if (index != CCS_DIRECTIVE_FILE_EXECUTE)
+	if (index != DIRECTIVE_FILE_EXECUTE)
 		return;
 	if (ccs_domain_def(buffer)) {
 		char *cp = strchr(buffer, ' ');
@@ -269,19 +264,19 @@
 }
 
 /**
- * ccs_compare_number - Compare two numeric values.
+ * compare_number - Compare two numeric values.
  *
  * @sarg: First number.
  * @darg: Second number.
  *
  * Returns true if @darg is included in @sarg, false otherwise.
  */
-static _Bool ccs_compare_number(const char *sarg, const char *darg)
+static _Bool compare_number(const char *sarg, const char *darg)
 {
 	int i;
 	struct ccs_number_entry sentry;
 	struct ccs_number_entry dentry;
-	struct ccs_number_group_entry *group;
+	struct number_group_entry *group;
 	if (ccs_parse_number(darg, &dentry))
 		return false;
 	if (sarg[0] != '@') {
@@ -293,7 +288,7 @@
 		return true;
 	}
 	/* Number group component. */
-	group = ccs_find_number_group(sarg + 1);
+	group = find_number_group(sarg + 1);
 	if (!group)
 		return false;
 	for (i = 0; i < group->member_name_len; i++) {
@@ -306,47 +301,46 @@
 }
 
 /**
- * ccs_editpolicy_do_optimize - Try to merge entries included in other entries.
+ * editpolicy_do_optimize - Try to merge entries included in other entries.
  *
- * @cp:                A line containing operand.
- * @s_index:           Type of entry.
- * @s_index2:          Type of entry.
- * @is_exception_list: True if optimizing acl_group, false otherwise.
+ * @cp:           A line containing operand.
+ * @s_index:      Type of entry.
+ * @s_index2:     Type of entry.
+ * @is_acl_group: True if optimizing acl_group, false otherwise.
  *
  * Returns nothing.
  */
-static void ccs_editpolicy_do_optimize(char *cp, const int current,
-				       enum ccs_editpolicy_directives s_index,
-				       enum ccs_editpolicy_directives s_index2,
-				       const bool is_exception_list)
+static void editpolicy_do_optimize(char *cp, const int current,
+				   enum directive_type s_index,
+				   enum directive_type s_index2,
+				   const bool is_acl_group)
 {
 	int index;
 	char *s[5];
 	char *d[5];
 	ccs_tokenize(cp, s, s_index);
 	ccs_get();
-	for (index = 0; index < ccs_list_item_count; index++) {
+	for (index = 0; index < generic_list_len; index++) {
 		char *line;
-		enum ccs_editpolicy_directives d_index =
-			ccs_gacl_list[index].directive;
-		enum ccs_editpolicy_directives d_index2;
+		enum directive_type d_index = generic_list[index].directive;
+		enum directive_type d_index2;
 		if (index == current)
 			/* Skip source. */
 			continue;
-		if (ccs_gacl_list[index].selected)
+		if (generic_list[index].selected)
 			/* Dest already selected. */
 			continue;
 		else if (s_index == s_index2 && s_index != d_index)
 			/* Source and dest have different directive. */
 			continue;
-		else if (is_exception_list && s_index2 != d_index)
+		else if (is_acl_group && s_index2 != d_index)
 			/* Source and dest have different directive. */
 			continue;
 		/* Source and dest have same directive. */
-		line = ccs_shprintf("%s", ccs_gacl_list[index].operand);
+		line = ccs_shprintf("%s", generic_list[index].operand);
 		d_index2 = d_index;
-		if (is_exception_list)
-			d_index = ccs_find_directive(true, line);
+		if (is_acl_group)
+			d_index = find_directive(true, line);
 		if (s_index != d_index || s_index2 != d_index2)
 			/* Source and dest have different directive. */
 			continue;
@@ -365,55 +359,55 @@
 			struct ccs_path_info darg;
 			char c;
 			int len;
-		case CCS_DIRECTIVE_FILE_EXECUTE:
-			if (!ccs_compare_path(s[0], d[0]))
+		case DIRECTIVE_FILE_EXECUTE:
+			if (!compare_path(s[0], d[0]))
 				continue;
 			if (strcmp(s[1], d[1]))
 				continue;
 			break;
-		case CCS_DIRECTIVE_FILE_MKBLOCK:
-		case CCS_DIRECTIVE_FILE_MKCHAR:
-			if (!ccs_compare_number(s[3], d[3]) ||
-			    !ccs_compare_number(s[2], d[2]))
+		case DIRECTIVE_FILE_MKBLOCK:
+		case DIRECTIVE_FILE_MKCHAR:
+			if (!compare_number(s[3], d[3]) ||
+			    !compare_number(s[2], d[2]))
 				continue;
 			/* fall through */
-		case CCS_DIRECTIVE_FILE_CREATE:
-		case CCS_DIRECTIVE_FILE_MKDIR:
-		case CCS_DIRECTIVE_FILE_MKFIFO:
-		case CCS_DIRECTIVE_FILE_MKSOCK:
-		case CCS_DIRECTIVE_FILE_IOCTL:
-		case CCS_DIRECTIVE_FILE_CHMOD:
-		case CCS_DIRECTIVE_FILE_CHOWN:
-		case CCS_DIRECTIVE_FILE_CHGRP:
-			if (!ccs_compare_number(s[1], d[1]))
+		case DIRECTIVE_FILE_CREATE:
+		case DIRECTIVE_FILE_MKDIR:
+		case DIRECTIVE_FILE_MKFIFO:
+		case DIRECTIVE_FILE_MKSOCK:
+		case DIRECTIVE_FILE_IOCTL:
+		case DIRECTIVE_FILE_CHMOD:
+		case DIRECTIVE_FILE_CHOWN:
+		case DIRECTIVE_FILE_CHGRP:
+			if (!compare_number(s[1], d[1]))
 				continue;
 			/* fall through */
-		case CCS_DIRECTIVE_FILE_READ:
-		case CCS_DIRECTIVE_FILE_WRITE:
-		case CCS_DIRECTIVE_FILE_UNLINK:
-		case CCS_DIRECTIVE_FILE_GETATTR:
-		case CCS_DIRECTIVE_FILE_RMDIR:
-		case CCS_DIRECTIVE_FILE_TRUNCATE:
-		case CCS_DIRECTIVE_FILE_APPEND:
-		case CCS_DIRECTIVE_FILE_UNMOUNT:
-		case CCS_DIRECTIVE_FILE_CHROOT:
-		case CCS_DIRECTIVE_FILE_SYMLINK:
-			if (!ccs_compare_path(s[0], d[0]))
+		case DIRECTIVE_FILE_READ:
+		case DIRECTIVE_FILE_WRITE:
+		case DIRECTIVE_FILE_UNLINK:
+		case DIRECTIVE_FILE_GETATTR:
+		case DIRECTIVE_FILE_RMDIR:
+		case DIRECTIVE_FILE_TRUNCATE:
+		case DIRECTIVE_FILE_APPEND:
+		case DIRECTIVE_FILE_UNMOUNT:
+		case DIRECTIVE_FILE_CHROOT:
+		case DIRECTIVE_FILE_SYMLINK:
+			if (!compare_path(s[0], d[0]))
 				continue;
 			break;
-		case CCS_DIRECTIVE_FILE_MOUNT:
-			if (!ccs_compare_number(s[3], d[3]) ||
-			    !ccs_compare_path(s[2], d[2]))
+		case DIRECTIVE_FILE_MOUNT:
+			if (!compare_number(s[3], d[3]) ||
+			    !compare_path(s[2], d[2]))
 				continue;
 			/* fall through */
-		case CCS_DIRECTIVE_FILE_LINK:
-		case CCS_DIRECTIVE_FILE_RENAME:
-		case CCS_DIRECTIVE_FILE_PIVOT_ROOT:
-			if (!ccs_compare_path(s[1], d[1]) ||
-			    !ccs_compare_path(s[0], d[0]))
+		case DIRECTIVE_FILE_LINK:
+		case DIRECTIVE_FILE_RENAME:
+		case DIRECTIVE_FILE_PIVOT_ROOT:
+			if (!compare_path(s[1], d[1]) ||
+			    !compare_path(s[0], d[0]))
 				continue;
 			break;
-		case CCS_DIRECTIVE_IPC_SIGNAL:
+		case DIRECTIVE_IPC_SIGNAL:
 			/* Signal number component. */
 			if (strcmp(s[0], d[0]))
 				continue;
@@ -425,18 +419,18 @@
 			if (c && c != ' ')
 				continue;
 			break;
-		case CCS_DIRECTIVE_NETWORK_INET:
+		case DIRECTIVE_NETWORK_INET:
 			if (strcmp(s[0], d[0]) || strcmp(s[1], d[1]) ||
-			    !ccs_compare_address(s[2], d[2]) ||
-			    !ccs_compare_number(s[3], d[3]))
+			    !compare_address(s[2], d[2]) ||
+			    !compare_number(s[3], d[3]))
 				continue;
 			break;
-		case CCS_DIRECTIVE_NETWORK_UNIX:
+		case DIRECTIVE_NETWORK_UNIX:
 			if (strcmp(s[0], d[0]) || strcmp(s[1], d[1]) ||
-			    !ccs_compare_path(s[2], d[2]))
+			    !compare_path(s[2], d[2]))
 				continue;
 			break;
-		case CCS_DIRECTIVE_MISC_ENV:
+		case DIRECTIVE_MISC_ENV:
 			/* An environemnt variable name component. */
 			sarg.name = s[0];
 			ccs_fill_path_info(&sarg);
@@ -453,37 +447,35 @@
 		default:
 			continue;
 		}
-		ccs_gacl_list[index].selected = 1;
+		generic_list[index].selected = 1;
 	}
 	ccs_put();
 }
 
 /**
- * ccs_editpolicy_optimize - Try to merge entries included in other entries.
+ * editpolicy_optimize - Try to merge entries included in other entries.
  *
  * @current: Index in the domain policy.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_optimize(const int current)
+void editpolicy_optimize(const int current)
 {
 	char *cp;
-	const bool is_exception_list =
-		ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST;
-	enum ccs_editpolicy_directives s_index;
-	enum ccs_editpolicy_directives s_index2;
+	const bool is_acl_group = current_screen == SCREEN_EXCEPTION_LIST;
+	enum directive_type s_index;
+	enum directive_type s_index2;
 	if (current < 0)
 		return;
-	s_index = ccs_gacl_list[current].directive;
-	if (s_index == CCS_DIRECTIVE_NONE)
+	s_index = generic_list[current].directive;
+	if (s_index == DIRECTIVE_NONE)
 		return;
 	/* Allow acl_group lines to be optimized. */
-	if (is_exception_list &&
-	    (s_index < CCS_DIRECTIVE_ACL_GROUP_000 ||
-	     s_index > CCS_DIRECTIVE_ACL_GROUP_255))
+	if (is_acl_group && (s_index < DIRECTIVE_ACL_GROUP_000 ||
+			     s_index > DIRECTIVE_ACL_GROUP_255))
 		return;
-	if (s_index == CCS_DIRECTIVE_USE_GROUP) {
-		unsigned int group = atoi(ccs_gacl_list[current].operand);
+	if (s_index == DIRECTIVE_USE_GROUP) {
+		unsigned int group = atoi(generic_list[current].operand);
 		int i;
 		if (group >= 256)
 			return;
@@ -491,21 +483,20 @@
 			cp = strdup(acl_group_list[group][i]);
 			if (!cp)
 				return;
-			s_index = ccs_find_directive(true, cp);
-			if (s_index != CCS_DIRECTIVE_NONE)
-				ccs_editpolicy_do_optimize(cp, -1, s_index,
-							   s_index, false);
+			s_index = find_directive(true, cp);
+			if (s_index != DIRECTIVE_NONE)
+				editpolicy_do_optimize(cp, -1, s_index,
+						       s_index, false);
 			free(cp);
 		}
 		return;
 	}
-	cp = strdup(ccs_gacl_list[current].operand);
+	cp = strdup(generic_list[current].operand);
 	if (!cp)
 		return;
 	s_index2 = s_index;
-	if (is_exception_list)
-		s_index = ccs_find_directive(true, cp);
-	ccs_editpolicy_do_optimize(cp, current, s_index, s_index2,
-				   is_exception_list);
+	if (is_acl_group)
+		s_index = find_directive(true, cp);
+	editpolicy_do_optimize(cp, current, s_index, s_index2, is_acl_group);
 	free(cp);
 }
