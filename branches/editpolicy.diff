Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.c
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.c	(revision 6401)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.c	(working copy)
@@ -24,173 +24,161 @@
 #include "editpolicy.h"
 #include "readline.h"
 
-/* Domain policy. */
-struct ccs_domain_policy3 ccs_dp = { };
+/* Window information */
+static struct window {
+	/* Domain policy. */
+	struct domain_policy dp;
+	/* Policy directory. */
+	const char *policy_dir;
+	/* Policy file's name. */
+	const char *policy_file;
+	/*
+	 * Array of "reset_domain"/"no_reset_domain"/"initialize_domain"/
+	 * "no_initialize_domain"/"keep_domain"/"no_keep_domain" entries.
+	 */
+	struct transition_entry *transition_list;
+	/* Structure for holding domain transition preference. */
+	struct transition_preference *preference_list;
+	/*
+	 * List of "task auto_domain_transition"/
+	 * "task manual_domain_transition"/"auto_domain_transition=" part.
+	 */
+	char **jump_list;
+	/* Last error message. */
+	char *last_error;
+	/* Caption of the current screen. */
+	const char *caption;
+	/* Currently selected domain. */
+	char *current_domain;
+	/* Currently selected PID. */
+	unsigned int current_pid;
+	/* Number of domain jump source domains. */
+	int unnumbered_domains;
+	/* Length of transition_list array. */
+	int transition_list_len;
+	/* Length of preference_list array. */
+	int preference_list_len;
+	/* Length of jump_list array. */
+	int jump_list_len;
+	/* Width of CUI screen. */
+	int width;
+	/* Height of CUI screen. */
+	int height;
+	/* Number of entries available on current screen. */
+	int list_items;
+	/* Lines available for displaying ACL entries. */
+	int body_lines;
+	/* Columns to shift. */
+	int eat_col;
+	/* Max columns. */
+	int max_col;
+	/* Refresh interval in second. 0 means no auto refresh. */
+	unsigned int refresh_interval;
+	/* Previously active screen's index. */
+	enum screen_type previous_screen;
+	/* Sort ACL by operand first? */
+	_Bool sort_acl;
+	/* Sort profiles by value? */
+	_Bool sort_profile;
+	/*
+	 * Domain screen is dealing with process list rather than domain list?
+	 */
+	_Bool show_tasklist;
+	/* Start from the first line when showing ACL screen? */
+	_Bool no_restore_cursor;
+	_Bool force_move_cursor;
+	/* Need to reload the screen due to auto refresh? */
+	_Bool need_reload;
+	/* Use ccs-editpolicy-agent program? */
+	_Bool offline_mode;
+	/* Use readonly mode? */
+	_Bool readonly_mode;
+} w;
 
-/* Readline history. */
-static struct ccs_readline_data ccs_rl = { };
-
-/* Array of "path_group" entries. */
-struct ccs_path_group_entry *ccs_path_group_list = NULL;
-/* Length of ccs_path_group_list array. */
-int ccs_path_group_list_len = 0;
-/* Array of "number_group" entry. */
-struct ccs_number_group_entry *ccs_number_group_list = NULL;
-/* Length of ccs_number_group_list array. */
-int ccs_number_group_list_len = 0;
-/* Array of "address_group" entry. */
-struct ccs_address_group_entry *ccs_address_group_list = NULL;
-/* Length of ccs_address_group_list array. */
-int ccs_address_group_list_len = 0;
-/* Array of "acl_group" entry. */
-char **acl_group_list[256];
-/* Length of acl_group_list array.*/
-int acl_group_list_len[256];
-
-/* Array of string ACL entries. */
-struct ccs_generic_acl *ccs_gacl_list = NULL;
-/* Length of ccs_generic_list array. */
-static int ccs_gacl_list_count = 0;
-
-/* Policy directory. */
-static const char *ccs_policy_dir = NULL;
-/* Use ccs-editpolicy-agent program? */
-static _Bool ccs_offline_mode = false;
-/* Use readonly mode? */
-static _Bool ccs_readonly_mode = false;
-/* Refresh interval in second. 0 means no auto refresh. */
-static unsigned int ccs_refresh_interval = 0;
-/* Need to reload the screen due to auto refresh? */
-static _Bool ccs_need_reload = false;
-/* Policy file's name. */
-static const char *ccs_policy_file = NULL;
-/* Caption of the current screen. */
-static const char *ccs_list_caption = NULL;
-/* Currently selected domain. */
-static char *ccs_current_domain = NULL;
-/* Currently selected PID. */
-static unsigned int ccs_current_pid = 0;
+/* Cursor info for CUI screen. */
+struct ccs_screen screen[MAX_SCREEN_TYPE] = { };
 /* Currently active screen's index. */
-enum ccs_screen_type ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
-/* Previously active screen's index. */
-static enum ccs_screen_type ccs_previous_screen = CCS_SCREEN_DOMAIN_LIST;
-/*
- * Array of "initialize_domain"/"no_initialize_domain"/"keep_domain"/
- * "no_keep_domain" entries.
- */
-static struct ccs_transition_control_entry *ccs_transition_control_list = NULL;
-/* Length of ccs_transition_control_list array. */
-static int ccs_transition_control_list_len = 0;
-/* Sort profiles by value? */
-static _Bool ccs_profile_sort_type = false;
-/* Number of domain jump source domains. */
-static int ccs_unnumbered_domain_count = 0;
-/* Width of CUI screen. */
-static int ccs_window_width = 0;
-/* Height of CUI screen. */
-static int ccs_window_height = 0;
-/* Cursor info for CUI screen. */
-struct ccs_screen ccs_screen[CCS_MAXSCREEN] = { };
-/* Number of entries available on current screen. */
-int ccs_list_item_count = 0;
-/* Lines available for displaying ACL entries. */
-static int ccs_body_lines = 0;
-/* Columns to shift. */
-static int ccs_eat_col = 0;
-/* Max columns. */
-static int ccs_max_col = 0;
-/* Sort ACL by operand first? */
-static _Bool ccs_acl_sort_type = false;
-/* Last error message. */
-static char *ccs_last_error = NULL;
-/* Domain screen is dealing with process list rather than domain list? */
-static _Bool ccs_domain_sort_type = false;
-/* Start from the first line when showing ACL screen? */
-static _Bool ccs_no_restore_cursor = false;
-static _Bool ccs_force_move_cursor = false;
-
+enum screen_type active = SCREEN_DOMAIN_LIST;
+/* Currently loaded policy. */
+struct policy p;
 /* Namespace to use. */
 const struct ccs_path_info *ccs_current_ns = NULL;
 
+/* Readline history. */
+static struct ccs_readline_data rl = { };
+
 /* Domain transition coltrol keywords. */
-static const char *ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
-	[CCS_TRANSITION_CONTROL_RESET]         = "reset_domain ",
-	[CCS_TRANSITION_CONTROL_NO_RESET]      = "no_reset_domain ",
-	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
-	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
-	[CCS_TRANSITION_CONTROL_KEEP]          = "keep_domain ",
-	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
+static const char *transition_type[MAX_TRANSITION_TYPE] = {
+	[TRANSITION_RESET]         = "reset_domain ",
+	[TRANSITION_NO_RESET]      = "no_reset_domain ",
+	[TRANSITION_INITIALIZE]    = "initialize_domain ",
+	[TRANSITION_NO_INITIALIZE] = "no_initialize_domain ",
+	[TRANSITION_KEEP]          = "keep_domain ",
+	[TRANSITION_NO_KEEP]       = "no_keep_domain ",
 };
 
-static FILE *ccs_editpolicy_open_write(const char *filename);
-static _Bool ccs_deleted_domain(const int index);
-static _Bool ccs_domain_unreachable(const int index);
-static _Bool ccs_jump_source(const int index);
-static _Bool ccs_jump_target(const int index);
-static _Bool ccs_keeper_domain(const int index);
-static _Bool ccs_select_item(const int index);
-static _Bool ccs_show_command_key(const enum ccs_screen_type screen,
-				  const _Bool readonly);
-static const char *ccs_eat(const char *str);
-static const char *ccs_get_last_name(const int index);
-static const struct ccs_transition_control_entry *ccs_transition_control
+static _Bool is_deleted_domain(const int index);
+static _Bool is_jump_source(const int index);
+static _Bool is_jump_target(const int index);
+static _Bool is_keeper_domain(const int index);
+static _Bool is_unreachable_domain(const int index);
+static _Bool select_item(void);
+static _Bool show_command_key(const enum screen_type screen,
+			      const _Bool readonly);
+static const char *shift(const char *str);
+static const char *get_last_name(const int index);
+static const struct transition_entry *find_transition
 (const struct ccs_path_info *ns, const char *domainname, const char *program);
-static enum ccs_screen_type ccs_generic_list_loop(void);
-static enum ccs_screen_type ccs_select_window(const int current);
-static int ccs_add_path_group_entry(const struct ccs_path_info *ns,
-				    const char *group_name,
-				    const char *member_name);
-static int ccs_add_path_group_policy(const struct ccs_path_info *ns,
-				     char *data);
-static int ccs_add_number_group_entry(const char *group_name,
-				      const char *member_name);
-static int ccs_add_number_group_policy(char *data);
-static int ccs_add_address_group_entry(const char *group_name,
-				       const char *member_name);
-static int ccs_add_address_group_policy(char *data);
-static void ccs_add_acl_group_policy(const int group, const char *data);
-static void ccs_editpolicy_clear_groups(void);
-static int ccs_add_transition_control_entry(const struct ccs_path_info *ns,
-					    const char *domainname,
-					    const char *program, const enum
-					    ccs_transition_type type);
-static int ccs_add_transition_control_policy(const struct ccs_path_info *ns,
-					     char *data, const enum
-					     ccs_transition_type type);
-static int ccs_count(const unsigned char *array, const int len);
-static int ccs_count2(const struct ccs_generic_acl *array, int len);
-static int ccs_domainname_attribute_compare(const void *a, const void *b);
-static int ccs_gacl_compare(const void *a, const void *b);
-static int ccs_gacl_compare0(const void *a, const void *b);
-static int ccs_profile_entry_compare(const void *a, const void *b);
-static int ccs_show_acl_line(const int index, const int list_indent);
-static int ccs_show_domain_line(const int index);
-static int ccs_show_literal_line(const int index);
-static int ccs_show_profile_line(const int index);
-static int ccs_show_stat_line(const int index);
-static int ccs_string_acl_compare(const void *a, const void *b);
-static void ccs_add_entry(void);
-static void ccs_adjust_cursor_pos(const int item_count);
-static void ccs_assign_djs(const struct ccs_path_info *ns,
-			   const char *domainname, const char *program);
-static void ccs_copy_file(const char *source, const char *dest);
-static void ccs_delete_entry(const int index);
-static void ccs_down_arrow_key(void);
-static void ccs_find_entry(const _Bool input, const _Bool forward,
-			   const int current);
-static void ccs_page_down_key(void);
-static void ccs_page_up_key(void);
-static void ccs_read_domain_and_exception_policy(void);
-static void ccs_read_generic_policy(void);
-static void ccs_resize_window(void);
-static void ccs_set_cursor_pos(const int index);
-static void ccs_set_level(const int current);
-static void ccs_set_profile(const int current);
-static void ccs_set_quota(const int current);
-static void ccs_show_current(void);
-static void ccs_show_list(void);
-static void ccs_sigalrm_handler(int sig);
-static void ccs_up_arrow_key(void);
+static enum screen_type generic_list_loop(void);
+static enum screen_type select_window(void);
+static FILE *editpolicy_open_write(const char *filename);
+static int add_address_group(const char *group_name, const char *member_name);
+static int add_address_group_policy(char *data);
+static int add_number_group(const char *group_name, const char *member_name);
+static int add_number_group_policy(char *data);
+static int add_path_group(const struct ccs_path_info *ns,
+			  const char *group_name, const char *member_name);
+static int add_path_group_policy(const struct ccs_path_info *ns, char *data);
+static int add_transition_entry(const struct ccs_path_info *ns,
+				const char *domainname, const char *program,
+				const enum transition_type type);
+static int add_transition_policy(const struct ccs_path_info *ns, char *data,
+				 const enum transition_type type);
+static int count_domainlist(void);
+static int count_generic(void);
+static int count_tasklist(void);
+static int domain_compare(const void *a, const void *b);
+static int generic_compare(const void *a, const void *b);
+static int profile_compare(const void *a, const void *b);
+static int show_acl_line(const int index, const int list_indent);
+static int show_domain_line(const int index);
+static int show_literal_line(const int index);
+static int show_profile_line(const int index);
+static int show_stat_line(const int index);
+static int string_compare(const void *a, const void *b);
+static void add_acl_group_policy(const int group, const char *data);
+static void add_entry(void);
+static void adjust_cursor_pos(const int item_count);
+static void assign_djs(const struct ccs_path_info *ns, const char *domainname,
+		       const char *program);
+static void copy_file(const char *source, const char *dest);
+static void delete_entry(void);
+static void down_arrow_key(void);
+static void editpolicy_clear_groups(void);
+static void find_entry(const _Bool input, const _Bool forward);
+static void page_down_key(void);
+static void page_up_key(void);
+static void read_domain_and_exception_policy(void);
+static void read_generic_policy(void);
+static void resize_window(void);
+static void set_cursor_pos(const int index);
+static void set_level(void);
+static void set_profile(void);
+static void set_quota(void);
+static void show_current(void);
+static void show_list(void);
+static void sigalrm_handler(int sig);
+static void up_arrow_key(void);
 
 #define ccs_alloc(ptr, size, count)					\
 	({								\
@@ -200,7 +188,7 @@
 	})
 
 /**
- * ccs_find_domain3 - Find a domain by name and other attributes.
+ * find_domain - Find a domain by name and other attributes.
  *
  * @domainname: Name of domain to find.
  * @target:     Name of target to find. Maybe NULL.
@@ -208,12 +196,12 @@
  *
  * Returns index number (>= 0) if found, EOF otherwise.
  */
-static int ccs_find_domain3(const char *domainname, const char *target,
-			    const _Bool is_dd)
+static int find_domain(const char *domainname, const char *target,
+		       const _Bool is_dd)
 {
 	int i;
-	for (i = 0; i < ccs_dp.list_len; i++) {
-		const struct ccs_domain *ptr = &ccs_dp.list[i];
+	for (i = 0; i < w.dp.list_len; i++) {
+		const struct ccs_domain *ptr = &w.dp.list[i];
 		if (ptr->is_dd == is_dd &&
 		    ((!ptr->target && !target) ||
 		     (ptr->target && target &&
@@ -225,17 +213,17 @@
 }
 
 /**
- * ccs_find_domain3_by_name - Find a domain by name.
+ * find_domain_by_name - Find a domain by name.
  *
  * @domainname: Name of domain to find.
  *
  * Returns pointer to "struct ccs_domain" if found, NULL otherwise.
  */
-static struct ccs_domain *ccs_find_domain3_by_name(const char *domainname)
+static struct ccs_domain *find_domain_by_name(const char *domainname)
 {
 	int i;
-	for (i = 0; i < ccs_dp.list_len; i++) {
-		struct ccs_domain *ptr = &ccs_dp.list[i];
+	for (i = 0; i < w.dp.list_len; i++) {
+		struct ccs_domain *ptr = &w.dp.list[i];
 		if (!ptr->target && !strcmp(ptr->domainname->name, domainname))
 			return ptr;
 	}
@@ -243,7 +231,7 @@
 }
 
 /**
- * ccs_assign_domain3 - Create a domain by name and other attributes.
+ * assign_domain - Create a domain by name and other attributes.
  *
  * @domainname: Name of domain to find.
  * @target:     Name of target domain if the domain acts as domain jump source,
@@ -252,36 +240,36 @@
  *
  * Returns index number (>= 0) if created or already exists, abort otherwise.
  */
-static int ccs_assign_domain3(const char *domainname, const char *target,
-			      const _Bool is_dd)
+static int assign_domain(const char *domainname, const char *target,
+			 const _Bool is_dd)
 {
 	struct ccs_domain *ptr;
-	int index = ccs_find_domain3(domainname, target, is_dd);
+	int index = find_domain(domainname, target, is_dd);
 	if (index >= 0)
 		return index;
-	ptr = ccs_alloc(ccs_dp.list, sizeof(*ptr), ccs_dp.list_len);
+	ptr = ccs_alloc(w.dp.list, sizeof(*ptr), w.dp.list_len);
 	ptr->domainname = ccs_savename(domainname);
 	if (target)
 		ptr->target = ccs_savename(target);
 	ptr->is_dd = is_dd;
-	return ccs_dp.list_len - 1;
+	return w.dp.list_len - 1;
 }
 
 /**
- * ccs_add_string_entry - Add string entry to a domain.
+ * add_string_entry - Add string entry to a domain.
  *
  * @entry: String to add.
  * @index: Index in the @dp array.
  *
  * Returns 0 if successfully added or already exists, -EINVAL otherwise.
  */
-static int ccs_add_string_entry3(const char *entry, const int index)
+static int add_string_entry(const char *entry, const int index)
 {
 	const struct ccs_path_info **acl_ptr;
 	int acl_count;
 	const struct ccs_path_info *cp;
 	int i;
-	if (index < 0 || index >= ccs_dp.list_len) {
+	if (index < 0 || index >= w.dp.list_len) {
 		fprintf(stderr, "ERROR: domain is out of range.\n");
 		return -EINVAL;
 	}
@@ -289,8 +277,8 @@
 		return -EINVAL;
 	cp = ccs_savename(entry);
 
-	acl_ptr = ccs_dp.list[index].string_ptr;
-	acl_count = ccs_dp.list[index].string_count;
+	acl_ptr = w.dp.list[index].string_ptr;
+	acl_count = w.dp.list[index].string_count;
 
 	/* Check for the same entry. */
 	for (i = 0; i < acl_count; i++)
@@ -298,68 +286,68 @@
 		if (cp == acl_ptr[i])
 			return 0;
 
-	*ccs_alloc(ccs_dp.list[index].string_ptr, sizeof(*acl_ptr),
-		   ccs_dp.list[index].string_count) = cp;
+	*ccs_alloc(w.dp.list[index].string_ptr, sizeof(*acl_ptr),
+		   w.dp.list[index].string_count) = cp;
 	return 0;
 }
 
 /**
- * ccs_clear_domain_policy3 - Clean up domain policy.
+ * clear_domain_policy - Clean up domain policy.
  *
  * Returns nothing.
  */
-static void ccs_clear_domain_policy3(void)
+static void clear_domain_policy(void)
 {
 	int index;
-	for (index = 0; index < ccs_dp.list_len; index++) {
-		free(ccs_dp.list[index].string_ptr);
-		ccs_dp.list[index].string_ptr = NULL;
-		ccs_dp.list[index].string_count = 0;
+	for (index = 0; index < w.dp.list_len; index++) {
+		free(w.dp.list[index].string_ptr);
+		w.dp.list[index].string_ptr = NULL;
+		w.dp.list[index].string_count = 0;
 	}
-	free(ccs_dp.list);
-	ccs_dp.list = NULL;
-	ccs_dp.list_len = 0;
+	free(w.dp.list);
+	w.dp.list = NULL;
+	w.dp.list_len = 0;
 }
 
 /**
- * ccs_is_same_namespace - Check namespace.
+ * is_same_namespace - Check namespace.
  *
  * @domain: Domainname.
  * @ns:     Namespace.
  *
  * Returns true if same namespace, false otherwise.
  */
-static _Bool ccs_is_same_namespace(const char *domain,
-				   const struct ccs_path_info *ns)
+static _Bool is_same_namespace(const char *domain,
+			       const struct ccs_path_info *ns)
 {
 	return !strncmp(domain, ns->name, ns->total_len) &&
 		(domain[ns->total_len] == ' ' || !domain[ns->total_len]);
 }
 
 /**
- * ccs_is_current_namespace - Check namespace.
+ * is_current_namespace - Check namespace.
  *
  * @line: Line to check namespace.
  *
  * Returns true if this line deals current namespace, false otherwise.
  */
-static _Bool ccs_is_current_namespace(const char *line)
+static _Bool is_current_namespace(const char *line)
 {
-	return ccs_is_same_namespace(line, ccs_current_ns);
+	return is_same_namespace(line, ccs_current_ns);
 }
 
 /**
- * ccs_copy_file - Copy local file to local or remote file.
+ * copy_file - Copy local file to local or remote file.
  *
  * @source: Local file.
  * @dest:   Local or remote file name.
  *
  * Returns nothing.
  */
-static void ccs_copy_file(const char *source, const char *dest)
+static void copy_file(const char *source, const char *dest)
 {
 	FILE *fp_in = fopen(source, "r");
-	FILE *fp_out = fp_in ? ccs_editpolicy_open_write(dest) : NULL;
+	FILE *fp_out = fp_in ? editpolicy_open_write(dest) : NULL;
 	while (fp_in && fp_out) {
 		int c = fgetc(fp_in);
 		if (c == EOF)
@@ -373,13 +361,13 @@
 }
 
 /**
- * ccs_get_ns - Get namespace component from domainname.
+ * get_ns - Get namespace component from domainname.
  *
  * @domainname: A domainname.
  *
  * Returns the namespace component of @domainname.
  */
-static const struct ccs_path_info *ccs_get_ns(const char *domainname)
+static const struct ccs_path_info *get_ns(const char *domainname)
 {
 	const struct ccs_path_info *ns;
 	char *line = ccs_strdup(domainname);
@@ -393,13 +381,13 @@
 }
 
 /**
- * ccs_get_last_word - Get last component of a line.
+ * get_last_word - Get last component of a line.
  *
  * @line: A line of words.
  *
  * Returns the last component of the line.
  */
-static const char *ccs_get_last_word(const char *line)
+static const char *get_last_word(const char *line)
 {
 	const char *cp = strrchr(line, ' ');
 	if (cp)
@@ -408,361 +396,316 @@
 }
 
 /**
- * ccs_get_last_name - Get last component of a domainname.
+ * get_last_name - Get last component of a domainname.
  *
  * @index: Index in the domain policy.
  *
  * Returns the last component of the domainname.
  */
-static const char *ccs_get_last_name(const int index)
+static const char *get_last_name(const int index)
 {
-	return ccs_get_last_word(ccs_dp.list[index].domainname->name);
+	return get_last_word(w.dp.list[index].domainname->name);
 }
 
 /**
- * ccs_count - Count non-zero elements in an array.
+ * count_domainlist - Count non-zero elements in an array.
  *
- * @array: Pointer to "const unsigned char".
- * @len:   Length of @array array.
- *
  * Returns number of non-zero elements.
  */
-static int ccs_count(const unsigned char *array, const int len)
+static int count_domainlist(void)
 {
 	int i;
 	int c = 0;
-	for (i = 0; i < len; i++)
-		if (array[i])
+	for (i = 0; i < w.dp.list_len; i++)
+		if (w.dp.list_selected[i])
 			c++;
 	return c;
 }
 
 /**
- * ccs_count2 - Count non-zero elements in a "struct ccs_generic_acl" array.
+ * count_generic - Count non-zero elements in a "struct generic_entry" array.
  *
- * @array: Pointer to "const struct ccs_generic_acl".
- * @len:   Length of @array array.
- *
  * Returns number of non-zero elements.
  */
-static int ccs_count2(const struct ccs_generic_acl *array, int len)
+static int count_generic(void)
 {
 	int i;
 	int c = 0;
-	for (i = 0; i < len; i++)
-		if (array[i].selected)
+	for (i = 0; i < p.generic_len; i++)
+		if (p.generic[i].selected)
 			c++;
 	return c;
 }
 
 /**
- * ccs_count3 - Count non-zero elements in a "struct ccs_task_entry" array.
+ * count_tasklist - Count non-zero elements in a "struct ccs_task_entry" array.
  *
- * @array: Pointer to "const struct ccs_task_entry".
- * @len:   Length of @array array.
- *
  * Returns number of non-zero elements.
  */
-static int ccs_count3(const struct ccs_task_entry *array, int len)
+static int count_tasklist(void)
 {
 	int i;
 	int c = 0;
-	for (i = 0; i < len; i++)
-		if (array[i].selected)
+	for (i = 0; i < ccs_task_list_len; i++)
+		if (ccs_task_list[i].selected)
 			c++;
 	return c;
 }
 
 /**
- * ccs_keeper_domain - Check whether the given domain is marked as keeper or not.
+ * is_keeper_domain - Check whether the given domain is marked as keeper or not.
  *
  * @index: Index in the domain policy.
  *
  * Returns true if the given domain is marked as "keep_domain",
  * false otherwise.
  */
-static _Bool ccs_keeper_domain(const int index)
+static _Bool is_keeper_domain(const int index)
 {
-	return ccs_dp.list[index].is_dk;
+	return w.dp.list[index].is_dk;
 }
 
 /**
- * ccs_jump_source - Check whether the given domain is marked as jump source or not.
+ * is_jump_source - Check whether the given domain is marked as jump source or not.
  *
  * @index: Index in the domain policy.
  *
  * Returns true if the given domain is marked as domain jump source,
  * false otherwise.
  */
-static _Bool ccs_jump_source(const int index)
+static _Bool is_jump_source(const int index)
 {
-	return ccs_dp.list[index].target != NULL;
+	return w.dp.list[index].target != NULL;
 }
 
 /**
- * ccs_jump_target - Check whether the given domain is marked as jump target or not.
+ * is_jump_target - Check whether the given domain is marked as jump target or not.
  *
  * @index: Index in the domain policy.
  *
  * Returns true if the given domain is a domain jump target, false otherwise.
  */
-static _Bool ccs_jump_target(const int index)
+static _Bool is_jump_target(const int index)
 {
-	return ccs_dp.list[index].is_djt;
+	return w.dp.list[index].is_djt;
 }
 
 /**
- * ccs_domain_unreachable - Check whether the given domain is marked as unreachable or not.
+ * is_unreachable_domain - Check whether the given domain is marked as unreachable or not.
  *
  * @index: Index in the domain policy.
  *
  * Returns true if the given domain is unreachable, false otherwise.
  */
-static _Bool ccs_domain_unreachable(const int index)
+static _Bool is_unreachable_domain(const int index)
 {
-	return ccs_dp.list[index].is_du;
+	return w.dp.list[index].is_du;
 }
 
 /**
- * ccs_deleted_domain - Check whether the given domain is marked as deleted or not.
+ * is_deleted_domain - Check whether the given domain is marked as deleted or not.
  *
  * @index: Index in the domain policy.
  *
  * Returns true if the given domain is marked as deleted, false otherwise.
  */
-static _Bool ccs_deleted_domain(const int index)
+static _Bool is_deleted_domain(const int index)
 {
-	return ccs_dp.list[index].is_dd;
+	return w.dp.list[index].is_dd;
 }
 
 /**
- * ccs_gacl_compare0 - strcmp() for qsort() callback.
+ * string_compare - strcmp() for qsort() callback.
  *
  * @a: Pointer to "void".
  * @b: Pointer to "void".
  *
  * Returns return value of strcmp().
  */
-static int ccs_gacl_compare0(const void *a, const void *b)
+static int string_compare(const void *a, const void *b)
 {
-	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
-	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
-	const enum ccs_editpolicy_directives a0_d = a0->directive;
-	const enum ccs_editpolicy_directives b0_d = b0->directive;
-	const char *a1 = ccs_directives[a0_d].alias;
-	const char *b1 = ccs_directives[b0_d].alias;
-	const char *a2 = a0->operand;
-	const char *b2 = b0->operand;
-	int ret;
-	if (a0_d >= CCS_DIRECTIVE_ACL_GROUP_000 &&
-	    a0_d <= CCS_DIRECTIVE_ACL_GROUP_255 && 
-	    b0_d >= CCS_DIRECTIVE_ACL_GROUP_000 &&
-	    b0_d <= CCS_DIRECTIVE_ACL_GROUP_255 && a0_d != b0_d)
-		return a0_d - b0_d;
-	ret = strcmp(a1, b1);
-	if (ret)
-		return ret;
-	return strcmp(a2, b2);
-}
-
-/**
- * ccs_string_acl_compare - strcmp() for qsort() callback.
- *
- * @a: Pointer to "void".
- * @b: Pointer to "void".
- *
- * Returns return value of strcmp().
- */
-static int ccs_string_acl_compare(const void *a, const void *b)
-{
-	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
-	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
+	const struct generic_entry *a0 = (struct generic_entry *) a;
+	const struct generic_entry *b0 = (struct generic_entry *) b;
 	const char *a1 = a0->operand;
 	const char *b1 = b0->operand;
 	return strcmp(a1, b1);
 }
 
 /**
- * ccs_add_transition_control_policy - Add "reset_domain"/"no_reset_domain"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/"no_keep_domain" entries.
+ * add_transition_policy - Add "reset_domain"/"no_reset_domain"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/"no_keep_domain" entries.
  *
  * @ns:   Pointer to "const struct ccs_path_info".
  * @data: Line to parse.
- * @type: One of values in "enum ccs_transition_type".
+ * @type: One of values in "enum transition_type".
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_transition_control_policy
-(const struct ccs_path_info *ns, char *data,
- const enum ccs_transition_type type)
+static int add_transition_policy
+(const struct ccs_path_info *ns, char *data, const enum transition_type type)
 {
 	char *domainname = strstr(data, " from ");
 	if (domainname) {
 		*domainname = '\0';
 		domainname += 6;
-	} else if (type == CCS_TRANSITION_CONTROL_NO_KEEP ||
-		   type == CCS_TRANSITION_CONTROL_KEEP) {
+	} else if (type == TRANSITION_NO_KEEP || type == TRANSITION_KEEP) {
 		domainname = data;
 		data = NULL;
 	}
-	return ccs_add_transition_control_entry(ns, domainname, data, type);
+	return add_transition_entry(ns, domainname, data, type);
 }
 
 /**
- * ccs_add_path_group_policy - Add "path_group" entry.
+ * add_path_group_policy - Add "path_group" entry.
  *
  * @ns:   Pointer to "const struct ccs_path_info".
  * @data: Line to parse.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_path_group_policy(const struct ccs_path_info *ns,
-				     char *data)
+static int add_path_group_policy(const struct ccs_path_info *ns, char *data)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return ccs_add_path_group_entry(ns, data, cp);
+	return add_path_group(ns, data, cp);
 }
 
 /**
- * ccs_add_number_group_policy - Add "number_group" entry.
+ * add_number_group_policy - Add "number_group" entry.
  *
  * @data: Line to parse.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_number_group_policy(char *data)
+static int add_number_group_policy(char *data)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return ccs_add_number_group_entry(data, cp);
+	return add_number_group(data, cp);
 }
 
 /**
- * ccs_add_address_group_policy - Add "address_group" entry.
+ * add_address_group_policy - Add "address_group" entry.
  *
  * @data: Line to parse.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_address_group_policy(char *data)
+static int add_address_group_policy(char *data)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return ccs_add_address_group_entry(data, cp);
+	return add_address_group(data, cp);
 }
 
 /**
- * ccs_add_acl_group_policys - Add "acl_group" entry.
+ * add_acl_group_policys - Add "acl_group" entry.
  *
  * @group: Group number.
  * @data:  Line to parse.
  *
  * Returns nothing.
  */
-static void ccs_add_acl_group_policy(const int group, const char *data)
+static void add_acl_group_policy(const int group, const char *data)
 {
-	char **ptr = acl_group_list[group];
-	const int len = acl_group_list_len[group];
+	char **ptr = p.acl_group[group];
+	const int len = p.acl_group_len[group];
 	int i;
 	for (i = 0; i < len; i++)
 		if (!strcmp(ptr[i], data))
 			return;
-	*ccs_alloc(acl_group_list[group], sizeof(char *),
-		   acl_group_list_len[group]) = ccs_strdup(data);
+	*ccs_alloc(p.acl_group[group], sizeof(char *),
+		   p.acl_group_len[group]) = ccs_strdup(data);
 }
 
 /**
- * ccs_editpolicy_clear_groups - Clear path_group/number_group/address_group/acl_group for reloading policy.
+ * editpolicy_clear_groups - Clear path_group/number_group/address_group/acl_group for reloading policy.
  *
  * Returns nothing.
  */
-static void ccs_editpolicy_clear_groups(void)
+static void editpolicy_clear_groups(void)
 {
 	int i;
 	for (i = 0; i < 256; i++)
-		while (acl_group_list_len[i])
-			free(acl_group_list[i][--acl_group_list_len[i]]);
-	while (ccs_path_group_list_len)
-		free(ccs_path_group_list[--ccs_path_group_list_len].
+		while (p.acl_group_len[i])
+			free(p.acl_group[i][--p.acl_group_len[i]]);
+	while (p.path_group_len)
+		free(p.path_group[--p.path_group_len].
 		     member_name);
-	while (ccs_number_group_list_len)
-		free(ccs_number_group_list[--ccs_number_group_list_len].
-		     member_name);
-	while (ccs_address_group_list_len)
-		free(ccs_address_group_list[--ccs_address_group_list_len].
-		     member_name);
+	while (p.number_group_len)
+		free(p.number_group[--p.number_group_len].member_name);
+	while (p.address_group_len)
+		free(p.address_group[--p.address_group_len].member_name);
 }
 
 /**
- * ccs_find_path_group_ns - Find "path_group" entry.
+ * find_path_group_ns - Find "path_group" entry.
  *
  * @ns:         Pointer to "const struct ccs_path_info".
  * @group_name: Name of path group.
  *
- * Returns pointer to "struct ccs_path_group_entry" if found, NULL otherwise.
+ * Returns pointer to "struct path_group" if found, NULL otherwise.
  */
-struct ccs_path_group_entry *ccs_find_path_group_ns
+struct path_group *find_path_group_ns
 (const struct ccs_path_info *ns, const char *group_name)
 {
 	int i;
-	for (i = 0; i < ccs_path_group_list_len; i++)
-		if (!ccs_pathcmp(ccs_path_group_list[i].ns, ns) &&
-		    !strcmp(group_name,
-			    ccs_path_group_list[i].group_name->name))
-			return &ccs_path_group_list[i];
+	for (i = 0; i < p.path_group_len; i++)
+		if (!ccs_pathcmp(p.path_group[i].ns, ns) &&
+		    !strcmp(group_name, p.path_group[i].group_name->name))
+			return &p.path_group[i];
 	return NULL;
 }
 
 /**
- * ccs_assign_djs - Assign domain jump source domain.
+ * assign_djs - Assign domain jump source domain.
  *
  * @ns:         Pointer to "const struct ccs_path_info".
  * @domainname: Domainname.
  * @program:    Program name.
  */
-static void ccs_assign_djs(const struct ccs_path_info *ns,
-			   const char *domainname, const char *program)
+static void assign_djs(const struct ccs_path_info *ns,
+		       const char *domainname, const char *program)
 {
-	const struct ccs_transition_control_entry *d_t =
-		ccs_transition_control(ns, domainname, program);
+	const struct transition_entry *d_t =
+		find_transition(ns, domainname, program);
 	if (!d_t)
 		return;
-	if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE ||
-	    d_t->type == CCS_TRANSITION_CONTROL_RESET) {
+	if (d_t->type == TRANSITION_INITIALIZE ||
+	    d_t->type == TRANSITION_RESET) {
 		char *line;
 		char *cp;
 		ccs_get();
-		if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE)
+		if (d_t->type == TRANSITION_INITIALIZE)
 			line = ccs_shprintf("%s %s", domainname, program);
 		else
 			line = ccs_shprintf("%s <%s>", domainname, program);
 		ccs_normalize_line(line);
 		cp = ccs_strdup(line);
-		if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE)
+		if (d_t->type == TRANSITION_INITIALIZE)
 			line = ccs_shprintf("%s %s", ns->name, program);
 		else
 			line = ccs_shprintf("<%s>", program);
-		ccs_assign_domain3(cp, line, false);
+		assign_domain(cp, line, false);
 		free(cp);
 		ccs_put();
 	}
 }
 
 /**
- * ccs_domainname_attribute_compare - strcmp() for qsort() callback.
+ * domain_compare - strcmp() for qsort() callback.
  *
  * @a: Pointer to "void".
  * @b: Pointer to "void".
  *
  * Returns return value of strcmp().
  */
-static int ccs_domainname_attribute_compare(const void *a, const void *b)
+static int domain_compare(const void *a, const void *b)
 {
 	const struct ccs_domain *a0 = a;
 	const struct ccs_domain *b0 = b;
@@ -803,208 +746,208 @@
 	name2 = ccs_strdup(line);
 	ccs_put();
 	k = strcmp(name1, name2);
-done:
+ done:
 	free(name1);
 	free(name2);
 	return k;
 }
 
 /**
- * ccs_find_target_domain - Find the domain jump target domain.
+ * find_target_domain - Find the domain jump target domain.
  *
  * @index: Index in the domain policy.
  *
  * Returns index of the domain if found in a current namespace,
  * -2 if found in a different namespace, EOF otherwise.
  */
-static int ccs_find_target_domain(const int index)
+static int find_target_domain(const int index)
 {
-	const char *cp = ccs_dp.list[index].target->name;
-	if (!ccs_is_current_namespace(cp)) {
-		if (ccs_dp.list[index].is_du)
+	const char *cp = w.dp.list[index].target->name;
+	if (!is_current_namespace(cp)) {
+		if (w.dp.list[index].is_du)
 			return EOF;
 		return -2;
 	}
-	return ccs_find_domain3(cp, NULL, false);
+	return find_domain(cp, NULL, false);
 }
 
 /**
- * ccs_show_domain_line - Show a line of the domain transition tree.
+ * show_domain_line - Show a line of the domain transition tree.
  *
  * @index: Index in the domain policy.
  *
  * Returns length of the printed line.
  */
-static int ccs_show_domain_line(const int index)
+static int show_domain_line(const int index)
 {
 	int tmp_col = 0;
-	const struct ccs_transition_control_entry *transition_control;
+	const struct transition_entry *transition;
 	char *line;
 	const char *sp;
-	const int number = ccs_dp.list[index].number;
+	const int number = w.dp.list[index].number;
 	int redirect_index;
-	const bool is_djs = ccs_jump_source(index);
-	const bool is_deleted = ccs_deleted_domain(index);
+	const bool is_djs = is_jump_source(index);
+	const bool is_deleted = is_deleted_domain(index);
 	if (number >= 0)
-		printw("%c%4d:%3u %c%c%c ", ccs_dp.list_selected[index] ? '&' :
-		       ' ', number, ccs_dp.list[index].profile,
-		       ccs_keeper_domain(index) ? '#' : ' ',
-		       ccs_jump_target(index) ? '*' : ' ',
-		       ccs_domain_unreachable(index) ? '!' : ' ');
-	else if (ccs_dp.list[index].is_djt)
+		printw("%c%4d:%3u %c%c%c ", w.dp.list_selected[index] ? '&' :
+		       ' ', number, w.dp.list[index].profile,
+		       is_keeper_domain(index) ? '#' : ' ',
+		       is_jump_target(index) ? '*' : ' ',
+		       is_unreachable_domain(index) ? '!' : ' ');
+	else if (w.dp.list[index].is_djt)
 		printw("          %c*%c ",
-		       ccs_keeper_domain(index) ? '#' : ' ',
-		       ccs_domain_unreachable(index) ? '!' : ' ');
+		       is_keeper_domain(index) ? '#' : ' ',
+		       is_unreachable_domain(index) ? '!' : ' ');
 	else
 		printw("              ");
 	tmp_col += 14;
-	sp = ccs_dp.list[index].domainname->name;
+	sp = w.dp.list[index].domainname->name;
 	while (true) {
 		const char *cp = strchr(sp, ' ');
 		if (!cp)
 			break;
-		printw("%s", ccs_eat("    "));
+		printw("%s", shift("    "));
 		tmp_col += 4;
 		sp = cp + 1;
 	}
 	if (is_djs) {
-		printw("%s", ccs_eat("=> "));
+		printw("%s", shift("=> "));
 		tmp_col += 3;
-		sp = ccs_dp.list[index].target->name;
+		sp = w.dp.list[index].target->name;
 	}
 	if (is_deleted) {
-		printw("%s", ccs_eat("( "));
+		printw("%s", shift("( "));
 		tmp_col += 2;
 	}
-	printw("%s", ccs_eat(sp));
+	printw("%s", shift(sp));
 	tmp_col += strlen(sp);
 	if (is_deleted) {
-		printw("%s", ccs_eat(" )"));
+		printw("%s", shift(" )"));
 		tmp_col += 2;
 	}
-	transition_control = ccs_dp.list[index].d_t;
-	if (!transition_control || is_djs)
+	transition = w.dp.list[index].d_t;
+	if (!transition || is_djs)
 		goto no_transition_control;
 	ccs_get();
 	line = ccs_shprintf(" ( %s%s from %s )",
-			    ccs_transition_type[transition_control->type],
-			    transition_control->program ?
-			    transition_control->program->name : "any",
-			    transition_control->domainname ?
-			    transition_control->domainname->name : "any");
-	printw("%s", ccs_eat(line));
+			    transition_type[transition->type],
+			    transition->program ?
+			    transition->program->name : "any",
+			    transition->domainname ?
+			    transition->domainname->name : "any");
+	printw("%s", shift(line));
 	tmp_col += strlen(line);
 	ccs_put();
 	goto done;
-no_transition_control:
+ no_transition_control:
 	if (!is_djs)
 		goto done;
 	ccs_get();
-	redirect_index = ccs_find_target_domain(index);
+	redirect_index = find_target_domain(index);
 	if (redirect_index >= 0)
 		line = ccs_shprintf(" ( -> %d )",
-				    ccs_dp.list[redirect_index].number);
+				    w.dp.list[redirect_index].number);
 	else if (redirect_index == EOF)
 		line = ccs_shprintf(" ( -> Not Found )");
 	else
 		line = ccs_shprintf(" ( -> Namespace jump )");
-	printw("%s", ccs_eat(line));
+	printw("%s", shift(line));
 	tmp_col += strlen(line);
 	ccs_put();
-done:
+ done:
 	return tmp_col;
 }
 
 /**
- * ccs_show_acl_line - Print an ACL line.
+ * show_acl_line - Print an ACL line.
  *
  * @index:       Index in the generic list.
  * @list_indent: Indent size.
  *
  * Returns length of the printed line.
  */
-static int ccs_show_acl_line(const int index, const int list_indent)
+static int show_acl_line(const int index, const int list_indent)
 {
-	const enum ccs_editpolicy_directives directive =
-		ccs_gacl_list[index].directive;
-	const char *cp1 = ccs_directives[directive].alias;
-	const char *cp2 = ccs_gacl_list[index].operand;
-	int len = list_indent - ccs_directives[directive].alias_len;
+	const enum directive_type directive =
+		p.generic[index].directive;
+	const char *cp1 = directive_map[directive].alias;
+	const char *cp2 = p.generic[index].operand;
+	int len = list_indent - directive_map[directive].alias_len;
 	printw("%c%4d: %s ",
-	       ccs_gacl_list[index].selected ? '&' : ' ',
-	       index, ccs_eat(cp1));
+	       p.generic[index].selected ? '&' : ' ',
+	       index, shift(cp1));
 	while (len-- > 0)
-		printw("%s", ccs_eat(" "));
-	printw("%s", ccs_eat(cp2));
+		printw("%s", shift(" "));
+	printw("%s", shift(cp2));
 	return strlen(cp1) + strlen(cp2) + 8 + list_indent;
 }
 
 /**
- * ccs_show_profile_line - Print a profile line.
+ * show_profile_line - Print a profile line.
  *
  * @index: Index in the generic list.
  *
  * Returns length of the printed line.
  */
-static int ccs_show_profile_line(const int index)
+static int show_profile_line(const int index)
 {
-	const char *cp = ccs_gacl_list[index].operand;
-	const u16 profile = ccs_gacl_list[index].directive;
+	const char *cp = p.generic[index].operand;
+	const u16 profile = p.generic[index].directive;
 	char number[8] = "";
 	if (profile <= 256)
 		snprintf(number, sizeof(number) - 1, "%3u-", profile);
-	printw("%c%4d: %s", ccs_gacl_list[index].selected ? '&' : ' ',
-	       index, ccs_eat(number));
-	printw("%s ", ccs_eat(cp));
+	printw("%c%4d: %s", p.generic[index].selected ? '&' : ' ',
+	       index, shift(number));
+	printw("%s ", shift(cp));
 	return strlen(number) + strlen(cp) + 8;
 }
 
 /**
- * ccs_show_literal_line - Print a literal line.
+ * show_literal_line - Print a literal line.
  *
  * @index: Index in the generic list.
  *
  * Returns length of the printed line.
  */
-static int ccs_show_literal_line(const int index)
+static int show_literal_line(const int index)
 {
-	const char *cp = ccs_gacl_list[index].operand;
+	const char *cp = p.generic[index].operand;
 	printw("%c%4d: %s ",
-	       ccs_gacl_list[index].selected ? '&' : ' ',
-	       index, ccs_eat(cp));
+	       p.generic[index].selected ? '&' : ' ',
+	       index, shift(cp));
 	return strlen(cp) + 8;
 }
 
 /**
- * ccs_show_stat_line - Print a statistics line.
+ * show_stat_line - Print a statistics line.
  *
  * @index: Index in the generic list.
  *
  * Returns length of the printed line.
  */
-static int ccs_show_stat_line(const int index)
+static int show_stat_line(const int index)
 {
 	char *line;
 	unsigned int now;
 	ccs_get();
-	line = ccs_shprintf("%s", ccs_gacl_list[index].operand);
+	line = ccs_shprintf("%s", p.generic[index].operand);
 	if (line[0])
-		printw("%s", ccs_eat(line));
+		printw("%s", shift(line));
 	now = strlen(line);
 	ccs_put();
 	return now;
 }
 
 /**
- * ccs_show_command_key - Print help screen.
+ * show_command_key - Print help screen.
  *
  * @screen:   Currently selected screen.
  * @readonly: True if readonly_mopde, false otherwise.
  *
  * Returns true to continue, false to quit.
  */
-static _Bool ccs_show_command_key(const enum ccs_screen_type screen,
-				  const _Bool readonly)
+static _Bool show_command_key(const enum screen_type screen,
+			      const _Bool readonly)
 {
 	int c;
 	clear();
@@ -1012,7 +955,7 @@
 	printw("Q/q        Quit this editor.\n");
 	printw("R/r        Refresh to the latest information.\n");
 	switch (screen) {
-	case CCS_SCREEN_STAT_LIST:
+	case SCREEN_STAT_LIST:
 		break;
 	default:
 		printw("F/f        Find first.\n");
@@ -1022,7 +965,7 @@
 	printw("W/w        Switch to selected screen.\n");
 	/* printw("Tab        Switch to next screen.\n"); */
 	switch (screen) {
-	case CCS_SCREEN_STAT_LIST:
+	case SCREEN_STAT_LIST:
 		break;
 	default:
 		printw("Insert     Copy an entry at the cursor position to "
@@ -1034,12 +977,12 @@
 		       "position.\n");
 	}
 	switch (screen) {
-	case CCS_SCREEN_NS_LIST:
+	case SCREEN_NS_LIST:
 		if (!readonly)
 			printw("A/a        Add a new namespace.\n");
 		break;
-	case CCS_SCREEN_DOMAIN_LIST:
-		if (ccs_domain_sort_type) {
+	case SCREEN_DOMAIN_LIST:
+		if (w.show_tasklist) {
 			printw("S/s        Set profile number of selected "
 			       "processes.\n");
 			printw("Enter      Edit ACLs of a process at the "
@@ -1056,12 +999,12 @@
 			       "cursor position.\n");
 		}
 		break;
-	case CCS_SCREEN_STAT_LIST:
+	case SCREEN_STAT_LIST:
 		if (!readonly)
 			printw("S/s        Set memory quota of selected "
 			       "items.\n");
 		break;
-	case CCS_SCREEN_PROFILE_LIST:
+	case SCREEN_PROFILE_LIST:
 		if (!readonly)
 			printw("S/s        Set mode of selected items.\n");
 		break;
@@ -1069,9 +1012,9 @@
 		break;
 	}
 	switch (screen) {
-	case CCS_SCREEN_EXCEPTION_LIST:
-	case CCS_SCREEN_ACL_LIST:
-	case CCS_SCREEN_MANAGER_LIST:
+	case SCREEN_EXCEPTION_LIST:
+	case SCREEN_ACL_LIST:
+	case SCREEN_MANAGER_LIST:
 		if (!readonly) {
 			printw("A/a        Add a new entry.\n");
 			printw("D/d        Delete selected entries.\n");
@@ -1080,22 +1023,22 @@
 		break;
 	}
 	switch (screen) {
-	case CCS_SCREEN_PROFILE_LIST:
+	case SCREEN_PROFILE_LIST:
 		if (!readonly)
 			printw("A/a        Define a new profile.\n");
 	default:
 		break;
 	}
 	switch (screen) {
-	case CCS_SCREEN_ACL_LIST:
+	case SCREEN_ACL_LIST:
 		printw("O/o        Set selection state to other entries "
 		       "included in an entry at the cursor position.\n");
 		/* Fall through. */
-	case CCS_SCREEN_PROFILE_LIST:
+	case SCREEN_PROFILE_LIST:
 		printw("@          Switch sort type.\n");
 		break;
-	case CCS_SCREEN_DOMAIN_LIST:
-		if (!ccs_offline_mode)
+	case SCREEN_DOMAIN_LIST:
+		if (!w.offline_mode)
 			printw("@          Switch domain/process list.\n");
 	default:
 		break;
@@ -1115,26 +1058,26 @@
 }
 
 /**
- * ccs_set_error - Set error line's caption.
+ * set_error - Set error line's caption.
  *
  * @filename: Filename to print. Maybe NULL.
  *
  * Returns nothing.
  */
-static void ccs_set_error(const char *filename)
+static void set_error(const char *filename)
 {
 	if (filename) {
 		const int len = strlen(filename) + 128;
-		ccs_last_error = ccs_realloc2(ccs_last_error, len);
-		snprintf(ccs_last_error, len - 1, "Can't open %s .", filename);
+		w.last_error = ccs_realloc2(w.last_error, len);
+		snprintf(w.last_error, len - 1, "Can't open %s .", filename);
 	} else {
-		free(ccs_last_error);
-		ccs_last_error = NULL;
+		free(w.last_error);
+		w.last_error = NULL;
 	}
 }
 
 /**
- * ccs_editpolicy_open_write - Wrapper for ccs_open_write().
+ * editpolicy_open_write - Wrapper for ccs_open_write().
  *
  * @filename: File to open for writing.
  *
@@ -1144,16 +1087,16 @@
  * this function sets error line if failed. Also, this function returns NULL if
  * readonly mode.
  */
-static FILE *ccs_editpolicy_open_write(const char *filename)
+static FILE *editpolicy_open_write(const char *filename)
 {
 	FILE *fp = ccs_open_write(filename);
 	if (!fp)
-		ccs_set_error(filename);
+		set_error(filename);
 	return fp;
 }
 
 /**
- * ccs_editpolicy_open_read - Wrapper for ccs_open_read().
+ * editpolicy_open_read - Wrapper for ccs_open_read().
  *
  * @filename: File to open for reading.
  *
@@ -1162,16 +1105,16 @@
  * Since CUI policy editor screen provides a line for printing error message,
  * this function sets error line if failed.
  */
-static FILE *ccs_editpolicy_open_read(const char *filename)
+static FILE *editpolicy_open_read(const char *filename)
 {
 	FILE *fp = ccs_open_read(filename);
 	if (!fp)
-		ccs_set_error(filename);
+		set_error(filename);
 	return fp;
 }
 
 /**
- * ccs_open2 - Wrapper for open().
+ * open2 - Wrapper for open().
  *
  * @filename: File to open.
  * @mode:     Flags to passed to open().
@@ -1181,57 +1124,57 @@
  * Since CUI policy editor screen provides a line for printing error message,
  * this function sets error line if failed.
  */
-static int ccs_open2(const char *filename, int mode)
+static int open2(const char *filename, int mode)
 {
 	const int fd = open(filename, mode);
 	if (fd == EOF && errno != ENOENT)
-		ccs_set_error(filename);
+		set_error(filename);
 	return fd;
 }
 
 /**
- * ccs_sigalrm_handler - Callback routine for timer interrupt.
+ * sigalrm_handler - Callback routine for timer interrupt.
  *
  * @sig: Signal number. Not used.
  *
  * Returns nothing.
  *
- * This function is called when ccs_refresh_interval is non-zero. This function
+ * This function is called when w.refresh_interval is non-zero. This function
  * marks current screen to reload. Also, this function reenables timer event.
  */
-static void ccs_sigalrm_handler(int sig)
+static void sigalrm_handler(int sig)
 {
-	ccs_need_reload = true;
-	alarm(ccs_refresh_interval);
+	w.need_reload = true;
+	alarm(w.refresh_interval);
 }
 
 /**
- * ccs_eat - Shift string data before displaying.
+ * shift - Shift string data before displaying.
  *
  * @str: String to be displayed.
  *
  * Returns shifted string.
  */
-static const char *ccs_eat(const char *str)
+static const char *shift(const char *str)
 {
-	while (*str && ccs_eat_col) {
+	while (*str && w.eat_col) {
 		str++;
-		ccs_eat_col--;
+		w.eat_col--;
 	}
 	return str;
 }
 
 /**
- * ccs_transition_control - Find domain transition control.
+ * transition_control - Find domain transition control.
  *
  * @ns:         Pointer to "const struct ccs_path_info".
  * @domainname: Domainname.
  * @program:    Program name.
  *
- * Returns pointer to "const struct ccs_transition_control_entry" if found one,
+ * Returns pointer to "const struct ccs_transition_entry" if found one,
  * NULL otherwise.
  */
-static const struct ccs_transition_control_entry *ccs_transition_control
+static const struct transition_entry *find_transition
 (const struct ccs_path_info *ns, const char *domainname, const char *program)
 {
 	int i;
@@ -1239,14 +1182,13 @@
 	struct ccs_path_info domain;
 	struct ccs_path_info last_name;
 	domain.name = domainname;
-	last_name.name = ccs_get_last_word(domainname);
+	last_name.name = get_last_word(domainname);
 	ccs_fill_path_info(&domain);
 	ccs_fill_path_info(&last_name);
-	for (type = 0; type < CCS_MAX_TRANSITION_TYPE; type++) {
-next:
-		for (i = 0; i < ccs_transition_control_list_len; i++) {
-			struct ccs_transition_control_entry *ptr
-				= &ccs_transition_control_list[i];
+	for (type = 0; type < MAX_TRANSITION_TYPE; type++) {
+ next:
+		for (i = 0; i < w.transition_list_len; i++) {
+			struct transition_entry *ptr = &w.transition_list[i];
 			if (ptr->type != type)
 				continue;
 			if (ccs_pathcmp(ptr->ns, ns))
@@ -1258,25 +1200,25 @@
 			if (ptr->program &&
 			    strcmp(ptr->program->name, program))
 				continue;
-			if (type == CCS_TRANSITION_CONTROL_NO_RESET) {
+			if (type == TRANSITION_NO_RESET) {
 				/*
 				 * Do not check for reset_domain if
 				 * no_reset_domain matched.
 				 */
-				type = CCS_TRANSITION_CONTROL_NO_INITIALIZE;
+				type = TRANSITION_NO_INITIALIZE;
 				goto next;
 			}
-			if (type == CCS_TRANSITION_CONTROL_NO_INITIALIZE) {
+			if (type == TRANSITION_NO_INITIALIZE) {
 				/*
 				 * Do not check for initialize_domain if
 				 * no_initialize_domain matched.
 				 */
-				type = CCS_TRANSITION_CONTROL_NO_KEEP;
+				type = TRANSITION_NO_KEEP;
 				goto next;
 			}
-			if (type == CCS_TRANSITION_CONTROL_RESET ||
-			    type == CCS_TRANSITION_CONTROL_INITIALIZE ||
-			    type == CCS_TRANSITION_CONTROL_KEEP)
+			if (type == TRANSITION_RESET ||
+			    type == TRANSITION_INITIALIZE ||
+			    type == TRANSITION_KEEP)
 				return ptr;
 			else
 				return NULL;
@@ -1286,29 +1228,29 @@
 }
 
 /**
- * ccs_profile_entry_compare -  strcmp() for qsort() callback.
+ * profile_compare -  strcmp() for qsort() callback.
  *
  * @a: Pointer to "void".
  * @b: Pointer to "void".
  *
  * Returns return value of strcmp().
  */
-static int ccs_profile_entry_compare(const void *a, const void *b)
+static int profile_compare(const void *a, const void *b)
 {
-	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
-	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
-	const enum ccs_editpolicy_directives a0_d = a0->directive;
-	const enum ccs_editpolicy_directives b0_d = b0->directive;
+	const struct generic_entry *a0 = (struct generic_entry *) a;
+	const struct generic_entry *b0 = (struct generic_entry *) b;
+	const enum directive_type a0_d = a0->directive;
+	const enum directive_type b0_d = b0->directive;
 	const char *a1 = a0->operand;
 	const char *b1 = b0->operand;
-	if (a0_d >= CCS_DIRECTIVE_ADDRESS_GROUP ||
-	    b0_d >= CCS_DIRECTIVE_ADDRESS_GROUP) {
+	if (a0_d >= DIRECTIVE_ADDRESS_GROUP ||
+	    b0_d >= DIRECTIVE_ADDRESS_GROUP) {
 		if (a1[0] == 'P')
 			return -1;
 		if (b1[0] == 'P')
 			return 1;
 	}
-	if (!ccs_profile_sort_type) {
+	if (!w.sort_profile) {
 		if (a0_d == b0_d)
 			return strcmp(a1, b1);
 		else
@@ -1327,77 +1269,77 @@
 }
 
 /**
- * ccs_add_generic_entry - Add text lines.
+ * add_generic_entry - Add text lines.
  *
  * @line:      Line to add.
- * @directive: One of values in "enum ccs_editpolicy_directives".
+ * @directive: One of values in "enum directive_type".
  *
  * Returns nothing.
  */
-static void ccs_add_generic_entry(const char *line, const enum
-				  ccs_editpolicy_directives directive)
+static void add_generic_entry(const char *line, const enum directive_type
+			      directive)
 {
-	struct ccs_generic_acl *ptr;
+	struct generic_entry *ptr;
 	int i;
-	for (i = 0; i < ccs_gacl_list_count; i++)
-		if (ccs_gacl_list[i].directive == directive &&
-		    !strcmp(line, ccs_gacl_list[i].operand))
+	for (i = 0; i < p.generic_len; i++)
+		if (p.generic[i].directive == directive &&
+		    !strcmp(line, p.generic[i].operand))
 			return;
-	ptr = ccs_alloc(ccs_gacl_list, sizeof(*ptr), ccs_gacl_list_count);
+	ptr = ccs_alloc(p.generic, sizeof(*ptr), p.generic_len);
 	ptr->directive = directive;
 	ptr->operand = ccs_strdup(line);
 }
 
 /**
- * ccs_read_generic_policy - Read policy data other than domain policy.
+ * read_generic_policy - Read policy data other than domain policy.
  *
  * Returns nothing.
  */
-static void ccs_read_generic_policy(void)
+static void read_generic_policy(void)
 {
 	FILE *fp = NULL;
 	_Bool flag = false;
 	const _Bool is_kernel_ns = !strcmp(ccs_current_ns->name, "<kernel>");
-	while (ccs_gacl_list_count)
-		free((void *) ccs_gacl_list[--ccs_gacl_list_count].operand);
-	if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+	while (p.generic_len)
+		free((void *) p.generic[--p.generic_len].operand);
+	if (active == SCREEN_ACL_LIST) {
 		if (ccs_network_mode)
 			/* We can read after write. */
-			fp = ccs_editpolicy_open_write(ccs_policy_file);
+			fp = editpolicy_open_write(w.policy_file);
 		else
 			/* Don't set error message if failed. */
-			fp = fopen(ccs_policy_file, "r+");
+			fp = fopen(w.policy_file, "r+");
 		if (fp) {
-			if (ccs_domain_sort_type)
+			if (w.show_tasklist)
 				fprintf(fp, "select pid=%u\n",
-					ccs_current_pid);
+					w.current_pid);
 			else
 				fprintf(fp, "select domain=%s\n",
-					ccs_current_domain);
+					w.current_domain);
 			if (ccs_network_mode)
 				fputc(0, fp);
 			fflush(fp);
 		}
-	} else if (ccs_current_screen == CCS_SCREEN_NS_LIST) {
-		ccs_add_generic_entry("<kernel>", CCS_DIRECTIVE_NONE);
+	} else if (active == SCREEN_NS_LIST) {
+		add_generic_entry("<kernel>", DIRECTIVE_NONE);
 	}
 	if (!fp)
-		fp = ccs_editpolicy_open_read(ccs_policy_file);
+		fp = editpolicy_open_read(w.policy_file);
 	if (!fp) {
-		ccs_set_error(ccs_policy_file);
+		set_error(w.policy_file);
 		return;
 	}
-	ccs_freadline_raw = ccs_current_screen == CCS_SCREEN_STAT_LIST;
+	ccs_freadline_raw = active == SCREEN_STAT_LIST;
 	ccs_get();
 	while (true) {
 		char *line = ccs_freadline_unpack(fp);
-		enum ccs_editpolicy_directives directive;
+		enum directive_type directive;
 		char *cp;
 		if (!line)
 			break;
-		if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+		if (active == SCREEN_ACL_LIST) {
 			if (ccs_domain_def(line)) {
-				flag = !strcmp(line, ccs_current_domain);
+				flag = !strcmp(line, w.current_domain);
 				continue;
 			}
 			if (!flag || !line[0] ||
@@ -1407,47 +1349,47 @@
 			if (!line[0])
 				continue;
 		}
-		if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST ||
-		    ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
+		if (active == SCREEN_EXCEPTION_LIST ||
+		    active == SCREEN_PROFILE_LIST) {
 			if (*line == '<') {
 				cp = strchr(line, ' ');
-				if (!cp++ || !ccs_is_current_namespace(line))
+				if (!cp++ || !is_current_namespace(line))
 					continue;
 				memmove(line, cp, strlen(cp) + 1);
 			} else if (!is_kernel_ns)
 				continue;
 		}
-		switch (ccs_current_screen) {
-		case CCS_SCREEN_EXCEPTION_LIST:
-			directive = ccs_find_directive(true, line);
-			if (directive == CCS_DIRECTIVE_NONE)
+		switch (active) {
+		case SCREEN_EXCEPTION_LIST:
+			directive = find_directive(true, line);
+			if (directive == DIRECTIVE_NONE)
 				continue;
-			/* Remember groups for ccs_editpolicy_optimize(). */
-			if (directive != CCS_DIRECTIVE_PATH_GROUP &&
-			    directive != CCS_DIRECTIVE_NUMBER_GROUP &&
-			    directive != CCS_DIRECTIVE_ADDRESS_GROUP &&
-			    (directive < CCS_DIRECTIVE_ACL_GROUP_000 ||
-			     directive > CCS_DIRECTIVE_ACL_GROUP_255))
+			/* Remember groups for editpolicy_optimize(). */
+			if (directive != DIRECTIVE_PATH_GROUP &&
+			    directive != DIRECTIVE_NUMBER_GROUP &&
+			    directive != DIRECTIVE_ADDRESS_GROUP &&
+			    (directive < DIRECTIVE_ACL_GROUP_000 ||
+			     directive > DIRECTIVE_ACL_GROUP_255))
 				break;
 			cp = ccs_strdup(line);
-			if (directive == CCS_DIRECTIVE_PATH_GROUP)
-				ccs_add_path_group_policy(ccs_current_ns, cp);
-			else if (directive == CCS_DIRECTIVE_NUMBER_GROUP)
-				ccs_add_number_group_policy(cp);
-			else if (directive == CCS_DIRECTIVE_ADDRESS_GROUP)
-				ccs_add_address_group_policy(cp);
+			if (directive == DIRECTIVE_PATH_GROUP)
+				add_path_group_policy(ccs_current_ns, cp);
+			else if (directive == DIRECTIVE_NUMBER_GROUP)
+				add_number_group_policy(cp);
+			else if (directive == DIRECTIVE_ADDRESS_GROUP)
+				add_address_group_policy(cp);
 			else
-				ccs_add_acl_group_policy
-					(directive -
-					 CCS_DIRECTIVE_ACL_GROUP_000, cp);
+				add_acl_group_policy
+					(directive - DIRECTIVE_ACL_GROUP_000,
+					 cp);
 			free(cp);
 			break;
-		case CCS_SCREEN_ACL_LIST:
-			directive = ccs_find_directive(true, line);
-			if (directive == CCS_DIRECTIVE_NONE)
+		case SCREEN_ACL_LIST:
+			directive = find_directive(true, line);
+			if (directive == DIRECTIVE_NONE)
 				continue;
 			break;
-		case CCS_SCREEN_PROFILE_LIST:
+		case SCREEN_PROFILE_LIST:
 			cp = strchr(line, '-');
 			if (cp) {
 				*cp++ = '\0';
@@ -1456,7 +1398,7 @@
 			} else
 				directive = (u16) -1;
 			break;
-		case CCS_SCREEN_NS_LIST:
+		case SCREEN_NS_LIST:
 			if (*line != '<')
 				continue;
 			cp = strchr(line, ' ');
@@ -1467,52 +1409,47 @@
 				continue;
 			/* Fall through. */
 		default:
-			directive = CCS_DIRECTIVE_NONE;
+			directive = DIRECTIVE_NONE;
 			break;
 		}
-		ccs_add_generic_entry(line, directive);
+		add_generic_entry(line, directive);
 	}
 	ccs_put();
 	ccs_freadline_raw = false;
 	fclose(fp);
-	switch (ccs_current_screen) {
-	case CCS_SCREEN_ACL_LIST:
-		qsort(ccs_gacl_list, ccs_gacl_list_count,
-		      sizeof(struct ccs_generic_acl), ccs_gacl_compare);
+	switch (active) {
+	case SCREEN_ACL_LIST:
+	case SCREEN_EXCEPTION_LIST:
+		qsort(p.generic, p.generic_len, sizeof(struct generic_entry),
+		      generic_compare);
 		break;
-	case CCS_SCREEN_EXCEPTION_LIST:
-		qsort(ccs_gacl_list, ccs_gacl_list_count,
-		      sizeof(struct ccs_generic_acl),
-		      ccs_gacl_compare0);
+	case SCREEN_PROFILE_LIST:
+		qsort(p.generic, p.generic_len, sizeof(struct generic_entry),
+		      profile_compare);
 		break;
-	case CCS_SCREEN_PROFILE_LIST:
-		qsort(ccs_gacl_list, ccs_gacl_list_count,
-		      sizeof(struct ccs_generic_acl),
-		      ccs_profile_entry_compare);
+	case SCREEN_STAT_LIST:
 		break;
-	case CCS_SCREEN_STAT_LIST:
-		break;
 	default:
-		qsort(ccs_gacl_list, ccs_gacl_list_count,
-		      sizeof(struct ccs_generic_acl), ccs_string_acl_compare);
+		qsort(p.generic, p.generic_len, sizeof(struct generic_entry),
+		      string_compare);
 	}
 }
 
 /**
- * ccs_add_transition_control_entry - Add "reset_domain"/"no_reset_domain"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/ "no_keep_domain" entries.
+ * add_transition_entry - Add "reset_domain"/"no_reset_domain"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/ "no_keep_domain" entries.
  *
  * @ns:         Pointer to "const struct ccs_path_info".
  * @domainname: Domainname.
  * @program:    Program name.
- * @type:       One of values in "enum ccs_transition_type".
+ * @type:       One of values in "enum transition_type".
  *
  * Returns 0 on success, -EINVAL otherwise.
  */
-static int ccs_add_transition_control_entry
-(const struct ccs_path_info *ns, const char *domainname, const char *program,
- const enum ccs_transition_type type)
+static int add_transition_entry(const struct ccs_path_info *ns,
+				const char *domainname, const char *program,
+				const enum transition_type type)
 {
-	struct ccs_transition_control_entry *ptr;
+	struct transition_entry *ptr;
 	if (program && strcmp(program, "any"))
 		if (!ccs_correct_path(program))
 			return -EINVAL;
@@ -1520,8 +1457,8 @@
 		if (!ccs_correct_domain(domainname))
 			if (!ccs_correct_path(domainname))
 				return -EINVAL;
-	ptr = ccs_alloc(ccs_transition_control_list, sizeof(*ptr),
-			ccs_transition_control_list_len);
+	ptr = ccs_alloc(w.transition_list, sizeof(*ptr),
+			w.transition_list_len);
 	ptr->ns = ns;
 	if (program && strcmp(program, "any"))
 		ptr->program = ccs_savename(program);
@@ -1532,7 +1469,7 @@
 }
 
 /**
- * ccs_add_path_group_entry - Add "path_group" entry.
+ * add_path_group - Add "path_group" entry.
  *
  * @ns:          Pointer to "const struct ccs_path_info".
  * @group_name:  Name of address group.
@@ -1540,21 +1477,20 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_path_group_entry(const struct ccs_path_info *ns,
-				    const char *group_name,
-				    const char *member_name)
+static int add_path_group(const struct ccs_path_info *ns,
+			  const char *group_name, const char *member_name)
 {
 	const struct ccs_path_info *saved_group_name;
 	const struct ccs_path_info *saved_member_name;
 	int i;
 	int j;
-	struct ccs_path_group_entry *group = NULL;
+	struct path_group *group = NULL;
 	if (!ccs_correct_word(group_name) || !ccs_correct_word(member_name))
 		return -EINVAL;
 	saved_group_name = ccs_savename(group_name);
 	saved_member_name = ccs_savename(member_name);
-	for (i = 0; i < ccs_path_group_list_len; i++) {
-		group = &ccs_path_group_list[i];
+	for (i = 0; i < p.path_group_len; i++) {
+		group = &p.path_group[i];
 		if (group->ns != ns)
 			continue;
 		if (saved_group_name != group->group_name)
@@ -1564,9 +1500,9 @@
 				return 0;
 		break;
 	}
-	if (i == ccs_path_group_list_len) {
-		group = ccs_alloc(ccs_path_group_list, sizeof(*group),
-				  ccs_path_group_list_len);
+	if (i == p.path_group_len) {
+		group = ccs_alloc(p.path_group, sizeof(*group),
+				  p.path_group_len);
 		group->ns = ns;
 		group->group_name = saved_group_name;
 	}
@@ -1576,28 +1512,27 @@
 }
 
 /**
- * ccs_add_number_group_entry - Add "number_group" entry.
+ * add_number_group - Add "number_group" entry.
  *
  * @group_name:  Name of number group.
  * @member_name: Number string.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_number_group_entry(const char *group_name,
-				      const char *member_name)
+static int add_number_group(const char *group_name, const char *member_name)
 {
 	const struct ccs_path_info *saved_group_name;
 	int i;
 	int j;
 	struct ccs_number_entry entry;
-	struct ccs_number_group_entry *group = NULL;
+	struct number_group *group = NULL;
 	if (ccs_parse_number(member_name, &entry))
 		return -EINVAL;
 	if (!ccs_correct_word(group_name))
 		return -EINVAL;
 	saved_group_name = ccs_savename(group_name);
-	for (i = 0; i < ccs_number_group_list_len; i++) {
-		group = &ccs_number_group_list[i];
+	for (i = 0; i < p.number_group_len; i++) {
+		group = &p.number_group[i];
 		if (saved_group_name != group->group_name)
 			continue;
 		for (j = 0; j < group->member_name_len; j++)
@@ -1606,9 +1541,9 @@
 				return 0;
 		break;
 	}
-	if (i == ccs_number_group_list_len) {
-		group = ccs_alloc(ccs_number_group_list, sizeof(*group),
-				  ccs_number_group_list_len);
+	if (i == p.number_group_len) {
+		group = ccs_alloc(p.number_group, sizeof(*group),
+				  p.number_group_len);
 		group->group_name = saved_group_name;
 	}
 	*ccs_alloc(group->member_name, sizeof(entry), group->member_name_len) =
@@ -1617,28 +1552,27 @@
 }
 
 /**
- * ccs_add_address_group_entry - Add "address_group" entry.
+ * add_address_group - Add "address_group" entry.
  *
  * @group_name:  Name of address group.
  * @member_name: Address string.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_add_address_group_entry(const char *group_name,
-				       const char *member_name)
+static int add_address_group(const char *group_name, const char *member_name)
 {
 	const struct ccs_path_info *saved_group_name;
 	int i;
 	int j;
 	struct ccs_ip_address_entry entry;
-	struct ccs_address_group_entry *group = NULL;
+	struct address_group *group = NULL;
 	if (ccs_parse_ip(member_name, &entry))
 		return -EINVAL;
 	if (!ccs_correct_word(group_name))
 		return -EINVAL;
 	saved_group_name = ccs_savename(group_name);
-	for (i = 0; i < ccs_address_group_list_len; i++) {
-		group = &ccs_address_group_list[i];
+	for (i = 0; i < p.address_group_len; i++) {
+		group = &p.address_group[i];
 		if (saved_group_name != group->group_name)
 			continue;
 		for (j = 0; j < group->member_name_len; j++)
@@ -1647,9 +1581,9 @@
 				return 0;
 		break;
 	}
-	if (i == ccs_address_group_list_len) {
-		group = ccs_alloc(ccs_address_group_list, sizeof(*group),
-				  ccs_address_group_list_len);
+	if (i == p.address_group_len) {
+		group = ccs_alloc(p.address_group, sizeof(*group),
+				  p.address_group_len);
 		group->group_name = saved_group_name;
 	}
 	*ccs_alloc(group->member_name, sizeof(entry), group->member_name_len) =
@@ -1657,22 +1591,15 @@
 	return 0;
 }
 
-/*
- * List of "task auto_domain_transition" "task manual_domain_transition"
- * "auto_domain_transition=" part.
- */
-static char **ccs_jump_list = NULL;
-static int ccs_jump_list_len = 0;
-
 /**
- * ccs_add_condition_domain_transition - Add auto_domain_transition= part.
+ * add_condition_domain_transition - Add auto_domain_transition= part.
  *
  * @line:  Line to parse.
  * @index: Current domain's index.
  *
  * Returns nothing.
  */
-static void ccs_add_condition_domain_transition(char *line, const int index)
+static void add_condition_domain_transition(char *line, const int index)
 {
 	static char domainname[4096];
 	int source;
@@ -1688,25 +1615,26 @@
 		return;
 	cp[source - 1] = '\0';
 	snprintf(domainname, sizeof(domainname) - 1, "%s  %s",
-		 ccs_dp.list[index].domainname->name, cp);
+		 w.dp.list[index].domainname->name, cp);
 	domainname[sizeof(domainname) - 1] = '\0';
 	ccs_normalize_line(domainname);
-	*ccs_alloc(ccs_jump_list, sizeof(char *), ccs_jump_list_len) =
+	*ccs_alloc(w.jump_list, sizeof(char *), w.jump_list_len) =
 		ccs_strdup(domainname);
-	ccs_assign_domain3(domainname, *cp == '<' ? cp : domainname, false);
+	assign_domain(domainname, *cp == '<' ? cp : domainname, false);
 }
 
 /**
- * ccs_add_acl_domain_transition - Add task acl.
+ * add_acl_domain_transition - Add task acl.
  *
  * @line:  Line to parse.
  * @index: Current domain's index.
  *
  * Returns nothing.
  */
-static void ccs_add_acl_domain_transition(char *line, const int index)
+static void add_acl_domain_transition(char *line, const int index)
 {
 	static char domainname[4096];
+	
 	int pos;
 	/* Chop off condition part which follows domainname. */
 	for (pos = 0; line[pos]; pos++)
@@ -1716,25 +1644,17 @@
 		}
 	if (!ccs_correct_domain(line))
 		return;
-	*ccs_alloc(ccs_jump_list, sizeof(char *), ccs_jump_list_len) =
+	*ccs_alloc(w.jump_list, sizeof(char *), w.jump_list_len) =
 		ccs_strdup(line);
 	snprintf(domainname, sizeof(domainname) - 1, "%s  %s",
-		 ccs_dp.list[index].domainname->name, ccs_get_last_word(line));
+		 w.dp.list[index].domainname->name, get_last_word(line));
 	domainname[sizeof(domainname) - 1] = '\0';
 	ccs_normalize_line(domainname);
-	ccs_assign_domain3(domainname, line, false);
+	assign_domain(domainname, line, false);
 }
 
-/* Structure for holding domain transition preference. */
-static struct ccs_transition_preference {
-	int index;
-	char *program;
-	char *domainname;
-} *ccs_transition_preference_list = NULL;
-static int ccs_transition_preference_list_len = 0;
-
 /**
- * ccs_parse_transition_preference - Parse transition preference.
+ * parse_preference - Parse transition preference.
  *
  * @program:    Pathname or path_group.
  * @domainname: Domainname or transition preference.
@@ -1742,10 +1662,9 @@
  *
  * Returns true if transition preference was found, false otherwise.
  */
-static _Bool ccs_parse_transition_preference(char *program, char *domainname,
-					     const int index)
+static _Bool parse_preference(char *program, char *domainname, const int index)
 {
-	struct ccs_transition_preference *ptr;
+	struct transition_preference *ptr;
 	char *cp = strchr(domainname, ' ');
 	if (*domainname == '<')
 		goto add;
@@ -1756,9 +1675,9 @@
 	    || !strcmp(domainname, "child") || !strcmp(domainname, "parent"))
 		goto add;
 	return false;
-add:
-	ptr = ccs_alloc(ccs_transition_preference_list, sizeof(*ptr),
-			ccs_transition_preference_list_len);
+ add:
+	ptr = ccs_alloc(w.preference_list, sizeof(*ptr),
+			w.preference_list_len);
 	ptr->index = index;
 	ptr->domainname = ccs_strdup(domainname);
 	ptr->program = ccs_strdup(program);
@@ -1767,22 +1686,22 @@
 }
 
 /**
- * ccs_make_transition_preference - Create transition preference.
+ * make_preference - Create transition preference.
  *
- * @program:    Pathname or path_group.
- * @domainname: Domainname or transition preference.
- * @index:      Current domain's index.
+ * @ptr: Pointer to "struct transition_preference".
  *
  * Returns nothing.
  */
-static void ccs_make_transition_preference(char *program, char *domainname,
-					   const int index)
+static void make_preference(struct transition_preference *ptr)
 {
 	static char buffer[4096];
-	const char *self = ccs_dp.list[index].domainname->name;
+	char *program = ptr->program;
+	char *domainname = ptr->domainname;
+	const int index = ptr->index;
+	const char *self = w.dp.list[index].domainname->name;
 	int i;
-	struct ccs_path_group_entry *group = *program == '@' ?
-		ccs_find_path_group_ns(ccs_get_ns(self), program + 1) : NULL;
+	struct path_group *group = *program == '@' ?
+		find_path_group_ns(get_ns(self), program + 1) : NULL;
 	const int j = group ? group->member_name_len : 0;
 	buffer[sizeof(buffer) - 1] = '\0';
 	if (*domainname == '<')
@@ -1794,7 +1713,7 @@
 			for (i = 0; i < j; i++) {
 				snprintf(buffer, sizeof(buffer) - 1, "<%s>",
 					 group->member_name[i]->name);
-				ccs_add_acl_domain_transition(buffer, index);
+				add_acl_domain_transition(buffer, index);
 			}
 			return;
 		}
@@ -1811,7 +1730,7 @@
 					continue;
 				snprintf(buffer, sizeof(buffer) - 1, "%s %s",
 					 tmp, cp2);
-				ccs_add_acl_domain_transition(buffer, index);
+				add_acl_domain_transition(buffer, index);
 			}
 			free(tmp);
 			return;
@@ -1826,7 +1745,7 @@
 					continue;
 				snprintf(buffer, sizeof(buffer) - 1, "%s %s",
 					 self, cp);
-				ccs_add_acl_domain_transition(buffer, index);
+				add_acl_domain_transition(buffer, index);
 			}
 			return;
 		}
@@ -1840,7 +1759,7 @@
 	} else
 		snprintf(buffer, sizeof(buffer) - 1, "%s %s", self,
 			 domainname);
-	ccs_add_acl_domain_transition(buffer, index);
+	add_acl_domain_transition(buffer, index);
 }
 
 /**
@@ -1858,7 +1777,7 @@
 				  const int index, const bool parse_flags)
 {
 	_Bool exec = false;
-	ccs_add_condition_domain_transition(line, index);
+	add_condition_domain_transition(line, index);
 	if (ccs_str_starts(line, "task auto_execute_handler ") ||
 	    ccs_str_starts(line, "task denied_execute_handler ") ||
 	    (exec = true, ccs_str_starts(line, "file execute "))) {
@@ -1869,20 +1788,20 @@
 		char *cp = strchr(line, ' ');
 		if (cp) {
 			*cp++ = '\0';
-			if (ccs_parse_transition_preference(line, cp, index))
+			if (parse_preference(line, cp, index))
 				return;
 		}
 		if ((exec && *line == '@') || ccs_correct_path(line))
-			ccs_add_string_entry3(line, index);
+			add_string_entry(line, index);
 	} else if (ccs_str_starts(line, "task auto_domain_transition ") ||
 		   ccs_str_starts(line, "task manual_domain_transition ")) {
-		ccs_add_acl_domain_transition(line, index);
+		add_acl_domain_transition(line, index);
 	} else if (parse_flags) {
 		unsigned int idx;
 		if (sscanf(line, "use_profile %u", &idx) == 1 && idx < 256)
-			ccs_dp.list[index].profile = (u8) idx;
+			w.dp.list[index].profile = (u8) idx;
 		else if (sscanf(line, "use_group %u", &idx) == 1 && idx < 256)
-			ccs_dp.list[index].group = (u8) idx;
+			w.dp.list[index].group = (u8) idx;
 	}
 }
 
@@ -1897,28 +1816,29 @@
 static void ccs_parse_exception_line(const struct ccs_path_info *ns,
 				     char *line)
 {
+	int index;
 	unsigned int group;
-	for (group = 0; group < CCS_MAX_TRANSITION_TYPE; group++) {
-		if (!ccs_str_starts(line, ccs_transition_type[group]))
+	for (index = 0; index < MAX_TRANSITION_TYPE; index++) {
+		if (!ccs_str_starts(line, transition_type[index]))
 			continue;
-		ccs_add_transition_control_policy(ns, line, group);
+		add_transition_policy(ns, line, index);
 		return;
 	}
 	if (ccs_str_starts(line, "path_group "))
-		ccs_add_path_group_policy(ns, line);
+		add_path_group_policy(ns, line);
 	else if (ccs_str_starts(line, "address_group "))
-		ccs_add_address_group_policy(line);
+		add_address_group_policy(line);
 	else if (ccs_str_starts(line, "number_group "))
-		ccs_add_number_group_policy(line);
+		add_number_group_policy(line);
 	else if (sscanf(line, "acl_group %u", &group) == 1 && group < 256) {
 		int index;
 		line = strchr(line + 10, ' ');
 		if (!line++)
 			return;
-		ccs_add_acl_group_policy(group, line);
-		for (index = 0; index < ccs_dp.list_len; index++) {
+		add_acl_group_policy(group, line);
+		for (index = 0; index < w.dp.list_len; index++) {
 			char *cp;
-			const struct ccs_domain *ptr = &ccs_dp.list[index];
+			const struct ccs_domain *ptr = &w.dp.list[index];
 			if (ptr->group != group || ptr->target || ptr->is_dd)
 				continue;
 			cp = ccs_strdup(line);
@@ -1929,7 +1849,7 @@
 }
 
 /**
- * ccs_read_domain_and_exception_policy - Read domain policy and exception policy.
+ * read_domain_and_exception_policy - Read domain policy and exception policy.
  *
  * Returns nothing.
  *
@@ -1937,7 +1857,7 @@
  * unreachable domains, we need to read not only the domain policy but also
  * the exception policy for printing the domain transition tree.
  */
-static void ccs_read_domain_and_exception_policy(void)
+static void read_domain_and_exception_policy(void)
 {
 	FILE *fp;
 	int i;
@@ -1947,11 +1867,11 @@
 	static const struct ccs_path_info *ccs_kernel_ns = NULL;
 	const struct ccs_path_info *ns;
 
-	while (ccs_jump_list_len)
-		free(ccs_jump_list[--ccs_jump_list_len]);
-	ccs_clear_domain_policy3();
-	ccs_transition_control_list_len = 0;
-	ccs_editpolicy_clear_groups();
+	while (w.jump_list_len)
+		free(w.jump_list[--w.jump_list_len]);
+	clear_domain_policy();
+	w.transition_list_len = 0;
+	editpolicy_clear_groups();
 	if (!ccs_kernel_ns)
 		ccs_kernel_ns = ccs_savename("<kernel>");
 	ns = ccs_kernel_ns;
@@ -1960,7 +1880,7 @@
 	fp = NULL;
 	if (ccs_network_mode)
 		/* We can read after write. */
-		fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
+		fp = editpolicy_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
 	else
 		/* Don't set error message if failed. */
 		fp = fopen(CCS_PROC_POLICY_DOMAIN_POLICY, "r+");
@@ -1970,7 +1890,7 @@
 			fputc(0, fp);
 		fflush(fp);
 	} else {
-		fp = ccs_editpolicy_open_read(CCS_PROC_POLICY_DOMAIN_POLICY);
+		fp = editpolicy_open_read(CCS_PROC_POLICY_DOMAIN_POLICY);
 	}
 	if (fp) {
 		index = EOF;
@@ -1980,8 +1900,8 @@
 			if (!line)
 				break;
 			if (*line == '<') {
-				ns = ccs_get_ns(line);
-				index = ccs_assign_domain3(line, NULL, false);
+				ns = get_ns(line);
+				index = assign_domain(line, NULL, false);
 				continue;
 			} else if (index == EOF) {
 				continue;
@@ -1993,7 +1913,7 @@
 	}
 
 	/* Load domain transition related entries and group entries. */
-	fp = ccs_editpolicy_open_read(CCS_PROC_POLICY_EXCEPTION_POLICY);
+	fp = editpolicy_open_read(CCS_PROC_POLICY_EXCEPTION_POLICY);
 	if (fp) {
 		ccs_get();
 		while (true) {
@@ -2016,17 +1936,15 @@
 	}
 
 	/* Create domain transition preference. */
-	for (i = 0; i < ccs_transition_preference_list_len; i++) {
-		struct ccs_transition_preference *ptr =
-			&ccs_transition_preference_list[i];
-		ccs_make_transition_preference(ptr->program, ptr->domainname,
-					       ptr->index);
+	for (i = 0; i < w.preference_list_len; i++) {
+		struct transition_preference *ptr = &w.preference_list[i];
+		make_preference(&w.preference_list[i]);
 		free(ptr->domainname);
 		free(ptr->program);
 	}
-	free(ccs_transition_preference_list);
-	ccs_transition_preference_list= NULL;
-	ccs_transition_preference_list_len = 0;
+	free(w.preference_list);
+	w.preference_list = NULL;
+	w.preference_list_len = 0;
 
 	/*
 	 * Domain jump sources by "task manual_domain_transition" keyword or
@@ -2041,46 +1959,46 @@
 	 * directives defined in the exception policy. Note that "file execute"
 	 * allows referring "path_group" directives.
 	 */
-	max_index = ccs_dp.list_len;
+	max_index = w.dp.list_len;
 	for (index = 0; index < max_index; index++) {
-		const char *domainname = ccs_dp.list[index].domainname->name;
+		const char *domainname = w.dp.list[index].domainname->name;
 		const struct ccs_path_info **string_ptr
-			= ccs_dp.list[index].string_ptr;
-		const int max_count = ccs_dp.list[index].string_count;
+			= w.dp.list[index].string_ptr;
+		const int max_count = w.dp.list[index].string_count;
 		/* Do not recursively create domain jump source. */
-		if (ccs_dp.list[index].target)
+		if (w.dp.list[index].target)
 			continue;
-		ns = ccs_get_ns(domainname);
+		ns = get_ns(domainname);
 		for (i = 0; i < max_count; i++) {
 			const char *name = string_ptr[i]->name;
-			struct ccs_path_group_entry *group;
+			struct path_group *group;
 			if (name[0] != '@') {
-				ccs_assign_djs(ns, domainname, name);
+				assign_djs(ns, domainname, name);
 				continue;
 			}
-			group = ccs_find_path_group_ns(ns, name + 1);
+			group = find_path_group_ns(ns, name + 1);
 			if (!group)
 				continue;
 			for (j = 0; j < group->member_name_len; j++) {
 				name = group->member_name[j]->name;
-				ccs_assign_djs(ns, domainname, name);
+				assign_djs(ns, domainname, name);
 			}
 		}
 	}
 
 	/* Create missing parent domains. */
-	max_index = ccs_dp.list_len;
+	max_index = w.dp.list_len;
 	for (index = 0; index < max_index; index++) {
 		char *line;
 		ccs_get();
-		line = ccs_shprintf("%s", ccs_dp.list[index].domainname->name);
+		line = ccs_shprintf("%s", w.dp.list[index].domainname->name);
 		while (true) {
 			char *cp = strrchr(line, ' ');
 			if (!cp)
 				break;
 			*cp = '\0';
-			if (ccs_find_domain3(line, NULL, false) == EOF)
-				ccs_assign_domain3(line, NULL, true);
+			if (find_domain(line, NULL, false) == EOF)
+				assign_domain(line, NULL, true);
 		}
 		ccs_put();
 	}
@@ -2089,7 +2007,7 @@
 	 * All domains and jump sources have been created by now.
 	 * Let's markup domain jump targets and unreachable domains.
 	 */
-	max_index = ccs_dp.list_len;
+	max_index = w.dp.list_len;
 
 	/*
 	 * Find domains that might be reachable via
@@ -2098,9 +2016,8 @@
 	 * "auto_domain_transition=" part of conditional ACL.
 	 * Such domains are marked with '*'.
 	 */
-	for (i = 0; i < ccs_jump_list_len; i++) {
-		struct ccs_domain *ptr =
-			ccs_find_domain3_by_name(ccs_jump_list[i]);
+	for (i = 0; i < w.jump_list_len; i++) {
+		struct ccs_domain *ptr = find_domain_by_name(w.jump_list[i]);
 		if (ptr)
 			ptr->is_djt = true;
 	}
@@ -2110,7 +2027,7 @@
 	 * keyword. Such domains are marked with '*'.
 	 */
 	for (index = 0; index < max_index; index++) {
-		const struct ccs_domain *domain = &ccs_dp.list[index];
+		const struct ccs_domain *domain = &w.dp.list[index];
 		const char *domainname = domain->domainname->name;
 		char *cp;
 		/* Ignore domain jump sources. */
@@ -2124,12 +2041,11 @@
 		if (!cp++ || strchr(cp, ' '))
 			continue;
 		/* Check "no_initialize_domain $program from any" entry. */
-		for (i = 0; i < ccs_transition_control_list_len; i++) {
-			struct ccs_transition_control_entry *ptr
-				= &ccs_transition_control_list[i];
-			if (ptr->type != CCS_TRANSITION_CONTROL_NO_INITIALIZE)
+		for (i = 0; i < w.transition_list_len; i++) {
+			struct transition_entry *ptr = &w.transition_list[i];
+			if (ptr->type != TRANSITION_NO_INITIALIZE)
 				continue;
-			if (!ccs_is_same_namespace(domainname, ptr->ns))
+			if (!is_same_namespace(domainname, ptr->ns))
 				continue;
 			if (ptr->domainname)
 				continue;
@@ -2137,24 +2053,23 @@
 				continue;
 			break;
 		}
-		if (i < ccs_transition_control_list_len)
+		if (i < w.transition_list_len)
 			continue;
 		/*
 		 * Check "initialize_domain $program from $domainname" entry.
 		 */
-		for (i = 0; i < ccs_transition_control_list_len; i++) {
-			struct ccs_transition_control_entry *ptr
-				= &ccs_transition_control_list[i];
-			if (ptr->type != CCS_TRANSITION_CONTROL_INITIALIZE)
+		for (i = 0; i < w.transition_list_len; i++) {
+			struct transition_entry *ptr = &w.transition_list[i];
+			if (ptr->type != TRANSITION_INITIALIZE)
 				continue;
-			if (!ccs_is_same_namespace(domainname, ptr->ns))
+			if (!is_same_namespace(domainname, ptr->ns))
 				continue;
 			if (ptr->program && strcmp(ptr->program->name, cp))
 				continue;
 			break;
 		}
-		if (i < ccs_transition_control_list_len)
-			ccs_dp.list[index].is_djt = true;
+		if (i < w.transition_list_len)
+			w.dp.list[index].is_djt = true;
 	}
 
 	/*
@@ -2162,19 +2077,18 @@
 	 * keyword. Such domains are marked with '#'.
 	 */
 	for (index = 0; index < max_index; index++) {
-		const struct ccs_domain *domain = &ccs_dp.list[index];
+		const struct ccs_domain *domain = &w.dp.list[index];
 		const struct ccs_path_info *name = domain->domainname;
-		const char *last_name = ccs_get_last_word(name->name);
+		const char *last_name = get_last_word(name->name);
 		/* Ignore domain jump sources. */
 		if (domain->target)
 			continue;
 		/* Check "no_keep_domain any from $domainname" entry. */
-		for (i = 0; i < ccs_transition_control_list_len; i++) {
-			struct ccs_transition_control_entry *ptr
-				= &ccs_transition_control_list[i];
-			if (ptr->type != CCS_TRANSITION_CONTROL_NO_KEEP)
+		for (i = 0; i < w.transition_list_len; i++) {
+			struct transition_entry *ptr = &w.transition_list[i];
+			if (ptr->type != TRANSITION_NO_KEEP)
 				continue;
-			if (!ccs_is_same_namespace(name->name, ptr->ns))
+			if (!is_same_namespace(name->name, ptr->ns))
 				continue;
 			if (ptr->program)
 				continue;
@@ -2183,23 +2097,22 @@
 			    !strcmp(ptr->domainname->name, last_name))
 				break;
 		}
-		if (i < ccs_transition_control_list_len)
+		if (i < w.transition_list_len)
 			continue;
 		/* Check "keep_domain $program from $domainname" entry. */
-		for (i = 0; i < ccs_transition_control_list_len; i++) {
-			struct ccs_transition_control_entry *ptr
-				= &ccs_transition_control_list[i];
-			if (ptr->type != CCS_TRANSITION_CONTROL_KEEP)
+		for (i = 0; i < w.transition_list_len; i++) {
+			struct transition_entry *ptr = &w.transition_list[i];
+			if (ptr->type != TRANSITION_KEEP)
 				continue;
-			if (!ccs_is_same_namespace(name->name, ptr->ns))
+			if (!is_same_namespace(name->name, ptr->ns))
 				continue;
 			if (!ptr->domainname ||
 			    !ccs_pathcmp(ptr->domainname, name) ||
 			    !strcmp(ptr->domainname->name, last_name))
 				break;
 		}
-		if (i < ccs_transition_control_list_len)
-			ccs_dp.list[index].is_dk = true;
+		if (i < w.transition_list_len)
+			w.dp.list[index].is_dk = true;
 	}
 
 	/*
@@ -2209,15 +2122,15 @@
 	 */
 	for (index = 0; index < max_index; index++) {
 		char *line;
-		struct ccs_domain * const domain = &ccs_dp.list[index];
+		struct ccs_domain * const domain = &w.dp.list[index];
 		/*
 		 * Mark domain jump source as unreachable if domain jump target
 		 * does not exist. Note that such domains are not marked with
 		 * '!'.
 		 */
 		if (domain->target) {
-			if (ccs_find_domain3(domain->target->name, NULL,
-					     false) == EOF)
+			if (find_domain(domain->target->name, NULL, false) ==
+			    EOF)
 				domain->is_du = true;
 			continue;
 		}
@@ -2227,13 +2140,13 @@
 		/* Ignore if deleted domain. */
 		if (domain->is_dd)
 			continue;
-		ns = ccs_get_ns(domain->domainname->name);
+		ns = get_ns(domain->domainname->name);
 		ccs_get();
 		line = ccs_shprintf("%s", domain->domainname->name);
 		while (true) {
 			const struct ccs_domain *ptr =
-				ccs_find_domain3_by_name(line);
-			const struct ccs_transition_control_entry *d_t;
+				find_domain_by_name(line);
+			const struct transition_entry *d_t;
 			char *cp;
 			/* Stop traversal if current is domain jump target. */
 			if (ptr && ptr->is_djt)
@@ -2243,7 +2156,7 @@
 				*cp++ = '\0';
 			else
 				break;
-			d_t = ccs_transition_control(ns, line, cp);
+			d_t = find_transition(ns, line, cp);
 			if (d_t)
 				domain->d_t = d_t;
 		}
@@ -2253,22 +2166,21 @@
 	}
 
 	/* Sort by domain name. */
-	qsort(ccs_dp.list, ccs_dp.list_len, sizeof(struct ccs_domain),
-	      ccs_domainname_attribute_compare);
+	qsort(w.dp.list, w.dp.list_len, sizeof(struct ccs_domain),
+	      domain_compare);
 
 	/*
 	 * Since this screen shows domain transition tree within current
 	 * namespace, purge domains that are not in current namespace.
 	 */
-	for (index = 0; index < ccs_dp.list_len; index++) {
+	for (index = 0; index < w.dp.list_len; index++) {
 		int i;
-		if (ccs_is_current_namespace(ccs_dp.list[index].
-					     domainname->name))
+		if (is_current_namespace(w.dp.list[index].domainname->name))
 			continue;
-		free(ccs_dp.list[index].string_ptr);
-		ccs_dp.list_len--;
-		for (i = index; i < ccs_dp.list_len; i++)
-			ccs_dp.list[i] = ccs_dp.list[i + 1];
+		free(w.dp.list[index].string_ptr);
+		w.dp.list_len--;
+		for (i = index; i < w.dp.list_len; i++)
+			w.dp.list[i] = w.dp.list[i + 1];
 		index--;
 	}
 
@@ -2276,32 +2188,31 @@
 	{
 		int number = 0;
 		int index;
-		ccs_unnumbered_domain_count = 0;
-		for (index = 0; index < ccs_dp.list_len; index++) {
-			if (ccs_deleted_domain(index) ||
-			    ccs_jump_source(index)) {
-				ccs_dp.list[index].number = -1;
-				ccs_unnumbered_domain_count++;
+		w.unnumbered_domains = 0;
+		for (index = 0; index < w.dp.list_len; index++) {
+			if (is_deleted_domain(index) ||
+			    is_jump_source(index)) {
+				w.dp.list[index].number = -1;
+				w.unnumbered_domains++;
 			} else {
-				ccs_dp.list[index].number = number++;
+				w.dp.list[index].number = number++;
 			}
 		}
 	}
 
-	if (!ccs_dp.list_len)
+	if (!w.dp.list_len)
 		return;
-	ccs_dp.list_selected = ccs_realloc2(ccs_dp.list_selected,
-					    ccs_dp.list_len);
+	w.dp.list_selected = ccs_realloc2(w.dp.list_selected, w.dp.list_len);
 }
 
 /**
- * ccs_show_process_line - Print a process line.
+ * show_process_line - Print a process line.
  *
  * @index: Index in the ccs_task_list array.
  *
  * Returns length of the printed line.
  */
-static int ccs_show_process_line(const int index)
+static int show_process_line(const int index)
 {
 	char *line;
 	int tmp_col = 0;
@@ -2310,7 +2221,7 @@
 	       ccs_task_list[index].profile);
 	tmp_col += 10;
 	for (i = 0; i < ccs_task_list[index].depth - 1; i++) {
-		printw("%s", ccs_eat("    "));
+		printw("%s", shift("    "));
 		tmp_col += 4;
 	}
 	ccs_get();
@@ -2318,82 +2229,82 @@
 			    " +- " : "", ccs_task_list[index].name,
 			    ccs_task_list[index].pid,
 			    ccs_task_list[index].domain);
-	printw("%s", ccs_eat(line));
+	printw("%s", shift(line));
 	tmp_col += strlen(line);
 	ccs_put();
 	return tmp_col;
 }
 
 /**
- * ccs_show_list - Print list on the screen.
+ * show_list - Print list on the screen.
  *
  * Returns nothing.
  */
-static void ccs_show_list(void)
+static void show_list(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &screen[active];
 	int ccs_list_indent;
 	const int offset = ptr->current;
 	int i;
 	int tmp_col;
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST)
-		ccs_list_item_count = ccs_domain_sort_type ?
-			ccs_task_list_len : ccs_dp.list_len;
+	if (active == SCREEN_DOMAIN_LIST)
+		w.list_items = w.show_tasklist ?
+			ccs_task_list_len : w.dp.list_len;
 	else
-		ccs_list_item_count = ccs_gacl_list_count;
+		w.list_items = p.generic_len;
 	clear();
 	move(0, 0);
-	if (ccs_window_height < CCS_HEADER_LINES + 1) {
+	if (w.height < CCS_HEADER_LINES + 1) {
 		printw("Please enlarge window.");
 		clrtobot();
 		refresh();
 		return;
 	}
 	/* add color */
-	ccs_editpolicy_color_change(ccs_editpolicy_color_head(), true);
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
-		if (ccs_domain_sort_type) {
+	editpolicy_color_change(editpolicy_color_head(), true);
+	if (active == SCREEN_DOMAIN_LIST) {
+		if (w.show_tasklist) {
 			i = ccs_task_list_len;
 			printw("<<< Process State Viewer >>>"
 			       "      %d process%s ", i, i > 1 ? "es" : "");
-			i = ccs_count3(ccs_task_list, i);
+			i = count_tasklist();
 		} else {
-			i = ccs_list_item_count - ccs_unnumbered_domain_count;
+			i = w.list_items - w.unnumbered_domains;
 			printw("<<< Domain Transition Editor >>>"
 			       "      %d domain%c ", i, i > 1 ? 's' : ' ');
-			i = ccs_count(ccs_dp.list_selected, ccs_dp.list_len);
+			i = count_domainlist();
 		}
 	} else {
-		i = ccs_list_item_count;
-		printw("<<< %s >>>      %d entr%s ", ccs_list_caption,
-		       i, i > 1 ? "ies" : "y");
-		i = ccs_count2(ccs_gacl_list, ccs_gacl_list_count);
+		i = w.list_items;
+		printw("<<< %s >>>      %d entr%s ", w.caption, i,
+		       i > 1 ? "ies" : "y");
+		i = count_generic();
 	}
 	if (i)
 		printw("(%u selected)", i);
 	printw("   '?' for help");
 	/* add color */
-	ccs_editpolicy_color_change(ccs_editpolicy_color_head(), false);
-	ccs_eat_col = ptr->x;
-	ccs_max_col = 0;
-	if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+	editpolicy_color_change(editpolicy_color_head(), false);
+	w.eat_col = ptr->x;
+	w.max_col = 0;
+	if (active == SCREEN_ACL_LIST) {
 		char *line;
 		ccs_get();
-		line = ccs_shprintf("%s", ccs_eat(ccs_current_domain));
-		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		line = ccs_shprintf("%s", shift(w.current_domain));
+		editpolicy_attr_change(A_REVERSE, true);  /* add color */
 		move(2, 0);
 		printw("%s", line);
-		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		editpolicy_attr_change(A_REVERSE, false); /* add color */
 		ccs_put();
 	}
 	ccs_list_indent = 0;
-	switch (ccs_current_screen) {
-	case CCS_SCREEN_EXCEPTION_LIST:
-	case CCS_SCREEN_ACL_LIST:
-		for (i = 0; i < ccs_list_item_count; i++) {
-			const enum ccs_editpolicy_directives directive =
-				ccs_gacl_list[i].directive;
-			const int len = ccs_directives[directive].alias_len;
+	switch (active) {
+	case SCREEN_EXCEPTION_LIST:
+	case SCREEN_ACL_LIST:
+		for (i = 0; i < w.list_items; i++) {
+			const enum directive_type directive =
+				p.generic[i].directive;
+			const int len = directive_map[directive].alias_len;
 			if (len > ccs_list_indent)
 				ccs_list_indent = len;
 		}
@@ -2401,106 +2312,106 @@
 	default:
 		break;
 	}
-	for (i = 0; i < ccs_body_lines; i++) {
+	for (i = 0; i < w.body_lines; i++) {
 		const int index = offset + i;
-		ccs_eat_col = ptr->x;
-		if (index >= ccs_list_item_count)
+		w.eat_col = ptr->x;
+		if (index >= w.list_items)
 			break;
 		move(CCS_HEADER_LINES + i, 0);
-		switch (ccs_current_screen) {
-		case CCS_SCREEN_DOMAIN_LIST:
-			if (!ccs_domain_sort_type)
-				tmp_col = ccs_show_domain_line(index);
+		switch (active) {
+		case SCREEN_DOMAIN_LIST:
+			if (!w.show_tasklist)
+				tmp_col = show_domain_line(index);
 			else
-				tmp_col = ccs_show_process_line(index);
+				tmp_col = show_process_line(index);
 			break;
-		case CCS_SCREEN_EXCEPTION_LIST:
-		case CCS_SCREEN_ACL_LIST:
-			tmp_col = ccs_show_acl_line(index, ccs_list_indent);
+		case SCREEN_EXCEPTION_LIST:
+		case SCREEN_ACL_LIST:
+			tmp_col = show_acl_line(index, ccs_list_indent);
 			break;
-		case CCS_SCREEN_PROFILE_LIST:
-			tmp_col = ccs_show_profile_line(index);
+		case SCREEN_PROFILE_LIST:
+			tmp_col = show_profile_line(index);
 			break;
-		case CCS_SCREEN_STAT_LIST:
-			tmp_col = ccs_show_stat_line(index);
+		case SCREEN_STAT_LIST:
+			tmp_col = show_stat_line(index);
 			break;
 		default:
-			tmp_col = ccs_show_literal_line(index);
+			tmp_col = show_literal_line(index);
 			break;
 		}
 		clrtoeol();
-		tmp_col -= ccs_window_width;
-		if (tmp_col > ccs_max_col)
-			ccs_max_col = tmp_col;
+		tmp_col -= w.width;
+		if (tmp_col > w.max_col)
+			w.max_col = tmp_col;
 	}
-	ccs_show_current();
+	show_current();
 }
 
 /**
- * ccs_resize_window - Callback for resize event.
+ * resize_window - Callback for resize event.
  *
  * Returns nothing.
  */
-static void ccs_resize_window(void)
+static void resize_window(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
-	getmaxyx(stdscr, ccs_window_height, ccs_window_width);
-	ccs_body_lines = ccs_window_height - CCS_HEADER_LINES;
-	if (ccs_body_lines <= ptr->y)
-		ptr->y = ccs_body_lines - 1;
+	struct ccs_screen *ptr = &screen[active];
+	getmaxyx(stdscr, w.height, w.width);
+	w.body_lines = w.height - CCS_HEADER_LINES;
+	if (w.body_lines <= ptr->y)
+		ptr->y = w.body_lines - 1;
 	if (ptr->y < 0)
 		ptr->y = 0;
 }
 
 /**
- * ccs_up_arrow_key - Callback event for pressing up-arrow key.
+ * up_arrow_key - Callback event for pressing up-arrow key.
  *
  * Returns nothing.
  */
-static void ccs_up_arrow_key(void)
+static void up_arrow_key(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &screen[active];
 	if (ptr->y > 0) {
 		ptr->y--;
-		ccs_show_current();
+		show_current();
 	} else if (ptr->current > 0) {
 		ptr->current--;
-		ccs_show_list();
+		show_list();
 	}
 }
 
 /**
- * ccs_down_arrow_key - Callback event for pressing down-arrow key.
+ * down_arrow_key - Callback event for pressing down-arrow key.
  *
  * Returns nothing.
  */
-static void ccs_down_arrow_key(void)
+static void down_arrow_key(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
-	if (ptr->y < ccs_body_lines - 1) {
-		if (ptr->current + ptr->y < ccs_list_item_count - 1) {
+	struct ccs_screen *ptr = &screen[active];
+	if (ptr->y < w.body_lines - 1) {
+		if (ptr->current + ptr->y < w.list_items - 1) {
 			ptr->y++;
-			ccs_show_current();
+			show_current();
 		}
-	} else if (ptr->current + ptr->y < ccs_list_item_count - 1) {
+	} else if (ptr->current + ptr->y < w.list_items - 1) {
 		ptr->current++;
-		ccs_show_list();
+		show_list();
 	}
 }
 
 /**
- * ccs_page_up_key - Callback event for pressing page-up key.
+ * page_up_key - Callback event for pressing page-up key.
  *
  * Returns nothing.
  */
-static void ccs_page_up_key(void)
+static void page_up_key(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &screen[active];
 	int p0 = ptr->current;
 	int p1 = ptr->y;
 	_Bool refresh;
-	if (p0 + p1 > ccs_body_lines) {
-		p0 -= ccs_body_lines;
+	if (p0 + p1 > w.body_lines) {
+		p0 -= w.body_lines;
 		if (p0 < 0)
 			p0 = 0;
 	} else if (p0 + p1 > 0) {
@@ -2513,28 +2424,28 @@
 	ptr->current = p0;
 	ptr->y = p1;
 	if (refresh)
-		ccs_show_list();
+		show_list();
 	else
-		ccs_show_current();
+		show_current();
 }
 
 /**
- * ccs_page_down_key - Callback event for pressing page-down key.
+ * page_down_key - Callback event for pressing page-down key.
  *
  * Returns nothing.
  */
-static void ccs_page_down_key(void)
+static void page_down_key(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
-	int ccs_count = ccs_list_item_count - 1;
+	struct ccs_screen *ptr = &screen[active];
+	int count = w.list_items - 1;
 	int p0 = ptr->current;
 	int p1 = ptr->y;
 	_Bool refresh;
-	if (p0 + p1 + ccs_body_lines < ccs_count) {
-		p0 += ccs_body_lines;
-	} else if (p0 + p1 < ccs_count) {
-		while (p0 + p1 < ccs_count) {
-			if (p1 + 1 < ccs_body_lines)
+	if (p0 + p1 + w.body_lines < count) {
+		p0 += w.body_lines;
+	} else if (p0 + p1 < count) {
+		while (p0 + p1 < count) {
+			if (p1 + 1 < w.body_lines)
 				p1++;
 			else
 				p0++;
@@ -2546,99 +2457,88 @@
 	ptr->current = p0;
 	ptr->y = p1;
 	if (refresh)
-		ccs_show_list();
+		show_list();
 	else
-		ccs_show_current();
+		show_current();
 }
 
 /**
- * ccs_editpolicy_get_current - Get currently selected line's index.
+ * editpolicy_get_current - Get currently selected line's index.
  *
  * Returns index for currently selected line on success, EOF otherwise.
  *
  * If current screen has no entry, this function returns EOF.
  */
-int ccs_editpolicy_get_current(void)
+int editpolicy_get_current(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
-	int ccs_count = ccs_list_item_count;
-	const int p0 = ptr->current;
-	const int p1 = ptr->y;
-	if (!ccs_count)
+	struct ccs_screen *ptr = &screen[active];
+	if (!w.list_items)
 		return EOF;
-	if (p0 + p1 < 0 || p0 + p1 >= ccs_count) {
-		fprintf(stderr,
-			"ERROR: ccs_current_item_index=%d ccs_current_y=%d\n",
-			p0, p1);
-		exit(127);
-	}
-	return p0 + p1;
+	return ptr->current + ptr->y;
 }
 
 /**
- * ccs_show_current - Show current cursor line.
+ * show_current - Show current cursor line.
  *
  * Returns nothing.
  */
-static void ccs_show_current(void)
+static void show_current(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST &&
-	    !ccs_domain_sort_type) {
+	struct ccs_screen *ptr = &screen[active];
+	if (active == SCREEN_DOMAIN_LIST &&
+	    !w.show_tasklist) {
 		char *line;
-		const int index = ccs_editpolicy_get_current();
+		const int index = editpolicy_get_current();
 		ccs_get();
-		ccs_eat_col = ptr->x;
+		w.eat_col = ptr->x;
 		if (index >= 0) {
-			line = ccs_shprintf
-				("%s", ccs_eat(ccs_dp.list[index].
-					       domainname->name));
-			if (ccs_jump_source(index)) {
+			line = ccs_shprintf("%s", shift(w.dp.list[index].
+							domainname->name));
+			if (is_jump_source(index)) {
 				char *cp = strrchr(line, ' ');
 				if (cp)
 					*cp = '\0';
 			}
 		} else
 			line = ccs_shprintf("%s", ccs_current_ns->name);
-		if (ccs_window_width < strlen(line))
-			line[ccs_window_width] = '\0';
+		if (w.width < strlen(line))
+			line[w.width] = '\0';
 		move(2, 0);
 		clrtoeol();
-		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		editpolicy_attr_change(A_REVERSE, true);  /* add color */
 		printw("%s", line);
-		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		editpolicy_attr_change(A_REVERSE, false); /* add color */
 		ccs_put();
 	}
-	if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST ||
-	    ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
+	if (active == SCREEN_EXCEPTION_LIST || active == SCREEN_PROFILE_LIST) {
 		char *line;
 		ccs_get();
-		ccs_eat_col = ptr->x;
+		w.eat_col = ptr->x;
 		line = ccs_shprintf("%s", ccs_current_ns->name);
-		if (ccs_window_width < strlen(line))
-			line[ccs_window_width] = '\0';
+		if (w.width < strlen(line))
+			line[w.width] = '\0';
 		move(2, 0);
 		clrtoeol();
-		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		editpolicy_attr_change(A_REVERSE, true);  /* add color */
 		printw("%s", line);
-		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		editpolicy_attr_change(A_REVERSE, false); /* add color */
 		ccs_put();
 	}
 	move(CCS_HEADER_LINES + ptr->y, 0);
-	ccs_editpolicy_line_draw();     /* add color */
+	editpolicy_line_draw();     /* add color */
 	refresh();
 }
 
 /**
- * ccs_adjust_cursor_pos - Adjust cursor position if needed.
+ * adjust_cursor_pos - Adjust cursor position if needed.
  *
  * @item_count: Available item count in this screen.
  *
  * Returns nothing.
  */
-static void ccs_adjust_cursor_pos(const int item_count)
+static void adjust_cursor_pos(const int item_count)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &screen[active];
 	if (item_count == 0) {
 		ptr->current = 0;
 		ptr->y = 0;
@@ -2653,16 +2553,16 @@
 }
 
 /**
- * ccs_set_cursor_pos - Move cursor position if needed.
+ * set_cursor_pos - Move cursor position if needed.
  *
  * @index: Index in the domain policy or currently selected line in the generic
  *         list.
  *
  * Returns nothing.
  */
-static void ccs_set_cursor_pos(const int index)
+static void set_cursor_pos(const int index)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
+	struct ccs_screen *ptr = &screen[active];
 	while (index < ptr->y + ptr->current) {
 		if (ptr->y > 0)
 			ptr->y--;
@@ -2670,7 +2570,7 @@
 			ptr->current--;
 	}
 	while (index > ptr->y + ptr->current) {
-		if (ptr->y < ccs_body_lines - 1)
+		if (ptr->y < w.body_lines - 1)
 			ptr->y++;
 		else
 			ptr->current++;
@@ -2678,77 +2578,86 @@
 }
 
 /**
- * ccs_select_item - Select an item.
+ * select_item - Select an item.
  *
- * @index: Index in the domain policy or currently selected line in the generic
- *         list.
- *
  * Returns true if selected, false otherwise.
  *
  * Domain transition source and deleted domains are not selectable.
  */
-static _Bool ccs_select_item(const int index)
+static _Bool select_item(void)
 {
 	int x;
 	int y;
+	const int index = editpolicy_get_current();
 	if (index < 0)
 		return false;
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
-		if (!ccs_domain_sort_type) {
-			if (ccs_deleted_domain(index) ||
-			    ccs_jump_source(index))
+	if (active == SCREEN_DOMAIN_LIST) {
+		if (!w.show_tasklist) {
+			if (is_deleted_domain(index) || is_jump_source(index))
 				return false;
-			ccs_dp.list_selected[index] ^= 1;
+			w.dp.list_selected[index] ^= 1;
 		} else {
 			ccs_task_list[index].selected ^= 1;
 		}
 	} else {
-		ccs_gacl_list[index].selected ^= 1;
+		p.generic[index].selected ^= 1;
 	}
 	getyx(stdscr, y, x);
-	ccs_editpolicy_sttr_save();    /* add color */
-	ccs_show_list();
-	ccs_editpolicy_sttr_restore(); /* add color */
+	editpolicy_sttr_save();    /* add color */
+	show_list();
+	editpolicy_sttr_restore(); /* add color */
 	move(y, x);
 	return true;
 }
 
 /**
- * ccs_gacl_compare - strcmp() for qsort() callback.
+ * generic_compare - strcmp() for qsort() callback.
  *
  * @a: Pointer to "void".
  * @b: Pointer to "void".
  *
  * Returns return value of strcmp().
  */
-static int ccs_gacl_compare(const void *a, const void *b)
+static int generic_compare(const void *a, const void *b)
 {
-	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
-	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
-	const enum ccs_editpolicy_directives a0_d = a0->directive;
-	const enum ccs_editpolicy_directives b0_d = b0->directive;
-	const char *a1 = ccs_directives[a0_d].alias;
-	const char *b1 = ccs_directives[b0_d].alias;
+	const struct generic_entry *a0 = (struct generic_entry *) a;
+	const struct generic_entry *b0 = (struct generic_entry *) b;
+	const enum directive_type a0_d = a0->directive;
+	const enum directive_type b0_d = b0->directive;
+	const char *a1 = directive_map[a0_d].alias;
+	const char *b1 = directive_map[b0_d].alias;
 	const char *a2 = a0->operand;
 	const char *b2 = b0->operand;
-	if (a0_d == CCS_DIRECTIVE_USE_GROUP && b0_d == CCS_DIRECTIVE_USE_GROUP)
+	if (active == SCREEN_EXCEPTION_LIST) {
+		int ret;
+		if (a0_d >= DIRECTIVE_ACL_GROUP_000 &&
+		    a0_d <= DIRECTIVE_ACL_GROUP_255 &&
+		    b0_d >= DIRECTIVE_ACL_GROUP_000 &&
+		    b0_d <= DIRECTIVE_ACL_GROUP_255 && a0_d != b0_d)
+			return a0_d - b0_d;
+		ret = strcmp(a1, b1);
+		if (ret)
+			return ret;
+		return strcmp(a2, b2);
+	}
+	if (a0_d == DIRECTIVE_USE_GROUP && b0_d == DIRECTIVE_USE_GROUP)
 		return atoi(a2) - atoi(b2);
-	if (!ccs_acl_sort_type) {
+	if (!w.sort_acl) {
 		const int ret = strcmp(a1, b1);
 		if (ret)
 			return ret;
 		return strcmp(a2, b2);
-	} else if (a0_d == CCS_DIRECTIVE_USE_GROUP) {
+	} else if (a0_d == DIRECTIVE_USE_GROUP) {
 		return 1;
-	} else if (b0_d == CCS_DIRECTIVE_USE_GROUP) {
+	} else if (b0_d == DIRECTIVE_USE_GROUP) {
 		return -1;
-	} else if (a0_d == CCS_DIRECTIVE_TRANSITION_FAILED) {
+	} else if (a0_d == DIRECTIVE_TRANSITION_FAILED) {
 		return 2;
-	} else if (b0_d == CCS_DIRECTIVE_TRANSITION_FAILED) {
+	} else if (b0_d == DIRECTIVE_TRANSITION_FAILED) {
 		return -2;
-	} else if (a0_d == CCS_DIRECTIVE_QUOTA_EXCEEDED) {
+	} else if (a0_d == DIRECTIVE_QUOTA_EXCEEDED) {
 		return 3;
-	} else if (b0_d == CCS_DIRECTIVE_QUOTA_EXCEEDED) {
+	} else if (b0_d == DIRECTIVE_QUOTA_EXCEEDED) {
 		return -3;
 	} else {
 		const int ret = strcmp(a2, b2);
@@ -2759,38 +2668,35 @@
 }
 
 /**
- * ccs_delete_entry - Delete an entry.
+ * delete_entry - Delete an entry.
  *
- * @index: Index in the domain policy.
- *
  * Returns nothing.
  */
-static void ccs_delete_entry(const int index)
+static void delete_entry(void)
 {
 	int c;
 	move(1, 0);
-	ccs_editpolicy_color_change(CCS_DISP_ERR, true);	/* add color */
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
-		c = ccs_count(ccs_dp.list_selected, ccs_dp.list_len);
-		if (!c && index < ccs_dp.list_len)
-			c = ccs_select_item(index);
+	editpolicy_color_change(COLOR_DISP_ERR, true);	/* add color */
+	if (active == SCREEN_DOMAIN_LIST) {
+		c = count_domainlist();
 		if (!c)
+			c = select_item();
+		if (!c)
 			printw("Select domain using Space key first.");
 		else
 			printw("Delete selected domain%s? ('Y'es/'N'o)",
 			       c > 1 ? "s" : "");
 	} else {
-		c = ccs_count2(ccs_gacl_list,
-			       ccs_gacl_list_count);
+		c = count_generic();
 		if (!c)
-			c = ccs_select_item(index);
+			c = select_item();
 		if (!c)
 			printw("Select entry using Space key first.");
 		else
 			printw("Delete selected entr%s? ('Y'es/'N'o)",
 			       c > 1 ? "ies" : "y");
 	}
-	ccs_editpolicy_color_change(CCS_DISP_ERR, false);	/* add color */
+	editpolicy_color_change(COLOR_DISP_ERR, false);	/* add color */
 	clrtoeol();
 	refresh();
 	if (!c)
@@ -2798,109 +2704,105 @@
 	do {
 		c = ccs_getch2();
 	} while (!(c == 'Y' || c == 'y' || c == 'N' || c == 'n' || c == EOF));
-	ccs_resize_window();
+	resize_window();
 	if (c != 'Y' && c != 'y') {
-		ccs_show_list();
+		show_list();
 		return;
 	}
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+	if (active == SCREEN_DOMAIN_LIST) {
 		int i;
-		FILE *fp = ccs_editpolicy_open_write
+		FILE *fp = editpolicy_open_write
 			(CCS_PROC_POLICY_DOMAIN_POLICY);
 		if (!fp)
 			return;
-		for (i = 0; i < ccs_dp.list_len; i++) {
-			if (!ccs_dp.list_selected[i])
+		for (i = 0; i < w.dp.list_len; i++) {
+			if (!w.dp.list_selected[i])
 				continue;
 			fprintf(fp, "delete %s\n",
-				ccs_dp.list[i].domainname->name);
+				w.dp.list[i].domainname->name);
 		}
 		ccs_close_write(fp);
 	} else {
 		int i;
 		const _Bool is_kernel_ns = !strcmp(ccs_current_ns->name,
 						   "<kernel>");
-		FILE *fp = ccs_editpolicy_open_write(ccs_policy_file);
+		FILE *fp = editpolicy_open_write(w.policy_file);
 		if (!fp)
 			return;
-		if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
-			if (ccs_domain_sort_type)
-				fprintf(fp, "select pid=%u\n",
-					ccs_current_pid);
+		if (active == SCREEN_ACL_LIST) {
+			if (w.show_tasklist)
+				fprintf(fp, "select pid=%u\n", w.current_pid);
 			else
 				fprintf(fp, "select domain=%s\n",
-					ccs_current_domain);
+					w.current_domain);
 		}
-		for (i = 0; i < ccs_gacl_list_count; i++) {
-			enum ccs_editpolicy_directives directive;
-			if (!ccs_gacl_list[i].selected)
+		for (i = 0; i < p.generic_len; i++) {
+			enum directive_type directive;
+			if (!p.generic[i].selected)
 				continue;
-			directive = ccs_gacl_list[i].directive;
+			directive = p.generic[i].directive;
 			fprintf(fp, "delete %s %s %s\n",
-				ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST
+				active == SCREEN_EXCEPTION_LIST
 				&& !is_kernel_ns ? ccs_current_ns->name : "",
-				ccs_directives[directive].original,
-				ccs_gacl_list[i].operand);
+				directive_map[directive].original,
+				p.generic[i].operand);
 		}
 		ccs_close_write(fp);
 	}
 }
 
 /**
- * ccs_add_entry - Add an entry.
+ * add_entry - Add an entry.
  *
  * Returns nothing.
  */
-static void ccs_add_entry(void)
+static void add_entry(void)
 {
 	FILE *fp;
 	char *line;
 	const _Bool is_kernel_ns = !strcmp(ccs_current_ns->name, "<kernel>");
-	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
-	line = ccs_readline(ccs_window_height - 1, 0, "Enter new entry> ",
-			    ccs_rl.history, ccs_rl.count, 128000, 8);
-	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
+	line = ccs_readline(w.height - 1, 0, "Enter new entry> ", rl.history,
+			    rl.count, 128000, 8);
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	ccs_rl.count = ccs_add_history(line, ccs_rl.history, ccs_rl.count,
-				       ccs_rl.max);
-	fp = ccs_editpolicy_open_write(ccs_policy_file);
+	rl.count = ccs_add_history(line, rl.history, rl.count, rl.max);
+	fp = editpolicy_open_write(w.policy_file);
 	if (!fp)
 		goto out;
-	switch (ccs_current_screen) {
-		enum ccs_editpolicy_directives directive;
-	case CCS_SCREEN_DOMAIN_LIST:
+	switch (active) {
+		enum directive_type directive;
+	case SCREEN_DOMAIN_LIST:
 		if (!ccs_correct_domain(line)) {
 			const int len = strlen(line) + 128;
-			ccs_last_error = ccs_realloc2(ccs_last_error, len);
-			snprintf(ccs_last_error, len - 1,
+			w.last_error = ccs_realloc2(w.last_error, len);
+			snprintf(w.last_error, len - 1,
 				 "%s is an invalid domainname.", line);
 			line[0] = '\0';
 		}
 		break;
-	case CCS_SCREEN_ACL_LIST:
-		if (ccs_domain_sort_type)
-			fprintf(fp, "select pid=%u\n", ccs_current_pid);
+	case SCREEN_ACL_LIST:
+		if (w.show_tasklist)
+			fprintf(fp, "select pid=%u\n", w.current_pid);
 		else
-			fprintf(fp, "select domain=%s\n", ccs_current_domain);
+			fprintf(fp, "select domain=%s\n", w.current_domain);
 		/* Fall through. */
-	case CCS_SCREEN_EXCEPTION_LIST:
-		if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST &&
-		    !is_kernel_ns)
+	case SCREEN_EXCEPTION_LIST:
+		if (active == SCREEN_EXCEPTION_LIST && !is_kernel_ns)
 			fprintf(fp, "%s ", ccs_current_ns->name);
-		directive = ccs_find_directive(false, line);
-		if (directive != CCS_DIRECTIVE_NONE)
-			fprintf(fp, "%s ", ccs_directives[directive].original);
+		directive = find_directive(false, line);
+		if (directive != DIRECTIVE_NONE)
+			fprintf(fp, "%s ", directive_map[directive].original);
 		break;
-	case CCS_SCREEN_PROFILE_LIST:
+	case SCREEN_PROFILE_LIST:
 		if (!strchr(line, '='))
-			fprintf(fp, "%s %s-COMMENT=\n",
-				!is_kernel_ns ? ccs_current_ns->name : "",
-				line);
+			fprintf(fp, "%s %s-COMMENT=\n", !is_kernel_ns ?
+				ccs_current_ns->name : "", line);
 		if (!is_kernel_ns)
 			fprintf(fp, "%s ", ccs_current_ns->name);
 		break;
-	case CCS_SCREEN_NS_LIST:
+	case SCREEN_NS_LIST:
 		fprintf(fp, "%s PROFILE_VERSION=20100903\n", line);
 		line[0] = '\0';
 		break;
@@ -2909,93 +2811,86 @@
 	}
 	fprintf(fp, "%s\n", line);
 	ccs_close_write(fp);
-out:
+ out:
 	free(line);
 }
 
 /**
- * ccs_find_entry - Find an entry by user's key input.
+ * find_entry - Find an entry by user's key input.
  *
  * @input:   True if find next/previous, false if find first.
  * @forward: True if find next, false if find previous.
- * @current: Current position.
  *
  * Returns nothing.
  */
-static void ccs_find_entry(const _Bool input, const _Bool forward,
-			   const int current)
+static void find_entry(const _Bool input, const _Bool forward)
 {
-	int index = current;
+	int index = editpolicy_get_current();
 	char *line = NULL;
-	if (current == EOF)
+	if (index == EOF)
 		return;
 	if (!input)
 		goto start_search;
-	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
-	line = ccs_readline(ccs_window_height - 1, 0, "Search> ",
-			    ccs_rl.history, ccs_rl.count, 128000, 8);
-	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
+	line = ccs_readline(w.height - 1, 0, "Search> ", rl.history, rl.count,
+			    128000, 8);
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	ccs_rl.count = ccs_add_history(line, ccs_rl.history, ccs_rl.count,
-				       ccs_rl.max);
-	free(ccs_rl.search_buffer[ccs_current_screen]);
-	ccs_rl.search_buffer[ccs_current_screen] = line;
+	rl.count = ccs_add_history(line, rl.history, rl.count, rl.max);
+	free(rl.search_buffer[active]);
+	rl.search_buffer[active] = line;
 	line = NULL;
 	index = -1;
-start_search:
+ start_search:
 	ccs_get();
 	while (true) {
 		const char *cp;
 		if (forward) {
-			if (++index >= ccs_list_item_count)
+			if (++index >= w.list_items)
 				break;
 		} else {
 			if (--index < 0)
 				break;
 		}
-		if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
-			if (ccs_domain_sort_type)
+		if (active == SCREEN_DOMAIN_LIST) {
+			if (w.show_tasklist)
 				cp = ccs_task_list[index].name;
 			else
-				cp = ccs_get_last_name(index);
-		} else if (ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
-			cp = ccs_shprintf("%u-%s",
-					  ccs_gacl_list[index].directive,
-					  ccs_gacl_list[index].operand);
+				cp = get_last_name(index);
+		} else if (active == SCREEN_PROFILE_LIST) {
+			cp = ccs_shprintf("%u-%s", p.generic[index].directive,
+					  p.generic[index].operand);
 		} else {
-			const enum ccs_editpolicy_directives directive =
-				ccs_gacl_list[index].directive;
+			const enum directive_type directive =
+				p.generic[index].directive;
 			cp = ccs_shprintf("%s %s",
-					  ccs_directives[directive].alias,
-					  ccs_gacl_list[index].operand);
+					  directive_map[directive].alias,
+					  p.generic[index].operand);
 		}
-		if (!strstr(cp, ccs_rl.search_buffer[ccs_current_screen]))
+		if (!strstr(cp, rl.search_buffer[active]))
 			continue;
-		ccs_set_cursor_pos(index);
+		set_cursor_pos(index);
 		break;
 	}
 	ccs_put();
-out:
+ out:
 	free(line);
-	ccs_show_list();
+	show_list();
 }
 
 /**
- * ccs_set_profile - Change profile number.
+ * set_profile - Change profile number.
  *
- * @current: Currently selected line in the generic list.
- *
  * Returns nothing.
  */
-static void ccs_set_profile(const int current)
+static void set_profile(void)
 {
 	int index;
 	FILE *fp;
 	char *line;
-	if (!ccs_domain_sort_type) {
-		if (!ccs_count(ccs_dp.list_selected, ccs_dp.list_len) &&
-		    !ccs_select_item(current)) {
+	if (!w.show_tasklist) {
+		if (!count_domainlist() && !select_item()) {
 			move(1, 0);
 			printw("Select domain using Space key first.");
 			clrtoeol();
@@ -3003,8 +2898,7 @@
 			return;
 		}
 	} else {
-		if (!ccs_count3(ccs_task_list, ccs_task_list_len) &&
-		    !ccs_select_item(current)) {
+		if (!count_tasklist() && !select_item()) {
 			move(1, 0);
 			printw("Select processes using Space key first.");
 			clrtoeol();
@@ -3012,82 +2906,80 @@
 			return;
 		}
 	}
-	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
-	line = ccs_readline(ccs_window_height - 1, 0, "Enter profile number> ",
-			    NULL, 0, 8, 1);
-	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
+	line = ccs_readline(w.height - 1, 0, "Enter profile number> ", NULL, 0,
+			    8, 1);
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
+	fp = editpolicy_open_write(CCS_PROC_POLICY_DOMAIN_POLICY);
 	if (!fp)
 		goto out;
-	if (!ccs_domain_sort_type) {
-		for (index = 0; index < ccs_dp.list_len; index++) {
-			if (!ccs_dp.list_selected[index])
+	if (!w.show_tasklist) {
+		for (index = 0; index < w.dp.list_len; index++) {
+			if (!w.dp.list_selected[index])
 				continue;
-			fprintf(fp, "select domain=%s\n" "use_profile %s\n",
-				ccs_dp.list[index].domainname->name, line);
+			fprintf(fp, "select domain=%s\nuse_profile %s\n",
+				w.dp.list[index].domainname->name, line);
 		}
 	} else {
 		for (index = 0; index < ccs_task_list_len; index++) {
 			if (!ccs_task_list[index].selected)
 				continue;
-			fprintf(fp, "select pid=%u\n" "use_profile %s\n",
+			fprintf(fp, "select pid=%u\nuse_profile %s\n",
 				ccs_task_list[index].pid, line);
 		}
 	}
 	ccs_close_write(fp);
-out:
+ out:
 	free(line);
 }
 
 /**
- * ccs_set_level - Change profiles.
+ * set_level - Change profiles.
  *
- * @current: Currently selected line in the generic list.
- *
  * Returns nothing.
  */
-static void ccs_set_level(const int current)
+static void set_level(void)
 {
 	int index;
 	FILE *fp;
 	char *line;
-	if (!ccs_count2(ccs_gacl_list, ccs_gacl_list_count))
-		ccs_select_item(current);
-	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	if (!count_generic())
+		select_item();
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
 	ccs_initial_readline_data = NULL;
-	for (index = 0; index < ccs_gacl_list_count; index++) {
+	for (index = 0; index < p.generic_len; index++) {
 		char *cp;
-		if (!ccs_gacl_list[index].selected)
+		if (!p.generic[index].selected)
 			continue;
-		cp = strchr(ccs_gacl_list[index].operand, '=');
+		cp = strchr(p.generic[index].operand, '=');
 		if (!cp)
 			continue;
 		ccs_initial_readline_data = cp + 1;
 		break;
 	}
-	line = ccs_readline(ccs_window_height - 1, 0, "Enter new value> ",
-			    NULL, 0, 128000, 1);
+	line = ccs_readline(w.height - 1, 0, "Enter new value> ", NULL, 0,
+			    128000, 1);
 	ccs_initial_readline_data = NULL;
-	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_PROFILE);
+	fp = editpolicy_open_write(CCS_PROC_POLICY_PROFILE);
 	if (!fp)
 		goto out;
-	for (index = 0; index < ccs_gacl_list_count; index++) {
+	for (index = 0; index < p.generic_len; index++) {
 		char *buf;
 		char *cp;
-		enum ccs_editpolicy_directives directive;
-		if (!ccs_gacl_list[index].selected)
+		enum directive_type directive;
+		if (!p.generic[index].selected)
 			continue;
 		ccs_get();
-		buf = ccs_shprintf("%s", ccs_gacl_list[index].operand);
+		buf = ccs_shprintf("%s", p.generic[index].operand);
 		cp = strchr(buf, '=');
 		if (cp)
 			*cp = '\0';
-		directive = ccs_gacl_list[index].directive;
+		directive = p.generic[index].directive;
 		fprintf(fp, "%s ", ccs_current_ns->name);
 		if (directive < 256)
 			fprintf(fp, "%u-", directive);
@@ -3095,40 +2987,38 @@
 		ccs_put();
 	}
 	ccs_close_write(fp);
-out:
+ out:
 	free(line);
 }
 
 /**
- * ccs_set_quota - Set memory quota.
+ * set_quota - Set memory quota.
  *
- * @current: Currently selected line in the generic list.
- *
  * Returns nothing.
  */
-static void ccs_set_quota(const int current)
+static void set_quota(void)
 {
 	int index;
 	FILE *fp;
 	char *line;
-	if (!ccs_count2(ccs_gacl_list, ccs_gacl_list_count))
-		ccs_select_item(current);
-	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
-	line = ccs_readline(ccs_window_height - 1, 0, "Enter new value> ",
-			    NULL, 0, 20, 1);
-	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
+	if (!count_generic())
+		select_item();
+	editpolicy_attr_change(A_BOLD, true);  /* add color */
+	line = ccs_readline(w.height - 1, 0, "Enter new value> ", NULL, 0, 20,
+			    1);
+	editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = ccs_editpolicy_open_write(CCS_PROC_POLICY_STAT);
+	fp = editpolicy_open_write(CCS_PROC_POLICY_STAT);
 	if (!fp)
 		goto out;
-	for (index = 0; index < ccs_gacl_list_count; index++) {
+	for (index = 0; index < p.generic_len; index++) {
 		char *buf;
 		char *cp;
-		if (!ccs_gacl_list[index].selected)
+		if (!p.generic[index].selected)
 			continue;
 		ccs_get();
-		buf = ccs_shprintf("%s", ccs_gacl_list[index].operand);
+		buf = ccs_shprintf("%s", p.generic[index].operand);
 		cp = strchr(buf, ':');
 		if (cp)
 			*cp = '\0';
@@ -3136,102 +3026,99 @@
 		ccs_put();
 	}
 	ccs_close_write(fp);
-out:
+ out:
 	free(line);
 }
 
 /**
- * ccs_select_ns_window - Check whether to switch to ACL list or not.
+ * select_ns_window - Check whether to switch to ACL list or not.
  *
- * @current: Index in the namespace list.
- *
- * Returns next window to display if valid, CCS_MAXSCREEN otherwise.
+ * Returns next window to display if valid, MAX_SCREEN_TYPE otherwise.
  */
-static enum ccs_screen_type ccs_select_ns_window(const int current)
+static enum screen_type select_ns_window(void)
 {
+	const int current = editpolicy_get_current();
 	if (current != EOF) {
-		const char *namespace = ccs_gacl_list[current].operand;
-		enum ccs_screen_type next = ccs_previous_screen;
-		if (next == CCS_SCREEN_ACL_LIST &&
+		const char *namespace = p.generic[current].operand;
+		enum screen_type next = w.previous_screen;
+		if (next == SCREEN_ACL_LIST &&
 		    strcmp(ccs_current_ns->name, namespace))
-			next = CCS_SCREEN_DOMAIN_LIST;
+			next = SCREEN_DOMAIN_LIST;
 		ccs_current_ns = ccs_savename(namespace);
 		return next;
 	}
-	return CCS_MAXSCREEN;
+	return MAX_SCREEN_TYPE;
 }
 
 /**
- * ccs_select_acl_window - Check whether to switch to ACL list or not.
+ * select_acl_window - Check whether to switch to ACL list or not.
  *
- * @current: Index in the domain policy.
- *
- * Returns next window to display if valid, CCS_MAXSCREEN otherwise.
+ * Returns next window to display if valid, MAX_SCREEN_TYPE otherwise.
  */
-static enum ccs_screen_type ccs_select_acl_window(const int current)
+static enum screen_type select_acl_window(void)
 {
+	const int current = editpolicy_get_current();
 	char *old_domain;
-	if (ccs_current_screen != CCS_SCREEN_DOMAIN_LIST || current == EOF)
-		return CCS_MAXSCREEN;
-	ccs_current_pid = 0;
-	if (ccs_domain_sort_type) {
-		ccs_current_pid = ccs_task_list[current].pid;
-	} else if (ccs_jump_source(current)) {
-		struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
-		const int redirect_index = ccs_find_target_domain(current);
+	if (active != SCREEN_DOMAIN_LIST || current == EOF)
+		return MAX_SCREEN_TYPE;
+	w.current_pid = 0;
+	if (w.show_tasklist) {
+		w.current_pid = ccs_task_list[current].pid;
+	} else if (is_jump_source(current)) {
+		struct ccs_screen *ptr = &screen[active];
+		const int redirect_index = find_target_domain(current);
 		if (redirect_index >= 0) {
 			ptr->current = redirect_index - ptr->y;
 			while (ptr->current < 0) {
 				ptr->current++;
 				ptr->y--;
 			}
-			ccs_show_list();
+			show_list();
 		}
 		if (redirect_index == -2) {
 			const char *domainname =
-				ccs_dp.list[current].target->name;
-			ccs_current_ns = ccs_get_ns(domainname);
-			free(ccs_current_domain);
-			ccs_current_domain = ccs_strdup(domainname);
-			ccs_force_move_cursor = true;
-			return CCS_SCREEN_DOMAIN_LIST;
+				w.dp.list[current].target->name;
+			ccs_current_ns = get_ns(domainname);
+			free(w.current_domain);
+			w.current_domain = ccs_strdup(domainname);
+			w.force_move_cursor = true;
+			return SCREEN_DOMAIN_LIST;
 		}
-		return CCS_MAXSCREEN;
-	} else if (ccs_deleted_domain(current)) {
-		return CCS_MAXSCREEN;
+		return MAX_SCREEN_TYPE;
+	} else if (is_deleted_domain(current)) {
+		return MAX_SCREEN_TYPE;
 	}
-	old_domain = ccs_current_domain;
-	if (ccs_domain_sort_type)
-		ccs_current_domain = ccs_strdup(ccs_task_list[current].domain);
+	old_domain = w.current_domain;
+	if (w.show_tasklist)
+		w.current_domain = ccs_strdup(ccs_task_list[current].domain);
 	else
-		ccs_current_domain = ccs_strdup(ccs_dp.list[current].
-						domainname->name);
-	ccs_no_restore_cursor = old_domain &&
-		strcmp(old_domain, ccs_current_domain);
+		w.current_domain = ccs_strdup(w.dp.list[current].
+					      domainname->name);
+	w.no_restore_cursor = old_domain &&
+		strcmp(old_domain, w.current_domain);
 	free(old_domain);
-	return CCS_SCREEN_ACL_LIST;
+	return SCREEN_ACL_LIST;
 }
 
 /**
- * ccs_select_window - Switch window.
+ * select_window - Switch window.
  *
- * @current: Index in the domain policy.
- *
  * Returns next window to display.
  */
-static enum ccs_screen_type ccs_select_window(const int current)
+static enum screen_type select_window(void)
 {
+	const int current = editpolicy_get_current();
 	move(0, 0);
 	printw("Press one of below keys to switch window.\n\n");
 	printw("e     <<< Exception Policy Editor >>>\n");
 	printw("d     <<< Domain Transition Editor >>>\n");
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST && current != EOF &&
-	    !ccs_jump_source(current) && !ccs_deleted_domain(current))
+	if (active == SCREEN_DOMAIN_LIST && current != EOF &&
+	    !is_jump_source(current) && !is_deleted_domain(current))
 		printw("a     <<< Domain Policy Editor >>>\n");
 	printw("p     <<< Profile Editor >>>\n");
 	printw("m     <<< Manager Policy Editor >>>\n");
 	printw("n     <<< Namespace Selector >>>\n");
-	if (!ccs_offline_mode) {
+	if (!w.offline_mode) {
 		/* printw("i     <<< Interactive Enforcing Mode >>>\n"); */
 		printw("s     <<< Statistics >>>\n");
 	}
@@ -3239,109 +3126,105 @@
 	clrtobot();
 	refresh();
 	while (true) {
-		enum ccs_screen_type next;
+		enum screen_type next;
 		int c = ccs_getch2();
 		switch (c) {
 		case 'E':
 		case 'e':
-			return CCS_SCREEN_EXCEPTION_LIST;
+			return SCREEN_EXCEPTION_LIST;
 		case 'D':
 		case 'd':
-			return CCS_SCREEN_DOMAIN_LIST;
+			return SCREEN_DOMAIN_LIST;
 		case 'A':
 		case 'a':
-			next = ccs_select_acl_window(current);
-			if (next == CCS_MAXSCREEN)
+			next = select_acl_window();
+			if (next == MAX_SCREEN_TYPE)
 				break;
 			return next;
 		case 'P':
 		case 'p':
-			return CCS_SCREEN_PROFILE_LIST;
+			return SCREEN_PROFILE_LIST;
 		case 'M':
 		case 'm':
-			return CCS_SCREEN_MANAGER_LIST;
+			return SCREEN_MANAGER_LIST;
 		case 'N':
 		case 'n':
-			return CCS_SCREEN_NS_LIST;
-		case '\t':
-			return ccs_previous_screen;
+			return SCREEN_NS_LIST;
 			/*
 		case 'I':
 		case 'i':
-			if (ccs_offline_mode)
+			if (w.offline_mode)
 				break;
-			return CCS_SCREEN_QUERY_LIST;
+			return SCREEN_QUERY_LIST;
 			*/
 		case 'S':
 		case 's':
-			if (ccs_offline_mode)
+			if (w.offline_mode)
 				break;
-			return CCS_SCREEN_STAT_LIST;
+			return SCREEN_STAT_LIST;
 		case 'Q':
 		case 'q':
 		case EOF:
-			return CCS_MAXSCREEN;
+			return MAX_SCREEN_TYPE;
 		}
 	}
 }
 
 /**
- * ccs_copy_mark_state - Copy selected state to lines under the current line.
+ * copy_mark_state - Copy selected state to lines under the current line.
  *
- * @current: Index in the domain policy.
- *
  * Returns nothing.
  */
-static void ccs_copy_mark_state(const int current)
+static void copy_mark_state(void)
 {
+	const int current = editpolicy_get_current();
 	int index;
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
-		if (ccs_domain_sort_type) {
+	if (current == EOF)
+		return;
+	if (active == SCREEN_DOMAIN_LIST) {
+		if (w.show_tasklist) {
 			const u8 selected = ccs_task_list[current].selected;
 			for (index = current; index < ccs_task_list_len;
 			     index++)
 				ccs_task_list[index].selected = selected;
 		} else {
-			const u8 selected = ccs_dp.list_selected[current];
-			if (ccs_deleted_domain(current) ||
-			    ccs_jump_source(current))
+			const u8 selected = w.dp.list_selected[current];
+			if (is_deleted_domain(current) ||
+			    is_jump_source(current))
 				return;
-			for (index = current; index < ccs_dp.list_len;
+			for (index = current; index < w.dp.list_len;
 			     index++) {
-				if (ccs_deleted_domain(index) ||
-				    ccs_jump_source(index))
+				if (is_deleted_domain(index) ||
+				    is_jump_source(index))
 					continue;
-				ccs_dp.list_selected[index] = selected;
+				w.dp.list_selected[index] = selected;
 			}
 		}
 	} else {
-		const u8 selected = ccs_gacl_list[current].selected;
-		for (index = current; index < ccs_gacl_list_count;
-		     index++)
-			ccs_gacl_list[index].selected = selected;
+		const _Bool selected = p.generic[current].selected;
+		for (index = current; index < p.generic_len; index++)
+			p.generic[index].selected = selected;
 	}
-	ccs_show_list();
+	show_list();
 }
 
 /**
- * ccs_copy_to_history - Copy line to histoy buffer.
+ * copy_to_history - Copy line to histoy buffer.
  *
- * @current: Index in the domain policy.
- *
  * Returns nothing.
  */
-static void ccs_copy_to_history(const int current)
+static void copy_to_history(void)
 {
+	const int current = editpolicy_get_current();
 	const char *line;
 	if (current == EOF)
 		return;
 	ccs_get();
-	switch (ccs_current_screen) {
-		enum ccs_editpolicy_directives directive;
-	case CCS_SCREEN_DOMAIN_LIST:
-		if (!ccs_domain_sort_type) {
-			const struct ccs_domain *domain =
-				&ccs_dp.list[current];
+	switch (active) {
+		enum directive_type directive;
+	case SCREEN_DOMAIN_LIST:
+		if (!w.show_tasklist) {
+			const struct ccs_domain *domain = &w.dp.list[current];
 			if (domain->target)
 				line = domain->target->name;
 			else
@@ -3349,80 +3232,78 @@
 		} else
 			line = ccs_task_list[current].domain;
 		break;
-	case CCS_SCREEN_EXCEPTION_LIST:
-	case CCS_SCREEN_ACL_LIST:
-		directive = ccs_gacl_list[current].directive;
-		line = ccs_shprintf("%s %s", ccs_directives[directive].alias,
-				ccs_gacl_list[current].operand);
+	case SCREEN_EXCEPTION_LIST:
+	case SCREEN_ACL_LIST:
+		directive = p.generic[current].directive;
+		line = ccs_shprintf("%s %s", directive_map[directive].alias,
+				    p.generic[current].operand);
 		break;
-	case CCS_SCREEN_STAT_LIST:
+	case SCREEN_STAT_LIST:
 		line = NULL;
 		break;
 	default:
-		line = ccs_shprintf("%s",
-				    ccs_gacl_list[current].operand);
+		line = ccs_shprintf("%s", p.generic[current].operand);
 	}
-	ccs_rl.count = ccs_add_history(line, ccs_rl.history, ccs_rl.count,
-				       ccs_rl.max);
+	rl.count = ccs_add_history(line, rl.history, rl.count, rl.max);
 	ccs_put();
 }
 
 /**
- * ccs_generic_list_loop - Main loop.
+ * generic_list_loop - Main loop.
  *
  * Returns next screen to display.
  */
-static enum ccs_screen_type ccs_generic_list_loop(void)
+static enum screen_type generic_list_loop(void)
 {
 	struct ccs_screen *ptr;
 	static struct {
 		int y;
 		int current;
-	} saved_cursor[CCS_MAXSCREEN] = { };
-	if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_EXCEPTION_POLICY;
-		ccs_list_caption = "Exception Policy Editor";
-	} else if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
-		ccs_list_caption = "Domain Policy Editor";
+	} saved_cursor[MAX_SCREEN_TYPE] = { };
+	if (active == SCREEN_EXCEPTION_LIST) {
+		w.policy_file = CCS_PROC_POLICY_EXCEPTION_POLICY;
+		w.caption = "Exception Policy Editor";
+	} else if (active == SCREEN_ACL_LIST) {
+		w.policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
+		w.caption = "Domain Policy Editor";
 		/*
-	} else if (ccs_current_screen == CCS_SCREEN_QUERY_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_QUERY;
-		ccs_list_caption = "Interactive Enforcing Mode";
+		  } else if (active == SCREEN_QUERY_LIST) {
+		  w.policy_file = CCS_PROC_POLICY_QUERY;
+		  w.caption = "Interactive Enforcing Mode";
 		*/
-	} else if (ccs_current_screen == CCS_SCREEN_NS_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_PROFILE;
-		ccs_list_caption = "Namespace Selector";
-	} else if (ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_PROFILE;
-		ccs_list_caption = "Profile Editor";
-	} else if (ccs_current_screen == CCS_SCREEN_MANAGER_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_MANAGER;
-		ccs_list_caption = "Manager Policy Editor";
-	} else if (ccs_current_screen == CCS_SCREEN_STAT_LIST) {
-		ccs_policy_file = CCS_PROC_POLICY_STAT;
-		ccs_list_caption = "Statistics";
+	} else if (active == SCREEN_NS_LIST) {
+		w.policy_file = CCS_PROC_POLICY_PROFILE;
+		w.caption = "Namespace Selector";
+	} else if (active == SCREEN_PROFILE_LIST) {
+		w.policy_file = CCS_PROC_POLICY_PROFILE;
+		w.caption = "Profile Editor";
+	} else if (active == SCREEN_MANAGER_LIST) {
+		w.policy_file = CCS_PROC_POLICY_MANAGER;
+		w.caption = "Manager Policy Editor";
+	} else if (active == SCREEN_STAT_LIST) {
+		w.policy_file = CCS_PROC_POLICY_STAT;
+		w.caption = "Statistics";
 	} else {
-		ccs_policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
-		/* ccs_list_caption = "Domain Transition Editor"; */
+		w.policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
+		/* w.caption = "Domain Transition Editor"; */
 	}
-	ptr = &ccs_screen[ccs_current_screen];
-	if (ccs_no_restore_cursor || ccs_force_move_cursor) {
+	ptr = &screen[active];
+	if (w.no_restore_cursor || w.force_move_cursor) {
 		ptr->current = 0;
 		ptr->y = 0;
-		ccs_no_restore_cursor = false;
+		w.no_restore_cursor = false;
 	} else {
-		ptr->current = saved_cursor[ccs_current_screen].current;
-		ptr->y = saved_cursor[ccs_current_screen].y;
+		ptr->current = saved_cursor[active].current;
+		ptr->y = saved_cursor[active].y;
 	}
-start:
-	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
-		if (!ccs_domain_sort_type) {
-			ccs_read_domain_and_exception_policy();
-			if (ccs_force_move_cursor) {
+ start:
+	if (active == SCREEN_DOMAIN_LIST) {
+		if (!w.show_tasklist) {
+			read_domain_and_exception_policy();
+			if (w.force_move_cursor) {
 				const int redirect_index =
-					ccs_find_domain3(ccs_current_domain,
-							 NULL, false);
+					find_domain(w.current_domain, NULL,
+						    false);
 				if (redirect_index >= 0) {
 					ptr->current = redirect_index - ptr->y;
 					while (ptr->current < 0) {
@@ -3430,108 +3311,104 @@
 						ptr->y--;
 					}
 				}
-				ccs_force_move_cursor = false;
+				w.force_move_cursor = false;
 			}
-			ccs_adjust_cursor_pos(ccs_dp.list_len);
+			adjust_cursor_pos(w.dp.list_len);
 		} else {
 			ccs_read_process_list(true);
-			ccs_adjust_cursor_pos(ccs_task_list_len);
+			adjust_cursor_pos(ccs_task_list_len);
 		}
 	} else {
-		ccs_read_generic_policy();
-		ccs_adjust_cursor_pos(ccs_gacl_list_count);
+		read_generic_policy();
+		adjust_cursor_pos(p.generic_len);
 	}
-start2:
-	ccs_show_list();
-	if (ccs_last_error) {
+ start2:
+	show_list();
+	if (w.last_error) {
 		move(1, 0);
-		printw("ERROR: %s", ccs_last_error);
+		printw("ERROR: %s", w.last_error);
 		clrtoeol();
 		refresh();
-		free(ccs_last_error);
-		ccs_last_error = NULL;
+		free(w.last_error);
+		w.last_error = NULL;
 	}
 	while (true) {
-		const int current = ccs_editpolicy_get_current();
 		const int c = ccs_getch2();
-		enum ccs_screen_type next;
-		saved_cursor[ccs_current_screen].current = ptr->current;
-		saved_cursor[ccs_current_screen].y = ptr->y;
+		enum screen_type next;
+		saved_cursor[active].current = ptr->current;
+		saved_cursor[active].y = ptr->y;
 		if (c == 'q' || c == 'Q')
-			return CCS_MAXSCREEN;
+			return MAX_SCREEN_TYPE;
 		if ((c == '\r' || c == '\n') &&
-		    ccs_current_screen == CCS_SCREEN_ACL_LIST)
-			return CCS_SCREEN_DOMAIN_LIST;
+		    active == SCREEN_ACL_LIST)
+			return SCREEN_DOMAIN_LIST;
 		if (c == '\t')
-			return ccs_previous_screen;
-		if (ccs_need_reload) {
-			ccs_need_reload = false;
+			return w.previous_screen;
+		if (w.need_reload) {
+			w.need_reload = false;
 			goto start;
 		}
 		if (c == ERR)
 			continue; /* Ignore invalid key. */
 		switch (c) {
 		case KEY_RESIZE:
-			ccs_resize_window();
-			ccs_show_list();
+			resize_window();
+			show_list();
 			break;
 		case KEY_UP:
-			ccs_up_arrow_key();
+			up_arrow_key();
 			break;
 		case KEY_DOWN:
-			ccs_down_arrow_key();
+			down_arrow_key();
 			break;
 		case KEY_PPAGE:
-			ccs_page_up_key();
+			page_up_key();
 			break;
 		case KEY_NPAGE:
-			ccs_page_down_key();
+			page_down_key();
 			break;
 		case ' ':
-			ccs_select_item(current);
+			select_item();
 			break;
 		case 'c':
 		case 'C':
-			if (current == EOF)
-				break;
-			ccs_copy_mark_state(current);
-			ccs_show_list();
+			copy_mark_state();
 			break;
 		case 'f':
 		case 'F':
-			if (ccs_current_screen != CCS_SCREEN_STAT_LIST)
-				ccs_find_entry(true, true, current);
+			if (active != SCREEN_STAT_LIST)
+				find_entry(true, true);
 			break;
 		case 'p':
 		case 'P':
-			if (ccs_current_screen == CCS_SCREEN_STAT_LIST)
+			if (active == SCREEN_STAT_LIST)
 				break;
-			if (!ccs_rl.search_buffer[ccs_current_screen])
-				ccs_find_entry(true, false, current);
+			if (!rl.search_buffer[active])
+				find_entry(true, false);
 			else
-				ccs_find_entry(false, false, current);
+				find_entry(false, false);
 			break;
 		case 'n':
 		case 'N':
-			if (ccs_current_screen == CCS_SCREEN_STAT_LIST)
+			if (active == SCREEN_STAT_LIST)
 				break;
-			if (!ccs_rl.search_buffer[ccs_current_screen])
-				ccs_find_entry(true, true, current);
+			if (!rl.search_buffer[active])
+				find_entry(true, true);
 			else
-				ccs_find_entry(false, true, current);
+				find_entry(false, true);
 			break;
 		case 'd':
 		case 'D':
-			if (ccs_readonly_mode)
+			if (w.readonly_mode)
 				break;
-			switch (ccs_current_screen) {
-			case CCS_SCREEN_DOMAIN_LIST:
-				if (ccs_domain_sort_type)
+			switch (active) {
+			case SCREEN_DOMAIN_LIST:
+				if (w.show_tasklist)
 					break;
-			case CCS_SCREEN_EXCEPTION_LIST:
-			case CCS_SCREEN_ACL_LIST:
-			case CCS_SCREEN_MANAGER_LIST:
-				ccs_delete_entry(current);
+			case SCREEN_EXCEPTION_LIST:
+			case SCREEN_ACL_LIST:
+			case SCREEN_MANAGER_LIST:
+				delete_entry();
 				goto start;
 			default:
 				break;
@@ -3539,18 +3416,18 @@
 			break;
 		case 'a':
 		case 'A':
-			if (ccs_readonly_mode)
+			if (w.readonly_mode)
 				break;
-			switch (ccs_current_screen) {
-			case CCS_SCREEN_DOMAIN_LIST:
-				if (ccs_domain_sort_type)
+			switch (active) {
+			case SCREEN_DOMAIN_LIST:
+				if (w.show_tasklist)
 					break;
-			case CCS_SCREEN_EXCEPTION_LIST:
-			case CCS_SCREEN_ACL_LIST:
-			case CCS_SCREEN_PROFILE_LIST:
-			case CCS_SCREEN_MANAGER_LIST:
-			case CCS_SCREEN_NS_LIST:
-				ccs_add_entry();
+			case SCREEN_EXCEPTION_LIST:
+			case SCREEN_ACL_LIST:
+			case SCREEN_PROFILE_LIST:
+			case SCREEN_MANAGER_LIST:
+			case SCREEN_NS_LIST:
+				add_entry();
 				goto start;
 			default:
 				break;
@@ -3558,26 +3435,26 @@
 			break;
 		case '\r':
 		case '\n':
-			if (ccs_current_screen == CCS_SCREEN_NS_LIST)
-				next = ccs_select_ns_window(current);
+			if (active == SCREEN_NS_LIST)
+				next = select_ns_window();
 			else
-				next = ccs_select_acl_window(current);
-			if (next == CCS_MAXSCREEN)
+				next = select_acl_window();
+			if (next == MAX_SCREEN_TYPE)
 				break;
 			return next;
 		case 's':
 		case 'S':
-			if (ccs_readonly_mode)
+			if (w.readonly_mode)
 				break;
-			switch (ccs_current_screen) {
-			case CCS_SCREEN_DOMAIN_LIST:
-				ccs_set_profile(current);
+			switch (active) {
+			case SCREEN_DOMAIN_LIST:
+				set_profile();
 				goto start;
-			case CCS_SCREEN_PROFILE_LIST:
-				ccs_set_level(current);
+			case SCREEN_PROFILE_LIST:
+				set_level();
 				goto start;
-			case CCS_SCREEN_STAT_LIST:
-				ccs_set_quota(current);
+			case SCREEN_STAT_LIST:
+				set_quota();
 				goto start;
 			default:
 				break;
@@ -3598,31 +3475,31 @@
 			ptr->x = 0;
 			goto start2;
 		case KEY_END:
-			ptr->x = ccs_max_col;
+			ptr->x = w.max_col;
 			goto start2;
 		case KEY_IC:
-			ccs_copy_to_history(current);
+			copy_to_history();
 			break;
 		case 'o':
 		case 'O':
-			if (ccs_current_screen == CCS_SCREEN_ACL_LIST ||
-			    ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST) {
-				ccs_editpolicy_optimize(current);
-				ccs_show_list();
+			if (active == SCREEN_ACL_LIST ||
+			    active == SCREEN_EXCEPTION_LIST) {
+				editpolicy_optimize();
+				show_list();
 			}
 			break;
 		case '@':
-			switch (ccs_current_screen) {
-			case CCS_SCREEN_ACL_LIST:
-				ccs_acl_sort_type = !ccs_acl_sort_type;
+			switch (active) {
+			case SCREEN_ACL_LIST:
+				w.sort_acl = !w.sort_acl;
 				goto start;
-			case CCS_SCREEN_PROFILE_LIST:
-				ccs_profile_sort_type = !ccs_profile_sort_type;
+			case SCREEN_PROFILE_LIST:
+				w.sort_profile = !w.sort_profile;
 				goto start;
-			case CCS_SCREEN_DOMAIN_LIST:
-				if (ccs_offline_mode)
+			case SCREEN_DOMAIN_LIST:
+				if (w.offline_mode)
 					break;
-				ccs_domain_sort_type = !ccs_domain_sort_type;
+				w.show_tasklist = !w.show_tasklist;
 				goto start;
 			default:
 				break;
@@ -3630,12 +3507,11 @@
 			break;
 		case 'w':
 		case 'W':
-			return ccs_select_window(current);
+			return select_window();
 		case '?':
-			if (ccs_show_command_key(ccs_current_screen,
-						 ccs_readonly_mode))
+			if (show_command_key(active, w.readonly_mode))
 				goto start;
-			return CCS_MAXSCREEN;
+			return MAX_SCREEN_TYPE;
 		}
 	}
 }
@@ -3643,14 +3519,14 @@
 /**
  * ccs_save_to_file - Save policy to file.
  *
- * @src: Filename to read from.
+ * @src:  Filename to read from.
  * @dest: Filename to write to.
  *
  * Returns true on success, false otherwise.
  */
 static _Bool ccs_save_to_file(const char *src, const char *dest)
 {
-	FILE *proc_fp = ccs_editpolicy_open_read(src);
+	FILE *proc_fp = editpolicy_open_read(src);
 	FILE *file_fp = fopen(dest, "w");
 	int c;
 	if (!file_fp || !proc_fp) {
@@ -3690,10 +3566,10 @@
 		char *ptr = argv[i];
 		char *cp = strchr(ptr, ':');
 		if (*ptr == '/') {
-			if (ccs_network_mode || ccs_offline_mode)
+			if (ccs_network_mode || w.offline_mode)
 				goto usage;
-			ccs_policy_dir = ptr;
-			ccs_offline_mode = true;
+			w.policy_dir = ptr;
+			w.offline_mode = true;
 		} else if (*ptr == '<') {
 			if (ccs_current_ns || strchr(ptr, ' ') ||
 			    !ccs_domain_def(ptr))
@@ -3701,7 +3577,7 @@
 			ccs_current_ns = ccs_savename(ptr);
 		} else if (cp) {
 			*cp++ = '\0';
-			if (ccs_network_mode || ccs_offline_mode)
+			if (ccs_network_mode || w.offline_mode)
 				goto usage;
 			ccs_network_ip = inet_addr(ptr);
 			ccs_network_port = htons(atoi(cp));
@@ -3709,32 +3585,31 @@
 			if (!ccs_check_remote_host())
 				exit(1);
 		} else if (!strcmp(ptr, "e"))
-			ccs_current_screen = CCS_SCREEN_EXCEPTION_LIST;
+			active = SCREEN_EXCEPTION_LIST;
 		else if (!strcmp(ptr, "d"))
-			ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
+			active = SCREEN_DOMAIN_LIST;
 		else if (!strcmp(ptr, "p"))
-			ccs_current_screen = CCS_SCREEN_PROFILE_LIST;
+			active = SCREEN_PROFILE_LIST;
 		else if (!strcmp(ptr, "m"))
-			ccs_current_screen = CCS_SCREEN_MANAGER_LIST;
+			active = SCREEN_MANAGER_LIST;
 		else if (!strcmp(ptr, "s"))
-			ccs_current_screen = CCS_SCREEN_STAT_LIST;
+			active = SCREEN_STAT_LIST;
 		else if (!strcmp(ptr, "n"))
-			ccs_current_screen = CCS_SCREEN_NS_LIST;
+			active = SCREEN_NS_LIST;
 		else if (!strcmp(ptr, "readonly"))
-			ccs_readonly_mode = true;
-		else if (sscanf(ptr, "refresh=%u", &ccs_refresh_interval)
-			 != 1) {
+			w.readonly_mode = true;
+		else if (sscanf(ptr, "refresh=%u", &w.refresh_interval) != 1) {
 usage:
 			printf("Usage: %s [e|d|p|m|s|n] [readonly] "
 			       "[refresh=interval] [<namespace>]"
-			       "[{policy_dir|remote_ip:remote_port}]\n",
+			       "[{w.policy_dir|remote_ip:remote_port}]\n",
 			       argv[0]);
 			exit(1);
 		}
 	}
 	if (!ccs_current_ns)
 		ccs_current_ns = ccs_savename("<kernel>");
-	ccs_previous_screen = ccs_current_screen;
+	w.previous_screen = active;
 }
 
 /**
@@ -3755,9 +3630,9 @@
 	 */
 	addr.sin_family = AF_INET;
 	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-	if (chdir(ccs_policy_dir) || chdir("policy/current/")) {
+	if (chdir(w.policy_dir) || chdir("policy/current/")) {
 		fprintf(stderr, "Directory %s/policy/current/ doesn't "
-			"exist.\n", ccs_policy_dir);
+			"exist.\n", w.policy_dir);
 		exit(1);
 	}
 	if (bind(fd, (struct sockaddr *) &addr, sizeof(addr)) || listen(fd, 5)
@@ -3786,7 +3661,7 @@
 		if (close(pipe_fd[1]) ||
 		    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) & ~O_NONBLOCK))
 			_exit(1);
-		ccs_editpolicy_offline_daemon(fd, pipe_fd[0]);
+		editpolicy_offline_daemon(fd, pipe_fd[0]);
 		_exit(1);
 	case -1:
 		fprintf(stderr, "fork()\n");
@@ -3794,14 +3669,14 @@
 	}
 	if (close(fd) || close(pipe_fd[0]))
 		exit(1);
-	ccs_copy_file("profile.conf", CCS_PROC_POLICY_PROFILE);
-	ccs_copy_file("exception_policy.conf",
-		      CCS_PROC_POLICY_EXCEPTION_POLICY);
-	ccs_copy_file("domain_policy.conf", CCS_PROC_POLICY_DOMAIN_POLICY);
-	ccs_copy_file("manager.conf", CCS_PROC_POLICY_MANAGER);
+	copy_file("profile.conf", CCS_PROC_POLICY_PROFILE);
+	copy_file("exception_policy.conf",
+		  CCS_PROC_POLICY_EXCEPTION_POLICY);
+	copy_file("domain_policy.conf", CCS_PROC_POLICY_DOMAIN_POLICY);
+	copy_file("manager.conf", CCS_PROC_POLICY_MANAGER);
 	if (chdir("..")) {
 		fprintf(stderr, "Directory %s/policy/ doesn't exist.\n",
-			ccs_policy_dir);
+			w.policy_dir);
 		exit(1);
 	}
 }
@@ -3813,8 +3688,8 @@
  */
 static void ccs_load_readwrite(void)
 {
-	const int fd1 = ccs_open2(CCS_PROC_POLICY_EXCEPTION_POLICY, O_RDWR);
-	const int fd2 = ccs_open2(CCS_PROC_POLICY_DOMAIN_POLICY, O_RDWR);
+	const int fd1 = open2(CCS_PROC_POLICY_EXCEPTION_POLICY, O_RDWR);
+	const int fd2 = open2(CCS_PROC_POLICY_DOMAIN_POLICY, O_RDWR);
 	if ((fd1 != EOF && write(fd1, "", 0) != 0) ||
 	    (fd2 != EOF && write(fd2, "", 0) != 0)) {
 		fprintf(stderr, "In order to run this program, it must be "
@@ -3846,8 +3721,8 @@
 		else if (errno == EEXIST)
 			now++;
 		else {
-			fprintf(stderr, "Can't create %s/%s .\n",
-				ccs_policy_dir, stamp);
+			fprintf(stderr, "Can't create %s/%s .\n", w.policy_dir,
+				stamp);
 			exit(1);
 		}
 	}
@@ -3876,11 +3751,11 @@
 
 int main(int argc, char *argv[])
 {
-	memset(acl_group_list, 0, sizeof(acl_group_list));
-	memset(acl_group_list_len, 0, sizeof(acl_group_list_len));
+	memset(&w, 0, sizeof(w));
+	memset(&p, 0, sizeof(p));
 	ccs_parse_args(argc, argv);
-	ccs_editpolicy_init_keyword_map();
-	if (ccs_offline_mode)
+	editpolicy_init_keyword_map();
+	if (w.offline_mode)
 		ccs_load_offline();
 	if (ccs_network_mode)
 		goto start;
@@ -3889,39 +3764,39 @@
 			"You can't use this editor for this kernel.\n");
 		return 1;
 	}
-	if (!ccs_readonly_mode)
+	if (!w.readonly_mode)
 		ccs_load_readwrite();
 start:
 	initscr();
-	ccs_editpolicy_color_init();
+	editpolicy_color_init();
 	cbreak();
 	noecho();
 	nonl();
 	intrflush(stdscr, FALSE);
 	keypad(stdscr, TRUE);
-	getmaxyx(stdscr, ccs_window_height, ccs_window_width);
-	if (ccs_refresh_interval) {
-		signal(SIGALRM, ccs_sigalrm_handler);
-		alarm(ccs_refresh_interval);
+	getmaxyx(stdscr, w.height, w.width);
+	if (w.refresh_interval) {
+		signal(SIGALRM, sigalrm_handler);
+		alarm(w.refresh_interval);
 		timeout(1000);
 	}
-	ccs_rl.max = 20;
-	ccs_rl.history = ccs_malloc(ccs_rl.max * sizeof(const char *));
-	while (ccs_current_screen < CCS_MAXSCREEN) {
-		enum ccs_screen_type next;
-		ccs_resize_window();
-		next = ccs_generic_list_loop();
-		if (next != ccs_current_screen)
-			ccs_previous_screen = ccs_current_screen;
-		ccs_current_screen = next;
+	rl.max = 20;
+	rl.history = ccs_malloc(rl.max * sizeof(const char *));
+	while (active < MAX_SCREEN_TYPE) {
+		enum screen_type next;
+		resize_window();
+		next = generic_list_loop();
+		if (next != active)
+			w.previous_screen = active;
+		active = next;
 	}
 	alarm(0);
 	clear();
 	move(0, 0);
 	refresh();
 	endwin();
-	if (ccs_offline_mode && !ccs_readonly_mode)
+	if (w.offline_mode && !w.readonly_mode)
 		ccs_save_offline();
-	ccs_clear_domain_policy3();
+	clear_domain_policy();
 	return 0;
 }
Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.h
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.h	(revision 6401)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy.h	(working copy)
@@ -23,396 +23,397 @@
 #include <signal.h>
 #include <curses.h>
 
-enum ccs_screen_type {
-	CCS_SCREEN_EXCEPTION_LIST,
-	CCS_SCREEN_DOMAIN_LIST,
-	CCS_SCREEN_ACL_LIST,
-	CCS_SCREEN_PROFILE_LIST,
-	CCS_SCREEN_MANAGER_LIST,
-	/* CCS_SCREEN_QUERY_LIST, */
-	CCS_SCREEN_NS_LIST,
-	CCS_SCREEN_STAT_LIST,
-	CCS_MAXSCREEN
+enum screen_type {
+	SCREEN_EXCEPTION_LIST,
+	SCREEN_DOMAIN_LIST,
+	SCREEN_ACL_LIST,
+	SCREEN_PROFILE_LIST,
+	SCREEN_MANAGER_LIST,
+	/* SCREEN_QUERY_LIST, */
+	SCREEN_NS_LIST,
+	SCREEN_STAT_LIST,
+	MAX_SCREEN_TYPE
 };
 
-enum ccs_transition_type {
+enum transition_type {
 	/* Do not change this order, */
-	CCS_TRANSITION_CONTROL_NO_RESET,
-	CCS_TRANSITION_CONTROL_RESET,
-	CCS_TRANSITION_CONTROL_NO_INITIALIZE,
-	CCS_TRANSITION_CONTROL_INITIALIZE,
-	CCS_TRANSITION_CONTROL_NO_KEEP,
-	CCS_TRANSITION_CONTROL_KEEP,
-	CCS_MAX_TRANSITION_TYPE
+	TRANSITION_NO_RESET,
+	TRANSITION_RESET,
+	TRANSITION_NO_INITIALIZE,
+	TRANSITION_INITIALIZE,
+	TRANSITION_NO_KEEP,
+	TRANSITION_KEEP,
+	MAX_TRANSITION_TYPE
 };
 
-enum ccs_editpolicy_directives {
-	CCS_DIRECTIVE_NONE,
-	CCS_DIRECTIVE_ACL_GROUP_000,
-	CCS_DIRECTIVE_ACL_GROUP_001,
-	CCS_DIRECTIVE_ACL_GROUP_002,
-	CCS_DIRECTIVE_ACL_GROUP_003,
-	CCS_DIRECTIVE_ACL_GROUP_004,
-	CCS_DIRECTIVE_ACL_GROUP_005,
-	CCS_DIRECTIVE_ACL_GROUP_006,
-	CCS_DIRECTIVE_ACL_GROUP_007,
-	CCS_DIRECTIVE_ACL_GROUP_008,
-	CCS_DIRECTIVE_ACL_GROUP_009,
-	CCS_DIRECTIVE_ACL_GROUP_010,
-	CCS_DIRECTIVE_ACL_GROUP_011,
-	CCS_DIRECTIVE_ACL_GROUP_012,
-	CCS_DIRECTIVE_ACL_GROUP_013,
-	CCS_DIRECTIVE_ACL_GROUP_014,
-	CCS_DIRECTIVE_ACL_GROUP_015,
-	CCS_DIRECTIVE_ACL_GROUP_016,
-	CCS_DIRECTIVE_ACL_GROUP_017,
-	CCS_DIRECTIVE_ACL_GROUP_018,
-	CCS_DIRECTIVE_ACL_GROUP_019,
-	CCS_DIRECTIVE_ACL_GROUP_020,
-	CCS_DIRECTIVE_ACL_GROUP_021,
-	CCS_DIRECTIVE_ACL_GROUP_022,
-	CCS_DIRECTIVE_ACL_GROUP_023,
-	CCS_DIRECTIVE_ACL_GROUP_024,
-	CCS_DIRECTIVE_ACL_GROUP_025,
-	CCS_DIRECTIVE_ACL_GROUP_026,
-	CCS_DIRECTIVE_ACL_GROUP_027,
-	CCS_DIRECTIVE_ACL_GROUP_028,
-	CCS_DIRECTIVE_ACL_GROUP_029,
-	CCS_DIRECTIVE_ACL_GROUP_030,
-	CCS_DIRECTIVE_ACL_GROUP_031,
-	CCS_DIRECTIVE_ACL_GROUP_032,
-	CCS_DIRECTIVE_ACL_GROUP_033,
-	CCS_DIRECTIVE_ACL_GROUP_034,
-	CCS_DIRECTIVE_ACL_GROUP_035,
-	CCS_DIRECTIVE_ACL_GROUP_036,
-	CCS_DIRECTIVE_ACL_GROUP_037,
-	CCS_DIRECTIVE_ACL_GROUP_038,
-	CCS_DIRECTIVE_ACL_GROUP_039,
-	CCS_DIRECTIVE_ACL_GROUP_040,
-	CCS_DIRECTIVE_ACL_GROUP_041,
-	CCS_DIRECTIVE_ACL_GROUP_042,
-	CCS_DIRECTIVE_ACL_GROUP_043,
-	CCS_DIRECTIVE_ACL_GROUP_044,
-	CCS_DIRECTIVE_ACL_GROUP_045,
-	CCS_DIRECTIVE_ACL_GROUP_046,
-	CCS_DIRECTIVE_ACL_GROUP_047,
-	CCS_DIRECTIVE_ACL_GROUP_048,
-	CCS_DIRECTIVE_ACL_GROUP_049,
-	CCS_DIRECTIVE_ACL_GROUP_050,
-	CCS_DIRECTIVE_ACL_GROUP_051,
-	CCS_DIRECTIVE_ACL_GROUP_052,
-	CCS_DIRECTIVE_ACL_GROUP_053,
-	CCS_DIRECTIVE_ACL_GROUP_054,
-	CCS_DIRECTIVE_ACL_GROUP_055,
-	CCS_DIRECTIVE_ACL_GROUP_056,
-	CCS_DIRECTIVE_ACL_GROUP_057,
-	CCS_DIRECTIVE_ACL_GROUP_058,
-	CCS_DIRECTIVE_ACL_GROUP_059,
-	CCS_DIRECTIVE_ACL_GROUP_060,
-	CCS_DIRECTIVE_ACL_GROUP_061,
-	CCS_DIRECTIVE_ACL_GROUP_062,
-	CCS_DIRECTIVE_ACL_GROUP_063,
-	CCS_DIRECTIVE_ACL_GROUP_064,
-	CCS_DIRECTIVE_ACL_GROUP_065,
-	CCS_DIRECTIVE_ACL_GROUP_066,
-	CCS_DIRECTIVE_ACL_GROUP_067,
-	CCS_DIRECTIVE_ACL_GROUP_068,
-	CCS_DIRECTIVE_ACL_GROUP_069,
-	CCS_DIRECTIVE_ACL_GROUP_070,
-	CCS_DIRECTIVE_ACL_GROUP_071,
-	CCS_DIRECTIVE_ACL_GROUP_072,
-	CCS_DIRECTIVE_ACL_GROUP_073,
-	CCS_DIRECTIVE_ACL_GROUP_074,
-	CCS_DIRECTIVE_ACL_GROUP_075,
-	CCS_DIRECTIVE_ACL_GROUP_076,
-	CCS_DIRECTIVE_ACL_GROUP_077,
-	CCS_DIRECTIVE_ACL_GROUP_078,
-	CCS_DIRECTIVE_ACL_GROUP_079,
-	CCS_DIRECTIVE_ACL_GROUP_080,
-	CCS_DIRECTIVE_ACL_GROUP_081,
-	CCS_DIRECTIVE_ACL_GROUP_082,
-	CCS_DIRECTIVE_ACL_GROUP_083,
-	CCS_DIRECTIVE_ACL_GROUP_084,
-	CCS_DIRECTIVE_ACL_GROUP_085,
-	CCS_DIRECTIVE_ACL_GROUP_086,
-	CCS_DIRECTIVE_ACL_GROUP_087,
-	CCS_DIRECTIVE_ACL_GROUP_088,
-	CCS_DIRECTIVE_ACL_GROUP_089,
-	CCS_DIRECTIVE_ACL_GROUP_090,
-	CCS_DIRECTIVE_ACL_GROUP_091,
-	CCS_DIRECTIVE_ACL_GROUP_092,
-	CCS_DIRECTIVE_ACL_GROUP_093,
-	CCS_DIRECTIVE_ACL_GROUP_094,
-	CCS_DIRECTIVE_ACL_GROUP_095,
-	CCS_DIRECTIVE_ACL_GROUP_096,
-	CCS_DIRECTIVE_ACL_GROUP_097,
-	CCS_DIRECTIVE_ACL_GROUP_098,
-	CCS_DIRECTIVE_ACL_GROUP_099,
-	CCS_DIRECTIVE_ACL_GROUP_100,
-	CCS_DIRECTIVE_ACL_GROUP_101,
-	CCS_DIRECTIVE_ACL_GROUP_102,
-	CCS_DIRECTIVE_ACL_GROUP_103,
-	CCS_DIRECTIVE_ACL_GROUP_104,
-	CCS_DIRECTIVE_ACL_GROUP_105,
-	CCS_DIRECTIVE_ACL_GROUP_106,
-	CCS_DIRECTIVE_ACL_GROUP_107,
-	CCS_DIRECTIVE_ACL_GROUP_108,
-	CCS_DIRECTIVE_ACL_GROUP_109,
-	CCS_DIRECTIVE_ACL_GROUP_110,
-	CCS_DIRECTIVE_ACL_GROUP_111,
-	CCS_DIRECTIVE_ACL_GROUP_112,
-	CCS_DIRECTIVE_ACL_GROUP_113,
-	CCS_DIRECTIVE_ACL_GROUP_114,
-	CCS_DIRECTIVE_ACL_GROUP_115,
-	CCS_DIRECTIVE_ACL_GROUP_116,
-	CCS_DIRECTIVE_ACL_GROUP_117,
-	CCS_DIRECTIVE_ACL_GROUP_118,
-	CCS_DIRECTIVE_ACL_GROUP_119,
-	CCS_DIRECTIVE_ACL_GROUP_120,
-	CCS_DIRECTIVE_ACL_GROUP_121,
-	CCS_DIRECTIVE_ACL_GROUP_122,
-	CCS_DIRECTIVE_ACL_GROUP_123,
-	CCS_DIRECTIVE_ACL_GROUP_124,
-	CCS_DIRECTIVE_ACL_GROUP_125,
-	CCS_DIRECTIVE_ACL_GROUP_126,
-	CCS_DIRECTIVE_ACL_GROUP_127,
-	CCS_DIRECTIVE_ACL_GROUP_128,
-	CCS_DIRECTIVE_ACL_GROUP_129,
-	CCS_DIRECTIVE_ACL_GROUP_130,
-	CCS_DIRECTIVE_ACL_GROUP_131,
-	CCS_DIRECTIVE_ACL_GROUP_132,
-	CCS_DIRECTIVE_ACL_GROUP_133,
-	CCS_DIRECTIVE_ACL_GROUP_134,
-	CCS_DIRECTIVE_ACL_GROUP_135,
-	CCS_DIRECTIVE_ACL_GROUP_136,
-	CCS_DIRECTIVE_ACL_GROUP_137,
-	CCS_DIRECTIVE_ACL_GROUP_138,
-	CCS_DIRECTIVE_ACL_GROUP_139,
-	CCS_DIRECTIVE_ACL_GROUP_140,
-	CCS_DIRECTIVE_ACL_GROUP_141,
-	CCS_DIRECTIVE_ACL_GROUP_142,
-	CCS_DIRECTIVE_ACL_GROUP_143,
-	CCS_DIRECTIVE_ACL_GROUP_144,
-	CCS_DIRECTIVE_ACL_GROUP_145,
-	CCS_DIRECTIVE_ACL_GROUP_146,
-	CCS_DIRECTIVE_ACL_GROUP_147,
-	CCS_DIRECTIVE_ACL_GROUP_148,
-	CCS_DIRECTIVE_ACL_GROUP_149,
-	CCS_DIRECTIVE_ACL_GROUP_150,
-	CCS_DIRECTIVE_ACL_GROUP_151,
-	CCS_DIRECTIVE_ACL_GROUP_152,
-	CCS_DIRECTIVE_ACL_GROUP_153,
-	CCS_DIRECTIVE_ACL_GROUP_154,
-	CCS_DIRECTIVE_ACL_GROUP_155,
-	CCS_DIRECTIVE_ACL_GROUP_156,
-	CCS_DIRECTIVE_ACL_GROUP_157,
-	CCS_DIRECTIVE_ACL_GROUP_158,
-	CCS_DIRECTIVE_ACL_GROUP_159,
-	CCS_DIRECTIVE_ACL_GROUP_160,
-	CCS_DIRECTIVE_ACL_GROUP_161,
-	CCS_DIRECTIVE_ACL_GROUP_162,
-	CCS_DIRECTIVE_ACL_GROUP_163,
-	CCS_DIRECTIVE_ACL_GROUP_164,
-	CCS_DIRECTIVE_ACL_GROUP_165,
-	CCS_DIRECTIVE_ACL_GROUP_166,
-	CCS_DIRECTIVE_ACL_GROUP_167,
-	CCS_DIRECTIVE_ACL_GROUP_168,
-	CCS_DIRECTIVE_ACL_GROUP_169,
-	CCS_DIRECTIVE_ACL_GROUP_170,
-	CCS_DIRECTIVE_ACL_GROUP_171,
-	CCS_DIRECTIVE_ACL_GROUP_172,
-	CCS_DIRECTIVE_ACL_GROUP_173,
-	CCS_DIRECTIVE_ACL_GROUP_174,
-	CCS_DIRECTIVE_ACL_GROUP_175,
-	CCS_DIRECTIVE_ACL_GROUP_176,
-	CCS_DIRECTIVE_ACL_GROUP_177,
-	CCS_DIRECTIVE_ACL_GROUP_178,
-	CCS_DIRECTIVE_ACL_GROUP_179,
-	CCS_DIRECTIVE_ACL_GROUP_180,
-	CCS_DIRECTIVE_ACL_GROUP_181,
-	CCS_DIRECTIVE_ACL_GROUP_182,
-	CCS_DIRECTIVE_ACL_GROUP_183,
-	CCS_DIRECTIVE_ACL_GROUP_184,
-	CCS_DIRECTIVE_ACL_GROUP_185,
-	CCS_DIRECTIVE_ACL_GROUP_186,
-	CCS_DIRECTIVE_ACL_GROUP_187,
-	CCS_DIRECTIVE_ACL_GROUP_188,
-	CCS_DIRECTIVE_ACL_GROUP_189,
-	CCS_DIRECTIVE_ACL_GROUP_190,
-	CCS_DIRECTIVE_ACL_GROUP_191,
-	CCS_DIRECTIVE_ACL_GROUP_192,
-	CCS_DIRECTIVE_ACL_GROUP_193,
-	CCS_DIRECTIVE_ACL_GROUP_194,
-	CCS_DIRECTIVE_ACL_GROUP_195,
-	CCS_DIRECTIVE_ACL_GROUP_196,
-	CCS_DIRECTIVE_ACL_GROUP_197,
-	CCS_DIRECTIVE_ACL_GROUP_198,
-	CCS_DIRECTIVE_ACL_GROUP_199,
-	CCS_DIRECTIVE_ACL_GROUP_200,
-	CCS_DIRECTIVE_ACL_GROUP_201,
-	CCS_DIRECTIVE_ACL_GROUP_202,
-	CCS_DIRECTIVE_ACL_GROUP_203,
-	CCS_DIRECTIVE_ACL_GROUP_204,
-	CCS_DIRECTIVE_ACL_GROUP_205,
-	CCS_DIRECTIVE_ACL_GROUP_206,
-	CCS_DIRECTIVE_ACL_GROUP_207,
-	CCS_DIRECTIVE_ACL_GROUP_208,
-	CCS_DIRECTIVE_ACL_GROUP_209,
-	CCS_DIRECTIVE_ACL_GROUP_210,
-	CCS_DIRECTIVE_ACL_GROUP_211,
-	CCS_DIRECTIVE_ACL_GROUP_212,
-	CCS_DIRECTIVE_ACL_GROUP_213,
-	CCS_DIRECTIVE_ACL_GROUP_214,
-	CCS_DIRECTIVE_ACL_GROUP_215,
-	CCS_DIRECTIVE_ACL_GROUP_216,
-	CCS_DIRECTIVE_ACL_GROUP_217,
-	CCS_DIRECTIVE_ACL_GROUP_218,
-	CCS_DIRECTIVE_ACL_GROUP_219,
-	CCS_DIRECTIVE_ACL_GROUP_220,
-	CCS_DIRECTIVE_ACL_GROUP_221,
-	CCS_DIRECTIVE_ACL_GROUP_222,
-	CCS_DIRECTIVE_ACL_GROUP_223,
-	CCS_DIRECTIVE_ACL_GROUP_224,
-	CCS_DIRECTIVE_ACL_GROUP_225,
-	CCS_DIRECTIVE_ACL_GROUP_226,
-	CCS_DIRECTIVE_ACL_GROUP_227,
-	CCS_DIRECTIVE_ACL_GROUP_228,
-	CCS_DIRECTIVE_ACL_GROUP_229,
-	CCS_DIRECTIVE_ACL_GROUP_230,
-	CCS_DIRECTIVE_ACL_GROUP_231,
-	CCS_DIRECTIVE_ACL_GROUP_232,
-	CCS_DIRECTIVE_ACL_GROUP_233,
-	CCS_DIRECTIVE_ACL_GROUP_234,
-	CCS_DIRECTIVE_ACL_GROUP_235,
-	CCS_DIRECTIVE_ACL_GROUP_236,
-	CCS_DIRECTIVE_ACL_GROUP_237,
-	CCS_DIRECTIVE_ACL_GROUP_238,
-	CCS_DIRECTIVE_ACL_GROUP_239,
-	CCS_DIRECTIVE_ACL_GROUP_240,
-	CCS_DIRECTIVE_ACL_GROUP_241,
-	CCS_DIRECTIVE_ACL_GROUP_242,
-	CCS_DIRECTIVE_ACL_GROUP_243,
-	CCS_DIRECTIVE_ACL_GROUP_244,
-	CCS_DIRECTIVE_ACL_GROUP_245,
-	CCS_DIRECTIVE_ACL_GROUP_246,
-	CCS_DIRECTIVE_ACL_GROUP_247,
-	CCS_DIRECTIVE_ACL_GROUP_248,
-	CCS_DIRECTIVE_ACL_GROUP_249,
-	CCS_DIRECTIVE_ACL_GROUP_250,
-	CCS_DIRECTIVE_ACL_GROUP_251,
-	CCS_DIRECTIVE_ACL_GROUP_252,
-	CCS_DIRECTIVE_ACL_GROUP_253,
-	CCS_DIRECTIVE_ACL_GROUP_254,
-	CCS_DIRECTIVE_ACL_GROUP_255,
-	CCS_DIRECTIVE_ADDRESS_GROUP,
-	CCS_DIRECTIVE_AGGREGATOR,
-	CCS_DIRECTIVE_CAPABILITY,
-	CCS_DIRECTIVE_DENY_AUTOBIND,
-	CCS_DIRECTIVE_FILE_APPEND,
-	CCS_DIRECTIVE_FILE_CHGRP,
-	CCS_DIRECTIVE_FILE_CHMOD,
-	CCS_DIRECTIVE_FILE_CHOWN,
-	CCS_DIRECTIVE_FILE_CHROOT,
-	CCS_DIRECTIVE_FILE_CREATE,
-	CCS_DIRECTIVE_FILE_EXECUTE,
-	CCS_DIRECTIVE_FILE_GETATTR,
-	CCS_DIRECTIVE_FILE_IOCTL,
-	CCS_DIRECTIVE_FILE_LINK,
-	CCS_DIRECTIVE_FILE_MKBLOCK,
-	CCS_DIRECTIVE_FILE_MKCHAR,
-	CCS_DIRECTIVE_FILE_MKDIR,
-	CCS_DIRECTIVE_FILE_MKFIFO,
-	CCS_DIRECTIVE_FILE_MKSOCK,
-	CCS_DIRECTIVE_FILE_MOUNT,
-	CCS_DIRECTIVE_FILE_PIVOT_ROOT,
-	CCS_DIRECTIVE_FILE_READ,
-	CCS_DIRECTIVE_FILE_RENAME,
-	CCS_DIRECTIVE_FILE_RMDIR,
-	CCS_DIRECTIVE_FILE_SYMLINK,
-	CCS_DIRECTIVE_FILE_TRUNCATE,
-	CCS_DIRECTIVE_FILE_UNLINK,
-	CCS_DIRECTIVE_FILE_UNMOUNT,
-	CCS_DIRECTIVE_FILE_WRITE,
-	CCS_DIRECTIVE_INITIALIZE_DOMAIN,
-	CCS_DIRECTIVE_IPC_SIGNAL,
-	CCS_DIRECTIVE_KEEP_DOMAIN,
-	CCS_DIRECTIVE_MISC_ENV,
-	CCS_DIRECTIVE_NETWORK_INET,
-	CCS_DIRECTIVE_NETWORK_UNIX,
-	CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN,
-	CCS_DIRECTIVE_NO_KEEP_DOMAIN,
-	CCS_DIRECTIVE_NO_RESET_DOMAIN,
-	CCS_DIRECTIVE_NUMBER_GROUP,
-	CCS_DIRECTIVE_PATH_GROUP,
-	CCS_DIRECTIVE_QUOTA_EXCEEDED,
-	CCS_DIRECTIVE_RESET_DOMAIN,
-	CCS_DIRECTIVE_TASK_AUTO_DOMAIN_TRANSITION,
-	CCS_DIRECTIVE_TASK_AUTO_EXECUTE_HANDLER,
-	CCS_DIRECTIVE_TASK_DENIED_EXECUTE_HANDLER,
-	CCS_DIRECTIVE_TASK_MANUAL_DOMAIN_TRANSITION,
-	CCS_DIRECTIVE_TRANSITION_FAILED,
-	CCS_DIRECTIVE_USE_GROUP,
-	CCS_DIRECTIVE_USE_PROFILE,
-	CCS_MAX_DIRECTIVE_INDEX
+enum directive_type {
+	DIRECTIVE_NONE,
+	DIRECTIVE_ACL_GROUP_000,
+	DIRECTIVE_ACL_GROUP_001,
+	DIRECTIVE_ACL_GROUP_002,
+	DIRECTIVE_ACL_GROUP_003,
+	DIRECTIVE_ACL_GROUP_004,
+	DIRECTIVE_ACL_GROUP_005,
+	DIRECTIVE_ACL_GROUP_006,
+	DIRECTIVE_ACL_GROUP_007,
+	DIRECTIVE_ACL_GROUP_008,
+	DIRECTIVE_ACL_GROUP_009,
+	DIRECTIVE_ACL_GROUP_010,
+	DIRECTIVE_ACL_GROUP_011,
+	DIRECTIVE_ACL_GROUP_012,
+	DIRECTIVE_ACL_GROUP_013,
+	DIRECTIVE_ACL_GROUP_014,
+	DIRECTIVE_ACL_GROUP_015,
+	DIRECTIVE_ACL_GROUP_016,
+	DIRECTIVE_ACL_GROUP_017,
+	DIRECTIVE_ACL_GROUP_018,
+	DIRECTIVE_ACL_GROUP_019,
+	DIRECTIVE_ACL_GROUP_020,
+	DIRECTIVE_ACL_GROUP_021,
+	DIRECTIVE_ACL_GROUP_022,
+	DIRECTIVE_ACL_GROUP_023,
+	DIRECTIVE_ACL_GROUP_024,
+	DIRECTIVE_ACL_GROUP_025,
+	DIRECTIVE_ACL_GROUP_026,
+	DIRECTIVE_ACL_GROUP_027,
+	DIRECTIVE_ACL_GROUP_028,
+	DIRECTIVE_ACL_GROUP_029,
+	DIRECTIVE_ACL_GROUP_030,
+	DIRECTIVE_ACL_GROUP_031,
+	DIRECTIVE_ACL_GROUP_032,
+	DIRECTIVE_ACL_GROUP_033,
+	DIRECTIVE_ACL_GROUP_034,
+	DIRECTIVE_ACL_GROUP_035,
+	DIRECTIVE_ACL_GROUP_036,
+	DIRECTIVE_ACL_GROUP_037,
+	DIRECTIVE_ACL_GROUP_038,
+	DIRECTIVE_ACL_GROUP_039,
+	DIRECTIVE_ACL_GROUP_040,
+	DIRECTIVE_ACL_GROUP_041,
+	DIRECTIVE_ACL_GROUP_042,
+	DIRECTIVE_ACL_GROUP_043,
+	DIRECTIVE_ACL_GROUP_044,
+	DIRECTIVE_ACL_GROUP_045,
+	DIRECTIVE_ACL_GROUP_046,
+	DIRECTIVE_ACL_GROUP_047,
+	DIRECTIVE_ACL_GROUP_048,
+	DIRECTIVE_ACL_GROUP_049,
+	DIRECTIVE_ACL_GROUP_050,
+	DIRECTIVE_ACL_GROUP_051,
+	DIRECTIVE_ACL_GROUP_052,
+	DIRECTIVE_ACL_GROUP_053,
+	DIRECTIVE_ACL_GROUP_054,
+	DIRECTIVE_ACL_GROUP_055,
+	DIRECTIVE_ACL_GROUP_056,
+	DIRECTIVE_ACL_GROUP_057,
+	DIRECTIVE_ACL_GROUP_058,
+	DIRECTIVE_ACL_GROUP_059,
+	DIRECTIVE_ACL_GROUP_060,
+	DIRECTIVE_ACL_GROUP_061,
+	DIRECTIVE_ACL_GROUP_062,
+	DIRECTIVE_ACL_GROUP_063,
+	DIRECTIVE_ACL_GROUP_064,
+	DIRECTIVE_ACL_GROUP_065,
+	DIRECTIVE_ACL_GROUP_066,
+	DIRECTIVE_ACL_GROUP_067,
+	DIRECTIVE_ACL_GROUP_068,
+	DIRECTIVE_ACL_GROUP_069,
+	DIRECTIVE_ACL_GROUP_070,
+	DIRECTIVE_ACL_GROUP_071,
+	DIRECTIVE_ACL_GROUP_072,
+	DIRECTIVE_ACL_GROUP_073,
+	DIRECTIVE_ACL_GROUP_074,
+	DIRECTIVE_ACL_GROUP_075,
+	DIRECTIVE_ACL_GROUP_076,
+	DIRECTIVE_ACL_GROUP_077,
+	DIRECTIVE_ACL_GROUP_078,
+	DIRECTIVE_ACL_GROUP_079,
+	DIRECTIVE_ACL_GROUP_080,
+	DIRECTIVE_ACL_GROUP_081,
+	DIRECTIVE_ACL_GROUP_082,
+	DIRECTIVE_ACL_GROUP_083,
+	DIRECTIVE_ACL_GROUP_084,
+	DIRECTIVE_ACL_GROUP_085,
+	DIRECTIVE_ACL_GROUP_086,
+	DIRECTIVE_ACL_GROUP_087,
+	DIRECTIVE_ACL_GROUP_088,
+	DIRECTIVE_ACL_GROUP_089,
+	DIRECTIVE_ACL_GROUP_090,
+	DIRECTIVE_ACL_GROUP_091,
+	DIRECTIVE_ACL_GROUP_092,
+	DIRECTIVE_ACL_GROUP_093,
+	DIRECTIVE_ACL_GROUP_094,
+	DIRECTIVE_ACL_GROUP_095,
+	DIRECTIVE_ACL_GROUP_096,
+	DIRECTIVE_ACL_GROUP_097,
+	DIRECTIVE_ACL_GROUP_098,
+	DIRECTIVE_ACL_GROUP_099,
+	DIRECTIVE_ACL_GROUP_100,
+	DIRECTIVE_ACL_GROUP_101,
+	DIRECTIVE_ACL_GROUP_102,
+	DIRECTIVE_ACL_GROUP_103,
+	DIRECTIVE_ACL_GROUP_104,
+	DIRECTIVE_ACL_GROUP_105,
+	DIRECTIVE_ACL_GROUP_106,
+	DIRECTIVE_ACL_GROUP_107,
+	DIRECTIVE_ACL_GROUP_108,
+	DIRECTIVE_ACL_GROUP_109,
+	DIRECTIVE_ACL_GROUP_110,
+	DIRECTIVE_ACL_GROUP_111,
+	DIRECTIVE_ACL_GROUP_112,
+	DIRECTIVE_ACL_GROUP_113,
+	DIRECTIVE_ACL_GROUP_114,
+	DIRECTIVE_ACL_GROUP_115,
+	DIRECTIVE_ACL_GROUP_116,
+	DIRECTIVE_ACL_GROUP_117,
+	DIRECTIVE_ACL_GROUP_118,
+	DIRECTIVE_ACL_GROUP_119,
+	DIRECTIVE_ACL_GROUP_120,
+	DIRECTIVE_ACL_GROUP_121,
+	DIRECTIVE_ACL_GROUP_122,
+	DIRECTIVE_ACL_GROUP_123,
+	DIRECTIVE_ACL_GROUP_124,
+	DIRECTIVE_ACL_GROUP_125,
+	DIRECTIVE_ACL_GROUP_126,
+	DIRECTIVE_ACL_GROUP_127,
+	DIRECTIVE_ACL_GROUP_128,
+	DIRECTIVE_ACL_GROUP_129,
+	DIRECTIVE_ACL_GROUP_130,
+	DIRECTIVE_ACL_GROUP_131,
+	DIRECTIVE_ACL_GROUP_132,
+	DIRECTIVE_ACL_GROUP_133,
+	DIRECTIVE_ACL_GROUP_134,
+	DIRECTIVE_ACL_GROUP_135,
+	DIRECTIVE_ACL_GROUP_136,
+	DIRECTIVE_ACL_GROUP_137,
+	DIRECTIVE_ACL_GROUP_138,
+	DIRECTIVE_ACL_GROUP_139,
+	DIRECTIVE_ACL_GROUP_140,
+	DIRECTIVE_ACL_GROUP_141,
+	DIRECTIVE_ACL_GROUP_142,
+	DIRECTIVE_ACL_GROUP_143,
+	DIRECTIVE_ACL_GROUP_144,
+	DIRECTIVE_ACL_GROUP_145,
+	DIRECTIVE_ACL_GROUP_146,
+	DIRECTIVE_ACL_GROUP_147,
+	DIRECTIVE_ACL_GROUP_148,
+	DIRECTIVE_ACL_GROUP_149,
+	DIRECTIVE_ACL_GROUP_150,
+	DIRECTIVE_ACL_GROUP_151,
+	DIRECTIVE_ACL_GROUP_152,
+	DIRECTIVE_ACL_GROUP_153,
+	DIRECTIVE_ACL_GROUP_154,
+	DIRECTIVE_ACL_GROUP_155,
+	DIRECTIVE_ACL_GROUP_156,
+	DIRECTIVE_ACL_GROUP_157,
+	DIRECTIVE_ACL_GROUP_158,
+	DIRECTIVE_ACL_GROUP_159,
+	DIRECTIVE_ACL_GROUP_160,
+	DIRECTIVE_ACL_GROUP_161,
+	DIRECTIVE_ACL_GROUP_162,
+	DIRECTIVE_ACL_GROUP_163,
+	DIRECTIVE_ACL_GROUP_164,
+	DIRECTIVE_ACL_GROUP_165,
+	DIRECTIVE_ACL_GROUP_166,
+	DIRECTIVE_ACL_GROUP_167,
+	DIRECTIVE_ACL_GROUP_168,
+	DIRECTIVE_ACL_GROUP_169,
+	DIRECTIVE_ACL_GROUP_170,
+	DIRECTIVE_ACL_GROUP_171,
+	DIRECTIVE_ACL_GROUP_172,
+	DIRECTIVE_ACL_GROUP_173,
+	DIRECTIVE_ACL_GROUP_174,
+	DIRECTIVE_ACL_GROUP_175,
+	DIRECTIVE_ACL_GROUP_176,
+	DIRECTIVE_ACL_GROUP_177,
+	DIRECTIVE_ACL_GROUP_178,
+	DIRECTIVE_ACL_GROUP_179,
+	DIRECTIVE_ACL_GROUP_180,
+	DIRECTIVE_ACL_GROUP_181,
+	DIRECTIVE_ACL_GROUP_182,
+	DIRECTIVE_ACL_GROUP_183,
+	DIRECTIVE_ACL_GROUP_184,
+	DIRECTIVE_ACL_GROUP_185,
+	DIRECTIVE_ACL_GROUP_186,
+	DIRECTIVE_ACL_GROUP_187,
+	DIRECTIVE_ACL_GROUP_188,
+	DIRECTIVE_ACL_GROUP_189,
+	DIRECTIVE_ACL_GROUP_190,
+	DIRECTIVE_ACL_GROUP_191,
+	DIRECTIVE_ACL_GROUP_192,
+	DIRECTIVE_ACL_GROUP_193,
+	DIRECTIVE_ACL_GROUP_194,
+	DIRECTIVE_ACL_GROUP_195,
+	DIRECTIVE_ACL_GROUP_196,
+	DIRECTIVE_ACL_GROUP_197,
+	DIRECTIVE_ACL_GROUP_198,
+	DIRECTIVE_ACL_GROUP_199,
+	DIRECTIVE_ACL_GROUP_200,
+	DIRECTIVE_ACL_GROUP_201,
+	DIRECTIVE_ACL_GROUP_202,
+	DIRECTIVE_ACL_GROUP_203,
+	DIRECTIVE_ACL_GROUP_204,
+	DIRECTIVE_ACL_GROUP_205,
+	DIRECTIVE_ACL_GROUP_206,
+	DIRECTIVE_ACL_GROUP_207,
+	DIRECTIVE_ACL_GROUP_208,
+	DIRECTIVE_ACL_GROUP_209,
+	DIRECTIVE_ACL_GROUP_210,
+	DIRECTIVE_ACL_GROUP_211,
+	DIRECTIVE_ACL_GROUP_212,
+	DIRECTIVE_ACL_GROUP_213,
+	DIRECTIVE_ACL_GROUP_214,
+	DIRECTIVE_ACL_GROUP_215,
+	DIRECTIVE_ACL_GROUP_216,
+	DIRECTIVE_ACL_GROUP_217,
+	DIRECTIVE_ACL_GROUP_218,
+	DIRECTIVE_ACL_GROUP_219,
+	DIRECTIVE_ACL_GROUP_220,
+	DIRECTIVE_ACL_GROUP_221,
+	DIRECTIVE_ACL_GROUP_222,
+	DIRECTIVE_ACL_GROUP_223,
+	DIRECTIVE_ACL_GROUP_224,
+	DIRECTIVE_ACL_GROUP_225,
+	DIRECTIVE_ACL_GROUP_226,
+	DIRECTIVE_ACL_GROUP_227,
+	DIRECTIVE_ACL_GROUP_228,
+	DIRECTIVE_ACL_GROUP_229,
+	DIRECTIVE_ACL_GROUP_230,
+	DIRECTIVE_ACL_GROUP_231,
+	DIRECTIVE_ACL_GROUP_232,
+	DIRECTIVE_ACL_GROUP_233,
+	DIRECTIVE_ACL_GROUP_234,
+	DIRECTIVE_ACL_GROUP_235,
+	DIRECTIVE_ACL_GROUP_236,
+	DIRECTIVE_ACL_GROUP_237,
+	DIRECTIVE_ACL_GROUP_238,
+	DIRECTIVE_ACL_GROUP_239,
+	DIRECTIVE_ACL_GROUP_240,
+	DIRECTIVE_ACL_GROUP_241,
+	DIRECTIVE_ACL_GROUP_242,
+	DIRECTIVE_ACL_GROUP_243,
+	DIRECTIVE_ACL_GROUP_244,
+	DIRECTIVE_ACL_GROUP_245,
+	DIRECTIVE_ACL_GROUP_246,
+	DIRECTIVE_ACL_GROUP_247,
+	DIRECTIVE_ACL_GROUP_248,
+	DIRECTIVE_ACL_GROUP_249,
+	DIRECTIVE_ACL_GROUP_250,
+	DIRECTIVE_ACL_GROUP_251,
+	DIRECTIVE_ACL_GROUP_252,
+	DIRECTIVE_ACL_GROUP_253,
+	DIRECTIVE_ACL_GROUP_254,
+	DIRECTIVE_ACL_GROUP_255,
+	DIRECTIVE_ADDRESS_GROUP,
+	DIRECTIVE_AGGREGATOR,
+	DIRECTIVE_CAPABILITY,
+	DIRECTIVE_DENY_AUTOBIND,
+	DIRECTIVE_FILE_APPEND,
+	DIRECTIVE_FILE_CHGRP,
+	DIRECTIVE_FILE_CHMOD,
+	DIRECTIVE_FILE_CHOWN,
+	DIRECTIVE_FILE_CHROOT,
+	DIRECTIVE_FILE_CREATE,
+	DIRECTIVE_FILE_EXECUTE,
+	DIRECTIVE_FILE_GETATTR,
+	DIRECTIVE_FILE_IOCTL,
+	DIRECTIVE_FILE_LINK,
+	DIRECTIVE_FILE_MKBLOCK,
+	DIRECTIVE_FILE_MKCHAR,
+	DIRECTIVE_FILE_MKDIR,
+	DIRECTIVE_FILE_MKFIFO,
+	DIRECTIVE_FILE_MKSOCK,
+	DIRECTIVE_FILE_MOUNT,
+	DIRECTIVE_FILE_PIVOT_ROOT,
+	DIRECTIVE_FILE_READ,
+	DIRECTIVE_FILE_RENAME,
+	DIRECTIVE_FILE_RMDIR,
+	DIRECTIVE_FILE_SYMLINK,
+	DIRECTIVE_FILE_TRUNCATE,
+	DIRECTIVE_FILE_UNLINK,
+	DIRECTIVE_FILE_UNMOUNT,
+	DIRECTIVE_FILE_WRITE,
+	DIRECTIVE_INITIALIZE_DOMAIN,
+	DIRECTIVE_IPC_SIGNAL,
+	DIRECTIVE_KEEP_DOMAIN,
+	DIRECTIVE_MISC_ENV,
+	DIRECTIVE_NETWORK_INET,
+	DIRECTIVE_NETWORK_UNIX,
+	DIRECTIVE_NO_INITIALIZE_DOMAIN,
+	DIRECTIVE_NO_KEEP_DOMAIN,
+	DIRECTIVE_NO_RESET_DOMAIN,
+	DIRECTIVE_NUMBER_GROUP,
+	DIRECTIVE_PATH_GROUP,
+	DIRECTIVE_QUOTA_EXCEEDED,
+	DIRECTIVE_RESET_DOMAIN,
+	DIRECTIVE_TASK_AUTO_DOMAIN_TRANSITION,
+	DIRECTIVE_TASK_AUTO_EXECUTE_HANDLER,
+	DIRECTIVE_TASK_DENIED_EXECUTE_HANDLER,
+	DIRECTIVE_TASK_MANUAL_DOMAIN_TRANSITION,
+	DIRECTIVE_TRANSITION_FAILED,
+	DIRECTIVE_USE_GROUP,
+	DIRECTIVE_USE_PROFILE,
+	MAX_DIRECTIVE_TYPE
 };
 
-enum ccs_color_pair {
-	CCS_NORMAL,
-	CCS_DOMAIN_HEAD,
-	CCS_DOMAIN_CURSOR,
-	CCS_EXCEPTION_HEAD,
-	CCS_EXCEPTION_CURSOR,
-	CCS_ACL_HEAD,
-	CCS_ACL_CURSOR,
-	CCS_PROFILE_HEAD,
-	CCS_PROFILE_CURSOR,
-	CCS_MANAGER_HEAD,
-	CCS_MANAGER_CURSOR,
-	CCS_STAT_HEAD,
-	CCS_STAT_CURSOR,
-	CCS_DEFAULT_COLOR,
-	CCS_DISP_ERR
+enum color_type {
+	COLOR_NORMAL,
+	COLOR_DOMAIN_HEAD,
+	COLOR_DOMAIN_CURSOR,
+	COLOR_EXCEPTION_HEAD,
+	COLOR_EXCEPTION_CURSOR,
+	COLOR_ACL_HEAD,
+	COLOR_ACL_CURSOR,
+	COLOR_PROFILE_HEAD,
+	COLOR_PROFILE_CURSOR,
+	COLOR_MANAGER_HEAD,
+	COLOR_MANAGER_CURSOR,
+	COLOR_STAT_HEAD,
+	COLOR_STAT_CURSOR,
+	COLOR_DEFAULT_COLOR,
+	COLOR_DISP_ERR
 };
 
-struct ccs_transition_control_entry {
+struct transition_entry {
 	const struct ccs_path_info *ns;
 	const struct ccs_path_info *domainname;    /* This may be NULL */
 	const struct ccs_path_info *program;       /* This may be NULL */
-	u8 type;
+	enum transition_type type;
 };
 
-struct ccs_generic_acl {
-	enum ccs_editpolicy_directives directive;
-	u8 selected;
+struct transition_preference {
+	int index;
+	char *program;
+	char *domainname;
+};
+
+struct generic_entry {
+	enum directive_type directive;
+	_Bool selected;
 	const char *operand;
 };
 
-struct ccs_editpolicy_directive {
+struct editpolicy_directive {
 	const char *original;
 	const char *alias;
 	int original_len;
 	int alias_len;
 };
 
-struct ccs_misc_policy {
-	const struct ccs_path_info **list;
-	int list_len;
-};
-
-struct ccs_path_group_entry {
+struct path_group {
 	const struct ccs_path_info *ns;
 	const struct ccs_path_info *group_name;
 	const struct ccs_path_info **member_name;
 	int member_name_len;
 };
 
-struct ccs_address_group_entry {
+struct address_group {
 	const struct ccs_path_info *group_name;
 	struct ccs_ip_address_entry *member_name;
 	int member_name_len;
 };
 
-struct ccs_number_group_entry {
+struct number_group {
 	const struct ccs_path_info *group_name;
 	struct ccs_number_entry *member_name;
 	int member_name_len;
@@ -422,7 +423,7 @@
 	const char **history;
 	int count;
 	int max;
-	char *search_buffer[CCS_MAXSCREEN];
+	char *search_buffer[MAX_SCREEN_TYPE];
 };
 
 struct ccs_screen {
@@ -432,7 +433,7 @@
 	int y;
 	/* Columns to shift when displaying. */
 	int x;
-	/* For ccs_editpolicy_line_draw(). */
+	/* For editpolicy_line_draw(). */
 	int saved_color_current; /* Initialized to -1 */
 	int saved_color_y;
 };
@@ -441,26 +442,25 @@
 
 #define CCS_EDITPOLICY_CONF "/etc/ccs/tools/editpolicy.conf"
 
-enum ccs_color_pair ccs_editpolicy_color_head(void);
-enum ccs_editpolicy_directives ccs_find_directive(const _Bool forward,
-						  char *line);
-int ccs_editpolicy_get_current(void);
-void ccs_editpolicy_attr_change(const attr_t attr, const _Bool flg);
-void ccs_editpolicy_color_change(const attr_t attr, const _Bool flg);
-void ccs_editpolicy_color_init(void);
-void ccs_editpolicy_init_keyword_map(void);
-void ccs_editpolicy_line_draw(void);
-void ccs_editpolicy_offline_daemon(const int listener, const int notifier);
-void ccs_editpolicy_optimize(const int current);
-void ccs_editpolicy_sttr_restore(void);
-void ccs_editpolicy_sttr_save(void);
-struct ccs_path_group_entry *ccs_find_path_group_ns
-(const struct ccs_path_info *ns, const char *group_name);
+enum color_type editpolicy_color_head(void);
+enum directive_type find_directive(const _Bool forward, char *line);
+int editpolicy_get_current(void);
+void editpolicy_attr_change(const attr_t attr, const _Bool flg);
+void editpolicy_color_change(const attr_t attr, const _Bool flg);
+void editpolicy_color_init(void);
+void editpolicy_init_keyword_map(void);
+void editpolicy_line_draw(void);
+void editpolicy_offline_daemon(const int listener, const int notifier);
+void editpolicy_optimize(void);
+void editpolicy_sttr_restore(void);
+void editpolicy_sttr_save(void);
+struct path_group *find_path_group_ns(const struct ccs_path_info *ns,
+				      const char *group_name);
 
 struct ccs_domain {
 	const struct ccs_path_info *domainname;
 	const struct ccs_path_info *target; /* This may be NULL */
-	const struct ccs_transition_control_entry *d_t; /* This may be NULL */
+	const struct transition_entry *d_t; /* This may be NULL */
 	const struct ccs_path_info **string_ptr;
 	int string_count;
 	int number;   /* domain number (-1 if target or is_dd) */
@@ -472,24 +472,37 @@
 	_Bool is_dd;  /* deleted domain */
 };
 
-struct ccs_domain_policy3 {
+struct domain_policy {
 	struct ccs_domain *list;
 	int list_len;
 	unsigned char *list_selected;
 };
 
-extern enum ccs_screen_type ccs_current_screen;
-extern int ccs_list_item_count;
-extern int ccs_path_group_list_len;
-extern int ccs_number_group_list_len;
-extern int ccs_address_group_list_len;
-extern int acl_group_list_len[256];
-extern struct ccs_domain_policy3 ccs_dp;
-extern struct ccs_editpolicy_directive ccs_directives[CCS_MAX_DIRECTIVE_INDEX];
-extern struct ccs_generic_acl *ccs_gacl_list;
-extern struct ccs_path_group_entry *ccs_path_group_list;
-extern struct ccs_number_group_entry *ccs_number_group_list;
-extern struct ccs_address_group_entry *ccs_address_group_list;
-extern char **acl_group_list[256];
-extern struct ccs_screen ccs_screen[CCS_MAXSCREEN];
+struct policy {
+	/* Array of "path_group" entries. */
+	struct path_group *path_group;
+	/* Length of path_group_list array. */
+	int path_group_len;
+	/* Array of "number_group" entry. */
+	struct number_group *number_group;
+	/* Length of number_group_list array. */
+	int number_group_len;
+	/* Array of "address_group" entry. */
+	struct address_group *address_group;
+	/* Length of address_group_list array. */
+	int address_group_len;
+	/* Array of "acl_group" entry. */
+	char **acl_group[256];
+	/* Length of acl_group_list array.*/
+	int acl_group_len[256];
+	/* Array of string ACL entries. */
+	struct generic_entry *generic;
+	/* Length of generic_list array. */
+	int generic_len;
+};
+
+extern enum screen_type active;
+extern struct policy p;
+extern struct editpolicy_directive directive_map[MAX_DIRECTIVE_TYPE];
+extern struct ccs_screen screen[MAX_SCREEN_TYPE];
 extern const struct ccs_path_info *ccs_current_ns;
Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_color.c
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_color.c	(revision 6401)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_color.c	(working copy)
@@ -26,45 +26,45 @@
 #ifdef COLOR_ON
 
 /**
- * ccs_editpolicy_color_init - Initialize line coloring table.
+ * editpolicy_color_init - Initialize line coloring table.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_color_init(void)
+void editpolicy_color_init(void)
 {
 	static struct ccs_color_env_t {
-		enum ccs_color_pair tag;
+		enum color_type tag;
 		short int fore;
 		short int back;
 		const char *name;
 	} color_env[] = {
-		{ CCS_DOMAIN_HEAD,      COLOR_BLACK,
+		{ COLOR_DOMAIN_HEAD,      COLOR_BLACK,
 		  COLOR_GREEN,      "DOMAIN_HEAD" },
-		{ CCS_DOMAIN_CURSOR,    COLOR_BLACK,
+		{ COLOR_DOMAIN_CURSOR,    COLOR_BLACK,
 		  COLOR_GREEN,      "DOMAIN_CURSOR" },
-		{ CCS_EXCEPTION_HEAD,   COLOR_BLACK,
+		{ COLOR_EXCEPTION_HEAD,   COLOR_BLACK,
 		  COLOR_CYAN,       "EXCEPTION_HEAD" },
-		{ CCS_EXCEPTION_CURSOR, COLOR_BLACK,
+		{ COLOR_EXCEPTION_CURSOR, COLOR_BLACK,
 		  COLOR_CYAN,       "EXCEPTION_CURSOR" },
-		{ CCS_ACL_HEAD,         COLOR_BLACK,
+		{ COLOR_ACL_HEAD,         COLOR_BLACK,
 		  COLOR_YELLOW,     "ACL_HEAD" },
-		{ CCS_ACL_CURSOR,       COLOR_BLACK,
+		{ COLOR_ACL_CURSOR,       COLOR_BLACK,
 		  COLOR_YELLOW,     "ACL_CURSOR" },
-		{ CCS_PROFILE_HEAD,     COLOR_WHITE,
+		{ COLOR_PROFILE_HEAD,     COLOR_WHITE,
 		  COLOR_RED,        "PROFILE_HEAD" },
-		{ CCS_PROFILE_CURSOR,   COLOR_WHITE,
+		{ COLOR_PROFILE_CURSOR,   COLOR_WHITE,
 		  COLOR_RED,        "PROFILE_CURSOR" },
-		{ CCS_MANAGER_HEAD,     COLOR_WHITE,
+		{ COLOR_MANAGER_HEAD,     COLOR_WHITE,
 		  COLOR_GREEN,      "MANAGER_HEAD" },
-		{ CCS_MANAGER_CURSOR,   COLOR_WHITE,
+		{ COLOR_MANAGER_CURSOR,   COLOR_WHITE,
 		  COLOR_GREEN,      "MANAGER_CURSOR" },
-		{ CCS_STAT_HEAD,        COLOR_BLACK,
+		{ COLOR_STAT_HEAD,        COLOR_BLACK,
 		  COLOR_YELLOW,     "STAT_HEAD" },
-		{ CCS_STAT_CURSOR,      COLOR_BLACK,
+		{ COLOR_STAT_CURSOR,      COLOR_BLACK,
 		  COLOR_YELLOW,     "STAT_CURSOR" },
-		{ CCS_DEFAULT_COLOR,    COLOR_WHITE,
+		{ COLOR_DEFAULT_COLOR,    COLOR_WHITE,
 		  COLOR_BLACK,      "DEFAULT_COLOR" },
-		{ CCS_NORMAL,           COLOR_WHITE,
+		{ COLOR_NORMAL,           COLOR_WHITE,
 		  COLOR_BLACK,      NULL }
 	};
 	FILE *fp = fopen(CCS_EDITPOLICY_CONF, "r");
@@ -111,22 +111,22 @@
 		struct ccs_color_env_t *colorp = &color_env[i];
 		init_pair(colorp->tag, colorp->fore, colorp->back);
 	}
-	init_pair(CCS_DISP_ERR, COLOR_RED, COLOR_BLACK); /* error message */
-	bkgdset(A_NORMAL | COLOR_PAIR(CCS_DEFAULT_COLOR) | ' ');
-	for (i = 0; i < CCS_MAXSCREEN; i++)
-		ccs_screen[i].saved_color_current = -1;
+	init_pair(COLOR_DISP_ERR, COLOR_RED, COLOR_BLACK); /* error message */
+	bkgdset(A_NORMAL | COLOR_PAIR(COLOR_DEFAULT_COLOR) | ' ');
+	for (i = 0; i < MAX_SCREEN_TYPE; i++)
+		screen[i].saved_color_current = -1;
 }
 
 /**
- * ccs_editpolicy_color_save - Save or load current color.
+ * editpolicy_color_save - Save or load current color.
  *
  * @flg: True if save request, false otherwise.
  *
  * Returns nothing.
  */
-static void ccs_editpolicy_color_save(const _Bool flg)
+static void editpolicy_color_save(const _Bool flg)
 {
-	static attr_t save_color = CCS_DEFAULT_COLOR;
+	static attr_t save_color = COLOR_DEFAULT_COLOR;
 	if (flg)
 		save_color = getattrs(stdscr);
 	else
@@ -134,14 +134,14 @@
 }
 
 /**
- * ccs_editpolicy_color_change - Change current color.
+ * editpolicy_color_change - Change current color.
  *
  * @attr: Coloe to use.
  * @flg:  True if turn on, false otherwise.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_color_change(const attr_t attr, const _Bool flg)
+void editpolicy_color_change(const attr_t attr, const _Bool flg)
 {
 	if (flg)
 		attron(COLOR_PAIR(attr));
@@ -150,14 +150,14 @@
 }
 
 /**
- * ccs_editpolicy_attr_change - Change current attribute.
+ * editpolicy_attr_change - Change current attribute.
  *
  * @attr: Coloe to use.
  * @flg:  True if turn on, false otherwise.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_attr_change(const attr_t attr, const _Bool flg)
+void editpolicy_attr_change(const attr_t attr, const _Bool flg)
 {
 	if (flg)
 		attron(attr);
@@ -166,80 +166,80 @@
 }
 
 /**
- * ccs_editpolicy_sttr_save - Save current color.
+ * editpolicy_sttr_save - Save current color.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_sttr_save(void)
+void editpolicy_sttr_save(void)
 {
-	ccs_editpolicy_color_save(true);
+	editpolicy_color_save(true);
 }
 
 /**
- * ccs_editpolicy_sttr_restore - Load current color.
+ * editpolicy_sttr_restore - Load current color.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_sttr_restore(void)
+void editpolicy_sttr_restore(void)
 {
-	ccs_editpolicy_color_save(false);
+	editpolicy_color_save(false);
 }
 
 /**
- * ccs_editpolicy_color_head - Get color to use for header line.
+ * editpolicy_color_head - Get color to use for header line.
  *
- * Returns one of values in "enum ccs_color_pair".
+ * Returns one of values in "enum color_type".
  */
-enum ccs_color_pair ccs_editpolicy_color_head(void)
+enum color_type editpolicy_color_head(void)
 {
-	switch (ccs_current_screen) {
-	case CCS_SCREEN_DOMAIN_LIST:
-		return CCS_DOMAIN_HEAD;
-	case CCS_SCREEN_EXCEPTION_LIST:
-		return CCS_EXCEPTION_HEAD;
-	case CCS_SCREEN_PROFILE_LIST:
-		return CCS_PROFILE_HEAD;
-	case CCS_SCREEN_MANAGER_LIST:
-		return CCS_MANAGER_HEAD;
-	case CCS_SCREEN_STAT_LIST:
-		return CCS_STAT_HEAD;
+	switch (active) {
+	case SCREEN_DOMAIN_LIST:
+		return COLOR_DOMAIN_HEAD;
+	case SCREEN_EXCEPTION_LIST:
+		return COLOR_EXCEPTION_HEAD;
+	case SCREEN_PROFILE_LIST:
+		return COLOR_PROFILE_HEAD;
+	case SCREEN_MANAGER_LIST:
+		return COLOR_MANAGER_HEAD;
+	case SCREEN_STAT_LIST:
+		return COLOR_STAT_HEAD;
 	default:
-		return CCS_ACL_HEAD;
+		return COLOR_ACL_HEAD;
 	}
 }
 
 /**
- * ccs_editpolicy_color_cursor - Get color to use for cursor line.
+ * editpolicy_color_cursor - Get color to use for cursor line.
  *
- * Returns one of values in "enum ccs_color_pair".
+ * Returns one of values in "enum color_type".
  */
-static inline enum ccs_color_pair ccs_editpolicy_color_cursor(void)
+static inline enum color_type editpolicy_color_cursor(void)
 {
-	switch (ccs_current_screen) {
-	case CCS_SCREEN_DOMAIN_LIST:
-		return CCS_DOMAIN_CURSOR;
-	case CCS_SCREEN_EXCEPTION_LIST:
-		return CCS_EXCEPTION_CURSOR;
-	case CCS_SCREEN_PROFILE_LIST:
-		return CCS_PROFILE_CURSOR;
-	case CCS_SCREEN_MANAGER_LIST:
-		return CCS_MANAGER_CURSOR;
-	case CCS_SCREEN_STAT_LIST:
-		return CCS_STAT_CURSOR;
+	switch (active) {
+	case SCREEN_DOMAIN_LIST:
+		return COLOR_DOMAIN_CURSOR;
+	case SCREEN_EXCEPTION_LIST:
+		return COLOR_EXCEPTION_CURSOR;
+	case SCREEN_PROFILE_LIST:
+		return COLOR_PROFILE_CURSOR;
+	case SCREEN_MANAGER_LIST:
+		return COLOR_MANAGER_CURSOR;
+	case SCREEN_STAT_LIST:
+		return COLOR_STAT_CURSOR;
 	default:
-		return CCS_ACL_CURSOR;
+		return COLOR_ACL_CURSOR;
 	}
 }
 
 /**
- * ccs_editpolicy_line_draw - Update colored line.
+ * editpolicy_line_draw - Update colored line.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_line_draw(void)
+void editpolicy_line_draw(void)
 {
-	struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
-	const int current = ccs_editpolicy_get_current();
+	struct ccs_screen *ptr = &screen[active];
+	const int current = editpolicy_get_current();
 	int y;
 	int x;
 
@@ -250,11 +250,11 @@
 	if (-1 < ptr->saved_color_current &&
 	    current != ptr->saved_color_current) {
 		move(CCS_HEADER_LINES + ptr->saved_color_y, 0);
-		chgat(-1, A_NORMAL, CCS_DEFAULT_COLOR, NULL);
+		chgat(-1, A_NORMAL, COLOR_DEFAULT_COLOR, NULL);
 	}
 
 	move(y, x);
-	chgat(-1, A_NORMAL, ccs_editpolicy_color_cursor(), NULL);
+	chgat(-1, A_NORMAL, editpolicy_color_cursor(), NULL);
 	touchwin(stdscr);
 
 	ptr->saved_color_current = current;
@@ -264,72 +264,72 @@
 #else
 
 /**
- * ccs_editpolicy_color_init - Initialize line coloring table.
+ * editpolicy_color_init - Initialize line coloring table.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_color_init(void)
+void editpolicy_color_init(void)
 {
 }
 
 /**
- * ccs_editpolicy_color_change - Change current color.
+ * editpolicy_color_change - Change current color.
  *
  * @attr: Coloe to use.
  * @flg:  True if turn on, false otherwise.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_color_change(const attr_t attr, const _Bool flg)
+void editpolicy_color_change(const attr_t attr, const _Bool flg)
 {
 }
 
 /**
- * ccs_editpolicy_attr_change - Change current attribute.
+ * editpolicy_attr_change - Change current attribute.
  *
  * @attr: Coloe to use.
  * @flg:  True if turn on, false otherwise.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_attr_change(const attr_t attr, const _Bool flg)
+void editpolicy_attr_change(const attr_t attr, const _Bool flg)
 {
 }
 
 /**
- * ccs_editpolicy_sttr_save - Save current color.
+ * editpolicy_sttr_save - Save current color.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_sttr_save(void)
+void editpolicy_sttr_save(void)
 {
 }
 
 /**
- * ccs_editpolicy_sttr_restore - Load current color.
+ * editpolicy_sttr_restore - Load current color.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_sttr_restore(void)
+void editpolicy_sttr_restore(void)
 {
 }
 
 /**
- * ccs_editpolicy_color_head - Get color to use for header line.
+ * editpolicy_color_head - Get color to use for header line.
  *
- * Returns one of values in "enum ccs_color_pair".
+ * Returns one of values in "enum color_type".
  */
-enum ccs_color_pair ccs_editpolicy_color_head(void)
+enum color_type editpolicy_color_head(void)
 {
-	return CCS_DEFAULT_COLOR;
+	return COLOR_DEFAULT_COLOR;
 }
 
 /**
- * ccs_editpolicy_line_draw - Update colored line.
+ * editpolicy_line_draw - Update colored line.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_line_draw(void)
+void editpolicy_line_draw(void)
 {
 }
 
Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_keyword.c
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_keyword.c	(revision 6401)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_keyword.c	(working copy)
@@ -24,368 +24,361 @@
 #include "editpolicy.h"
 
 /* keyword array for rewriting keywords upon display. */
-struct ccs_editpolicy_directive ccs_directives[CCS_MAX_DIRECTIVE_INDEX] = {
-	[CCS_DIRECTIVE_ACL_GROUP_000] = { "acl_group 0", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_001] = { "acl_group 1", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_002] = { "acl_group 2", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_003] = { "acl_group 3", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_004] = { "acl_group 4", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_005] = { "acl_group 5", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_006] = { "acl_group 6", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_007] = { "acl_group 7", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_008] = { "acl_group 8", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_009] = { "acl_group 9", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_010] = { "acl_group 10", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_011] = { "acl_group 11", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_012] = { "acl_group 12", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_013] = { "acl_group 13", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_014] = { "acl_group 14", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_015] = { "acl_group 15", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_016] = { "acl_group 16", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_017] = { "acl_group 17", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_018] = { "acl_group 18", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_019] = { "acl_group 19", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_020] = { "acl_group 20", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_021] = { "acl_group 21", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_022] = { "acl_group 22", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_023] = { "acl_group 23", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_024] = { "acl_group 24", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_025] = { "acl_group 25", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_026] = { "acl_group 26", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_027] = { "acl_group 27", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_028] = { "acl_group 28", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_029] = { "acl_group 29", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_030] = { "acl_group 30", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_031] = { "acl_group 31", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_032] = { "acl_group 32", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_033] = { "acl_group 33", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_034] = { "acl_group 34", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_035] = { "acl_group 35", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_036] = { "acl_group 36", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_037] = { "acl_group 37", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_038] = { "acl_group 38", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_039] = { "acl_group 39", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_040] = { "acl_group 40", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_041] = { "acl_group 41", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_042] = { "acl_group 42", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_043] = { "acl_group 43", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_044] = { "acl_group 44", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_045] = { "acl_group 45", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_046] = { "acl_group 46", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_047] = { "acl_group 47", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_048] = { "acl_group 48", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_049] = { "acl_group 49", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_050] = { "acl_group 50", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_051] = { "acl_group 51", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_052] = { "acl_group 52", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_053] = { "acl_group 53", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_054] = { "acl_group 54", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_055] = { "acl_group 55", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_056] = { "acl_group 56", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_057] = { "acl_group 57", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_058] = { "acl_group 58", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_059] = { "acl_group 59", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_060] = { "acl_group 60", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_061] = { "acl_group 61", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_062] = { "acl_group 62", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_063] = { "acl_group 63", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_064] = { "acl_group 64", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_065] = { "acl_group 65", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_066] = { "acl_group 66", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_067] = { "acl_group 67", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_068] = { "acl_group 68", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_069] = { "acl_group 69", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_070] = { "acl_group 70", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_071] = { "acl_group 71", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_072] = { "acl_group 72", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_073] = { "acl_group 73", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_074] = { "acl_group 74", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_075] = { "acl_group 75", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_076] = { "acl_group 76", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_077] = { "acl_group 77", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_078] = { "acl_group 78", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_079] = { "acl_group 79", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_080] = { "acl_group 80", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_081] = { "acl_group 81", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_082] = { "acl_group 82", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_083] = { "acl_group 83", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_084] = { "acl_group 84", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_085] = { "acl_group 85", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_086] = { "acl_group 86", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_087] = { "acl_group 87", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_088] = { "acl_group 88", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_089] = { "acl_group 89", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_090] = { "acl_group 90", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_091] = { "acl_group 91", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_092] = { "acl_group 92", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_093] = { "acl_group 93", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_094] = { "acl_group 94", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_095] = { "acl_group 95", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_096] = { "acl_group 96", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_097] = { "acl_group 97", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_098] = { "acl_group 98", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_099] = { "acl_group 99", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_100] = { "acl_group 100", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_101] = { "acl_group 101", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_102] = { "acl_group 102", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_103] = { "acl_group 103", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_104] = { "acl_group 104", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_105] = { "acl_group 105", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_106] = { "acl_group 106", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_107] = { "acl_group 107", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_108] = { "acl_group 108", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_109] = { "acl_group 109", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_110] = { "acl_group 110", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_111] = { "acl_group 111", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_112] = { "acl_group 112", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_113] = { "acl_group 113", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_114] = { "acl_group 114", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_115] = { "acl_group 115", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_116] = { "acl_group 116", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_117] = { "acl_group 117", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_118] = { "acl_group 118", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_119] = { "acl_group 119", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_120] = { "acl_group 120", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_121] = { "acl_group 121", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_122] = { "acl_group 122", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_123] = { "acl_group 123", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_124] = { "acl_group 124", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_125] = { "acl_group 125", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_126] = { "acl_group 126", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_127] = { "acl_group 127", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_128] = { "acl_group 128", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_129] = { "acl_group 129", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_130] = { "acl_group 130", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_131] = { "acl_group 131", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_132] = { "acl_group 132", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_133] = { "acl_group 133", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_134] = { "acl_group 134", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_135] = { "acl_group 135", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_136] = { "acl_group 136", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_137] = { "acl_group 137", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_138] = { "acl_group 138", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_139] = { "acl_group 139", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_140] = { "acl_group 140", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_141] = { "acl_group 141", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_142] = { "acl_group 142", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_143] = { "acl_group 143", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_144] = { "acl_group 144", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_145] = { "acl_group 145", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_146] = { "acl_group 146", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_147] = { "acl_group 147", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_148] = { "acl_group 148", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_149] = { "acl_group 149", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_150] = { "acl_group 150", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_151] = { "acl_group 151", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_152] = { "acl_group 152", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_153] = { "acl_group 153", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_154] = { "acl_group 154", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_155] = { "acl_group 155", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_156] = { "acl_group 156", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_157] = { "acl_group 157", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_158] = { "acl_group 158", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_159] = { "acl_group 159", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_160] = { "acl_group 160", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_161] = { "acl_group 161", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_162] = { "acl_group 162", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_163] = { "acl_group 163", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_164] = { "acl_group 164", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_165] = { "acl_group 165", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_166] = { "acl_group 166", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_167] = { "acl_group 167", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_168] = { "acl_group 168", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_169] = { "acl_group 169", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_170] = { "acl_group 170", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_171] = { "acl_group 171", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_172] = { "acl_group 172", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_173] = { "acl_group 173", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_174] = { "acl_group 174", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_175] = { "acl_group 175", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_176] = { "acl_group 176", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_177] = { "acl_group 177", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_178] = { "acl_group 178", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_179] = { "acl_group 179", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_180] = { "acl_group 180", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_181] = { "acl_group 181", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_182] = { "acl_group 182", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_183] = { "acl_group 183", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_184] = { "acl_group 184", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_185] = { "acl_group 185", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_186] = { "acl_group 186", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_187] = { "acl_group 187", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_188] = { "acl_group 188", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_189] = { "acl_group 189", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_190] = { "acl_group 190", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_191] = { "acl_group 191", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_192] = { "acl_group 192", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_193] = { "acl_group 193", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_194] = { "acl_group 194", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_195] = { "acl_group 195", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_196] = { "acl_group 196", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_197] = { "acl_group 197", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_198] = { "acl_group 198", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_199] = { "acl_group 199", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_200] = { "acl_group 200", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_201] = { "acl_group 201", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_202] = { "acl_group 202", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_203] = { "acl_group 203", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_204] = { "acl_group 204", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_205] = { "acl_group 205", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_206] = { "acl_group 206", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_207] = { "acl_group 207", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_208] = { "acl_group 208", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_209] = { "acl_group 209", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_210] = { "acl_group 210", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_211] = { "acl_group 211", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_212] = { "acl_group 212", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_213] = { "acl_group 213", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_214] = { "acl_group 214", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_215] = { "acl_group 215", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_216] = { "acl_group 216", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_217] = { "acl_group 217", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_218] = { "acl_group 218", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_219] = { "acl_group 219", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_220] = { "acl_group 220", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_221] = { "acl_group 221", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_222] = { "acl_group 222", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_223] = { "acl_group 223", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_224] = { "acl_group 224", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_225] = { "acl_group 225", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_226] = { "acl_group 226", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_227] = { "acl_group 227", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_228] = { "acl_group 228", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_229] = { "acl_group 229", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_230] = { "acl_group 230", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_231] = { "acl_group 231", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_232] = { "acl_group 232", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_233] = { "acl_group 233", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_234] = { "acl_group 234", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_235] = { "acl_group 235", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_236] = { "acl_group 236", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_237] = { "acl_group 237", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_238] = { "acl_group 238", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_239] = { "acl_group 239", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_240] = { "acl_group 240", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_241] = { "acl_group 241", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_242] = { "acl_group 242", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_243] = { "acl_group 243", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_244] = { "acl_group 244", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_245] = { "acl_group 245", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_246] = { "acl_group 246", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_247] = { "acl_group 247", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_248] = { "acl_group 248", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_249] = { "acl_group 249", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_250] = { "acl_group 250", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_251] = { "acl_group 251", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_252] = { "acl_group 252", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_253] = { "acl_group 253", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_254] = { "acl_group 254", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ACL_GROUP_255] = { "acl_group 255", NULL, 0, 0 },
-	[CCS_DIRECTIVE_ADDRESS_GROUP] = { "address_group", NULL, 0, 0 },
-	[CCS_DIRECTIVE_AGGREGATOR]    = { "aggregator", NULL, 0, 0 },
-	[CCS_DIRECTIVE_CAPABILITY]    = { "capability", NULL, 0, 0 },
-	[CCS_DIRECTIVE_DENY_AUTOBIND] = { "deny_autobind", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_APPEND]   = { "file append", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_CHGRP]    = { "file chgrp", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_CHMOD]    = { "file chmod", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_CHOWN]    = { "file chown", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_CHROOT]   = { "file chroot", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_CREATE]   = { "file create", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_EXECUTE]  = { "file execute", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_GETATTR]  = { "file getattr", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_IOCTL]    = { "file ioctl", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_LINK]     = { "file link", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MKBLOCK]  = { "file mkblock", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MKCHAR]   = { "file mkchar", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MKDIR]    = { "file mkdir", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MKFIFO]   = { "file mkfifo", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MKSOCK]   = { "file mksock", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_MOUNT]    = { "file mount", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_PIVOT_ROOT] = { "file pivot_root", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_READ]     = { "file read", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_RENAME]   = { "file rename", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_RMDIR]    = { "file rmdir", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_SYMLINK]  = { "file symlink", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_TRUNCATE] = { "file truncate", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_UNLINK]   = { "file unlink", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_UNMOUNT]  = { "file unmount", NULL, 0, 0 },
-	[CCS_DIRECTIVE_FILE_WRITE]    = { "file write", NULL, 0, 0 },
-	[CCS_DIRECTIVE_INITIALIZE_DOMAIN]
-	= { "initialize_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_IPC_SIGNAL]    = { "ipc signal", NULL, 0, 0 },
-	[CCS_DIRECTIVE_KEEP_DOMAIN]   = { "keep_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_MISC_ENV]      = { "misc env", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NETWORK_INET]  = { "network inet", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NETWORK_UNIX]  = { "network unix", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NONE]          = { "", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN]
+struct editpolicy_directive directive_map[MAX_DIRECTIVE_TYPE] = {
+	[DIRECTIVE_ACL_GROUP_000] = { "acl_group 0", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_001] = { "acl_group 1", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_002] = { "acl_group 2", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_003] = { "acl_group 3", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_004] = { "acl_group 4", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_005] = { "acl_group 5", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_006] = { "acl_group 6", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_007] = { "acl_group 7", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_008] = { "acl_group 8", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_009] = { "acl_group 9", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_010] = { "acl_group 10", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_011] = { "acl_group 11", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_012] = { "acl_group 12", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_013] = { "acl_group 13", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_014] = { "acl_group 14", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_015] = { "acl_group 15", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_016] = { "acl_group 16", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_017] = { "acl_group 17", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_018] = { "acl_group 18", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_019] = { "acl_group 19", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_020] = { "acl_group 20", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_021] = { "acl_group 21", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_022] = { "acl_group 22", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_023] = { "acl_group 23", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_024] = { "acl_group 24", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_025] = { "acl_group 25", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_026] = { "acl_group 26", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_027] = { "acl_group 27", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_028] = { "acl_group 28", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_029] = { "acl_group 29", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_030] = { "acl_group 30", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_031] = { "acl_group 31", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_032] = { "acl_group 32", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_033] = { "acl_group 33", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_034] = { "acl_group 34", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_035] = { "acl_group 35", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_036] = { "acl_group 36", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_037] = { "acl_group 37", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_038] = { "acl_group 38", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_039] = { "acl_group 39", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_040] = { "acl_group 40", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_041] = { "acl_group 41", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_042] = { "acl_group 42", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_043] = { "acl_group 43", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_044] = { "acl_group 44", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_045] = { "acl_group 45", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_046] = { "acl_group 46", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_047] = { "acl_group 47", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_048] = { "acl_group 48", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_049] = { "acl_group 49", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_050] = { "acl_group 50", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_051] = { "acl_group 51", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_052] = { "acl_group 52", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_053] = { "acl_group 53", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_054] = { "acl_group 54", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_055] = { "acl_group 55", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_056] = { "acl_group 56", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_057] = { "acl_group 57", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_058] = { "acl_group 58", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_059] = { "acl_group 59", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_060] = { "acl_group 60", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_061] = { "acl_group 61", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_062] = { "acl_group 62", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_063] = { "acl_group 63", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_064] = { "acl_group 64", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_065] = { "acl_group 65", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_066] = { "acl_group 66", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_067] = { "acl_group 67", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_068] = { "acl_group 68", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_069] = { "acl_group 69", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_070] = { "acl_group 70", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_071] = { "acl_group 71", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_072] = { "acl_group 72", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_073] = { "acl_group 73", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_074] = { "acl_group 74", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_075] = { "acl_group 75", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_076] = { "acl_group 76", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_077] = { "acl_group 77", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_078] = { "acl_group 78", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_079] = { "acl_group 79", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_080] = { "acl_group 80", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_081] = { "acl_group 81", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_082] = { "acl_group 82", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_083] = { "acl_group 83", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_084] = { "acl_group 84", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_085] = { "acl_group 85", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_086] = { "acl_group 86", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_087] = { "acl_group 87", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_088] = { "acl_group 88", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_089] = { "acl_group 89", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_090] = { "acl_group 90", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_091] = { "acl_group 91", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_092] = { "acl_group 92", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_093] = { "acl_group 93", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_094] = { "acl_group 94", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_095] = { "acl_group 95", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_096] = { "acl_group 96", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_097] = { "acl_group 97", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_098] = { "acl_group 98", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_099] = { "acl_group 99", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_100] = { "acl_group 100", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_101] = { "acl_group 101", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_102] = { "acl_group 102", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_103] = { "acl_group 103", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_104] = { "acl_group 104", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_105] = { "acl_group 105", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_106] = { "acl_group 106", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_107] = { "acl_group 107", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_108] = { "acl_group 108", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_109] = { "acl_group 109", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_110] = { "acl_group 110", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_111] = { "acl_group 111", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_112] = { "acl_group 112", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_113] = { "acl_group 113", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_114] = { "acl_group 114", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_115] = { "acl_group 115", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_116] = { "acl_group 116", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_117] = { "acl_group 117", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_118] = { "acl_group 118", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_119] = { "acl_group 119", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_120] = { "acl_group 120", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_121] = { "acl_group 121", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_122] = { "acl_group 122", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_123] = { "acl_group 123", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_124] = { "acl_group 124", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_125] = { "acl_group 125", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_126] = { "acl_group 126", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_127] = { "acl_group 127", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_128] = { "acl_group 128", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_129] = { "acl_group 129", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_130] = { "acl_group 130", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_131] = { "acl_group 131", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_132] = { "acl_group 132", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_133] = { "acl_group 133", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_134] = { "acl_group 134", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_135] = { "acl_group 135", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_136] = { "acl_group 136", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_137] = { "acl_group 137", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_138] = { "acl_group 138", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_139] = { "acl_group 139", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_140] = { "acl_group 140", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_141] = { "acl_group 141", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_142] = { "acl_group 142", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_143] = { "acl_group 143", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_144] = { "acl_group 144", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_145] = { "acl_group 145", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_146] = { "acl_group 146", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_147] = { "acl_group 147", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_148] = { "acl_group 148", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_149] = { "acl_group 149", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_150] = { "acl_group 150", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_151] = { "acl_group 151", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_152] = { "acl_group 152", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_153] = { "acl_group 153", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_154] = { "acl_group 154", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_155] = { "acl_group 155", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_156] = { "acl_group 156", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_157] = { "acl_group 157", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_158] = { "acl_group 158", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_159] = { "acl_group 159", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_160] = { "acl_group 160", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_161] = { "acl_group 161", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_162] = { "acl_group 162", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_163] = { "acl_group 163", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_164] = { "acl_group 164", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_165] = { "acl_group 165", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_166] = { "acl_group 166", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_167] = { "acl_group 167", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_168] = { "acl_group 168", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_169] = { "acl_group 169", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_170] = { "acl_group 170", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_171] = { "acl_group 171", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_172] = { "acl_group 172", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_173] = { "acl_group 173", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_174] = { "acl_group 174", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_175] = { "acl_group 175", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_176] = { "acl_group 176", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_177] = { "acl_group 177", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_178] = { "acl_group 178", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_179] = { "acl_group 179", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_180] = { "acl_group 180", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_181] = { "acl_group 181", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_182] = { "acl_group 182", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_183] = { "acl_group 183", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_184] = { "acl_group 184", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_185] = { "acl_group 185", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_186] = { "acl_group 186", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_187] = { "acl_group 187", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_188] = { "acl_group 188", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_189] = { "acl_group 189", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_190] = { "acl_group 190", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_191] = { "acl_group 191", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_192] = { "acl_group 192", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_193] = { "acl_group 193", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_194] = { "acl_group 194", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_195] = { "acl_group 195", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_196] = { "acl_group 196", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_197] = { "acl_group 197", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_198] = { "acl_group 198", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_199] = { "acl_group 199", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_200] = { "acl_group 200", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_201] = { "acl_group 201", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_202] = { "acl_group 202", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_203] = { "acl_group 203", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_204] = { "acl_group 204", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_205] = { "acl_group 205", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_206] = { "acl_group 206", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_207] = { "acl_group 207", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_208] = { "acl_group 208", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_209] = { "acl_group 209", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_210] = { "acl_group 210", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_211] = { "acl_group 211", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_212] = { "acl_group 212", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_213] = { "acl_group 213", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_214] = { "acl_group 214", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_215] = { "acl_group 215", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_216] = { "acl_group 216", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_217] = { "acl_group 217", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_218] = { "acl_group 218", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_219] = { "acl_group 219", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_220] = { "acl_group 220", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_221] = { "acl_group 221", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_222] = { "acl_group 222", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_223] = { "acl_group 223", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_224] = { "acl_group 224", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_225] = { "acl_group 225", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_226] = { "acl_group 226", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_227] = { "acl_group 227", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_228] = { "acl_group 228", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_229] = { "acl_group 229", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_230] = { "acl_group 230", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_231] = { "acl_group 231", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_232] = { "acl_group 232", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_233] = { "acl_group 233", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_234] = { "acl_group 234", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_235] = { "acl_group 235", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_236] = { "acl_group 236", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_237] = { "acl_group 237", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_238] = { "acl_group 238", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_239] = { "acl_group 239", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_240] = { "acl_group 240", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_241] = { "acl_group 241", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_242] = { "acl_group 242", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_243] = { "acl_group 243", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_244] = { "acl_group 244", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_245] = { "acl_group 245", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_246] = { "acl_group 246", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_247] = { "acl_group 247", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_248] = { "acl_group 248", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_249] = { "acl_group 249", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_250] = { "acl_group 250", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_251] = { "acl_group 251", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_252] = { "acl_group 252", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_253] = { "acl_group 253", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_254] = { "acl_group 254", NULL, 0, 0 },
+	[DIRECTIVE_ACL_GROUP_255] = { "acl_group 255", NULL, 0, 0 },
+	[DIRECTIVE_ADDRESS_GROUP] = { "address_group", NULL, 0, 0 },
+	[DIRECTIVE_AGGREGATOR]    = { "aggregator", NULL, 0, 0 },
+	[DIRECTIVE_CAPABILITY]    = { "capability", NULL, 0, 0 },
+	[DIRECTIVE_DENY_AUTOBIND] = { "deny_autobind", NULL, 0, 0 },
+	[DIRECTIVE_FILE_APPEND]   = { "file append", NULL, 0, 0 },
+	[DIRECTIVE_FILE_CHGRP]    = { "file chgrp", NULL, 0, 0 },
+	[DIRECTIVE_FILE_CHMOD]    = { "file chmod", NULL, 0, 0 },
+	[DIRECTIVE_FILE_CHOWN]    = { "file chown", NULL, 0, 0 },
+	[DIRECTIVE_FILE_CHROOT]   = { "file chroot", NULL, 0, 0 },
+	[DIRECTIVE_FILE_CREATE]   = { "file create", NULL, 0, 0 },
+	[DIRECTIVE_FILE_EXECUTE]  = { "file execute", NULL, 0, 0 },
+	[DIRECTIVE_FILE_GETATTR]  = { "file getattr", NULL, 0, 0 },
+	[DIRECTIVE_FILE_IOCTL]    = { "file ioctl", NULL, 0, 0 },
+	[DIRECTIVE_FILE_LINK]     = { "file link", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MKBLOCK]  = { "file mkblock", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MKCHAR]   = { "file mkchar", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MKDIR]    = { "file mkdir", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MKFIFO]   = { "file mkfifo", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MKSOCK]   = { "file mksock", NULL, 0, 0 },
+	[DIRECTIVE_FILE_MOUNT]    = { "file mount", NULL, 0, 0 },
+	[DIRECTIVE_FILE_PIVOT_ROOT] = { "file pivot_root", NULL, 0, 0 },
+	[DIRECTIVE_FILE_READ]     = { "file read", NULL, 0, 0 },
+	[DIRECTIVE_FILE_RENAME]   = { "file rename", NULL, 0, 0 },
+	[DIRECTIVE_FILE_RMDIR]    = { "file rmdir", NULL, 0, 0 },
+	[DIRECTIVE_FILE_SYMLINK]  = { "file symlink", NULL, 0, 0 },
+	[DIRECTIVE_FILE_TRUNCATE] = { "file truncate", NULL, 0, 0 },
+	[DIRECTIVE_FILE_UNLINK]   = { "file unlink", NULL, 0, 0 },
+	[DIRECTIVE_FILE_UNMOUNT]  = { "file unmount", NULL, 0, 0 },
+	[DIRECTIVE_FILE_WRITE]    = { "file write", NULL, 0, 0 },
+	[DIRECTIVE_INITIALIZE_DOMAIN] = { "initialize_domain", NULL, 0, 0 },
+	[DIRECTIVE_IPC_SIGNAL]    = { "ipc signal", NULL, 0, 0 },
+	[DIRECTIVE_KEEP_DOMAIN]   = { "keep_domain", NULL, 0, 0 },
+	[DIRECTIVE_MISC_ENV]      = { "misc env", NULL, 0, 0 },
+	[DIRECTIVE_NETWORK_INET]  = { "network inet", NULL, 0, 0 },
+	[DIRECTIVE_NETWORK_UNIX]  = { "network unix", NULL, 0, 0 },
+	[DIRECTIVE_NONE]          = { "", NULL, 0, 0 },
+	[DIRECTIVE_NO_INITIALIZE_DOMAIN]
 	= { "no_initialize_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NO_KEEP_DOMAIN] = { "no_keep_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NO_RESET_DOMAIN] = { "no_reset_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_NUMBER_GROUP]  = { "number_group", NULL, 0, 0 },
-	[CCS_DIRECTIVE_PATH_GROUP]    = { "path_group", NULL, 0, 0 },
-	[CCS_DIRECTIVE_QUOTA_EXCEEDED] = { "quota_exceeded", NULL, 0, 0 },
-	[CCS_DIRECTIVE_RESET_DOMAIN]  = { "reset_domain", NULL, 0, 0 },
-	[CCS_DIRECTIVE_TASK_AUTO_DOMAIN_TRANSITION]
+	[DIRECTIVE_NO_KEEP_DOMAIN] = { "no_keep_domain", NULL, 0, 0 },
+	[DIRECTIVE_NO_RESET_DOMAIN] = { "no_reset_domain", NULL, 0, 0 },
+	[DIRECTIVE_NUMBER_GROUP]  = { "number_group", NULL, 0, 0 },
+	[DIRECTIVE_PATH_GROUP]    = { "path_group", NULL, 0, 0 },
+	[DIRECTIVE_QUOTA_EXCEEDED] = { "quota_exceeded", NULL, 0, 0 },
+	[DIRECTIVE_RESET_DOMAIN]  = { "reset_domain", NULL, 0, 0 },
+	[DIRECTIVE_TASK_AUTO_DOMAIN_TRANSITION]
 	= { "task auto_domain_transition", NULL, 0, 0 },
-	[CCS_DIRECTIVE_TASK_AUTO_EXECUTE_HANDLER]
+	[DIRECTIVE_TASK_AUTO_EXECUTE_HANDLER]
 	= { "task auto_execute_handler", NULL, 0, 0 },
-	[CCS_DIRECTIVE_TASK_DENIED_EXECUTE_HANDLER]
+	[DIRECTIVE_TASK_DENIED_EXECUTE_HANDLER]
 	= { "task denied_execute_handler", NULL, 0, 0 },
-	[CCS_DIRECTIVE_TASK_MANUAL_DOMAIN_TRANSITION]
+	[DIRECTIVE_TASK_MANUAL_DOMAIN_TRANSITION]
 	= { "task manual_domain_transition", NULL, 0, 0 },
-	[CCS_DIRECTIVE_TRANSITION_FAILED]
+	[DIRECTIVE_TRANSITION_FAILED]
 	= { "transition_failed", NULL, 0, 0 },
-	[CCS_DIRECTIVE_USE_GROUP]     = { "use_group", NULL, 0, 0 },
-	[CCS_DIRECTIVE_USE_PROFILE]   = { "use_profile", NULL, 0, 0 },
+	[DIRECTIVE_USE_GROUP]     = { "use_group", NULL, 0, 0 },
+	[DIRECTIVE_USE_PROFILE]   = { "use_profile", NULL, 0, 0 },
 };
 
 /**
- * ccs_find_directive - Find keyword index.
+ * find_directive - Find keyword index.
  *
  * @forward: True if original -> alias conversion, false otherwise.
  * @line: A line containing keyword and operand.
  *
- * Returns one of values in "enum ccs_editpolicy_directives".
+ * Returns one of values in "enum directive_type".
  */
-enum ccs_editpolicy_directives ccs_find_directive(const _Bool forward,
-						  char *line)
+enum directive_type find_directive(const _Bool forward, char *line)
 {
-	u16 i;
-	for (i = 1; i < CCS_MAX_DIRECTIVE_INDEX; i++) {
+	enum directive_type i;
+	for (i = 1; i < MAX_DIRECTIVE_TYPE; i++) {
+		int len;
 		if (forward) {
-			const int len = ccs_directives[i].original_len;
-			if (strncmp(line, ccs_directives[i].original, len) ||
+			len = directive_map[i].original_len;
+			if (strncmp(line, directive_map[i].original, len) ||
 			    (line[len] != ' ' && line[len]))
 				continue;
-			if (line[len])
-				memmove(line, line + len + 1,
-					strlen(line + len + 1) + 1);
-			else
-				line[0] = '\0';
-			return i;
 		} else {
-			const int len = ccs_directives[i].alias_len;
-			if (strncmp(line, ccs_directives[i].alias, len) ||
+			len = directive_map[i].alias_len;
+			if (strncmp(line, directive_map[i].alias, len) ||
 			    (line[len] != ' ' && line[len]))
 				continue;
-			if (line[len])
-				memmove(line, line + len + 1,
-					strlen(line + len + 1) + 1);
-			else
-				line[0] = '\0';
-			return i;
 		}
+		if (line[len])
+			memmove(line, line + len + 1,
+				strlen(line + len + 1) + 1);
+		else
+			line[0] = '\0';
+		return i;
 	}
-	return CCS_DIRECTIVE_NONE;
+	return DIRECTIVE_NONE;
 }
 
 /**
- * ccs_editpolicy_init_keyword_map - Initialize keyword mapping table.
+ * editpolicy_init_keyword_map - Initialize keyword mapping table.
  *
  * Returns nothing.
  */
-void ccs_editpolicy_init_keyword_map(void)
+void editpolicy_init_keyword_map(void)
 {
 	FILE *fp = fopen(CCS_EDITPOLICY_CONF, "r");
 	int i;
@@ -407,24 +400,24 @@
 		ccs_normalize_line(cp);
 		if (!*line || !*cp)
 			continue;
-		for (i = 1; i < CCS_MAX_DIRECTIVE_INDEX; i++) {
-			if (strcmp(line, ccs_directives[i].original))
+		for (i = 1; i < MAX_DIRECTIVE_TYPE; i++) {
+			if (strcmp(line, directive_map[i].original))
 				continue;
-			free((void *) ccs_directives[i].alias);
+			free((void *) directive_map[i].alias);
 			cp = ccs_strdup(cp);
-			ccs_directives[i].alias = cp;
-			ccs_directives[i].alias_len = strlen(cp);
+			directive_map[i].alias = cp;
+			directive_map[i].alias_len = strlen(cp);
 			break;
 		}
 	}
 	ccs_put();
 	fclose(fp);
 use_default:
-	for (i = 1; i < CCS_MAX_DIRECTIVE_INDEX; i++) {
-		if (!ccs_directives[i].alias)
-			ccs_directives[i].alias = ccs_directives[i].original;
-		ccs_directives[i].original_len =
-			strlen(ccs_directives[i].original);
-		ccs_directives[i].alias_len = strlen(ccs_directives[i].alias);
+	for (i = 1; i < MAX_DIRECTIVE_TYPE; i++) {
+		if (!directive_map[i].alias)
+			directive_map[i].alias = directive_map[i].original;
+		directive_map[i].original_len =
+			strlen(directive_map[i].original);
+		directive_map[i].alias_len = strlen(directive_map[i].alias);
 	}
 }
Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_offline.c
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_offline.c	(revision 6401)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_offline.c	(working copy)
@@ -1129,13 +1129,13 @@
 };
 
 /* String table for domain transition control keywords. */
-static const char * const ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
-	[CCS_TRANSITION_CONTROL_NO_RESET]      = "no_reset_domain ",
-	[CCS_TRANSITION_CONTROL_RESET]         = "reset_domain ",
-	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
-	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
-	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
-	[CCS_TRANSITION_CONTROL_KEEP]          = "keep_domain ",
+static const char * const ccs_transition_type[MAX_TRANSITION_TYPE] = {
+	[TRANSITION_NO_RESET]      = "no_reset_domain ",
+	[TRANSITION_RESET]         = "reset_domain ",
+	[TRANSITION_NO_INITIALIZE] = "no_initialize_domain ",
+	[TRANSITION_INITIALIZE]    = "initialize_domain ",
+	[TRANSITION_NO_KEEP]       = "no_keep_domain ",
+	[TRANSITION_KEEP]          = "keep_domain ",
 };
 
 /* String table for grouping keywords. */
@@ -2353,8 +2353,8 @@
 	if (domainname) {
 		*domainname = '\0';
 		domainname += 6;
-	} else if (type == CCS_TRANSITION_CONTROL_NO_KEEP ||
-		   type == CCS_TRANSITION_CONTROL_KEEP) {
+	} else if (type == TRANSITION_NO_KEEP ||
+		   type == TRANSITION_KEEP) {
 		domainname = program;
 		program = NULL;
 	}
@@ -4471,7 +4471,7 @@
 		return ccs_write_aggregator(&param);
 	if (ccs_str_starts(param.data, "deny_autobind "))
 		return ccs_write_reserved_port(&param);
-	for (i = 0; i < CCS_MAX_TRANSITION_TYPE; i++)
+	for (i = 0; i < MAX_TRANSITION_TYPE; i++)
 		if (ccs_str_starts(param.data, ccs_transition_type[i]))
 			return ccs_write_transition_control(&param, i);
 	for (i = 0; i < CCS_MAX_GROUP; i++)
@@ -4743,11 +4743,11 @@
 }
 
 /**
- * ccs_editpolicy_offline_init - Initialize variables for offline daemon.
+ * editpolicy_offline_init - Initialize variables for offline daemon.
  *
  * Returns nothing.
  */
-static void ccs_editpolicy_offline_init(void)
+static void editpolicy_offline_init(void)
 {
 	static _Bool first = true;
 	int i;
@@ -4772,17 +4772,17 @@
 }
 
 /**
- * ccs_editpolicy_offline_main - Read request and handle policy I/O.
+ * editpolicy_offline_main - Read request and handle policy I/O.
  *
  * @fd: Socket file descriptor. 
  *
  * Returns nothing.
  */
-static void ccs_editpolicy_offline_main(const int fd)
+static void editpolicy_offline_main(const int fd)
 {
 	int i;
 	static char buffer[4096];
-	ccs_editpolicy_offline_init();
+	editpolicy_offline_init();
 	/* Read filename. */
 	for (i = 0; i < sizeof(buffer); i++) {
 		if (read(fd, buffer + i, 1) != 1)
@@ -4857,14 +4857,14 @@
 }
 
 /**
- * ccs_editpolicy_offline_daemon - Emulate /proc/ccs/ interface.
+ * editpolicy_offline_daemon - Emulate /proc/ccs/ interface.
  *
  * @listener: Listener fd. This is a listening PF_INET socket.
  * @notifier: Notifier fd. This is a pipe's reader side.
  *
  * This function does not return.
  */
-void ccs_editpolicy_offline_daemon(const int listener, const int notifier)
+void editpolicy_offline_daemon(const int listener, const int notifier)
 {
 	while (1) {
 		struct pollfd pfd[2] = {
@@ -4880,7 +4880,7 @@
 		fd = accept(listener, (struct sockaddr *) &addr, &size);
 		if (fd == EOF)
 			continue;
-		ccs_editpolicy_offline_main(fd);
+		editpolicy_offline_main(fd);
 		close(fd);
 	}
 }
Index: trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_optimizer.c
===================================================================
--- trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_optimizer.c	(revision 6401)
+++ trunk/1.8.x/ccs-tools/usr_sbin/editpolicy_optimizer.c	(working copy)
@@ -23,64 +23,58 @@
 #include "ccstools.h"
 #include "editpolicy.h"
 
-static struct ccs_address_group_entry *ccs_find_address_group
-(const char *group_name);
-static struct ccs_number_group_entry *ccs_find_number_group
-(const char *group_name);
-static _Bool ccs_compare_address(const char *sarg, const char *darg);
-static _Bool ccs_compare_number(const char *sarg, const char *darg);
-static _Bool ccs_compare_path(const char *sarg, const char *darg);
+static struct address_group *find_address_group(const char *group_name);
+static struct number_group *find_number_group(const char *group_name);
+static _Bool compare_address(const char *sarg, const char *darg);
+static _Bool compare_number(const char *sarg, const char *darg);
+static _Bool compare_path(const char *sarg, const char *darg);
 
 /**
- * ccs_find_address_group - Find an "address_group" by name.
+ * find_address_group - Find an "address_group" by name.
  *
  * @group_name: Group name to find.
  *
- * Returns pointer to "struct ccs_address_group_entry" if found,
+ * Returns pointer to "struct address_group" if found,
  * NULL otherwise.
  */
-static struct ccs_address_group_entry *ccs_find_address_group
-(const char *group_name)
+static struct address_group *find_address_group(const char *group_name)
 {
 	int i;
-	for (i = 0; i < ccs_address_group_list_len; i++)
-		if (!strcmp(group_name,
-			    ccs_address_group_list[i].group_name->name))
-			return &ccs_address_group_list[i];
+	for (i = 0; i < p.address_group_len; i++)
+		if (!strcmp(group_name, p.address_group[i].group_name->name))
+			return &p.address_group[i];
 	return NULL;
 }
 
 /**
- * ccs_find_number_group - Find an "number_group" by name.
+ * find_number_group - Find an "number_group" by name.
  *
  * @group_name: Group name to find.
  *
- * Returns pointer to "struct ccs_number_group_entry" if found,
+ * Returns pointer to "struct number_group" if found,
  * NULL otherwise.
  */
-static struct ccs_number_group_entry *ccs_find_number_group
-(const char *group_name)
+static struct number_group *find_number_group(const char *group_name)
 {
 	int i;
-	for (i = 0; i < ccs_number_group_list_len; i++)
-		if (!strcmp(group_name,
-			    ccs_number_group_list[i].group_name->name))
-			return &ccs_number_group_list[i];
+	for (i = 0; i < p.number_group_len; i++)
+		if (!strcmp(group_name, p.number_group[i].group_name->name))
+			return &p.number_group[i];
 	return NULL;
 }
 
 /**
- * ccs_compare_path - Compare two pathnames.
+ * compare_path - Compare two pathnames.
  *
  * @sarg: First pathname. Maybe wildcard.
  * @darg: Second pathname.
  *
  * Returns true if @darg is included in @sarg, false otherwise.
  */
-static _Bool ccs_compare_path(const char *sarg, const char *darg)
+static _Bool compare_path(const char *sarg, const char *darg)
 {
 	int i;
-	struct ccs_path_group_entry *group;
+	struct path_group *group;
 	struct ccs_path_info s;
 	struct ccs_path_info d;
 	s.name = sarg;
@@ -95,7 +89,7 @@
 		/* Pathname component. */
 		return ccs_path_matches_pattern(&d, &s);
 	/* path_group component. */
-	group = ccs_find_path_group_ns(ccs_current_ns, s.name + 1);
+	group = find_path_group_ns(ccs_current_ns, s.name + 1);
 	if (!group)
 		return false;
 	for (i = 0; i < group->member_name_len; i++) {
@@ -110,19 +104,19 @@
 }
 
 /**
- * ccs_compare_address - Compare two IPv4/v6 addresses.
+ * compare_address - Compare two IPv4/v6 addresses.
  *
  * @sarg: First address.
  * @darg: Second address.
  *
  * Returns true if @darg is included in @sarg, false otherwise.
  */
-static _Bool ccs_compare_address(const char *sarg, const char *darg)
+static _Bool compare_address(const char *sarg, const char *darg)
 {
 	int i;
 	struct ccs_ip_address_entry sentry;
 	struct ccs_ip_address_entry dentry;
-	struct ccs_address_group_entry *group;
+	struct address_group *group;
 	if (ccs_parse_ip(darg, &dentry))
 		return false;
 	if (sarg[0] != '@') {
@@ -136,7 +130,7 @@
 		return true;
 	}
 	/* IP address group component. */
-	group = ccs_find_address_group(sarg + 1);
+	group = find_address_group(sarg + 1);
 	if (!group)
 		return false;
 	for (i = 0; i < group->member_name_len; i++) {
@@ -154,51 +148,50 @@
  *
  * @buffer: Line to tokenize.
  * @w:      A "char *" array with 5 elements.
- * @index:  One of values in "enum ccs_editpolicy_directives".
+ * @index:  One of values in "enum directive_type".
  *
  * Returns nothing.
  */
-static void ccs_tokenize(char *buffer, char *w[5],
-			 enum ccs_editpolicy_directives index)
+static void ccs_tokenize(char *buffer, char *w[5], enum directive_type index)
 {
 	u8 i;
 	u8 words;
 	switch (index) {
-	case CCS_DIRECTIVE_FILE_MKBLOCK:
-	case CCS_DIRECTIVE_FILE_MKCHAR:
-	case CCS_DIRECTIVE_FILE_MOUNT:
-	case CCS_DIRECTIVE_NETWORK_INET:
+	case DIRECTIVE_FILE_MKBLOCK:
+	case DIRECTIVE_FILE_MKCHAR:
+	case DIRECTIVE_FILE_MOUNT:
+	case DIRECTIVE_NETWORK_INET:
 		words = 4;
 		break;
-	case CCS_DIRECTIVE_NETWORK_UNIX:
+	case DIRECTIVE_NETWORK_UNIX:
 		words = 3;
 		break;
-	case CCS_DIRECTIVE_FILE_CREATE:
-	case CCS_DIRECTIVE_FILE_MKDIR:
-	case CCS_DIRECTIVE_FILE_MKFIFO:
-	case CCS_DIRECTIVE_FILE_MKSOCK:
-	case CCS_DIRECTIVE_FILE_IOCTL:
-	case CCS_DIRECTIVE_FILE_CHMOD:
-	case CCS_DIRECTIVE_FILE_CHOWN:
-	case CCS_DIRECTIVE_FILE_CHGRP:
-	case CCS_DIRECTIVE_FILE_LINK:
-	case CCS_DIRECTIVE_FILE_RENAME:
-	case CCS_DIRECTIVE_FILE_PIVOT_ROOT:
-	case CCS_DIRECTIVE_IPC_SIGNAL:
+	case DIRECTIVE_FILE_CREATE:
+	case DIRECTIVE_FILE_MKDIR:
+	case DIRECTIVE_FILE_MKFIFO:
+	case DIRECTIVE_FILE_MKSOCK:
+	case DIRECTIVE_FILE_IOCTL:
+	case DIRECTIVE_FILE_CHMOD:
+	case DIRECTIVE_FILE_CHOWN:
+	case DIRECTIVE_FILE_CHGRP:
+	case DIRECTIVE_FILE_LINK:
+	case DIRECTIVE_FILE_RENAME:
+	case DIRECTIVE_FILE_PIVOT_ROOT:
+	case DIRECTIVE_IPC_SIGNAL:
 		words = 2;
 		break;
-	case CCS_DIRECTIVE_FILE_EXECUTE:
-	case CCS_DIRECTIVE_FILE_READ:
-	case CCS_DIRECTIVE_FILE_WRITE:
-	case CCS_DIRECTIVE_FILE_UNLINK:
-	case CCS_DIRECTIVE_FILE_GETATTR:
-	case CCS_DIRECTIVE_FILE_RMDIR:
-	case CCS_DIRECTIVE_FILE_TRUNCATE:
-	case CCS_DIRECTIVE_FILE_APPEND:
-	case CCS_DIRECTIVE_FILE_UNMOUNT:
-	case CCS_DIRECTIVE_FILE_CHROOT:
-	case CCS_DIRECTIVE_FILE_SYMLINK:
-	case CCS_DIRECTIVE_MISC_ENV:
+	case DIRECTIVE_FILE_EXECUTE:
+	case DIRECTIVE_FILE_READ:
+	case DIRECTIVE_FILE_WRITE:
+	case DIRECTIVE_FILE_UNLINK:
+	case DIRECTIVE_FILE_GETATTR:
+	case DIRECTIVE_FILE_RMDIR:
+	case DIRECTIVE_FILE_TRUNCATE:
+	case DIRECTIVE_FILE_APPEND:
+	case DIRECTIVE_FILE_UNMOUNT:
+	case DIRECTIVE_FILE_CHROOT:
+	case DIRECTIVE_FILE_SYMLINK:
+	case DIRECTIVE_MISC_ENV:
 		words = 1;
 		break;
 	default:
@@ -212,7 +205,7 @@
 		w[i] = buffer;
 		if (!cp)
 			return;
-		if (index == CCS_DIRECTIVE_IPC_SIGNAL && i == 1 &&
+		if (index == DIRECTIVE_IPC_SIGNAL && i == 1 &&
 		    ccs_domain_def(buffer)) {
 			cp = strchr(buffer, ' ');
 			if (!cp)
@@ -230,7 +223,7 @@
 		buffer = cp + 1;
 	}
 	w[4] = buffer;
-	if (index != CCS_DIRECTIVE_FILE_EXECUTE)
+	if (index != DIRECTIVE_FILE_EXECUTE)
 		return;
 	if (ccs_domain_def(buffer)) {
 		char *cp = strchr(buffer, ' ');
@@ -253,9 +246,8 @@
 		if (cp)
 			*cp = '\0';
 		if (ccs_correct_path(buffer) || !strcmp(buffer, "keep") ||
-		    !strcmp(buffer, "reset") ||
-		    !strcmp(buffer, "initialize") ||
-		    !strcmp(buffer, "child") || !strcmp(buffer, "parent")) {
+		    !strcmp(buffer, "reset") || !strcmp(buffer, "initialize")
+		    || !strcmp(buffer, "child") || !strcmp(buffer, "parent")) {
 			w[1] = buffer;
 			if (cp)
 				w[4] = cp + 1;
@@ -269,19 +261,19 @@
 }
 
 /**
- * ccs_compare_number - Compare two numeric values.
+ * compare_number - Compare two numeric values.
  *
  * @sarg: First number.
  * @darg: Second number.
  *
  * Returns true if @darg is included in @sarg, false otherwise.
  */
-static _Bool ccs_compare_number(const char *sarg, const char *darg)
+static _Bool compare_number(const char *sarg, const char *darg)
 {
 	int i;
 	struct ccs_number_entry sentry;
 	struct ccs_number_entry dentry;
-	struct ccs_number_group_entry *group;
+	struct number_group *group;
 	if (ccs_parse_number(darg, &dentry))
 		return false;
 	if (sarg[0] != '@') {
@@ -293,7 +285,7 @@
 		return true;
 	}
 	/* Number group component. */
-	group = ccs_find_number_group(sarg + 1);
+	group = find_number_group(sarg + 1);
 	if (!group)
 		return false;
 	for (i = 0; i < group->member_name_len; i++) {
@@ -306,47 +298,46 @@
 }
 
 /**
- * ccs_editpolicy_do_optimize - Try to merge entries included in other entries.
+ * editpolicy_do_optimize - Try to merge entries included in other entries.
  *
- * @cp:                A line containing operand.
- * @s_index:           Type of entry.
- * @s_index2:          Type of entry.
- * @is_exception_list: True if optimizing acl_group, false otherwise.
+ * @cp:           A line containing operand.
+ * @s_index:      Type of entry.
+ * @s_index2:     Type of entry.
+ * @is_acl_group: True if optimizing acl_group, false otherwise.
  *
  * Returns nothing.
  */
-static void ccs_editpolicy_do_optimize(char *cp, const int current,
-				       enum ccs_editpolicy_directives s_index,
-				       enum ccs_editpolicy_directives s_index2,
-				       const bool is_exception_list)
+static void editpolicy_do_optimize(char *cp, const int current,
+				   enum directive_type s_index,
+				   enum directive_type s_index2,
+				   const bool is_acl_group)
 {
 	int index;
 	char *s[5];
 	char *d[5];
 	ccs_tokenize(cp, s, s_index);
 	ccs_get();
-	for (index = 0; index < ccs_list_item_count; index++) {
+	for (index = 0; index < p.generic_len; index++) {
 		char *line;
-		enum ccs_editpolicy_directives d_index =
-			ccs_gacl_list[index].directive;
-		enum ccs_editpolicy_directives d_index2;
+		enum directive_type d_index = p.generic[index].directive;
+		enum directive_type d_index2;
 		if (index == current)
 			/* Skip source. */
 			continue;
-		if (ccs_gacl_list[index].selected)
+		if (p.generic[index].selected)
 			/* Dest already selected. */
 			continue;
 		else if (s_index == s_index2 && s_index != d_index)
 			/* Source and dest have different directive. */
 			continue;
-		else if (is_exception_list && s_index2 != d_index)
+		else if (is_acl_group && s_index2 != d_index)
 			/* Source and dest have different directive. */
 			continue;
 		/* Source and dest have same directive. */
-		line = ccs_shprintf("%s", ccs_gacl_list[index].operand);
+		line = ccs_shprintf("%s", p.generic[index].operand);
 		d_index2 = d_index;
-		if (is_exception_list)
-			d_index = ccs_find_directive(true, line);
+		if (is_acl_group)
+			d_index = find_directive(true, line);
 		if (s_index != d_index || s_index2 != d_index2)
 			/* Source and dest have different directive. */
 			continue;
@@ -365,55 +356,55 @@
 			struct ccs_path_info darg;
 			char c;
 			int len;
-		case CCS_DIRECTIVE_FILE_EXECUTE:
-			if (!ccs_compare_path(s[0], d[0]))
+		case DIRECTIVE_FILE_EXECUTE:
+			if (!compare_path(s[0], d[0]))
 				continue;
 			if (strcmp(s[1], d[1]))
 				continue;
 			break;
-		case CCS_DIRECTIVE_FILE_MKBLOCK:
-		case CCS_DIRECTIVE_FILE_MKCHAR:
-			if (!ccs_compare_number(s[3], d[3]) ||
-			    !ccs_compare_number(s[2], d[2]))
+		case DIRECTIVE_FILE_MKBLOCK:
+		case DIRECTIVE_FILE_MKCHAR:
+			if (!compare_number(s[3], d[3]) ||
+			    !compare_number(s[2], d[2]))
 				continue;
 			/* fall through */
-		case CCS_DIRECTIVE_FILE_CREATE:
-		case CCS_DIRECTIVE_FILE_MKDIR:
-		case CCS_DIRECTIVE_FILE_MKFIFO:
-		case CCS_DIRECTIVE_FILE_MKSOCK:
-		case CCS_DIRECTIVE_FILE_IOCTL:
-		case CCS_DIRECTIVE_FILE_CHMOD:
-		case CCS_DIRECTIVE_FILE_CHOWN:
-		case CCS_DIRECTIVE_FILE_CHGRP:
-			if (!ccs_compare_number(s[1], d[1]))
+		case DIRECTIVE_FILE_CREATE:
+		case DIRECTIVE_FILE_MKDIR:
+		case DIRECTIVE_FILE_MKFIFO:
+		case DIRECTIVE_FILE_MKSOCK:
+		case DIRECTIVE_FILE_IOCTL:
+		case DIRECTIVE_FILE_CHMOD:
+		case DIRECTIVE_FILE_CHOWN:
+		case DIRECTIVE_FILE_CHGRP:
+			if (!compare_number(s[1], d[1]))
 				continue;
 			/* fall through */
-		case CCS_DIRECTIVE_FILE_READ:
-		case CCS_DIRECTIVE_FILE_WRITE:
-		case CCS_DIRECTIVE_FILE_UNLINK:
-		case CCS_DIRECTIVE_FILE_GETATTR:
-		case CCS_DIRECTIVE_FILE_RMDIR:
-		case CCS_DIRECTIVE_FILE_TRUNCATE:
-		case CCS_DIRECTIVE_FILE_APPEND:
-		case CCS_DIRECTIVE_FILE_UNMOUNT:
-		case CCS_DIRECTIVE_FILE_CHROOT:
-		case CCS_DIRECTIVE_FILE_SYMLINK:
-			if (!ccs_compare_path(s[0], d[0]))
+		case DIRECTIVE_FILE_READ:
+		case DIRECTIVE_FILE_WRITE:
+		case DIRECTIVE_FILE_UNLINK:
+		case DIRECTIVE_FILE_GETATTR:
+		case DIRECTIVE_FILE_RMDIR:
+		case DIRECTIVE_FILE_TRUNCATE:
+		case DIRECTIVE_FILE_APPEND:
+		case DIRECTIVE_FILE_UNMOUNT:
+		case DIRECTIVE_FILE_CHROOT:
+		case DIRECTIVE_FILE_SYMLINK:
+			if (!compare_path(s[0], d[0]))
 				continue;
 			break;
-		case CCS_DIRECTIVE_FILE_MOUNT:
-			if (!ccs_compare_number(s[3], d[3]) ||
-			    !ccs_compare_path(s[2], d[2]))
+		case DIRECTIVE_FILE_MOUNT:
+			if (!compare_number(s[3], d[3]) ||
+			    !compare_path(s[2], d[2]))
 				continue;
 			/* fall through */
-		case CCS_DIRECTIVE_FILE_LINK:
-		case CCS_DIRECTIVE_FILE_RENAME:
-		case CCS_DIRECTIVE_FILE_PIVOT_ROOT:
-			if (!ccs_compare_path(s[1], d[1]) ||
-			    !ccs_compare_path(s[0], d[0]))
+		case DIRECTIVE_FILE_LINK:
+		case DIRECTIVE_FILE_RENAME:
+		case DIRECTIVE_FILE_PIVOT_ROOT:
+			if (!compare_path(s[1], d[1]) ||
+			    !compare_path(s[0], d[0]))
 				continue;
 			break;
-		case CCS_DIRECTIVE_IPC_SIGNAL:
+		case DIRECTIVE_IPC_SIGNAL:
 			/* Signal number component. */
 			if (strcmp(s[0], d[0]))
 				continue;
@@ -425,18 +416,18 @@
 			if (c && c != ' ')
 				continue;
 			break;
-		case CCS_DIRECTIVE_NETWORK_INET:
+		case DIRECTIVE_NETWORK_INET:
 			if (strcmp(s[0], d[0]) || strcmp(s[1], d[1]) ||
-			    !ccs_compare_address(s[2], d[2]) ||
-			    !ccs_compare_number(s[3], d[3]))
+			    !compare_address(s[2], d[2]) ||
+			    !compare_number(s[3], d[3]))
 				continue;
 			break;
-		case CCS_DIRECTIVE_NETWORK_UNIX:
+		case DIRECTIVE_NETWORK_UNIX:
 			if (strcmp(s[0], d[0]) || strcmp(s[1], d[1]) ||
-			    !ccs_compare_path(s[2], d[2]))
+			    !compare_path(s[2], d[2]))
 				continue;
 			break;
-		case CCS_DIRECTIVE_MISC_ENV:
+		case DIRECTIVE_MISC_ENV:
 			/* An environemnt variable name component. */
 			sarg.name = s[0];
 			ccs_fill_path_info(&sarg);
@@ -453,59 +444,55 @@
 		default:
 			continue;
 		}
-		ccs_gacl_list[index].selected = 1;
+		p.generic[index].selected = 1;
 	}
 	ccs_put();
 }
 
 /**
- * ccs_editpolicy_optimize - Try to merge entries included in other entries.
+ * editpolicy_optimize - Try to merge entries included in other entries.
  *
- * @current: Index in the domain policy.
- *
  * Returns nothing.
  */
-void ccs_editpolicy_optimize(const int current)
+void editpolicy_optimize(void)
 {
 	char *cp;
-	const bool is_exception_list =
-		ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST;
-	enum ccs_editpolicy_directives s_index;
-	enum ccs_editpolicy_directives s_index2;
+	const bool is_acl_group = active == SCREEN_EXCEPTION_LIST;
+	const int current = editpolicy_get_current();
+	enum directive_type s_index;
+	enum directive_type s_index2;
 	if (current < 0)
 		return;
-	s_index = ccs_gacl_list[current].directive;
-	if (s_index == CCS_DIRECTIVE_NONE)
+	s_index = p.generic[current].directive;
+	if (s_index == DIRECTIVE_NONE)
 		return;
 	/* Allow acl_group lines to be optimized. */
-	if (is_exception_list &&
-	    (s_index < CCS_DIRECTIVE_ACL_GROUP_000 ||
-	     s_index > CCS_DIRECTIVE_ACL_GROUP_255))
+	if (is_acl_group && (s_index < DIRECTIVE_ACL_GROUP_000 ||
+			     s_index > DIRECTIVE_ACL_GROUP_255))
 		return;
-	if (s_index == CCS_DIRECTIVE_USE_GROUP) {
-		unsigned int group = atoi(ccs_gacl_list[current].operand);
+	if (s_index == DIRECTIVE_USE_GROUP) {
+		unsigned int group = atoi(p.generic[current].operand);
 		int i;
 		if (group >= 256)
 			return;
-		for (i = 0; i < acl_group_list_len[group]; i++) {
-			cp = strdup(acl_group_list[group][i]);
+		for (i = 0; i < p.acl_group_len[group]; i++) {
+			cp = strdup(p.acl_group[group][i]);
 			if (!cp)
 				return;
-			s_index = ccs_find_directive(true, cp);
-			if (s_index != CCS_DIRECTIVE_NONE)
-				ccs_editpolicy_do_optimize(cp, -1, s_index,
-							   s_index, false);
+			s_index = find_directive(true, cp);
+			if (s_index != DIRECTIVE_NONE)
+				editpolicy_do_optimize(cp, -1, s_index,
+						       s_index, false);
 			free(cp);
 		}
 		return;
 	}
-	cp = strdup(ccs_gacl_list[current].operand);
+	cp = strdup(p.generic[current].operand);
 	if (!cp)
 		return;
 	s_index2 = s_index;
-	if (is_exception_list)
-		s_index = ccs_find_directive(true, cp);
-	ccs_editpolicy_do_optimize(cp, current, s_index, s_index2,
-				   is_exception_list);
+	if (is_acl_group)
+		s_index = find_directive(true, cp);
+	editpolicy_do_optimize(cp, current, s_index, s_index2, is_acl_group);
 	free(cp);
 }
