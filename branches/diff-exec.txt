Index: security/ccsecurity/domain.c
===================================================================
--- security/ccsecurity/domain.c	(revision 5395)
+++ security/ccsecurity/domain.c	(working copy)
@@ -97,6 +97,18 @@
 		new_entry->cond = ccs_get_condition(param);
 		if (!new_entry->cond)
 			return -EINVAL;
+		/*
+		 * Domain transition preference is allowed for only 
+		 * "file execute"/"task auto_execute_handler"/
+		 * "task denied_auto_execute_handler" entries.
+		 */
+		if (new_entry->cond->exec_transit &&
+		    !(new_entry->type == CCS_TYPE_PATH_ACL &&
+		      container_of(new_entry, struct ccs_path_acl, head)->perm
+		      == 1 << CCS_TYPE_EXECUTE) &&
+		    new_entry->type != CCS_TYPE_AUTO_EXECUTE_HANDLER &&
+		    new_entry->type != CCS_TYPE_DENIED_EXECUTE_HANDLER)
+			goto out;
 	}
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
@@ -613,7 +625,7 @@
 		}
 
 		/* Check execute permission. */
-		retval = ccs_path_permission(r, CCS_TYPE_EXECUTE, candidate);
+		retval = ccs_execute_permission(r, candidate);
 		if (retval == CCS_RETRY_REQUEST)
 			goto retry;
 		if (retval < 0)
@@ -627,11 +639,36 @@
 		if (r->param.path.matched_path)
 			candidate = r->param.path.matched_path;
 	}
-
-	/* Calculate domain to transit to. */
+	/*
+	 * Check for domain transition preference if "file execute" matched.
+	 * If preference is given, make do_execve() fail if domain transition
+	 * has failed, for domain transition preference should be used with
+	 * destination domain defined.
+	 */
+	if (r->ee->transition) {
+		const char *domainname = r->ee->transition->name;
+		reject_on_transition_failure = true;
+		if (!strcmp(domainname, "keep"))
+			goto force_keep_domain;
+		if (!strcmp(domainname, "initialize"))
+			goto force_initialize_domain;
+		if (!strcmp(domainname, "reset"))
+			goto force_reset_domain;
+		if (*domainname == '<')
+			strncpy(ee->tmp, domainname, CCS_EXEC_TMPSIZE - 1);
+		else
+			snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%s %s",
+				 old_domain->domainname->name, domainname);
+		goto force_jump_domain;
+	}
+	/*
+	 * No domain transition preference specified.
+	 * Calculate domain to transit to.
+	 */
 	switch (ccs_transition_type(old_domain->ns, old_domain->domainname,
 				    candidate)) {
 	case CCS_TRANSITION_CONTROL_RESET:
+force_reset_domain:
 		/* Transit to the root of specified namespace. */
 		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "<%s>",
 			 candidate->name);
@@ -642,11 +679,13 @@
 		reject_on_transition_failure = true;
 		break;
 	case CCS_TRANSITION_CONTROL_INITIALIZE:
+force_initialize_domain:
 		/* Transit to the child of current namespace's root. */
 		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%s %s",
 			 old_domain->ns->name, candidate->name);
 		break;
 	case CCS_TRANSITION_CONTROL_KEEP:
+force_keep_domain:
 		/* Keep current domain. */
 		domain = old_domain;
 		break;
@@ -667,6 +706,7 @@
 		}
 		break;
 	}
+force_jump_domain:
 	/*
 	 * Tell GC that I started execve().
 	 * Also, tell open_exec() to check read permission.
@@ -1127,6 +1167,9 @@
 		return false;
 	ee->handler = container_of(r->matched_acl, struct ccs_handler_acl,
 				   head)->handler;
+	ee->transition = r->matched_acl && r->matched_acl->cond &&
+		r->matched_acl->cond->exec_transit ?
+		r->matched_acl->cond->transit : NULL;
 	return true;
 }
 
Index: security/ccsecurity/file.c
===================================================================
--- security/ccsecurity/file.c	(revision 5395)
+++ security/ccsecurity/file.c	(working copy)
@@ -614,14 +614,42 @@
 	do {
 		ccs_check_acl(r, ccs_check_path_acl);
 		error = ccs_audit_path_log(r);
-		/*
-		 * Do not retry for execute request, for aggregator may have
-		 * changed.
-		 */
-	} while (error == CCS_RETRY_REQUEST && operation != CCS_TYPE_EXECUTE);
+	} while (error == CCS_RETRY_REQUEST);
 	return error;
 }
 
+/**
+ * ccs_execute_permission - Check permission for execute operation.
+ *
+ * @r:         Pointer to "struct ccs_request_info".
+ * @filename:  Filename to check.
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+int ccs_execute_permission(struct ccs_request_info *r,
+			   const struct ccs_path_info *filename)
+{
+	/*
+	 * Unlike other permission checks, this check is done regardless of
+	 * profile mode settings in order check for domain transition
+	 * preference.
+	 */
+	r->type = CCS_MAC_FILE_EXECUTE;
+	r->mode = ccs_get_mode(r->profile, r->type);
+	r->param_type = CCS_TYPE_PATH_ACL;
+	r->param.path.filename = filename;
+	r->param.path.operation = CCS_TYPE_EXECUTE;
+	ccs_check_acl(r, ccs_check_path_acl);
+	r->ee->transition = r->matched_acl && r->matched_acl->cond &&
+		r->matched_acl->cond->exec_transit ?
+		r->matched_acl->cond->transit : NULL;
+	if (r->mode != CCS_CONFIG_DISABLED)
+		return ccs_audit_path_log(r);
+	return 0;
+}
+
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 32)
 
 /**
Index: security/ccsecurity/internal.h
===================================================================
--- security/ccsecurity/internal.h	(revision 5395)
+++ security/ccsecurity/internal.h	(working copy)
@@ -905,6 +905,7 @@
 	u16 argc; /* Number of "struct ccs_argv". */
 	u16 envc; /* Number of "struct ccs_envp". */
 	u8 grant_log; /* One of values in "enum ccs_grant_log". */
+	bool exec_transit; /* True if transit is for "file execute". */
 	const struct ccs_path_info *transit; /* Maybe NULL. */
 	/*
 	 * struct ccs_condition_element condition[condc];
@@ -1061,6 +1062,7 @@
 	struct ccs_obj_info obj;
 	struct linux_binprm *bprm;
 	struct ccs_domain_info *previous_domain;
+	const struct ccs_path_info *transition;
 	int reader_idx;
 	/* For execute_handler */
 	const struct ccs_path_info *handler;
@@ -1408,6 +1410,8 @@
 (const struct ccs_path_info *pathname, const struct ccs_group *group);
 int ccs_close_control(struct ccs_io_buffer *head);
 int ccs_env_perm(struct ccs_request_info *r, const char *env);
+int ccs_execute_permission(struct ccs_request_info *r,
+			   const struct ccs_path_info *filename);
 int ccs_get_path(const char *pathname, struct path *path);
 int ccs_init_request_info(struct ccs_request_info *r, const u8 index);
 int ccs_open_control(const u8 type, struct file *file);
Index: security/ccsecurity/condition.c
===================================================================
--- security/ccsecurity/condition.c	(revision 5395)
+++ security/ccsecurity/condition.c	(working copy)
@@ -355,8 +355,9 @@
 		a->numbers_count == b->numbers_count &&
 		a->names_count == b->names_count &&
 		a->argc == b->argc && a->envc == b->envc &&
-		a->grant_log == b->grant_log && a->transit == b->transit &&
-		!memcmp(a + 1, b + 1, a->size - sizeof(*a));
+		a->grant_log == b->grant_log &&
+		a->exec_transit == b->exec_transit && a->transit == b->transit
+		&& !memcmp(a + 1, b + 1, a->size - sizeof(*a));
 }
 
 /**
@@ -435,6 +436,39 @@
 }
 
 /**
+ * ccs_get_transit_preference - Parse domain transition preference for execve().
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ * @e:     Pointer to "struct ccs_condition".
+ *
+ * Returns the condition string part.
+ */
+static char *ccs_get_transit_preference(struct ccs_acl_param *param,
+					struct ccs_condition *e)
+{
+	const char *pos = param->data;
+	if (*pos == '<' || *pos == '/' || !strcmp(pos, "keep") ||
+	    !strcmp(pos, "initialize") || !strcmp(pos, "reset"))
+		e->exec_transit = true;
+	else
+		return (char *) pos;
+	if (*pos == '<')
+		e->transit = ccs_get_domainname(param);
+	else {
+		pos = ccs_read_token(param);
+		if (ccs_correct_word(pos))
+			e->transit = ccs_get_name(pos);
+	}
+	if (e->transit)
+		return param->data;
+	/*
+	 * Return a bad read-only condition string that will let
+	 * ccs_get_condition() return NULL.
+	 */
+	return "/";
+}
+
+/**
  * ccs_get_condition - Parse condition part.
  *
  * @param: Pointer to "struct ccs_acl_param".
@@ -450,7 +484,7 @@
 	struct ccs_argv *argv = NULL;
 	struct ccs_envp *envp = NULL;
 	struct ccs_condition e = { };
-	char * const start_of_string = param->data;
+	char * const start_of_string = ccs_get_transit_preference(param, &e);
 	char * const end_of_string = start_of_string + strlen(start_of_string);
 	char *pos;
 rerun:
@@ -625,8 +659,9 @@
 		+ e.envc * sizeof(struct ccs_envp);
 	entry = kzalloc(e.size, CCS_GFP_FLAGS);
 	if (!entry)
-		return NULL;
+		goto out2;
 	*entry = e;
+	e.transit = NULL;
 	condp = (struct ccs_condition_element *) (entry + 1);
 	numbers_p = (struct ccs_number_union *) (condp + e.condc);
 	names_p = (struct ccs_name_union *) (numbers_p + e.numbers_count);
@@ -653,6 +688,8 @@
 		ccs_del_condition(&entry->head.list);
 		kfree(entry);
 	}
+out2:
+	ccs_put_name(e.transit);
 	return NULL;
 }
 
Index: security/ccsecurity/policy_io.c
===================================================================
--- security/ccsecurity/policy_io.c	(revision 5395)
+++ security/ccsecurity/policy_io.c	(working copy)
@@ -1383,6 +1383,10 @@
 	case 0:
 		head->r.cond_index = 0;
 		head->r.cond_step++;
+		if (cond->transit && cond->exec_transit) {
+			ccs_set_space(head);
+			ccs_set_string(head, cond->transit->name);
+		}
 		/* fall through */
 	case 1:
 		{
@@ -1496,7 +1500,7 @@
 			ccs_io_printf(head, " grant_log=%s",
 				      ccs_yesno(cond->grant_log ==
 						CCS_GRANTLOG_YES));
-		if (cond->transit) {
+		if (cond->transit && !cond->exec_transit) {
 			const char *name = cond->transit->name;
 			ccs_set_string(head, " auto_domain_transition=\"");
 			ccs_set_string(head, name);
