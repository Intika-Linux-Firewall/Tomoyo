Index: trunk/1.7.x/ccs-patch/security/ccsecurity/address_group.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/address_group.c	(revision 3536)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/address_group.c	(working copy)
@@ -105,8 +105,7 @@
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
 	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (ccs_memcmp(member, &e, offsetof(typeof(e), is_ipv6),
-			       sizeof(e)))
+		if (!ccs_same_address_group_member(member, &e))
 			continue;
 		member->is_deleted = is_delete;
 		error = 0;
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/mount.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/mount.c	(revision 3536)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/mount.c	(working copy)
@@ -362,9 +362,7 @@
 	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
 		struct ccs_mount_acl *acl =
 			container_of(ptr, struct ccs_mount_acl, head);
-		if (ptr->type != CCS_TYPE_MOUNT_ACL || ptr->cond != condition
-		    || ccs_memcmp(acl, &e, offsetof(typeof(e), dev_name),
-				  sizeof(e)))
+		if (!ccs_same_mount_acl(acl, &e))
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c	(revision 3536)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c	(working copy)
@@ -108,8 +108,7 @@
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
 	list_for_each_entry_rcu(ptr, &ccs_domain_initializer_list, list) {
-		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), is_not),
-			       sizeof(e)))
+		if (!ccs_same_domain_initializer_entry(ptr, &e))
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
@@ -270,8 +269,7 @@
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
 	list_for_each_entry_rcu(ptr, &ccs_domain_keeper_list, list) {
-		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), is_not),
-			       sizeof(e)))
+		if (!ccs_same_domain_keeper_entry(ptr, &e))
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
@@ -417,8 +415,7 @@
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
 	list_for_each_entry_rcu(ptr, &ccs_aggregator_list, list) {
-		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), original_name),
-			       sizeof(e)))
+		if (!ccs_same_aggregator_entry(ptr, &e))
 			continue;
 		ptr->is_deleted = is_delete;
 		error = 0;
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/file.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/file.c	(revision 3536)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/file.c	(working copy)
@@ -1266,9 +1266,7 @@
 	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
 		struct ccs_path_acl *acl =
 			container_of(ptr, struct ccs_path_acl, head);
-		if (ptr->type != CCS_TYPE_PATH_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+		if (!ccs_same_path_acl(acl, &e))
 			continue;
 		if (is_delete) {
 			acl->perm &= ~perm;
@@ -1344,9 +1342,7 @@
 	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
 		struct ccs_path_number3_acl *acl =
 			container_of(ptr, struct ccs_path_number3_acl, head);
-		if (ptr->type != CCS_TYPE_PATH_NUMBER3_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+		if (!ccs_same_path_number3_acl(acl, &e))
 			continue;
 		if (is_delete) {
 			acl->perm &= ~perm;
@@ -1414,9 +1410,7 @@
 	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
 		struct ccs_path2_acl *acl =
 			container_of(ptr, struct ccs_path2_acl, head);
-		if (ptr->type != CCS_TYPE_PATH2_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name1), sizeof(e)))
+		if (!ccs_same_path2_acl(acl, &e))
 			continue;
 		if (is_delete) {
 			acl->perm &= ~perm;
@@ -1998,9 +1992,7 @@
 	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
 		struct ccs_path_number_acl *acl =
 			container_of(ptr, struct ccs_path_number_acl, head);
-		if (ptr->type != CCS_TYPE_PATH_NUMBER_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+		if (!ccs_same_path_number_acl(acl, &e))
 			continue;
 		if (is_delete) {
 			acl->perm &= ~perm;
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h	(revision 3536)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -1023,13 +1023,125 @@
 	return a->hash != b->hash || strcmp(a->name, b->name);
 }
 
-static inline int ccs_memcmp(void *a, void *b, const size_t offset,
-			     const size_t size)
+static inline bool ccs_same_acl_head(const struct ccs_acl_info *p1,
+				     const struct ccs_acl_info *p2)
 {
-	return memcmp(((char *) a) + offset, ((char *) b) + offset,
-		      size - offset);
+	return p1->type == p2->type && p1->cond == p2->cond;
 }
 
+static inline bool ccs_same_name_union(const struct ccs_name_union *p1,
+				       const struct ccs_name_union *p2)
+{
+	return p1->filename == p2->filename && p1->group == p2->group &&
+		p1->is_group == p2->is_group;
+}
+
+static inline bool ccs_same_number_union(const struct ccs_number_union *p1,
+					 const struct ccs_number_union *p2)
+{
+	return p1->values[0] == p2->values[0] && p1->values[1] == p2->values[1]
+		&& p1->group == p2->group && p1->min_type == p2->min_type &&
+		p1->max_type == p2->max_type && p1->is_group == p2->is_group;
+}
+
+static inline bool ccs_same_path_acl(const struct ccs_path_acl *p1,
+				     const struct ccs_path_acl *p2)
+{
+	return ccs_same_acl_head(&p1->head, &p2->head) &&
+		ccs_same_name_union(&p1->name, &p2->name);
+}
+
+static inline bool ccs_same_path_number3_acl
+(const struct ccs_path_number3_acl *p1,
+ const struct ccs_path_number3_acl *p2)
+{
+	return ccs_same_acl_head(&p1->head, &p2->head)
+		&& ccs_same_name_union(&p1->name, &p2->name)
+		&& ccs_same_number_union(&p1->mode, &p2->mode)
+		&& ccs_same_number_union(&p1->major, &p2->major)
+		&& ccs_same_number_union(&p1->minor, &p2->minor);
+}
+
+static inline bool ccs_same_path2_acl(const struct ccs_path2_acl *p1,
+				      const struct ccs_path2_acl *p2)
+{
+	return ccs_same_acl_head(&p1->head, &p2->head)
+		&& ccs_same_name_union(&p1->name1, &p2->name1)
+		&& ccs_same_name_union(&p1->name2, &p2->name2);
+}
+
+static inline bool ccs_same_path_number_acl
+(const struct ccs_path_number_acl *p1, const struct ccs_path_number_acl *p2)
+{
+	return ccs_same_acl_head(&p1->head, &p2->head)
+		&& ccs_same_name_union(&p1->name, &p2->name)
+		&& ccs_same_number_union(&p1->number, &p2->number);
+}
+
+static inline bool ccs_same_mount_acl(const struct ccs_mount_acl *p1,
+				      const struct ccs_mount_acl *p2)
+{
+	return ccs_same_acl_head(&p1->head, &p2->head) &&
+		ccs_same_name_union(&p1->dev_name, &p2->dev_name) &&
+		ccs_same_name_union(&p1->dir_name, &p2->dir_name) &&
+		ccs_same_name_union(&p1->fs_type, &p2->fs_type) &&
+		ccs_same_number_union(&p1->flags, &p2->flags);
+}
+
+static inline bool ccs_same_ip_network_acl(const struct ccs_ip_network_acl *p1,
+					   const struct ccs_ip_network_acl *p2)
+{
+	return ccs_same_acl_head(&p1->head, &p2->head)
+		&& p1->address_type == p2->address_type &&
+		p1->address.ipv4.min == p2->address.ipv4.min &&
+		p1->address.ipv6.min == p2->address.ipv6.min &&
+		p1->address.ipv4.max == p2->address.ipv4.max &&
+		p1->address.ipv6.max == p2->address.ipv6.max &&
+		p1->address.group == p2->address.group &&
+		ccs_same_number_union(&p1->port, &p2->port);
+}
+
+static inline bool ccs_same_address_group_member
+(const struct ccs_address_group_member *p1,
+ const struct ccs_address_group_member *p2)
+{
+	return p1->is_ipv6 == p2->is_ipv6 &&
+		p1->min.ipv4 == p2->min.ipv4 && p1->min.ipv6 == p2->min.ipv6 &&
+		p1->max.ipv4 == p2->max.ipv4 && p1->max.ipv6 == p2->max.ipv6;
+}
+
+static inline bool ccs_same_domain_initializer_entry
+(const struct ccs_domain_initializer_entry *p1,
+ const struct ccs_domain_initializer_entry *p2)
+{
+	return p1->is_not == p2->is_not && p1->is_last_name == p2->is_last_name
+		&& p1->domainname == p2->domainname
+		&& p1->program == p2->program;
+}
+
+static inline bool ccs_same_domain_keeper_entry
+(const struct ccs_domain_keeper_entry *p1,
+ const struct ccs_domain_keeper_entry *p2)
+{
+	return p1->is_not == p2->is_not && p1->is_last_name == p2->is_last_name
+		&& p1->domainname == p2->domainname
+		&& p1->program == p2->program;
+}
+
+static inline bool ccs_same_aggregator_entry
+(const struct ccs_aggregator_entry *p1,
+ const struct ccs_aggregator_entry *p2)
+{
+	return p1->original_name == p2->original_name &&
+		p1->aggregated_name == p2->aggregated_name;
+}
+
+static inline bool ccs_same_condition(const struct ccs_condition *p1,
+				      const struct ccs_condition *p2)
+{
+	return p1->size == p2->size && !memcmp(p1, p2, p1->size);
+}
+
 #define CCS_HASH_BITS 8
 #define CCS_MAX_HASH (1 << CCS_HASH_BITS)
 
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/condition.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/condition.c	(revision 3536)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/condition.c	(working copy)
@@ -768,8 +768,7 @@
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
 	list_for_each_entry_rcu(ptr, &ccs_condition_list, list) {
-		if (ccs_memcmp(ptr, entry, offsetof(typeof(*entry), size),
-			       size))
+		if (!ccs_same_condition(ptr, entry))
 			continue;
 		/* Same entry found. Share this entry. */
 		atomic_inc(&ptr->users);
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/network.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/network.c	(revision 3536)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/network.c	(working copy)
@@ -346,10 +346,7 @@
 	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
 		struct ccs_ip_network_acl *acl =
 			container_of(ptr, struct ccs_ip_network_acl, head);
-		if (ptr->type != CCS_TYPE_IP_NETWORK_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), address_type),
-			       sizeof(e)))
+		if (!ccs_same_ip_network_acl(acl, &e))
 			continue;
 		if (is_delete) {
 			acl->perm &= ~e.perm;
Index: trunk/1.7.x/ccs-tools/ccstools/kernel_test/testall.sh
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/kernel_test/testall.sh	(revision 3536)
+++ trunk/1.7.x/ccs-tools/ccstools/kernel_test/testall.sh	(working copy)
@@ -6,7 +6,6 @@
 echo "Testing all. (All results are reported)"
 newns ccs_accept_test
 newns ccs_filesystem_test
-newns ccs_bind_test
 newns ccs_file_test
 newns ccs_rewrite_test
 newns ccs_capability_test
@@ -18,6 +17,7 @@
 newns ccs_new_capability_test
 newns ccs_new_network_test
 newns ccs_new_test
+newns ccs_bind_test
 echo
 echo
 echo
