Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/ccstools.h
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/ccstools.h	(working copy)
@@ -43,226 +43,226 @@
 #define true     1
 #define false    0
 
-enum screen_type {
-	SCREEN_EXCEPTION_LIST,
-	SCREEN_DOMAIN_LIST,
-	SCREEN_ACL_LIST,
-	SCREEN_PROFILE_LIST,
-	SCREEN_MANAGER_LIST,
-	SCREEN_QUERY_LIST,
-	SCREEN_MEMINFO_LIST,
-	MAXSCREEN
+enum ccs_screen_type {
+	CCS_SCREEN_EXCEPTION_LIST,
+	CCS_SCREEN_DOMAIN_LIST,
+	CCS_SCREEN_ACL_LIST,
+	CCS_SCREEN_PROFILE_LIST,
+	CCS_SCREEN_MANAGER_LIST,
+	CCS_SCREEN_QUERY_LIST,
+	CCS_SCREEN_MEMINFO_LIST,
+	CCS_MAXSCREEN
 };
 
-enum policy_type {
-	POLICY_TYPE_UNKNOWN,
-	POLICY_TYPE_DOMAIN_POLICY,
-	POLICY_TYPE_EXCEPTION_POLICY,
+enum ccs_policy_type {
+	CCS_POLICY_TYPE_UNKNOWN,
+	CCS_POLICY_TYPE_DOMAIN_POLICY,
+	CCS_POLICY_TYPE_EXCEPTION_POLICY,
 };
 
-#define VALUE_TYPE_DECIMAL     1
-#define VALUE_TYPE_OCTAL       2
-#define VALUE_TYPE_HEXADECIMAL 3
+#define CCS_VALUE_TYPE_DECIMAL     1
+#define CCS_VALUE_TYPE_OCTAL       2
+#define CCS_VALUE_TYPE_HEXADECIMAL 3
 
-enum socket_operation_type {
-	NETWORK_ACL_UDP_BIND,
-	NETWORK_ACL_UDP_CONNECT,
-	NETWORK_ACL_TCP_BIND,
-	NETWORK_ACL_TCP_LISTEN,
-	NETWORK_ACL_TCP_CONNECT,
-	NETWORK_ACL_TCP_ACCEPT,
-	NETWORK_ACL_RAW_BIND,
-	NETWORK_ACL_RAW_CONNECT
+enum ccs_socket_operation_type {
+	CCS_NETWORK_ACL_UDP_BIND,
+	CCS_NETWORK_ACL_UDP_CONNECT,
+	CCS_NETWORK_ACL_TCP_BIND,
+	CCS_NETWORK_ACL_TCP_LISTEN,
+	CCS_NETWORK_ACL_TCP_CONNECT,
+	CCS_NETWORK_ACL_TCP_ACCEPT,
+	CCS_NETWORK_ACL_RAW_BIND,
+	CCS_NETWORK_ACL_RAW_CONNECT
 };
 
-#define KEYWORD_AGGREGATOR               "aggregator "
-#define KEYWORD_ALLOW_ENV                "allow_env "
-#define KEYWORD_ALLOW_IOCTL              "allow_ioctl "
-#define KEYWORD_ALLOW_CAPABILITY         "allow_capability "
-#define KEYWORD_ALLOW_CHROOT             "allow_chroot "
-#define KEYWORD_ALLOW_MOUNT              "allow_mount "
-#define KEYWORD_ALLOW_NETWORK            "allow_network "
-#define KEYWORD_ALLOW_PIVOT_ROOT         "allow_pivot_root "
-#define KEYWORD_ALLOW_READ               "allow_read "
-#define KEYWORD_ALLOW_SIGNAL             "allow_signal "
-#define KEYWORD_DELETE                   "delete "
-#define KEYWORD_DENY_AUTOBIND            "deny_autobind "
-#define KEYWORD_DENY_REWRITE             "deny_rewrite "
-#define KEYWORD_ALLOW_UNMOUNT            "allow_unmount "
-#define KEYWORD_ALLOW_CHMOD              "allow_chmod "
-#define KEYWORD_ALLOW_CHOWN              "allow_chown "
-#define KEYWORD_ALLOW_CHGRP              "allow_chgrp "
-#define KEYWORD_FILE_PATTERN             "file_pattern "
-#define KEYWORD_MAC_FOR_CAPABILITY       "MAC_FOR_CAPABILITY::"
-#define KEYWORD_SELECT                   "select "
-#define KEYWORD_UNDELETE                 "undelete "
-#define KEYWORD_USE_PROFILE              "use_profile "
-#define KEYWORD_USE_PROFILE_LEN          (sizeof(KEYWORD_USE_PROFILE) - 1)
-#define KEYWORD_INITIALIZE_DOMAIN        "initialize_domain "
-#define KEYWORD_KEEP_DOMAIN              "keep_domain "
-#define KEYWORD_PATH_GROUP               "path_group "
-#define KEYWORD_ADDRESS_GROUP            "address_group "
-#define KEYWORD_NUMBER_GROUP             "number_group "
-#define KEYWORD_NO_INITIALIZE_DOMAIN     "no_" KEYWORD_INITIALIZE_DOMAIN
-#define KEYWORD_NO_KEEP_DOMAIN           "no_" KEYWORD_KEEP_DOMAIN
-#define KEYWORD_EXECUTE_HANDLER          "execute_handler "
-#define KEYWORD_DENIED_EXECUTE_HANDLER   "denied_execute_handler "
-#define KEYWORD_ALLOW_EXECUTE            "allow_execute "
+#define CCS_KEYWORD_AGGREGATOR               "aggregator "
+#define CCS_KEYWORD_ALLOW_ENV                "allow_env "
+#define CCS_KEYWORD_ALLOW_IOCTL              "allow_ioctl "
+#define CCS_KEYWORD_ALLOW_CAPABILITY         "allow_capability "
+#define CCS_KEYWORD_ALLOW_CHROOT             "allow_chroot "
+#define CCS_KEYWORD_ALLOW_MOUNT              "allow_mount "
+#define CCS_KEYWORD_ALLOW_NETWORK            "allow_network "
+#define CCS_KEYWORD_ALLOW_PIVOT_ROOT         "allow_pivot_root "
+#define CCS_KEYWORD_ALLOW_READ               "allow_read "
+#define CCS_KEYWORD_ALLOW_SIGNAL             "allow_signal "
+#define CCS_KEYWORD_DELETE                   "delete "
+#define CCS_KEYWORD_DENY_AUTOBIND            "deny_autobind "
+#define CCS_KEYWORD_DENY_REWRITE             "deny_rewrite "
+#define CCS_KEYWORD_ALLOW_UNMOUNT            "allow_unmount "
+#define CCS_KEYWORD_ALLOW_CHMOD              "allow_chmod "
+#define CCS_KEYWORD_ALLOW_CHOWN              "allow_chown "
+#define CCS_KEYWORD_ALLOW_CHGRP              "allow_chgrp "
+#define CCS_KEYWORD_FILE_PATTERN             "file_pattern "
+#define CCS_KEYWORD_MAC_FOR_CAPABILITY       "MAC_FOR_CAPABILITY::"
+#define CCS_KEYWORD_SELECT                   "select "
+#define CCS_KEYWORD_UNDELETE                 "undelete "
+#define CCS_KEYWORD_USE_PROFILE              "use_profile "
+#define CCS_KEYWORD_USE_PROFILE_LEN          (sizeof(CCS_KEYWORD_USE_PROFILE) - 1)
+#define CCS_KEYWORD_INITIALIZE_DOMAIN        "initialize_domain "
+#define CCS_KEYWORD_KEEP_DOMAIN              "keep_domain "
+#define CCS_KEYWORD_PATH_GROUP               "ccs_path_group "
+#define CCS_KEYWORD_ADDRESS_GROUP            "address_group "
+#define CCS_KEYWORD_NUMBER_GROUP             "number_group "
+#define CCS_KEYWORD_NO_INITIALIZE_DOMAIN     "no_" CCS_KEYWORD_INITIALIZE_DOMAIN
+#define CCS_KEYWORD_NO_KEEP_DOMAIN           "no_" CCS_KEYWORD_KEEP_DOMAIN
+#define CCS_KEYWORD_EXECUTE_HANDLER          "execute_handler "
+#define CCS_KEYWORD_DENIED_EXECUTE_HANDLER   "denied_execute_handler "
+#define CCS_KEYWORD_ALLOW_EXECUTE            "allow_execute "
 
 #define CCS_AUDITD_MAX_FILES             2
-#define SAVENAME_MAX_HASH                256
-#define PAGE_SIZE                        4096
+#define CCS_SAVENAME_MAX_HASH            256
+#define CCS_PAGE_SIZE                    4096
 #define CCS_MAX_PATHNAME_LEN             4000
-#define ROOT_NAME                        "<kernel>"
-#define ROOT_NAME_LEN                    (sizeof(ROOT_NAME) - 1)
+#define CCS_ROOT_NAME                    "<kernel>"
+#define CCS_ROOT_NAME_LEN            (sizeof(CCS_ROOT_NAME) - 1)
 
 #define CCSTOOLS_CONFIG_FILE "/usr/lib/ccs/ccstools.conf"
 
-#define DISK_POLICY_DOMAIN_POLICY    "domain_policy.conf"
-#define DISK_POLICY_EXCEPTION_POLICY "exception_policy.conf"
-#define DISK_POLICY_PROFILE          "profile.conf"
-#define DISK_POLICY_MANAGER          "manager.conf"
-#define DISK_POLICY_MEMINFO          "meminfo.conf"
+#define CCS_DISK_POLICY_DOMAIN_POLICY    "domain_policy.conf"
+#define CCS_DISK_POLICY_EXCEPTION_POLICY "exception_policy.conf"
+#define CCS_DISK_POLICY_PROFILE          "profile.conf"
+#define CCS_DISK_POLICY_MANAGER          "manager.conf"
+#define CCS_DISK_POLICY_MEMINFO          "meminfo.conf"
 
-enum editpolicy_directives {
-	DIRECTIVE_NONE,
-	DIRECTIVE_ALLOW_EXECUTE,
-	DIRECTIVE_ALLOW_READ,
-	DIRECTIVE_ALLOW_WRITE,
-	DIRECTIVE_ALLOW_READ_WRITE,
-	DIRECTIVE_ALLOW_CREATE,
-	DIRECTIVE_ALLOW_UNLINK,
-	DIRECTIVE_ALLOW_MKDIR,
-	DIRECTIVE_ALLOW_RMDIR,
-	DIRECTIVE_ALLOW_MKFIFO,
-	DIRECTIVE_ALLOW_MKSOCK,
-	DIRECTIVE_ALLOW_MKBLOCK,
-	DIRECTIVE_ALLOW_MKCHAR,
-	DIRECTIVE_ALLOW_TRUNCATE,
-	DIRECTIVE_ALLOW_SYMLINK,
-	DIRECTIVE_ALLOW_LINK,
-	DIRECTIVE_ALLOW_RENAME,
-	DIRECTIVE_ALLOW_REWRITE,
-	DIRECTIVE_ALLOW_TRANSIT,
-	DIRECTIVE_ALLOW_SIGNAL,
-	DIRECTIVE_ALLOW_NETWORK,
-	DIRECTIVE_ALLOW_IOCTL,
-	DIRECTIVE_ALLOW_ENV,
-	DIRECTIVE_ADDRESS_GROUP,
-	DIRECTIVE_AGGREGATOR,
-	DIRECTIVE_ALLOW_CAPABILITY,
-	DIRECTIVE_ALLOW_CHROOT,
-	DIRECTIVE_ALLOW_MOUNT,
-	DIRECTIVE_ALLOW_PIVOT_ROOT,
-	DIRECTIVE_DENY_AUTOBIND,
-	DIRECTIVE_DENY_REWRITE,
-	DIRECTIVE_ALLOW_UNMOUNT,
-	DIRECTIVE_ALLOW_CHMOD,
-	DIRECTIVE_ALLOW_CHOWN,
-	DIRECTIVE_ALLOW_CHGRP,
-	DIRECTIVE_FILE_PATTERN,
-	DIRECTIVE_EXECUTE_HANDLER,
-	DIRECTIVE_DENIED_EXECUTE_HANDLER,
-	DIRECTIVE_IGNORE_GLOBAL_ALLOW_ENV,
-	DIRECTIVE_IGNORE_GLOBAL_ALLOW_READ,
-	DIRECTIVE_INITIALIZE_DOMAIN,
-	DIRECTIVE_KEEP_DOMAIN,
-	DIRECTIVE_NO_INITIALIZE_DOMAIN,
-	DIRECTIVE_NO_KEEP_DOMAIN,
-	DIRECTIVE_PATH_GROUP,
-	DIRECTIVE_NUMBER_GROUP,
-	DIRECTIVE_QUOTA_EXCEEDED,
-	DIRECTIVE_USE_PROFILE,
-	DIRECTIVE_TRANSITION_FAILED,
-	MAX_DIRECTIVE_INDEX
+enum ccs_editpolicy_directives {
+	CCS_DIRECTIVE_NONE,
+	CCS_DIRECTIVE_ALLOW_EXECUTE,
+	CCS_DIRECTIVE_ALLOW_READ,
+	CCS_DIRECTIVE_ALLOW_WRITE,
+	CCS_DIRECTIVE_ALLOW_READ_WRITE,
+	CCS_DIRECTIVE_ALLOW_CREATE,
+	CCS_DIRECTIVE_ALLOW_UNLINK,
+	CCS_DIRECTIVE_ALLOW_MKDIR,
+	CCS_DIRECTIVE_ALLOW_RMDIR,
+	CCS_DIRECTIVE_ALLOW_MKFIFO,
+	CCS_DIRECTIVE_ALLOW_MKSOCK,
+	CCS_DIRECTIVE_ALLOW_MKBLOCK,
+	CCS_DIRECTIVE_ALLOW_MKCHAR,
+	CCS_DIRECTIVE_ALLOW_TRUNCATE,
+	CCS_DIRECTIVE_ALLOW_SYMLINK,
+	CCS_DIRECTIVE_ALLOW_LINK,
+	CCS_DIRECTIVE_ALLOW_RENAME,
+	CCS_DIRECTIVE_ALLOW_REWRITE,
+	CCS_DIRECTIVE_ALLOW_TRANSIT,
+	CCS_DIRECTIVE_ALLOW_SIGNAL,
+	CCS_DIRECTIVE_ALLOW_NETWORK,
+	CCS_DIRECTIVE_ALLOW_IOCTL,
+	CCS_DIRECTIVE_ALLOW_ENV,
+	CCS_DIRECTIVE_ADDRESS_GROUP,
+	CCS_DIRECTIVE_AGGREGATOR,
+	CCS_DIRECTIVE_ALLOW_CAPABILITY,
+	CCS_DIRECTIVE_ALLOW_CHROOT,
+	CCS_DIRECTIVE_ALLOW_MOUNT,
+	CCS_DIRECTIVE_ALLOW_PIVOT_ROOT,
+	CCS_DIRECTIVE_DENY_AUTOBIND,
+	CCS_DIRECTIVE_DENY_REWRITE,
+	CCS_DIRECTIVE_ALLOW_UNMOUNT,
+	CCS_DIRECTIVE_ALLOW_CHMOD,
+	CCS_DIRECTIVE_ALLOW_CHOWN,
+	CCS_DIRECTIVE_ALLOW_CHGRP,
+	CCS_DIRECTIVE_FILE_PATTERN,
+	CCS_DIRECTIVE_EXECUTE_HANDLER,
+	CCS_DIRECTIVE_DENIED_EXECUTE_HANDLER,
+	CCS_DIRECTIVE_IGNORE_GLOBAL_ALLOW_ENV,
+	CCS_DIRECTIVE_IGNORE_GLOBAL_ALLOW_READ,
+	CCS_DIRECTIVE_INITIALIZE_DOMAIN,
+	CCS_DIRECTIVE_KEEP_DOMAIN,
+	CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN,
+	CCS_DIRECTIVE_NO_KEEP_DOMAIN,
+	CCS_DIRECTIVE_PATH_GROUP,
+	CCS_DIRECTIVE_NUMBER_GROUP,
+	CCS_DIRECTIVE_QUOTA_EXCEEDED,
+	CCS_DIRECTIVE_USE_PROFILE,
+	CCS_DIRECTIVE_TRANSITION_FAILED,
+	CCS_MAX_DIRECTIVE_INDEX
 };
 
-enum color_pair {
-	NORMAL, DOMAIN_HEAD, DOMAIN_CURSOR,
-	EXCEPTION_HEAD, EXCEPTION_CURSOR, ACL_HEAD, ACL_CURSOR,
-	PROFILE_HEAD, PROFILE_CURSOR, MANAGER_HEAD, MANAGER_CURSOR,
-	MEMORY_HEAD, MEMORY_CURSOR, DISP_ERR
+enum ccs_color_pair {
+	CCS_NORMAL, CCS_DOMAIN_HEAD, CCS_DOMAIN_CURSOR,
+	CCS_EXCEPTION_HEAD, CCS_EXCEPTION_CURSOR, CCS_ACL_HEAD, CCS_ACL_CURSOR,
+	CCS_PROFILE_HEAD, CCS_PROFILE_CURSOR, CCS_MANAGER_HEAD, CCS_MANAGER_CURSOR,
+	CCS_MEMORY_HEAD, CCS_MEMORY_CURSOR, CCS_DISP_ERR
 };
 
-static const int header_lines = 3;
+static const int ccs_header_lines = 3;
 
 /***** CONSTANTS DEFINITION END *****/
 
 /***** STRUCTURES DEFINITION START *****/
 
-struct path_info {
+struct ccs_path_info {
 	const char *name;
-	u32 hash;           /* = full_name_hash(name, strlen(name)) */
-	u16 total_len;      /* = strlen(name)                       */
-	u16 const_len;      /* = const_part_length(name)            */
-	_Bool is_dir;       /* = strendswith(name, "/")             */
-	_Bool is_patterned; /* = const_len < total_len              */
+	u32 hash;           /* = ccs_full_name_hash(name, total_len) */
+	u16 total_len;      /* = strlen(name)                        */
+	u16 const_len;      /* = ccs_const_part_length(name)         */
+	_Bool is_dir;       /* = ccs_strendswith(name, "/")          */
+	_Bool is_patterned; /* = const_len < total_len               */
 };
 
-struct path_group_entry {
-	const struct path_info *group_name;
-	const struct path_info **member_name;
+struct ccs_path_group_entry {
+	const struct ccs_path_info *group_name;
+	const struct ccs_path_info **member_name;
 	int member_name_len;
 };
 
-struct ip_address_entry {
+struct ccs_ip_address_entry {
 	u8 min[16];
 	u8 max[16];
 	_Bool is_ipv6;
 };
 
-struct address_group_entry {
-	const struct path_info *group_name;
-	struct ip_address_entry *member_name;
+struct ccs_address_group_entry {
+	const struct ccs_path_info *group_name;
+	struct ccs_ip_address_entry *member_name;
 	int member_name_len;
 };
 
-struct number_entry {
+struct ccs_number_entry {
 	unsigned long min;
 	unsigned long max;
 };
 
-struct number_group_entry {
-	const struct path_info *group_name;
-	struct number_entry *member_name;
+struct ccs_number_group_entry {
+	const struct ccs_path_info *group_name;
+	struct ccs_number_entry *member_name;
 	int member_name_len;
 };
 
-struct savename_entry {
-	struct savename_entry *next;
-	struct path_info entry;
+struct ccs_savename_entry {
+	struct ccs_savename_entry *next;
+	struct ccs_path_info entry;
 };
 
-struct free_memory_block_list {
-	struct free_memory_block_list *next;
+struct ccs_free_memory_block_list {
+	struct ccs_free_memory_block_list *next;
 	char *ptr;
 	int len;
 };
 
-struct dll_pathname_entry {
+struct ccs_dll_pathname_entry {
 	char *pathname;
 	char *real_pathname;
 };
 
-struct domain_initializer_entry {
-	const struct path_info *domainname;    /* This may be NULL */
-	const struct path_info *program;
+struct ccs_domain_initializer_entry {
+	const struct ccs_path_info *domainname;    /* This may be NULL */
+	const struct ccs_path_info *program;
 	_Bool is_not;
 	_Bool is_last_name;
 };
 
-struct domain_keeper_entry {
-	const struct path_info *domainname;
-	const struct path_info *program;       /* This may be NULL */
+struct ccs_domain_keeper_entry {
+	const struct ccs_path_info *domainname;
+	const struct ccs_path_info *program;       /* This may be NULL */
 	_Bool is_not;
 	_Bool is_last_name;
 };
 
-struct domain_info {
-	const struct path_info *domainname;
-	const struct domain_initializer_entry *d_i; /* This may be NULL */
-	const struct domain_keeper_entry *d_k; /* This may be NULL */
-	const struct path_info **string_ptr;
+struct ccs_domain_info {
+	const struct ccs_path_info *domainname;
+	const struct ccs_domain_initializer_entry *d_i; /* This may be NULL */
+	const struct ccs_domain_keeper_entry *d_k; /* This may be NULL */
+	const struct ccs_path_info **string_ptr;
 	int string_count;
 	int number;   /* domain number (-1 if is_dis or is_dd) */
 	u8 profile;
@@ -274,26 +274,26 @@
 	_Bool profile_assigned;
 };
 
-struct domain_policy {
-	struct domain_info *list;
+struct ccs_domain_policy {
+	struct ccs_domain_info *list;
 	int list_len;
 	unsigned char *list_selected;
 };
 
-struct generic_acl {
+struct ccs_generic_acl {
 	u16 directive;
 	u8 selected;
 	const char *operand;
 };
 
-struct editpolicy_directive {
+struct ccs_editpolicy_directive {
 	const char *original;
 	const char *alias;
 	int original_len;
 	int alias_len;
 };
 
-struct task_entry {
+struct ccs_task_entry {
 	pid_t pid;
 	pid_t ppid;
 	char *name;
@@ -308,126 +308,126 @@
 
 /***** PROTOTYPES DEFINITION START *****/
 
-_Bool check_remote_host(void);
-void out_of_memory(void);
-void normalize_line(unsigned char *line);
-_Bool is_domain_def(const unsigned char *domainname);
-_Bool is_correct_domain(const unsigned char *domainname);
-void fprintf_encoded(FILE *fp, const char *pathname);
-_Bool decode(const char *ascii, char *bin);
-_Bool is_correct_path(const char *filename, const s8 start_type,
-		      const s8 pattern_type, const s8 end_type);
-int string_compare(const void *a, const void *b);
-_Bool pathcmp(const struct path_info *a, const struct path_info *b);
-void fill_path_info(struct path_info *ptr);
-const struct path_info *savename(const char *name);
-_Bool str_starts(char *str, const char *begin);
-_Bool path_matches_pattern(const struct path_info *pathname0,
-			   const struct path_info *pattern0);
-char *make_filename(const char *prefix, const time_t time);
+_Bool ccs_check_remote_host(void);
+void ccs_out_of_memory(void);
+void ccs_normalize_line(unsigned char *line);
+_Bool ccs_is_domain_def(const unsigned char *domainname);
+_Bool ccs_is_correct_domain(const unsigned char *domainname);
+void ccs_fprintf_encoded(FILE *fp, const char *ccs_pathname);
+_Bool ccs_decode(const char *ascii, char *bin);
+_Bool ccs_is_correct_path(const char *filename, const s8 start_type,
+			  const s8 pattern_type, const s8 end_type);
+int ccs_string_compare(const void *a, const void *b);
+_Bool ccs_pathcmp(const struct ccs_path_info *a, const struct ccs_path_info *b);
+void ccs_fill_path_info(struct ccs_path_info *ptr);
+const struct ccs_path_info *ccs_savename(const char *name);
+_Bool ccs_str_starts(char *str, const char *begin);
+_Bool ccs_path_matches_pattern(const struct ccs_path_info *pathname0,
+			       const struct ccs_path_info *pattern0);
+char *ccs_make_filename(const char *prefix, const time_t time);
 
-int sortpolicy_main(int argc, char *argv[]);
-int setprofile_main(int argc, char *argv[]);
-int setlevel_main(int argc, char *argv[]);
-int selectpolicy_main(int argc, char *argv[]);
-int diffpolicy_main(int argc, char *argv[]);
-int savepolicy_main(int argc, char *argv[]);
-int pathmatch_main(int argc, char *argv[]);
-int loadpolicy_main(int argc, char *argv[]);
-int ldwatch_main(int argc, char *argv[]);
-int findtemp_main(int argc, char *argv[]);
-int editpolicy_main(int argc, char *argv[]);
-int checkpolicy_main(int argc, char *argv[]);
-int pstree_main(int argc, char *argv[]);
-int queryd_main(int argc, char *argv[]);
-int auditd_main(int argc, char *argv[]);
-int patternize_main(int argc, char *argv[]);
-_Bool move_proc_to_file(const char *src, const char *dest);
-_Bool is_identical_file(const char *file1, const char *file2);
-FILE *open_read(const char *filename);
-FILE *open_write(const char *filename);
-int open_stream(const char *filename);
-void clear_domain_policy(struct domain_policy *dp);
-int find_domain_by_ptr(struct domain_policy *dp,
-		       const struct path_info *domainname);
-void read_domain_policy(struct domain_policy *dp, const char *filename);
-void delete_domain(struct domain_policy *dp, const int index);
-void handle_domain_policy(struct domain_policy *dp, FILE *fp, _Bool is_write);
-int del_string_entry(struct domain_policy *dp, const char *entry,
-		     const int index);
-int add_string_entry(struct domain_policy *dp, const char *entry,
-		     const int index);
-int find_domain(struct domain_policy *dp, const char *domainname0,
-		const _Bool is_dis, const _Bool is_dd);
-int find_or_assign_new_domain(struct domain_policy *dp, const char *domainname,
-			      const _Bool is_dis, const _Bool is_dd);
-const char *domain_name(const struct domain_policy *dp, const int index);
-void send_fd(char *data, int *fd);
-void read_process_list(_Bool show_all);
-void editpolicy_offline_daemon(void);
-void editpolicy_init_keyword_map(void);
-void editpolicy_line_draw(const int screen);
-void editpolicy_try_optimize(struct domain_policy *dp, const int current,
-			     const int screen);
-struct path_group_entry *find_path_group(const char *group_name);
-int add_address_group_policy(char *data, const _Bool is_delete);
-int add_number_group_policy(char *data, const _Bool is_delete);
-u8 find_directive(const _Bool forward, char *line);
-void editpolicy_color_init(void);
-void editpolicy_color_change(const attr_t attr, const _Bool flg);
-void editpolicy_attr_change(const attr_t attr, const _Bool flg);
-void editpolicy_sttr_save(void);
-void editpolicy_sttr_restore(void);
-int editpolicy_color_head(const int screen);
-int editpolicy_color_cursor(const int screen);
-int editpolicy_get_current(void);
-int parse_number(const char *number, struct number_entry *entry);
-int parse_ip(const char *address, struct ip_address_entry *entry);
+int ccs_sortpolicy_main(int argc, char *argv[]);
+int ccs_setprofile_main(int argc, char *argv[]);
+int ccs_setlevel_main(int argc, char *argv[]);
+int ccs_selectpolicy_main(int argc, char *argv[]);
+int ccs_diffpolicy_main(int argc, char *argv[]);
+int ccs_savepolicy_main(int argc, char *argv[]);
+int ccs_pathmatch_main(int argc, char *argv[]);
+int ccs_loadpolicy_main(int argc, char *argv[]);
+int ccs_ldwatch_main(int argc, char *argv[]);
+int ccs_findtemp_main(int argc, char *argv[]);
+int ccs_editpolicy_main(int argc, char *argv[]);
+int ccs_checkpolicy_main(int argc, char *argv[]);
+int ccs_pstree_main(int argc, char *argv[]);
+int ccs_queryd_main(int argc, char *argv[]);
+int ccs_auditd_main(int argc, char *argv[]);
+int ccs_patternize_main(int argc, char *argv[]);
+_Bool ccs_move_proc_to_file(const char *src, const char *dest);
+_Bool ccs_is_identical_file(const char *file1, const char *file2);
+FILE *ccs_open_read(const char *filename);
+FILE *ccs_open_write(const char *filename);
+int ccs_open_stream(const char *filename);
+void ccs_clear_domain_policy(struct ccs_domain_policy *dp);
+int ccs_find_domain_by_ptr(struct ccs_domain_policy *dp,
+			   const struct ccs_path_info *domainname);
+void ccs_read_domain_policy(struct ccs_domain_policy *dp, const char *filename);
+void ccs_delete_domain(struct ccs_domain_policy *dp, const int index);
+void ccs_handle_domain_policy(struct ccs_domain_policy *dp, FILE *fp, _Bool is_write);
+int ccs_del_string_entry(struct ccs_domain_policy *dp, const char *entry,
+			 const int index);
+int ccs_add_string_entry(struct ccs_domain_policy *dp, const char *entry,
+			 const int index);
+int ccs_find_domain(struct ccs_domain_policy *dp, const char *domainname0,
+		    const _Bool is_dis, const _Bool is_dd);
+int ccs_find_or_assign_new_domain(struct ccs_domain_policy *dp, const char *domainname,
+				  const _Bool is_dis, const _Bool is_dd);
+const char *ccs_domain_name(const struct ccs_domain_policy *dp, const int index);
+void ccs_send_fd(char *data, int *fd);
+void ccs_read_process_list(_Bool show_all);
+void ccs_editpolicy_offline_daemon(void);
+void ccs_editpolicy_init_keyword_map(void);
+void ccs_editpolicy_line_draw(const int screen);
+void ccs_editpolicy_try_optimize(struct ccs_domain_policy *dp, const int current,
+				 const int screen);
+struct ccs_path_group_entry *ccs_find_path_group(const char *group_name);
+int ccs_add_address_group_policy(char *data, const _Bool is_delete);
+int ccs_add_number_group_policy(char *data, const _Bool is_delete);
+u8 ccs_find_directive(const _Bool forward, char *line);
+void ccs_editpolicy_color_init(void);
+void ccs_editpolicy_color_change(const attr_t attr, const _Bool flg);
+void ccs_editpolicy_attr_change(const attr_t attr, const _Bool flg);
+void ccs_editpolicy_sttr_save(void);
+void ccs_editpolicy_sttr_restore(void);
+int ccs_editpolicy_color_head(const int screen);
+int ccs_editpolicy_color_cursor(const int screen);
+int ccs_editpolicy_get_current(void);
+int ccs_parse_number(const char *number, struct ccs_number_entry *entry);
+int ccs_parse_ip(const char *address, struct ccs_ip_address_entry *entry);
 
-void get(void);
-void put(void);
-char *freadline(FILE *fp);
-char *shprintf(const char *fmt, ...) __attribute__ ((format(printf, 1, 2)));
+void ccs_get(void);
+void ccs_put(void);
+char *ccs_freadline(FILE *fp);
+char *ccs_shprintf(const char *fmt, ...) __attribute__ ((format(printf, 1, 2)));
 
-char *simple_readline(const int start_y, const int start_x, const char *prompt,
-		      const char *history[], const int history_count,
-		      const int max_length, const int scroll_width);
-int simple_add_history(const char *buffer, const char **history,
-		       const int history_count, const int max_history);
-int getch2(void);
+char *ccs_simple_readline(const int start_y, const int start_x, const char *prompt,
+			  const char *history[], const int history_count,
+			  const int max_length, const int scroll_width);
+int ccs_simple_add_history(const char *buffer, const char **history,
+			   const int history_count, const int max_history);
+int ccs_getch2(void);
 
-extern _Bool offline_mode;
-extern const char *policy_dir;
-extern _Bool network_mode;
-extern u32 network_ip;
-extern u16 network_port;
-extern int persistent_fd;
-extern int query_fd;
-extern int path_group_list_len;
-extern int address_group_list_len;
-extern int number_group_list_len;
-extern struct generic_acl *generic_acl_list;
-extern int generic_acl_list_count;
-extern char *initial_readline_data;
-extern struct path_group_entry *path_group_list;
-extern int path_group_list_len;
-extern int current_y[MAXSCREEN];
-extern int list_item_count[MAXSCREEN];
-extern struct editpolicy_directive directives[MAX_DIRECTIVE_INDEX];
-extern struct task_entry *task_list;
-extern int task_list_len;
+extern _Bool ccs_offline_mode;
+extern const char *ccs_policy_dir;
+extern _Bool ccs_network_mode;
+extern u32 ccs_network_ip;
+extern u16 ccs_network_port;
+extern int ccs_persistent_fd;
+extern int ccs_query_fd;
+extern int ccs_path_group_list_len;
+extern int ccs_address_group_list_len;
+extern int ccs_number_group_list_len;
+extern struct ccs_generic_acl *ccs_generic_acl_list;
+extern int ccs_generic_acl_list_count;
+extern char *ccs_initial_readline_data;
+extern struct ccs_path_group_entry *ccs_path_group_list;
+extern int ccs_path_group_list_len;
+extern int ccs_current_y[CCS_MAXSCREEN];
+extern int ccs_list_item_count[CCS_MAXSCREEN];
+extern struct ccs_editpolicy_directive ccs_directives[CCS_MAX_DIRECTIVE_INDEX];
+extern struct ccs_task_entry *ccs_task_list;
+extern int ccs_task_list_len;
 
-#define proc_policy_dir              "/proc/ccs/"
-#define disk_policy_dir              "/etc/ccs/"
-#define proc_policy_domain_policy    "/proc/ccs/domain_policy"
-#define proc_policy_exception_policy "/proc/ccs/exception_policy"
-#define proc_policy_profile          "/proc/ccs/profile"
-#define proc_policy_manager          "/proc/ccs/manager"
-#define proc_policy_meminfo          "/proc/ccs/meminfo"
-#define proc_policy_query            "/proc/ccs/query"
-#define proc_policy_grant_log        "/proc/ccs/grant_log"
-#define proc_policy_reject_log       "/proc/ccs/reject_log"
-#define proc_policy_domain_status    "/proc/ccs/.domain_status"
-#define proc_policy_process_status   "/proc/ccs/.process_status"
+#define ccs_proc_policy_dir              "/proc/ccs/"
+#define ccs_disk_policy_dir              "/etc/ccs/"
+#define ccs_proc_policy_domain_policy    "/proc/ccs/domain_policy"
+#define ccs_proc_policy_exception_policy "/proc/ccs/exception_policy"
+#define ccs_proc_policy_profile          "/proc/ccs/profile"
+#define ccs_proc_policy_manager          "/proc/ccs/manager"
+#define ccs_proc_policy_meminfo          "/proc/ccs/meminfo"
+#define ccs_proc_policy_query            "/proc/ccs/query"
+#define ccs_proc_policy_grant_log        "/proc/ccs/grant_log"
+#define ccs_proc_policy_reject_log       "/proc/ccs/reject_log"
+#define ccs_proc_policy_domain_status    "/proc/ccs/.domain_status"
+#define ccs_proc_policy_process_status   "/proc/ccs/.process_status"
 
 /***** PROTOTYPES DEFINITION END *****/
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/loadpolicy.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/loadpolicy.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/loadpolicy.c	(working copy)
@@ -10,9 +10,9 @@
  */
 #include "ccstools.h"
 
-static void close_write(FILE *fp)
+static void ccs_close_write(FILE *fp)
 {
-	if (network_mode) {
+	if (ccs_network_mode) {
 		fputc(0, fp);
 		fflush(fp);
 		fgetc(fp);
@@ -20,12 +20,12 @@
 	fclose(fp);
 }
 
-static int write_domain_policy(struct domain_policy *dp, const int fd)
+static int ccs_write_domain_policy(struct ccs_domain_policy *dp, const int fd)
 {
 	int i;
 	int j;
 	for (i = 0; i < dp->list_len; i++) {
-		const struct path_info **string_ptr
+		const struct ccs_path_info **string_ptr
 			= dp->list[i].string_ptr;
 		const int string_count = dp->list[i].string_count;
 		write(fd, dp->list[i].domainname->name,
@@ -34,7 +34,7 @@
 		if (dp->list[i].profile_assigned) {
 			char buf[128];
 			memset(buf, 0, sizeof(buf));
-			snprintf(buf, sizeof(buf) - 1, KEYWORD_USE_PROFILE
+			snprintf(buf, sizeof(buf) - 1, CCS_KEYWORD_USE_PROFILE
 				 "%u\n\n", dp->list[i].profile);
 			write(fd, buf, strlen(buf));
 		} else
@@ -51,12 +51,12 @@
 
 /***** sortpolicy start *****/
 
-int sortpolicy_main(int argc, char *argv[])
+int ccs_sortpolicy_main(int argc, char *argv[])
 {
-	struct domain_policy dp = { NULL, 0, NULL };
-	read_domain_policy(&dp, NULL);
-	write_domain_policy(&dp, 1);
-	clear_domain_policy(&dp);
+	struct ccs_domain_policy dp = { NULL, 0, NULL };
+	ccs_read_domain_policy(&dp, NULL);
+	ccs_write_domain_policy(&dp, 1);
+	ccs_clear_domain_policy(&dp);
 	return 0;
 }
 
@@ -64,17 +64,17 @@
 
 /***** diffpolicy start *****/
 
-int diffpolicy_main(int argc, char *argv[])
+int ccs_diffpolicy_main(int argc, char *argv[])
 {
-	struct domain_policy old_policy = { NULL, 0, NULL };
-	struct domain_policy new_policy = { NULL, 0, NULL };
-	const struct path_info **old_string_ptr;
-	const struct path_info **new_string_ptr;
+	struct ccs_domain_policy old_policy = { NULL, 0, NULL };
+	struct ccs_domain_policy new_policy = { NULL, 0, NULL };
+	const struct ccs_path_info **old_string_ptr;
+	const struct ccs_path_info **new_string_ptr;
 	int old_string_count;
 	int new_string_count;
 	int old_index;
 	int new_index;
-	const struct path_info *domainname;
+	const struct ccs_path_info *domainname;
 	int i;
 	int j;
 	const char *old = NULL;
@@ -93,11 +93,11 @@
 		       "- : Read policy from stdin.\n", argv[0]);
 		return 0;
 	}
-	read_domain_policy(&old_policy, old);
-	read_domain_policy(&new_policy, new);
+	ccs_read_domain_policy(&old_policy, old);
+	ccs_read_domain_policy(&new_policy, new);
 	for (old_index = 0; old_index < old_policy.list_len; old_index++) {
 		domainname = old_policy.list[old_index].domainname;
-		new_index = find_domain_by_ptr(&new_policy, domainname);
+		new_index = ccs_find_domain_by_ptr(&new_policy, domainname);
 		if (new_index >= 0)
 			continue;
 		/* This domain was deleted. */
@@ -105,13 +105,13 @@
 	}
 	for (new_index = 0; new_index < new_policy.list_len; new_index++) {
 		domainname = new_policy.list[new_index].domainname;
-		old_index = find_domain_by_ptr(&old_policy, domainname);
+		old_index = ccs_find_domain_by_ptr(&old_policy, domainname);
 		if (old_index >= 0)
 			continue;
 		/* This domain was added. */
 		printf("%s\n\n", domainname->name);
 		if (new_policy.list[new_index].profile_assigned)
-			printf(KEYWORD_USE_PROFILE "%u\n",
+			printf(CCS_KEYWORD_USE_PROFILE "%u\n",
 			       new_policy.list[new_index].profile);
 		new_string_ptr = new_policy.list[new_index].string_ptr;
 		new_string_count = new_policy.list[new_index].string_count;
@@ -122,7 +122,7 @@
 	for (old_index = 0; old_index < old_policy.list_len; old_index++) {
 		_Bool first = true;
 		domainname = old_policy.list[old_index].domainname;
-		new_index = find_domain_by_ptr(&new_policy, domainname);
+		new_index = ccs_find_domain_by_ptr(&new_policy, domainname);
 		if (new_index == EOF)
 			continue;
 		/* This domain exists in both old policy and new policy. */
@@ -160,7 +160,7 @@
 				printf("%s\n\n", domainname->name);
 			first = false;
 			if (old_policy.list[old_index].profile_assigned)
-				printf(KEYWORD_USE_PROFILE "%u\n",
+				printf(CCS_KEYWORD_USE_PROFILE "%u\n",
 				       old_policy.list[old_index].profile);
 		}
 		if (!first)
@@ -173,7 +173,7 @@
 
 /***** selectpolicy start *****/
 
-int selectpolicy_main(int argc, char *argv[])
+int ccs_selectpolicy_main(int argc, char *argv[])
 {
 	_Bool recursive = false;
 	_Bool matched = false;
@@ -189,13 +189,13 @@
 		return 0;
 	}
 	for (i = start; i < argc; i++)
-		normalize_line(argv[i]);
-	get();
+		ccs_normalize_line(argv[i]);
+	ccs_get();
 	while (true) {
-		char *line = freadline(stdin);
+		char *line = ccs_freadline(stdin);
 		if (!line)
 			break;
-		if (is_domain_def(line)) {
+		if (ccs_is_domain_def(line)) {
 			matched = false;
 			for (i = start; i < argc; i++) {
 				const int len = strlen(argv[i]);
@@ -214,7 +214,7 @@
 		if (matched)
 			puts(line);
 	}
-	put();
+	ccs_put();
 	return 0;
 }
 
@@ -222,16 +222,16 @@
 
 /***** savepolicy start *****/
 
-static _Bool cat_file(const char *path)
+static _Bool ccs_cat_file(const char *path)
 {
-	FILE *fp = open_read(path);
+	FILE *fp = ccs_open_read(path);
 	if (!fp) {
 		fprintf(stderr, "Can't open %s\n", path);
 		return false;
 	}
 	while (true) {
 		int c = fgetc(fp);
-		if (network_mode && !c)
+		if (ccs_network_mode && !c)
 			break;
 		if (c == EOF)
 			break;
@@ -241,7 +241,7 @@
 	return true;
 }
 
-int savepolicy_main(int argc, char *argv[])
+int ccs_savepolicy_main(int argc, char *argv[])
 {
 	char *filename;
 	_Bool write_to_stdout = false;
@@ -253,34 +253,34 @@
 	_Bool force_save = false;
 	time_t now = time(NULL);
 	int i;
-	policy_dir = NULL;
+	ccs_policy_dir = NULL;
 	for (i = 1; i < argc; i++) {
 		char *ptr = argv[i];
 		char *cp = strchr(ptr, ':');
 		if (*ptr == '/') {
-			if (policy_dir)
+			if (ccs_policy_dir)
 				goto usage;
-			policy_dir = ptr;
+			ccs_policy_dir = ptr;
 			argv[i] = "";
 		} else if (cp) {
 			*cp++ = '\0';
-			network_ip = inet_addr(ptr);
-			network_port = htons(atoi(cp));
-			if (network_mode)
+			ccs_network_ip = inet_addr(ptr);
+			ccs_network_port = htons(atoi(cp));
+			if (ccs_network_mode)
 				goto usage;
-			network_mode = true;
-			if (!check_remote_host())
+			ccs_network_mode = true;
+			if (!ccs_check_remote_host())
 				return 1;
 			argv[i] = "";
 		}
 	}
-	if (!network_mode && access(proc_policy_dir, F_OK)) {
+	if (!ccs_network_mode && access(ccs_proc_policy_dir, F_OK)) {
 		fprintf(stderr,
 			"You can't run this program for this kernel.\n");
 		return 0;
 	}
-	if (!network_mode && !policy_dir)
-		policy_dir = disk_policy_dir;
+	if (!ccs_network_mode && !ccs_policy_dir)
+		ccs_policy_dir = ccs_disk_policy_dir;
 	for (i = 1; i < argc; i++) {
 		char *ptr = argv[i];
 		char *e = strchr(ptr, 'e');
@@ -310,7 +310,7 @@
 		if (strcspn(ptr, "edafpmu-"))
 			goto usage;
 	}
-	if (!write_to_stdout && !policy_dir)
+	if (!write_to_stdout && !ccs_policy_dir)
 		goto usage;
 	if (write_to_stdout &&
 	    save_exception_policy + save_domain_policy +
@@ -323,49 +323,49 @@
 		save_exception_policy = 1;
 		save_domain_policy = 1;
 	}
-	if (!write_to_stdout && chdir(policy_dir)) {
-		printf("Directory %s doesn't exist.\n", policy_dir);
+	if (!write_to_stdout && chdir(ccs_policy_dir)) {
+		printf("Directory %s doesn't exist.\n", ccs_policy_dir);
 		return 1;
 	}
 
-	if (!network_mode) {
+	if (!ccs_network_mode) {
 		/* Exclude nonexistent policy. */
-		if (access(proc_policy_exception_policy, R_OK))
+		if (access(ccs_proc_policy_exception_policy, R_OK))
 			save_exception_policy = 0;
-		if (access(proc_policy_domain_policy, R_OK))
+		if (access(ccs_proc_policy_domain_policy, R_OK))
 			save_domain_policy = 0;
-		if (access(proc_policy_profile, R_OK))
+		if (access(ccs_proc_policy_profile, R_OK))
 			save_profile = 0;
-		if (access(proc_policy_manager, R_OK))
+		if (access(ccs_proc_policy_manager, R_OK))
 			save_manager = 0;
-		if (access(proc_policy_meminfo, R_OK))
+		if (access(ccs_proc_policy_meminfo, R_OK))
 			save_meminfo = 0;
 	}
 
 	if (write_to_stdout) {
 		if (save_profile)
-			cat_file(proc_policy_profile);
+			ccs_cat_file(ccs_proc_policy_profile);
 		else if (save_manager)
-			cat_file(proc_policy_manager);
+			ccs_cat_file(ccs_proc_policy_manager);
 		else if (save_exception_policy)
-			cat_file(proc_policy_exception_policy);
+			ccs_cat_file(ccs_proc_policy_exception_policy);
 		else if (save_domain_policy)
-			cat_file(proc_policy_domain_policy);
+			ccs_cat_file(ccs_proc_policy_domain_policy);
 		else if (save_meminfo)
-			cat_file(proc_policy_meminfo);
+			ccs_cat_file(ccs_proc_policy_meminfo);
 		goto done;
 	}
 	if (save_profile)
-		move_proc_to_file(proc_policy_profile, DISK_POLICY_PROFILE);
+		ccs_move_proc_to_file(ccs_proc_policy_profile, CCS_DISK_POLICY_PROFILE);
 	if (save_manager)
-		move_proc_to_file(proc_policy_manager, DISK_POLICY_MANAGER);
+		ccs_move_proc_to_file(ccs_proc_policy_manager, CCS_DISK_POLICY_MANAGER);
 
 	if (save_exception_policy) {
-		filename = make_filename("exception_policy", now);
-		if (move_proc_to_file(proc_policy_exception_policy, filename)
+		filename = ccs_make_filename("exception_policy", now);
+		if (ccs_move_proc_to_file(ccs_proc_policy_exception_policy, filename)
 		    && !write_to_stdout) {
 			if (!force_save &&
-			    is_identical_file("exception_policy.conf",
+			    ccs_is_identical_file("exception_policy.conf",
 					      filename)) {
 				unlink(filename);
 			} else {
@@ -376,11 +376,11 @@
 	}
 
 	if (save_domain_policy) {
-		filename = make_filename("domain_policy", now);
-		if (move_proc_to_file(proc_policy_domain_policy, filename)
+		filename = ccs_make_filename("domain_policy", now);
+		if (ccs_move_proc_to_file(ccs_proc_policy_domain_policy, filename)
 		    && !write_to_stdout) {
 			if (!force_save &&
-			    is_identical_file("domain_policy.conf", filename)) {
+			    ccs_is_identical_file("domain_policy.conf", filename)) {
 				unlink(filename);
 			} else {
 				unlink("domain_policy.conf");
@@ -412,10 +412,10 @@
 
 /***** loadpolicy start *****/
 
-static void move_file_to_proc(const char *src, const char *dest)
+static void ccs_move_file_to_proc(const char *src, const char *dest)
 {
 	FILE *file_fp = stdin;
-	FILE *proc_fp = open_write(dest);
+	FILE *proc_fp = ccs_open_write(dest);
 	if (!proc_fp) {
 		fprintf(stderr, "Can't open %s\n", dest);
 		return;
@@ -428,27 +428,27 @@
 			return;
 		}
 	}
-	get();
+	ccs_get();
 	while (true) {
-		char *line = freadline(file_fp);
+		char *line = ccs_freadline(file_fp);
 		if (!line)
 			break;
 		if (line[0])
 			fprintf(proc_fp, "%s\n", line);
 	}
-	put();
-	close_write(proc_fp);
+	ccs_put();
+	ccs_close_write(proc_fp);
 	if (file_fp != stdin)
 		fclose(file_fp);
 }
 
-static void delete_proc_policy(const char *name)
+static void ccs_delete_proc_policy(const char *name)
 {
 	FILE *fp_in;
 	FILE *fp_out;
-	if (network_mode) {
-		fp_in = open_read(name);
-		fp_out = open_write(name);
+	if (ccs_network_mode) {
+		fp_in = ccs_open_read(name);
+		fp_out = ccs_open_write(name);
 	} else {
 		fp_in = fopen(name, "r");
 		fp_out = fopen(name, "w");
@@ -461,33 +461,33 @@
 			fclose(fp_out);
 		return;
 	}
-	get();
+	ccs_get();
 	while (true) {
-		char *line = freadline(fp_in);
+		char *line = ccs_freadline(fp_in);
 		if (!line)
 			break;
 		fprintf(fp_out, "delete %s\n", line);
 	}
-	put();
+	ccs_put();
 	fclose(fp_in);
-	close_write(fp_out);
+	ccs_close_write(fp_out);
 }
 
-static void update_domain_policy(struct domain_policy *proc_policy,
-				 struct domain_policy *file_policy,
-				 const char *src, const char *dest)
+static void ccs_update_domain_policy(struct ccs_domain_policy *proc_policy,
+				     struct ccs_domain_policy *file_policy,
+				     const char *src, const char *dest)
 {
 	int file_index;
 	int proc_index;
 	FILE *proc_fp;
-	_Bool nm = network_mode;
+	_Bool nm = ccs_network_mode;
 	/* Load disk policy to file_policy->list. */
-	network_mode = false;
-	read_domain_policy(file_policy, src);
-	network_mode = nm;
+	ccs_network_mode = false;
+	ccs_read_domain_policy(file_policy, src);
+	ccs_network_mode = nm;
 	/* Load proc policy to proc_policy->list. */
-	read_domain_policy(proc_policy, dest);
-	proc_fp = open_write(dest);
+	ccs_read_domain_policy(proc_policy, dest);
+	proc_fp = ccs_open_write(dest);
 	if (!proc_fp) {
 		fprintf(stderr, "Can't open %s\n", dest);
 		return;
@@ -495,15 +495,15 @@
 	for (file_index = 0; file_index < file_policy->list_len; file_index++) {
 		int i;
 		int j;
-		const struct path_info *domainname
+		const struct ccs_path_info *domainname
 			= file_policy->list[file_index].domainname;
-		const struct path_info **file_string_ptr
+		const struct ccs_path_info **file_string_ptr
 			= file_policy->list[file_index].string_ptr;
 		const int file_string_count
 			= file_policy->list[file_index].string_count;
-		const struct path_info **proc_string_ptr;
+		const struct ccs_path_info **proc_string_ptr;
 		int proc_string_count;
-		proc_index = find_domain_by_ptr(proc_policy, domainname);
+		proc_index = ccs_find_domain_by_ptr(proc_policy, domainname);
 		fprintf(proc_fp, "%s\n", domainname->name);
 		if (proc_index == EOF)
 			goto not_found;
@@ -522,13 +522,13 @@
 				fprintf(proc_fp, "delete %s\n",
 					proc_string_ptr[j]->name);
 		}
-		delete_domain(proc_policy, proc_index);
+		ccs_delete_domain(proc_policy, proc_index);
 not_found:
 		/* Append entries defined in disk policy. */
 		for (i = 0; i < file_string_count; i++)
 			fprintf(proc_fp, "%s\n", file_string_ptr[i]->name);
 		if (file_policy->list[file_index].profile_assigned)
-			fprintf(proc_fp, KEYWORD_USE_PROFILE "%u\n",
+			fprintf(proc_fp, CCS_KEYWORD_USE_PROFILE "%u\n",
 				file_policy->list[file_index].profile);
 	}
 	/* Delete all domains that are not defined in disk policy. */
@@ -536,13 +536,13 @@
 		fprintf(proc_fp, "delete %s\n",
 			proc_policy->list[proc_index].domainname->name);
 	}
-	close_write(proc_fp);
+	ccs_close_write(proc_fp);
 }
 
-int loadpolicy_main(int argc, char *argv[])
+int ccs_loadpolicy_main(int argc, char *argv[])
 {
-	struct domain_policy proc_policy = { NULL, 0, NULL };
-	struct domain_policy file_policy = { NULL, 0, NULL };
+	struct ccs_domain_policy proc_policy = { NULL, 0, NULL };
+	struct ccs_domain_policy file_policy = { NULL, 0, NULL };
 	_Bool read_from_stdin = false;
 	int load_profile = 0;
 	int load_manager = 0;
@@ -551,29 +551,29 @@
 	int load_meminfo = 0;
 	_Bool refresh_policy = false;
 	int i;
-	policy_dir = NULL;
+	ccs_policy_dir = NULL;
 	for (i = 1; i < argc; i++) {
 		char *ptr = argv[i];
 		char *cp = strchr(ptr, ':');
 		if (*ptr == '/') {
-			if (policy_dir)
+			if (ccs_policy_dir)
 				goto usage;
-			policy_dir = ptr;
+			ccs_policy_dir = ptr;
 			argv[i] = "";
 		} else if (cp) {
 			*cp++ = '\0';
-			network_ip = inet_addr(ptr);
-			network_port = htons(atoi(cp));
-			if (network_mode)
+			ccs_network_ip = inet_addr(ptr);
+			ccs_network_port = htons(atoi(cp));
+			if (ccs_network_mode)
 				goto usage;
-			network_mode = true;
-			if (!check_remote_host())
+			ccs_network_mode = true;
+			if (!ccs_check_remote_host())
 				return 1;
 			argv[i] = "";
 		}
 	}
-	if (!network_mode && !policy_dir)
-		policy_dir = disk_policy_dir;
+	if (!ccs_network_mode && !ccs_policy_dir)
+		ccs_policy_dir = ccs_disk_policy_dir;
 	for (i = 1; i < argc; i++) {
 		char *ptr = argv[i];
 		char *e = strchr(ptr, 'e');
@@ -601,7 +601,7 @@
 		if (strcspn(ptr, "edafpmu-"))
 			goto usage;
 	}
-	if (!read_from_stdin && !policy_dir)
+	if (!read_from_stdin && !ccs_policy_dir)
 		goto usage;
 	if (read_from_stdin &&
 	    load_exception_policy + load_domain_policy +
@@ -611,64 +611,64 @@
 	    load_domain_policy + load_profile + load_manager +
 	    load_meminfo == 0)
 		goto usage;
-	if (!read_from_stdin && chdir(policy_dir)) {
-		printf("Directory %s doesn't exist.\n", policy_dir);
+	if (!read_from_stdin && chdir(ccs_policy_dir)) {
+		printf("Directory %s doesn't exist.\n", ccs_policy_dir);
 		return 1;
 	}
 
 	if (load_profile) {
 		if (read_from_stdin)
-			move_file_to_proc(NULL, proc_policy_profile);
+			ccs_move_file_to_proc(NULL, ccs_proc_policy_profile);
 		else
-			move_file_to_proc(DISK_POLICY_PROFILE,
-					  proc_policy_profile);
+			ccs_move_file_to_proc(CCS_DISK_POLICY_PROFILE,
+					      ccs_proc_policy_profile);
 	}
-
+	
 	if (load_manager) {
 		if (read_from_stdin)
-			move_file_to_proc(NULL, proc_policy_manager);
+			ccs_move_file_to_proc(NULL, ccs_proc_policy_manager);
 		else
-			move_file_to_proc(DISK_POLICY_MANAGER,
-					  proc_policy_manager);
+			ccs_move_file_to_proc(CCS_DISK_POLICY_MANAGER,
+					      ccs_proc_policy_manager);
 	}
-
+	
 	if (load_meminfo) {
 		if (read_from_stdin)
-			move_file_to_proc(NULL, proc_policy_meminfo);
+			ccs_move_file_to_proc(NULL, ccs_proc_policy_meminfo);
 		else
-			move_file_to_proc(DISK_POLICY_MEMINFO,
-					  proc_policy_meminfo);
+			ccs_move_file_to_proc(CCS_DISK_POLICY_MEMINFO,
+					      ccs_proc_policy_meminfo);
 	}
 
 	if (load_exception_policy) {
 		if (refresh_policy)
-			delete_proc_policy(proc_policy_exception_policy);
+			ccs_delete_proc_policy(ccs_proc_policy_exception_policy);
 		if (read_from_stdin)
-			move_file_to_proc(NULL, proc_policy_exception_policy);
+			ccs_move_file_to_proc(NULL, ccs_proc_policy_exception_policy);
 		else
-			move_file_to_proc(DISK_POLICY_EXCEPTION_POLICY,
-					  proc_policy_exception_policy);
+			ccs_move_file_to_proc(CCS_DISK_POLICY_EXCEPTION_POLICY,
+					      ccs_proc_policy_exception_policy);
 	}
-
+	
 	if (load_domain_policy) {
 		if (refresh_policy) {
 			if (read_from_stdin)
-				update_domain_policy(&proc_policy, &file_policy,
-						     NULL,
-						     proc_policy_domain_policy);
+				ccs_update_domain_policy(&proc_policy, &file_policy,
+							 NULL,
+							 ccs_proc_policy_domain_policy);
 			else
-				update_domain_policy(&proc_policy, &file_policy,
-						     DISK_POLICY_DOMAIN_POLICY,
-						     proc_policy_domain_policy);
-			clear_domain_policy(&proc_policy);
-			clear_domain_policy(&file_policy);
+				ccs_update_domain_policy(&proc_policy, &file_policy,
+							 CCS_DISK_POLICY_DOMAIN_POLICY,
+							 ccs_proc_policy_domain_policy);
+			ccs_clear_domain_policy(&proc_policy);
+			ccs_clear_domain_policy(&file_policy);
 		} else {
 			if (read_from_stdin)
-				move_file_to_proc(NULL,
-						  proc_policy_domain_policy);
+				ccs_move_file_to_proc(NULL,
+						      ccs_proc_policy_domain_policy);
 			else
-				move_file_to_proc(DISK_POLICY_DOMAIN_POLICY,
-						  proc_policy_domain_policy);
+				ccs_move_file_to_proc(CCS_DISK_POLICY_DOMAIN_POLICY,
+						      ccs_proc_policy_domain_policy);
 		}
 	}
 	return 0;
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/pstree.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/pstree.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/pstree.c	(working copy)
@@ -10,30 +10,30 @@
  */
 #include "ccstools.h"
 
-static void dump(const pid_t pid, const int depth)
+static void ccs_dump(const pid_t pid, const int depth)
 {
 	int i;
-	for (i = 0; i < task_list_len; i++) {
+	for (i = 0; i < ccs_task_list_len; i++) {
 		int j;
-		if (pid != task_list[i].pid)
+		if (pid != ccs_task_list[i].pid)
 			continue;
-		printf("%3d", task_list[i].profile);
+		printf("%3d", ccs_task_list[i].profile);
 		for (j = 0; j < depth - 1; j++)
 			printf("    ");
 		for (; j < depth; j++)
 			printf("  +-");
-		printf(" %s (%u) %s\n", task_list[i].name,
-		       task_list[i].pid, task_list[i].domain);
-		task_list[i].selected = true;
+		printf(" %s (%u) %s\n", ccs_task_list[i].name,
+		       ccs_task_list[i].pid, ccs_task_list[i].domain);
+		ccs_task_list[i].selected = true;
 	}
-	for (i = 0; i < task_list_len; i++) {
-		if (pid != task_list[i].ppid)
+	for (i = 0; i < ccs_task_list_len; i++) {
+		if (pid != ccs_task_list[i].ppid)
 			continue;
-		dump(task_list[i].pid, depth + 1);
+		ccs_dump(ccs_task_list[i].pid, depth + 1);
 	}
 }
 
-int pstree_main(int argc, char *argv[])
+int ccs_pstree_main(int argc, char *argv[])
 {
 	static _Bool show_all = false;
 	int i;
@@ -42,12 +42,12 @@
 		char *cp = strchr(ptr, ':');
 		if (cp) {
 			*cp++ = '\0';
-			if (network_mode)
+			if (ccs_network_mode)
 				goto usage;
-			network_ip = inet_addr(ptr);
-			network_port = htons(atoi(cp));
-			network_mode = true;
-			if (!check_remote_host())
+			ccs_network_ip = inet_addr(ptr);
+			ccs_network_port = htons(atoi(cp));
+			ccs_network_mode = true;
+			if (!ccs_check_remote_host())
 				return 1;
 		} else if (!strcmp(ptr, "-a")) {
 			show_all = true;
@@ -58,9 +58,9 @@
 			return 0;
 		}
 	}
-	read_process_list(show_all);
-	if (!task_list_len) {
-		if (network_mode) {
+	ccs_read_process_list(show_all);
+	if (!ccs_task_list_len) {
+		if (ccs_network_mode) {
 			fprintf(stderr, "Can't connect.\n");
 			return 1;
 		} else {
@@ -69,21 +69,21 @@
 			return 1;
 		}
 	}
-	dump(1, 0);
-	for (i = 0; i < task_list_len; i++) {
-		if (task_list[i].selected)
+	ccs_dump(1, 0);
+	for (i = 0; i < ccs_task_list_len; i++) {
+		if (ccs_task_list[i].selected)
 			continue;
 		printf("%3d %s (%u) %s\n",
-		       task_list[i].profile, task_list[i].name,
-		       task_list[i].pid, task_list[i].domain);
-		task_list[i].selected = true;
+		       ccs_task_list[i].profile, ccs_task_list[i].name,
+		       ccs_task_list[i].pid, ccs_task_list[i].domain);
+		ccs_task_list[i].selected = true;
 	}
-	while (task_list_len) {
-		task_list_len--;
-		free((void *) task_list[task_list_len].name);
-		free((void *) task_list[task_list_len].domain);
+	while (ccs_task_list_len) {
+		ccs_task_list_len--;
+		free((void *) ccs_task_list[ccs_task_list_len].name);
+		free((void *) ccs_task_list[ccs_task_list_len].domain);
 	}
-	free(task_list);
-	task_list = NULL;
+	free(ccs_task_list);
+	ccs_task_list = NULL;
 	return 0;
 }
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_color.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_color.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_color.c	(working copy)
@@ -12,65 +12,65 @@
 
 /* Prototypes */
 
-static void editpolicy_color_save(const _Bool flg);
+static void ccs_editpolicy_color_save(const _Bool flg);
 
 /* Main functions */
 
 #ifdef COLOR_ON
 
-void editpolicy_color_init(void)
+void ccs_editpolicy_color_init(void)
 {
-	static struct color_env_t {
-		enum color_pair	tag;
+	static struct ccs_color_env_t {
+		enum ccs_color_pair tag;
 		short int fore;
 		short int back;
 		const char *name;
 	} color_env[] = {
-		{ DOMAIN_HEAD,      COLOR_BLACK,
+		{ CCS_DOMAIN_HEAD,      COLOR_BLACK,
 		  COLOR_GREEN,      "DOMAIN_HEAD" },
-		{ DOMAIN_CURSOR,    COLOR_BLACK,
+		{ CCS_DOMAIN_CURSOR,    COLOR_BLACK,
 		  COLOR_GREEN,      "DOMAIN_CURSOR" },
-		{ EXCEPTION_HEAD,   COLOR_BLACK,
+		{ CCS_EXCEPTION_HEAD,   COLOR_BLACK,
 		  COLOR_CYAN,       "EXCEPTION_HEAD" },
-		{ EXCEPTION_CURSOR, COLOR_BLACK,
+		{ CCS_EXCEPTION_CURSOR, COLOR_BLACK,
 		  COLOR_CYAN,       "EXCEPTION_CURSOR" },
-		{ ACL_HEAD,         COLOR_BLACK,
+		{ CCS_ACL_HEAD,         COLOR_BLACK,
 		  COLOR_YELLOW,     "ACL_HEAD" },
-		{ ACL_CURSOR,       COLOR_BLACK,
+		{ CCS_ACL_CURSOR,       COLOR_BLACK,
 		  COLOR_YELLOW,     "ACL_CURSOR" },
-		{ PROFILE_HEAD,     COLOR_WHITE,
+		{ CCS_PROFILE_HEAD,     COLOR_WHITE,
 		  COLOR_RED,        "PROFILE_HEAD" },
-		{ PROFILE_CURSOR,   COLOR_WHITE,
+		{ CCS_PROFILE_CURSOR,   COLOR_WHITE,
 		  COLOR_RED,        "PROFILE_CURSOR" },
-		{ MANAGER_HEAD,     COLOR_WHITE,
+		{ CCS_MANAGER_HEAD,     COLOR_WHITE,
 		  COLOR_GREEN,      "MANAGER_HEAD" },
-		{ MANAGER_CURSOR,   COLOR_WHITE,
+		{ CCS_MANAGER_CURSOR,   COLOR_WHITE,
 		  COLOR_GREEN,      "MANAGER_CURSOR" },
-		{ MEMORY_HEAD,      COLOR_BLACK,
+		{ CCS_MEMORY_HEAD,      COLOR_BLACK,
 		  COLOR_YELLOW,     "MEMORY_HEAD" },
-		{ MEMORY_CURSOR,    COLOR_BLACK,
+		{ CCS_MEMORY_CURSOR,    COLOR_BLACK,
 		  COLOR_YELLOW,     "MEMORY_CURSOR" },
-		{ NORMAL,           COLOR_WHITE,
+		{ CCS_NORMAL,           COLOR_WHITE,
 		  COLOR_BLACK,      NULL }
 	};
 	FILE *fp = fopen(CCSTOOLS_CONFIG_FILE, "r");
 	int i;
 	if (!fp)
 		goto use_default;
-	get();
+	ccs_get();
 	while (true) {
-		char *line = freadline(fp);
+		char *line = ccs_freadline(fp);
 		char *cp;
 		if (!line)
 			break;
-		if (!str_starts(line, "editpolicy.line_color "))
+		if (!ccs_str_starts(line, "editpolicy.line_color "))
 			continue;
 		cp = strchr(line, '=');
 		if (!cp)
 			continue;
 		*cp++ = '\0';
-		normalize_line(line);
-		normalize_line(cp);
+		ccs_normalize_line(line);
+		ccs_normalize_line(cp);
 		if (!*line || !*cp)
 			continue;
 		for (i = 0; color_env[i].name; i++) {
@@ -89,27 +89,27 @@
 			break;
 		}
 	}
-	put();
+	ccs_put();
 	fclose(fp);
 use_default:
 	start_color();
 	for (i = 0; color_env[i].name; i++) {
-		struct color_env_t *colorp = &color_env[i];
+		struct ccs_color_env_t *colorp = &color_env[i];
 		init_pair(colorp->tag, colorp->fore, colorp->back);
 	}
-	init_pair(DISP_ERR, COLOR_RED, COLOR_BLACK); /* error message */
+	init_pair(CCS_DISP_ERR, COLOR_RED, COLOR_BLACK); /* error message */
 }
 
-static void editpolicy_color_save(const _Bool flg)
+static void ccs_editpolicy_color_save(const _Bool flg)
 {
-	static attr_t save_color = NORMAL;
+	static attr_t save_color = CCS_NORMAL;
 	if (flg)
 		save_color = getattrs(stdscr);
 	else
 		attrset(save_color);
 }
 
-void editpolicy_color_change(const attr_t attr, const _Bool flg)
+void ccs_editpolicy_color_change(const attr_t attr, const _Bool flg)
 {
 	if (flg)
 		attron(COLOR_PAIR(attr));
@@ -117,7 +117,7 @@
 		attroff(COLOR_PAIR(attr));
 }
 
-void editpolicy_attr_change(const attr_t attr, const _Bool flg)
+void ccs_editpolicy_attr_change(const attr_t attr, const _Bool flg)
 {
 	if (flg)
 		attron(attr);
@@ -125,59 +125,59 @@
 		attroff(attr);
 }
 
-void editpolicy_sttr_save(void)
+void ccs_editpolicy_sttr_save(void)
 {
-	editpolicy_color_save(true);
+	ccs_editpolicy_color_save(true);
 }
 
-void editpolicy_sttr_restore(void)
+void ccs_editpolicy_sttr_restore(void)
 {
-	editpolicy_color_save(false);
+	ccs_editpolicy_color_save(false);
 }
 
-int editpolicy_color_head(const int screen)
+int ccs_editpolicy_color_head(const int screen)
 {
 	switch (screen) {
-	case SCREEN_DOMAIN_LIST:
-		return DOMAIN_HEAD;
-	case SCREEN_EXCEPTION_LIST:
-		return EXCEPTION_HEAD;
-	case SCREEN_PROFILE_LIST:
-		return PROFILE_HEAD;
-	case SCREEN_MANAGER_LIST:
-		return MANAGER_HEAD;
-	case SCREEN_MEMINFO_LIST:
-		return MEMORY_HEAD;
+	case CCS_SCREEN_DOMAIN_LIST:
+		return CCS_DOMAIN_HEAD;
+	case CCS_SCREEN_EXCEPTION_LIST:
+		return CCS_EXCEPTION_HEAD;
+	case CCS_SCREEN_PROFILE_LIST:
+		return CCS_PROFILE_HEAD;
+	case CCS_SCREEN_MANAGER_LIST:
+		return CCS_MANAGER_HEAD;
+	case CCS_SCREEN_MEMINFO_LIST:
+		return CCS_MEMORY_HEAD;
 	default:
-		return ACL_HEAD;
+		return CCS_ACL_HEAD;
 	}
 }
 
-int editpolicy_color_cursor(const int screen)
+int ccs_editpolicy_color_cursor(const int screen)
 {
 	switch (screen) {
-	case SCREEN_DOMAIN_LIST:
-		return DOMAIN_CURSOR;
-	case SCREEN_EXCEPTION_LIST:
-		return EXCEPTION_CURSOR;
-	case SCREEN_PROFILE_LIST:
-		return PROFILE_CURSOR;
-	case SCREEN_MANAGER_LIST:
-		return MANAGER_CURSOR;
-	case SCREEN_MEMINFO_LIST:
-		return MEMORY_CURSOR;
+	case CCS_SCREEN_DOMAIN_LIST:
+		return CCS_DOMAIN_CURSOR;
+	case CCS_SCREEN_EXCEPTION_LIST:
+		return CCS_EXCEPTION_CURSOR;
+	case CCS_SCREEN_PROFILE_LIST:
+		return CCS_PROFILE_CURSOR;
+	case CCS_SCREEN_MANAGER_LIST:
+		return CCS_MANAGER_CURSOR;
+	case CCS_SCREEN_MEMINFO_LIST:
+		return CCS_MEMORY_CURSOR;
 	default:
-		return ACL_CURSOR;
+		return CCS_ACL_CURSOR;
 	}
 }
 
-void editpolicy_line_draw(const int screen)
+void ccs_editpolicy_line_draw(const int screen)
 {
-	static int before_current[MAXSCREEN] = { -1, -1, -1, -1,
-						 -1, -1, -1 };
-	static int before_y[MAXSCREEN]       = { -1, -1, -1, -1,
-						 -1, -1, -1 };
-	int current = editpolicy_get_current();
+	static int ccs_before_current[CCS_MAXSCREEN] = { -1, -1, -1, -1,
+							 -1, -1, -1 };
+	static int ccs_before_y[CCS_MAXSCREEN]       = { -1, -1, -1, -1,
+							 -1, -1, -1 };
+	int current = ccs_editpolicy_get_current();
 	int y;
 	int x;
 
@@ -185,44 +185,44 @@
 		return;
 
 	getyx(stdscr, y, x);
-	if (-1 < before_current[screen] &&
-	    current != before_current[screen]){
-		move(header_lines + before_y[screen], 0);
-		chgat(-1, A_NORMAL, NORMAL, NULL);
+	if (-1 < ccs_before_current[screen] &&
+	    current != ccs_before_current[screen]){
+		move(ccs_header_lines + ccs_before_y[screen], 0);
+		chgat(-1, A_NORMAL, CCS_NORMAL, NULL);
 	}
 
 	move(y, x);
-	chgat(-1, A_NORMAL, editpolicy_color_cursor(screen), NULL);
+	chgat(-1, A_NORMAL, ccs_editpolicy_color_cursor(screen), NULL);
 	touchwin(stdscr);
 
-	before_current[screen] = current;
-	before_y[screen] = current_y[screen];
+	ccs_before_current[screen] = current;
+	ccs_before_y[screen] = ccs_current_y[screen];
 }
 
 #else
 
-void editpolicy_color_init(void)
+void ccs_editpolicy_color_init(void)
 {
 }
-void editpolicy_color_change(const attr_t attr, const _Bool flg)
+void ccs_editpolicy_color_change(const attr_t attr, const _Bool flg)
 {
 }
-void editpolicy_attr_change(const attr_t attr, const _Bool flg)
+void ccs_editpolicy_attr_change(const attr_t attr, const _Bool flg)
 {
 }
-void editpolicy_sttr_save(void)
+void ccs_editpolicy_sttr_save(void)
 {
 }
-void editpolicy_sttr_restore(void)
+void ccs_editpolicy_sttr_restore(void)
 {
 }
-int editpolicy_color_head(const int screen)
+int ccs_editpolicy_color_head(const int screen)
 {
 }
-int editpolicy_color_cursor(const int screen)
+int ccs_editpolicy_color_cursor(const int screen)
 {
 }
-void editpolicy_line_draw(const int screen)
+void ccs_editpolicy_line_draw(const int screen)
 {
 }
 
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/ld-watch.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/ld-watch.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/ld-watch.c	(working copy)
@@ -10,10 +10,10 @@
  */
 #include "ccstools.h"
 
-static struct dll_pathname_entry *entry_list = NULL;
-static int entry_list_count = 0;
+static struct ccs_dll_pathname_entry *ccs_entry_list = NULL;
+static int ccs_entry_list_count = 0;
 
-static void update_ld_list(int argc, char *argv[], FILE *fp_policy)
+static void ccs_update_ld_list(int argc, char *argv[], FILE *fp_policy)
 {
 	struct stat64 buf;
 	static time_t last_modified = 0;
@@ -42,11 +42,11 @@
 		real_pathname = realpath(cp, NULL);
 		if (!real_pathname)
 			continue;
-		for (i = 0; i < entry_list_count; i++) {
-			if (!strcmp(entry_list[i].real_pathname, real_pathname))
+		for (i = 0; i < ccs_entry_list_count; i++) {
+			if (!strcmp(ccs_entry_list[i].real_pathname, real_pathname))
 				break;
 		}
-		if (i < entry_list_count) {
+		if (i < ccs_entry_list_count) {
 			free(real_pathname);
 			continue;
 		}
@@ -64,31 +64,31 @@
 		/* Add an entry. */
 		pathname = strdup(cp);
 		if (!pathname)
-			out_of_memory();
-		entry_list = realloc(entry_list, (entry_list_count + 1) *
-				     sizeof(struct dll_pathname_entry));
-		if (!entry_list)
-			out_of_memory();
-		entry_list[entry_list_count].pathname = pathname;
-		entry_list[entry_list_count++].real_pathname = real_pathname;
+			ccs_out_of_memory();
+		ccs_entry_list = realloc(ccs_entry_list, (ccs_entry_list_count + 1) *
+				     sizeof(struct ccs_dll_pathname_entry));
+		if (!ccs_entry_list)
+			ccs_out_of_memory();
+		ccs_entry_list[ccs_entry_list_count].pathname = pathname;
+		ccs_entry_list[ccs_entry_list_count++].real_pathname = real_pathname;
 		printf("Added %s : %s\n", pathname, real_pathname);
-		fprintf(fp_policy, KEYWORD_ALLOW_READ);
-		fprintf_encoded(fp_policy, real_pathname);
+		fprintf(fp_policy, CCS_KEYWORD_ALLOW_READ);
+		ccs_fprintf_encoded(fp_policy, real_pathname);
 		fprintf(fp_policy, "\n");
 		fflush(fp_policy);
 	}
 	pclose(fp_ldconfig);
 out:
-	printf("Monitoring %d files.\n", entry_list_count);
+	printf("Monitoring %d files.\n", ccs_entry_list_count);
 }
 
-int ldwatch_main(int argc, char *argv[])
+int ccs_ldwatch_main(int argc, char *argv[])
 {
 	FILE *fp_policy;
 	if (argc > 1 && !strcmp(argv[1], "--help"))
 		goto usage;
 	{
-		const int fd = open(proc_policy_exception_policy, O_RDWR);
+		const int fd = open(ccs_proc_policy_exception_policy, O_RDWR);
 		if (fd == EOF) {
 			fprintf(stderr, "You can't run this program "
 				"for this kernel.\n");
@@ -96,30 +96,30 @@
 		} else if (write(fd, "", 0) != 0) {
 			fprintf(stderr, "You need to register this program to "
 				"%s to run this program.\n",
-				proc_policy_manager);
+				ccs_proc_policy_manager);
 			return 1;
 		}
 		close(fd);
 	}
-	fp_policy = fopen(proc_policy_exception_policy, "w");
+	fp_policy = fopen(ccs_proc_policy_exception_policy, "w");
 	if (!fp_policy) {
 		fprintf(stderr, "Can't open policy file.\n");
 		exit(1);
 	}
 	while (true) {
 		int i;
-		update_ld_list(argc, argv, fp_policy);
+		ccs_update_ld_list(argc, argv, fp_policy);
 		/* Check entries for update. */
-		for (i = 0; i < entry_list_count; i++) {
-			struct dll_pathname_entry *ptr = &entry_list[i];
+		for (i = 0; i < ccs_entry_list_count; i++) {
+			struct ccs_dll_pathname_entry *ptr = &ccs_entry_list[i];
 			char *real_pathname = realpath(ptr->pathname, NULL);
 			if (real_pathname &&
 			    strcmp(ptr->real_pathname, real_pathname)) {
 				printf("Changed %s : %s -> %s\n",
 				       ptr->pathname, ptr->real_pathname,
 				       real_pathname);
-				fprintf(fp_policy, KEYWORD_ALLOW_READ);
-				fprintf_encoded(fp_policy, real_pathname);
+				fprintf(fp_policy, CCS_KEYWORD_ALLOW_READ);
+				ccs_fprintf_encoded(fp_policy, real_pathname);
 				fprintf(fp_policy, "\n");
 				fflush(fp_policy);
 				free(ptr->real_pathname);
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy.c	(working copy)
@@ -10,84 +10,84 @@
  */
 #include "ccstools.h"
 
-struct readline_data {
+struct ccs_readline_data {
 	const char **history;
 	int count;
 	int max;
-	char *search_buffer[MAXSCREEN];
+	char *search_buffer[CCS_MAXSCREEN];
 };
 
 /* Prototypes */
 
-static void sigalrm_handler(int sig);
-static const char *get_last_name(const struct domain_policy *dp,
-				 const int index);
-static _Bool is_keeper_domain(struct domain_policy *dp, const int index);
-static _Bool is_initializer_source(struct domain_policy *dp, const int index);
-static _Bool is_initializer_target(struct domain_policy *dp, const int index);
-static _Bool is_domain_unreachable(struct domain_policy *dp, const int index);
-static _Bool is_deleted_domain(struct domain_policy *dp, const int index);
-static const struct domain_keeper_entry *
-is_domain_keeper(const struct path_info *domainname, const char *program);
-static const struct domain_initializer_entry *
-is_domain_initializer(const struct path_info *domainname, const char *program);
-static int generic_acl_compare(const void *a, const void *b);
-static int generic_acl_compare0(const void *a, const void *b);
-static int string_acl_compare(const void *a, const void *b);
-static int profile_entry_compare(const void *a, const void *b);
-static void read_generic_policy(void);
-static int add_domain_initializer_entry(const char *domainname,
-					const char *program,
-					const _Bool is_not);
-static int add_domain_initializer_policy(char *data, const _Bool is_not);
-static int add_domain_keeper_entry(const char *domainname, const char *program,
-				   const _Bool is_not);
-static int add_domain_keeper_policy(char *data, const _Bool is_not);
-static int add_path_group_entry(const char *group_name, const char *member_name,
-				const _Bool is_delete);
-static int add_path_group_policy(char *data, const _Bool is_delete);
-static void assign_domain_initializer_source(struct domain_policy *dp,
-					     const struct path_info *domainname,
-					     const char *program);
-static int domainname_attribute_compare(const void *a, const void *b);
-static void read_domain_and_exception_policy(struct domain_policy *dp);
-static void show_current(struct domain_policy *dp);
-static const char *eat(const char *str);
-static int show_domain_line(struct domain_policy *dp, const int index);
-static int show_acl_line(const int index, const int list_indent);
-static int show_profile_line(const int index);
-static int show_literal_line(const int index);
-static int show_meminfo_line(const int index);
-static void show_list(struct domain_policy *dp);
-static void resize_window(void);
-static void up_arrow_key(struct domain_policy *dp);
-static void down_arrow_key(struct domain_policy *dp);
-static void page_up_key(struct domain_policy *dp);
-static void page_down_key(struct domain_policy *dp);
-static void adjust_cursor_pos(const int item_count);
-static void set_cursor_pos(const int index);
-static int count(const unsigned char *array, const int len);
-static int count2(const struct generic_acl *array, int len);
-static _Bool select_item(struct domain_policy *dp, const int index);
-static int generic_acl_compare(const void *a, const void *b);
-static void delete_entry(struct domain_policy *dp, const int index);
-static void add_entry(struct readline_data *rl);
-static void find_entry(struct domain_policy *dp, _Bool input, _Bool forward,
-		       const int current, struct readline_data *rl);
-static void set_profile(struct domain_policy *dp, const int current);
-static void set_level(struct domain_policy *dp, const int current);
-static void set_quota(struct domain_policy *dp, const int current);
-static int select_window(struct domain_policy *dp, const int current);
-static _Bool show_command_key(const int screen, const _Bool readonly);
-static int generic_list_loop(struct domain_policy *dp);
-static void copy_file(const char *source, const char *dest);
+static void ccs_sigalrm_handler(int sig);
+static const char *ccs_get_last_name(const struct ccs_domain_policy *dp,
+				     const int index);
+static _Bool ccs_is_keeper_domain(struct ccs_domain_policy *dp, const int index);
+static _Bool ccs_is_initializer_source(struct ccs_domain_policy *dp, const int index);
+static _Bool ccs_is_initializer_target(struct ccs_domain_policy *dp, const int index);
+static _Bool ccs_is_domain_unreachable(struct ccs_domain_policy *dp, const int index);
+static _Bool ccs_is_deleted_domain(struct ccs_domain_policy *dp, const int index);
+static const struct ccs_domain_keeper_entry *
+ccs_is_domain_keeper(const struct ccs_path_info *domainname, const char *program);
+static const struct ccs_domain_initializer_entry *
+ccs_is_domain_initializer(const struct ccs_path_info *domainname, const char *program);
+static int ccs_generic_acl_compare(const void *a, const void *b);
+static int ccs_generic_acl_compare0(const void *a, const void *b);
+static int ccs_string_acl_compare(const void *a, const void *b);
+static int ccs_profile_entry_compare(const void *a, const void *b);
+static void ccs_read_generic_policy(void);
+static int ccs_add_domain_initializer_entry(const char *domainname,
+					    const char *program,
+					    const _Bool is_not);
+static int ccs_add_domain_initializer_policy(char *data, const _Bool is_not);
+static int ccs_add_domain_keeper_entry(const char *domainname, const char *program,
+				       const _Bool is_not);
+static int ccs_add_domain_keeper_policy(char *data, const _Bool is_not);
+static int ccs_add_path_group_entry(const char *group_name, const char *member_name,
+				    const _Bool is_delete);
+static int ccs_add_path_group_policy(char *data, const _Bool is_delete);
+static void ccs_assign_domain_initializer_source(struct ccs_domain_policy *dp,
+						 const struct ccs_path_info *domainname,
+						 const char *program);
+static int ccs_domainname_attribute_compare(const void *a, const void *b);
+static void ccs_read_domain_and_exception_policy(struct ccs_domain_policy *dp);
+static void ccs_show_current(struct ccs_domain_policy *dp);
+static const char *ccs_eat(const char *str);
+static int ccs_show_domain_line(struct ccs_domain_policy *dp, const int index);
+static int ccs_show_acl_line(const int index, const int list_indent);
+static int ccs_show_profile_line(const int index);
+static int ccs_show_literal_line(const int index);
+static int ccs_show_meminfo_line(const int index);
+static void ccs_show_list(struct ccs_domain_policy *dp);
+static void ccs_resize_window(void);
+static void ccs_up_arrow_key(struct ccs_domain_policy *dp);
+static void ccs_down_arrow_key(struct ccs_domain_policy *dp);
+static void ccs_page_up_key(struct ccs_domain_policy *dp);
+static void ccs_page_down_key(struct ccs_domain_policy *dp);
+static void ccs_adjust_cursor_pos(const int item_count);
+static void ccs_set_cursor_pos(const int index);
+static int ccs_count(const unsigned char *array, const int len);
+static int ccs_count2(const struct ccs_generic_acl *array, int len);
+static _Bool ccs_select_item(struct ccs_domain_policy *dp, const int index);
+static int ccs_generic_acl_compare(const void *a, const void *b);
+static void ccs_delete_entry(struct ccs_domain_policy *dp, const int index);
+static void ccs_add_entry(struct ccs_readline_data *rl);
+static void ccs_find_entry(struct ccs_domain_policy *dp, _Bool input, _Bool forward,
+			   const int current, struct ccs_readline_data *rl);
+static void ccs_set_profile(struct ccs_domain_policy *dp, const int current);
+static void ccs_set_level(struct ccs_domain_policy *dp, const int current);
+static void ccs_set_quota(struct ccs_domain_policy *dp, const int current);
+static int ccs_select_window(struct ccs_domain_policy *dp, const int current);
+static _Bool ccs_show_command_key(const int screen, const _Bool readonly);
+static int ccs_generic_list_loop(struct ccs_domain_policy *dp);
+static void ccs_copy_file(const char *source, const char *dest);
 
 /* Utility Functions */
 
-static void copy_file(const char *source, const char *dest)
+static void ccs_copy_file(const char *source, const char *dest)
 {
 	FILE *fp_in = fopen(source, "r");
-	FILE *fp_out = fp_in ? open_write(dest) : NULL;
+	FILE *fp_out = fp_in ? ccs_open_write(dest) : NULL;
 	while (fp_in && fp_out) {
 		int c = fgetc(fp_in);
 		if (c == EOF)
@@ -100,17 +100,17 @@
 		fclose(fp_in);
 }
 
-static const char *get_last_name(const struct domain_policy *dp,
-				 const int index)
+static const char *ccs_get_last_name(const struct ccs_domain_policy *dp,
+				     const int index)
 {
-	const char *cp0 = domain_name(dp, index);
+	const char *cp0 = ccs_domain_name(dp, index);
 	const char *cp1 = strrchr(cp0, ' ');
 	if (cp1)
 		return cp1 + 1;
 	return cp0;
 }
 
-static int count(const unsigned char *array, const int len)
+static int ccs_count(const unsigned char *array, const int len)
 {
 	int i;
 	int c = 0;
@@ -120,7 +120,7 @@
 	return c;
 }
 
-static int count2(const struct generic_acl *array, int len)
+static int ccs_count2(const struct ccs_generic_acl *array, int len)
 {
 	int i;
 	int c = 0;
@@ -130,7 +130,7 @@
 	return c;
 }
 
-static int count3(const struct task_entry *array, int len)
+static int ccs_count3(const struct ccs_task_entry *array, int len)
 {
 	int i;
 	int c = 0;
@@ -140,37 +140,37 @@
 	return c;
 }
 
-static _Bool is_keeper_domain(struct domain_policy *dp, const int index)
+static _Bool ccs_is_keeper_domain(struct ccs_domain_policy *dp, const int index)
 {
 	return dp->list[index].is_dk;
 }
 
-static _Bool is_initializer_source(struct domain_policy *dp, const int index)
+static _Bool ccs_is_initializer_source(struct ccs_domain_policy *dp, const int index)
 {
 	return dp->list[index].is_dis;
 }
 
-static _Bool is_initializer_target(struct domain_policy *dp, const int index)
+static _Bool ccs_is_initializer_target(struct ccs_domain_policy *dp, const int index)
 {
 	return dp->list[index].is_dit;
 }
 
-static _Bool is_domain_unreachable(struct domain_policy *dp, const int index)
+static _Bool ccs_is_domain_unreachable(struct ccs_domain_policy *dp, const int index)
 {
 	return dp->list[index].is_du;
 }
 
-static _Bool is_deleted_domain(struct domain_policy *dp, const int index)
+static _Bool ccs_is_deleted_domain(struct ccs_domain_policy *dp, const int index)
 {
 	return dp->list[index].is_dd;
 }
 
-int add_string_entry(struct domain_policy *dp, const char *entry,
-		     const int index)
+int ccs_add_string_entry(struct ccs_domain_policy *dp, const char *entry,
+			 const int index)
 {
-	const struct path_info **acl_ptr;
+	const struct ccs_path_info **acl_ptr;
 	int acl_count;
-	const struct path_info *cp;
+	const struct ccs_path_info *cp;
 	int i;
 	if (index < 0 || index >= dp->list_len) {
 		fprintf(stderr, "%s: ERROR: domain is out of range.\n",
@@ -179,36 +179,36 @@
 	}
 	if (!entry || !*entry)
 		return -EINVAL;
-	cp = savename(entry);
+	cp = ccs_savename(entry);
 	if (!cp)
-		out_of_memory();
+		ccs_out_of_memory();
 
 	acl_ptr = dp->list[index].string_ptr;
 	acl_count = dp->list[index].string_count;
 
 	/* Check for the same entry. */
 	for (i = 0; i < acl_count; i++) {
-		/* Faster comparison, for they are savename'd. */
+		/* Faster comparison, for they are ccs_savename'd. */
 		if (cp == acl_ptr[i])
 			return 0;
 	}
 
 	acl_ptr = realloc(acl_ptr, (acl_count + 1)
-			  * sizeof(const struct path_info *));
+			  * sizeof(const struct ccs_path_info *));
 	if (!acl_ptr)
-		out_of_memory();
+		ccs_out_of_memory();
 	acl_ptr[acl_count++] = cp;
 	dp->list[index].string_ptr = acl_ptr;
 	dp->list[index].string_count = acl_count;
 	return 0;
 }
 
-int del_string_entry(struct domain_policy *dp, const char *entry,
-		     const int index)
+int ccs_del_string_entry(struct ccs_domain_policy *dp, const char *entry,
+			 const int index)
 {
-	const struct path_info **acl_ptr;
+	const struct ccs_path_info **acl_ptr;
 	int acl_count;
-	const struct path_info *cp;
+	const struct ccs_path_info *cp;
 	int i;
 	if (index < 0 || index >= dp->list_len) {
 		fprintf(stderr, "%s: ERROR: domain is out of range.\n",
@@ -217,15 +217,15 @@
 	}
 	if (!entry || !*entry)
 		return -EINVAL;
-	cp = savename(entry);
+	cp = ccs_savename(entry);
 	if (!cp)
-		out_of_memory();
+		ccs_out_of_memory();
 
 	acl_ptr = dp->list[index].string_ptr;
 	acl_count = dp->list[index].string_count;
 
 	for (i = 0; i < acl_count; i++) {
-		/* Faster comparison, for they are savename'd. */
+		/* Faster comparison, for they are ccs_savename'd. */
 		if (cp != acl_ptr[i])
 			continue;
 		dp->list[index].string_count--;
@@ -236,43 +236,43 @@
 	return -ENOENT;
 }
 
-int find_domain(struct domain_policy *dp, const char *domainname0,
-		const _Bool is_dis, const _Bool is_dd)
+int ccs_find_domain(struct ccs_domain_policy *dp, const char *domainname0,
+		    const _Bool is_dis, const _Bool is_dd)
 {
 	int i;
-	struct path_info domainname;
+	struct ccs_path_info domainname;
 	domainname.name = domainname0;
-	fill_path_info(&domainname);
+	ccs_fill_path_info(&domainname);
 	for (i = 0; i < dp->list_len; i++) {
 		if (dp->list[i].is_dis == is_dis &&
 		    dp->list[i].is_dd == is_dd &&
-		    !pathcmp(&domainname, dp->list[i].domainname))
+		    !ccs_pathcmp(&domainname, dp->list[i].domainname))
 			return i;
 	}
 	return EOF;
 }
 
-int find_or_assign_new_domain(struct domain_policy *dp, const char *domainname,
-			      const _Bool is_dis, const _Bool is_dd)
+int ccs_find_or_assign_new_domain(struct ccs_domain_policy *dp, const char *domainname,
+				  const _Bool is_dis, const _Bool is_dd)
 {
-	const struct path_info *saved_domainname;
-	int index = find_domain(dp, domainname, is_dis, is_dd);
+	const struct ccs_path_info *saved_domainname;
+	int index = ccs_find_domain(dp, domainname, is_dis, is_dd);
 	if (index >= 0)
 		goto found;
-	if (!is_correct_domain(domainname)) {
+	if (!ccs_is_correct_domain(domainname)) {
 		fprintf(stderr, "%s: Invalid domainname '%s'\n",
 			__func__, domainname);
 		return EOF;
 	}
 	dp->list = realloc(dp->list, (dp->list_len + 1) *
-			   sizeof(struct domain_info));
+			   sizeof(struct ccs_domain_info));
 	if (!dp->list)
-		out_of_memory();
+		ccs_out_of_memory();
 	memset(&dp->list[dp->list_len], 0,
-	       sizeof(struct domain_info));
-	saved_domainname = savename(domainname);
+	       sizeof(struct ccs_domain_info));
+	saved_domainname = ccs_savename(domainname);
 	if (!saved_domainname)
-		out_of_memory();
+		ccs_out_of_memory();
 	dp->list[dp->list_len].domainname = saved_domainname;
 	dp->list[dp->list_len].is_dis = is_dis;
 	dp->list[dp->list_len].is_dd = is_dd;
@@ -281,12 +281,12 @@
 	return index;
 }
 
-static int generic_acl_compare0(const void *a, const void *b)
+static int ccs_generic_acl_compare0(const void *a, const void *b)
 {
-	const struct generic_acl *a0 = (struct generic_acl *) a;
-	const struct generic_acl *b0 = (struct generic_acl *) b;
-	const char *a1 = directives[a0->directive].alias;
-	const char *b1 = directives[b0->directive].alias;
+	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
+	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
+	const char *a1 = ccs_directives[a0->directive].alias;
+	const char *b1 = ccs_directives[b0->directive].alias;
 	const char *a2 = a0->operand;
 	const char *b2 = b0->operand;
 	const int ret = strcmp(a1, b1);
@@ -295,65 +295,65 @@
 	return strcmp(a2, b2);
 }
 
-static int string_acl_compare(const void *a, const void *b)
+static int ccs_string_acl_compare(const void *a, const void *b)
 {
-	const struct generic_acl *a0 = (struct generic_acl *) a;
-	const struct generic_acl *b0 = (struct generic_acl *) b;
+	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
+	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
 	const char *a1 = a0->operand;
 	const char *b1 = b0->operand;
 	return strcmp(a1, b1);
 }
 
-static int add_domain_initializer_policy(char *data, const _Bool is_not)
+static int ccs_add_domain_initializer_policy(char *data, const _Bool is_not)
 {
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
-		return add_domain_initializer_entry(cp + 6, data, is_not);
+		return ccs_add_domain_initializer_entry(cp + 6, data, is_not);
 	} else {
-		return add_domain_initializer_entry(NULL, data, is_not);
+		return ccs_add_domain_initializer_entry(NULL, data, is_not);
 	}
 }
 
-static int add_domain_keeper_policy(char *data, const _Bool is_not)
+static int ccs_add_domain_keeper_policy(char *data, const _Bool is_not)
 {
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
-		return add_domain_keeper_entry(cp + 6, data, is_not);
+		return ccs_add_domain_keeper_entry(cp + 6, data, is_not);
 	} else {
-		return add_domain_keeper_entry(data, NULL, is_not);
+		return ccs_add_domain_keeper_entry(data, NULL, is_not);
 	}
 }
 
-static int add_path_group_policy(char *data, const _Bool is_delete)
+static int ccs_add_path_group_policy(char *data, const _Bool is_delete)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return add_path_group_entry(data, cp, is_delete);
+	return ccs_add_path_group_entry(data, cp, is_delete);
 }
 
-static void assign_domain_initializer_source(struct domain_policy *dp,
-					     const struct path_info *domainname,
-					     const char *program)
+static void ccs_assign_domain_initializer_source(struct ccs_domain_policy *dp,
+						 const struct ccs_path_info *domainname,
+						 const char *program)
 {
-	if (is_domain_initializer(domainname, program)) {
+	if (ccs_is_domain_initializer(domainname, program)) {
 		char *line;
-		get();
-		line = shprintf("%s %s", domainname->name, program);
-		normalize_line(line);
-		if (find_or_assign_new_domain(dp, line, true, false) == EOF)
-			out_of_memory();
-		put();
+		ccs_get();
+		line = ccs_shprintf("%s %s", domainname->name, program);
+		ccs_normalize_line(line);
+		if (ccs_find_or_assign_new_domain(dp, line, true, false) == EOF)
+			ccs_out_of_memory();
+		ccs_put();
 	}
 }
 
-static int domainname_attribute_compare(const void *a, const void *b)
+static int ccs_domainname_attribute_compare(const void *a, const void *b)
 {
-	const struct domain_info *a0 = a;
-	const struct domain_info *b0 = b;
+	const struct ccs_domain_info *a0 = a;
+	const struct ccs_domain_info *b0 = b;
 	const int k = strcmp(a0->domainname->name, b0->domainname->name);
 	if ((k > 0) || (!k && !a0->is_dis && b0->is_dis))
 		return 1;
@@ -361,11 +361,11 @@
 }
 
 
-static int show_domain_line(struct domain_policy *dp, const int index)
+static int ccs_show_domain_line(struct ccs_domain_policy *dp, const int index)
 {
 	int tmp_col = 0;
-	const struct domain_initializer_entry *domain_initializer;
-	const struct domain_keeper_entry *domain_keeper;
+	const struct ccs_domain_initializer_entry *domain_initializer;
+	const struct ccs_domain_keeper_entry *domain_keeper;
 	char *line;
 	const char *sp;
 	const int number = dp->list[index].number;
@@ -376,156 +376,156 @@
 			printw("%3u", dp->list[index].profile);
 		else
 			printw("???");
-		printw(" %c%c%c ", is_keeper_domain(dp, index) ? '#' : ' ',
-		       is_initializer_target(dp, index) ? '*' : ' ',
-		       is_domain_unreachable(dp, index) ? '!' : ' ');
+		printw(" %c%c%c ", ccs_is_keeper_domain(dp, index) ? '#' : ' ',
+		       ccs_is_initializer_target(dp, index) ? '*' : ' ',
+		       ccs_is_domain_unreachable(dp, index) ? '!' : ' ');
 	} else
 		printw("              ");
 	tmp_col += 14;
-	sp = domain_name(dp, index);
+	sp = ccs_domain_name(dp, index);
 	while (true) {
 		const char *cp = strchr(sp, ' ');
 		if (!cp)
 			break;
-		printw("%s", eat("    "));
+		printw("%s", ccs_eat("    "));
 		tmp_col += 4;
 		sp = cp + 1;
 	}
-	if (is_deleted_domain(dp, index)) {
-		printw("%s", eat("( "));
+	if (ccs_is_deleted_domain(dp, index)) {
+		printw("%s", ccs_eat("( "));
 		tmp_col += 2;
 	}
-	printw("%s", eat(sp));
+	printw("%s", ccs_eat(sp));
 	tmp_col += strlen(sp);
-	if (is_deleted_domain(dp, index)) {
-		printw("%s", eat(" )"));
+	if (ccs_is_deleted_domain(dp, index)) {
+		printw("%s", ccs_eat(" )"));
 		tmp_col += 2;
 	}
 	domain_initializer = dp->list[index].d_i;
 	if (!domain_initializer)
 		goto not_domain_initializer;
-	get();
+	ccs_get();
 	if (domain_initializer->domainname)
-		line = shprintf(" ( " KEYWORD_INITIALIZE_DOMAIN "%s from %s )",
-				domain_initializer->program->name,
-				domain_initializer->domainname->name);
+		line = ccs_shprintf(" ( " CCS_KEYWORD_INITIALIZE_DOMAIN "%s from %s )",
+				    domain_initializer->program->name,
+				    domain_initializer->domainname->name);
 	else
-		line = shprintf(" ( " KEYWORD_INITIALIZE_DOMAIN "%s )",
-				domain_initializer->program->name);
-	printw("%s", eat(line));
+		line = ccs_shprintf(" ( " CCS_KEYWORD_INITIALIZE_DOMAIN "%s )",
+				    domain_initializer->program->name);
+	printw("%s", ccs_eat(line));
 	tmp_col += strlen(line);
-	put();
+	ccs_put();
 	goto done;
 not_domain_initializer:
 	domain_keeper = dp->list[index].d_k;
 	if (!domain_keeper)
 		goto not_domain_keeper;
-	get();
+	ccs_get();
 	if (domain_keeper->program)
-		line = shprintf(" ( " KEYWORD_KEEP_DOMAIN "%s from %s )",
-				domain_keeper->program->name,
-				domain_keeper->domainname->name);
+		line = ccs_shprintf(" ( " CCS_KEYWORD_KEEP_DOMAIN "%s from %s )",
+				    domain_keeper->program->name,
+				    domain_keeper->domainname->name);
 	else
-		line = shprintf(" ( " KEYWORD_KEEP_DOMAIN "%s )",
-				domain_keeper->domainname->name);
-	printw("%s", eat(line));
+		line = ccs_shprintf(" ( " CCS_KEYWORD_KEEP_DOMAIN "%s )",
+				    domain_keeper->domainname->name);
+	printw("%s", ccs_eat(line));
 	tmp_col += strlen(line);
-	put();
+	ccs_put();
 	goto done;
 not_domain_keeper:
-	if (!is_initializer_source(dp, index))
+	if (!ccs_is_initializer_source(dp, index))
 		goto done;
-	get();
-	line = shprintf(ROOT_NAME "%s", strrchr(domain_name(dp, index), ' '));
-	redirect_index = find_domain(dp, line, false, false);
+	ccs_get();
+	line = ccs_shprintf(CCS_ROOT_NAME "%s", strrchr(ccs_domain_name(dp, index), ' '));
+	redirect_index = ccs_find_domain(dp, line, false, false);
 	if (redirect_index >= 0)
-		line = shprintf(" ( -> %d )", dp->list[redirect_index].number);
+		line = ccs_shprintf(" ( -> %d )", dp->list[redirect_index].number);
 	else
-		line = shprintf(" ( -> Not Found )");
-	printw("%s", eat(line));
+		line = ccs_shprintf(" ( -> Not Found )");
+	printw("%s", ccs_eat(line));
 	tmp_col += strlen(line);
-	put();
+	ccs_put();
 done:
 	return tmp_col;
 }
 
-static int show_acl_line(const int index, const int list_indent)
+static int ccs_show_acl_line(const int index, const int list_indent)
 {
-	u8 directive = generic_acl_list[index].directive;
-	const char *cp1 = directives[directive].alias;
-	const char *cp2 = generic_acl_list[index].operand;
-	int len = list_indent - directives[directive].alias_len;
+	u8 directive = ccs_generic_acl_list[index].directive;
+	const char *cp1 = ccs_directives[directive].alias;
+	const char *cp2 = ccs_generic_acl_list[index].operand;
+	int len = list_indent - ccs_directives[directive].alias_len;
 	printw("%c%4d: %s ",
-	       generic_acl_list[index].selected ? '&' : ' ',
-	       index, eat(cp1));
+	       ccs_generic_acl_list[index].selected ? '&' : ' ',
+	       index, ccs_eat(cp1));
 	while (len-- > 0)
-		printw("%s", eat(" "));
-	printw("%s", eat(cp2));
+		printw("%s", ccs_eat(" "));
+	printw("%s", ccs_eat(cp2));
 	return strlen(cp1) + strlen(cp2) + 8 + list_indent;
 }
 
-static int show_profile_line(const int index)
+static int ccs_show_profile_line(const int index)
 {
-	const char *cp = generic_acl_list[index].operand;
-	const u16 profile = generic_acl_list[index].directive;
+	const char *cp = ccs_generic_acl_list[index].operand;
+	const u16 profile = ccs_generic_acl_list[index].directive;
 	char number[8] = "";
 	if (profile <= 256)
 		snprintf(number, sizeof(number) - 1, "%3u-", profile);
-	printw("%c%4d: %s", generic_acl_list[index].selected ? '&' : ' ',
-	       index, eat(number));
-	printw("%s ", eat(cp));
+	printw("%c%4d: %s", ccs_generic_acl_list[index].selected ? '&' : ' ',
+	       index, ccs_eat(number));
+	printw("%s ", ccs_eat(cp));
 	return strlen(number) + strlen(cp) + 8;
 }
 
-static int show_literal_line(const int index)
+static int ccs_show_literal_line(const int index)
 {
-	const char *cp = generic_acl_list[index].operand;
+	const char *cp = ccs_generic_acl_list[index].operand;
 	printw("%c%4d: %s ",
-	       generic_acl_list[index].selected ? '&' : ' ',
-	       index, eat(cp));
+	       ccs_generic_acl_list[index].selected ? '&' : ' ',
+	       index, ccs_eat(cp));
 	return strlen(cp) + 8;
 }
 
-static int show_meminfo_line(const int index)
+static int ccs_show_meminfo_line(const int index)
 {
 	char *line;
 	unsigned int now = 0;
 	unsigned int quota = -1;
-	const char *data = generic_acl_list[index].operand;
-	get();
+	const char *data = ccs_generic_acl_list[index].operand;
+	ccs_get();
 	if (sscanf(data, "Policy: %u (Quota: %u)", &now, &quota) >= 1)
-		line = shprintf("Memory used for policy      = %10u bytes   "
-				"(Quota: %10u bytes)", now, quota);
+		line = ccs_shprintf("Memory used for policy      = %10u bytes   "
+				    "(Quota: %10u bytes)", now, quota);
 	else if (sscanf(data, "Audit logs: %u (Quota: %u)", &now, &quota) >= 1)
-		line = shprintf("Memory used for audit logs  = %10u bytes   "
-				"(Quota: %10u bytes)", now, quota);
+		line = ccs_shprintf("Memory used for audit logs  = %10u bytes   "
+				    "(Quota: %10u bytes)", now, quota);
 	else if (sscanf(data, "Query lists: %u (Quota: %u)", &now, &quota) >= 1)
-		line = shprintf("Memory used for query lists = %10u bytes   "
-				"(Quota: %10u bytes)", now, quota);
+		line = ccs_shprintf("Memory used for query lists = %10u bytes   "
+				    "(Quota: %10u bytes)", now, quota);
 	else if (sscanf(data, "Total: %u", &now) == 1)
-		line = shprintf("Total memory in use         = %10u bytes",
-				now);
+		line = ccs_shprintf("Total memory in use         = %10u bytes",
+				    now);
 	else if (sscanf(data, "Shared: %u (Quota: %u)", &now, &quota) >= 1)
-		line = shprintf("Memory for string data      = %10u bytes    "
-				"Quota = %10u bytes", now, quota);
+		line = ccs_shprintf("Memory for string data      = %10u bytes    "
+				    "Quota = %10u bytes", now, quota);
 	else if (sscanf(data, "Private: %u (Quota: %u)", &now, &quota) >= 1)
-		line = shprintf("Memory for numeric data     = %10u bytes    "
-				"Quota = %10u bytes", now, quota);
+		line = ccs_shprintf("Memory for numeric data     = %10u bytes    "
+				    "Quota = %10u bytes", now, quota);
 	else if (sscanf(data, "Dynamic: %u (Quota: %u)", &now, &quota) >= 1)
-		line = shprintf("Memory for temporary data   = %10u bytes    "
-				"Quota = %10u bytes", now, quota);
+		line = ccs_shprintf("Memory for temporary data   = %10u bytes    "
+				    "Quota = %10u bytes", now, quota);
 	else
-		line = shprintf("%s", data);
+		line = ccs_shprintf("%s", data);
 	if (line[0])
-		printw("%s", eat(line));
+		printw("%s", ccs_eat(line));
 	now = strlen(line);
-	put();
+	ccs_put();
 	return now;
 }
 
-static int domain_sort_type = 0;
+static int ccs_domain_sort_type = 0;
 
-static _Bool show_command_key(const int screen, const _Bool readonly)
+static _Bool ccs_show_command_key(const int screen, const _Bool readonly)
 {
 	int c;
 	clear();
@@ -533,7 +533,7 @@
 	printw("Q/q        Quit this editor.\n");
 	printw("R/r        Refresh to the latest information.\n");
 	switch (screen) {
-	case SCREEN_MEMINFO_LIST:
+	case CCS_SCREEN_MEMINFO_LIST:
 		break;
 	default:
 		printw("F/f        Find first.\n");
@@ -543,7 +543,7 @@
 	printw("W/w        Switch to selected screen.\n");
 	/* printw("Tab        Switch to next screen.\n"); */
 	switch (screen) {
-	case SCREEN_MEMINFO_LIST:
+	case CCS_SCREEN_MEMINFO_LIST:
 		break;
 	default:
 		printw("Insert     Copy an entry at the cursor position to "
@@ -555,8 +555,8 @@
 		       "position.\n");
 	}
 	switch (screen) {
-	case SCREEN_DOMAIN_LIST:
-		if (domain_sort_type) {
+	case CCS_SCREEN_DOMAIN_LIST:
+		if (ccs_domain_sort_type) {
 			printw("S/s        Set profile number of selected "
 			       "processes.\n");
 			printw("Enter      Edit ACLs of a process at the "
@@ -572,40 +572,40 @@
 			       "cursor position.\n");
 		}
 		break;
-	case SCREEN_MEMINFO_LIST:
+	case CCS_SCREEN_MEMINFO_LIST:
 		if (!readonly)
 			printw("S/s        Set memory quota of selected "
 			       "items.\n");
 		break;
-	case SCREEN_PROFILE_LIST:
+	case CCS_SCREEN_PROFILE_LIST:
 		if (!readonly)
 			printw("S/s        Set mode of selected items.\n");
 		break;
 	}
 	switch (screen) {
-	case SCREEN_EXCEPTION_LIST:
-	case SCREEN_ACL_LIST:
-	case SCREEN_MANAGER_LIST:
+	case CCS_SCREEN_EXCEPTION_LIST:
+	case CCS_SCREEN_ACL_LIST:
+	case CCS_SCREEN_MANAGER_LIST:
 		if (!readonly) {
 			printw("A/a        Add a new entry.\n");
 			printw("D/d        Delete selected entries.\n");
 		}
 	}
 	switch (screen) {
-	case SCREEN_PROFILE_LIST:
+	case CCS_SCREEN_PROFILE_LIST:
 		if (!readonly)
 			printw("A/a        Define a new profile.\n");
 	}
 	switch (screen) {
-	case SCREEN_ACL_LIST:
+	case CCS_SCREEN_ACL_LIST:
 		printw("O/o        Set selection state to other entries "
 		       "included in an entry at the cursor position.\n");
 		/* Fall through. */
-	case SCREEN_PROFILE_LIST:
+	case CCS_SCREEN_PROFILE_LIST:
 		printw("@          Switch sort type.\n");
 		break;
-	case SCREEN_DOMAIN_LIST:
-		if (!offline_mode)
+	case CCS_SCREEN_DOMAIN_LIST:
+		if (!ccs_offline_mode)
 			printw("@          Switch domain/process list.\n");
 	}
 	printw("Arrow-keys and PageUp/PageDown/Home/End keys "
@@ -613,7 +613,7 @@
 	printw("Press '?' to escape from this help.\n");
 	refresh();
 	while (true) {
-		c = getch2();
+		c = ccs_getch2();
 		if (c == '?' || c == EOF)
 			break;
 		if (c == 'Q' || c == 'q')
@@ -624,63 +624,63 @@
 
 /* Variables */
 
-static _Bool readonly_mode = false;
-static unsigned int refresh_interval = 0;
-static _Bool need_reload = false;
+static _Bool ccs_readonly_mode = false;
+static unsigned int ccs_refresh_interval = 0;
+static _Bool ccs_need_reload = false;
 
-_Bool offline_mode = false;
-const char *policy_dir = NULL;
-_Bool network_mode = false;
-u32 network_ip = INADDR_NONE;
-u16 network_port = 0;
+_Bool ccs_offline_mode = false;
+const char *ccs_policy_dir = NULL;
+_Bool ccs_network_mode = false;
+u32 ccs_network_ip = INADDR_NONE;
+u16 ccs_network_port = 0;
 
-struct path_group_entry *path_group_list = NULL;
-int path_group_list_len = 0;
+struct ccs_path_group_entry *ccs_path_group_list = NULL;
+int ccs_path_group_list_len = 0;
 
-static const char *policy_file = NULL;
-static const char *list_caption = NULL;
-static char *current_domain = NULL;
-static unsigned int current_pid = 0;
+static const char *ccs_policy_file = NULL;
+static const char *ccs_list_caption = NULL;
+static char *ccs_current_domain = NULL;
+static unsigned int ccs_current_pid = 0;
 
-static int current_screen = SCREEN_DOMAIN_LIST;
+static int ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
 
-struct generic_acl *generic_acl_list = NULL;
-int generic_acl_list_count = 0;
+struct ccs_generic_acl *ccs_generic_acl_list = NULL;
+int ccs_generic_acl_list_count = 0;
 
-struct task_entry *task_list = NULL;
-int task_list_len = 0;
-static int dump_index = 0;
+struct ccs_task_entry *ccs_task_list = NULL;
+int ccs_task_list_len = 0;
+static int ccs_dump_index = 0;
 
-static struct domain_keeper_entry *domain_keeper_list = NULL;
-static int domain_keeper_list_len = 0;
-static struct domain_initializer_entry *domain_initializer_list = NULL;
-static int domain_initializer_list_len = 0;
+static struct ccs_domain_keeper_entry *ccs_domain_keeper_list = NULL;
+static int ccs_domain_keeper_list_len = 0;
+static struct ccs_domain_initializer_entry *ccs_domain_initializer_list = NULL;
+static int ccs_domain_initializer_list_len = 0;
 
-static int profile_sort_type = 0;
-static int unnumbered_domain_count = 0;
+static int ccs_profile_sort_type = 0;
+static int ccs_unnumbered_domain_count = 0;
 
-static int window_width = 0;
-static int window_height = 0;
-static int current_item_index[MAXSCREEN];
-int current_y[MAXSCREEN];
-int list_item_count[MAXSCREEN];
+static int ccs_window_width = 0;
+static int ccs_window_height = 0;
+static int ccs_current_item_index[CCS_MAXSCREEN];
+int ccs_current_y[CCS_MAXSCREEN];
+int ccs_list_item_count[CCS_MAXSCREEN];
 
-static int body_lines = 0;
+static int ccs_body_lines = 0;
 
-static int max_eat_col[MAXSCREEN];
-static int eat_col = 0;
-static int max_col = 0;
-static int list_indent = 0;
+static int ccs_max_eat_col[CCS_MAXSCREEN];
+static int ccs_eat_col = 0;
+static int ccs_max_col = 0;
+static int ccs_list_indent = 0;
 
-static int acl_sort_type = 1;
+static int ccs_acl_sort_type = 1;
 
-static char *last_error = NULL;
+static char *ccs_last_error = NULL;
 
 /* Main Functions */
 
-static void close_write(FILE *fp)
+static void ccs_close_write(FILE *fp)
 {
-	if (network_mode) {
+	if (ccs_network_mode) {
 		fputc(0, fp);
 		fflush(fp);
 		fgetc(fp);
@@ -688,63 +688,63 @@
 	fclose(fp);
 }
 
-static void set_error(const char *filename)
+static void ccs_set_error(const char *filename)
 {
 	if (filename) {
 		const int len = strlen(filename) + 128;
-		last_error = realloc(last_error, len);
-		if (!last_error)
-			out_of_memory();
-		memset(last_error, 0, len);
-		snprintf(last_error, len - 1, "Can't open %s .", filename);
+		ccs_last_error = realloc(ccs_last_error, len);
+		if (!ccs_last_error)
+			ccs_out_of_memory();
+		memset(ccs_last_error, 0, len);
+		snprintf(ccs_last_error, len - 1, "Can't open %s .", filename);
 	} else {
-		free(last_error);
-		last_error = NULL;
+		free(ccs_last_error);
+		ccs_last_error = NULL;
 	}
 }
 
-static int open2(const char *filename, int mode)
+static int ccs_open2(const char *filename, int mode)
 {
 	const int fd = open(filename, mode);
 	if (fd == EOF && errno != ENOENT)
-		set_error(filename);
+		ccs_set_error(filename);
 	return fd;
 }
 
-static void sigalrm_handler(int sig)
+static void ccs_sigalrm_handler(int sig)
 {
-	need_reload = true;
-	alarm(refresh_interval);
+	ccs_need_reload = true;
+	alarm(ccs_refresh_interval);
 }
 
-static const char *eat(const char *str)
+static const char *ccs_eat(const char *str)
 {
-	while (*str && eat_col) {
+	while (*str && ccs_eat_col) {
 		str++;
-		eat_col--;
+		ccs_eat_col--;
 	}
 	return str;
 }
 
-static const struct domain_keeper_entry *
-is_domain_keeper(const struct path_info *domainname, const char *program)
+static const struct ccs_domain_keeper_entry *
+ccs_is_domain_keeper(const struct ccs_path_info *domainname, const char *program)
 {
 	int i;
-	const struct domain_keeper_entry *flag = NULL;
-	struct path_info last_name;
+	const struct ccs_domain_keeper_entry *flag = NULL;
+	struct ccs_path_info last_name;
 	last_name.name = strrchr(domainname->name, ' ');
 	if (last_name.name)
 		last_name.name++;
 	else
 		last_name.name = domainname->name;
-	fill_path_info(&last_name);
-	for (i = 0; i < domain_keeper_list_len; i++) {
-		struct domain_keeper_entry *ptr = &domain_keeper_list[i];
+	ccs_fill_path_info(&last_name);
+	for (i = 0; i < ccs_domain_keeper_list_len; i++) {
+		struct ccs_domain_keeper_entry *ptr = &ccs_domain_keeper_list[i];
 		if (!ptr->is_last_name) {
-			if (pathcmp(ptr->domainname, domainname))
+			if (ccs_pathcmp(ptr->domainname, domainname))
 				continue;
 		} else {
-			if (pathcmp(ptr->domainname, &last_name))
+			if (ccs_pathcmp(ptr->domainname, &last_name))
 				continue;
 		}
 		if (ptr->program && strcmp(ptr->program->name, program))
@@ -756,27 +756,27 @@
 	return flag;
 }
 
-static const struct domain_initializer_entry *
-is_domain_initializer(const struct path_info *domainname, const char *program)
+static const struct ccs_domain_initializer_entry *
+ccs_is_domain_initializer(const struct ccs_path_info *domainname, const char *program)
 {
 	int i;
-	const struct domain_initializer_entry *flag = NULL;
-	struct path_info last_name;
+	const struct ccs_domain_initializer_entry *flag = NULL;
+	struct ccs_path_info last_name;
 	last_name.name = strrchr(domainname->name, ' ');
 	if (last_name.name)
 		last_name.name++;
 	else
 		last_name.name = domainname->name;
-	fill_path_info(&last_name);
-	for (i = 0; i < domain_initializer_list_len; i++) {
-		struct domain_initializer_entry *ptr
-			= &domain_initializer_list[i];
+	ccs_fill_path_info(&last_name);
+	for (i = 0; i < ccs_domain_initializer_list_len; i++) {
+		struct ccs_domain_initializer_entry *ptr
+			= &ccs_domain_initializer_list[i];
 		if (ptr->domainname) {
 			if (!ptr->is_last_name) {
-				if (pathcmp(ptr->domainname, domainname))
+				if (ccs_pathcmp(ptr->domainname, domainname))
 					continue;
 			} else {
-				if (pathcmp(ptr->domainname, &last_name))
+				if (ccs_pathcmp(ptr->domainname, &last_name))
 					continue;
 			}
 		}
@@ -789,19 +789,19 @@
 	return flag;
 }
 
-FILE *open_write(const char *filename)
+FILE *ccs_open_write(const char *filename)
 {
-	if (network_mode) {
+	if (ccs_network_mode) {
 		const int fd = socket(AF_INET, SOCK_STREAM, 0);
 		struct sockaddr_in addr;
 		FILE *fp;
 		memset(&addr, 0, sizeof(addr));
 		addr.sin_family = AF_INET;
-		addr.sin_addr.s_addr = network_ip;
-		addr.sin_port = network_port;
+		addr.sin_addr.s_addr = ccs_network_ip;
+		addr.sin_port = ccs_network_port;
 		if (connect(fd, (struct sockaddr *) &addr, sizeof(addr))) {
 			close(fd);
-			set_error(filename);
+			ccs_set_error(filename);
 			return NULL;
 		}
 		fp = fdopen(fd, "r+");
@@ -811,11 +811,11 @@
 		fflush(fp);
 		if (fgetc(fp) != 0) {
 			fclose(fp);
-			set_error(filename);
+			ccs_set_error(filename);
 			return NULL;
 		}
 		return fp;
-	} else if (offline_mode) {
+	} else if (ccs_offline_mode) {
 		char request[1024];
 		int fd[2];
 		if (socketpair(PF_UNIX, SOCK_STREAM, 0, fd)) {
@@ -826,7 +826,7 @@
 			goto out;
 		memset(request, 0, sizeof(request));
 		snprintf(request, sizeof(request) - 1, "POST %s", filename);
-		send_fd(request, &fd[1]);
+		ccs_send_fd(request, &fd[1]);
 		return fdopen(fd[0], "w");
 out:
 		close(fd[1]);
@@ -834,25 +834,25 @@
 		exit(1);
 	} else {
 		FILE *fp;
-		if (readonly_mode)
+		if (ccs_readonly_mode)
 			return NULL;
-		fp = fdopen(open2(filename, O_WRONLY), "w");
+		fp = fdopen(ccs_open2(filename, O_WRONLY), "w");
 		if (!fp)
-			set_error(filename);
+			ccs_set_error(filename);
 		return fp;
 	}
 }
 
-FILE *open_read(const char *filename)
+FILE *ccs_open_read(const char *filename)
 {
-	if (network_mode) {
-		FILE *fp = open_write(filename);
+	if (ccs_network_mode) {
+		FILE *fp = ccs_open_write(filename);
 		if (fp) {
 			fputc(0, fp);
 			fflush(fp);
 		}
 		return fp;
-	} else if (offline_mode) {
+	} else if (ccs_offline_mode) {
 		char request[1024];
 		int fd[2];
 		FILE *fp;
@@ -867,7 +867,7 @@
 			goto out;
 		memset(request, 0, sizeof(request));
 		snprintf(request, sizeof(request) - 1, "GET %s", filename);
-		send_fd(request, &fd[1]);
+		ccs_send_fd(request, &fd[1]);
 		return fp;
 out:
 		close(fd[1]);
@@ -878,10 +878,10 @@
 	}
 }
 
-static int profile_entry_compare(const void *a, const void *b)
+static int ccs_profile_entry_compare(const void *a, const void *b)
 {
-	const struct generic_acl *a0 = (struct generic_acl *) a;
-	const struct generic_acl *b0 = (struct generic_acl *) b;
+	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
+	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
 	const char *a1 = a0->operand;
 	const char *b1 = b0->operand;
 	const int a2 = a0->directive;
@@ -902,7 +902,7 @@
 				return 1;
 		}
 	}
-	if (profile_sort_type == 0) {
+	if (ccs_profile_sort_type == 0) {
 		if (a2 == b2)
 			return strcmp(a1, b1);
 		else
@@ -920,65 +920,65 @@
 	}
 }
 
-static void read_generic_policy(void)
+static void ccs_read_generic_policy(void)
 {
 	FILE *fp = NULL;
 	_Bool flag = false;
-	while (generic_acl_list_count)
+	while (ccs_generic_acl_list_count)
 		free((void *)
-		     generic_acl_list[--generic_acl_list_count].operand);
-	if (current_screen == SCREEN_ACL_LIST) {
-		if (network_mode)
+		     ccs_generic_acl_list[--ccs_generic_acl_list_count].operand);
+	if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+		if (ccs_network_mode)
 			/* We can read after write. */
-			fp = open_write(policy_file);
-		else if (!offline_mode)
+			fp = ccs_open_write(ccs_policy_file);
+		else if (!ccs_offline_mode)
 			/* Don't set error message if failed. */
-			fp = fopen(policy_file, "r+");
+			fp = fopen(ccs_policy_file, "r+");
 		if (fp) {
-			if (domain_sort_type)
-				fprintf(fp, "select pid=%u\n", current_pid);
+			if (ccs_domain_sort_type)
+				fprintf(fp, "select pid=%u\n", ccs_current_pid);
 			else
 				fprintf(fp, "select domain=%s\n",
-					current_domain);
-			if (network_mode)
+					ccs_current_domain);
+			if (ccs_network_mode)
 				fputc(0, fp);
 			fflush(fp);
 		}
 	}
 	if (!fp)
-		fp = open_read(policy_file);
+		fp = ccs_open_read(ccs_policy_file);
 	if (!fp) {
-		set_error(policy_file);
+		ccs_set_error(ccs_policy_file);
 		return;
 	}
-	get();
+	ccs_get();
 	while (true) {
-		char *line = freadline(fp);
+		char *line = ccs_freadline(fp);
 		u16 directive;
 		char *cp;
 		if (!line)
 			break;
-		if (current_screen == SCREEN_ACL_LIST) {
-			if (is_domain_def(line)) {
-				flag = !strcmp(line, current_domain);
+		if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+			if (ccs_is_domain_def(line)) {
+				flag = !strcmp(line, ccs_current_domain);
 				continue;
 			}
 			if (!flag || !line[0] ||
-			    !strncmp(line, KEYWORD_USE_PROFILE,
-				     KEYWORD_USE_PROFILE_LEN))
+			    !strncmp(line, CCS_KEYWORD_USE_PROFILE,
+				     CCS_KEYWORD_USE_PROFILE_LEN))
 				continue;
 		} else {
 			if (!line[0])
 				continue;
 		}
-		switch (current_screen) {
-		case SCREEN_EXCEPTION_LIST:
-		case SCREEN_ACL_LIST:
-			directive = find_directive(true, line);
-			if (directive == DIRECTIVE_NONE)
+		switch (ccs_current_screen) {
+		case CCS_SCREEN_EXCEPTION_LIST:
+		case CCS_SCREEN_ACL_LIST:
+			directive = ccs_find_directive(true, line);
+			if (directive == CCS_DIRECTIVE_NONE)
 				continue;
 			break;
-		case SCREEN_PROFILE_LIST:
+		case CCS_SCREEN_PROFILE_LIST:
 			cp = strchr(line, '-');
 			if (cp) {
 				*cp++ = '\0';
@@ -988,43 +988,43 @@
 				directive = (u16) -1;
 			break;
 		default:
-			directive = DIRECTIVE_NONE;
+			directive = CCS_DIRECTIVE_NONE;
 			break;
 		}
-		generic_acl_list = realloc(generic_acl_list,
-					   (generic_acl_list_count + 1) *
-					   sizeof(struct generic_acl));
-		if (!generic_acl_list)
-			out_of_memory();
+		ccs_generic_acl_list = realloc(ccs_generic_acl_list,
+					       (ccs_generic_acl_list_count + 1) *
+					       sizeof(struct ccs_generic_acl));
+		if (!ccs_generic_acl_list)
+			ccs_out_of_memory();
 		cp = strdup(line);
 		if (!cp)
-			out_of_memory();
-		generic_acl_list[generic_acl_list_count].directive = directive;
-		generic_acl_list[generic_acl_list_count].selected = 0;
-		generic_acl_list[generic_acl_list_count++].operand = cp;
+			ccs_out_of_memory();
+		ccs_generic_acl_list[ccs_generic_acl_list_count].directive = directive;
+		ccs_generic_acl_list[ccs_generic_acl_list_count].selected = 0;
+		ccs_generic_acl_list[ccs_generic_acl_list_count++].operand = cp;
 	}
-	put();
+	ccs_put();
 	fclose(fp);
-	switch (current_screen) {
-	case SCREEN_ACL_LIST:
-		qsort(generic_acl_list, generic_acl_list_count,
-		      sizeof(struct generic_acl), generic_acl_compare);
+	switch (ccs_current_screen) {
+	case CCS_SCREEN_ACL_LIST:
+		qsort(ccs_generic_acl_list, ccs_generic_acl_list_count,
+		      sizeof(struct ccs_generic_acl), ccs_generic_acl_compare);
 		break;
-	case SCREEN_EXCEPTION_LIST:
-		qsort(generic_acl_list, generic_acl_list_count,
-		      sizeof(struct generic_acl), generic_acl_compare0);
+	case CCS_SCREEN_EXCEPTION_LIST:
+		qsort(ccs_generic_acl_list, ccs_generic_acl_list_count,
+		      sizeof(struct ccs_generic_acl), ccs_generic_acl_compare0);
 		break;
-	case SCREEN_PROFILE_LIST:
-		qsort(generic_acl_list, generic_acl_list_count,
-		      sizeof(struct generic_acl), profile_entry_compare);
+	case CCS_SCREEN_PROFILE_LIST:
+		qsort(ccs_generic_acl_list, ccs_generic_acl_list_count,
+		      sizeof(struct ccs_generic_acl), ccs_profile_entry_compare);
 		break;
 	default:
-		qsort(generic_acl_list, generic_acl_list_count,
-		      sizeof(struct generic_acl), string_acl_compare);
+		qsort(ccs_generic_acl_list, ccs_generic_acl_list_count,
+		      sizeof(struct ccs_generic_acl), ccs_string_acl_compare);
 	}
 }
 
-static pid_t get_ppid(const pid_t pid)
+static pid_t ccs_get_ppid(const pid_t pid)
 {
 	char buffer[1024];
 	FILE *fp;
@@ -1043,7 +1043,7 @@
 	return ppid;
 }
 
-static char *get_name(const pid_t pid)
+static char *ccs_get_name(const pid_t pid)
 {
 	char buffer[1024];
 	FILE *fp;
@@ -1099,47 +1099,47 @@
 	return NULL;
 }
 
-static void sort_process_entry(const pid_t pid, const int depth)
+static void ccs_sort_process_entry(const pid_t pid, const int depth)
 {
 	int i;
-	for (i = 0; i < task_list_len; i++) {
-		if (pid != task_list[i].pid)
+	for (i = 0; i < ccs_task_list_len; i++) {
+		if (pid != ccs_task_list[i].pid)
 			continue;
-		task_list[i].index = dump_index++;
-		task_list[i].depth = depth;
-		task_list[i].selected = true;
+		ccs_task_list[i].index = ccs_dump_index++;
+		ccs_task_list[i].depth = depth;
+		ccs_task_list[i].selected = true;
 	}
-	for (i = 0; i < task_list_len; i++) {
-		if (pid != task_list[i].ppid)
+	for (i = 0; i < ccs_task_list_len; i++) {
+		if (pid != ccs_task_list[i].ppid)
 			continue;
-		sort_process_entry(task_list[i].pid, depth + 1);
+		ccs_sort_process_entry(ccs_task_list[i].pid, depth + 1);
 	}
 }
 
-static int task_entry_compare(const void *a, const void *b)
+static int ccs_task_entry_compare(const void *a, const void *b)
 {
-	const struct task_entry *a0 = (struct task_entry *) a;
-	const struct task_entry *b0 = (struct task_entry *) b;
+	const struct ccs_task_entry *a0 = (struct ccs_task_entry *) a;
+	const struct ccs_task_entry *b0 = (struct ccs_task_entry *) b;
 	return a0->index - b0->index;
 }
 
-void read_process_list(_Bool show_all)
+void ccs_read_process_list(_Bool show_all)
 {
 	int i;
-	while (task_list_len) {
-		task_list_len--;
-		free((void *) task_list[task_list_len].name);
-		free((void *) task_list[task_list_len].domain);
+	while (ccs_task_list_len) {
+		ccs_task_list_len--;
+		free((void *) ccs_task_list[ccs_task_list_len].name);
+		free((void *) ccs_task_list[ccs_task_list_len].domain);
 	}
-	dump_index = 0;
-	if (network_mode) {
-		FILE *fp = open_write(show_all ? "proc:all_process_status" :
-				      "proc:process_status");
+	ccs_dump_index = 0;
+	if (ccs_network_mode) {
+		FILE *fp = ccs_open_write(show_all ? "proc:all_process_status" :
+					  "proc:process_status");
 		if (!fp)
 			return;
-		get();
+		ccs_get();
 		while (true) {
-			char *line = freadline(fp);
+			char *line = ccs_freadline(fp);
 			unsigned int pid = 0;
 			unsigned int ppid = 0;
 			int profile = -1;
@@ -1154,8 +1154,8 @@
 			if (!name)
 				name = strdup("<UNKNOWN>");
 			if (!name)
-				out_of_memory();
-			line = freadline(fp);
+				ccs_out_of_memory();
+			line = ccs_freadline(fp);
 			if (!line ||
 			    sscanf(line, "%u %u", &pid, &profile) != 2) {
 				free(name);
@@ -1167,27 +1167,27 @@
 			if (!domain)
 				domain = strdup("<UNKNOWN>");
 			if (!domain)
-				out_of_memory();
-			task_list = realloc(task_list,
-					    (task_list_len + 1) *
-					    sizeof(struct task_entry));
-			if (!task_list)
-				out_of_memory();
-			memset(&task_list[task_list_len], 0,
-			       sizeof(task_list[0]));
-			task_list[task_list_len].pid = pid;
-			task_list[task_list_len].ppid = ppid;
-			task_list[task_list_len].profile = profile;
-			task_list[task_list_len].name = name;
-			task_list[task_list_len].domain = domain;
-			task_list_len++;
+				ccs_out_of_memory();
+			ccs_task_list = realloc(ccs_task_list,
+						(ccs_task_list_len + 1) *
+						sizeof(struct ccs_task_entry));
+			if (!ccs_task_list)
+				ccs_out_of_memory();
+			memset(&ccs_task_list[ccs_task_list_len], 0,
+			       sizeof(ccs_task_list[0]));
+			ccs_task_list[ccs_task_list_len].pid = pid;
+			ccs_task_list[ccs_task_list_len].ppid = ppid;
+			ccs_task_list[ccs_task_list_len].profile = profile;
+			ccs_task_list[ccs_task_list_len].name = name;
+			ccs_task_list[ccs_task_list_len].domain = domain;
+			ccs_task_list_len++;
 		}
-		put();
+		ccs_put();
 		fclose(fp);
 	} else {
 		static const int line_len = 8192;
 		char *line;
-		int status_fd = open(proc_policy_process_status, O_RDWR);
+		int status_fd = open(ccs_proc_policy_process_status, O_RDWR);
 		DIR *dir = opendir("/proc/");
 		if (status_fd == EOF || !dir) {
 			if (status_fd != EOF)
@@ -1198,7 +1198,7 @@
 		}
 		line = malloc(line_len);
 		if (!line)
-			out_of_memory();
+			ccs_out_of_memory();
 		while (1) {
 			char *name;
 			char *domain;
@@ -1219,11 +1219,11 @@
 				if (readlink(buffer, test, sizeof(test)) <= 0)
 					continue;
 			}
-			name = get_name(pid);
+			name = ccs_get_name(pid);
 			if (!name)
 				name = strdup("<UNKNOWN>");
 			if (!name)
-				out_of_memory();
+				ccs_out_of_memory();
 			snprintf(buffer, sizeof(buffer) - 1, "%u\n", pid);
 			write(status_fd, buffer, strlen(buffer));
 			memset(line, 0, line_len);
@@ -1238,120 +1238,120 @@
 			if (!domain)
 				domain = strdup("<UNKNOWN>");
 			if (!domain)
-				out_of_memory();
-			task_list = realloc(task_list, (task_list_len + 1) *
-					    sizeof(struct task_entry));
-			if (!task_list)
-				out_of_memory();
-			memset(&task_list[task_list_len], 0,
-			       sizeof(task_list[0]));
-			task_list[task_list_len].pid = pid;
-			task_list[task_list_len].ppid = get_ppid(pid);
-			task_list[task_list_len].profile = profile;
-			task_list[task_list_len].name = name;
-			task_list[task_list_len].domain = domain;
-			task_list_len++;
+				ccs_out_of_memory();
+			ccs_task_list = realloc(ccs_task_list, (ccs_task_list_len + 1) *
+						sizeof(struct ccs_task_entry));
+			if (!ccs_task_list)
+				ccs_out_of_memory();
+			memset(&ccs_task_list[ccs_task_list_len], 0,
+			       sizeof(ccs_task_list[0]));
+			ccs_task_list[ccs_task_list_len].pid = pid;
+			ccs_task_list[ccs_task_list_len].ppid = ccs_get_ppid(pid);
+			ccs_task_list[ccs_task_list_len].profile = profile;
+			ccs_task_list[ccs_task_list_len].name = name;
+			ccs_task_list[ccs_task_list_len].domain = domain;
+			ccs_task_list_len++;
 		}
 		free(line);
 		closedir(dir);
 		close(status_fd);
 	}
-	sort_process_entry(1, 0);
-	for (i = 0; i < task_list_len; i++) {
-		if (task_list[i].selected) {
-			task_list[i].selected = false;
+	ccs_sort_process_entry(1, 0);
+	for (i = 0; i < ccs_task_list_len; i++) {
+		if (ccs_task_list[i].selected) {
+			ccs_task_list[i].selected = false;
 			continue;
 		}
-		task_list[i].index = dump_index++;
-		task_list[i].depth = 0;
+		ccs_task_list[i].index = ccs_dump_index++;
+		ccs_task_list[i].depth = 0;
 	}
-	qsort(task_list, task_list_len, sizeof(struct task_entry),
-	      task_entry_compare);
+	qsort(ccs_task_list, ccs_task_list_len, sizeof(struct ccs_task_entry),
+	      ccs_task_entry_compare);
 }
 
-static int add_domain_initializer_entry(const char *domainname,
-					const char *program, const _Bool is_not)
+static int ccs_add_domain_initializer_entry(const char *domainname,
+					    const char *program, const _Bool is_not)
 {
 	void *vp;
-	struct domain_initializer_entry *ptr;
+	struct ccs_domain_initializer_entry *ptr;
 	_Bool is_last_name = false;
-	if (!is_correct_path(program, 1, 0, -1))
+	if (!ccs_is_correct_path(program, 1, 0, -1))
 		return -EINVAL;
 	if (domainname) {
-		if (is_correct_path(domainname, 1, -1, -1))
+		if (ccs_is_correct_path(domainname, 1, -1, -1))
 			is_last_name = true;
-		else if (!is_correct_domain(domainname))
+		else if (!ccs_is_correct_domain(domainname))
 			return -EINVAL;
 	}
-	vp = realloc(domain_initializer_list,
-		     (domain_initializer_list_len + 1) *
-		     sizeof(struct domain_initializer_entry));
+	vp = realloc(ccs_domain_initializer_list,
+		     (ccs_domain_initializer_list_len + 1) *
+		     sizeof(struct ccs_domain_initializer_entry));
 	if (!vp)
-		out_of_memory();
-	domain_initializer_list = vp;
-	ptr = &domain_initializer_list[domain_initializer_list_len++];
-	memset(ptr, 0, sizeof(struct domain_initializer_entry));
-	ptr->program = savename(program);
+		ccs_out_of_memory();
+	ccs_domain_initializer_list = vp;
+	ptr = &ccs_domain_initializer_list[ccs_domain_initializer_list_len++];
+	memset(ptr, 0, sizeof(struct ccs_domain_initializer_entry));
+	ptr->program = ccs_savename(program);
 	if (!ptr->program)
-		out_of_memory();
+		ccs_out_of_memory();
 	if (domainname) {
-		ptr->domainname = savename(domainname);
+		ptr->domainname = ccs_savename(domainname);
 		if (!ptr->domainname)
-			out_of_memory();
+			ccs_out_of_memory();
 	}
 	ptr->is_not = is_not;
 	ptr->is_last_name = is_last_name;
 	return 0;
 }
 
-static int add_domain_keeper_entry(const char *domainname, const char *program,
-				   const _Bool is_not)
+static int ccs_add_domain_keeper_entry(const char *domainname, const char *program,
+				       const _Bool is_not)
 {
-	struct domain_keeper_entry *ptr;
+	struct ccs_domain_keeper_entry *ptr;
 	_Bool is_last_name = false;
-	if (is_correct_path(domainname, 1, -1, -1))
+	if (ccs_is_correct_path(domainname, 1, -1, -1))
 		is_last_name = true;
-	else if (!is_correct_domain(domainname))
+	else if (!ccs_is_correct_domain(domainname))
 		return -EINVAL;
-	if (program && !is_correct_path(program, 1, 0, -1))
+	if (program && !ccs_is_correct_path(program, 1, 0, -1))
 		return -EINVAL;
-	domain_keeper_list = realloc(domain_keeper_list,
-				     (domain_keeper_list_len + 1) *
-				     sizeof(struct domain_keeper_entry));
-	if (!domain_keeper_list)
-		out_of_memory();
-	ptr = &domain_keeper_list[domain_keeper_list_len++];
-	memset(ptr, 0, sizeof(struct domain_keeper_entry));
-	ptr->domainname = savename(domainname);
+	ccs_domain_keeper_list = realloc(ccs_domain_keeper_list,
+					 (ccs_domain_keeper_list_len + 1) *
+					 sizeof(struct ccs_domain_keeper_entry));
+	if (!ccs_domain_keeper_list)
+		ccs_out_of_memory();
+	ptr = &ccs_domain_keeper_list[ccs_domain_keeper_list_len++];
+	memset(ptr, 0, sizeof(struct ccs_domain_keeper_entry));
+	ptr->domainname = ccs_savename(domainname);
 	if (!ptr->domainname)
-		out_of_memory();
+		ccs_out_of_memory();
 	if (program) {
-		ptr->program = savename(program);
+		ptr->program = ccs_savename(program);
 		if (!ptr->program)
-			out_of_memory();
+			ccs_out_of_memory();
 	}
 	ptr->is_not = is_not;
 	ptr->is_last_name = is_last_name;
 	return 0;
 }
 
-static int add_path_group_entry(const char *group_name, const char *member_name,
+static int ccs_add_path_group_entry(const char *group_name, const char *member_name,
 				const _Bool is_delete)
 {
-	const struct path_info *saved_group_name;
-	const struct path_info *saved_member_name;
+	const struct ccs_path_info *saved_group_name;
+	const struct ccs_path_info *saved_member_name;
 	int i;
 	int j;
-	struct path_group_entry *group = NULL;
-	if (!is_correct_path(group_name, 0, 0, 0) ||
-	    !is_correct_path(member_name, 0, 0, 0))
+	struct ccs_path_group_entry *group = NULL;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
+	    !ccs_is_correct_path(member_name, 0, 0, 0))
 		return -EINVAL;
-	saved_group_name = savename(group_name);
-	saved_member_name = savename(member_name);
+	saved_group_name = ccs_savename(group_name);
+	saved_member_name = ccs_savename(member_name);
 	if (!saved_group_name || !saved_member_name)
 		return -ENOMEM;
-	for (i = 0; i < path_group_list_len; i++) {
-		group = &path_group_list[i];
+	for (i = 0; i < ccs_path_group_list_len; i++) {
+		group = &ccs_path_group_list[i];
 		if (saved_group_name != group->group_name)
 			continue;
 		for (j = 0; j < group->member_name_len; j++) {
@@ -1369,126 +1369,126 @@
 	}
 	if (is_delete)
 		return -ENOENT;
-	if (i == path_group_list_len) {
-		path_group_list = realloc(path_group_list,
-					  (path_group_list_len + 1) *
-					  sizeof(struct path_group_entry));
-		if (!path_group_list)
-			out_of_memory();
-		group = &path_group_list[path_group_list_len++];
-		memset(group, 0, sizeof(struct path_group_entry));
+	if (i == ccs_path_group_list_len) {
+		ccs_path_group_list = realloc(ccs_path_group_list,
+					  (ccs_path_group_list_len + 1) *
+					  sizeof(struct ccs_path_group_entry));
+		if (!ccs_path_group_list)
+			ccs_out_of_memory();
+		group = &ccs_path_group_list[ccs_path_group_list_len++];
+		memset(group, 0, sizeof(struct ccs_path_group_entry));
 		group->group_name = saved_group_name;
 	}
 	group->member_name = realloc(group->member_name,
 				     (group->member_name_len + 1)
-				     * sizeof(const struct path_info *));
+				     * sizeof(const struct ccs_path_info *));
 	if (!group->member_name)
-		out_of_memory();
+		ccs_out_of_memory();
 	group->member_name[group->member_name_len++] = saved_member_name;
 	return 0;
 }
 
-static void read_domain_and_exception_policy(struct domain_policy *dp)
+static void ccs_read_domain_and_exception_policy(struct ccs_domain_policy *dp)
 {
 	FILE *fp;
 	int i;
 	int j;
 	int index;
 	int max_index;
-	clear_domain_policy(dp);
-	domain_keeper_list_len = 0;
-	domain_initializer_list_len = 0;
-	while (path_group_list_len)
-		free(path_group_list[--path_group_list_len].member_name);
+	ccs_clear_domain_policy(dp);
+	ccs_domain_keeper_list_len = 0;
+	ccs_domain_initializer_list_len = 0;
+	while (ccs_path_group_list_len)
+		free(ccs_path_group_list[--ccs_path_group_list_len].member_name);
 	/*
-	while (address_group_list_len)
-		free(address_group_list[--address_group_list_len].member_name);
+	while (ccs_address_group_list_len)
+		free(ccs_address_group_list[--ccs_address_group_list_len].member_name);
 	*/
-	address_group_list_len = 0;
-	number_group_list_len = 0;
-	find_or_assign_new_domain(dp, ROOT_NAME, false, false);
+	ccs_address_group_list_len = 0;
+	ccs_number_group_list_len = 0;
+	ccs_find_or_assign_new_domain(dp, CCS_ROOT_NAME, false, false);
 
 	/* Load domain_initializer list, domain_keeper list. */
-	fp = open_read(proc_policy_exception_policy);
+	fp = ccs_open_read(ccs_proc_policy_exception_policy);
 	if (!fp) {
-		set_error(proc_policy_exception_policy);
+		ccs_set_error(ccs_proc_policy_exception_policy);
 		goto no_exception;
 	}
-	get();
+	ccs_get();
 	while (true) {
-		char *line = freadline(fp);
+		char *line = ccs_freadline(fp);
 		if (!line)
 			break;
-		if (str_starts(line, KEYWORD_INITIALIZE_DOMAIN))
-			add_domain_initializer_policy(line, false);
-		else if (str_starts(line, KEYWORD_NO_INITIALIZE_DOMAIN))
-			add_domain_initializer_policy(line, true);
-		else if (str_starts(line, KEYWORD_KEEP_DOMAIN))
-			add_domain_keeper_policy(line, false);
-		else if (str_starts(line, KEYWORD_NO_KEEP_DOMAIN))
-			add_domain_keeper_policy(line, true);
-		else if (str_starts(line, KEYWORD_PATH_GROUP))
-			add_path_group_policy(line, false);
-		else if (str_starts(line, KEYWORD_ADDRESS_GROUP))
-			add_address_group_policy(line, false);
-		else if (str_starts(line, KEYWORD_NUMBER_GROUP))
-			add_number_group_policy(line, false);
+		if (ccs_str_starts(line, CCS_KEYWORD_INITIALIZE_DOMAIN))
+			ccs_add_domain_initializer_policy(line, false);
+		else if (ccs_str_starts(line, CCS_KEYWORD_NO_INITIALIZE_DOMAIN))
+			ccs_add_domain_initializer_policy(line, true);
+		else if (ccs_str_starts(line, CCS_KEYWORD_KEEP_DOMAIN))
+			ccs_add_domain_keeper_policy(line, false);
+		else if (ccs_str_starts(line, CCS_KEYWORD_NO_KEEP_DOMAIN))
+			ccs_add_domain_keeper_policy(line, true);
+		else if (ccs_str_starts(line, CCS_KEYWORD_PATH_GROUP))
+			ccs_add_path_group_policy(line, false);
+		else if (ccs_str_starts(line, CCS_KEYWORD_ADDRESS_GROUP))
+			ccs_add_address_group_policy(line, false);
+		else if (ccs_str_starts(line, CCS_KEYWORD_NUMBER_GROUP))
+			ccs_add_number_group_policy(line, false);
 	}
-	put();
+	ccs_put();
 	fclose(fp);
 no_exception:
 
 	/* Load all domain list. */
 	fp = NULL;
-	if (network_mode)
+	if (ccs_network_mode)
 		/* We can read after write. */
-		fp = open_write(policy_file);
-	else if (!offline_mode)
+		fp = ccs_open_write(ccs_policy_file);
+	else if (!ccs_offline_mode)
 		/* Don't set error message if failed. */
-		fp = fopen(policy_file, "r+");
+		fp = fopen(ccs_policy_file, "r+");
 	if (fp) {
 		fprintf(fp, "select allow_execute\n");
-		if (network_mode)
+		if (ccs_network_mode)
 			fputc(0, fp);
 		fflush(fp);
 	}
 	if (!fp)
-		fp = open_read(proc_policy_domain_policy);
+		fp = ccs_open_read(ccs_proc_policy_domain_policy);
 	if (!fp) {
-		set_error(proc_policy_domain_policy);
+		ccs_set_error(ccs_proc_policy_domain_policy);
 		goto no_domain;
 	}
 	index = EOF;
-	get();
+	ccs_get();
 	while (true) {
-		char *line = freadline(fp);
+		char *line = ccs_freadline(fp);
 		unsigned int profile;
 		if (!line)
 			break;
-		if (is_domain_def(line)) {
-			index = find_or_assign_new_domain(dp, line, false,
-							  false);
+		if (ccs_is_domain_def(line)) {
+			index = ccs_find_or_assign_new_domain(dp, line, false,
+							      false);
 			continue;
 		} else if (index == EOF) {
 			continue;
 		}
-		if (str_starts(line, KEYWORD_EXECUTE_HANDLER)) {
-			add_string_entry(dp, line, index);
-		} else if (str_starts(line, KEYWORD_DENIED_EXECUTE_HANDLER)) {
-			add_string_entry(dp, line, index);
-		} else if (str_starts(line, KEYWORD_ALLOW_EXECUTE)) {
+		if (ccs_str_starts(line, CCS_KEYWORD_EXECUTE_HANDLER)) {
+			ccs_add_string_entry(dp, line, index);
+		} else if (ccs_str_starts(line, CCS_KEYWORD_DENIED_EXECUTE_HANDLER)) {
+			ccs_add_string_entry(dp, line, index);
+		} else if (ccs_str_starts(line, CCS_KEYWORD_ALLOW_EXECUTE)) {
 			char *cp = strchr(line, ' ');
 			if (cp)
 				*cp = '\0';
-			if (*line == '@' || is_correct_path(line, 1, 0, -1))
-				add_string_entry(dp, line, index);
-		} else if (sscanf(line, KEYWORD_USE_PROFILE "%u", &profile)
+			if (*line == '@' || ccs_is_correct_path(line, 1, 0, -1))
+				ccs_add_string_entry(dp, line, index);
+		} else if (sscanf(line, CCS_KEYWORD_USE_PROFILE "%u", &profile)
 			   == 1) {
 			dp->list[index].profile = (u8) profile;
 			dp->list[index].profile_assigned = 1;
 		}
 	}
-	put();
+	ccs_put();
 	fclose(fp);
 no_domain:
 
@@ -1497,46 +1497,46 @@
 	/* Find unreachable domains. */
 	for (index = 0; index < max_index; index++) {
 		char *line;
-		get();
-		line = shprintf("%s", domain_name(dp, index));
+		ccs_get();
+		line = ccs_shprintf("%s", ccs_domain_name(dp, index));
 		while (true) {
-			const struct domain_initializer_entry *d_i;
-			const struct domain_keeper_entry *d_k;
-			struct path_info parent;
+			const struct ccs_domain_initializer_entry *d_i;
+			const struct ccs_domain_keeper_entry *d_k;
+			struct ccs_path_info parent;
 			char *cp = strrchr(line, ' ');
 			if (!cp)
 				break;
 			*cp++ = '\0';
 			parent.name = line;
-			fill_path_info(&parent);
-			d_i = is_domain_initializer(&parent, cp);
+			ccs_fill_path_info(&parent);
+			d_i = ccs_is_domain_initializer(&parent, cp);
 			if (d_i) {
 				/* Initializer under <kernel> is reachable. */
-				if (parent.total_len == ROOT_NAME_LEN)
+				if (parent.total_len == CCS_ROOT_NAME_LEN)
 					break;
 				dp->list[index].d_i = d_i;
 				dp->list[index].d_k = NULL;
 				continue;
 			}
-			d_k = is_domain_keeper(&parent, cp);
+			d_k = ccs_is_domain_keeper(&parent, cp);
 			if (d_k) {
 				dp->list[index].d_i = NULL;
 				dp->list[index].d_k = d_k;
 			}
 		}
-		put();
+		ccs_put();
 		if (dp->list[index].d_i || dp->list[index].d_k)
 			dp->list[index].is_du = true;
 	}
 
 	/* Find domain initializer target domains. */
 	for (index = 0; index < max_index; index++) {
-		char *cp = strchr(domain_name(dp, index), ' ');
+		char *cp = strchr(ccs_domain_name(dp, index), ' ');
 		if (!cp || strchr(cp + 1, ' '))
 			continue;
-		for (i = 0; i < domain_initializer_list_len; i++) {
-			struct domain_initializer_entry *ptr
-				= &domain_initializer_list[i];
+		for (i = 0; i < ccs_domain_initializer_list_len; i++) {
+			struct ccs_domain_initializer_entry *ptr
+				= &ccs_domain_initializer_list[i];
 			if (ptr->is_not)
 				continue;
 			if (strcmp(ptr->program->name, cp + 1))
@@ -1547,14 +1547,14 @@
 
 	/* Find domain keeper domains. */
 	for (index = 0; index < max_index; index++) {
-		for (i = 0; i < domain_keeper_list_len; i++) {
-			struct domain_keeper_entry *ptr
-				= &domain_keeper_list[i];
+		for (i = 0; i < ccs_domain_keeper_list_len; i++) {
+			struct ccs_domain_keeper_entry *ptr
+				= &ccs_domain_keeper_list[i];
 			char *cp;
 			if (ptr->is_not)
 				continue;
 			if (!ptr->is_last_name) {
-				if (pathcmp(ptr->domainname,
+				if (ccs_pathcmp(ptr->domainname,
 					    dp->list[index].domainname))
 					continue;
 				dp->list[index].is_dk = true;
@@ -1570,30 +1570,30 @@
 
 	/* Create domain initializer source domains. */
 	for (index = 0; index < max_index; index++) {
-		const struct path_info *domainname
+		const struct ccs_path_info *domainname
 			= dp->list[index].domainname;
-		const struct path_info **string_ptr
+		const struct ccs_path_info **string_ptr
 			= dp->list[index].string_ptr;
 		const int max_count = dp->list[index].string_count;
 		/* Don't create source domain under <kernel> because
-		   they will become target domains. */
-		if (domainname->total_len == ROOT_NAME_LEN)
+		   they will become ccs_target domains. */
+		if (domainname->total_len == CCS_ROOT_NAME_LEN)
 			continue;
 		for (i = 0; i < max_count; i++) {
-			const struct path_info *cp = string_ptr[i];
-			struct path_group_entry *group;
+			const struct ccs_path_info *cp = string_ptr[i];
+			struct ccs_path_group_entry *group;
 			if (cp->name[0] != '@') {
-				assign_domain_initializer_source(dp, domainname,
-								 cp->name);
+				ccs_assign_domain_initializer_source(dp, domainname,
+								     cp->name);
 				continue;
 			}
-			group = find_path_group(cp->name + 1);
+			group = ccs_find_path_group(cp->name + 1);
 			if (!group)
 				continue;
 			for (j = 0; j < group->member_name_len; j++) {
 				cp = group->member_name[j];
-				assign_domain_initializer_source(dp, domainname,
-								 cp->name);
+				ccs_assign_domain_initializer_source(dp, domainname,
+								     cp->name);
 			}
 		}
 	}
@@ -1601,36 +1601,36 @@
 	/* Create missing parent domains. */
 	for (index = 0; index < max_index; index++) {
 		char *line;
-		get();
-		line = shprintf("%s", domain_name(dp, index));
+		ccs_get();
+		line = ccs_shprintf("%s", ccs_domain_name(dp, index));
 		while (true) {
 			char *cp = strrchr(line, ' ');
 			if (!cp)
 				break;
 			*cp = '\0';
-			if (find_domain(dp, line, false, false) != EOF)
+			if (ccs_find_domain(dp, line, false, false) != EOF)
 				continue;
-			if (find_or_assign_new_domain(dp, line, false, true)
+			if (ccs_find_or_assign_new_domain(dp, line, false, true)
 			    == EOF)
-				out_of_memory();
+				ccs_out_of_memory();
 		}
-		put();
+		ccs_put();
 	}
 
 	/* Sort by domain name. */
-	qsort(dp->list, dp->list_len, sizeof(struct domain_info),
-	      domainname_attribute_compare);
+	qsort(dp->list, dp->list_len, sizeof(struct ccs_domain_info),
+	      ccs_domainname_attribute_compare);
 
 	/* Assign domain numbers. */
 	{
 		int number = 0;
 		int index;
-		unnumbered_domain_count = 0;
+		ccs_unnumbered_domain_count = 0;
 		for (index = 0; index < dp->list_len; index++) {
-			if (is_deleted_domain(dp, index) ||
-			    is_initializer_source(dp, index)) {
+			if (ccs_is_deleted_domain(dp, index) ||
+			    ccs_is_initializer_source(dp, index)) {
 				dp->list[index].number = -1;
-				unnumbered_domain_count++;
+				ccs_unnumbered_domain_count++;
 			} else {
 				dp->list[index].number = number++;
 			}
@@ -1639,176 +1639,176 @@
 
 	dp->list_selected = realloc(dp->list_selected, dp->list_len);
 	if (dp->list_len && !dp->list_selected)
-		out_of_memory();
+		ccs_out_of_memory();
 	memset(dp->list_selected, 0, dp->list_len);
 }
 
-static int show_process_line(const int index)
+static int ccs_show_process_line(const int index)
 {
 	char *line;
 	int tmp_col = 0;
 	int i;
-	printw("%c%4d:%3u ", task_list[index].selected ? '&' : ' ', index,
-	       task_list[index].profile);
+	printw("%c%4d:%3u ", ccs_task_list[index].selected ? '&' : ' ', index,
+	       ccs_task_list[index].profile);
 	tmp_col += 10;
-	for (i = 0; i < task_list[index].depth - 1; i++) {
-		printw("%s", eat("    "));
+	for (i = 0; i < ccs_task_list[index].depth - 1; i++) {
+		printw("%s", ccs_eat("    "));
 		tmp_col += 4;
 	}
-	get();
-	line = shprintf("%s%s (%u) %s", task_list[index].depth ?
-			" +- " : "", task_list[index].name,
-			task_list[index].pid, task_list[index].domain);
-	printw("%s", eat(line));
+	ccs_get();
+	line = ccs_shprintf("%s%s (%u) %s", ccs_task_list[index].depth ?
+			    " +- " : "", ccs_task_list[index].name,
+			    ccs_task_list[index].pid, ccs_task_list[index].domain);
+	printw("%s", ccs_eat(line));
 	tmp_col += strlen(line);
-	put();
+	ccs_put();
 	return tmp_col;
 }
 
-static void show_list(struct domain_policy *dp)
+static void ccs_show_list(struct ccs_domain_policy *dp)
 {
-	const int offset = current_item_index[current_screen];
+	const int offset = ccs_current_item_index[ccs_current_screen];
 	int i;
 	int tmp_col;
-	if (current_screen == SCREEN_DOMAIN_LIST)
-		list_item_count[SCREEN_DOMAIN_LIST] = domain_sort_type ?
-			task_list_len : dp->list_len;
+	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST)
+		ccs_list_item_count[CCS_SCREEN_DOMAIN_LIST] = ccs_domain_sort_type ?
+			ccs_task_list_len : dp->list_len;
 	else
-		list_item_count[current_screen] = generic_acl_list_count;
+		ccs_list_item_count[ccs_current_screen] = ccs_generic_acl_list_count;
 	clear();
 	move(0, 0);
-	if (window_height < header_lines + 1) {
+	if (ccs_window_height < ccs_header_lines + 1) {
 		printw("Please enlarge window.");
 		clrtobot();
 		refresh();
 		return;
 	}
 	/* add color */
-	editpolicy_color_change(editpolicy_color_head(current_screen), true);
-	if (current_screen == SCREEN_DOMAIN_LIST) {
-		if (domain_sort_type) {
+	ccs_editpolicy_color_change(ccs_editpolicy_color_head(ccs_current_screen), true);
+	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+		if (ccs_domain_sort_type) {
 			printw("<<< Process State Viewer >>>"
 			       "      %d process%s    '?' for help",
-			       task_list_len, task_list_len > 1 ? "es" : "");
+			       ccs_task_list_len, ccs_task_list_len > 1 ? "es" : "");
 		} else {
-			int i = list_item_count[SCREEN_DOMAIN_LIST]
-				- unnumbered_domain_count;
+			int i = ccs_list_item_count[CCS_SCREEN_DOMAIN_LIST]
+				- ccs_unnumbered_domain_count;
 			printw("<<< Domain Transition Editor >>>"
 			       "      %d domain%c    '?' for help",
 			       i, i > 1 ? 's' : ' ');
 		}
 	} else {
-		int i = list_item_count[current_screen];
+		int i = ccs_list_item_count[ccs_current_screen];
 		printw("<<< %s >>>"
-		       "      %d entr%s    '?' for help", list_caption,
+		       "      %d entr%s    '?' for help", ccs_list_caption,
 		       i, i > 1 ? "ies" : "y");
 	}
 	/* add color */
-	editpolicy_color_change(editpolicy_color_head(current_screen), false);
-	eat_col = max_eat_col[current_screen];
-	max_col = 0;
-	if (current_screen == SCREEN_ACL_LIST) {
+	ccs_editpolicy_color_change(ccs_editpolicy_color_head(ccs_current_screen), false);
+	ccs_eat_col = ccs_max_eat_col[ccs_current_screen];
+	ccs_max_col = 0;
+	if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
 		char *line;
-		get();
-		line = shprintf("%s", eat(current_domain));
-		editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		ccs_get();
+		line = ccs_shprintf("%s", ccs_eat(ccs_current_domain));
+		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
 		move(2, 0);
 		printw("%s", line);
-		editpolicy_attr_change(A_REVERSE, false); /* add color */
-		put();
+		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		ccs_put();
 	}
-	list_indent = 0;
-	switch (current_screen) {
-	case SCREEN_EXCEPTION_LIST:
-	case SCREEN_ACL_LIST:
-		for (i = 0; i < list_item_count[current_screen]; i++) {
-			const u8 directive = generic_acl_list[i].directive;
-			const int len = directives[directive].alias_len;
-			if (len > list_indent)
-				list_indent = len;
+	ccs_list_indent = 0;
+	switch (ccs_current_screen) {
+	case CCS_SCREEN_EXCEPTION_LIST:
+	case CCS_SCREEN_ACL_LIST:
+		for (i = 0; i < ccs_list_item_count[ccs_current_screen]; i++) {
+			const u8 directive = ccs_generic_acl_list[i].directive;
+			const int len = ccs_directives[directive].alias_len;
+			if (len > ccs_list_indent)
+				ccs_list_indent = len;
 		}
 		break;
 	}
-	for (i = 0; i < body_lines; i++) {
+	for (i = 0; i < ccs_body_lines; i++) {
 		const int index = offset + i;
-		eat_col = max_eat_col[current_screen];
-		if (index >= list_item_count[current_screen])
+		ccs_eat_col = ccs_max_eat_col[ccs_current_screen];
+		if (index >= ccs_list_item_count[ccs_current_screen])
 			break;
-		move(header_lines + i, 0);
-		switch (current_screen) {
-		case SCREEN_DOMAIN_LIST:
-			if (!domain_sort_type)
-				tmp_col = show_domain_line(dp, index);
+		move(ccs_header_lines + i, 0);
+		switch (ccs_current_screen) {
+		case CCS_SCREEN_DOMAIN_LIST:
+			if (!ccs_domain_sort_type)
+				tmp_col = ccs_show_domain_line(dp, index);
 			else
-				tmp_col = show_process_line(index);
+				tmp_col = ccs_show_process_line(index);
 			break;
-		case SCREEN_EXCEPTION_LIST:
-		case SCREEN_ACL_LIST:
-			tmp_col = show_acl_line(index, list_indent);
+		case CCS_SCREEN_EXCEPTION_LIST:
+		case CCS_SCREEN_ACL_LIST:
+			tmp_col = ccs_show_acl_line(index, ccs_list_indent);
 			break;
-		case SCREEN_PROFILE_LIST:
-			tmp_col = show_profile_line(index);
+		case CCS_SCREEN_PROFILE_LIST:
+			tmp_col = ccs_show_profile_line(index);
 			break;
-		case SCREEN_MEMINFO_LIST:
-			tmp_col = show_meminfo_line(index);
+		case CCS_SCREEN_MEMINFO_LIST:
+			tmp_col = ccs_show_meminfo_line(index);
 			break;
 		default:
-			tmp_col = show_literal_line(index);
+			tmp_col = ccs_show_literal_line(index);
 			break;
 		}
 		clrtoeol();
-		tmp_col -= window_width;
-		if (tmp_col > max_col)
-			max_col = tmp_col;
+		tmp_col -= ccs_window_width;
+		if (tmp_col > ccs_max_col)
+			ccs_max_col = tmp_col;
 	}
-	show_current(dp);
+	ccs_show_current(dp);
 }
 
-static void resize_window(void)
+static void ccs_resize_window(void)
 {
-	getmaxyx(stdscr, window_height, window_width);
-	body_lines = window_height - header_lines;
-	if (body_lines <= current_y[current_screen])
-		current_y[current_screen] = body_lines - 1;
-	if (current_y[current_screen] < 0)
-		current_y[current_screen] = 0;
+	getmaxyx(stdscr, ccs_window_height, ccs_window_width);
+	ccs_body_lines = ccs_window_height - ccs_header_lines;
+	if (ccs_body_lines <= ccs_current_y[ccs_current_screen])
+		ccs_current_y[ccs_current_screen] = ccs_body_lines - 1;
+	if (ccs_current_y[ccs_current_screen] < 0)
+		ccs_current_y[ccs_current_screen] = 0;
 }
 
-static void up_arrow_key(struct domain_policy *dp)
+static void ccs_up_arrow_key(struct ccs_domain_policy *dp)
 {
-	if (current_y[current_screen] > 0) {
-		current_y[current_screen]--;
-		show_current(dp);
-	} else if (current_item_index[current_screen] > 0) {
-		current_item_index[current_screen]--;
-		show_list(dp);
+	if (ccs_current_y[ccs_current_screen] > 0) {
+		ccs_current_y[ccs_current_screen]--;
+		ccs_show_current(dp);
+	} else if (ccs_current_item_index[ccs_current_screen] > 0) {
+		ccs_current_item_index[ccs_current_screen]--;
+		ccs_show_list(dp);
 	}
 }
 
-static void down_arrow_key(struct domain_policy *dp)
+static void ccs_down_arrow_key(struct ccs_domain_policy *dp)
 {
-	if (current_y[current_screen] < body_lines - 1) {
-		if (current_item_index[current_screen]
-		    + current_y[current_screen]
-		    < list_item_count[current_screen] - 1) {
-			current_y[current_screen]++;
-			show_current(dp);
+	if (ccs_current_y[ccs_current_screen] < ccs_body_lines - 1) {
+		if (ccs_current_item_index[ccs_current_screen]
+		    + ccs_current_y[ccs_current_screen]
+		    < ccs_list_item_count[ccs_current_screen] - 1) {
+			ccs_current_y[ccs_current_screen]++;
+			ccs_show_current(dp);
 		}
-	} else if (current_item_index[current_screen]
-		   + current_y[current_screen]
-		   < list_item_count[current_screen] - 1) {
-		current_item_index[current_screen]++;
-		show_list(dp);
+	} else if (ccs_current_item_index[ccs_current_screen]
+		   + ccs_current_y[ccs_current_screen]
+		   < ccs_list_item_count[ccs_current_screen] - 1) {
+		ccs_current_item_index[ccs_current_screen]++;
+		ccs_show_list(dp);
 	}
 }
 
-static void page_up_key(struct domain_policy *dp)
+static void ccs_page_up_key(struct ccs_domain_policy *dp)
 {
-	int p0 = current_item_index[current_screen];
-	int p1 = current_y[current_screen];
+	int p0 = ccs_current_item_index[ccs_current_screen];
+	int p1 = ccs_current_y[ccs_current_screen];
 	_Bool refresh;
-	if (p0 + p1 > body_lines) {
-		p0 -= body_lines;
+	if (p0 + p1 > ccs_body_lines) {
+		p0 -= ccs_body_lines;
 		if (p0 < 0)
 			p0 = 0;
 	} else if (p0 + p1 > 0) {
@@ -1817,26 +1817,26 @@
 	} else {
 		return;
 	}
-	refresh = (current_item_index[current_screen] != p0);
-	current_item_index[current_screen] = p0;
-	current_y[current_screen] = p1;
+	refresh = (ccs_current_item_index[ccs_current_screen] != p0);
+	ccs_current_item_index[ccs_current_screen] = p0;
+	ccs_current_y[ccs_current_screen] = p1;
 	if (refresh)
-		show_list(dp);
+		ccs_show_list(dp);
 	else
-		show_current(dp);
+		ccs_show_current(dp);
 }
 
-static void page_down_key(struct domain_policy *dp)
+static void ccs_page_down_key(struct ccs_domain_policy *dp)
 {
-	int count = list_item_count[current_screen] - 1;
-	int p0 = current_item_index[current_screen];
-	int p1 = current_y[current_screen];
+	int ccs_count = ccs_list_item_count[ccs_current_screen] - 1;
+	int p0 = ccs_current_item_index[ccs_current_screen];
+	int p1 = ccs_current_y[ccs_current_screen];
 	_Bool refresh;
-	if (p0 + p1 + body_lines < count) {
-		p0 += body_lines;
-	} else if (p0 + p1 < count) {
-		while (p0 + p1 < count) {
-			if (p1 + 1 < body_lines)
+	if (p0 + p1 + ccs_body_lines < ccs_count) {
+		p0 += ccs_body_lines;
+	} else if (p0 + p1 < ccs_count) {
+		while (p0 + p1 < ccs_count) {
+			if (p1 + 1 < ccs_body_lines)
 				p1++;
 			else
 				p0++;
@@ -1844,121 +1844,121 @@
 	} else {
 		return;
 	}
-	refresh = (current_item_index[current_screen] != p0);
-	current_item_index[current_screen] = p0;
-	current_y[current_screen] = p1;
+	refresh = (ccs_current_item_index[ccs_current_screen] != p0);
+	ccs_current_item_index[ccs_current_screen] = p0;
+	ccs_current_y[ccs_current_screen] = p1;
 	if (refresh)
-		show_list(dp);
+		ccs_show_list(dp);
 	else
-		show_current(dp);
+		ccs_show_current(dp);
 }
 
-int editpolicy_get_current(void)
+int ccs_editpolicy_get_current(void)
 {
-	int count = list_item_count[current_screen];
-	const int p0 = current_item_index[current_screen];
-	const int p1 = current_y[current_screen];
-	if (!count)
+	int ccs_count = ccs_list_item_count[ccs_current_screen];
+	const int p0 = ccs_current_item_index[ccs_current_screen];
+	const int p1 = ccs_current_y[ccs_current_screen];
+	if (!ccs_count)
 		return EOF;
-	if (p0 + p1 < 0 || p0 + p1 >= count) {
-		fprintf(stderr, "ERROR: current_item_index=%d current_y=%d\n",
+	if (p0 + p1 < 0 || p0 + p1 >= ccs_count) {
+		fprintf(stderr, "ERROR: ccs_current_item_index=%d ccs_current_y=%d\n",
 			p0, p1);
 		exit(127);
 	}
 	return p0 + p1;
 }
 
-static void show_current(struct domain_policy *dp)
+static void ccs_show_current(struct ccs_domain_policy *dp)
 {
-	if (current_screen == SCREEN_DOMAIN_LIST && !domain_sort_type) {
+	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST && !ccs_domain_sort_type) {
 		char *line;
-		const int index = editpolicy_get_current();
-		get();
-		eat_col = max_eat_col[current_screen];
-		line = shprintf("%s", eat(domain_name(dp, index)));
-		if (window_width < strlen(line))
-			line[window_width] = '\0';
+		const int index = ccs_editpolicy_get_current();
+		ccs_get();
+		ccs_eat_col = ccs_max_eat_col[ccs_current_screen];
+		line = ccs_shprintf("%s", ccs_eat(ccs_domain_name(dp, index)));
+		if (ccs_window_width < strlen(line))
+			line[ccs_window_width] = '\0';
 		move(2, 0);
 		clrtoeol();
-		editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
 		printw("%s", line);
-		editpolicy_attr_change(A_REVERSE, false); /* add color */
-		put();
+		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		ccs_put();
 	}
-	move(header_lines + current_y[current_screen], 0);
-	editpolicy_line_draw(current_screen);     /* add color */
+	move(ccs_header_lines + ccs_current_y[ccs_current_screen], 0);
+	ccs_editpolicy_line_draw(ccs_current_screen);     /* add color */
 	refresh();
 }
 
-static void adjust_cursor_pos(const int item_count)
+static void ccs_adjust_cursor_pos(const int item_count)
 {
 	if (item_count == 0) {
-		current_item_index[current_screen] = 0;
-		current_y[current_screen] = 0;
+		ccs_current_item_index[ccs_current_screen] = 0;
+		ccs_current_y[ccs_current_screen] = 0;
 	} else {
-		while (current_item_index[current_screen]
-		       + current_y[current_screen] >= item_count) {
-			if (current_y[current_screen] > 0)
-				current_y[current_screen]--;
-			else if (current_item_index[current_screen] > 0)
-				current_item_index[current_screen]--;
+		while (ccs_current_item_index[ccs_current_screen]
+		       + ccs_current_y[ccs_current_screen] >= item_count) {
+			if (ccs_current_y[ccs_current_screen] > 0)
+				ccs_current_y[ccs_current_screen]--;
+			else if (ccs_current_item_index[ccs_current_screen] > 0)
+				ccs_current_item_index[ccs_current_screen]--;
 		}
 	}
 }
 
-static void set_cursor_pos(const int index)
+static void ccs_set_cursor_pos(const int index)
 {
-	while (index < current_y[current_screen]
-	       + current_item_index[current_screen]) {
-		if (current_y[current_screen] > 0)
-			current_y[current_screen]--;
+	while (index < ccs_current_y[ccs_current_screen]
+	       + ccs_current_item_index[ccs_current_screen]) {
+		if (ccs_current_y[ccs_current_screen] > 0)
+			ccs_current_y[ccs_current_screen]--;
 		else
-			current_item_index[current_screen]--;
+			ccs_current_item_index[ccs_current_screen]--;
 	}
-	while (index > current_y[current_screen]
-	       + current_item_index[current_screen]) {
-		if (current_y[current_screen] < body_lines - 1)
-			current_y[current_screen]++;
+	while (index > ccs_current_y[ccs_current_screen]
+	       + ccs_current_item_index[ccs_current_screen]) {
+		if (ccs_current_y[ccs_current_screen] < ccs_body_lines - 1)
+			ccs_current_y[ccs_current_screen]++;
 		else
-			current_item_index[current_screen]++;
+			ccs_current_item_index[ccs_current_screen]++;
 	}
 }
 
-static _Bool select_item(struct domain_policy *dp, const int index)
+static _Bool ccs_select_item(struct ccs_domain_policy *dp, const int index)
 {
 	int x;
 	int y;
 	if (index < 0)
 		return false;
-	if (current_screen == SCREEN_DOMAIN_LIST) {
-		if (!domain_sort_type) {
-			if (is_deleted_domain(dp, index) ||
-			    is_initializer_source(dp, index))
+	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+		if (!ccs_domain_sort_type) {
+			if (ccs_is_deleted_domain(dp, index) ||
+			    ccs_is_initializer_source(dp, index))
 				return false;
 			dp->list_selected[index] ^= 1;
 		} else {
-			task_list[index].selected ^= 1;
+			ccs_task_list[index].selected ^= 1;
 		}
 	} else {
-		generic_acl_list[index].selected ^= 1;
+		ccs_generic_acl_list[index].selected ^= 1;
 	}
 	getyx(stdscr, y, x);
-	editpolicy_sttr_save();    /* add color */
-	show_list(dp);
-	editpolicy_sttr_restore(); /* add color */
+	ccs_editpolicy_sttr_save();    /* add color */
+	ccs_show_list(dp);
+	ccs_editpolicy_sttr_restore(); /* add color */
 	move(y, x);
 	return true;
 }
 
-static int generic_acl_compare(const void *a, const void *b)
+static int ccs_generic_acl_compare(const void *a, const void *b)
 {
-	const struct generic_acl *a0 = (struct generic_acl *) a;
-	const struct generic_acl *b0 = (struct generic_acl *) b;
-	const char *a1 = directives[a0->directive].alias;
-	const char *b1 = directives[b0->directive].alias;
+	const struct ccs_generic_acl *a0 = (struct ccs_generic_acl *) a;
+	const struct ccs_generic_acl *b0 = (struct ccs_generic_acl *) b;
+	const char *a1 = ccs_directives[a0->directive].alias;
+	const char *b1 = ccs_directives[b0->directive].alias;
 	const char *a2 = a0->operand;
 	const char *b2 = b0->operand;
-	if (acl_sort_type == 0) {
+	if (ccs_acl_sort_type == 0) {
 		const int ret = strcmp(a1, b1);
 		if (ret)
 			return ret;
@@ -1971,132 +1971,132 @@
 	}
 }
 
-static void delete_entry(struct domain_policy *dp, const int index)
+static void ccs_delete_entry(struct ccs_domain_policy *dp, const int index)
 {
 	int c;
 	move(1, 0);
-	editpolicy_color_change(DISP_ERR, true);	/* add color */
-	if (current_screen == SCREEN_DOMAIN_LIST) {
-		c = count(dp->list_selected, dp->list_len);
+	ccs_editpolicy_color_change(CCS_DISP_ERR, true);	/* add color */
+	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+		c = ccs_count(dp->list_selected, dp->list_len);
 		if (!c && index < dp->list_len)
-			c = select_item(dp, index);
+			c = ccs_select_item(dp, index);
 		if (!c)
 			printw("Select domain using Space key first.");
 		else
 			printw("Delete selected domain%s? ('Y'es/'N'o)",
 			       c > 1 ? "s" : "");
 	} else {
-		c = count2(generic_acl_list, generic_acl_list_count);
+		c = ccs_count2(ccs_generic_acl_list, ccs_generic_acl_list_count);
 		if (!c)
-			c = select_item(dp, index);
+			c = ccs_select_item(dp, index);
 		if (!c)
 			printw("Select entry using Space key first.");
 		else
 			printw("Delete selected entr%s? ('Y'es/'N'o)",
 			       c > 1 ? "ies" : "y");
 	}
-	editpolicy_color_change(DISP_ERR, false);	/* add color */
+	ccs_editpolicy_color_change(CCS_DISP_ERR, false);	/* add color */
 	clrtoeol();
 	refresh();
 	if (!c)
 		return;
 	do {
-		c = getch2();
+		c = ccs_getch2();
 	} while (!(c == 'Y' || c == 'y' || c == 'N' || c == 'n' || c == EOF));
-	resize_window();
+	ccs_resize_window();
 	if (c != 'Y' && c != 'y') {
-		show_list(dp);
+		ccs_show_list(dp);
 		return;
 	}
-	if (current_screen == SCREEN_DOMAIN_LIST) {
+	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
 		int i;
-		FILE *fp = open_write(proc_policy_domain_policy);
+		FILE *fp = ccs_open_write(ccs_proc_policy_domain_policy);
 		if (!fp)
 			return;
 		for (i = 1; i < dp->list_len; i++) {
 			if (!dp->list_selected[i])
 				continue;
-			fprintf(fp, "delete %s\n", domain_name(dp, i));
+			fprintf(fp, "delete %s\n", ccs_domain_name(dp, i));
 		}
-		close_write(fp);
+		ccs_close_write(fp);
 	} else {
 		int i;
-		FILE *fp = open_write(policy_file);
+		FILE *fp = ccs_open_write(ccs_policy_file);
 		if (!fp)
 			return;
-		if (current_screen == SCREEN_ACL_LIST) {
-			if (domain_sort_type)
-				fprintf(fp, "select pid=%u\n", current_pid);
+		if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+			if (ccs_domain_sort_type)
+				fprintf(fp, "select pid=%u\n", ccs_current_pid);
 			else
 				fprintf(fp, "select domain=%s\n",
-					current_domain);
+					ccs_current_domain);
 		}
-		for (i = 0; i < generic_acl_list_count; i++) {
+		for (i = 0; i < ccs_generic_acl_list_count; i++) {
 			u8 directive;
-			if (!generic_acl_list[i].selected)
+			if (!ccs_generic_acl_list[i].selected)
 				continue;
-			directive = generic_acl_list[i].directive;
+			directive = ccs_generic_acl_list[i].directive;
 			fprintf(fp, "delete %s %s\n",
-				directives[directive].original,
-				generic_acl_list[i].operand);
+				ccs_directives[directive].original,
+				ccs_generic_acl_list[i].operand);
 		}
-		close_write(fp);
+		ccs_close_write(fp);
 	}
 }
 
-static void add_entry(struct readline_data *rl)
+static void ccs_add_entry(struct ccs_readline_data *rl)
 {
 	FILE *fp;
 	char *line;
-	editpolicy_attr_change(A_BOLD, true);  /* add color */
-	line = simple_readline(window_height - 1, 0, "Enter new entry> ",
-			       rl->history, rl->count, 128000, 8);
-	editpolicy_attr_change(A_BOLD, false); /* add color */
+	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	line = ccs_simple_readline(ccs_window_height - 1, 0, "Enter new entry> ",
+				   rl->history, rl->count, 128000, 8);
+	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	rl->count = simple_add_history(line, rl->history, rl->count, rl->max);
-	fp = open_write(policy_file);
+	rl->count = ccs_simple_add_history(line, rl->history, rl->count, rl->max);
+	fp = ccs_open_write(ccs_policy_file);
 	if (!fp)
 		goto out;
-	switch (current_screen) {
+	switch (ccs_current_screen) {
 		u8 directive;
-	case SCREEN_DOMAIN_LIST:
-		if (!is_correct_domain(line)) {
+	case CCS_SCREEN_DOMAIN_LIST:
+		if (!ccs_is_correct_domain(line)) {
 			const int len = strlen(line) + 128;
-			last_error = realloc(last_error, len);
-			if (!last_error)
-				out_of_memory();
-			memset(last_error, 0, len);
-			snprintf(last_error, len - 1,
+			ccs_last_error = realloc(ccs_last_error, len);
+			if (!ccs_last_error)
+				ccs_out_of_memory();
+			memset(ccs_last_error, 0, len);
+			snprintf(ccs_last_error, len - 1,
 				 "%s is an invalid domainname.", line);
 			line[0] = '\0';
 		}
 		break;
-	case SCREEN_ACL_LIST:
-		if (domain_sort_type)
-			fprintf(fp, "select pid=%u\n", current_pid);
+	case CCS_SCREEN_ACL_LIST:
+		if (ccs_domain_sort_type)
+			fprintf(fp, "select pid=%u\n", ccs_current_pid);
 		else
-			fprintf(fp, "select domain=%s\n", current_domain);
+			fprintf(fp, "select domain=%s\n", ccs_current_domain);
 		/* Fall through. */
-	case SCREEN_EXCEPTION_LIST:
-		directive = find_directive(false, line);
-		if (directive != DIRECTIVE_NONE)
+	case CCS_SCREEN_EXCEPTION_LIST:
+		directive = ccs_find_directive(false, line);
+		if (directive != CCS_DIRECTIVE_NONE)
 			fprintf(fp, "%s ",
-				directives[directive].original);
+				ccs_directives[directive].original);
 		break;
-	case SCREEN_PROFILE_LIST:
+	case CCS_SCREEN_PROFILE_LIST:
 		if (!strchr(line, '='))
 			fprintf(fp, "%s-COMMENT=\n", line);
 		break;
 	}
 	fprintf(fp, "%s\n", line);
-	close_write(fp);
+	ccs_close_write(fp);
 out:
 	free(line);
 }
 
-static void find_entry(struct domain_policy *dp, _Bool input, _Bool forward,
-		       const int current, struct readline_data *rl)
+static void ccs_find_entry(struct ccs_domain_policy *dp, _Bool input, _Bool forward,
+			   const int current, struct ccs_readline_data *rl)
 {
 	int index = current;
 	char *line = NULL;
@@ -2104,61 +2104,61 @@
 		return;
 	if (!input)
 		goto start_search;
-	editpolicy_attr_change(A_BOLD, true);  /* add color */
-	line = simple_readline(window_height - 1, 0, "Search> ",
-			       rl->history, rl->count, 128000, 8);
-	editpolicy_attr_change(A_BOLD, false); /* add color */
+	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	line = ccs_simple_readline(ccs_window_height - 1, 0, "Search> ",
+				   rl->history, rl->count, 128000, 8);
+	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	rl->count = simple_add_history(line, rl->history, rl->count, rl->max);
-	free(rl->search_buffer[current_screen]);
-	rl->search_buffer[current_screen] = line;
+	rl->count = ccs_simple_add_history(line, rl->history, rl->count, rl->max);
+	free(rl->search_buffer[ccs_current_screen]);
+	rl->search_buffer[ccs_current_screen] = line;
 	line = NULL;
 	index = -1;
 start_search:
-	get();
+	ccs_get();
 	while (true) {
 		const char *cp;
 		if (forward) {
-			if (++index >= list_item_count[current_screen])
+			if (++index >= ccs_list_item_count[ccs_current_screen])
 				break;
 		} else {
 			if (--index < 0)
 				break;
 		}
-		if (current_screen == SCREEN_DOMAIN_LIST) {
-			if (domain_sort_type)
-				cp = task_list[index].name;
+		if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+			if (ccs_domain_sort_type)
+				cp = ccs_task_list[index].name;
 			else
-				cp = get_last_name(dp, index);
-		} else if (current_screen == SCREEN_PROFILE_LIST) {
-			cp = shprintf("%u-%s",
-				      generic_acl_list[index].directive,
-				      generic_acl_list[index].operand);
+				cp = ccs_get_last_name(dp, index);
+		} else if (ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
+			cp = ccs_shprintf("%u-%s",
+					  ccs_generic_acl_list[index].directive,
+					  ccs_generic_acl_list[index].operand);
 		} else {
-			const u8 directive = generic_acl_list[index].directive;
-			cp = shprintf("%s %s", directives[directive].alias,
-				      generic_acl_list[index].operand);
+			const u8 directive = ccs_generic_acl_list[index].directive;
+			cp = ccs_shprintf("%s %s", ccs_directives[directive].alias,
+					  ccs_generic_acl_list[index].operand);
 		}
-		if (!strstr(cp, rl->search_buffer[current_screen]))
+		if (!strstr(cp, rl->search_buffer[ccs_current_screen]))
 			continue;
-		set_cursor_pos(index);
+		ccs_set_cursor_pos(index);
 		break;
 	}
-	put();
+	ccs_put();
 out:
 	free(line);
-	show_list(dp);
+	ccs_show_list(dp);
 }
 
-static void set_profile(struct domain_policy *dp, const int current)
+static void ccs_set_profile(struct ccs_domain_policy *dp, const int current)
 {
 	int index;
 	FILE *fp;
 	char *line;
-	if (!domain_sort_type) {
-		if (!count(dp->list_selected, dp->list_len) &&
-		    !select_item(dp, current)) {
+	if (!ccs_domain_sort_type) {
+		if (!ccs_count(dp->list_selected, dp->list_len) &&
+		    !ccs_select_item(dp, current)) {
 			move(1, 0);
 			printw("Select domain using Space key first.");
 			clrtoeol();
@@ -2166,8 +2166,8 @@
 			return;
 		}
 	} else {
-		if (!count3(task_list, task_list_len) &&
-		    !select_item(dp, current)) {
+		if (!ccs_count3(ccs_task_list, ccs_task_list_len) &&
+		    !ccs_select_item(dp, current)) {
 			move(1, 0);
 			printw("Select processes using Space key first.");
 			clrtoeol();
@@ -2175,173 +2175,173 @@
 			return;
 		}
 	}
-	editpolicy_attr_change(A_BOLD, true);  /* add color */
-	line = simple_readline(window_height - 1, 0, "Enter profile number> ",
-			       NULL, 0, 8, 1);
-	editpolicy_attr_change(A_BOLD, false); /* add color */
+	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	line = ccs_simple_readline(ccs_window_height - 1, 0, "Enter profile number> ",
+				   NULL, 0, 8, 1);
+	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = open_write(proc_policy_domain_policy);
+	fp = ccs_open_write(ccs_proc_policy_domain_policy);
 	if (!fp)
 		goto out;
-	if (!domain_sort_type) {
+	if (!ccs_domain_sort_type) {
 		for (index = 0; index < dp->list_len; index++) {
 			if (!dp->list_selected[index])
 				continue;
-			fprintf(fp, "select domain=%s\n" KEYWORD_USE_PROFILE
-				"%s\n", domain_name(dp, index), line);
+			fprintf(fp, "select domain=%s\n" CCS_KEYWORD_USE_PROFILE
+				"%s\n", ccs_domain_name(dp, index), line);
 		}
 	} else {
-		for (index = 0; index < task_list_len; index++) {
-			if (!task_list[index].selected)
+		for (index = 0; index < ccs_task_list_len; index++) {
+			if (!ccs_task_list[index].selected)
 				continue;
-			fprintf(fp, "select pid=%u\n" KEYWORD_USE_PROFILE
-				"%s\n", task_list[index].pid, line);
+			fprintf(fp, "select pid=%u\n" CCS_KEYWORD_USE_PROFILE
+				"%s\n", ccs_task_list[index].pid, line);
 		}
 	}
-	close_write(fp);
+	ccs_close_write(fp);
 out:
 	free(line);
 }
 
-static void set_level(struct domain_policy *dp, const int current)
+static void ccs_set_level(struct ccs_domain_policy *dp, const int current)
 {
 	int index;
 	FILE *fp;
 	char *line;
-	if (!count2(generic_acl_list, generic_acl_list_count))
-		select_item(dp, current);
-	editpolicy_attr_change(A_BOLD, true);  /* add color */
-	initial_readline_data = NULL;
-	for (index = 0; index < generic_acl_list_count; index++) {
+	if (!ccs_count2(ccs_generic_acl_list, ccs_generic_acl_list_count))
+		ccs_select_item(dp, current);
+	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	ccs_initial_readline_data = NULL;
+	for (index = 0; index < ccs_generic_acl_list_count; index++) {
 		char *cp;
-		if (!generic_acl_list[index].selected)
+		if (!ccs_generic_acl_list[index].selected)
 			continue;
-		cp = strchr(generic_acl_list[index].operand, '=');
+		cp = strchr(ccs_generic_acl_list[index].operand, '=');
 		if (!cp)
 			continue;
-		initial_readline_data = cp + 1;
+		ccs_initial_readline_data = cp + 1;
 		break;
 	}
-	line = simple_readline(window_height - 1, 0, "Enter new value> ",
-			       NULL, 0, 128000, 1);
-	initial_readline_data = NULL;
-	editpolicy_attr_change(A_BOLD, false); /* add color */
+	line = ccs_simple_readline(ccs_window_height - 1, 0, "Enter new value> ",
+				   NULL, 0, 128000, 1);
+	ccs_initial_readline_data = NULL;
+	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = open_write(proc_policy_profile);
+	fp = ccs_open_write(ccs_proc_policy_profile);
 	if (!fp)
 		goto out;
-	for (index = 0; index < generic_acl_list_count; index++) {
+	for (index = 0; index < ccs_generic_acl_list_count; index++) {
 		char *buf;
 		char *cp;
 		u16 directive;
-		if (!generic_acl_list[index].selected)
+		if (!ccs_generic_acl_list[index].selected)
 			continue;
-		get();
-		buf = shprintf("%s", generic_acl_list[index].operand);
+		ccs_get();
+		buf = ccs_shprintf("%s", ccs_generic_acl_list[index].operand);
 		cp = strchr(buf, '=');
 		if (cp)
 			*cp = '\0';
-		directive = generic_acl_list[index].directive;
+		directive = ccs_generic_acl_list[index].directive;
 		if (directive < 256)
 			fprintf(fp, "%u-", directive);
 		fprintf(fp, "%s=%s\n", buf, line);
-		put();
+		ccs_put();
 	}
-	close_write(fp);
+	ccs_close_write(fp);
 out:
 	free(line);
 }
 
-static void set_quota(struct domain_policy *dp, const int current)
+static void ccs_set_quota(struct ccs_domain_policy *dp, const int current)
 {
 	int index;
 	FILE *fp;
 	char *line;
-	if (!count2(generic_acl_list, generic_acl_list_count))
-		select_item(dp, current);
-	editpolicy_attr_change(A_BOLD, true);  /* add color */
-	line = simple_readline(window_height - 1, 0, "Enter new value> ",
-			       NULL, 0, 20, 1);
-	editpolicy_attr_change(A_BOLD, false); /* add color */
+	if (!ccs_count2(ccs_generic_acl_list, ccs_generic_acl_list_count))
+		ccs_select_item(dp, current);
+	ccs_editpolicy_attr_change(A_BOLD, true);  /* add color */
+	line = ccs_simple_readline(ccs_window_height - 1, 0, "Enter new value> ",
+				   NULL, 0, 20, 1);
+	ccs_editpolicy_attr_change(A_BOLD, false); /* add color */
 	if (!line || !*line)
 		goto out;
-	fp = open_write(proc_policy_meminfo);
+	fp = ccs_open_write(ccs_proc_policy_meminfo);
 	if (!fp)
 		goto out;
-	for (index = 0; index < generic_acl_list_count; index++) {
+	for (index = 0; index < ccs_generic_acl_list_count; index++) {
 		char *buf;
 		char *cp;
-		if (!generic_acl_list[index].selected)
+		if (!ccs_generic_acl_list[index].selected)
 			continue;
-		get();
-		buf = shprintf("%s", generic_acl_list[index].operand);
+		ccs_get();
+		buf = ccs_shprintf("%s", ccs_generic_acl_list[index].operand);
 		cp = strchr(buf, ':');
 		if (cp)
 			*cp = '\0';
 		fprintf(fp, "%s: %s\n", buf, line);
-		put();
+		ccs_put();
 	}
-	close_write(fp);
+	ccs_close_write(fp);
 out:
 	free(line);
 }
 
-static _Bool select_acl_window(struct domain_policy *dp, const int current,
-			       const _Bool may_refresh)
+static _Bool ccs_select_acl_window(struct ccs_domain_policy *dp, const int current,
+				   const _Bool may_refresh)
 {
-	if (current_screen != SCREEN_DOMAIN_LIST || current == EOF)
+	if (ccs_current_screen != CCS_SCREEN_DOMAIN_LIST || current == EOF)
 		return false;
-	current_pid = 0;
-	if (domain_sort_type) {
-		current_pid = task_list[current].pid;
-	} else if (is_initializer_source(dp, current)) {
+	ccs_current_pid = 0;
+	if (ccs_domain_sort_type) {
+		ccs_current_pid = ccs_task_list[current].pid;
+	} else if (ccs_is_initializer_source(dp, current)) {
 		char *buf;
 		int redirect_index;
 		if (!may_refresh)
 			return false;
-		get();
-		buf = shprintf(ROOT_NAME "%s",
-			       strrchr(domain_name(dp, current), ' '));
-		redirect_index = find_domain(dp, buf, false, false);
-		put();
+		ccs_get();
+		buf = ccs_shprintf(CCS_ROOT_NAME "%s",
+			       strrchr(ccs_domain_name(dp, current), ' '));
+		redirect_index = ccs_find_domain(dp, buf, false, false);
+		ccs_put();
 		if (redirect_index == EOF)
 			return false;
-		current_item_index[current_screen]
-			= redirect_index - current_y[current_screen];
-		while (current_item_index[current_screen] < 0) {
-			current_item_index[current_screen]++;
-			current_y[current_screen]--;
+		ccs_current_item_index[ccs_current_screen]
+			= redirect_index - ccs_current_y[ccs_current_screen];
+		while (ccs_current_item_index[ccs_current_screen] < 0) {
+			ccs_current_item_index[ccs_current_screen]++;
+			ccs_current_y[ccs_current_screen]--;
 		}
-		show_list(dp);
+		ccs_show_list(dp);
 		return false;
-	} else if (is_deleted_domain(dp, current)) {
+	} else if (ccs_is_deleted_domain(dp, current)) {
 		return false;
 	}
-	free(current_domain);
-	if (domain_sort_type)
-		current_domain = strdup(task_list[current].domain);
+	free(ccs_current_domain);
+	if (ccs_domain_sort_type)
+		ccs_current_domain = strdup(ccs_task_list[current].domain);
 	else
-		current_domain = strdup(domain_name(dp, current));
-	if (!current_domain)
-		out_of_memory();
+		ccs_current_domain = strdup(ccs_domain_name(dp, current));
+	if (!ccs_current_domain)
+		ccs_out_of_memory();
 	return true;
 }
 
-static int select_window(struct domain_policy *dp, const int current)
+static int ccs_select_window(struct ccs_domain_policy *dp, const int current)
 {
 	move(0, 0);
 	printw("Press one of below keys to switch window.\n\n");
 	printw("e     <<< Exception Policy Editor >>>\n");
 	printw("d     <<< Domain Transition Editor >>>\n");
-	if (current_screen == SCREEN_DOMAIN_LIST && current != EOF &&
-	    !is_initializer_source(dp, current) &&
-	    !is_deleted_domain(dp, current))
+	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST && current != EOF &&
+	    !ccs_is_initializer_source(dp, current) &&
+	    !ccs_is_deleted_domain(dp, current))
 		printw("a     <<< Domain Policy Editor >>>\n");
 	printw("p     <<< Profile Editor >>>\n");
 	printw("m     <<< Manager Policy Editor >>>\n");
-	if (!offline_mode) {
+	if (!ccs_offline_mode) {
 		/* printw("i     <<< Interactive Enforcing Mode >>>\n"); */
 		printw("u     <<< Memory Usage >>>\n");
 	}
@@ -2349,95 +2349,95 @@
 	clrtobot();
 	refresh();
 	while (true) {
-		int c = getch2();
+		int c = ccs_getch2();
 		if (c == 'E' || c == 'e')
-			return SCREEN_EXCEPTION_LIST;
+			return CCS_SCREEN_EXCEPTION_LIST;
 		if (c == 'D' || c == 'd')
-			return SCREEN_DOMAIN_LIST;
+			return CCS_SCREEN_DOMAIN_LIST;
 		if (c == 'A' || c == 'a')
-			if (select_acl_window(dp, current, false))
-				return SCREEN_ACL_LIST;
+			if (ccs_select_acl_window(dp, current, false))
+				return CCS_SCREEN_ACL_LIST;
 		if (c == 'P' || c == 'p')
-			return SCREEN_PROFILE_LIST;
+			return CCS_SCREEN_PROFILE_LIST;
 		if (c == 'M' || c == 'm')
-			return SCREEN_MANAGER_LIST;
-		if (!offline_mode) {
+			return CCS_SCREEN_MANAGER_LIST;
+		if (!ccs_offline_mode) {
 			/*
 			if (c == 'I' || c == 'i')
-				return SCREEN_QUERY_LIST;
+				return CCS_SCREEN_QUERY_LIST;
 			*/
 			if (c == 'U' || c == 'u')
-				return SCREEN_MEMINFO_LIST;
+				return CCS_SCREEN_MEMINFO_LIST;
 		}
 		if (c == 'Q' || c == 'q')
-			return MAXSCREEN;
+			return CCS_MAXSCREEN;
 		if (c == EOF)
-			return MAXSCREEN;
+			return CCS_MAXSCREEN;
 	}
 }
 
-static void copy_mark_state(struct domain_policy *dp, const int current)
+static void ccs_copy_mark_state(struct ccs_domain_policy *dp, const int current)
 {
 	int index;
-	if (current_screen == SCREEN_DOMAIN_LIST) {
-		if (domain_sort_type) {
-			const u8 selected = task_list[current].selected;
-			for (index = current; index < task_list_len; index++)
-				task_list[index].selected = selected;
+	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+		if (ccs_domain_sort_type) {
+			const u8 selected = ccs_task_list[current].selected;
+			for (index = current; index < ccs_task_list_len; index++)
+				ccs_task_list[index].selected = selected;
 		} else {
 			const u8 selected = dp->list_selected[current];
-			if (is_deleted_domain(dp, current) ||
-			    is_initializer_source(dp, current))
+			if (ccs_is_deleted_domain(dp, current) ||
+			    ccs_is_initializer_source(dp, current))
 				return;
 			for (index = current;
 			     index < dp->list_len; index++) {
-				if (is_deleted_domain(dp, index) ||
-				    is_initializer_source(dp, index))
+				if (ccs_is_deleted_domain(dp, index) ||
+				    ccs_is_initializer_source(dp, index))
 					continue;
 				dp->list_selected[index] = selected;
 			}
 		}
 	} else {
-		const u8 selected = generic_acl_list[current].selected;
-		for (index = current; index < generic_acl_list_count; index++)
-			generic_acl_list[index].selected = selected;
+		const u8 selected = ccs_generic_acl_list[current].selected;
+		for (index = current; index < ccs_generic_acl_list_count; index++)
+			ccs_generic_acl_list[index].selected = selected;
 	}
-	show_list(dp);
+	ccs_show_list(dp);
 }
 
-static void copy_to_history(struct domain_policy *dp, const int current,
-			    struct readline_data *rl)
+static void ccs_copy_to_history(struct ccs_domain_policy *dp, const int current,
+				struct ccs_readline_data *rl)
 {
 	const char *line;
 	if (current == EOF)
 		return;
-	get();
-	switch (current_screen) {
+	ccs_get();
+	switch (ccs_current_screen) {
 		u8 directive;
-	case SCREEN_DOMAIN_LIST:
-		line = domain_name(dp, current);
+	case CCS_SCREEN_DOMAIN_LIST:
+		line = ccs_domain_name(dp, current);
 		break;
-	case SCREEN_EXCEPTION_LIST:
-	case SCREEN_ACL_LIST:
-		directive = generic_acl_list[current].directive;
-		line = shprintf("%s %s", directives[directive].alias,
-				generic_acl_list[current].operand);
+	case CCS_SCREEN_EXCEPTION_LIST:
+	case CCS_SCREEN_ACL_LIST:
+		directive = ccs_generic_acl_list[current].directive;
+		line = ccs_shprintf("%s %s", ccs_directives[directive].alias,
+				ccs_generic_acl_list[current].operand);
 		break;
-	case SCREEN_MEMINFO_LIST:
+	case CCS_SCREEN_MEMINFO_LIST:
 		line = NULL;
 		break;
 	default:
-		line = shprintf("%s", generic_acl_list[current].operand);
+		line = ccs_shprintf("%s", ccs_generic_acl_list[current].operand);
 	}
-	rl->count = simple_add_history(line, rl->history, rl->count, rl->max);
-	put();
+	rl->count = ccs_simple_add_history(line, rl->history, rl->count, rl->max);
+	ccs_put();
 }
 
-static int generic_list_loop(struct domain_policy *dp)
+static int ccs_generic_list_loop(struct ccs_domain_policy *dp)
 {
-	static struct readline_data rl;
-	static int saved_current_y[MAXSCREEN];
-	static int saved_current_item_index[MAXSCREEN];
+	static struct ccs_readline_data rl;
+	static int saved_current_y[CCS_MAXSCREEN];
+	static int saved_current_item_index[CCS_MAXSCREEN];
 	static _Bool first = true;
 	if (first) {
 		memset(&rl, 0, sizeof(rl));
@@ -2448,176 +2448,176 @@
 		       sizeof(saved_current_item_index));
 		first = false;
 	}
-	if (current_screen == SCREEN_EXCEPTION_LIST) {
-		policy_file = proc_policy_exception_policy;
-		list_caption = "Exception Policy Editor";
-	} else if (current_screen == SCREEN_ACL_LIST) {
-		policy_file = proc_policy_domain_policy;
-		list_caption = "Domain Policy Editor";
-	} else if (current_screen == SCREEN_QUERY_LIST) {
-		policy_file = proc_policy_query;
-		list_caption = "Interactive Enforcing Mode";
-	} else if (current_screen == SCREEN_PROFILE_LIST) {
-		policy_file = proc_policy_profile;
-		list_caption = "Profile Editor";
-	} else if (current_screen == SCREEN_MANAGER_LIST) {
-		policy_file = proc_policy_manager;
-		list_caption = "Manager Policy Editor";
-	} else if (current_screen == SCREEN_MEMINFO_LIST) {
-		policy_file = proc_policy_meminfo;
-		list_caption = "Memory Usage";
+	if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST) {
+		ccs_policy_file = ccs_proc_policy_exception_policy;
+		ccs_list_caption = "Exception Policy Editor";
+	} else if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+		ccs_policy_file = ccs_proc_policy_domain_policy;
+		ccs_list_caption = "Domain Policy Editor";
+	} else if (ccs_current_screen == CCS_SCREEN_QUERY_LIST) {
+		ccs_policy_file = ccs_proc_policy_query;
+		ccs_list_caption = "Interactive Enforcing Mode";
+	} else if (ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
+		ccs_policy_file = ccs_proc_policy_profile;
+		ccs_list_caption = "Profile Editor";
+	} else if (ccs_current_screen == CCS_SCREEN_MANAGER_LIST) {
+		ccs_policy_file = ccs_proc_policy_manager;
+		ccs_list_caption = "Manager Policy Editor";
+	} else if (ccs_current_screen == CCS_SCREEN_MEMINFO_LIST) {
+		ccs_policy_file = ccs_proc_policy_meminfo;
+		ccs_list_caption = "Memory Usage";
 	} else {
-		policy_file = proc_policy_domain_policy;
-		/* list_caption = "Domain Transition Editor"; */
+		ccs_policy_file = ccs_proc_policy_domain_policy;
+		/* ccs_list_caption = "Domain Transition Editor"; */
 	}
-	current_item_index[current_screen]
-		= saved_current_item_index[current_screen];
-	current_y[current_screen] = saved_current_y[current_screen];
+	ccs_current_item_index[ccs_current_screen]
+		= saved_current_item_index[ccs_current_screen];
+	ccs_current_y[ccs_current_screen] = saved_current_y[ccs_current_screen];
 start:
-	if (current_screen == SCREEN_DOMAIN_LIST) {
-		if (domain_sort_type == 0) {
-			read_domain_and_exception_policy(dp);
-			adjust_cursor_pos(dp->list_len);
+	if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST) {
+		if (ccs_domain_sort_type == 0) {
+			ccs_read_domain_and_exception_policy(dp);
+			ccs_adjust_cursor_pos(dp->list_len);
 		} else {
-			read_process_list(true);
-			adjust_cursor_pos(task_list_len);
+			ccs_read_process_list(true);
+			ccs_adjust_cursor_pos(ccs_task_list_len);
 		}
 	} else {
-		read_generic_policy();
-		adjust_cursor_pos(generic_acl_list_count);
+		ccs_read_generic_policy();
+		ccs_adjust_cursor_pos(ccs_generic_acl_list_count);
 	}
 start2:
-	show_list(dp);
-	if (last_error) {
+	ccs_show_list(dp);
+	if (ccs_last_error) {
 		move(1, 0);
-		printw("ERROR: %s", last_error);
+		printw("ERROR: %s", ccs_last_error);
 		clrtoeol();
 		refresh();
-		free(last_error);
-		last_error = NULL;
+		free(ccs_last_error);
+		ccs_last_error = NULL;
 	}
 	while (true) {
-		const int current = editpolicy_get_current();
-		const int c = getch2();
-		saved_current_item_index[current_screen]
-			= current_item_index[current_screen];
-		saved_current_y[current_screen] = current_y[current_screen];
+		const int current = ccs_editpolicy_get_current();
+		const int c = ccs_getch2();
+		saved_current_item_index[ccs_current_screen]
+			= ccs_current_item_index[ccs_current_screen];
+		saved_current_y[ccs_current_screen] = ccs_current_y[ccs_current_screen];
 		if (c == 'q' || c == 'Q')
-			return MAXSCREEN;
+			return CCS_MAXSCREEN;
 		if ((c == '\r' || c == '\n') &&
-		    current_screen == SCREEN_ACL_LIST)
-			return SCREEN_DOMAIN_LIST;
+		    ccs_current_screen == CCS_SCREEN_ACL_LIST)
+			return CCS_SCREEN_DOMAIN_LIST;
 		if (c == '\t') {
-			if (current_screen == SCREEN_DOMAIN_LIST)
-				return SCREEN_EXCEPTION_LIST;
+			if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST)
+				return CCS_SCREEN_EXCEPTION_LIST;
 			else
-				return SCREEN_DOMAIN_LIST;
+				return CCS_SCREEN_DOMAIN_LIST;
 		}
-		if (need_reload) {
-			need_reload = false;
+		if (ccs_need_reload) {
+			ccs_need_reload = false;
 			goto start;
 		}
 		if (c == ERR)
 			continue; /* Ignore invalid key. */
 		switch (c) {
 		case KEY_RESIZE:
-			resize_window();
-			show_list(dp);
+			ccs_resize_window();
+			ccs_show_list(dp);
 			break;
 		case KEY_UP:
-			up_arrow_key(dp);
+			ccs_up_arrow_key(dp);
 			break;
 		case KEY_DOWN:
-			down_arrow_key(dp);
+			ccs_down_arrow_key(dp);
 			break;
 		case KEY_PPAGE:
-			page_up_key(dp);
+			ccs_page_up_key(dp);
 			break;
 		case KEY_NPAGE:
-			page_down_key(dp);
+			ccs_page_down_key(dp);
 			break;
 		case ' ':
-			select_item(dp, current);
+			ccs_select_item(dp, current);
 			break;
 		case 'c':
 		case 'C':
 			if (current == EOF)
 				break;
-			copy_mark_state(dp, current);
-			show_list(dp);
+			ccs_copy_mark_state(dp, current);
+			ccs_show_list(dp);
 			break;
 		case 'f':
 		case 'F':
-			if (current_screen != SCREEN_MEMINFO_LIST)
-				find_entry(dp, true, true, current, &rl);
+			if (ccs_current_screen != CCS_SCREEN_MEMINFO_LIST)
+				ccs_find_entry(dp, true, true, current, &rl);
 			break;
 		case 'p':
 		case 'P':
-			if (current_screen == SCREEN_MEMINFO_LIST)
+			if (ccs_current_screen == CCS_SCREEN_MEMINFO_LIST)
 				break;
-			if (!rl.search_buffer[current_screen])
-				find_entry(dp, true, false, current, &rl);
+			if (!rl.search_buffer[ccs_current_screen])
+				ccs_find_entry(dp, true, false, current, &rl);
 			else
-				find_entry(dp, false, false, current, &rl);
+				ccs_find_entry(dp, false, false, current, &rl);
 			break;
 		case 'n':
 		case 'N':
-			if (current_screen == SCREEN_MEMINFO_LIST)
+			if (ccs_current_screen == CCS_SCREEN_MEMINFO_LIST)
 				break;
-			if (!rl.search_buffer[current_screen])
-				find_entry(dp, true, true, current, &rl);
+			if (!rl.search_buffer[ccs_current_screen])
+				ccs_find_entry(dp, true, true, current, &rl);
 			else
-				find_entry(dp, false, true, current, &rl);
+				ccs_find_entry(dp, false, true, current, &rl);
 			break;
 		case 'd':
 		case 'D':
-			if (readonly_mode)
+			if (ccs_readonly_mode)
 				break;
-			switch (current_screen) {
-			case SCREEN_DOMAIN_LIST:
-				if (domain_sort_type)
+			switch (ccs_current_screen) {
+			case CCS_SCREEN_DOMAIN_LIST:
+				if (ccs_domain_sort_type)
 					break;
-			case SCREEN_EXCEPTION_LIST:
-			case SCREEN_ACL_LIST:
-			case SCREEN_MANAGER_LIST:
-				delete_entry(dp, current);
+			case CCS_SCREEN_EXCEPTION_LIST:
+			case CCS_SCREEN_ACL_LIST:
+			case CCS_SCREEN_MANAGER_LIST:
+				ccs_delete_entry(dp, current);
 				goto start;
 			}
 			break;
 		case 'a':
 		case 'A':
-			if (readonly_mode)
+			if (ccs_readonly_mode)
 				break;
-			switch (current_screen) {
-			case SCREEN_DOMAIN_LIST:
-				if (domain_sort_type)
+			switch (ccs_current_screen) {
+			case CCS_SCREEN_DOMAIN_LIST:
+				if (ccs_domain_sort_type)
 					break;
-			case SCREEN_EXCEPTION_LIST:
-			case SCREEN_ACL_LIST:
-			case SCREEN_PROFILE_LIST:
-			case SCREEN_MANAGER_LIST:
-				add_entry(&rl);
+			case CCS_SCREEN_EXCEPTION_LIST:
+			case CCS_SCREEN_ACL_LIST:
+			case CCS_SCREEN_PROFILE_LIST:
+			case CCS_SCREEN_MANAGER_LIST:
+				ccs_add_entry(&rl);
 				goto start;
 			}
 			break;
 		case '\r':
 		case '\n':
-			if (select_acl_window(dp, current, true))
-				return SCREEN_ACL_LIST;
+			if (ccs_select_acl_window(dp, current, true))
+				return CCS_SCREEN_ACL_LIST;
 			break;
 		case 's':
 		case 'S':
-			if (readonly_mode)
+			if (ccs_readonly_mode)
 				break;
-			switch (current_screen) {
-			case SCREEN_DOMAIN_LIST:
-				set_profile(dp, current);
+			switch (ccs_current_screen) {
+			case CCS_SCREEN_DOMAIN_LIST:
+				ccs_set_profile(dp, current);
 				goto start;
-			case SCREEN_PROFILE_LIST:
-				set_level(dp, current);
+			case CCS_SCREEN_PROFILE_LIST:
+				ccs_set_level(dp, current);
 				goto start;
-			case SCREEN_MEMINFO_LIST:
-				set_quota(dp, current);
+			case CCS_SCREEN_MEMINFO_LIST:
+				ccs_set_quota(dp, current);
 				goto start;
 			}
 			break;
@@ -2625,95 +2625,95 @@
 		case 'R':
 			goto start;
 		case KEY_LEFT:
-			if (!max_eat_col[current_screen])
+			if (!ccs_max_eat_col[ccs_current_screen])
 				break;
-			max_eat_col[current_screen]--;
+			ccs_max_eat_col[ccs_current_screen]--;
 			goto start2;
 		case KEY_RIGHT:
-			max_eat_col[current_screen]++;
+			ccs_max_eat_col[ccs_current_screen]++;
 			goto start2;
 		case KEY_HOME:
-			max_eat_col[current_screen] = 0;
+			ccs_max_eat_col[ccs_current_screen] = 0;
 			goto start2;
 		case KEY_END:
-			max_eat_col[current_screen] = max_col;
+			ccs_max_eat_col[ccs_current_screen] = ccs_max_col;
 			goto start2;
 		case KEY_IC:
-			copy_to_history(dp, current, &rl);
+			ccs_copy_to_history(dp, current, &rl);
 			break;
 		case 'o':
 		case 'O':
-			if (current_screen == SCREEN_ACL_LIST) {
-				editpolicy_try_optimize(dp, current,
-							current_screen);
-				show_list(dp);
+			if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+				ccs_editpolicy_try_optimize(dp, current,
+							    ccs_current_screen);
+				ccs_show_list(dp);
 			}
 			break;
 		case '@':
-			if (current_screen == SCREEN_ACL_LIST) {
-				acl_sort_type = (acl_sort_type + 1) % 2;
+			if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
+				ccs_acl_sort_type = (ccs_acl_sort_type + 1) % 2;
 				goto start;
-			} else if (current_screen == SCREEN_PROFILE_LIST) {
-				profile_sort_type = (profile_sort_type + 1) % 2;
+			} else if (ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
+				ccs_profile_sort_type = (ccs_profile_sort_type + 1) % 2;
 				goto start;
-			} else if (current_screen == SCREEN_DOMAIN_LIST &&
-				   !offline_mode) {
-				domain_sort_type = (domain_sort_type + 1) % 2;
+			} else if (ccs_current_screen == CCS_SCREEN_DOMAIN_LIST &&
+				   !ccs_offline_mode) {
+				ccs_domain_sort_type = (ccs_domain_sort_type + 1) % 2;
 				goto start;
 			}
 			break;
 		case 'w':
 		case 'W':
-			return select_window(dp, current);
+			return ccs_select_window(dp, current);
 		case '?':
-			if (show_command_key(current_screen, readonly_mode))
+			if (ccs_show_command_key(ccs_current_screen, ccs_readonly_mode))
 				goto start;
-			return MAXSCREEN;
+			return CCS_MAXSCREEN;
 		}
 	}
 }
 
-int editpolicy_main(int argc, char *argv[])
+int ccs_editpolicy_main(int argc, char *argv[])
 {
-	struct domain_policy dp = { NULL, 0, NULL };
-	struct domain_policy bp = { NULL, 0, NULL };
-	memset(current_y, 0, sizeof(current_y));
-	memset(current_item_index, 0, sizeof(current_item_index));
-	memset(list_item_count, 0, sizeof(list_item_count));
-	memset(max_eat_col, 0, sizeof(max_eat_col));
-	policy_dir = NULL;
+	struct ccs_domain_policy dp = { NULL, 0, NULL };
+	struct ccs_domain_policy bp = { NULL, 0, NULL };
+	memset(ccs_current_y, 0, sizeof(ccs_current_y));
+	memset(ccs_current_item_index, 0, sizeof(ccs_current_item_index));
+	memset(ccs_list_item_count, 0, sizeof(ccs_list_item_count));
+	memset(ccs_max_eat_col, 0, sizeof(ccs_max_eat_col));
+	ccs_policy_dir = NULL;
 	if (argc > 1) {
 		int i;
 		for (i = 1; i < argc; i++) {
 			char *ptr = argv[i];
 			char *cp = strchr(ptr, ':');
 			if (*ptr == '/') {
-				if (network_mode || offline_mode)
+				if (ccs_network_mode || ccs_offline_mode)
 					goto usage;
-				policy_dir = ptr;
-				offline_mode = true;
+				ccs_policy_dir = ptr;
+				ccs_offline_mode = true;
 			} else if (cp) {
 				*cp++ = '\0';
-				if (network_mode || offline_mode)
+				if (ccs_network_mode || ccs_offline_mode)
 					goto usage;
-				network_ip = inet_addr(ptr);
-				network_port = htons(atoi(cp));
-				network_mode = true;
-				if (!check_remote_host())
+				ccs_network_ip = inet_addr(ptr);
+				ccs_network_port = htons(atoi(cp));
+				ccs_network_mode = true;
+				if (!ccs_check_remote_host())
 					return 1;
 			} else if (!strcmp(ptr, "e"))
-				current_screen = SCREEN_EXCEPTION_LIST;
+				ccs_current_screen = CCS_SCREEN_EXCEPTION_LIST;
 			else if (!strcmp(ptr, "d"))
-				current_screen = SCREEN_DOMAIN_LIST;
+				ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
 			else if (!strcmp(ptr, "p"))
-				current_screen = SCREEN_PROFILE_LIST;
+				ccs_current_screen = CCS_SCREEN_PROFILE_LIST;
 			else if (!strcmp(ptr, "m"))
-				current_screen = SCREEN_MANAGER_LIST;
+				ccs_current_screen = CCS_SCREEN_MANAGER_LIST;
 			else if (!strcmp(ptr, "u"))
-				current_screen = SCREEN_MEMINFO_LIST;
+				ccs_current_screen = CCS_SCREEN_MEMINFO_LIST;
 			else if (!strcmp(ptr, "readonly"))
-				readonly_mode = true;
-			else if (sscanf(ptr, "refresh=%u", &refresh_interval)
+				ccs_readonly_mode = true;
+			else if (sscanf(ptr, "refresh=%u", &ccs_refresh_interval)
 				 != 1) {
 usage:
 				printf("Usage: %s [e|d|p|m|u] [readonly] "
@@ -2724,12 +2724,12 @@
 			}
 		}
 	}
-	editpolicy_init_keyword_map();
-	if (offline_mode) {
+	ccs_editpolicy_init_keyword_map();
+	if (ccs_offline_mode) {
 		int fd[2] = { EOF, EOF };
-		if (chdir(policy_dir)) {
+		if (chdir(ccs_policy_dir)) {
 			printf("Directory %s doesn't exist.\n",
-			       policy_dir);
+			       ccs_policy_dir);
 			return 1;
 		}
 		if (socketpair(PF_UNIX, SOCK_STREAM, 0, fd)) {
@@ -2739,37 +2739,37 @@
 		switch (fork()) {
 		case 0:
 			close(fd[0]);
-			persistent_fd = fd[1];
-			editpolicy_offline_daemon();
+			ccs_persistent_fd = fd[1];
+			ccs_editpolicy_offline_daemon();
 			_exit(0);
 		case -1:
 			fprintf(stderr, "fork()\n");
 			exit(1);
 		}
 		close(fd[1]);
-		persistent_fd = fd[0];
-		copy_file(DISK_POLICY_EXCEPTION_POLICY,
-			  proc_policy_exception_policy);
-		copy_file(DISK_POLICY_DOMAIN_POLICY, proc_policy_domain_policy);
-		copy_file(DISK_POLICY_PROFILE, proc_policy_profile);
-		copy_file(DISK_POLICY_MANAGER, proc_policy_manager);
-	} else if (!network_mode) {
-		if (chdir(proc_policy_dir)) {
+		ccs_persistent_fd = fd[0];
+		ccs_copy_file(CCS_DISK_POLICY_EXCEPTION_POLICY,
+			      ccs_proc_policy_exception_policy);
+		ccs_copy_file(CCS_DISK_POLICY_DOMAIN_POLICY, ccs_proc_policy_domain_policy);
+		ccs_copy_file(CCS_DISK_POLICY_PROFILE, ccs_proc_policy_profile);
+		ccs_copy_file(CCS_DISK_POLICY_MANAGER, ccs_proc_policy_manager);
+	} else if (!ccs_network_mode) {
+		if (chdir(ccs_proc_policy_dir)) {
 			fprintf(stderr,
 				"You can't use this editor for this kernel.\n");
 			return 1;
 		}
-		if (!readonly_mode) {
-			const int fd1 = open2(proc_policy_exception_policy,
-					      O_RDWR);
-			const int fd2 = open2(proc_policy_domain_policy,
-					      O_RDWR);
+		if (!ccs_readonly_mode) {
+			const int fd1 = ccs_open2(ccs_proc_policy_exception_policy,
+						  O_RDWR);
+			const int fd2 = ccs_open2(ccs_proc_policy_domain_policy,
+						  O_RDWR);
 			if ((fd1 != EOF && write(fd1, "", 0) != 0) ||
 			    (fd2 != EOF && write(fd2, "", 0) != 0)) {
 				fprintf(stderr,
 					"You need to register this program to "
 					"%s to run this program.\n",
-					proc_policy_manager);
+					ccs_proc_policy_manager);
 				return 1;
 			}
 			close(fd1);
@@ -2777,61 +2777,61 @@
 		}
 	}
 	initscr();
-	editpolicy_color_init();
+	ccs_editpolicy_color_init();
 	cbreak();
 	noecho();
 	nonl();
 	intrflush(stdscr, FALSE);
 	keypad(stdscr, TRUE);
-	getmaxyx(stdscr, window_height, window_width);
-	if (refresh_interval) {
-		signal(SIGALRM, sigalrm_handler);
-		alarm(refresh_interval);
+	getmaxyx(stdscr, ccs_window_height, ccs_window_width);
+	if (ccs_refresh_interval) {
+		signal(SIGALRM, ccs_sigalrm_handler);
+		alarm(ccs_refresh_interval);
 		timeout(1000);
 	}
-	while (current_screen < MAXSCREEN) {
-		resize_window();
-		current_screen = generic_list_loop(&dp);
+	while (ccs_current_screen < CCS_MAXSCREEN) {
+		ccs_resize_window();
+		ccs_current_screen = ccs_generic_list_loop(&dp);
 	}
 	alarm(0);
 	clear();
 	move(0, 0);
 	refresh();
 	endwin();
-	if (offline_mode && !readonly_mode) {
+	if (ccs_offline_mode && !ccs_readonly_mode) {
 		time_t now = time(NULL);
-		const char *filename = make_filename("exception_policy", now);
-		if (move_proc_to_file(proc_policy_exception_policy, filename)) {
-			if (is_identical_file("exception_policy.conf",
-					      filename)) {
+		const char *filename = ccs_make_filename("exception_policy", now);
+		if (ccs_move_proc_to_file(ccs_proc_policy_exception_policy, filename)) {
+			if (ccs_is_identical_file("exception_policy.conf",
+						  filename)) {
 				unlink(filename);
 			} else {
 				unlink("exception_policy.conf");
 				symlink(filename, "exception_policy.conf");
 			}
 		}
-		clear_domain_policy(&dp);
-		filename = make_filename("domain_policy", now);
-		if (move_proc_to_file(proc_policy_domain_policy, filename)) {
-			if (is_identical_file("domain_policy.conf", filename)) {
+		ccs_clear_domain_policy(&dp);
+		filename = ccs_make_filename("domain_policy", now);
+		if (ccs_move_proc_to_file(ccs_proc_policy_domain_policy, filename)) {
+			if (ccs_is_identical_file("domain_policy.conf", filename)) {
 				unlink(filename);
 			} else {
 				unlink("domain_policy.conf");
 				symlink(filename, "domain_policy.conf");
 			}
 		}
-		filename = make_filename("profile", now);
-		if (move_proc_to_file(proc_policy_profile, filename)) {
-			if (is_identical_file("profile.conf", filename)) {
+		filename = ccs_make_filename("profile", now);
+		if (ccs_move_proc_to_file(ccs_proc_policy_profile, filename)) {
+			if (ccs_is_identical_file("profile.conf", filename)) {
 				unlink(filename);
 			} else {
 				unlink("profile.conf");
 				symlink(filename, "profile.conf");
 			}
 		}
-		filename = make_filename("manager", now);
-		if (move_proc_to_file(proc_policy_manager, filename)) {
-			if (is_identical_file("manager.conf", filename)) {
+		filename = ccs_make_filename("manager", now);
+		if (ccs_move_proc_to_file(ccs_proc_policy_manager, filename)) {
+			if (ccs_is_identical_file("manager.conf", filename)) {
 				unlink(filename);
 			} else {
 				unlink("manager.conf");
@@ -2839,7 +2839,7 @@
 			}
 		}
 	}
-	clear_domain_policy(&bp);
-	clear_domain_policy(&dp);
+	ccs_clear_domain_policy(&bp);
+	ccs_clear_domain_policy(&dp);
 	return 0;
 }
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/findtemp.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/findtemp.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/findtemp.c	(working copy)
@@ -10,7 +10,7 @@
  */
 #include "ccstools.h"
 
-int findtemp_main(int argc, char *argv[])
+int ccs_findtemp_main(int argc, char *argv[])
 {
 	const char **pattern_list = NULL;
 	int pattern_list_count = 0;
@@ -31,7 +31,7 @@
 					free(domain);
 					domain = strdup(buffer);
 					if (!domain)
-						out_of_memory();
+						ccs_out_of_memory();
 					flag = 0;
 					continue;
 				}
@@ -41,7 +41,7 @@
 					char *cp2 = strchr(cp, ' ');
 					if (cp2)
 						*cp2 = '\0';
-					if (*cp == '/' && decode(cp, buffer2)
+					if (*cp == '/' && ccs_decode(cp, buffer2)
 					    && lstat64(buffer2, &buf)) {
 						if (!flag)
 							printf("\n%s\n",
@@ -71,7 +71,7 @@
 			continue;
 		{
 			struct stat64 buf;
-			if (!decode(buffer, buffer2))
+			if (!ccs_decode(buffer, buffer2))
 				continue;
 			if (!lstat64(buffer2, &buf))
 				continue;
@@ -85,14 +85,14 @@
 		pattern_list = realloc(pattern_list, sizeof(const char *) *
 				       (pattern_list_count + 1));
 		if (!pattern_list)
-			out_of_memory();
+			ccs_out_of_memory();
 		cp = strdup(buffer);
 		if (!cp)
-			out_of_memory();
+			ccs_out_of_memory();
 		pattern_list[pattern_list_count++] = cp;
 	}
 	qsort(pattern_list, pattern_list_count, sizeof(const char *),
-	      string_compare);
+	      ccs_string_compare);
 	for (i = 0; i < pattern_list_count; i++)
 		printf("%s\n", pattern_list[i]);
 	for (i = 0; i < pattern_list_count; i++)
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_offline.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_offline.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_offline.c	(working copy)
@@ -10,39 +10,39 @@
  */
 #include "ccstools.h"
 
-struct misc_policy {
-	const struct path_info **list;
+struct ccs_misc_policy {
+	const struct ccs_path_info **list;
 	int list_len;
 };
 
 /* Prototypes */
 
-static void handle_misc_policy(struct misc_policy *mp, FILE *fp,
-			       _Bool is_write);
+static void ccs_handle_misc_policy(struct ccs_misc_policy *mp, FILE *fp,
+				   _Bool is_write);
 
 /* Utility functions */
 
-static void handle_misc_policy(struct misc_policy *mp, FILE *fp, _Bool is_write)
+static void ccs_handle_misc_policy(struct ccs_misc_policy *mp, FILE *fp, _Bool is_write)
 {
 	int i;
 	if (!is_write)
 		goto read_policy;
 	while (true) {
-		char *line = freadline(fp);
-		const struct path_info *cp;
+		char *line = ccs_freadline(fp);
+		const struct ccs_path_info *cp;
 		_Bool is_delete;
 		if (!line)
 			break;
 		if (!line[0])
 			continue;
-		is_delete = str_starts(line, "delete ");
-		cp = savename(line);
+		is_delete = ccs_str_starts(line, "delete ");
+		cp = ccs_savename(line);
 		if (!cp)
-			out_of_memory();
+			ccs_out_of_memory();
 		if (!is_delete)
 			goto append_policy;
 		for (i = 0; i < mp->list_len; i++)
-			/* Faster comparison, for they are savename'd. */
+			/* Faster comparison, for they are ccs_savename'd. */
 			if (mp->list[i] == cp)
 				break;
 		if (i < mp->list_len)
@@ -51,15 +51,15 @@
 		continue;
 append_policy:
 		for (i = 0; i < mp->list_len; i++)
-			/* Faster comparison, for they are savename'd. */
+			/* Faster comparison, for they are ccs_savename'd. */
 			if (mp->list[i] == cp)
 				break;
 		if (i < mp->list_len)
 			continue;
 		mp->list = realloc(mp->list, (mp->list_len + 1)
-				   * sizeof(const struct path_info *));
+				   * sizeof(const struct ccs_path_info *));
 		if (!mp->list)
-			out_of_memory();
+			ccs_out_of_memory();
 		mp->list[mp->list_len++] = cp;
 	}
 	return;
@@ -70,11 +70,11 @@
 
 /* Variables */
 
-int persistent_fd = EOF;
+int ccs_persistent_fd = EOF;
 
 /* Main functions */
 
-void send_fd(char *data, int *fd)
+void ccs_send_fd(char *data, int *fd)
 {
 	struct msghdr msg;
 	struct iovec iov = { data, strlen(data) };
@@ -90,22 +90,22 @@
 	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
 	msg.msg_controllen = cmsg->cmsg_len;
 	memmove(CMSG_DATA(cmsg), fd, sizeof(int));
-	sendmsg(persistent_fd, &msg, 0);
+	sendmsg(ccs_persistent_fd, &msg, 0);
 	close(*fd);
 }
 
-void editpolicy_offline_daemon(void)
+void ccs_editpolicy_offline_daemon(void)
 {
-	struct misc_policy mp[3];
-	struct domain_policy dp;
+	struct ccs_misc_policy mp[3];
+	struct ccs_domain_policy dp;
 	static const int buffer_len = 8192;
 	char *buffer = malloc(buffer_len);
 	if (!buffer)
-		out_of_memory();
+		ccs_out_of_memory();
 	memset(&dp, 0, sizeof(dp));
 	memset(&mp, 0, sizeof(mp));
-	get();
-	find_or_assign_new_domain(&dp, ROOT_NAME, false, false);
+	ccs_get();
+	ccs_find_or_assign_new_domain(&dp, CCS_ROOT_NAME, false, false);
 	while (true) {
 		FILE *fp;
 		struct msghdr msg;
@@ -119,7 +119,7 @@
 		msg.msg_controllen = sizeof(cmsg_buf);
 		memset(buffer, 0, buffer_len);
 		errno = 0;
-		if (recvmsg(persistent_fd, &msg, 0) <= 0)
+		if (recvmsg(ccs_persistent_fd, &msg, 0) <= 0)
 			break;
 		cmsg = CMSG_FIRSTHDR(&msg);
 		if (!cmsg)
@@ -137,29 +137,29 @@
 		} else {
 			break;
 		}
-		if (str_starts(buffer, "POST ")) {
-			if (!strcmp(buffer, proc_policy_domain_policy))
-				handle_domain_policy(&dp, fp, true);
-			else if (!strcmp(buffer, proc_policy_exception_policy))
-				handle_misc_policy(&mp[0], fp, true);
-			else if (!strcmp(buffer, proc_policy_profile))
-				handle_misc_policy(&mp[1], fp, true);
-			else if (!strcmp(buffer, proc_policy_manager))
-				handle_misc_policy(&mp[2], fp, true);
-		} else if (str_starts(buffer, "GET ")) {
-			if (!strcmp(buffer, proc_policy_domain_policy))
-				handle_domain_policy(&dp, fp, false);
-			else if (!strcmp(buffer, proc_policy_exception_policy))
-				handle_misc_policy(&mp[0], fp, false);
-			else if (!strcmp(buffer, proc_policy_profile))
-				handle_misc_policy(&mp[1], fp, false);
-			else if (!strcmp(buffer, proc_policy_manager))
-				handle_misc_policy(&mp[2], fp, false);
+		if (ccs_str_starts(buffer, "POST ")) {
+			if (!strcmp(buffer, ccs_proc_policy_domain_policy))
+				ccs_handle_domain_policy(&dp, fp, true);
+			else if (!strcmp(buffer, ccs_proc_policy_exception_policy))
+				ccs_handle_misc_policy(&mp[0], fp, true);
+			else if (!strcmp(buffer, ccs_proc_policy_profile))
+				ccs_handle_misc_policy(&mp[1], fp, true);
+			else if (!strcmp(buffer, ccs_proc_policy_manager))
+				ccs_handle_misc_policy(&mp[2], fp, true);
+		} else if (ccs_str_starts(buffer, "GET ")) {
+			if (!strcmp(buffer, ccs_proc_policy_domain_policy))
+				ccs_handle_domain_policy(&dp, fp, false);
+			else if (!strcmp(buffer, ccs_proc_policy_exception_policy))
+				ccs_handle_misc_policy(&mp[0], fp, false);
+			else if (!strcmp(buffer, ccs_proc_policy_profile))
+				ccs_handle_misc_policy(&mp[1], fp, false);
+			else if (!strcmp(buffer, ccs_proc_policy_manager))
+				ccs_handle_misc_policy(&mp[2], fp, false);
 		}
 		fclose(fp);
 	}
-	put();
-	clear_domain_policy(&dp);
+	ccs_put();
+	ccs_clear_domain_policy(&dp);
 	{
 		int i;
 		for (i = 0; i < 3; i++) {
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_optimizer.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_optimizer.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_optimizer.c	(working copy)
@@ -11,32 +11,32 @@
 #include "ccstools.h"
 
 /* Prototypes */
-static int add_address_group_entry(const char *group_name,
-				   const char *member_name,
-				   const _Bool is_delete);
-static struct address_group_entry *find_address_group(const char *group_name);
-static int add_number_group_entry(const char *group_name,
-				  const char *member_name,
-				  const _Bool is_delete);
-static struct number_group_entry *find_number_group(const char *group_name);
-static _Bool compare_path(const char *sarg, const char *darg,
-			  const u8 directive);
-static _Bool compare_number(const char *sarg, const char *darg);
-static _Bool compare_address(const char *sarg, const char *darg);
+static int ccs_add_address_group_entry(const char *group_name,
+				       const char *member_name,
+				       const _Bool is_delete);
+static struct ccs_address_group_entry *ccs_find_address_group(const char *group_name);
+static int ccs_add_number_group_entry(const char *group_name,
+				      const char *member_name,
+				      const _Bool is_delete);
+static struct ccs_number_group_entry *ccs_find_number_group(const char *group_name);
+static _Bool ccs_compare_path(const char *sarg, const char *darg,
+			      const u8 directive);
+static _Bool ccs_compare_number(const char *sarg, const char *darg);
+static _Bool ccs_compare_address(const char *sarg, const char *darg);
 
 /* Utility functions */
 
-struct path_group_entry *find_path_group(const char *group_name)
+struct ccs_path_group_entry *ccs_find_path_group(const char *group_name)
 {
 	int i;
-	for (i = 0; i < path_group_list_len; i++) {
-		if (!strcmp(group_name, path_group_list[i].group_name->name))
-			return &path_group_list[i];
+	for (i = 0; i < ccs_path_group_list_len; i++) {
+		if (!strcmp(group_name, ccs_path_group_list[i].group_name->name))
+			return &ccs_path_group_list[i];
 	}
 	return NULL;
 }
 
-int parse_ip(const char *address, struct ip_address_entry *entry)
+int ccs_parse_ip(const char *address, struct ccs_ip_address_entry *entry)
 {
 	unsigned int min[8];
 	unsigned int max[8];
@@ -77,63 +77,63 @@
 	return -EINVAL;
 }
 
-int add_address_group_policy(char *data, const _Bool is_delete)
+int ccs_add_address_group_policy(char *data, const _Bool is_delete)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return add_address_group_entry(data, cp, is_delete);
+	return ccs_add_address_group_entry(data, cp, is_delete);
 }
 
-static _Bool compare_path(const char *sarg, const char *darg,
-			  const u8 directive)
+static _Bool ccs_compare_path(const char *sarg, const char *darg,
+			      const u8 directive)
 {
 	int i;
-	struct path_group_entry *group;
-	struct path_info s;
-	struct path_info d;
+	struct ccs_path_group_entry *group;
+	struct ccs_path_info s;
+	struct ccs_path_info d;
 	_Bool may_use_pattern;
 	s.name = sarg;
 	d.name = darg;
-	fill_path_info(&s);
-	fill_path_info(&d);
+	ccs_fill_path_info(&s);
+	ccs_fill_path_info(&d);
 	may_use_pattern = !d.is_patterned
-		&& (directive != DIRECTIVE_ALLOW_EXECUTE);
-	if (!pathcmp(&s, &d))
+		&& (directive != CCS_DIRECTIVE_ALLOW_EXECUTE);
+	if (!ccs_pathcmp(&s, &d))
 		return true;
 	if (d.name[0] == '@')
 		return false;
 	if (s.name[0] != '@') {
 		/* Pathname component. */
-		return may_use_pattern && path_matches_pattern(&d, &s);
+		return may_use_pattern && ccs_path_matches_pattern(&d, &s);
 	}
-	/* path_group component. */
-	group = find_path_group(s.name + 1);
+	/* ccs_path_group component. */
+	group = ccs_find_path_group(s.name + 1);
 	if (!group)
 		return false;
 	for (i = 0; i < group->member_name_len; i++) {
-		const struct path_info *member_name;
+		const struct ccs_path_info *member_name;
 		member_name = group->member_name[i];
-		if (!pathcmp(member_name, &d))
+		if (!ccs_pathcmp(member_name, &d))
 			return true;
-		if (may_use_pattern && path_matches_pattern(&d, member_name))
+		if (may_use_pattern && ccs_path_matches_pattern(&d, member_name))
 			return true;
 	}
 	return false;
 }
 
-static _Bool compare_address(const char *sarg, const char *darg)
+static _Bool ccs_compare_address(const char *sarg, const char *darg)
 {
 	int i;
-	struct ip_address_entry sentry;
-	struct ip_address_entry dentry;
-	struct address_group_entry *group;
-	if (parse_ip(darg, &dentry))
+	struct ccs_ip_address_entry sentry;
+	struct ccs_ip_address_entry dentry;
+	struct ccs_address_group_entry *group;
+	if (ccs_parse_ip(darg, &dentry))
 		return false;
 	if (sarg[0] != '@') {
 		/* IP address component. */
-		if (parse_ip(sarg, &sentry))
+		if (ccs_parse_ip(sarg, &sentry))
 			return false;
 		if (sentry.is_ipv6 != dentry.is_ipv6 ||
 		    memcmp(dentry.min, sentry.min, 16) < 0 ||
@@ -142,11 +142,11 @@
 		return true;
 	}
 	/* IP address group component. */
-	group = find_address_group(sarg + 1);
+	group = ccs_find_address_group(sarg + 1);
 	if (!group)
 		return false;
 	for (i = 0; i < group->member_name_len; i++) {
-		struct ip_address_entry *sentry = &group->member_name[i];
+		struct ccs_ip_address_entry *sentry = &group->member_name[i];
 		if (sentry->is_ipv6 == dentry.is_ipv6
 		    && memcmp(sentry->min, dentry.min, 16) <= 0
 		    && memcmp(dentry.max, sentry->max, 16) <= 0)
@@ -181,7 +181,7 @@
 	return i < count || !*buffer ? cp : NULL;
 }
 
-int parse_number(const char *number, struct number_entry *entry)
+int ccs_parse_number(const char *number, struct ccs_number_entry *entry)
 {
 	unsigned long min;
 	unsigned long max;
@@ -211,37 +211,37 @@
 	return 0;
 }
 
-int add_number_group_policy(char *data, const _Bool is_delete)
+int ccs_add_number_group_policy(char *data, const _Bool is_delete)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp)
 		return -EINVAL;
 	*cp++ = '\0';
-	return add_number_group_entry(data, cp, is_delete);
+	return ccs_add_number_group_entry(data, cp, is_delete);
 }
 
-static _Bool compare_number(const char *sarg, const char *darg)
+static _Bool ccs_compare_number(const char *sarg, const char *darg)
 {
 	int i;
-	struct number_entry sentry;
-	struct number_entry dentry;
-	struct number_group_entry *group;
-	if (parse_number(darg, &dentry))
+	struct ccs_number_entry sentry;
+	struct ccs_number_entry dentry;
+	struct ccs_number_group_entry *group;
+	if (ccs_parse_number(darg, &dentry))
 		return false;
 	if (sarg[0] != '@') {
 		/* Number component. */
-		if (parse_number(sarg, &sentry))
+		if (ccs_parse_number(sarg, &sentry))
 			return false;
 		if (sentry.min > dentry.min || sentry.max < dentry.max)
 			return false;
 		return true;
 	}
 	/* Number group component. */
-	group = find_number_group(sarg + 1);
+	group = ccs_find_number_group(sarg + 1);
 	if (!group)
 		return false;
 	for (i = 0; i < group->member_name_len; i++) {
-		struct number_entry *entry = &group->member_name[i];
+		struct ccs_number_entry *entry = &group->member_name[i];
 		if (entry->min > dentry.min || entry->max < dentry.max)
 			continue;
 		return true;
@@ -249,8 +249,8 @@
 	return false;
 }
 
-void editpolicy_try_optimize(struct domain_policy *dp, const int current,
-			     const int screen)
+void ccs_editpolicy_try_optimize(struct ccs_domain_policy *dp, const int current,
+				 const int screen)
 {
 	char *cp;
 	u8 s_index;
@@ -261,10 +261,10 @@
 	char *d[5];
 	if (current < 0)
 		return;
-	s_index = generic_acl_list[current].directive;
-	if (s_index == DIRECTIVE_NONE)
+	s_index = ccs_generic_acl_list[current].directive;
+	if (s_index == CCS_DIRECTIVE_NONE)
 		return;
-	cp = strdup(generic_acl_list[current].operand);
+	cp = strdup(ccs_generic_acl_list[current].operand);
 	if (!cp)
 		return;
 
@@ -274,21 +274,21 @@
 		return;
 	}
 
-	get();
-	for (index = 0; index < list_item_count[screen]; index++) {
+	ccs_get();
+	for (index = 0; index < ccs_list_item_count[screen]; index++) {
 		char *line;
-		const u8 d_index = generic_acl_list[index].directive;
+		const u8 d_index = ccs_generic_acl_list[index].directive;
 		if (index == current)
 			continue;
-		if (generic_acl_list[index].selected)
+		if (ccs_generic_acl_list[index].selected)
 			continue;
-		if (s_index == DIRECTIVE_ALLOW_READ_WRITE) {
+		if (s_index == CCS_DIRECTIVE_ALLOW_READ_WRITE) {
 			/* Source starts with "allow_read/write " */
-			if (d_index == DIRECTIVE_ALLOW_READ_WRITE) {
+			if (d_index == CCS_DIRECTIVE_ALLOW_READ_WRITE) {
 				/* Dest starts with "allow_read/write " */
-			} else if (d_index == DIRECTIVE_ALLOW_READ) {
+			} else if (d_index == CCS_DIRECTIVE_ALLOW_READ) {
 				/* Dest starts with "allow_read " */
-			} else if (d_index == DIRECTIVE_ALLOW_WRITE) {
+			} else if (d_index == CCS_DIRECTIVE_ALLOW_WRITE) {
 				/* Dest starts with "allow_write " */
 			} else {
 				/*
@@ -303,7 +303,7 @@
 			/* Source and dest start with different directive. */
 			continue;
 		}
-		line = shprintf("%s", generic_acl_list[index].operand);
+		line = ccs_shprintf("%s", ccs_generic_acl_list[index].operand);
 		d_cond = ccs_tokenize(line, d, sizeof(d));
 
 		/* Compare condition part. */
@@ -321,54 +321,54 @@
 			fclose(fp);
 		}
 		switch (d_index) {
-			struct path_info sarg;
-			struct path_info darg;
+			struct ccs_path_info sarg;
+			struct ccs_path_info darg;
 			char c;
 			int len;
-		case DIRECTIVE_ALLOW_MKBLOCK:
-		case DIRECTIVE_ALLOW_MKCHAR:
-			if (!compare_number(s[3], d[3]) ||
-			    !compare_number(s[2], d[2]))
+		case CCS_DIRECTIVE_ALLOW_MKBLOCK:
+		case CCS_DIRECTIVE_ALLOW_MKCHAR:
+			if (!ccs_compare_number(s[3], d[3]) ||
+			    !ccs_compare_number(s[2], d[2]))
 				continue;
 			/* fall through */
-		case DIRECTIVE_ALLOW_CREATE:
-		case DIRECTIVE_ALLOW_MKDIR:
-		case DIRECTIVE_ALLOW_MKFIFO:
-		case DIRECTIVE_ALLOW_MKSOCK:
-		case DIRECTIVE_ALLOW_IOCTL:
-		case DIRECTIVE_ALLOW_CHMOD:
-		case DIRECTIVE_ALLOW_CHOWN:
-		case DIRECTIVE_ALLOW_CHGRP:
-			if (!compare_number(s[1], d[1]))
+		case CCS_DIRECTIVE_ALLOW_CREATE:
+		case CCS_DIRECTIVE_ALLOW_MKDIR:
+		case CCS_DIRECTIVE_ALLOW_MKFIFO:
+		case CCS_DIRECTIVE_ALLOW_MKSOCK:
+		case CCS_DIRECTIVE_ALLOW_IOCTL:
+		case CCS_DIRECTIVE_ALLOW_CHMOD:
+		case CCS_DIRECTIVE_ALLOW_CHOWN:
+		case CCS_DIRECTIVE_ALLOW_CHGRP:
+			if (!ccs_compare_number(s[1], d[1]))
 				continue;
 			/* fall through */
-		case DIRECTIVE_ALLOW_EXECUTE:
-		case DIRECTIVE_ALLOW_READ:
-		case DIRECTIVE_ALLOW_WRITE:
-		case DIRECTIVE_ALLOW_READ_WRITE:
-		case DIRECTIVE_ALLOW_UNLINK:
-		case DIRECTIVE_ALLOW_RMDIR:
-		case DIRECTIVE_ALLOW_TRUNCATE:
-		case DIRECTIVE_ALLOW_REWRITE:
-		case DIRECTIVE_ALLOW_UNMOUNT:
-		case DIRECTIVE_ALLOW_CHROOT:
-		case DIRECTIVE_ALLOW_SYMLINK:
-			if (!compare_path(s[0], d[0], d_index))
+		case CCS_DIRECTIVE_ALLOW_EXECUTE:
+		case CCS_DIRECTIVE_ALLOW_READ:
+		case CCS_DIRECTIVE_ALLOW_WRITE:
+		case CCS_DIRECTIVE_ALLOW_READ_WRITE:
+		case CCS_DIRECTIVE_ALLOW_UNLINK:
+		case CCS_DIRECTIVE_ALLOW_RMDIR:
+		case CCS_DIRECTIVE_ALLOW_TRUNCATE:
+		case CCS_DIRECTIVE_ALLOW_REWRITE:
+		case CCS_DIRECTIVE_ALLOW_UNMOUNT:
+		case CCS_DIRECTIVE_ALLOW_CHROOT:
+		case CCS_DIRECTIVE_ALLOW_SYMLINK:
+			if (!ccs_compare_path(s[0], d[0], d_index))
 				continue;
 			break;
-		case DIRECTIVE_ALLOW_MOUNT:
-			if (!compare_number(s[3], d[3]) ||
-			    !compare_path(s[2], d[2], d_index))
+		case CCS_DIRECTIVE_ALLOW_MOUNT:
+			if (!ccs_compare_number(s[3], d[3]) ||
+			    !ccs_compare_path(s[2], d[2], d_index))
 				continue;
 			/* fall through */
-		case DIRECTIVE_ALLOW_LINK:
-		case DIRECTIVE_ALLOW_RENAME:
-		case DIRECTIVE_ALLOW_PIVOT_ROOT:
-			if (!compare_path(s[1], d[1], d_index) ||
-			    !compare_path(s[0], d[0], d_index))
+		case CCS_DIRECTIVE_ALLOW_LINK:
+		case CCS_DIRECTIVE_ALLOW_RENAME:
+		case CCS_DIRECTIVE_ALLOW_PIVOT_ROOT:
+			if (!ccs_compare_path(s[1], d[1], d_index) ||
+			    !ccs_compare_path(s[0], d[0], d_index))
 				continue;
 			break;
-		case DIRECTIVE_ALLOW_SIGNAL:
+		case CCS_DIRECTIVE_ALLOW_SIGNAL:
 			/* Signal number component. */
 			if (strcmp(s[0], d[0]))
 				continue;
@@ -380,60 +380,60 @@
 			if (c && c != ' ')
 				continue;
 			break;
-		case DIRECTIVE_ALLOW_NETWORK:
+		case CCS_DIRECTIVE_ALLOW_NETWORK:
 			if (strcmp(s[0], d[0]) || strcmp(s[1], d[1]) ||
-			    !compare_address(s[2], d[2]) ||
-			    !compare_number(s[3], d[3]))
+			    !ccs_compare_address(s[2], d[2]) ||
+			    !ccs_compare_number(s[3], d[3]))
 				continue;
 			break;
-		case DIRECTIVE_ALLOW_ENV:
+		case CCS_DIRECTIVE_ALLOW_ENV:
 			/* An environemnt variable name component. */
 			sarg.name = s[0];
-			fill_path_info(&sarg);
+			ccs_fill_path_info(&sarg);
 			darg.name = d[0];
-			fill_path_info(&darg);
-			if (!pathcmp(&sarg, &darg))
+			ccs_fill_path_info(&darg);
+			if (!ccs_pathcmp(&sarg, &darg))
 				break;
 			/* allow_env doesn't interpret leading @ as
-			   path_group. */
+			   ccs_path_group. */
 			if (darg.is_patterned ||
-			    !path_matches_pattern(&darg, &sarg))
+			    !ccs_path_matches_pattern(&darg, &sarg))
 				continue;
 			break;
 		default:
 			continue;
 		}
-		generic_acl_list[index].selected = 1;
+		ccs_generic_acl_list[index].selected = 1;
 	}
-	put();
+	ccs_put();
 	free(cp);
 }
 
 /* Variables */
 
-static struct address_group_entry *address_group_list = NULL;
-int address_group_list_len = 0;
+static struct ccs_address_group_entry *ccs_address_group_list = NULL;
+int ccs_address_group_list_len = 0;
 
 /* Main functions */
 
-static int add_address_group_entry(const char *group_name,
-				   const char *member_name,
-				   const _Bool is_delete)
+static int ccs_add_address_group_entry(const char *group_name,
+				       const char *member_name,
+				       const _Bool is_delete)
 {
-	const struct path_info *saved_group_name;
+	const struct ccs_path_info *saved_group_name;
 	int i;
 	int j;
-	struct ip_address_entry entry;
-	struct address_group_entry *group = NULL;
-	if (parse_ip(member_name, &entry))
+	struct ccs_ip_address_entry entry;
+	struct ccs_address_group_entry *group = NULL;
+	if (ccs_parse_ip(member_name, &entry))
 		return -EINVAL;
-	if (!is_correct_path(group_name, 0, 0, 0))
+	if (!ccs_is_correct_path(group_name, 0, 0, 0))
 		return -EINVAL;
-	saved_group_name = savename(group_name);
+	saved_group_name = ccs_savename(group_name);
 	if (!saved_group_name)
 		return -ENOMEM;
-	for (i = 0; i < address_group_list_len; i++) {
-		group = &address_group_list[i];
+	for (i = 0; i < ccs_address_group_list_len; i++) {
+		group = &ccs_address_group_list[i];
 		if (saved_group_name != group->group_name)
 			continue;
 		for (j = 0; j < group->member_name_len; j++) {
@@ -452,58 +452,58 @@
 	}
 	if (is_delete)
 		return -ENOENT;
-	if (i == address_group_list_len) {
+	if (i == ccs_address_group_list_len) {
 		void *vp;
-		vp = realloc(address_group_list,
-			     (address_group_list_len + 1) *
-			     sizeof(struct address_group_entry));
+		vp = realloc(ccs_address_group_list,
+			     (ccs_address_group_list_len + 1) *
+			     sizeof(struct ccs_address_group_entry));
 		if (!vp)
-			out_of_memory();
-		address_group_list = vp;
-		group = &address_group_list[address_group_list_len++];
-		memset(group, 0, sizeof(struct address_group_entry));
+			ccs_out_of_memory();
+		ccs_address_group_list = vp;
+		group = &ccs_address_group_list[ccs_address_group_list_len++];
+		memset(group, 0, sizeof(struct ccs_address_group_entry));
 		group->group_name = saved_group_name;
 	}
 	group->member_name = realloc(group->member_name,
 				     (group->member_name_len + 1) *
-				     sizeof(const struct ip_address_entry));
+				     sizeof(const struct ccs_ip_address_entry));
 	if (!group->member_name)
-		out_of_memory();
+		ccs_out_of_memory();
 	group->member_name[group->member_name_len++] = entry;
 	return 0;
 }
 
-static struct address_group_entry *find_address_group(const char *group_name)
+static struct ccs_address_group_entry *ccs_find_address_group(const char *group_name)
 {
 	int i;
-	for (i = 0; i < address_group_list_len; i++) {
-		if (!strcmp(group_name, address_group_list[i].group_name->name))
-			return &address_group_list[i];
+	for (i = 0; i < ccs_address_group_list_len; i++) {
+		if (!strcmp(group_name, ccs_address_group_list[i].group_name->name))
+			return &ccs_address_group_list[i];
 	}
 	return NULL;
 }
 
-static struct number_group_entry *number_group_list = NULL;
-int number_group_list_len = 0;
+static struct ccs_number_group_entry *ccs_number_group_list = NULL;
+int ccs_number_group_list_len = 0;
 
-static int add_number_group_entry(const char *group_name,
-				  const char *member_name,
-				  const _Bool is_delete)
+static int ccs_add_number_group_entry(const char *group_name,
+				      const char *member_name,
+				      const _Bool is_delete)
 {
-	const struct path_info *saved_group_name;
+	const struct ccs_path_info *saved_group_name;
 	int i;
 	int j;
-	struct number_entry entry;
-	struct number_group_entry *group = NULL;
-	if (parse_number(member_name, &entry))
+	struct ccs_number_entry entry;
+	struct ccs_number_group_entry *group = NULL;
+	if (ccs_parse_number(member_name, &entry))
 		return -EINVAL;
-	if (!is_correct_path(group_name, 0, 0, 0))
+	if (!ccs_is_correct_path(group_name, 0, 0, 0))
 		return -EINVAL;
-	saved_group_name = savename(group_name);
+	saved_group_name = ccs_savename(group_name);
 	if (!saved_group_name)
 		return -ENOMEM;
-	for (i = 0; i < number_group_list_len; i++) {
-		group = &number_group_list[i];
+	for (i = 0; i < ccs_number_group_list_len; i++) {
+		group = &ccs_number_group_list[i];
 		if (saved_group_name != group->group_name)
 			continue;
 		for (j = 0; j < group->member_name_len; j++) {
@@ -522,33 +522,33 @@
 	}
 	if (is_delete)
 		return -ENOENT;
-	if (i == number_group_list_len) {
+	if (i == ccs_number_group_list_len) {
 		void *vp;
-		vp = realloc(number_group_list,
-			     (number_group_list_len + 1) *
-			     sizeof(struct number_group_entry));
+		vp = realloc(ccs_number_group_list,
+			     (ccs_number_group_list_len + 1) *
+			     sizeof(struct ccs_number_group_entry));
 		if (!vp)
-			out_of_memory();
-		number_group_list = vp;
-		group = &number_group_list[number_group_list_len++];
-		memset(group, 0, sizeof(struct number_group_entry));
+			ccs_out_of_memory();
+		ccs_number_group_list = vp;
+		group = &ccs_number_group_list[ccs_number_group_list_len++];
+		memset(group, 0, sizeof(struct ccs_number_group_entry));
 		group->group_name = saved_group_name;
 	}
 	group->member_name = realloc(group->member_name,
 				     (group->member_name_len + 1) *
-				     sizeof(const struct number_entry));
+				     sizeof(const struct ccs_number_entry));
 	if (!group->member_name)
-		out_of_memory();
+		ccs_out_of_memory();
 	group->member_name[group->member_name_len++] = entry;
 	return 0;
 }
 
-static struct number_group_entry *find_number_group(const char *group_name)
+static struct ccs_number_group_entry *ccs_find_number_group(const char *group_name)
 {
 	int i;
-	for (i = 0; i < number_group_list_len; i++) {
-		if (!strcmp(group_name, number_group_list[i].group_name->name))
-			return &number_group_list[i];
+	for (i = 0; i < ccs_number_group_list_len; i++) {
+		if (!strcmp(group_name, ccs_number_group_list[i].group_name->name))
+			return &ccs_number_group_list[i];
 	}
 	return NULL;
 }
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_keyword.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_keyword.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/editpolicy_keyword.c	(working copy)
@@ -12,71 +12,71 @@
 
 /* Variables */
 
-struct editpolicy_directive directives[MAX_DIRECTIVE_INDEX] = {
-	[DIRECTIVE_NONE] = { "", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_EXECUTE]    = { "allow_execute", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_READ]       = { "allow_read", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_WRITE]      = { "allow_write", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_READ_WRITE] = { "allow_read/write", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_CREATE]     = { "allow_create", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_UNLINK]     = { "allow_unlink", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_MKDIR]      = { "allow_mkdir", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_RMDIR]      = { "allow_rmdir", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_MKFIFO]     = { "allow_mkfifo", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_MKSOCK]     = { "allow_mksock", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_MKBLOCK]    = { "allow_mkblock", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_MKCHAR]     = { "allow_mkchar", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_TRUNCATE]   = { "allow_truncate", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_SYMLINK]    = { "allow_symlink", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_LINK]       = { "allow_link", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_RENAME]     = { "allow_rename", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_REWRITE]    = { "allow_rewrite", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_TRANSIT]    = { "allow_transit", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_IOCTL]      = { "allow_ioctl", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_SIGNAL]     = { "allow_signal", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_NETWORK]    = { "allow_network", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_ENV]        = { "allow_env", NULL, 0, 0 },
-	[DIRECTIVE_ADDRESS_GROUP]    = { "address_group", NULL, 0, 0 },
-	[DIRECTIVE_AGGREGATOR]       = { "aggregator", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_CAPABILITY] = { "allow_capability", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_CHROOT]     = { "allow_chroot", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_MOUNT]      = { "allow_mount", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_PIVOT_ROOT] = { "allow_pivot_root", NULL, 0, 0 },
-	[DIRECTIVE_DENY_AUTOBIND]    = { "deny_autobind", NULL, 0, 0 },
-	[DIRECTIVE_DENY_REWRITE]     = { "deny_rewrite", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_UNMOUNT]    = { "allow_unmount", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_CHMOD]      = { "allow_chmod", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_CHOWN]      = { "allow_chown", NULL, 0, 0 },
-	[DIRECTIVE_ALLOW_CHGRP]      = { "allow_chgrp", NULL, 0, 0 },
-	[DIRECTIVE_FILE_PATTERN]     = { "file_pattern", NULL, 0, 0 },
-	[DIRECTIVE_EXECUTE_HANDLER]  = { "execute_handler", NULL, 0, 0 },
-	[DIRECTIVE_DENIED_EXECUTE_HANDLER] = {
+struct ccs_editpolicy_directive ccs_directives[CCS_MAX_DIRECTIVE_INDEX] = {
+	[CCS_DIRECTIVE_NONE] = { "", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_EXECUTE]    = { "allow_execute", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_READ]       = { "allow_read", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_WRITE]      = { "allow_write", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_READ_WRITE] = { "allow_read/write", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_CREATE]     = { "allow_create", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_UNLINK]     = { "allow_unlink", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_MKDIR]      = { "allow_mkdir", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_RMDIR]      = { "allow_rmdir", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_MKFIFO]     = { "allow_mkfifo", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_MKSOCK]     = { "allow_mksock", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_MKBLOCK]    = { "allow_mkblock", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_MKCHAR]     = { "allow_mkchar", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_TRUNCATE]   = { "allow_truncate", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_SYMLINK]    = { "allow_symlink", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_LINK]       = { "allow_link", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_RENAME]     = { "allow_rename", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_REWRITE]    = { "allow_rewrite", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_TRANSIT]    = { "allow_transit", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_IOCTL]      = { "allow_ioctl", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_SIGNAL]     = { "allow_signal", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_NETWORK]    = { "allow_network", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_ENV]        = { "allow_env", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ADDRESS_GROUP]    = { "address_group", NULL, 0, 0 },
+	[CCS_DIRECTIVE_AGGREGATOR]       = { "aggregator", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_CAPABILITY] = { "allow_capability", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_CHROOT]     = { "allow_chroot", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_MOUNT]      = { "allow_mount", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_PIVOT_ROOT] = { "allow_pivot_root", NULL, 0, 0 },
+	[CCS_DIRECTIVE_DENY_AUTOBIND]    = { "deny_autobind", NULL, 0, 0 },
+	[CCS_DIRECTIVE_DENY_REWRITE]     = { "deny_rewrite", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_UNMOUNT]    = { "allow_unmount", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_CHMOD]      = { "allow_chmod", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_CHOWN]      = { "allow_chown", NULL, 0, 0 },
+	[CCS_DIRECTIVE_ALLOW_CHGRP]      = { "allow_chgrp", NULL, 0, 0 },
+	[CCS_DIRECTIVE_FILE_PATTERN]     = { "file_pattern", NULL, 0, 0 },
+	[CCS_DIRECTIVE_EXECUTE_HANDLER]  = { "execute_handler", NULL, 0, 0 },
+	[CCS_DIRECTIVE_DENIED_EXECUTE_HANDLER] = {
 		"denied_execute_handler", NULL, 0, 0 },
-	[DIRECTIVE_IGNORE_GLOBAL_ALLOW_ENV] = {
+	[CCS_DIRECTIVE_IGNORE_GLOBAL_ALLOW_ENV] = {
 		"ignore_global_allow_env", NULL, 0, 0 },
-	[DIRECTIVE_IGNORE_GLOBAL_ALLOW_READ] = {
+	[CCS_DIRECTIVE_IGNORE_GLOBAL_ALLOW_READ] = {
 		"ignore_global_allow_read", NULL, 0, 0 },
-	[DIRECTIVE_INITIALIZE_DOMAIN]    = { "initialize_domain", NULL, 0, 0 },
-	[DIRECTIVE_KEEP_DOMAIN]          = { "keep_domain", NULL, 0, 0 },
-	[DIRECTIVE_NO_INITIALIZE_DOMAIN] = {
+	[CCS_DIRECTIVE_INITIALIZE_DOMAIN]    = { "initialize_domain", NULL, 0, 0 },
+	[CCS_DIRECTIVE_KEEP_DOMAIN]          = { "keep_domain", NULL, 0, 0 },
+	[CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN] = {
 		"no_initialize_domain", NULL, 0, 0 },
-	[DIRECTIVE_NO_KEEP_DOMAIN]       = { "no_keep_domain", NULL, 0, 0 },
-	[DIRECTIVE_PATH_GROUP]       = { "path_group", NULL, 0, 0 },
-	[DIRECTIVE_NUMBER_GROUP]     = { "number_group", NULL, 0, 0 },
-	[DIRECTIVE_QUOTA_EXCEEDED]   = { "quota_exceeded", NULL, 0, 0 },
-	[DIRECTIVE_USE_PROFILE]      = { "use_profile", NULL, 0, 0 },
-	[DIRECTIVE_TRANSITION_FAILED] = { "transition_failed", NULL, 0, 0 },
+	[CCS_DIRECTIVE_NO_KEEP_DOMAIN]       = { "no_keep_domain", NULL, 0, 0 },
+	[CCS_DIRECTIVE_PATH_GROUP]       = { "path_group", NULL, 0, 0 },
+	[CCS_DIRECTIVE_NUMBER_GROUP]     = { "number_group", NULL, 0, 0 },
+	[CCS_DIRECTIVE_QUOTA_EXCEEDED]   = { "quota_exceeded", NULL, 0, 0 },
+	[CCS_DIRECTIVE_USE_PROFILE]      = { "use_profile", NULL, 0, 0 },
+	[CCS_DIRECTIVE_TRANSITION_FAILED] = { "transition_failed", NULL, 0, 0 },
 };
 
 /* Main functions */
 
-u8 find_directive(const _Bool forward, char *line)
+u8 ccs_find_directive(const _Bool forward, char *line)
 {
 	u8 i;
-	for (i = 1; i < MAX_DIRECTIVE_INDEX; i++) {
+	for (i = 1; i < CCS_MAX_DIRECTIVE_INDEX; i++) {
 		if (forward) {
-			const int len = directives[i].original_len;
-			if (strncmp(line, directives[i].original, len) ||
+			const int len = ccs_directives[i].original_len;
+			if (strncmp(line, ccs_directives[i].original, len) ||
 			    (line[len] != ' ' && line[len]))
 				continue;
 			if (line[len])
@@ -86,8 +86,8 @@
 				line[0] = '\0';
 			return i;
 		} else {
-			const int len = directives[i].alias_len;
-			if (strncmp(line, directives[i].alias, len) ||
+			const int len = ccs_directives[i].alias_len;
+			if (strncmp(line, ccs_directives[i].alias, len) ||
 			    (line[len] != ' ' && line[len]))
 				continue;
 			if (line[len])
@@ -98,50 +98,50 @@
 			return i;
 		}
 	}
-	return DIRECTIVE_NONE;
+	return CCS_DIRECTIVE_NONE;
 }
 
-void editpolicy_init_keyword_map(void)
+void ccs_editpolicy_init_keyword_map(void)
 {
 	FILE *fp = fopen(CCSTOOLS_CONFIG_FILE, "r");
 	int i;
 	if (!fp)
 		goto use_default;
-	get();
+	ccs_get();
 	while (true) {
-		char *line = freadline(fp);
+		char *line = ccs_freadline(fp);
 		char *cp;
 		if (!line)
 			break;
-		if (!str_starts(line, "editpolicy.keyword_alias "))
+		if (!ccs_str_starts(line, "editpolicy.keyword_alias "))
 			continue;
 		cp = strchr(line, '=');
 		if (!cp)
 			continue;
 		*cp++ = '\0';
-		normalize_line(line);
-		normalize_line(cp);
+		ccs_normalize_line(line);
+		ccs_normalize_line(cp);
 		if (!*line || !*cp)
 			continue;
-		for (i = 1; i < MAX_DIRECTIVE_INDEX; i++) {
-			if (strcmp(line, directives[i].original))
+		for (i = 1; i < CCS_MAX_DIRECTIVE_INDEX; i++) {
+			if (strcmp(line, ccs_directives[i].original))
 				continue;
-			free((void *) directives[i].alias);
+			free((void *) ccs_directives[i].alias);
 			cp = strdup(cp);
 			if (!cp)
-				out_of_memory();
-			directives[i].alias = cp;
-			directives[i].alias_len = strlen(cp);
+				ccs_out_of_memory();
+			ccs_directives[i].alias = cp;
+			ccs_directives[i].alias_len = strlen(cp);
 			break;
 		}
 	}
-	put();
+	ccs_put();
 	fclose(fp);
 use_default:
-	for (i = 1; i < MAX_DIRECTIVE_INDEX; i++) {
-		if (!directives[i].alias)
-			directives[i].alias = directives[i].original;
-		directives[i].original_len = strlen(directives[i].original);
-		directives[i].alias_len = strlen(directives[i].alias);
+	for (i = 1; i < CCS_MAX_DIRECTIVE_INDEX; i++) {
+		if (!ccs_directives[i].alias)
+			ccs_directives[i].alias = ccs_directives[i].original;
+		ccs_directives[i].original_len = strlen(ccs_directives[i].original);
+		ccs_directives[i].alias_len = strlen(ccs_directives[i].alias);
 	}
 }
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/pathmatch.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/pathmatch.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/pathmatch.c	(working copy)
@@ -1,5 +1,5 @@
 /*
- * pathmatch.c
+ * ccs_pathmatch.c
  *
  * TOMOYO Linux's utilities.
  *
@@ -10,11 +10,11 @@
  */
 #include "ccstools.h"
 
-static unsigned char revalidate_path(const char *path)
+static unsigned char ccs_revalidate_path(const char *ccs_path)
 {
 	struct stat buf;
 	unsigned char type = DT_UNKNOWN;
-	if (!lstat(path, &buf)) {
+	if (!lstat(ccs_path, &buf)) {
 		if (S_ISREG(buf.st_mode))
 			type = DT_REG;
 		else if (S_ISDIR(buf.st_mode))
@@ -25,23 +25,23 @@
 	return type;
 }
 
-static int scandir_filter(const struct dirent *buf)
+static int ccs_scandir_filter(const struct dirent *buf)
 {
 	return strcmp(buf->d_name, ".") && strcmp(buf->d_name, "..");
 }
 
-static struct path_info target;
-static _Bool print_path_needs_separator = false;
+static struct ccs_path_info ccs_target;
+static _Bool ccs_print_path_needs_separator = false;
 
-static _Bool print_path(const char *path, const int type)
+static _Bool ccs_print_path(const char *path, const int type)
 {
-	struct path_info name;
+	struct ccs_path_info name;
 	int len;
 	char *cp;
 	len = strlen(path) * 4 + 4;
 	cp = malloc(len);
 	if (!cp)
-		out_of_memory();
+		ccs_out_of_memory();
 	name.name = cp;
 	while (true) {
 		const unsigned char c = *(const unsigned char *) path++;
@@ -62,76 +62,76 @@
 			*cp++ = (c & 7) + '0';
 		}
 	}
-	fill_path_info(&name);
-	if (path_matches_pattern(&name, &target)) {
-		if (print_path_needs_separator)
+	ccs_fill_path_info(&name);
+	if (ccs_path_matches_pattern(&name, &ccs_target)) {
+		if (ccs_print_path_needs_separator)
 			putchar(' ');
-		print_path_needs_separator = true;
+		ccs_print_path_needs_separator = true;
 		printf("%s", name.name);
 	}
-	len = name.total_len >= target.const_len ? target.const_len :
+	len = name.total_len >= ccs_target.const_len ? ccs_target.const_len :
 		name.total_len;
-	len = strncmp(name.name, target.name, len);
+	len = strncmp(name.name, ccs_target.name, len);
 	free((void *) name.name);
 	return !len;
 }
 
-static char path[8192];
+static char ccs_path[8192];
 
-static void scan_dir(void)
+static void ccs_scan_dir(void)
 {
 	struct dirent **namelist;
-	int n = scandir(path, &namelist, scandir_filter, 0);
+	int n = scandir(ccs_path, &namelist, ccs_scandir_filter, 0);
 	int len;
 	int i;
 	if (n < 0)
 		return;
-	len = strlen(path);
+	len = strlen(ccs_path);
 	if (len == 1)
 		len = 0;
 	for (i = 0; i < n; i++) {
 		unsigned char type = namelist[i]->d_type;
-		snprintf(path + len, sizeof(path) - len - 1, "/%s",
+		snprintf(ccs_path + len, sizeof(ccs_path) - len - 1, "/%s",
 			 namelist[i]->d_name);
 		if (type == DT_UNKNOWN)
-			type = revalidate_path(path);
-		if (print_path(path, type) && type == DT_DIR)
-			scan_dir();
+			type = ccs_revalidate_path(ccs_path);
+		if (ccs_print_path(ccs_path, type) && type == DT_DIR)
+			ccs_scan_dir();
 		free((void *) namelist[i]);
 	}
 	free((void *) namelist);
 }
 
-static void do_pathmatch_main(char *find)
+static void ccs_do_pathmatch_main(char *find)
 {
 	if (!strcmp(find, "/"))
 		putchar('/');
-	else if (is_correct_path(find, 1, 0, 0)) {
-		target.name = find;
-		fill_path_info(&target);
-		print_path_needs_separator = false;
-		memset(path, 0, sizeof(path));
-		strncpy(path, "/", sizeof(path) - 1);
-		scan_dir();
+	else if (ccs_is_correct_path(find, 1, 0, 0)) {
+		ccs_target.name = find;
+		ccs_fill_path_info(&ccs_target);
+		ccs_print_path_needs_separator = false;
+		memset(ccs_path, 0, sizeof(ccs_path));
+		strncpy(ccs_path, "/", sizeof(ccs_path) - 1);
+		ccs_scan_dir();
 	}
 	putchar('\n');
 }
 
-int pathmatch_main(int argc, char *argv[])
+int ccs_pathmatch_main(int argc, char *argv[])
 {
 	if (argc > 1) {
 		int i;
 		for (i = 1; i < argc; i++)
-			do_pathmatch_main(argv[i]);
+			ccs_do_pathmatch_main(argv[i]);
 	} else {
-		get();
+		ccs_get();
 		while (true) {
-			char *line = freadline(stdin);
+			char *line = ccs_freadline(stdin);
 			if (!line)
 				break;
-			do_pathmatch_main(line);
+			ccs_do_pathmatch_main(line);
 		}
-		put();
+		ccs_put();
 	}
 	return 0;
 }
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/queryd.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/queryd.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/queryd.c	(working copy)
@@ -10,27 +10,27 @@
  */
 #include "ccstools.h"
 
-#define GLOBALLY_READABLE_FILES_UPDATE_NONE 0
-#define GLOBALLY_READABLE_FILES_UPDATE_ASK  1
-#define GLOBALLY_READABLE_FILES_UPDATE_AUTO 2
+#define CCS_GLOBALLY_READABLE_FILES_UPDATE_NONE 0
+#define CCS_GLOBALLY_READABLE_FILES_UPDATE_ASK  1
+#define CCS_GLOBALLY_READABLE_FILES_UPDATE_AUTO 2
 
 /* Prototypes */
 
-static void _printw(const char *fmt, ...)
+static void ccs_printw(const char *fmt, ...)
      __attribute__ ((format(printf, 1, 2)));
-static int send_encoded(const int fd, const char *fmt, ...)
+static int ccs_send_encoded(const int fd, const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
-static void do_check_update(const int fd);
-static void handle_update(const int check_update, const int fd);
+static void ccs_do_check_update(const int fd);
+static void ccs_handle_update(const int ccs_check_update, const int fd);
 /*
-static _Bool convert_path_info(FILE *fp, const struct path_info *pattern,
-			       const char *new);
+static _Bool ccs_convert_path_info(FILE *fp, const struct ccs_path_info *pattern,
+				   const char *new);
 */
-static _Bool handle_query(unsigned int serial);
+static _Bool ccs_handle_query(unsigned int serial);
 
 /* Utility functions */
 
-static void _printw(const char *fmt, ...)
+static void ccs_printw(const char *fmt, ...)
 {
 	va_list args;
 	int i;
@@ -41,7 +41,7 @@
 	va_end(args);
 	buffer = malloc(len);
 	if (!buffer)
-		out_of_memory();
+		ccs_out_of_memory();
 	va_start(args, fmt);
 	len = vsnprintf(buffer, len, fmt, args);
 	va_end(args);
@@ -52,7 +52,7 @@
 	free(buffer);
 }
 
-static int send_encoded(const int fd, const char *fmt, ...)
+static int ccs_send_encoded(const int fd, const char *fmt, ...)
 {
 	va_list args;
 	int i;
@@ -65,7 +65,7 @@
 	va_end(args);
 	buffer = malloc(len * 5);
 	if (!buffer)
-		out_of_memory();
+		ccs_out_of_memory();
 	va_start(args, fmt);
 	vsnprintf(buffer, len, fmt, args);
 	va_end(args);
@@ -94,16 +94,16 @@
 }
 
 #if 0
-static _Bool check_path_info(const char *buffer)
+static _Bool ccs_check_path_info(const char *buffer)
 {
 	_Bool modified = false;
-	static struct path_info *update_list = NULL;
+	static struct ccs_path_info *update_list = NULL;
 	static int update_list_len = 0;
 	char *sp = strdup(buffer);
 	char *str = sp;
 	const char *path_list[2] = {
-		proc_policy_exception_policy,
-		proc_policy_domain_policy
+		ccs_proc_policy_exception_policy,
+		ccs_proc_policy_domain_policy
 	};
 	if (!str)
 		return false;
@@ -114,11 +114,11 @@
 			break;
 		for (i = 0; i < update_list_len; i++) {
 			int j;
-			struct path_info old;
+			struct ccs_path_info old;
 			/* TODO: split cp at upadte_list's depth. */
 			old.name = cp;
-			fill_path_info(&old);
-			if (!path_matches_pattern(&old, &update_list[i]))
+			ccs_fill_path_info(&old);
+			if (!ccs_path_matches_pattern(&old, &update_list[i]))
 				continue;
 			for (j = 0; j < 2; j++) {
 				FILE *fp = fopen(path_list[j], "r+");
@@ -135,9 +135,9 @@
 }
 #endif
 
-static void do_check_update(const int fd)
+static void ccs_do_check_update(const int fd)
 {
-	FILE *fp_in = fopen(proc_policy_exception_policy, "r");
+	FILE *fp_in = fopen(ccs_proc_policy_exception_policy, "r");
 	char **pathnames = NULL;
 	int pathnames_len = 0;
 	char buffer[16384];
@@ -151,17 +151,17 @@
 		if (!cp)
 			break;
 		*cp = '\0';
-		if (!str_starts(buffer, KEYWORD_ALLOW_READ))
+		if (!ccs_str_starts(buffer, CCS_KEYWORD_ALLOW_READ))
 			continue;
-		if (!decode(buffer, buffer))
+		if (!ccs_decode(buffer, buffer))
 			continue;
 		pathnames = realloc(pathnames, sizeof(char *) *
 				    (pathnames_len + 1));
 		if (!pathnames)
-			out_of_memory();
+			ccs_out_of_memory();
 		pathnames[pathnames_len] = strdup(buffer);
 		if (!pathnames[pathnames_len])
-			out_of_memory();
+			ccs_out_of_memory();
 		pathnames_len++;
 	}
 	fclose(fp_in);
@@ -174,7 +174,7 @@
 			int j;
 			if (!stat64(pathnames[i], &buf))
 				continue;
-			send_encoded(fd, "-%s", pathnames[i]);
+			ccs_send_encoded(fd, "-%s", pathnames[i]);
 			free(pathnames[i]);
 			pathnames_len--;
 			for (j = i; j < pathnames_len; j++)
@@ -212,12 +212,12 @@
 				pathnames = realloc(pathnames, sizeof(char *) *
 						    (pathnames_len + 1));
 				if (!pathnames)
-					out_of_memory();
+					ccs_out_of_memory();
 				cp = strdup(real_pathname);
 				if (!cp)
-					out_of_memory();
+					ccs_out_of_memory();
 				pathnames[pathnames_len++] = cp;
-				send_encoded(fd, "+%s", pathnames[i]);
+				ccs_send_encoded(fd, "+%s", pathnames[i]);
 			}
 			free(real_pathname);
 		}
@@ -226,8 +226,8 @@
 }
 
 #if 0
-static _Bool convert_path_info(FILE *fp, const struct path_info *pattern,
-			       const char *new)
+static _Bool ccs_convert_path_info(FILE *fp, const struct ccs_path_info *pattern,
+				   const char *new)
 {
 	_Bool modified = false;
 	const char *cp = pattern->name;
@@ -246,7 +246,7 @@
 		cp = buffer;
 		while (*cp) {
 			char c;
-			struct path_info old;
+			struct ccs_path_info old;
 			_Bool matched;
 			if (*cp != '/' || --d)
 				continue;
@@ -254,8 +254,8 @@
 			c = *cp;
 			*cp = '\0';
 			old.name = buffer;
-			fill_path_info(&old);
-			matched = path_matches_pattern(&old, pattern);
+			ccs_fill_path_info(&old);
+			matched = ccs_path_matches_pattern(&old, pattern);
 			*cp = c;
 			if (matched) {
 				fprintf(fp, "%s%s", new, cp);
@@ -271,72 +271,72 @@
 }
 #endif
 
-static void send_keepalive(void)
+static void ccs_send_keepalive(void)
 {
 	static time_t previous = 0;
 	time_t now = time(NULL);
 	if (previous != now || !previous) {
 		previous = now;
-		write(query_fd, "\n", 1);
+		write(ccs_query_fd, "\n", 1);
 	}
 }
 
-static void handle_update(const int check_update, const int fd)
+static void ccs_handle_update(const int check_update, const int fd)
 {
 	static FILE *fp = NULL;
 	char pathname[8192];
 	int c;
 	if (!fp)
-		fp = fopen(proc_policy_exception_policy, "w");
+		fp = fopen(ccs_proc_policy_exception_policy, "w");
 	memset(pathname, 0, sizeof(pathname));
 	if (recv(fd, pathname, sizeof(pathname) - 1, 0) == EOF)
 		return;
-	if (check_update == GLOBALLY_READABLE_FILES_UPDATE_AUTO) {
+	if (check_update == CCS_GLOBALLY_READABLE_FILES_UPDATE_AUTO) {
 		if (pathname[0] == '-')
-			fprintf(fp, KEYWORD_DELETE);
-		fprintf(fp, KEYWORD_ALLOW_READ "%s\n", pathname + 1);
+			fprintf(fp, CCS_KEYWORD_DELETE);
+		fprintf(fp, CCS_KEYWORD_ALLOW_READ "%s\n", pathname + 1);
 		fflush(fp);
-		_printw("The pathname %s was %s globally readable file.\n\n",
+		ccs_printw("The pathname %s was %s globally readable file.\n\n",
 		       pathname + 1, (pathname[0] == '-') ?
 		       "deleted. Deleted from" : "created. Appended to");
 		return;
 	}
-	_printw("The pathname %s was %s globally readable file? ('Y'es/'N'o):",
+	ccs_printw("The pathname %s was %s globally readable file? ('Y'es/'N'o):",
 	       pathname + 1, (pathname[0] == '-') ?
 	       "deleted. Delete from" : "created. Append to");
 	while (true) {
-		c = getch2();
+		c = ccs_getch2();
 		if (c == 'Y' || c == 'y' || c == 'N' || c == 'n')
 			break;
-		send_keepalive();
+		ccs_send_keepalive();
 	}
-	_printw("%c\n", c);
+	ccs_printw("%c\n", c);
 	if (c == 'Y' || c == 'y') {
 		if (pathname[0] == '-')
-			fprintf(fp, KEYWORD_DELETE);
-		fprintf(fp, KEYWORD_ALLOW_READ "%s\n", pathname + 1);
+			fprintf(fp, CCS_KEYWORD_DELETE);
+		fprintf(fp, CCS_KEYWORD_ALLOW_READ "%s\n", pathname + 1);
 		fflush(fp);
 	}
-	_printw("\n");
+	ccs_printw("\n");
 }
 
 /* Variables */
 
-static unsigned short int retries = 0;
+static unsigned short int ccs_retries = 0;
 
-static int check_update = GLOBALLY_READABLE_FILES_UPDATE_AUTO;
+static int ccs_check_update = CCS_GLOBALLY_READABLE_FILES_UPDATE_AUTO;
 
-static FILE *domain_fp = NULL;
-static int domain_policy_fd = EOF;
-static const int max_readline_history = 20;
-static const char **readline_history = NULL;
-static int readline_history_count = 0;
-static const int buffer_len = 32768;
-static char *buffer = NULL;
+static FILE *ccs_domain_fp = NULL;
+static int ccs_domain_policy_fd = EOF;
+static const int ccs_max_readline_history = 20;
+static const char **ccs_readline_history = NULL;
+static int ccs_readline_history_count = 0;
+static const int ccs_buffer_len = 32768;
+static char *ccs_buffer = NULL;
 
 /* Main functions */
 
-static _Bool handle_query(unsigned int serial)
+static _Bool ccs_handle_query(unsigned int serial)
 {
 	int c = 0;
 	int y;
@@ -346,82 +346,82 @@
 	unsigned int pid;
 	time_t stamp;
 	char pidbuf[128];
-	char *cp = strstr(buffer, " (global-pid=");
+	char *cp = strstr(ccs_buffer, " (global-pid=");
 	if (!cp || sscanf(cp + 13, "%u", &pid) != 1) {
-		_printw("ERROR: Unsupported query.\n");
+		ccs_printw("ERROR: Unsupported query.\n");
 		return false;
 	}
-	cp = buffer + strlen(buffer);
+	cp = ccs_buffer + strlen(ccs_buffer);
 	if (*(cp - 1) != '\n') {
-		_printw("ERROR: Unsupported query.\n");
+		ccs_printw("ERROR: Unsupported query.\n");
 		return false;
 	}
 	*(cp - 1) = '\0';
 	/*
-	if (0 && !retries && check_path_info(buffer)) {
+	if (0 && !ccs_retries && check_path_info(ccs_buffer)) {
 		c = 'r';
 		goto write_answer;
 	}
 	*/
 	if (pid != prev_pid) {
 		if (prev_pid)
-			_printw("----------------------------------------\n");
+			ccs_printw("----------------------------------------\n");
 		prev_pid = pid;
 	}
-	if (sscanf(buffer, "#timestamp=%lu", &stamp) == 1) {
-		cp = strchr(buffer, ' ');
+	if (sscanf(ccs_buffer, "#timestamp=%lu", &stamp) == 1) {
+		cp = strchr(ccs_buffer, ' ');
 		if (cp) {
 			struct tm *tm = localtime(&stamp);
-			_printw("#%04d-%02d-%02d %02d:%02d:%02d#",
-			       tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
-			       tm->tm_hour, tm->tm_min, tm->tm_sec);
-			memmove(buffer, cp, strlen(cp) + 1);
+			ccs_printw("#%04d-%02d-%02d %02d:%02d:%02d#",
+				   tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
+				   tm->tm_hour, tm->tm_min, tm->tm_sec);
+			memmove(ccs_buffer, cp, strlen(cp) + 1);
 		}
 	}
-	_printw("%s\n", buffer);
+	ccs_printw("%s\n", ccs_buffer);
 	/* Is this domain query? */
-	if (strstr(buffer, "\n#"))
+	if (strstr(ccs_buffer, "\n#"))
 		goto not_domain_query;
 	memset(pidbuf, 0, sizeof(pidbuf));
 	snprintf(pidbuf, sizeof(pidbuf) - 1, "select global-pid=%u\n", pid);
-	_printw("Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy "
-		"and retry):");
+	ccs_printw("Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy "
+		   "and retry):");
 	while (true) {
-		c = getch2();
+		c = ccs_getch2();
 		if (c == 'Y' || c == 'y' || c == 'N' || c == 'n' || c == 'R' ||
 		    c == 'r' || c == 'A' || c == 'a' || c == 'S' || c == 's')
 			break;
-		send_keepalive();
+		ccs_send_keepalive();
 	}
-	_printw("%c\n", c);
+	ccs_printw("%c\n", c);
 
 	if (c == 'S' || c == 's') {
-		if (network_mode) {
-			fprintf(domain_fp, "%s", pidbuf);
-			fputc(0, domain_fp);
-			fflush(domain_fp);
-			rewind(domain_fp);
+		if (ccs_network_mode) {
+			fprintf(ccs_domain_fp, "%s", pidbuf);
+			fputc(0, ccs_domain_fp);
+			fflush(ccs_domain_fp);
+			rewind(ccs_domain_fp);
 			while (1) {
 				char c;
-				if (fread(&c, 1, 1, domain_fp) != 1 || !c)
+				if (fread(&c, 1, 1, ccs_domain_fp) != 1 || !c)
 					break;
 				addch(c);
 				refresh();
-				send_keepalive();
+				ccs_send_keepalive();
 			}
 		} else {
-			write(domain_policy_fd, pidbuf, strlen(pidbuf));
+			write(ccs_domain_policy_fd, pidbuf, strlen(pidbuf));
 			while (1) {
 				int i;
-				int len = read(domain_policy_fd, buffer,
-					       buffer_len - 1);
+				int len = read(ccs_domain_policy_fd, ccs_buffer,
+					       ccs_buffer_len - 1);
 				if (len <= 0)
 					break;
 				for (i = 0; i < len; i++) {
-					addch(buffer[i]);
+					addch(ccs_buffer[i]);
 					refresh();
 				}
-				send_keepalive();
+				ccs_send_keepalive();
 			}
 		}
 		c = 'r';
@@ -432,34 +432,34 @@
 		goto not_append;
 	c = 'r';
 	getyx(stdscr, y, x);
-	cp = strrchr(buffer, '\n');
+	cp = strrchr(ccs_buffer, '\n');
 	if (!cp)
 		return false;
 	*cp++ = '\0';
-	initial_readline_data = cp;
-	readline_history_count = simple_add_history(cp, readline_history,
-						    readline_history_count,
-						    max_readline_history);
-	line = simple_readline(y, 0, "Enter new entry> ", readline_history,
-			       readline_history_count, 128000, 8);
+	ccs_initial_readline_data = cp;
+	ccs_readline_history_count = ccs_simple_add_history(cp, ccs_readline_history,
+							    ccs_readline_history_count,
+							    ccs_max_readline_history);
+	line = ccs_simple_readline(y, 0, "Enter new entry> ", ccs_readline_history,
+				   ccs_readline_history_count, 128000, 8);
 	scrollok(stdscr, TRUE);
-	_printw("\n");
+	ccs_printw("\n");
 	if (!line || !*line) {
-		_printw("None added.\n");
+		ccs_printw("None added.\n");
 		goto not_append;
 	}
-	readline_history_count = simple_add_history(line, readline_history,
-						    readline_history_count,
-						    max_readline_history);
-	if (network_mode) {
-		fprintf(domain_fp, "%s%s\n", pidbuf, line);
-		fflush(domain_fp);
+	ccs_readline_history_count = ccs_simple_add_history(line, ccs_readline_history,
+							    ccs_readline_history_count,
+							    ccs_max_readline_history);
+	if (ccs_network_mode) {
+		fprintf(ccs_domain_fp, "%s%s\n", pidbuf, line);
+		fflush(ccs_domain_fp);
 	} else {
-		write(domain_policy_fd, pidbuf, strlen(pidbuf));
-		write(domain_policy_fd, line, strlen(line));
-		write(domain_policy_fd, "\n", 1);
+		write(ccs_domain_policy_fd, pidbuf, strlen(pidbuf));
+		write(ccs_domain_policy_fd, line, strlen(line));
+		write(ccs_domain_policy_fd, "\n", 1);
 	}
-	_printw("Added '%s'.\n", line);
+	ccs_printw("Added '%s'.\n", line);
 not_append:
 	free(line);
 write_answer:
@@ -470,24 +470,24 @@
 		c = 3;
 	else
 		c = 2;
-	snprintf(buffer, buffer_len - 1, "A%u=%u\n", serial, c);
-	write(query_fd, buffer, strlen(buffer));
-	_printw("\n");
+	snprintf(ccs_buffer, ccs_buffer_len - 1, "A%u=%u\n", serial, c);
+	write(ccs_query_fd, ccs_buffer, strlen(ccs_buffer));
+	ccs_printw("\n");
 	return true;
 not_domain_query:
-	_printw("Allow? ('Y'es/'N'o/'R'etry):");
+	ccs_printw("Allow? ('Y'es/'N'o/'R'etry):");
 	while (true) {
-		c = getch2();
+		c = ccs_getch2();
 		if (c == 'Y' || c == 'y' || c == 'N' || c == 'n' ||
 		    c == 'R' || c == 'r')
 			break;
-		send_keepalive();
+		ccs_send_keepalive();
 	}
-	_printw("%c\n", c);
+	ccs_printw("%c\n", c);
 	goto write_answer;
 }
 
-int queryd_main(int argc, char *argv[])
+int ccs_queryd_main(int argc, char *argv[])
 {
 	int pipe_fd[2] = { EOF, EOF };
 	if (argc == 1)
@@ -496,21 +496,21 @@
 		char *cp = strchr(argv[1], ':');
 		if (cp) {
 			*cp++ = '\0';
-			network_ip = inet_addr(argv[1]);
-			network_port = htons(atoi(cp));
-			network_mode = true;
-			if (!check_remote_host())
+			ccs_network_ip = inet_addr(argv[1]);
+			ccs_network_port = htons(atoi(cp));
+			ccs_network_mode = true;
+			if (!ccs_check_remote_host())
 				return 1;
-			check_update = GLOBALLY_READABLE_FILES_UPDATE_NONE;
+			ccs_check_update = CCS_GLOBALLY_READABLE_FILES_UPDATE_NONE;
 			goto ok;
 		}
 	}
 	if (!strcmp(argv[1], "--no-update")) {
-		check_update = GLOBALLY_READABLE_FILES_UPDATE_NONE;
+		ccs_check_update = CCS_GLOBALLY_READABLE_FILES_UPDATE_NONE;
 		goto ok;
 	}
 	if (!strcmp(argv[1], "--ask-update")) {
-		check_update = GLOBALLY_READABLE_FILES_UPDATE_ASK;
+		ccs_check_update = CCS_GLOBALLY_READABLE_FILES_UPDATE_ASK;
 		goto ok;
 	}
 	printf("Usage: %s [--no-update|--ask-update|remote_ip:remote_port]\n\n",
@@ -526,33 +526,33 @@
 	printf("To terminate this program, use 'Ctrl-C'.\n");
 	return 0;
  ok:
-	if (network_mode) {
-		query_fd = open_stream("proc:query");
-		domain_fp = open_write(proc_policy_domain_policy);
+	if (ccs_network_mode) {
+		ccs_query_fd = ccs_open_stream("proc:query");
+		ccs_domain_fp = ccs_open_write(ccs_proc_policy_domain_policy);
 	} else {
-		query_fd = open(proc_policy_query, O_RDWR);
-		domain_policy_fd = open(proc_policy_domain_policy, O_RDWR);
+		ccs_query_fd = open(ccs_proc_policy_query, O_RDWR);
+		ccs_domain_policy_fd = open(ccs_proc_policy_domain_policy, O_RDWR);
 	}
-	if (query_fd == EOF) {
+	if (ccs_query_fd == EOF) {
 		fprintf(stderr,
 			"You can't run this utility for this kernel.\n");
 		return 1;
-	} else if (!network_mode && write(query_fd, "", 0) != 0) {
+	} else if (!ccs_network_mode && write(ccs_query_fd, "", 0) != 0) {
 		fprintf(stderr, "You need to register this program to %s to "
-			"run this program.\n", proc_policy_manager);
+			"run this program.\n", ccs_proc_policy_manager);
 		return 1;
 	}
-	if (check_update != GLOBALLY_READABLE_FILES_UPDATE_NONE) {
+	if (ccs_check_update != CCS_GLOBALLY_READABLE_FILES_UPDATE_NONE) {
 		socketpair(AF_UNIX, SOCK_DGRAM, 0, pipe_fd);
 		switch (fork()) {
 		case 0:
-			if (domain_fp)
-				fclose(domain_fp);
+			if (ccs_domain_fp)
+				fclose(ccs_domain_fp);
 			else
-				close(domain_policy_fd);
-			close(query_fd);
+				close(ccs_domain_policy_fd);
+			close(ccs_query_fd);
 			close(pipe_fd[0]);
-			do_check_update(pipe_fd[1]);
+			ccs_do_check_update(pipe_fd[1]);
 			_exit(0);
 		case -1:
 			fprintf(stderr, "Can't fork().\n");
@@ -561,10 +561,10 @@
 		close(pipe_fd[1]);
 		pipe_fd[1] = EOF;
 	}
-	readline_history = malloc(max_readline_history * sizeof(const char *));
-	if (!readline_history)
-		out_of_memory();
-	send_keepalive();
+	ccs_readline_history = malloc(ccs_max_readline_history * sizeof(const char *));
+	if (!ccs_readline_history)
+		ccs_out_of_memory();
+	ccs_send_keepalive();
 	initscr();
 	cbreak();
 	noecho();
@@ -574,77 +574,77 @@
 	clear();
 	refresh();
 	scrollok(stdscr, TRUE);
-	if (network_mode) {
-		const u32 ip = ntohl(network_ip);
-		_printw("Monitoring /proc/ccs/query via %u.%u.%u.%u:%u.",
-			(u8) (ip >> 24), (u8) (ip >> 16), (u8) (ip >> 8),
-			(u8) ip, ntohs(network_port));
+	if (ccs_network_mode) {
+		const u32 ip = ntohl(ccs_network_ip);
+		ccs_printw("Monitoring /proc/ccs/query via %u.%u.%u.%u:%u.",
+			   (u8) (ip >> 24), (u8) (ip >> 16), (u8) (ip >> 8),
+			   (u8) ip, ntohs(ccs_network_port));
 	} else
-		_printw("Monitoring /proc/ccs/query %s.",
-			check_update != GLOBALLY_READABLE_FILES_UPDATE_NONE ?
-			"and /etc/ld.so.cache " : "");
-	_printw(" Press Ctrl-C to terminate.\n\n");
+		ccs_printw("Monitoring /proc/ccs/query %s.",
+			   ccs_check_update != CCS_GLOBALLY_READABLE_FILES_UPDATE_NONE ?
+			   "and /etc/ld.so.cache " : "");
+	ccs_printw(" Press Ctrl-C to terminate.\n\n");
 	while (true) {
 		static _Bool first = true;
 		static unsigned int prev_serial = 0;
 		fd_set rfds;
 		unsigned int serial;
 		char *cp;
-		if (!buffer) {
-			buffer = malloc(buffer_len);
-			if (!buffer)
+		if (!ccs_buffer) {
+			ccs_buffer = malloc(ccs_buffer_len);
+			if (!ccs_buffer)
 				break;
 		}
 		/* Wait for query. */
-		if (network_mode) {
+		if (ccs_network_mode) {
 			int i;
-			write(query_fd, "", 1);
-			memset(buffer, 0, buffer_len);
-			for (i = 0; i < buffer_len - 1; i++) {
-				if (read(query_fd, buffer + i, 1) != 1)
+			write(ccs_query_fd, "", 1);
+			memset(ccs_buffer, 0, ccs_buffer_len);
+			for (i = 0; i < ccs_buffer_len - 1; i++) {
+				if (read(ccs_query_fd, ccs_buffer + i, 1) != 1)
 					break;
-				if (!buffer[i])
+				if (!ccs_buffer[i])
 					goto read_ok;
 			}
 			break;
 		}
 		FD_ZERO(&rfds);
-		FD_SET(query_fd, &rfds);
+		FD_SET(ccs_query_fd, &rfds);
 		if (pipe_fd[0] != EOF)
 			FD_SET(pipe_fd[0], &rfds);
-		select(query_fd > pipe_fd[0] ? query_fd + 1 : pipe_fd[0] + 1,
+		select(ccs_query_fd > pipe_fd[0] ? ccs_query_fd + 1 : pipe_fd[0] + 1,
 		       &rfds, NULL, NULL, NULL);
 		if (pipe_fd[0] != EOF && FD_ISSET(pipe_fd[0], &rfds))
-			handle_update(check_update, pipe_fd[0]);
-		if (!FD_ISSET(query_fd, &rfds))
+			ccs_handle_update(ccs_check_update, pipe_fd[0]);
+		if (!FD_ISSET(ccs_query_fd, &rfds))
 			continue;
 
 		/* Read query. */
-		memset(buffer, 0, buffer_len);
-		if (read(query_fd, buffer, buffer_len - 1) <= 0)
+		memset(ccs_buffer, 0, ccs_buffer_len);
+		if (read(ccs_query_fd, ccs_buffer, ccs_buffer_len - 1) <= 0)
 			continue;
 read_ok:
-		cp = strchr(buffer, '\n');
+		cp = strchr(ccs_buffer, '\n');
 		if (!cp)
 			continue;
 		*cp = '\0';
 
 		/* Get query number. */
-		if (sscanf(buffer, "Q%u-%hu", &serial, &retries) != 2)
+		if (sscanf(ccs_buffer, "Q%u-%hu", &serial, &ccs_retries) != 2)
 			continue;
-		memmove(buffer, cp + 1, strlen(cp + 1) + 1);
+		memmove(ccs_buffer, cp + 1, strlen(cp + 1) + 1);
 
 		first = false;
 		prev_serial = serial;
 		/* Clear pending input. */;
 		timeout(0);
 		while (true) {
-			int c = getch2();
+			int c = ccs_getch2();
 			if (c == EOF || c == ERR)
 				break;
 		}
 		timeout(1000);
-		if (handle_query(serial))
+		if (ccs_handle_query(serial))
 			continue;
 		break;
 	}
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/auditd.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/auditd.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/auditd.c	(working copy)
@@ -10,7 +10,7 @@
  */
 #include "ccstools.h"
 
-int open_stream(const char *filename)
+int ccs_open_stream(const char *filename)
 {
 	const int fd = socket(AF_INET, SOCK_STREAM, 0);
 	struct sockaddr_in addr;
@@ -18,8 +18,8 @@
 	int len = strlen(filename) + 1;
 	memset(&addr, 0, sizeof(addr));
 	addr.sin_family = AF_INET;
-	addr.sin_addr.s_addr = network_ip;
-	addr.sin_port = network_port;
+	addr.sin_addr.s_addr = ccs_network_ip;
+	addr.sin_port = ccs_network_port;
 	if (connect(fd, (struct sockaddr *) &addr, sizeof(addr)) ||
 	    write(fd, filename, len) != len || read(fd, &c, 1) != 1 || c) {
 		close(fd);
@@ -28,11 +28,11 @@
 	return fd;
 }
 
-int auditd_main(int argc, char *argv[])
+int ccs_auditd_main(int argc, char *argv[])
 {
 	const char *procfile_path[CCS_AUDITD_MAX_FILES] = {
-		proc_policy_grant_log,
-		proc_policy_reject_log
+		ccs_proc_policy_grant_log,
+		ccs_proc_policy_reject_log
 	};
 	int i;
 	int fd_in[CCS_AUDITD_MAX_FILES];
@@ -51,12 +51,12 @@
 				goto usage;
 		} else if (cp) {
 			*cp++ = '\0';
-			if (network_mode)
+			if (ccs_network_mode)
 				goto usage;
-			network_ip = inet_addr(ptr);
-			network_port = htons(atoi(cp));
-			network_mode = true;
-			if (!check_remote_host())
+			ccs_network_ip = inet_addr(ptr);
+			ccs_network_port = htons(atoi(cp));
+			ccs_network_mode = true;
+			if (!ccs_check_remote_host())
 				return 1;
 			procfile_path[0] = "proc:grant_log";
 			procfile_path[1] = "proc:reject_log";
@@ -65,7 +65,7 @@
 	}
 	if (!logfile_path[1])
 		goto usage;
-	if (network_mode)
+	if (ccs_network_mode)
 		goto start;
 	if (access(procfile_path[0], R_OK) || access(procfile_path[1], R_OK)) {
 		fprintf(stderr, "You can't run this daemon for this kernel.\n");
@@ -117,8 +117,8 @@
 	close(2);
 	openlog("ccs-auditd", 0,  LOG_USER);
 	for (i = 0; i < CCS_AUDITD_MAX_FILES; i++) {
-		if (network_mode)
-			fd_in[i] = open_stream(procfile_path[i]);
+		if (ccs_network_mode)
+			fd_in[i] = ccs_open_stream(procfile_path[i]);
 		else
 			fd_in[i] = open(procfile_path[i], O_RDONLY);
 		if (fd_in[i] == EOF) {
@@ -143,7 +143,7 @@
 			if (!FD_ISSET(fd_in[i], &rfds))
 				continue;
 			memset(buffer, 0, sizeof(buffer));
-			if (network_mode) {
+			if (ccs_network_mode) {
 				int j;
 				for (j = 0; j < sizeof(buffer) - 1; j++) {
 					if (read(fd_in[i], buffer + j, 1) != 1)
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/setprofile.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/setprofile.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/setprofile.c	(working copy)
@@ -10,7 +10,7 @@
  */
 #include "ccstools.h"
 
-int setprofile_main(int argc, char *argv[])
+int ccs_setprofile_main(int argc, char *argv[])
 {
 	FILE *fp_in;
 	FILE *fp_out;
@@ -28,9 +28,9 @@
 		return 0;
 	}
 	for (i = start; i < argc; i++)
-		normalize_line(argv[i]);
+		ccs_normalize_line(argv[i]);
 	{
-		const int fd = open(proc_policy_domain_status, O_RDWR);
+		const int fd = open(ccs_proc_policy_domain_status, O_RDWR);
 		if (fd == EOF) {
 			fprintf(stderr, "You can't run this command for this "
 				"kernel.\n");
@@ -38,21 +38,21 @@
 		} else if (write(fd, "", 0) != 0) {
 			fprintf(stderr, "You need to register this program to "
 				"%s to run this program.\n",
-				proc_policy_manager);
+				ccs_proc_policy_manager);
 			return 1;
 		}
 		close(fd);
 	}
 	{
 		_Bool profile_found = false;
-		FILE *fp = fopen(proc_policy_profile, "r");
+		FILE *fp = fopen(ccs_proc_policy_profile, "r");
 		if (!fp) {
 			fprintf(stderr, "Can't open policy file.\n");
 			exit(1);
 		}
-		get();
+		ccs_get();
 		while (true) {
-			char *line = freadline(fp);
+			char *line = ccs_freadline(fp);
 			if (!line)
 				break;
 			if (atoi(line) != profile)
@@ -60,23 +60,23 @@
 			profile_found = true;
 			break;
 		}
-		put();
+		ccs_put();
 		fclose(fp);
 		if (!profile_found) {
 			fprintf(stderr, "Profile %u not defined.\n", profile);
 			exit(1);
 		}
 	}
-	fp_in = fopen(proc_policy_domain_status, "r");
-	fp_out = fopen(proc_policy_domain_status, "w");
+	fp_in = fopen(ccs_proc_policy_domain_status, "r");
+	fp_out = fopen(ccs_proc_policy_domain_status, "w");
 	if (!fp_in || !fp_out) {
 		fprintf(stderr, "Can't open policy file.\n");
 		exit(1);
 	}
-	get();
+	ccs_get();
 	while (true) {
 		char *cp;
-		char *line = freadline(fp_in);
+		char *line = ccs_freadline(fp_in);
 		if (!line)
 			break;
 		cp = strchr(line, ' ');
@@ -98,7 +98,7 @@
 			printf("%u %s\n", profile, cp);
 		}
 	}
-	put();
+	ccs_put();
 	fclose(fp_in);
 	fclose(fp_out);
 	return 0;
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/setlevel.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/setlevel.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/setlevel.c	(working copy)
@@ -10,13 +10,13 @@
  */
 #include "ccstools.h"
 
-int setlevel_main(int argc, char *argv[])
+int ccs_setlevel_main(int argc, char *argv[])
 {
-	const char *policy_file = proc_policy_profile;
+	const char *policy_file = ccs_proc_policy_profile;
 	int i;
 	int fd;
 	char c;
-	if (access(proc_policy_dir, F_OK)) {
+	if (access(ccs_proc_policy_dir, F_OK)) {
 		fprintf(stderr, "You can't use this command for this "
 			"kernel.\n");
 		return 1;
@@ -27,7 +27,7 @@
 		return 1;
 	} else if (write(fd, "", 0) != 0) {
 		fprintf(stderr, "You need to register this program to %s to "
-			"run this program.\n", proc_policy_manager);
+			"run this program.\n", ccs_proc_policy_manager);
 		return 1;
 	}
 	if (argc == 1) {
@@ -48,9 +48,9 @@
 				*(cp + 1) = '\0';
 		}
 		fflush(fp);
-		get();
+		ccs_get();
 		while (true) {
-			char *line = freadline(fp);
+			char *line = ccs_freadline(fp);
 			if (!line)
 				break;
 			for (i = 1; i < argc; i++) {
@@ -60,7 +60,7 @@
 				break;
 			}
 		}
-		put();
+		ccs_put();
 		fclose(fp);
 	}
 	close(fd);
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/readline.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/readline.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/readline.c	(working copy)
@@ -10,7 +10,7 @@
  */
 #include "ccstools.h"
 
-static int getch0(void)
+static int ccs_getch0(void)
 {
 	static int enter_key = EOF;
 	int c;
@@ -18,7 +18,7 @@
 	c = getch();
 	if (c == 127 || c == 8)
 		c = KEY_BACKSPACE;
-	/* syslog(LOG_INFO, "getch0='%c' (%d)\n", c, c); */
+	/* syslog(LOG_INFO, "ccs_getch0='%c' (%d)\n", c, c); */
 	if (c == '\r' || c == '\n') {
 		if (enter_key == EOF)
 			enter_key = c;
@@ -28,7 +28,7 @@
 	return c;
 }
 
-int getch2(void)
+int ccs_getch2(void)
 {
 	static int c0 = 0;
 	static int c1 = 0;
@@ -42,25 +42,25 @@
 		len--;
 		return c0;
 	}
-	c0 = getch0();
+	c0 = ccs_getch0();
 	if (c0 != 0x1B)
 		return c0;
-	c1 = getch0();
+	c1 = ccs_getch0();
 	if (c1 != '[') {
 		len = 1;
 		return c0;
 	}
-	c2 = getch0();
+	c2 = ccs_getch0();
 	if (c2 < '1' || c2 > '6') {
 		len = 2;
 		return c0;
 	}
-	c3 = getch0();
+	c3 = ccs_getch0();
 	if (c3 != '~') {
 		len = 3;
 		return c0;
 	}
-	/* syslog(LOG_INFO, "getch2='%c'\n", c2); */
+	/* syslog(LOG_INFO, "ccs_getch2='%c'\n", c2); */
 	switch (c2) {
 	case '1':
 		return KEY_HOME;
@@ -78,8 +78,8 @@
 	return 0;
 }
 
-int simple_add_history(const char *buffer, const char **history,
-		       const int history_count, const int max_history)
+int ccs_simple_add_history(const char *buffer, const char **history,
+			   const int history_count, const int max_history)
 {
 	char *cp = buffer ? strdup(buffer) : NULL;
 	if (!cp)
@@ -102,12 +102,12 @@
 	return 0;
 }
 
-int query_fd = EOF;
-char *initial_readline_data = NULL;
+int ccs_query_fd = EOF;
+char *ccs_initial_readline_data = NULL;
 
-char *simple_readline(const int start_y, const int start_x, const char *prompt,
-		      const char *history[], const int history_count,
-		      const int max_length, const int scroll_width)
+char *ccs_simple_readline(const int start_y, const int start_x, const char *prompt,
+			  const char *history[], const int history_count,
+			  const int max_length, const int scroll_width)
 {
 	const int prompt_len = prompt ? strlen(prompt) : 0;
 	int buffer_len = 0;
@@ -138,8 +138,8 @@
 	}
 	move(start_y, start_x);
 	history_pos = history_count;
-	if (initial_readline_data) {
-		strncpy(buffer, initial_readline_data, max_length);
+	if (ccs_initial_readline_data) {
+		strncpy(buffer, ccs_initial_readline_data, max_length);
 		buffer_len = strlen(buffer);
 		ungetch(KEY_END);
 	}
@@ -169,9 +169,9 @@
 		clrtoeol();
 		move(y, cur_pos + prompt_len);
 		refresh();
-		c = getch2();
-		if (query_fd != EOF)
-			write(query_fd, "\n", 1);
+		c = ccs_getch2();
+		if (ccs_query_fd != EOF)
+			write(ccs_query_fd, "\n", 1);
 		if (c == 4) { /* Ctrl-D */
 			if (!buffer_len)
 				buffer_len = -1;
@@ -283,6 +283,6 @@
 	}
 	if (buffer_len == -1)
 		return NULL;
-	normalize_line(buffer);
+	ccs_normalize_line(buffer);
 	return strdup(buffer);
 }
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/patternize.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/patternize.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/patternize.c	(working copy)
@@ -14,7 +14,7 @@
  * Check whether the given filename is patterened.
  * Returns nonzero if patterned, zero otherwise.
  */
-static _Bool path_contains_pattern(const char *filename)
+static _Bool ccs_path_contains_pattern(const char *filename)
 {
 	if (filename) {
 		char c;
@@ -49,74 +49,74 @@
 	return false;
 }
 
-struct path_pattern_entry {
+struct ccs_path_pattern_entry {
 	const char *group_name;
-	struct path_info path;
-	struct number_entry number;
-	struct ip_address_entry ip;
+	struct ccs_path_info path;
+	struct ccs_number_entry number;
+	struct ccs_ip_address_entry ip;
 	int type;
 };
 
-static struct path_pattern_entry *pattern_list = NULL;
-static int pattern_list_len = 0;
+static struct ccs_path_pattern_entry *ccs_pattern_list = NULL;
+static int ccs_pattern_list_len = 0;
 
-static const char *path_patternize(const char *cp)
+static const char *ccs_path_patternize(const char *cp)
 {
 	int i;
-	struct path_info cp2;
+	struct ccs_path_info cp2;
 	cp2.name = cp;
-	fill_path_info(&cp2);
-	for (i = 1; i < pattern_list_len; i++) {
-		const int type = pattern_list[i].type;
+	ccs_fill_path_info(&cp2);
+	for (i = 1; i < ccs_pattern_list_len; i++) {
+		const int type = ccs_pattern_list[i].type;
 		if (type != 1 && type != 2)
 			continue;
-		if (!path_matches_pattern(&cp2, &pattern_list[i].path))
+		if (!ccs_path_matches_pattern(&cp2, &ccs_pattern_list[i].path))
 			continue;
 		if (type == 2)
-			return pattern_list[i].group_name;
-		return pattern_list[i].path.name;
+			return ccs_pattern_list[i].group_name;
+		return ccs_pattern_list[i].path.name;
 	}
 	return cp;
 }
 
-static const char *number_patternize(const char *cp)
+static const char *ccs_number_patternize(const char *cp)
 {
 	int i;
-	struct number_entry entry;
-	if (parse_number(cp, &entry))
+	struct ccs_number_entry entry;
+	if (ccs_parse_number(cp, &entry))
 		return cp;
-	for (i = 1; i < pattern_list_len; i++) {
-		const int type = pattern_list[i].type;
+	for (i = 1; i < ccs_pattern_list_len; i++) {
+		const int type = ccs_pattern_list[i].type;
 		if (type != 3)
 			continue;
-		if (pattern_list[i].number.min > entry.min ||
-		    pattern_list[i].number.max < entry.max)
+		if (ccs_pattern_list[i].number.min > entry.min ||
+		    ccs_pattern_list[i].number.max < entry.max)
 			continue;
-		return pattern_list[i].group_name;
+		return ccs_pattern_list[i].group_name;
 	}
 	return cp;
 }
 
-static const char *address_patternize(const char *cp)
+static const char *ccs_address_patternize(const char *cp)
 {
 	int i;
-	struct ip_address_entry entry;
-	if (parse_ip(cp, &entry))
+	struct ccs_ip_address_entry entry;
+	if (ccs_parse_ip(cp, &entry))
 		return cp;
-	for (i = 1; i < pattern_list_len; i++) {
-		const int type = pattern_list[i].type;
+	for (i = 1; i < ccs_pattern_list_len; i++) {
+		const int type = ccs_pattern_list[i].type;
 		if (type != 4)
 			continue;
-		if (pattern_list[i].ip.is_ipv6 != entry.is_ipv6 ||
-		    memcmp(entry.min, pattern_list[i].ip.min, 16) < 0 ||
-		    memcmp(pattern_list[i].ip.max, entry.max, 16) < 0)
+		if (ccs_pattern_list[i].ip.is_ipv6 != entry.is_ipv6 ||
+		    memcmp(entry.min, ccs_pattern_list[i].ip.min, 16) < 0 ||
+		    memcmp(ccs_pattern_list[i].ip.max, entry.max, 16) < 0)
 			continue;
-		return pattern_list[i].group_name;
+		return ccs_pattern_list[i].group_name;
 	}
 	return cp;
 }
 
-int patternize_main(int argc, char *argv[])
+int ccs_patternize_main(int argc, char *argv[])
 {
 	int i;
 	_Bool need_free = 0;
@@ -124,87 +124,87 @@
 		FILE *fp = fopen(argv[2], "r");
 		argv = NULL;
 		argc = 0;
-		get();
+		ccs_get();
 		while (fp) {
-			char *line = freadline(fp);
+			char *line = ccs_freadline(fp);
 			if (!line)
 				break;
-			normalize_line(line);
-			if (str_starts(line, "file_pattern ") ||
-			    str_starts(line, "path_group") ||
-			    str_starts(line, "number_group") ||
-			    is_correct_path(line, 0, 1, 0)) {
+			ccs_normalize_line(line);
+			if (ccs_str_starts(line, "file_pattern ") ||
+			    ccs_str_starts(line, "path_group") ||
+			    ccs_str_starts(line, "number_group") ||
+			    ccs_is_correct_path(line, 0, 1, 0)) {
 				char *cp = strdup(line);
 				argv = realloc(argv,
 					       (argc + 1) * sizeof(char *));
 				if (!argv || !cp)
-					out_of_memory();
+					ccs_out_of_memory();
 				argv[argc++] = cp;
 			}
 		}
-		put();
+		ccs_put();
 		if (fp)
 			fclose(fp);
 		need_free = 1;
 	}
-	pattern_list_len = argc;
-	pattern_list = calloc(argc, sizeof(struct path_pattern_entry));
-	if (!pattern_list)
-		out_of_memory();
+	ccs_pattern_list_len = argc;
+	ccs_pattern_list = calloc(argc, sizeof(struct ccs_path_pattern_entry));
+	if (!ccs_pattern_list)
+		ccs_out_of_memory();
 	for (i = 0; i < argc; i++) {
-		normalize_line(argv[i]);
-		if (str_starts(argv[i], "file_pattern ")) {
-			if (!is_correct_path(argv[i], 0, 1, 0))
+		ccs_normalize_line(argv[i]);
+		if (ccs_str_starts(argv[i], "file_pattern ")) {
+			if (!ccs_is_correct_path(argv[i], 0, 1, 0))
 				continue;
-			pattern_list[i].path.name = argv[i];
-			pattern_list[i].type = 1;
-		} else if (str_starts(argv[i], "path_group")) {
+			ccs_pattern_list[i].path.name = argv[i];
+			ccs_pattern_list[i].type = 1;
+		} else if (ccs_str_starts(argv[i], "ccs_path_group")) {
 			char *cp = strchr(argv[i] + 1, ' ');
 			if (!cp)
 				continue;
 			*cp = '\0';
 			if (argv[i][0] != ' ' ||
-			    !is_correct_path(argv[i] + 1, 0, 0, 0) ||
-			    !is_correct_path(cp + 1, 0, 0, 0))
+			    !ccs_is_correct_path(argv[i] + 1, 0, 0, 0) ||
+			    !ccs_is_correct_path(cp + 1, 0, 0, 0))
 				continue;
 			argv[i][0] = '@';
-			pattern_list[i].group_name = argv[i];
-			pattern_list[i].path.name = cp + 1;
-			pattern_list[i].type = 2;
-		} else if (str_starts(argv[i], "number_group")) {
+			ccs_pattern_list[i].group_name = argv[i];
+			ccs_pattern_list[i].path.name = cp + 1;
+			ccs_pattern_list[i].type = 2;
+		} else if (ccs_str_starts(argv[i], "number_group")) {
 			char *cp = strchr(argv[i] + 1, ' ');
 			if (!cp)
 				continue;
 			*cp = '\0';
 			if (argv[i][0] != ' ' ||
-			    !is_correct_path(argv[i] + 1, 0, 0, 0) ||
-			    parse_number(cp + 1, &pattern_list[i].number))
+			    !ccs_is_correct_path(argv[i] + 1, 0, 0, 0) ||
+			    ccs_parse_number(cp + 1, &ccs_pattern_list[i].number))
 				continue;
 			argv[i][0] = '@';
-			pattern_list[i].group_name = argv[i];
-			pattern_list[i].type = 3;
-		} else if (str_starts(argv[i], "address_group")) {
+			ccs_pattern_list[i].group_name = argv[i];
+			ccs_pattern_list[i].type = 3;
+		} else if (ccs_str_starts(argv[i], "address_group")) {
 			char *cp = strchr(argv[i] + 1, ' ');
 			if (!cp)
 				continue;
 			*cp = '\0';
 			if (argv[i][0] != ' ' ||
-			    !is_correct_path(argv[i] + 1, 0, 0, 0) ||
-			    parse_ip(cp + 1, &pattern_list[i].ip))
+			    !ccs_is_correct_path(argv[i] + 1, 0, 0, 0) ||
+			    ccs_parse_ip(cp + 1, &ccs_pattern_list[i].ip))
 				continue;
 			argv[i][0] = '@';
-			pattern_list[i].group_name = argv[i];
-			pattern_list[i].type = 4;
-		} else if (is_correct_path(argv[i], 0, 1, 0)) {
-			pattern_list[i].path.name = argv[i];
-			pattern_list[i].type = 1;
+			ccs_pattern_list[i].group_name = argv[i];
+			ccs_pattern_list[i].type = 4;
+		} else if (ccs_is_correct_path(argv[i], 0, 1, 0)) {
+			ccs_pattern_list[i].path.name = argv[i];
+			ccs_pattern_list[i].type = 1;
 		}
-		if (pattern_list[i].path.name)
-			fill_path_info(&pattern_list[i].path);
+		if (ccs_pattern_list[i].path.name)
+			ccs_fill_path_info(&ccs_pattern_list[i].path);
 	}
-	get();
+	ccs_get();
 	while (true) {
-		char *sp = freadline(stdin);
+		char *sp = ccs_freadline(stdin);
 		const char *cp;
 		_Bool first = true;
 		u8 path_count = 0;
@@ -259,14 +259,14 @@
 				skip_count--;
 			} else if (path_count) {
 				if (path_count-- && *cp != '@' &&
-				    !path_contains_pattern(cp))
-					cp = path_patternize(cp);
+				    !ccs_path_contains_pattern(cp))
+					cp = ccs_path_patternize(cp);
 			} else if (address_count) {
 				if (address_count-- && *cp != '@')
-					cp = address_patternize(cp);
+					cp = ccs_address_patternize(cp);
 			} else if (number_count) {
 				if (number_count-- && *cp != '@')
-					cp = number_patternize(cp);
+					cp = ccs_number_patternize(cp);
 			}
 			if (!first)
 				putchar(' ');
@@ -275,8 +275,8 @@
 		}
 		putchar('\n');
 	}
-	put();
-	free(pattern_list);
+	ccs_put();
+	free(ccs_pattern_list);
 	if (need_free) {
 		while (argc)
 			free(argv[--argc]);
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/ccstools.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/ccstools.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/ccstools.c	(working copy)
@@ -12,30 +12,30 @@
 
 /* Prototypes */
 
-static _Bool is_byte_range(const char *str);
-static _Bool is_decimal(const char c);
-static _Bool is_hexadecimal(const char c);
-static _Bool is_alphabet_char(const char c);
-static u8 make_byte(const u8 c1, const u8 c2, const u8 c3);
-static inline unsigned long partial_name_hash(unsigned long c,
-					      unsigned long prevhash);
-static inline unsigned int full_name_hash(const unsigned char *name,
-					  unsigned int len);
-static void *alloc_element(const unsigned int size);
-static int const_part_length(const char *filename);
-static int domainname_compare(const void *a, const void *b);
-static int path_info_compare(const void *a, const void *b);
-static void sort_domain_policy(struct domain_policy *dp);
+static _Bool ccs_is_byte_range(const char *str);
+static _Bool ccs_is_decimal(const char c);
+static _Bool ccs_is_hexadecimal(const char c);
+static _Bool ccs_is_alphabet_char(const char c);
+static u8 ccs_make_byte(const u8 c1, const u8 c2, const u8 c3);
+static inline unsigned long ccs_partial_name_hash(unsigned long c,
+						  unsigned long prevhash);
+static inline unsigned int ccs_full_name_hash(const unsigned char *name,
+					      unsigned int len);
+static void *ccs_alloc_element(const unsigned int size);
+static int ccs_const_part_length(const char *filename);
+static int ccs_domainname_compare(const void *a, const void *b);
+static int ccs_path_info_compare(const void *a, const void *b);
+static void ccs_sort_domain_policy(struct ccs_domain_policy *dp);
 
 /* Utility functions */
 
-void out_of_memory(void)
+void ccs_out_of_memory(void)
 {
 	fprintf(stderr, "Out of memory. Aborted.\n");
 	exit(1);
 }
 
-_Bool str_starts(char *str, const char *begin)
+_Bool ccs_str_starts(char *str, const char *begin)
 {
 	const int len = strlen(begin);
 	if (strncmp(str, begin, len))
@@ -44,36 +44,36 @@
 	return true;
 }
 
-static _Bool is_byte_range(const char *str)
+static _Bool ccs_is_byte_range(const char *str)
 {
 	return *str >= '0' && *str++ <= '3' &&
 		*str >= '0' && *str++ <= '7' &&
 		*str >= '0' && *str <= '7';
 }
 
-static _Bool is_decimal(const char c)
+static _Bool ccs_is_decimal(const char c)
 {
 	return c >= '0' && c <= '9';
 }
 
-static _Bool is_hexadecimal(const char c)
+static _Bool ccs_is_hexadecimal(const char c)
 {
 	return (c >= '0' && c <= '9') ||
 		(c >= 'A' && c <= 'F') ||
 		(c >= 'a' && c <= 'f');
 }
 
-static _Bool is_alphabet_char(const char c)
+static _Bool ccs_is_alphabet_char(const char c)
 {
 	return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
 }
 
-static u8 make_byte(const u8 c1, const u8 c2, const u8 c3)
+static u8 ccs_make_byte(const u8 c1, const u8 c2, const u8 c3)
 {
 	return ((c1 - '0') << 6) + ((c2 - '0') << 3) + (c3 - '0');
 }
 
-void normalize_line(unsigned char *line)
+void ccs_normalize_line(unsigned char *line)
 {
 	unsigned char *sp = line;
 	unsigned char *dp = line;
@@ -92,7 +92,7 @@
 	*dp = '\0';
 }
 
-char *make_filename(const char *prefix, const time_t time)
+char *ccs_make_filename(const char *prefix, const time_t time)
 {
 	struct tm *tm = localtime(&time);
 	static char filename[1024];
@@ -105,35 +105,35 @@
 }
 
 /* Copied from kernel source. */
-static inline unsigned long partial_name_hash(unsigned long c,
-					      unsigned long prevhash)
+static inline unsigned long ccs_partial_name_hash(unsigned long c,
+						  unsigned long prevhash)
 {
 	return (prevhash + (c << 4) + (c >> 4)) * 11;
 }
 
 /* Copied from kernel source. */
-static inline unsigned int full_name_hash(const unsigned char *name,
-					  unsigned int len)
+static inline unsigned int ccs_full_name_hash(const unsigned char *name,
+					      unsigned int len)
 {
 	unsigned long hash = 0;
 	while (len--)
-		hash = partial_name_hash(*name++, hash);
+		hash = ccs_partial_name_hash(*name++, hash);
 	return (unsigned int) hash;
 }
 
-static void *alloc_element(const unsigned int size)
+static void *ccs_alloc_element(const unsigned int size)
 {
 	static char *buf = NULL;
-	static unsigned int buf_used_len = PAGE_SIZE;
+	static unsigned int buf_used_len = CCS_PAGE_SIZE;
 	char *ptr = NULL;
-	if (size > PAGE_SIZE)
+	if (size > CCS_PAGE_SIZE)
 		return NULL;
-	if (buf_used_len + size > PAGE_SIZE) {
-		ptr = malloc(PAGE_SIZE);
+	if (buf_used_len + size > CCS_PAGE_SIZE) {
+		ptr = malloc(CCS_PAGE_SIZE);
 		if (!ptr)
-			out_of_memory();
+			ccs_out_of_memory();
 		buf = ptr;
-		memset(buf, 0, PAGE_SIZE);
+		memset(buf, 0, CCS_PAGE_SIZE);
 		buf_used_len = size;
 		ptr = buf;
 	} else if (size) {
@@ -142,12 +142,12 @@
 		buf_used_len += size;
 		for (i = 0; i < size; i++)
 			if (ptr[i])
-				out_of_memory();
+				ccs_out_of_memory();
 	}
 	return ptr;
 }
 
-static int const_part_length(const char *filename)
+static int ccs_const_part_length(const char *filename)
 {
 	int len = 0;
 	if (filename) {
@@ -183,18 +183,18 @@
 	return len;
 }
 
-_Bool is_domain_def(const unsigned char *domainname)
+_Bool ccs_is_domain_def(const unsigned char *domainname)
 {
-	return !strncmp(domainname, ROOT_NAME, ROOT_NAME_LEN) &&
-		(domainname[ROOT_NAME_LEN] == '\0'
-		 || domainname[ROOT_NAME_LEN] == ' ');
+	return !strncmp(domainname, CCS_ROOT_NAME, CCS_ROOT_NAME_LEN) &&
+		(domainname[CCS_ROOT_NAME_LEN] == '\0'
+		 || domainname[CCS_ROOT_NAME_LEN] == ' ');
 }
 
-_Bool is_correct_domain(const unsigned char *domainname)
+_Bool ccs_is_correct_domain(const unsigned char *domainname)
 {
-	if (!domainname || strncmp(domainname, ROOT_NAME, ROOT_NAME_LEN))
+	if (!domainname || strncmp(domainname, CCS_ROOT_NAME, CCS_ROOT_NAME_LEN))
 		goto out;
-	domainname += ROOT_NAME_LEN;
+	domainname += CCS_ROOT_NAME_LEN;
 	if (!*domainname)
 		return true;
 	do {
@@ -243,7 +243,7 @@
 	return false;
 }
 
-void fprintf_encoded(FILE *fp, const char *pathname)
+void ccs_fprintf_encoded(FILE *fp, const char *pathname)
 {
 	while (true) {
 		unsigned char c = *(const unsigned char *) pathname++;
@@ -261,7 +261,7 @@
 	}
 }
 
-_Bool decode(const char *ascii, char *bin)
+_Bool ccs_decode(const char *ascii, char *bin)
 {
 	while (true) {
 		char c = *ascii++;
@@ -302,8 +302,8 @@
 	return true;
 }
 
-_Bool is_correct_path(const char *filename, const s8 start_type,
-		     const s8 pattern_type, const s8 end_type)
+_Bool ccs_is_correct_path(const char *filename, const s8 start_type,
+			  const s8 pattern_type, const s8 end_type)
 {
 	const char *const start = filename;
 	_Bool in_repetition = false;
@@ -379,7 +379,7 @@
 				e = *filename++;
 				if (e < '0' || e > '7')
 					break;
-				c = make_byte(c, d, e);
+				c = ccs_make_byte(c, d, e);
 				if (c && (c <= ' ' || c >= 127))
 					continue; /* pattern is not \000 */
 			}
@@ -401,9 +401,9 @@
 	return false;
 }
 
-static _Bool file_matches_pattern2(const char *filename,
-				  const char *filename_end,
-				  const char *pattern, const char *pattern_end)
+static _Bool ccs_file_matches_pattern2(const char *filename,
+				       const char *filename_end,
+				       const char *pattern, const char *pattern_end)
 {
 	while (filename < filename_end && pattern < pattern_end) {
 		char c;
@@ -423,7 +423,7 @@
 			} else if (c == '\\') {
 				if (filename[1] == '\\')
 					filename++;
-				else if (is_byte_range(filename + 1))
+				else if (ccs_is_byte_range(filename + 1))
 					filename += 3;
 				else
 					return false;
@@ -436,22 +436,22 @@
 				return false;
 			break;
 		case '+':
-			if (!is_decimal(c))
+			if (!ccs_is_decimal(c))
 				return false;
 			break;
 		case 'x':
-			if (!is_hexadecimal(c))
+			if (!ccs_is_hexadecimal(c))
 				return false;
 			break;
 		case 'a':
-			if (!is_alphabet_char(c))
+			if (!ccs_is_alphabet_char(c))
 				return false;
 			break;
 		case '0':
 		case '1':
 		case '2':
 		case '3':
-			if (c == '\\' && is_byte_range(filename + 1)
+			if (c == '\\' && ccs_is_byte_range(filename + 1)
 			    && !strncmp(filename + 1, pattern, 3)) {
 				filename += 3;
 				pattern += 2;
@@ -461,10 +461,10 @@
 		case '*':
 		case '@':
 			for (i = 0; i <= filename_end - filename; i++) {
-				if (file_matches_pattern2(filename + i,
-							  filename_end,
-							  pattern + 1,
-							  pattern_end))
+				if (ccs_file_matches_pattern2(filename + i,
+							      filename_end,
+							      pattern + 1,
+							      pattern_end))
 					return true;
 				c = filename[i];
 				if (c == '.' && *pattern == '@')
@@ -473,7 +473,7 @@
 					continue;
 				if (filename[i + 1] == '\\')
 					i++;
-				else if (is_byte_range(filename + i + 1))
+				else if (ccs_is_byte_range(filename + i + 1))
 					i += 3;
 				else
 					break; /* Bad pattern. */
@@ -483,20 +483,20 @@
 			j = 0;
 			c = *pattern;
 			if (c == '$') {
-				while (is_decimal(filename[j]))
+				while (ccs_is_decimal(filename[j]))
 					j++;
 			} else if (c == 'X') {
-				while (is_hexadecimal(filename[j]))
+				while (ccs_is_hexadecimal(filename[j]))
 					j++;
 			} else if (c == 'A') {
-				while (is_alphabet_char(filename[j]))
+				while (ccs_is_alphabet_char(filename[j]))
 					j++;
 			}
 			for (i = 1; i <= j; i++) {
-				if (file_matches_pattern2(filename + i,
-							  filename_end,
-							  pattern + 1,
-							  pattern_end))
+				if (ccs_file_matches_pattern2(filename + i,
+							      filename_end,
+							      pattern + 1,
+							      pattern_end))
 					return true;
 			}
 			return false; /* Not matched or bad pattern. */
@@ -510,9 +510,9 @@
 	return filename == filename_end && pattern == pattern_end;
 }
 
-static _Bool file_matches_pattern(const char *filename,
-				  const char *filename_end,
-				  const char *pattern, const char *pattern_end)
+static _Bool ccs_file_matches_pattern(const char *filename,
+				      const char *filename_end,
+				      const char *pattern, const char *pattern_end)
 {
 	const char *pattern_start = pattern;
 	_Bool first = true;
@@ -521,8 +521,8 @@
 		/* Split at "\-" pattern. */
 		if (*pattern++ != '\\' || *pattern++ != '-')
 			continue;
-		result = file_matches_pattern2(filename, filename_end,
-					       pattern_start, pattern - 2);
+		result = ccs_file_matches_pattern2(filename, filename_end,
+						   pattern_start, pattern - 2);
 		if (first)
 			result = !result;
 		if (result)
@@ -530,12 +530,12 @@
 		first = false;
 		pattern_start = pattern;
 	}
-	result = file_matches_pattern2(filename, filename_end,
-				       pattern_start, pattern_end);
+	result = ccs_file_matches_pattern2(filename, filename_end,
+					   pattern_start, pattern_end);
 	return first ? result : !result;
 }
 
-static _Bool path_matches_pattern2(const char *f, const char *p)
+static _Bool ccs_path_matches_pattern2(const char *f, const char *p)
 {
 	const char *f_delimiter;
 	const char *p_delimiter;
@@ -548,7 +548,7 @@
 			p_delimiter = p + strlen(p);
 		if (*p == '\\' && *(p + 1) == '{')
 			goto recursive;
-		if (!file_matches_pattern(f, f_delimiter, p, p_delimiter))
+		if (!ccs_file_matches_pattern(f, f_delimiter, p, p_delimiter))
 			return false;
 		f = f_delimiter;
 		if (*f)
@@ -574,8 +574,8 @@
 		return false; /* Bad pattern. */
 	do {
 		/* Compare current component with pattern. */
-		if (!file_matches_pattern(f, f_delimiter, p + 2,
-					  p_delimiter - 2))
+		if (!ccs_file_matches_pattern(f, f_delimiter, p + 2,
+					      p_delimiter - 2))
 			break;
 		/* Proceed to next component. */
 		f = f_delimiter;
@@ -583,15 +583,15 @@
 			break;
 		f++;
 		/* Continue comparison. */
-		if (path_matches_pattern2(f, p_delimiter + 1))
+		if (ccs_path_matches_pattern2(f, p_delimiter + 1))
 			return true;
 		f_delimiter = strchr(f, '/');
 	} while (f_delimiter);
 	return false; /* Not matched. */
 }
 
-_Bool path_matches_pattern(const struct path_info *filename,
-			   const struct path_info *pattern)
+_Bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
+			       const struct ccs_path_info *pattern)
 {
 	/*
 	if (!filename || !pattern)
@@ -602,7 +602,7 @@
 	const int len = pattern->const_len;
 	/* If @pattern doesn't contain pattern, I can use strcmp(). */
 	if (!pattern->is_patterned)
-		return !pathcmp(filename, pattern);
+		return !ccs_pathcmp(filename, pattern);
 	/* Don't compare directory and non-directory. */
 	if (filename->is_dir != pattern->is_dir)
 		return false;
@@ -611,62 +611,62 @@
 		return false;
 	f += len;
 	p += len;
-	return path_matches_pattern2(f, p);
+	return ccs_path_matches_pattern2(f, p);
 }
 
-int string_compare(const void *a, const void *b)
+int ccs_string_compare(const void *a, const void *b)
 {
 	return strcmp(*(char **) a, *(char **) b);
 }
 
-_Bool pathcmp(const struct path_info *a, const struct path_info *b)
+_Bool ccs_pathcmp(const struct ccs_path_info *a, const struct ccs_path_info *b)
 {
 	return a->hash != b->hash || strcmp(a->name, b->name);
 }
 
-void fill_path_info(struct path_info *ptr)
+void ccs_fill_path_info(struct ccs_path_info *ptr)
 {
 	const char *name = ptr->name;
 	const int len = strlen(name);
 	ptr->total_len = len;
-	ptr->const_len = const_part_length(name);
+	ptr->const_len = ccs_const_part_length(name);
 	ptr->is_dir = len && (name[len - 1] == '/');
 	ptr->is_patterned = (ptr->const_len < len);
-	ptr->hash = full_name_hash(name, len);
+	ptr->hash = ccs_full_name_hash(name, len);
 }
 
-static unsigned int memsize(const unsigned int size)
+static unsigned int ccs_memsize(const unsigned int size)
 {
 	if (size <= 1048576)
-		return ((size / PAGE_SIZE) + 1) * PAGE_SIZE;
+		return ((size / CCS_PAGE_SIZE) + 1) * CCS_PAGE_SIZE;
 	return 0;
 }
 
-const struct path_info *savename(const char *name)
+const struct ccs_path_info *ccs_savename(const char *name)
 {
-	static struct free_memory_block_list fmb_list = { NULL, NULL, 0 };
+	static struct ccs_free_memory_block_list fmb_list = { NULL, NULL, 0 };
 	/* The list of names. */
-	static struct savename_entry name_list[SAVENAME_MAX_HASH];
-	struct savename_entry *ptr;
-	struct savename_entry *prev = NULL;
+	static struct ccs_savename_entry name_list[CCS_SAVENAME_MAX_HASH];
+	struct ccs_savename_entry *ptr;
+	struct ccs_savename_entry *prev = NULL;
 	unsigned int hash;
-	struct free_memory_block_list *fmb = &fmb_list;
+	struct ccs_free_memory_block_list *fmb = &fmb_list;
 	int len;
 	static _Bool first_call = true;
 	if (!name)
 		return NULL;
 	len = strlen(name) + 1;
-	hash = full_name_hash((const unsigned char *) name, len - 1);
+	hash = ccs_full_name_hash((const unsigned char *) name, len - 1);
 	if (first_call) {
 		int i;
 		first_call = false;
 		memset(&name_list, 0, sizeof(name_list));
-		for (i = 0; i < SAVENAME_MAX_HASH; i++) {
+		for (i = 0; i < CCS_SAVENAME_MAX_HASH; i++) {
 			name_list[i].entry.name = "/";
-			fill_path_info(&name_list[i].entry);
+			ccs_fill_path_info(&name_list[i].entry);
 		}
 	}
-	ptr = &name_list[hash % SAVENAME_MAX_HASH];
+	ptr = &name_list[hash % CCS_SAVENAME_MAX_HASH];
 	while (ptr) {
 		if (hash == ptr->entry.hash && !strcmp(name, ptr->entry.name))
 			goto out;
@@ -679,29 +679,29 @@
 			fmb = fmb->next;
 			continue;
 		}
-		cp = malloc(memsize(len));
+		cp = malloc(ccs_memsize(len));
 		if (!cp)
-			out_of_memory();
-		fmb->next = alloc_element(sizeof(*fmb->next));
+			ccs_out_of_memory();
+		fmb->next = ccs_alloc_element(sizeof(*fmb->next));
 		if (!fmb->next)
-			out_of_memory();
-		memset(cp, 0, memsize(len));
+			ccs_out_of_memory();
+		memset(cp, 0, ccs_memsize(len));
 		fmb = fmb->next;
 		fmb->ptr = cp;
-		fmb->len = memsize(len);
+		fmb->len = ccs_memsize(len);
 	}
-	ptr = alloc_element(sizeof(*ptr));
+	ptr = ccs_alloc_element(sizeof(*ptr));
 	if (!ptr)
-		out_of_memory();
-	memset(ptr, 0, sizeof(struct savename_entry));
+		ccs_out_of_memory();
+	memset(ptr, 0, sizeof(struct ccs_savename_entry));
 	ptr->entry.name = fmb->ptr;
 	memmove(fmb->ptr, name, len);
-	fill_path_info(&ptr->entry);
+	ccs_fill_path_info(&ptr->entry);
 	fmb->ptr += len;
 	fmb->len -= len;
 	prev->next = ptr; /* prev != NULL because name_list is not empty. */
 	if (!fmb->len) {
-		struct free_memory_block_list *ptr = &fmb_list;
+		struct ccs_free_memory_block_list *ptr = &fmb_list;
 		while (ptr->next != fmb)
 			ptr = ptr->next;
 		ptr->next = fmb->next;
@@ -710,11 +710,11 @@
 	return ptr ? &ptr->entry : NULL;
 }
 
-_Bool move_proc_to_file(const char *src, const char *dest)
+_Bool ccs_move_proc_to_file(const char *src, const char *dest)
 {
 	FILE *proc_fp;
 	FILE *file_fp = stdout;
-	proc_fp = open_read(src);
+	proc_fp = ccs_open_read(src);
 	if (!proc_fp) {
 		fprintf(stderr, "Can't open %s\n", src);
 		return false;
@@ -729,7 +729,7 @@
 	}
 	while (true) {
 		int c = fgetc(proc_fp);
-		if (network_mode && !c)
+		if (ccs_network_mode && !c)
 			break;
 		if (c == EOF)
 			break;
@@ -741,7 +741,7 @@
 	return true;
 }
 
-_Bool is_identical_file(const char *file1, const char *file2)
+_Bool ccs_is_identical_file(const char *file1, const char *file2)
 {
 	char buffer1[4096];
 	char buffer2[4096];
@@ -771,7 +771,7 @@
 	return false;
 }
 
-void clear_domain_policy(struct domain_policy *dp)
+void ccs_clear_domain_policy(struct ccs_domain_policy *dp)
 {
 	int index;
 	for (index = 0; index < dp->list_len; index++) {
@@ -784,8 +784,8 @@
 	dp->list_len = 0;
 }
 
-int find_domain_by_ptr(struct domain_policy *dp,
-		       const struct path_info *domainname)
+int ccs_find_domain_by_ptr(struct ccs_domain_policy *dp,
+			   const struct ccs_path_info *domainname)
 {
 	int i;
 	for (i = 0; i < dp->list_len; i++) {
@@ -795,53 +795,53 @@
 	return EOF;
 }
 
-const char *domain_name(const struct domain_policy *dp, const int index)
+const char *ccs_domain_name(const struct ccs_domain_policy *dp, const int index)
 {
 	return dp->list[index].domainname->name;
 }
 
-static int domainname_compare(const void *a, const void *b)
+static int ccs_domainname_compare(const void *a, const void *b)
 {
-	return strcmp(((struct domain_info *) a)->domainname->name,
-		      ((struct domain_info *) b)->domainname->name);
+	return strcmp(((struct ccs_domain_info *) a)->domainname->name,
+		      ((struct ccs_domain_info *) b)->domainname->name);
 }
 
-static int path_info_compare(const void *a, const void *b)
+static int ccs_path_info_compare(const void *a, const void *b)
 {
-	const char *a0 = (*(struct path_info **) a)->name;
-	const char *b0 = (*(struct path_info **) b)->name;
+	const char *a0 = (*(struct ccs_path_info **) a)->name;
+	const char *b0 = (*(struct ccs_path_info **) b)->name;
 	return strcmp(a0, b0);
 }
 
-static void sort_domain_policy(struct domain_policy *dp)
+static void ccs_sort_domain_policy(struct ccs_domain_policy *dp)
 {
 	int i;
-	qsort(dp->list, dp->list_len, sizeof(struct domain_info),
-	      domainname_compare);
+	qsort(dp->list, dp->list_len, sizeof(struct ccs_domain_info),
+	      ccs_domainname_compare);
 	for (i = 0; i < dp->list_len; i++)
 		qsort(dp->list[i].string_ptr, dp->list[i].string_count,
-		      sizeof(struct path_info *), path_info_compare);
+		      sizeof(struct ccs_path_info *), ccs_path_info_compare);
 }
 
-void read_domain_policy(struct domain_policy *dp, const char *filename)
+void ccs_read_domain_policy(struct ccs_domain_policy *dp, const char *filename)
 {
 	FILE *fp = stdin;
 	if (filename) {
-		fp = open_read(filename);
+		fp = ccs_open_read(filename);
 		if (!fp) {
 			fprintf(stderr, "Can't open %s\n", filename);
 			return;
 		}
 	}
-	get();
-	handle_domain_policy(dp, fp, true);
-	put();
+	ccs_get();
+	ccs_handle_domain_policy(dp, fp, true);
+	ccs_put();
 	if (fp != stdin)
 		fclose(fp);
-	sort_domain_policy(dp);
+	ccs_sort_domain_policy(dp);
 }
 
-void delete_domain(struct domain_policy *dp, const int index)
+void ccs_delete_domain(struct ccs_domain_policy *dp, const int index)
 {
 	if (index >= 0 && index < dp->list_len) {
 		int i;
@@ -852,60 +852,60 @@
 	}
 }
 
-void handle_domain_policy(struct domain_policy *dp, FILE *fp, _Bool is_write)
+void ccs_handle_domain_policy(struct ccs_domain_policy *dp, FILE *fp, _Bool is_write)
 {
 	int i;
 	int index = EOF;
 	if (!is_write)
 		goto read_policy;
 	while (true) {
-		char *line = freadline(fp);
+		char *line = ccs_freadline(fp);
 		_Bool is_delete = false;
 		_Bool is_select = false;
 		unsigned int profile;
 		if (!line)
 			break;
-		if (str_starts(line, "delete "))
+		if (ccs_str_starts(line, "delete "))
 			is_delete = true;
-		else if (str_starts(line, "select "))
+		else if (ccs_str_starts(line, "select "))
 			is_select = true;
-		str_starts(line, "domain=");
-		if (is_domain_def(line)) {
+		ccs_str_starts(line, "domain=");
+		if (ccs_is_domain_def(line)) {
 			if (is_delete) {
-				index = find_domain(dp, line, false, false);
+				index = ccs_find_domain(dp, line, false, false);
 				if (index >= 0)
-					delete_domain(dp, index);
+					ccs_delete_domain(dp, index);
 				index = EOF;
 				continue;
 			}
 			if (is_select) {
-				index = find_domain(dp, line, false, false);
+				index = ccs_find_domain(dp, line, false, false);
 				continue;
 			}
-			index = find_or_assign_new_domain(dp, line, false,
-							  false);
+			index = ccs_find_or_assign_new_domain(dp, line, false,
+							      false);
 			continue;
 		}
 		if (index == EOF || !line[0])
 			continue;
-		if (sscanf(line, KEYWORD_USE_PROFILE "%u", &profile) == 1) {
+		if (sscanf(line, CCS_KEYWORD_USE_PROFILE "%u", &profile) == 1) {
 			dp->list[index].profile = (u8) profile;
 			dp->list[index].profile_assigned = 1;
 		} else if (is_delete)
-			del_string_entry(dp, line, index);
+			ccs_del_string_entry(dp, line, index);
 		else
-			add_string_entry(dp, line, index);
+			ccs_add_string_entry(dp, line, index);
 	}
 	return;
 read_policy:
 	for (i = 0; i < dp->list_len; i++) {
 		int j;
-		const struct path_info **string_ptr
+		const struct ccs_path_info **string_ptr
 			= dp->list[i].string_ptr;
 		const int string_count = dp->list[i].string_count;
-		fprintf(fp, "%s\n", domain_name(dp, i));
+		fprintf(fp, "%s\n", ccs_domain_name(dp, i));
 		if (dp->list[i].profile_assigned)
-			fprintf(fp, KEYWORD_USE_PROFILE "%u\n",
+			fprintf(fp, CCS_KEYWORD_USE_PROFILE "%u\n",
 				dp->list[i].profile);
 		fprintf(fp, "\n");
 		for (j = 0; j < string_count; j++)
@@ -916,28 +916,28 @@
 
 /* Variables */
 
-static _Bool buffer_locked = false;
+static _Bool ccs_buffer_locked = false;
 
 /* Main functions */
 
-void get(void)
+void ccs_get(void)
 {
-	if (buffer_locked)
-		out_of_memory();
-	buffer_locked = true;
+	if (ccs_buffer_locked)
+		ccs_out_of_memory();
+	ccs_buffer_locked = true;
 }
 
-void put(void)
+void ccs_put(void)
 {
-	if (!buffer_locked)
-		out_of_memory();
-	buffer_locked = false;
+	if (!ccs_buffer_locked)
+		ccs_out_of_memory();
+	ccs_buffer_locked = false;
 }
 
-char *shprintf(const char *fmt, ...)
+char *ccs_shprintf(const char *fmt, ...)
 {
-	if (!buffer_locked)
-		out_of_memory();
+	if (!ccs_buffer_locked)
+		ccs_out_of_memory();
 	while (true) {
 		static char *policy = NULL;
 		static int max_policy_len = 0;
@@ -947,38 +947,38 @@
 		len = vsnprintf(policy, max_policy_len, fmt, args);
 		va_end(args);
 		if (len < 0)
-			out_of_memory();
+			ccs_out_of_memory();
 		if (len >= max_policy_len) {
 			char *cp;
 			max_policy_len = len + 1;
 			cp = realloc(policy, max_policy_len);
 			if (!cp)
-				out_of_memory();
+				ccs_out_of_memory();
 			policy = cp;
 		} else
 			return policy;
 	}
 }
 
-char *freadline(FILE *fp)
+char *ccs_freadline(FILE *fp)
 {
 	static char *policy = NULL;
 	int pos = 0;
-	if (!buffer_locked)
-		out_of_memory();
+	if (!ccs_buffer_locked)
+		ccs_out_of_memory();
 	while (true) {
 		static int max_policy_len = 0;
 		const int c = fgetc(fp);
 		if (c == EOF)
 			return NULL;
-		if (network_mode && !c)
+		if (ccs_network_mode && !c)
 			return NULL;
 		if (pos == max_policy_len) {
 			char *cp;
 			max_policy_len += 4096;
 			cp = realloc(policy, max_policy_len);
 			if (!cp)
-				out_of_memory();
+				ccs_out_of_memory();
 			policy = cp;
 		}
 		policy[pos++] = (char) c;
@@ -987,23 +987,23 @@
 			break;
 		}
 	}
-	normalize_line(policy);
+	ccs_normalize_line(policy);
 	return policy;
 }
 
-_Bool check_remote_host(void)
+_Bool ccs_check_remote_host(void)
 {
-	int ccs_major = 0;
-	int ccs_minor = 0;
-	int ccs_rev = 0;
-	FILE *fp = open_read("version");
+	int major = 0;
+	int minor = 0;
+	int rev = 0;
+	FILE *fp = ccs_open_read("version");
 	if (!fp ||
-	    fscanf(fp, "%u.%u.%u", &ccs_major, &ccs_minor, &ccs_rev) < 2 ||
-	    ccs_major != 1 || ccs_minor != 7) {
-		const u32 ip = ntohl(network_ip);
+	    fscanf(fp, "%u.%u.%u", &major, &minor, &rev) < 2 ||
+	    major != 1 || minor != 7) {
+		const u32 ip = ntohl(ccs_network_ip);
 		fprintf(stderr, "Can't connect to %u.%u.%u.%u:%u\n",
 			(u8) (ip >> 24), (u8) (ip >> 16),
-			(u8) (ip >> 8), (u8) ip, ntohs(network_port));
+			(u8) (ip >> 8), (u8) ip, ntohs(ccs_network_port));
 		if (fp)
 			fclose(fp);
 		return false;
@@ -1023,37 +1023,37 @@
 	if (strrchr(argv0, '/'))
 		argv0 = strrchr(argv0, '/') + 1;
 	if (!strcmp(argv0, "ccs-sortpolicy"))
-		ret = sortpolicy_main(argc, argv);
+		ret = ccs_sortpolicy_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-setprofile"))
-		ret = setprofile_main(argc, argv);
+		ret = ccs_setprofile_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-setlevel"))
-		ret = setlevel_main(argc, argv);
+		ret = ccs_setlevel_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-selectpolicy"))
-		ret = selectpolicy_main(argc, argv);
+		ret = ccs_selectpolicy_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-diffpolicy"))
-		ret = diffpolicy_main(argc, argv);
+		ret = ccs_diffpolicy_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-savepolicy"))
-		ret = savepolicy_main(argc, argv);
+		ret = ccs_savepolicy_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-pathmatch"))
-		ret = pathmatch_main(argc, argv);
+		ret = ccs_pathmatch_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-loadpolicy"))
-		ret = loadpolicy_main(argc, argv);
+		ret = ccs_loadpolicy_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-ld-watch"))
-		ret = ldwatch_main(argc, argv);
+		ret = ccs_ldwatch_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-findtemp"))
-		ret = findtemp_main(argc, argv);
+		ret = ccs_findtemp_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-editpolicy"))
-		ret = editpolicy_main(argc, argv);
+		ret = ccs_editpolicy_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-checkpolicy"))
-		ret = checkpolicy_main(argc, argv);
+		ret = ccs_checkpolicy_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-pstree"))
-		ret = pstree_main(argc, argv);
+		ret = ccs_pstree_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-queryd"))
-		ret = queryd_main(argc, argv);
+		ret = ccs_queryd_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-auditd"))
-		ret = auditd_main(argc, argv);
+		ret = ccs_auditd_main(argc, argv);
 	else if (!strcmp(argv0, "ccs-patternize"))
-		ret = patternize_main(argc, argv);
+		ret = ccs_patternize_main(argc, argv);
 	else
 		goto show_version;
 	return ret;
Index: trunk/1.7.x/ccs-tools/ccstools/ccstools.src/checkpolicy.c
===================================================================
--- trunk/1.7.x/ccs-tools/ccstools/ccstools.src/checkpolicy.c	(revision 3568)
+++ trunk/1.7.x/ccs-tools/ccstools/ccstools.src/checkpolicy.c	(working copy)
@@ -10,7 +10,7 @@
  */
 #include "ccstools.h"
 
-static int parse_ulong(unsigned long *result, char **str)
+static int ccs_parse_ulong(unsigned long *result, char **str)
 {
 	const char *cp = *str;
 	char *ep;
@@ -29,11 +29,11 @@
 	if (cp == ep)
 		return 0;
 	*str = ep;
-	return base == 16 ? VALUE_TYPE_HEXADECIMAL :
-		(base == 8 ? VALUE_TYPE_OCTAL : VALUE_TYPE_DECIMAL);
+	return base == 16 ? CCS_VALUE_TYPE_HEXADECIMAL :
+		(base == 8 ? CCS_VALUE_TYPE_OCTAL : CCS_VALUE_TYPE_DECIMAL);
 }
 
-static char *find_condition_part(char *data)
+static char *ccs_find_condition_part(char *data)
 {
 	char *cp = strstr(data, " if ");
 	if (!cp)
@@ -43,11 +43,11 @@
 	return cp;
 }
 
-static unsigned int line = 0;
-static unsigned int errors = 0;
-static unsigned int warnings = 0;
+static unsigned int ccs_line = 0;
+static unsigned int ccs_errors = 0;
+static unsigned int ccs_warnings = 0;
 
-static _Bool check_condition(char *condition)
+static _Bool ccs_check_condition(char *condition)
 {
 	enum ccs_conditions_index {
 		CCS_TASK_UID,             /* current_uid()   */
@@ -160,32 +160,32 @@
 		[CCS_TASK_EXECUTE_HANDLER] = "execute_handler",
 		[CCS_EXEC_REALPATH]        = "exec.realpath",
 		[CCS_SYMLINK_TARGET]       = "symlink.target",
-		[CCS_PATH1_UID]            = "path1.uid",
-		[CCS_PATH1_GID]            = "path1.gid",
-		[CCS_PATH1_INO]            = "path1.ino",
-		[CCS_PATH1_MAJOR]          = "path1.major",
-		[CCS_PATH1_MINOR]          = "path1.minor",
-		[CCS_PATH1_PERM]           = "path1.perm",
-		[CCS_PATH1_TYPE]           = "path1.type",
-		[CCS_PATH1_DEV_MAJOR]      = "path1.dev_major",
-		[CCS_PATH1_DEV_MINOR]      = "path1.dev_minor",
-		[CCS_PATH2_UID]            = "path2.uid",
-		[CCS_PATH2_GID]            = "path2.gid",
-		[CCS_PATH2_INO]            = "path2.ino",
-		[CCS_PATH2_MAJOR]          = "path2.major",
-		[CCS_PATH2_MINOR]          = "path2.minor",
-		[CCS_PATH2_PERM]           = "path2.perm",
-		[CCS_PATH2_TYPE]           = "path2.type",
-		[CCS_PATH2_DEV_MAJOR]      = "path2.dev_major",
-		[CCS_PATH2_DEV_MINOR]      = "path2.dev_minor",
-		[CCS_PATH1_PARENT_UID]     = "path1.parent.uid",
-		[CCS_PATH1_PARENT_GID]     = "path1.parent.gid",
-		[CCS_PATH1_PARENT_INO]     = "path1.parent.ino",
-		[CCS_PATH1_PARENT_PERM]    = "path1.parent.perm",
-		[CCS_PATH2_PARENT_UID]     = "path2.parent.uid",
-		[CCS_PATH2_PARENT_GID]     = "path2.parent.gid",
-		[CCS_PATH2_PARENT_INO]     = "path2.parent.ino",
-		[CCS_PATH2_PARENT_PERM]    = "path2.parent.perm",
+		[CCS_PATH1_UID]            = "ccs_path1.uid",
+		[CCS_PATH1_GID]            = "ccs_path1.gid",
+		[CCS_PATH1_INO]            = "ccs_path1.ino",
+		[CCS_PATH1_MAJOR]          = "ccs_path1.major",
+		[CCS_PATH1_MINOR]          = "ccs_path1.minor",
+		[CCS_PATH1_PERM]           = "ccs_path1.perm",
+		[CCS_PATH1_TYPE]           = "ccs_path1.type",
+		[CCS_PATH1_DEV_MAJOR]      = "ccs_path1.dev_major",
+		[CCS_PATH1_DEV_MINOR]      = "ccs_path1.dev_minor",
+		[CCS_PATH2_UID]            = "ccs_path2.uid",
+		[CCS_PATH2_GID]            = "ccs_path2.gid",
+		[CCS_PATH2_INO]            = "ccs_path2.ino",
+		[CCS_PATH2_MAJOR]          = "ccs_path2.major",
+		[CCS_PATH2_MINOR]          = "ccs_path2.minor",
+		[CCS_PATH2_PERM]           = "ccs_path2.perm",
+		[CCS_PATH2_TYPE]           = "ccs_path2.type",
+		[CCS_PATH2_DEV_MAJOR]      = "ccs_path2.dev_major",
+		[CCS_PATH2_DEV_MINOR]      = "ccs_path2.dev_minor",
+		[CCS_PATH1_PARENT_UID]     = "ccs_path1.parent.uid",
+		[CCS_PATH1_PARENT_GID]     = "ccs_path1.parent.gid",
+		[CCS_PATH1_PARENT_INO]     = "ccs_path1.parent.ino",
+		[CCS_PATH1_PARENT_PERM]    = "ccs_path1.parent.perm",
+		[CCS_PATH2_PARENT_UID]     = "ccs_path2.parent.uid",
+		[CCS_PATH2_PARENT_GID]     = "ccs_path2.parent.gid",
+		[CCS_PATH2_PARENT_INO]     = "ccs_path2.parent.ino",
+		[CCS_PATH2_PARENT_PERM]    = "ccs_path2.parent.perm",
 	};
 	char *const start = condition;
 	char *pos = condition;
@@ -219,7 +219,7 @@
 			if (post_state[3] & (1 << i))
 				goto out;
 			post_state[3] |= 1 << i;
-			if (!parse_ulong(&right_min, &condition) ||
+			if (!ccs_parse_ulong(&right_min, &condition) ||
 			    right_min > 255)
 				goto out;
 			post_state[i] = (u8) right_min;
@@ -241,7 +241,7 @@
 		int r_len;
 		if (next)
 			*next++ = '\0';
-		if (!is_correct_path(pos, 0, 0, 0))
+		if (!ccs_is_correct_path(pos, 0, 0, 0))
 			goto out;
 		eq = strchr(pos, '=');
 		if (!eq)
@@ -252,7 +252,7 @@
 		r_len = strlen(eq + 1);
 		if (!strncmp(pos, "exec.argv[", 10)) {
 			pos += 10;
-			if (!parse_ulong(&left_min, &pos) || strcmp(pos, "]"))
+			if (!ccs_parse_ulong(&left_min, &pos) || strcmp(pos, "]"))
 				goto out;
 			pos = eq + 1;
 			if (r_len < 2)
@@ -279,11 +279,11 @@
 			break;
 		}
 		if (left == CCS_MAX_CONDITION_KEYWORD) {
-			if (!parse_ulong(&left_min, &pos))
+			if (!ccs_parse_ulong(&left_min, &pos))
 				goto out;
 			if (pos[0] == '-') {
 				pos++;
-				if (!parse_ulong(&left_max, &pos) || pos[0] ||
+				if (!ccs_parse_ulong(&left_max, &pos) || pos[0] ||
 				    left_min > left_max)
 					goto out;
 			} else if (pos[0])
@@ -309,11 +309,11 @@
 			goto next;
 		if (pos[0] == '@' && pos[1])
 			goto next;
-		if (!parse_ulong(&right_min, &pos))
+		if (!ccs_parse_ulong(&right_min, &pos))
 			goto out;
 		if (pos[0] == '-') {
 			pos++;
-			if (!parse_ulong(&right_max, &pos) || pos[0] ||
+			if (!ccs_parse_ulong(&right_max, &pos) || pos[0] ||
 			    right_min > right_max)
 				goto out;
 		} else if (pos[0])
@@ -323,12 +323,12 @@
 	}
 	return true;
 out:
-	printf("%u: ERROR: '%s' is an illegal condition.\n", line, pos);
-	errors++;
+	printf("%u: ERROR: '%s' is an illegal condition.\n", ccs_line, pos);
+	ccs_errors++;
 	return false;
 }
 
-static void check_capability_policy(char *data)
+static void ccs_check_capability_policy(char *data)
 {
 	static const char *capability_keywords[] = {
 		"inet_tcp_create", "inet_tcp_listen", "inet_tcp_connect",
@@ -346,40 +346,40 @@
 		if (!strcmp(data, capability_keywords[i]))
 			return;
 	}
-	printf("%u: ERROR: '%s' is a bad capability name.\n", line, data);
-	errors++;
+	printf("%u: ERROR: '%s' is a bad capability name.\n", ccs_line, data);
+	ccs_errors++;
 }
 
-static void check_signal_policy(char *data)
+static void ccs_check_signal_policy(char *data)
 {
 	int sig;
 	char *cp;
 	cp = strchr(data, ' ');
 	if (!cp) {
-		printf("%u: ERROR: Too few parameters.\n", line);
-		errors++;
+		printf("%u: ERROR: Too few parameters.\n", ccs_line);
+		ccs_errors++;
 		return;
 	}
 	*cp++ = '\0';
 	if (sscanf(data, "%d", &sig) != 1) {
-		printf("%u: ERROR: '%s' is a bad signal number.\n", line, data);
-		errors++;
+		printf("%u: ERROR: '%s' is a bad signal number.\n", ccs_line, data);
+		ccs_errors++;
 	}
-	if (!is_correct_domain(cp)) {
-		printf("%u: ERROR: '%s' is a bad domainname.\n", line, cp);
-		errors++;
+	if (!ccs_is_correct_domain(cp)) {
+		printf("%u: ERROR: '%s' is a bad domainname.\n", ccs_line, cp);
+		ccs_errors++;
 	}
 }
 
-static void check_env_policy(char *data)
+static void ccs_check_env_policy(char *data)
 {
-	if (!is_correct_path(data, 0, 0, 0)) {
-		printf("%u: ERROR: '%s' is a bad variable name.\n", line, data);
-		errors++;
+	if (!ccs_is_correct_path(data, 0, 0, 0)) {
+		printf("%u: ERROR: '%s' is a bad variable name.\n", ccs_line, data);
+		ccs_errors++;
 	}
 }
 
-static void check_network_policy(char *data)
+static void ccs_check_network_policy(char *data)
 {
 	int sock_type;
 	int operation;
@@ -407,17 +407,17 @@
 		goto out;
 	cp2++;
 	if (!strncmp(cp1, "bind ", 5)) {
-		operation = (sock_type == SOCK_STREAM) ? NETWORK_ACL_TCP_BIND :
-			(sock_type == SOCK_DGRAM) ? NETWORK_ACL_UDP_BIND :
-			NETWORK_ACL_RAW_BIND;
+		operation = (sock_type == SOCK_STREAM) ? CCS_NETWORK_ACL_TCP_BIND :
+			(sock_type == SOCK_DGRAM) ? CCS_NETWORK_ACL_UDP_BIND :
+			CCS_NETWORK_ACL_RAW_BIND;
 	} else if (!strncmp(cp1, "connect ", 8)) {
 		operation = (sock_type == SOCK_STREAM) ?
-			NETWORK_ACL_TCP_CONNECT : (sock_type == SOCK_DGRAM) ?
-			NETWORK_ACL_UDP_CONNECT : NETWORK_ACL_RAW_CONNECT;
+			CCS_NETWORK_ACL_TCP_CONNECT : (sock_type == SOCK_DGRAM) ?
+			CCS_NETWORK_ACL_UDP_CONNECT : CCS_NETWORK_ACL_RAW_CONNECT;
 	} else if (sock_type == SOCK_STREAM && !strncmp(cp1, "listen ", 7)) {
-		operation = NETWORK_ACL_TCP_LISTEN;
+		operation = CCS_NETWORK_ACL_TCP_LISTEN;
 	} else if (sock_type == SOCK_STREAM && !strncmp(cp1, "accept ", 7)) {
-		operation = NETWORK_ACL_TCP_ACCEPT;
+		operation = CCS_NETWORK_ACL_TCP_ACCEPT;
 	} else {
 		goto out;
 	}
@@ -474,11 +474,11 @@
 			return;
 	}
 out:
-	printf("%u: ERROR: Bad network address.\n", line);
-	errors++;
+	printf("%u: ERROR: Bad network address.\n", ccs_line);
+	ccs_errors++;
 }
 
-static void check_file_policy(char *data)
+static void ccs_check_file_policy(char *data)
 {
 	static const struct {
 		const char * const keyword;
@@ -516,8 +516,8 @@
 	char *cp;
 	int type;
 	if (!filename) {
-		printf("%u: ERROR: Unknown command '%s'\n", line, data);
-		errors++;
+		printf("%u: ERROR: Unknown command '%s'\n", ccs_line, data);
+		ccs_errors++;
 		return;
 	}
 	*filename++ = '\0';
@@ -531,24 +531,24 @@
 			cp = strrchr(filename, ' ');
 			if (!cp) {
 				printf("%u: ERROR: Too few arguments.\n",
-				       line);
+				       ccs_line);
 				break;
 			}
-			if (!is_correct_path(cp + 1, 0, 0, 0)) {
+			if (!ccs_is_correct_path(cp + 1, 0, 0, 0)) {
 				printf("%u: ERROR: '%s' is a bad argument\n",
-				       line, cp + 1);
+				       ccs_line, cp + 1);
 				break;
 			}
 			*cp = '\0';
 			cp = strrchr(filename, ' ');
 			if (!cp) {
 				printf("%u: ERROR: Too few arguments.\n",
-				       line);
+				       ccs_line);
 				break;
 			}
-			if (!is_correct_path(cp + 1, 0, 0, 0)) {
+			if (!ccs_is_correct_path(cp + 1, 0, 0, 0)) {
 				printf("%u: ERROR: '%s' is a bad argument.\n",
-				       line, cp + 1);
+				       ccs_line, cp + 1);
 				break;
 			}
 			*cp = '\0';
@@ -557,40 +557,40 @@
 			cp = strrchr(filename, ' ');
 			if (!cp) {
 				printf("%u: ERROR: Too few arguments.\n",
-				       line);
+				       ccs_line);
 				break;
 			}
-			if (!is_correct_path(cp + 1, 0, 0, 0)) {
+			if (!ccs_is_correct_path(cp + 1, 0, 0, 0)) {
 				printf("%u: ERROR: '%s' is a bad argument.\n",
-				       line, cp + 1);
+				       ccs_line, cp + 1);
 				break;
 			}
 			*cp = '\0';
 		}
-		if (!is_correct_path(filename, 0, 0, 0)) {
-			printf("%u: ERROR: '%s' is a bad argument.\n", line,
+		if (!ccs_is_correct_path(filename, 0, 0, 0)) {
+			printf("%u: ERROR: '%s' is a bad argument.\n", ccs_line,
 			       filename);
 			break;
 		}
 		/* "allow_execute"/"allow_transit" don't accept patterns. */
 		if (type <= 1 && filename[0] != '@' &&
-		    !is_correct_path(filename, 1, -1, -1)) {
+		    !ccs_is_correct_path(filename, 1, -1, -1)) {
 			printf("%u: ERROR: Patterns not allowed for "
-			       "execute/transit permission.\n", line);
+			       "execute/transit permission.\n", ccs_line);
 			break;
 		}
 		return;
 	}
 	if (!acl_type_array[type].keyword)
 		goto out;
-	errors++;
+	ccs_errors++;
 	return;
 out:
-	printf("%u: ERROR: Invalid permission '%s %s'\n", line, data, filename);
-	errors++;
+	printf("%u: ERROR: Invalid permission '%s %s'\n", ccs_line, data, filename);
+	ccs_errors++;
 }
 
-static void check_reserved_port_policy(char *data)
+static void ccs_check_reserved_port_policy(char *data)
 {
 	unsigned int from;
 	unsigned int to;
@@ -603,129 +603,129 @@
 		if (from < 65536)
 			return;
 	} else {
-		printf("%u: ERROR: Too few parameters.\n", line);
-		errors++;
+		printf("%u: ERROR: Too few parameters.\n", ccs_line);
+		ccs_errors++;
 		return;
 	}
 out:
-	printf("%u: ERROR: '%s' is a bad port number.\n", line, data);
-	errors++;
+	printf("%u: ERROR: '%s' is a bad port number.\n", ccs_line, data);
+	ccs_errors++;
 }
 
-static void check_domain_initializer_entry(const char *domainname,
-					const char *program)
+static void ccs_check_domain_initializer_entry(const char *domainname,
+					       const char *program)
 {
-	if (!is_correct_path(program, 1, 0, -1)) {
-		printf("%u: ERROR: '%s' is a bad pathname.\n", line, program);
-		errors++;
+	if (!ccs_is_correct_path(program, 1, 0, -1)) {
+		printf("%u: ERROR: '%s' is a bad pathname.\n", ccs_line, program);
+		ccs_errors++;
 	}
-	if (domainname && !is_correct_path(domainname, 1, -1, -1) &&
-	    !is_correct_domain(domainname)) {
+	if (domainname && !ccs_is_correct_path(domainname, 1, -1, -1) &&
+	    !ccs_is_correct_domain(domainname)) {
 		printf("%u: ERROR: '%s' is a bad domainname.\n",
-		       line, domainname);
-		errors++;
+		       ccs_line, domainname);
+		ccs_errors++;
 	}
 }
 
-static void check_domain_initializer_policy(char *data)
+static void ccs_check_domain_initializer_policy(char *data)
 {
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
-		check_domain_initializer_entry(cp + 6, data);
+		ccs_check_domain_initializer_entry(cp + 6, data);
 	} else {
-		check_domain_initializer_entry(NULL, data);
+		ccs_check_domain_initializer_entry(NULL, data);
 	}
 }
 
-static void check_domain_keeper_entry(const char *domainname,
-				      const char *program)
+static void ccs_check_domain_keeper_entry(const char *domainname,
+					  const char *program)
 {
-	if (!is_correct_path(domainname, 1, -1, -1) &&
-	    !is_correct_domain(domainname)) {
+	if (!ccs_is_correct_path(domainname, 1, -1, -1) &&
+	    !ccs_is_correct_domain(domainname)) {
 		printf("%u: ERROR: '%s' is a bad domainname.\n",
-		       line, domainname);
-		errors++;
+		       ccs_line, domainname);
+		ccs_errors++;
 	}
-	if (program && !is_correct_path(program, 1, 0, -1)) {
-		printf("%u: ERROR: '%s' is a bad pathname.\n", line, program);
-		errors++;
+	if (program && !ccs_is_correct_path(program, 1, 0, -1)) {
+		printf("%u: ERROR: '%s' is a bad pathname.\n", ccs_line, program);
+		ccs_errors++;
 	}
 }
 
-static void check_domain_keeper_policy(char *data)
+static void ccs_check_domain_keeper_policy(char *data)
 {
 	char *cp = strstr(data, " from ");
 	if (cp) {
 		*cp = '\0';
-		check_domain_keeper_entry(cp + 6, data);
+		ccs_check_domain_keeper_entry(cp + 6, data);
 	} else {
-		check_domain_keeper_entry(data, NULL);
+		ccs_check_domain_keeper_entry(data, NULL);
 	}
 }
 
-static void check_path_group_policy(char *data)
+static void ccs_check_path_group_policy(char *data)
 {
 	char *cp = strchr(data, ' ');
 	if (!cp) {
-		printf("%u: ERROR: Too few parameters.\n", line);
-		errors++;
+		printf("%u: ERROR: Too few parameters.\n", ccs_line);
+		ccs_errors++;
 		return;
 	}
 	*cp++ = '\0';
-	if (!is_correct_path(data, 0, 0, 0)) {
-		printf("%u: ERROR: '%s' is a bad group name.\n", line, data);
-		errors++;
+	if (!ccs_is_correct_path(data, 0, 0, 0)) {
+		printf("%u: ERROR: '%s' is a bad group name.\n", ccs_line, data);
+		ccs_errors++;
 	}
-	if (!is_correct_path(cp, 0, 0, 0)) {
-		printf("%u: ERROR: '%s' is a bad pathname.\n", line, cp);
-		errors++;
+	if (!ccs_is_correct_path(cp, 0, 0, 0)) {
+		printf("%u: ERROR: '%s' is a bad pathname.\n", ccs_line, cp);
+		ccs_errors++;
 	}
 }
 
-static void check_number_group_policy(char *data)
+static void ccs_check_number_group_policy(char *data)
 {
 	char *cp = strchr(data, ' ');
 	unsigned long v;
 	if (!cp) {
-		printf("%u: ERROR: Too few parameters.\n", line);
-		errors++;
+		printf("%u: ERROR: Too few parameters.\n", ccs_line);
+		ccs_errors++;
 		return;
 	}
 	*cp++ = '\0';
-	if (!is_correct_path(data, 0, 0, 0)) {
-		printf("%u: ERROR: '%s' is a bad group name.\n", line, data);
-		errors++;
+	if (!ccs_is_correct_path(data, 0, 0, 0)) {
+		printf("%u: ERROR: '%s' is a bad group name.\n", ccs_line, data);
+		ccs_errors++;
 	}
 	data = cp;
 	cp = strchr(data, '-');
 	if (cp)
 		*cp = '\0';
-	if (!parse_ulong(&v, &data) || *data) {
-		printf("%u: ERROR: '%s' is a bad number.\n", line, data);
-		errors++;
+	if (!ccs_parse_ulong(&v, &data) || *data) {
+		printf("%u: ERROR: '%s' is a bad number.\n", ccs_line, data);
+		ccs_errors++;
 	}
-	if (cp && !parse_ulong(&v, &cp)) {
-		printf("%u: ERROR: '%s' is a bad number.\n", line, cp);
-		errors++;
+	if (cp && !ccs_parse_ulong(&v, &cp)) {
+		printf("%u: ERROR: '%s' is a bad number.\n", ccs_line, cp);
+		ccs_errors++;
 	}
 }
 
-static void check_address_group_policy(char *data)
+static void ccs_check_address_group_policy(char *data)
 {
 	char *cp = strchr(data, ' ');
 	u16 min_address[8];
 	u16 max_address[8];
 	int count;
 	if (!cp) {
-		printf("%u: ERROR: Too few parameters.\n", line);
-		errors++;
+		printf("%u: ERROR: Too few parameters.\n", ccs_line);
+		ccs_errors++;
 		return;
 	}
 	*cp++ = '\0';
-	if (!is_correct_path(data, 0, 0, 0)) {
-		printf("%u: ERROR: '%s' is a bad group name.\n", line, data);
-		errors++;
+	if (!ccs_is_correct_path(data, 0, 0, 0)) {
+		printf("%u: ERROR: '%s' is a bad group name.\n", ccs_line, data);
+		ccs_errors++;
 	}
 	count = sscanf(cp, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx-"
 		       "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
@@ -743,25 +743,25 @@
 		       &max_address[2], &max_address[3]);
 	if (count == 4 || count == 8)
 		return;
-	printf("%u: ERROR: '%s' is a bad address.\n", line, cp);
-	errors++;
+	printf("%u: ERROR: '%s' is a bad address.\n", ccs_line, cp);
+	ccs_errors++;
 }
 
-static void check_domain_policy(char *policy)
+static void ccs_check_domain_policy(char *policy)
 {
 	static int domain = EOF;
 	_Bool is_delete = false;
 	_Bool is_select = false;
-	if (str_starts(policy, KEYWORD_DELETE))
+	if (ccs_str_starts(policy, CCS_KEYWORD_DELETE))
 		is_delete = true;
-	else if (str_starts(policy, KEYWORD_SELECT))
+	else if (ccs_str_starts(policy, CCS_KEYWORD_SELECT))
 		is_select = true;
 	if (!strncmp(policy, "<kernel>", 8)) {
-		if (!is_correct_domain(policy) ||
+		if (!ccs_is_correct_domain(policy) ||
 		    strlen(policy) >= CCS_MAX_PATHNAME_LEN) {
 			printf("%u: ERROR: '%s' is a bad domainname.\n",
-			       line, policy);
-			errors++;
+			       ccs_line, policy);
+			ccs_errors++;
 		} else {
 			if (is_delete)
 				domain = EOF;
@@ -770,142 +770,142 @@
 		}
 	} else if (is_select) {
 		printf("%u: ERROR: Command 'select' is valid for selecting "
-		       "domains only.\n", line);
-		errors++;
+		       "domains only.\n", ccs_line);
+		ccs_errors++;
 	} else if (domain == EOF) {
 		printf("%u: WARNING: '%s' is unprocessed because domain is not "
-		       "selected.\n", line, policy);
-		warnings++;
-	} else if (str_starts(policy, KEYWORD_USE_PROFILE)) {
+		       "selected.\n", ccs_line, policy);
+		ccs_warnings++;
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_USE_PROFILE)) {
 		unsigned int profile;
 		if (sscanf(policy, "%u", &profile) != 1 ||
 		    profile >= 256) {
 			printf("%u: ERROR: '%s' is a bad profile.\n",
-			       line, policy);
-			errors++;
+			       ccs_line, policy);
+			ccs_errors++;
 		}
 	} else if (!strcmp(policy, "ignore_global_allow_read")) {
 		/* Nothing to do. */
 	} else if (!strcmp(policy, "ignore_global_allow_env")) {
 		/* Nothing to do. */
-	} else if (str_starts(policy, "execute_handler ") ||
-		   str_starts(policy, "denied_execute_handler")) {
-		if (!is_correct_path(policy, 1, -1, -1)) {
+	} else if (ccs_str_starts(policy, "execute_handler ") ||
+		   ccs_str_starts(policy, "denied_execute_handler")) {
+		if (!ccs_is_correct_path(policy, 1, -1, -1)) {
 			printf("%u: ERROR: '%s' is a bad pathname.\n",
-			       line, policy);
-			errors++;
+			       ccs_line, policy);
+			ccs_errors++;
 		}
 	} else if (!strcmp(policy, "transition_failed")) {
 		/* Nothing to do. */
 	} else if (!strcmp(policy, "quota_exceeded")) {
 		/* Nothing to do. */
 	} else {
-		char *cp = find_condition_part(policy);
-		if (cp && !check_condition(cp))
+		char *cp = ccs_find_condition_part(policy);
+		if (cp && !ccs_check_condition(cp))
 			return;
-		if (str_starts(policy, KEYWORD_ALLOW_CAPABILITY))
-			check_capability_policy(policy);
-		else if (str_starts(policy, KEYWORD_ALLOW_NETWORK))
-			check_network_policy(policy);
-		else if (str_starts(policy, KEYWORD_ALLOW_SIGNAL))
-			check_signal_policy(policy);
-		else if (str_starts(policy, KEYWORD_ALLOW_ENV))
-			check_env_policy(policy);
+		if (ccs_str_starts(policy, CCS_KEYWORD_ALLOW_CAPABILITY))
+			ccs_check_capability_policy(policy);
+		else if (ccs_str_starts(policy, CCS_KEYWORD_ALLOW_NETWORK))
+			ccs_check_network_policy(policy);
+		else if (ccs_str_starts(policy, CCS_KEYWORD_ALLOW_SIGNAL))
+			ccs_check_signal_policy(policy);
+		else if (ccs_str_starts(policy, CCS_KEYWORD_ALLOW_ENV))
+			ccs_check_env_policy(policy);
 		else
-			check_file_policy(policy);
+			ccs_check_file_policy(policy);
 	}
 }
 
-static void check_exception_policy(char *policy)
+static void ccs_check_exception_policy(char *policy)
 {
-	str_starts(policy, KEYWORD_DELETE);
-	if (str_starts(policy, KEYWORD_ALLOW_READ)) {
-		if (!is_correct_path(policy, 1, 0, -1)) {
+	ccs_str_starts(policy, CCS_KEYWORD_DELETE);
+	if (ccs_str_starts(policy, CCS_KEYWORD_ALLOW_READ)) {
+		if (!ccs_is_correct_path(policy, 1, 0, -1)) {
 			printf("%u: ERROR: '%s' is a bad pathname.\n",
-			       line, policy);
-			errors++;
+			       ccs_line, policy);
+			ccs_errors++;
 		}
-	} else if (str_starts(policy, KEYWORD_INITIALIZE_DOMAIN)) {
-		check_domain_initializer_policy(policy);
-	} else if (str_starts(policy, KEYWORD_NO_INITIALIZE_DOMAIN)) {
-		check_domain_initializer_policy(policy);
-	} else if (str_starts(policy, KEYWORD_KEEP_DOMAIN)) {
-		check_domain_keeper_policy(policy);
-	} else if (str_starts(policy, KEYWORD_NO_KEEP_DOMAIN)) {
-		check_domain_keeper_policy(policy);
-	} else if (str_starts(policy, KEYWORD_PATH_GROUP)) {
-		check_path_group_policy(policy);
-	} else if (str_starts(policy, KEYWORD_NUMBER_GROUP)) {
-		check_number_group_policy(policy);
-	} else if (str_starts(policy, KEYWORD_ADDRESS_GROUP)) {
-		check_address_group_policy(policy);
-	} else if (str_starts(policy, KEYWORD_AGGREGATOR)) {
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_INITIALIZE_DOMAIN)) {
+		ccs_check_domain_initializer_policy(policy);
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_NO_INITIALIZE_DOMAIN)) {
+		ccs_check_domain_initializer_policy(policy);
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_KEEP_DOMAIN)) {
+		ccs_check_domain_keeper_policy(policy);
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_NO_KEEP_DOMAIN)) {
+		ccs_check_domain_keeper_policy(policy);
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_PATH_GROUP)) {
+		ccs_check_path_group_policy(policy);
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_NUMBER_GROUP)) {
+		ccs_check_number_group_policy(policy);
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_ADDRESS_GROUP)) {
+		ccs_check_address_group_policy(policy);
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_AGGREGATOR)) {
 		char *cp = strchr(policy, ' ');
 		if (!cp) {
-			printf("%u: ERROR: Too few parameters.\n", line);
-			errors++;
+			printf("%u: ERROR: Too few parameters.\n", ccs_line);
+			ccs_errors++;
 		} else {
 			*cp++ = '\0';
-			if (!is_correct_path(policy, 1, 0, -1)) {
+			if (!ccs_is_correct_path(policy, 1, 0, -1)) {
 				printf("%u: ERROR: '%s' is a bad pattern.\n",
-				       line, policy);
-				errors++;
+				       ccs_line, policy);
+				ccs_errors++;
 			}
-			if (!is_correct_path(cp, 1, -1, -1)) {
+			if (!ccs_is_correct_path(cp, 1, -1, -1)) {
 				printf("%u: ERROR: '%s' is a bad pathname.\n",
-				       line, cp);
-				errors++;
+				       ccs_line, cp);
+				ccs_errors++;
 			}
 		}
-	} else if (str_starts(policy, KEYWORD_FILE_PATTERN)) {
-		if (!is_correct_path(policy, 0, 1, 0)) {
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_FILE_PATTERN)) {
+		if (!ccs_is_correct_path(policy, 0, 1, 0)) {
 			printf("%u: ERROR: '%s' is a bad pattern.\n",
-			       line, policy);
-			errors++;
+			       ccs_line, policy);
+			ccs_errors++;
 		}
-	} else if (str_starts(policy, KEYWORD_DENY_REWRITE)) {
-		if (!is_correct_path(policy, 0, 0, 0)) {
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_DENY_REWRITE)) {
+		if (!ccs_is_correct_path(policy, 0, 0, 0)) {
 			printf("%u: ERROR: '%s' is a bad pattern.\n",
-			       line, policy);
-			errors++;
+			       ccs_line, policy);
+			ccs_errors++;
 		}
-	} else if (str_starts(policy, KEYWORD_ALLOW_ENV)) {
-		if (!is_correct_path(policy, 0, 0, 0)) {
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_ALLOW_ENV)) {
+		if (!ccs_is_correct_path(policy, 0, 0, 0)) {
 			printf("%u: ERROR: '%s' is a bad variable name.\n",
-			       line, policy);
-			errors++;
+			       ccs_line, policy);
+			ccs_errors++;
 		}
-	} else if (str_starts(policy, KEYWORD_DENY_AUTOBIND)) {
-		check_reserved_port_policy(policy);
+	} else if (ccs_str_starts(policy, CCS_KEYWORD_DENY_AUTOBIND)) {
+		ccs_check_reserved_port_policy(policy);
 	} else {
 		printf("%u: ERROR: Unknown command '%s'.\n",
-		       line, policy);
-		errors++;
+		       ccs_line, policy);
+		ccs_errors++;
 	}
 }
 
-int checkpolicy_main(int argc, char *argv[])
+int ccs_checkpolicy_main(int argc, char *argv[])
 {
 	char *policy = NULL;
-	int policy_type = POLICY_TYPE_UNKNOWN;
+	int policy_type = CCS_POLICY_TYPE_UNKNOWN;
 	if (argc > 1) {
 		switch (argv[1][0]) {
 		case 'e':
-			policy_type = POLICY_TYPE_EXCEPTION_POLICY;
+			policy_type = CCS_POLICY_TYPE_EXCEPTION_POLICY;
 			break;
 		case 'd':
-			policy_type = POLICY_TYPE_DOMAIN_POLICY;
+			policy_type = CCS_POLICY_TYPE_DOMAIN_POLICY;
 			break;
 		}
 	}
-	if (policy_type == POLICY_TYPE_UNKNOWN) {
+	if (policy_type == CCS_POLICY_TYPE_UNKNOWN) {
 		fprintf(stderr, "%s e|d < policy_to_check\n", argv[0]);
 		return 0;
 	}
 	while (true) {
 		bool badchar_warned = false;
 		int pos = 0;
-		line++;
+		ccs_line++;
 		while (true) {
 			static int max_policy_len = 0;
 			int c = getchar();
@@ -916,7 +916,7 @@
 				max_policy_len += 4096;
 				cp = realloc(policy, max_policy_len);
 				if (!cp)
-					out_of_memory();
+					ccs_out_of_memory();
 				policy = cp;
 			}
 			policy[pos++] = (char) c;
@@ -928,28 +928,28 @@
 			    c == '\t' || (c >= ' ' && c < 127))
 				continue;
 			printf("%u: WARNING: Line contains illegal "
-			       "character (\\%03o).\n", line, c);
-			warnings++;
+			       "character (\\%03o).\n", ccs_line, c);
+			ccs_warnings++;
 			badchar_warned = true;
 		}
-		normalize_line(policy);
+		ccs_normalize_line(policy);
 		if (!policy[0] || policy[0] == '#')
 			continue;
 		switch (policy_type) {
-		case POLICY_TYPE_DOMAIN_POLICY:
-			check_domain_policy(policy);
+		case CCS_POLICY_TYPE_DOMAIN_POLICY:
+			ccs_check_domain_policy(policy);
 			break;
-		case POLICY_TYPE_EXCEPTION_POLICY:
-			check_exception_policy(policy);
+		case CCS_POLICY_TYPE_EXCEPTION_POLICY:
+			ccs_check_exception_policy(policy);
 			break;
 		}
 	}
  out:
 	free(policy);
 	policy = NULL;
-	line--;
+	ccs_line--;
 	printf("Total:   %u Line%s   %u Error%s   %u Warning%s\n",
-	       line, line > 1 ? "s" : "", errors, errors > 1 ? "s" : "",
-	       warnings, warnings > 1 ? "s" : "");
-	return errors ? 2 : (warnings ? 1 : 0);
+	       ccs_line, ccs_line > 1 ? "s" : "", ccs_errors, ccs_errors > 1 ? "s" : "",
+	       ccs_warnings, ccs_warnings > 1 ? "s" : "");
+	return ccs_errors ? 2 : (ccs_warnings ? 1 : 0);
 }
