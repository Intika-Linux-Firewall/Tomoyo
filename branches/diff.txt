Index: trunk/1.7.x/ccs-patch/security/ccsecurity/address_group.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/address_group.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/address_group.c	(working copy)
@@ -1,229 +0,0 @@
-/*
- * security/ccsecurity/address_group.c
- *
- * Copyright (C) 2005-2009  NTT DATA CORPORATION
- *
- * Version: 1.7.1   2009/11/11
- *
- * This file is applicable to both 2.4.30 and 2.6.11 and later.
- * See README.ccs for ChangeLog.
- *
- */
-
-#include <linux/slab.h>
-#include "internal.h"
-
-/* The list for "struct ccs_address_group". */
-LIST_HEAD(ccs_address_group_list);
-
-/**
- * ccs_get_address_group - Allocate memory for "struct ccs_address_group".
- *
- * @group_name: The name of address group.
- *
- * Returns pointer to "struct ccs_address_group" on success,
- * NULL otherwise.
- */
-struct ccs_address_group *ccs_get_address_group(const char *group_name)
-{
-	struct ccs_address_group *entry = NULL;
-	struct ccs_address_group *group;
-	const struct ccs_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
-	    !group_name[0])
-		return NULL;
-	saved_group_name = ccs_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(group, &ccs_address_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &ccs_address_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
-}
-
-/**
- * ccs_write_address_group_policy - Write "struct ccs_address_group" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_address_group_policy(char *data, const bool is_delete)
-{
-	struct ccs_address_group *group;
-	struct ccs_address_group_member *entry = NULL;
-	struct ccs_address_group_member *member;
-	struct ccs_address_group_member e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	u16 min_address[8];
-	u16 max_address[8];
-	char *w[2];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	group = ccs_get_address_group(w[0]);
-	if (!group)
-		return -ENOMEM;
-	switch (ccs_parse_ip_address(w[1], min_address, max_address)) {
-	case 2:
-		e.is_ipv6 = true;
-		e.min.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
-						  min_address);
-		e.max.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
-						  max_address);
-		if (!e.min.ipv6 || !e.max.ipv6)
-			goto out;
-		break;
-	case 1:
-		e.min.ipv4 = ntohl(*(u32 *) min_address);
-		e.max.ipv4 = ntohl(*(u32 *) max_address);
-		break;
-	default:
-		goto out;
-	}
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (ccs_memcmp(member, &e, offsetof(typeof(e), is_ipv6),
-			       sizeof(e)))
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &group->member_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	if (e.is_ipv6) {
-		ccs_put_ipv6_address(e.min.ipv6);
-		ccs_put_ipv6_address(e.max.ipv6);
-	}
-	ccs_put_address_group(group);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_address_group_policy - Read "struct ccs_address_group" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_address_group_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &ccs_address_group_list) {
-		struct ccs_address_group *group;
-		group = list_entry(gpos, struct ccs_address_group, list);
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			char buf[128];
-			struct ccs_address_group_member *member;
-			member = list_entry(mpos,
-					    struct ccs_address_group_member,
-					    list);
-			if (member->is_deleted)
-				continue;
-			if (member->is_ipv6) {
-				const struct in6_addr *min_address
-					= member->min.ipv6;
-				const struct in6_addr *max_address
-					= member->max.ipv6;
-				ccs_print_ipv6(buf, sizeof(buf), min_address);
-				if (min_address != max_address) {
-					int len;
-					char *cp = buf + strlen(buf);
-					*cp++ = '-';
-					len = strlen(buf);
-					ccs_print_ipv6(cp, sizeof(buf) - len,
-						       max_address);
-				}
-			} else {
-				const u32 min_address = member->min.ipv4;
-				const u32 max_address = member->max.ipv4;
-				memset(buf, 0, sizeof(buf));
-				snprintf(buf, sizeof(buf) - 1, "%u.%u.%u.%u",
-					 HIPQUAD(min_address));
-				if (min_address != max_address) {
-					const int len = strlen(buf);
-					snprintf(buf + len,
-						 sizeof(buf) - 1 - len,
-						 "-%u.%u.%u.%u",
-						 HIPQUAD(max_address));
-				}
-			}
-			if (!ccs_io_printf(head, CCS_KEYWORD_ADDRESS_GROUP
-					   "%s %s\n", group->group_name->name,
-					   buf))
-				return false;
-		}
-	}
-	return true;
-}
-
-/**
- * ccs_address_matches_group - Check whether the given address matches members of the given address group.
- *
- * @is_ipv6: True if @address is an IPv6 address.
- * @address: An IPv4 or IPv6 address.
- * @group:   Pointer to "struct ccs_address_group".
- *
- * Returns true if @address matches addresses in @group group, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
-			       const struct ccs_address_group *group)
-{
-	struct ccs_address_group_member *member;
-	const u32 ip = ntohl(*address);
-	bool matched = false;
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->is_deleted)
-			continue;
-		if (member->is_ipv6) {
-			if (is_ipv6 &&
-			    memcmp(member->min.ipv6, address, 16) <= 0 &&
-			    memcmp(address, member->max.ipv6, 16) <= 0) {
-				matched = true;
-				break;
-			}
-		} else {
-			if (!is_ipv6 &&
-			    member->min.ipv4 <= ip && ip <= member->max.ipv4) {
-				matched = true;
-				break;
-			}
-		}
-	}
-	return matched;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/mount.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/mount.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/mount.c	(working copy)
@@ -96,7 +96,7 @@
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
 /* For compatibility with older kernels. */
-static void put_filesystem(struct file_system_type *fs)
+static inline void put_filesystem(struct file_system_type *fs)
 {
 	module_put(fs->owner);
 }
@@ -346,59 +346,3 @@
 	ccs_read_unlock(idx);
 	return error;
 }
-
-/**
- * ccs_write_mount_policy - Write "struct ccs_mount_acl" list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_mount_policy(char *data, struct ccs_domain_info *domain,
-			   struct ccs_condition *condition,
-			   const bool is_delete)
-{
-	struct ccs_mount_acl *entry = NULL;
-	struct ccs_acl_info *ptr;
-	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL,
-				   .head.cond = condition };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	char *w[4];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[3][0])
-		return -EINVAL;
-	if (!ccs_parse_name_union(w[0], &e.dev_name) ||
-	    !ccs_parse_name_union(w[1], &e.dir_name) ||
-	    !ccs_parse_name_union(w[2], &e.fs_type) ||
-	    !ccs_parse_number_union(w[3], &e.flags))
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_mount_acl *acl =
-			container_of(ptr, struct ccs_mount_acl, head);
-		if (ptr->type != CCS_TYPE_MOUNT_ACL || ptr->cond != condition
-		    || ccs_memcmp(acl, &e, offsetof(typeof(e), dev_name),
-				  sizeof(e)))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name_union(&e.dev_name);
-	ccs_put_name_union(&e.dir_name);
-	ccs_put_name_union(&e.fs_type);
-	ccs_put_number_union(&e.flags);
-	kfree(entry);
-	return error;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/number_group.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/number_group.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/number_group.c	(working copy)
@@ -17,139 +17,6 @@
 LIST_HEAD(ccs_number_group_list);
 
 /**
- * ccs_get_number_group - Allocate memory for "struct ccs_number_group".
- *
- * @group_name: The name of number group.
- *
- * Returns pointer to "struct ccs_number_group" on success,
- * NULL otherwise.
- */
-struct ccs_number_group *ccs_get_number_group(const char *group_name)
-{
-	struct ccs_number_group *entry = NULL;
-	struct ccs_number_group *group;
-	const struct ccs_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
-	    !group_name[0])
-		return NULL;
-	saved_group_name = ccs_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(group, &ccs_number_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &ccs_number_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
-}
-
-/**
- * ccs_write_number_group_policy - Write "struct ccs_number_group" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, nagative value otherwise.
- */
-int ccs_write_number_group_policy(char *data, const bool is_delete)
-{
-	struct ccs_number_group *group;
-	struct ccs_number_group_member *entry = NULL;
-	struct ccs_number_group_member e = { };
-	struct ccs_number_group_member *member;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	char *w[2];
-	if (!ccs_tokenize(data, w, sizeof(w)))
-		return -EINVAL;
-	if (!ccs_parse_number_union(w[1], &e.number))
-		return -EINVAL;
-	if (e.number.is_group || e.number.values[0] > e.number.values[1]) {
-		ccs_put_number_union(&e.number);
-		return -EINVAL;
-	}
-	group = ccs_get_number_group(w[0]);
-	if (!group)
-		return -ENOMEM;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (memcmp(&member->number, &e.number, sizeof(e.number)))
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &group->member_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_number_group(group);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_number_group_policy - Read "struct ccs_number_group" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_number_group_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &ccs_number_group_list) {
-		struct ccs_number_group *group;
-		const char *name;
-		group = list_entry(gpos, struct ccs_number_group, list);
-		name = group->group_name->name;
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			int pos;
-			const struct ccs_number_group_member *member
-				= list_entry(mpos,
-					     struct ccs_number_group_member,
-					     list);
-			if (member->is_deleted)
-				continue;
-			pos = head->read_avail;
-			if (!ccs_io_printf(head, CCS_KEYWORD_NUMBER_GROUP "%s",
-					   name) ||
-			    !ccs_print_number_union(head, &member->number) ||
-			    !ccs_io_printf(head, "\n")) {
-				head->read_avail = pos;
-				return false;
-			}
-		}
-	}
-	return true;
-}
-
-/**
  * ccs_number_matches_group - Check whether the given number matches members of the given number group.
  *
  * @min:   Min number.
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/autobind.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/autobind.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/autobind.c	(working copy)
@@ -15,64 +15,9 @@
 /* The list for "struct ccs_reserved_entry". */
 LIST_HEAD(ccs_reservedport_list);
 
-static u8 ccs_reserved_port_map[8192];
+u8 ccs_reserved_port_map[8192];
 
 /**
- * ccs_update_reserved_entry - Update "struct ccs_reserved_entry" list.
- *
- * @min_port: Start of port number range.
- * @max_port: End of port number range.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_reserved_entry(const u16 min_port, const u16 max_port,
-				     const bool is_delete)
-{
-	struct ccs_reserved_entry *ptr;
-	struct ccs_reserved_entry e = {
-		.min_port = min_port,
-		.max_port = max_port
-	};
-	int error = -ENOMEM;
-	u8 *ccs_tmp_map = kzalloc(8192, GFP_KERNEL);
-	struct ccs_reserved_entry *entry = kmalloc(sizeof(e), GFP_KERNEL);
-	if (!ccs_tmp_map || !entry) {
-		kfree(entry);
-		kfree(ccs_tmp_map);
-		return -ENOMEM;
-	}
-	if (is_delete)
-		error = -ENOENT;
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
-		if (ptr->min_port != min_port || ptr->max_port != max_port)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_reservedport_list);
-		entry = NULL;
-		error = 0;
-	}
-	list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
-		unsigned int port;
-		if (ptr->is_deleted)
-			continue;
-		for (port = ptr->min_port; port <= ptr->max_port; port++)
-			ccs_tmp_map[port >> 8] |= 1 << (port & 7);
-	}
-	memmove(ccs_reserved_port_map, ccs_tmp_map,
-		sizeof(ccs_reserved_port_map));
-	mutex_unlock(&ccs_policy_lock);
-	kfree(entry);
-	kfree(ccs_tmp_map);
-	return error;
-}
-
-/**
  * ccs_lport_reserved - Check permission for bind()'s automatic port number selection.
  *
  * @port: Port number.
@@ -85,60 +30,3 @@
 		? true : false;
 }
 EXPORT_SYMBOL(ccs_lport_reserved); /* for net/ipv4/ and net/ipv6/ */
-
-/**
- * ccs_write_reserved_port_policy - Write "struct ccs_reserved_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_reserved_port_policy(char *data, const bool is_delete)
-{
-	unsigned int from;
-	unsigned int to;
-	if (strchr(data, ' '))
-		goto out;
-	if (sscanf(data, "%u-%u", &from, &to) == 2) {
-		if (from <= to && to < 65536)
-			return ccs_update_reserved_entry(from, to, is_delete);
-	} else if (sscanf(data, "%u", &from) == 1) {
-		if (from < 65536)
-			return ccs_update_reserved_entry(from, from, is_delete);
-	}
- out:
-	return -EINVAL;
-}
-
-/**
- * ccs_read_reserved_port_policy - Read "struct ccs_reserved_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	char buffer[16];
-	memset(buffer, 0, sizeof(buffer));
-	list_for_each_cookie(pos, head->read_var2, &ccs_reservedport_list) {
-		u16 min_port;
-		u16 max_port;
-		struct ccs_reserved_entry *ptr;
-		ptr = list_entry(pos, struct ccs_reserved_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		min_port = ptr->min_port;
-		max_port = ptr->max_port;
-		snprintf(buffer, sizeof(buffer) - 1, "%u%c%u", min_port,
-			 min_port != max_port ? '-' : '\0', max_port);
-		if (!ccs_io_printf(head, CCS_KEYWORD_DENY_AUTOBIND "%s\n",
-				   buffer))
-			return false;
-	}
-	return true;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/audit.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/audit.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/audit.c	(working copy)
@@ -395,6 +395,33 @@
 static unsigned int ccs_audit_log_count[2];
 
 /**
+ * ccs_get_audit - Get audit mode.
+ *
+ * @profile:    Profile number.
+ * @index:      Index number of functionality.
+ * @is_granted: True if granted log, false otherwise.
+ *
+ * Returns mode.
+ */
+static bool ccs_get_audit(const u8 profile, const u8 index,
+			  const bool is_granted)
+{
+	u8 mode;
+	const u8 category = ccs_index2category[index] + CCS_MAX_MAC_INDEX
+		+ CCS_MAX_CAPABILITY_INDEX;
+	if (!ccs_policy_loaded)
+		return false;
+	mode = ccs_profile(profile)->config[index];
+	if (mode == CCS_CONFIG_USE_DEFAULT)
+		mode = ccs_profile(profile)->config[category];
+	if (mode == CCS_CONFIG_USE_DEFAULT)
+		mode = ccs_profile(profile)->default_config;
+	if (is_granted)
+		return mode & CCS_CONFIG_WANT_GRANT_LOG;
+	return mode & CCS_CONFIG_WANT_REJECT_LOG;
+}
+
+/**
  * ccs_write_audit_log - Write audit log.
  *
  * @is_granted: True if this is a granted log.
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/domain.c	(working copy)
@@ -73,123 +73,6 @@
 LIST_HEAD(ccs_domain_initializer_list);
 
 /**
- * ccs_update_domain_initializer_entry - Update "struct ccs_domain_initializer_entry" list.
- *
- * @domainname: The name of domain. May be NULL.
- * @program:    The name of program.
- * @is_not:     True if it is "no_initialize_domain" entry.
- * @is_delete:  True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_domain_initializer_entry(const char *domainname,
-					       const char *program,
-					       const bool is_not,
-					       const bool is_delete)
-{
-	struct ccs_domain_initializer_entry *entry = NULL;
-	struct ccs_domain_initializer_entry *ptr;
-	struct ccs_domain_initializer_entry e = { .is_not = is_not };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(program, 1, -1, -1))
-		return -EINVAL; /* No patterns allowed. */
-	if (domainname) {
-		if (!ccs_is_domain_def(domainname) &&
-		    ccs_is_correct_path(domainname, 1, -1, -1))
-			e.is_last_name = true;
-		else if (!ccs_is_correct_domain(domainname))
-			return -EINVAL;
-		e.domainname = ccs_get_name(domainname);
-		if (!e.domainname)
-			goto out;
-	}
-	e.program = ccs_get_name(program);
-	if (!e.program)
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_domain_initializer_list, list) {
-		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), is_not),
-			       sizeof(e)))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_domain_initializer_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.domainname);
-	ccs_put_name(e.program);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_domain_initializer_policy - Read "struct ccs_domain_initializer_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_domain_initializer_list) {
-		const char *no;
-		const char *from = "";
-		const char *domain = "";
-		struct ccs_domain_initializer_entry *ptr;
-		ptr = list_entry(pos, struct ccs_domain_initializer_entry,
-				 list);
-		if (ptr->is_deleted)
-			continue;
-		no = ptr->is_not ? "no_" : "";
-		if (ptr->domainname) {
-			from = " from ";
-			domain = ptr->domainname->name;
-		}
-		done = ccs_io_printf(head, "%s" CCS_KEYWORD_INITIALIZE_DOMAIN
-				     "%s%s%s\n", no, ptr->program->name, from,
-				     domain);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
- * ccs_write_domain_initializer_policy - Write "struct ccs_domain_initializer_entry" list.
- *
- * @data:      String to parse.
- * @is_not:    True if it is "no_initialize_domain" entry.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_domain_initializer_policy(char *data, const bool is_not,
-					const bool is_delete)
-{
-	char *cp = strstr(data, " from ");
-	if (cp) {
-		*cp = '\0';
-		return ccs_update_domain_initializer_entry(cp + 6, data,
-							   is_not, is_delete);
-	}
-	return ccs_update_domain_initializer_entry(NULL, data, is_not,
-						   is_delete);
-}
-
-/**
  * ccs_is_domain_initializer - Check whether the given program causes domainname reinitialization.
  *
  * @domainname: The name of domain.
@@ -234,120 +117,6 @@
 LIST_HEAD(ccs_domain_keeper_list);
 
 /**
- * ccs_update_domain_keeper_entry - Update "struct ccs_domain_keeper_entry" list.
- *
- * @domainname: The name of domain.
- * @program:    The name of program. May be NULL.
- * @is_not:     True if it is "no_keep_domain" entry.
- * @is_delete:  True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_domain_keeper_entry(const char *domainname,
-					  const char *program,
-					  const bool is_not,
-					  const bool is_delete)
-{
-	struct ccs_domain_keeper_entry *entry = NULL;
-	struct ccs_domain_keeper_entry *ptr;
-	struct ccs_domain_keeper_entry e = { .is_not = is_not };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_domain_def(domainname) &&
-	    ccs_is_correct_path(domainname, 1, -1, -1))
-		e.is_last_name = true;
-	else if (!ccs_is_correct_domain(domainname))
-		return -EINVAL;
-	if (program) {
-		if (!ccs_is_correct_path(program, 1, -1, -1))
-			return -EINVAL;
-		e.program = ccs_get_name(program);
-		if (!e.program)
-			goto out;
-	}
-	e.domainname = ccs_get_name(domainname);
-	if (!e.domainname)
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_domain_keeper_list, list) {
-		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), is_not),
-			       sizeof(e)))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_domain_keeper_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.domainname);
-	ccs_put_name(e.program);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_write_domain_keeper_policy - Write "struct ccs_domain_keeper_entry" list.
- *
- * @data:      String to parse.
- * @is_not:    True if it is "no_keep_domain" entry.
- * @is_delete: True if it is a delete request.
- *
- */
-int ccs_write_domain_keeper_policy(char *data, const bool is_not,
-				   const bool is_delete)
-{
-	char *cp = strstr(data, " from ");
-	if (cp) {
-		*cp = '\0';
-		return ccs_update_domain_keeper_entry(cp + 6, data,
-						      is_not, is_delete);
-	}
-	return ccs_update_domain_keeper_entry(data, NULL, is_not, is_delete);
-}
-
-/**
- * ccs_read_domain_keeper_policy - Read "struct ccs_domain_keeper_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_domain_keeper_list) {
-		struct ccs_domain_keeper_entry *ptr;
-		const char *no;
-		const char *from = "";
-		const char *program = "";
-		ptr = list_entry(pos, struct ccs_domain_keeper_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		no = ptr->is_not ? "no_" : "";
-		if (ptr->program) {
-			from = " from ";
-			program = ptr->program->name;
-		}
-		done = ccs_io_printf(head, "%s" CCS_KEYWORD_KEEP_DOMAIN
-				     "%s%s%s\n", no, program, from,
-				     ptr->domainname->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
  * ccs_is_domain_keeper - Check whether the given program causes domain transition suppression.
  *
  * @domainname: The name of domain.
@@ -389,97 +158,6 @@
 /* The list for "struct ccs_aggregator_entry". */
 LIST_HEAD(ccs_aggregator_list);
 
-/**
- * ccs_update_aggregator_entry - Update "struct ccs_aggregator_entry" list.
- *
- * @original_name:   The original program's name.
- * @aggregated_name: The aggregated program's name.
- * @is_delete:       True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_aggregator_entry(const char *original_name,
-				       const char *aggregated_name,
-				       const bool is_delete)
-{
-	struct ccs_aggregator_entry *entry = NULL;
-	struct ccs_aggregator_entry *ptr;
-	struct ccs_aggregator_entry e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(original_name, 1, 0, -1) ||
-	    !ccs_is_correct_path(aggregated_name, 1, -1, -1))
-		return -EINVAL;
-	e.original_name = ccs_get_name(original_name);
-	e.aggregated_name = ccs_get_name(aggregated_name);
-	if (!e.original_name || !e.aggregated_name)
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_aggregator_list, list) {
-		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), original_name),
-			       sizeof(e)))
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_aggregator_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.original_name);
-	ccs_put_name(e.aggregated_name);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_aggregator_policy - Read "struct ccs_aggregator_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_aggregator_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2, &ccs_aggregator_list) {
-		struct ccs_aggregator_entry *ptr;
-		ptr = list_entry(pos, struct ccs_aggregator_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_AGGREGATOR "%s %s\n",
-				     ptr->original_name->name,
-				     ptr->aggregated_name->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
- * ccs_write_aggregator_policy - Write "struct ccs_aggregator_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_aggregator_policy(char *data, const bool is_delete)
-{
-	char *w[2];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	return ccs_update_aggregator_entry(w[0], w[1], is_delete);
-}
-
 /* Domain create/delete handler. */
 
 /**
@@ -813,7 +491,7 @@
  *
  * Returns number of directories to strip.
  */
-static inline int ccs_root_depth(struct dentry *dentry, struct vfsmount *vfsmnt)
+static int ccs_root_depth(struct dentry *dentry, struct vfsmount *vfsmnt)
 {
 	int depth = 0;
 	ccs_realpath_lock();
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/memory.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/memory.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/memory.c	(working copy)
@@ -206,7 +206,7 @@
 			char *cp2 = strchr(cp, ' ');
 			if (cp2)
 				*cp2++ = '\0';
-			ccs_write_domain_initializer_policy(cp, false, false);
+			//ccs_write_domain_initializer_policy(cp, false, false);
 			cp = cp2;
 		}
 	}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/path_group.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/path_group.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/path_group.c	(working copy)
@@ -15,130 +15,6 @@
 LIST_HEAD(ccs_path_group_list);
 
 /**
- * ccs_get_path_group - Allocate memory for "struct ccs_path_group".
- *
- * @group_name: The name of pathname group.
- *
- * Returns pointer to "struct ccs_path_group" on success, NULL otherwise.
- */
-struct ccs_path_group *ccs_get_path_group(const char *group_name)
-{
-	struct ccs_path_group *entry = NULL;
-	struct ccs_path_group *group;
-	const struct ccs_path_info *saved_group_name;
-	int error = -ENOMEM;
-	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
-	    !group_name[0])
-		return NULL;
-	saved_group_name = ccs_get_name(group_name);
-	if (!saved_group_name)
-		return NULL;
-	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(group, &ccs_path_group_list, list) {
-		if (saved_group_name != group->group_name)
-			continue;
-		atomic_inc(&group->users);
-		error = 0;
-		break;
-	}
-	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
-		INIT_LIST_HEAD(&entry->member_list);
-		entry->group_name = saved_group_name;
-		saved_group_name = NULL;
-		atomic_set(&entry->users, 1);
-		list_add_tail_rcu(&entry->list, &ccs_path_group_list);
-		group = entry;
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(saved_group_name);
-	kfree(entry);
-	return !error ? group : NULL;
-}
-
-/**
- * ccs_write_path_group_policy - Write "struct ccs_path_group" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, nagative value otherwise.
- */
-int ccs_write_path_group_policy(char *data, const bool is_delete)
-{
-	struct ccs_path_group *group;
-	struct ccs_path_group_member *entry = NULL;
-	struct ccs_path_group_member *member;
-	struct ccs_path_group_member e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	char *w[2];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	group = ccs_get_path_group(w[0]);
-	if (!group)
-		return -ENOMEM;
-	e.member_name = ccs_get_name(w[1]);
-	if (!e.member_name)
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(member, &group->member_list, list) {
-		if (member->member_name != e.member_name)
-			continue;
-		member->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &group->member_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.member_name);
-	ccs_put_path_group(group);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_path_group_policy - Read "struct ccs_path_group" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_path_group_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *gpos;
-	struct list_head *mpos;
-	list_for_each_cookie(gpos, head->read_var1, &ccs_path_group_list) {
-		struct ccs_path_group *group;
-		group = list_entry(gpos, struct ccs_path_group, list);
-		list_for_each_cookie(mpos, head->read_var2,
-				     &group->member_list) {
-			struct ccs_path_group_member *member;
-			member = list_entry(mpos, struct ccs_path_group_member,
-					    list);
-			if (member->is_deleted)
-				continue;
-			if (!ccs_io_printf(head, CCS_KEYWORD_PATH_GROUP
-					   "%s %s\n",
-					   group->group_name->name,
-					   member->member_name->name))
-				return false;
-		}
-	}
-	return true;
-}
-
-/**
  * ccs_path_matches_group - Check whether the given pathname matches members of the given pathname group.
  *
  * @pathname:        The name of pathname.
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/signal.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/signal.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/signal.c	(working copy)
@@ -137,58 +137,6 @@
 }
 
 /**
- * ccs_write_signal_policy - Write "struct ccs_signal_acl" list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_signal_policy(char *data, struct ccs_domain_info *domain,
-			    struct ccs_condition *condition,
-			    const bool is_delete)
-{
-	struct ccs_signal_acl *entry = NULL;
-	struct ccs_acl_info *ptr;
-	struct ccs_signal_acl e = { .head.type = CCS_TYPE_SIGNAL_ACL,
-				    .head.cond = condition };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	int sig;
-	char *domainname = strchr(data, ' ');
-	if (sscanf(data, "%d", &sig) != 1 || !domainname ||
-	    !ccs_is_correct_domain(domainname + 1))
-		return -EINVAL;
-	e.sig = sig;
-	e.domainname = ccs_get_name(domainname + 1);
-	if (!e.domainname)
-		return -ENOMEM;
-	if (!is_delete)
-		entry = kmalloc(sizeof(*entry), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_signal_acl *acl =
-			container_of(ptr, struct ccs_signal_acl, head);
-		if (ptr->type != CCS_TYPE_SIGNAL_ACL || ptr->cond != condition
-		    || acl->sig != sig || acl->domainname != e.domainname)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.domainname);
-	kfree(entry);
-	return error;
-}
-
-/**
  * ccs_kill_permission - Permission check for kill().
  *
  * @pid: PID
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/util.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/util.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/util.c	(working copy)
@@ -19,8 +19,7 @@
 bool ccs_policy_loaded;
 
 /* Index table for searching parent category. */
-static const u8 ccs_index2category[CCS_MAX_MAC_INDEX +
-				   CCS_MAX_CAPABILITY_INDEX] = {
+const u8 ccs_index2category[CCS_MAX_MAC_INDEX + CCS_MAX_CAPABILITY_INDEX] = {
 	[CCS_MAC_FILE_EXECUTE]    = CCS_MAC_CATEGORY_FILE,
 	[CCS_MAC_FILE_OPEN]       = CCS_MAC_CATEGORY_FILE,
 	[CCS_MAC_FILE_CREATE]     = CCS_MAC_CATEGORY_FILE,
@@ -123,138 +122,13 @@
 /* Utility functions. */
 
 /**
- * ccs_parse_ulong - Parse an "unsigned long" value.
- *
- * @result: Pointer to "unsigned long".
- * @str:    Pointer to string to parse.
- *
- * Returns value type on success, 0 otherwise.
- *
- * The @src is updated to point the first character after the value
- * on success.
- */
-u8 ccs_parse_ulong(unsigned long *result, char **str)
-{
-	const char *cp = *str;
-	char *ep;
-	int base = 10;
-	if (*cp == '0') {
-		char c = *(cp + 1);
-		if (c == 'x' || c == 'X') {
-			base = 16;
-			cp += 2;
-		} else if (c >= '0' && c <= '7') {
-			base = 8;
-			cp++;
-		}
-	}
-	*result = simple_strtoul(cp, &ep, base);
-	if (cp == ep)
-		return 0;
-	*str = ep;
-	switch (base) {
-	case 16:
-		return CCS_VALUE_TYPE_HEXADECIMAL;
-	case 8:
-		return CCS_VALUE_TYPE_OCTAL;
-	default:
-		return CCS_VALUE_TYPE_DECIMAL;
-	}
-}
-
-/**
- * ccs_print_ulong - Print an "unsigned long" value.
- *
- * @buffer:     Pointer to buffer.
- * @buffer_len: Size of @buffer.
- * @value:      An "unsigned long" value.
- * @type:       Type of @value.
- *
- * Returns nothing.
- */
-void ccs_print_ulong(char *buffer, const int buffer_len,
-		     const unsigned long value, const u8 type)
-{
-	if (type == CCS_VALUE_TYPE_DECIMAL)
-		snprintf(buffer, buffer_len, "%lu", value);
-	else if (type == CCS_VALUE_TYPE_OCTAL)
-		snprintf(buffer, buffer_len, "0%lo", value);
-	else if (type == CCS_VALUE_TYPE_HEXADECIMAL)
-		snprintf(buffer, buffer_len, "0x%lX", value);
-	else
-		snprintf(buffer, buffer_len, "type(%u)", type);
-}
-
-/**
- * ccs_parse_name_union - Parse a ccs_name_union.
- *
- * @filename: Name or name group.
- * @ptr:      Pointer to "struct ccs_name_union".
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr)
-{
-	if (!ccs_is_correct_path(filename, 0, 0, 0))
-		return false;
-	if (filename[0] == '@') {
-		ptr->group = ccs_get_path_group(filename + 1);
-		ptr->is_group = true;
-		return ptr->group != NULL;
-	}
-	ptr->filename = ccs_get_name(filename);
-	ptr->is_group = false;
-	return ptr->filename != NULL;
-}
-
-/**
- * ccs_parse_number_union - Parse a ccs_number_union.
- *
- * @data: Number or number range or number group.
- * @ptr:  Pointer to "struct ccs_number_union".
- *
- * Returns true on success, false otherwise.
- */
-bool ccs_parse_number_union(char *data, struct ccs_number_union *num)
-{
-	u8 type;
-	unsigned long v;
-	memset(num, 0, sizeof(*num));
-	if (data[0] == '@') {
-		if (!ccs_is_correct_path(data, 0, 0, 0))
-			return false;
-		num->group = ccs_get_number_group(data + 1);
-		num->is_group = true;
-		return num->group != NULL;
-	}
-	type = ccs_parse_ulong(&v, &data);
-	if (!type)
-		return false;
-	num->values[0] = v;
-	num->min_type = type;
-	if (!*data) {
-		num->values[1] = v;
-		num->max_type = type;
-		return true;
-	}
-	if (*data++ != '-')
-		return false;
-	type = ccs_parse_ulong(&v, &data);
-	if (!type || *data)
-		return false;
-	num->values[1] = v;
-	num->max_type = type;
-	return true;
-}
-
-/**
  * ccs_is_byte_range - Check whether the string isa \ooo style octal value.
  *
  * @str: Pointer to the string.
  *
  * Returns true if @str is a \ooo style octal value, false otherwise.
  */
-static inline bool ccs_is_byte_range(const char *str)
+static bool ccs_is_byte_range(const char *str)
 {
 	return *str >= '0' && *str++ <= '3' &&
 		*str >= '0' && *str++ <= '7' &&
@@ -268,7 +142,7 @@
  *
  * Returns true if @c is a decimal character, false otherwise.
  */
-static inline bool ccs_is_decimal(const char c)
+static bool ccs_is_decimal(const char c)
 {
 	return c >= '0' && c <= '9';
 }
@@ -280,7 +154,7 @@
  *
  * Returns true if @c is a hexadecimal character, false otherwise.
  */
-static inline bool ccs_is_hexadecimal(const char c)
+static bool ccs_is_hexadecimal(const char c)
 {
 	return (c >= '0' && c <= '9') ||
 		(c >= 'A' && c <= 'F') ||
@@ -294,7 +168,7 @@
  *
  * Returns true if @c is an alphabet character, false otherwise.
  */
-static inline bool ccs_is_alphabet_char(const char c)
+static bool ccs_is_alphabet_char(const char c)
 {
 	return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');
 }
@@ -308,7 +182,7 @@
  *
  * Returns byte value.
  */
-static inline u8 ccs_make_byte(const u8 c1, const u8 c2, const u8 c3)
+static u8 ccs_make_byte(const u8 c1, const u8 c2, const u8 c3)
 {
 	return ((c1 - '0') << 6) + ((c2 - '0') << 3) + (c3 - '0');
 }
@@ -957,32 +831,6 @@
 }
 
 /**
- * ccs_get_audit - Get audit mode.
- *
- * @profile:    Profile number.
- * @index:      Index number of functionality.
- * @is_granted: True if granted log, false otherwise.
- *
- * Returns mode.
- */
-bool ccs_get_audit(const u8 profile, const u8 index, const bool is_granted)
-{
-	u8 mode;
-	const u8 category = ccs_index2category[index] + CCS_MAX_MAC_INDEX
-		+ CCS_MAX_CAPABILITY_INDEX;
-	if (!ccs_policy_loaded)
-		return false;
-	mode = ccs_profile(profile)->config[index];
-	if (mode == CCS_CONFIG_USE_DEFAULT)
-		mode = ccs_profile(profile)->config[category];
-	if (mode == CCS_CONFIG_USE_DEFAULT)
-		mode = ccs_profile(profile)->default_config;
-	if (is_granted)
-		return mode & CCS_CONFIG_WANT_GRANT_LOG;
-	return mode & CCS_CONFIG_WANT_REJECT_LOG;
-}
-
-/**
  * ccs_get_mode - Get MAC mode.
  *
  * @profile: Profile number.
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/file.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/file.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/file.c	(working copy)
@@ -30,43 +30,6 @@
 #define ACC_MODE(x) ("\000\004\002\006"[(x)&O_ACCMODE])
 #endif
 
-static const char *ccs_path_keyword[CCS_MAX_PATH_OPERATION] = {
-	[CCS_TYPE_READ_WRITE] = "read/write",
-	[CCS_TYPE_EXECUTE]    = "execute",
-	[CCS_TYPE_READ]       = "read",
-	[CCS_TYPE_WRITE]      = "write",
-	[CCS_TYPE_UNLINK]     = "unlink",
-	[CCS_TYPE_RMDIR]      = "rmdir",
-	[CCS_TYPE_TRUNCATE]   = "truncate",
-	[CCS_TYPE_SYMLINK]    = "symlink",
-	[CCS_TYPE_REWRITE]    = "rewrite",
-	[CCS_TYPE_CHROOT]     = "chroot",
-	[CCS_TYPE_UMOUNT]     = "unmount",
-	[CCS_TYPE_TRANSIT]    = "transit",
-};
-
-static const char *ccs_path_number3_keyword[CCS_MAX_PATH_NUMBER3_OPERATION] = {
-	[CCS_TYPE_MKBLOCK]    = "mkblock",
-	[CCS_TYPE_MKCHAR]     = "mkchar",
-};
-
-static const char *ccs_path2_keyword[CCS_MAX_PATH2_OPERATION] = {
-	[CCS_TYPE_LINK]       = "link",
-	[CCS_TYPE_RENAME]     = "rename",
-	[CCS_TYPE_PIVOT_ROOT] = "pivot_root",
-};
-
-static const char *ccs_path_number_keyword[CCS_MAX_PATH_NUMBER_OPERATION] = {
-	[CCS_TYPE_CREATE] = "create",
-	[CCS_TYPE_MKDIR]  = "mkdir",
-	[CCS_TYPE_MKFIFO] = "mkfifo",
-	[CCS_TYPE_MKSOCK] = "mksock",
-	[CCS_TYPE_IOCTL]  = "ioctl",
-	[CCS_TYPE_CHMOD]  = "chmod",
-	[CCS_TYPE_CHOWN]  = "chown",
-	[CCS_TYPE_CHGRP]  = "chgrp",
-};
-
 static const u8 ccs_p2mac[CCS_MAX_PATH_OPERATION] = {
 	[CCS_TYPE_READ_WRITE] = CCS_MAC_FILE_OPEN,
 	[CCS_TYPE_EXECUTE]    = CCS_MAC_FILE_EXECUTE,
@@ -104,6 +67,29 @@
 	[CCS_TYPE_CHGRP]  = CCS_MAC_FILE_CHGRP,
 };
 
+/**
+ * ccs_print_ulong - Print an "unsigned long" value.
+ *
+ * @buffer:     Pointer to buffer.
+ * @buffer_len: Size of @buffer.
+ * @value:      An "unsigned long" value.
+ * @type:       Type of @value.
+ *
+ * Returns nothing.
+ */
+static void ccs_print_ulong(char *buffer, const int buffer_len,
+			    const unsigned long value, const u8 type)
+{
+	if (type == CCS_VALUE_TYPE_DECIMAL)
+		snprintf(buffer, buffer_len, "%lu", value);
+	else if (type == CCS_VALUE_TYPE_OCTAL)
+		snprintf(buffer, buffer_len, "0%lo", value);
+	else if (type == CCS_VALUE_TYPE_HEXADECIMAL)
+		snprintf(buffer, buffer_len, "0x%lX", value);
+	else
+		snprintf(buffer, buffer_len, "type(%u)", type);
+}
+
 /*
  * Below part contains copy of some of VFS helper functions.
  *
@@ -119,7 +105,7 @@
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
 
 /* Permission checks from vfs_create(). */
-static inline int ccs_pre_vfs_create(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_create(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	down(&dir->i_zombie);
@@ -143,7 +129,7 @@
 }
 
 /* Permission checks from vfs_mkdir(). */
-static inline int ccs_pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	down(&dir->i_zombie);
@@ -155,7 +141,7 @@
 }
 
 /* Permission checks from vfs_rmdir(). */
-static inline int ccs_pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_delete(dir, dentry, 1);
 	if (!error && (!dir->i_op || !dir->i_op->rmdir))
@@ -164,7 +150,7 @@
 }
 
 /* Permission checks from vfs_unlink(). */
-static inline int ccs_pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 33)
 	int error;
@@ -193,7 +179,7 @@
 }
 
 /* Permission checks from vfs_symlink(). */
-static inline int ccs_pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
 {
 	int error;
 	down(&dir->i_zombie);
@@ -208,9 +194,8 @@
 }
 
 /* Permission checks from vfs_link(). */
-static inline int ccs_pre_vfs_link(struct dentry *old_dentry,
-				   struct inode *dir,
-				   struct dentry *new_dentry)
+static int ccs_pre_vfs_link(struct dentry *old_dentry, struct inode *dir,
+			    struct dentry *new_dentry)
 {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 33)
 	struct inode *inode;
@@ -263,10 +248,10 @@
 }
 
 /* Permission checks from vfs_rename_dir(). */
-static inline int ccs_pre_vfs_rename_dir(struct inode *old_dir,
-					 struct dentry *old_dentry,
-					 struct inode *new_dir,
-					 struct dentry *new_dentry)
+static int ccs_pre_vfs_rename_dir(struct inode *old_dir,
+				  struct dentry *old_dentry,
+				  struct inode *new_dir,
+				  struct dentry *new_dentry)
 {
 	int error;
 	if (old_dentry->d_inode == new_dentry->d_inode)
@@ -290,10 +275,10 @@
 }
 
 /* Permission checks from vfs_rename_other(). */
-static inline int ccs_pre_vfs_rename_other(struct inode *old_dir,
-					   struct dentry *old_dentry,
-					   struct inode *new_dir,
-					   struct dentry *new_dentry)
+static int ccs_pre_vfs_rename_other(struct inode *old_dir,
+				    struct dentry *old_dentry,
+				    struct inode *new_dir,
+				    struct dentry *new_dentry)
 {
 	int error;
 	if (old_dentry->d_inode == new_dentry->d_inode)
@@ -315,10 +300,8 @@
 }
 
 /* Permission checks from vfs_rename(). */
-static inline int ccs_pre_vfs_rename(struct inode *old_dir,
-				     struct dentry *old_dentry,
-				     struct inode *new_dir,
-				     struct dentry *new_dentry)
+static int ccs_pre_vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			      struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error;
 	lock_kernel(); /* From do_rename(). */
@@ -335,7 +318,7 @@
 #else
 
 /* Permission checks from vfs_create(). */
-static inline int ccs_pre_vfs_create(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_create(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_create(dir, dentry, 0);
 	if (error)
@@ -357,7 +340,7 @@
 }
 
 /* Permission checks from vfs_mkdir(). */
-static inline int ccs_pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_mkdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_create(dir, dentry, 1);
 	if (error)
@@ -368,7 +351,7 @@
 }
 
 /* Permission checks from vfs_rmdir(). */
-static inline int ccs_pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_rmdir(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_delete(dir, dentry, 1);
 	if (error)
@@ -379,7 +362,7 @@
 }
 
 /* Permission checks from vfs_unlink(). */
-static inline int ccs_pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_unlink(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_delete(dir, dentry, 0);
 	if (error)
@@ -390,9 +373,8 @@
 }
 
 /* Permission checks from vfs_link(). */
-static inline int ccs_pre_vfs_link(struct dentry *old_dentry,
-				   struct inode *dir,
-				   struct dentry *new_dentry)
+static int ccs_pre_vfs_link(struct dentry *old_dentry, struct inode *dir,
+			    struct dentry *new_dentry)
 {
 	struct inode *inode = old_dentry->d_inode;
 	int error;
@@ -413,7 +395,7 @@
 }
 
 /* Permission checks from vfs_symlink(). */
-static inline int ccs_pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
+static int ccs_pre_vfs_symlink(struct inode *dir, struct dentry *dentry)
 {
 	int error = ccs_may_create(dir, dentry, 0);
 	if (error)
@@ -424,10 +406,8 @@
 }
 
 /* Permission checks from vfs_rename(). */
-static inline int ccs_pre_vfs_rename(struct inode *old_dir,
-				     struct dentry *old_dentry,
-				     struct inode *new_dir,
-				     struct dentry *new_dentry)
+static int ccs_pre_vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			      struct inode *new_dir, struct dentry *new_dentry)
 {
 	int error;
 	const int is_dir = S_ISDIR(old_dentry->d_inode->i_mode);
@@ -458,22 +438,6 @@
 
 /* Main functions. */
 
-void ccs_put_name_union(struct ccs_name_union *ptr)
-{
-	if (!ptr)
-		return;
-	if (ptr->is_group)
-		ccs_put_path_group(ptr->group);
-	else
-		ccs_put_name(ptr->filename);
-}
-
-void ccs_put_number_union(struct ccs_number_union *ptr)
-{
-	if (ptr && ptr->is_group)
-		ccs_put_number_group(ptr->group);
-}
-
 bool ccs_compare_number_union(const unsigned long value,
 			      const struct ccs_number_union *ptr)
 {
@@ -502,58 +466,6 @@
 	return false;
 }
 
-/**
- * ccs_path2keyword - Get the name of path operations.
- *
- * @operation: Type of operation.
- *
- * Returns the name of path operation.
- */
-const char *ccs_path2keyword(const u8 operation)
-{
-	return (operation < CCS_MAX_PATH_OPERATION)
-		? ccs_path_keyword[operation] : NULL;
-}
-
-/**
- * ccs_path_number32keyword - Get the name of path/number/number/number operations.
- *
- * @operation: Type of operation.
- *
- * Returns the name of path/number/number/number operation.
- */
-const char *ccs_path_number32keyword(const u8 operation)
-{
-	return (operation < CCS_MAX_PATH_NUMBER3_OPERATION)
-		? ccs_path_number3_keyword[operation] : NULL;
-}
-
-/**
- * ccs_path22keyword - Get the name of path/path operations.
- *
- * @operation: Type of operation.
- *
- * Returns the name of path/path operation.
- */
-const char *ccs_path22keyword(const u8 operation)
-{
-	return (operation < CCS_MAX_PATH2_OPERATION)
-		? ccs_path2_keyword[operation] : NULL;
-}
-
-/**
- * ccs_path_number2keyword - Get the name of path/number operations.
- *
- * @operation: Type of operation.
- *
- * Returns the name of path/number operation.
- */
-const char *ccs_path_number2keyword(const u8 operation)
-{
-	return (operation < CCS_MAX_PATH_NUMBER_OPERATION)
-		? ccs_path_number_keyword[operation] : NULL;
-}
-
 static void ccs_add_slash(struct ccs_path_info *buf)
 {
 	if (buf->is_dir)
@@ -571,7 +483,7 @@
  *
  * Returns true if @name ends with @tail, false otherwise.
  */
-static bool ccs_strendswith(const char *name, const char *tail)
+bool ccs_strendswith(const char *name, const char *tail)
 {
 	int len;
 	if (!name || !tail)
@@ -601,11 +513,6 @@
 	return false;
 }
 
-static int ccs_update_path_acl(const u8 type, const char *filename,
-			       struct ccs_domain_info * const domain,
-			       struct ccs_condition *condition,
-			       const bool is_delete);
-
 /**
  * ccs_audit_path_log - Audit path request log.
  *
@@ -723,74 +630,6 @@
 	return found;
 }
 
-/**
- * ccs_write_globally_readable_policy - Write "struct ccs_globally_readable_file_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_globally_readable_policy(char *data, const bool is_delete)
-{
-	struct ccs_globally_readable_file_entry *entry = NULL;
-	struct ccs_globally_readable_file_entry *ptr;
-	struct ccs_globally_readable_file_entry e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(data, 1, 0, -1))
-		return -EINVAL;
-	e.filename = ccs_get_name(data);
-	if (!e.filename)
-		return -ENOMEM;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_globally_readable_list, list) {
-		if (ptr->filename != e.filename)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_globally_readable_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.filename);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_globally_readable_policy - Read "struct ccs_globally_readable_file_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_globally_readable_list) {
-		struct ccs_globally_readable_file_entry *ptr;
-		ptr = list_entry(pos, struct ccs_globally_readable_file_entry,
-				 list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_READ "%s\n",
-				     ptr->filename->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
 /* The list for "struct ccs_pattern_entry". */
 LIST_HEAD(ccs_pattern_list);
 
@@ -823,72 +662,6 @@
 	return pattern ? pattern->name : filename->name;
 }
 
-/**
- * ccs_write_pattern_policy - Write "struct ccs_pattern_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_pattern_policy(char *data, const bool is_delete)
-{
-	struct ccs_pattern_entry *entry = NULL;
-	struct ccs_pattern_entry *ptr;
-	struct ccs_pattern_entry e = { .pattern = ccs_get_name(data) };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!e.pattern)
-		return error;
-	if (!e.pattern->is_patterned)
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_pattern_list, list) {
-		if (e.pattern != ptr->pattern)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_pattern_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name(e.pattern);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_file_pattern - Read "struct ccs_pattern_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_file_pattern(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2, &ccs_pattern_list) {
-		struct ccs_pattern_entry *ptr;
-		ptr = list_entry(pos, struct ccs_pattern_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_FILE_PATTERN "%s\n",
-				     ptr->pattern->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
 /* The list for "struct ccs_no_rewrite_entry". */
 LIST_HEAD(ccs_no_rewrite_list);
 
@@ -918,113 +691,6 @@
 }
 
 /**
- * ccs_write_no_rewrite_policy - Write "struct ccs_no_rewrite_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_no_rewrite_policy(char *data, const bool is_delete)
-{
-	struct ccs_no_rewrite_entry *entry = NULL;
-	struct ccs_no_rewrite_entry *ptr;
-	struct ccs_no_rewrite_entry e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(data, 0, 0, 0))
-		return -EINVAL;
-	e.pattern = ccs_get_name(data);
-	if (!e.pattern)
-		return error;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_no_rewrite_list, list) {
-		if (ptr->pattern != e.pattern)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_no_rewrite_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.pattern);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_no_rewrite_policy - Read "struct ccs_no_rewrite_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns true on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2, &ccs_no_rewrite_list) {
-		struct ccs_no_rewrite_entry *ptr;
-		ptr = list_entry(pos, struct ccs_no_rewrite_entry, list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_DENY_REWRITE "%s\n",
-				     ptr->pattern->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
- * ccs_update_file_acl - Update file's read/write/execute ACL.
- *
- * @perm:      Permission (between 1 to 7).
- * @filename:  Filename.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- *
- * This is legacy support interface for older policy syntax.
- * Current policy syntax uses "allow_read/write" instead of "6",
- * "allow_read" instead of "4", "allow_write" instead of "2",
- * "allow_execute" instead of "1".
- */
-static inline int ccs_update_file_acl(u8 perm, const char *filename,
-				      struct ccs_domain_info * const domain,
-				      struct ccs_condition *condition,
-				      const bool is_delete)
-{
-	if (perm > 7 || !perm)
-		return -EINVAL;
-	if (filename[0] != '@' && ccs_strendswith(filename, "/"))
-		/*
-		 * Only 'allow_mkdir' and 'allow_rmdir' are valid for
-		 * directory permissions.
-		 */
-		return 0;
-	if (perm & 4)
-		ccs_update_path_acl(CCS_TYPE_READ, filename, domain,
-				    condition, is_delete);
-	if (perm & 2)
-		ccs_update_path_acl(CCS_TYPE_WRITE, filename,
-				    domain, condition, is_delete);
-	if (perm & 1)
-		ccs_update_path_acl(CCS_TYPE_EXECUTE, filename,
-				    domain, condition, is_delete);
-	return 0;
-}
-
-/**
  * ccs_path_acl - Check permission for path operation.
  *
  * @r:               Pointer to "struct ccs_request_info".
@@ -1159,288 +825,6 @@
 }
 
 /**
- * ccs_update_execute_handler - Update "struct ccs_execute_handler_record" list.
- *
- * @type:      Type of execute handler.
- * @filename:  Pathname to the execute handler.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static inline int ccs_update_execute_handler(const u8 type,
-					     const char *filename,
-					     struct ccs_domain_info * const
-					     domain, const bool is_delete)
-{
-	struct ccs_acl_info *ptr;
-	struct ccs_execute_handler_record e = { .head.type = type };
-	struct ccs_execute_handler_record *entry = NULL;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!domain)
-		return -EINVAL;
-	if (!ccs_is_correct_path(filename, 1, -1, -1))
-		return -EINVAL;
-	e.handler = ccs_get_name(filename);
-	if (!e.handler)
-		return -ENOMEM;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_execute_handler_record *acl;
-		if (ptr->type != type)
-			continue;
-		/* Condition not supported. */
-		acl = container_of(ptr, struct ccs_execute_handler_record,
-				   head);
-		if (acl->handler != e.handler)
-			continue;
-		if (!is_delete) {
-			/* Only one entry can exist in a domain. */
-			struct ccs_acl_info *ptr2;
-			list_for_each_entry_rcu(ptr2, &domain->acl_info_list,
-						list) {
-				if (ptr2->type == type)
-					ptr2->is_deleted = true;
-			}
-		}
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		/* Only one entry can exist in a domain. */
-		list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-			if (ptr->type == type)
-				ptr->is_deleted = true;
-		}
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.handler);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_update_path_acl - Update "struct ccs_path_acl" list.
- *
- * @type:      Type of operation.
- * @filename:  Filename.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_path_acl(const u8 type, const char *filename,
-			       struct ccs_domain_info * const domain,
-			       struct ccs_condition *condition,
-			       const bool is_delete)
-{
-	static const u16 ccs_rw_mask =
-		(1 << CCS_TYPE_READ) | (1 << CCS_TYPE_WRITE);
-	const u16 perm = 1 << type;
-	struct ccs_acl_info *ptr;
-	struct ccs_path_acl e = {
-		.head.type = CCS_TYPE_PATH_ACL,
-		.head.cond = condition,
-		.perm = perm
-	};
-	struct ccs_path_acl *entry = NULL;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (type == CCS_TYPE_READ_WRITE)
-		e.perm |= ccs_rw_mask;
-	if (!ccs_parse_name_union(filename, &e.name))
-		return -EINVAL;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path_acl *acl =
-			container_of(ptr, struct ccs_path_acl, head);
-		if (ptr->type != CCS_TYPE_PATH_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if ((acl->perm & ccs_rw_mask) != ccs_rw_mask)
-				acl->perm &= ~(1 << CCS_TYPE_READ_WRITE);
-			else if (!(acl->perm & (1 << CCS_TYPE_READ_WRITE)))
-				acl->perm &= ~ccs_rw_mask;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			if ((acl->perm & ccs_rw_mask) == ccs_rw_mask)
-				acl->perm |= 1 << CCS_TYPE_READ_WRITE;
-			else if (acl->perm & (1 << CCS_TYPE_READ_WRITE))
-				acl->perm |= ccs_rw_mask;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name_union(&e.name);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_update_path_number3_acl - Update "struct ccs_path_number3_acl" list.
- *
- * @type:      Type of operation.
- * @filename:  Filename.
- * @mode:      Create mode.
- * @major:     Device major number.
- * @minor:     Device minor number.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static inline int ccs_update_path_number3_acl(const u8 type,
-					      const char *filename, char *mode,
-					      char *major, char *minor,
-					      struct ccs_domain_info * const
-					      domain,
-					      struct ccs_condition *condition,
-					      const bool is_delete)
-{
-	const u8 perm = 1 << type;
-	struct ccs_acl_info *ptr;
-	struct ccs_path_number3_acl e = {
-		.head.type = CCS_TYPE_PATH_NUMBER3_ACL,
-		.head.cond = condition,
-		.perm = perm
-	};
-	struct ccs_path_number3_acl *entry = NULL;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_parse_name_union(filename, &e.name) ||
-	    !ccs_parse_number_union(mode, &e.mode) ||
-	    !ccs_parse_number_union(major, &e.major) ||
-	    !ccs_parse_number_union(minor, &e.minor))
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path_number3_acl *acl =
-			container_of(ptr, struct ccs_path_number3_acl, head);
-		if (ptr->type != CCS_TYPE_PATH_NUMBER3_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name_union(&e.name);
-	ccs_put_number_union(&e.mode);
-	ccs_put_number_union(&e.major);
-	ccs_put_number_union(&e.minor);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_update_path2_acl - Update "struct ccs_path2_acl" list.
- *
- * @type:      Type of operation.
- * @filename1: First filename.
- * @filename2: Second filename.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static inline int ccs_update_path2_acl(const u8 type,
-				       const char *filename1,
-				       const char *filename2,
-				       struct ccs_domain_info * const
-				       domain,
-				       struct ccs_condition *condition,
-				       const bool is_delete)
-{
-	const u8 perm = 1 << type;
-	struct ccs_acl_info *ptr;
-	struct ccs_path2_acl e = {
-		.head.type = CCS_TYPE_PATH2_ACL,
-		.head.cond = condition,
-		.perm = perm
-	};
-	struct ccs_path2_acl *entry = NULL;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_parse_name_union(filename1, &e.name1) ||
-	    !ccs_parse_name_union(filename2, &e.name2))
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path2_acl *acl =
-			container_of(ptr, struct ccs_path2_acl, head);
-		if (ptr->type != CCS_TYPE_PATH2_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name1), sizeof(e)))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name_union(&e.name1);
-	ccs_put_name_union(&e.name2);
-	kfree(entry);
-	return error;
-}
-
-/**
  * ccs_path2_acl - Check permission for path/path operation.
  *
  * @r:         Pointer to "struct ccs_request_info".
@@ -1955,77 +1339,6 @@
 }
 
 /**
- * ccs_update_path_number_acl - Update ioctl/chmod/chown/chgrp ACL.
- *
- * @type:      Type of operation.
- * @filename:  Filename.
- * @number:    Number.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-static inline int ccs_update_path_number_acl(const u8 type,
-					     const char *filename,
-					     char *number,
-					     struct ccs_domain_info * const
-					     domain,
-					     struct ccs_condition *condition,
-					     const bool is_delete)
-{
-	const u8 perm = 1 << type;
-	struct ccs_acl_info *ptr;
-	struct ccs_path_number_acl e = {
-		.head.type = CCS_TYPE_PATH_NUMBER_ACL,
-		.head.cond = condition,
-		.perm = perm
-	};
-	struct ccs_path_number_acl *entry = NULL;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!domain)
-		return -EINVAL;
-	if (!ccs_parse_name_union(filename, &e.name))
-		return -EINVAL;
-	if (!ccs_parse_number_union(number, &e.number))
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_path_number_acl *acl =
-			container_of(ptr, struct ccs_path_number_acl, head);
-		if (ptr->type != CCS_TYPE_PATH_NUMBER_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	ccs_put_name_union(&e.name);
-	ccs_put_number_union(&e.number);
-	kfree(entry);
-	return error;
-}
-
-/**
  * ccs_path_number_acl - Check permission for ioctl/chmod/chown/chgrp operation.
  *
  * @r:        Pointer to "struct ccs_request_info".
@@ -2283,72 +1596,6 @@
 	return ccs_path_perm(CCS_TYPE_UMOUNT, NULL, mnt->mnt_root, mnt, NULL);
 }
 
-/**
- * ccs_write_file_policy - Update file related list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_file_policy(char *data, struct ccs_domain_info *domain,
-			  struct ccs_condition *condition,
-			  const bool is_delete)
-{
-	char *w[5];
-	u8 type;
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
-		return -EINVAL;
-	if (strncmp(w[0], "allow_", 6)) {
-		unsigned int perm;
-		if (sscanf(w[0], "%u", &perm) == 1)
-			return ccs_update_file_acl((u8) perm, w[1], domain,
-						   condition, is_delete);
-		if (!strcmp(w[0], CCS_KEYWORD_EXECUTE_HANDLER))
-			type = CCS_TYPE_EXECUTE_HANDLER;
-		else if (!strcmp(w[0], CCS_KEYWORD_DENIED_EXECUTE_HANDLER))
-			type = CCS_TYPE_DENIED_EXECUTE_HANDLER;
-		else
-			goto out;
-		return ccs_update_execute_handler(type, w[1], domain,
-						  is_delete);
-	}
-	w[0] += 6;
-	for (type = 0; type < CCS_MAX_PATH_OPERATION; type++) {
-		if (strcmp(w[0], ccs_path_keyword[type]))
-			continue;
-		return ccs_update_path_acl(type, w[1], domain, condition,
-					   is_delete);
-	}
-	if (!w[2][0])
-		goto out;
-	for (type = 0; type < CCS_MAX_PATH2_OPERATION; type++) {
-		if (strcmp(w[0], ccs_path2_keyword[type]))
-			continue;
-		return ccs_update_path2_acl(type, w[1], w[2], domain,
-					    condition, is_delete);
-	}
-	for (type = 0; type < CCS_MAX_PATH_NUMBER_OPERATION; type++) {
-		if (strcmp(w[0], ccs_path_number_keyword[type]))
-			continue;
-		return ccs_update_path_number_acl(type, w[1], w[2], domain,
-						  condition, is_delete);
-	}
-	if (!w[3][0] || !w[4][0])
-		goto out;
-	for (type = 0; type < CCS_MAX_PATH_NUMBER3_OPERATION; type++) {
-		if (strcmp(w[0], ccs_path_number3_keyword[type]))
-			continue;
-		return ccs_update_path_number3_acl(type, w[1], w[2], w[3],
-						   w[4], domain, condition,
-						   is_delete);
-	}
- out:
-	return -EINVAL;
-}
-
 /*
  * Permission checks from vfs_mknod().
  *
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/environ.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/environ.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/environ.c	(working copy)
@@ -57,74 +57,6 @@
 }
 
 /**
- * ccs_write_globally_usable_env_policy - Write "struct ccs_globally_usable_env_entry" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_globally_usable_env_policy(char *data, const bool is_delete)
-{
-	struct ccs_globally_usable_env_entry *entry = NULL;
-	struct ccs_globally_usable_env_entry e = { };
-	struct ccs_globally_usable_env_entry *ptr;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(data, 0, 0, 0) || strchr(data, '='))
-		return -EINVAL;
-	e.env = ccs_get_name(data);
-	if (!e.env)
-		return error;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_globally_usable_env_list, list) {
-		if (ptr->env != e.env)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		list_add_tail_rcu(&entry->list, &ccs_globally_usable_env_list);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.env);
-	kfree(entry);
-	return error;
-}
-
-/**
- * ccs_read_globally_usable_env_policy - Read "struct ccs_globally_usable_env_entry" list.
- *
- * @head: Pointer to "struct ccs_io_buffer".
- *
- * Returns 0 on success, false otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head)
-{
-	struct list_head *pos;
-	bool done = true;
-	list_for_each_cookie(pos, head->read_var2,
-			     &ccs_globally_usable_env_list) {
-		struct ccs_globally_usable_env_entry *ptr;
-		ptr = list_entry(pos, struct ccs_globally_usable_env_entry,
-				 list);
-		if (ptr->is_deleted)
-			continue;
-		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_ENV "%s\n",
-				     ptr->env->name);
-		if (!done)
-			break;
-	}
-	return done;
-}
-
-/**
  * ccs_env_acl - Check permission for environment variable's name.
  *
  * @r:       Pointer to "struct ccs_request_info".
@@ -184,53 +116,3 @@
 	} while (error == CCS_RETRY_REQUEST);
 	return error;
 }
-
-/**
- * ccs_write_env_policy - Write "struct ccs_env_acl" list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_env_policy(char *data, struct ccs_domain_info *domain,
-			 struct ccs_condition *condition,
-			 const bool is_delete)
-{
-	struct ccs_env_acl *entry = NULL;
-	struct ccs_acl_info *ptr;
-	struct ccs_env_acl e = {
-		.head.type = CCS_TYPE_ENV_ACL,
-		.head.cond = condition
-	};
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	if (!ccs_is_correct_path(data, 0, 0, 0) || strchr(data, '='))
-		return -EINVAL;
-	e.env = ccs_get_name(data);
-	if (!e.env)
-		return error;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_env_acl *acl =
-			container_of(ptr, struct ccs_env_acl, head);
-		if (ptr->type != CCS_TYPE_ENV_ACL || ptr->cond != condition ||
-		    acl->env != e.env)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	ccs_put_name(e.env);
-	kfree(entry);
-	return error;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -858,8 +858,6 @@
 
 /* Prototype definition. */
 
-bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
-			       const struct ccs_address_group *group);
 bool ccs_commit_ok(void *ptr, void *data, const unsigned int size);
 bool ccs_compare_name_union(const struct ccs_path_info *name,
 			    const struct ccs_name_union *ptr);
@@ -869,7 +867,6 @@
 bool ccs_domain_quota_ok(struct ccs_request_info *r);
 bool ccs_dump_page(struct linux_binprm *bprm, unsigned long pos,
 		   struct ccs_page_dump *dump);
-bool ccs_get_audit(const u8 profile, const u8 index, const bool is_granted);
 bool ccs_io_printf(struct ccs_io_buffer *head, const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
 bool ccs_is_correct_domain(const unsigned char *domainname);
@@ -879,27 +876,13 @@
 bool ccs_memory_ok(const void *ptr, const unsigned int size);
 bool ccs_number_matches_group(const unsigned long min, const unsigned long max,
 			      const struct ccs_number_group *group);
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr);
-bool ccs_parse_number_union(char *data, struct ccs_number_union *num);
 bool ccs_path_matches_group(const struct ccs_path_info *pathname,
 			    const struct ccs_path_group *group,
 			    const bool may_use_pattern);
 bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 			      const struct ccs_path_info *pattern);
-bool ccs_print_number_union(struct ccs_io_buffer *head,
-			    const struct ccs_number_union *ptr);
-bool ccs_read_address_group_policy(struct ccs_io_buffer *head);
-bool ccs_read_aggregator_policy(struct ccs_io_buffer *head);
-bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head);
-bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head);
-bool ccs_read_file_pattern(struct ccs_io_buffer *head);
-bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head);
-bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head);
-bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head);
-bool ccs_read_number_group_policy(struct ccs_io_buffer *head);
-bool ccs_read_path_group_policy(struct ccs_io_buffer *head);
-bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head);
 bool ccs_str_starts(char **src, const char *find);
+bool ccs_strendswith(const char *name, const char *tail);
 bool ccs_tokenize(char *buffer, char *w[], size_t size);
 char *ccs_encode(const char *str);
 char *ccs_init_audit_log(int *len, struct ccs_request_info *r);
@@ -926,64 +909,27 @@
 			  struct ccs_domain_info *domain, const u8 index);
 int ccs_may_transit(const char *domainname, const char *pathname);
 int ccs_open_control(const u8 type, struct file *file);
-int ccs_parse_ip_address(char *address, u16 *min, u16 *max);
 int ccs_path_permission(struct ccs_request_info *r, u8 operation,
 			const struct ccs_path_info *filename);
-int ccs_poll_control(struct file *file, poll_table *wait);
 int ccs_poll_audit_log(struct file *file, poll_table *wait);
+int ccs_poll_control(struct file *file, poll_table *wait);
 int ccs_read_control(struct file *file, char __user *buffer,
 		     const int buffer_len);
 int ccs_read_lock(void);
 int ccs_supervisor(struct ccs_request_info *r, const char *fmt, ...)
      __attribute__ ((format(printf, 2, 3)));
 int ccs_symlink_path(const char *pathname, struct ccs_path_info *name);
-int ccs_write_address_group_policy(char *data, const bool is_delete);
-int ccs_write_aggregator_policy(char *data, const bool is_delete);
 int ccs_write_audit_log(const bool is_granted, struct ccs_request_info *r,
 			const char *fmt, ...)
      __attribute__ ((format(printf, 3, 4)));
-int ccs_write_capability_policy(char *data, struct ccs_domain_info *domain,
-				struct ccs_condition *condition,
-				const bool is_delete);
 int ccs_write_control(struct file *file, const char __user *buffer,
 		      const int buffer_len);
-int ccs_write_domain_initializer_policy(char *data, const bool is_not,
-					const bool is_delete);
-int ccs_write_domain_keeper_policy(char *data, const bool is_not,
-				   const bool is_delete);
-int ccs_write_env_policy(char *data, struct ccs_domain_info *domain,
-			 struct ccs_condition *condition,
-			 const bool is_delete);
-int ccs_write_file_policy(char *data, struct ccs_domain_info *domain,
-			  struct ccs_condition *condition,
-			  const bool is_delete);
-int ccs_write_globally_readable_policy(char *data, const bool is_delete);
-int ccs_write_globally_usable_env_policy(char *data, const bool is_delete);
 int ccs_write_memory_quota(struct ccs_io_buffer *head);
-int ccs_write_mount_policy(char *data, struct ccs_domain_info *domain,
-			   struct ccs_condition *condition,
-			   const bool is_delete);
-int ccs_write_network_policy(char *data, struct ccs_domain_info *domain,
-			     struct ccs_condition *condition,
-			     const bool is_delete);
-int ccs_write_no_rewrite_policy(char *data, const bool is_delete);
-int ccs_write_number_group_policy(char *data, const bool is_delete);
-int ccs_write_path_group_policy(char *data, const bool is_delete);
-int ccs_write_pattern_policy(char *data, const bool is_delete);
-int ccs_write_reserved_port_policy(char *data, const bool is_delete);
-int ccs_write_signal_policy(char *data, struct ccs_domain_info *domain,
-			    struct ccs_condition *condition,
-			    const bool is_delete);
 size_t ccs_del_condition(struct ccs_condition *cond);
-struct ccs_address_group *ccs_get_address_group(const char *group_name);
-struct ccs_condition *ccs_get_condition(char * const condition);
 struct ccs_domain_info *ccs_find_domain(const char *domainname);
 struct ccs_domain_info *ccs_find_or_assign_new_domain(const char *domainname,
 						      const u8 profile);
-struct ccs_number_group *ccs_get_number_group(const char *group_name);
-struct ccs_path_group *ccs_get_path_group(const char *group_name);
 struct ccs_profile *ccs_profile(const u8 profile);
-u8 ccs_parse_ulong(unsigned long *result, char **str);
 void ccs_check_profile(void);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
 void ccs_get_attributes(struct ccs_obj_info *obj);
@@ -992,10 +938,6 @@
 void ccs_normalize_line(unsigned char *buffer);
 void ccs_print_ipv6(char *buffer, const int buffer_len,
 		    const struct in6_addr *ip);
-void ccs_print_ulong(char *buffer, const int buffer_len,
-		     const unsigned long value, const u8 type);
-void ccs_put_name_union(struct ccs_name_union *ptr);
-void ccs_put_number_union(struct ccs_number_union *ptr);
 void ccs_read_audit_log(struct ccs_io_buffer *head);
 void ccs_read_memory_counter(struct ccs_io_buffer *head);
 void ccs_read_unlock(const int idx);
@@ -1039,6 +981,9 @@
 extern struct list_head ccs_condition_list;
 extern struct mutex ccs_name_list_lock;
 extern struct list_head ccs_name_list[CCS_MAX_HASH];
+extern u8 ccs_reserved_port_map[8192];
+extern const u8 ccs_index2category[CCS_MAX_MAC_INDEX
+				   + CCS_MAX_CAPABILITY_INDEX];
 
 extern bool ccs_policy_loaded;
 extern struct ccs_domain_info ccs_kernel_domain;
@@ -1201,4 +1146,20 @@
 	}
 }
 
+static inline void ccs_put_name_union(struct ccs_name_union *ptr)
+{
+	if (!ptr)
+		return;
+	if (ptr->is_group)
+		ccs_put_path_group(ptr->group);
+	else
+		ccs_put_name(ptr->filename);
+}
+
+static inline void ccs_put_number_union(struct ccs_number_union *ptr)
+{
+	if (ptr && ptr->is_group)
+		ccs_put_number_group(ptr->group);
+}
+
 #endif
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/capability.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/capability.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/capability.c	(working copy)
@@ -86,57 +86,3 @@
 	ccs_read_unlock(idx);
 	return error;
 }
-
-/**
- * ccs_write_capability_policy - Write "struct ccs_capability_acl" list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_capability_policy(char *data, struct ccs_domain_info *domain,
-				struct ccs_condition *condition,
-				const bool is_delete)
-{
-	struct ccs_capability_acl e = {
-		.head.type = CCS_TYPE_CAPABILITY_ACL,
-		.head.cond = condition,
-	};
-	struct ccs_capability_acl *entry = NULL;
-	struct ccs_acl_info *ptr;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	u8 capability;
-	for (capability = 0; capability < CCS_MAX_CAPABILITY_INDEX;
-	     capability++) {
-		if (strcmp(data, ccs_cap2keyword(capability)))
-			continue;
-		break;
-	}
-	if (capability == CCS_MAX_CAPABILITY_INDEX)
-		return -EINVAL;
-	e.operation = capability;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_capability_acl *acl =
-			container_of(ptr, struct ccs_capability_acl, head);
-		if (ptr->type != CCS_TYPE_CAPABILITY_ACL ||
-		    ptr->cond != condition || acl->operation != capability)
-			continue;
-		ptr->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
-	kfree(entry);
-	return error;
-}
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/condition.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/condition.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/condition.c	(working copy)
@@ -263,141 +263,6 @@
 	return result == match;
 }
 
-static bool ccs_parse_name_union_quoted(char *filename,
-					struct ccs_name_union *ptr)
-{
-	bool result;
-	char *cp = NULL;
-	if (*filename == '"') {
-		cp = filename + strlen(filename) - 1;
-		if (*cp != '"')
-			return false;
-		*cp = '\0';
-		filename++;
-	}
-	result = ccs_parse_name_union(filename, ptr);
-	if (cp)
-		*cp = '"';
-	return result;
-}
-
-/**
- * ccs_get_dqword - ccs_get_name() for a quoted string.
- *
- * @start: String to save.
- *
- * Returns pointer to "struct ccs_path_info" on success, NULL otherwise.
- */
-static const struct ccs_path_info *ccs_get_dqword(char *start)
-{
-	char *cp;
-	if (*start++ != '"')
-		return NULL;
-	cp = start;
-	while (1) {
-		const char c = *cp++;
-		if (!c)
-			return NULL;
-		if (c != '"' || *cp)
-			continue;
-		*(cp - 1) = '\0';
-		break;
-	}
-	if (!ccs_is_correct_path(start, 0, 0, 0))
-		return NULL;
-	return ccs_get_name(start);
-}
-
-/**
- * ccs_parse_argv - Parse an argv[] condition part.
- *
- * @start: String to parse.
- * @argv:  Pointer to "struct ccs_argv_entry".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_argv(char *start, struct ccs_argv_entry *argv)
-{
-	unsigned long index;
-	const struct ccs_path_info *value;
-	bool is_not;
-	char c;
-	if (ccs_parse_ulong(&index, &start) != CCS_VALUE_TYPE_DECIMAL)
-		goto out;
-	if (*start++ != ']')
-		goto out;
-	c = *start++;
-	if (c == '=')
-		is_not = false;
-	else if (c == '!' && *start++ == '=')
-		is_not = true;
-	else
-		goto out;
-	value = ccs_get_dqword(start);
-	if (!value)
-		goto out;
-	argv->index = index;
-	argv->is_not = is_not;
-	argv->value = value;
-	return true;
- out:
-	return false;
-}
-
-/**
- * ccs_parse_envp - Parse an envp[] condition part.
- *
- * @start: String to parse.
- * @envp:  Pointer to "struct ccs_envp_entry".
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_envp(char *start, struct ccs_envp_entry *envp)
-{
-	const struct ccs_path_info *name;
-	const struct ccs_path_info *value;
-	bool is_not;
-	char *cp = start;
-	/*
-	 * Since environment variable names don't
-	 * contain '=', I can treat '"]=' and '"]!='
-	 * sequences as delimiters.
-	 */
-	while (1) {
-		if (!strncmp(start, "\"]=", 3)) {
-			is_not = false;
-			*start = '\0';
-			start += 3;
-			break;
-		} else if (!strncmp(start, "\"]!=", 4)) {
-			is_not = true;
-			*start = '\0';
-			start += 4;
-			break;
-		} else if (!*start++) {
-			goto out;
-		}
-	}
-	if (!*cp || !ccs_is_correct_path(cp, 0, 0, 0))
-		goto out;
-	name = ccs_get_name(cp);
-	if (!name)
-		goto out;
-	if (!strcmp(start, "NULL")) {
-		value = NULL;
-	} else {
-		value = ccs_get_dqword(start);
-		if (!value)
-			goto out;
-	}
-	envp->name = name;
-	envp->is_not = is_not;
-	envp->value = value;
-	return true;
- out:
-	return false;
-}
-
 /* The list for "struct ccs_condition". */
 LIST_HEAD(ccs_condition_list);
 
@@ -469,339 +334,6 @@
 };
 
 /**
- * ccs_parse_post_condition - Parse post-condition part.
- *
- * @condition:  String to parse.
- * @post_state: Buffer to store post-condition part.
- *
- * Returns true on success, false otherwise.
- */
-static bool ccs_parse_post_condition(char * const condition, u8 post_state[4])
-{
-	char *start = strstr(condition, "; set ");
-	if (!start)
-		return true;
-	*start = '\0';
-	start += 6;
-	while (1) {
-		int i;
-		unsigned long value;
-		while (*start == ' ')
-			start++;
-		if (!*start)
-			break;
-		if (!strncmp(start, "task.state[0]=", 14))
-			i = 0;
-		else if (!strncmp(start, "task.state[1]=", 14))
-			i = 1;
-		else if (!strncmp(start, "task.state[2]=", 14))
-			i = 2;
-		else
-			goto out;
-		start += 14;
-		if (post_state[3] & (1 << i))
-			goto out;
-		post_state[3] |= 1 << i;
-		if (!ccs_parse_ulong(&value, &start) || value > 255)
-			goto out;
-		post_state[i] = (u8) value;
-	}
-	return true;
- out:
-	return false;
-}
-
-/**
- * ccs_get_condition - Parse condition part.
- *
- * @condition: Pointer to string to parse.
- *
- * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
- */
-struct ccs_condition *ccs_get_condition(char * const condition)
-{
-	static const bool debug;
-	char *start = condition;
-	struct ccs_condition *entry = NULL;
-	struct ccs_condition *ptr;
-	struct ccs_condition_element *condp;
-	struct ccs_number_union *numbers_p;
-	struct ccs_name_union *names_p;
-	struct ccs_argv_entry *argv;
-	struct ccs_envp_entry *envp;
-	u32 size;
-	u8 i;
-	bool found = false;
-	u16 condc = 0;
-	u16 numbers_count = 0;
-	u16 names_count = 0;
-	u16 argc = 0;
-	u16 envc = 0;
-	u8 post_state[4] = { 0, 0, 0, 0 };
-	char *end_of_string;
-	if (!ccs_parse_post_condition(start, post_state))
-		goto out;
-	start = condition;
-	if (!strncmp(start, "if ", 3))
-		start += 3;
-	else if (*start)
-		return NULL;
-	end_of_string = start + strlen(start);
-	while (1) {
-		u8 left;
-		u8 right;
-		char *word = start;
-		char *cp;
-		char *eq;
-		bool is_not = false;
-		if (!*word)
-			break;
-		cp = strchr(start, ' ');
-		if (cp) {
-			*cp = '\0';
-			start = cp + 1;
-		} else {
-			start = "";
-		}
-		if (debug)
-			printk(KERN_WARNING "%u: <%s>\n", __LINE__, word);
-		if (!strncmp(word, "exec.argv[", 10)) {
-			argc++;
-			condc++;
-			continue;
-		} else if (!strncmp(word, "exec.envp[\"", 11)) {
-			envc++;
-			condc++;
-			continue;
-		}
-		eq = strchr(word, '=');
-		if (!eq)
-			goto out;
-		if (eq > word && *(eq - 1) == '!') {
-			is_not = true;
-			eq--;
-		}
-		*eq = '\0';
-		for (left = 0; left < CCS_MAX_CONDITION_KEYWORD; left++) {
-			if (strcmp(word, ccs_condition_keyword[left]))
-				continue;
-			break;
-		}
-		if (debug)
-			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
-			       word, left);
-		if (left == CCS_MAX_CONDITION_KEYWORD)
-			numbers_count++;
-		*eq = is_not ? '!' : '=';
-		word = eq + 1;
-		if (is_not)
-			word++;
-		condc++;
-		if (debug)
-			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
-			       word, left);
-		if (left == CCS_EXEC_REALPATH || left == CCS_SYMLINK_TARGET) {
-			names_count++;
-			continue;
-		}
-		for (right = 0; right < CCS_MAX_CONDITION_KEYWORD; right++) {
-			if (strcmp(word, ccs_condition_keyword[right]))
-				continue;
-			break;
-		}
-		if (debug)
-			printk(KERN_WARNING "%u: <%s> right=%u\n", __LINE__,
-			       word, right);
-		if (right == CCS_MAX_CONDITION_KEYWORD)
-			numbers_count++;
-	}
-	if (debug)
-		printk(KERN_DEBUG "%u: cond=%u numbers=%u names=%u ac=%u "
-		       "ec=%u\n", __LINE__, condc, numbers_count, names_count,
-		       argc, envc);
-	size = sizeof(*entry)
-		+ condc * sizeof(struct ccs_condition_element)
-		+ numbers_count * sizeof(struct ccs_number_union)
-		+ names_count * sizeof(struct ccs_name_union)
-		+ argc * sizeof(struct ccs_argv_entry)
-		+ envc * sizeof(struct ccs_envp_entry);
-	entry = kzalloc(size, GFP_KERNEL);
-	if (!entry)
-		return NULL;
-	INIT_LIST_HEAD(&entry->list);
-	for (i = 0; i < 4; i++)
-		entry->post_state[i] = post_state[i];
-	entry->condc = condc;
-	entry->numbers_count = numbers_count;
-	entry->names_count = names_count;
-	entry->argc = argc;
-	entry->envc = envc;
-	condp = (struct ccs_condition_element *) (entry + 1);
-	numbers_p = (struct ccs_number_union *) (condp + condc);
-	names_p = (struct ccs_name_union *) (numbers_p + numbers_count);
-	argv = (struct ccs_argv_entry *) (names_p + names_count);
-	envp = (struct ccs_envp_entry *) (argv + argc);
-	for (start = condition; start < end_of_string; start++)
-		if (!*start)
-			*start = ' ';
-	start = condition;
-	if (!strncmp(start, "if ", 3))
-		start += 3;
-	else if (*start)
-		goto out;
-	while (1) {
-		u8 left;
-		u8 right;
-		char *word = start;
-		char *cp;
-		char *eq;
-		bool is_not = false;
-		if (!*word)
-			break;
-		cp = strchr(start, ' ');
-		if (cp) {
-			*cp = '\0';
-			start = cp + 1;
-		} else {
-			start = "";
-		}
-		if (debug)
-			printk(KERN_WARNING "%u: <%s>\n", __LINE__, word);
-		if (!strncmp(word, "exec.argv[", 10)) {
-			if (!ccs_parse_argv(word + 10, argv))
-				goto out;
-			argv++;
-			argc--;
-			condc--;
-			left = CCS_ARGV_ENTRY;
-			right = -1;
-			goto store_value;
-		} else if (!strncmp(word, "exec.envp[\"", 11)) {
-			if (!ccs_parse_envp(word + 11, envp))
-				goto out;
-			envp++;
-			envc--;
-			condc--;
-			left = CCS_ENVP_ENTRY;
-			right = -1;
-			goto store_value;
-		}
-		eq = strchr(word, '=');
-		if (!eq) {
-			if (debug)
-				printk(KERN_WARNING "%u: No operator.\n",
-				       __LINE__);
-			goto out;
-		}
-		if (eq > word && *(eq - 1) == '!') {
-			is_not = true;
-			eq--;
-		}
-		*eq = '\0';
-		for (left = 0; left < CCS_MAX_CONDITION_KEYWORD; left++) {
-			if (strcmp(word, ccs_condition_keyword[left]))
-				continue;
-			break;
-		}
-		if (debug)
-			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
-			       word, left);
-		if (left == CCS_MAX_CONDITION_KEYWORD) {
-			left = CCS_NUMBER_UNION;
-			if (!ccs_parse_number_union(word, numbers_p))
-				goto out;
-			if (numbers_p->is_group)
-				goto out;
-			numbers_p++;
-			numbers_count--;
-		}
-		*eq = is_not ? '!' : '=';
-		word = eq + 1;
-		if (is_not)
-			word++;
-		condc--;
-		if (debug)
-			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
-			       word, left);
-		if (left == CCS_EXEC_REALPATH || left == CCS_SYMLINK_TARGET) {
-			right = CCS_NAME_UNION;
-			if (!ccs_parse_name_union_quoted(word, names_p++))
-				goto out;
-			names_count--;
-			goto store_value;
-		}
-		for (right = 0; right < CCS_MAX_CONDITION_KEYWORD; right++) {
-			if (strcmp(word, ccs_condition_keyword[right]))
-				continue;
-			break;
-		}
-		if (right == CCS_MAX_CONDITION_KEYWORD) {
-			right = CCS_NUMBER_UNION;
-			if (!ccs_parse_number_union(word, numbers_p++))
-				goto out;
-			numbers_count--;
-		}
- store_value:
-		condp->left = left;
-		condp->right = right;
-		condp->equals = !is_not;
-		if (debug)
-			printk(KERN_WARNING "%u: left=%u right=%u match=%u\n",
-			       __LINE__, condp->left, condp->right,
-			       condp->equals);
-		condp++;
-	}
-	if (debug) {
-		for (start = condition; start < end_of_string; start++)
-			if (!*start)
-				*start = ' ';
-		printk(KERN_DEBUG "%u: <%s> cond=%u numbers=%u names=%u ac=%u "
-		       "ec=%u\n", __LINE__, condition, condc, numbers_count,
-		       names_count, argc, envc);
-	}
-	BUG_ON(names_count);
-	BUG_ON(numbers_count);
-	BUG_ON(argc);
-	BUG_ON(envc);
-	BUG_ON(condc);
-	entry->size = size;
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &ccs_condition_list, list) {
-		if (ccs_memcmp(ptr, entry, offsetof(typeof(*entry), size),
-			       size))
-			continue;
-		/* Same entry found. Share this entry. */
-		atomic_inc(&ptr->users);
-		found = true;
-		break;
-	}
-	if (!found) {
-		if (ccs_memory_ok(entry, size)) {
-			atomic_set(&entry->users, 1);
-			list_add_rcu(&entry->list, &ccs_condition_list);
-		} else {
-			found = true;
-			ptr = NULL;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
-	if (found) {
-		ccs_del_condition(entry);
-		kfree(entry);
-		entry = ptr;
-	}
-	return entry;
- out:
-	if (debug)
-		printk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);
-	if (entry) {
-		ccs_del_condition(entry);
-		kfree(entry);
-	}
-	return NULL;
-}
-
-/**
  * ccs_get_attributes - Revalidate "struct inode".
  *
  * @obj: Pointer to "struct ccs_obj_info".
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/policy_io.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -10,6 +10,13 @@
  *
  */
 
+#include <linux/net.h>
+#include <linux/inet.h>
+#include <linux/in.h>
+#include <linux/in6.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/udp.h>
 #include "internal.h"
 
 static struct ccs_profile ccs_default_profile = {
@@ -192,10 +199,99 @@
 	 + CCS_MAC_CATEGORY_CAPABILITY] = "capability",
 };
 
+static const char *ccs_path_keyword[CCS_MAX_PATH_OPERATION] = {
+	[CCS_TYPE_READ_WRITE] = "read/write",
+	[CCS_TYPE_EXECUTE]    = "execute",
+	[CCS_TYPE_READ]       = "read",
+	[CCS_TYPE_WRITE]      = "write",
+	[CCS_TYPE_UNLINK]     = "unlink",
+	[CCS_TYPE_RMDIR]      = "rmdir",
+	[CCS_TYPE_TRUNCATE]   = "truncate",
+	[CCS_TYPE_SYMLINK]    = "symlink",
+	[CCS_TYPE_REWRITE]    = "rewrite",
+	[CCS_TYPE_CHROOT]     = "chroot",
+	[CCS_TYPE_UMOUNT]     = "unmount",
+	[CCS_TYPE_TRANSIT]    = "transit",
+};
+
+static const char *ccs_path_number3_keyword[CCS_MAX_PATH_NUMBER3_OPERATION] = {
+	[CCS_TYPE_MKBLOCK]    = "mkblock",
+	[CCS_TYPE_MKCHAR]     = "mkchar",
+};
+
+static const char *ccs_path2_keyword[CCS_MAX_PATH2_OPERATION] = {
+	[CCS_TYPE_LINK]       = "link",
+	[CCS_TYPE_RENAME]     = "rename",
+	[CCS_TYPE_PIVOT_ROOT] = "pivot_root",
+};
+
+static const char *ccs_path_number_keyword[CCS_MAX_PATH_NUMBER_OPERATION] = {
+	[CCS_TYPE_CREATE] = "create",
+	[CCS_TYPE_MKDIR]  = "mkdir",
+	[CCS_TYPE_MKFIFO] = "mkfifo",
+	[CCS_TYPE_MKSOCK] = "mksock",
+	[CCS_TYPE_IOCTL]  = "ioctl",
+	[CCS_TYPE_CHMOD]  = "chmod",
+	[CCS_TYPE_CHOWN]  = "chown",
+	[CCS_TYPE_CHGRP]  = "chgrp",
+};
+
 /* Permit policy management by non-root user? */
 static bool ccs_manage_by_non_root;
 
 /**
+ * ccs_path2keyword - Get the name of path operations.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of path operation.
+ */
+const char *ccs_path2keyword(const u8 operation)
+{
+	return (operation < CCS_MAX_PATH_OPERATION)
+		? ccs_path_keyword[operation] : NULL;
+}
+
+/**
+ * ccs_path_number32keyword - Get the name of path/number/number/number operations.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of path/number/number/number operation.
+ */
+const char *ccs_path_number32keyword(const u8 operation)
+{
+	return (operation < CCS_MAX_PATH_NUMBER3_OPERATION)
+		? ccs_path_number3_keyword[operation] : NULL;
+}
+
+/**
+ * ccs_path22keyword - Get the name of path/path operations.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of path/path operation.
+ */
+const char *ccs_path22keyword(const u8 operation)
+{
+	return (operation < CCS_MAX_PATH2_OPERATION)
+		? ccs_path2_keyword[operation] : NULL;
+}
+
+/**
+ * ccs_path_number2keyword - Get the name of path/number operations.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of path/number operation.
+ */
+const char *ccs_path_number2keyword(const u8 operation)
+{
+	return (operation < CCS_MAX_PATH_NUMBER_OPERATION)
+		? ccs_path_number_keyword[operation] : NULL;
+}
+
+/**
  * ccs_cap2keyword - Convert capability operation to capability name.
  *
  * @operation: The capability index.
@@ -800,6 +896,198 @@
 }
 
 /**
+ * ccs_get_path_group - Allocate memory for "struct ccs_path_group".
+ *
+ * @group_name: The name of pathname group.
+ *
+ * Returns pointer to "struct ccs_path_group" on success, NULL otherwise.
+ */
+static struct ccs_path_group *ccs_get_path_group(const char *group_name)
+{
+	struct ccs_path_group *entry = NULL;
+	struct ccs_path_group *group;
+	const struct ccs_path_info *saved_group_name;
+	int error = -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
+	    !group_name[0])
+		return NULL;
+	saved_group_name = ccs_get_name(group_name);
+	if (!saved_group_name)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(group, &ccs_path_group_list, list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		atomic_inc(&group->users);
+		error = 0;
+		break;
+	}
+	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
+		INIT_LIST_HEAD(&entry->member_list);
+		entry->group_name = saved_group_name;
+		saved_group_name = NULL;
+		atomic_set(&entry->users, 1);
+		list_add_tail_rcu(&entry->list, &ccs_path_group_list);
+		group = entry;
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name(saved_group_name);
+	kfree(entry);
+	return !error ? group : NULL;
+}
+
+/**
+ * ccs_parse_name_union - Parse a ccs_name_union.
+ *
+ * @filename: Name or name group.
+ * @ptr:      Pointer to "struct ccs_name_union".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_parse_name_union(const char *filename,
+				 struct ccs_name_union *ptr)
+{
+	if (!ccs_is_correct_path(filename, 0, 0, 0))
+		return false;
+	if (filename[0] == '@') {
+		ptr->group = ccs_get_path_group(filename + 1);
+		ptr->is_group = true;
+		return ptr->group != NULL;
+	}
+	ptr->filename = ccs_get_name(filename);
+	ptr->is_group = false;
+	return ptr->filename != NULL;
+}
+
+/**
+ * ccs_get_number_group - Allocate memory for "struct ccs_number_group".
+ *
+ * @group_name: The name of number group.
+ *
+ * Returns pointer to "struct ccs_number_group" on success,
+ * NULL otherwise.
+ */
+static struct ccs_number_group *ccs_get_number_group(const char *group_name)
+{
+	struct ccs_number_group *entry = NULL;
+	struct ccs_number_group *group;
+	const struct ccs_path_info *saved_group_name;
+	int error = -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
+	    !group_name[0])
+		return NULL;
+	saved_group_name = ccs_get_name(group_name);
+	if (!saved_group_name)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(group, &ccs_number_group_list, list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		atomic_inc(&group->users);
+		error = 0;
+		break;
+	}
+	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
+		INIT_LIST_HEAD(&entry->member_list);
+		entry->group_name = saved_group_name;
+		saved_group_name = NULL;
+		atomic_set(&entry->users, 1);
+		list_add_tail_rcu(&entry->list, &ccs_number_group_list);
+		group = entry;
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name(saved_group_name);
+	kfree(entry);
+	return !error ? group : NULL;
+}
+
+/**
+ * ccs_parse_ulong - Parse an "unsigned long" value.
+ *
+ * @result: Pointer to "unsigned long".
+ * @str:    Pointer to string to parse.
+ *
+ * Returns value type on success, 0 otherwise.
+ *
+ * The @src is updated to point the first character after the value
+ * on success.
+ */
+static u8 ccs_parse_ulong(unsigned long *result, char **str)
+{
+	const char *cp = *str;
+	char *ep;
+	int base = 10;
+	if (*cp == '0') {
+		char c = *(cp + 1);
+		if (c == 'x' || c == 'X') {
+			base = 16;
+			cp += 2;
+		} else if (c >= '0' && c <= '7') {
+			base = 8;
+			cp++;
+		}
+	}
+	*result = simple_strtoul(cp, &ep, base);
+	if (cp == ep)
+		return 0;
+	*str = ep;
+	switch (base) {
+	case 16:
+		return CCS_VALUE_TYPE_HEXADECIMAL;
+	case 8:
+		return CCS_VALUE_TYPE_OCTAL;
+	default:
+		return CCS_VALUE_TYPE_DECIMAL;
+	}
+}
+
+/**
+ * ccs_parse_number_union - Parse a ccs_number_union.
+ *
+ * @data: Number or number range or number group.
+ * @ptr:  Pointer to "struct ccs_number_union".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_parse_number_union(char *data, struct ccs_number_union *num)
+{
+	u8 type;
+	unsigned long v;
+	memset(num, 0, sizeof(*num));
+	if (data[0] == '@') {
+		if (!ccs_is_correct_path(data, 0, 0, 0))
+			return false;
+		num->group = ccs_get_number_group(data + 1);
+		num->is_group = true;
+		return num->group != NULL;
+	}
+	type = ccs_parse_ulong(&v, &data);
+	if (!type)
+		return false;
+	num->values[0] = v;
+	num->min_type = type;
+	if (!*data) {
+		num->values[1] = v;
+		num->max_type = type;
+		return true;
+	}
+	if (*data++ != '-')
+		return false;
+	type = ccs_parse_ulong(&v, &data);
+	if (!type || *data)
+		return false;
+	num->values[1] = v;
+	num->max_type = type;
+	return true;
+}
+
+/**
  * ccs_find_condition_part - Find condition part from the statement.
  *
  * @data: String to parse.
@@ -890,6 +1178,893 @@
 	return true;
 }
 
+/**
+ * ccs_write_capability_policy - Write "struct ccs_capability_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_capability_policy(char *data, struct ccs_domain_info *domain,
+				       struct ccs_condition *condition,
+				       const bool is_delete)
+{
+	struct ccs_capability_acl e = {
+		.head.type = CCS_TYPE_CAPABILITY_ACL,
+		.head.cond = condition,
+	};
+	struct ccs_capability_acl *entry = NULL;
+	struct ccs_acl_info *ptr;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	u8 capability;
+	for (capability = 0; capability < CCS_MAX_CAPABILITY_INDEX;
+	     capability++) {
+		if (strcmp(data, ccs_cap2keyword(capability)))
+			continue;
+		break;
+	}
+	if (capability == CCS_MAX_CAPABILITY_INDEX)
+		return -EINVAL;
+	e.operation = capability;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_capability_acl *acl =
+			container_of(ptr, struct ccs_capability_acl, head);
+		if (ptr->type != CCS_TYPE_CAPABILITY_ACL ||
+		    ptr->cond != condition || acl->operation != capability)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_get_address_group - Allocate memory for "struct ccs_address_group".
+ *
+ * @group_name: The name of address group.
+ *
+ * Returns pointer to "struct ccs_address_group" on success,
+ * NULL otherwise.
+ */
+static struct ccs_address_group *ccs_get_address_group(const char *group_name)
+{
+	struct ccs_address_group *entry = NULL;
+	struct ccs_address_group *group;
+	const struct ccs_path_info *saved_group_name;
+	int error = -ENOMEM;
+	if (!ccs_is_correct_path(group_name, 0, 0, 0) ||
+	    !group_name[0])
+		return NULL;
+	saved_group_name = ccs_get_name(group_name);
+	if (!saved_group_name)
+		return NULL;
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(group, &ccs_address_group_list, list) {
+		if (saved_group_name != group->group_name)
+			continue;
+		atomic_inc(&group->users);
+		error = 0;
+		break;
+	}
+	if (error && ccs_memory_ok(entry, sizeof(*entry))) {
+		INIT_LIST_HEAD(&entry->member_list);
+		entry->group_name = saved_group_name;
+		saved_group_name = NULL;
+		atomic_set(&entry->users, 1);
+		list_add_tail_rcu(&entry->list, &ccs_address_group_list);
+		group = entry;
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name(saved_group_name);
+	kfree(entry);
+	return !error ? group : NULL;
+}
+
+/**
+ * ccs_parse_ip_address - Parse an IP address.
+ *
+ * @address: String to parse.
+ * @min:     Pointer to store min address.
+ * @max:     Pointer to store max address.
+ *
+ * Returns 2 if @address is an IPv6, 1 if @address is an IPv4, 0 otherwise.
+ */
+static int ccs_parse_ip_address(char *address, u16 *min, u16 *max)
+{
+	int count = sscanf(address, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx"
+			   "-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
+			   &min[0], &min[1], &min[2], &min[3],
+			   &min[4], &min[5], &min[6], &min[7],
+			   &max[0], &max[1], &max[2], &max[3],
+			   &max[4], &max[5], &max[6], &max[7]);
+	if (count == 8 || count == 16) {
+		u8 i;
+		if (count == 8)
+			memmove(max, min, sizeof(u16) * 8);
+		for (i = 0; i < 8; i++) {
+			min[i] = htons(min[i]);
+			max[i] = htons(max[i]);
+		}
+		return 2;
+	}
+	count = sscanf(address, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
+		       &min[0], &min[1], &min[2], &min[3],
+		       &max[0], &max[1], &max[2], &max[3]);
+	if (count == 4 || count == 8) {
+		u32 ip = htonl((((u8) min[0]) << 24) + (((u8) min[1]) << 16)
+			       + (((u8) min[2]) << 8) + (u8) min[3]);
+		memmove(min, &ip, sizeof(ip));
+		if (count == 8)
+			ip = htonl((((u8) max[0]) << 24) + (((u8) max[1]) << 16)
+				   + (((u8) max[2]) << 8) + (u8) max[3]);
+		memmove(max, &ip, sizeof(ip));
+		return 1;
+	}
+	return 0;
+}
+
+/**
+ * ccs_write_network_policy - Write "struct ccs_ip_network_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_network_policy(char *data, struct ccs_domain_info *domain,
+				    struct ccs_condition *condition,
+				    const bool is_delete)
+{
+	struct ccs_ip_network_acl *entry = NULL;
+	struct ccs_acl_info *ptr;
+	struct ccs_ip_network_acl e = {
+		.head.type = CCS_TYPE_IP_NETWORK_ACL,
+		.head.cond = condition,
+	};
+	u16 min_address[8];
+	u16 max_address[8];
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	u8 sock_type;
+	char *w[4];
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[3][0])
+		return -EINVAL;
+	if (!strcmp(w[0], "TCP"))
+		sock_type = SOCK_STREAM;
+	else if (!strcmp(w[0], "UDP"))
+		sock_type = SOCK_DGRAM;
+	else if (!strcmp(w[0], "RAW"))
+		sock_type = SOCK_RAW;
+	else
+		return -EINVAL;
+	if (!strcmp(w[1], "bind"))
+		switch (sock_type) {
+		case SOCK_STREAM:
+			e.perm = 1 << CCS_NETWORK_TCP_BIND;
+			break;
+		case SOCK_DGRAM:
+			e.perm = 1 << CCS_NETWORK_UDP_BIND;
+			break;
+		default:
+			e.perm = 1 << CCS_NETWORK_RAW_BIND;
+			break;
+		}
+	else if (!strcmp(w[1], "connect"))
+		switch (sock_type) {
+		case SOCK_STREAM:
+			e.perm = 1 << CCS_NETWORK_TCP_CONNECT;
+			break;
+		case SOCK_DGRAM:
+			e.perm = 1 << CCS_NETWORK_UDP_CONNECT;
+			break;
+		default:
+			e.perm = 1 << CCS_NETWORK_RAW_CONNECT;
+			break;
+		}
+	else if (sock_type == SOCK_STREAM && !strcmp(w[1], "listen"))
+		e.perm = 1 << CCS_NETWORK_TCP_LISTEN;
+	else if (sock_type == SOCK_STREAM && !strcmp(w[1], "accept"))
+		e.perm = 1 << CCS_NETWORK_TCP_ACCEPT;
+	else
+		return -EINVAL;
+	switch (ccs_parse_ip_address(w[2], min_address, max_address)) {
+	case 2:
+		e.address_type = CCS_IP_ADDRESS_TYPE_IPv6;
+		e.address.ipv6.min = ccs_get_ipv6_address((struct in6_addr *)
+							  min_address);
+		e.address.ipv6.max = ccs_get_ipv6_address((struct in6_addr *)
+							  max_address);
+		if (!e.address.ipv6.min || !e.address.ipv6.max)
+			goto out;
+		break;
+	case 1:
+		e.address_type = CCS_IP_ADDRESS_TYPE_IPv4;
+		/* use host byte order to allow u32 comparison.*/
+		e.address.ipv4.min = ntohl(*(u32 *) min_address);
+		e.address.ipv4.max = ntohl(*(u32 *) max_address);
+		break;
+	default:
+		if (w[2][0] != '@')
+			return -EINVAL;
+		e.address_type = CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
+		e.address.group = ccs_get_address_group(w[2] + 1);
+		if (!e.address.group)
+			return -ENOMEM;
+		break;
+	}
+	if (!ccs_parse_number_union(w[3], &e.port))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_ip_network_acl *acl =
+			container_of(ptr, struct ccs_ip_network_acl, head);
+		if (ptr->type != CCS_TYPE_IP_NETWORK_ACL ||
+		    ptr->cond != condition ||
+		    ccs_memcmp(acl, &e, offsetof(typeof(e), address_type),
+			       sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~e.perm;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= e.perm;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	if (w[2][0] == '@')
+		ccs_put_address_group(e.address.group);
+	else if (e.address_type == CCS_IP_ADDRESS_TYPE_IPv6) {
+		ccs_put_ipv6_address(e.address.ipv6.min);
+		ccs_put_ipv6_address(e.address.ipv6.max);
+	}
+	ccs_put_number_union(&e.port);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_signal_policy - Write "struct ccs_signal_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_signal_policy(char *data, struct ccs_domain_info *domain,
+				   struct ccs_condition *condition,
+				   const bool is_delete)
+{
+	struct ccs_signal_acl *entry = NULL;
+	struct ccs_acl_info *ptr;
+	struct ccs_signal_acl e = { .head.type = CCS_TYPE_SIGNAL_ACL,
+				    .head.cond = condition };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	int sig;
+	char *domainname = strchr(data, ' ');
+	if (sscanf(data, "%d", &sig) != 1 || !domainname ||
+	    !ccs_is_correct_domain(domainname + 1))
+		return -EINVAL;
+	e.sig = sig;
+	e.domainname = ccs_get_name(domainname + 1);
+	if (!e.domainname)
+		return -ENOMEM;
+	if (!is_delete)
+		entry = kmalloc(sizeof(*entry), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_signal_acl *acl =
+			container_of(ptr, struct ccs_signal_acl, head);
+		if (ptr->type != CCS_TYPE_SIGNAL_ACL || ptr->cond != condition
+		    || acl->sig != sig || acl->domainname != e.domainname)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name(e.domainname);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_env_policy - Write "struct ccs_env_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_env_policy(char *data, struct ccs_domain_info *domain,
+				struct ccs_condition *condition,
+				const bool is_delete)
+{
+	struct ccs_env_acl *entry = NULL;
+	struct ccs_acl_info *ptr;
+	struct ccs_env_acl e = {
+		.head.type = CCS_TYPE_ENV_ACL,
+		.head.cond = condition
+	};
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(data, 0, 0, 0) || strchr(data, '='))
+		return -EINVAL;
+	e.env = ccs_get_name(data);
+	if (!e.env)
+		return error;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_env_acl *acl =
+			container_of(ptr, struct ccs_env_acl, head);
+		if (ptr->type != CCS_TYPE_ENV_ACL || ptr->cond != condition ||
+		    acl->env != e.env)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name(e.env);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_mount_policy - Write "struct ccs_mount_acl" list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_mount_policy(char *data, struct ccs_domain_info *domain,
+				  struct ccs_condition *condition,
+				  const bool is_delete)
+{
+	struct ccs_mount_acl *entry = NULL;
+	struct ccs_acl_info *ptr;
+	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL,
+				   .head.cond = condition };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	char *w[4];
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[3][0])
+		return -EINVAL;
+	if (!ccs_parse_name_union(w[0], &e.dev_name) ||
+	    !ccs_parse_name_union(w[1], &e.dir_name) ||
+	    !ccs_parse_name_union(w[2], &e.fs_type) ||
+	    !ccs_parse_number_union(w[3], &e.flags))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_mount_acl *acl =
+			container_of(ptr, struct ccs_mount_acl, head);
+		if (ptr->type != CCS_TYPE_MOUNT_ACL || ptr->cond != condition
+		    || ccs_memcmp(acl, &e, offsetof(typeof(e), dev_name),
+				  sizeof(e)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	ccs_put_name_union(&e.dev_name);
+	ccs_put_name_union(&e.dir_name);
+	ccs_put_name_union(&e.fs_type);
+	ccs_put_number_union(&e.flags);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_execute_handler - Update "struct ccs_execute_handler_record" list.
+ *
+ * @type:      Type of execute handler.
+ * @filename:  Pathname to the execute handler.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_execute_handler(const u8 type, const char *filename,
+				      struct ccs_domain_info * const domain,
+				      const bool is_delete)
+{
+	struct ccs_acl_info *ptr;
+	struct ccs_execute_handler_record e = { .head.type = type };
+	struct ccs_execute_handler_record *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!domain)
+		return -EINVAL;
+	if (!ccs_is_correct_path(filename, 1, -1, -1))
+		return -EINVAL;
+	e.handler = ccs_get_name(filename);
+	if (!e.handler)
+		return -ENOMEM;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_execute_handler_record *acl;
+		if (ptr->type != type)
+			continue;
+		/* Condition not supported. */
+		acl = container_of(ptr, struct ccs_execute_handler_record,
+				   head);
+		if (acl->handler != e.handler)
+			continue;
+		if (!is_delete) {
+			/* Only one entry can exist in a domain. */
+			struct ccs_acl_info *ptr2;
+			list_for_each_entry_rcu(ptr2, &domain->acl_info_list,
+						list) {
+				if (ptr2->type == type)
+					ptr2->is_deleted = true;
+			}
+		}
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		/* Only one entry can exist in a domain. */
+		list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+			if (ptr->type == type)
+				ptr->is_deleted = true;
+		}
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name(e.handler);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_path_acl - Update "struct ccs_path_acl" list.
+ *
+ * @type:      Type of operation.
+ * @filename:  Filename.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_path_acl(const u8 type, const char *filename,
+			       struct ccs_domain_info * const domain,
+			       struct ccs_condition *condition,
+			       const bool is_delete)
+{
+	static const u16 ccs_rw_mask =
+		(1 << CCS_TYPE_READ) | (1 << CCS_TYPE_WRITE);
+	const u16 perm = 1 << type;
+	struct ccs_acl_info *ptr;
+	struct ccs_path_acl e = {
+		.head.type = CCS_TYPE_PATH_ACL,
+		.head.cond = condition,
+		.perm = perm
+	};
+	struct ccs_path_acl *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (type == CCS_TYPE_READ_WRITE)
+		e.perm |= ccs_rw_mask;
+	if (!ccs_parse_name_union(filename, &e.name))
+		return -EINVAL;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_path_acl *acl =
+			container_of(ptr, struct ccs_path_acl, head);
+		if (ptr->type != CCS_TYPE_PATH_ACL ||
+		    ptr->cond != condition ||
+		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~perm;
+			if ((acl->perm & ccs_rw_mask) != ccs_rw_mask)
+				acl->perm &= ~(1 << CCS_TYPE_READ_WRITE);
+			else if (!(acl->perm & (1 << CCS_TYPE_READ_WRITE)))
+				acl->perm &= ~ccs_rw_mask;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= perm;
+			if ((acl->perm & ccs_rw_mask) == ccs_rw_mask)
+				acl->perm |= 1 << CCS_TYPE_READ_WRITE;
+			else if (acl->perm & (1 << CCS_TYPE_READ_WRITE))
+				acl->perm |= ccs_rw_mask;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name_union(&e.name);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_path_number3_acl - Update "struct ccs_path_number3_acl" list.
+ *
+ * @type:      Type of operation.
+ * @filename:  Filename.
+ * @mode:      Create mode.
+ * @major:     Device major number.
+ * @minor:     Device minor number.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_path_number3_acl(const u8 type, const char *filename,
+				       char *mode, char *major, char *minor,
+				       struct ccs_domain_info * const domain,
+				       struct ccs_condition *condition,
+				       const bool is_delete)
+{
+	const u8 perm = 1 << type;
+	struct ccs_acl_info *ptr;
+	struct ccs_path_number3_acl e = {
+		.head.type = CCS_TYPE_PATH_NUMBER3_ACL,
+		.head.cond = condition,
+		.perm = perm
+	};
+	struct ccs_path_number3_acl *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_parse_name_union(filename, &e.name) ||
+	    !ccs_parse_number_union(mode, &e.mode) ||
+	    !ccs_parse_number_union(major, &e.major) ||
+	    !ccs_parse_number_union(minor, &e.minor))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_path_number3_acl *acl =
+			container_of(ptr, struct ccs_path_number3_acl, head);
+		if (ptr->type != CCS_TYPE_PATH_NUMBER3_ACL ||
+		    ptr->cond != condition ||
+		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~perm;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= perm;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	ccs_put_name_union(&e.name);
+	ccs_put_number_union(&e.mode);
+	ccs_put_number_union(&e.major);
+	ccs_put_number_union(&e.minor);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_path2_acl - Update "struct ccs_path2_acl" list.
+ *
+ * @type:      Type of operation.
+ * @filename1: First filename.
+ * @filename2: Second filename.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_path2_acl(const u8 type, const char *filename1,
+				const char *filename2,
+				struct ccs_domain_info * const domain,
+				struct ccs_condition *condition,
+				const bool is_delete)
+{
+	const u8 perm = 1 << type;
+	struct ccs_acl_info *ptr;
+	struct ccs_path2_acl e = {
+		.head.type = CCS_TYPE_PATH2_ACL,
+		.head.cond = condition,
+		.perm = perm
+	};
+	struct ccs_path2_acl *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_parse_name_union(filename1, &e.name1) ||
+	    !ccs_parse_name_union(filename2, &e.name2))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_path2_acl *acl =
+			container_of(ptr, struct ccs_path2_acl, head);
+		if (ptr->type != CCS_TYPE_PATH2_ACL ||
+		    ptr->cond != condition ||
+		    ccs_memcmp(acl, &e, offsetof(typeof(e), name1), sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~perm;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= perm;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	ccs_put_name_union(&e.name1);
+	ccs_put_name_union(&e.name2);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_path_number_acl - Update ioctl/chmod/chown/chgrp ACL.
+ *
+ * @type:      Type of operation.
+ * @filename:  Filename.
+ * @number:    Number.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_path_number_acl(const u8 type, const char *filename,
+				      char *number,
+				      struct ccs_domain_info * const domain,
+				      struct ccs_condition *condition,
+				      const bool is_delete)
+{
+	const u8 perm = 1 << type;
+	struct ccs_acl_info *ptr;
+	struct ccs_path_number_acl e = {
+		.head.type = CCS_TYPE_PATH_NUMBER_ACL,
+		.head.cond = condition,
+		.perm = perm
+	};
+	struct ccs_path_number_acl *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!domain)
+		return -EINVAL;
+	if (!ccs_parse_name_union(filename, &e.name))
+		return -EINVAL;
+	if (!ccs_parse_number_union(number, &e.number))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct ccs_path_number_acl *acl =
+			container_of(ptr, struct ccs_path_number_acl, head);
+		if (ptr->type != CCS_TYPE_PATH_NUMBER_ACL ||
+		    ptr->cond != condition ||
+		    ccs_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~perm;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= perm;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		ccs_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	ccs_put_name_union(&e.name);
+	ccs_put_number_union(&e.number);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_file_acl - Update file's read/write/execute ACL.
+ *
+ * @perm:      Permission (between 1 to 7).
+ * @filename:  Filename.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * This is legacy support interface for older policy syntax.
+ * Current policy syntax uses "allow_read/write" instead of "6",
+ * "allow_read" instead of "4", "allow_write" instead of "2",
+ * "allow_execute" instead of "1".
+ */
+static int ccs_update_file_acl(u8 perm, const char *filename,
+			       struct ccs_domain_info * const domain,
+			       struct ccs_condition *condition,
+			       const bool is_delete)
+{
+	if (perm > 7 || !perm)
+		return -EINVAL;
+	if (filename[0] != '@' && ccs_strendswith(filename, "/"))
+		/*
+		 * Only 'allow_mkdir' and 'allow_rmdir' are valid for
+		 * directory permissions.
+		 */
+		return 0;
+	if (perm & 4)
+		ccs_update_path_acl(CCS_TYPE_READ, filename, domain,
+				    condition, is_delete);
+	if (perm & 2)
+		ccs_update_path_acl(CCS_TYPE_WRITE, filename,
+				    domain, condition, is_delete);
+	if (perm & 1)
+		ccs_update_path_acl(CCS_TYPE_EXECUTE, filename,
+				    domain, condition, is_delete);
+	return 0;
+}
+
+/**
+ * ccs_write_file_policy - Update file related list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct ccs_domain_info".
+ * @condition: Pointer to "struct ccs_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_file_policy(char *data, struct ccs_domain_info *domain,
+				 struct ccs_condition *condition,
+				 const bool is_delete)
+{
+	char *w[5];
+	u8 type;
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
+		return -EINVAL;
+	if (strncmp(w[0], "allow_", 6)) {
+		unsigned int perm;
+		if (sscanf(w[0], "%u", &perm) == 1)
+			return ccs_update_file_acl((u8) perm, w[1], domain,
+						   condition, is_delete);
+		if (!strcmp(w[0], CCS_KEYWORD_EXECUTE_HANDLER))
+			type = CCS_TYPE_EXECUTE_HANDLER;
+		else if (!strcmp(w[0], CCS_KEYWORD_DENIED_EXECUTE_HANDLER))
+			type = CCS_TYPE_DENIED_EXECUTE_HANDLER;
+		else
+			goto out;
+		return ccs_update_execute_handler(type, w[1], domain,
+						  is_delete);
+	}
+	w[0] += 6;
+	for (type = 0; type < CCS_MAX_PATH_OPERATION; type++) {
+		if (strcmp(w[0], ccs_path_keyword[type]))
+			continue;
+		return ccs_update_path_acl(type, w[1], domain, condition,
+					   is_delete);
+	}
+	if (!w[2][0])
+		goto out;
+	for (type = 0; type < CCS_MAX_PATH2_OPERATION; type++) {
+		if (strcmp(w[0], ccs_path2_keyword[type]))
+			continue;
+		return ccs_update_path2_acl(type, w[1], w[2], domain,
+					    condition, is_delete);
+	}
+	for (type = 0; type < CCS_MAX_PATH_NUMBER_OPERATION; type++) {
+		if (strcmp(w[0], ccs_path_number_keyword[type]))
+			continue;
+		return ccs_update_path_number_acl(type, w[1], w[2], domain,
+						  condition, is_delete);
+	}
+	if (!w[3][0] || !w[4][0])
+		goto out;
+	for (type = 0; type < CCS_MAX_PATH_NUMBER3_OPERATION; type++) {
+		if (strcmp(w[0], ccs_path_number3_keyword[type]))
+			continue;
+		return ccs_update_path_number3_acl(type, w[1], w[2], w[3],
+						   w[4], domain, condition,
+						   is_delete);
+	}
+ out:
+	return -EINVAL;
+}
+
 static int ccs_write_domain_policy2(char *data, struct ccs_domain_info *domain,
 				    struct ccs_condition *cond,
 				    const bool is_delete)
@@ -908,7 +2083,475 @@
 	return ccs_write_file_policy(data, domain, cond, is_delete);
 }
 
+static bool ccs_parse_name_union_quoted(char *filename,
+					struct ccs_name_union *ptr)
+{
+	bool result;
+	char *cp = NULL;
+	if (*filename == '"') {
+		cp = filename + strlen(filename) - 1;
+		if (*cp != '"')
+			return false;
+		*cp = '\0';
+		filename++;
+	}
+	result = ccs_parse_name_union(filename, ptr);
+	if (cp)
+		*cp = '"';
+	return result;
+}
+
 /**
+ * ccs_get_dqword - ccs_get_name() for a quoted string.
+ *
+ * @start: String to save.
+ *
+ * Returns pointer to "struct ccs_path_info" on success, NULL otherwise.
+ */
+static const struct ccs_path_info *ccs_get_dqword(char *start)
+{
+	char *cp;
+	if (*start++ != '"')
+		return NULL;
+	cp = start;
+	while (1) {
+		const char c = *cp++;
+		if (!c)
+			return NULL;
+		if (c != '"' || *cp)
+			continue;
+		*(cp - 1) = '\0';
+		break;
+	}
+	if (!ccs_is_correct_path(start, 0, 0, 0))
+		return NULL;
+	return ccs_get_name(start);
+}
+
+/**
+ * ccs_parse_argv - Parse an argv[] condition part.
+ *
+ * @start: String to parse.
+ * @argv:  Pointer to "struct ccs_argv_entry".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_parse_argv(char *start, struct ccs_argv_entry *argv)
+{
+	unsigned long index;
+	const struct ccs_path_info *value;
+	bool is_not;
+	char c;
+	if (ccs_parse_ulong(&index, &start) != CCS_VALUE_TYPE_DECIMAL)
+		goto out;
+	if (*start++ != ']')
+		goto out;
+	c = *start++;
+	if (c == '=')
+		is_not = false;
+	else if (c == '!' && *start++ == '=')
+		is_not = true;
+	else
+		goto out;
+	value = ccs_get_dqword(start);
+	if (!value)
+		goto out;
+	argv->index = index;
+	argv->is_not = is_not;
+	argv->value = value;
+	return true;
+ out:
+	return false;
+}
+
+/**
+ * ccs_parse_envp - Parse an envp[] condition part.
+ *
+ * @start: String to parse.
+ * @envp:  Pointer to "struct ccs_envp_entry".
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_parse_envp(char *start, struct ccs_envp_entry *envp)
+{
+	const struct ccs_path_info *name;
+	const struct ccs_path_info *value;
+	bool is_not;
+	char *cp = start;
+	/*
+	 * Since environment variable names don't
+	 * contain '=', I can treat '"]=' and '"]!='
+	 * sequences as delimiters.
+	 */
+	while (1) {
+		if (!strncmp(start, "\"]=", 3)) {
+			is_not = false;
+			*start = '\0';
+			start += 3;
+			break;
+		} else if (!strncmp(start, "\"]!=", 4)) {
+			is_not = true;
+			*start = '\0';
+			start += 4;
+			break;
+		} else if (!*start++) {
+			goto out;
+		}
+	}
+	if (!*cp || !ccs_is_correct_path(cp, 0, 0, 0))
+		goto out;
+	name = ccs_get_name(cp);
+	if (!name)
+		goto out;
+	if (!strcmp(start, "NULL")) {
+		value = NULL;
+	} else {
+		value = ccs_get_dqword(start);
+		if (!value)
+			goto out;
+	}
+	envp->name = name;
+	envp->is_not = is_not;
+	envp->value = value;
+	return true;
+ out:
+	return false;
+}
+
+/**
+ * ccs_parse_post_condition - Parse post-condition part.
+ *
+ * @condition:  String to parse.
+ * @post_state: Buffer to store post-condition part.
+ *
+ * Returns true on success, false otherwise.
+ */
+static bool ccs_parse_post_condition(char * const condition, u8 post_state[4])
+{
+	char *start = strstr(condition, "; set ");
+	if (!start)
+		return true;
+	*start = '\0';
+	start += 6;
+	while (1) {
+		int i;
+		unsigned long value;
+		while (*start == ' ')
+			start++;
+		if (!*start)
+			break;
+		if (!strncmp(start, "task.state[0]=", 14))
+			i = 0;
+		else if (!strncmp(start, "task.state[1]=", 14))
+			i = 1;
+		else if (!strncmp(start, "task.state[2]=", 14))
+			i = 2;
+		else
+			goto out;
+		start += 14;
+		if (post_state[3] & (1 << i))
+			goto out;
+		post_state[3] |= 1 << i;
+		if (!ccs_parse_ulong(&value, &start) || value > 255)
+			goto out;
+		post_state[i] = (u8) value;
+	}
+	return true;
+ out:
+	return false;
+}
+
+/**
+ * ccs_get_condition - Parse condition part.
+ *
+ * @condition: Pointer to string to parse.
+ *
+ * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
+ */
+static struct ccs_condition *ccs_get_condition(char * const condition)
+{
+	static const bool debug;
+	char *start = condition;
+	struct ccs_condition *entry = NULL;
+	struct ccs_condition *ptr;
+	struct ccs_condition_element *condp;
+	struct ccs_number_union *numbers_p;
+	struct ccs_name_union *names_p;
+	struct ccs_argv_entry *argv;
+	struct ccs_envp_entry *envp;
+	u32 size;
+	u8 i;
+	bool found = false;
+	u16 condc = 0;
+	u16 numbers_count = 0;
+	u16 names_count = 0;
+	u16 argc = 0;
+	u16 envc = 0;
+	u8 post_state[4] = { 0, 0, 0, 0 };
+	char *end_of_string;
+	if (!ccs_parse_post_condition(start, post_state))
+		goto out;
+	start = condition;
+	if (!strncmp(start, "if ", 3))
+		start += 3;
+	else if (*start)
+		return NULL;
+	end_of_string = start + strlen(start);
+	while (1) {
+		u8 left;
+		u8 right;
+		char *word = start;
+		char *cp;
+		char *eq;
+		bool is_not = false;
+		if (!*word)
+			break;
+		cp = strchr(start, ' ');
+		if (cp) {
+			*cp = '\0';
+			start = cp + 1;
+		} else {
+			start = "";
+		}
+		if (debug)
+			printk(KERN_WARNING "%u: <%s>\n", __LINE__, word);
+		if (!strncmp(word, "exec.argv[", 10)) {
+			argc++;
+			condc++;
+			continue;
+		} else if (!strncmp(word, "exec.envp[\"", 11)) {
+			envc++;
+			condc++;
+			continue;
+		}
+		eq = strchr(word, '=');
+		if (!eq)
+			goto out;
+		if (eq > word && *(eq - 1) == '!') {
+			is_not = true;
+			eq--;
+		}
+		*eq = '\0';
+		for (left = 0; left < CCS_MAX_CONDITION_KEYWORD; left++) {
+			if (strcmp(word, ccs_condition_keyword[left]))
+				continue;
+			break;
+		}
+		if (debug)
+			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
+			       word, left);
+		if (left == CCS_MAX_CONDITION_KEYWORD)
+			numbers_count++;
+		*eq = is_not ? '!' : '=';
+		word = eq + 1;
+		if (is_not)
+			word++;
+		condc++;
+		if (debug)
+			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
+			       word, left);
+		if (left == CCS_EXEC_REALPATH || left == CCS_SYMLINK_TARGET) {
+			names_count++;
+			continue;
+		}
+		for (right = 0; right < CCS_MAX_CONDITION_KEYWORD; right++) {
+			if (strcmp(word, ccs_condition_keyword[right]))
+				continue;
+			break;
+		}
+		if (debug)
+			printk(KERN_WARNING "%u: <%s> right=%u\n", __LINE__,
+			       word, right);
+		if (right == CCS_MAX_CONDITION_KEYWORD)
+			numbers_count++;
+	}
+	if (debug)
+		printk(KERN_DEBUG "%u: cond=%u numbers=%u names=%u ac=%u "
+		       "ec=%u\n", __LINE__, condc, numbers_count, names_count,
+		       argc, envc);
+	size = sizeof(*entry)
+		+ condc * sizeof(struct ccs_condition_element)
+		+ numbers_count * sizeof(struct ccs_number_union)
+		+ names_count * sizeof(struct ccs_name_union)
+		+ argc * sizeof(struct ccs_argv_entry)
+		+ envc * sizeof(struct ccs_envp_entry);
+	entry = kzalloc(size, GFP_KERNEL);
+	if (!entry)
+		return NULL;
+	INIT_LIST_HEAD(&entry->list);
+	for (i = 0; i < 4; i++)
+		entry->post_state[i] = post_state[i];
+	entry->condc = condc;
+	entry->numbers_count = numbers_count;
+	entry->names_count = names_count;
+	entry->argc = argc;
+	entry->envc = envc;
+	condp = (struct ccs_condition_element *) (entry + 1);
+	numbers_p = (struct ccs_number_union *) (condp + condc);
+	names_p = (struct ccs_name_union *) (numbers_p + numbers_count);
+	argv = (struct ccs_argv_entry *) (names_p + names_count);
+	envp = (struct ccs_envp_entry *) (argv + argc);
+	for (start = condition; start < end_of_string; start++)
+		if (!*start)
+			*start = ' ';
+	start = condition;
+	if (!strncmp(start, "if ", 3))
+		start += 3;
+	else if (*start)
+		goto out;
+	while (1) {
+		u8 left;
+		u8 right;
+		char *word = start;
+		char *cp;
+		char *eq;
+		bool is_not = false;
+		if (!*word)
+			break;
+		cp = strchr(start, ' ');
+		if (cp) {
+			*cp = '\0';
+			start = cp + 1;
+		} else {
+			start = "";
+		}
+		if (debug)
+			printk(KERN_WARNING "%u: <%s>\n", __LINE__, word);
+		if (!strncmp(word, "exec.argv[", 10)) {
+			if (!ccs_parse_argv(word + 10, argv))
+				goto out;
+			argv++;
+			argc--;
+			condc--;
+			left = CCS_ARGV_ENTRY;
+			right = -1;
+			goto store_value;
+		} else if (!strncmp(word, "exec.envp[\"", 11)) {
+			if (!ccs_parse_envp(word + 11, envp))
+				goto out;
+			envp++;
+			envc--;
+			condc--;
+			left = CCS_ENVP_ENTRY;
+			right = -1;
+			goto store_value;
+		}
+		eq = strchr(word, '=');
+		if (!eq) {
+			if (debug)
+				printk(KERN_WARNING "%u: No operator.\n",
+				       __LINE__);
+			goto out;
+		}
+		if (eq > word && *(eq - 1) == '!') {
+			is_not = true;
+			eq--;
+		}
+		*eq = '\0';
+		for (left = 0; left < CCS_MAX_CONDITION_KEYWORD; left++) {
+			if (strcmp(word, ccs_condition_keyword[left]))
+				continue;
+			break;
+		}
+		if (debug)
+			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
+			       word, left);
+		if (left == CCS_MAX_CONDITION_KEYWORD) {
+			left = CCS_NUMBER_UNION;
+			if (!ccs_parse_number_union(word, numbers_p))
+				goto out;
+			if (numbers_p->is_group)
+				goto out;
+			numbers_p++;
+			numbers_count--;
+		}
+		*eq = is_not ? '!' : '=';
+		word = eq + 1;
+		if (is_not)
+			word++;
+		condc--;
+		if (debug)
+			printk(KERN_WARNING "%u: <%s> left=%u\n", __LINE__,
+			       word, left);
+		if (left == CCS_EXEC_REALPATH || left == CCS_SYMLINK_TARGET) {
+			right = CCS_NAME_UNION;
+			if (!ccs_parse_name_union_quoted(word, names_p++))
+				goto out;
+			names_count--;
+			goto store_value;
+		}
+		for (right = 0; right < CCS_MAX_CONDITION_KEYWORD; right++) {
+			if (strcmp(word, ccs_condition_keyword[right]))
+				continue;
+			break;
+		}
+		if (right == CCS_MAX_CONDITION_KEYWORD) {
+			right = CCS_NUMBER_UNION;
+			if (!ccs_parse_number_union(word, numbers_p++))
+				goto out;
+			numbers_count--;
+		}
+ store_value:
+		condp->left = left;
+		condp->right = right;
+		condp->equals = !is_not;
+		if (debug)
+			printk(KERN_WARNING "%u: left=%u right=%u match=%u\n",
+			       __LINE__, condp->left, condp->right,
+			       condp->equals);
+		condp++;
+	}
+	if (debug) {
+		for (start = condition; start < end_of_string; start++)
+			if (!*start)
+				*start = ' ';
+		printk(KERN_DEBUG "%u: <%s> cond=%u numbers=%u names=%u ac=%u "
+		       "ec=%u\n", __LINE__, condition, condc, numbers_count,
+		       names_count, argc, envc);
+	}
+	BUG_ON(names_count);
+	BUG_ON(numbers_count);
+	BUG_ON(argc);
+	BUG_ON(envc);
+	BUG_ON(condc);
+	entry->size = size;
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &ccs_condition_list, list) {
+		if (ccs_memcmp(ptr, entry, offsetof(typeof(*entry), size),
+			       size))
+			continue;
+		/* Same entry found. Share this entry. */
+		atomic_inc(&ptr->users);
+		found = true;
+		break;
+	}
+	if (!found) {
+		if (ccs_memory_ok(entry, size)) {
+			atomic_set(&entry->users, 1);
+			list_add_rcu(&entry->list, &ccs_condition_list);
+		} else {
+			found = true;
+			ptr = NULL;
+		}
+	}
+	mutex_unlock(&ccs_policy_lock);
+	if (found) {
+		ccs_del_condition(entry);
+		kfree(entry);
+		entry = ptr;
+	}
+	return entry;
+ out:
+	if (debug)
+		printk(KERN_WARNING "%u: %s failed\n", __LINE__, __func__);
+	if (entry) {
+		ccs_del_condition(entry);
+		kfree(entry);
+	}
+	return NULL;
+}
+
+/**
  * ccs_write_domain_policy - Write domain policy.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -1079,7 +2722,7 @@
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_print_number_union(struct ccs_io_buffer *head,
+static bool ccs_print_number_union(struct ccs_io_buffer *head,
 			    const struct ccs_number_union *ptr)
 {
 	return ccs_print_number_union_common(head, ptr, true);
@@ -1849,7 +3492,633 @@
 			      (u8) (ccs_flags >> 8));
 }
 
+
 /**
+ * ccs_update_domain_initializer_entry - Update "struct ccs_domain_initializer_entry" list.
+ *
+ * @domainname: The name of domain. May be NULL.
+ * @program:    The name of program.
+ * @is_not:     True if it is "no_initialize_domain" entry.
+ * @is_delete:  True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_domain_initializer_entry(const char *domainname,
+					       const char *program,
+					       const bool is_not,
+					       const bool is_delete)
+{
+	struct ccs_domain_initializer_entry *entry = NULL;
+	struct ccs_domain_initializer_entry *ptr;
+	struct ccs_domain_initializer_entry e = { .is_not = is_not };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(program, 1, -1, -1))
+		return -EINVAL; /* No patterns allowed. */
+	if (domainname) {
+		if (!ccs_is_domain_def(domainname) &&
+		    ccs_is_correct_path(domainname, 1, -1, -1))
+			e.is_last_name = true;
+		else if (!ccs_is_correct_domain(domainname))
+			return -EINVAL;
+		e.domainname = ccs_get_name(domainname);
+		if (!e.domainname)
+			goto out;
+	}
+	e.program = ccs_get_name(program);
+	if (!e.program)
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &ccs_domain_initializer_list, list) {
+		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), is_not),
+			       sizeof(e)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccs_domain_initializer_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	ccs_put_name(e.domainname);
+	ccs_put_name(e.program);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_domain_keeper_entry - Update "struct ccs_domain_keeper_entry" list.
+ *
+ * @domainname: The name of domain.
+ * @program:    The name of program. May be NULL.
+ * @is_not:     True if it is "no_keep_domain" entry.
+ * @is_delete:  True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_domain_keeper_entry(const char *domainname,
+					  const char *program,
+					  const bool is_not,
+					  const bool is_delete)
+{
+	struct ccs_domain_keeper_entry *entry = NULL;
+	struct ccs_domain_keeper_entry *ptr;
+	struct ccs_domain_keeper_entry e = { .is_not = is_not };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_domain_def(domainname) &&
+	    ccs_is_correct_path(domainname, 1, -1, -1))
+		e.is_last_name = true;
+	else if (!ccs_is_correct_domain(domainname))
+		return -EINVAL;
+	if (program) {
+		if (!ccs_is_correct_path(program, 1, -1, -1))
+			return -EINVAL;
+		e.program = ccs_get_name(program);
+		if (!e.program)
+			goto out;
+	}
+	e.domainname = ccs_get_name(domainname);
+	if (!e.domainname)
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &ccs_domain_keeper_list, list) {
+		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), is_not),
+			       sizeof(e)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccs_domain_keeper_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	ccs_put_name(e.domainname);
+	ccs_put_name(e.program);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_domain_keeper_policy - Write "struct ccs_domain_keeper_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_not:    True if it is "no_keep_domain" entry.
+ * @is_delete: True if it is a delete request.
+ *
+ */
+static int ccs_write_domain_keeper_policy(char *data, const bool is_not,
+					  const bool is_delete)
+{
+	char *cp = strstr(data, " from ");
+	if (cp) {
+		*cp = '\0';
+		return ccs_update_domain_keeper_entry(cp + 6, data,
+						      is_not, is_delete);
+	}
+	return ccs_update_domain_keeper_entry(data, NULL, is_not, is_delete);
+}
+
+/**
+ * ccs_write_domain_initializer_policy - Write "struct ccs_domain_initializer_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_not:    True if it is "no_initialize_domain" entry.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_domain_initializer_policy(char *data, const bool is_not,
+					       const bool is_delete)
+{
+	char *cp = strstr(data, " from ");
+	if (cp) {
+		*cp = '\0';
+		return ccs_update_domain_initializer_entry(cp + 6, data,
+							   is_not, is_delete);
+	}
+	return ccs_update_domain_initializer_entry(NULL, data, is_not,
+						   is_delete);
+}
+
+/**
+ * ccs_update_aggregator_entry - Update "struct ccs_aggregator_entry" list.
+ *
+ * @original_name:   The original program's name.
+ * @aggregated_name: The aggregated program's name.
+ * @is_delete:       True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_aggregator_entry(const char *original_name,
+				       const char *aggregated_name,
+				       const bool is_delete)
+{
+	struct ccs_aggregator_entry *entry = NULL;
+	struct ccs_aggregator_entry *ptr;
+	struct ccs_aggregator_entry e = { };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(original_name, 1, 0, -1) ||
+	    !ccs_is_correct_path(aggregated_name, 1, -1, -1))
+		return -EINVAL;
+	e.original_name = ccs_get_name(original_name);
+	e.aggregated_name = ccs_get_name(aggregated_name);
+	if (!e.original_name || !e.aggregated_name)
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &ccs_aggregator_list, list) {
+		if (ccs_memcmp(ptr, &e, offsetof(typeof(e), original_name),
+			       sizeof(e)))
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccs_aggregator_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	ccs_put_name(e.original_name);
+	ccs_put_name(e.aggregated_name);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_aggregator_policy - Write "struct ccs_aggregator_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_aggregator_policy(char *data, const bool is_delete)
+{
+	char *w[2];
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
+		return -EINVAL;
+	return ccs_update_aggregator_entry(w[0], w[1], is_delete);
+}
+
+/**
+ * ccs_write_globally_readable_policy - Write "struct ccs_globally_readable_file_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_globally_readable_policy(char *data, const bool is_delete)
+{
+	struct ccs_globally_readable_file_entry *entry = NULL;
+	struct ccs_globally_readable_file_entry *ptr;
+	struct ccs_globally_readable_file_entry e = { };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(data, 1, 0, -1))
+		return -EINVAL;
+	e.filename = ccs_get_name(data);
+	if (!e.filename)
+		return -ENOMEM;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &ccs_globally_readable_list, list) {
+		if (ptr->filename != e.filename)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccs_globally_readable_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name(e.filename);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_globally_usable_env_policy - Write "struct ccs_globally_usable_env_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_globally_usable_env_policy(char *data,
+						const bool is_delete)
+{
+	struct ccs_globally_usable_env_entry *entry = NULL;
+	struct ccs_globally_usable_env_entry e = { };
+	struct ccs_globally_usable_env_entry *ptr;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(data, 0, 0, 0) || strchr(data, '='))
+		return -EINVAL;
+	e.env = ccs_get_name(data);
+	if (!e.env)
+		return error;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &ccs_globally_usable_env_list, list) {
+		if (ptr->env != e.env)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccs_globally_usable_env_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name(e.env);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_pattern_policy - Write "struct ccs_pattern_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_pattern_policy(char *data, const bool is_delete)
+{
+	struct ccs_pattern_entry *entry = NULL;
+	struct ccs_pattern_entry *ptr;
+	struct ccs_pattern_entry e = { .pattern = ccs_get_name(data) };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!e.pattern)
+		return error;
+	if (!e.pattern->is_patterned)
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &ccs_pattern_list, list) {
+		if (e.pattern != ptr->pattern)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccs_pattern_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	ccs_put_name(e.pattern);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_path_group_policy - Write "struct ccs_path_group" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, nagative value otherwise.
+ */
+static int ccs_write_path_group_policy(char *data, const bool is_delete)
+{
+	struct ccs_path_group *group;
+	struct ccs_path_group_member *entry = NULL;
+	struct ccs_path_group_member *member;
+	struct ccs_path_group_member e = { };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	char *w[2];
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
+		return -EINVAL;
+	group = ccs_get_path_group(w[0]);
+	if (!group)
+		return -ENOMEM;
+	e.member_name = ccs_get_name(w[1]);
+	if (!e.member_name)
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(member, &group->member_list, list) {
+		if (member->member_name != e.member_name)
+			continue;
+		member->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &group->member_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	ccs_put_name(e.member_name);
+	ccs_put_path_group(group);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_number_group_policy - Write "struct ccs_number_group" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, nagative value otherwise.
+ */
+static int ccs_write_number_group_policy(char *data, const bool is_delete)
+{
+	struct ccs_number_group *group;
+	struct ccs_number_group_member *entry = NULL;
+	struct ccs_number_group_member e = { };
+	struct ccs_number_group_member *member;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	char *w[2];
+	if (!ccs_tokenize(data, w, sizeof(w)))
+		return -EINVAL;
+	if (!ccs_parse_number_union(w[1], &e.number))
+		return -EINVAL;
+	if (e.number.is_group || e.number.values[0] > e.number.values[1]) {
+		ccs_put_number_union(&e.number);
+		return -EINVAL;
+	}
+	group = ccs_get_number_group(w[0]);
+	if (!group)
+		return -ENOMEM;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(member, &group->member_list, list) {
+		if (memcmp(&member->number, &e.number, sizeof(e.number)))
+			continue;
+		member->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &group->member_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_number_group(group);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_no_rewrite_policy - Write "struct ccs_no_rewrite_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_no_rewrite_policy(char *data, const bool is_delete)
+{
+	struct ccs_no_rewrite_entry *entry = NULL;
+	struct ccs_no_rewrite_entry *ptr;
+	struct ccs_no_rewrite_entry e = { };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!ccs_is_correct_path(data, 0, 0, 0))
+		return -EINVAL;
+	e.pattern = ccs_get_name(data);
+	if (!e.pattern)
+		return error;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &ccs_no_rewrite_list, list) {
+		if (ptr->pattern != e.pattern)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccs_no_rewrite_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+	ccs_put_name(e.pattern);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_write_address_group_policy - Write "struct ccs_address_group" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_address_group_policy(char *data, const bool is_delete)
+{
+	struct ccs_address_group *group;
+	struct ccs_address_group_member *entry = NULL;
+	struct ccs_address_group_member *member;
+	struct ccs_address_group_member e = { };
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	u16 min_address[8];
+	u16 max_address[8];
+	char *w[2];
+	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
+		return -EINVAL;
+	group = ccs_get_address_group(w[0]);
+	if (!group)
+		return -ENOMEM;
+	switch (ccs_parse_ip_address(w[1], min_address, max_address)) {
+	case 2:
+		e.is_ipv6 = true;
+		e.min.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
+						  min_address);
+		e.max.ipv6 = ccs_get_ipv6_address((struct in6_addr *)
+						  max_address);
+		if (!e.min.ipv6 || !e.max.ipv6)
+			goto out;
+		break;
+	case 1:
+		e.min.ipv4 = ntohl(*(u32 *) min_address);
+		e.max.ipv4 = ntohl(*(u32 *) max_address);
+		break;
+	default:
+		goto out;
+	}
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(member, &group->member_list, list) {
+		if (ccs_memcmp(member, &e, offsetof(typeof(e), is_ipv6),
+			       sizeof(e)))
+			continue;
+		member->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &group->member_list);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&ccs_policy_lock);
+ out:
+	if (e.is_ipv6) {
+		ccs_put_ipv6_address(e.min.ipv6);
+		ccs_put_ipv6_address(e.max.ipv6);
+	}
+	ccs_put_address_group(group);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * ccs_update_reserved_entry - Update "struct ccs_reserved_entry" list.
+ *
+ * @min_port: Start of port number range.
+ * @max_port: End of port number range.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_update_reserved_entry(const u16 min_port, const u16 max_port,
+				     const bool is_delete)
+{
+	struct ccs_reserved_entry *ptr;
+	struct ccs_reserved_entry e = {
+		.min_port = min_port,
+		.max_port = max_port
+	};
+	int error = -ENOMEM;
+	u8 *ccs_tmp_map = kzalloc(8192, GFP_KERNEL);
+	struct ccs_reserved_entry *entry = kmalloc(sizeof(e), GFP_KERNEL);
+	if (!ccs_tmp_map || !entry) {
+		kfree(entry);
+		kfree(ccs_tmp_map);
+		return -ENOMEM;
+	}
+	if (is_delete)
+		error = -ENOENT;
+	mutex_lock(&ccs_policy_lock);
+	list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
+		if (ptr->min_port != min_port || ptr->max_port != max_port)
+			continue;
+		ptr->is_deleted = is_delete;
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
+		list_add_tail_rcu(&entry->list, &ccs_reservedport_list);
+		entry = NULL;
+		error = 0;
+	}
+	list_for_each_entry_rcu(ptr, &ccs_reservedport_list, list) {
+		unsigned int port;
+		if (ptr->is_deleted)
+			continue;
+		for (port = ptr->min_port; port <= ptr->max_port; port++)
+			ccs_tmp_map[port >> 8] |= 1 << (port & 7);
+	}
+	memmove(ccs_reserved_port_map, ccs_tmp_map,
+		sizeof(ccs_reserved_port_map));
+	mutex_unlock(&ccs_policy_lock);
+	kfree(entry);
+	kfree(ccs_tmp_map);
+	return error;
+}
+
+/**
+ * ccs_write_reserved_port_policy - Write "struct ccs_reserved_entry" list.
+ *
+ * @data:      String to parse.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_reserved_port_policy(char *data, const bool is_delete)
+{
+	unsigned int from;
+	unsigned int to;
+	if (strchr(data, ' '))
+		goto out;
+	if (sscanf(data, "%u-%u", &from, &to) == 2) {
+		if (from <= to && to < 65536)
+			return ccs_update_reserved_entry(from, to, is_delete);
+	} else if (sscanf(data, "%u", &from) == 1) {
+		if (from < 65536)
+			return ccs_update_reserved_entry(from, from, is_delete);
+	}
+ out:
+	return -EINVAL;
+}
+
+/**
  * ccs_write_exception_policy - Write exception policy.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -1892,6 +4161,381 @@
 }
 
 /**
+ * ccs_read_domain_keeper_policy - Read "struct ccs_domain_keeper_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_domain_keeper_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2,
+			     &ccs_domain_keeper_list) {
+		struct ccs_domain_keeper_entry *ptr;
+		const char *no;
+		const char *from = "";
+		const char *program = "";
+		ptr = list_entry(pos, struct ccs_domain_keeper_entry, list);
+		if (ptr->is_deleted)
+			continue;
+		no = ptr->is_not ? "no_" : "";
+		if (ptr->program) {
+			from = " from ";
+			program = ptr->program->name;
+		}
+		done = ccs_io_printf(head, "%s" CCS_KEYWORD_KEEP_DOMAIN
+				     "%s%s%s\n", no, program, from,
+				     ptr->domainname->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_globally_readable_policy - Read "struct ccs_globally_readable_file_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_globally_readable_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2,
+			     &ccs_globally_readable_list) {
+		struct ccs_globally_readable_file_entry *ptr;
+		ptr = list_entry(pos, struct ccs_globally_readable_file_entry,
+				 list);
+		if (ptr->is_deleted)
+			continue;
+		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_READ "%s\n",
+				     ptr->filename->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_globally_usable_env_policy - Read "struct ccs_globally_usable_env_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns 0 on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_globally_usable_env_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2,
+			     &ccs_globally_usable_env_list) {
+		struct ccs_globally_usable_env_entry *ptr;
+		ptr = list_entry(pos, struct ccs_globally_usable_env_entry,
+				 list);
+		if (ptr->is_deleted)
+			continue;
+		done = ccs_io_printf(head, CCS_KEYWORD_ALLOW_ENV "%s\n",
+				     ptr->env->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_domain_initializer_policy - Read "struct ccs_domain_initializer_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_domain_initializer_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2,
+			     &ccs_domain_initializer_list) {
+		const char *no;
+		const char *from = "";
+		const char *domain = "";
+		struct ccs_domain_initializer_entry *ptr;
+		ptr = list_entry(pos, struct ccs_domain_initializer_entry,
+				 list);
+		if (ptr->is_deleted)
+			continue;
+		no = ptr->is_not ? "no_" : "";
+		if (ptr->domainname) {
+			from = " from ";
+			domain = ptr->domainname->name;
+		}
+		done = ccs_io_printf(head, "%s" CCS_KEYWORD_INITIALIZE_DOMAIN
+				     "%s%s%s\n", no, ptr->program->name, from,
+				     domain);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_aggregator_policy - Read "struct ccs_aggregator_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_aggregator_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2, &ccs_aggregator_list) {
+		struct ccs_aggregator_entry *ptr;
+		ptr = list_entry(pos, struct ccs_aggregator_entry, list);
+		if (ptr->is_deleted)
+			continue;
+		done = ccs_io_printf(head, CCS_KEYWORD_AGGREGATOR "%s %s\n",
+				     ptr->original_name->name,
+				     ptr->aggregated_name->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_file_pattern - Read "struct ccs_pattern_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_file_pattern(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2, &ccs_pattern_list) {
+		struct ccs_pattern_entry *ptr;
+		ptr = list_entry(pos, struct ccs_pattern_entry, list);
+		if (ptr->is_deleted)
+			continue;
+		done = ccs_io_printf(head, CCS_KEYWORD_FILE_PATTERN "%s\n",
+				     ptr->pattern->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_no_rewrite_policy - Read "struct ccs_no_rewrite_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_no_rewrite_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	bool done = true;
+	list_for_each_cookie(pos, head->read_var2, &ccs_no_rewrite_list) {
+		struct ccs_no_rewrite_entry *ptr;
+		ptr = list_entry(pos, struct ccs_no_rewrite_entry, list);
+		if (ptr->is_deleted)
+			continue;
+		done = ccs_io_printf(head, CCS_KEYWORD_DENY_REWRITE "%s\n",
+				     ptr->pattern->name);
+		if (!done)
+			break;
+	}
+	return done;
+}
+
+/**
+ * ccs_read_path_group_policy - Read "struct ccs_path_group" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_path_group_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *gpos;
+	struct list_head *mpos;
+	list_for_each_cookie(gpos, head->read_var1, &ccs_path_group_list) {
+		struct ccs_path_group *group;
+		group = list_entry(gpos, struct ccs_path_group, list);
+		list_for_each_cookie(mpos, head->read_var2,
+				     &group->member_list) {
+			struct ccs_path_group_member *member;
+			member = list_entry(mpos, struct ccs_path_group_member,
+					    list);
+			if (member->is_deleted)
+				continue;
+			if (!ccs_io_printf(head, CCS_KEYWORD_PATH_GROUP
+					   "%s %s\n",
+					   group->group_name->name,
+					   member->member_name->name))
+				return false;
+		}
+	}
+	return true;
+}
+
+/**
+ * ccs_read_number_group_policy - Read "struct ccs_number_group" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_number_group_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *gpos;
+	struct list_head *mpos;
+	list_for_each_cookie(gpos, head->read_var1, &ccs_number_group_list) {
+		struct ccs_number_group *group;
+		const char *name;
+		group = list_entry(gpos, struct ccs_number_group, list);
+		name = group->group_name->name;
+		list_for_each_cookie(mpos, head->read_var2,
+				     &group->member_list) {
+			int pos;
+			const struct ccs_number_group_member *member
+				= list_entry(mpos,
+					     struct ccs_number_group_member,
+					     list);
+			if (member->is_deleted)
+				continue;
+			pos = head->read_avail;
+			if (!ccs_io_printf(head, CCS_KEYWORD_NUMBER_GROUP "%s",
+					   name) ||
+			    !ccs_print_number_union(head, &member->number) ||
+			    !ccs_io_printf(head, "\n")) {
+				head->read_avail = pos;
+				return false;
+			}
+		}
+	}
+	return true;
+}
+
+/**
+ * ccs_read_address_group_policy - Read "struct ccs_address_group" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_address_group_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *gpos;
+	struct list_head *mpos;
+	list_for_each_cookie(gpos, head->read_var1, &ccs_address_group_list) {
+		struct ccs_address_group *group;
+		group = list_entry(gpos, struct ccs_address_group, list);
+		list_for_each_cookie(mpos, head->read_var2,
+				     &group->member_list) {
+			char buf[128];
+			struct ccs_address_group_member *member;
+			member = list_entry(mpos,
+					    struct ccs_address_group_member,
+					    list);
+			if (member->is_deleted)
+				continue;
+			if (member->is_ipv6) {
+				const struct in6_addr *min_address
+					= member->min.ipv6;
+				const struct in6_addr *max_address
+					= member->max.ipv6;
+				ccs_print_ipv6(buf, sizeof(buf), min_address);
+				if (min_address != max_address) {
+					int len;
+					char *cp = buf + strlen(buf);
+					*cp++ = '-';
+					len = strlen(buf);
+					ccs_print_ipv6(cp, sizeof(buf) - len,
+						       max_address);
+				}
+			} else {
+				const u32 min_address = member->min.ipv4;
+				const u32 max_address = member->max.ipv4;
+				memset(buf, 0, sizeof(buf));
+				snprintf(buf, sizeof(buf) - 1, "%u.%u.%u.%u",
+					 HIPQUAD(min_address));
+				if (min_address != max_address) {
+					const int len = strlen(buf);
+					snprintf(buf + len,
+						 sizeof(buf) - 1 - len,
+						 "-%u.%u.%u.%u",
+						 HIPQUAD(max_address));
+				}
+			}
+			if (!ccs_io_printf(head, CCS_KEYWORD_ADDRESS_GROUP
+					   "%s %s\n", group->group_name->name,
+					   buf))
+				return false;
+		}
+	}
+	return true;
+}
+
+/**
+ * ccs_read_reserved_port_policy - Read "struct ccs_reserved_entry" list.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true on success, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_read_reserved_port_policy(struct ccs_io_buffer *head)
+{
+	struct list_head *pos;
+	char buffer[16];
+	memset(buffer, 0, sizeof(buffer));
+	list_for_each_cookie(pos, head->read_var2, &ccs_reservedport_list) {
+		u16 min_port;
+		u16 max_port;
+		struct ccs_reserved_entry *ptr;
+		ptr = list_entry(pos, struct ccs_reserved_entry, list);
+		if (ptr->is_deleted)
+			continue;
+		min_port = ptr->min_port;
+		max_port = ptr->max_port;
+		snprintf(buffer, sizeof(buffer) - 1, "%u%c%u", min_port,
+			 min_port != max_port ? '-' : '\0', max_port);
+		if (!ccs_io_printf(head, CCS_KEYWORD_DENY_AUTOBIND "%s\n",
+				   buffer))
+			return false;
+	}
+	return true;
+}
+
+/**
  * ccs_read_exception_policy - Read exception policy.
  *
  * @head: Pointer to "struct ccs_io_buffer".
Index: trunk/1.7.x/ccs-patch/security/ccsecurity/network.c
===================================================================
--- trunk/1.7.x/ccs-patch/security/ccsecurity/network.c	(revision 3495)
+++ trunk/1.7.x/ccs-patch/security/ccsecurity/network.c	(working copy)
@@ -19,6 +19,9 @@
 #include <net/udp.h>
 #include "internal.h"
 
+/* The list for "struct ccs_address_group". */
+LIST_HEAD(ccs_address_group_list);
+
 /**
  * ccs_audit_network_log - Audit network log.
  *
@@ -40,49 +43,6 @@
 				   "%s %s %u\n", operation, address, port);
 }
 
-/**
- * ccs_parse_ip_address - Parse an IP address.
- *
- * @address: String to parse.
- * @min:     Pointer to store min address.
- * @max:     Pointer to store max address.
- *
- * Returns 2 if @address is an IPv6, 1 if @address is an IPv4, 0 otherwise.
- */
-int ccs_parse_ip_address(char *address, u16 *min, u16 *max)
-{
-	int count = sscanf(address, "%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx"
-			   "-%hx:%hx:%hx:%hx:%hx:%hx:%hx:%hx",
-			   &min[0], &min[1], &min[2], &min[3],
-			   &min[4], &min[5], &min[6], &min[7],
-			   &max[0], &max[1], &max[2], &max[3],
-			   &max[4], &max[5], &max[6], &max[7]);
-	if (count == 8 || count == 16) {
-		u8 i;
-		if (count == 8)
-			memmove(max, min, sizeof(u16) * 8);
-		for (i = 0; i < 8; i++) {
-			min[i] = htons(min[i]);
-			max[i] = htons(max[i]);
-		}
-		return 2;
-	}
-	count = sscanf(address, "%hu.%hu.%hu.%hu-%hu.%hu.%hu.%hu",
-		       &min[0], &min[1], &min[2], &min[3],
-		       &max[0], &max[1], &max[2], &max[3]);
-	if (count == 4 || count == 8) {
-		u32 ip = htonl((((u8) min[0]) << 24) + (((u8) min[1]) << 16)
-			       + (((u8) min[2]) << 8) + (u8) min[3]);
-		memmove(min, &ip, sizeof(ip));
-		if (count == 8)
-			ip = htonl((((u8) max[0]) << 24) + (((u8) max[1]) << 16)
-				   + (((u8) max[2]) << 8) + (u8) max[3]);
-		memmove(max, &ip, sizeof(ip));
-		return 1;
-	}
-	return 0;
-}
-
 #if !defined(NIP6)
 #define NIP6(addr)							\
 	ntohs((addr).s6_addr16[0]), ntohs((addr).s6_addr16[1]),		\
@@ -147,6 +107,44 @@
 }
 
 /**
+ * ccs_address_matches_group - Check whether the given address matches members of the given address group.
+ *
+ * @is_ipv6: True if @address is an IPv6 address.
+ * @address: An IPv4 or IPv6 address.
+ * @group:   Pointer to "struct ccs_address_group".
+ *
+ * Returns true if @address matches addresses in @group group, false otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static bool ccs_address_matches_group(const bool is_ipv6, const u32 *address,
+				      const struct ccs_address_group *group)
+{
+	struct ccs_address_group_member *member;
+	const u32 ip = ntohl(*address);
+	bool matched = false;
+	list_for_each_entry_rcu(member, &group->member_list, list) {
+		if (member->is_deleted)
+			continue;
+		if (member->is_ipv6) {
+			if (is_ipv6 &&
+			    memcmp(member->min.ipv6, address, 16) <= 0 &&
+			    memcmp(address, member->max.ipv6, 16) <= 0) {
+				matched = true;
+				break;
+			}
+		} else {
+			if (!is_ipv6 &&
+			    member->min.ipv4 <= ip && ip <= member->max.ipv4) {
+				matched = true;
+				break;
+			}
+		}
+	}
+	return matched;
+}
+
+/**
  * ccs_network_entry2 - Check permission for network operation.
  *
  * @is_ipv6:   True if @address is an IPv6 address.
@@ -251,140 +249,6 @@
 }
 
 /**
- * ccs_write_network_policy - Write "struct ccs_ip_network_acl" list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct ccs_domain_info".
- * @condition: Pointer to "struct ccs_condition". May be NULL.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_network_policy(char *data, struct ccs_domain_info *domain,
-			     struct ccs_condition *condition,
-			     const bool is_delete)
-{
-	struct ccs_ip_network_acl *entry = NULL;
-	struct ccs_acl_info *ptr;
-	struct ccs_ip_network_acl e = {
-		.head.type = CCS_TYPE_IP_NETWORK_ACL,
-		.head.cond = condition,
-	};
-	u16 min_address[8];
-	u16 max_address[8];
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	u8 sock_type;
-	char *w[4];
-	if (!ccs_tokenize(data, w, sizeof(w)) || !w[3][0])
-		return -EINVAL;
-	if (!strcmp(w[0], "TCP"))
-		sock_type = SOCK_STREAM;
-	else if (!strcmp(w[0], "UDP"))
-		sock_type = SOCK_DGRAM;
-	else if (!strcmp(w[0], "RAW"))
-		sock_type = SOCK_RAW;
-	else
-		return -EINVAL;
-	if (!strcmp(w[1], "bind"))
-		switch (sock_type) {
-		case SOCK_STREAM:
-			e.perm = 1 << CCS_NETWORK_TCP_BIND;
-			break;
-		case SOCK_DGRAM:
-			e.perm = 1 << CCS_NETWORK_UDP_BIND;
-			break;
-		default:
-			e.perm = 1 << CCS_NETWORK_RAW_BIND;
-			break;
-		}
-	else if (!strcmp(w[1], "connect"))
-		switch (sock_type) {
-		case SOCK_STREAM:
-			e.perm = 1 << CCS_NETWORK_TCP_CONNECT;
-			break;
-		case SOCK_DGRAM:
-			e.perm = 1 << CCS_NETWORK_UDP_CONNECT;
-			break;
-		default:
-			e.perm = 1 << CCS_NETWORK_RAW_CONNECT;
-			break;
-		}
-	else if (sock_type == SOCK_STREAM && !strcmp(w[1], "listen"))
-		e.perm = 1 << CCS_NETWORK_TCP_LISTEN;
-	else if (sock_type == SOCK_STREAM && !strcmp(w[1], "accept"))
-		e.perm = 1 << CCS_NETWORK_TCP_ACCEPT;
-	else
-		return -EINVAL;
-	switch (ccs_parse_ip_address(w[2], min_address, max_address)) {
-	case 2:
-		e.address_type = CCS_IP_ADDRESS_TYPE_IPv6;
-		e.address.ipv6.min = ccs_get_ipv6_address((struct in6_addr *)
-							  min_address);
-		e.address.ipv6.max = ccs_get_ipv6_address((struct in6_addr *)
-							  max_address);
-		if (!e.address.ipv6.min || !e.address.ipv6.max)
-			goto out;
-		break;
-	case 1:
-		e.address_type = CCS_IP_ADDRESS_TYPE_IPv4;
-		/* use host byte order to allow u32 comparison.*/
-		e.address.ipv4.min = ntohl(*(u32 *) min_address);
-		e.address.ipv4.max = ntohl(*(u32 *) max_address);
-		break;
-	default:
-		if (w[2][0] != '@')
-			return -EINVAL;
-		e.address_type = CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
-		e.address.group = ccs_get_address_group(w[2] + 1);
-		if (!e.address.group)
-			return -ENOMEM;
-		break;
-	}
-	if (!ccs_parse_number_union(w[3], &e.port))
-		goto out;
-	if (!is_delete)
-		entry = kmalloc(sizeof(e), GFP_KERNEL);
-	mutex_lock(&ccs_policy_lock);
-	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
-		struct ccs_ip_network_acl *acl =
-			container_of(ptr, struct ccs_ip_network_acl, head);
-		if (ptr->type != CCS_TYPE_IP_NETWORK_ACL ||
-		    ptr->cond != condition ||
-		    ccs_memcmp(acl, &e, offsetof(typeof(e), address_type),
-			       sizeof(e)))
-			continue;
-		if (is_delete) {
-			acl->perm &= ~e.perm;
-			if (!acl->perm)
-				ptr->is_deleted = true;
-		} else {
-			if (ptr->is_deleted)
-				acl->perm = 0;
-			acl->perm |= e.perm;
-			ptr->is_deleted = false;
-		}
-		error = 0;
-		break;
-	}
-	if (!is_delete && error && ccs_commit_ok(entry, &e, sizeof(e))) {
-		ccs_add_domain_acl(domain, &entry->head);
-		entry = NULL;
-		error = 0;
-	}
-	mutex_unlock(&ccs_policy_lock);
- out:
-	if (w[2][0] == '@')
-		ccs_put_address_group(e.address.group);
-	else if (e.address_type == CCS_IP_ADDRESS_TYPE_IPv6) {
-		ccs_put_ipv6_address(e.address.ipv6.min);
-		ccs_put_ipv6_address(e.address.ipv6.max);
-	}
-	ccs_put_number_union(&e.port);
-	kfree(entry);
-	return error;
-}
-
-/**
  * ccs_network_listen_acl - Check permission for listen() operation.
  *
  * @is_ipv6: True if @address is an IPv6 address.
@@ -393,8 +257,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int ccs_network_listen_acl(const bool is_ipv6, const u8 *address,
-					 const u16 port)
+static int ccs_network_listen_acl(const bool is_ipv6, const u8 *address,
+				  const u16 port)
 {
 	return ccs_network_entry(is_ipv6, CCS_NETWORK_TCP_LISTEN,
 				 (const u32 *) address, ntohs(port));
@@ -410,9 +274,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int ccs_network_connect_acl(const bool is_ipv6,
-					  const int sock_type,
-					  const u8 *address, const u16 port)
+static int ccs_network_connect_acl(const bool is_ipv6, const int sock_type,
+				   const u8 *address, const u16 port)
 {
 	u8 operation;
 	switch (sock_type) {
@@ -466,8 +329,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int ccs_network_accept_acl(const bool is_ipv6, const u8 *address,
-					 const u16 port)
+static int ccs_network_accept_acl(const bool is_ipv6, const u8 *address,
+				  const u16 port)
 {
 	int retval;
 	current->ccs_flags |= CCS_DONT_SLEEP_ON_ENFORCE_ERROR;
@@ -487,9 +350,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int ccs_network_sendmsg_acl(const bool is_ipv6,
-					  const int sock_type,
-					  const u8 *address, const u16 port)
+static int ccs_network_sendmsg_acl(const bool is_ipv6, const int sock_type,
+				   const u8 *address, const u16 port)
 {
 	u8 operation;
 	if (sock_type == SOCK_DGRAM)
@@ -510,9 +372,8 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static inline int ccs_network_recvmsg_acl(const bool is_ipv6,
-					  const int sock_type,
-					  const u8 *address, const u16 port)
+static int ccs_network_recvmsg_acl(const bool is_ipv6, const int sock_type,
+				   const u8 *address, const u16 port)
 {
 	int retval;
 	const u8 operation
