<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=shift_jis">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>Policy Specifications of TOMOYO Linux</title>
<link rel="stylesheet" href="tomoyo.css" media="all" type="text/css">
</head>
<body>
<p style="text-align:right;"><a href="../../ja/1.6.x/policy-reference.html">Japanese Page</a></p>
<h1 style="text-align:center;">Policy Specifications of TOMOYO Linux</h1>
<p style="text-align:right;">Last modified: $Date: 2008-04-10 16:59:12 +0900 (Thu, 10 Apr 2008) $</p>
<h1><a name="index">Index</a></h1>
<h2>1. <a href="#Keyword_Index">Keywords Index</a></h2>
<h2>2. <a href="#Common_Rules">Introduction</a></h2>
<p>2.1 <a href="#word_expression_rules">Word Expression Rules</a></p>
<p>2.2 <a href="#wildcard_expression_rules">Wildcard Expression Rules</a></p>
<p>2.3 <a href="#word_length_rules">Word Length Rules</a></p>
<p>2.4 <a href="#line_length_rules">Line Length Rules</a></p>
<p>2.5 <a href="#memory_allocation_rules">Memory Allocation Rules</a></p>
<h2>3. <a href="#Policy_Files">Policy Files</a></h2>
<p>3.1 <a href="#policy_file_locations">Policy File's Location</a></p>
<p>3.2 <a href="#policy_file_modifiers">Policy File's Modification</a></p>
<h2>4. <a href="#Domain_Rules">Domain Rules</a></h2>
<p>4.1 <a href="#domain_definition">Domain Definition</a></p>
<p>4.2 <a href="#domain_transition">Domain Transition</a></p>
<p>4.3 <a href="#access_logs">Access Logs</a></p>
<h2>5. <a href="#Syntax_Details">Syntax Details</a></h2>
<h2>6. <a href="#Advanced_Features">Advanced Features</a></h2>
<p>6.1 <a href="#non_root_policy_update">Allowing policy modification by non root user.</a></p>
<p>6.2 <a href="#conditional_acl">Using conditional ACL.</a></p>
<p>6.3 <a href="#stateful_acl">Using stateful ACL.</a></p>
<p>6.4 <a href="#sleep_penalty">Sleep penalty for policy violation.</a></p>
<p>6.5 <a href="#execute_handler">Judging execute request outside the kernel.</a></p>
<p>6.6 <a href="#denied_execute_handler">Invoking alternative program for execute requests that are not permitted by policy.</a></p>
<hr>

<h1>1. <a name="Keyword_Index">Keywords Index</a></h1>

<p>Used by /proc/ccs/profile and /etc/ccs/profile.conf</p>

<ul>
<li><a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a></li>
<li><a href="#profile_MAC_FOR_ARGV0">MAC_FOR_ARGV0</a></li>
<li><a href="#profile_MAC_FOR_ENV">MAC_FOR_ENV</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::inet_tcp_create">MAC_FOR_CAPABILITY::inet_tcp_create</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::inet_tcp_listen">MAC_FOR_CAPABILITY::inet_tcp_listen</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::inet_tcp_connect">MAC_FOR_CAPABILITY::inet_tcp_connect</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::use_inet_udp">MAC_FOR_CAPABILITY::use_inet_udp</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::use_inet_ip">MAC_FOR_CAPABILITY::use_inet_ip</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::use_route">MAC_FOR_CAPABILITY::use_route</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::use_packet">MAC_FOR_CAPABILITY::use_packet</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::use_kernel_module">MAC_FOR_CAPABILITY::use_kernel_module</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::create_fifo">MAC_FOR_CAPABILITY::create_fifo</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::create_block_dev">MAC_FOR_CAPABILITY::create_block_dev</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::create_char_dev">MAC_FOR_CAPABILITY::create_char_dev</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::create_unix_socket">MAC_FOR_CAPABILITY::create_unix_socket</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_MOUNT">MAC_FOR_CAPABILITY::SYS_MOUNT</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_UMOUNT">MAC_FOR_CAPABILITY::SYS_UMOUNT</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_REBOOT">MAC_FOR_CAPABILITY::SYS_REBOOT</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_CHROOT">MAC_FOR_CAPABILITY::SYS_CHROOT</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_KILL">MAC_FOR_CAPABILITY::SYS_KILL</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_VHANGUP">MAC_FOR_CAPABILITY::SYS_VHANGUP</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_TIME">MAC_FOR_CAPABILITY::SYS_TIME</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_NICE">MAC_FOR_CAPABILITY::SYS_NICE</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_SETHOSTNAME">MAC_FOR_CAPABILITY::SYS_SETHOSTNAME</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_LINK">MAC_FOR_CAPABILITY::SYS_LINK</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_SYMLINK">MAC_FOR_CAPABILITY::SYS_SYMLINK</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_RENAME">MAC_FOR_CAPABILITY::SYS_RENAME</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_UNLINK">MAC_FOR_CAPABILITY::SYS_UNLINK</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_CHMOD">MAC_FOR_CAPABILITY::SYS_CHMOD</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_CHOWN">MAC_FOR_CAPABILITY::SYS_CHOWN</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_IOCTL">MAC_FOR_CAPABILITY::SYS_IOCTL</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_KEXEC_LOAD">MAC_FOR_CAPABILITY::SYS_KEXEC_LOAD</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_PIVOT_ROOT">MAC_FOR_CAPABILITY::SYS_PIVOT_ROOT</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_PTRACE">MAC_FOR_CAPABILITY::SYS_PTRACE</a></li>
<li><a href="#profile_MAC_FOR_NETWORK">MAC_FOR_NETWORK</a></li>
<li><a href="#profile_MAC_FOR_SIGNAL">MAC_FOR_SIGNAL</a></li>
<li><a href="#profile_DENY_CONCEAL_MOUNT">DENY_CONCEAL_MOUNT</a></li>
<li><a href="#profile_RESTRICT_CHROOT">RESTRICT_CHROOT</a></li>
<li><a href="#profile_RESTRICT_MOUNT">RESTRICT_MOUNT</a></li>
<li><a href="#profile_RESTRICT_UNMOUNT">RESTRICT_UNMOUNT</a></li>
<li><a href="#profile_RESTRICT_PIVOT_ROOT">RESTRICT_PIVOT_ROOT</a></li>
<li><a href="#profile_RESTRICT_AUTOBIND">RESTRICT_AUTOBIND</a></li>
<li><a href="#profile_MAX_ACCEPT_ENTRY">MAX_ACCEPT_ENTRY</a></li>
<li><a href="#profile_MAX_GRANT_LOG">MAX_GRANT_LOG</a></li>
<li><a href="#profile_MAX_REJECT_LOG">MAX_REJECT_LOG</a></li>
<li><a href="#profile_TOMOYO_VERBOSE">TOMOYO_VERBOSE</a></li>
<li><a href="#profile_ALLOW_ENFORCE_GRACE">ALLOW_ENFORCE_GRACE</a></li>
<li><a href="#profile_SLEEP_PERIOD">SLEEP_PERIOD</a></li>
</ul>

<p>Used by /proc/ccs/system_policy and /etc/ccs/system_policy.conf</p>

<ul>
<li><a href="#system_policy_allow_mount">allow_mount</a></li>
<li><a href="#system_policy_deny_unmount">deny_unmount</a></li>
<li><a href="#system_policy_allow_chroot">allow_chroot</a></li>
<li><a href="#system_policy_allow_pivot_root">allow_pivot_root</a></li>
<li><a href="#system_policy_deny_autobind">deny_autobind</a></li>
</ul>

<p>Used by /proc/ccs/exception_policy and /etc/ccs/exception_policy.conf</p>

<ul>
<li><a href="#exception_policy_aggregator">aggregator</a></li>
<li><a href="#exception_policy_initialize_domain">initialize_domain</a></li>
<li><a href="#exception_policy_no_initialize_domain">no_initialize_domain</a></li>
<li><a href="#exception_policy_keep_domain">keep_domain</a></li>
<li><a href="#exception_policy_no_keep_domain">no_keep_domain</a></li>
<li><a href="#exception_policy_file_pattern">file_pattern</a></li>
<li><a href="#exception_policy_path_group">path_group</a></li>
<li><a href="#exception_policy_address_group">address_group</a></li>
<li><a href="#exception_policy_allow_read">allow_read</a></li>
<li><a href="#exception_policy_allow_env">allow_env</a></li>
<li><a href="#exception_policy_deny_rewrite">deny_rewrite</a></li>
<li><a href="#exception_policy_alias">alias</a></li>
</ul>

<p>Used by /proc/ccs/domain_policy and /etc/ccs/domain_policy.conf</p>

<ul>
<li><a href="#domain_policy_allow_execute">allow_execute</a></li>
<li><a href="#domain_policy_allow_read">allow_read</a></li>
<li><a href="#domain_policy_allow_write">allow_write</a></li>
<li><a href="#domain_policy_allow_read/write">allow_read/write</a></li>
<li><a href="#domain_policy_allow_create">allow_create</a></li>
<li><a href="#domain_policy_allow_unlink">allow_unlink</a></li>
<li><a href="#domain_policy_allow_mkdir">allow_mkdir</a></li>
<li><a href="#domain_policy_allow_rmdir">allow_rmdir</a></li>
<li><a href="#domain_policy_allow_mkfifo">allow_mkfifo</a></li>
<li><a href="#domain_policy_allow_mksock">allow_mksock</a></li>
<li><a href="#domain_policy_allow_mkblock">allow_mkblock</a></li>
<li><a href="#domain_policy_allow_mkchar">allow_mkchar</a></li>
<li><a href="#domain_policy_allow_truncate">allow_truncate</a></li>
<li><a href="#domain_policy_allow_symlink">allow_symlink</a></li>
<li><a href="#domain_policy_allow_link">allow_link</a></li>
<li><a href="#domain_policy_allow_rename">allow_rename</a></li>
<li><a href="#domain_policy_allow_rewrite">allow_rewrite</a></li>
<li><a href="#domain_policy_allow_argv0">allow_argv0</a></li>
<li><a href="#domain_policy_allow_env">allow_env</a></li>
<li><a href="#domain_policy_allow_network">allow_network</a></li>
<li><a href="#domain_policy_allow_capability">allow_capability</a></li>
<li><a href="#domain_policy_allow_signal">allow_signal</a></li>
<li><a href="#domain_policy_use_profile">use_profile</a></li>
<li><a href="#domain_policy_ignore_global_allow_read">ignore_global_allow_read</a></li>
<li><a href="#domain_policy_ignore_global_allow_env">ignore_global_allow_env</a></li>
<li><a href="#domain_policy_execute_handler">execute_handler</a></li>
<li><a href="#domain_policy_denied_execute_handler">denied_execute_handler</a></li>
<li><a href="#domain_policy_quota_exceeded">quota_exceeded</a></li>
</ul>

<p>Used by /proc/ccs/manager and /etc/ccs/manager.conf</p>

<ul>
<li><a href="#manager_manage_by_non_root">manage_by_non_root</a></li>
</ul>

<h1>2. <a name="Common_Rules">Introduction</a></h1>

<h2>2.1 <a name="word_expression_rules">Word Expression Rules</a></h2>

<p>TOMOYO Linux performs pathname based access control. A pathname may contain not only alphabet and number but also space and carrige return and multibyte  (e.g. kanji) characters. Thus, to be able to handle any characters correctly,
TOMOYO Linux follows the rules shown below to reprenent a word. A word means all tokens that are treated as string data, such as pathnames, comments, environment variable's names, parameters for program execution.</p>

<ul>
<li>NUL character (0x00) is used for indicating end of string. Thus you cannot include \000 in a word.</li>
<li>\ character (0x5C) is used for indicating octal expression. Thus, you need to use \\ to represent a \.</li>
<li>Characters 0x01 - 0x20 and 0x7F - 0xFF are represented using octal expression \ooo .</li>
<li>The rest characters (i.e. 0x21 - 0x5B and 0x5D - 0x7E) are represented as is.</li>
</ul>

<table border="1">
<tr><td><table><tr><td></td><td>Lower 4 bits</td></tr><tr><td>Higher 4 bits</td><td></td></tr></table></td><td>0x0</td><td>0x1</td><td>0x2</td><td>0x3</td><td>0x4</td><td>0x5</td><td>0x6</td><td>0x7</td><td>0x8</td><td>0x9</td><td>0xA</td><td>0xB</td><td>0xC</td><td>0xD</td><td>0xE</td><td>0xF</td></tr>
<tr><td>0x0</td><td></td><td>\001</td><td>\002</td><td>\003</td><td>\004</td><td>\005</td><td>\006</td><td>\007</td><td>\010</td><td>\011</td><td>\012</td><td>\013</td><td>\014</td><td>\015</td><td>\016</td><td>\017</td></tr>
<tr><td>0x1</td><td>\020</td><td>\021</td><td>\022</td><td>\023</td><td>\024</td><td>\025</td><td>\026</td><td>\027</td><td>\030</td><td>\031</td><td>\032</td><td>\033</td><td>\034</td><td>\035</td><td>\036</td><td>\037</td></tr>
<tr><td>0x2</td><td>\040</td><td>!</td><td>"</td><td>#</td><td>$</td><td>%</td><td>&amp;</td><td>'</td><td>(</td><td>)</td><td>*</td><td>+</td><td>,</td><td>-</td><td>.</td><td>/</td></tr>
<tr><td>0x3</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>:</td><td>;</td><td>&lt;</td><td>=</td><td>&gt;</td><td>?</td></tr>
<tr><td>0x4</td><td>@</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td><td>I</td><td>J</td><td>K</td><td>L</td><td>M</td><td>N</td><td>O</td></tr>
<tr><td>0x5</td><td>P</td><td>Q</td><td>R</td><td>S</td><td>T</td><td>U</td><td>V</td><td>W</td><td>X</td><td>Y</td><td>Z</td><td>[</td><td>\\</td><td>]</td><td>^</td><td>_</td></tr>
<tr><td>0x6</td><td>`</td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td><td>i</td><td>j</td><td>k</td><td>l</td><td>m</td><td>n</td><td>o</td></tr>
<tr><td>0x7</td><td>p</td><td>q</td><td>r</td><td>s</td><td>t</td><td>u</td><td>v</td><td>w</td><td>x</td><td>y</td><td>z</td><td>{</td><td>|</td><td>}</td><td>~</td><td>\177</td></tr>
<tr><td>0x8</td><td>\200</td><td>\201</td><td>\202</td><td>\203</td><td>\204</td><td>\205</td><td>\206</td><td>\207</td><td>\210</td><td>\211</td><td>\212</td><td>\213</td><td>\214</td><td>\215</td><td>\216</td><td>\217</td></tr>
<tr><td>0x9</td><td>\220</td><td>\221</td><td>\222</td><td>\223</td><td>\224</td><td>\225</td><td>\226</td><td>\227</td><td>\230</td><td>\231</td><td>\232</td><td>\233</td><td>\234</td><td>\235</td><td>\236</td><td>\237</td></tr>
<tr><td>0xA</td><td>\240</td><td>\241</td><td>\242</td><td>\243</td><td>\244</td><td>\245</td><td>\246</td><td>\247</td><td>\250</td><td>\251</td><td>\252</td><td>\253</td><td>\254</td><td>\255</td><td>\256</td><td>\257</td></tr>
<tr><td>0xB</td><td>\260</td><td>\261</td><td>\262</td><td>\263</td><td>\264</td><td>\265</td><td>\266</td><td>\267</td><td>\270</td><td>\271</td><td>\272</td><td>\273</td><td>\274</td><td>\275</td><td>\276</td><td>\277</td></tr>
<tr><td>0xC</td><td>\300</td><td>\301</td><td>\302</td><td>\303</td><td>\304</td><td>\305</td><td>\306</td><td>\307</td><td>\310</td><td>\311</td><td>\312</td><td>\313</td><td>\314</td><td>\315</td><td>\316</td><td>\317</td></tr>
<tr><td>0xD</td><td>\320</td><td>\321</td><td>\322</td><td>\323</td><td>\324</td><td>\325</td><td>\326</td><td>\327</td><td>\330</td><td>\331</td><td>\332</td><td>\333</td><td>\334</td><td>\335</td><td>\336</td><td>\337</td></tr>
<tr><td>0xE</td><td>\340</td><td>\341</td><td>\342</td><td>\343</td><td>\344</td><td>\345</td><td>\346</td><td>\347</td><td>\350</td><td>\351</td><td>\352</td><td>\353</td><td>\354</td><td>\355</td><td>\356</td><td>\357</td></tr>
<tr><td>0xF</td><td>\360</td><td>\361</td><td>\362</td><td>\363</td><td>\364</td><td>\365</td><td>\366</td><td>\367</td><td>\370</td><td>\371</td><td>\372</td><td>\373</td><td>\374</td><td>\375</td><td>\376</td><td>\377</td></tr>
</table>

<ul>
<li>Space character (0x20) is used as a delimiter that separates words. Line feed character (0x0A) is used as a delimiter that separates lines.</li>
<li>Only words that follows the rule above and the delimiters (i.e. space character and line feed characters) are valid. All other characters are regarded as space character. Multiple spaces are automatically compressed into one space. Leading and trailing spaces are automatically deleted.</li>
</ul>

<p>Some examples are shown below.</p>

<table border="1">
<tr><td>Word</td><td>Correct expression</td><td>Wrong expression</td></tr>
<tr><td>Hello world!</td><td>Hello\040world!</td><td>"Hello world!"</td></tr>
<tr><td>/home/user/Documents and Settings/</td><td>/home/user/Documents\040and\040Settings/</td><td>/home/user/Documents and Settings/</td></tr>
</table>

<p>Pathname must start with / character. Pathnames that end with / character is interpreted as directories, and that don't end with / character is interpreted as non-directories.</p>

<table border="1">
<tr><td>Pathname</td><td>Interpretation</td></tr>
<tr><td>/</td><td>A directory</td></tr>
<tr><td>/tmp/</td><td>A directory</td></tr>
<tr><td>/tmp</td><td>Not a directory</td></tr>
<tr><td>tmp/</td><td>Invalid pathname</td></tr>
</table>

<p>Exceptions are pipes and sockets. Pipes begin with "pipe:" and sockets begin with "socket:" when these pathnames are accessed via /proc/PID/fd/ directory.</p>

<h2>2.2 <a name="wildcard_expression_rules">Wildcard Expression Rules</a></h2>

<p>Like temporary files, pathnames may contain randomly selected characters. Thus, you often need to define pathnames using wildcards. TOMOYO Linux supports wildcards shown below.</p>

<table border="1">
<tr><td>Wildcard</td><td>Meaning</td><td>Example</td></tr>
<tr><td>\*</td><td>More than or equals to 0 character other than '/'.</td><td>/var/log/samba/\*</td></tr>
<tr><td>\@</td><td>More than or equals to 0 character other than '/' or '.'.</td><td>/var/www/html/\@.html</td></tr>
<tr><td>\?</td><td>1 byte character other than '/'.</td><td>/tmp/mail.\?\?\?\?\?\?</td></tr>
<tr><td>\$</td><td>More than or equals to 1 decimal digit.</td><td>/proc/\$/cmdline</td></tr>
<tr><td>\+</td><td>1 decimal digit.</td><td>/var/tmp/my_work.\+</td></tr>
<tr><td>\X</td><td>More than or equals to 1 hexadecimal digit.</td><td>/var/tmp/my-work.\X</td></tr>
<tr><td>\x</td><td>1 hexadecimal digit.</td><td>/tmp/my-work.\x</td></tr>
<tr><td>\A</td><td>More than or equals to 1 alphabet character.</td><td>/var/log/my-work/\$-\A-\$.log</td></tr>
<tr><td>\a</td><td>1 alphabet character.</td><td>/home/users/\a/\*/public_html/\*.html</td></tr>
<tr><td>\-</td><td>Pathname subtraction operator.</td><td>
 <table border="1">
 <tr><td>Example</td><td>Meaning</td></tr>
 <tr><td>/etc/\*</td><td>All files in /etc/ directory.</td></tr>
 <tr><td>/etc/\*\-\*shadow\*</td><td>/etc/\* other than /etc/\*shadow\*</td></tr>
 <tr><td>/\*\-proc\-sys/</td><td>/\*/ other than /proc/ /sys/</td></tr>
 </table>
</td></tr>
</table>

<h2>2.3 <a name="word_length_rules">Word Length Rules</a></h2>

<p>There is no limitation regarding the length of pathnames in Linux. But to perform pathname based access control, it is impossible to support pathnames with infinite length. Thus, in TOMOYO Linux, the length of a word is limited to 4000 bytes including trailing NUL character.</p>

<h2>2.4 <a name="line_length_rules">Line Length Rules</a></h2>

<p>In TOMOYO Linux, the length of a line is limited to 8192 bytes including trailing NUL character.</p>

<h2>2.5 <a name="memory_allocation_rules">Memory Allocation Rules</a></h2>

<p>In TOMOYO Linux, memory allocated for holding access permissions and words are never freed. There is no way except rebooting the system that can free unneeded memory.</p>

<p>But don't worry. The policy seldom change after you start production mode. By tuning policy before starting production mode, you can reduce memory usage to (usually) less than 1 MB.</p>

<p>The memory used by TOMOYO Linux can be obtained via /proc/ccs/meminfo . The unit is byte. "Shared:" indicates memory used for holding words. "Private:" indicates memory used for holding access permissions. These memory never decrease.
"Dynamic:" indicates memory used for temporal purpose such as access permission checks and access logs. This memory decreases when it became unneeded.</p>

<table border="1">
<tr><td><pre>
# cat /proc/ccs/meminfo

Shared:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;65536
Private:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;49152
Dynamic:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5106
Total:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;119794
</pre></td></tr>
</table>

<h1>3. <a name="Policy_Files">Policy Files</a></h1>

<h2>3.1 <a name="policy_file_locations">Policy File's Location</a></h2>

<p>Policy files are files that contain access permissions. These files are automatically loaded into the kernel upon boot.</p>

<p>When a system boots, /sbin/init is executed. When the execution of /sbin/init is requested and if /sbin/ccs-init exists, /sbin/ccs-init is executed, and /sbin/init is executed after /sbin/ccs-init terminates.</p>

<p> /sbin/ccs-init loads policy files in /etc/ccs/ directory via the kernel's /proc/ccs/ interface.</p>

<table border="1">
<tr><td>The kernel's interface</td><td>Policy file</td><td>Contents</td></tr>
<tr><td><a href="#profile">/proc/ccs/profile</a></td><td>/etc/ccs/profile.conf</td><td>Profiles (Collection of access control levels)</td></tr>
<tr><td><a href="#manager">/proc/ccs/manager</a></td><td>/etc/ccs/manager.conf</td><td>Managers (Programs that can modify policy via /proc/ccs/ interface)</td></tr>
<tr><td><a href="#system_policy">/proc/ccs/system_policy</a></td><td>/etc/ccs/system_policy.conf</td><td>System policy (Access permissions given to system)</td></tr>
<tr><td><a href="#exception_policy">/proc/ccs/exception_policy</a></td><td>/etc/ccs/exception_policy.conf</td><td>Exception policy (Collection of exceptions for domain policy)</td></tr>
<tr><td><a href="#domain_policy">/proc/ccs/domain_policy</a></td><td>/etc/ccs/domain_policy.conf</td><td>Domain policy (Access permissions gioven to individual domains)</td></tr>
</table>

<p>There are more interfaces for obtaining informations. These intafaces don't have corresponding policy files.</p>

<table border="1">
<tr><td>The kernel's interface</td><td>Meaning</td></tr>
<tr><td><a href="#query">/proc/ccs/query</a></td><td>Access requests that are waiting for administrator's decision.</td></tr>
<tr><td><a href="#.domain_status">/proc/ccs/.domain_status</a></td><td>The list of domainnames and profile numbers currently defined in domain policy.</td></tr>
<tr><td><a href="#meminfo">/proc/ccs/meminfo</a></td><td>Memory usage.</td></tr>
<tr><td><a href="#grant_log">/proc/ccs/grant_log</a></td><td>Access requests that didn't violate domain policy.</td></tr>
<tr><td><a href="#reject_log">/proc/ccs/reject_log</a></td><td>Access requests that violated domain policy.</td></tr>
<tr><td><a href="#self_domain">/proc/ccs/self_domain</a></td><td>The name of domain the current process belongs to.</td></tr>
<tr><td><a href="#.process_status">/proc/ccs/.process_status</a></td><td>The list of domainnames and profile numbers currently running processes belongs to.</td></tr>
<tr><td><a href="#.updates_counter">/proc/ccs/.updates_counter</a></td><td>Counter for policy updates.</td></tr>
<tr><td><a href="#version">/proc/ccs/version</a></td><td>Version of TOMOYO Linux.</td></tr>
</table>

<h2>3.2 <a name="policy_file_modifiers">Policy File's Modification</a></h2>

<p>Register the name of programs or domains that can modify policy via the kernel's /proc/ccs/ interface. Only</p>

<ul>
<li>Processes with programs listed in /proc/ccs/manager</li>
<li>Processes with domainnames listed in /proc/ccs/manager</li>
</ul>

<p>can modify policy via the kernel's /proc/ccs/ interface. Some examples are show below.</p>

<table border="1">
<tr><td>
# cat /proc/ccs/manager<br>
/usr/lib/ccs/loadpolicy<br>
/usr/lib/ccs/editpolicy<br>
/usr/lib/ccs/setlevel<br>
/usr/lib/ccs/setprofile<br>
/usr/lib/ccs/ld-watch<br>
/usr/lib/ccs/ccs-queryd<br>
&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash
</td></tr>
</table>

<p>By default, only processes with UID = 0 and EUID = 0 can modify policy via this interface. But by doing configurations described in <a href="#non_root_policy_update">Allowing policy modification by non root user.</a>, non root user can modify policy via this interface.</p>

<p>Exception is, processes that blong to domains with profiles for learning mode can append access permissions to <a href="#system_policy">/proc/ccs/system_policy</a> and <a href="#domain_policy">/proc/ccs/domain_policy</a> by simply requesting the access.</p>

<h1>4. <a name="Domain_Rules">Domain Rules</a></h1>

<h2>4.1 <a name="domain_definition">Domain Definition</a></h2>

<p>TOMOYO Linux has two patterns of policies. One gives access permissions as a whole system. The other gives access permissions as per a domain. The former is called system policy and is managed via <a href="#system_policy">/proc/ccs/system_policy</a>. The latter is called domain policy and is managed via <a href="#domain_policy">/proc/ccs/domain_policy</a>.</p>

<p>In TOMOYO Linux, every process belongs to a single domain, and all programs belong to different domain. Even the two processes are executing the same program, if their previous domains differ, they belong to different domain.</p>

<p>All domains are defined originating from "&lt;kernel&gt;" domain, which the kernel process belongs to. Since /sbin/init is invoked by the "&lt;kernel&gt;" domain, the domain for /sbin/init is defined as "&lt;kernel&gt; /sbin/init". Since /etc/rc.d/rc is invoked by /sbin/init invoked by the kernel, the domain for /etc/rc.d/rc is defined as "&lt;kernel&gt; /sbin/init /etc/rc.d/rc".</p>

<h2>4.2 <a name="domain_transition">Domain Transition</a></h2>

<p>There are some programs that behave differently depending on the invocation name.
For example, /sbin/pidof is a symbolic link to /sbin/killall5 . Since TOMOYO Linux uses canonicalized pathname, by default, if /sbin/pidof is executed, the domain is defined as if /sbin/killall5 is executed.</p>

<p>When a process tries to execute a program, the steps shown below are performed.</p>

<table border="1">
<tr><td>Step</td><td>Procedure</td></tr>
<tr><td>Getting program's name</td><td>
<p>Get the name of program that the process is going to execute and keep it as "Candidate 1". This procedure solves symbolic link if the program is a symbolic link.</p>
<p>Get the name of program that the process is going to execute and keep it as "Candidate 2". This procedure does not solve symbolic link if the program is a symbolic link.</p>
</td></tr>
<tr><td>Handling symbolic links</td><td>
<p>If "Candidate 1" and "Candidate 2" differ, search exception policy for</p>

<ul>
<li>alias "Candidate 1" "Candidate 2"
</ul>

<p>and if found one, replace "Candidate 1" with "Candidate 2".</p>
</td></tr>
<tr><td><a name="exec_stage_check_argv0">Checking argv[0]</a></td><td>
<p>If the basename of "Candidate 1" and the basename of argv[0] differ, search domain policy for</p>

<ul>
<li>allow_argv0 "Candidate 1" "the basename of argv[0]"
</ul>

<p>and deny the execute request if not found one.</p>
</td></tr>
<tr><td>Aggregating similar programs</td><td>
<p>Search exception policy for</p>

<ul>
<li>aggregator "Candidate 1" "aggregated name"
</ul>

<p>and if found one, replace "Candidate 1" with "aggregated name".</p>
</td></tr>
<tr><td><a name="exec_stage_check_execute">Checking permission</a></td><td>
<p>Search domain policy for</p>

<ul>
<li>allow_execute "Candidate 1"
<li>allow_execute @"a pathname group containing Candidate 1"
</ul>

<p>and deny the execute request if not found one.</p>
</td></tr>
<tr><td><a name="exec_stage_check_destination">Deciding destination domain</a></td><td>

<p>(1) Search exception policy for</p>

<ul>
<li>no_initialize_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>no_initialize_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>no_initialize_domain "Candidate 1"
</ul>

<p>and if found one, jump to (3).</p>

<p>(2) Search exception policy for</p>

<ul>
<li>initialize_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>initialize_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>initialize_domain "Candidate 1"
</ul>

<p>and if found one, concatenate "the name of the domain that the kernel belongs to (i.e. &lt;kernel&gt;)" and "Candidate 1" and keep the result as destination domain, then jump to (6).</p>

<p>(3) Search exception policy for</p>

<ul>
<li>no_keep_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>no_keep_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>no_keep_domain "the name of the domain the current process belongs to"
<li>no_keep_domain "the last part of the name of the domain the current process belongs to"
</ul>

<p>and if found one, jump to (5).</p>

<p>(4) Search exception policy for</p>

<ul>
<li>keep_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>keep_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>keep_domain "the name of the domain the current process belongs to"
<li>keep_domain "the last part of the name of the domain the current process belongs to"
</ul>

<p>and if found one, set "the name of the domain the current process belongs to" as destination domain, then jump to (6).</p>

<p>(5) Concatenate "the name of the domain the current process belongs to" and "Candidate 1" and keep the result as destination domain.</p>

<p>(6) Check whether the destination domain is defined, and deny the execute request if not.</p>

</td></tr>
<tr><td>Checking environment variable names</td><td>

<p>(1) Examine all environment variables' names are granted in the destination domain, and deny the execute request if more than one of them are not granted.</p>

<p>(2) Perform regular steps for executing program. If successfully completed, the process transits to destination domain.</p>
</td></tr>
</table>

<p>There is an exception. If either</p>

<ul>
<li>The execute request was denied at "<a href="#exec_stage_check_argv0">Checking argv[0]</a>" or "<a href="#exec_stage_check_execute">Checking permission</a>" or "<a href="#exec_stage_check_destination">Deciding destination domain</a>" but the domain the process that issued execute request belongs to has <a href="#domain_policy_denied_execute_handler">denied_execute_handler</a> keyword.</li>
<li>The domain the process that issued execute request belongs to has <a href="#domain_policy_execute_handler">execute_handler</a> keyword.</li>
</ul>

<p>and</p>

<ul>
<li>The process that issued execute request is not a process executed by <a href="#domain_policy_execute_handler">execute_handler</a> or <a href="#domain_policy_denied_execute_handler">denied_execute_handler</a> keyword.</li>
</ul>

<p>the steps shown below is performed instead for the steps shown above. The usage of this exception is explained in "<a href="#execute_handler">Judging execute request outside the kernel.</a>" and "<a href="#denied_execute_handler">Invoking alternative program for execute requests that are not permitted by policy.</a>"</p>

<table border="1">
<tr><td>Step</td><td>Procedure</td></tr>
<tr><td>Getting program's name</td><td>
<p>Keep the pathname of the program specified by <a href="#domain_policy_denied_execute_handler">denied_execute_handler</a> or <a href="#domain_policy_execute_handler">execute_handler</a> and keep it as "Candidate 1".</p>
</td></tr>
<tr><td>Appending information</td><td>
<p>Append all environment variables to the tail of arguments, and delete all environment variables.</p>
<p>Insert "Candidate 1" "the domainname the process that issued execute request belongs to" "the pathname of the process that issued execute request" "state of the process that issued execute request" "the pathname of the requested program" "number of arguments" "number of environment variables" to the top of arguments.</p>
</td></tr>
<tr><td>Deciding destination domain</td><td>

<p>(1) Search exception policy for</p>

<ul>
<li>no_initialize_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>no_initialize_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>no_initialize_domain "Candidate 1"
</ul>

<p>and if found one, jump to (3).</p>

<p>(2) Search exception policy for</p>

<ul>
<li>initialize_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>initialize_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>initialize_domain "Candidate 1"
</ul>

<p>and if found one, concatenate "the name of the domain that the kernel belongs to (i.e. &lt;kernel&gt;)" and "Candidate 1" and keep the result as destination domain, then jump to (6).</p>

<p>(3) Search exception policy for</p>

<ul>
<li>no_keep_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>no_keep_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>no_keep_domain "the name of the domain the current process belongs to"
<li>no_keep_domain "the last part of the name of the domain the current process belongs to"
</ul>

<p>and if found one, jump to (5).</p>

<p>(4) Search exception policy for</p>

<ul>
<li>keep_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>keep_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>keep_domain "the name of the domain the current process belongs to"
<li>keep_domain "the last part of the name of the domain the current process belongs to"
</ul>

<p>and if found one, set "the name of the domain the current process belongs to" as destination domain, then jump to (6).</p>

<p>(5) Concatenate "the name of the domain the current process belongs to" and "Candidate 1" and keep the result as destination domain.</p>

<p>(6) Check whether the destination domain is defined, and deny the execute request if not.</p>

</td></tr>
<tr><td>Execute program</td><td>

<p>Perform regular steps for executing program. If successfully completed, the process transits to destination domain.</p>

</td></tr>
</table>

<h2>4.3 <a name="access_logs">Access Logs</a></h2>

<p>ドメインポリシによって許可されたアクセス要求のログと拒否されたアクセス要求のログを生成します。前者は許可ログと呼ばれ、 /proc/ccs/grant_log から取得することができます。後者は拒否ログと呼ばれ、 /proc/ccs/reject_log から取得することができます。これらのログを取得してファイルとして保存するためのツールとして /usr/lib/ccs/ccs-auditd というプログラムが付属しています。</p>

<p>以下に例を示します。最初の例はプログラムを実行しようとしたときのログです。</p>

<table border="1">
<tr><td>
#2008-04-09 12:50:15# profile=1 mode=learning pid=5054 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 state[0]=0 state[1]=0 state[2]=0 argc=2 envc=16 argv[]={ "cat" "/etc/fstab" } envp[]={ "TERM=vt100" "SHELL=/bin/bash" "SSH_CLIENT=::ffff:192.168.99.1\04048601\04022" "SSH_TTY=/dev/pts/0" "USER=root" "MAIL=/var/mail/root" "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/lib/ccs" "PWD=/root" "LANG=C" "PS1=\\h:\\w\\$\040" "SHLVL=1" "HOME=/root" "LANGUAGE=en_JP:en_US:en_GB:en" "LOGNAME=root" "SSH_CONNECTION=::ffff:192.168.99.1\04048601\040::ffff:192.168.99.152\04022" "_=/bin/cat" }<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
allow_execute /bin/cat
</td></tr>
</table>

<p>このログは、 &lt;kernel&gt; /usr/sbin/sshd /bin/bash というドメインに属しているプロセスが /bin/cat というプログラムを実行しようとし、そのときの引数の内容は "cat" "/etc/fstab" 、環境変数の内容は "TERM=vt100" "SHELL=/bin/bash" "SSH_CLIENT=::ffff:192.168.99.1\04048601\04022" "SSH_TTY=/dev/pts/0" "USER=root" "MAIL=/var/mail/root" "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/lib/ccs" "PWD=/root" "LANG=C" "PS1=\\h:\\w\\$\040" "SHLVL=1" "HOME=/root" "LANGUAGE=en_JP:en_US:en_GB:en" "LOGNAME=root" "SSH_CONNECTION=::ffff:192.168.99.1\04048601\040::ffff:192.168.99.152\04022" "_=/bin/cat" であったということを示しています。また、プロセスＩＤやユーザＩＤなど、プロセスに関する情報も一緒に出力されます。</p>

<p>次の例は、ファイルを読み込みモードでオープンしようとしたときのログです。</p>

<table border="1">
<tr><td>
#2008-04-09 12:50:15# profile=1 mode=learning pid=5054 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 state[0]=0 state[1]=0 state[2]=0<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/cat<br>
allow_read /etc/fstab
</td></tr>
</table>

<p>このログは、 &lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/cat というドメインに属しているプロセスが /etc/fstab というファイルをオープンしようとしたことを示しています。</p>

<p>次の例は、ドメインが新規作成されたときのログです。</p>

<table border="1">
<tr><td>
#2008-04-09 12:52:01# profile=1 mode=learning pid=5110 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 state[0]=0 state[1]=0 state[2]=0<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash /bin/audit-exec-param /bin/cat<br>
use_profile 1
</td></tr>
</table>

<p>このログは、 &lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash /bin/audit-exec-param /bin/cat というドメインが新規作成され、プロファイルとして 1 が割り当てられたことを示しています。 TOMOYO Linux では、ドメインが自動的に新規作成されていきます。自動的に新規作成された場合には、ドメインを新規作成することになったプロセスの属しているドメインに割り当てられていたプロファイル番号が引き継がれます。</p>

<p>次の例は、<a href="#execute_handler">Judging execute request outside the kernel.</a>するために要求されたのとは異なるプログラムが実行されたときのログです。</p>
<table border="1">
<tr><td>
#2008-04-09 12:52:01# profile=1 mode=learning pid=5110 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 state[0]=0 state[1]=0 state[2]=0 argc=24 envc=0 argv[]={ "/bin/audit-exec-param" "&lt;kernel&gt;\040/usr/sbin/sshd\040/bin/bash\040/bin/bash" "/bin/bash" "pid=5110\040uid=0\040gid=0\040euid=0\040egid=0\040suid=0\040sgid=0\040fsuid=0\040fsgid=0\040state[0]=0\040state[1]=0\040state[2]=0" "/bin/cat" "2" "18" "cat" "/etc/fstab" "SHELL=/bin/bash" "TERM=vt100" "SSH_CLIENT=::ffff:192.168.99.1\04048601\04022" "SSH_TTY=/dev/pts/0" "USER=root" "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/lib/ccs" "MAIL=/var/mail/root" "_=/bin/cat" "PWD=/root" "LANG=C" "HOME=/root" "SHLVL=2" "LANGUAGE=en_JP:en_US:en_GB:en" "LOGNAME=root" "SSH_CONNECTION=::ffff:192.168.99.1\04048601\040::ffff:192.168.99.152\04022" } envp[]={ }<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash<br>
execute_handler /bin/audit-exec-param
</td></tr>
</table>

<p>このログは、 &lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash というドメインに属しているプロセスがプログラムを実行しようとしたが、 execute_handler が指定されていたので代わりに /bin/audit-exec-param というプログラムが実行されたこと、 /bin/audit-exec-param に渡された引数の内容は "/bin/audit-exec-param" "&lt;kernel&gt;\040/usr/sbin/sshd\040/bin/bash\040/bin/bash" "/bin/bash" "pid=5110\040uid=0\040gid=0\040euid=0\040egid=0\040suid=0\040sgid=0\040fsuid=0\040fsgid=0\040state[0]=0\040state[1]=0\040state[2]=0" "/bin/cat" "2" "18" "cat" "/etc/fstab" "SHELL=/bin/bash" "TERM=vt100" "SSH_CLIENT=::ffff:192.168.99.1\04048601\04022" "SSH_TTY=/dev/pts/0" "USER=root" "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/lib/ccs" "MAIL=/var/mail/root" "_=/bin/cat" "PWD=/root" "LANG=C" "HOME=/root" "SHLVL=2" "LANGUAGE=en_JP:en_US:en_GB:en" "LOGNAME=root" "SSH_CONNECTION=::ffff:192.168.99.1\04048601\040::ffff:192.168.99.152\04022" であったということを示しています。 LD_PRELOAD などの環境変数によって  /bin/audit-exec-param の動作が左右されるのを防ぐため、環境変数を引数に移動しています。</p>

<p>このように、アクセスログは 3 行で 1 件（ /usr/lib/ccs/ccs-auditd によってファイルに保存されるときに空行が入るので 4 行で 1 件）となっており、これらのログはそのままドメインポリシとして追加可能な形式になっています。アクセス拒否ログから許可したい部分を抽出して、例えば /var/log/tomoyo/diff.txt という名前で保存した後、</p>

<table border="1">
<tr><td>
# /usr/lib/ccs/loadpolicy -d &lt; /var/log/tomoyo/diff.txt
</td></tr>
</table>

<p>という操作を行うことで、ドメインポリシに追加することができます。そのため、「学習モード」を使わなくても、最初から「許容モード」を使って拒否ログを出力させ、拒否ログの内容を編集するというアプローチでもドメインポリシを定義していくことができます。「学習モード」でドメインポリシを作成する場合にはプロセスの状態（アクセスログの先頭行の内容）は加味されませんが、アクセス拒否ログからドメインポリシを生成すると、最初から<a href="#conditional_acl">Using conditional ACL.</a>を行うことができます。例えば、「学習モード」を使わずにログを生成し、</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
allow_execute /bin/cat if exec.argc=2 exec.argv[0]="cat" exec.argv[1]="/etc/fstab"
</td></tr>
</table>

<p>としてドメインポリシを追加した場合、「学習モード」で追加される</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
allow_execute /bin/cat
</td></tr>
</table>

<p>よりも細かい指定を行うことができるようになります。</p>

<h1>5. <a name="Syntax_Details">Syntax Details</a></h1>

<h2><a name="profile">/proc/ccs/profile</a></h2>

<p>TOMOYO Linux では、ファイル以外にもいくつかの項目について強制アクセス制御を行うことができますが、ポリシ管理の負担を減らすために、必要の無い機能を無効化できるようになっています。</p>

<p>有効にしたい機能とそのモードを「 プロファイル番号-項目=値 」という形式で定義します。プロファイル番号は 0 〜 255 が指定可能です。プロファイルの内容を変更するには setlevel コマンドまたは loadpolicy コマンドを使用します。</p>

<p>各ドメインには 1 個のプロファイルが割り当てられます。ドメインにプロファイルを割り当てるには setprofile コマンドまたは editpolicy コマンドまたは loadpolicy コマンドを使用します。</p>

<p>現在ドメインに割り当てられているプロファイル番号は editpolicy コマンドで確認できます。<br>
現在動作中のプロセスに割り当てられているプロファイル番号は ccstree コマンドで確認できます。<br>
現在のポリシを savepolicy コマンドで保存した場合、 <a href="#domain_policy_use_profile">use_profile</a> というキーワードに保持されます。</p>

<p>現在のプロファイルを読み出しまたは追加するには以下のように操作します。</p>

<p>（例）<br>
cat /proc/ccs/profile<br>
savepolicy -p<br>
setlevel 1-MAC_FOR_FILE=learning<br>
echo 1-MAC_FOR_FILE=learning | loadpolicy -p</p>

<p>関連項目：<a href="#policy_file_modifiers">Policy File's Modification</a></p>

<h3><a name="profile_MAC_FOR_FILE">MAC_FOR_FILE</a></h3>

<p>ファイルに対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.
ポリシへの自動追加も行いません。</td></tr>
<tr><td>enforcing</td><td>強制モード。ポリシに違反したらエラーとします。</td></tr>
</table>

<h3><a name="profile_MAC_FOR_ARGV0">MAC_FOR_ARGV0</a></h3>

<p>プログラム実行時の argv[0] に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_ENV">MAC_FOR_ENV</a></h3>

<p>プログラム実行時の環境変数名に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::inet_tcp_create">MAC_FOR_CAPABILITY::inet_tcp_create</a></h3>

<p>TCP ソケットの使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::inet_tcp_listen">MAC_FOR_CAPABILITY::inet_tcp_listen</a></h3>

<p>TCP ソケットの listen に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::inet_tcp_connect">MAC_FOR_CAPABILITY::inet_tcp_connect</a></h3>

<p>TCP ソケットの connect に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::use_inet_udp">MAC_FOR_CAPABILITY::use_inet_udp</a></h3>

<p>UDP ソケットの使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::use_inet_ip">MAC_FOR_CAPABILITY::use_inet_ip</a></h3>

<p>RAW ソケットの使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::use_route">MAC_FOR_CAPABILITY::use_route</a></h3>

<p>ROUTE ソケットの使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::use_packet">MAC_FOR_CAPABILITY::use_packet</a></h3>

<p>PACKET ソケットの使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::use_kernel_module">MAC_FOR_CAPABILITY::use_kernel_module</a></h3>

<p>create_module(2) init_module(2) delete_module(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::create_fifo">MAC_FOR_CAPABILITY::create_fifo</a></h3>

<p>mknod(2) で FIFO の作成に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::create_block_dev">MAC_FOR_CAPABILITY::create_block_dev</a></h3>

<p>mknod(2) でブロック型デバイスの作成に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::create_char_dev">MAC_FOR_CAPABILITY::create_char_dev</a></h3>

<p>mknod(2) でキャラクタ型デバイスの作成に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::create_unix_socket">MAC_FOR_CAPABILITY::create_unix_socket</a></h3>

<p>mknod(2) で UNIX ドメインソケットの作成に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_MOUNT">MAC_FOR_CAPABILITY::SYS_MOUNT</a></h3>

<p>mount(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_UMOUNT">MAC_FOR_CAPABILITY::SYS_UMOUNT</a></h3>

<p>umount(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_REBOOT">MAC_FOR_CAPABILITY::SYS_REBOOT</a></h3>

<p>reboot(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_CHROOT">MAC_FOR_CAPABILITY::SYS_CHROOT</a></h3>

<p>chroot(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_KILL">MAC_FOR_CAPABILITY::SYS_VHANGUP</a></h3>

<p>0 以外のシグナルで kill(2) tkill(2) tgkill(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_VHANGUP">MAC_FOR_CAPABILITY::SYS_VHANGUP</a></h3>

<p>vhangup(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_TIME">MAC_FOR_CAPABILITY::SYS_TIME</a></h3>

<p>stime(2) settimeofday(2) adjtimex(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_NICE">MAC_FOR_CAPABILITY::SYS_NICE</a></h3>

<p>nice(2) setpriority(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_SETHOSTNAME">MAC_FOR_CAPABILITY::SYS_SETHOSTNAME</a></h3>

<p>sethostname(2) setdomainname(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_LINK">MAC_FOR_CAPABILITY::SYS_LINK</a></h3>

<p>link(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_SYMLINK">MAC_FOR_CAPABILITY::SYS_SYMLINK</a></h3>

<p>symlink(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_RENAME">MAC_FOR_CAPABILITY::SYS_RENAME</a></h3>

<p>symlink(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_UNLINK">MAC_FOR_CAPABILITY::SYS_UNLINK</a></h3>

<p>symlink(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_CHMOD">MAC_FOR_CAPABILITY::SYS_CHMOD</a></h3>

<p>chmod(2) fchmod(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_CHOWN">MAC_FOR_CAPABILITY::SYS_CHOWN</a></h3>

<p>chown(2) fchown(2) lchown(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_IOCTL">MAC_FOR_CAPABILITY::SYS_IOCTL</a></h3>

<p>chown(2) fchown(2) lchown(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_KEXEC_LOAD">MAC_FOR_CAPABILITY::SYS_KEXEC_LOAD</a></h3>

<p>kexec_load(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_PIVOT_ROOT">MAC_FOR_CAPABILITY::SYS_PIVOT_ROOT</a></h3>

<p>pivot_root(2) の使用に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_PTRACE">MAC_FOR_CAPABILITY::SYS_PTRACE</a></h3>

<p>ptrace(2) の使用に対する強制アクセス制御のレベルを指定します。<br>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_NETWORK">MAC_FOR_NETWORK</a></h3>

<p>ネットワークに対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_SIGNAL">MAC_FOR_SIGNAL</a></h3>

<p>シグナルの送信に対する強制アクセス制御のレベルを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_DENY_CONCEAL_MOUNT">DENY_CONCEAL_MOUNT</a></h3>
<p>既存のマウントを隠蔽するようなマウントを禁止します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>permissive</td><td>許容モード。既存のマウントを隠蔽するようなマウント要求に対して警告メッセージを表示しますが、拒否はしません。</td></tr>
<tr><td>enforcing</td><td>強制モード。既存のマウントを隠蔽するようなマウント要求に対してエラーメッセージを表示し、拒否します。</td></tr>
</table>

<h3><a name="profile_RESTRICT_CHROOT">RESTRICT_CHROOT</a></h3>

<p>chroot で移動可能なディレクトリの制限を有効にします。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_RESTRICT_MOUNT">RESTRICT_MOUNT</a></h3>

<p>mount で指定可能なパラメータの制限を有効にします。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_RESTRICT_UNMOUNT">RESTRICT_UNMOUNT</a></h3>

<p>指定されたディレクトリのアンマウントを禁止します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>permissive</td><td>許容モード。指定されたディレクトリのアンマウント要求に対して警告メッセージを表示しますが、拒否はしません。</td></tr>
<tr><td>enforcing</td><td>強制モード。指定されたディレクトリのアンマウント要求に対してエラーメッセージを表示し、拒否します。</td></tr>
</table>

<h3><a name="profile_RESTRICT_PIVOT_ROOT">RESTRICT_PIVOT_ROOT</a></h3>

<p>pivot_root で交換可能なディレクトリの制限を有効にします。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_RESTRICT_AUTOBIND">RESTRICT_AUTOBIND</a></h3>

<p>ローカルのポート番号を自動選択させる際に特定のポート番号を選択させないようにするかどうかを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>enabled</td><td>有効。ローカルのポート番号を自動選択させる際に、特定のポート番号を選択させないようにします。</td></tr>
</table>

<h3><a name="profile_MAX_ACCEPT_ENTRY">MAX_ACCEPT_ENTRY</a></h3>

<p>学習モードに於いて自動的に追加されるアクセス許可の上限を指定します。デフォルトは 2048 件です。</p>

<h3><a name="profile_MAX_GRANT_LOG">MAX_GRANT_LOG</a></h3>

<p>カーネル内に保持する、ポリシによって許可されたアクセス要求のログの件数を指定します。デフォルトは 1024 件です。</p>

<h3><a name="profile_MAX_REJECT_LOG">MAX_REJECT_LOG</a></h3>

<p>カーネル内に保持する、ポリシによって許可されなかったアクセス要求のログの件数を指定します。デフォルトは 1024 件です。</p>

<h3><a name="profile_TOMOYO_VERBOSE">TOMOYO_VERBOSE</a></h3>

<p>ドメインポリシに対する違反を syslog に表示するかどうかを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>ドメインポリシに対する違反を表示しません。</td></tr>
<tr><td>enabled</td><td>ドメインポリシに対する違反を表示します。</td></tr>
</table>

<h3><a name="profile_ALLOW_ENFORCE_GRACE">ALLOW_ENFORCE_GRACE</a></h3>

<p>強制モードに於いてポリシに違反したアクセス要求を対話的に許可できるようにするかどうかを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>強制モードでポリシに違反したら直ちに拒否します。</td></tr>
<tr><td>enabled</td><td>強制モードでポリシに違反しても、対話的な操作により許可することを可能にします。</td></tr>
</table>

<h3><a name="profile_SLEEP_PERIOD">SLEEP_PERIOD</a></h3>

<p>強制モードに於いてポリシ違反が発生した場合にスリープさせるかどうかを指定します。</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>0 〜 3000</td><td>スリープさせる時間を 0.1 秒単位で指定します。デフォルトは 0 秒です。</td></tr>
</table>

<h2>

<a name="system_policy">/proc/ccs/system_policy</a></h2>

<p>このファイルでは、システム全体として与えるアクセス許可を定義します。</p>

<p>現在のシステムポリシを読み出しまたは追加または削除するには以下のように操作します。</p>
<p>（例）<br>
cat /proc/ccs/system_policy<br>
savepolicy -s<br>
echo 'allow_mount /proc /proc/ proc' | loadpolicy -s<br>
echo 'delete allow_mount /proc /proc/ proc' | loadpolicy -s</p>

<p>関連項目：<a href="#policy_file_modifiers">Policy File's Modification</a></p>

<h3><a name="system_policy_allow_mount">allow_mount</a></h3>
<p>マウント許可を指定するには、 allow_mount というキーワードに続けて、「デバイスファイル マウントポイント ファイルシステム オプション」を指定します。 デバイスファイルを必要とするファイルシステムを指定する場合は、デバイスファイルは正規化されたファイル名でなければいけません。マウントポイントは正規化されたディレクトリ名でなければいけません。オプションは 16 進数の数値で指定します。</p>

<p>「 any マウントポイント --remount オプション」と指定すると、「 mount -o remount マウントポイント」が許可されます。</p>

<p>「複製元 複製先 --bind オプション」と指定すると、「 mount --bind 複製元 複製先」が許可されます。<br>
「移動元 移動先 --move オプション」と指定すると、「 mount --move 移動元 移動先」が許可されます。<br>
複製元／複製先／移動元／移動先は正規化されたディレクトリ名でなければなりません。</p>

<p>カーネル 2.6.15 以降では、 Shared Subtree という機能が利用できます。<br>
「 any マウントポイント --make-unbindable オプション」と指定すると、「 mount --make-unbindable マウントポイント」が許可されます。<br>
「 any マウントポイント --make-private オプション」と指定すると、「 mount --make-private マウントポイント」が許可されます。<br>
「 any マウントポイント --make-slave オプション」と指定すると、「 mount --make-slave マウントポイント」が許可されます。<br>
「 any マウントポイント --make-shared オプション」と指定すると、「 mount --make-shared マウントポイント」が許可されます。
</p>

<p>（例）<br>
allow_mount none /dev/pts/ devpts 0x0<br>
allow_mount /proc /proc/ proc 0x0<br>
allow_mount usbdevfs /proc/bus/usb/ usbdevfs 0x0<br>
allow_mount none /data/ tmpfs 0xE<br>
allow_mount none /dev/shm/ tmpfs 0xE<br>
allow_mount /dev/hdc /var/www/ ext2 0xF<br>
allow_mount any / --remount 0x0</p>

<h3><a name="system_policy_deny_unmount">deny_unmount</a></h3>
<p>アンマウント禁止を指定するには、 deny_unmount というキーワードに続けて、アンマウントを許可しない正規化されたディレクトリ名を指定します。<br>
通常、 /sbin/mingetty が使用する /dev/tty? を含む /dev/ ディレクトリと、リモートログインする場合に pty デバイスファイルが作成される /dev/pts/ ディレクトリを指定します。</p>
<p>/dev が読み込み専用になってしまったり、 /dev/pts がアンマウントされてしまうと、ログインができなくなってしまいます。そのため、 / が読み込み専用のシステムでは、 /dev/ や /dev/pts/ がアンマウントされないようにしなければなりません。</p>

<p>（例）<br>
deny_unmount /dev/<br>
deny_unmount /dev/pts/<br>
deny_unmount /proc/</p>

<h3><a name="system_policy_allow_chroot">allow_chroot</a></h3>
<p>chroot 許可を指定するには、 allow_chroot というキーワードに続けて、 chroot で移動することを許可したい正規化されたディレクトリ名を指定します。<br>
通常、 sshd が使用する /var/empty/sshd/ を指定します。 その他に chroot 環境で動かしたいアプリケーションや、 chroot を行うアプリケーション（ vsftpd の場合 /usr/share/empty/ ）が存在する場合は、それらも指定します。</p>

<p>（例）<br>
allow_chroot /var/empty/sshd/<br>
allow_chroot /usr/share/empty/<br>
allow_chroot /var/www/html/<br>
allow_chroot /</p>

<h3><a name="system_policy_allow_pivot_root">allow_pivot_root</a></h3>
<p>pivot_root 許可を指定するには、 allow_pivot_root というキーワードに続けて、新しいルートとなる正規化されたディレクトリ名と古いルートディレクトリとなる正規化されたディレクトリ名を指定します。<br>
通常、このキーワードを使う必要はありません。</p>

<h3><a name="system_policy_deny_autobind">deny_autobind</a></h3>
<p>ローカルポートの自動選択で特定のポート番号が選択させるのを禁止するには、 deny_autobind というキーワードに続けて、ローカルポート番号を指定します。 このキーワードは、特定のポート番号が一時的な用途で割り当てられるのを防ぐのが狙いです。例えば、一部のプロキシサーバはポート 8080 を使用するので、ポート 8080 が一時的な用途のために割り当てられるべきではありません。</p>

<p>（例）<br>
deny_autobind 1-1023<br>
deny_autobind 8080</p>

<h2><a name="domain_policy">/proc/ccs/domain_policy</a></h2>

<p>このファイルでは、全てのドメインを定義し、各ドメインに対して与えるアクセス許可を定義します。</p>

<p>ドメインを定義している行（ &lt;kernel&gt; で始まる行）の次行から次のドメインを定義している行の前行までが、そのドメインに対するアクセス許可です。</p>

<p>それぞれのアクセス許可について、必要に応じて追加の条件を指定することができます。そのための構文は<a href="#conditional_acl">Using conditional ACL.</a>で説明します。さらに、必要に応じてプロセスの状態を切り替え、プロセスの状態も条件として使うための方法を<a href="#stateful_acl">Using stateful ACL.</a>で説明します。</p>

<p>現在のドメインポリシを読み出しまたは追加または削除するには、以下のように操作します。</p>
<p>（例）ドメインを選択してアクセス許可を追加（ドメインが存在しない場合は作成されます）<br>
printf "&lt;kernel&gt; /sbin/init\nallow_read /etc/passwd\n" | loadpolicy -d</p>
<p>（例）ドメインを選択してアクセス許可を追加（ドメインが存在しない場合は作成されません）<br>
printf "select &lt;kernel&gt; /sbin/init\nallow_read /etc/passwd\n" | loadpolicy -d</p>
<p>（例）ドメインを選択してアクセス許可を削除<br>
printf "select &lt;kernel&gt; /sbin/init\ndelete allow_read /etc/passwd\ndelete allow_read /etc/shadow\n" | loadpolicy -d</p>
<p>（例）特定のドメインを削除<br>
printf "delete &lt;kernel&gt; /sbin/init\n" | loadpolicy -d</p>
<p>（例）ドメインポリシの読み出し<br>
cat /proc/ccs/domain_policy</p>

<p>関連項目：<a href="#policy_file_modifiers">Policy File's Modification</a></p>

<h3><a name="domain_policy_allow_execute">allow_execute</a></h3>
<p>指定されたパス名を実行することを許可します。パス名にワイルドカードを使用することは認められていません。ワイルドカードで指定しなければ対応できない場合には、プログラム名をグループ化してからアクセス許可を与えてください。</p>
<p>（例） allow_execute /bin/ls</p>
<p>関連項目：<a href="#domain_transition">ドメイン遷移</a> <a href="#exception_policy_path_group">path_group</a> <a href="#exception_policy_aggregator">aggregator</a></p>

<h3><a name="domain_policy_allow_write">allow_write</a></h3>
<p>指定されたパス名を書き込みモードでオープンすることを許可します。</p>
<p>（例） allow_write /dev/null</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_read">allow_read</a></h3>
<p>指定されたパス名を読み込みモードでオープンすることを許可します。</p>
<p>（例） allow_read /proc/meminfo</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_read/write">allow_read/write</a></h3>
<p>指定されたパス名を読み書きモードでオープンすることを許可します。</p>
<p>（例） allow_read/write /dev/null</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_create">allow_create</a></h3>
<p>指定されたパス名のファイルを新規作成することを許可します。</p>
<p>（例） allow_create /var/lock/subsys/crond</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_unlink">allow_unlink</a></h3>
<p>指定されたパス名を削除することを許可します。</p>
<p>（例） allow_unlink /var/lock/subsys/crond</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_mkdir">allow_mkdir</a></h3>
<p>パス名で指定されたディレクトリを作成することを許可します。</p>
<p>（例） allow_mkdir /tmp/logwatch.\*/</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_rmdir">allow_rmdir</a></h3>
<p>ディレクトリの削除を許可します。</p>
<p>（例） allow_rmdir /tmp/logwatch.\*/</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_mkfifo">allow_mkfifo</a></h3>
<p>FIFO の作成を許可します。</p>
<p>（例） allow_mkfifo /dev/initctl</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_mksock">allow_mksock</a></h3>
<p>UNIX ドメインソケットの作成を許可します。</p>
<p>（例） allow_mksock /dev/log</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_mkblock">allow_mkblock</a></h3>
<p>ブロック型デバイスファイルの作成を許可します。</p>
<p>（例） allow_mkblock /dev/\*</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_mkchar">allow_mkchar</a></h3>
<p>キャラクタ型デバイスファイルの作成を許可します。</p>
<p>（例） allow_mkchar /dev/\*</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_truncate">allow_truncate</a></h3>
<p>ファイルの切り詰めと伸長を許可します。</p>
<p>（例） allow_truncate /etc/mtab</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_symlink">allow_symlink</a></h3>
<p>シンボリックリンクの作成を許可します。</p>
<p>（例） allow_symlink /dev/cdrom</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_link">allow_link</a></h3>
<p>ハードリンクの作成を許可します。</p>
<p>（例） allow_link /etc/mtab~\$ /etc/mtab~</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_rename">allow_rename</a></h3>
<p>ファイル名の変更を許可します。</p>
<p>（例） allow_rename /etc/mtab.tmp /etc/mtab</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_rewrite">allow_rewrite</a></h3>
<p><a href="#exception_policy_deny_rewrite">deny_rewrite</a> によりファイルの内容の上書きが禁止されているパス名が指すファイル内容の上書きを許可します。</p>
<p>（例） allow_rewrite /var/log/messages</p>
<p>関連項目： <a href="#exception_policy_path_group">path_group</a> <a href="#exception_policy_deny_rewrite">deny_rewrite</a></p>

<h3><a name="domain_policy_allow_argv0">allow_argv0</a></h3>

<p>argv[0] の組み合わせを制限するには、 allow_argv0 というキーワードに続けて、絶対パス名と「 argv[0] の最後の / より後ろの部分」を指定します。</p>

<p>プログラムを実行する関数である execve() には filename と argv[] と envp[] を渡すことができます。いくつかのプログラム（例えば busybox ）は argv[0] の内容によって振る舞いを変化させます。
プログラムへのシンボリックリンクを経由してプログラムを実行する場合、 TOMOYO Linux のドメイン遷移は filename が指すパス名を正規化した内容に基づいて行われるのに対し、振る舞いは argv[0] （通常は filename が指すパス名と同じ内容）に基づいて行われてしまいます。例えば、 /bin/ls と /bin/cat が busybox へのハードリンクとして提供されている環境において、 /tmp/cat という /bin/ls へのシンボリックリンクを作成して /tmp/cat を実行することにより、 /bin/ls のためのドメインで cat として振舞うことができてしまうという抜け穴になります。</p>
<p>このキーワードの目的は、 filename と argv[0] の内容の組み合わせを制限することでそのような抜け穴を塞ぐことです。</p>

<h3><a name="domain_policy_allow_env">allow_env</a></h3>

<p>環境変数名を制限するには、 allow_env というキーワードに続けて、「環境変数名」を指定します。</p>

<p>プログラムを実行する関数である execve() には filename と argv[] と envp[] を渡すことができます。多くのプログラムは envp[] の内容によって振る舞いを変化させます。</p>
<p>このキーワードの目的は、実行されるプログラムに渡される環境変数を制限することです。</p>

<p>関連項目： <a href="#exception_policy_allow_env">allow_env</a></p>

<h3><a name="domain_policy_allow_capability">allow_capability</a></h3>

<p>ケイパビリティのアクセス許可を指定するには、 allow_capability というキーワードに続けて、ケイパビリティを指定します。以下のケイパビリティが指定できます。</p>

<table border="1">
<tr><td>allow_capability inet_tcp_create</td><td>TCP ソケットの使用を許可</td></tr>
<tr><td>allow_capability inet_tcp_listen</td><td>TCP ソケットの listen を許可</td></tr>
<tr><td>allow_capability inet_tcp_connect</td><td>TCP ソケットの connect を許可</td></tr>
<tr><td>allow_capability use_inet_udp</td><td>UDP ソケットの使用を許可</td></tr>
<tr><td>allow_capability use_inet_ip</td><td>RAW ソケットの使用を許可</td></tr>
<tr><td>allow_capability use_route</td><td>ROUTE ソケットの使用を許可</td></tr>
<tr><td>allow_capability use_packet</td><td>PACKET ソケットの使用を許可</td></tr>
<tr><td>allow_capability use_kernel_module</td><td>create_module(2) init_module(2) delete_module(2) の使用を許可</td></tr>
<tr><td>allow_capability create_fifo</td><td>mknod(2) で FIFO の作成を許可</td></tr>
<tr><td>allow_capability create_block_dev</td><td>mknod(2) でブロック型デバイスの作成を許可</td></tr>
<tr><td>allow_capability create_char_dev</td><td>mknod(2) でキャラクタ型デバイスの作成を許可</td></tr>
<tr><td>allow_capability create_unix_socket</td><td>mknod(2) で UNIX ドメインソケットの作成を許可</td></tr>
<tr><td>allow_capability SYS_MOUNT</td><td>mount(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_UMOUNT</td><td>umount(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_REBOOT</td><td>reboot(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_CHROOT</td><td>chroot(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_KILL</td><td>0 以外のシグナルで kill(2) tkill(2) tgkill(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_VHANGUP</td><td>vhangup(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_TIME</td><td>stime(2) settimeofday(2) adjtimex(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_NICE</td><td>nice(2) setpriority(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_SETHOSTNAME</td><td>sethostname(2) setdomainname(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_LINK</td><td>link(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_SYMLINK</td><td>symlink(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_RENAME</td><td>rename(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_UNLINK</td><td>unlink(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_CHMOD</td><td>chmod(2) fchmod(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_CHOWN</td><td>chown(2) fchown(2) lchown(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_IOCTL</td><td>ioctl(2) compat_sys_ioctl(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_KEXEC_LOAD</td><td>kexec_load(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_PIVOT_ROOT</td><td>pivot_root(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_PTRACE</td><td>ptrace(2) の使用を許可</td></tr>
</table>

<p>allow_capability キーワードの目的は、プログラムが呼び出すことができるシステムコールを制限することです。幾つかのシステムコールに対しては他のキーワードやポリシファイルを使用してより詳細な制限が可能になっています。</p>
<ul>
<li>作成を許可するキャラクタ型デバイスファイルのパス名を <a href="#domain_policy_allow_mkblock">allow_mkblock</a> キーワードを使用して制限することができます。
<li>作成を許可するブロック型デバイスファイルのパス名を <a href="#domain_policy_allow_mkchar">allow_mkchar</a> キーワードを使用して制限することができます。
<li>作成を許可する FIFO のパス名を <a href="#domain_policy_allow_mkfifo">allow_mkfifo</a> キーワードを使用して制限することができます。
<li>作成を許可する UNIX ドメインソケットのパス名を <a href="#domain_policy_allow_mksock">allow_mksock</a> キーワードを使用して制限することができます。
<li>作成を許可するシンボリックリンクのパス名を <a href="#domain_policy_allow_symlink">allow_symlink</a> キーワードを使用して制限することができます。
<li>削除を許可するパス名を <a href="#domain_policy_allow_unlink">allow_unlink</a> キーワードを使用して制限することができます。
<li>ハードリンクを許可する組み合わせを <a href="#domain_policy_allow_link">allow_link</a> キーワードを使用して制限することができます。
<li>パス名の変更を許可する組み合わせを <a href="#domain_policy_allow_rename">allow_rename</a> キーワードを使用して制限することができます。
<li>使用を許可する IP アドレスの範囲ととポート番号の範囲を <a href="#domain_policy_allow_network">allow_network</a> キーワードを使用して制限することができます。
<li>送信可能なシグナルの番号と送信先のドメインを <a href="#domain_policy_allow_signal">allow_signal</a> キーワードを使用して制限することができます。
<li>マウントを許可するデバイスおよびマウントポイントを <a href="#system_policy_allow_mount">allow_mount</a> キーワードを使用して制限することができます。
<li>アンマウントを許可しないマウントポイントを <a href="#system_policy_deny_unmount">deny_unmount</a> キーワードを使用して指定することができます。
<li>chroot で移動できるディレクトリを <a href="#system_policy_allow_chroot">allow_chroot</a> キーワードを使用して制限することができます。
<li>pivot_root で交換できるディレクトリを <a href="#system_policy_allow_pivot_root">allow_pivot_root</a> キーワードを使用して制限することができます。
</ul>

<h3><a name="domain_policy_allow_network">allow_network</a></h3>

<p>ネットワークのアクセス許可を指定するには、 allow_network というキーワードに続けて、プロトコル（ TCP UDP RAW の何れか）、 IP アドレス、ポート番号（ TCP UDP の場合）またはプロトコル番号（ RAW の場合）を指定します。 IPv4 プロトコルおよび IPv6 プロトコルで使用するローカルポート番号が対象です。</p>
<table border="1">
<tr><td>キーワード</td><td>許可されるアクセス</td><td>指定例</td></tr>
<tr><td>allow_network TCP bind</td><td>ローカルの TCP アドレス／ポートの割り当て</td><td>allow_network TCP bind 0.0.0.0 80</td></tr>
<tr><td>allow_network TCP listen</td><td>ローカルの TCP アドレス／ポートでの待機</td><td>allow_network TCP listen 0.0.0.0 80</td></tr>
<tr><td>allow_network TCP accept</td><td>リモートの TCP アドレス／ポートからの接続受付および通信</td><td>allow_network TCP accept 10.0.0.0-10.255.255.255 1024-65535</td></tr>
<tr><td>allow_network TCP connect</td><td>リモートの TCP アドレス／ポートへの接続および通信</td><td>allow_network TCP connect 127.0.0.1 1024-65535</td></tr>
<tr><td>allow_network UDP bind</td><td>ローカルの UDP アドレス／ポートの割り当て</td><td>allow_network UDP bind 0.0.0.0 53</td></tr>

<tr><td>allow_network UDP connect</td><td>リモートの UDP アドレス／ポートとの通信</td><td>allow_network UDP connect 127.0.0.1 53</td></tr>
<tr><td>allow_network RAW bind</td><td>ローカルの IP アドレス／プロトコルの割り当て</td><td>allow_network RAW bind 127.0.0.1 255</td></tr>
<tr><td>allow_network RAW connect</td><td>リモートの IP アドレス／プロトコルとの通信</td><td>allow_network RAW connect 10.0.0.1 1</td></tr>
</table>
<p>IPv6 で使われる "::" という表記はサポートされていません。 "::1" ではなく "0:0:0:0:0:0:0:1" のように表記する必要があります。</p>

<p>同じＩＰアドレスを繰り返し指定する手間を避けるために、パス名と同様にグループ化を行うことができます。</p>

<p>関連項目： <a href="#exception_policy_address_group">address_group</a></p>

<h3><a name="domain_policy_allow_signal">allow_signal</a></h3>

<p>シグナルのアクセス許可を指定するには、 allow_signal というキーワードに続けて、シグナルの番号および操作対象ドメインを指定します。<br>
　例外が 2 つ存在します。シグナル番号が 0 の場合は常に許可されます。また、自分の属するドメインへのシグナルの場合には常に許可されます。<br>
　その他の場合、このファイルに指定されたシグナル番号とドメイン名で始まる場合のみそのシグナルを送信できます。<br>
　操作対象ドメインとして &lt;kernel&gt; を指定すると、全てのドメインに指定された番号のシグナルを送信できます。</p>

<h3><a name="domain_policy_use_profile">use_profile</a></h3>

<p>これは、このドメインに対して割り当てられているプロファイル番号を示しています。プロファイル番号は 0 〜 255 の値をとります。</p>

<h3><a name="domain_policy_ignore_global_allow_read">ignore_global_allow_read</a></h3>

<p>これは、このドメインに対しては例外ポリシで指定されている <a href="#exception_policy_allow_read">allow_read</a> を無視することを示しています。特定のドメインに対して特に読み込みモードでオープンできるファイルを制限したい場合に使います。</p>

<p>関連項目： <a href="#exception_policy_allow_read">allow_read</a></p>

<h3><a name="domain_policy_ignore_global_allow_env">ignore_global_allow_env</a></h3>

<p>これは、このドメインに対しては例外ポリシで指定されている <a href="#exception_policy_allow_env">allow_env</a> を無視することを示しています。特定のドメインに対して特に環境変数の受け渡しを制限したい場合に使います。</p>

<p>関連項目： <a href="#exception_policy_allow_env">allow_env</a></p>

<h3><a name="domain_policy_execute_handler">execute_handler</a></h3>

<p>これは、このドメインに対しては常にこのキーワードで指定されたプログラムだけを実行することを示しています。特定のドメインで実行されるプログラムの実行要求を全て特定のプログラムを経由して起動させたい場合に使います。</p>

<p>このキーワードが指定されている場合、 <a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a> の値に関わらず常にこのキーワードで指定されたプログラムが実行されます。そのため、このキーワードに適切なプログラムへのパス名が指定されていなかった場合、このキーワードが指定されているドメインからは一切のプログラムを実行できなくなります。</p>

<p>関連項目： <a href="#domain_policy_denied_execute_handler">denied_execute_handler</a> <a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a> <a href="#domain_policy_allow_execute">allow_execute</a> <a href="#domain_policy_allow_argv0">allow_argv0</a></p>

<h3><a name="domain_policy_denied_execute_handler">denied_execute_handler</a></h3>

<p>これは、 <a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a> が enforcing の状態に於いて許可されていないプログラムの実行が要求された場合には、常にこのキーワードで指定されたプログラムを実行することを示しています。このキーワードが指定されていない場合、 <a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a> が enforcing の状態に於いて許可されていないプログラムの実行が要求された場合にはプログラムの実行を拒否します。</p>

<p>ただし、ドメインに対して <a href="#domain_policy_execute_handler">execute_handler</a> キーワードが指定されている場合、このキーワードは無視されます。</p>

<h3><a name="domain_policy_quota_exceeded">quota_exceeded</a></h3>

<p>これは、学習モードで動作中にアクセス許可の数が <a href="#profile_MAX_ACCEPT_ENTRY">MAX_ACCEPT_ENTRY</a> で指定された値に到達したため、このドメインに対してはアクセス許可を学習しきれなかったことを示しています。チューニングを行うなどしてアクセス許可の数を減らすようにしてください。</p>

<p>関連項目： <a href="#profile_MAX_ACCEPT_ENTRY">MAX_ACCEPT_ENTRY</a></p>

<h2><a name="exception_policy">/proc/ccs/exception_policy</a></h2>

<p>現在の例外ポリシを読み出しまたは追加または削除するには以下のように操作します。</p>
<p>（例）<br>
echo 'file_pattern /proc/\$/status' | loadpolicy -e<br>
echo 'delete file_pattern /proc/\$/status' | loadpolicy -e<br>
cat /proc/ccs/exception_policy</p>

<p>関連項目： <a href="#policy_file_modifiers">Policy File's Modification</a></p>

<h3><a name="exception_policy_file_pattern">file_pattern</a></h3>

<p>パス名のパターン化を指示するには、 file_pattern というキーワードに続けて、パス名のパターンを指定します。パス名は正規化されたパス名でなければなりません。このキーワードは実行許可を与える場合とドメイン定義には適用されません。<br>
例えば、プロセスＩＤを含む正規化されたパス名（ /proc/PID/ ）は、アクセス制御が正しく行われるようにグループ化されなければなりません。</p>

<p>学習モード（ <a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a> が learning に設定されている状態）でパス名に対するアクセスを行うと、自動的にパターン化された状態で学習されます。学習モード以外には影響しません。この構文は、既知のパターンをテンプレート化することによって、後でチューニングを行うときの手間を軽減するためだけに使われる。</p>

<h3><a name="exception_policy_path_group">path_group</a></h3>

<p>パス名のグループを定義するには、 path_group というキーワードに続けて、グループ名とパス名のパターンを指定します。<br>
　例えば、ホームディレクトリ以下の全ファイルをまとめたい場合、</p>

<table border="1">
<tr><td>
path_group HOME-DIR-FILE /home/\*/\*<br>
path_group HOME-DIR-FILE /home/\*/\*/\*<br>
path_group HOME-DIR-FILE /home/\*/\*/\*/\*<br>
path_group HOME-DIR-FILE /home/\*/\*/\*/\*/\*<br>
path_group HOME-DIR-FILE /home/\*/\*/\*/\*/\*/\*<br>
path_group HOME-DIR-FILE /home/\*/\*/\*/\*/\*/\*/\*
</td></tr>
</table>

<p>のように定義しておくことで、ドメインポリシのファイルに対するアクセス許可を指定する際に</p>

<table border="1">
<tr><td>
allow_read @HOME-DIR-FILE
</td></tr>
</table>

<p>のように指定できます。</p>

<h3><a name="exception_policy_address_group">address_group</a></h3>

<p>アドレスのグループを定義するには、 address_group というキーワードに続けて、グループ名と IP アドレスのパターンを指定します。<br>
　例えば、ローカルアドレスをまとめたい場合、</p>

<table border="1">
<tr><td>
address_group local-address 10.0.0.0-10.255.255.255<br>
address_group local-address 172.16.0.0-172.31.255.255<br>
address_group local-address 192.168.0.0-192.168.255.255
</td></tr>
</table>

<p>のように定義しておくことで、ドメインポリシのネットワークに対するアクセス許可を指定する際に</p>

<table border="1">
<tr><td>
allow_network TCP accept @local-address 1024-65535
</td></tr>
</table>

<p>のように指定できます。</p>

<h3><a name="exception_policy_allow_read">allow_read</a></h3>

<p>無条件に読み込みを許可するファイルを指定するには、 allow_read というキーワードに続けて、正規化されたファイル名を指定します。このキーワードの目的は、 GLIBC がプログラム実行時に参照するファイルやエラーメッセージを表示する際に参照するファイルのように、どのようなプログラムから参照されても構わないというファイルを指定することで、各ドメインで記述しないで済むようにすることです。なお、各ドメインで ignore_global_allow_read という指定をすると、ここで指定された allow_read は無視されます。</p>

<p>関連項目： <a href="#domain_policy_allow_read">allow_read</a> <a href="#domain_policy_ignore_global_allow_read">ignore_global_allow_read</a></p>

<h3><a name="exception_policy_allow_env">allow_env</a></h3>

<p>無条件に受け取ってよい環境変数名を指定するには、 allow_env というキーワードに続けて、環境変数名を指定します。このキーワードの目的は、 PATH や HOME のように、どのようなプログラムに渡されても構わないような環境変数名を指定することで、各ドメインで記述しないで済むようにすることです。くれぐれも LD_PRELOAD のような危険な環境変数を指定しないでください。なお、各ドメインで ignore_global_allow_env という指定をすると、ここで指定された allow_env は無視されます。</p>

<p>関連項目： <a href="#domain_policy_ignore_global_allow_env">ignore_global_allow_env</a> <a href="#domain_policy_allow_env">allow_env</a></p>

<h3><a name="exception_policy_deny_rewrite">deny_rewrite</a></h3>

<p>deny_rewrite というキーワードを使用して、既に記録されている部分の書き換えを禁止したいファイル（ログファイル等）のパス名を登録します。パターンが使用できます。 deny_rewrite というキーワードを使用して登録されたファイルは、ドメイン用ポリシの中で明示的に <a href="#domain_policy_allow_rewrite">allow_rewrite</a> というキーワードを用いて許可が与えられない限り、追記ではない書き込みモードでのオープンとファイルの切り詰めが禁止されます。</p>

<p>関連項目： <a href="#domain_policy_allow_rewrite">allow_rewrite</a></p>

<h3><a name="exception_policy_alias">alias</a></h3>

<p>シンボリックリンクを解決した名前ではなくシンボリックリンクの名前のまま実行させるプログラムを指定するには、 alias というキーワードに続けてシンボリックリンクを解決したパス名とシンボリックリンクを解決する前のパス名を指定します。このキーワードの目的は、実行時の名前によって異なる振る舞いをするプログラムが、ハードリンクではなくシンボリックリンクで参照される場合に、シンボリックリンクの名前でドメインを遷移できるようにすることです。</p>
<p>例えば /sbin/pidof は /sbin/killall5 へのシンボリックリンクであるため、通常は /sbin/pidof を実行すると /sbin/killall5 が実行されたものとしてドメインが定義されます。しかし、 alias /sbin/killall5 /sbin/pidof という指定をすることで、 /sbin/pidof を実行すると /sbin/pidof が実行されたものとしてドメインが定義されるようにできます。</p>

<p>関連項目： <a href="#domain_policy_allow_execute">allow_execute</a></p>

<h3><a name="exception_policy_aggregator">aggregator</a></h3>

<p>複数のプログラムを単一のプログラム名で扱うには、 aggregator というキーワードに続けて集約前のプログラム名と集約後のプログラム名を指定します。このキーワードの目的は、同様のプログラムを集約することです。</p>
<p>例えば、 /usr/bin/tac と /bin/cat は似ているので、 aggregator /usr/bin/tac /bin/cat という指定をすることで /usr/bin/tac を /bin/cat のドメインで実行することができるようになります。</p>
<p>例えば、 Fedora Core 3 の /usr/sbin/logrotate は /tmp/logrotate.\?\?\?\?\?\? というパターンのプログラムを作成して実行するが、 TOMOYO Linux では安全上の理由からプログラムの実行許可を与える場合とドメインを定義する場合にパターンを使用することを認めていません。しかし、 aggregator /tmp/logrotate.\?\?\?\?\?\? /tmp/logrotate.tmp という指定をすることで /tmp/logrotate.\?\?\?\?\?\? を /tmp/logrotate.tmp のドメインで実行することができるようになります。</p>

<p>関連項目： <a href="#domain_policy_allow_execute">allow_execute</a></p>

<h3><a name="exception_policy_initialize_domain">initialize_domain</a></h3>

<p>特定のプログラムが実行された場合にドメイン遷移を初期化させるには、 initialize_domain というキーワードを使用します。</p>

<ul>
<li>initialize_domain プログラム名 from ドメイン名
<li>initialize_domain プログラム名 from ドメイン名の最後のプログラム名
<li>initialize_domain プログラム名
</ul>

<p> from 以降が指定されていない場合は任意のドメインから実行された場合に適用されます。ドメイン名が &lt;kernel&gt; で始まらない場合は、ドメイン名の最後のプログラム名が一致する全てのドメインに適用されます。</p>

<p>このキーワードの目的は、常駐型プログラムや必要に応じてカーネルから起動されるプログラムを、通常とは異なるドメインに遷移させることで、ドメイン遷移を集約することです。</p>

<p>関連項目：<a href="#domain_transition">ドメイン遷移</a> <a href="#exception_policy_no_initialize_domain">no_initialize_domain</a></p>

<h3><a name="exception_policy_no_initialize_domain">no_initialize_domain</a></h3>

<p>initialize_domain の効力を打ち消すには、 no_initialize_domain というキーワードを指定します。</p>
<ul>
<li>no_initialize_domain プログラム名 from ドメイン名
<li>no_initialize_domain プログラム名 from ドメイン名の最後のプログラム名
<li>no_initialize_domain プログラム名
</ul>

<p>このキーワードはドメイン遷移を初期化させたくない場合に使用します。</p>

<p>関連項目：<a href="#domain_transition">ドメイン遷移</a> <a href="#exception_policy_initialize_domain">initialize_domain</a></p>

<h3><a name="exception_policy_keep_domain">keep_domain</a></h3>

<p>特定のドメインからプログラムが実行されてもドメイン遷移を行わないようにするには、 keep_domain というキーワードを使用します。</p>

<ul>
<li>keep_domain プログラム名 from ドメイン名
<li>keep_domain プログラム名 from ドメイン名の最後のプログラム名
<li>keep_domain ドメイン名
<li>keep_domain ドメイン名の最後のプログラム名
</ul>

<p> from 以前が指定されていない場合は任意のプログラムが実行された場合に適用されます。ドメイン名が &lt;kernel&gt; で始まらない場合は、ドメイン名の最後のプログラム名が一致する全てのドメインに適用されます。</p>

<p>このキーワードの目的は、不要なドメイン遷移の発生を抑制することでドメイン数とメモリ消費を抑えることです。</p>

<p>関連項目：<a href="#domain_transition">ドメイン遷移</a> <a href="#exception_policy_no_keep_domain">no_keep_domain</a></p>

<h3><a name="exception_policy_no_keep_domain">no_keep_domain</a></h3>

<p>keep_domain の効力を打ち消すには、 no_keep_domain というキーワードを指定します。</p>

<ul>
<li>no_keep_domain プログラム名 from ドメイン名
<li>no_keep_domain プログラム名 from ドメイン名の最後のプログラム名
<li>no_keep_domain ドメイン名
<li>no_keep_domain ドメイン名の最後のプログラム名
</ul>

<p>このキーワードはドメイン遷移を行わせたい場合に使用します。</p>

<p>関連項目：<a href="#domain_transition">ドメイン遷移</a> <a href="#exception_policy_keep_domain">keep_domain</a></p>

<h2><a name="query">/proc/ccs/query</a></h2>

<p>強制モードで動作中にポリシ違反が発生した場合に、そのアクセス要求を個別に許可するかどうかの指定を行うために使用します。 ALLOW_ENFORCE_GRACE=enabled に設定されているプロファイルが割り当てられているドメインに対して強制モードでポリシ違反が発生した場合、 ccs-queryd を用いて対話的に諾否を指定できます。</p>

<h2><a name="manager">/proc/ccs/manager</a></h2>

<p>ポリシの読み書きを行えるプログラムまたはドメインの一覧を取得または追加します。</p>

<h3><a name="manager_manage_by_non_root">manage_by_non_root</a></h3>

<p>デフォルトではユーザＩＤと実効ユーザＩＤの両方が 0 であるプロセスだけがポリシを変更できますが、非 root ユーザによる変更を認めたい場合に使用します。</p>

<h2><a name=".domain_status">/proc/ccs/.domain_status</a></h2>

<p>setprofile コマンドが行単位での処理を行いやすくするために domain_policy の内容からプロファイル番号とドメイン名の部分だけを抽出したもの。ＤＢＭＳのビューに相当する機能を提供します。</p>

<h2><a name="meminfo">/proc/ccs/meminfo</a></h2>

<p>TOMOYO Linux がポリシを保持するために使用しているカーネルのメモリ情報を取得します。</p>
<p>（例）<br>
cat /proc/ccs/meminfo<br></p>

<h2><a name="grant_log">/proc/ccs/grant_log</a></h2>

<p>ドメインポリシに対するアクセス許可ログを取得します。取得すべきログが無い場合はすぐに戻ってくるので、ログが発生するまで待機させるには select(2) を使ってください。記憶できる件数は MAX_GRANT_LOG 件までです。それ以上は記録されないので、随時読み出すようにする必要があります。</p>
<p>（例）<br>
cat /proc/ccs/grant_log</p>

<h2><a name="reject_log">/proc/ccs/reject_log</a></h2>

<p>ドメインポリシに対するアクセス拒否ログを取得します。取得すべきログが無い場合はすぐに戻ってくるので、ログが発生するまで待機させるには select(2) を使ってください。記憶できる件数は MAX_REJECT_LOG 件までです。それ以上は記録されないので、随時読み出すようにする必要があります。</p>
<p>（例）<br>
cat /proc/ccs/reject_log</p>

<h2><a name="self_domain">/proc/ccs/self_domain</a></h2>

<p>呼び出し元プロセスが属しているドメインの名前を取得します。</p>
<p>（例）<br>
cat /proc/ccs/self_domain</p>

<h2><a name=".process_status">/proc/ccs/.process_status</a></h2>

<p>ccstree コマンド（「現在動作中のプロセス」と「そのプロセスが属しているドメイン」と「そのドメインに割り当てられているプロファイル番号」を pstree のように一覧表示する）のためのインタフェース。例外的にポリシマネージャとして登録されていないプログラムでも書き込みを行える。</p>

<h2><a name=".updates_counter">/proc/ccs/.updates_counter</a></h2>

<p>ポリシの変更を検出するためのカウンタです。参照されるたびに 0 にリセットされます。ポリシの更新を監視するプログラムのためのインタフェースです。</p>

<h2><a name="version">/proc/ccs/version</a></h2>

<p>TOMOYO Linux のバージョン番号を取得するためのインタフェースです。</p>
<p>（例）<br>
cat /proc/ccs/version</p>

<h1>6. <a name="Advanced_Features">Advanced Features</a></h1>

<h2>6.1 <a name="non_root_policy_update">Allowing policy modification by non root user.</a></h2>

<p>デフォルトではユーザＩＤと実効ユーザＩＤの両方が 0 であるプロセスだけがポリシを変更できますが、非 root ユーザによる変更を認めたい場合には</p>

<table border="1">
<tr><td>
# echo manage_by_non_root | /usr/lib/ccs/loadpolicy -m
</td></tr>
</table>

<p>のように manage_by_non_root というキーワードを書き込むことで、ユーザＩＤと実効ユーザＩＤのチェックを無効にすることができます。また、再びユーザＩＤと実効ユーザＩＤのチェックを有効にするには、</p>

<table border="1">
<tr><td>
# echo delete manage_by_non_root | /usr/lib/ccs/loadpolicy -m
</td></tr>
</table>

<p>のように delete manage_by_non_root というキーワードを書き込んでください。 /proc/ccs/ 以下のエントリの所有者は root なので、非 root ユーザによるアクセスを認めるためには必要に応じて chown/chmod を実行してください。<br>
起動時に自動的にこの処理が行われるようにするために、 /sbin/ccs-init は /etc/ccs/ccs-post-init というプログラムが存在する場合には /etc/ccs/ccs-post-init も実行するようになっています。よって、例えば demo ユーザが /proc/ccs/ インタフェースへの読み書きができるように設定したい場合は、</p>

<table border="1">
<tr><td>
#! /bin/sh<br>
echo manage_by_non_root &gt; /proc/ccs/manager<br>
chown -R demo /proc/ccs/
</td></tr>
</table>

<p>という内容で /etc/ccs/ccs-post-init を作成し、</p>

<table border="1">
<tr><td>
# chmod 755 /etc/ccs/ccs-post-init<br>
# chown -R demo /etc/ccs/<br>
# chmod 755 /usr/lib/ccs/
</td></tr>
</table>

<p>を実行することで demo ユーザがポリシのあるディレクトリへのアクセスとポリシを編集するためのプログラムを実行できるようになります。</p>

<h2>6.2 <a name="conditional_acl">Using conditional ACL.</a></h2>

<p>アクセス許可にユーザＩＤ等に基づいた条件を付加することができます。条件は個々のアクセス許可の末尾に " if " 句を追加する形で指定します。</p>

<table border="1">
<tr><td>指定例</td><td>Meaning</td></tr>
<tr><td>allow_read /etc/passwd</td><td>/etc/passwd の参照を許可</td></tr>
<tr><td>allow_read /etc/passwd if task.uid=0</td><td>プロセスのユーザＩＤが 0 の場合に限り、 /etc/passwd の参照を許可</td></tr>
<tr><td>allow_read /etc/passwd if task.uid!=0</td><td>プロセスのユーザＩＤが 0 ではない場合に限り、 /etc/passwd の参照を許可</td></tr>
<tr><td>allow_network TCP connect 10.0.0.1</td><td>TCP プロトコルで 10.0.0.1 への接続を許可</td></tr>
<tr><td>allow_network TCP connect 10.0.0.1 if task.uid=100</td><td>プロセスのユーザＩＤが 100 の場合に限り、 TCP プロトコルで 10.0.0.1 への接続を許可</td></tr>
<tr><td>allow_capability SYS_KILL</td><td>kill(2) の使用を許可</td></tr>
<tr><td>allow_capability SYS_KILL if task.ppid=1 task.uid=0 task.euid=0</td><td>親プロセスが /sbin/init であり、かつ、プロセスのユーザＩＤと実効ユーザＩＤが 0 の場合に限り、 kill(2) の使用を許可</td></tr>
</table>

<p>以下の変数を指定できます。</p>

<table border="1">
<tr><td>Variable</td><td>Meaning</td></tr>
<tr><td>task.uid</td><td>UID of current process</td></tr>
<tr><td>task.euid</td><td>Effective UID of current process</td></tr>
<tr><td>task.suid</td><td>Saved UID of current process</td></tr>
<tr><td>task.fsuid</td><td>File System UID of current process</td></tr>
<tr><td>task.gid</td><td>GID of current process</td></tr>
<tr><td>task.egid</td><td>Effective GID of current process</td></tr>
<tr><td>task.sgid</td><td>Saved GID of current process</td></tr>
<tr><td>task.fsgid</td><td>File System GID of current process</td></tr>
<tr><td>task.pid</td><td>PID of current process</td></tr>
<tr><td>task.ppid</td><td>PID of parent process</td></tr>
<tr><td>path1.uid</td><td>UID of object.</td></tr>
<tr><td>path1.gid</td><td>GID of object.</td></tr>
<tr><td>path1.ino</td><td>i-node number of object.</td></tr>
<tr><td>path1.parent.uid</td><td>UID of object's parent directory.</td></tr>
<tr><td>path1.parent.gid</td><td>GID of object's parent directory.</td></tr>
<tr><td>path1.parent.ino</td><td>i-node number of object's parent directory.</td></tr>
<tr><td>path2.parent.uid</td><td>UID of object's parent directory.</td></tr>
<tr><td>path2.parent.gid</td><td>GID of object's parent directory.</td></tr>
<tr><td>path2.parent.ino</td><td>i-node number of object's parent directory.</td></tr>
<tr><td>exec.argc</td><td>Number of argv[] passed for execute request.</td></tr>
<tr><td>exec.envc</td><td>Number of envp[] passed for execute request.</td></tr>
<tr><td>exec.argv[index]="value"</td><td>argv[index] (where 0 &lt;= index &lt; exec.argc) matches "value". </td></tr>
<tr><td>exec.argv[index]!="value"</td><td>argv[index] (where 0 &lt;= index &lt; exec.argc) does not match "value".</td></tr>
<tr><td>exec.envp["name"]="value"</td><td>Environment variable "name" is defined and matches "value".</td></tr>
<tr><td>exec.envp["name"]!="value"</td><td>Environment variable "name" is not defined or does not match "value".</td></tr>
<tr><td>exec.envp["name"]!=NULL</td><td>Environment variable "name" is defined.</td></tr>
<tr><td>exec.envp["name"]=NULL</td><td>Environment variable "name" is not defined.</td></tr>
</table>

<p>"path1" corresponds to the first pathname of operations that requires pathnames, and "path2" corresponds to the second pathname of operations that requires pathnames. For example, the case of "<a href="#domain_policy_allow_rename">allow_rename</a> file1 file2", path1 corresponds to file1 and path2 corresponds to file2.</p>

<p>"path1" except "path1.parent" is not available for pathnames that don't exist. Thus, you can't use when creating pathnames (such as <a href="#domain_policy_allow_create">allow_create</a> keyword).</p>

<p>"path1.parent" is always available.</p>

<p>"path2.parent" is available only for operations that require 2 pathnames (i.e. <a href="#domain_policy_allow_link">allow_link</a> and <a href="#domain_policy_allow_rename">allow_rename</a> keywords).</p>

<p>"path2" except "path2.parent" is not supported. (If "path2" already exist for "rename" operation, "unlink" or "rmdir" operation is performed implicitly.)</p>

<p>"path1" is not supported when accessing via "sysctl" (i.e. accessing files under /proc/sys/ directories using "sysctl" instead for "open").</p>

<p>"exec" is available only for operation taht executes a program (i.e. <a href="#domain_policy_allow_execute">allow_execute</a> keyword).</p>

<h2>6.3 <a name="stateful_acl">Using stateful ACL.</a></h2>

<p>Since TOMOYO Linux doesn't require modification of userland applications, it is impossible to change the range of accessible resources without domain transition.
But there are cases you wish to change the range of accessible resources without domain transition. For example, you might wish to change the range of accessible resources depending on the client's IP address. To support such cases, you can assign state variables to each processes and you can use the state variables in<a href="#conditional_acl">Using conditional ACL.</a></p>

<table border="1">
<tr><td>Variable</td><td>Meaning</td></tr>
<tr><td>task.state[0]</td><td>Current process's state variable 0</td></tr>
<tr><td>task.state[1]</td><td>Current process's state variable 1</td></tr>
<tr><td>task.state[2]</td><td>Current process's state variable 2</td></tr>
</table>

<p>Each task.state can take an integer value between 0 and 255. To change state variable, append " ; set " part after an ACL.</p>

<table border="1">
<tr><td>Example</td><td>Meaning</td></tr>
<tr><td>allow_network TCP accept @TRUSTED_HOSTS 1024-65535 ; set task.state[0]=1</td><td>If a TCP connection is accepted from an IP address included in an address group @TRUSTED_HOSTS, set 1 to state[0].</td></tr>
<tr><td>allow_network TCP accept @UNTRUSTED_HOSTS 1024-65535 ; set task.state[0]=0</td><td>If a TCP connection is accepted from an IP address included in an address group @UNTRUSTED_HOSTS, set 0 to state[0].</td></tr>
<tr><td>allow_execute /bin/bash if task.state[0]=1</td><td>Allow execution of /bin/bash if state[0] is 1.</td></tr>
<tr><td>allow_execute /sbin/nologin if task.state[0]=0</td><td>Allow execution of /sbin/nologin if state[0] is 0.</td></tr>
<tr><td>allow_execute /etc/passwd if task.state[2]=0 ; set task.state[2]=1</td><td>If state[2] is 0, allow opening /etc/passwd for reading and then, set 1 to state[2].</td></tr>
</table>

<p>When using the state variables, please be careful with the following points.</p>

<ul>
<li>The domain a process belongs to is automatically updated upon execution of a program, but the state variables of the process are not updated unless they are explicitly specified using " ; set " part. Thus, be careful with forgetting to reset when needed.</li>
<li>The state variables are updated when the access request is permitted by the policy. Thus, situations that the access request was not processed although the state variables were updated can happen because of errors after checking the policy (e.g. out of memory).</li>
<li>If an IP address is included in both @TRUSTED_HOSTS and @UNTRUSTED_HOSTS, the permission which matched first is used. So, be careful with using order dependent policy.</li>
</ul>

<h2>6.4 <a name="sleep_penalty">Sleep penalty for policy violation.</a></h2>

<p>強制モードでポリシ違反が発生した場合に、ポリシ違反の原因となったプロセスを一定時間スリープ状態にさせることができます。</p>

<table border="1">
<tr><td>/proc/ccs/profile での指定例</td><td>Meaning</td></tr>
<tr><td>3-SLEEP_PERIOD=1</td><td>プロファイル 3 が割り当てられているプロセスが強制モードに於いてポリシ違反を発生させた場合、 0.1 秒間スリープさせます。</td></tr>
<tr><td>4-SLEEP_PERIOD=10</td><td>プロファイル 4 が割り当てられているプロセスが強制モードに於いてポリシ違反を発生させた場合、 1 秒間スリープさせます。</td></tr>
</table>

<p>この機能は、無限ループの中でポリシ違反が発生した場合に、ＣＰＵ使用率が 100% になってしまうのを回避するための安全装置です。通常は 0.1 秒間スリープさせるだけで充分です。</p>

<p>この機能は、許可されていないホストからの TCP 接続要求や UDP パケットを攻撃者が故意に送りつけることでポリシ違反を発生させることでサービスを長時間スリープ状態にさせることにより、許可されているホストからの TCP 接続要求や UDP パケットの処理を大幅に遅延させるという攻撃が成立してしまうのを回避するために、ネットワークの受信系の操作に対しては機能しないようになっています。</p>

<h2>6.5 <a name="execute_handler">Judging execute request outside the kernel.</a></h2>

<p>TOMOYO Linux では、原則としてポリシに従ってプログラムの実行可否を制御します。プログラム実行時のパラメータをチェックしたい場合には、<a href="#conditional_acl">Using conditional ACL.</a>で説明したように exec.argv や exec.envp を使ってチェックを行うことができます。しかし、<a href="#conditional_acl">Using conditional ACL.</a>では、単純なパターンマッチしかサポートされておらず、また、どのようなプログラムの実行を許可するかを予め指定しておく必要があります。</p>

<p>そこで、 TOMOYO Linux 1.6.0 では <a href="#domain_policy_execute_handler">execute_handler</a> という仕組みが導入されました。この仕組みは、プログラムの実行可否をカーネルが判断するのではなく、 <a href="#domain_policy_execute_handler">execute_handler</a> により指定されたプログラムが判断し、プログラムの実行を許可すべきと判断した場合には実際にプログラムを実行するという動作をします。</p>

<p>Linux に於いては、プログラムを実行するという動作は、プログラムの実行を要求したプロセスを上書きするという動作であり、プログラムの実行に成功した場合にはプログラムの実行を要求したプロセスに制御が戻ることはありません。つまり、要求されたプログラムの実行に失敗した場合にしか、プログラムの実行を要求したプロセスに対して、要求されたプログラムが実行されなかったことが通知されません。<br>
例えば、プログラムＡとして動作しているプロセスがプログラムＢの実行を要求する場合を考えてみます。<br>
プログラムＡとして動作しているプロセスがプログラムＢの実行を要求すると、カーネルが「プログラムＡとして動作しているプロセスからプログラムＢを実行することは適切であるかどうか」をポリシを照合することで判断し、適切であると判断された場合には「プログラムＡとして動作しているプロセスをプログラムＢで上書き」し、適切では無いと判断された場合には「プログラムＡとして動作しているプロセスにプログラムＢの実行が認められていないことを通知」します。</p>

<p><a href="#domain_policy_execute_handler">execute_handler</a> を指定した場合、 execute_handler として指定されたプログラムＣがこの動作に介在します。<br>
プログラムＡとして動作しているプロセスがプログラムＢの実行を要求すると、プログラムＣに「プログラムＡとして動作しているプロセスからプログラムＢを実行することは適切であるかどうか」を判断してもらうために「プログラムＡとして動作しているプロセスをプログラムＣで上書き」します。プログラムＣとして動作するようになったプロセスが「プログラムＡとして動作していたプロセスからプログラムＢを実行することは適切であるかどうか」を判断し、適切であると判断した場合には「プログラムＣとして動作しているプロセスをプログラムＢで上書き」し、適切では無いと判断された場合には「プログラムＣとして動作しているプロセスをプログラムＢで上書きせずに終了」します。</p>

<p>このように、プログラムＢの実行を要求したプログラムＡとして動作していたプロセスがに対して、プログラムＢの実行に失敗したことを通知する手段を放棄することになるため、プログラムＢの実行を要求したプログラムＡとして動作していたプロセスが、プログラムＢが実行されなかったという通知を受けることができなくなるという副作用が発生します。<br>
しかし、たとえ <a href="#domain_policy_execute_handler">execute_handler</a> を指定していない場合であっても、「共有ライブラリの読み込みができなかった」「 KILL シグナルを受信した」「メモリ不足になり OOM killer によって強制終了させられた」など、様々な要因によって「実行には成功したが期待された動作を始める前に終了してしまった」という状況が起こりえます。つまり、「プログラムの実行が失敗しなかった」ということと「要求されたプログラムが期待した動作を始めた」ということの間には、不確定要素が存在します。<br>
そう考えると、「プログラムの実行に失敗したという通知が無い限りプログラムは期待された動作を始める」という保証は最初から存在しないわけなので、 <a href="#domain_policy_execute_handler">execute_handler</a> により指定されたプログラムＣが、プログラムＢの実行に失敗したことをプログラムＢの実行を要求したプログラムＡとして動作していたプロセスに通知できなかったという結果になったとしても、容認できる範囲であると言えると思います。</p>

<p>TOMOYO Linux は、どのプログラムからどのプログラムを実行する必要があるかを事前に把握して、必要最小限のプログラムの実行のみを認めるというアプローチを採用しています。そのため、正常な動作をしている限り、ポリシで許可されていないプログラムの実行要求は起こらないはずだと仮定すると、全てのプログラムの実行要求をとりあえず受理して構わないと考えることができます。もしも受理すべきではないプログラムの実行要求が発生した場合、 <a href="#domain_policy_denied_execute_handler">denied_execute_handler</a> の機能を使うことで要求を拒否する代わりにそのプロセスを強制終了させるなどの行動を起こすことができます。つまり、カーネルの内部でプログラムの実行可否の判断を行わなくても構わないということです。</p>

<p>そこで、ドメインに対して <a href="#domain_policy_execute_handler">execute_handler</a> キーワードを指定しておくことで、そのドメインから発生する全てのプログラムの実行可否の判断をカーネル外部のプログラムに委ねることができるようになります。</p>
<p>カーネルの内部では利用可能なライブラリが少ない上に連続したメモリ領域の割り当てが失敗する可能性が高くなりますが、
カーネルの外部であれば豊富なライブラリを使ってメモリ割り当ての限界を心配せずに詳細なチェックが可能になります。そこで、 <a href="#domain_policy_execute_handler">execute_handler</a> で指定したプログラムにプログラム実行時のパラメータをチェックしてもらい、適切であればプログラムを実行してもらうようにすることができます。</p>

<p>この方式の副作用は、プログラムの実行を拒否すべきと判断した場合に、プログラムの実行を要求したプロセスに通知する方法が無い点です。しかし、自由にカスタマイズできるので、 ssh 等を用いて遠隔地のマシンに問い合わせをしながらしながら判断することも可能です。</p>

<p>この機能を使うには、以下のように指定します。</p>

<table border="1">
<tr><td>/proc/ccs/domain_policy の例</td><td>Meaning</td></tr>
<tr><td>execute_handler /usr/sbin/check-and-exec</td><td>このドメインに属しているプロセスがプログラムの実行を要求した場合、要求されたプログラムを実行する代わりに /usr/sbin/check-and-exec を実行します。 /usr/sbin/check-and-exec はパラメータをチェックし、妥当と判断した場合には要求されたプログラムを実行します。</td></tr>
</table>

<p>execute_handler で指定されたプログラムは、以下のパラメータを受け取ります。<a href="#access_logs">Access Logs</a>で説明した、 allow_execute のログと比較してみてください。</p>

<ul>
<li>argv[0] には、 execute_handler で指定されたプログラムのパス名が入っています。</li>
<li>argv[1] には、プログラムの実行を要求したプロセスのドメイン名が入っています。</li>
<li>argv[2] には、プログラムの実行を要求したプロセスのパス名が入っています。</li>
<li>argv[3] には、プログラムの実行を要求したプロセスの情報が入っています。</li>
<li>argv[4] には、実行が要求されたプログラムのパス名が入っています。</li>
<li>argv[5] には、プログラム実行要求時の引数の数が入っています。</li>
<li>argv[6] には、プログラム実行要求時の環境変数の数が入っています。</li>
<li>argv[7] から argv[6 + argc] には、呼び出し元プロセスが渡した argv[] の内容が入っています。</li>
<li>argv[7 + argc] から argv [6 + argc + envc] には、呼び出し元プロセスが渡した envp[] の内容が入っています。</li>
<li>環境変数 envp[] は全てクリアされます。</li>
<li>標準入出力などは呼び出し元プロセスのものを引き継ぎます。</li>
</ul>

<p>この機能を使用する際には、以下の点に注意してください。</p>

<ul>
<li>execute_handler で指定されたプログラムに対して実行許可（ <a href="#domain_policy_allow_execute">allow_execute</a> ）を与える必要はありませんし、与えるべきではありません。</li>
<li>プロセスが chroot 内部の環境で動作している場合、 execute_handler で指定されたプログラムが見つからないために実行されない場合があります。これは、プロセスが chroot 内部の環境で動作している場合に、 chroot 外部の環境にあるプログラムを実行できてしまうと危険なので、 execute_handler で指定されたプログラムは、プロセスの名前空間のルートディレクトリではなく、プロセスのルートディレクトリから検索するようになっているためです。</li>
<li>execute_handler で指定されたプログラムが動作するためのドメインが存在しない場合、実行されません。そのため、例えば &lt;kernel&gt; 直下に execute_handler で指定されたプログラム用のドメインを作成して、そのプログラムを <a href="#exception_policy_initialize_domain">initialize_domain</a> キーワードで指定するなどの準備をしてください。</li>
<li>execute_handler で指定されたプログラムは環境変数の影響を受けるのを避けるため、全ての環境変数の内容をクリアした状態で起動されます。そのため、環境変数 PATH 等が設定されていないので、外部コマンドを呼び出す場合には注意してください。また、 execute_handler で指定されたプログラムが動作するドメインにも強制モード用のプロファイルを割り当てておくことを推奨します。</li>
</ul>

<p>ccs-tools のソースパッケージには、 audit-exec-param.c というサンプルプログラムが入っています。ご自由に改造してお使いください。</p>
<p>この機能は、機構を提供しているだけです。この機構を活用できるかどうかはあなた次第です。</p>

<h2>6.6 <a name="denied_execute_handler">Invoking alternative program for execute requests that are not permitted by policy.</a></h2>

<p>TOMOYO Linux では、どのプログラムからどのプログラムを実行する必要があるかを事前に把握して、必要最小限のプログラムの実行のみを認めるというアプローチを採用しています。そのため、不要なプログラムの実行を拒否するという振る舞いだけでなく、それ以外の振る舞いを行うこともできます。</p>

<p>強制モードに於いて allow_execute 構文により許可されていないプログラムの実行が要求された場合、デフォルトではプログラムの実行を拒否します。しかし、あるプログラムからどのプログラムの実行を許可する必要があるかを把握済みであるという前提があれば、プロセスが正常な動作をしている限りに於いて許可されていないプログラムの実行が要求されることは無いので、許可されていないプログラムの実行が要求されたということはプロセスが正常な動作をしていない（つまり、プロセスにとっては制御を失った状態である）とみなすことができます。</p>

<p>攻撃者はバッファオーバーフローなどのセキュリティホールを攻撃することでプロセスの制御を奪い、シェルなどのコマンドの実行を要求してきます。もし、そのプロセスからシェルの実行を許可する必要が無い（すなわち allow_execute /bin/bash のようなアクセス許可を与える必要が無い）のであれば、シェルの実行が要求された時点で既にプロセスにとっては制御を失っていると考えることができます。</p>

<p>通常、許可されていないプログラムの実行が要求された場合は、その要求を拒否するだけです。しかし、制御を失っているプロセスから要求されたプログラムの実行要求を拒否したところで、そのプロセスの制御が取り戻される（つまり、正常な動作をするようになる）とは考えられません。しかし、プログラムを実行するということは、現在動作中のプロセスを新しいプログラムに置き換えることで、制御を新しいプログラムに譲渡することを意味します。つまり、あるプロセスがバッファオーバーフローなどにより制御を失っていたとしても、プログラムを実行することにより、そのプロセスの制御が取り戻されるわけです。</p>

<p>攻撃者の手によって制御を失ったプロセスからプログラムが実行された後の制御は、どのプログラムが実行されたかによって決まります。シェルが実行された場合には、シェルはユーザが要求したとおりに処理を実行してしまうため、プログラムの実行を要求したプロセスの所有者である攻撃者の手に委ねられてしまうわけです。しかし、何もせずに終了するようなプログラム（例えば /bin/true ）が実行された場合には、プロセスの制御が攻撃者の手に委ねられてしまうことはありません。</p>

<p>このように、攻撃者の手によって本来許可する必要の無いプログラムの実行が要求されるという出来事は、見方を変えると、攻撃者自身が制御を取り戻すためのチャンスを与えてくれていると考えることができます。そこで、 TOMOYO Linux では、許可されていないプログラムの実行が要求された場合、その要求を拒否する代わりに他のプログラムを実行するための機構を提供しています。この機構を用いて何をするかはシステム管理者の自由です。</p>

<p>例えば、シェルの実行要求を /bin/true の実行要求に差し替えてしまうことで、そのプロセスを直ちに強制終了させることができます。</p>

<p>例えば、シェルの実行要求をハニーポットクライアントプログラムの実行要求に差し替えてしまうことで、攻撃者がどのようなリクエストを行うかを観察することができます。</p>

<p>例えば、そのログインセッションを強制終了させることができます。</p>

<p>例えば、要求されたコマンドがどのパッケージに含まれているかを教えてくれる Ubuntu の command-not-found パッケージのように、「 You are not permitted to execute this program. 」のような警告を表示することができます。</p>

<p>例えば、攻撃者の接続元ＩＰアドレスを割り出して、ファイアウォールの設定を変更することができます。</p>

<p>この機能を使うには、以下のように指定します。</p>

<table border="1">
<tr><td>/proc/ccs/profile の例</td><td>/proc/ccs/domain_policy の例</td><td>Meaning</td></tr>
<tr><td>3-MAC_FOR_FILE=enforcing</td><td>use_profile 3<br>denied_execute_handler /bin/true</td><td>プロファイル 3 が割り当てられているドメインに属しているプロセスが、許可されていないプログラムの実行を要求した場合、代わりに /bin/true を実行します。</td></tr>
</table>

<p>この機能を使用する際の注意事項は<a href="#execute_handler">Judging execute request outside the kernel.</a>と同じです。</p>

<hr>
<p><a href="index.html#manual">Return to index</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</body>
</html>
