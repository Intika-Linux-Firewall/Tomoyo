<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=shift_jis">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>Policy Specifications of TOMOYO Linux</title>
<link rel="stylesheet" href="tomoyo.css" media="all" type="text/css">
</head>
<body>
<p style="text-align:right;"><a href="../../ja/1.6.x/policy-reference.html">Japanese Page</a></p>
<h1 style="text-align:center;">Policy Specifications of TOMOYO Linux</h1>
<p style="text-align:right;">Last modified: $Date: 2008-04-10 16:59:12 +0900 (Thu, 10 Apr 2008) $</p>
<h1><a name="index">Index</a></h1>
<h2>1. <a href="#Keyword_Index">Keywords Index</a></h2>
<h2>2. <a href="#Common_Rules">Introduction</a></h2>
<p>2.1 <a href="#word_expression_rules">Word Expression Rules</a></p>
<p>2.2 <a href="#wildcard_expression_rules">Wildcard Expression Rules</a></p>
<p>2.3 <a href="#word_length_rules">Word Length Rules</a></p>
<p>2.4 <a href="#line_length_rules">Line Length Rules</a></p>
<p>2.5 <a href="#memory_allocation_rules">Memory Allocation Rules</a></p>
<h2>3. <a href="#Policy_Files">Policy Files</a></h2>
<p>3.1 <a href="#policy_file_locations">Policy File's Location</a></p>
<p>3.2 <a href="#policy_file_modifiers">Policy File's Modification</a></p>
<h2>4. <a href="#Domain_Rules">Domain Rules</a></h2>
<p>4.1 <a href="#domain_definition">Domain Definition</a></p>
<p>4.2 <a href="#domain_transition">Domain Transition</a></p>
<p>4.3 <a href="#access_logs">Access Logs</a></p>
<h2>5. <a href="#Syntax_Details">Syntax Details</a></h2>
<h2>6. <a href="#Advanced_Features">Advanced Features</a></h2>
<p>6.1 <a href="#non_root_policy_update">Allowing policy modification by non root user.</a></p>
<p>6.2 <a href="#conditional_acl">Using conditional ACL.</a></p>
<p>6.3 <a href="#stateful_acl">Using stateful ACL.</a></p>
<p>6.4 <a href="#sleep_penalty">Sleep penalty for policy violation.</a></p>
<p>6.5 <a href="#execute_handler">Judging execute request outside the kernel.</a></p>
<p>6.6 <a href="#denied_execute_handler">Invoking alternative program for execute requests that are not permitted by policy.</a></p>
<hr>

<h1>1. <a name="Keyword_Index">Keywords Index</a></h1>

<p>Used by /proc/ccs/profile and /etc/ccs/profile.conf</p>

<ul>
<li><a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a></li>
<li><a href="#profile_MAC_FOR_ARGV0">MAC_FOR_ARGV0</a></li>
<li><a href="#profile_MAC_FOR_ENV">MAC_FOR_ENV</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::inet_tcp_create">MAC_FOR_CAPABILITY::inet_tcp_create</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::inet_tcp_listen">MAC_FOR_CAPABILITY::inet_tcp_listen</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::inet_tcp_connect">MAC_FOR_CAPABILITY::inet_tcp_connect</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::use_inet_udp">MAC_FOR_CAPABILITY::use_inet_udp</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::use_inet_ip">MAC_FOR_CAPABILITY::use_inet_ip</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::use_route">MAC_FOR_CAPABILITY::use_route</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::use_packet">MAC_FOR_CAPABILITY::use_packet</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::use_kernel_module">MAC_FOR_CAPABILITY::use_kernel_module</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::create_fifo">MAC_FOR_CAPABILITY::create_fifo</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::create_block_dev">MAC_FOR_CAPABILITY::create_block_dev</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::create_char_dev">MAC_FOR_CAPABILITY::create_char_dev</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::create_unix_socket">MAC_FOR_CAPABILITY::create_unix_socket</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_MOUNT">MAC_FOR_CAPABILITY::SYS_MOUNT</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_UMOUNT">MAC_FOR_CAPABILITY::SYS_UMOUNT</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_REBOOT">MAC_FOR_CAPABILITY::SYS_REBOOT</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_CHROOT">MAC_FOR_CAPABILITY::SYS_CHROOT</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_KILL">MAC_FOR_CAPABILITY::SYS_KILL</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_VHANGUP">MAC_FOR_CAPABILITY::SYS_VHANGUP</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_TIME">MAC_FOR_CAPABILITY::SYS_TIME</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_NICE">MAC_FOR_CAPABILITY::SYS_NICE</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_SETHOSTNAME">MAC_FOR_CAPABILITY::SYS_SETHOSTNAME</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_LINK">MAC_FOR_CAPABILITY::SYS_LINK</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_SYMLINK">MAC_FOR_CAPABILITY::SYS_SYMLINK</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_RENAME">MAC_FOR_CAPABILITY::SYS_RENAME</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_UNLINK">MAC_FOR_CAPABILITY::SYS_UNLINK</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_CHMOD">MAC_FOR_CAPABILITY::SYS_CHMOD</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_CHOWN">MAC_FOR_CAPABILITY::SYS_CHOWN</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_IOCTL">MAC_FOR_CAPABILITY::SYS_IOCTL</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_KEXEC_LOAD">MAC_FOR_CAPABILITY::SYS_KEXEC_LOAD</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_PIVOT_ROOT">MAC_FOR_CAPABILITY::SYS_PIVOT_ROOT</a></li>
<li><a href="#profile_MAC_FOR_CAPABILITY::SYS_PTRACE">MAC_FOR_CAPABILITY::SYS_PTRACE</a></li>
<li><a href="#profile_MAC_FOR_NETWORK">MAC_FOR_NETWORK</a></li>
<li><a href="#profile_MAC_FOR_SIGNAL">MAC_FOR_SIGNAL</a></li>
<li><a href="#profile_DENY_CONCEAL_MOUNT">DENY_CONCEAL_MOUNT</a></li>
<li><a href="#profile_RESTRICT_CHROOT">RESTRICT_CHROOT</a></li>
<li><a href="#profile_RESTRICT_MOUNT">RESTRICT_MOUNT</a></li>
<li><a href="#profile_RESTRICT_UNMOUNT">RESTRICT_UNMOUNT</a></li>
<li><a href="#profile_RESTRICT_PIVOT_ROOT">RESTRICT_PIVOT_ROOT</a></li>
<li><a href="#profile_RESTRICT_AUTOBIND">RESTRICT_AUTOBIND</a></li>
<li><a href="#profile_MAX_ACCEPT_ENTRY">MAX_ACCEPT_ENTRY</a></li>
<li><a href="#profile_MAX_GRANT_LOG">MAX_GRANT_LOG</a></li>
<li><a href="#profile_MAX_REJECT_LOG">MAX_REJECT_LOG</a></li>
<li><a href="#profile_TOMOYO_VERBOSE">TOMOYO_VERBOSE</a></li>
<li><a href="#profile_ALLOW_ENFORCE_GRACE">ALLOW_ENFORCE_GRACE</a></li>
<li><a href="#profile_SLEEP_PERIOD">SLEEP_PERIOD</a></li>
</ul>

<p>Used by /proc/ccs/system_policy and /etc/ccs/system_policy.conf</p>

<ul>
<li><a href="#system_policy_allow_mount">allow_mount</a></li>
<li><a href="#system_policy_deny_unmount">deny_unmount</a></li>
<li><a href="#system_policy_allow_chroot">allow_chroot</a></li>
<li><a href="#system_policy_allow_pivot_root">allow_pivot_root</a></li>
<li><a href="#system_policy_deny_autobind">deny_autobind</a></li>
</ul>

<p>Used by /proc/ccs/exception_policy and /etc/ccs/exception_policy.conf</p>

<ul>
<li><a href="#exception_policy_aggregator">aggregator</a></li>
<li><a href="#exception_policy_initialize_domain">initialize_domain</a></li>
<li><a href="#exception_policy_no_initialize_domain">no_initialize_domain</a></li>
<li><a href="#exception_policy_keep_domain">keep_domain</a></li>
<li><a href="#exception_policy_no_keep_domain">no_keep_domain</a></li>
<li><a href="#exception_policy_file_pattern">file_pattern</a></li>
<li><a href="#exception_policy_path_group">path_group</a></li>
<li><a href="#exception_policy_address_group">address_group</a></li>
<li><a href="#exception_policy_allow_read">allow_read</a></li>
<li><a href="#exception_policy_allow_env">allow_env</a></li>
<li><a href="#exception_policy_deny_rewrite">deny_rewrite</a></li>
<li><a href="#exception_policy_alias">alias</a></li>
</ul>

<p>Used by /proc/ccs/domain_policy and /etc/ccs/domain_policy.conf</p>

<ul>
<li><a href="#domain_policy_allow_execute">allow_execute</a></li>
<li><a href="#domain_policy_allow_read">allow_read</a></li>
<li><a href="#domain_policy_allow_write">allow_write</a></li>
<li><a href="#domain_policy_allow_read/write">allow_read/write</a></li>
<li><a href="#domain_policy_allow_create">allow_create</a></li>
<li><a href="#domain_policy_allow_unlink">allow_unlink</a></li>
<li><a href="#domain_policy_allow_mkdir">allow_mkdir</a></li>
<li><a href="#domain_policy_allow_rmdir">allow_rmdir</a></li>
<li><a href="#domain_policy_allow_mkfifo">allow_mkfifo</a></li>
<li><a href="#domain_policy_allow_mksock">allow_mksock</a></li>
<li><a href="#domain_policy_allow_mkblock">allow_mkblock</a></li>
<li><a href="#domain_policy_allow_mkchar">allow_mkchar</a></li>
<li><a href="#domain_policy_allow_truncate">allow_truncate</a></li>
<li><a href="#domain_policy_allow_symlink">allow_symlink</a></li>
<li><a href="#domain_policy_allow_link">allow_link</a></li>
<li><a href="#domain_policy_allow_rename">allow_rename</a></li>
<li><a href="#domain_policy_allow_rewrite">allow_rewrite</a></li>
<li><a href="#domain_policy_allow_argv0">allow_argv0</a></li>
<li><a href="#domain_policy_allow_env">allow_env</a></li>
<li><a href="#domain_policy_allow_network">allow_network</a></li>
<li><a href="#domain_policy_allow_capability">allow_capability</a></li>
<li><a href="#domain_policy_allow_signal">allow_signal</a></li>
<li><a href="#domain_policy_use_profile">use_profile</a></li>
<li><a href="#domain_policy_ignore_global_allow_read">ignore_global_allow_read</a></li>
<li><a href="#domain_policy_ignore_global_allow_env">ignore_global_allow_env</a></li>
<li><a href="#domain_policy_execute_handler">execute_handler</a></li>
<li><a href="#domain_policy_denied_execute_handler">denied_execute_handler</a></li>
<li><a href="#domain_policy_quota_exceeded">quota_exceeded</a></li>
</ul>

<p>Used by /proc/ccs/manager and /etc/ccs/manager.conf</p>

<ul>
<li><a href="#manager_manage_by_non_root">manage_by_non_root</a></li>
</ul>

<h1>2. <a name="Common_Rules">Introduction</a></h1>

<h2>2.1 <a name="word_expression_rules">Word Expression Rules</a></h2>

<p>TOMOYO Linux performs pathname based access control. A pathname may contain not only alphabet and number but also space and carriage return and multibyte  (e.g. kanji) characters. Thus, to be able to handle any characters correctly,
TOMOYO Linux follows the rules shown below to represent a word. A word means all tokens that are treated as string data, such as pathnames, comments, environment variable's names, parameters for program execution.</p>

<ul>
<li>NUL character (0x00) is used for indicating end of string. Thus you cannot include \000 in a word.</li>
<li>\ character (0x5C) is used for indicating octal expression. Thus, you need to use \\ to represent a \.</li>
<li>Characters 0x01 - 0x20 and 0x7F - 0xFF are represented using octal expression \ooo .</li>
<li>The rest characters (i.e. 0x21 - 0x5B and 0x5D - 0x7E) are represented as is.</li>
</ul>

<table border="1">
<tr><td><table><tr><td></td><td>Lower 4 bits</td></tr><tr><td>Higher 4 bits</td><td></td></tr></table></td><td>0x0</td><td>0x1</td><td>0x2</td><td>0x3</td><td>0x4</td><td>0x5</td><td>0x6</td><td>0x7</td><td>0x8</td><td>0x9</td><td>0xA</td><td>0xB</td><td>0xC</td><td>0xD</td><td>0xE</td><td>0xF</td></tr>
<tr><td>0x0</td><td></td><td>\001</td><td>\002</td><td>\003</td><td>\004</td><td>\005</td><td>\006</td><td>\007</td><td>\010</td><td>\011</td><td>\012</td><td>\013</td><td>\014</td><td>\015</td><td>\016</td><td>\017</td></tr>
<tr><td>0x1</td><td>\020</td><td>\021</td><td>\022</td><td>\023</td><td>\024</td><td>\025</td><td>\026</td><td>\027</td><td>\030</td><td>\031</td><td>\032</td><td>\033</td><td>\034</td><td>\035</td><td>\036</td><td>\037</td></tr>
<tr><td>0x2</td><td>\040</td><td>!</td><td>"</td><td>#</td><td>$</td><td>%</td><td>&amp;</td><td>'</td><td>(</td><td>)</td><td>*</td><td>+</td><td>,</td><td>-</td><td>.</td><td>/</td></tr>
<tr><td>0x3</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>:</td><td>;</td><td>&lt;</td><td>=</td><td>&gt;</td><td>?</td></tr>
<tr><td>0x4</td><td>@</td><td>A</td><td>B</td><td>C</td><td>D</td><td>E</td><td>F</td><td>G</td><td>H</td><td>I</td><td>J</td><td>K</td><td>L</td><td>M</td><td>N</td><td>O</td></tr>
<tr><td>0x5</td><td>P</td><td>Q</td><td>R</td><td>S</td><td>T</td><td>U</td><td>V</td><td>W</td><td>X</td><td>Y</td><td>Z</td><td>[</td><td>\\</td><td>]</td><td>^</td><td>_</td></tr>
<tr><td>0x6</td><td>`</td><td>a</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td><td>h</td><td>i</td><td>j</td><td>k</td><td>l</td><td>m</td><td>n</td><td>o</td></tr>
<tr><td>0x7</td><td>p</td><td>q</td><td>r</td><td>s</td><td>t</td><td>u</td><td>v</td><td>w</td><td>x</td><td>y</td><td>z</td><td>{</td><td>|</td><td>}</td><td>~</td><td>\177</td></tr>
<tr><td>0x8</td><td>\200</td><td>\201</td><td>\202</td><td>\203</td><td>\204</td><td>\205</td><td>\206</td><td>\207</td><td>\210</td><td>\211</td><td>\212</td><td>\213</td><td>\214</td><td>\215</td><td>\216</td><td>\217</td></tr>
<tr><td>0x9</td><td>\220</td><td>\221</td><td>\222</td><td>\223</td><td>\224</td><td>\225</td><td>\226</td><td>\227</td><td>\230</td><td>\231</td><td>\232</td><td>\233</td><td>\234</td><td>\235</td><td>\236</td><td>\237</td></tr>
<tr><td>0xA</td><td>\240</td><td>\241</td><td>\242</td><td>\243</td><td>\244</td><td>\245</td><td>\246</td><td>\247</td><td>\250</td><td>\251</td><td>\252</td><td>\253</td><td>\254</td><td>\255</td><td>\256</td><td>\257</td></tr>
<tr><td>0xB</td><td>\260</td><td>\261</td><td>\262</td><td>\263</td><td>\264</td><td>\265</td><td>\266</td><td>\267</td><td>\270</td><td>\271</td><td>\272</td><td>\273</td><td>\274</td><td>\275</td><td>\276</td><td>\277</td></tr>
<tr><td>0xC</td><td>\300</td><td>\301</td><td>\302</td><td>\303</td><td>\304</td><td>\305</td><td>\306</td><td>\307</td><td>\310</td><td>\311</td><td>\312</td><td>\313</td><td>\314</td><td>\315</td><td>\316</td><td>\317</td></tr>
<tr><td>0xD</td><td>\320</td><td>\321</td><td>\322</td><td>\323</td><td>\324</td><td>\325</td><td>\326</td><td>\327</td><td>\330</td><td>\331</td><td>\332</td><td>\333</td><td>\334</td><td>\335</td><td>\336</td><td>\337</td></tr>
<tr><td>0xE</td><td>\340</td><td>\341</td><td>\342</td><td>\343</td><td>\344</td><td>\345</td><td>\346</td><td>\347</td><td>\350</td><td>\351</td><td>\352</td><td>\353</td><td>\354</td><td>\355</td><td>\356</td><td>\357</td></tr>
<tr><td>0xF</td><td>\360</td><td>\361</td><td>\362</td><td>\363</td><td>\364</td><td>\365</td><td>\366</td><td>\367</td><td>\370</td><td>\371</td><td>\372</td><td>\373</td><td>\374</td><td>\375</td><td>\376</td><td>\377</td></tr>
</table>

<ul>
<li>Space character (0x20) is used as a delimiter that separates words. Line feed character (0x0A) is used as a delimiter that separates lines.</li>
<li>Only words that follow the rule above and the delimiters (i.e. space character and line feed characters) are valid. All other characters are regarded as space character. Multiple spaces are automatically compressed into one space. Leading and trailing spaces are automatically deleted.</li>
</ul>

<p>Some examples are shown below.</p>

<table border="1">
<tr><td>Word</td><td>Correct expression</td><td>Wrong expression</td></tr>
<tr><td>Hello world!</td><td>Hello\040world!</td><td>"Hello world!"</td></tr>
<tr><td>/home/user/Documents and Settings/</td><td>/home/user/Documents\040and\040Settings/</td><td>/home/user/Documents and Settings/</td></tr>
</table>

<p>Pathname must start with / character. Pathnames that end with / character are interpreted as directories, and that don't end with / character are interpreted as non-directories.</p>

<table border="1">
<tr><td>Pathname</td><td>Interpretation</td></tr>
<tr><td>/</td><td>A directory</td></tr>
<tr><td>/tmp/</td><td>A directory</td></tr>
<tr><td>/tmp</td><td>Not a directory</td></tr>
<tr><td>tmp/</td><td>Invalid pathname</td></tr>
</table>

<p>Exceptions are pipes and sockets. Pipes begin with "pipe:" and sockets begin with "socket:" when these pathnames are accessed via /proc/PID/fd/ directory.</p>

<h2>2.2 <a name="wildcard_expression_rules">Wildcard Expression Rules</a></h2>

<p>Like temporary files, pathnames may contain randomly selected characters. Thus, you often need to define pathnames using wildcards. TOMOYO Linux supports wildcards shown below.</p>

<table border="1">
<tr><td>Wildcard</td><td>Meaning</td><td>Example</td></tr>
<tr><td>\*</td><td>More than or equals to 0 character other than '/'.</td><td>/var/log/samba/\*</td></tr>
<tr><td>\@</td><td>More than or equals to 0 character other than '/' or '.'.</td><td>/var/www/html/\@.html</td></tr>
<tr><td>\?</td><td>1 byte character other than '/'.</td><td>/tmp/mail.\?\?\?\?\?\?</td></tr>
<tr><td>\$</td><td>More than or equals to 1 decimal digit.</td><td>/proc/\$/cmdline</td></tr>
<tr><td>\+</td><td>1 decimal digit.</td><td>/var/tmp/my_work.\+</td></tr>
<tr><td>\X</td><td>More than or equals to 1 hexadecimal digit.</td><td>/var/tmp/my-work.\X</td></tr>
<tr><td>\x</td><td>1 hexadecimal digit.</td><td>/tmp/my-work.\x</td></tr>
<tr><td>\A</td><td>More than or equals to 1 alphabet character.</td><td>/var/log/my-work/\$-\A-\$.log</td></tr>
<tr><td>\a</td><td>1 alphabet character.</td><td>/home/users/\a/\*/public_html/\*.html</td></tr>
<tr><td>\-</td><td>Pathname subtraction operator.</td><td>
 <table border="1">
 <tr><td>Example</td><td>Meaning</td></tr>
 <tr><td>/etc/\*</td><td>All files in /etc/ directory.</td></tr>
 <tr><td>/etc/\*\-\*shadow\*</td><td>/etc/\* other than /etc/\*shadow\*</td></tr>
 <tr><td>/\*\-proc\-sys/</td><td>/\*/ other than /proc/ /sys/</td></tr>
 </table>
</td></tr>
</table>

<h2>2.3 <a name="word_length_rules">Word Length Rules</a></h2>

<p>There is no limitation regarding the length of pathnames in Linux. But to perform pathname based access control, it is impossible to support pathnames with infinite length. Thus, in TOMOYO Linux, the length of a word is limited to 4000 bytes including trailing NUL character.</p>

<h2>2.4 <a name="line_length_rules">Line Length Rules</a></h2>

<p>In TOMOYO Linux, the length of a line is limited to 8192 bytes including trailing NUL character.</p>

<h2>2.5 <a name="memory_allocation_rules">Memory Allocation Rules</a></h2>

<p>In TOMOYO Linux, memory allocated for holding access permissions and words are never freed. There is no way except rebooting the system that can free unneeded memory.</p>

<p>But don't worry. The policy seldom changes after you start production mode. By tuning policy before starting production mode, you can reduce memory usage to (usually) less than 1 MB.</p>

<p>The memory used by TOMOYO Linux can be obtained via /proc/ccs/meminfo . The unit is byte. "Shared:" indicates memory used for holding words. "Private:" indicates memory used for holding access permissions. These memories never decrease.
"Dynamic:" indicates memory used for temporal purpose such as access permission checks and access logs. This memory decreases when it became unneeded.</p>

<table border="1">
<tr><td><pre>
# cat /proc/ccs/meminfo

Shared:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;65536
Private:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;49152
Dynamic:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5106
Total:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;119794
</pre></td></tr>
</table>

<h1>3. <a name="Policy_Files">Policy Files</a></h1>

<h2>3.1 <a name="policy_file_locations">Policy File's Location</a></h2>

<p>Policy files are files that contain access permissions. These files are automatically loaded into the kernel upon boot.</p>

<p>When a system boots, /sbin/init is executed. When the execution of /sbin/init is requested and if /sbin/ccs-init exists, /sbin/ccs-init is executed, and /sbin/init is executed after /sbin/ccs-init terminates.</p>

<p> /sbin/ccs-init loads policy files in /etc/ccs/ directory via the kernel's /proc/ccs/ interface.</p>

<table border="1">
<tr><td>The kernel's interface</td><td>Policy file</td><td>Contents</td></tr>
<tr><td><a href="#profile">/proc/ccs/profile</a></td><td>/etc/ccs/profile.conf</td><td>Profiles (Collection of access control levels)</td></tr>
<tr><td><a href="#manager">/proc/ccs/manager</a></td><td>/etc/ccs/manager.conf</td><td>Managers (Programs that can modify policy via /proc/ccs/ interface)</td></tr>
<tr><td><a href="#system_policy">/proc/ccs/system_policy</a></td><td>/etc/ccs/system_policy.conf</td><td>System policy (Access permissions given to system)</td></tr>
<tr><td><a href="#exception_policy">/proc/ccs/exception_policy</a></td><td>/etc/ccs/exception_policy.conf</td><td>Exception policy (Collection of exceptions for domain policy)</td></tr>
<tr><td><a href="#domain_policy">/proc/ccs/domain_policy</a></td><td>/etc/ccs/domain_policy.conf</td><td>Domain policy (Access permissions given to individual domains)</td></tr>
</table>

<p>There are more interfaces for obtaining information. These interfaces don't have corresponding policy files.</p>

<table border="1">
<tr><td>The kernel's interface</td><td>Meaning</td></tr>
<tr><td><a href="#query">/proc/ccs/query</a></td><td>Access requests that are waiting for administrator's decision.</td></tr>
<tr><td><a href="#.domain_status">/proc/ccs/.domain_status</a></td><td>The list of domainnames and profile numbers currently defined in domain policy.</td></tr>
<tr><td><a href="#meminfo">/proc/ccs/meminfo</a></td><td>Memory usage.</td></tr>
<tr><td><a href="#grant_log">/proc/ccs/grant_log</a></td><td>Access requests that didn't violate domain policy.</td></tr>
<tr><td><a href="#reject_log">/proc/ccs/reject_log</a></td><td>Access requests that violated domain policy.</td></tr>
<tr><td><a href="#self_domain">/proc/ccs/self_domain</a></td><td>The name of domain the current process belongs to.</td></tr>
<tr><td><a href="#.process_status">/proc/ccs/.process_status</a></td><td>The list of domainnames and profile numbers currently running processes belongs to.</td></tr>
<tr><td><a href="#.updates_counter">/proc/ccs/.updates_counter</a></td><td>Counter for policy updates.</td></tr>
<tr><td><a href="#version">/proc/ccs/version</a></td><td>Version of TOMOYO Linux.</td></tr>
</table>

<h2>3.2 <a name="policy_file_modifiers">Policy File's Modification</a></h2>

<p>Register the name of programs or domains that can modify policy via the kernel's /proc/ccs/ interface. Only</p>

<ul>
<li>Processes with programs listed in /proc/ccs/manager</li>
<li>Processes with domainnames listed in /proc/ccs/manager</li>
</ul>

<p>can modify policy via the kernel's /proc/ccs/ interface. Some examples are show below.</p>

<table border="1">
<tr><td>
# cat /proc/ccs/manager<br>
/usr/lib/ccs/loadpolicy<br>
/usr/lib/ccs/editpolicy<br>
/usr/lib/ccs/setlevel<br>
/usr/lib/ccs/setprofile<br>
/usr/lib/ccs/ld-watch<br>
/usr/lib/ccs/ccs-queryd<br>
&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash
</td></tr>
</table>

<p>By default, only processes with UID = 0 and EUID = 0 can modify policy via this interface. But by doing configurations described in <a href="#non_root_policy_update">Allowing policy modification by non root user.</a>, non root user can modify policy via this interface.</p>

<p>Exception is, processes that belong to domains with profiles for learning mode can append access permissions to <a href="#system_policy">/proc/ccs/system_policy</a> and <a href="#domain_policy">/proc/ccs/domain_policy</a> by simply requesting the access.</p>

<h1>4. <a name="Domain_Rules">Domain Rules</a></h1>

<h2>4.1 <a name="domain_definition">Domain Definition</a></h2>

<p>TOMOYO Linux has two patterns of policies. One gives access permissions as a whole system. The other gives access permissions as per a domain. The former is called system policy and is managed via <a href="#system_policy">/proc/ccs/system_policy</a>. The latter is called domain policy and is managed via <a href="#domain_policy">/proc/ccs/domain_policy</a>.</p>

<p>In TOMOYO Linux, every process belongs to a single domain, and all programs belong to different domain. Even the two processes are executing the same program, if their previous domains differ, they belong to different domain.</p>

<p>All domains are defined originating from "&lt;kernel&gt;" domain, which the kernel process belongs to. Since /sbin/init is invoked by the "&lt;kernel&gt;" domain, the domain for /sbin/init is defined as "&lt;kernel&gt; /sbin/init". Since /etc/rc.d/rc is invoked by /sbin/init invoked by the kernel, the domain for /etc/rc.d/rc is defined as "&lt;kernel&gt; /sbin/init /etc/rc.d/rc".</p>

<h2>4.2 <a name="domain_transition">Domain Transition</a></h2>

<p>There are some programs that behave differently depending on the invocation name.
For example, /sbin/pidof is a symbolic link to /sbin/killall5 . Since TOMOYO Linux uses canonicalized pathname, by default, if /sbin/pidof is executed, the domain is defined as if /sbin/killall5 is executed.</p>

<p>When a process tries to execute a program, the steps shown below are performed.</p>

<table border="1">
<tr><td>Step</td><td>Procedure</td></tr>
<tr><td>Getting program's name</td><td>
<p>Get the name of program that the process is going to execute and keep it as "Candidate 1". This procedure solves symbolic link if the program is a symbolic link.</p>
<p>Get the name of program that the process is going to execute and keep it as "Candidate 2". This procedure does not solve symbolic link if the program is a symbolic link.</p>
</td></tr>
<tr><td>Handling symbolic links</td><td>
<p>If "Candidate 1" and "Candidate 2" differ, search exception policy for</p>

<ul>
<li>alias "Candidate 1" "Candidate 2"
</ul>

<p>and if found one, replace "Candidate 1" with "Candidate 2".</p>
</td></tr>
<tr><td><a name="exec_stage_check_argv0">Checking argv[0]</a></td><td>
<p>If the basename of "Candidate 1" and the basename of argv[0] differ, search domain policy for</p>

<ul>
<li>allow_argv0 "Candidate 1" "the basename of argv[0]"
</ul>

<p>and deny the execute request if not found one.</p>
</td></tr>
<tr><td>Aggregating similar programs</td><td>
<p>Search exception policy for</p>

<ul>
<li>aggregator "Candidate 1" "aggregated name"
</ul>

<p>and if found one, replace "Candidate 1" with "aggregated name".</p>
</td></tr>
<tr><td><a name="exec_stage_check_execute">Checking permission</a></td><td>
<p>Search domain policy for</p>

<ul>
<li>allow_execute "Candidate 1"
<li>allow_execute @"a pathname group containing Candidate 1"
</ul>

<p>and deny the execute request if not found one.</p>
</td></tr>
<tr><td><a name="exec_stage_check_destination">Deciding destination domain</a></td><td>

<p>(1) Search exception policy for</p>

<ul>
<li>no_initialize_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>no_initialize_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>no_initialize_domain "Candidate 1"
</ul>

<p>and if found one, jump to (3).</p>

<p>(2) Search exception policy for</p>

<ul>
<li>initialize_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>initialize_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>initialize_domain "Candidate 1"
</ul>

<p>and if found one, concatenate "the name of the domain that the kernel belongs to (i.e. &lt;kernel&gt;)" and "Candidate 1" and keep the result as destination domain, then jump to (6).</p>

<p>(3) Search exception policy for</p>

<ul>
<li>no_keep_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>no_keep_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>no_keep_domain "the name of the domain the current process belongs to"
<li>no_keep_domain "the last part of the name of the domain the current process belongs to"
</ul>

<p>and if found one, jump to (5).</p>

<p>(4) Search exception policy for</p>

<ul>
<li>keep_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>keep_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>keep_domain "the name of the domain the current process belongs to"
<li>keep_domain "the last part of the name of the domain the current process belongs to"
</ul>

<p>and if found one, set "the name of the domain the current process belongs to" as destination domain, then jump to (6).</p>

<p>(5) Concatenate "the name of the domain the current process belongs to" and "Candidate 1" and keep the result as destination domain.</p>

<p>(6) Check whether the destination domain is defined, and deny the execute request if not.</p>

</td></tr>
<tr><td>Checking environment variable names</td><td>

<p>(1) Examine all environment variables' names are granted in the destination domain, and deny the execute request if more than one of them are not granted.</p>

<p>(2) Perform regular steps for executing program. If successfully completed, the process transits to destination domain.</p>
</td></tr>
</table>

<p>There is an exception. If either</p>

<ul>
<li>The execute request was denied at "<a href="#exec_stage_check_argv0">Checking argv[0]</a>" or "<a href="#exec_stage_check_execute">Checking permission</a>" or "<a href="#exec_stage_check_destination">Deciding destination domain</a>" but the domain the process that issued execute request belongs to has <a href="#domain_policy_denied_execute_handler">denied_execute_handler</a> keyword.</li>
<li>The domain the process that issued execute request belongs to has <a href="#domain_policy_execute_handler">execute_handler</a> keyword.</li>
</ul>

<p>and</p>

<ul>
<li>The process that issued execute request is not a process executed by <a href="#domain_policy_execute_handler">execute_handler</a> or <a href="#domain_policy_denied_execute_handler">denied_execute_handler</a> keyword.</li>
</ul>

<p>the steps shown below is performed instead for the steps shown above. The usage of this exception is explained in "<a href="#execute_handler">Judging execute request outside the kernel.</a>" and "<a href="#denied_execute_handler">Invoking alternative program for execute requests that are not permitted by policy.</a>"</p>

<table border="1">
<tr><td>Step</td><td>Procedure</td></tr>
<tr><td>Getting program's name</td><td>
<p>Keep the pathname of the program specified by <a href="#domain_policy_denied_execute_handler">denied_execute_handler</a> or <a href="#domain_policy_execute_handler">execute_handler</a> and keep it as "Candidate 1".</p>
</td></tr>
<tr><td>Appending information</td><td>
<p>Append all environment variables to the tail of arguments, and delete all environment variables.</p>
<p>Insert "Candidate 1" "the domainname the process that issued execute request belongs to" "the pathname of the process that issued execute request" "state of the process that issued execute request" "the pathname of the requested program" "number of arguments" "number of environment variables" to the top of arguments.</p>
</td></tr>
<tr><td>Deciding destination domain</td><td>

<p>(1) Search exception policy for</p>

<ul>
<li>no_initialize_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>no_initialize_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>no_initialize_domain "Candidate 1"
</ul>

<p>and if found one, jump to (3).</p>

<p>(2) Search exception policy for</p>

<ul>
<li>initialize_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>initialize_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>initialize_domain "Candidate 1"
</ul>

<p>and if found one, concatenate "the name of the domain that the kernel belongs to (i.e. &lt;kernel&gt;)" and "Candidate 1" and keep the result as destination domain, then jump to (6).</p>

<p>(3) Search exception policy for</p>

<ul>
<li>no_keep_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>no_keep_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>no_keep_domain "the name of the domain the current process belongs to"
<li>no_keep_domain "the last part of the name of the domain the current process belongs to"
</ul>

<p>and if found one, jump to (5).</p>

<p>(4) Search exception policy for</p>

<ul>
<li>keep_domain "Candidate 1" from "the name of the domain the current process belongs to"
<li>keep_domain "Candidate 1" from "the last part of the name of the domain the current process belongs to"
<li>keep_domain "the name of the domain the current process belongs to"
<li>keep_domain "the last part of the name of the domain the current process belongs to"
</ul>

<p>and if found one, set "the name of the domain the current process belongs to" as destination domain, then jump to (6).</p>

<p>(5) Concatenate "the name of the domain the current process belongs to" and "Candidate 1" and keep the result as destination domain.</p>

<p>(6) Check whether the destination domain is defined, and deny the execute request if not.</p>

</td></tr>
<tr><td>Execute program</td><td>

<p>Perform regular steps for executing program. If successfully completed, the process transits to destination domain.</p>

</td></tr>
</table>

<h2>4.3 <a name="access_logs">Access Logs</a></h2>

<p>TOMOYO Linux generates two types of access logs. One contains access requests that didn't violate domain policy. The other contains access requests that violated domain policy. The former is called grant log and is readable via /proc/ccs/grant_log . The latter is called reject log and is readable via /proc/ccs/reject_log . A utility program /usr/lib/ccs/ccs-auditd is included for reading these logs and saving the logs as files.</p>

<p>Some examples are shown below. The first log is generated by execute request.</p>

<table border="1">
<tr><td>
#2008-04-09 12:50:15# profile=1 mode=learning pid=5054 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 state[0]=0 state[1]=0 state[2]=0 argc=2 envc=16 argv[]={ "cat" "/etc/fstab" } envp[]={ "TERM=vt100" "SHELL=/bin/bash" "SSH_CLIENT=::ffff:192.168.99.1\04048601\04022" "SSH_TTY=/dev/pts/0" "USER=root" "MAIL=/var/mail/root" "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/lib/ccs" "PWD=/root" "LANG=C" "PS1=\\h:\\w\\$\040" "SHLVL=1" "HOME=/root" "LANGUAGE=en_JP:en_US:en_GB:en" "LOGNAME=root" "SSH_CONNECTION=::ffff:192.168.99.1\04048601\040::ffff:192.168.99.152\04022" "_=/bin/cat" }<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
allow_execute /bin/cat
</td></tr>
</table>

<p>This log shows that a process that belongs to "&lt;kernel&gt; /usr/sbin/sshd /bin/bash" domain attempted to execute /bin/cat , and the arguments were "cat" and "/etc/fstab", environment variables were "TERM=vt100" "SHELL=/bin/bash" "SSH_CLIENT=::ffff:192.168.99.1\04048601\04022" "SSH_TTY=/dev/pts/0" "USER=root" "MAIL=/var/mail/root" "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/lib/ccs" "PWD=/root" "LANG=C" "PS1=\\h:\\w\\$\040" "SHLVL=1" "HOME=/root" "LANGUAGE=en_JP:en_US:en_GB:en" "LOGNAME=root" "SSH_CONNECTION=::ffff:192.168.99.1\04048601\040::ffff:192.168.99.152\04022" "_=/bin/cat". Also, process information such as PID, UID are shown.</p>

<p>The next log is generated by opening a file for reading.</p>

<table border="1">
<tr><td>
#2008-04-09 12:50:15# profile=1 mode=learning pid=5054 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 state[0]=0 state[1]=0 state[2]=0<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/cat<br>
allow_read /etc/fstab
</td></tr>
</table>

<p>This log shows that a process that belongs to "&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/cat" domain opened /etc/fstab for reading.</p>

<p>The next log is generated when a new domain is created.</p>

<table border="1">
<tr><td>
#2008-04-09 12:52:01# profile=1 mode=learning pid=5110 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 state[0]=0 state[1]=0 state[2]=0<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash /bin/audit-exec-param /bin/cat<br>
use_profile 1
</td></tr>
</table>

<p>This log shows that a domain named "&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash /bin/audit-exec-param /bin/cat" was created and profile 1 was assigned. TOMOYO Linux automatically creates domains as needed. When a domain is automatically created, the profile number of the domain the process that requested program execution belongs to is inherited.</p>

<p>The next log is generated when a program that is different from the program being requested was executed because of <a href="#execute_handler">Judging execute request outside the kernel.</a></p>
<table border="1">
<tr><td>
#2008-04-09 12:52:01# profile=1 mode=learning pid=5110 uid=0 gid=0 euid=0 egid=0 suid=0 sgid=0 fsuid=0 fsgid=0 state[0]=0 state[1]=0 state[2]=0 argc=24 envc=0 argv[]={ "/bin/audit-exec-param" "&lt;kernel&gt;\040/usr/sbin/sshd\040/bin/bash\040/bin/bash" "/bin/bash" "pid=5110\040uid=0\040gid=0\040euid=0\040egid=0\040suid=0\040sgid=0\040fsuid=0\040fsgid=0\040state[0]=0\040state[1]=0\040state[2]=0" "/bin/cat" "2" "18" "cat" "/etc/fstab" "SHELL=/bin/bash" "TERM=vt100" "SSH_CLIENT=::ffff:192.168.99.1\04048601\04022" "SSH_TTY=/dev/pts/0" "USER=root" "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/lib/ccs" "MAIL=/var/mail/root" "_=/bin/cat" "PWD=/root" "LANG=C" "HOME=/root" "SHLVL=2" "LANGUAGE=en_JP:en_US:en_GB:en" "LOGNAME=root" "SSH_CONNECTION=::ffff:192.168.99.1\04048601\040::ffff:192.168.99.152\04022" } envp[]={ }<br>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash<br>
execute_handler /bin/audit-exec-param
</td></tr>
</table>

<p>This log shows that a process that belongs to a domain named "&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/bash" attempted to execute a program, but since the execute_handler keyword is specified to the domain, /bin/audit-exec-param was executed, and arguments passed to /bin/audit-exec-param were "/bin/audit-exec-param" "&lt;kernel&gt;\040/usr/sbin/sshd\040/bin/bash\040/bin/bash" "/bin/bash" "pid=5110\040uid=0\040gid=0\040euid=0\040egid=0\040suid=0\040sgid=0\040fsuid=0\040fsgid=0\040state[0]=0\040state[1]=0\040state[2]=0" "/bin/cat" "2" "18" "cat" "/etc/fstab" "SHELL=/bin/bash" "TERM=vt100" "SSH_CLIENT=::ffff:192.168.99.1\04048601\04022" "SSH_TTY=/dev/pts/0" "USER=root" "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11:/usr/lib/ccs" "MAIL=/var/mail/root" "_=/bin/cat" "PWD=/root" "LANG=C" "HOME=/root" "SHLVL=2" "LANGUAGE=en_JP:en_US:en_GB:en" "LOGNAME=root" "SSH_CONNECTION=::ffff:192.168.99.1\04048601\040::ffff:192.168.99.152\04022". To avoid /bin/audit-exec-param affected by environment variables such as LD_PRELOAD, environment variables are moved to arguments.</p>

<p>In this way, an access log consists of 3 lines (or 4 lines since /usr/lib/ccs/ccs-auditd inserts an empty line), and they are in the domain policy format and appendable to the domain policy. Pick up portions you want to permit from reject log and save (for example, /var/log/tomoyo/diff.txt) and you can add to domain policy by doing</p>

<table border="1">
<tr><td>
# /usr/lib/ccs/loadpolicy -d &lt; /var/log/tomoyo/diff.txt
</td></tr>
</table>

<p>Therefore, you don't need to use "learning mode" from the beginning. If you wish, you can use "permissive mode" from the beginning and let reject logs generated, then edit reject logs and append to domain policy when developing domain policy. When domain policy is generated by "learning mode", process state (the first line of an access logs) is not taken into account. But when domain policy is generated from reject logs, you can use <a href="#conditional_acl">Using conditional ACL.</a> from the beginning. For example, generate a reject log by not using "learning mode" and append like</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
allow_execute /bin/cat if exec.argc=2 exec.argv[0]="cat" exec.argv[1]="/etc/fstab"
</td></tr>
</table>

<p>then, you can give more precise permission compared to the permission appended by "learning mode"'s log (shown below).</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd /bin/bash<br>
allow_execute /bin/cat
</td></tr>
</table>

<h1>5. <a name="Syntax_Details">Syntax Details</a></h1>

<h2><a name="profile">/proc/ccs/profile</a></h2>

<p>TOMOYO Linux can perform several MACs besides MAC for files, but to reduce the load of policy managements, you can disable MACs you think unnecessary.</p>

<p>List up functions and their modes in "$number-$variable=$value" format. The $number is profile number between 0 and 255. To modify profile, use "setlevel" or "loadpolicy" commands.</p>

<p>Each domain is assigned one profile. To assign profile to domains, use "setprofile" or "editpolicy" or "loadpolicy" commands.</p>

<p>You can see profiles currently assigned to domains using "editpolicy" command.<br>
You can see profiles currently assigned to processes using "ccstree" command.<br>
If you saved current policy using "savepolicy" command, the currently assigned profile number is saved as <a href="#domain_policy_use_profile">use_profile</a> line of domain policy.</p>

<p>To read or modify current profiles, operate like below.</p>

<p>(Example)<br>
cat /proc/ccs/profile<br>
savepolicy -p<br>
setlevel 1-MAC_FOR_FILE=learning<br>
echo 1-MAC_FOR_FILE=learning | loadpolicy -p</p>

<p>See also: <a href="#policy_file_modifiers">Policy File's Modification</a></p>

<h3><a name="profile_MAC_FOR_FILE">MAC_FOR_FILE</a></h3>

<p>Specifies access control level regarding file access requests.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_ARGV0">MAC_FOR_ARGV0</a></h3>

<p>Specifies access control level regarding program invocation mame (a.k.a. argv[0]).</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_ENV">MAC_FOR_ENV</a></h3>

<p>Specifies access control level regarding environment variable names (a.k.a. envp[]).</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::inet_tcp_create">MAC_FOR_CAPABILITY::inet_tcp_create</a></h3>

<p>Specifies access control level regarding creation of TCP sockets.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::inet_tcp_listen">MAC_FOR_CAPABILITY::inet_tcp_listen</a></h3>

<p>Specifies access control level regarding TCP socket's listen operation.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::inet_tcp_connect">MAC_FOR_CAPABILITY::inet_tcp_connect</a></h3>

<p>Specifies access control level regarding TCP socket's connect operation.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::use_inet_udp">MAC_FOR_CAPABILITY::use_inet_udp</a></h3>

<p>Specifies access control level regarding use of UDP sockets.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::use_inet_ip">MAC_FOR_CAPABILITY::use_inet_ip</a></h3>

<p>Specifies access control level regarding use of RAW sockets.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::use_route">MAC_FOR_CAPABILITY::use_route</a></h3>

<p>Specifies access control level regarding use of ROUTE sockets.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::use_packet">MAC_FOR_CAPABILITY::use_packet</a></h3>

<p>Specifies access control level regarding use of PACKET sockets.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::use_kernel_module">MAC_FOR_CAPABILITY::use_kernel_module</a></h3>

<p>Specifies access control level regarding use of create_module(2) init_module(2) delete_module(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::create_fifo">MAC_FOR_CAPABILITY::create_fifo</a></h3>

<p>Specifies access control level regarding creation of FIFO using mknod(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::create_block_dev">MAC_FOR_CAPABILITY::create_block_dev</a></h3>

<p>Specifies access control level regarding creation of block device file using mknod(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::create_char_dev">MAC_FOR_CAPABILITY::create_char_dev</a></h3>

<p>Specifies access control level regarding creation of character device file using mknod(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::create_unix_socket">MAC_FOR_CAPABILITY::create_unix_socket</a></h3>

<p>Specifies access control level regarding creation of UNIX domain socket using mknod(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_MOUNT">MAC_FOR_CAPABILITY::SYS_MOUNT</a></h3>

<p>Specifies access control level regarding use of mount(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_UMOUNT">MAC_FOR_CAPABILITY::SYS_UMOUNT</a></h3>

<p>Specifies access control level regarding use of umount(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_REBOOT">MAC_FOR_CAPABILITY::SYS_REBOOT</a></h3>

<p>Specifies access control level regarding use of reboot(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_CHROOT">MAC_FOR_CAPABILITY::SYS_CHROOT</a></h3>

<p>Specifies access control level regarding use of chroot(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_KILL">MAC_FOR_CAPABILITY::SYS_VHANGUP</a></h3>

<p>Specifies access control level regarding use of kill(2) tkill(2) tgkill(2) syscall with non 0 signal.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_VHANGUP">MAC_FOR_CAPABILITY::SYS_VHANGUP</a></h3>

<p>Specifies access control level regarding use of vhangup(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_TIME">MAC_FOR_CAPABILITY::SYS_TIME</a></h3>

<p>Specifies access control level regarding use of stime(2) settimeofday(2) adjtimex(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_NICE">MAC_FOR_CAPABILITY::SYS_NICE</a></h3>

<p>Specifies access control level regarding use of nice(2) setpriority(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_SETHOSTNAME">MAC_FOR_CAPABILITY::SYS_SETHOSTNAME</a></h3>

<p>Specifies access control level regarding use of sethostname(2) setdomainname(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_LINK">MAC_FOR_CAPABILITY::SYS_LINK</a></h3>

<p>Specifies access control level regarding use of link(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_SYMLINK">MAC_FOR_CAPABILITY::SYS_SYMLINK</a></h3>

<p>Specifies access control level regarding use of symlink(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_RENAME">MAC_FOR_CAPABILITY::SYS_RENAME</a></h3>

<p>Specifies access control level regarding use of rename(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_UNLINK">MAC_FOR_CAPABILITY::SYS_UNLINK</a></h3>

<p>Specifies access control level regarding use of unlink(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_CHMOD">MAC_FOR_CAPABILITY::SYS_CHMOD</a></h3>

<p>Specifies access control level regarding use of chmod(2) fchmod(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_CHOWN">MAC_FOR_CAPABILITY::SYS_CHOWN</a></h3>

<p>Specifies access control level regarding use of chown(2) fchown(2) lchown(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_IOCTL">MAC_FOR_CAPABILITY::SYS_IOCTL</a></h3>

<p>Specifies access control level regarding use of ioctl(2) compat_sys_ioctl(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_KEXEC_LOAD">MAC_FOR_CAPABILITY::SYS_KEXEC_LOAD</a></h3>

<p>Specifies access control level regarding use of kexec_load(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_PIVOT_ROOT">MAC_FOR_CAPABILITY::SYS_PIVOT_ROOT</a></h3>

<p>Specifies access control level regarding use of pivot_root(2) syscall.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_CAPABILITY::SYS_PTRACE">MAC_FOR_CAPABILITY::SYS_PTRACE</a></h3>

<p>Specifies access control level regarding use of ptrace(2) syscall.<br>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_NETWORK">MAC_FOR_NETWORK</a></h3>

<p>Specifies access control level regarding network access requests.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_MAC_FOR_SIGNAL">MAC_FOR_SIGNAL</a></h3>

<p>Specifies access control level regarding signal transmission requests.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_DENY_CONCEAL_MOUNT">DENY_CONCEAL_MOUNT</a></h3>
<p>Specifies access control level regarding mount requests that shadow existent mounts.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>permissive</td><td>Permissive mode. Prints warning messages for mount requests that will shadow existent mounts. But don't reject the request.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. Prints error messages for mount requests that will shadow existent mounts. And reject the request.</td></tr>
</table>

<h3><a name="profile_RESTRICT_CHROOT">RESTRICT_CHROOT</a></h3>

<p>Specifies access control level regarding chroot requests.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_RESTRICT_MOUNT">RESTRICT_MOUNT</a></h3>

<p>Specifies access control level regarding mount request's parameters.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_RESTRICT_UNMOUNT">RESTRICT_UNMOUNT</a></h3>

<p>Specifies access control level regarding unmount request of specific directories.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>permissive</td><td>Permissive mode. Prints warning messages for unmount requests against directories that are not permitted to be unmounted. But don't reject the request.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. Prints error messages for unmount requests against directories that are not permitted to be unmounted. And reject the request.</td></tr>
</table>

<h3><a name="profile_RESTRICT_PIVOT_ROOT">RESTRICT_PIVOT_ROOT</a></h3>

<p>Specifies access control level regarding pivot_root requests.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>learning</td><td>Learning mode. An access request is not rejected even if the request violates policy. Also, the permission to allow the request is automatically added to policy so that the same request no longer violates policy.</td></tr>
<tr><td>permissive</td><td>Permissive mode. An access request is not rejected even if the request violates policy. But, the permission to allow the request is not added to policy.</td></tr>
<tr><td>enforcing</td><td>Enforcing mode. An access request is rejected if the request violates policy.</td></tr>
</table>

<h3><a name="profile_RESTRICT_AUTOBIND">RESTRICT_AUTOBIND</a></h3>

<p>Specifies access control level regarding automatic local port selection requests.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>enabled</td><td>Enabled. Forbid specified port number from being selected when automatic local port selection request happens.</td></tr>
</table>

<h3><a name="profile_MAX_ACCEPT_ENTRY">MAX_ACCEPT_ENTRY</a></h3>

<p>Limits the max number of ACL entries that are automatically appended during learning mode. Default is 2048.</p>

<h3><a name="profile_MAX_GRANT_LOG">MAX_GRANT_LOG</a></h3>

<p>Limits the max number of grant logs that the kernel can hold. Default is 1024.</p>

<h3><a name="profile_MAX_REJECT_LOG">MAX_REJECT_LOG</a></h3>

<p>Limits the max number of reject logs that the kernel can hold. Default is 1024.</p>

<h3><a name="profile_TOMOYO_VERBOSE">TOMOYO_VERBOSE</a></h3>

<p>Specifies whether to print domain policy violation messages or not.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Disabled. Don't print domain policy violation messages.</td></tr>
<tr><td>enabled</td><td>Enabled. Print domain policy violation messages.</td></tr>
</table>

<h3><a name="profile_ALLOW_ENFORCE_GRACE">ALLOW_ENFORCE_GRACE</a></h3>

<p>Specifies whether to permit judging access requests which violates policy in enforcing mode interactively.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>disabled</td><td>Reject immediately when an access request violated policy in enforcing mode.</td></tr>
<tr><td>enabled</td><td>Ask for administrator's decision when an access request violated policy in enforcing mode.</td></tr>
</table>

<h3><a name="profile_SLEEP_PERIOD">SLEEP_PERIOD</a></h3>

<p>Specifies how long should the process that violated policy in enforcing mode sleep for.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>Between 0 to 3000</td><td>Sleep duration in 0.1 seconds. Default is 0.</td></tr>
</table>

<h2>

<a name="system_policy">/proc/ccs/system_policy</a></h2>

<p>This file contains permissions that apply to the entire system.</p>

<p>To read or modify current system policy, operate like below.</p>
<p>(Example)<br>
cat /proc/ccs/system_policy<br>
savepolicy -s<br>
echo 'allow_mount /proc /proc/ proc' | loadpolicy -s<br>
echo 'delete allow_mount /proc /proc/ proc' | loadpolicy -s</p>

<p>See also: <a href="#policy_file_modifiers">Policy File's Modification</a></p>

<h3><a name="system_policy_allow_mount">allow_mount</a></h3>
<p>To grant mount permission, use allow_mount keyword followed by "$devicefile $mountpoint $filesystem $options".<br>
The $devicefile need to be a canonicalized file if the $filesystem requires device file.<br>
The $mountpoint must be a canonicalized file.<br>
The $options is a hexadecimal integer expression.</p>

<p>To grant "mount -o remount $mountpoint" permission, use allow_mount keyword followed by "any $mountpoint --remount $options".</p>

<p>To grant "mount --bind $source_dir $dest_dir" and "mount --move $source_dir $dest_dir" permission, use allow_mount keyword followed by "$source_dir $dest_dir --bind $options" and "$source_dir $dest_dir --move $options" respectively.<br>
The $source_dir and $dest_dir must be canonicalized directory.</p>

<p>Kernel 2.6.15 and later supports "Shared Subtree" functionality.<br>
To grant "mount --make-unbindable $mountpoint" permission, use allow_mount keyword followed by "any $mountpoint --make-unbindable $options".<br>
To grant "mount --make-private $mountpoint" permission, use allow_mount keyword followed by "any $mountpoint --make-private $options".<br>
To grant "mount --make-slave $mountpoint" permission, use allow_mount keyword followed by "any $mountpoint --make-slave $options".<br>
To grant "mount --make-shared $mountpoint" permission, use allow_mount keyword followed by "any $mountpoint --make-shared $options".</p>

<p>(Example)<br>
allow_mount none /dev/pts/ devpts 0x0<br>
allow_mount /proc /proc/ proc 0x0<br>
allow_mount usbdevfs /proc/bus/usb/ usbdevfs 0x0<br>
allow_mount none /data/ tmpfs 0xE<br>
allow_mount none /dev/shm/ tmpfs 0xE<br>
allow_mount /dev/hdc /var/www/ ext2 0xF<br>
allow_mount any / --remount 0x0</p>

<h3><a name="system_policy_deny_unmount">deny_unmount</a></h3>
<p>To reject unmount request, use deny_unmount keyword followed by a canonicalized directory.<br>
Usually, specify /dev/ directory (that contains /dev/tty? used by /sbin/mingetty) and /dev/pts/ directory (that are used to create pty device files for remote login).</p>
<p>If /dev/ becomes read-only or /dev/pts/ is unmounted, you can't login to the system. Therefore /dev/ and /dev/pts/ must not be unmounted for systems where / is read-only.</p>

<p>(Example)<br>
deny_unmount /dev/<br>
deny_unmount /dev/pts/<br>
deny_unmount /proc/</p>

<h3><a name="system_policy_allow_chroot">allow_chroot</a></h3>
<p>To grant chroot permission, use allow_chroot keyword followed by a canonicalized directory.<br>
Usually, grant /var/empty/sshd/ that sshd uses. In addition, if you have applications that runs in the chroot'ed environment or applications that uses chroot (for example, /usr/share/empty/ is used by vsftpd), grant such directories too.</p>

<p>(Example)<br>
allow_chroot /var/empty/sshd/<br>
allow_chroot /usr/share/empty/<br>
allow_chroot /var/www/html/<br>
allow_chroot /</p>

<h3><a name="system_policy_allow_pivot_root">allow_pivot_root</a></h3>
<p>To grant pivot_root permission, use allow_pivot_root keyword followed by the new root's canonicalized directory and the previous root's canonicalized directory.<br>
Usually, you don't need this keyword.</p>

<h3><a name="system_policy_deny_autobind">deny_autobind</a></h3>
<p>To prevent specific local port from being selected automatically, use deny_autobind keyword followed by local port number.<br>
This keyword is intended to prevent specific local port from being bound for temporary use. For example, some proxy server uses local port 8080, so port 8080 should not be bound by other programs for temporary use.</p>

<p>(Example)<br>
deny_autobind 1-1023<br>
deny_autobind 8080</p>

<h2><a name="domain_policy">/proc/ccs/domain_policy</a></h2>

<p>This file contains definition of all domains and permissions that are granted to each domain.</p>

<p>Lines from the next line to a domain definition ( any lines starting with "&lt;kernel&gt;") to the previous line to the next domain definitions are interpreted as access permissions for that domain.</p>

<p>You can specify additional conditions as needed. The syntax for specifing additional conditions are described in <a href="#conditional_acl">Using conditional ACL.</a> Also, how to switch process's state as needed and use the process's state for conditions is described in <a href="#stateful_acl">Using stateful ACL.</a></p>

<p>To read or modify current domain policy, operate like below.</p>
<p>(Example) Selecting specific domain and appending ACLs. The domain will be created if nonexistent.<br>
printf "&lt;kernel&gt; /sbin/init\nallow_read /etc/passwd\n" | loadpolicy -d</p>
<p>(Example) Selecting specific domain and appending ACLs. The domain won't be created if nonexistent.<br>
printf "select &lt;kernel&gt; /sbin/init\nallow_read /etc/passwd\n" | loadpolicy -d</p>
<p>(Example) Selecting specific domain and removing ACLs.<br>
printf "select &lt;kernel&gt; /sbin/init\ndelete allow_read /etc/passwd\ndelete allow_read /etc/shadow\n" | loadpolicy -d</p>
<p>(Example) Deleting specific domain.<br>
printf "delete &lt;kernel&gt; /sbin/init\n" | loadpolicy -d</p>
<p>(Example) Reading current domain policy.<br>
cat /proc/ccs/domain_policy</p>

<p>See also: <a href="#policy_file_modifiers">Policy File's Modification</a></p>

<h3><a name="domain_policy_allow_execute">allow_execute</a></h3>
<p>wpXsBpXChJ[hgpFBChJ[hwAvOO[vANZX^B</p>
<p>(Example) allow_execute /bin/ls</p>
<p>See also: <a href="#domain_transition">hCJ</a> <a href="#exception_policy_path_group">path_group</a> <a href="#exception_policy_aggregator">aggregator</a></p>

<h3><a name="domain_policy_allow_write">allow_write</a></h3>
<p>wpX[hI[vB</p>
<p>(Example) allow_write /dev/null</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_read">allow_read</a></h3>
<p>wpX[hI[vB</p>
<p>(Example) allow_read /proc/meminfo</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_read/write">allow_read/write</a></h3>
<p>wpX[hI[vB</p>
<p>(Example) allow_read/write /dev/null</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_create">allow_create</a></h3>
<p>wpXt@CVKB</p>
<p>(Example) allow_create /var/lock/subsys/crond</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_unlink">allow_unlink</a></h3>
<p>wpXB</p>
<p>(Example) allow_unlink /var/lock/subsys/crond</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_mkdir">allow_mkdir</a></h3>
<p>pXwfBNgB</p>
<p>(Example) allow_mkdir /tmp/logwatch.\*/</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_rmdir">allow_rmdir</a></h3>
<p>fBNgB</p>
<p>(Example) allow_rmdir /tmp/logwatch.\*/</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_mkfifo">allow_mkfifo</a></h3>
<p>FIFO B</p>
<p>(Example) allow_mkfifo /dev/initctl</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_mksock">allow_mksock</a></h3>
<p>UNIX hC\PbgB</p>
<p>(Example) allow_mksock /dev/log</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_mkblock">allow_mkblock</a></h3>
<p>ubN^foCXt@CB</p>
<p>(Example) allow_mkblock /dev/\*</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_mkchar">allow_mkchar</a></h3>
<p>LN^^foCXt@CB</p>
<p>(Example) allow_mkchar /dev/\*</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_truncate">allow_truncate</a></h3>
<p>t@ClLB</p>
<p>(Example) allow_truncate /etc/mtab</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_symlink">allow_symlink</a></h3>
<p>V{bNNB</p>
<p>(Example) allow_symlink /dev/cdrom</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_link">allow_link</a></h3>
<p>n[hNB</p>
<p>(Example) allow_link /etc/mtab~\$ /etc/mtab~</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_rename">allow_rename</a></h3>
<p>t@CXB</p>
<p>(Example) allow_rename /etc/mtab.tmp /etc/mtab</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a></p>

<h3><a name="domain_policy_allow_rewrite">allow_rewrite</a></h3>
<p><a href="#exception_policy_deny_rewrite">deny_rewrite</a> t@Ce~pXwt@CeB</p>
<p>(Example) allow_rewrite /var/log/messages</p>
<p>See also:  <a href="#exception_policy_path_group">path_group</a> <a href="#exception_policy_deny_rewrite">deny_rewrite</a></p>

<h3><a name="domain_policy_allow_argv0">allow_argv0</a></h3>

<p>argv[0] gA allow_argv0 L[[hApXu argv[0]  / vwB</p>

<p>vOs execve()  filename  argv[]  envp[] nBvOi busybox j argv[0] eUB
vOV{bNNoRvOsA TOMOYO Linux hCJ filename wpXKesAU argv[0] i filename wpXejsBA /bin/ls  /bin/cat  busybox n[hNA /tmp/cat  /bin/ls V{bNN /tmp/cat sA /bin/ls hC cat UB</p>
<p>L[[hIA filename  argv[0] egB</p>

<h3><a name="domain_policy_allow_env">allow_env</a></h3>

<p>A allow_env L[[hAuvwB</p>

<p>vOs execve()  filename  argv[]  envp[] nBvO envp[] eUB</p>
<p>L[[hIAsvOnB</p>

<p>See also:  <a href="#exception_policy_allow_env">allow_env</a></p>

<h3><a name="domain_policy_allow_capability">allow_capability</a></h3>

<p>To grant capability permission, use allow_capability directive followed by a capability. The following capabilities are applicable.</p>

<table border="1">
<tr><td>allow_capability inet_tcp_create</td><td>Permit creation of TCP sockets.</td></tr>
<tr><td>allow_capability inet_tcp_listen</td><td>Permit TCP socket's listen operation.</td></tr>
<tr><td>allow_capability inet_tcp_connect</td><td>Permit TCP socket's connect operation.</td></tr>
<tr><td>allow_capability use_inet_udp</td><td>Permit use of UDP sockets.</td></tr>
<tr><td>allow_capability use_inet_ip</td><td>Permit use of RAW sockets.</td></tr>
<tr><td>allow_capability use_route</td><td>Permit use of ROUTE sockets.</td></tr>
<tr><td>allow_capability use_packet</td><td>Permit use of PACKET sockets.</td></tr>
<tr><td>allow_capability use_kernel_module</td><td>Permit use of create_module(2) init_module(2) delete_module(2) syscall.</td></tr>
<tr><td>allow_capability create_fifo</td><td>Permit creation of FIFO using mknod(2) syscall.</td></tr>
<tr><td>allow_capability create_block_dev</td><td>Permit creation of block device using mknod(2) syscall.</td></tr>
<tr><td>allow_capability create_char_dev</td><td>Permit creation of character device using mknod(2) syscall.</td></tr>
<tr><td>allow_capability create_unix_socket</td><td>Permit creation of UNIX domain sockets using mknod(2) syscall.</td></tr>
<tr><td>allow_capability SYS_MOUNT</td><td>Permit use of mount(2) syscall.</td></tr>
<tr><td>allow_capability SYS_UMOUNT</td><td>Permit use of umount(2) syscall.</td></tr>
<tr><td>allow_capability SYS_REBOOT</td><td>Permit use of reboot(2) syscall.</td></tr>
<tr><td>allow_capability SYS_CHROOT</td><td>Permit use of chroot(2) syscall.</td></tr>
<tr><td>allow_capability SYS_KILL</td><td>Permit use of kill(2) tkill(2) tgkill(2) syscall with non 0 signal.</td></tr>
<tr><td>allow_capability SYS_VHANGUP</td><td>Permit use of vhangup(2) syscall.</td></tr>
<tr><td>allow_capability SYS_TIME</td><td>Permit use of stime(2) settimeofday(2) adjtimex(2) syscall.</td></tr>
<tr><td>allow_capability SYS_NICE</td><td>Permit use of nice(2) setpriority(2) syscall.</td></tr>
<tr><td>allow_capability SYS_SETHOSTNAME</td><td>Permit use of sethostname(2) setdomainname(2) syscall.</td></tr>
<tr><td>allow_capability SYS_LINK</td><td>Permit use of link(2) syscall.</td></tr>
<tr><td>allow_capability SYS_SYMLINK</td><td>Permit use of symlink(2) syscall.</td></tr>
<tr><td>allow_capability SYS_RENAME</td><td>Permit use of rename(2) syscall.</td></tr>
<tr><td>allow_capability SYS_UNLINK</td><td>Permit use of unlink(2) syscall.</td></tr>
<tr><td>allow_capability SYS_CHMOD</td><td>Permit use of chmod(2) fchmod(2) syscall.</td></tr>
<tr><td>allow_capability SYS_CHOWN</td><td>Permit use of chown(2) fchown(2) lchown(2) syscall.</td></tr>
<tr><td>allow_capability SYS_IOCTL</td><td>Permit use of ioctl(2) compat_sys_ioctl(2) syscall.</td></tr>
<tr><td>allow_capability SYS_KEXEC_LOAD</td><td>Permit use of kexec_load(2) syscall.</td></tr>
<tr><td>allow_capability SYS_PIVOT_ROOT</td><td>Permit use of pivot_root(2) syscall.</td></tr>
<tr><td>allow_capability SYS_PTRACE</td><td>Permit use of ptrace(2) syscall.</td></tr>
</table>

<p>The purpose of allow_capability directive is to restrict system calls that a program can call. You can restrict more strictly with other directives and policy files for some system calls.</p>

<ul>
<li>You can restrict creation of block device files using <a href="#domain_policy_allow_mkblock">allow_mkblock</a> keyword.
<li>You can restrict creation of character device files using <a href="#domain_policy_allow_mkchar">allow_mkchar</a> keyword.
<li>You can restrict creation of FIFOs using <a href="#domain_policy_allow_mkfifo">allow_mkfifo</a> keyword.
<li>You can restrict creation of UNIX domain sockets using <a href="#domain_policy_allow_mksock">allow_mksock</a> keyword.
<li>You can restrict creation of symbolic links using <a href="#domain_policy_allow_symlink">allow_symlink</a> keyword.
<li>You can restrict deletion of non-directories using <a href="#domain_policy_allow_unlink">allow_unlink</a> keyword.
<li>You can restrict combination of pathnames that can be hard linked using <a href="#domain_policy_allow_link">allow_link</a> keyword.
<li>You can restrict combination of pathnames that can be renamed using <a href="#domain_policy_allow_rename">allow_rename</a> keyword.
<li>You can restrict IP addresses and ports using <a href="#domain_policy_allow_network">allow_network</a> keyword.
<li>You can restrict signal numbers and target domain using <a href="#domain_policy_allow_signal">allow_signal</a> keyword.
<li>You can restrict devices and directories for mount operations using <a href="#system_policy_allow_mount">allow_mount</a> keyword.
<li>You can restrict directories that you don't allow unmount using <a href="#system_policy_deny_unmount">deny_unmount</a> keyword.
<li>You can restrict directories that can chroot to using <a href="#system_policy_allow_chroot">allow_chroot</a> keyword.
<li>You can restrict directories that can exchange using <a href="#system_policy_allow_pivot_root">allow_pivot_root</a> keyword.
</ul>

<h3><a name="domain_policy_allow_network">allow_network</a></h3>

<p>To grant permission for socket operations, use allow_network directive followed by protocol(TCP or UDP or RAW) and IP address and port number (for TCP or UDP) / protocol number (for RAW). This permission is applicable to IPv4 and IPv6.</p>
<table border="1">
<tr><td>Keyword</td><td>Permitted operation</td><td>Example</td></tr>
<tr><td>allow_network TCP bind</td><td>	Bind to local TCP address/port.</td><td>allow_network TCP bind 0.0.0.0 80</td></tr>
<tr><td>allow_network TCP listen</td><td>Listen to local TCP address/port.</td><td>allow_network TCP listen 0.0.0.0 80</td></tr>
<tr><td>allow_network TCP accept</td><td>Accept from and communicate with remote TCP address/port.</td><td>allow_network TCP accept 10.0.0.0-10.255.255.255 1024-65535</td></tr>
<tr><td>allow_network TCP connect</td><td>Connect to and communicate with remote TCP address/port.</td><td>allow_network TCP connect 127.0.0.1 1024-65535</td></tr>
<tr><td>allow_network UDP bind</td><td>Bind to local UDP address/port.</td><td>allow_network UDP bind 0.0.0.0 53</td></tr>

<tr><td>allow_network UDP connect</td><td>Communicate with remote UDP address/port.</td><td>allow_network UDP connect 127.0.0.1 53</td></tr>
<tr><td>allow_network RAW bind</td><td>Bind to local IP address/protocol.</td><td>allow_network RAW bind 127.0.0.1 255</td></tr>
<tr><td>allow_network RAW connect</td><td>Communicate with remote IP address/protocol.</td><td>allow_network RAW connect 10.0.0.1 1</td></tr>
</table>
<p>Use of "::" for IPv6 address representation is not supported. You need to use "0:0:0:0:0:0:0:1" for "::1".</p>

<p>To reduce the labor of repeating same IP addresses, you can define groups like pathnames.</p>

<p>See also:  <a href="#exception_policy_address_group">address_group</a></p>

<h3><a name="domain_policy_allow_signal">allow_signal</a></h3>

<p>VOiANZXwA allow_signal L[[hAVOihCwB<br>
@O 2 BVOi 0 BAhCVOiB<br>
@At@CwVOihCnVOiMB<br>
@hC &lt;kernel&gt; wAShCwVOiMB</p>

<h3><a name="domain_policy_use_profile">use_profile</a></h3>

<p>AhCvt@CBvt@C 0 ` 255 lB</p>

<h3><a name="domain_policy_ignore_global_allow_read">ignore_global_allow_read</a></h3>

<p>AhCO|Vw <a href="#exception_policy_allow_read">allow_read</a> BhC[hI[vt@CgB</p>

<p>See also:  <a href="#exception_policy_allow_read">allow_read</a></p>

<h3><a name="domain_policy_ignore_global_allow_env">ignore_global_allow_env</a></h3>

<p>AhCO|Vw <a href="#exception_policy_allow_env">allow_env</a> BhCngB</p>

<p>See also:  <a href="#exception_policy_allow_env">allow_env</a></p>

<h3><a name="domain_policy_execute_handler">execute_handler</a></h3>

<p>AhCL[[hwvOsBhCsvOsvSvOoRNgB</p>

<p>L[[hwA <a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a> lL[[hwvOsBAL[[hKvOpXwAL[[hwhCvOsB</p>

<p>See also:  <a href="#domain_policy_denied_execute_handler">denied_execute_handler</a> <a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a> <a href="#domain_policy_allow_execute">allow_execute</a> <a href="#domain_policy_allow_argv0">allow_argv0</a></p>

<h3><a name="domain_policy_denied_execute_handler">denied_execute_handler</a></h3>

<p>A <a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a>  enforcing vOsvAL[[hwvOsBL[[hwA <a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a>  enforcing vOsvvOsB</p>

<p>AhC <a href="#domain_policy_execute_handler">execute_handler</a> L[[hwAL[[hB</p>

<h3><a name="domain_policy_quota_exceeded">quota_exceeded</a></h3>

<p>AwK[hANZX <a href="#profile_MAX_ACCEPT_ENTRY">MAX_ACCEPT_ENTRY</a> wlBAhCANZXwKB`[jOsANZXB</p>

<p>See also:  <a href="#profile_MAX_ACCEPT_ENTRY">MAX_ACCEPT_ENTRY</a></p>

<h2><a name="exception_policy">/proc/ccs/exception_policy</a></h2>

<p>To read or modify current exception policy, operate like below.</p>
<p>(Example)<br>
echo 'file_pattern /proc/\$/status' | loadpolicy -e<br>
echo 'delete file_pattern /proc/\$/status' | loadpolicy -e<br>
cat /proc/ccs/exception_policy</p>

<p>See also:  <a href="#policy_file_modifiers">Policy File's Modification</a></p>

<h3><a name="exception_policy_file_pattern">file_pattern</a></h3>

<p>To declare pathname pattern, use file_pattern directive followed by pathname pattern. The pathname pattern must be a canonicalized Pathname. This directive is not applicable to neither granting execute permissions nor domain definitions.<br>
For example, canonicalized pathname that contains a process ID (i.e. /proc/PID/ files) needs to be grouped in order to make access control work well.</p>

<p>When file access requests arise in learning mode ( profile's <a href="#profile_MAC_FOR_FILE">MAC_FOR_FILE</a> is set to "learning" ) , the requested pathname is automatically patterned according to patterens specified using this keyword. This keyword does not affect modes other than learning mode. This keyword is used for only reducing the burden of policy tuning which is needed after the lerning mode by making already known pathname patterns as templetes.</p>

<h3><a name="exception_policy_path_group">path_group</a></h3>

<p>pXO[v`A path_group L[[hAO[vpXp^[wB<br>
@Az[fBNgSt@CA</p>

<table border="1">
<tr><td>
path_group HOME-DIR-FILE /home/\*/\*<br>
path_group HOME-DIR-FILE /home/\*/\*/\*<br>
path_group HOME-DIR-FILE /home/\*/\*/\*/\*<br>
path_group HOME-DIR-FILE /home/\*/\*/\*/\*/\*<br>
path_group HOME-DIR-FILE /home/\*/\*/\*/\*/\*/\*<br>
path_group HOME-DIR-FILE /home/\*/\*/\*/\*/\*/\*/\*
</td></tr>
</table>

<p>`AhC|Vt@CANZXw</p>

<table border="1">
<tr><td>
allow_read @HOME-DIR-FILE
</td></tr>
</table>

<p>wB</p>

<h3><a name="exception_policy_address_group">address_group</a></h3>

<p>AhXO[v`A address_group L[[hAO[v IP AhXp^[wB<br>
@A[JAhXA</p>

<table border="1">
<tr><td>
address_group local-address 10.0.0.0-10.255.255.255<br>
address_group local-address 172.16.0.0-172.31.255.255<br>
address_group local-address 192.168.0.0-192.168.255.255
</td></tr>
</table>

<p>`AhC|Vlbg[NANZXw</p>

<table border="1">
<tr><td>
allow_network TCP accept @local-address 1024-65535
</td></tr>
</table>

<p>wB</p>

<h3><a name="exception_policy_allow_read">allow_read</a></h3>

<p>t@CwA allow_read L[[hAKt@CwBL[[hIA GLIBC vOsQt@CG[bZ[W\Qt@CAvOQ\t@CwAehCLqBAehC ignore_global_allow_read wAw allow_read B</p>

<p>See also:  <a href="#domain_policy_allow_read">allow_read</a> <a href="#domain_policy_ignore_global_allow_read">ignore_global_allow_read</a></p>

<h3><a name="exception_policy_allow_env">allow_env</a></h3>

<p>wA allow_env L[[hAwBL[[hIA PATH  HOME AvOn\wAehCLqB LD_PRELOAD wBAehC ignore_global_allow_env wAw allow_env B</p>

<p>See also:  <a href="#domain_policy_ignore_global_allow_env">ignore_global_allow_env</a> <a href="#domain_policy_allow_env">allow_env</a></p>

<h3><a name="exception_policy_deny_rewrite">deny_rewrite</a></h3>

<p>deny_rewrite L[[hgpAL^~t@CiOt@CjpXo^Bp^[gpB deny_rewrite L[[hgpo^t@CAhCp|VI <a href="#domain_policy_allow_rewrite">allow_rewrite</a> L[[hp^AL[hI[vt@Cl~B</p>

<p>See also:  <a href="#domain_policy_allow_rewrite">allow_rewrite</a></p>

<h3><a name="exception_policy_alias">alias</a></h3>

<p>V{bNNOV{bNNOsvOwA alias L[[hV{bNNpXV{bNNOpXwBL[[hIAsOUvOAn[hNV{bNNQAV{bNNOhCJB</p>
<p> /sbin/pidof  /sbin/killall5 V{bNNA /sbin/pidof s /sbin/killall5 shC`BA alias /sbin/killall5 /sbin/pidof wA /sbin/pidof s /sbin/pidof shC`B</p>

<p>See also:  <a href="#domain_policy_allow_execute">allow_execute</a></p>

<h3><a name="exception_policy_aggregator">aggregator</a></h3>

<p>vOPvOA aggregator L[[hWOvOWvOwBL[[hIAlvOWB</p>
<p>A /usr/bin/tac  /bin/cat A aggregator /usr/bin/tac /bin/cat w /usr/bin/tac  /bin/cat hCsB</p>
<p>A Fedora Core 3  /usr/sbin/logrotate  /tmp/logrotate.\?\?\?\?\?\? p^[vOsA TOMOYO Linux SRvOs^hC`p^[gpFBA aggregator /tmp/logrotate.\?\?\?\?\?\? /tmp/logrotate.tmp w /tmp/logrotate.\?\?\?\?\?\?  /tmp/logrotate.tmp hCsB</p>

<p>See also:  <a href="#domain_policy_allow_execute">allow_execute</a></p>

<h3><a name="exception_policy_initialize_domain">initialize_domain</a></h3>

<p>vOshCJA initialize_domain L[[hgpB</p>

<ul>
<li>initialize_domain vO from hC
<li>initialize_domain vO from hCvO
<li>initialize_domain vO
</ul>

<p> from ~wChCsKpBhC &lt;kernel&gt; nAhCvOvShCKpB</p>

<p>L[[hIA^vOKvJ[lNvOAhCJAhCJWB</p>

<p>See also: <a href="#domain_transition">hCJ</a> <a href="#exception_policy_no_initialize_domain">no_initialize_domain</a></p>

<h3><a name="exception_policy_no_initialize_domain">no_initialize_domain</a></h3>

<p>initialize_domain A no_initialize_domain L[[hwB</p>
<ul>
<li>no_initialize_domain vO from hC
<li>no_initialize_domain vO from hCvO
<li>no_initialize_domain vO
</ul>

<p>L[[hhCJgpB</p>

<p>See also: <a href="#domain_transition">hCJ</a> <a href="#exception_policy_initialize_domain">initialize_domain</a></p>

<h3><a name="exception_policy_keep_domain">keep_domain</a></h3>

<p>hCvOshCJsA keep_domain L[[hgpB</p>

<ul>
<li>keep_domain vO from hC
<li>keep_domain vO from hCvO
<li>keep_domain hC
<li>keep_domain hCvO
</ul>

<p> from OwCvOsKpBhC &lt;kernel&gt; nAhCvOvShCKpB</p>

<p>L[[hIAsvhCJ}hC}B</p>

<p>See also: <a href="#domain_transition">hCJ</a> <a href="#exception_policy_no_keep_domain">no_keep_domain</a></p>

<h3><a name="exception_policy_no_keep_domain">no_keep_domain</a></h3>

<p>keep_domain A no_keep_domain L[[hwB</p>

<ul>
<li>no_keep_domain vO from hC
<li>no_keep_domain vO from hCvO
<li>no_keep_domain hC
<li>no_keep_domain hCvO
</ul>

<p>L[[hhCJsgpB</p>

<p>See also: <a href="#domain_transition">hCJ</a> <a href="#exception_policy_keep_domain">keep_domain</a></p>

<h2><a name="query">/proc/ccs/query</a></h2>

<p>[h|VAANZXvwsgpB ALLOW_ENFORCE_GRACE=enabled vt@ChC[h|VA ccs-queryd pbIwB</p>

<h2><a name="manager">/proc/ccs/manager</a></h2>

<p>|VsvOhCB</p>

<h3><a name="manager_manage_by_non_root">manage_by_non_root</a></h3>

<p>ftHg[Uhc[Uhc 0 vZX|VXA root [UXFgpB</p>

<h2><a name=".domain_status">/proc/ccs/.domain_status</a></h2>

<p>setprofile R}hsPs domain_policy evt@ChCoBcalrr[@\B</p>

<h2><a name="meminfo">/proc/ccs/meminfo</a></h2>

<p>TOMOYO Linux |VgpJ[lB</p>
<p>(Example)<br>
cat /proc/ccs/meminfo<br></p>

<h2><a name="grant_log">/proc/ccs/grant_log</a></h2>

<p>hC|VANZXOBOAO@ select(2) gBL MAX_GRANT_LOG BL^AoKvB</p>
<p>(Example)<br>
cat /proc/ccs/grant_log</p>

<h2><a name="reject_log">/proc/ccs/reject_log</a></h2>

<p>hC|VANZXOBOAO@ select(2) gBL MAX_REJECT_LOG BL^AoKvB</p>
<p>(Example)<br>
cat /proc/ccs/reject_log</p>

<h2><a name="self_domain">/proc/ccs/self_domain</a></h2>

<p>ovZXhCOB</p>
<p>(Example)<br>
cat /proc/ccs/self_domain</p>

<h2><a name=".process_status">/proc/ccs/.process_status</a></h2>

<p>ccstree R}hiuvZXvuvZXhCvuhCvt@Cv pstree \jC^tF[XBOI|V}l[Wo^vOsB</p>

<h2><a name=".updates_counter">/proc/ccs/.updates_counter</a></h2>

<p>|VXoJE^BQ 0 ZbgB|VXVvOC^tF[XB</p>

<h2><a name="version">/proc/ccs/version</a></h2>

<p>TOMOYO Linux o[WC^tF[XB</p>
<p>(Example)<br>
cat /proc/ccs/version</p>

<h1>6. <a name="Advanced_Features">Advanced Features</a></h1>

<h2>6.1 <a name="non_root_policy_update">Allowing policy modification by non root user.</a></h2>

<p>ftHg[Uhc[Uhc 0 vZX|VXA root [UXF</p>

<table border="1">
<tr><td>
# echo manage_by_non_root | /usr/lib/ccs/loadpolicy -m
</td></tr>
</table>

<p> manage_by_non_root L[[hA[Uhc[Uhc`FbNBA[Uhc[Uhc`FbNLA</p>

<table border="1">
<tr><td>
# echo delete manage_by_non_root | /usr/lib/ccs/loadpolicy -m
</td></tr>
</table>

<p> delete manage_by_non_root L[[hB /proc/ccs/ GgL root A root [UANZXFKv chown/chmod sB<br>
NIsA /sbin/ccs-init  /etc/ccs/ccs-post-init vO /etc/ccs/ccs-post-init sBA demo [U /proc/ccs/ C^tF[XA</p>

<table border="1">
<tr><td>
#! /bin/sh<br>
echo manage_by_non_root &gt; /proc/ccs/manager<br>
chown -R demo /proc/ccs/
</td></tr>
</table>

<p>e /etc/ccs/ccs-post-init A</p>

<table border="1">
<tr><td>
# chmod 755 /etc/ccs/ccs-post-init<br>
# chown -R demo /etc/ccs/<br>
# chmod 755 /usr/lib/ccs/
</td></tr>
</table>

<p>s demo [U|VfBNgANZX|VWvOsB</p>

<h2>6.2 <a name="conditional_acl">Using conditional ACL.</a></h2>

<p>ANZX[UhctBXANZX " if " `wB</p>

<table border="1">
<tr><td>w</td><td>Meaning</td></tr>
<tr><td>allow_read /etc/passwd</td><td>/etc/passwd Q</td></tr>
<tr><td>allow_read /etc/passwd if task.uid=0</td><td>vZX[Uhc 0 A /etc/passwd Q</td></tr>
<tr><td>allow_read /etc/passwd if task.uid!=0</td><td>vZX[Uhc 0 A /etc/passwd Q</td></tr>
<tr><td>allow_network TCP connect 10.0.0.1</td><td>TCP vgR 10.0.0.1 </td></tr>
<tr><td>allow_network TCP connect 10.0.0.1 if task.uid=100</td><td>vZX[Uhc 100 A TCP vgR 10.0.0.1 </td></tr>
<tr><td>allow_capability SYS_KILL</td><td>kill(2) gp</td></tr>
<tr><td>allow_capability SYS_KILL if task.ppid=1 task.uid=0 task.euid=0</td><td>evZX /sbin/init AAvZX[Uhc[Uhc 0 A kill(2) gp</td></tr>
</table>

<p>wB</p>

<table border="1">
<tr><td>Variable</td><td>Meaning</td></tr>
<tr><td>task.uid</td><td>UID of current process</td></tr>
<tr><td>task.euid</td><td>Effective UID of current process</td></tr>
<tr><td>task.suid</td><td>Saved UID of current process</td></tr>
<tr><td>task.fsuid</td><td>File System UID of current process</td></tr>
<tr><td>task.gid</td><td>GID of current process</td></tr>
<tr><td>task.egid</td><td>Effective GID of current process</td></tr>
<tr><td>task.sgid</td><td>Saved GID of current process</td></tr>
<tr><td>task.fsgid</td><td>File System GID of current process</td></tr>
<tr><td>task.pid</td><td>PID of current process</td></tr>
<tr><td>task.ppid</td><td>PID of parent process</td></tr>
<tr><td>path1.uid</td><td>UID of object.</td></tr>
<tr><td>path1.gid</td><td>GID of object.</td></tr>
<tr><td>path1.ino</td><td>i-node number of object.</td></tr>
<tr><td>path1.parent.uid</td><td>UID of object's parent directory.</td></tr>
<tr><td>path1.parent.gid</td><td>GID of object's parent directory.</td></tr>
<tr><td>path1.parent.ino</td><td>i-node number of object's parent directory.</td></tr>
<tr><td>path2.parent.uid</td><td>UID of object's parent directory.</td></tr>
<tr><td>path2.parent.gid</td><td>GID of object's parent directory.</td></tr>
<tr><td>path2.parent.ino</td><td>i-node number of object's parent directory.</td></tr>
<tr><td>exec.argc</td><td>Number of argv[] passed for execute request.</td></tr>
<tr><td>exec.envc</td><td>Number of envp[] passed for execute request.</td></tr>
<tr><td>exec.argv[index]="value"</td><td>argv[index] (where 0 &lt;= index &lt; exec.argc) matches "value". </td></tr>
<tr><td>exec.argv[index]!="value"</td><td>argv[index] (where 0 &lt;= index &lt; exec.argc) does not match "value".</td></tr>
<tr><td>exec.envp["name"]="value"</td><td>Environment variable "name" is defined and matches "value".</td></tr>
<tr><td>exec.envp["name"]!="value"</td><td>Environment variable "name" is not defined or does not match "value".</td></tr>
<tr><td>exec.envp["name"]!=NULL</td><td>Environment variable "name" is defined.</td></tr>
<tr><td>exec.envp["name"]=NULL</td><td>Environment variable "name" is not defined.</td></tr>
</table>

<p>"path1" corresponds to the first pathname of operations that requires pathnames, and "path2" corresponds to the second pathname of operations that requires pathnames. For example, the case of "<a href="#domain_policy_allow_rename">allow_rename</a> file1 file2", path1 corresponds to file1 and path2 corresponds to file2.</p>

<p>"path1" except "path1.parent" is not available for pathnames that don't exist. Thus, you can't use when creating pathnames (such as <a href="#domain_policy_allow_create">allow_create</a> keyword).</p>

<p>"path1.parent" is always available.</p>

<p>"path2.parent" is available only for operations that require 2 pathnames (i.e. <a href="#domain_policy_allow_link">allow_link</a> and <a href="#domain_policy_allow_rename">allow_rename</a> keywords).</p>

<p>"path2" except "path2.parent" is not supported. (If "path2" already exist for "rename" operation, "unlink" or "rmdir" operation is performed implicitly.)</p>

<p>"path1" is not supported when accessing via "sysctl" (i.e. accessing files under /proc/sys/ directories using "sysctl" instead for "open").</p>

<p>"exec" is available only for operation taht executes a program (i.e. <a href="#domain_policy_allow_execute">allow_execute</a> keyword).</p>

<h2>6.3 <a name="stateful_acl">Using stateful ACL.</a></h2>

<p>Since TOMOYO Linux doesn't require modification of userland applications, it is impossible to change the range of accessible resources without domain transition.
But there are cases you wish to change the range of accessible resources without domain transition. For example, you might wish to change the range of accessible resources depending on the client's IP address. To support such cases, you can assign state variables to each processes and you can use the state variables in<a href="#conditional_acl">Using conditional ACL.</a></p>

<table border="1">
<tr><td>Variable</td><td>Meaning</td></tr>
<tr><td>task.state[0]</td><td>Current process's state variable 0</td></tr>
<tr><td>task.state[1]</td><td>Current process's state variable 1</td></tr>
<tr><td>task.state[2]</td><td>Current process's state variable 2</td></tr>
</table>

<p>Each task.state can take an integer value between 0 and 255. To change state variable, append " ; set " part after an ACL.</p>

<table border="1">
<tr><td>Example</td><td>Meaning</td></tr>
<tr><td>allow_network TCP accept @TRUSTED_HOSTS 1024-65535 ; set task.state[0]=1</td><td>If a TCP connection is accepted from an IP address included in an address group @TRUSTED_HOSTS, set 1 to state[0].</td></tr>
<tr><td>allow_network TCP accept @UNTRUSTED_HOSTS 1024-65535 ; set task.state[0]=0</td><td>If a TCP connection is accepted from an IP address included in an address group @UNTRUSTED_HOSTS, set 0 to state[0].</td></tr>
<tr><td>allow_execute /bin/bash if task.state[0]=1</td><td>Allow execution of /bin/bash if state[0] is 1.</td></tr>
<tr><td>allow_execute /sbin/nologin if task.state[0]=0</td><td>Allow execution of /sbin/nologin if state[0] is 0.</td></tr>
<tr><td>allow_execute /etc/passwd if task.state[2]=0 ; set task.state[2]=1</td><td>If state[2] is 0, allow opening /etc/passwd for reading and then, set 1 to state[2].</td></tr>
</table>

<p>When using the state variables, please be careful with the following points.</p>

<ul>
<li>The domain a process belongs to is automatically updated upon execution of a program, but the state variables of the process are not updated unless they are explicitly specified using " ; set " part. Thus, be careful with forgetting to reset when needed.</li>
<li>The state variables are updated when the access request is permitted by the policy. Thus, situations that the access request was not processed although the state variables were updated can happen because of errors after checking the policy (e.g. out of memory).</li>
<li>If an IP address is included in both @TRUSTED_HOSTS and @UNTRUSTED_HOSTS, the permission which matched first is used. So, be careful with using order dependent policy.</li>
</ul>

<h2>6.4 <a name="sleep_penalty">Sleep penalty for policy violation.</a></h2>

<p>[h|VA|VvZXX[vB</p>

<table border="1">
<tr><td>/proc/ccs/profile w</td><td>Meaning</td></tr>
<tr><td>3-SLEEP_PERIOD=1</td><td>vt@C 3 vZX[h|VA 0.1 bX[vB</td></tr>
<tr><td>4-SLEEP_PERIOD=10</td><td>vt@C 4 vZX[h|VA 1 bX[vB</td></tr>
</table>

<p>@\A[v|VAbotgp 100% SuB 0.1 bX[v[B</p>

<p>@\AzXg TCP v UDP pPbgU|VT[rXX[vAzXg TCP v UDP pPbgxUAlbg[NMn@\B</p>

<h2>6.5 <a name="execute_handler">Judging execute request outside the kernel.</a></h2>

<p>TOMOYO Linux A|V]vOsBvOsp[^`FbNA<a href="#conditional_acl">Using conditional ACL.</a> exec.argv  exec.envp g`FbNsBA<a href="#conditional_acl">Using conditional ACL.</a>APp^[}b`T|[gAAvOs\wKvB</p>

<p>A TOMOYO Linux 1.6.0  <a href="#domain_policy_execute_handler">execute_handler</a> dgBdgAvOsJ[lfA <a href="#domain_policy_execute_handler">execute_handler</a> wvOfAvOsfvOsB</p>

<p>Linux AvOsAvOsvvZXAvOsvOsvvZXBAvvOssAvOsvvZXAvvOsmB<br>
AvO`vZXvOasvlB<br>
vO`vZXvOasvAJ[luvO`vZXvOasKv|VfAKfuvO`vZXvOavAKfuvO`vZXvOasFmvB</p>

<p><a href="#domain_policy_execute_handler">execute_handler</a> wA execute_handler wvObB<br>
vO`vZXvOasvAvObuvO`vZXvOasKvfuvO`vZXvObvBvObvZXuvO`vZXvOasKvfAKfuvObvZXvOavAKfuvObvZXvOaIvB</p>

<p>AvOasvvO`vZXAvOassmiAvOasvvO`vZXAvOasmpB<br>
A <a href="#domain_policy_execute_handler">execute_handler</a> wAuLCuvu KILL VOiMvus OOM killer IvAlXvusnOIvNBAuvOssvuvvOnvAsmvfB<br>
lAuvOssmvOnvA <a href="#domain_policy_execute_handler">execute_handler</a> wvObAvOassvOasvvO`vZXmAeFvB</p>

<p>TOMOYO Linux AvOvOsKvOcAKvvOsFAv[`pBAA|VvOsvNASvOsv\lBvOsvA <a href="#domain_policy_denied_execute_handler">denied_execute_handler</a> @\gvvZXIsNBAJ[lvOsfs\B</p>

<p>AhC <a href="#domain_policy_execute_handler">execute_handler</a> L[[hwAhCSvOsfJ[lOvOB</p>
<p>J[lp\CuAs\A
J[lOLxCugESz`FbN\BA <a href="#domain_policy_execute_handler">execute_handler</a> wvOvOsp[^`FbNAKvOsB</p>

<p>pAvOsfAvOsvvZXm@_BARJX^}CYA ssh pun}Vf\B</p>

<p>@\gAwB</p>

<table border="1">
<tr><td>/proc/ccs/domain_policy </td><td>Meaning</td></tr>
<tr><td>execute_handler /usr/sbin/check-and-exec</td><td>hCvZXvOsvAvvOs /usr/sbin/check-and-exec sB /usr/sbin/check-and-exec p[^`FbNAfvvOsB</td></tr>
</table>

<p>execute_handler wvOAp[^B<a href="#access_logs">Access Logs</a>A allow_execute OrB</p>

<ul>
<li>argv[0] A execute_handler wvOpXB</li>
<li>argv[1] AvOsvvZXhCB</li>
<li>argv[2] AvOsvvZXpXB</li>
<li>argv[3] AvOsvvZXB</li>
<li>argv[4] AsvvOpXB</li>
<li>argv[5] AvOsvB</li>
<li>argv[6] AvOsvB</li>
<li>argv[7]  argv[6 + argc] AovZXn argv[] eB</li>
<li>argv[7 + argc]  argv [6 + argc + envc] AovZXn envp[] eB</li>
<li> envp[] SNAB</li>
<li>WoovZXpB</li>
</ul>

<p>@\gpA_B</p>

<ul>
<li>execute_handler wvOsi <a href="#domain_policy_allow_execute">allow_execute</a> j^KvA^B</li>
<li>vZX chroot A execute_handler wvOsBAvZX chroot A chroot OvOsA execute_handler wvOAvZXO[gfBNgAvZX[gfBNgB</li>
<li>execute_handler wvOhCAsBA &lt;kernel&gt;  execute_handler wvOphCAvO <a href="#exception_policy_initialize_domain">initialize_domain</a> L[[hwB</li>
<li>execute_handler wvOeASeNANBA PATH AOR}hoBA execute_handler wvOhC[hpvt@CB</li>
</ul>

<p>ccs-tools \[XpbP[WA audit-exec-param.c TvvOBRgB</p>
<p>@\A@\B@\pB</p>

<h2>6.6 <a name="denied_execute_handler">Invoking alternative program for execute requests that are not permitted by policy.</a></h2>

<p>TOMOYO Linux AvOvOsKvOcAKvvOsFAv[`pBAsvvOsUAOUsB</p>

<p>[h allow_execute \vOsvAftHgvOsBAvOvOsKvcOAvZXvOsvAvOsvvZXiAvZXjB</p>

<p>Uobt@I[o[t[ZLeBz[UvZXDAVFR}hsvBAvZXVFsKvi allow_execute /bin/bash ANZX^KvjAVFsv_vZXlB</p>

<p>AvOsvAvBAvZXvvOsvAvZXiAjlBAvOsAvZXVvOuAVvOnBAvZXobt@I[o[t[AvOsAvZXB</p>

<p>UvZXvOsAvOsBVFsAVF[UvsAvOsvvZXLUBAIvOi /bin/true jsAvZXUB</p>

<p>AU{KvvOsvoAAUg`X^lBA TOMOYO Linux AvOsvAvvOs@\B@\pVXeRB</p>

<p>AVFsv /bin/true svAvZXIB</p>

<p>AVFsvnj[|bgNCAgvOsvAUNGXgs@B</p>

<p>AOCZbVIB</p>

<p>AvR}hpbP[W Ubuntu  command-not-found pbP[WAu You are not permitted to execute this program. vx\B</p>

<p>AUhoAhXoAt@CAEH[XB</p>

<p>@\gAwB</p>

<table border="1">
<tr><td>/proc/ccs/profile </td><td>/proc/ccs/domain_policy </td><td>Meaning</td></tr>
<tr><td>3-MAC_FOR_FILE=enforcing</td><td>use_profile 3<br>denied_execute_handler /bin/true</td><td>vt@C 3 hCvZXAvOsvA /bin/true sB</td></tr>
</table>

<p>@\gp<a href="#execute_handler">Judging execute request outside the kernel.</a>B</p>

<hr>
<p><a href="index.html#manual">Return to index</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</body>
</html>
