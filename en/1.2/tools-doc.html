<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>Tools Documentation</title>
<link rel="stylesheet" href="tomoyo.css" media="all" type="text/css">
</head>
<body>
<p>Info: Version <a href="../1.3/">1.3</a> is available.</p>
<h1>Tools Documentation</h1>
<p style="text-align:right;">Last modified: $Date$ JST</p>
<hr>
<h2><a name="administration_tool">&lt;&lt;Tools for system administrators&gt;&gt;</a></h2>
<p>Most administrators need tools only in this chapter and the next chapter.</p>
<h3><a name="editpolicy">&lt;Policy Editor "editpolicy"&gt;</a></h3>
<p>Edits the current policy in /proc/ccs/policy/ directory.</p>
<p>You may give one of "s" "e" "d" to the commandline to choose the initial screen. If not given, screen for domain listing is shown.</p>

<p>Keys applicable to all screens</p>
<table border="1">
<tr><td>q/Q</td><td>Quit</td></tr>
<tr><td>r/R</td><td>Refresh</td></tr>
<tr><td>Up-arrow</td><td>Scroll 1 line up.</td></tr>
<tr><td>Down-arrow</td><td>Scroll 1 line down.</td></tr>
<tr><td>PageUp</td><td>Scroll 1 page up.</td></tr>
<tr><td>PageDown</td><td>Scroll 1 page down.</td></tr>
</table>

<p>Keys applicable to screen for system policy</p>
<table border="1">
<tr><td>a/A</td><td>Add an entry.</td></tr>
<tr><td>d/D</td><td>Delete the selected entry.</td></tr>
<tr><td>Tab</td><td>Switch to screen for exception policy.</td></tr>
</table>

<p>Keys applicable to screen for exception policy.</p>
<table border="1">
<tr><td>a/A</td><td>Add an entry.</td></tr>
<tr><td>d/D</td><td>Delete the selected entry.</td></tr>
<tr><td>Tab</td><td>Switch to screen for domain listing.</td></tr>
</table>

<p>Keys applicable to screen for domain listing.</p>
<table border="1">
<tr><td>a/A</td><td>Create a domain.</td></tr>
<tr><td>d/D</td><td>Delete the selected domain and its descendants.</td></tr>
<tr><td>Tab</td><td>Switch to screen for system policy.</td></tr>
<tr><td>Enter</td><td>Switch to screen for editing ACLs for the selected domain.</td></tr>
<tr><td>@</td><td>New search</td></tr>
<tr><td>Left-arrow</td><td>Search previous</td></tr>
<tr><td>Right-arrow</td><td>Search next</td></tr>
</table>

<p>Keys applicable to screen for editing ACLs for the selected domain</p>
<table border="1">
<tr><td>Enter</td><td>Return to screen for domain listing.</td></tr>
<tr><td>a/A</td><td>Add an access permission.</td></tr>
<tr><td>d/D</td><td>Delete existing permission.</td></tr>
</table>

<p>This program keeps pathnames on dynamically allocated memory on the first appearance of the pathname and never frees that memory until termination. This is to reduce memory for keeping filenames.</p>
<p>The same mechanism is used by the TOMOYO Linux kernel. The memory allocated by the kernel for keeping pathnames and access permissions is never freed. Therefore, you can't run in "accept mode" forever, otherwise the system falls into out of memory. But actual amount of extra memory consumed by TOMOYO Linux kernel, though it depends on the number of domains and number of access permissions for domains, is less than 1 MB in most systems.</p>
<p>The memory for keeping access logs is allocated dynamically, and is freed as soon as the userland program reads the log. Also, there is a limitation for the maximum number of logs that the kernel can keep, therefore the system won't become out of memory even if the userland program doesn't read the logs.</p>
<h3><a name="loadpolicy">&lt;Policy Loader "loadpolicy"&gt;</a></h3>
<p>Reloads the on-disk policy onto memory.</p>
<p>There are the following commandline parameters.</p>
<ul>
<li>s --- Reload system policy.
<li>e --- Reload exception policy.
<li>d --- Reload domain policy.
<li>a --- Reload the above three policies.
<li>f --- Erase on-memory policy before loading.
</ul>
<h3><a name="setlevel">&lt;Access control level changer "setlevel"&gt;</a></h3>
<p>Changes the current control level (i.e. writing to /proc/ccs/status ) and displays the new control level.</p>
<p>You can give the new control level from commandline parameter.</p>
<p>Only programs that are listed in /root/security/manager.txt can write to /proc/ccs/ directory. You may use shells and /bin/cat for accept mode, but you should list only loadpolicy editpolicy setlevel for production state.</p>
<h3><a name="savepolicy">&lt;Policy Saver "savepolicy"&gt;</a></h3>
<p>Saves the on-memory policy onto disk.</p>
<p>There are the following commandline parameters.</p>
<ul>
<li>s --- Save system policy.
<li>e --- Save exception policy.
<li>d --- Save domain policy.
<li>a --- Save the above three policies.
<li>f --- Save even if on-memory policy and on-disk policy are same.
</ul>
<h3><a name="makesyaoranconf">&lt;Template generator for SYAORAN filesystem "makesyaoranconf"&gt;</a></h3>
<p>Generates syaoran.conf, the configuration file for SYAORAN (the Tamper-Proof /dev filesystem). You can use SYAORAN filesystem if you want to run the system with read-only root fs or you want to prevent device files from tampering.</p>
<p>You can't create files that are not listed in the configuration file. If the system creates device files dynamically, attach all necessary devices before executing this program to ensure all device files are listed in the configuration file.</p>
<h3><a name="ccs-auditd">&lt;Access log reader daemon "ccs-auditd"&gt;</a></h3>
<p>Reads from /proc/ccs/info/grant_log and /proc/ccs/info/reject_log and writes to the location given in the commandline parameters.</p>
<p>The first commandline parameter is the location of access granted log. The second one is the location of access rejected log. You may give /dev/null as the location. If you needn't to save access logs, you needn't to run this program.</p>
<p>This program runs as a daemon. You can start from /etc/rc.d/rc.local if you are using RedHat Linux. The number of logs that the kernel will keep is given using "MAX_GRANT_LOG=integer" and "MAX_REJECT_LOG=integer" lines in the profile.</p>
<h3><a name="findtemp">&lt;Temporal pathnames detector "findtemp"&gt;</a></h3>
<p>Reads domain policy from standard input and checks the existence of pathnames that contains write permission, and dumps the nonexistent pathnames.</p>
<p>The nonexistent pathnames with write permission are likely used as temporal pathnames. So find the naming rules from similar nonexistent pathnames and append the pattern to /root/security/exception_policy.txt and /proc/ccs/policy/exception_policy .</p>
<p>If "--all" is given as a commandline parameter, this program will report all nonexistent pathnames.</p>
<p>You can pass the content of /root/security/domain_policy.txt or /proc/ccs/policy/domain_policy using redirection or pipes to the standard input of this program.</p>
<h3><a name="ld-watch">&lt;Library pathnames updater "ld-watch"&gt;</a></h3>
<p>Appends shared libraries to exception policy automatically using "allow_read" directive when the location of shared libraries in /etc/ld.so.cache has changed.</p>
<p>By running this program while updating packages, you can avoid errors "unable to start applications because shared libraries are unreadable" when the pathnames of shared libraries accessed by general programs has changed.</p>
<h3><a name="ccs-queryd">&lt;Delayed enforcing mode handler "ccs-queryd"&gt;</a></h3>
<p>Detects policy violation and displays the access request. You can tell the system whether the access request should be granted (or granted and policy should be appended to grant the access request) or rejected after you validate the access request.</p>
<p>By running this program while updating packages, you can avoid errors due to insufficient permissions.</p>
<p>Never grant access requests unconditionally. The cause of policy violation is not always updating packages, but may by malicious requests by attackers. If you grant access requests caused by malicious requests by attackers, the system gets intruded.</p>
<p>To use this program, you need to set "MAX_ENFORCE_GRACE=integer" in /proc/ccs/status where integer is the grace time in seconds.</p>
<hr>
<h2><a name="authentication_tool">&lt;&lt;Tools for reinforcing login authentications&gt;&gt;</a></h2>
<p>The programs described in this chapter are used only when you want to reinforce login authentications.</p>
<h3><a name="falsh">&lt;Restricted login shell for authentication "falsh"&gt;</a></h3>
<p>A tiny shell that have no built-in command such as kill. You can use this program for login shell ( the shell specified in the /etc/passwd file). You won't need this program if you don't want to reinforce login authentications.</p>
<p>You should make your own programs for additional authentications. You shouldn't use the following example programs without modifications.</p>
<h3><a name="honey">&lt;An example program for password authentication with timings "honey"&gt;</a></h3>
<p>This program fails unless the correct password is typed with the correct time interval. Conventional authentication programs don't check the time interval of typing, but this program does to prevent password brute force attack.</p>
<h3><a name="candy">&lt;An example program for password authentication with time limit "candy"</a></h3>
<p>This program fails unless the correct password is typed and this program was invoked within 10 seconds after the parent process was invoked. Conventional authentication programs don't check the time interval between the invocation time of parent process and the invocation time of child process, but this program does to prevent password brute force attack.</p>
<h3><a name="groovy">&lt;An example program for lockfile authentication "groovy"&gt;</a></h3>
<p>This program fails while the file /tmp/.lockme exists. This program prompts for password, but doesn't check for password. This program checks for the existence of the file /tmp/.lockme . This program prevents password brute force attack by keeping locked just before you run this program. This is a program for demonstration, and using a filename that are apparent to crackers. You must customize if you want to use.</p>
<h3><a name="checktoken">&lt;An example program for token authentication "gettoken / checktoken"&gt;</a></h3>
<p>This program generates tokens by according to the system time. The authentication will succeed if the output of gettoken is passwd to the input of checktoken. These are programs for demonstration, and the algorithm is too poor. You must customize if you want to use.</p>
<h3><a name="chaplet">&lt;An example program for challenge-handshake authentication "chaplet"&gt;</a></h3>
<p>This program displays strings as a challenge data. The authentication will succeed if you input only numerical letters from the challenge data as a response data. This is a program for demonstration, and the algorithm is too poor. You must customize if you want to use.</p>
<hr>
<h2><a name="looproot_tool">&lt;&lt;Tools for working with read-only root filesystem.&gt;&gt;</a></h2>
<p>The programs described in this chapter are used only when you want to run your system with read-only root filesystem.</p>
<h3><a name="remount_rootfs">&lt;Conditional remounter "remount_rootfs"&gt;</a></h3>
<p>Remounts root fs in read-write mode and enables swap partitions. Unmounts forcefully initrd-loop.img mounted on /initrd/ .</p>
<p>If the kernel commandline includes "readonly", root fs is not remounted. If the kernel commandline includes "noswap", swap partitions are not enabled.</p>
<h3><a name="initrd-loop.img">&lt;Initial RAM disk for loopback mount image "initrd-loop.img"&gt;</a></h3>
<p>This is an initial RAM disk that includes linuxrc for a loopback mountable root filesystem image. You can use this initial RAM disk if you are using a loopback mount image for root fs. It is possible to do loopback mount with standard nash program, but nash script can't handle errors and continue running until kernel panic. This program can stop on error.</p>
<p>If the original linuxrc (which is a nash script) exists as linuxrc.org , this linuxrc reads linuxrc.org , and processes lines that starts with insmod or sleep. linuxrc uses external insmod command to handle insmod request, you need to include insmod in the initrd-loop.img if you want to use insmod. But if insmod requires dynamic link library files, the initrd-loop.img will become larger, so you should built-in modules into the kernel that needs to be loaded by linuxrc .</p>
<p>If the file /.linuxrc exists in the loopback mounted root fs, it is executed before linuxrc terminates.</p>
<p>The location of the loopback mountable root fs is given from the kernel commandline using ROOTIMG= parameter. The default is /rootimg .</p>
<p>The device name that contains the loopback mountable root fs is given using root= parameter. But you need to give it by device file name. root=LABEL=/ can't be interpreted, for linuxrc is not a nash script.</p>
<p>The filesystem type of the loopback mountable root fs is given using IMAGE= parameter. The filesystem type of device which contains the loopback mountable root fs is given using CONTAINER= parameter. You can omit these parameters if filesystem type is one of ext2, ext3, iso9660, vfat, reiserfs, xfs, jfs.</p>
<hr>
<h2><a name="miniroot_tool">&lt;&lt;Tools for building customized root filesystem&gt;&gt;</a></h2>
<p>The programs described in this chapter are used only when you want to create custom root filesystem with minimum files.</p>
<h3><a name="makelink">&lt;Hard link generator "makelink"&gt;</a></h3>
<p>Reads the list of hard links from standard input and generates according to the list. This program is used to create hard links in the destination environment if the source environment is hard linked. The reason why the program to dump hard links and the program to generate hard links is that the destination directory may be included in the source directory or the destination and the source are different machines.</p>
<h3><a name="dumplink">&lt;Hard link dumper "dumplink"&gt;</a></h3>
<p>Dumps the list of hard links. Save the output of this program to file, and pass to makelink .</p>
<h3><a name="makesymlink">&lt;Symbolic link generator "makesymlink"&gt;</a></h3>
<p>Reads the list of symbolic links from standard input and generates according to the list. The hard links and symbolic links might depend on each other. So repeatedly run makelink and makesymlink .</p>
<h3><a name="dumpsymlink">&lt;Symbolic link dumper "dumpsymlink"&gt;</a></h3>
<p>Dumps the list of symbolic links. Save the output of this program to file, and pass to makesymlink .</p>
<hr>
<p><a href="index.html#manual">Return to index</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</body>
</html>
