<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linux Install manual (Targeted version)</title>
<link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<p>Info: Version <a href="../1.3/">1.3</a> is available.</p>
<h1>TOMOYO Linux Install manual (Targeted version)</h1>
<p style="text-align:right;">Last modified: $Date$</p>

<h1>Index</h1>

<table border="0">
<tr><td>
<a href="#preparation">Preparation</a><br>
&nbsp;&nbsp;<a href="#install-kernel">Install Kernel</a><br>
&nbsp;&nbsp;<a href="#install-tool">Install Tool</a><br>
&nbsp;&nbsp;<a href="#boot-test">Boot Test</a>
</td></tr><tr><td>
<a href="#policy-preparation">Preparing Policy</a><br>
&nbsp;&nbsp;<a href="#example_policy">About Default Policy</a><br>
&nbsp;&nbsp;<a href="#manager-programs">Defining Policy Managers</a><br>
&nbsp;&nbsp;<a href="#patch-shutdown">Modifying Shutdown Procedure</a><br>
&nbsp;&nbsp;<a href="#create-profiles">Creating Profiles</a><br>
&nbsp;&nbsp;<a href="#create-exceptions">Creating Exception Policy</a>
</td></tr><tr><td>
<a href="#generate-policy">Creating Policy</a><br>
&nbsp;&nbsp;<a href="#accept-mode-1">Accept Mode and tuning</a><br>
&nbsp;&nbsp;<a href="#accept-mode-2">Rerunning accept mode</a><br>
&nbsp;&nbsp;<a href="#permissive-mode">Permissive Mode</a>
</td></tr><tr><td>
<a href="#production-state">Production State</a><br>
&nbsp;&nbsp;<a href="#enforce-mode">Enforce mode</a>
</td></tr>
</table>
<hr>

<h1><a name="preparation">Preparation</a></h1>

<p>There are no limitations for distributions. But since it is impossible to cover all distributions, this manual covers "RedHat Linux 9", "Fedora Core 3" and "Debian Sarge".</p>

<p>The size of policy files gets smaller by uninstalling unnecessary applications. You should know what application you want to run on the system.</p>

<h2><a name="install-kernel">Install Kernel</a></h2>

<p>To compile kernel, see <a href="compile.html">TOMOYO Linux kernel compilation</a>.</p>

<h2><a name="install-tool">Install Tool</a></h2>

<p>To compile tools, run the following commands.</p>

<table border="1">
<tr><td>
cd /root/<br>
# Download source of tools for TOMOYO Linux.<br>
wget -O ccs-tools-1.2-20060903.tar.gz 'http://sourceforge.jp/frs/redir.php?m=jaist&amp;f=/tomoyo/21579/ccs-tools-1.2-20060903.tar.gz'<br>
# Extract.<br>
tar -zxf ccs-tools-1.2-20060903.tar.gz<br>
# Compile.<br>
make -sC ccstools/
</td></tr>
</table>

<h2><a name="boot-test">Boot Test</a></h2>

<p>Boot with TOMOYO Linux kernel, and check the system works properly.</p>

<p>After you confirmed the system works properly, save the content of /proc/ccs/status as /root/security/status.txt . This file contains the topics controllable for this kernel. This file is used as a hint when creating profiles (described later).</p>

<table border="1">
<tr><td>
mkdir -p /root/security<br>
cat /proc/ccs/status &gt; /root/security/status.txt
</td></tr>
</table>

<h1><a name="policy-preparation">Preparing Policy</a></h1>

<p>Please use normal kernel for operations in this chapter.<br>
If you use TOMOYO Linux's kernel, /root/ccstools/savepolicy will be executed on shutdown and modifications you made on /root/security/exception_policy.txt will be lost.</p>

<h2><a name="example_policy">About Default Policy</a></h2>
<p>TOMOYO Linux doesn't have default policy files distributed with softwares. Administrators need to create policy files using "accept mode".<br>
The <a href="http://tomoyo.sourceforge.jp/cgi-bin/lxr/source/?v=policy-sample">example policies</a> are available to help your understanding. You may use these examples as a guide, but you MUST NOT use these examples as default policies.</p>

<h2><a name="manager-programs">Defining Policy Managers</a></h2>

<p>Create /root/security/manager.txt and list up programs that are allowed to update policies via /proc/ccs/ interface.<br>
Specifically, "loadpolicy" that reloads policy, "editpolicy" that edits policy, "setlevel" that changes control level, "ld-watch" that updates globally readable files, "ccs-queryd" that grants access requests interactively.</p>
<table border="1">
<tr><td>
cat &gt; /root/security/manager.txt &lt;&lt; EOF<br>
/root/ccstools/loadpolicy<br>
/root/ccstools/editpolicy<br>
/root/ccstools/setlevel<br>
/root/ccstools/ld-watch<br>
/root/ccstools/ccs-queryd<br>
EOF<br></td>
</tr>
</table>

<h2><a name="patch-shutdown">Modifying Shutdown Procedure</a></h2>

<p>To save on-memory policies onto disk just before power off, modify the shutdown script to run /root/ccstools/savepolicy . Actual locations to modify depends on distributions.
In many cases, since the final program invoked in the shutdown script under /etc/init.d/ directory is the program to power off, save on-memory policies just before the invocation of the program.</p>

<p>If you are using RedHat Linux 9 or Fedora Core 3, modify as follows.</p>

<table border="1">
<tr><td colspan="2">/etc/rc.d/init.d/halt</td></tr>
<tr><td>Before</td><td>After</td></tr>
<tr><td>
<br>
exec $command $HALTARGS
</td><td>
/root/ccstools/savepolicy<br>
exec $command $HALTARGS
</td></tr>
</table>

<p>If you are using Debian Sarge, modify as follows. To create and include domains for executing halt/reboot among the domain policy, run halt/reboot once before invoking savepolicy.</p>

<table border="1">
<tr><td colspan="2">/etc/init.d/halt</td><td colspan="2">/etc/init.d/reboot</td></tr>
<tr><td>Before</td><td>After</td><td>Before</td><td>After</td></tr>
<tr><td>
<br>
<br>
halt -d -f -i $poweroff $hddown
</td><td>
halt --help 2&gt; /dev/null<br>
/root/ccstools/savepolicy<br>
halt -d -f -i $poweroff $hddown
</td><td>
<br>
<br>
reboot -d -f -i
</td><td>
reboot --help 2&gt; /dev/null<br>
/root/ccstools/savepolicy<br>
reboot -d -f -i
</td></tr>
</table>

<h2><a name="create-profiles">Creating Profiles</a></h2>

<p>TOMOYO Linux can perform several MACs besides MAC for files, but to reduce the load of policy managements, you can disable MACs you think unnecessary.</p>

<p>You can switch the MACs and their initial control status by creating several profiles and specifying the profile index number at kernel command line.
Specifically, the parameter CCS=$INDEX (where $INDEX is an integer) given in the kernel command line corresponds to the profile /root/security/profile$INDEX.txt to use.</p>

<p>Refer the descriptions below and create profiles for "accept mode", "permissive mode", "enforce mode". Only topics included in /root/security/status.txt are configurable. The topics included in /root/security/status.txt vary depending on the kernel configuration.</p>

<table border="1">
<tr><td>Name</td><td>Control</td><td>Accept mode supported</td></tr>
<tr><td>MAC_FOR_FILE</td><td>File Access</td><td>Yes</td></tr>
<tr><td>MAX_ACCEPT_FILES</td><td>Limits the max number of file ACL entries that are automatically appended during accept mode</td><td>-</td></tr>
<tr><td>MAX_GRANT_LOG</td><td>Limits the max number of grant logs that the kernel can hold</td><td>-</td></tr>
<tr><td>MAX_REJECT_LOG</td><td>Limits the max number of reject logs that the kernel can hold</td><td>-</td></tr>
<tr><td>TOMOYO_VERBOSE</td><td>Dump domain policy violation messages to syslog</td><td>-</td></tr>
<tr><td>MAX_ENFORCE_GRACE</td><td>Wait before rejecting access request when the request violates policy in enforce mode</td><td>-</td></tr>
</table>

<p>You can give the following values for MAX_ACCEPT_FILES</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>any integer</td><td>The max number of file ACL entries that are automatically appended during accept mode.
The default is given at the kernel compilation time.</td></tr>
</table>

<p>You can give the following values for MAX_GRANT_LOG and MAX_REJECT_LOG</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>any integer</td><td>The max number of logs that the kernel can hold. The default is given at the kernel compilation time. You may give 0 if you don't need logs.
</td></tr>
</table>

<p>You can give the following values for TOMOYO_VERBOSE</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>0</td><td>Don't dump domain policy violation messages.</td></tr>
<tr><td>1</td><td>Dump domain policy violation messages.</td></tr>
</table>

<p>You can give the following values for MAX_ENFORCE_GRACE</p>

<table border="1"><tr><td>Value</td><td>Meaning</td></tr>
<tr><td>any integer</td><td>The max grace time in seconds. If the administrator tells the kernel not to reject the request that violated policy in enforce mode, the request will be granted.</td></tr>
</table>

<p>You can give the following values for all but listed above.</p>

<table border="1">
<tr><td>Value</td><td>Meaning</td></tr>
<tr><td>0</td><td>Disabled. Works as if regular kernel.</td></tr>
<tr><td>1</td><td>Accept mode. Not rejected if the request violates policy. Automatically appended to policy.</td></tr>
<tr><td>2</td><td>Permissive mode. Not rejected if the request violates policy. Not appended to policy automatically.</td></tr>
<tr><td>3</td><td>Enforce mode. Rejected if the request violates policy.</td></tr>
</table>

<h2><a name="create-exceptions">Creating Exception Policy</a></h2>

<p>Register pathnames with patterns that likely exists on all Linux systems.<br>
Register pathnames with patterns using the "file_pattern" directive in /root/security/exception_policy.txt .<br>
When a file operation are performed and the requested pathname matches to a patterned pathname registered with "file_pattern" directive, policy is generated using patterned pathnames.<br>
The following is the guideline.</p>

<ul>
<li>Files under /proc/PID/ directory.
<li>Files under /sys/ directory. (Applicable to 2.6 kernels only)
<li>Some files under /dev/ directory.
<li>Policy files under /root/security/ directory.
<li>Manual pages.
<li>Spool directories.
<li>Temporary files used for sending and receiving mails.
<li>Temporary files used by man command.
<li>Temporary files used by mount command.
</ul>

<p>TOMOYO Linux needs more patterned pathnames depending on the applications installed and their configurations. You can add missing patterned pathnames after running the system.</p>

<p>Register files that are allowed to be read by all programs.<br>
Register pathnames using the "allow_read" directive in /root/security/exception_policy.txt . No patterns allowed.<br>
When a read access is requested and the requested pathname matches to a pathname registered with "allow_read" directive, the read access is granted without checking domain policy.<br>
The following is the guideline.</p>

<ul>
<li>Dynamically-linked library files that are registered with ldconfig.
<li>Some files under /proc/ directory.
<li>Some locale data under /usr/share/locale/ directory.
</ul>

<p>A shell script is included that performs the operations described above.
Run as the following.</p>

<table border="1">
<tr><td>
/root/ccstools/make_targeted_exception.sh | sort | uniq &gt; /root/security/exception_policy.txt
</td></tr>
</table>

<p>Next, specify programs you want to apply MAC protection. Some candidates are shown by running the following command.</p>

<table border="1">
<tr><td>
/root/ccstools/make_exception.sh | grep '^initializer' | sort | uniq
</td></tr>
</table>

<p>For example, if you want to enable Mandatory Access Controls on /usr/sbin/httpd and programs invoked by /usr/sbin/httpd , add the following line.</p>

<table border="1">
<tr><td>
initializer /usr/sbin/httpd
</td></tr>
</table>

<p>By these steps, /usr/sbin/httpd and programs invoked by /usr/sbin/httpd run in the "&lt;kernel&gt; /usr/sbin/httpd" domain and its child domains and are protected by Mandatory Access Controls.</p>

<p>For example, if you want to enable Mandatory Access Controls on /usr/sbin/sshd and programs invoked by /usr/sbin/sshd , add the following line.</p>

<table border="1">
<tr><td>
initializer /usr/sbin/sshd
</td></tr>
</table>

<p>By these steps, /usr/sbin/sshd and programs invoked by /usr/sbin/sshd run in the "&lt;kernel&gt; /usr/sbin/sshd" domain and its child domains and are protected by Mandatory Access Controls.</p>

<h1><a name="generate-policy">Creating Policy</a></h1>

<h2><a name="accept-mode-1">Accept Mode and tuning</a></h2>

<h3>Boot options</h3>

<p>Boot with TOMOYO Linux kernel with the profile number for accept mode to CCS= parameter.
Give the parameter "TOMOYO_NOLOAD" to the kernel command line for the first time to skip reading domain policy.
If the parameter "TOMOYO_NOLOAD" is given, the domain policy file (domain_policy.txt) won't get loaded.
(Therefore, choose TOMOYO Linux kernel with TOMOYO_NOLOAD parameter and the profile number for accept mode to CCS= parameter.)</p>

<h3>Confirming processes to be protected</h3>

<p>If you run the following command, the process IDs of the programs on which MAC aren't applied are shown.</p>

<table border="1">
<tr><td>
cat /proc/ccs/info/trusted_pids
</td></tr>
</table>

<p>Make sure that the process IDs of the programs you want to protect aren't shown. If shown, do the following operation.</p>

<table border="1">
<tr><td>
* Run "/root/ccstools/editpolicy e".<br>
* Move cursors using UP/DOWN arrow keys and make sure that the line "initializer program_to_protect" doesn't exist. For example, if you want to protect "/usr/sbin/squid", make sure the line "initializer /usr/sbin/squid" doesn't exist.<br>
* When you press "a" key, a prompt "Enter new entry&gt;" will appear, then input "initializer program_to_protect" and press "Enter" key.<br>
* Move cursors using UP/DOWN arrow keys and make sure that the line "initializer program_to_protect" exists.<br>
* Press "q" key to quit the editor.<br>
* Restart the program you want to protect.<br>
* Examine the contents of /proc/ccs/info/trusted_pids and make sure that the process IDs of the programs you want to protect aren't shown.
</td></tr>
</table>

<h3>Examining behavior</h3>

<p>Do a series of operations you want to allow.</p>

<p>Repeat several times, for all access patterns may not be recorded by single operations.<br>
Also, there are operations that are done only startup and shutdown, repeat reboot for several times.</p>

<p>When you are running with accept mode, you may find messages in the following format.</p>

<table border="1">
<tr><td>
TOMOYO-WARNING: Domain '&lt;kernel&gt; ...' has so many ACLs to hold. Stopped auto-append mode.
</td></tr>
</table>

<p>This message tells you that the safeguard for this program is activated to prevent memory consumption and dull response since this program accessed so many files. When the safeguard is activated, file ACLs for that domain are no longer appended automatically.</p>

<p>To deal with this message, you need to edit ACLs manually.<br>
For example, if the following message appeared, you need to reduce the number of file ACLs for &lt;kernel&gt; /usr/sbin/hald using appropriate pathname patterns.</p>

<table border="1">
<tr><td>
TOMOYO-WARNING: Domain '&lt;kernel&gt; /usr/sbin/hald' has so many ACLs to hold. Stopped auto-append mode.
</td></tr>
</table>

<h3>Patterning pathnames</h3>

<p>Run the following command to find pathnames that are likely temporary.</p>

<table border="1">
<tr><td>
/root/ccstools/findtemp &lt; /proc/ccs/policy/domain_policy | sort | uniq
</td></tr>
</table>

<p>Make patterns appropriately and do the following operation.</p>

<table border="1">
<tr><td>
* Run "/root/ccstools/editpolicy e".<br>
* Move cursors using UP/DOWN arrow keys and make sure that the line "file_pattern patterned_pathname" doesn't exist. For example, if you want to add pattern "/tmp/sh-thd-\$", make sure the line "file_pattern /tmp/sh-thd-\$" doesn't exist.<br>
* When you press "a" key, a prompt "Enter new entry&gt;" will appear, then input "file_pattern patterned_pathname" and press "Enter" key.<br>
* Move cursors using UP/DOWN arrow keys and make sure that the line "file_pattern patterned_pathname" exists.<br>
* Press "q" key to quit the editor.<br>
</td></tr>
</table>

<p>Guidelines for temporary pathnames are "Multiple pathnames that differs only last 6 letters", "Multiple pathnames that differs only numerical part" and so on.<br>
An example of patterned pathnames is shown below. These patterned pathnames may not exist or exist in other location depending on the applications installed and their configurations.</p>
<ul>
<li>file_pattern /etc/.fstab.hal.\?</li>
<li>file_pattern /etc/blkid.tab-\?\?\?\?\?\?</li>
<li>file_pattern /etc/mrtg/mrtg.cfg_l_\$</li>
<li>file_pattern /root/.emacs.d/auto-save-list/.saves-\$-\*</li>
<li>file_pattern /root/Mail/inbox/\$</li>
<li>file_pattern /tmp/auto\?\?\?\?\?\?/</li>
<li>file_pattern /tmp/autofs.\?\?\?\?\?\?</li>
<li>file_pattern /tmp/logrotate.\?\?\?\?\?\?</li>
<li>file_pattern /tmp/logwatch.\*/</li>
<li>file_pattern /tmp/logwatch.\*/\*</li>
<li>file_pattern /tmp/makewhatis\?\?\?\?\?\?/</li>
<li>file_pattern /tmp/makewhatis\?\?\?\?\?\?/w</li>
<li>file_pattern /tmp/sh-thd-\$</li>
<li>file_pattern /tmp/spamassassin-\$/</li>
<li>file_pattern /tmp/spamassassin-\$/.spamassassin/</li>
<li>file_pattern /tmp/spamassassin-\$/.spamassassin/auto-whitelist\*</li>
<li>file_pattern /tmp/whatis.\?\?\?\?\?\?</li>
<li>file_pattern /var/lib/dhcp/dhcpd.leases.\$</li>
<li>file_pattern /var/lock/autofs.\$</li>
<li>file_pattern /var/lock/mrtg/mrtg_l_\$</li>
<li>file_pattern /var/log/ksymoops/\*</li>
<li>file_pattern /var/log/sa/sa\*</li>
<li>file_pattern /var/mailman/locks/gate_news.lock.\*</li>
<li>file_pattern /var/run/gpm\?\?\?\?\?\?</li>
</ul>

<h3>Add conditions to ACLs</h3>

<p>TOMOYO Linux 1.2 supports conditional ACLs. By using this feature, you can control system's user ID based access control.</p>

<p>If you want to protect non-anonymous FTP service, by adding conditions in the following manner, you can forbid access to directories outside the user's home directory. To reduce damages when it is cracked, it is recommended that you should expose directories only under specific (such as "ftp") directory rather than exposing whole of home directories.
If you use vsftpd, you can give like the following way.</p>

<table border="1">
<tr><td>Before</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/vsftpd<br>
<br>
6 /home/\*/ftp/\*<br>
6 /home/\*/ftp/\*/\*<br>
6 /home/\*/ftp/\*/\*/\*<br>
6 /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_mkdir /home/\*/ftp/\*/<br>
allow_mkdir /home/\*/ftp/\*/\*/<br>
allow_mkdir /home/\*/ftp/\*/\*/\*/<br>
<br>
allow_rmdir /home/\*/ftp/\*/<br>
allow_rmdir /home/\*/ftp/\*/\*/<br>
allow_rmdir /home/\*/ftp/\*/\*/\*/<br>
<br>
allow_create /home/\*/ftp/\*<br>
allow_create /home/\*/ftp/\*/\*<br>
allow_create /home/\*/ftp/\*/\*/\*<br>
allow_create /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_truncate /home/\*/ftp/\*<br>
allow_truncate /home/\*/ftp/\*/\*<br>
allow_truncate /home/\*/ftp/\*/\*/\*<br>
allow_truncate /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_unlink /home/\*/ftp/\*<br>
allow_unlink /home/\*/ftp/\*/\*<br>
allow_unlink /home/\*/ftp/\*/\*/\*<br>
allow_unlink /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/ftp/\* /home/\*/ftp/\*<br>
allow_rename /home/\*/ftp/\*/\* /home/\*/ftp/\*/\*<br>
allow_rename /home/\*/ftp/\*/\*/\* /home/\*/ftp/\*/\*/\*<br>
allow_rename /home/\*/ftp/\*/\*/\*/\* /home/\*/ftp/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/ftp/\*/ /home/\*/ftp/\*/<br>
allow_rename /home/\*/ftp/\*/\*/ /home/\*/ftp/\*/\*/<br>
allow_rename /home/\*/ftp/\*/\*/\*/ /home/\*/ftp/\*/\*/\*/<br>
</td></tr>
</table>


<table border="1">
<tr><td>After</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/vsftpd<br>
<br>
6 /home/\*/ftp/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
6 /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_mkdir /home/\*/ftp/\*/ if task.uid=path1.parent.uid<br>
allow_mkdir /home/\*/ftp/\*/\*/ if task.uid=path1.parent.uid<br>
allow_mkdir /home/\*/ftp/\*/\*/\*/ if task.uid=path1.parent.uid<br>
<br>
allow_rmdir /home/\*/ftp/\*/ if task.uid=path1.uid<br>
allow_rmdir /home/\*/ftp/\*/\*/ if task.uid=path1.uid<br>
allow_rmdir /home/\*/ftp/\*/\*/\*/ if task.uid=path1.uid<br>
<br>
allow_create /home/\*/ftp/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\*/\* if task.uid=path1.parent.uid<br>
allow_create /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.parent.uid<br>
<br>
allow_truncate /home/\*/ftp/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
allow_truncate /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_unlink /home/\*/ftp/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\*/\* if task.uid=path1.uid<br>
allow_unlink /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.uid<br>
<br>
allow_rename /home/\*/ftp/\* /home/\*/ftp/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\* /home/\*/ftp/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\* /home/\*/ftp/\*/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\*/\* /home/\*/ftp/\*/\*/\*/\* if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
<br>
allow_rename /home/\*/ftp/\*/ /home/\*/ftp/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/ /home/\*/ftp/\*/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
allow_rename /home/\*/ftp/\*/\*/\*/ /home/\*/ftp/\*/\*/\*/ if task.uid=path1.parent.uid task.uid=path2.parent.uid<br>
</td></tr>
</table>

<p>If you want to protect Samba service, by adding conditions in the following manner, you can forbid access to directories outside the user's home directory. To reduce damages when it is cracked, it is recommended that you should expose directories only under specific (such as "samba") directory rather than exposing whole of home directories.</p>

<table border="1">
<tr><td>Before</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
<br>
6 /home/\*/samba/\*<br>
6 /home/\*/samba/\*/\*<br>
6 /home/\*/samba/\*/\*/\*<br>
6 /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_mkdir /home/\*/samba/\*/<br>
allow_mkdir /home/\*/samba/\*/\*/<br>
allow_mkdir /home/\*/samba/\*/\*/\*/<br>
<br>
allow_rmdir /home/\*/samba/\*/<br>
allow_rmdir /home/\*/samba/\*/\*/<br>
allow_rmdir /home/\*/samba/\*/\*/\*/<br>
<br>
allow_create /home/\*/samba/\*<br>
allow_create /home/\*/samba/\*/\*<br>
allow_create /home/\*/samba/\*/\*/\*<br>
allow_create /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_truncate /home/\*/samba/\*<br>
allow_truncate /home/\*/samba/\*/\*<br>
allow_truncate /home/\*/samba/\*/\*/\*<br>
allow_truncate /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_unlink /home/\*/samba/\*<br>
allow_unlink /home/\*/samba/\*/\*<br>
allow_unlink /home/\*/samba/\*/\*/\*<br>
allow_unlink /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/samba/\* /home/\*/samba/\*<br>
allow_rename /home/\*/samba/\*/\* /home/\*/samba/\*/\*<br>
allow_rename /home/\*/samba/\*/\*/\* /home/\*/samba/\*/\*/\*<br>
allow_rename /home/\*/samba/\*/\*/\*/\* /home/\*/samba/\*/\*/\*/\*<br>
<br>
allow_rename /home/\*/samba/\*/ /home/\*/samba/\*/<br>
allow_rename /home/\*/samba/\*/\*/ /home/\*/samba/\*/\*/<br>
allow_rename /home/\*/samba/\*/\*/\*/ /home/\*/samba/\*/\*/\*/
</td></tr>
</table>

<table border="1">
<tr><td>After</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
<br>
6 /home/\*/samba/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
6 /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_mkdir /home/\*/samba/\*/ if task.euid=path1.parent.uid<br>
allow_mkdir /home/\*/samba/\*/\*/ if task.euid=path1.parent.uid<br>
allow_mkdir /home/\*/samba/\*/\*/\*/ if task.euid=path1.parent.uid<br>
<br>
allow_rmdir /home/\*/samba/\*/ if task.euid=path1.uid<br>
allow_rmdir /home/\*/samba/\*/\*/ if task.euid=path1.uid<br>
allow_rmdir /home/\*/samba/\*/\*/\*/ if task.euid=path1.uid<br>
<br>
allow_create /home/\*/samba/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\*/\* if task.euid=path1.parent.uid<br>
allow_create /home/\*/samba/\*/\*/\*/\* if task.euid=path1.parent.uid<br>
<br>
allow_truncate /home/\*/samba/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
allow_truncate /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_unlink /home/\*/samba/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\*/\* if task.euid=path1.uid<br>
allow_unlink /home/\*/samba/\*/\*/\*/\* if task.euid=path1.uid<br>
<br>
allow_rename /home/\*/samba/\* /home/\*/samba/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\* /home/\*/samba/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\* /home/\*/samba/\*/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\*/\* /home/\*/samba/\*/\*/\*/\* if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
<br>
allow_rename /home/\*/samba/\*/ /home/\*/samba/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/ /home/\*/samba/\*/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid<br>
allow_rename /home/\*/samba/\*/\*/\*/ /home/\*/samba/\*/\*/\*/ if task.euid=path1.parent.uid task.euid=path2.parent.uid
</td></tr>
</table>

<p>If you want to protect SSH service, by adding conditions in the following manner, you can forbid login as user "root".</p>

<table border="1">
<tr><td>Before</td><td>After</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
<br>
1 /bin/bash
</td><td>
&lt;kernel&gt; /usr/sbin/sshd<br>
<br>
1 /bin/bash if task.uid!=0 task.euid!=0
</td></tr>
</table>

<p>See <a href="policy-reference.html#conditional_acl">Conditional permission</a> for available conditions.</p>

<h3>Patterning File Access Permissions</h3>

<p>Append access permissions for files that are not necessarily accessed in the accept mode such as WWW contents for WWW service to /root/security/domain_policy.txt .<br>
The following example allows /usr/sbin/httpd to read files in the /var/www/html/ directory.</p>

<table border="1">
<tr><td>
&lt;kernel&gt; /usr/sbin/httpd<br>
4 /var/www/html/\*<br>
4 /var/www/html/\*/\*<br>
4 /var/www/html/\*/\*/\*<br>
4 /var/www/html/\*/\*/\*/\*<br>
4 /var/www/html/\*/\*/\*/\*/\*<br></td>
</tr>
</table>

<p>In the same way, modify access permissions for files using patterns that should be grouped.
The following example shows /usr/sbin/smbd should handle all log files equally.</p>

<table border="1">
<tr><td>Before</td><td>After</td></tr>
<tr><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
2 /var/log/samba/host1.log<br>
2 /var/log/samba/host2.log<br>
2 /var/log/samba/host3.log<br>
2 /var/log/samba/host4.log<br>
2 /var/log/samba/host5.log
</td><td>
&lt;kernel&gt; /usr/sbin/smbd<br>
2 /var/log/samba/\*.log
</td></tr>
</table>

<h2><a name="accept-mode-2">Rerunning accept mode</a></h2>

<p>If you are sure you found all patterns, recreate the domain policy from the beginning.
Give the parameter "TOMOYO_NOLOAD" to the kernel command line for the first time to skip reading domain policy.</p>

<h2><a name="permissive-mode">Permissive Mode</a></h2>

<p>Boot with TOMOYO Linux kernel with the profile number for permissive mode to CCS= parameter.</p>
<p>Check that error messages don't appear when you operate you want to allow.</p>
<p>If the system works properly, the installation of TOMOYO Linux is done.</p>

<h1><a name="production-state">Production State</a></h1>

<h2><a name="enforce-mode">Enforce mode</a></h2>

<p>Boot with TOMOYO Linux kernel with the profile number for enforce mode to CCS= parameter.</p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="sflogo.php" title="SourceForge.jp"></a></p>
</body>
</html>
