---
 tomoyotools.src/pathmatch.c   |  178 +++++++++++++++++-------------------------
 tomoyotools.src/tomoyotools.c |  124 +++++++++++++++++++----------
 tomoyotools.src/tomoyotools.h |    3 
 3 files changed, 157 insertions(+), 148 deletions(-)

--- tomoyo-tools.orig/tomoyotools.src/pathmatch.c
+++ tomoyo-tools/tomoyotools.src/pathmatch.c
@@ -10,134 +10,111 @@
  */
 #include "tomoyotools.h"
 
-static _Bool print_path_needs_separator = false;
+static unsigned char revalidate_path(const char *path)
+{
+	struct stat buf;
+	unsigned char type = DT_UNKNOWN;
+	if (!lstat(path, &buf)) {
+		if (S_ISREG(buf.st_mode))
+			type = DT_REG;
+		else if (S_ISDIR(buf.st_mode))
+			type = DT_DIR;
+		else if (S_ISLNK(buf.st_mode))
+			type = DT_LNK;
+	}
+	return type;
+}
 
-static void print_path(const char *dir, const char *file, const char *trailer)
+static int scandir_filter(const struct dirent *buf)
 {
-	if (print_path_needs_separator)
-		putchar(' ');
-	print_path_needs_separator = true;
-	fprintf_encoded(stdout, dir);
-	fprintf_encoded(stdout, file);
-	fprintf_encoded(stdout, trailer);
+	return strcmp(buf->d_name, ".") && strcmp(buf->d_name, "..");
 }
 
-static char *scandir_filter_current_part = NULL;
+static struct path_info target;
+static _Bool print_path_needs_separator = false;
 
-static int scandir_filter(const struct dirent *buf)
+static _Bool print_path(const char *path, const int type)
 {
-	char buffer[1024];
-	char c;
-	char *dp = buffer;
-	const char *cp = buf->d_name;
-	if (buf->d_type == DT_DIR) {
-		if (!strcmp(cp, ".") || !strcmp(cp, ".."))
-			return 0;
-	}
-	/* Make sure strlen(cp) * 4 + 1 < sizeof(buffer). */
-	if (strlen(cp) > 255)
-		return 0;
+	struct path_info name;
+	int len;
+	char *cp;
+	len = strlen(path) * 4 + 4;
+	cp = malloc(len);
+	if (!cp)
+		out_of_memory();
+	name.name = cp;
 	while (true) {
-		c = *cp++;
-		if (!c)
+		const unsigned char c = *(const unsigned char *) path++;
+		if (!c) {
+			if (type == DT_DIR)
+				*cp++ = '/';
+			*cp++ = '\0';
 			break;
-		if (c == '\\') {
-			*dp++ = '\\';
-			*dp++ = '\\';
+		} else if (c == '\\') {
+			*cp++ = '\\';
+			*cp++ = '\\';
 		} else if (c > ' ' && c < 127) {
-			*dp++ = c;
+			*cp++ = c;
 		} else {
-			*dp++ = '\\';
-			*dp++ = ((c >> 6) + '0');
-			*dp++ = (((c >> 3) & 7) + '0');
-			*dp++ = ((c & 7) + '0');
+			*cp++ = '\\';
+			*cp++ = (c >> 6) + '0';
+			*cp++ = ((c >> 3) & 7) + '0';
+			*cp++ = (c & 7) + '0';
 		}
 	}
-	*dp = '\0';
-	/* printf("Compare: %s %s\n", buffer, scandir_filter_current_part); */
-	if (file_matches_pattern(buffer, dp, scandir_filter_current_part,
-				 strchr(scandir_filter_current_part, '\0')))
-		return 1;
-	return 0;
+	fill_path_info(&name);
+	if (path_matches_pattern(&name, &target)) {
+		if (print_path_needs_separator)
+			putchar(' ');
+		print_path_needs_separator = true;
+		printf("%s", name.name);
+	}
+	len = name.total_len >= target.const_len ? target.const_len :
+		name.total_len;
+	len = strncmp(name.name, target.name, len);
+	free((void *) name.name);
+	return !len;
 }
 
-static _Bool scandir_target_is_dir = false;
-static int scandir_target_depth = 0;
-static char **scandir_target_part = NULL;
+static char path[8192];
 
-static void scan_dir(const char *path, int depth)
+static void scan_dir(void)
 {
 	struct dirent **namelist;
+	int n = scandir(path, &namelist, scandir_filter, 0);
+	int len;
 	int i;
-	int n;
-	scandir_filter_current_part = scandir_target_part[depth];
-	/* printf("Scan: %d %s\n", depth, scandir_filter_current_part); */
-	n = scandir(path, &namelist, scandir_filter, 0);
 	if (n < 0)
 		return;
+	len = strlen(path);
+	if (len == 1)
+		len = 0;
 	for (i = 0; i < n; i++) {
-		const char *cp = namelist[i]->d_name;
-		const unsigned char type = namelist[i]->d_type;
-		if (depth < scandir_target_depth - 1) {
-			if (type == DT_DIR) {
-				const int len = strlen(path) + strlen(cp) + 4;
-				char *child_path = malloc(len);
-				if (!child_path)
-					out_of_memory();
-				snprintf(child_path, len - 1, "%s%s/",
-					 path, cp);
-				/* printf("Check: %s\n", child_path); */
-				scan_dir(child_path, depth + 1);
-				free(child_path);
-			}
-		} else if (scandir_target_is_dir) {
-			if (type == DT_DIR)
-				print_path(path, cp, "/");
-		} else if (type != DT_DIR) {
-			print_path(path, cp, "");
-		}
+		unsigned char type = namelist[i]->d_type;
+		snprintf(path + len, sizeof(path) - len - 1, "/%s",
+			 namelist[i]->d_name);
+		if (type == DT_UNKNOWN)
+			type = revalidate_path(path);
+		if (print_path(path, type) && type == DT_DIR)
+			scan_dir();
 		free((void *) namelist[i]);
 	}
 	free((void *) namelist);
 }
 
-static void do_pathmatch_main(char *target)
+static void do_pathmatch_main(char *find)
 {
-	if (!strcmp(target, "/")) {
-		printf("/\n");
-	} else if (target[0] != '/') {
-		putchar('\n');
-	} else {
-		char *cp;
-		int i;
-		scandir_target_is_dir = (*(strchr(target, '\0') - 1) == '/');
-		scandir_target_depth = 0;
-		cp = target + 1;
-		for (i = 1; ; i++) {
-			char c = target[i];
-			if (c != '/' && c != '\0')
-				continue;
-			target[i] = '\0';
-			scandir_target_part = realloc(scandir_target_part,
-						      (scandir_target_depth + 1)
-						      * sizeof(char *));
-			if (!scandir_target_part)
-				out_of_memory();
-			if (target + i != cp)
-				scandir_target_part[scandir_target_depth++]
-					= cp;
-			cp = target + i + 1;
-			if (!c)
-				break;
-		}
-		/*
-		for (i = 0; i < target_depth; i++)
-			printf("%d %s\n", i, scandir_target_part[i]);
-		*/
+	if (!strcmp(find, "/"))
+		putchar('/');
+	else if (is_correct_path(find, 1, 0, 0)) {
+		target.name = find;
+		fill_path_info(&target);
 		print_path_needs_separator = false;
-		scan_dir("/", 0);
-		putchar('\n');
+		memset(path, 0, sizeof(path));
+		strncpy(path, "/", sizeof(path) - 1);
+		scan_dir();
 	}
+	putchar('\n');
 }
 
 int pathmatch_main(int argc, char *argv[])
@@ -152,8 +129,5 @@ int pathmatch_main(int argc, char *argv[
 			do_pathmatch_main(shared_buffer);
 		put();
 	}
-	free(scandir_target_part);
-	scandir_target_part = NULL;
-	scandir_target_depth = 0;
 	return 0;
 }
--- tomoyo-tools.orig/tomoyotools.src/tomoyotools.c
+++ tomoyo-tools/tomoyotools.src/tomoyotools.c
@@ -22,7 +22,6 @@ static inline unsigned long partial_name
 static inline unsigned int full_name_hash(const unsigned char *name,
 					  unsigned int len);
 static void *alloc_element(const unsigned int size);
-static int path_depth(const char *pathname);
 static int const_part_length(const char *filename);
 static int domainname_compare(const void *a, const void *b);
 static int path_info_compare(const void *a, const void *b);
@@ -148,22 +147,6 @@ static void *alloc_element(const unsigne
 	return ptr;
 }
 
-static int path_depth(const char *pathname)
-{
-	int i = 0;
-	if (pathname) {
-		char *ep = strchr(pathname, '\0');
-		if (pathname < ep--) {
-			if (*ep != '/')
-				i++;
-			while (pathname <= ep)
-				if (*ep-- == '/')
-					i += 2;
-		}
-	}
-	return i;
-}
-
 static int const_part_length(const char *filename)
 {
 	int len = 0;
@@ -322,6 +305,8 @@ _Bool decode(const char *ascii, char *bi
 _Bool is_correct_path(const char *filename, const s8 start_type,
 		     const s8 pattern_type, const s8 end_type)
 {
+	const char *const start = filename;
+	_Bool in_repetition = false;
 	_Bool contains_pattern = false;
 	unsigned char c;
 	if (!filename)
@@ -368,6 +353,22 @@ _Bool is_correct_path(const char *filena
 					break; /* Must not contain pattern */
 				contains_pattern = true;
 				continue;
+			case '{':   /* "/\{" */
+				if (filename - 3 < start ||
+				    *(filename - 3) != '/')
+					break;
+				if (pattern_type == -1)
+					break; /* Must not contain pattern */
+				contains_pattern = true;
+				in_repetition = true;
+				continue;
+			case '}':   /* "\}/" */
+				if (*filename != '/')
+					break;
+				if (!in_repetition)
+					break;
+				in_repetition = false;
+				continue;
 			case '0':   /* "\ooo" */
 			case '1':
 			case '2':
@@ -383,6 +384,8 @@ _Bool is_correct_path(const char *filena
 					continue; /* pattern is not \000 */
 			}
 			goto out;
+		} else if (in_repetition && c == '/') {
+			goto out;
 		} else if (c <= ' ' || c >= 127) {
 			goto out;
 		}
@@ -391,6 +394,8 @@ _Bool is_correct_path(const char *filena
 		if (!contains_pattern)
 			goto out;
 	}
+	if (in_repetition)
+		goto out;
 	return true;
 out:
 	return false;
@@ -505,8 +510,9 @@ static _Bool file_matches_pattern2(const
 	return filename == filename_end && pattern == pattern_end;
 }
 
-_Bool file_matches_pattern(const char *filename, const char *filename_end,
-			  const char *pattern, const char *pattern_end)
+static _Bool file_matches_pattern(const char *filename,
+				  const char *filename_end,
+				  const char *pattern, const char *pattern_end)
 {
 	const char *pattern_start = pattern;
 	_Bool first = true;
@@ -529,35 +535,19 @@ _Bool file_matches_pattern(const char *f
 	return first ? result : !result;
 }
 
-_Bool path_matches_pattern(const struct path_info *filename,
-			  const struct path_info *pattern)
+static _Bool path_matches_pattern2(const char *f, const char *p)
 {
-	/*
-	if (!filename || !pattern)
-		return false;
-	*/
-	const char *f = filename->name;
-	const char *p = pattern->name;
-	const int len = pattern->const_len;
-	/* If @pattern doesn't contain pattern, I can use strcmp(). */
-	if (!pattern->is_patterned)
-		return !pathcmp(filename, pattern);
-	/* Don't compare if the number of '/' differs. */
-	if (filename->depth != pattern->depth)
-		return false;
-	/* Compare the initial length without patterns. */
-	if (strncmp(f, p, len))
-		return false;
-	f += len;
-	p += len;
-	/* Main loop. Compare each directory component. */
+	const char *f_delimiter;
+	const char *p_delimiter;
 	while (*f && *p) {
-		const char *f_delimiter = strchr(f, '/');
-		const char *p_delimiter = strchr(p, '/');
+		f_delimiter = strchr(f, '/');
 		if (!f_delimiter)
 			f_delimiter = strchr(f, '\0');
+		p_delimiter = strchr(p, '/');
 		if (!p_delimiter)
 			p_delimiter = strchr(p, '\0');
+		if (*p == '\\' && *(p + 1) == '{')
+			goto recursive;
 		if (!file_matches_pattern(f, f_delimiter, p, p_delimiter))
 			return false;
 		f = f_delimiter;
@@ -572,6 +562,55 @@ _Bool path_matches_pattern(const struct 
 	       (*(p + 1) == '*' || *(p + 1) == '@'))
 		p += 2;
 	return !*f && !*p;
+ recursive:
+	/*
+	 * The "\{" pattern is permitted only after '/' character.
+	 * This guarantees that below "*(p - 1)" is safe.
+	 * Also, the "\}" pattern is permitted only before '/' character
+	 * so that "\{" + "\}" pair will not break the "\-" operator.
+	 */
+	if (*(p - 1) != '/' || p_delimiter <= p + 3 || *p_delimiter != '/' ||
+	    *(p_delimiter - 1) != '}' || *(p_delimiter - 2) != '\\')
+		return false; /* Bad pattern. */
+	do {
+		/* Compare current component with pattern. */
+		if (!file_matches_pattern(f, f_delimiter, p + 2,
+					  p_delimiter - 2))
+			break;
+		/* Proceed to next component. */
+		f = f_delimiter;
+		if (*f)
+			f++;
+		/* Continue comparison. */
+		if (path_matches_pattern2(f, p_delimiter + 1))
+			return true;
+		f_delimiter = strchr(f, '/');
+	} while (f_delimiter);
+	return false; /* Not matched. */
+}
+
+_Bool path_matches_pattern(const struct path_info *filename,
+			   const struct path_info *pattern)
+{
+	/*
+	if (!filename || !pattern)
+		return false;
+	*/
+	const char *f = filename->name;
+	const char *p = pattern->name;
+	const int len = pattern->const_len;
+	/* If @pattern doesn't contain pattern, I can use strcmp(). */
+	if (!pattern->is_patterned)
+		return !pathcmp(filename, pattern);
+	/* Don't compare directory and non-directory. */
+	if (filename->is_dir != pattern->is_dir)
+		return false;
+	/* Compare the initial length without patterns. */
+	if (strncmp(f, p, len))
+		return false;
+	f += len;
+	p += len;
+	return path_matches_pattern2(f, p);
 }
 
 int string_compare(const void *a, const void *b)
@@ -593,7 +632,6 @@ void fill_path_info(struct path_info *pt
 	ptr->is_dir = len && (name[len - 1] == '/');
 	ptr->is_patterned = (ptr->const_len < len);
 	ptr->hash = full_name_hash(name, len);
-	ptr->depth = path_depth(name);
 }
 
 static unsigned int memsize(const unsigned int size)
--- tomoyo-tools.orig/tomoyotools.src/tomoyotools.h
+++ tomoyo-tools/tomoyotools.src/tomoyotools.h
@@ -155,7 +155,6 @@ struct path_info {
 	u16 const_len;      /* = const_part_length(name)            */
 	_Bool is_dir;       /* = strendswith(name, "/")             */
 	_Bool is_patterned; /* = path_contains_pattern(name)        */
-	u16 depth;          /* = path_depth(name)                   */
 };
 
 struct savename_entry {
@@ -244,8 +243,6 @@ void fprintf_encoded(FILE *fp, const cha
 _Bool decode(const char *ascii, char *bin);
 _Bool is_correct_path(const char *filename, const s8 start_type,
 		      const s8 pattern_type, const s8 end_type);
-_Bool file_matches_pattern(const char *filename, const char *filename_end,
-			   const char *pattern, const char *pattern_end);
 int string_compare(const void *a, const void *b);
 _Bool pathcmp(const struct path_info *a, const struct path_info *b);
 void fill_path_info(struct path_info *ptr);
