Index: tomoyo-realpath.patch
===================================================================
--- tomoyo-realpath.patch	(revision 1704)
+++ tomoyo-realpath.patch	(working copy)
@@ -15,13 +15,13 @@
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 Signed-off-by: Toshiharu Harada <haradats@nttdata.co.jp>
 ---
- security/tomoyo/realpath.c |  692 +++++++++++++++++++++++++++++++++++++++++++++
- security/tomoyo/realpath.h |   62 ++++
- 2 files changed, 754 insertions(+)
+ security/tomoyo/realpath.c |  571 +++++++++++++++++++++++++++++++++++++++++++++
+ security/tomoyo/realpath.h |   60 ++++
+ 2 files changed, 631 insertions(+)
 
 --- /dev/null
 +++ linux-next/security/tomoyo/realpath.c
-@@ -0,0 +1,692 @@
+@@ -0,0 +1,571 @@
 +/*
 + * security/tomoyo/realpath.c
 + *
@@ -41,164 +41,25 @@
 +#include "realpath.h"
 +
 +/**
-+ * get_absolute_path - Get the path of a dentry but ignores chroot'ed root.
++ * tmy_realpath_from_path2 - Returns realpath(3) of the given dentry but ignores chroot'ed root.
 + *
-+ * @dentry: Pointer to "struct dentry".
-+ * @vfsmnt: Pointer to "struct vfsmount".
-+ * @buffer: Pointer to buffer to return value in.
-+ * @buflen: Sizeof @buffer.
++ * @path:        Pointer to "struct path".
++ * @newname:     Pointer to buffer to return value in.
++ * @newname_len: Size of @newname.
 + *
-+ * Returns 0 on success, -ENOMEM otherwise.
++ * Returns 0 on success, negative value otherwise.
 + *
 + * If dentry is a directory, trailing '/' is appended.
 + * Characters out of 0x20 < c < 0x7F range are converted to
 + * \ooo style octal string.
 + * Character \ is converted to \\ string.
 + */
-+static int get_absolute_path(struct dentry *dentry, struct vfsmount *vfsmnt,
-+			     char *buffer, int buflen)
++int tmy_realpath_from_path2(struct path *path, char *newname, int newname_len)
 +{
-+	int error = -ENOMEM;
-+	char *start = buffer;
-+	char *end = buffer + buflen;
-+	bool is_dir = (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode));
-+
-+	/***** CRITICAL SECTION START *****/
-+	spin_lock(&dcache_lock);
-+	spin_lock(&vfsmount_lock);
-+
-+	if (buflen < 256)
-+		goto out;
-+
-+	*--end = '\0';
-+	buflen--;
-+
-+	for (;;) {
-+		struct dentry *parent;
-+
-+		if (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {
-+			/* Global root? */
-+			if (vfsmnt->mnt_parent == vfsmnt)
-+				break;
-+			dentry = vfsmnt->mnt_mountpoint;
-+			vfsmnt = vfsmnt->mnt_parent;
-+			continue;
-+		}
-+		if (is_dir) {
-+			is_dir = false;
-+			*--end = '/';
-+			buflen--;
-+		}
-+		parent = dentry->d_parent;
-+		{
-+			const char *sp = dentry->d_name.name;
-+			const char *cp = sp + dentry->d_name.len - 1;
-+			unsigned char c;
-+
-+			/*
-+			 * Exception: Use /proc/self/ rather than
-+			 * /proc/\$/ for current process.
-+			 */
-+			if (IS_ROOT(parent) && *sp > '0' && *sp <= '9' &&
-+			    parent->d_sb &&
-+			    parent->d_sb->s_magic == PROC_SUPER_MAGIC) {
-+				unsigned long pid;
-+				if (!strict_strtoul(sp, 10, &pid) &&
-+				    (pid_t) pid == current->tgid) {
-+					sp = "self";
-+					cp = sp + 3;
-+				}
-+			}
-+
-+			while (sp <= cp) {
-+				c = *(unsigned char *) cp;
-+				if (c == '\\') {
-+					buflen -= 2;
-+					if (buflen < 0)
-+						goto out;
-+					*--end = '\\';
-+					*--end = '\\';
-+				} else if (c > ' ' && c < 127) {
-+					if (--buflen < 0)
-+						goto out;
-+					*--end = (char) c;
-+				} else {
-+					buflen -= 4;
-+					if (buflen < 0)
-+						goto out;
-+					*--end = (c & 7) + '0';
-+					*--end = ((c >> 3) & 7) + '0';
-+					*--end = (c >> 6) + '0';
-+					*--end = '\\';
-+				}
-+				cp--;
-+			}
-+			if (--buflen < 0)
-+				goto out;
-+			*--end = '/';
-+		}
-+		dentry = parent;
-+	}
-+	if (*end == '/') {
-+		buflen++;
-+		end++;
-+	}
-+	{
-+		const char *sp = dentry->d_name.name;
-+		const char *cp = sp + dentry->d_name.len - 1;
-+		unsigned char c;
-+		while (sp <= cp) {
-+			c = *(unsigned char *) cp;
-+			if (c == '\\') {
-+				buflen -= 2;
-+				if (buflen < 0)
-+					goto out;
-+				*--end = '\\';
-+				*--end = '\\';
-+			} else if (c > ' ' && c < 127) {
-+				if (--buflen < 0)
-+					goto out;
-+				*--end = (char) c;
-+			} else {
-+				buflen -= 4;
-+				if (buflen < 0)
-+					goto out;
-+				*--end = (c & 7) + '0';
-+				*--end = ((c >> 3) & 7) + '0';
-+				*--end = (c >> 6) + '0';
-+				*--end = '\\';
-+			}
-+			cp--;
-+		}
-+	}
-+	/* Move the pathname to the top of the buffer. */
-+	memmove(start, end, strlen(end) + 1);
-+	error = 0;
-+out:
-+	spin_unlock(&vfsmount_lock);
-+	spin_unlock(&dcache_lock);
-+	/***** CRITICAL SECTION END *****/
-+	return error;
-+}
-+
-+/**
-+ * tmy_realpath_from_dentry2 - Returns realpath(3) of the given dentry but ignores chroot'ed root.
-+ *
-+ * @dentry:      Pointer to "struct dentry".
-+ * @mnt:         Pointer to "struct vfsmount".
-+ * @newname:     Pointer to buffer to return value in.
-+ * @newname_len: Size of @newname.
-+ *
-+ * Returns 0 on success, negative value otherwise.
-+ */
-+int tmy_realpath_from_dentry2(struct dentry *dentry, struct vfsmount *mnt,
-+			      char *newname, int newname_len)
-+{
 +	int error;
-+	struct dentry *d_dentry;
-+	struct vfsmount *d_mnt;
++	struct dentry *dentry = path->dentry;
 +
-+	if (!dentry || !mnt || !newname || newname_len <= 2048)
++	if (!dentry || !path->mnt || !newname || newname_len <= 2048)
 +		return -EINVAL;
 +	if (dentry->d_op && dentry->d_op->d_dname) {
 +		/* For "socket:[\$]" and "pipe:[\$]". */
@@ -236,12 +97,34 @@
 +			}
 +		}
 +		goto out;
++	} else {
++		unsigned char *sp;
++		error = -ENOMEM;
++		path_get(path);
++		sp = d_realpath(path, newname, newname_len);
++		path_put(path);
++		if (!IS_ERR(sp)) {
++			char *dp = newname;
++			newname += newname_len - 5;
++			while (dp <= newname) {
++				const unsigned char c = *(unsigned char *) sp++;
++				*dp++ = c;
++				if (c == '\\') {
++					*dp++ = '\\';
++				} else if (c > ' ' && c < 127) {
++					continue;
++				} else if (!c) {
++					error = 0;
++					break;
++				} else {
++					*dp++ = '\\';
++					*dp++ = (c >> 6) + '0';
++					*dp++ = ((c >> 3) & 7) + '0';
++					*dp++ = (c & 7) + '0';
++				}
++			}
++		}
 +	}
-+	d_dentry = dget(dentry);
-+	d_mnt = mntget(mnt);
-+	error = get_absolute_path(d_dentry, d_mnt, newname, newname_len);
-+	dput(d_dentry);
-+	mntput(d_mnt);
 + out:
 +	if (error)
 +		printk(KERN_WARNING "tmy_realpath: Pathname too long.\n");
@@ -249,22 +132,20 @@
 +}
 +
 +/**
-+ * tmy_realpath_from_dentry - Returns realpath(3) of the given pathname but ignores chroot'ed root.
++ * tmy_realpath_from_path - Returns realpath(3) of the given pathname but ignores chroot'ed root.
 + *
-+ * @dentry: Pointer to "struct dentry".
-+ * @mnt:    Pointer to "struct vfsmount".
++ * @path: Pointer to "struct path".
 + *
-+ * Returns the realpath of the given @dentry and @mnt on success,
-+ * NULL otherwise.
++ * Returns the realpath of the given @path on success, NULL otherwise.
 + *
 + * These functions use tmy_alloc(), so the caller must call tmy_free()
 + * if these functions didn't return NULL.
 + */
-+char *tmy_realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt)
++char *tmy_realpath_from_path(struct path *path)
 +{
 +	char *buf = tmy_alloc(sizeof(struct tmy_page_buffer));
 +
-+	if (buf && tmy_realpath_from_dentry2(dentry, mnt, buf,
++	if (buf && tmy_realpath_from_path2(path, buf,
 +					     TMY_MAX_PATHNAME_LEN - 1) == 0)
 +		return buf;
 +	tmy_free(buf);
@@ -283,8 +164,7 @@
 +	struct nameidata nd;
 +
 +	if (pathname && path_lookup(pathname, LOOKUP_FOLLOW, &nd) == 0) {
-+		char *buf = tmy_realpath_from_dentry(nd.path.dentry,
-+						     nd.path.mnt);
++		char *buf = tmy_realpath_from_path(&nd.path);
 +		path_put(&nd.path);
 +		return buf;
 +	}
@@ -303,8 +183,7 @@
 +	struct nameidata nd;
 +
 +	if (pathname && path_lookup(pathname, 0, &nd) == 0) {
-+		char *buf = tmy_realpath_from_dentry(nd.path.dentry,
-+						     nd.path.mnt);
++		char *buf = tmy_realpath_from_path(&nd.path);
 +		path_put(&nd.path);
 +		return buf;
 +	}
@@ -716,7 +595,7 @@
 +}
 --- /dev/null
 +++ linux-next/security/tomoyo/realpath.h
-@@ -0,0 +1,62 @@
+@@ -0,0 +1,60 @@
 +/*
 + * security/tomoyo/realpath.h
 + *
@@ -731,15 +610,13 @@
 +#ifndef _SECURITY_TOMOYO_REALPATH_H
 +#define _SECURITY_TOMOYO_REALPATH_H
 +
-+struct dentry;
-+struct vfsmount;
++struct path;
 +struct condition_list;
 +struct path_info;
 +struct tmy_io_buffer;
 +
 +/* Returns realpath(3) of the given pathname but ignores chroot'ed root. */
-+int tmy_realpath_from_dentry2(struct dentry *dentry, struct vfsmount *mnt,
-+			      char *newname, int newname_len);
++int tmy_realpath_from_path2(struct path *path, char *newname, int newname_len);
 +
 +/*
 + * Returns realpath(3) of the given pathname but ignores chroot'ed root.
@@ -750,7 +627,7 @@
 +/* Same with tmy_realpath() except that it doesn't follow the final symlink. */
 +char *tmy_realpath_nofollow(const char *pathname);
 +/* Same with tmy_realpath() except that the pathname is already solved. */
-+char *tmy_realpath_from_dentry(struct dentry *dentry, struct vfsmount *mnt);
++char *tmy_realpath_from_path(struct path *path);
 +/* Same with tmy_realpath() except that it uses struct ctl_table. */
 +char *sysctlpath_from_table(struct ctl_table *table);
 +
Index: tomoyo-hooks.patch
===================================================================
--- tomoyo-hooks.patch	(revision 1704)
+++ tomoyo-hooks.patch	(working copy)
@@ -4,13 +4,13 @@
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 Signed-off-by: Toshiharu Harada <haradats@nttdata.co.jp>
 ---
- security/tomoyo/tomoyo.c |  374 +++++++++++++++++++++++++++++++++++++++++++++++
- security/tomoyo/tomoyo.h |  108 +++++++++++++
- 2 files changed, 482 insertions(+)
+ security/tomoyo/tomoyo.c |  376 +++++++++++++++++++++++++++++++++++++++++++++++
+ security/tomoyo/tomoyo.h |  105 +++++++++++++
+ 2 files changed, 481 insertions(+)
 
 --- /dev/null
 +++ linux-next/security/tomoyo/tomoyo.c
-@@ -0,0 +1,374 @@
+@@ -0,0 +1,376 @@
 +/*
 + * security/tomoyo/tomoyo.c
 + *
@@ -79,8 +79,7 @@
 +	 * Read permission is checked against interpreters using next domain.
 +	 * '1' is the result of open_to_namei_flags(O_RDONLY).
 +	 */
-+	return tmy_check_open_permission(domain, bprm->file->f_path.dentry,
-+					 bprm->file->f_path.mnt, 1);
++	return tmy_check_open_permission(domain, &bprm->file->f_path, 1);
 +}
 +
 +static int tmy_sysctl(struct ctl_table *table, int op)
@@ -194,42 +193,46 @@
 +{
 +	return tmy_save_result(tmy_check_1path_perm(tmy_domain(),
 +						    TMY_TYPE_TRUNCATE_ACL,
-+						    path->dentry, path->mnt));
++						    path));
 +}
 +
 +static int tmy_path_unlink(struct path *parent, struct dentry *dentry)
 +{
++	struct path path = { parent->mnt, dentry };
 +	return tmy_save_result(tmy_check_1path_perm(tmy_domain(),
 +						    TMY_TYPE_UNLINK_ACL,
-+						    dentry, parent->mnt));
++						    &path));
 +}
 +
 +static int tmy_path_mkdir(struct path *parent, struct dentry *dentry, int mode)
 +{
++	struct path path = { parent->mnt, dentry };
 +	return tmy_save_result(tmy_check_1path_perm(tmy_domain(),
 +						    TMY_TYPE_MKDIR_ACL,
-+						    dentry, parent->mnt));
++						    &path));
 +}
 +
 +static int tmy_path_rmdir(struct path *parent, struct dentry *dentry)
 +{
++	struct path path = { parent->mnt, dentry };
 +	return tmy_save_result(tmy_check_1path_perm(tmy_domain(),
 +						    TMY_TYPE_RMDIR_ACL,
-+						    dentry, parent->mnt));
++						    &path));
 +}
 +
 +static int tmy_path_symlink(struct path *parent, struct dentry *dentry,
 +			    const char *old_name)
 +{
++	struct path path = { parent->mnt, dentry };
 +	return tmy_save_result(tmy_check_1path_perm(tmy_domain(),
 +						    TMY_TYPE_SYMLINK_ACL,
-+						    dentry, parent->mnt));
++						    &path));
 +}
 +
 +static int tmy_path_mknod(struct path *parent, struct dentry *dentry, int mode,
 +			  unsigned int dev)
 +{
-+	struct vfsmount *mnt = parent->mnt;
++	struct path path = { parent->mnt, dentry };
 +	int type = TMY_TYPE_CREATE_ACL;
 +
 +	switch (mode & S_IFMT) {
@@ -247,27 +250,27 @@
 +		break;
 +	}
 +	return tmy_save_result(tmy_check_1path_perm(tmy_domain(),
-+						    type, dentry, mnt));
++						    type, &path));
 +}
 +
 +static int tmy_path_link(struct dentry *old_dentry, struct path *new_dir,
 +			 struct dentry *new_dentry)
 +{
++	struct path path1 = { new_dir->mnt, old_dentry };
++	struct path path2 = { new_dir->mnt, new_dentry };
 +	return tmy_save_result(tmy_check_2path_perm(tmy_domain(),
 +						    TMY_TYPE_LINK_ACL,
-+						    old_dentry, new_dir->mnt,
-+						    new_dentry, new_dir->mnt));
++						    &path1, &path2));
 +}
 +
 +static int tmy_path_rename(struct path *old_parent, struct dentry *old_dentry,
 +			   struct path *new_parent, struct dentry *new_dentry)
 +{
++	struct path path1 = { old_parent->mnt, old_dentry };
++	struct path path2 = { new_parent->mnt, new_dentry };
 +	return tmy_save_result(tmy_check_2path_perm(tmy_domain(),
 +						    TMY_TYPE_RENAME_ACL,
-+						    old_dentry,
-+						    old_parent->mnt,
-+						    new_dentry,
-+						    new_parent->mnt));
++						    &path1, &path2));
 +}
 +
 +static int tmy_inode_link(struct dentry *old_dentry, struct inode *inode,
@@ -338,8 +341,7 @@
 +	/* Don't check read permission here if called from do_execve(). */
 +	if (current->in_execve)
 +		return 0;
-+	return tmy_check_open_permission(tmy_domain(), f->f_path.dentry,
-+					 f->f_path.mnt, flags);
++	return tmy_check_open_permission(tmy_domain(), &f->f_path, flags);
 +}
 +
 +static struct security_operations tomoyo_security_ops = {
@@ -387,7 +389,7 @@
 +security_initcall(tmy_init);
 --- /dev/null
 +++ linux-next/security/tomoyo/tomoyo.h
-@@ -0,0 +1,108 @@
+@@ -0,0 +1,105 @@
 +/*
 + * security/tomoyo/tomoyo.h
 + *
@@ -403,8 +405,7 @@
 +#define _SECURITY_TOMOYO_TOMOYO_H
 +
 +struct path_info;
-+struct dentry;
-+struct vfsmount;
++struct path;
 +struct inode;
 +struct linux_binprm;
 +struct pt_regs;
@@ -415,14 +416,12 @@
 +int tmy_check_exec_perm(struct domain_info *domain,
 +			const struct path_info *filename,
 +			struct tmy_page_buffer *buf);
-+int tmy_check_open_permission(struct domain_info *domain,
-+			      struct dentry *dentry, struct vfsmount *mnt,
++int tmy_check_open_permission(struct domain_info *domain, struct path *path,
 +			      const int flag);
 +int tmy_check_1path_perm(struct domain_info *domain, const u8 operation,
-+			 struct dentry *dentry, struct vfsmount *mnt);
++			 struct path *path);
 +int tmy_check_2path_perm(struct domain_info *domain, const u8 operation,
-+			 struct dentry *dentry1, struct vfsmount *mnt1,
-+			 struct dentry *dentry2, struct vfsmount *mnt2);
++			 struct path *path1, struct path *path2);
 +int tmy_check_rewrite_permission(struct domain_info *domain,
 +				 struct file *filp);
 +int tmy_find_next_domain(struct linux_binprm *bprm,
Index: tomoyo-file-restriction-part.patch
===================================================================
--- tomoyo-file-restriction-part.patch	(revision 1704)
+++ tomoyo-file-restriction-part.patch	(working copy)
@@ -6,12 +6,12 @@
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 Signed-off-by: Toshiharu Harada <haradats@nttdata.co.jp>
 ---
- security/tomoyo/file.c | 1240 +++++++++++++++++++++++++++++++++++++++++++++++++
- 1 file changed, 1240 insertions(+)
+ security/tomoyo/file.c | 1232 +++++++++++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 1232 insertions(+)
 
 --- /dev/null
 +++ linux-next/security/tomoyo/file.c
-@@ -0,0 +1,1240 @@
+@@ -0,0 +1,1232 @@
 +/*
 + * security/tomoyo/file.c
 + *
@@ -121,13 +121,11 @@
 +/**
 + * tmy_get_path - Get realpath.
 + *
-+ * @dentry: Pointer to "struct dentry".
-+ * @mnt:    Pointer to "struct vfsmount".
++ * @path: Pointer to "struct path".
 + *
 + * Returns pointer to "struct path_info" on success, NULL otherwise.
 + */
-+static struct path_info *tmy_get_path(struct dentry *dentry,
-+				      struct vfsmount *mnt)
++static struct path_info *tmy_get_path(struct path *path)
 +{
 +	int error;
 +	struct path_info_with_data *buf = tmy_alloc(sizeof(*buf));
@@ -135,8 +133,8 @@
 +	if (!buf)
 +		return NULL;
 +	/* Preserve one byte for appending "/". */
-+	error = tmy_realpath_from_dentry2(dentry, mnt, buf->body,
-+					  sizeof(buf->body) - 2);
++	error = tmy_realpath_from_path2(path, buf->body,
++					sizeof(buf->body) - 2);
 +	if (!error) {
 +		buf->head.name = buf->body;
 +		tmy_fill_path_info(&buf->head);
@@ -1062,15 +1060,13 @@
 + * tmy_check_open_permission - Check permission for "read" and "write".
 + *
 + * @domain: Pointer to "struct domain_info".
-+ * @dentry: Pointer to "struct dentry".
-+ * @mnt:    Pointer to "struct vfsmount".
++ * @path:   Pointer to "struct path".
 + * @flag:   Flags for open().
 + *
 + * Returns 0 on success, negative value otherwise.
 + */
 +int tmy_check_open_permission(struct domain_info *domain,
-+			      struct dentry *dentry, struct vfsmount *mnt,
-+			      const int flag)
++			      struct path *path, const int flag)
 +{
 +	const u8 acc_mode = ACC_MODE(flag);
 +	int error = -ENOMEM;
@@ -1078,17 +1074,17 @@
 +	const u8 mode = tmy_check_flags(domain, TMY_TOMOYO_MAC_FOR_FILE);
 +	const bool is_enforce = (mode == 3);
 +
-+	if (!mode || !mnt)
++	if (!mode || !path->mnt)
 +		return 0;
 +	if (acc_mode == 0)
 +		return 0;
-+	if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode))
++	if (path->dentry->d_inode && S_ISDIR(path->dentry->d_inode->i_mode))
 +		/*
 +		 * I don't check directories here because mkdir() and rmdir()
 +		 * don't call me.
 +		 */
 +		return 0;
-+	buf = tmy_get_path(dentry, mnt);
++	buf = tmy_get_path(path);
 +	if (!buf)
 +		goto out;
 +	error = 0;
@@ -1122,22 +1118,21 @@
 + *
 + * @domain:    Pointer to "struct domain_info".
 + * @operation: Type of operation.
-+ * @dentry:    Pointer to "struct dentry".
-+ * @mnt:       Pointer to "struct vfsmount".
++ * @path:      Pointer to "struct path".
 + *
 + * Returns 0 on success, negative value otherwise.
 + */
 +int tmy_check_1path_perm(struct domain_info *domain, const u8 operation,
-+			 struct dentry *dentry, struct vfsmount *mnt)
++			 struct path *path)
 +{
 +	int error = -ENOMEM;
 +	struct path_info *buf;
 +	const u8 mode = tmy_check_flags(domain, TMY_TOMOYO_MAC_FOR_FILE);
 +	const bool is_enforce = (mode == 3);
 +
-+	if (!mode || !mnt)
++	if (!mode || !path->mnt)
 +		return 0;
-+	buf = tmy_get_path(dentry, mnt);
++	buf = tmy_get_path(path);
 +	if (!buf)
 +		goto out;
 +	switch (operation) {
@@ -1174,7 +1169,7 @@
 +
 +	if (!mode || !filp->f_path.mnt)
 +		return 0;
-+	buf = tmy_get_path(filp->f_path.dentry, filp->f_path.mnt);
++	buf = tmy_get_path(&filp->f_path);
 +	if (!buf)
 +		goto out;
 +	if (!is_no_rewrite_file(buf)) {
@@ -1195,16 +1190,13 @@
 + *
 + * @domain:    Pointer to "struct domain_info".
 + * @operation: Type of operation.
-+ * @dentry1:   Pointer to "struct dentry".
-+ * @mnt1:      Pointer to "struct vfsmount".
-+ * @dentry2:   Pointer to "struct dentry".
-+ * @mnt2:      Pointer to "struct vfsmount".
++ * @path1:      Pointer to "struct path".
++ * @path2:      Pointer to "struct path".
 + *
 + * Returns 0 on success, negative value otherwise.
 + */
 +int tmy_check_2path_perm(struct domain_info * const domain, const u8 operation,
-+			 struct dentry *dentry1, struct vfsmount *mnt1,
-+			 struct dentry *dentry2, struct vfsmount *mnt2)
++			 struct path *path1, struct path *path2)
 +{
 +	int error = -ENOMEM;
 +	struct path_info *buf1, *buf2;
@@ -1212,15 +1204,15 @@
 +	const bool is_enforce = (mode == 3);
 +	const char *msg;
 +
-+	if (!mode || !mnt1 || !mnt2)
++	if (!mode || !path1->mnt || !path2->mnt)
 +		return 0;
-+	buf1 = tmy_get_path(dentry1, mnt1);
-+	buf2 = tmy_get_path(dentry2, mnt2);
++	buf1 = tmy_get_path(path1);
++	buf2 = tmy_get_path(path2);
 +	if (!buf1 || !buf2)
 +		goto out;
-+	if (operation == TMY_TYPE_RENAME_ACL) {
-+		/* TYPE_LINK_ACL can't reach here for directory. */
-+		if (dentry1->d_inode && S_ISDIR(dentry1->d_inode->i_mode)) {
++	{
++		struct dentry *dentry = path1->dentry;
++		if (dentry->d_inode && S_ISDIR(dentry->d_inode->i_mode)) {
 +			/* tmy_get_path() preserves space for appending "/." */
 +			if (!buf1->is_dir) {
 +				strcat((char *) buf1->name, "/");
Index: series
===================================================================
--- series	(revision 1704)
+++ series	(working copy)
@@ -7,3 +7,4 @@
 tomoyo-domain-transition-part.patch
 tomoyo-hooks.patch
 tomoyo-makefile.patch
+introduce-d_realpath.patch
Index: tomoyo-common.patch
===================================================================
--- tomoyo-common.patch	(revision 1704)
+++ tomoyo-common.patch	(working copy)
@@ -6,13 +6,13 @@
 Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
 Signed-off-by: Toshiharu Harada <haradats@nttdata.co.jp>
 ---
- security/tomoyo/common.c | 2210 +++++++++++++++++++++++++++++++++++++++++++++++
+ security/tomoyo/common.c | 2209 +++++++++++++++++++++++++++++++++++++++++++++++
  security/tomoyo/common.h |  319 ++++++
- 2 files changed, 2529 insertions(+)
+ 2 files changed, 2528 insertions(+)
 
 --- /dev/null
 +++ linux-next/security/tomoyo/common.c
-@@ -0,0 +1,2210 @@
+@@ -0,0 +1,2209 @@
 +/*
 + * security/tomoyo/common.c
 + *
@@ -746,8 +746,7 @@
 +	down_read(&mm->mmap_sem);
 +	for (vma = mm->mmap; vma; vma = vma->vm_next) {
 +		if ((vma->vm_flags & VM_EXECUTABLE) && vma->vm_file) {
-+			struct path *path = &vma->vm_file->f_path;
-+			cp = tmy_realpath_from_dentry(path->dentry, path->mnt);
++			cp = tmy_realpath_from_path(&vma->vm_file->f_path);
 +			break;
 +		}
 +	}
