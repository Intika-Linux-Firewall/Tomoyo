Subject: Add hooks for notifying of start/finish of an execve operation.

This patch adds two hooks for notifying current proces of an execve operation
is about to start and finish.

Since TOMOYO Linux's specification requires only execute permission to execute
a program so that it can allow opening the file for execute but disallow
opening the file for reading, it wants a hook for distinguishing opening
the file by open(2) and execve(2).

Since TOMOYO Linux changes internal state before an execve operation reaches to
the point of no return, it needs a hook for reverting changes when the execve
operation failed.

security_start_execve() hook allows TOMOYO Linux to understand that the
subsequent open is for executing a program, and security_finish_execve() hook
allows TOMOYO Linux to revert changes when the execve operation failed.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 fs/compat.c              |    4 ++++
 fs/exec.c                |    4 ++++
 include/linux/security.h |   20 ++++++++++++++++++++
 security/capability.c    |   10 ++++++++++
 security/security.c      |   10 ++++++++++
 5 files changed, 48 insertions(+)

--- linux-2.6.27-rc7-mm1.orig/fs/compat.c
+++ linux-2.6.27-rc7-mm1/fs/compat.c
@@ -1397,6 +1397,8 @@ int compat_do_execve(char * filename,
 	if (retval < 0)
 		goto out_free;
 
+	security_start_execve();
+
 	retval = -ENOMEM;
 	bprm->cred = prepare_exec_creds();
 	if (!bprm->cred)
@@ -1448,6 +1450,7 @@ int compat_do_execve(char * filename,
 		goto out;
 
 	/* execve succeeded */
+	security_finish_execve();
 	mutex_unlock(&current->cred_exec_mutex);
 	acct_update_integrals(current);
 	free_bprm(bprm);
@@ -1464,6 +1467,7 @@ out_file:
 	}
 
 out_unlock:
+	security_finish_execve();
 	mutex_unlock(&current->cred_exec_mutex);
 
 out_free:
--- linux-2.6.27-rc7-mm1.orig/fs/exec.c
+++ linux-2.6.27-rc7-mm1/fs/exec.c
@@ -1302,6 +1302,8 @@ int do_execve(char * filename,
 	if (retval < 0)
 		goto out_free;
 
+	security_start_execve();
+
 	retval = -ENOMEM;
 	bprm->cred = prepare_exec_creds();
 	if (!bprm->cred)
@@ -1354,6 +1356,7 @@ int do_execve(char * filename,
 		goto out;
 
 	/* execve succeeded */
+	security_finish_execve();
 	mutex_unlock(&current->cred_exec_mutex);
 	acct_update_integrals(current);
 	free_bprm(bprm);
@@ -1372,6 +1375,7 @@ out_file:
 	}
 
 out_unlock:
+	security_finish_execve();
 	mutex_unlock(&current->cred_exec_mutex);
 
 out_free:
--- linux-2.6.27-rc7-mm1.orig/include/linux/security.h
+++ linux-2.6.27-rc7-mm1/include/linux/security.h
@@ -192,6 +192,14 @@ static inline void security_free_mnt_opt
  *	on the initial stack to the ELF interpreter to indicate whether libc
  *	should enable secure mode.
  *	@bprm contains the linux_binprm structure.
+ * @start_execve:
+ *	Notify current process of an execve operation is about to start.
+ *	This is called immediately after obtaining current->cred_exec_mutex
+ *	mutex.
+ * @finish_execve:
+ *	Notify current process of an execve operation is about to finish.
+ *	This is called immediately before releasing current->cred_exec_mutex
+ *	mutex.
  *
  * Security hooks for filesystem operations.
  *
@@ -1352,6 +1360,8 @@ struct security_operations {
 	int (*settime) (struct timespec *ts, struct timezone *tz);
 	int (*vm_enough_memory) (struct mm_struct *mm, long pages);
 
+	void (*start_execve) (void);
+	void (*finish_execve) (void);
 	int (*bprm_set_creds) (struct linux_binprm *bprm);
 	int (*bprm_check_security) (struct linux_binprm *bprm);
 	int (*bprm_secureexec) (struct linux_binprm *bprm);
@@ -1632,6 +1642,8 @@ int security_syslog(int type);
 int security_settime(struct timespec *ts, struct timezone *tz);
 int security_vm_enough_memory(long pages);
 int security_vm_enough_memory_mm(struct mm_struct *mm, long pages);
+void security_start_execve(void);
+void security_finish_execve(void);
 int security_bprm_set_creds(struct linux_binprm *bprm);
 int security_bprm_check(struct linux_binprm *bprm);
 void security_bprm_committing_creds(struct linux_binprm *bprm);
@@ -1879,6 +1891,14 @@ static inline int security_vm_enough_mem
 	return cap_vm_enough_memory(mm, pages);
 }
 
+static inline void security_start_execve(void)
+{
+}
+
+static inline void security_finish_execve(void)
+{
+}
+
 static inline int security_bprm_set_creds(struct linux_binprm *bprm)
 {
 	return cap_bprm_set_creds(bprm);
--- linux-2.6.27-rc7-mm1.orig/security/capability.c
+++ linux-2.6.27-rc7-mm1/security/capability.c
@@ -32,6 +32,14 @@ static int cap_quota_on(struct dentry *d
 	return 0;
 }
 
+static void cap_start_execve(void)
+{
+}
+
+static void cap_finish_execve(void)
+{
+}
+
 static int cap_bprm_check_security (struct linux_binprm *bprm)
 {
 	return 0;
@@ -877,6 +885,8 @@ void security_fixup_ops(struct security_
 	set_to_cap_if_null(ops, syslog);
 	set_to_cap_if_null(ops, settime);
 	set_to_cap_if_null(ops, vm_enough_memory);
+	set_to_cap_if_null(ops, start_execve);
+	set_to_cap_if_null(ops, finish_execve);
 	set_to_cap_if_null(ops, bprm_set_creds);
 	set_to_cap_if_null(ops, bprm_committing_creds);
 	set_to_cap_if_null(ops, bprm_committed_creds);
--- linux-2.6.27-rc7-mm1.orig/security/security.c
+++ linux-2.6.27-rc7-mm1/security/security.c
@@ -199,6 +199,16 @@ int security_vm_enough_memory_mm(struct 
 	return security_ops->vm_enough_memory(mm, pages);
 }
 
+void security_start_execve(void)
+{
+	security_ops->start_execve();
+}
+
+void security_finish_execve(void)
+{
+	security_ops->finish_execve();
+}
+
 int security_bprm_set_creds(struct linux_binprm *bprm)
 {
 	return security_ops->bprm_set_creds(bprm);
