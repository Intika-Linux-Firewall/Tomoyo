[PATCH] TOMOYO: Split file access control functions by type of parameters.

Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.h |   50 +--
 security/tomoyo/file.c   |  653 ++++++++++++++++++++++++++++++++++++++++++-----
 2 files changed, 614 insertions(+), 89 deletions(-)

--- security-testing-2.6.orig/security/tomoyo/common.h
+++ security-testing-2.6/security/tomoyo/common.h
@@ -86,12 +86,14 @@ enum tomoyo_acl_entry_type_index {
 /* Index numbers for File Controls. */
 
 /*
- * TYPE_READ_WRITE_ACL is special. TYPE_READ_WRITE_ACL is automatically set
- * if both TYPE_READ_ACL and TYPE_WRITE_ACL are set. Both TYPE_READ_ACL and
- * TYPE_WRITE_ACL are automatically set if TYPE_READ_WRITE_ACL is set.
- * TYPE_READ_WRITE_ACL is automatically cleared if either TYPE_READ_ACL or
- * TYPE_WRITE_ACL is cleared. Both TYPE_READ_ACL and TYPE_WRITE_ACL are
- * automatically cleared if TYPE_READ_WRITE_ACL is cleared.
+ * TOMOYO_TYPE_READ_WRITE is special. TOMOYO_TYPE_READ_WRITE is automatically
+ * set if both TOMOYO_TYPE_READ and TOMOYO_TYPE_WRITE are set.
+ * Both TOMOYO_TYPE_READ and TOMOYO_TYPE_WRITE are automatically set if
+ * TOMOYO_TYPE_READ_WRITE is set.
+ * TOMOYO_TYPE_READ_WRITE is automatically cleared if either TOMOYO_TYPE_READ
+ * or TOMOYO_TYPE_WRITE is cleared.
+ * Both TOMOYO_TYPE_READ and TOMOYO_TYPE_WRITE are automatically cleared if
+ * TOMOYO_TYPE_READ_WRITE is cleared.
  */
 
 enum tomoyo_path_acl_index {
@@ -99,27 +101,23 @@ enum tomoyo_path_acl_index {
 	TOMOYO_TYPE_EXECUTE,
 	TOMOYO_TYPE_READ,
 	TOMOYO_TYPE_WRITE,
-	TOMOYO_TYPE_CREATE,
 	TOMOYO_TYPE_UNLINK,
-	TOMOYO_TYPE_MKDIR,
 	TOMOYO_TYPE_RMDIR,
-	TOMOYO_TYPE_MKFIFO,
-	TOMOYO_TYPE_MKSOCK,
-	TOMOYO_TYPE_MKBLOCK,
-	TOMOYO_TYPE_MKCHAR,
 	TOMOYO_TYPE_TRUNCATE,
 	TOMOYO_TYPE_SYMLINK,
 	TOMOYO_TYPE_REWRITE,
-	TOMOYO_TYPE_IOCTL,
-	TOMOYO_TYPE_CHMOD,
-	TOMOYO_TYPE_CHOWN,
-	TOMOYO_TYPE_CHGRP,
 	TOMOYO_TYPE_CHROOT,
 	TOMOYO_TYPE_MOUNT,
 	TOMOYO_TYPE_UMOUNT,
 	TOMOYO_MAX_PATH_OPERATION
 };
 
+enum tomoyo_path_number3_acl_index {
+	TOMOYO_TYPE_MKBLOCK,
+	TOMOYO_TYPE_MKCHAR,
+	TOMOYO_MAX_PATH_NUMBER3_OPERATION
+};
+
 enum tomoyo_path2_acl_index {
 	TOMOYO_TYPE_LINK,
 	TOMOYO_TYPE_RENAME,
@@ -127,16 +125,16 @@ enum tomoyo_path2_acl_index {
 	TOMOYO_MAX_PATH2_OPERATION
 };
 
-enum tomoyo_securityfs_interface_index {
-	TOMOYO_DOMAINPOLICY,
-	TOMOYO_EXCEPTIONPOLICY,
-	TOMOYO_DOMAIN_STATUS,
-	TOMOYO_PROCESS_STATUS,
-	TOMOYO_MEMINFO,
-	TOMOYO_SELFDOMAIN,
-	TOMOYO_VERSION,
-	TOMOYO_PROFILE,
-	TOMOYO_MANAGER
+enum tomoyo_path_number_acl_index {
+	TOMOYO_TYPE_CREATE,
+	TOMOYO_TYPE_MKDIR,
+	TOMOYO_TYPE_MKFIFO,
+	TOMOYO_TYPE_MKSOCK,
+	TOMOYO_TYPE_IOCTL,
+	TOMOYO_TYPE_CHMOD,
+	TOMOYO_TYPE_CHOWN,
+	TOMOYO_TYPE_CHGRP,
+	TOMOYO_MAX_PATH_NUMBER_OPERATION
 };
 
 /********** Structure definitions. **********/
--- security-testing-2.6.orig/security/tomoyo/file.c
+++ security-testing-2.6/security/tomoyo/file.c
@@ -11,39 +11,49 @@
 
 #include "common.h"
 
-/* Keyword array for single path operations. */
+/* Keyword array for operations with one pathname. */
 static const char *tomoyo_path_keyword[TOMOYO_MAX_PATH_OPERATION] = {
 	[TOMOYO_TYPE_READ_WRITE] = "read/write",
 	[TOMOYO_TYPE_EXECUTE]    = "execute",
 	[TOMOYO_TYPE_READ]       = "read",
 	[TOMOYO_TYPE_WRITE]      = "write",
-	[TOMOYO_TYPE_CREATE]     = "create",
 	[TOMOYO_TYPE_UNLINK]     = "unlink",
-	[TOMOYO_TYPE_MKDIR]      = "mkdir",
 	[TOMOYO_TYPE_RMDIR]      = "rmdir",
-	[TOMOYO_TYPE_MKFIFO]     = "mkfifo",
-	[TOMOYO_TYPE_MKSOCK]     = "mksock",
-	[TOMOYO_TYPE_MKBLOCK]    = "mkblock",
-	[TOMOYO_TYPE_MKCHAR]     = "mkchar",
 	[TOMOYO_TYPE_TRUNCATE]   = "truncate",
 	[TOMOYO_TYPE_SYMLINK]    = "symlink",
 	[TOMOYO_TYPE_REWRITE]    = "rewrite",
-	[TOMOYO_TYPE_IOCTL]      = "ioctl",
-	[TOMOYO_TYPE_CHMOD]      = "chmod",
-	[TOMOYO_TYPE_CHOWN]      = "chown",
-	[TOMOYO_TYPE_CHGRP]      = "chgrp",
 	[TOMOYO_TYPE_CHROOT]     = "chroot",
 	[TOMOYO_TYPE_MOUNT]      = "mount",
 	[TOMOYO_TYPE_UMOUNT]     = "unmount",
 };
 
-/* Keyword array for double path operations. */
+/* Keyword array for operations with one pathname and three numbers. */
+static const char *tomoyo_path_number3_keyword
+[TOMOYO_MAX_PATH_NUMBER3_OPERATION] = {
+	[TOMOYO_TYPE_MKBLOCK]    = "mkblock",
+	[TOMOYO_TYPE_MKCHAR]     = "mkchar",
+};
+
+/* Keyword array for operations with two pathnames. */
 static const char *tomoyo_path2_keyword[TOMOYO_MAX_PATH2_OPERATION] = {
-	[TOMOYO_TYPE_LINK]    = "link",
-	[TOMOYO_TYPE_RENAME]  = "rename",
+	[TOMOYO_TYPE_LINK]       = "link",
+	[TOMOYO_TYPE_RENAME]     = "rename",
 	[TOMOYO_TYPE_PIVOT_ROOT] = "pivot_root",
 };
 
+/* Keyword array for operations with one pathname and one number. */
+static const char *tomoyo_path_number_keyword
+[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {
+	[TOMOYO_TYPE_CREATE]     = "create",
+	[TOMOYO_TYPE_MKDIR]      = "mkdir",
+	[TOMOYO_TYPE_MKFIFO]     = "mkfifo",
+	[TOMOYO_TYPE_MKSOCK]     = "mksock",
+	[TOMOYO_TYPE_IOCTL]      = "ioctl",
+	[TOMOYO_TYPE_CHMOD]      = "chmod",
+	[TOMOYO_TYPE_CHOWN]      = "chown",
+	[TOMOYO_TYPE_CHGRP]      = "chgrp",
+};
+
 void tomoyo_put_name_union(struct tomoyo_name_union *ptr)
 {
 	if (!ptr)
@@ -103,6 +113,19 @@ const char *tomoyo_path2keyword(const u8
 }
 
 /**
+ * tomoyo_path_number32keyword - Get the name of path/number/number/number operations.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of path/number/number/number operation.
+ */
+const char *tomoyo_path_number32keyword(const u8 operation)
+{
+	return (operation < TOMOYO_MAX_PATH_NUMBER3_OPERATION)
+		? tomoyo_path_number3_keyword[operation] : NULL;
+}
+
+/**
  * tomoyo_path22keyword - Get the name of double path operation.
  *
  * @operation: Type of operation.
@@ -116,6 +139,19 @@ const char *tomoyo_path22keyword(const u
 }
 
 /**
+ * tomoyo_path_number2keyword - Get the name of path/number operations.
+ *
+ * @operation: Type of operation.
+ *
+ * Returns the name of path/number operation.
+ */
+const char *tomoyo_path_number2keyword(const u8 operation)
+{
+	return (operation < TOMOYO_MAX_PATH_NUMBER_OPERATION)
+		? tomoyo_path_number_keyword[operation] : NULL;
+}
+
+/**
  * tomoyo_strendswith - Check whether the token ends with the given token.
  *
  * @name: The token to check.
@@ -775,54 +811,6 @@ static int tomoyo_check_file_perm2(struc
 }
 
 /**
- * tomoyo_write_file_policy - Update file related list.
- *
- * @data:      String to parse.
- * @domain:    Pointer to "struct tomoyo_domain_info".
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds tomoyo_read_lock().
- */
-int tomoyo_write_file_policy(char *data, struct tomoyo_domain_info *domain,
-			     const bool is_delete)
-{
-	char *filename = strchr(data, ' ');
-	char *filename2;
-	unsigned int perm;
-	u8 type;
-
-	if (!filename)
-		return -EINVAL;
-	*filename++ = '\0';
-	if (sscanf(data, "%u", &perm) == 1)
-		return tomoyo_update_file_acl(filename, (u8) perm, domain,
-					      is_delete);
-	if (strncmp(data, "allow_", 6))
-		goto out;
-	data += 6;
-	for (type = 0; type < TOMOYO_MAX_PATH_OPERATION; type++) {
-		if (strcmp(data, tomoyo_path_keyword[type]))
-			continue;
-		return tomoyo_update_path_acl(type, filename, domain,
-					      is_delete);
-	}
-	filename2 = strchr(filename, ' ');
-	if (!filename2)
-		goto out;
-	*filename2++ = '\0';
-	for (type = 0; type < TOMOYO_MAX_PATH2_OPERATION; type++) {
-		if (strcmp(data, tomoyo_path2_keyword[type]))
-			continue;
-		return tomoyo_update_path2_acl(type, filename, filename2,
-					       domain, is_delete);
-	}
- out:
-	return -EINVAL;
-}
-
-/**
  * tomoyo_update_path_acl - Update "struct tomoyo_path_acl" list.
  *
  * @type:      Type of operation.
@@ -901,6 +889,80 @@ static int tomoyo_update_path_acl(const 
 }
 
 /**
+ * tomoyo_update_path_number3_acl - Update "struct tomoyo_path_number3_acl" list.
+ *
+ * @type:      Type of operation.
+ * @filename:  Filename.
+ * @mode:      Create mode.
+ * @major:     Device major number.
+ * @minor:     Device minor number.
+ * @domain:    Pointer to "struct tomoyo_domain_info".
+ * @condition: Pointer to "struct tomoyo_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static inline int tomoyo_update_path_number3_acl(const u8 type,
+					      const char *filename, char *mode,
+					      char *major, char *minor,
+					      struct tomoyo_domain_info * const
+					      domain,
+					      struct tomoyo_condition *condition,
+					      const bool is_delete)
+{
+	const u8 perm = 1 << type;
+	struct tomoyo_acl_info *ptr;
+	struct tomoyo_path_number3_acl e = {
+		.head.type = TOMOYO_TYPE_PATH_NUMBER3_ACL,
+		.head.cond = condition,
+		.perm = perm
+	};
+	struct tomoyo_path_number3_acl *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!tomoyo_parse_name_union(filename, &e.name) ||
+	    !tomoyo_parse_number_union(mode, &e.mode) ||
+	    !tomoyo_parse_number_union(major, &e.major) ||
+	    !tomoyo_parse_number_union(minor, &e.minor))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&tomoyo_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct tomoyo_path_number3_acl *acl =
+			container_of(ptr, struct tomoyo_path_number3_acl, head);
+		if (ptr->type != TOMOYO_TYPE_PATH_NUMBER3_ACL ||
+		    ptr->cond != condition ||
+		    tomoyo_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~perm;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= perm;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && tomoyo_commit_ok(entry, &e, sizeof(e))) {
+		tomoyo_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&tomoyo_policy_lock);
+ out:
+	tomoyo_put_name_union(&e.name);
+	tomoyo_put_number_union(&e.mode);
+	tomoyo_put_number_union(&e.major);
+	tomoyo_put_number_union(&e.minor);
+	kfree(entry);
+	return error;
+}
+
+/**
  * tomoyo_update_path2_acl - Update "struct tomoyo_path2_acl" list.
  *
  * @type:      Type of operation.
@@ -983,6 +1045,51 @@ static int tomoyo_path_acl(struct tomoyo
 }
 
 /**
+ * tomoyo_path_number3_acl - Check permission for path/number/number/number operation.
+ *
+ * @r:        Pointer to "struct tomoyo_request_info".
+ * @filename: Filename to check.
+ * @perm:     Permission.
+ * @mode:     Create mode.
+ * @major:    Device major number.
+ * @minor:    Device minor number.
+ *
+ * Returns 0 on success, -EPERM otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+static int tomoyo_path_number3_acl(struct tomoyo_request_info *r,
+				   const struct tomoyo_path_info *filename,
+				   const u16 perm, const unsigned int mode,
+				   const unsigned int major,
+				   const unsigned int minor)
+{
+	struct tomoyo_domain_info *domain = r->domain;
+	struct tomoyo_acl_info *ptr;
+	int error = -EPERM;
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct tomoyo_path_number3_acl *acl;
+		if (ptr->is_deleted || ptr->type != TOMOYO_TYPE_PATH_NUMBER3_ACL)
+			continue;
+		acl = container_of(ptr, struct tomoyo_path_number3_acl, head);
+		if (!tomoyo_compare_number_union(mode, &acl->mode))
+			continue;
+		if (!tomoyo_compare_number_union(major, &acl->major))
+			continue;
+		if (!tomoyo_compare_number_union(minor, &acl->minor))
+			continue;
+		if (!(acl->perm & perm) || !tomoyo_condition(r, ptr))
+			continue;
+		if (!tomoyo_compare_name_union(filename, &acl->name))
+			continue;
+		r->cond = ptr->cond;
+		error = 0;
+		break;
+	}
+	return error;
+}
+
+/**
  * tomoyo_path2_acl - Check permission for double path operation.
  *
  * @domain:    Pointer to "struct tomoyo_domain_info".
@@ -1075,6 +1182,113 @@ static int tomoyo_path_permission2(struc
 }
 
 /**
+ * tomoyo_path_number_perm2 - Check permission for "create", "mkdir", "mkfifo", "mksock", "ioctl", "chmod", "chown", "chgrp".
+ *
+ * @r:        Pointer to "strct tomoyo_request_info".
+ * @filename: Filename to check.
+ * @number:   Number.
+ *
+ * Returns 0 on success, 1 on retry, negative value otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+static int tomoyo_path_number_perm2(struct tomoyo_request_info *r,
+				    const u8 type,
+				    const struct tomoyo_path_info *filename,
+				    const unsigned long number)
+{
+	char buffer[64];
+	int error;
+	u8 radix;
+	const char *msg = tomoyo_path_number2keyword(type);
+	if (!filename)
+		return 0;
+	switch (type) {
+	case TOMOYO_TYPE_CREATE:
+	case TOMOYO_TYPE_MKDIR:
+	case TOMOYO_TYPE_MKFIFO:
+	case TOMOYO_TYPE_MKSOCK:
+	case TOMOYO_TYPE_CHMOD:
+		radix = TOMOYO_VALUE_TYPE_OCTAL;
+		break;
+	case TOMOYO_TYPE_IOCTL:
+		radix = TOMOYO_VALUE_TYPE_HEXADECIMAL;
+		break;
+	default:
+		radix = TOMOYO_VALUE_TYPE_DECIMAL;
+		break;
+	}
+	tomoyo_print_ulong(buffer, sizeof(buffer), number, radix);
+	do {
+		error = tomoyo_path_number_acl(r, type, filename, number);
+		tomoyo_audit_path_number_log(r, msg, filename->name, buffer,
+					  !error);
+		if (!error)
+			return 0;
+		error = tomoyo_supervisor(r, "allow_%s %s %s\n", msg,
+				       tomoyo_file_pattern(filename), buffer);
+	} while (error == 1);
+	if (r->mode != TOMOYO_CONFIG_ENFORCING)
+		error = 0;
+	return error;
+}
+
+/**
+ * tomoyo_path_number_perm - Check permission for "create", "mkdir", "mkfifo", "mksock", "ioctl", "chmod", "chown", "chgrp".
+ *
+ * @type:   Type of operation.
+ * @dir:    Pointer to "struct inode". May be NULL.
+ * @dentry: Pointer to "struct dentry".
+ * @vfsmnt: Pointer to "struct vfsmount".
+ * @number: Number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_path_number_perm(const u8 type, struct inode *dir,
+				   struct dentry *dentry,
+				   struct vfsmount *vfsmnt,
+				   unsigned long number)
+{
+	struct tomoyo_request_info r;
+	int error = 0;
+	struct tomoyo_path_info buf;
+	int idx;
+	if (!vfsmnt || !dentry)
+		return 0;
+	buf.name = NULL;
+	idx = tomoyo_read_lock();
+	if (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])
+	    == TOMOYO_CONFIG_DISABLED)
+		goto out;
+	switch (type) {
+	case TOMOYO_TYPE_CREATE:
+		error = tomoyo_pre_vfs_create(dir, dentry);
+		break;
+	case TOMOYO_TYPE_MKDIR:
+		error = tomoyo_pre_vfs_mkdir(dir, dentry);
+		break;
+	case TOMOYO_TYPE_MKFIFO:
+	case TOMOYO_TYPE_MKSOCK:
+		error = tomoyo_pre_vfs_mknod(dir, dentry);
+		break;
+	}
+	if (error)
+		goto out;
+	error = -ENOMEM;
+	if (!tomoyo_get_realpath(&buf, dentry, vfsmnt))
+		goto out;
+	if (type == TOMOYO_TYPE_MKDIR)
+		tomoyo_add_slash(&buf);
+	error = tomoyo_path_number_perm2(&r, type, &buf, number);
+ out:
+	kfree(buf.name);
+	tomoyo_read_unlock(idx);
+	if (r.mode != TOMOYO_CONFIG_ENFORCING)
+		error = 0;
+	return error;
+}
+
+/**
  * tomoyo_check_exec_perm - Check permission for "execute".
  *
  * @domain:   Pointer to "struct tomoyo_domain_info".
@@ -1154,7 +1368,7 @@ int tomoyo_check_open_permission(struct 
 }
 
 /**
- * tomoyo_path_perm - Check permission for "create", "unlink", "mkdir", "rmdir", "mkfifo", "mksock", "mkblock", "mkchar", "truncate", "symlink", "ioctl", "chmod", "chown", "chgrp", "chroot", "mount" and "unmount".
+ * tomoyo_path_perm - Check permission for "unlink", "rmdir", "truncate", "symlink", "chroot", "mount" and "unmount".
  *
  * @operation: Type of operation.
  * @path:      Pointer to "struct path".
@@ -1198,6 +1412,55 @@ int tomoyo_path_perm(const u8 operation,
 }
 
 /**
+ * tomoyo_path_number3_perm - Check permission for "mkblock" and "mkchar".
+ *
+ * @operation: Type of operation. (TOMOYO_TYPE_MKCHAR or TOMOYO_TYPE_MKBLOCK)
+ * @dir:       Pointer to "struct inode".
+ * @dentry:    Pointer to "struct dentry".
+ * @mnt:       Pointer to "struct vfsmount".
+ * @mode:      Create mode.
+ * @dev:       Device number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_path_number3_perm(const u8 operation, struct inode *dir,
+				    struct dentry *dentry,
+				    struct vfsmount *mnt,
+				    const unsigned int mode, unsigned int dev)
+{
+	struct tomoyo_request_info r;
+	int error = 0;
+	struct tomoyo_path_info buf;
+	bool is_enforce = false;
+	int idx;
+	if (!mnt)
+		return 0;
+	buf.name = NULL;
+	idx = tomoyo_read_lock();
+	if (tomoyo_init_request_info(&r, NULL, tomoyo_pnnn2mac[operation])
+	    == TOMOYO_CONFIG_DISABLED)
+		goto out;
+	is_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);
+	error = tomoyo_pre_vfs_mknod(dir, dentry);
+	if (error)
+		goto out;
+	error = -EPERM;
+	if (!capable(CAP_MKNOD))
+		goto out;
+	error = -ENOMEM;
+	if (!tomoyo_get_realpath(&buf, dentry, mnt))
+		goto out;
+	//dev = new_decode_dev(dev);
+	error = tomoyo_path_number3_perm2(&r, operation, &buf, mode, dev);
+ out:
+	kfree(buf.name);
+	tomoyo_read_unlock(idx);
+	if (!is_enforce)
+		error = 0;
+	return error;
+}
+
+/**
  * tomoyo_check_rewrite_permission - Check permission for "rewrite".
  *
  * @filp: Pointer to "struct file".
@@ -1299,3 +1562,267 @@ int tomoyo_path2_perm(const u8 operation
 		error = 0;
 	return error;
 }
+
+/**
+ * tomoyo_update_path_number_acl - Update ioctl/chmod/chown/chgrp ACL.
+ *
+ * @type:      Type of operation.
+ * @filename:  Filename.
+ * @number:    Number.
+ * @domain:    Pointer to "struct tomoyo_domain_info".
+ * @condition: Pointer to "struct tomoyo_condition". May be NULL.
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static inline int tomoyo_update_path_number_acl(const u8 type,
+					     const char *filename,
+					     char *number,
+					     struct tomoyo_domain_info * const
+					     domain,
+					     struct tomoyo_condition *condition,
+					     const bool is_delete)
+{
+	const u8 perm = 1 << type;
+	struct tomoyo_acl_info *ptr;
+	struct tomoyo_path_number_acl e = {
+		.head.type = TOMOYO_TYPE_PATH_NUMBER_ACL,
+		.head.cond = condition,
+		.perm = perm
+	};
+	struct tomoyo_path_number_acl *entry = NULL;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	if (!domain)
+		return -EINVAL;
+	if (!tomoyo_parse_name_union(filename, &e.name))
+		return -EINVAL;
+	if (!tomoyo_parse_number_union(number, &e.number))
+		goto out;
+	if (!is_delete)
+		entry = kmalloc(sizeof(e), GFP_KERNEL);
+	mutex_lock(&tomoyo_policy_lock);
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct tomoyo_path_number_acl *acl =
+			container_of(ptr, struct tomoyo_path_number_acl,
+				     head);
+		if (ptr->type != TOMOYO_TYPE_PATH_NUMBER_ACL ||
+		    ptr->cond != condition ||
+		    tomoyo_memcmp(acl, &e, offsetof(typeof(e), name), sizeof(e)))
+			continue;
+		if (is_delete) {
+			acl->perm &= ~perm;
+			if (!acl->perm)
+				ptr->is_deleted = true;
+		} else {
+			if (ptr->is_deleted)
+				acl->perm = 0;
+			acl->perm |= perm;
+			ptr->is_deleted = false;
+		}
+		error = 0;
+		break;
+	}
+	if (!is_delete && error && tomoyo_commit_ok(entry, &e, sizeof(e))) {
+		tomoyo_add_domain_acl(domain, &entry->head);
+		entry = NULL;
+		error = 0;
+	}
+	mutex_unlock(&tomoyo_policy_lock);
+ out:
+	tomoyo_put_name_union(&e.name);
+	tomoyo_put_number_union(&e.number);
+	kfree(entry);
+	return error;
+}
+
+/**
+ * tomoyo_path_number_acl - Check permission for ioctl/chmod/chown/chgrp operation.
+ *
+ * @r:        Pointer to "struct tomoyo_request_info".
+ * @type:     Operation.
+ * @filename: Filename to check.
+ * @number:   Number.
+ *
+ * Returns 0 on success, -EPERM otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+static int tomoyo_path_number_acl(struct tomoyo_request_info *r, const u8 type,
+				  const struct tomoyo_path_info *filename,
+				  const unsigned long number)
+{
+	struct tomoyo_domain_info *domain = r->domain;
+	struct tomoyo_acl_info *ptr;
+	const u8 perm = 1 << type;
+	int error = -EPERM;
+	list_for_each_entry_rcu(ptr, &domain->acl_info_list, list) {
+		struct tomoyo_path_number_acl *acl;
+		if (ptr->is_deleted || ptr->type != TOMOYO_TYPE_PATH_NUMBER_ACL)
+			continue;
+		acl = container_of(ptr, struct tomoyo_path_number_acl,
+				   head);
+		if (!(acl->perm & perm) || !tomoyo_condition(r, ptr) ||
+		    !tomoyo_compare_number_union(number, &acl->number) ||
+		    !tomoyo_compare_name_union(filename, &acl->name))
+			continue;
+		r->cond = ptr->cond;
+		error = 0;
+		break;
+	}
+	return error;
+}
+
+/**
+ * tomoyo_path_number_perm2 - Check permission for "create", "mkdir", "mkfifo", "mksock", "ioctl", "chmod", "chown", "chgrp".
+ *
+ * @r:        Pointer to "strct tomoyo_request_info".
+ * @filename: Filename to check.
+ * @numr:     Number.
+ *
+ * Returns 0 on success, 1 on retry, negative value otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+static int tomoyo_path_number_perm2(struct tomoyo_request_info *r,
+				    const u8 type,
+				    const struct tomoyo_path_info *filename,
+				    const unsigned long number)
+{
+	char buffer[64];
+	int error;
+	u8 radix;
+	const char *msg = tomoyo_path_number2keyword(type);
+	if (!filename)
+		return 0;
+	switch (type) {
+	case TOMOYO_TYPE_CREATE:
+	case TOMOYO_TYPE_MKDIR:
+	case TOMOYO_TYPE_MKFIFO:
+	case TOMOYO_TYPE_MKSOCK:
+	case TOMOYO_TYPE_CHMOD:
+		radix = TOMOYO_VALUE_TYPE_OCTAL;
+		break;
+	case TOMOYO_TYPE_IOCTL:
+		radix = TOMOYO_VALUE_TYPE_HEXADECIMAL;
+		break;
+	default:
+		radix = TOMOYO_VALUE_TYPE_DECIMAL;
+		break;
+	}
+	tomoyo_print_ulong(buffer, sizeof(buffer), number, radix);
+	do {
+		error = tomoyo_path_number_acl(r, type, filename, number);
+		tomoyo_audit_path_number_log(r, msg, filename->name, buffer,
+					  !error);
+		if (!error)
+			return 0;
+		error = tomoyo_supervisor(r, "allow_%s %s %s\n", msg,
+				       tomoyo_file_pattern(filename), buffer);
+	} while (error == 1);
+	if (r->mode != TOMOYO_CONFIG_ENFORCING)
+		error = 0;
+	return error;
+}
+
+/**
+ * tomoyo_path_number_perm - Check permission for "create", "mkdir", "mkfifo", "mksock", "ioctl", "chmod", "chown", "chgrp".
+ *
+ * @type:   Type of operation.
+ * @dir:    Pointer to "struct inode". May be NULL.
+ * @dentry: Pointer to "struct dentry".
+ * @vfsmnt: Pointer to "struct vfsmount".
+ * @number: Number.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int tomoyo_path_number_perm(const u8 type, struct inode *dir,
+				   struct dentry *dentry,
+				   struct vfsmount *vfsmnt,
+				   unsigned long number)
+{
+	struct tomoyo_request_info r;
+	int error = 0;
+	struct tomoyo_path_info buf;
+	int idx;
+	if (!vfsmnt || !dentry)
+		return 0;
+	buf.name = NULL;
+	idx = tomoyo_read_lock();
+	if (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])
+	    == TOMOYO_CONFIG_DISABLED)
+		goto out;
+	switch (type) {
+	case TOMOYO_TYPE_CREATE:
+		error = tomoyo_pre_vfs_create(dir, dentry);
+		break;
+	case TOMOYO_TYPE_MKDIR:
+		error = tomoyo_pre_vfs_mkdir(dir, dentry);
+		break;
+	case TOMOYO_TYPE_MKFIFO:
+	case TOMOYO_TYPE_MKSOCK:
+		error = tomoyo_pre_vfs_mknod(dir, dentry);
+		break;
+	}
+	if (error)
+		goto out;
+	error = -ENOMEM;
+	if (!tomoyo_get_realpath(&buf, dentry, vfsmnt))
+		goto out;
+	if (type == TOMOYO_TYPE_MKDIR)
+		tomoyo_add_slash(&buf);
+	error = tomoyo_path_number_perm2(&r, type, &buf, number);
+ out:
+	kfree(buf.name);
+	tomoyo_read_unlock(idx);
+	if (r.mode != TOMOYO_CONFIG_ENFORCING)
+		error = 0;
+	return error;
+}
+
+/**
+ * tomoyo_write_file_policy - Update file related list.
+ *
+ * @data:      String to parse.
+ * @domain:    Pointer to "struct tomoyo_domain_info".
+ * @is_delete: True if it is a delete request.
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds tomoyo_read_lock().
+ */
+int tomoyo_write_file_policy(char *data, struct tomoyo_domain_info *domain,
+			     const bool is_delete)
+{
+	char *filename = strchr(data, ' ');
+	char *filename2;
+	unsigned int perm;
+	u8 type;
+
+	if (!filename)
+		return -EINVAL;
+	*filename++ = '\0';
+	if (sscanf(data, "%u", &perm) == 1)
+		return tomoyo_update_file_acl(filename, (u8) perm, domain,
+					      is_delete);
+	if (strncmp(data, "allow_", 6))
+		goto out;
+	data += 6;
+	for (type = 0; type < TOMOYO_MAX_PATH_OPERATION; type++) {
+		if (strcmp(data, tomoyo_path_keyword[type]))
+			continue;
+		return tomoyo_update_path_acl(type, filename, domain,
+					      is_delete);
+	}
+	filename2 = strchr(filename, ' ');
+	if (!filename2)
+		goto out;
+	*filename2++ = '\0';
+	for (type = 0; type < TOMOYO_MAX_PATH2_OPERATION; type++) {
+		if (strcmp(data, tomoyo_path2_keyword[type]))
+			continue;
+		return tomoyo_update_path2_acl(type, filename, filename2,
+					       domain, is_delete);
+	}
+ out:
+	return -EINVAL;
+}
