Subject: LSM adapter functions.

Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/tomoyo.c |  285 +++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 285 insertions(+)

--- /dev/null
+++ mm/security/tomoyo/tomoyo.c
@@ -0,0 +1,285 @@
+/*
+ * security/tomoyo/tomoyo.c
+ *
+ * LSM hooks for TOMOYO Linux.
+ */
+
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/utime.h>
+#include <linux/file.h>
+#include <linux/smp_lock.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+#include <stdarg.h>
+#include <linux/delay.h>
+#include <linux/security.h>
+#include "ccs_common.h"
+#include "tomoyo.h"
+#include "realpath.h"
+
+static struct kmem_cache *ccs_cachep;
+
+static int ccs_task_alloc_security(struct task_struct *p)
+{
+	struct ccs_security *ptr = kmem_cache_alloc(ccs_cachep, GFP_KERNEL);
+
+	if (!ptr)
+		return -ENOMEM;
+	memcpy(ptr, CCS_SECURITY, sizeof(*ptr));
+	p->security = ptr;
+	return 0;
+}
+
+static void ccs_task_free_security(struct task_struct *p)
+{
+	kmem_cache_free(ccs_cachep, p->security);
+}
+
+static int ccs_bprm_alloc_security(struct linux_binprm *bprm)
+{
+	CCS_SECURITY->prev_domain = CCS_SECURITY->domain;
+	return 0;
+}
+
+static int ccs_bprm_check_security(struct linux_binprm *bprm)
+{
+	struct domain_info *next_domain = NULL;
+	int retval = 0;
+
+	ccs_load_policy(bprm->filename);
+
+	/*
+	 * CCS_CHECK_READ_FOR_OPEN_EXEC bit indicates whether this function is
+	 * called by do_execve() or not.
+	 * If called by do_execve(), I do domain transition.
+	 */
+	if ((CCS_SECURITY->flags & CCS_CHECK_READ_FOR_OPEN_EXEC))
+		goto out;
+	retval = ccs_find_next_domain(bprm, &next_domain);
+	if (retval)
+		goto out;
+	CCS_SECURITY->domain = next_domain;
+	CCS_SECURITY->flags |= CCS_CHECK_READ_FOR_OPEN_EXEC;
+ out:
+	return retval;
+}
+
+static void ccs_bprm_post_apply_creds(struct linux_binprm *bprm)
+{
+	CCS_SECURITY->prev_domain = CCS_SECURITY->domain;
+}
+
+static void ccs_bprm_free_security(struct linux_binprm *bprm)
+{
+	CCS_SECURITY->domain = CCS_SECURITY->prev_domain;
+	CCS_SECURITY->flags &= ~CCS_CHECK_READ_FOR_OPEN_EXEC;
+}
+
+static int ccs_sysctl(struct ctl_table *table, int op)
+{
+	int error;
+	char *name;
+
+	if ((op & 6) == 0)
+		return 0;
+
+	name = sysctlpath_from_table(table);
+	if (!name)
+		return -ENOMEM;
+
+	error = ccs_check_file_perm(name, op & 6, "sysctl");
+	ccs_free(name);
+
+	return error;
+}
+
+static int ccs_inode_permission(struct inode *inode, int mask,
+				struct nameidata *nd)
+{
+	int flag = 0;
+
+	if (S_ISDIR(inode->i_mode)) /* ignore because inode is directory */
+		return 0;
+	if (!nd || !nd->path.dentry || !nd->path.mnt)
+		return 0;
+	/*
+	 * If called by other than do_execve(), I check for read permission of
+	 * interpreter.
+	 * Unlike DAC, I don't check for read permission of pathname passed to
+	 * do_execve().
+	 * TOMOYO Linux checks for program's execute permission and
+	 * interpreter's read permission.
+	 */
+	if ((mask == MAY_EXEC) &&
+	    (CCS_SECURITY->flags & CCS_CHECK_READ_FOR_OPEN_EXEC))
+		mask = MAY_READ;
+	if ((mask == MAY_EXEC) || (mask == 0))
+		return 0;
+
+	if (mask == (MAY_READ | MAY_EXEC))
+		flag |= O_RDONLY + 1;
+	else {
+		if (mask & MAY_READ)
+			flag |= O_RDONLY + 1;
+		if (mask & MAY_WRITE)
+			flag |= O_WRONLY + 1;
+		if ((mask & MAY_APPEND))
+			flag |= O_APPEND;
+	}
+
+	return ccs_check_open_permission(nd->path.dentry, nd->path.mnt, flag);
+}
+
+static int ccs_path_truncate(struct path *path, loff_t length,
+			     unsigned int time_attrs, struct file *filp)
+{
+	return ccs_check_1path_perm(CCS_TYPE_TRUNCATE_ACL, path->dentry,
+				    path->mnt);
+}
+
+static int ccs_path_create(struct inode *dir, struct dentry *dentry, int mode,
+			   struct nameidata *nd)
+{
+	if (!nd || !nd->path.mnt)
+		return 0;
+	return ccs_check_1path_perm(CCS_TYPE_CREATE_ACL, dentry, nd->path.mnt);
+}
+
+static int ccs_path_unlink(struct path *dir, struct dentry *dentry)
+{
+	const int err = pre_vfs_unlink(dir->dentry->d_inode, dentry);
+	if (err)
+		return err;
+	return ccs_check_1path_perm(CCS_TYPE_UNLINK_ACL, dentry, dir->mnt);
+}
+
+static int ccs_path_mkdir(struct path *dir, struct dentry *dentry, int mode)
+{
+	const int err = pre_vfs_mkdir(dir->dentry->d_inode, dentry);
+	if (err)
+		return err;
+	return ccs_check_1path_perm(CCS_TYPE_MKDIR_ACL, dentry, dir->mnt);
+}
+
+static int ccs_path_rmdir(struct path *dir, struct dentry *dentry)
+{
+	const int err = pre_vfs_rmdir(dir->dentry->d_inode, dentry);
+	if (err)
+		return err;
+	return ccs_check_1path_perm(CCS_TYPE_RMDIR_ACL, dentry, dir->mnt);
+}
+
+static int ccs_path_symlink(struct path *dir, struct dentry *dentry,
+			    const char *old_name)
+{
+	const int err = pre_vfs_symlink(dir->dentry->d_inode, dentry);
+	if (err)
+		return err;
+	return ccs_check_1path_perm(CCS_TYPE_SYMLINK_ACL, dentry, dir->mnt);
+}
+
+static int ccs_path_mknod(struct path *dir, struct dentry *dentry, int mode,
+			  unsigned int dev)
+{
+	struct vfsmount *mnt = dir->mnt;
+	int err = 0;
+	switch (mode & S_IFMT) {
+	case S_IFCHR:
+	case S_IFBLK:
+	case S_IFIFO:
+	case S_IFSOCK:
+		break;
+	default:
+		return 0;
+	}
+	err = pre_vfs_mknod(dir->dentry->d_inode, dentry, mode);
+	if (err)
+		return err;
+	if (S_ISCHR(mode))
+		return ccs_check_1path_perm(CCS_TYPE_MKCHAR_ACL, dentry, mnt);
+	if (S_ISBLK(mode))
+		return ccs_check_1path_perm(CCS_TYPE_MKBLOCK_ACL, dentry, mnt);
+	if (S_ISFIFO(mode))
+		return ccs_check_1path_perm(CCS_TYPE_MKFIFO_ACL, dentry, mnt);
+	if (S_ISSOCK(mode))
+		return ccs_check_1path_perm(CCS_TYPE_MKSOCK_ACL, dentry, mnt);
+	return 0;
+}
+
+static int ccs_path_link(struct path *old_path, struct path *new_dir,
+			 struct dentry *new_dentry)
+{
+	const int err = pre_vfs_link(old_path->dentry, new_dir->dentry->d_inode,
+				     new_dentry);
+	if (err)
+		return err;
+	return ccs_check_2path_perm(CCS_TYPE_LINK_ACL,
+				    old_path->dentry, old_path->mnt,
+				    new_dentry, new_dir->mnt);
+}
+
+static int ccs_path_rename(struct path *old_dir, struct dentry *old_dentry,
+			   struct path *new_dir, struct dentry *new_dentry)
+{
+	const int err = pre_vfs_rename(old_dir->dentry->d_inode, old_dentry,
+				       new_dir->dentry->d_inode, new_dentry);
+	if (err)
+		return err;
+	return ccs_check_2path_perm(CCS_TYPE_RENAME_ACL,
+				    old_dir->dentry, old_dir->mnt,
+				    new_dentry, new_dir->mnt);
+}
+
+static int ccs_file_fcntl(struct file *file, unsigned int cmd,
+			  unsigned long arg)
+{
+	if (!((arg ^ file->f_flags) & O_APPEND))
+		return ccs_check_rewrite_permission(file);
+	return 0;
+}
+
+static struct security_operations tomoyo_security_ops = {
+	.task_alloc_security       = ccs_task_alloc_security,
+	.task_free_security        = ccs_task_free_security,
+	.bprm_alloc_security       = ccs_bprm_alloc_security,
+	.bprm_check_security       = ccs_bprm_check_security,
+	.bprm_post_apply_creds     = ccs_bprm_post_apply_creds,
+	.bprm_free_security        = ccs_bprm_free_security,
+	.sysctl                    = ccs_sysctl,
+	.inode_permission          = ccs_inode_permission,
+	.path_truncate             = ccs_path_truncate,
+	.path_create               = ccs_path_create,
+	.path_unlink               = ccs_path_unlink,
+	.path_mkdir                = ccs_path_mkdir,
+	.path_rmdir                = ccs_path_rmdir,
+	.path_symlink              = ccs_path_symlink,
+	.path_mknod                = ccs_path_mknod,
+	.path_link                 = ccs_path_link,
+	.path_rename               = ccs_path_rename,
+	.file_fcntl                = ccs_file_fcntl,
+};
+
+static int __init ccs_init(void)
+{
+	struct ccs_security *ccs_security;
+	/* register ourselves with the security framework */
+	if (register_security(&tomoyo_security_ops))
+		panic("Failure registering TOMOYO Linux");
+
+	printk(KERN_INFO "TOMOYO Linux initialized\n");
+	ccs_cachep = kmem_cache_create("tomoyo_security",
+				       sizeof(struct ccs_security),
+				       0, SLAB_PANIC, NULL);
+	ccs_security = kmem_cache_alloc(ccs_cachep, GFP_KERNEL);
+	BUG_ON(!ccs_security);
+	memset(ccs_security, 0, sizeof(*ccs_security));
+	ccs_security->domain = &KERNEL_DOMAIN;
+	init_task.security = ccs_security;
+	return 0;
+}
+
+security_initcall(ccs_init);
