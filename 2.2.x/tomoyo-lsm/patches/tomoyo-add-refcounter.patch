Subject: TOMOYO: Add refcounter.

A process who is reading/writing list elements has pointers which point to
(possibly marked-as-deleted) list elements and releases a lock when the process
leaves the kernel.

As of now, TOMOYO cannot release memory used by marked-as-deleted list elements
because TOMOYO does not manage list of pointers.

This is preparation for implementing GC support.

Approach:

  Define a structure

    struct tomoyo_entry {
        struct list_head list;
        atomic_t users;
    };

  and replace "struct list_head" with "struct tomoyo_entry".

  Get a reference by calling

    void tomoyo_get_ref(struct list_head *item)

  before releasing a lock and drop a reference by calling

    void tomoyo_put_ref(struct list_head *item)

  after obtaining a lock.

Memory Management Rules:

  When /sys/kernel/security/tomoyo/ interface opened for writing is closed,
  garbage collector functions are called. The garbage collector functions take
  appropriate locks and remove elements if that element has is_deleted flag set
  and that element's refcounter is 0.

  Since strings are likely referenced by multiple list elements, this patch
  assigns a refcounter to each string.
  The garbage collector function releases memory of the string if the string's
  refcounter becomes 0.

Signed-off-by: Kentaro Takeda <takedakn@nttdata.co.jp>
Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
---
 security/tomoyo/common.c   |  130 +++++++++++++++++++++++++++++----------------
 security/tomoyo/common.h   |   26 +++++++--
 security/tomoyo/domain.c   |  124 ++++++++++++++++++------------------------
 security/tomoyo/file.c     |  116 ++++++++++++++++++++++++++--------------
 security/tomoyo/realpath.c |   13 +---
 security/tomoyo/tomoyo.c   |   18 +++++-
 6 files changed, 260 insertions(+), 167 deletions(-)

--- linux-2.6.git.orig/security/tomoyo/common.c
+++ linux-2.6.git/security/tomoyo/common.c
@@ -340,10 +340,9 @@ bool tomoyo_is_domain_def(const unsigned
  *
  * @domainname: The domainname to find.
  *
- * Caller must call down_read(&tomoyo_domain_list_lock); or
- * down_write(&tomoyo_domain_list_lock); .
- *
  * Returns pointer to "struct tomoyo_domain_info" if found, NULL otherwise.
+ *
+ * Caller must call down_read(&tomoyo_domain_list_lock);.
  */
 struct tomoyo_domain_info *tomoyo_find_domain(const char *domainname)
 {
@@ -352,7 +351,7 @@ struct tomoyo_domain_info *tomoyo_find_d
 
 	name.name = domainname;
 	tomoyo_fill_path_info(&name);
-	list_for_each_entry(domain, &tomoyo_domain_list, list) {
+	list_for_each_entry(domain, &tomoyo_domain_list, entry.list) {
 		if (!domain->is_deleted &&
 		    !tomoyo_pathcmp(&name, domain->domainname))
 			return domain;
@@ -797,7 +796,7 @@ bool tomoyo_domain_quota_is_ok(struct to
 	if (!domain)
 		return true;
 	down_read(&tomoyo_domain_acl_info_list_lock);
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		if (ptr->type & TOMOYO_ACL_DELETED)
 			continue;
 		switch (tomoyo_acl_type2(ptr)) {
@@ -898,6 +897,9 @@ static struct tomoyo_profile *tomoyo_fin
 	return ptr;
 }
 
+/* Lock for protecting profile->comment. */
+static DEFINE_MUTEX(tomoyo_profile_comment_lock);
+
 /**
  * tomoyo_write_profile - Write to profile table.
  *
@@ -932,8 +934,10 @@ static int tomoyo_write_profile(struct t
 		const struct tomoyo_path_info *new_comment
 			= tomoyo_get_name(cp + 1);
 		const struct tomoyo_path_info *old_comment;
+		mutex_lock(&tomoyo_profile_comment_lock);
 		old_comment = profile->comment;
 		profile->comment = new_comment;
+		mutex_unlock(&tomoyo_profile_comment_lock);
 		tomoyo_put_name(old_comment);
 		return 0;
 	}
@@ -992,9 +996,13 @@ static int tomoyo_read_profile(struct to
 		if (!profile)
 			continue;
 		if (!type) { /* Print profile' comment tag. */
-			if (!tomoyo_io_printf(head, "%u-COMMENT=%s\n",
-					      index, profile->comment ?
-					      profile->comment->name : ""))
+			bool done;
+			mutex_lock(&tomoyo_profile_comment_lock);
+			done = tomoyo_io_printf(head, "%u-COMMENT=%s\n",
+						index, profile->comment ?
+						profile->comment->name : "");
+			mutex_unlock(&tomoyo_profile_comment_lock);
+			if (!done)
 				break;
 			continue;
 		}
@@ -1042,7 +1050,7 @@ static int tomoyo_read_profile(struct to
  *      otherwise.
  */
 struct tomoyo_policy_manager_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	/* A path to program or a domainname. */
 	const struct tomoyo_path_info *manager;
 	bool is_domain;  /* True if manager is a domainname. */
@@ -1113,7 +1121,7 @@ static int tomoyo_update_manager_entry(c
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
 	down_write(&tomoyo_policy_manager_list_lock);
-	list_for_each_entry(ptr, &tomoyo_policy_manager_list, list) {
+	list_for_each_entry(ptr, &tomoyo_policy_manager_list, entry.list) {
 		if (ptr->manager != saved_manager)
 			continue;
 		ptr->is_deleted = is_delete;
@@ -1124,7 +1132,8 @@ static int tomoyo_update_manager_entry(c
 		new_entry->manager = saved_manager;
 		saved_manager = NULL;
 		new_entry->is_domain = is_domain;
-		list_add_tail(&new_entry->list, &tomoyo_policy_manager_list);
+		list_add_tail(&new_entry->entry.list,
+			      &tomoyo_policy_manager_list);
 		new_entry = NULL;
 		error = 0;
 	}
@@ -1168,17 +1177,19 @@ static int tomoyo_read_manager_policy(st
 	if (head->read_eof)
 		return 0;
 	down_read(&tomoyo_policy_manager_list_lock);
+	tomoyo_put_ref(head->read_var2);
 	list_for_each_cookie(pos, head->read_var2,
 			     &tomoyo_policy_manager_list) {
 		struct tomoyo_policy_manager_entry *ptr;
 		ptr = list_entry(pos, struct tomoyo_policy_manager_entry,
-				 list);
+				 entry.list);
 		if (ptr->is_deleted)
 			continue;
 		done = tomoyo_io_printf(head, "%s\n", ptr->manager->name);
 		if (!done)
 			break;
 	}
+	tomoyo_get_ref(head->read_var2);
 	up_read(&tomoyo_policy_manager_list_lock);
 	head->read_eof = done;
 	return 0;
@@ -1203,7 +1214,7 @@ static bool tomoyo_is_policy_manager(voi
 	if (!tomoyo_manage_by_non_root && (task->cred->uid || task->cred->euid))
 		return false;
 	down_read(&tomoyo_policy_manager_list_lock);
-	list_for_each_entry(ptr, &tomoyo_policy_manager_list, list) {
+	list_for_each_entry(ptr, &tomoyo_policy_manager_list, entry.list) {
 		if (!ptr->is_deleted && ptr->is_domain
 		    && !tomoyo_pathcmp(domainname, ptr->manager)) {
 			found = true;
@@ -1217,7 +1228,7 @@ static bool tomoyo_is_policy_manager(voi
 	if (!exe)
 		return false;
 	down_read(&tomoyo_policy_manager_list_lock);
-	list_for_each_entry(ptr, &tomoyo_policy_manager_list, list) {
+	list_for_each_entry(ptr, &tomoyo_policy_manager_list, entry.list) {
 		if (!ptr->is_deleted && !ptr->is_domain
 		    && !strcmp(exe, ptr->manager->name)) {
 			found = true;
@@ -1249,9 +1260,14 @@ static bool tomoyo_is_policy_manager(voi
 static bool tomoyo_is_select_one(struct tomoyo_io_buffer *head,
 				 const char *data)
 {
+	bool result = false;
 	unsigned int pid;
 	struct tomoyo_domain_info *domain = NULL;
 
+	down_read(&tomoyo_domain_list_lock);
+	tomoyo_put_ref(head->write_var1);
+	tomoyo_put_ref(head->read_var1);
+	tomoyo_put_ref(head->read_var2);
 	if (sscanf(data, "pid=%u", &pid) == 1) {
 		struct task_struct *p;
 		read_lock(&tasklist_lock);
@@ -1260,17 +1276,15 @@ static bool tomoyo_is_select_one(struct 
 			domain = tomoyo_real_domain(p);
 		read_unlock(&tasklist_lock);
 	} else if (!strncmp(data, "domain=", 7)) {
-		if (tomoyo_is_domain_def(data + 7)) {
-			down_read(&tomoyo_domain_list_lock);
+		if (tomoyo_is_domain_def(data + 7))
 			domain = tomoyo_find_domain(data + 7);
-			up_read(&tomoyo_domain_list_lock);
-		}
 	} else
-		return false;
-	head->write_var1 = domain;
+		goto out;
+	result = true;
+	head->write_var1 = domain ? &domain->entry.list : NULL;
 	/* Accessing read_buf is safe because head->io_sem is held. */
 	if (!head->read_buf)
-		return true; /* Do nothing if open(O_WRONLY). */
+		goto out; /* Do nothing if open(O_WRONLY). */
 	head->read_avail = 0;
 	tomoyo_io_printf(head, "# select %s\n", data);
 	head->read_single_domain = true;
@@ -1278,20 +1292,23 @@ static bool tomoyo_is_select_one(struct 
 	if (domain) {
 		struct tomoyo_domain_info *d;
 		head->read_var1 = NULL;
-		down_read(&tomoyo_domain_list_lock);
-		list_for_each_entry(d, &tomoyo_domain_list, list) {
+		list_for_each_entry(d, &tomoyo_domain_list, entry.list) {
 			if (d == domain)
 				break;
-			head->read_var1 = &d->list;
+			head->read_var1 = &d->entry.list;
 		}
-		up_read(&tomoyo_domain_list_lock);
 		head->read_var2 = NULL;
 		head->read_bit = 0;
 		head->read_step = 0;
 		if (domain->is_deleted)
 			tomoyo_io_printf(head, "# This is a deleted domain.\n");
 	}
-	return true;
+ out:
+	tomoyo_get_ref(head->read_var2);
+	tomoyo_get_ref(head->read_var1);
+	tomoyo_get_ref(head->write_var1);
+	up_read(&tomoyo_domain_list_lock);
+	return result;
 }
 
 /**
@@ -1300,17 +1317,20 @@ static bool tomoyo_is_select_one(struct 
  * @domainname: The name of domain.
  *
  * Returns 0.
+ *
+ * Caller must call down_read(&tomoyo_domain_list_lock);.
  */
 static int tomoyo_delete_domain(char *domainname)
 {
 	struct tomoyo_domain_info *domain;
 	struct tomoyo_path_info name;
 
+	up_read(&tomoyo_domain_list_lock);
 	name.name = domainname;
 	tomoyo_fill_path_info(&name);
 	down_write(&tomoyo_domain_list_lock);
 	/* Is there an active domain? */
-	list_for_each_entry(domain, &tomoyo_domain_list, list) {
+	list_for_each_entry(domain, &tomoyo_domain_list, entry.list) {
 		/* Never delete tomoyo_kernel_domain */
 		if (domain == &tomoyo_kernel_domain)
 			continue;
@@ -1321,6 +1341,7 @@ static int tomoyo_delete_domain(char *do
 		break;
 	}
 	up_write(&tomoyo_domain_list_lock);
+	down_read(&tomoyo_domain_list_lock);
 	return 0;
 }
 
@@ -1334,7 +1355,9 @@ static int tomoyo_delete_domain(char *do
 static int tomoyo_write_domain_policy(struct tomoyo_io_buffer *head)
 {
 	char *data = head->write_buf;
-	struct tomoyo_domain_info *domain = head->write_var1;
+	struct tomoyo_domain_info *domain
+		= container_of(head->write_var1, struct tomoyo_domain_info,
+			       entry.list);
 	bool is_delete = false;
 	bool is_select = false;
 	unsigned int profile;
@@ -1349,16 +1372,18 @@ static int tomoyo_write_domain_policy(st
 	if (!tomoyo_is_policy_manager())
 		return -EPERM;
 	if (tomoyo_is_domain_def(data)) {
+		down_read(&tomoyo_domain_list_lock);
+		tomoyo_put_ref(head->write_var1);
 		domain = NULL;
 		if (is_delete)
 			tomoyo_delete_domain(data);
-		else if (is_select) {
-			down_read(&tomoyo_domain_list_lock);
+		else if (is_select)
 			domain = tomoyo_find_domain(data);
-			up_read(&tomoyo_domain_list_lock);
-		} else
+		else
 			domain = tomoyo_find_or_assign_new_domain(data, 0);
-		head->write_var1 = domain;
+		head->write_var1 = domain ? &domain->entry.list : NULL;
+		tomoyo_get_ref(head->write_var1);
+		up_read(&tomoyo_domain_list_lock);
 		return 0;
 	}
 	if (!domain)
@@ -1512,12 +1537,16 @@ static int tomoyo_read_domain_policy(str
 	if (head->read_step == 0)
 		head->read_step = 1;
 	down_read(&tomoyo_domain_list_lock);
+	down_read(&tomoyo_domain_acl_info_list_lock);
+	tomoyo_put_ref(head->read_var1);
+	tomoyo_put_ref(head->read_var2);
 	list_for_each_cookie(dpos, head->read_var1, &tomoyo_domain_list) {
 		struct tomoyo_domain_info *domain;
 		const char *quota_exceeded = "";
 		const char *transition_failed = "";
 		const char *ignore_global_allow_read = "";
-		domain = list_entry(dpos, struct tomoyo_domain_info, list);
+		domain = list_entry(dpos, struct tomoyo_domain_info,
+				    entry.list);
 		if (head->read_step != 1)
 			goto acl_loop;
 		if (domain->is_deleted && !head->read_single_domain)
@@ -1543,17 +1572,15 @@ acl_loop:
 		if (head->read_step == 3)
 			goto tail_mark;
 		/* Print ACL entries in the domain. */
-		down_read(&tomoyo_domain_acl_info_list_lock);
 		list_for_each_cookie(apos, head->read_var2,
 				     &domain->acl_info_list) {
 			struct tomoyo_acl_info *ptr
 				= list_entry(apos, struct tomoyo_acl_info,
-					     list);
+					     entry.list);
 			done = tomoyo_print_entry(head, ptr);
 			if (!done)
 				break;
 		}
-		up_read(&tomoyo_domain_acl_info_list_lock);
 		if (!done)
 			break;
 		head->read_step = 3;
@@ -1565,6 +1592,9 @@ tail_mark:
 		if (head->read_single_domain)
 			break;
 	}
+	tomoyo_get_ref(head->read_var2);
+	tomoyo_get_ref(head->read_var1);
+	up_read(&tomoyo_domain_acl_info_list_lock);
 	up_read(&tomoyo_domain_list_lock);
 	head->read_eof = done;
 	return 0;
@@ -1592,14 +1622,14 @@ static int tomoyo_write_domain_profile(s
 	if (!cp)
 		return -EINVAL;
 	*cp = '\0';
+	if (strict_strtoul(data, 10, &profile) ||
+	    profile >= TOMOYO_MAX_PROFILES)
+		return -EINVAL;
 	down_read(&tomoyo_domain_list_lock);
 	domain = tomoyo_find_domain(cp + 1);
-	up_read(&tomoyo_domain_list_lock);
-	if (strict_strtoul(data, 10, &profile))
-		return -EINVAL;
-	if (domain && profile < TOMOYO_MAX_PROFILES
-	    && (tomoyo_profile_ptr[profile] || !tomoyo_policy_loaded))
+	if (domain && (tomoyo_profile_ptr[profile] || !tomoyo_policy_loaded))
 		domain->profile = (u8) profile;
+	up_read(&tomoyo_domain_list_lock);
 	return 0;
 }
 
@@ -1625,9 +1655,10 @@ static int tomoyo_read_domain_profile(st
 	if (head->read_eof)
 		return 0;
 	down_read(&tomoyo_domain_list_lock);
+	tomoyo_put_ref(head->read_var1);
 	list_for_each_cookie(pos, head->read_var1, &tomoyo_domain_list) {
 		struct tomoyo_domain_info *domain;
-		domain = list_entry(pos, struct tomoyo_domain_info, list);
+		domain = list_entry(pos, struct tomoyo_domain_info, entry.list);
 		if (domain->is_deleted)
 			continue;
 		done = tomoyo_io_printf(head, "%u %s\n", domain->profile,
@@ -1635,6 +1666,7 @@ static int tomoyo_read_domain_profile(st
 		if (!done)
 			break;
 	}
+	tomoyo_get_ref(head->read_var1);
 	up_read(&tomoyo_domain_list_lock);
 	head->read_eof = done;
 	return 0;
@@ -1673,6 +1705,7 @@ static int tomoyo_read_pid(struct tomoyo
 		const int pid = head->read_step;
 		struct task_struct *p;
 		struct tomoyo_domain_info *domain = NULL;
+		down_read(&tomoyo_domain_list_lock);
 		read_lock(&tasklist_lock);
 		p = find_task_by_vpid(pid);
 		if (p)
@@ -1681,6 +1714,7 @@ static int tomoyo_read_pid(struct tomoyo
 		if (domain)
 			tomoyo_io_printf(head, "%d %u %s", pid, domain->profile,
 					 domain->domainname->name);
+		up_read(&tomoyo_domain_list_lock);
 		head->read_eof = true;
 	}
 	return 0;
@@ -1856,7 +1890,7 @@ void tomoyo_load_policy(const char *file
 	{ /* Check all profiles currently assigned to domains are defined. */
 		struct tomoyo_domain_info *domain;
 		down_read(&tomoyo_domain_list_lock);
-		list_for_each_entry(domain, &tomoyo_domain_list, list) {
+		list_for_each_entry(domain, &tomoyo_domain_list, entry.list) {
 			const u8 profile = domain->profile;
 			if (tomoyo_profile_ptr[profile])
 				continue;
@@ -1997,6 +2031,10 @@ static int tomoyo_open_control(const u8 
 		}
 	}
 	file->private_data = head;
+	/* Get refcount. Though nothing happens. */
+	tomoyo_get_ref(head->write_var1);
+	tomoyo_get_ref(head->read_var1);
+	tomoyo_get_ref(head->read_var2);
 	/*
 	 * Call the handler now if the file is
 	 * /sys/kernel/security/tomoyo/self_domain
@@ -2120,6 +2158,10 @@ static int tomoyo_close_control(struct f
 	head->read_buf = NULL;
 	tomoyo_free(head->write_buf);
 	head->write_buf = NULL;
+	/* Put refcount if partially read or written. */
+	tomoyo_put_ref(head->read_var2);
+	tomoyo_put_ref(head->read_var1);
+	tomoyo_put_ref(head->write_var1);
 	tomoyo_free(head);
 	head = NULL;
 	file->private_data = NULL;
--- linux-2.6.git.orig/security/tomoyo/common.h
+++ linux-2.6.git/security/tomoyo/common.h
@@ -23,6 +23,25 @@
 #include <linux/mount.h>
 #include <linux/list.h>
 
+struct tomoyo_entry {
+	struct list_head list;
+	atomic_t users;
+};
+
+static inline void tomoyo_get_ref(struct list_head *item)
+{
+	if (item)
+		atomic_dec(&(container_of(item, struct tomoyo_entry,
+					  list)->users));
+}
+
+static inline void tomoyo_put_ref(struct list_head *item)
+{
+	if (item)
+		atomic_inc(&(container_of(item, struct tomoyo_entry,
+					  list)->users));
+}
+
 struct dentry;
 struct vfsmount;
 
@@ -117,7 +136,7 @@ struct tomoyo_path_info_with_data {
  * without enlarging their structure size.
  */
 struct tomoyo_acl_info {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	/*
 	 * Type of this ACL entry.
 	 *
@@ -152,10 +171,11 @@ struct tomoyo_acl_info {
  * open()ed file after that file was unlink()ed).
  */
 struct tomoyo_domain_info {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	struct list_head acl_info_list;
 	/* Name of this domain. Never NULL.          */
 	const struct tomoyo_path_info *domainname;
+	atomic_t users;
 	u8 profile;        /* Profile number to use. */
 	bool is_deleted;   /* Delete flag.           */
 	bool quota_warned; /* Quota warnning flag.   */
@@ -271,7 +291,7 @@ struct tomoyo_io_buffer {
 	/* Extra variables for reading.         */
 	struct list_head *read_var2;
 	/* The position currently writing to.   */
-	struct tomoyo_domain_info *write_var1;
+	struct list_head *write_var1;
 	/* The step for reading.                */
 	int read_step;
 	/* Buffer for reading.                  */
--- linux-2.6.git.orig/security/tomoyo/domain.c
+++ linux-2.6.git/security/tomoyo/domain.c
@@ -77,7 +77,7 @@ DECLARE_RWSEM(tomoyo_domain_list_lock);
  *      component of a domainname", false otherwise.
  */
 struct tomoyo_domain_initializer_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *domainname;    /* This may be NULL */
 	const struct tomoyo_path_info *program;
 	bool is_deleted;
@@ -104,7 +104,7 @@ struct tomoyo_domain_initializer_entry {
  *      component of a domainname", false otherwise.
  */
 struct tomoyo_domain_keeper_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *domainname;
 	const struct tomoyo_path_info *program;       /* This may be NULL */
 	bool is_deleted;
@@ -124,7 +124,7 @@ struct tomoyo_domain_keeper_entry {
  *      otherwise.
  */
 struct tomoyo_alias_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *original_name;
 	const struct tomoyo_path_info *aliased_name;
 	bool is_deleted;
@@ -228,7 +228,7 @@ static int tomoyo_update_domain_initiali
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
 	down_write(&tomoyo_domain_initializer_list_lock);
-	list_for_each_entry(ptr, &tomoyo_domain_initializer_list, list) {
+	list_for_each_entry(ptr, &tomoyo_domain_initializer_list, entry.list) {
 		if (ptr->is_not != is_not ||
 		    ptr->domainname != saved_domainname ||
 		    ptr->program != saved_program)
@@ -244,7 +244,7 @@ static int tomoyo_update_domain_initiali
 		saved_program = NULL;
 		new_entry->is_not = is_not;
 		new_entry->is_last_name = is_last_name;
-		list_add_tail(&new_entry->list,
+		list_add_tail(&new_entry->entry.list,
 			      &tomoyo_domain_initializer_list);
 		new_entry = NULL;
 		error = 0;
@@ -269,6 +269,7 @@ bool tomoyo_read_domain_initializer_poli
 	bool done = true;
 
 	down_read(&tomoyo_domain_initializer_list_lock);
+	tomoyo_put_ref(head->read_var2);
 	list_for_each_cookie(pos, head->read_var2,
 			     &tomoyo_domain_initializer_list) {
 		const char *no;
@@ -276,7 +277,7 @@ bool tomoyo_read_domain_initializer_poli
 		const char *domain = "";
 		struct tomoyo_domain_initializer_entry *ptr;
 		ptr = list_entry(pos, struct tomoyo_domain_initializer_entry,
-				  list);
+				 entry.list);
 		if (ptr->is_deleted)
 			continue;
 		no = ptr->is_not ? "no_" : "";
@@ -291,6 +292,7 @@ bool tomoyo_read_domain_initializer_poli
 		if (!done)
 			break;
 	}
+	tomoyo_get_ref(head->read_var2);
 	up_read(&tomoyo_domain_initializer_list_lock);
 	return done;
 }
@@ -339,7 +341,7 @@ static bool tomoyo_is_domain_initializer
 	bool flag = false;
 
 	down_read(&tomoyo_domain_initializer_list_lock);
-	list_for_each_entry(ptr,  &tomoyo_domain_initializer_list, list) {
+	list_for_each_entry(ptr,  &tomoyo_domain_initializer_list, entry.list) {
 		if (ptr->is_deleted)
 			continue;
 		if (ptr->domainname) {
@@ -446,7 +448,7 @@ static int tomoyo_update_domain_keeper_e
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
 	down_write(&tomoyo_domain_keeper_list_lock);
-	list_for_each_entry(ptr, &tomoyo_domain_keeper_list, list) {
+	list_for_each_entry(ptr, &tomoyo_domain_keeper_list, entry.list) {
 		if (ptr->is_not != is_not ||
 		    ptr->domainname != saved_domainname ||
 		    ptr->program != saved_program)
@@ -462,7 +464,8 @@ static int tomoyo_update_domain_keeper_e
 		saved_program = NULL;
 		new_entry->is_not = is_not;
 		new_entry->is_last_name = is_last_name;
-		list_add_tail(&new_entry->list, &tomoyo_domain_keeper_list);
+		list_add_tail(&new_entry->entry.list,
+			      &tomoyo_domain_keeper_list);
 		new_entry = NULL;
 		error = 0;
 	}
@@ -507,6 +510,7 @@ bool tomoyo_read_domain_keeper_policy(st
 	bool done = true;
 
 	down_read(&tomoyo_domain_keeper_list_lock);
+	tomoyo_put_ref(head->read_var2);
 	list_for_each_cookie(pos, head->read_var2,
 			     &tomoyo_domain_keeper_list) {
 		struct tomoyo_domain_keeper_entry *ptr;
@@ -514,7 +518,8 @@ bool tomoyo_read_domain_keeper_policy(st
 		const char *from = "";
 		const char *program = "";
 
-		ptr = list_entry(pos, struct tomoyo_domain_keeper_entry, list);
+		ptr = list_entry(pos, struct tomoyo_domain_keeper_entry,
+				 entry.list);
 		if (ptr->is_deleted)
 			continue;
 		no = ptr->is_not ? "no_" : "";
@@ -529,6 +534,7 @@ bool tomoyo_read_domain_keeper_policy(st
 		if (!done)
 			break;
 	}
+	tomoyo_get_ref(head->read_var2);
 	up_read(&tomoyo_domain_keeper_list_lock);
 	return done;
 }
@@ -551,7 +557,7 @@ static bool tomoyo_is_domain_keeper(cons
 	bool flag = false;
 
 	down_read(&tomoyo_domain_keeper_list_lock);
-	list_for_each_entry(ptr, &tomoyo_domain_keeper_list, list) {
+	list_for_each_entry(ptr, &tomoyo_domain_keeper_list, entry.list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!ptr->is_last_name) {
@@ -638,7 +644,7 @@ static int tomoyo_update_alias_entry(con
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
 	down_write(&tomoyo_alias_list_lock);
-	list_for_each_entry(ptr, &tomoyo_alias_list, list) {
+	list_for_each_entry(ptr, &tomoyo_alias_list, entry.list) {
 		if (ptr->original_name != saved_original_name ||
 		    ptr->aliased_name != saved_aliased_name)
 			continue;
@@ -651,7 +657,7 @@ static int tomoyo_update_alias_entry(con
 		saved_original_name = NULL;
 		new_entry->aliased_name = saved_aliased_name;
 		saved_aliased_name = NULL;
-		list_add_tail(&new_entry->list, &tomoyo_alias_list);
+		list_add_tail(&new_entry->entry.list, &tomoyo_alias_list);
 		new_entry = NULL;
 		error = 0;
 	}
@@ -675,10 +681,11 @@ bool tomoyo_read_alias_policy(struct tom
 	bool done = true;
 
 	down_read(&tomoyo_alias_list_lock);
+	tomoyo_put_ref(head->read_var2);
 	list_for_each_cookie(pos, head->read_var2, &tomoyo_alias_list) {
 		struct tomoyo_alias_entry *ptr;
 
-		ptr = list_entry(pos, struct tomoyo_alias_entry, list);
+		ptr = list_entry(pos, struct tomoyo_alias_entry, entry.list);
 		if (ptr->is_deleted)
 			continue;
 		done = tomoyo_io_printf(head, TOMOYO_KEYWORD_ALIAS "%s %s\n",
@@ -687,6 +694,7 @@ bool tomoyo_read_alias_policy(struct tom
 		if (!done)
 			break;
 	}
+	tomoyo_get_ref(head->read_var2);
 	up_read(&tomoyo_alias_list_lock);
 	return done;
 }
@@ -722,64 +730,41 @@ struct tomoyo_domain_info *tomoyo_find_o
 							    const u8 profile)
 {
 	struct tomoyo_domain_info *new_domain = NULL;
-	struct tomoyo_domain_info *domain;
-	const struct tomoyo_path_info *saved_domainname;
+	struct tomoyo_domain_info *domain = NULL;
+	const struct tomoyo_path_info *saved_domainname = NULL;
+	bool found = true;
 
+	up_read(&tomoyo_domain_list_lock);
 	if (!tomoyo_is_correct_domain(domainname, __func__))
-		return NULL;
+		goto out;
 	saved_domainname = tomoyo_get_name(domainname);
 	if (!saved_domainname)
-		return NULL;
+		goto out;
 	new_domain = kmalloc(sizeof(*new_domain), GFP_KERNEL);
 	down_write(&tomoyo_domain_list_lock);
-	domain = tomoyo_find_domain(domainname);
-	if (domain)
-		goto out;
-	/* Can I reuse memory of deleted domain? */
-	list_for_each_entry(domain, &tomoyo_domain_list, list) {
-		struct task_struct *p;
-		struct tomoyo_acl_info *ptr;
-		bool flag;
-		if (!domain->is_deleted ||
+	list_for_each_entry(domain, &tomoyo_domain_list, entry.list) {
+		if (domain->is_deleted ||
 		    domain->domainname != saved_domainname)
 			continue;
-		flag = false;
-		read_lock(&tasklist_lock);
-		for_each_process(p) {
-			if (tomoyo_real_domain(p) != domain)
-				continue;
-			flag = true;
-			break;
-		}
-		read_unlock(&tasklist_lock);
-		if (flag)
-			continue;
-		list_for_each_entry(ptr, &domain->acl_info_list, list) {
-			ptr->type |= TOMOYO_ACL_DELETED;
-		}
-		domain->ignore_global_allow_read = false;
-		domain->domain_transition_failed = false;
-		domain->profile = profile;
-		domain->quota_warned = false;
-		mb(); /* Avoid out-of-order execution. */
-		domain->is_deleted = false;
-		goto out;
+		found = true;
+		break;
 	}
-	/* No memory reusable. Create using new memory. */
-	if (tomoyo_memory_ok(new_domain)) {
+	if (!found && tomoyo_memory_ok(new_domain)) {
 		domain = new_domain;
 		new_domain = NULL;
 		INIT_LIST_HEAD(&domain->acl_info_list);
 		domain->domainname = saved_domainname;
 		saved_domainname = NULL;
 		domain->profile = profile;
-		list_add_tail(&domain->list, &tomoyo_domain_list);
+		list_add_tail(&domain->entry.list, &tomoyo_domain_list);
+		found = true;
 	}
- out:
 	up_write(&tomoyo_domain_list_lock);
+ out:
 	tomoyo_put_name(saved_domainname);
 	kfree(new_domain);
-	return domain;
+	down_read(&tomoyo_domain_list_lock);
+	return found ? domain : NULL;
 }
 
 /**
@@ -849,7 +834,7 @@ int tomoyo_find_next_domain(struct linux
 		struct tomoyo_alias_entry *ptr;
 		/* Is this program allowed to be called via symbolic links? */
 		down_read(&tomoyo_alias_list_lock);
-		list_for_each_entry(ptr, &tomoyo_alias_list, list) {
+		list_for_each_entry(ptr, &tomoyo_alias_list, entry.list) {
 			if (ptr->is_deleted ||
 			    tomoyo_pathcmp(&r, ptr->original_name) ||
 			    tomoyo_pathcmp(&s, ptr->aliased_name))
@@ -889,30 +874,29 @@ int tomoyo_find_next_domain(struct linux
 		snprintf(new_domain_name, TOMOYO_MAX_PATHNAME_LEN + 1,
 			 "%s %s", old_domain_name, real_program_name);
 	}
+	down_read(&tomoyo_domain_list_lock);
 	if (domain || strlen(new_domain_name) >= TOMOYO_MAX_PATHNAME_LEN)
 		goto done;
-	down_read(&tomoyo_domain_list_lock);
 	domain = tomoyo_find_domain(new_domain_name);
-	up_read(&tomoyo_domain_list_lock);
-	if (domain)
-		goto done;
-	if (is_enforce)
-		goto done;
-	domain = tomoyo_find_or_assign_new_domain(new_domain_name,
-						  old_domain->profile);
+	if (!domain && !is_enforce)
+		domain = tomoyo_find_or_assign_new_domain(new_domain_name,
+							  old_domain->profile);
  done:
-	if (domain)
-		goto out;
-	printk(KERN_WARNING "TOMOYO-ERROR: Domain '%s' not defined.\n",
-	       new_domain_name);
-	if (is_enforce)
-		retval = -EPERM;
-	else
-		old_domain->domain_transition_failed = true;
+	if (!domain) {
+		printk(KERN_WARNING "TOMOYO-ERROR: Domain '%s' not defined.\n",
+		       new_domain_name);
+		if (is_enforce)
+			retval = -EPERM;
+		else
+			old_domain->domain_transition_failed = true;
+	}
  out:
 	if (!domain)
 		domain = old_domain;
+	BUG_ON(bprm->cred->security);
+	atomic_inc(&domain->entry.users);
 	bprm->cred->security = domain;
+	up_read(&tomoyo_domain_list_lock);
 	tomoyo_free(real_program_name);
 	tomoyo_free(symlink_program_name);
 	tomoyo_free(tmp);
--- linux-2.6.git.orig/security/tomoyo/file.c
+++ linux-2.6.git/security/tomoyo/file.c
@@ -25,7 +25,7 @@
  *      otherwise.
  */
 struct tomoyo_globally_readable_file_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *filename;
 	bool is_deleted;
 };
@@ -42,7 +42,7 @@ struct tomoyo_globally_readable_file_ent
  *      otherwise.
  */
 struct tomoyo_pattern_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *pattern;
 	bool is_deleted;
 };
@@ -59,7 +59,7 @@ struct tomoyo_pattern_entry {
  *      otherwise.
  */
 struct tomoyo_no_rewrite_entry {
-	struct list_head list;
+	struct tomoyo_entry entry;
 	const struct tomoyo_path_info *pattern;
 	bool is_deleted;
 };
@@ -222,7 +222,7 @@ static int tomoyo_update_globally_readab
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
 	down_write(&tomoyo_globally_readable_list_lock);
-	list_for_each_entry(ptr, &tomoyo_globally_readable_list, list) {
+	list_for_each_entry(ptr, &tomoyo_globally_readable_list, entry.list) {
 		if (ptr->filename != saved_filename)
 			continue;
 		ptr->is_deleted = is_delete;
@@ -232,7 +232,8 @@ static int tomoyo_update_globally_readab
 	if (!is_delete && error && tomoyo_memory_ok(new_entry)) {
 		new_entry->filename = saved_filename;
 		saved_filename = NULL;
-		list_add_tail(&new_entry->list, &tomoyo_globally_readable_list);
+		list_add_tail(&new_entry->entry.list,
+			      &tomoyo_globally_readable_list);
 		new_entry = NULL;
 		error = 0;
 	}
@@ -255,7 +256,7 @@ static bool tomoyo_is_globally_readable_
 	struct tomoyo_globally_readable_file_entry *ptr;
 	bool found = false;
 	down_read(&tomoyo_globally_readable_list_lock);
-	list_for_each_entry(ptr, &tomoyo_globally_readable_list, list) {
+	list_for_each_entry(ptr, &tomoyo_globally_readable_list, entry.list) {
 		if (!ptr->is_deleted &&
 		    tomoyo_path_matches_pattern(filename, ptr->filename)) {
 			found = true;
@@ -292,12 +293,13 @@ bool tomoyo_read_globally_readable_polic
 	bool done = true;
 
 	down_read(&tomoyo_globally_readable_list_lock);
+	tomoyo_put_ref(head->read_var2);
 	list_for_each_cookie(pos, head->read_var2,
 			     &tomoyo_globally_readable_list) {
 		struct tomoyo_globally_readable_file_entry *ptr;
 		ptr = list_entry(pos,
 				 struct tomoyo_globally_readable_file_entry,
-				 list);
+				 entry.list);
 		if (ptr->is_deleted)
 			continue;
 		done = tomoyo_io_printf(head, TOMOYO_KEYWORD_ALLOW_READ "%s\n",
@@ -305,6 +307,7 @@ bool tomoyo_read_globally_readable_polic
 		if (!done)
 			break;
 	}
+	tomoyo_get_ref(head->read_var2);
 	up_read(&tomoyo_globally_readable_list_lock);
 	return done;
 }
@@ -365,7 +368,7 @@ static int tomoyo_update_file_pattern_en
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
 	down_write(&tomoyo_pattern_list_lock);
-	list_for_each_entry(ptr, &tomoyo_pattern_list, list) {
+	list_for_each_entry(ptr, &tomoyo_pattern_list, entry.list) {
 		if (saved_pattern != ptr->pattern)
 			continue;
 		ptr->is_deleted = is_delete;
@@ -375,7 +378,7 @@ static int tomoyo_update_file_pattern_en
 	if (!is_delete && error && tomoyo_memory_ok(new_entry)) {
 		new_entry->pattern = saved_pattern;
 		saved_pattern = NULL;
-		list_add_tail(&new_entry->list, &tomoyo_pattern_list);
+		list_add_tail(&new_entry->entry.list, &tomoyo_pattern_list);
 		new_entry = NULL;
 		error = 0;
 	}
@@ -390,32 +393,44 @@ static int tomoyo_update_file_pattern_en
  *
  * @filename: The filename to find patterned pathname.
  *
- * Returns pointer to pathname pattern if matched, @filename otherwise.
+ * Returns pointer to "struct tomoyo_pattern_entry" if matched, NULL otherwise.
+ *
+ * Caller must call tomoyo_put_file_pattern() if this function didn't return
+ * NULL.
  */
-static const struct tomoyo_path_info *
+static struct tomoyo_pattern_entry *
 tomoyo_get_file_pattern(const struct tomoyo_path_info *filename)
 {
 	struct tomoyo_pattern_entry *ptr;
-	const struct tomoyo_path_info *pattern = NULL;
+	struct tomoyo_pattern_entry *pattern = NULL;
 
 	down_read(&tomoyo_pattern_list_lock);
-	list_for_each_entry(ptr, &tomoyo_pattern_list, list) {
+	list_for_each_entry(ptr, &tomoyo_pattern_list, entry.list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!tomoyo_path_matches_pattern(filename, ptr->pattern))
 			continue;
-		pattern = ptr->pattern;
-		if (tomoyo_strendswith(pattern->name, "/\\*")) {
+		pattern = ptr;
+		if (tomoyo_strendswith(ptr->pattern->name, "/\\*")) {
 			/* Do nothing. Try to find the better match. */
 		} else {
 			/* This would be the better match. Use this. */
 			break;
 		}
 	}
-	up_read(&tomoyo_pattern_list_lock);
 	if (pattern)
-		filename = pattern;
-	return filename;
+		atomic_inc(&pattern->entry.users);
+	up_read(&tomoyo_pattern_list_lock);
+	return pattern;
+}
+
+static void tomoyo_put_file_pattern(struct tomoyo_pattern_entry *name)
+{
+	if (!name)
+		return;
+	down_read(&tomoyo_pattern_list_lock);
+	atomic_dec(&name->entry.users);
+	up_read(&tomoyo_pattern_list_lock);
 }
 
 /**
@@ -444,9 +459,10 @@ bool tomoyo_read_file_pattern(struct tom
 	bool done = true;
 
 	down_read(&tomoyo_pattern_list_lock);
+	tomoyo_put_ref(head->read_var2);
 	list_for_each_cookie(pos, head->read_var2, &tomoyo_pattern_list) {
 		struct tomoyo_pattern_entry *ptr;
-		ptr = list_entry(pos, struct tomoyo_pattern_entry, list);
+		ptr = list_entry(pos, struct tomoyo_pattern_entry, entry.list);
 		if (ptr->is_deleted)
 			continue;
 		done = tomoyo_io_printf(head, TOMOYO_KEYWORD_FILE_PATTERN
@@ -454,6 +470,7 @@ bool tomoyo_read_file_pattern(struct tom
 		if (!done)
 			break;
 	}
+	tomoyo_get_ref(head->read_var2);
 	up_read(&tomoyo_pattern_list_lock);
 	return done;
 }
@@ -514,7 +531,7 @@ static int tomoyo_update_no_rewrite_entr
 	if (!is_delete)
 		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
 	down_write(&tomoyo_no_rewrite_list_lock);
-	list_for_each_entry(ptr, &tomoyo_no_rewrite_list, list) {
+	list_for_each_entry(ptr, &tomoyo_no_rewrite_list, entry.list) {
 		if (ptr->pattern != saved_pattern)
 			continue;
 		ptr->is_deleted = is_delete;
@@ -524,7 +541,7 @@ static int tomoyo_update_no_rewrite_entr
 	if (!is_delete && error && tomoyo_memory_ok(new_entry)) {
 		new_entry->pattern = saved_pattern;
 		saved_pattern = NULL;
-		list_add_tail(&new_entry->list, &tomoyo_no_rewrite_list);
+		list_add_tail(&new_entry->entry.list, &tomoyo_no_rewrite_list);
 		new_entry = NULL;
 		error = 0;
 	}
@@ -547,7 +564,7 @@ static bool tomoyo_is_no_rewrite_file(co
 	bool found = false;
 
 	down_read(&tomoyo_no_rewrite_list_lock);
-	list_for_each_entry(ptr, &tomoyo_no_rewrite_list, list) {
+	list_for_each_entry(ptr, &tomoyo_no_rewrite_list, entry.list) {
 		if (ptr->is_deleted)
 			continue;
 		if (!tomoyo_path_matches_pattern(filename, ptr->pattern))
@@ -585,9 +602,11 @@ bool tomoyo_read_no_rewrite_policy(struc
 	bool done = true;
 
 	down_read(&tomoyo_no_rewrite_list_lock);
+	tomoyo_put_ref(head->read_var2);
 	list_for_each_cookie(pos, head->read_var2, &tomoyo_no_rewrite_list) {
 		struct tomoyo_no_rewrite_entry *ptr;
-		ptr = list_entry(pos, struct tomoyo_no_rewrite_entry, list);
+		ptr = list_entry(pos, struct tomoyo_no_rewrite_entry,
+				 entry.list);
 		if (ptr->is_deleted)
 			continue;
 		done = tomoyo_io_printf(head, TOMOYO_KEYWORD_DENY_REWRITE
@@ -595,6 +614,7 @@ bool tomoyo_read_no_rewrite_policy(struc
 		if (!done)
 			break;
 	}
+	tomoyo_get_ref(head->read_var2);
 	up_read(&tomoyo_no_rewrite_list_lock);
 	return done;
 }
@@ -662,7 +682,7 @@ static int tomoyo_check_single_path_acl2
 	int error = -EPERM;
 
 	down_read(&tomoyo_domain_acl_info_list_lock);
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_single_path_acl_record *acl;
 		if (tomoyo_acl_type2(ptr) != TOMOYO_TYPE_SINGLE_PATH_ACL)
 			continue;
@@ -760,11 +780,13 @@ static int tomoyo_check_file_perm2(struc
 	if (is_enforce)
 		return error;
 	if (mode == 1 && tomoyo_domain_quota_is_ok(domain)) {
+		struct tomoyo_pattern_entry *p = NULL;
 		/* Don't use patterns for execute permission. */
-		const struct tomoyo_path_info *patterned_file = (perm != 1) ?
-			tomoyo_get_file_pattern(filename) : filename;
-		tomoyo_update_file_acl(patterned_file->name, perm,
-				       domain, false);
+		if (perm != 1)
+			p = tomoyo_get_file_pattern(filename);
+		tomoyo_update_file_acl(p ? p->pattern->name : filename->name,
+				       perm, domain, false);
+		tomoyo_put_file_pattern(p);
 	}
 	return 0;
 }
@@ -849,7 +871,7 @@ static int tomoyo_update_single_path_acl
 	down_write(&tomoyo_domain_acl_info_list_lock);
 	if (is_delete)
 		goto delete;
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_single_path_acl_record *acl;
 		if (tomoyo_acl_type1(ptr) != TOMOYO_TYPE_SINGLE_PATH_ACL)
 			continue;
@@ -877,13 +899,14 @@ static int tomoyo_update_single_path_acl
 			new_entry->perm |= rw_mask;
 		new_entry->filename = saved_filename;
 		saved_filename = NULL;
-		list_add_tail(&new_entry->head.list, &domain->acl_info_list);
+		list_add_tail(&new_entry->head.entry.list,
+			      &domain->acl_info_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	goto out;
  delete:
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_single_path_acl_record *acl;
 		if (tomoyo_acl_type2(ptr) != TOMOYO_TYPE_SINGLE_PATH_ACL)
 			continue;
@@ -948,7 +971,7 @@ static int tomoyo_update_double_path_acl
 	down_write(&tomoyo_domain_acl_info_list_lock);
 	if (is_delete)
 		goto delete;
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_double_path_acl_record *acl;
 		if (tomoyo_acl_type1(ptr) != TOMOYO_TYPE_DOUBLE_PATH_ACL)
 			continue;
@@ -973,13 +996,14 @@ static int tomoyo_update_double_path_acl
 		saved_filename1 = NULL;
 		new_entry->filename2 = saved_filename2;
 		saved_filename2 = NULL;
-		list_add_tail(&new_entry->head.list, &domain->acl_info_list);
+		list_add_tail(&new_entry->head.entry.list,
+			      &domain->acl_info_list);
 		new_entry = NULL;
 		error = 0;
 	}
 	goto out;
  delete:
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_double_path_acl_record *acl;
 		if (tomoyo_acl_type2(ptr) != TOMOYO_TYPE_DOUBLE_PATH_ACL)
 			continue;
@@ -1044,7 +1068,7 @@ static int tomoyo_check_double_path_acl(
 	if (!tomoyo_check_flags(domain, TOMOYO_MAC_FOR_FILE))
 		return 0;
 	down_read(&tomoyo_domain_acl_info_list_lock);
-	list_for_each_entry(ptr, &domain->acl_info_list, list) {
+	list_for_each_entry(ptr, &domain->acl_info_list, entry.list) {
 		struct tomoyo_double_path_acl_record *acl;
 		if (tomoyo_acl_type2(ptr) != TOMOYO_TYPE_DOUBLE_PATH_ACL)
 			continue;
@@ -1094,8 +1118,12 @@ static int tomoyo_check_single_path_perm
 		       tomoyo_get_msg(is_enforce), msg, filename->name,
 		       tomoyo_get_last_name(domain));
 	if (mode == 1 && tomoyo_domain_quota_is_ok(domain)) {
-		const char *name = tomoyo_get_file_pattern(filename)->name;
-		tomoyo_update_single_path_acl(operation, name, domain, false);
+		struct tomoyo_pattern_entry *p
+			= tomoyo_get_file_pattern(filename);
+		tomoyo_update_single_path_acl(operation,
+					      p ? p->pattern->name :
+					      filename->name, domain, false);
+		tomoyo_put_file_pattern(p);
 	}
 	if (!is_enforce)
 		error = 0;
@@ -1339,10 +1367,18 @@ int tomoyo_check_2path_perm(struct tomoy
 		       msg, buf1->name, buf2->name,
 		       tomoyo_get_last_name(domain));
 	if (mode == 1 && tomoyo_domain_quota_is_ok(domain)) {
-		const char *name1 = tomoyo_get_file_pattern(buf1)->name;
-		const char *name2 = tomoyo_get_file_pattern(buf2)->name;
-		tomoyo_update_double_path_acl(operation, name1, name2, domain,
+		struct tomoyo_pattern_entry *p1
+			= tomoyo_get_file_pattern(buf1);
+		struct tomoyo_pattern_entry *p2
+			= tomoyo_get_file_pattern(buf2);
+		tomoyo_update_double_path_acl(operation,
+					      p1 ? p1->pattern->name :
+					      buf1->name,
+					      p2 ? p2->pattern->name :
+					      buf2->name, domain,
 					      false);
+		tomoyo_put_file_pattern(p1);
+		tomoyo_put_file_pattern(p2);
 	}
  out:
 	tomoyo_free(buf1);
--- linux-2.6.git.orig/security/tomoyo/realpath.c
+++ linux-2.6.git/security/tomoyo/realpath.c
@@ -238,15 +238,10 @@ static unsigned int tomoyo_quota_for_sav
 /*
  * tomoyo_name_entry is a structure which is used for linking
  * "struct tomoyo_path_info" into tomoyo_name_list .
- *
- * Since tomoyo_name_list manages a list of strings which are shared by
- * multiple processes (whereas "struct tomoyo_path_info" inside
- * "struct tomoyo_path_info_with_data" is not shared), a reference counter will
- * be added to "struct tomoyo_name_entry" rather than "struct tomoyo_path_info"
- * when TOMOYO starts supporting garbage collector.
  */
 struct tomoyo_name_entry {
 	struct list_head list;
+	atomic_t users;
 	struct tomoyo_path_info entry;
 };
 
@@ -265,8 +260,6 @@ static DEFINE_MUTEX(tomoyo_name_list_loc
  * @name: The string to store into the permernent memory.
  *
  * Returns pointer to "struct tomoyo_path_info" on success, NULL otherwise.
- *
- * The RAM is shared, so NEVER try to modify or kfree() the returned name.
  */
 const struct tomoyo_path_info *tomoyo_get_name(const char *name)
 {
@@ -291,6 +284,7 @@ const struct tomoyo_path_info *tomoyo_ge
 			    list) {
 		if (hash != ptr->entry.hash || strcmp(name, ptr->entry.name))
 			continue;
+		atomic_inc(&ptr->users);
 		error = 0;
 		break;
 	}
@@ -305,6 +299,7 @@ const struct tomoyo_path_info *tomoyo_ge
 		ptr->entry.name = ((char *) ptr) + sizeof(*ptr);
 		memmove((char *) ptr->entry.name, name, len);
 		tomoyo_fill_path_info(&ptr->entry);
+		atomic_set(&ptr->users, 1);
 		list_add_tail(&ptr->list,
 			      &tomoyo_name_list[hash % TOMOYO_MAX_HASH]);
 		entry = NULL;
@@ -332,7 +327,7 @@ void __init tomoyo_realpath_init(void)
 		INIT_LIST_HEAD(&tomoyo_name_list[i]);
 	INIT_LIST_HEAD(&tomoyo_kernel_domain.acl_info_list);
 	tomoyo_kernel_domain.domainname = tomoyo_get_name(TOMOYO_ROOT_NAME);
-	list_add_tail(&tomoyo_kernel_domain.list, &tomoyo_domain_list);
+	list_add_tail(&tomoyo_kernel_domain.entry.list, &tomoyo_domain_list);
 	down_read(&tomoyo_domain_list_lock);
 	if (tomoyo_find_domain(TOMOYO_ROOT_NAME) != &tomoyo_kernel_domain)
 		panic("Can't register tomoyo_kernel_domain");
--- linux-2.6.git.orig/security/tomoyo/tomoyo.c
+++ linux-2.6.git/security/tomoyo/tomoyo.c
@@ -22,9 +22,19 @@ static int tomoyo_cred_prepare(struct cr
 	 * we don't need to duplicate.
 	 */
 	new->security = old->security;
+	if (new->security)
+		atomic_inc(&((struct tomoyo_domain_info *)
+			     new->security)->entry.users);
 	return 0;
 }
 
+static void tomoyo_cred_free(struct cred *cred)
+{
+	struct tomoyo_domain_info *domain = cred->security;
+	if (domain)
+		atomic_dec(&domain->entry.users);
+}
+
 static int tomoyo_bprm_set_creds(struct linux_binprm *bprm)
 {
 	int rc;
@@ -49,7 +59,11 @@ static int tomoyo_bprm_set_creds(struct 
 	 * Tell tomoyo_bprm_check_security() is called for the first time of an
 	 * execve operation.
 	 */
-	bprm->cred->security = NULL;
+	if (bprm->cred->security) {
+		atomic_dec(&((struct tomoyo_domain_info *)
+			     bprm->cred->security)->entry.users);
+		bprm->cred->security = NULL;
+	}
 	return 0;
 }
 
@@ -263,6 +277,7 @@ static int tomoyo_dentry_open(struct fil
 static struct security_operations tomoyo_security_ops = {
 	.name                = "tomoyo",
 	.cred_prepare        = tomoyo_cred_prepare,
+	.cred_free           = tomoyo_cred_free,
 	.bprm_set_creds      = tomoyo_bprm_set_creds,
 	.bprm_check_security = tomoyo_bprm_check_security,
 #ifdef CONFIG_SYSCTL
@@ -291,6 +306,7 @@ static int __init tomoyo_init(void)
 		panic("Failure registering TOMOYO Linux");
 	printk(KERN_INFO "TOMOYO Linux initialized\n");
 	cred->security = &tomoyo_kernel_domain;
+	atomic_inc(&tomoyo_kernel_domain.entry.users);
 	tomoyo_realpath_init();
 	return 0;
 }
