Index: trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c	(working copy)
@@ -1,93 +0,0 @@
-/*
- * security/ccsecurity/autobind.c
- *
- * Copyright (C) 2005-2011  NTT DATA CORPORATION
- *
- * Version: 1.8.3   2011/09/29
- */
-
-#include "internal.h"
-
-/* Bitmap for reserved local port numbers.*/
-static u8 ccs_reserved_port_map[8192];
-
-/**
- * ccs_lport_reserved - Check whether local port is reserved or not.
- *
- * @port: Port number.
- *
- * Returns true if local port is reserved, false otherwise.
- */
-static bool __ccs_lport_reserved(const u16 port)
-{
-	return ccs_reserved_port_map[port >> 3] & (1 << (port & 7))
-		? true : false;
-}
-
-/**
- * ccs_same_reserved - Check for duplicated "struct ccs_reserved" entry.
- *
- * @a: Pointer to "struct ccs_acl_head".
- * @b: Pointer to "struct ccs_acl_head".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_reserved(const struct ccs_acl_head *a,
-			      const struct ccs_acl_head *b)
-{
-	const struct ccs_reserved *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_reserved *p2 = container_of(b, typeof(*p2), head);
-	return ccs_same_number_union(&p1->port, &p2->port);
-}
-
-/**
- * ccs_write_reserved_port - Update "struct ccs_reserved" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-int ccs_write_reserved_port(struct ccs_acl_param *param)
-{
-	struct ccs_reserved e = { };
-	struct ccs_policy_namespace *ns = param->ns;
-	int error;
-	u8 *tmp;
-	if (param->data[0] == '@' || !ccs_parse_number_union(param, &e.port) ||
-	    e.port.values[1] > 65535 || param->data[0])
-		return -EINVAL;
-	param->list = &ns->policy_list[CCS_ID_RESERVEDPORT];
-	error = ccs_update_policy(&e.head, sizeof(e), param,
-				  ccs_same_reserved);
-	/*
-	 * ccs_put_number_union() is not needed because param->data[0] != '@'.
-	 */
-	if (error)
-		return error;
-	tmp = kzalloc(sizeof(ccs_reserved_port_map), CCS_GFP_FLAGS);
-	if (!tmp)
-		return -ENOMEM;
-	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
-				 &ccs_ss) {
-		struct ccs_reserved *ptr;
-		struct list_head *list = &ns->policy_list[CCS_ID_RESERVEDPORT];
-		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
-			unsigned int port;
-			if (ptr->head.is_deleted)
-				continue;
-			for (port = ptr->port.values[0];
-			     port <= ptr->port.values[1]; port++)
-				tmp[port >> 3] |= 1 << (port & 7);
-		}
-	}
-	memmove(ccs_reserved_port_map, tmp, sizeof(ccs_reserved_port_map));
-	kfree(tmp);
-	/*
-	 * Since this feature is no-op by default, we don't need to register
-	 * this callback hook unless the first entry is added.
-	 */
-	ccsecurity_ops.lport_reserved = __ccs_lport_reserved;
-	return 0;
-}
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c	(working copy)
@@ -15,133 +15,6 @@
 LIST_HEAD(ccs_domain_list);
 
 /**
- * ccs_update_policy - Update an entry for exception policy.
- *
- * @new_entry:       Pointer to "struct ccs_acl_info".
- * @size:            Size of @new_entry in bytes.
- * @param:           Pointer to "struct ccs_acl_param".
- * @check_duplicate: Callback function to find duplicated entry.
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      struct ccs_acl_param *param,
-		      bool (*check_duplicate) (const struct ccs_acl_head *,
-					       const struct ccs_acl_head *))
-{
-	int error = param->is_delete ? -ENOENT : -ENOMEM;
-	struct ccs_acl_head *entry;
-	struct list_head *list = param->list;
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		return -ENOMEM;
-	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
-		if (entry->is_deleted == CCS_GC_IN_PROGRESS)
-			continue;
-		if (!check_duplicate(entry, new_entry))
-			continue;
-		entry->is_deleted = param->is_delete;
-		error = 0;
-		break;
-	}
-	if (error && !param->is_delete) {
-		entry = ccs_commit_ok(new_entry, size);
-		if (entry) {
-			list_add_tail_rcu(&entry->list, list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
-	return error;
-}
-
-/**
- * ccs_same_acl_head - Check for duplicated "struct ccs_acl_info" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static inline bool ccs_same_acl_head(const struct ccs_acl_info *a,
-				     const struct ccs_acl_info *b)
-{
-	return a->type == b->type && a->cond == b->cond;
-}
-
-/**
- * ccs_update_domain - Update an entry for domain policy.
- *
- * @new_entry:       Pointer to "struct ccs_acl_info".
- * @size:            Size of @new_entry in bytes.
- * @param:           Pointer to "struct ccs_acl_param".
- * @check_duplicate: Callback function to find duplicated entry.
- * @merge_duplicate: Callback function to merge duplicated entry. Maybe NULL.
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-int ccs_update_domain(struct ccs_acl_info *new_entry, const int size,
-		      struct ccs_acl_param *param,
-		      bool (*check_duplicate) (const struct ccs_acl_info *,
-					       const struct ccs_acl_info *),
-		      bool (*merge_duplicate) (struct ccs_acl_info *,
-					       struct ccs_acl_info *,
-					       const bool))
-{
-	const bool is_delete = param->is_delete;
-	int error = is_delete ? -ENOENT : -ENOMEM;
-	struct ccs_acl_info *entry;
-	struct list_head * const list = param->list;
-	if (param->data[0]) {
-		new_entry->cond = ccs_get_condition(param);
-		if (!new_entry->cond)
-			return -EINVAL;
-		/*
-		 * Domain transition preference is allowed for only
-		 * "file execute"/"task auto_execute_handler"/
-		 * "task denied_auto_execute_handler" entries.
-		 */
-		if (new_entry->cond->exec_transit &&
-		    !(new_entry->type == CCS_TYPE_PATH_ACL &&
-		      container_of(new_entry, struct ccs_path_acl, head)->perm
-		      == 1 << CCS_TYPE_EXECUTE) &&
-		    new_entry->type != CCS_TYPE_AUTO_EXECUTE_HANDLER &&
-		    new_entry->type != CCS_TYPE_DENIED_EXECUTE_HANDLER)
-			goto out;
-	}
-	if (mutex_lock_interruptible(&ccs_policy_lock))
-		goto out;
-	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
-		if (entry->is_deleted == CCS_GC_IN_PROGRESS)
-			continue;
-		if (!ccs_same_acl_head(entry, new_entry) ||
-		    !check_duplicate(entry, new_entry))
-			continue;
-		if (merge_duplicate)
-			entry->is_deleted = merge_duplicate(entry, new_entry,
-							    is_delete);
-		else
-			entry->is_deleted = is_delete;
-		error = 0;
-		break;
-	}
-	if (error && !is_delete) {
-		entry = ccs_commit_ok(new_entry, size);
-		if (entry) {
-			list_add_tail_rcu(&entry->list, list);
-			error = 0;
-		}
-	}
-	mutex_unlock(&ccs_policy_lock);
-out:
-	ccs_put_condition(new_entry->cond);
-	return error;
-}
-
-/**
  * ccs_check_acl - Do permission check.
  *
  * @r:           Pointer to "struct ccs_request_info".
@@ -183,74 +56,6 @@
 }
 
 /**
- * ccs_same_transition_control - Check for duplicated "struct ccs_transition_control" entry.
- *
- * @a: Pointer to "struct ccs_acl_head".
- * @b: Pointer to "struct ccs_acl_head".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_transition_control(const struct ccs_acl_head *a,
-					const struct ccs_acl_head *b)
-{
-	const struct ccs_transition_control *p1 = container_of(a, typeof(*p1),
-							       head);
-	const struct ccs_transition_control *p2 = container_of(b, typeof(*p2),
-							       head);
-	return p1->type == p2->type && p1->is_last_name == p2->is_last_name
-		&& p1->domainname == p2->domainname
-		&& p1->program == p2->program;
-}
-
-/**
- * ccs_write_transition_control - Write "struct ccs_transition_control" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- * @type:  Type of this entry.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_transition_control(struct ccs_acl_param *param, const u8 type)
-{
-	struct ccs_transition_control e = { .type = type };
-	int error = param->is_delete ? -ENOENT : -ENOMEM;
-	char *program = param->data;
-	char *domainname = strstr(program, " from ");
-	if (domainname) {
-		*domainname = '\0';
-		domainname += 6;
-	} else if (type == CCS_TRANSITION_CONTROL_NO_KEEP ||
-		   type == CCS_TRANSITION_CONTROL_KEEP) {
-		domainname = program;
-		program = NULL;
-	}
-	if (program && strcmp(program, "any")) {
-		if (!ccs_correct_path(program))
-			return -EINVAL;
-		e.program = ccs_get_name(program);
-		if (!e.program)
-			goto out;
-	}
-	if (domainname && strcmp(domainname, "any")) {
-		if (!ccs_correct_domain(domainname)) {
-			if (!ccs_correct_path(domainname))
-				goto out;
-			e.is_last_name = true;
-		}
-		e.domainname = ccs_get_name(domainname);
-		if (!e.domainname)
-			goto out;
-	}
-	param->list = &param->ns->policy_list[CCS_ID_TRANSITION_CONTROL];
-	error = ccs_update_policy(&e.head, sizeof(e), param,
-				  ccs_same_transition_control);
-out:
-	ccs_put_name(e.domainname);
-	ccs_put_name(e.program);
-	return error;
-}
-
-/**
  * ccs_last_word - Get last component of a domainname.
  *
  * @name: Domainname to check.
@@ -351,53 +156,6 @@
 	return type;
 }
 
-/**
- * ccs_same_aggregator - Check for duplicated "struct ccs_aggregator" entry.
- *
- * @a: Pointer to "struct ccs_acl_head".
- * @b: Pointer to "struct ccs_acl_head".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_aggregator(const struct ccs_acl_head *a,
-				const struct ccs_acl_head *b)
-{
-	const struct ccs_aggregator *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_aggregator *p2 = container_of(b, typeof(*p2), head);
-	return p1->original_name == p2->original_name &&
-		p1->aggregated_name == p2->aggregated_name;
-}
-
-/**
- * ccs_write_aggregator - Write "struct ccs_aggregator" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_aggregator(struct ccs_acl_param *param)
-{
-	struct ccs_aggregator e = { };
-	int error = param->is_delete ? -ENOENT : -ENOMEM;
-	const char *original_name = ccs_read_token(param);
-	const char *aggregated_name = ccs_read_token(param);
-	if (!ccs_correct_word(original_name) ||
-	    !ccs_correct_path(aggregated_name))
-		return -EINVAL;
-	e.original_name = ccs_get_name(original_name);
-	e.aggregated_name = ccs_get_name(aggregated_name);
-	if (!e.original_name || !e.aggregated_name ||
-	    e.aggregated_name->is_patterned) /* No patterns allowed. */
-		goto out;
-	param->list = &param->ns->policy_list[CCS_ID_AGGREGATOR];
-	error = ccs_update_policy(&e.head, sizeof(e), param,
-				  ccs_same_aggregator);
-out:
-	ccs_put_name(e.original_name);
-	ccs_put_name(e.aggregated_name);
-	return error;
-}
-
 /* Domain create handler. */
 
 /**
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/util.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/util.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/util.c	(working copy)
@@ -1048,28 +1048,12 @@
 			continue;
 		switch (ptr->type) {
 		case CCS_TYPE_PATH_ACL:
-			perm = container_of(ptr, struct ccs_path_acl,
-					    head)->perm;
-			break;
 		case CCS_TYPE_PATH2_ACL:
-			perm = container_of(ptr, struct ccs_path2_acl,
-					    head)->perm;
-			break;
 		case CCS_TYPE_PATH_NUMBER_ACL:
-			perm = container_of(ptr, struct ccs_path_number_acl,
-					    head)->perm;
-			break;
 		case CCS_TYPE_MKDEV_ACL:
-			perm = container_of(ptr, struct ccs_mkdev_acl,
-					    head)->perm;
-			break;
 		case CCS_TYPE_INET_ACL:
-			perm = container_of(ptr, struct ccs_inet_acl,
-					    head)->perm;
-			break;
 		case CCS_TYPE_UNIX_ACL:
-			perm = container_of(ptr, struct ccs_unix_acl,
-					    head)->perm;
+			perm = ptr->perm;
 			break;
 		case CCS_TYPE_AUTO_EXECUTE_HANDLER:
 		case CCS_TYPE_DENIED_EXECUTE_HANDLER:
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/signal.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/signal.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/signal.c	(working copy)
@@ -146,47 +146,6 @@
 }
 
 /**
- * ccs_same_signal_acl - Check for duplicated "struct ccs_signal_acl" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_signal_acl(const struct ccs_acl_info *a,
-				const struct ccs_acl_info *b)
-{
-	const struct ccs_signal_acl *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_signal_acl *p2 = container_of(b, typeof(*p2), head);
-	return ccs_same_number_union(&p1->sig, &p2->sig) &&
-		p1->domainname == p2->domainname;
-}
-
-/**
- * ccs_write_ipc - Update "struct ccs_signal_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_ipc(struct ccs_acl_param *param)
-{
-	struct ccs_signal_acl e = { .head.type = CCS_TYPE_SIGNAL_ACL };
-	int error;
-	if (!ccs_parse_number_union(param, &e.sig))
-		return -EINVAL;
-	e.domainname = ccs_get_domainname(param);
-	if (!e.domainname)
-		error = -EINVAL;
-	else
-		error = ccs_update_domain(&e.head, sizeof(e), param,
-					  ccs_same_signal_acl, NULL);
-	ccs_put_name(e.domainname);
-	ccs_put_number_union(&e.sig);
-	return error;
-}
-
-/**
  * ccs_signal_init - Register ipc related hooks.
  *
  * Returns nothing.
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/file.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/file.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/file.c	(working copy)
@@ -264,7 +264,7 @@
 			       const struct ccs_acl_info *ptr)
 {
 	const struct ccs_path_acl *acl = container_of(ptr, typeof(*acl), head);
-	if (acl->perm & (1 << r->param.path.operation)) {
+	if (ptr->perm & (1 << r->param.path.operation)) {
 		r->param.path.matched_path =
 			ccs_compare_name_union(r->param.path.filename,
 					       &acl->name);
@@ -286,7 +286,7 @@
 {
 	const struct ccs_path_number_acl *acl =
 		container_of(ptr, typeof(*acl), head);
-	return (acl->perm & (1 << r->param.path_number.operation)) &&
+	return (ptr->perm & (1 << r->param.path_number.operation)) &&
 		ccs_compare_number_union(r->param.path_number.number,
 					 &acl->number) &&
 		ccs_compare_name_union(r->param.path_number.filename,
@@ -306,7 +306,7 @@
 {
 	const struct ccs_path2_acl *acl =
 		container_of(ptr, typeof(*acl), head);
-	return (acl->perm & (1 << r->param.path2.operation)) &&
+	return (ptr->perm & (1 << r->param.path2.operation)) &&
 		ccs_compare_name_union(r->param.path2.filename1, &acl->name1)
 		&& ccs_compare_name_union(r->param.path2.filename2,
 					  &acl->name2);
@@ -325,7 +325,7 @@
 {
 	const struct ccs_mkdev_acl *acl =
 		container_of(ptr, typeof(*acl), head);
-	return (acl->perm & (1 << r->param.mkdev.operation)) &&
+	return (ptr->perm & (1 << r->param.mkdev.operation)) &&
 		ccs_compare_number_union(r->param.mkdev.mode, &acl->mode) &&
 		ccs_compare_number_union(r->param.mkdev.major, &acl->major) &&
 		ccs_compare_number_union(r->param.mkdev.minor, &acl->minor) &&
@@ -333,263 +333,6 @@
 }
 
 /**
- * ccs_same_path_acl - Check for duplicated "struct ccs_path_acl" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b except permission bits, false otherwise.
- */
-static bool ccs_same_path_acl(const struct ccs_acl_info *a,
-			      const struct ccs_acl_info *b)
-{
-	const struct ccs_path_acl *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_path_acl *p2 = container_of(b, typeof(*p2), head);
-	return ccs_same_name_union(&p1->name, &p2->name);
-}
-
-/**
- * ccs_merge_path_acl - Merge duplicated "struct ccs_path_acl" entry.
- *
- * @a:         Pointer to "struct ccs_acl_info".
- * @b:         Pointer to "struct ccs_acl_info".
- * @is_delete: True for @a &= ~@b, false for @a |= @b.
- *
- * Returns true if @a is empty, false otherwise.
- */
-static bool ccs_merge_path_acl(struct ccs_acl_info *a, struct ccs_acl_info *b,
-			       const bool is_delete)
-{
-	u16 * const a_perm = &container_of(a, struct ccs_path_acl, head)->perm;
-	u16 perm = *a_perm;
-	const u16 b_perm = container_of(b, struct ccs_path_acl, head)->perm;
-	if (is_delete)
-		perm &= ~b_perm;
-	else
-		perm |= b_perm;
-	*a_perm = perm;
-	return !perm;
-}
-
-/**
- * ccs_update_path_acl - Update "struct ccs_path_acl" list.
- *
- * @perm:  Permission.
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_update_path_acl(const u16 perm, struct ccs_acl_param *param)
-{
-	struct ccs_path_acl e = {
-		.head.type = CCS_TYPE_PATH_ACL,
-		.perm = perm
-	};
-	int error;
-	if (!ccs_parse_name_union(param, &e.name))
-		error = -EINVAL;
-	else
-		error = ccs_update_domain(&e.head, sizeof(e), param,
-					  ccs_same_path_acl,
-					  ccs_merge_path_acl);
-	ccs_put_name_union(&e.name);
-	return error;
-}
-
-/**
- * ccs_same_mkdev_acl - Check for duplicated "struct ccs_mkdev_acl" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b except permission bits, false otherwise.
- */
-static bool ccs_same_mkdev_acl(const struct ccs_acl_info *a,
-			       const struct ccs_acl_info *b)
-{
-	const struct ccs_mkdev_acl *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_mkdev_acl *p2 = container_of(b, typeof(*p2), head);
-	return ccs_same_name_union(&p1->name, &p2->name) &&
-		ccs_same_number_union(&p1->mode, &p2->mode) &&
-		ccs_same_number_union(&p1->major, &p2->major) &&
-		ccs_same_number_union(&p1->minor, &p2->minor);
-}
-
-/**
- * ccs_merge_mkdev_acl - Merge duplicated "struct ccs_mkdev_acl" entry.
- *
- * @a:         Pointer to "struct ccs_acl_info".
- * @b:         Pointer to "struct ccs_acl_info".
- * @is_delete: True for @a &= ~@b, false for @a |= @b.
- *
- * Returns true if @a is empty, false otherwise.
- */
-static bool ccs_merge_mkdev_acl(struct ccs_acl_info *a, struct ccs_acl_info *b,
-				const bool is_delete)
-{
-	u8 *const a_perm = &container_of(a, struct ccs_mkdev_acl, head)->perm;
-	u8 perm = *a_perm;
-	const u8 b_perm = container_of(b, struct ccs_mkdev_acl, head)->perm;
-	if (is_delete)
-		perm &= ~b_perm;
-	else
-		perm |= b_perm;
-	*a_perm = perm;
-	return !perm;
-}
-
-/**
- * ccs_update_mkdev_acl - Update "struct ccs_mkdev_acl" list.
- *
- * @perm:  Permission.
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_update_mkdev_acl(const u8 perm, struct ccs_acl_param *param)
-{
-	struct ccs_mkdev_acl e = {
-		.head.type = CCS_TYPE_MKDEV_ACL,
-		.perm = perm
-	};
-	int error;
-	if (!ccs_parse_name_union(param, &e.name) ||
-	    !ccs_parse_number_union(param, &e.mode) ||
-	    !ccs_parse_number_union(param, &e.major) ||
-	    !ccs_parse_number_union(param, &e.minor))
-		error = -EINVAL;
-	else
-		error = ccs_update_domain(&e.head, sizeof(e), param,
-					  ccs_same_mkdev_acl,
-					  ccs_merge_mkdev_acl);
-	ccs_put_name_union(&e.name);
-	ccs_put_number_union(&e.mode);
-	ccs_put_number_union(&e.major);
-	ccs_put_number_union(&e.minor);
-	return error;
-}
-
-/**
- * ccs_same_path2_acl - Check for duplicated "struct ccs_path2_acl" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b except permission bits, false otherwise.
- */
-static bool ccs_same_path2_acl(const struct ccs_acl_info *a,
-			       const struct ccs_acl_info *b)
-{
-	const struct ccs_path2_acl *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_path2_acl *p2 = container_of(b, typeof(*p2), head);
-	return ccs_same_name_union(&p1->name1, &p2->name1) &&
-		ccs_same_name_union(&p1->name2, &p2->name2);
-}
-
-/**
- * ccs_merge_path2_acl - Merge duplicated "struct ccs_path2_acl" entry.
- *
- * @a:         Pointer to "struct ccs_acl_info".
- * @b:         Pointer to "struct ccs_acl_info".
- * @is_delete: True for @a &= ~@b, false for @a |= @b.
- *
- * Returns true if @a is empty, false otherwise.
- */
-static bool ccs_merge_path2_acl(struct ccs_acl_info *a, struct ccs_acl_info *b,
-				const bool is_delete)
-{
-	u8 * const a_perm = &container_of(a, struct ccs_path2_acl, head)->perm;
-	u8 perm = *a_perm;
-	const u8 b_perm = container_of(b, struct ccs_path2_acl, head)->perm;
-	if (is_delete)
-		perm &= ~b_perm;
-	else
-		perm |= b_perm;
-	*a_perm = perm;
-	return !perm;
-}
-
-/**
- * ccs_update_path2_acl - Update "struct ccs_path2_acl" list.
- *
- * @perm:  Permission.
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_update_path2_acl(const u8 perm, struct ccs_acl_param *param)
-{
-	struct ccs_path2_acl e = {
-		.head.type = CCS_TYPE_PATH2_ACL,
-		.perm = perm
-	};
-	int error;
-	if (!ccs_parse_name_union(param, &e.name1) ||
-	    !ccs_parse_name_union(param, &e.name2))
-		error = -EINVAL;
-	else
-		error = ccs_update_domain(&e.head, sizeof(e), param,
-					  ccs_same_path2_acl,
-					  ccs_merge_path2_acl);
-	ccs_put_name_union(&e.name1);
-	ccs_put_name_union(&e.name2);
-	return error;
-}
-
-/**
- * ccs_same_mount_acl - Check for duplicated "struct ccs_mount_acl" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_mount_acl(const struct ccs_acl_info *a,
-			       const struct ccs_acl_info *b)
-{
-	const struct ccs_mount_acl *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_mount_acl *p2 = container_of(b, typeof(*p2), head);
-	return ccs_same_name_union(&p1->dev_name, &p2->dev_name) &&
-		ccs_same_name_union(&p1->dir_name, &p2->dir_name) &&
-		ccs_same_name_union(&p1->fs_type, &p2->fs_type) &&
-		ccs_same_number_union(&p1->flags, &p2->flags);
-}
-
-/**
- * ccs_update_mount_acl - Write "struct ccs_mount_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_update_mount_acl(struct ccs_acl_param *param)
-{
-	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL };
-	int error;
-	if (!ccs_parse_name_union(param, &e.dev_name) ||
-	    !ccs_parse_name_union(param, &e.dir_name) ||
-	    !ccs_parse_name_union(param, &e.fs_type) ||
-	    !ccs_parse_number_union(param, &e.flags))
-		error = -EINVAL;
-	else
-		error = ccs_update_domain(&e.head, sizeof(e), param,
-					  ccs_same_mount_acl, NULL);
-	ccs_put_name_union(&e.dev_name);
-	ccs_put_name_union(&e.dir_name);
-	ccs_put_name_union(&e.fs_type);
-	ccs_put_number_union(&e.flags);
-	return error;
-}
-
-/**
  * ccs_path_permission - Check permission for path operation.
  *
  * @r:         Pointer to "struct ccs_request_info".
@@ -964,79 +707,6 @@
 }
 
 /**
- * ccs_same_path_number_acl - Check for duplicated "struct ccs_path_number_acl" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b except permission bits, false otherwise.
- */
-static bool ccs_same_path_number_acl(const struct ccs_acl_info *a,
-				     const struct ccs_acl_info *b)
-{
-	const struct ccs_path_number_acl *p1 = container_of(a, typeof(*p1),
-							    head);
-	const struct ccs_path_number_acl *p2 = container_of(b, typeof(*p2),
-							    head);
-	return ccs_same_name_union(&p1->name, &p2->name) &&
-		ccs_same_number_union(&p1->number, &p2->number);
-}
-
-/**
- * ccs_merge_path_number_acl - Merge duplicated "struct ccs_path_number_acl" entry.
- *
- * @a:         Pointer to "struct ccs_acl_info".
- * @b:         Pointer to "struct ccs_acl_info".
- * @is_delete: True for @a &= ~@b, false for @a |= @b.
- *
- * Returns true if @a is empty, false otherwise.
- */
-static bool ccs_merge_path_number_acl(struct ccs_acl_info *a,
-				      struct ccs_acl_info *b,
-				      const bool is_delete)
-{
-	u8 * const a_perm = &container_of(a, struct ccs_path_number_acl, head)
-		->perm;
-	u8 perm = *a_perm;
-	const u8 b_perm = container_of(b, struct ccs_path_number_acl, head)
-		->perm;
-	if (is_delete)
-		perm &= ~b_perm;
-	else
-		perm |= b_perm;
-	*a_perm = perm;
-	return !perm;
-}
-
-/**
- * ccs_update_path_number_acl - Update create/mkdir/mkfifo/mksock/ioctl/chmod/chown/chgrp ACL.
- *
- * @perm:  Permission.
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-static int ccs_update_path_number_acl(const u8 perm,
-				      struct ccs_acl_param *param)
-{
-	struct ccs_path_number_acl e = {
-		.head.type = CCS_TYPE_PATH_NUMBER_ACL,
-		.perm = perm
-	};
-	int error;
-	if (!ccs_parse_name_union(param, &e.name) ||
-	    !ccs_parse_number_union(param, &e.number))
-		error = -EINVAL;
-	else
-		error = ccs_update_domain(&e.head, sizeof(e), param,
-					  ccs_same_path_number_acl,
-					  ccs_merge_path_number_acl);
-	ccs_put_name_union(&e.name);
-	ccs_put_number_union(&e.number);
-	return error;
-}
-
-/**
  * ccs_path_number_perm - Check permission for "create", "mkdir", "mkfifo", "mksock", "ioctl", "chmod", "chown", "chgrp".
  *
  * @type:   Type of operation.
@@ -1211,46 +881,6 @@
 }
 
 /**
- * ccs_write_file - Update file related list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-int ccs_write_file(struct ccs_acl_param *param)
-{
-	u16 perm = 0;
-	u8 type;
-	const char *operation = ccs_read_token(param);
-	for (type = 0; type < CCS_MAX_PATH_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_path_keyword[type]))
-			perm |= 1 << type;
-	if (perm)
-		return ccs_update_path_acl(perm, param);
-	for (type = 0; type < CCS_MAX_PATH2_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_mac_keywords[ccs_pp2mac[type]]))
-			perm |= 1 << type;
-	if (perm)
-		return ccs_update_path2_acl(perm, param);
-	for (type = 0; type < CCS_MAX_PATH_NUMBER_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_mac_keywords[ccs_pn2mac[type]]))
-			perm |= 1 << type;
-	if (perm)
-		return ccs_update_path_number_acl(perm, param);
-	for (type = 0; type < CCS_MAX_MKDEV_OPERATION; type++)
-		if (ccs_permstr(operation,
-				ccs_mac_keywords[ccs_pnnn2mac[type]]))
-			perm |= 1 << type;
-	if (perm)
-		return ccs_update_mkdev_acl(perm, param);
-	if (ccs_permstr(operation, ccs_mac_keywords[CCS_MAC_FILE_MOUNT]))
-		return ccs_update_mount_acl(param);
-	return -EINVAL;
-}
-
-/**
  * __ccs_mknod_permission - Check permission for vfs_mknod().
  *
  * @dentry: Pointer to "struct dentry".
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/environ.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/environ.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/environ.c	(working copy)
@@ -61,58 +61,3 @@
 	} while (error == CCS_RETRY_REQUEST);
 	return error;
 }
-
-/**
- * ccs_same_env_acl - Check for duplicated "struct ccs_env_acl" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_env_acl(const struct ccs_acl_info *a,
-			     const struct ccs_acl_info *b)
-{
-	const struct ccs_env_acl *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_env_acl *p2 = container_of(b, typeof(*p2), head);
-	return p1->env == p2->env;
-}
-
-/**
- * ccs_write_env - Write "struct ccs_env_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-static int ccs_write_env(struct ccs_acl_param *param)
-{
-	struct ccs_env_acl e = { .head.type = CCS_TYPE_ENV_ACL };
-	int error = -ENOMEM;
-	const char *data = ccs_read_token(param);
-	if (!ccs_correct_word(data) || strchr(data, '='))
-		return -EINVAL;
-	e.env = ccs_get_name(data);
-	if (!e.env)
-		return error;
-	error = ccs_update_domain(&e.head, sizeof(e), param,
-				  ccs_same_env_acl, NULL);
-	ccs_put_name(e.env);
-	return error;
-}
-
-/**
- * ccs_write_misc - Update environment variable list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_misc(struct ccs_acl_param *param)
-{
-	if (ccs_str_starts(&param->data, "env "))
-		return ccs_write_env(param);
-	return -EINVAL;
-}
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/capability.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/capability.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/capability.c	(working copy)
@@ -96,48 +96,6 @@
 }
 
 /**
- * ccs_same_capability_acl - Check for duplicated "struct ccs_capability_acl" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_capability_acl(const struct ccs_acl_info *a,
-				    const struct ccs_acl_info *b)
-{
-	const struct ccs_capability_acl *p1 = container_of(a, typeof(*p1),
-							   head);
-	const struct ccs_capability_acl *p2 = container_of(b, typeof(*p2),
-							   head);
-	return p1->operation == p2->operation;
-}
-
-/**
- * ccs_write_capability - Write "struct ccs_capability_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-int ccs_write_capability(struct ccs_acl_param *param)
-{
-	struct ccs_capability_acl e = { .head.type = CCS_TYPE_CAPABILITY_ACL };
-	const char *operation = ccs_read_token(param);
-	for (e.operation = 0; e.operation < CCS_MAX_CAPABILITY_INDEX;
-	     e.operation++) {
-		if (strcmp(operation,
-			   ccs_mac_keywords[ccs_c2mac[e.operation]]))
-			continue;
-		return ccs_update_domain(&e.head, sizeof(e), param,
-					 ccs_same_capability_acl, NULL);
-	}
-	return -EINVAL;
-}
-
-/**
  * ccs_capability_init - Register capability related hooks.
  *
  * Returns nothing.
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -825,6 +825,7 @@
 	struct ccs_condition *cond; /* Maybe NULL. */
 	s8 is_deleted; /* true or false or CCS_GC_IN_PROGRESS */
 	u8 type; /* One of values in "enum ccs_acl_entry_type_index". */
+	u16 perm;
 } __attribute__((__packed__));
 
 /* Structure for holding a word. */
@@ -1214,7 +1215,6 @@
  */
 struct ccs_path_acl {
 	struct ccs_acl_info head; /* type = CCS_TYPE_PATH_ACL */
-	u16 perm; /* Bitmask of values in "enum ccs_path_acl_index". */
 	struct ccs_name_union name;
 };
 
@@ -1223,7 +1223,6 @@
  */
 struct ccs_path2_acl {
 	struct ccs_acl_info head; /* type = CCS_TYPE_PATH2_ACL */
-	u8 perm; /* Bitmask of values in "enum ccs_path2_acl_index". */
 	struct ccs_name_union name1;
 	struct ccs_name_union name2;
 };
@@ -1234,7 +1233,6 @@
  */
 struct ccs_path_number_acl {
 	struct ccs_acl_info head; /* type = CCS_TYPE_PATH_NUMBER_ACL */
-	u8 perm; /* Bitmask of values in "enum ccs_path_number_acl_index". */
 	struct ccs_name_union name;
 	struct ccs_number_union number;
 };
@@ -1242,7 +1240,6 @@
 /* Structure for "file mkblock" and "file mkchar" directive. */
 struct ccs_mkdev_acl {
 	struct ccs_acl_info head; /* type = CCS_TYPE_MKDEV_ACL */
-	u8 perm; /* Bitmask of values in "enum ccs_mkdev_acl_index". */
 	struct ccs_name_union name;
 	struct ccs_number_union mode;
 	struct ccs_number_union major;
@@ -1282,7 +1279,6 @@
 struct ccs_inet_acl {
 	struct ccs_acl_info head; /* type = CCS_TYPE_INET_ACL */
 	u8 protocol;
-	u8 perm; /* Bitmask of values in "enum ccs_network_acl_index" */
 	struct ccs_ipaddr_union address;
 	struct ccs_number_union port;
 };
@@ -1291,7 +1287,6 @@
 struct ccs_unix_acl {
 	struct ccs_acl_info head; /* type = CCS_TYPE_UNIX_ACL */
 	u8 protocol;
-	u8 perm; /* Bitmask of values in "enum ccs_network_acl_index" */
 	struct ccs_name_union name;
 };
 
@@ -1308,6 +1303,30 @@
 	struct list_head *list; /* List to add or remove. */
 	struct ccs_policy_namespace *ns; /* Namespace to use. */
 	bool is_delete; /* True if it is a delete request. */
+	union ccs_acl_union {
+		struct ccs_acl_info acl_info;
+		struct ccs_handler_acl handler_acl;
+		struct ccs_task_acl task_acl;
+		struct ccs_path_acl path_acl;
+		struct ccs_path2_acl path2_acl;
+		struct ccs_path_number_acl path_number_acl;
+		struct ccs_mkdev_acl mkdev_acl;
+		struct ccs_mount_acl mount_acl;
+		struct ccs_env_acl env_acl;
+		struct ccs_capability_acl capability_acl;
+		struct ccs_signal_acl signal_acl;
+		struct ccs_inet_acl inet_acl;
+		struct ccs_unix_acl unix_acl;
+		/**/
+		struct ccs_acl_head acl_head;
+		struct ccs_transition_control transition_control;
+		struct ccs_aggregator aggregator;
+		struct ccs_reserved reserved;
+		struct ccs_manager manager;
+		struct ccs_path_group path_group;
+		struct ccs_number_group number_group;
+		struct ccs_address_group address_group;
+	} e;
 };
 
 /* Structure for reading/writing policy via /proc/ccs/ interfaces. */
@@ -1461,27 +1480,6 @@
 int ccs_supervisor(struct ccs_request_info *r, const char *fmt, ...)
 	__attribute__ ((format(printf, 2, 3)));
 int ccs_symlink_path(const char *pathname, struct ccs_path_info *name);
-int ccs_update_domain(struct ccs_acl_info *new_entry, const int size,
-		      struct ccs_acl_param *param,
-		      bool (*check_duplicate) (const struct ccs_acl_info *,
-					       const struct ccs_acl_info *),
-		      bool (*merge_duplicate) (struct ccs_acl_info *,
-					       struct ccs_acl_info *,
-					       const bool));
-int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      struct ccs_acl_param *param,
-		      bool (*check_duplicate) (const struct ccs_acl_head *,
-					       const struct ccs_acl_head *));
-int ccs_write_aggregator(struct ccs_acl_param *param);
-int ccs_write_capability(struct ccs_acl_param *param);
-int ccs_write_file(struct ccs_acl_param *param);
-int ccs_write_group(struct ccs_acl_param *param, const u8 type);
-int ccs_write_inet_network(struct ccs_acl_param *param);
-int ccs_write_ipc(struct ccs_acl_param *param);
-int ccs_write_misc(struct ccs_acl_param *param);
-int ccs_write_reserved_port(struct ccs_acl_param *param);
-int ccs_write_transition_control(struct ccs_acl_param *param, const u8 type);
-int ccs_write_unix_network(struct ccs_acl_param *param);
 ssize_t ccs_read_control(struct ccs_io_buffer *head, char __user *buffer,
 			 const size_t buffer_len);
 ssize_t ccs_write_control(struct ccs_io_buffer *head,
@@ -1500,6 +1498,7 @@
 		   bool (*check_entry) (struct ccs_request_info *,
 					const struct ccs_acl_info *));
 void ccs_convert_time(time_t time, struct ccs_time *p);
+void ccs_del_acl(struct list_head *element);
 void ccs_del_condition(struct list_head *element);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
 void ccs_get_attributes(struct ccs_obj_info *obj);
@@ -1567,51 +1566,6 @@
 	return a->hash != b->hash || strcmp(a->name, b->name);
 }
 
-/**
- * ccs_same_name_union - Check for duplicated "struct ccs_name_union" entry.
- *
- * @a: Pointer to "struct ccs_name_union".
- * @b: Pointer to "struct ccs_name_union".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static inline bool ccs_same_name_union(const struct ccs_name_union *a,
-				       const struct ccs_name_union *b)
-{
-	return a->filename == b->filename && a->group == b->group;
-}
-
-/**
- * ccs_same_number_union - Check for duplicated "struct ccs_number_union" entry.
- *
- * @a: Pointer to "struct ccs_number_union".
- * @b: Pointer to "struct ccs_number_union".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static inline bool ccs_same_number_union(const struct ccs_number_union *a,
-					 const struct ccs_number_union *b)
-{
-	return a->values[0] == b->values[0] && a->values[1] == b->values[1] &&
-		a->group == b->group && a->value_type[0] == b->value_type[0] &&
-		a->value_type[1] == b->value_type[1];
-}
-
-/**
- * ccs_same_ipaddr_union - Check for duplicated "struct ccs_ipaddr_union" entry.
- *
- * @a: Pointer to "struct ccs_ipaddr_union".
- * @b: Pointer to "struct ccs_ipaddr_union".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static inline bool ccs_same_ipaddr_union(const struct ccs_ipaddr_union *a,
-					 const struct ccs_ipaddr_union *b)
-{
-	return !memcmp(a->ip, b->ip, sizeof(a->ip)) && a->group == b->group &&
-		a->is_ipv6 == b->is_ipv6;
-}
-
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
 
 /**
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -846,18 +846,43 @@
 }
 
 /**
- * ccs_same_manager - Check for duplicated "struct ccs_manager" entry.
+ * ccs_update_policy - Update an entry for exception policy.
  *
- * @a: Pointer to "struct ccs_acl_head".
- * @b: Pointer to "struct ccs_acl_head".
+ * @size:  Size of new entry in bytes.
+ * @param: Pointer to "struct ccs_acl_param".
  *
- * Returns true if @a == @b, false otherwise.
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds ccs_read_lock().
  */
-static bool ccs_same_manager(const struct ccs_acl_head *a,
-			     const struct ccs_acl_head *b)
+static int ccs_update_policy(const int size, struct ccs_acl_param *param)
 {
-	return container_of(a, struct ccs_manager, head)->manager
-		== container_of(b, struct ccs_manager, head)->manager;
+	struct ccs_acl_head *new_entry = &param->e.acl_head; 
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
+	struct ccs_acl_head *entry;
+	struct list_head *list = param->list;
+	if (WARN_ON(size < sizeof(*entry)))
+		return -EINVAL;
+	if (mutex_lock_interruptible(&ccs_policy_lock))
+		return -ENOMEM;
+	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
+		if (entry->is_deleted == CCS_GC_IN_PROGRESS)
+			continue;
+		if (memcmp(entry + 1, new_entry + 1, size - sizeof(*entry)))
+			continue;
+		entry->is_deleted = param->is_delete;
+		error = 0;
+		break;
+	}
+	if (error && !param->is_delete) {
+		entry = ccs_commit_ok(new_entry, size);
+		if (entry) {
+			list_add_tail_rcu(&entry->list, list);
+			error = 0;
+		}
+	}
+	mutex_unlock(&ccs_policy_lock);
+	return error;
 }
 
 /**
@@ -871,26 +896,27 @@
 static inline int ccs_update_manager_entry(const char *manager,
 					   const bool is_delete)
 {
-	struct ccs_manager e = { };
 	struct ccs_acl_param param = {
 		/* .ns = &ccs_kernel_namespace, */
 		.is_delete = is_delete,
 		.list = &ccs_kernel_namespace.policy_list[CCS_ID_MANAGER],
 	};
+	struct ccs_manager *e = &param.e.manager;
 	int error = is_delete ? -ENOENT : -ENOMEM;
+	/* Forced zero clear for using memcmp() at ccs_update_policy(). */
+	memset(&param.e, 0, sizeof(param.e));
 	if (ccs_domain_def(manager)) {
 		if (!ccs_correct_domain(manager))
 			return -EINVAL;
-		e.is_domain = true;
+		e->is_domain = true;
 	} else {
 		if (!ccs_correct_path(manager))
 			return -EINVAL;
 	}
-	e.manager = ccs_get_name(manager);
-	if (e.manager) {
-		error = ccs_update_policy(&e.head, sizeof(e), &param,
-					  ccs_same_manager);
-		ccs_put_name(e.manager);
+	e->manager = ccs_get_name(manager);
+	if (e->manager) {
+		error = ccs_update_policy(sizeof(*e), &param);
+		ccs_put_name(e->manager);
 	}
 	return error;
 }
@@ -1052,35 +1078,66 @@
 }
 
 /**
- * ccs_same_handler_acl - Check for duplicated "struct ccs_handler_acl" entry.
+ * ccs_update_domain - Update an entry for domain policy.
  *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
+ * @size:  Size of new entry in bytes.
+ * @param: Pointer to "struct ccs_acl_param".
  *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_handler_acl(const struct ccs_acl_info *a,
-				 const struct ccs_acl_info *b)
-{
-	const struct ccs_handler_acl *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_handler_acl *p2 = container_of(b, typeof(*p2), head);
-	return p1->handler == p2->handler;
-}
-
-/**
- * ccs_same_task_acl - Check for duplicated "struct ccs_task_acl" entry.
+ * Returns 0 on success, negative value otherwise.
  *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b, false otherwise.
+ * Caller holds ccs_read_lock().
  */
-static bool ccs_same_task_acl(const struct ccs_acl_info *a,
-			      const struct ccs_acl_info *b)
+static int ccs_update_domain(const int size, struct ccs_acl_param *param)
 {
-	const struct ccs_task_acl *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_task_acl *p2 = container_of(b, typeof(*p2), head);
-	return p1->domainname == p2->domainname;
+	struct ccs_acl_info *new_entry = &param->e.acl_info; 
+	const bool is_delete = param->is_delete;
+	int error = is_delete ? -ENOENT : -ENOMEM;
+	struct ccs_acl_info *entry;
+	struct list_head * const list = param->list;
+	if (WARN_ON(size <= sizeof(*entry)))
+		return -EINVAL;
+	if (param->data[0]) {
+		new_entry->cond = ccs_get_condition(param);
+		if (!new_entry->cond)
+			return -EINVAL;
+		/*
+		 * Domain transition preference is allowed for only
+		 * "file execute"/"task auto_execute_handler"/
+		 * "task denied_auto_execute_handler" entries.
+		 */
+		if (new_entry->cond->exec_transit &&
+		    !(new_entry->type == CCS_TYPE_PATH_ACL &&
+		      new_entry->perm == 1 << CCS_TYPE_EXECUTE) &&
+		    new_entry->type != CCS_TYPE_AUTO_EXECUTE_HANDLER &&
+		    new_entry->type != CCS_TYPE_DENIED_EXECUTE_HANDLER)
+			return -EINVAL;
+	}
+	if (mutex_lock_interruptible(&ccs_policy_lock))
+		return -ENOMEM;
+	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
+		if (entry->is_deleted == CCS_GC_IN_PROGRESS)
+			continue;
+		if (entry->type != new_entry->type ||
+		    entry->cond != new_entry->cond ||
+		    memcmp(entry + 1, new_entry + 1, size - sizeof(*entry)))
+			continue;
+		if (is_delete)
+			entry->perm &= ~new_entry->perm;
+		else
+			entry->perm |= new_entry->perm;
+		entry->is_deleted = !entry->perm;
+		error = 0;
+		break;
+	}
+	if (error && !is_delete) {
+		entry = ccs_commit_ok(new_entry, size);
+		if (entry) {
+			list_add_tail_rcu(&entry->list, list);
+			error = 0;
+		}
+	}
+	mutex_unlock(&ccs_policy_lock);
+	return error;
 }
 
 /**
@@ -1099,44 +1156,254 @@
 					    "auto_domain_transition ");
 	if (!is_auto && !ccs_str_starts(&param->data,
 					"manual_domain_transition ")) {
-		struct ccs_handler_acl e = { };
+		struct ccs_handler_acl *e = &param->e.handler_acl;
 		char *handler;
 		if (ccs_str_starts(&param->data, "auto_execute_handler "))
-			e.head.type = CCS_TYPE_AUTO_EXECUTE_HANDLER;
+			e->head.type = CCS_TYPE_AUTO_EXECUTE_HANDLER;
 		else if (ccs_str_starts(&param->data,
 					"denied_execute_handler "))
-			e.head.type = CCS_TYPE_DENIED_EXECUTE_HANDLER;
+			e->head.type = CCS_TYPE_DENIED_EXECUTE_HANDLER;
 		else
 			return -EINVAL;
 		handler = ccs_read_token(param);
 		if (!ccs_correct_path(handler))
 			return -EINVAL;
-		e.handler = ccs_get_name(handler);
-		if (!e.handler)
+		e->handler = ccs_get_name(handler);
+		if (!e->handler)
 			return -ENOMEM;
-		if (e.handler->is_patterned)
-			error = -EINVAL; /* No patterns allowed. */
-		else
-			error = ccs_update_domain(&e.head, sizeof(e), param,
-						  ccs_same_handler_acl, NULL);
-		ccs_put_name(e.handler);
+		if (e->handler->is_patterned)
+			return -EINVAL; /* No patterns allowed. */
+		return ccs_update_domain(sizeof(*e), param);
 	} else {
-		struct ccs_task_acl e = {
-			.head.type = is_auto ?
-			CCS_TYPE_AUTO_TASK_ACL : CCS_TYPE_MANUAL_TASK_ACL,
-			.domainname = ccs_get_domainname(param),
-		};
-		if (!e.domainname)
-			error = -EINVAL;
-		else
-			error = ccs_update_domain(&e.head, sizeof(e), param,
-						  ccs_same_task_acl, NULL);
-		ccs_put_name(e.domainname);
+		struct ccs_task_acl *e = &param->e.task_acl;
+		e->head.type = is_auto ?
+			CCS_TYPE_AUTO_TASK_ACL : CCS_TYPE_MANUAL_TASK_ACL;
+		e->domainname = ccs_get_domainname(param);
+		if (!e->domainname)
+			return -EINVAL;
+		return ccs_update_domain(sizeof(*e), param);
 	}
 	return error;
 }
 
 /**
+ * ccs_write_inet_network - Write "struct ccs_inet_acl" list.
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static int ccs_write_inet_network(struct ccs_acl_param *param)
+{
+	struct ccs_inet_acl *e = &param->e.inet_acl;
+	u8 type;
+	const char *protocol = ccs_read_token(param);
+	const char *operation = ccs_read_token(param);
+	e->head.type = CCS_TYPE_INET_ACL;
+	for (type = 0; type < CCS_SOCK_MAX; type++)
+		if (!strcmp(protocol, ccs_proto_keyword[type]))
+			break;
+	if (type == CCS_SOCK_MAX)
+		return -EINVAL;
+	e->protocol = type;
+	e->head.perm = 0;
+	for (type = 0; type < CCS_MAX_NETWORK_OPERATION; type++)
+		if (ccs_permstr(operation, ccs_socket_keyword[type]))
+			e->head.perm |= 1 << type;
+	if (!e->head.perm)
+		return -EINVAL;
+	if (param->data[0] == '@') {
+		param->data++;
+		e->address.group = ccs_get_group(param, CCS_ADDRESS_GROUP);
+		if (!e->address.group)
+			return -ENOMEM;
+	} else {
+		if (!ccs_parse_ipaddr_union(param, &e->address))
+			return -EINVAL;
+	}
+	if (!ccs_parse_number_union(param, &e->port) ||
+	    e->port.values[1] > 65535)
+		return -EINVAL;
+	return ccs_update_domain(sizeof(*e), param);
+}
+
+/**
+ * ccs_write_unix_network - Write "struct ccs_unix_acl" list.
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_unix_network(struct ccs_acl_param *param)
+{
+	struct ccs_unix_acl *e = &param->e.unix_acl;
+	u8 type;
+	const char *protocol = ccs_read_token(param);
+	const char *operation = ccs_read_token(param);
+	e->head.type = CCS_TYPE_UNIX_ACL;
+	for (type = 0; type < CCS_SOCK_MAX; type++)
+		if (!strcmp(protocol, ccs_proto_keyword[type]))
+			break;
+	if (type == CCS_SOCK_MAX)
+		return -EINVAL;
+	e->protocol = type;
+	e->head.perm = 0;
+	for (type = 0; type < CCS_MAX_NETWORK_OPERATION; type++)
+		if (ccs_permstr(operation, ccs_socket_keyword[type]))
+			e->head.perm |= 1 << type;
+	if (!e->head.perm)
+		return -EINVAL;
+	if (!ccs_parse_name_union(param, &e->name))
+		return -EINVAL;
+	return ccs_update_domain(sizeof(*e), param);
+}
+
+/**
+ * ccs_write_file - Update file related list.
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static int ccs_write_file(struct ccs_acl_param *param)
+{
+	u16 perm = 0;
+	u8 type;
+	const char *operation = ccs_read_token(param);
+	for (type = 0; type < CCS_MAX_PATH_OPERATION; type++)
+		if (ccs_permstr(operation, ccs_path_keyword[type]))
+			perm |= 1 << type;
+	if (perm) {
+		struct ccs_path_acl *e = &param->e.path_acl;
+		e->head.type = CCS_TYPE_PATH_ACL;
+		e->head.perm = perm;
+		if (!ccs_parse_name_union(param, &e->name))
+			return -EINVAL;
+		return ccs_update_domain(sizeof(*e), param);
+	}
+	for (type = 0; type < CCS_MAX_PATH2_OPERATION; type++)
+		if (ccs_permstr(operation, ccs_mac_keywords[ccs_pp2mac[type]]))
+			perm |= 1 << type;
+	if (perm) {
+		struct ccs_path2_acl *e = &param->e.path2_acl;
+		e->head.type = CCS_TYPE_PATH2_ACL;
+		e->head.perm = perm;
+		if (!ccs_parse_name_union(param, &e->name1) ||
+		    !ccs_parse_name_union(param, &e->name2))
+			return -EINVAL;
+		return ccs_update_domain(sizeof(*e), param);
+	}
+	for (type = 0; type < CCS_MAX_PATH_NUMBER_OPERATION; type++)
+		if (ccs_permstr(operation, ccs_mac_keywords[ccs_pn2mac[type]]))
+			perm |= 1 << type;
+	if (perm) {
+		struct ccs_path_number_acl *e = &param->e.path_number_acl;
+		e->head.type = CCS_TYPE_PATH_NUMBER_ACL;
+		e->head.perm = perm;
+		if (!ccs_parse_name_union(param, &e->name) ||
+		    !ccs_parse_number_union(param, &e->number))
+			return -EINVAL;
+		return ccs_update_domain(sizeof(*e), param);
+	}
+	for (type = 0; type < CCS_MAX_MKDEV_OPERATION; type++)
+		if (ccs_permstr(operation,
+				ccs_mac_keywords[ccs_pnnn2mac[type]]))
+			perm |= 1 << type;
+	if (perm) {
+		struct ccs_mkdev_acl *e = &param->e.mkdev_acl;
+		e->head.type = CCS_TYPE_MKDEV_ACL;
+		e->head.perm = perm;
+		if (!ccs_parse_name_union(param, &e->name) ||
+		    !ccs_parse_number_union(param, &e->mode) ||
+		    !ccs_parse_number_union(param, &e->major) ||
+		    !ccs_parse_number_union(param, &e->minor))
+			return -EINVAL;
+		return ccs_update_domain(sizeof(*e), param);
+	}
+	if (ccs_permstr(operation, ccs_mac_keywords[CCS_MAC_FILE_MOUNT])) {
+		struct ccs_mount_acl *e = &param->e.mount_acl;
+		e->head.type = CCS_TYPE_MOUNT_ACL;
+		if (!ccs_parse_name_union(param, &e->dev_name) ||
+		    !ccs_parse_name_union(param, &e->dir_name) ||
+		    !ccs_parse_name_union(param, &e->fs_type) ||
+		    !ccs_parse_number_union(param, &e->flags))
+			return -EINVAL;
+		return ccs_update_domain(sizeof(*e), param);
+	}
+	return -EINVAL;
+}
+
+/**
+ * ccs_write_misc - Update environment variable list.
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_misc(struct ccs_acl_param *param)
+{
+	if (ccs_str_starts(&param->data, "env ")) {
+		struct ccs_env_acl *e = &param->e.env_acl;
+		const char *data = ccs_read_token(param);
+		e->head.type = CCS_TYPE_ENV_ACL;
+		if (!ccs_correct_word(data) || strchr(data, '='))
+			return -EINVAL;
+		e->env = ccs_get_name(data);
+		if (!e->env)
+			return -ENOMEM;
+		return ccs_update_domain(sizeof(*e), param);
+	}
+	return -EINVAL;
+}
+
+/**
+ * ccs_write_ipc - Update "struct ccs_signal_acl" list.
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_ipc(struct ccs_acl_param *param)
+{
+	struct ccs_signal_acl *e = &param->e.signal_acl;
+	e->head.type = CCS_TYPE_SIGNAL_ACL;
+	if (!ccs_parse_number_union(param, &e->sig))
+		return -EINVAL;
+	e->domainname = ccs_get_domainname(param);
+	if (!e->domainname)
+		return -EINVAL;
+	return ccs_update_domain(sizeof(*e), param);
+}
+
+/**
+ * ccs_write_capability - Write "struct ccs_capability_acl" list.
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static int ccs_write_capability(struct ccs_acl_param *param)
+{
+	struct ccs_capability_acl *e = &param->e.capability_acl;
+	const char *operation = ccs_read_token(param);
+	u8 type;
+	e->head.type = CCS_TYPE_CAPABILITY_ACL;
+	for (type = 0; type < CCS_MAX_CAPABILITY_INDEX; type++) {
+		if (strcmp(operation, ccs_mac_keywords[ccs_c2mac[type]]))
+			continue;
+		e->operation = type;
+		return ccs_update_domain(sizeof(*e), param);
+	}
+	return -EINVAL;
+}
+
+/**
  * ccs_write_domain2 - Write domain policy.
  *
  * @ns:        Pointer to "struct ccs_policy_namespace".
@@ -1171,10 +1438,16 @@
 		{ "task ", ccs_write_task },
 	};
 	u8 i;
+	/* Forced zero clear for using memcmp() at ccs_update_domain(). */
+	memset(&param.e, 0, sizeof(param.e));
+	param.e.acl_info.perm = 1;
 	for (i = 0; i < ARRAY_SIZE(ccs_callback); i++) {
+		int error;
 		if (!ccs_str_starts(&param.data, ccs_callback[i].keyword))
 			continue;
-		return ccs_callback[i].write(&param);
+		error = ccs_callback[i].write(&param);
+		ccs_del_acl(&param.e.acl_info.list);
+		return error;
 	}
 	return -EINVAL;
 }
@@ -1557,9 +1830,8 @@
 	else if (acl_type == CCS_TYPE_PATH_ACL) {
 		struct ccs_path_acl *ptr
 			= container_of(acl, typeof(*ptr), head);
-		const u16 perm = ptr->perm;
 		for (bit = 0; bit < CCS_MAX_PATH_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
+			if (!(acl->perm & (1 << bit)))
 				continue;
 			if (head->r.print_transition_related_only &&
 			    bit != CCS_TYPE_EXECUTE && !may_trigger_transition)
@@ -1599,9 +1871,8 @@
 	} else if (acl_type == CCS_TYPE_MKDEV_ACL) {
 		struct ccs_mkdev_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		const u8 perm = ptr->perm;
 		for (bit = 0; bit < CCS_MAX_MKDEV_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
+			if (!(acl->perm & (1 << bit)))
 				continue;
 			if (first) {
 				ccs_set_group(head, "file ");
@@ -1621,9 +1892,8 @@
 	} else if (acl_type == CCS_TYPE_PATH2_ACL) {
 		struct ccs_path2_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		const u8 perm = ptr->perm;
 		for (bit = 0; bit < CCS_MAX_PATH2_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
+			if (!(acl->perm & (1 << bit)))
 				continue;
 			if (first) {
 				ccs_set_group(head, "file ");
@@ -1641,9 +1911,8 @@
 	} else if (acl_type == CCS_TYPE_PATH_NUMBER_ACL) {
 		struct ccs_path_number_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		const u8 perm = ptr->perm;
 		for (bit = 0; bit < CCS_MAX_PATH_NUMBER_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
+			if (!(acl->perm & (1 << bit)))
 				continue;
 			if (first) {
 				ccs_set_group(head, "file ");
@@ -1672,9 +1941,8 @@
 	} else if (acl_type == CCS_TYPE_INET_ACL) {
 		struct ccs_inet_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		const u8 perm = ptr->perm;
 		for (bit = 0; bit < CCS_MAX_NETWORK_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
+			if (!(acl->perm & (1 << bit)))
 				continue;
 			if (first) {
 				ccs_set_group(head, "network inet ");
@@ -1703,9 +1971,8 @@
 	} else if (acl_type == CCS_TYPE_UNIX_ACL) {
 		struct ccs_unix_acl *ptr =
 			container_of(acl, typeof(*ptr), head);
-		const u8 perm = ptr->perm;
 		for (bit = 0; bit < CCS_MAX_NETWORK_OPERATION; bit++) {
-			if (!(perm & (1 << bit)))
+			if (!(acl->perm & (1 << bit)))
 				continue;
 			if (first) {
 				ccs_set_group(head, "network unix ");
@@ -1918,6 +2185,190 @@
 };
 
 /**
+ * ccs_write_group - Write "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group" list.
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ * @type:  Type of this group.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_group(struct ccs_acl_param *param, const u8 type)
+{
+	struct ccs_group *group = ccs_get_group(param, type);
+	int error = -EINVAL;
+	if (!group)
+		return -ENOMEM;
+	param->list = &group->member_list;
+	if (type == CCS_PATH_GROUP) {
+		struct ccs_path_group *e = &param->e.path_group;
+		e->member_name = ccs_get_name(ccs_read_token(param));
+		if (!e->member_name) {
+			error = -ENOMEM;
+			goto out;
+		}
+		error = ccs_update_policy(sizeof(*e), param);
+		ccs_put_name(e->member_name);
+	} else if (type == CCS_NUMBER_GROUP) {
+		struct ccs_number_group *e = &param->e.number_group;
+		if (param->data[0] == '@' ||
+		    !ccs_parse_number_union(param, &e->number))
+			goto out;
+		error = ccs_update_policy(sizeof(*e), param);
+	} else {
+		struct ccs_address_group *e = &param->e.address_group;
+		if (param->data[0] == '@' ||
+		    !ccs_parse_ipaddr_union(param, &e->address))
+			goto out;
+		error = ccs_update_policy(sizeof(*e), param);
+	}
+out:
+	ccs_put_group(group);
+	return error;
+}
+
+/* Bitmap for reserved local port numbers.*/
+static u8 ccs_reserved_port_map[8192];
+
+/**
+ * ccs_lport_reserved - Check whether local port is reserved or not.
+ *
+ * @port: Port number.
+ *
+ * Returns true if local port is reserved, false otherwise.
+ */
+static bool __ccs_lport_reserved(const u16 port)
+{
+	return ccs_reserved_port_map[port >> 3] & (1 << (port & 7))
+		? true : false;
+}
+
+/**
+ * ccs_write_reserved_port - Update "struct ccs_reserved" list.
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ *
+ * Returns 0 on success, negative value otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static int ccs_write_reserved_port(struct ccs_acl_param *param)
+{
+	struct ccs_reserved *e = &param->e.reserved;
+	struct ccs_policy_namespace *ns = param->ns;
+	int error;
+	u8 *tmp;
+	if (param->data[0] == '@' || !ccs_parse_number_union(param, &e->port) ||
+	    e->port.values[1] > 65535 || param->data[0])
+		return -EINVAL;
+	param->list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+	error = ccs_update_policy(sizeof(*e), param);
+	if (error)
+		return error;
+	tmp = kzalloc(sizeof(ccs_reserved_port_map), CCS_GFP_FLAGS);
+	if (!tmp)
+		return -ENOMEM;
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		struct ccs_reserved *ptr;
+		struct list_head *list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
+			unsigned int port;
+			if (ptr->head.is_deleted)
+				continue;
+			for (port = ptr->port.values[0];
+			     port <= ptr->port.values[1]; port++)
+				tmp[port >> 3] |= 1 << (port & 7);
+		}
+	}
+	memmove(ccs_reserved_port_map, tmp, sizeof(ccs_reserved_port_map));
+	kfree(tmp);
+	/*
+	 * Since this feature is no-op by default, we don't need to register
+	 * this callback hook unless the first entry is added.
+	 */
+	ccsecurity_ops.lport_reserved = __ccs_lport_reserved;
+	return 0;
+}
+
+/**
+ * ccs_write_aggregator - Write "struct ccs_aggregator" list.
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_aggregator(struct ccs_acl_param *param)
+{
+	struct ccs_aggregator *e = &param->e.aggregator;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
+	const char *original_name = ccs_read_token(param);
+	const char *aggregated_name = ccs_read_token(param);
+	if (!ccs_correct_word(original_name) ||
+	    !ccs_correct_path(aggregated_name))
+		return -EINVAL;
+	e->original_name = ccs_get_name(original_name);
+	e->aggregated_name = ccs_get_name(aggregated_name);
+	if (!e->original_name || !e->aggregated_name ||
+	    e->aggregated_name->is_patterned) /* No patterns allowed. */
+		goto out;
+	param->list = &param->ns->policy_list[CCS_ID_AGGREGATOR];
+	error = ccs_update_policy(sizeof(*e), param);
+out:
+	ccs_put_name(e->original_name);
+	ccs_put_name(e->aggregated_name);
+	return error;
+}
+
+/**
+ * ccs_write_transition_control - Write "struct ccs_transition_control" list.
+ *
+ * @param: Pointer to "struct ccs_acl_param".
+ * @type:  Type of this entry.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int ccs_write_transition_control(struct ccs_acl_param *param,
+					const u8 type)
+{
+	struct ccs_transition_control *e = &param->e.transition_control;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
+	char *program = param->data;
+	char *domainname = strstr(program, " from ");
+	e->type = type;
+	if (domainname) {
+		*domainname = '\0';
+		domainname += 6;
+	} else if (type == CCS_TRANSITION_CONTROL_NO_KEEP ||
+		   type == CCS_TRANSITION_CONTROL_KEEP) {
+		domainname = program;
+		program = NULL;
+	}
+	if (program && strcmp(program, "any")) {
+		if (!ccs_correct_path(program))
+			return -EINVAL;
+		e->program = ccs_get_name(program);
+		if (!e->program)
+			goto out;
+	}
+	if (domainname && strcmp(domainname, "any")) {
+		if (!ccs_correct_domain(domainname)) {
+			if (!ccs_correct_path(domainname))
+				goto out;
+			e->is_last_name = true;
+		}
+		e->domainname = ccs_get_name(domainname);
+		if (!e->domainname)
+			goto out;
+	}
+	param->list = &param->ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+	error = ccs_update_policy(sizeof(*e), param);
+out:
+	ccs_put_name(e->domainname);
+	ccs_put_name(e->program);
+	return error;
+}
+
+/**
  * ccs_write_exception - Write exception policy.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -1933,6 +2384,8 @@
 		.data = head->write_buf,
 	};
 	u8 i;
+	/* Forced zero clear for using memcmp() at ccs_update_policy(). */
+	memset(&param.e, 0, sizeof(param.e));
 	if (ccs_str_starts(&param.data, "aggregator "))
 		return ccs_write_aggregator(&param);
 	if (ccs_str_starts(&param.data, "deny_autobind "))
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c	(working copy)
@@ -264,7 +264,7 @@
  *
  * Returns nothing.
  */
-static void ccs_del_acl(struct list_head *element)
+void ccs_del_acl(struct list_head *element)
 {
 	struct ccs_acl_info *acl = container_of(element, typeof(*acl), list);
 	ccs_put_condition(acl->cond);
@@ -343,6 +343,7 @@
 		{
 			struct ccs_signal_acl *entry =
 				container_of(acl, typeof(*entry), head);
+			ccs_put_number_union(&entry->sig);
 			ccs_put_name(entry->domainname);
 		}
 		break;
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/network.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/network.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/network.c	(working copy)
@@ -537,161 +537,6 @@
 	},
 };
 
-/**
- * ccs_same_inet_acl - Check for duplicated "struct ccs_inet_acl" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b except permission bits, false otherwise.
- */
-static bool ccs_same_inet_acl(const struct ccs_acl_info *a,
-			      const struct ccs_acl_info *b)
-{
-	const struct ccs_inet_acl *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_inet_acl *p2 = container_of(b, typeof(*p2), head);
-	return p1->protocol == p2->protocol &&
-		ccs_same_ipaddr_union(&p1->address, &p2->address) &&
-		ccs_same_number_union(&p1->port, &p2->port);
-}
-
-/**
- * ccs_same_unix_acl - Check for duplicated "struct ccs_unix_acl" entry.
- *
- * @a: Pointer to "struct ccs_acl_info".
- * @b: Pointer to "struct ccs_acl_info".
- *
- * Returns true if @a == @b except permission bits, false otherwise.
- */
-static bool ccs_same_unix_acl(const struct ccs_acl_info *a,
-			      const struct ccs_acl_info *b)
-{
-	const struct ccs_unix_acl *p1 = container_of(a, typeof(*p1), head);
-	const struct ccs_unix_acl *p2 = container_of(b, typeof(*p2), head);
-	return p1->protocol == p2->protocol &&
-		ccs_same_name_union(&p1->name, &p2->name);
-}
-
-/**
- * ccs_merge_inet_acl - Merge duplicated "struct ccs_inet_acl" entry.
- *
- * @a:         Pointer to "struct ccs_acl_info".
- * @b:         Pointer to "struct ccs_acl_info".
- * @is_delete: True for @a &= ~@b, false for @a |= @b.
- *
- * Returns true if @a is empty, false otherwise.
- */
-static bool ccs_merge_inet_acl(struct ccs_acl_info *a, struct ccs_acl_info *b,
-			       const bool is_delete)
-{
-	u8 * const a_perm = &container_of(a, struct ccs_inet_acl, head)->perm;
-	u8 perm = *a_perm;
-	const u8 b_perm = container_of(b, struct ccs_inet_acl, head)->perm;
-	if (is_delete)
-		perm &= ~b_perm;
-	else
-		perm |= b_perm;
-	*a_perm = perm;
-	return !perm;
-}
-
-/**
- * ccs_merge_unix_acl - Merge duplicated "struct ccs_unix_acl" entry.
- *
- * @a:         Pointer to "struct ccs_acl_info".
- * @b:         Pointer to "struct ccs_acl_info".
- * @is_delete: True for @a &= ~@b, false for @a |= @b.
- *
- * Returns true if @a is empty, false otherwise.
- */
-static bool ccs_merge_unix_acl(struct ccs_acl_info *a, struct ccs_acl_info *b,
-			       const bool is_delete)
-{
-	u8 * const a_perm = &container_of(a, struct ccs_unix_acl, head)->perm;
-	u8 perm = *a_perm;
-	const u8 b_perm = container_of(b, struct ccs_unix_acl, head)->perm;
-	if (is_delete)
-		perm &= ~b_perm;
-	else
-		perm |= b_perm;
-	*a_perm = perm;
-	return !perm;
-}
-
-/**
- * ccs_write_inet_network - Write "struct ccs_inet_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-int ccs_write_inet_network(struct ccs_acl_param *param)
-{
-	struct ccs_inet_acl e = { .head.type = CCS_TYPE_INET_ACL };
-	int error = -EINVAL;
-	u8 type;
-	const char *protocol = ccs_read_token(param);
-	const char *operation = ccs_read_token(param);
-	for (e.protocol = 0; e.protocol < CCS_SOCK_MAX; e.protocol++)
-		if (!strcmp(protocol, ccs_proto_keyword[e.protocol]))
-			break;
-	for (type = 0; type < CCS_MAX_NETWORK_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_socket_keyword[type]))
-			e.perm |= 1 << type;
-	if (e.protocol == CCS_SOCK_MAX || !e.perm)
-		return -EINVAL;
-	if (param->data[0] == '@') {
-		param->data++;
-		e.address.group = ccs_get_group(param, CCS_ADDRESS_GROUP);
-		if (!e.address.group)
-			return -ENOMEM;
-	} else {
-		if (!ccs_parse_ipaddr_union(param, &e.address))
-			goto out;
-	}
-	if (!ccs_parse_number_union(param, &e.port) ||
-	    e.port.values[1] > 65535)
-		goto out;
-	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_inet_acl,
-				  ccs_merge_inet_acl);
-out:
-	ccs_put_group(e.address.group);
-	ccs_put_number_union(&e.port);
-	return error;
-}
-
-/**
- * ccs_write_unix_network - Write "struct ccs_unix_acl" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_unix_network(struct ccs_acl_param *param)
-{
-	struct ccs_unix_acl e = { .head.type = CCS_TYPE_UNIX_ACL };
-	int error;
-	u8 type;
-	const char *protocol = ccs_read_token(param);
-	const char *operation = ccs_read_token(param);
-	for (e.protocol = 0; e.protocol < CCS_SOCK_MAX; e.protocol++)
-		if (!strcmp(protocol, ccs_proto_keyword[e.protocol]))
-			break;
-	for (type = 0; type < CCS_MAX_NETWORK_OPERATION; type++)
-		if (ccs_permstr(operation, ccs_socket_keyword[type]))
-			e.perm |= 1 << type;
-	if (e.protocol == CCS_SOCK_MAX || !e.perm)
-		return -EINVAL;
-	if (!ccs_parse_name_union(param, &e.name))
-		return -EINVAL;
-	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_unix_acl,
-				  ccs_merge_unix_acl);
-	ccs_put_name_union(&e.name);
-	return error;
-}
-
 #ifndef CONFIG_NET
 
 /**
@@ -776,7 +621,7 @@
 {
 	const struct ccs_inet_acl *acl = container_of(ptr, typeof(*acl), head);
 	const u8 size = r->param.inet_network.is_ipv6 ? 16 : 4;
-	if (!(acl->perm & (1 << r->param.inet_network.operation)) ||
+	if (!(ptr->perm & (1 << r->param.inet_network.operation)) ||
 	    !ccs_compare_number_union(r->param.inet_network.port, &acl->port))
 		return false;
 	if (acl->address.group)
@@ -802,7 +647,7 @@
 			       const struct ccs_acl_info *ptr)
 {
 	const struct ccs_unix_acl *acl = container_of(ptr, typeof(*acl), head);
-	return (acl->perm & (1 << r->param.unix_network.operation)) &&
+	return (ptr->perm & (1 << r->param.unix_network.operation)) &&
 		ccs_compare_name_union(r->param.unix_network.address,
 				       &acl->name);
 }
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/group.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/group.c	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/group.c	(working copy)
@@ -9,105 +9,6 @@
 #include "internal.h"
 
 /**
- * ccs_same_path_group - Check for duplicated "struct ccs_path_group" entry.
- *
- * @a: Pointer to "struct ccs_acl_head".
- * @b: Pointer to "struct ccs_acl_head".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_path_group(const struct ccs_acl_head *a,
-				const struct ccs_acl_head *b)
-{
-	return container_of(a, struct ccs_path_group, head)->member_name ==
-		container_of(b, struct ccs_path_group, head)->member_name;
-}
-
-/**
- * ccs_same_number_group - Check for duplicated "struct ccs_number_group" entry.
- *
- * @a: Pointer to "struct ccs_acl_head".
- * @b: Pointer to "struct ccs_acl_head".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_number_group(const struct ccs_acl_head *a,
-				  const struct ccs_acl_head *b)
-{
-	return !memcmp(&container_of(a, struct ccs_number_group, head)->number,
-		       &container_of(b, struct ccs_number_group, head)->number,
-		       sizeof(container_of(a, struct ccs_number_group, head)
-			      ->number));
-}
-
-/**
- * ccs_same_address_group - Check for duplicated "struct ccs_address_group" entry.
- *
- * @a: Pointer to "struct ccs_acl_head".
- * @b: Pointer to "struct ccs_acl_head".
- *
- * Returns true if @a == @b, false otherwise.
- */
-static bool ccs_same_address_group(const struct ccs_acl_head *a,
-				   const struct ccs_acl_head *b)
-{
-	const struct ccs_address_group *p1 = container_of(a, typeof(*p1),
-							  head);
-	const struct ccs_address_group *p2 = container_of(b, typeof(*p2),
-							  head);
-	return ccs_same_ipaddr_union(&p1->address, &p2->address);
-}
-
-/**
- * ccs_write_group - Write "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group" list.
- *
- * @param: Pointer to "struct ccs_acl_param".
- * @type:  Type of this group.
- *
- * Returns 0 on success, negative value otherwise.
- */
-int ccs_write_group(struct ccs_acl_param *param, const u8 type)
-{
-	struct ccs_group *group = ccs_get_group(param, type);
-	int error = -EINVAL;
-	if (!group)
-		return -ENOMEM;
-	param->list = &group->member_list;
-	if (type == CCS_PATH_GROUP) {
-		struct ccs_path_group e = { };
-		e.member_name = ccs_get_name(ccs_read_token(param));
-		if (!e.member_name) {
-			error = -ENOMEM;
-			goto out;
-		}
-		error = ccs_update_policy(&e.head, sizeof(e), param,
-					  ccs_same_path_group);
-		ccs_put_name(e.member_name);
-	} else if (type == CCS_NUMBER_GROUP) {
-		struct ccs_number_group e = { };
-		if (param->data[0] == '@' ||
-		    !ccs_parse_number_union(param, &e.number))
-			goto out;
-		error = ccs_update_policy(&e.head, sizeof(e), param,
-					  ccs_same_number_group);
-		/*
-		 * ccs_put_number_union() is not needed because
-		 * param->data[0] != '@'.
-		 */
-	} else {
-		struct ccs_address_group e = { };
-		if (param->data[0] == '@' ||
-		    !ccs_parse_ipaddr_union(param, &e.address))
-			goto out;
-		error = ccs_update_policy(&e.head, sizeof(e), param,
-					  ccs_same_address_group);
-	}
-out:
-	ccs_put_group(group);
-	return error;
-}
-
-/**
  * ccs_path_matches_group - Check whether the given pathname matches members of the given pathname group.
  *
  * @pathname: The name of pathname.
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/Makefile
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/Makefile	(revision 5585)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/Makefile	(working copy)
@@ -1,4 +1,4 @@
-ccsecurity-objs := audit.o autobind.o capability.o condition.o domain.o environ.o file.o gc.o group.o memory.o mount.o network.o policy_io.o proc_if.o realpath.o signal.o util.o
+ccsecurity-objs := audit.o capability.o condition.o domain.o environ.o file.o gc.o group.o memory.o mount.o network.o policy_io.o proc_if.o realpath.o signal.o util.o
 
 ifeq ($(PATCHLEVEL),4)
 
