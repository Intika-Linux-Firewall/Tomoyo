diff -upr before/distro/armadillo-9/linux-2.4.31-a9-3/fs/namei.c after/distro/armadillo-9/linux-2.4.31-a9-3/fs/namei.c
--- before/distro/armadillo-9/linux-2.4.31-a9-3/fs/namei.c	2009-03-19 11:24:30.000000000 +0900
+++ after/distro/armadillo-9/linux-2.4.31-a9-3/fs/namei.c	2009-03-20 02:20:59.000000000 +0900
@@ -1064,10 +1064,10 @@ do_last:
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt,
+						   mode & ~current->fs->umask,
+						   0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry,
@@ -1301,16 +1301,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1324,35 +1314,16 @@ asmlinkage long sys_mknod(const char * f
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1415,10 +1386,10 @@ asmlinkage long sys_mkdir(const char * p
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode &
+							   ~current->fs->umask);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1531,10 +1502,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1581,10 +1550,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1604,12 +1569,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1659,10 +1621,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1680,10 +1638,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1751,10 +1708,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1775,14 +1728,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2016,18 +1964,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2035,6 +1976,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2053,10 +1997,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/armadillo-9/linux-2.4.31-a9-3/fs/open.c after/distro/armadillo-9/linux-2.4.31-a9-3/fs/open.c
--- before/distro/armadillo-9/linux-2.4.31-a9-3/fs/open.c	2009-03-19 11:24:30.000000000 +0900
+++ after/distro/armadillo-9/linux-2.4.31-a9-3/fs/open.c	2009-03-19 23:25:31.000000000 +0900
@@ -170,7 +170,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -228,7 +228,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/armadillo-9/linux-2.4.31-a9-3/net/unix/af_unix.c after/distro/armadillo-9/linux-2.4.31-a9-3/net/unix/af_unix.c
--- before/distro/armadillo-9/linux-2.4.31-a9-3/net/unix/af_unix.c	2009-03-19 11:24:30.000000000 +0900
+++ after/distro/armadillo-9/linux-2.4.31-a9-3/net/unix/af_unix.c	2009-03-19 22:48:45.000000000 +0900
@@ -648,11 +648,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -718,10 +713,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/armadillo-9/linux-2.6.12.3-a9-16/fs/namei.c after/distro/armadillo-9/linux-2.6.12.3-a9-16/fs/namei.c
--- before/distro/armadillo-9/linux-2.6.12.3-a9-16/fs/namei.c	2009-03-19 11:24:31.000000000 +0900
+++ after/distro/armadillo-9/linux-2.6.12.3-a9-16/fs/namei.c	2009-03-20 01:40:01.000000000 +0900
@@ -1315,13 +1315,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error) {
@@ -1495,6 +1488,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
@@ -1659,16 +1657,6 @@ asmlinkage long sys_mknod(const char __u
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1682,37 +1670,21 @@ asmlinkage long sys_mknod(const char __u
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1775,10 +1747,9 @@ asmlinkage long sys_mkdir(const char __u
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -1886,10 +1857,8 @@ asmlinkage long sys_rmdir(const char __u
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1946,10 +1915,6 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1972,12 +1937,9 @@ asmlinkage long sys_unlink(const char __
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2026,10 +1988,6 @@ asmlinkage long sys_symlink(const char _
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2047,10 +2005,9 @@ asmlinkage long sys_symlink(const char _
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2120,10 +2077,6 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -2142,12 +2095,9 @@ asmlinkage long sys_link(const char __us
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2373,14 +2323,10 @@ static inline int do_rename(const char *
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2404,10 +2350,6 @@ asmlinkage long sys_rename(const char __
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/armadillo-9/linux-2.6.12.3-a9-16/fs/open.c after/distro/armadillo-9/linux-2.6.12.3-a9-16/fs/open.c
--- before/distro/armadillo-9/linux-2.6.12.3-a9-16/fs/open.c	2009-03-19 11:24:31.000000000 +0900
+++ after/distro/armadillo-9/linux-2.6.12.3-a9-16/fs/open.c	2009-03-19 23:25:26.000000000 +0900
@@ -265,7 +265,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -322,7 +322,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/armadillo-9/linux-2.6.12.3-a9-16/net/unix/af_unix.c after/distro/armadillo-9/linux-2.6.12.3-a9-16/net/unix/af_unix.c
--- before/distro/armadillo-9/linux-2.6.12.3-a9-16/net/unix/af_unix.c	2009-03-19 11:24:31.000000000 +0900
+++ after/distro/armadillo-9/linux-2.6.12.3-a9-16/net/unix/af_unix.c	2009-03-19 22:48:35.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/centos-3.9/linux-2.4.21-58.EL/fs/namei.c after/distro/centos-3.9/linux-2.4.21-58.EL/fs/namei.c
--- before/distro/centos-3.9/linux-2.4.21-58.EL/fs/namei.c	2009-03-19 11:24:33.000000000 +0900
+++ after/distro/centos-3.9/linux-2.4.21-58.EL/fs/namei.c	2009-03-20 02:19:51.000000000 +0900
@@ -1089,10 +1089,8 @@ do_last:
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt, mode, 0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry, mode);
@@ -1325,16 +1323,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1349,35 +1337,16 @@ asmlinkage long sys_mknod(const char * f
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1442,10 +1411,9 @@ asmlinkage long sys_mkdir(const char * p
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -1557,10 +1525,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1607,10 +1573,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1630,12 +1592,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1685,10 +1644,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1706,10 +1661,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1777,10 +1731,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1801,14 +1751,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2042,18 +1987,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2061,6 +1999,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2079,10 +2020,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/centos-3.9/linux-2.4.21-58.EL/fs/open.c after/distro/centos-3.9/linux-2.4.21-58.EL/fs/open.c
--- before/distro/centos-3.9/linux-2.4.21-58.EL/fs/open.c	2009-03-19 11:24:33.000000000 +0900
+++ after/distro/centos-3.9/linux-2.4.21-58.EL/fs/open.c	2009-03-19 23:25:02.000000000 +0900
@@ -249,7 +249,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -307,7 +307,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/centos-3.9/linux-2.4.21-58.EL/net/unix/af_unix.c after/distro/centos-3.9/linux-2.4.21-58.EL/net/unix/af_unix.c
--- before/distro/centos-3.9/linux-2.4.21-58.EL/net/unix/af_unix.c	2009-03-19 11:24:33.000000000 +0900
+++ after/distro/centos-3.9/linux-2.4.21-58.EL/net/unix/af_unix.c	2009-03-19 22:48:06.000000000 +0900
@@ -659,11 +659,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -729,10 +724,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/centos-5.2/linux-2.6.18-92.1.22.el5/fs/namei.c after/distro/centos-5.2/linux-2.6.18-92.1.22.el5/fs/namei.c
--- before/distro/centos-5.2/linux-2.6.18-92.1.22.el5/fs/namei.c	2009-03-19 11:24:33.000000000 +0900
+++ after/distro/centos-5.2/linux-2.6.18-92.1.22.el5/fs/namei.c	2009-03-20 01:40:25.000000000 +0900
@@ -1526,13 +1526,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1712,6 +1705,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1897,16 +1895,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1920,37 +1908,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2016,10 +1988,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2131,10 +2102,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2196,10 +2165,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2222,12 +2187,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2291,10 +2253,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2312,10 +2270,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2390,10 +2347,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2417,12 +2370,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2652,14 +2602,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2684,10 +2630,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/centos-5.2/linux-2.6.18-92.1.22.el5/fs/open.c after/distro/centos-5.2/linux-2.6.18-92.1.22.el5/fs/open.c
--- before/distro/centos-5.2/linux-2.6.18-92.1.22.el5/fs/open.c	2009-03-19 11:24:33.000000000 +0900
+++ after/distro/centos-5.2/linux-2.6.18-92.1.22.el5/fs/open.c	2009-03-19 23:24:53.000000000 +0900
@@ -277,7 +277,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -334,7 +334,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/centos-5.2/linux-2.6.18-92.1.22.el5/net/unix/af_unix.c after/distro/centos-5.2/linux-2.6.18-92.1.22.el5/net/unix/af_unix.c
--- before/distro/centos-5.2/linux-2.6.18-92.1.22.el5/net/unix/af_unix.c	2009-03-19 11:24:33.000000000 +0900
+++ after/distro/centos-5.2/linux-2.6.18-92.1.22.el5/net/unix/af_unix.c	2009-03-19 22:47:47.000000000 +0900
@@ -767,11 +767,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -816,10 +811,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/centos-5.3/linux-2.6.18-128.el5/fs/namei.c after/distro/centos-5.3/linux-2.6.18-128.el5/fs/namei.c
--- before/distro/centos-5.3/linux-2.6.18-128.el5/fs/namei.c	2009-03-19 11:24:34.000000000 +0900
+++ after/distro/centos-5.3/linux-2.6.18-128.el5/fs/namei.c	2009-03-20 01:40:33.000000000 +0900
@@ -1526,13 +1526,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1712,6 +1705,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1897,16 +1895,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1920,37 +1908,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2016,10 +1988,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2131,10 +2102,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2196,10 +2165,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2222,12 +2187,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2291,10 +2253,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2312,10 +2270,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2390,10 +2347,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2417,12 +2370,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2652,14 +2602,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2684,10 +2630,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/centos-5.3/linux-2.6.18-128.el5/fs/open.c after/distro/centos-5.3/linux-2.6.18-128.el5/fs/open.c
--- before/distro/centos-5.3/linux-2.6.18-128.el5/fs/open.c	2009-03-19 11:24:34.000000000 +0900
+++ after/distro/centos-5.3/linux-2.6.18-128.el5/fs/open.c	2009-03-19 23:24:48.000000000 +0900
@@ -278,7 +278,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -335,7 +335,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/centos-5.3/linux-2.6.18-128.el5/net/unix/af_unix.c after/distro/centos-5.3/linux-2.6.18-128.el5/net/unix/af_unix.c
--- before/distro/centos-5.3/linux-2.6.18-128.el5/net/unix/af_unix.c	2009-03-19 11:24:34.000000000 +0900
+++ after/distro/centos-5.3/linux-2.6.18-128.el5/net/unix/af_unix.c	2009-03-19 22:47:36.000000000 +0900
@@ -768,11 +768,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -817,10 +812,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/debian-etch/linux-2.6.18-23etch1/fs/namei.c after/distro/debian-etch/linux-2.6.18-23etch1/fs/namei.c
--- before/distro/debian-etch/linux-2.6.18-23etch1/fs/namei.c	2009-03-19 11:24:34.000000000 +0900
+++ after/distro/debian-etch/linux-2.6.18-23etch1/fs/namei.c	2009-03-20 01:40:42.000000000 +0900
@@ -1485,13 +1485,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1671,6 +1664,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1856,16 +1854,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1879,37 +1867,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1975,10 +1947,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2090,10 +2061,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2155,10 +2124,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2181,12 +2146,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2250,10 +2212,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2271,10 +2229,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2349,10 +2306,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2376,12 +2329,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2611,14 +2561,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2643,10 +2589,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/debian-etch/linux-2.6.18-23etch1/fs/open.c after/distro/debian-etch/linux-2.6.18-23etch1/fs/open.c
--- before/distro/debian-etch/linux-2.6.18-23etch1/fs/open.c	2009-03-19 11:24:34.000000000 +0900
+++ after/distro/debian-etch/linux-2.6.18-23etch1/fs/open.c	2009-03-19 23:24:44.000000000 +0900
@@ -274,7 +274,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -331,7 +331,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/debian-etch/linux-2.6.18-23etch1/net/unix/af_unix.c after/distro/debian-etch/linux-2.6.18-23etch1/net/unix/af_unix.c
--- before/distro/debian-etch/linux-2.6.18-23etch1/net/unix/af_unix.c	2009-03-19 11:24:34.000000000 +0900
+++ after/distro/debian-etch/linux-2.6.18-23etch1/net/unix/af_unix.c	2009-03-19 22:47:25.000000000 +0900
@@ -767,11 +767,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -816,10 +811,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/debian-lenny/linux-2.6.26-13/fs/namei.c after/distro/debian-lenny/linux-2.6.26-13/fs/namei.c
--- before/distro/debian-lenny/linux-2.6.26-13/fs/namei.c	2009-03-19 11:24:34.000000000 +0900
+++ after/distro/debian-lenny/linux-2.6.26-13/fs/namei.c	2009-03-20 02:18:09.000000000 +0900
@@ -1597,14 +1597,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1712,6 +1704,11 @@ static int __open_namei_create(struct na
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->path.dentry);
@@ -2100,16 +2097,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
diff -upr before/distro/debian-sarge/linux-2.4.27-10sarge7/fs/namei.c after/distro/debian-sarge/linux-2.4.27-10sarge7/fs/namei.c
--- before/distro/debian-sarge/linux-2.4.27-10sarge7/fs/namei.c	2009-03-19 11:24:35.000000000 +0900
+++ after/distro/debian-sarge/linux-2.4.27-10sarge7/fs/namei.c	2009-03-20 02:17:35.000000000 +0900
@@ -1059,10 +1059,8 @@ do_last:
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt, mode, 0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry, mode);
@@ -1293,16 +1291,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1317,35 +1305,16 @@ asmlinkage long sys_mknod(const char * f
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1410,10 +1379,9 @@ asmlinkage long sys_mkdir(const char * p
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -1525,10 +1493,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1575,10 +1541,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1598,12 +1560,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1653,10 +1612,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1674,10 +1629,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1745,10 +1699,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1769,14 +1719,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2010,18 +1955,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2029,6 +1967,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2047,10 +1988,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/debian-sarge/linux-2.4.27-10sarge7/fs/open.c after/distro/debian-sarge/linux-2.4.27-10sarge7/fs/open.c
--- before/distro/debian-sarge/linux-2.4.27-10sarge7/fs/open.c	2009-03-19 11:24:35.000000000 +0900
+++ after/distro/debian-sarge/linux-2.4.27-10sarge7/fs/open.c	2009-03-19 23:24:34.000000000 +0900
@@ -170,7 +170,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -228,7 +228,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/debian-sarge/linux-2.4.27-10sarge7/net/unix/af_unix.c after/distro/debian-sarge/linux-2.4.27-10sarge7/net/unix/af_unix.c
--- before/distro/debian-sarge/linux-2.4.27-10sarge7/net/unix/af_unix.c	2009-03-19 11:24:35.000000000 +0900
+++ after/distro/debian-sarge/linux-2.4.27-10sarge7/net/unix/af_unix.c	2009-03-19 22:47:04.000000000 +0900
@@ -659,11 +659,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -729,10 +724,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/debian-sarge/linux-2.6.8-17sarge1/fs/namei.c after/distro/debian-sarge/linux-2.6.8-17sarge1/fs/namei.c
--- before/distro/debian-sarge/linux-2.6.8-17sarge1/fs/namei.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/debian-sarge/linux-2.6.8-17sarge1/fs/namei.c	2009-03-20 01:47:10.000000000 +0900
@@ -1221,13 +1221,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error) {
@@ -1400,6 +1393,11 @@ do_last:
 	if (!dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry, mode, nd);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
@@ -1570,16 +1568,6 @@ asmlinkage long sys_mknod(const char __u
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1593,37 +1581,21 @@ asmlinkage long sys_mknod(const char __u
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1686,10 +1658,9 @@ asmlinkage long sys_mkdir(const char __u
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -1801,10 +1772,8 @@ asmlinkage long sys_rmdir(const char __u
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1861,10 +1830,6 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1887,12 +1852,9 @@ asmlinkage long sys_unlink(const char __
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1942,10 +1904,6 @@ asmlinkage long sys_symlink(const char _
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1963,10 +1921,9 @@ asmlinkage long sys_symlink(const char _
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2036,10 +1993,6 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -2058,12 +2011,9 @@ asmlinkage long sys_link(const char __us
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2289,14 +2239,10 @@ static inline int do_rename(const char *
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2320,10 +2266,6 @@ asmlinkage long sys_rename(const char __
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/debian-sarge/linux-2.6.8-17sarge1/fs/open.c after/distro/debian-sarge/linux-2.6.8-17sarge1/fs/open.c
--- before/distro/debian-sarge/linux-2.6.8-17sarge1/fs/open.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/debian-sarge/linux-2.6.8-17sarge1/fs/open.c	2009-03-19 23:24:30.000000000 +0900
@@ -265,7 +265,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -322,7 +322,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/debian-sarge/linux-2.6.8-17sarge1/net/unix/af_unix.c after/distro/debian-sarge/linux-2.6.8-17sarge1/net/unix/af_unix.c
--- before/distro/debian-sarge/linux-2.6.8-17sarge1/net/unix/af_unix.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/debian-sarge/linux-2.6.8-17sarge1/net/unix/af_unix.c	2009-03-19 22:46:53.000000000 +0900
@@ -742,11 +742,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -812,10 +807,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/fs/namei.c after/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/fs/namei.c
--- before/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/fs/namei.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/fs/namei.c	2009-03-20 02:16:24.000000000 +0900
@@ -1519,14 +1519,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1634,6 +1626,11 @@ static int __open_namei_create(struct na
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->path.dentry);
@@ -1997,16 +1994,6 @@ int vfs_mknod(struct inode *dir, struct 
 
 static int may_mknod(mode_t mode)
 {
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 	case S_IFREG:
 	case S_IFCHR:
@@ -2050,39 +2037,21 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const
 	error = mnt_want_write(nd.path.mnt);
 	if (error)
 		goto out_dput;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode,
+					   new_decode_dev(dev));
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);
 			break;
 	}
@@ -2146,10 +2115,8 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);
@@ -2260,10 +2227,8 @@ static long do_rmdir(int dfd, const char
 	if (error)
 		goto exit3;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
@@ -2327,10 +2292,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(dfd, pathname, &nd, &name);
 	if (error)
@@ -2353,10 +2314,8 @@ static long do_unlinkat(int dfd, const c
 		if (error)
 			goto exit2;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-						     nd.path.mnt);
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
@@ -2423,10 +2382,6 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	char *to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if (IS_ERR(from))
@@ -2445,10 +2400,8 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_symlink_permission(nd.path.dentry->d_inode, dentry,
+					     nd.path.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.path.dentry->d_inode, dentry, from);
@@ -2527,10 +2480,6 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_at(olddfd, oldname,
 			     flags & AT_SYMLINK_FOLLOW ? LOOKUP_FOLLOW : 0,
@@ -2552,12 +2501,9 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_path.dentry, nd.path.dentry->d_inode,
-			     new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_path.dentry,
-					     old_path.mnt, new_dentry,
-					     nd.path.mnt);
+	error = ccs_check_link_permission(old_path.dentry,
+					  nd.path.dentry->d_inode, new_dentry,
+					  nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_path.dentry, nd.path.dentry->d_inode, new_dentry);
@@ -2736,10 +2682,6 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	char *from;
 	char *to;
 	int error;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(olddfd, oldname, &oldnd, &from);
 	if (error)
@@ -2792,21 +2734,16 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	error = -ENOTEMPTY;
 	if (new_dentry == trap)
 		goto exit5;
-	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-				     oldnd.path.mnt, new_dentry,
-				     newnd.path.mnt);
-	if (error)
-		goto exit5;
-	/***** TOMOYO Linux end. *****/
 
 	error = mnt_want_write(oldnd.path.mnt);
 	if (error)
 		goto exit5;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.path.mnt);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
 	mnt_drop_write(oldnd.path.mnt);
diff -upr before/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/fs/open.c after/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/fs/open.c
--- before/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/fs/open.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/fs/open.c	2009-03-19 23:24:25.000000000 +0900
@@ -276,7 +276,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, path.dentry, path.mnt);
+	error = ccs_check_truncate_permission(path.dentry, path.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -337,7 +337,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/net/unix/af_unix.c after/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/net/unix/af_unix.c
--- before/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/net/unix/af_unix.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/fedora-10/linux-2.6.27.19-170.2.35.fc10/net/unix/af_unix.c	2009-03-19 22:53:11.000000000 +0900
@@ -784,11 +784,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -836,10 +831,8 @@ static int unix_bind(struct socket *sock
 		if (err)
 			goto out_mknod_dput;
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.path.mnt);
+		err = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						 dentry, nd.path.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.path.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/fedora-7/linux-2.6.23.17-88.fc7/fs/namei.c after/distro/fedora-7/linux-2.6.23.17-88.fc7/fs/namei.c
--- before/distro/fedora-7/linux-2.6.23.17-88.fc7/fs/namei.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/fedora-7/linux-2.6.23.17-88.fc7/fs/namei.c	2009-03-20 01:20:33.000000000 +0900
@@ -1561,13 +1561,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1669,6 +1662,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1942,16 +1940,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1965,37 +1953,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2064,9 +2036,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2177,9 +2148,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2241,10 +2210,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2267,12 +2232,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2338,10 +2300,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2360,9 +2318,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2437,10 +2394,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2465,10 +2418,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2697,14 +2648,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2729,10 +2676,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/fedora-7/linux-2.6.23.17-88.fc7/fs/open.c after/distro/fedora-7/linux-2.6.23.17-88.fc7/fs/open.c
--- before/distro/fedora-7/linux-2.6.23.17-88.fc7/fs/open.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/fedora-7/linux-2.6.23.17-88.fc7/fs/open.c	2009-03-19 23:24:20.000000000 +0900
@@ -275,7 +275,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -334,7 +334,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/fedora-7/linux-2.6.23.17-88.fc7/net/unix/af_unix.c after/distro/fedora-7/linux-2.6.23.17-88.fc7/net/unix/af_unix.c
--- before/distro/fedora-7/linux-2.6.23.17-88.fc7/net/unix/af_unix.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/fedora-7/linux-2.6.23.17-88.fc7/net/unix/af_unix.c	2009-03-19 22:46:32.000000000 +0900
@@ -794,11 +794,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -843,10 +838,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/fedora-8/linux-2.6.26.8-57.fc8/fs/namei.c after/distro/fedora-8/linux-2.6.26.8-57.fc8/fs/namei.c
--- before/distro/fedora-8/linux-2.6.26.8-57.fc8/fs/namei.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/fedora-8/linux-2.6.26.8-57.fc8/fs/namei.c	2009-03-20 02:15:20.000000000 +0900
@@ -1612,14 +1612,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1727,6 +1719,11 @@ static int __open_namei_create(struct na
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->path.dentry);
@@ -2115,16 +2112,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -2145,39 +2132,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	error = mnt_want_write(nd.path.mnt);
 	if (error)
 		goto out_dput;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode,
+					   new_decode_dev(dev));
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);
 			break;
 	}
@@ -2246,10 +2215,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);
@@ -2365,10 +2332,8 @@ static long do_rmdir(int dfd, const char
 	if (error)
 		goto exit3;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
@@ -2433,10 +2398,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2462,10 +2423,8 @@ static long do_unlinkat(int dfd, const c
 		if (error)
 			goto exit2;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-						     nd.path.mnt);
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
@@ -2533,10 +2492,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2558,10 +2513,8 @@ asmlinkage long sys_symlinkat(const char
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_symlink_permission(nd.path.dentry->d_inode, dentry,
+					     nd.path.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.path.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2638,10 +2591,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2669,12 +2618,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.path.dentry, nd.path.dentry->d_inode,
-			     new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.path.dentry,
-					     old_nd.path.mnt, new_dentry,
-					     nd.path.mnt);
+	error = ccs_check_link_permission(old_nd.path.dentry,
+					  nd.path.dentry->d_inode, new_dentry,
+					  nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.path.dentry, nd.path.dentry->d_inode, new_dentry);
@@ -2904,21 +2850,16 @@ static int do_rename(int olddfd, const c
 	error = -ENOTEMPTY;
 	if (new_dentry == trap)
 		goto exit5;
-	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-				     oldnd.path.mnt, new_dentry,
-				     newnd.path.mnt);
-	if (error)
-		goto exit5;
-	/***** TOMOYO Linux end. *****/
 
 	error = mnt_want_write(oldnd.path.mnt);
 	if (error)
 		goto exit5;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.path.mnt);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
 	mnt_drop_write(oldnd.path.mnt);
@@ -2942,10 +2883,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/fedora-8/linux-2.6.26.8-57.fc8/fs/open.c after/distro/fedora-8/linux-2.6.26.8-57.fc8/fs/open.c
--- before/distro/fedora-8/linux-2.6.26.8-57.fc8/fs/open.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/fedora-8/linux-2.6.26.8-57.fc8/fs/open.c	2009-03-19 23:24:16.000000000 +0900
@@ -277,8 +277,8 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.path.dentry,
-				     nd.path.mnt);
+	error = ccs_check_truncate_permission(nd.path.dentry, nd.path.mnt,
+					      length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -339,7 +339,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/fedora-8/linux-2.6.26.8-57.fc8/net/unix/af_unix.c after/distro/fedora-8/linux-2.6.26.8-57.fc8/net/unix/af_unix.c
--- before/distro/fedora-8/linux-2.6.26.8-57.fc8/net/unix/af_unix.c	2009-03-19 11:24:47.000000000 +0900
+++ after/distro/fedora-8/linux-2.6.26.8-57.fc8/net/unix/af_unix.c	2009-03-19 22:52:56.000000000 +0900
@@ -786,11 +786,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -838,10 +833,8 @@ static int unix_bind(struct socket *sock
 		if (err)
 			goto out_mknod_dput;
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.path.mnt);
+		err = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						 dentry, nd.path.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.path.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/fs/namei.c after/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/fs/namei.c
--- before/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/fs/namei.c	2009-03-19 11:24:48.000000000 +0900
+++ after/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/fs/namei.c	2009-03-20 02:15:00.000000000 +0900
@@ -1519,14 +1519,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1634,6 +1626,11 @@ static int __open_namei_create(struct na
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->path.dentry);
@@ -1997,16 +1994,6 @@ int vfs_mknod(struct inode *dir, struct 
 
 static int may_mknod(mode_t mode)
 {
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 	case S_IFREG:
 	case S_IFCHR:
@@ -2050,39 +2037,21 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const
 	error = mnt_want_write(nd.path.mnt);
 	if (error)
 		goto out_dput;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode,
+					   new_decode_dev(dev));
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);
 			break;
 	}
@@ -2146,10 +2115,8 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);
@@ -2260,10 +2227,8 @@ static long do_rmdir(int dfd, const char
 	if (error)
 		goto exit3;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
@@ -2327,10 +2292,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(dfd, pathname, &nd, &name);
 	if (error)
@@ -2353,10 +2314,8 @@ static long do_unlinkat(int dfd, const c
 		if (error)
 			goto exit2;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-						     nd.path.mnt);
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
@@ -2423,10 +2382,6 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	char *to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if (IS_ERR(from))
@@ -2445,10 +2400,8 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_symlink_permission(nd.path.dentry->d_inode, dentry,
+					     nd.path.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.path.dentry->d_inode, dentry, from);
@@ -2527,10 +2480,6 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_at(olddfd, oldname,
 			     flags & AT_SYMLINK_FOLLOW ? LOOKUP_FOLLOW : 0,
@@ -2552,12 +2501,9 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_path.dentry, nd.path.dentry->d_inode,
-			     new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_path.dentry,
-					     old_path.mnt, new_dentry,
-					     nd.path.mnt);
+	error = ccs_check_link_permission(old_path.dentry,
+					  nd.path.dentry->d_inode, new_dentry,
+					  nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_path.dentry, nd.path.dentry->d_inode, new_dentry);
@@ -2736,10 +2682,6 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	char *from;
 	char *to;
 	int error;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(olddfd, oldname, &oldnd, &from);
 	if (error)
@@ -2792,21 +2734,16 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	error = -ENOTEMPTY;
 	if (new_dentry == trap)
 		goto exit5;
-	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-				     oldnd.path.mnt, new_dentry,
-				     newnd.path.mnt);
-	if (error)
-		goto exit5;
-	/***** TOMOYO Linux end. *****/
 
 	error = mnt_want_write(oldnd.path.mnt);
 	if (error)
 		goto exit5;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.path.mnt);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
 	mnt_drop_write(oldnd.path.mnt);
diff -upr before/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/fs/open.c after/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/fs/open.c
--- before/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/fs/open.c	2009-03-19 11:24:48.000000000 +0900
+++ after/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/fs/open.c	2009-03-19 23:24:11.000000000 +0900
@@ -276,7 +276,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, path.dentry, path.mnt);
+	error = ccs_check_truncate_permission(path.dentry, path.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -337,7 +337,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/net/unix/af_unix.c after/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/net/unix/af_unix.c
--- before/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/net/unix/af_unix.c	2009-03-19 11:24:48.000000000 +0900
+++ after/distro/fedora-9/linux-2.6.27.19-78.2.30.fc9/net/unix/af_unix.c	2009-03-19 22:52:41.000000000 +0900
@@ -784,11 +784,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -836,10 +831,8 @@ static int unix_bind(struct socket *sock
 		if (err)
 			goto out_mknod_dput;
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.path.mnt);
+		err = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						 dentry, nd.path.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.path.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/fs/namei.c after/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/fs/namei.c
--- before/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/fs/namei.c	2009-03-19 11:24:48.000000000 +0900
+++ after/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/fs/namei.c	2009-03-20 01:40:54.000000000 +0900
@@ -1321,13 +1321,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error) {
@@ -1501,6 +1494,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
@@ -1665,16 +1663,6 @@ asmlinkage long sys_mknod(const char __u
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1688,37 +1676,21 @@ asmlinkage long sys_mknod(const char __u
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1781,10 +1753,9 @@ asmlinkage long sys_mkdir(const char __u
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -1892,10 +1863,8 @@ asmlinkage long sys_rmdir(const char __u
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1952,10 +1921,6 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1978,12 +1943,9 @@ asmlinkage long sys_unlink(const char __
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2032,10 +1994,6 @@ asmlinkage long sys_symlink(const char _
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2053,10 +2011,9 @@ asmlinkage long sys_symlink(const char _
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2126,10 +2083,6 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -2148,12 +2101,9 @@ asmlinkage long sys_link(const char __us
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2379,14 +2329,10 @@ static inline int do_rename(const char *
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2410,10 +2356,6 @@ asmlinkage long sys_rename(const char __
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/fs/open.c after/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/fs/open.c
--- before/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/fs/open.c	2009-03-19 11:24:48.000000000 +0900
+++ after/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/fs/open.c	2009-03-19 23:24:06.000000000 +0900
@@ -265,7 +265,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -322,7 +322,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/net/unix/af_unix.c after/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/net/unix/af_unix.c
--- before/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/net/unix/af_unix.c	2009-03-19 11:24:48.000000000 +0900
+++ after/distro/fedora-core-3/linux-2.6.12-2.3.legacy_FC3/net/unix/af_unix.c	2009-03-19 22:45:56.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/fs/namei.c after/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/fs/namei.c
--- before/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/fs/namei.c	2009-03-19 11:24:48.000000000 +0900
+++ after/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/fs/namei.c	2009-03-20 01:41:04.000000000 +0900
@@ -1486,13 +1486,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1672,6 +1665,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1847,16 +1845,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1870,37 +1858,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1966,10 +1938,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2081,10 +2052,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2146,10 +2115,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2172,12 +2137,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2241,10 +2203,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2262,10 +2220,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2340,10 +2297,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if (flags != 0)
 		return -EINVAL;
@@ -2365,12 +2318,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2600,14 +2550,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2632,10 +2578,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/fs/open.c after/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/fs/open.c
--- before/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/fs/open.c	2009-03-19 11:24:48.000000000 +0900
+++ after/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/fs/open.c	2009-03-19 23:24:01.000000000 +0900
@@ -275,7 +275,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -331,7 +331,8 @@ static long do_sys_ftruncate(unsigned in
 	if (IS_APPEND(inode))
 		goto out_putf;
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/net/unix/af_unix.c after/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/net/unix/af_unix.c
--- before/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/net/unix/af_unix.c	2009-03-19 11:24:48.000000000 +0900
+++ after/distro/fedora-core-4/linux-2.6.17-1.2142_FC4/net/unix/af_unix.c	2009-03-19 22:45:46.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/fs/namei.c after/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/fs/namei.c
--- before/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/fs/namei.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/fs/namei.c	2009-03-20 01:20:22.000000000 +0900
@@ -1510,13 +1510,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1618,6 +1611,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1891,16 +1889,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1914,37 +1902,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2013,9 +1985,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2126,9 +2097,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2190,10 +2159,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2216,12 +2181,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2287,10 +2249,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2309,9 +2267,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2386,10 +2343,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2414,10 +2367,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2646,14 +2597,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2678,10 +2625,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/fs/open.c after/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/fs/open.c
--- before/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/fs/open.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/fs/open.c	2009-03-19 23:23:57.000000000 +0900
@@ -271,7 +271,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -328,7 +328,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/net/unix/af_unix.c after/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/net/unix/af_unix.c
--- before/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/net/unix/af_unix.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/fedora-core-5/linux-2.6.20-1.2320.fc5/net/unix/af_unix.c	2009-03-19 22:45:36.000000000 +0900
@@ -768,11 +768,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -817,10 +812,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/fedora-core-6/linux-2.6.22.14-72.fc6/fs/namei.c after/distro/fedora-core-6/linux-2.6.22.14-72.fc6/fs/namei.c
--- before/distro/fedora-core-6/linux-2.6.22.14-72.fc6/fs/namei.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/fedora-core-6/linux-2.6.22.14-72.fc6/fs/namei.c	2009-03-20 01:20:12.000000000 +0900
@@ -1528,13 +1528,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1636,6 +1629,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1909,16 +1907,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1932,37 +1920,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2031,9 +2003,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2144,9 +2115,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2208,10 +2177,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2234,12 +2199,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2305,10 +2267,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2327,9 +2285,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2404,10 +2361,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2432,10 +2385,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2664,14 +2615,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2696,10 +2643,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/fedora-core-6/linux-2.6.22.14-72.fc6/fs/open.c after/distro/fedora-core-6/linux-2.6.22.14-72.fc6/fs/open.c
--- before/distro/fedora-core-6/linux-2.6.22.14-72.fc6/fs/open.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/fedora-core-6/linux-2.6.22.14-72.fc6/fs/open.c	2009-03-19 23:23:52.000000000 +0900
@@ -273,7 +273,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -330,7 +330,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/fedora-core-6/linux-2.6.22.14-72.fc6/net/unix/af_unix.c after/distro/fedora-core-6/linux-2.6.22.14-72.fc6/net/unix/af_unix.c
--- before/distro/fedora-core-6/linux-2.6.22.14-72.fc6/net/unix/af_unix.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/fedora-core-6/linux-2.6.22.14-72.fc6/net/unix/af_unix.c	2009-03-19 22:45:23.000000000 +0900
@@ -767,11 +767,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -816,10 +811,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/gentoo/linux-2.6.24-gentoo-r8/fs/namei.c after/distro/gentoo/linux-2.6.24-gentoo-r8/fs/namei.c
--- before/distro/gentoo/linux-2.6.24-gentoo-r8/fs/namei.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/gentoo/linux-2.6.24-gentoo-r8/fs/namei.c	2009-03-20 01:12:53.000000000 +0900
@@ -1590,13 +1590,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1700,6 +1693,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1973,16 +1971,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1996,37 +1984,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2095,9 +2067,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2208,9 +2179,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2272,10 +2241,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2298,12 +2263,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2369,10 +2331,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2391,9 +2349,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2468,10 +2425,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2496,10 +2449,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2728,14 +2679,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2760,10 +2707,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/gentoo/linux-2.6.24-gentoo-r8/fs/open.c after/distro/gentoo/linux-2.6.24-gentoo-r8/fs/open.c
--- before/distro/gentoo/linux-2.6.24-gentoo-r8/fs/open.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/gentoo/linux-2.6.24-gentoo-r8/fs/open.c	2009-03-19 23:23:47.000000000 +0900
@@ -275,7 +275,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -334,7 +334,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/gentoo/linux-2.6.24-gentoo-r8/net/unix/af_unix.c after/distro/gentoo/linux-2.6.24-gentoo-r8/net/unix/af_unix.c
--- before/distro/gentoo/linux-2.6.24-gentoo-r8/net/unix/af_unix.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/gentoo/linux-2.6.24-gentoo-r8/net/unix/af_unix.c	2009-03-19 22:45:08.000000000 +0900
@@ -799,11 +799,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -848,10 +843,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/gentoo/linux-2.6.27-hardened-r8/fs/namei.c after/distro/gentoo/linux-2.6.27-hardened-r8/fs/namei.c
--- before/distro/gentoo/linux-2.6.27-hardened-r8/fs/namei.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/gentoo/linux-2.6.27-hardened-r8/fs/namei.c	2009-03-20 02:13:13.000000000 +0900
@@ -1535,14 +1535,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1655,6 +1647,11 @@ static int __open_namei_create(struct na
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	if (!error)
 		gr_handle_create(path->dentry, nd->path.mnt);
@@ -2053,16 +2050,6 @@ int vfs_mknod(struct inode *dir, struct 
 
 static int may_mknod(mode_t mode)
 {
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 	case S_IFREG:
 	case S_IFCHR:
@@ -2118,39 +2105,21 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const
 	if (error)
 		goto out_dput;
 
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode,
+					   new_decode_dev(dev));
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);
 			break;
 	}
@@ -2222,10 +2191,8 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);
@@ -2355,10 +2322,8 @@ static long do_rmdir(int dfd, const char
 	if (error)
 		goto exit3;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
@@ -2426,10 +2391,6 @@ static long do_unlinkat(int dfd, const c
 	struct inode *inode = NULL;
 	ino_t saved_ino = 0;
 	dev_t saved_dev = 0;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(dfd, pathname, &nd, &name);
 	if (error)
@@ -2463,10 +2424,8 @@ static long do_unlinkat(int dfd, const c
 		if (error)
 			goto exit2;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-						     nd.path.mnt);
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
@@ -2535,10 +2494,6 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	char *to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if (IS_ERR(from))
@@ -2562,10 +2517,8 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_symlink_permission(nd.path.dentry->d_inode, dentry,
+					     nd.path.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.path.dentry->d_inode, dentry, from);
@@ -2646,10 +2599,6 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_at(olddfd, oldname,
 			     flags & AT_SYMLINK_FOLLOW ? LOOKUP_FOLLOW : 0,
@@ -2685,12 +2634,9 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_path.dentry, nd.path.dentry->d_inode,
-			     new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_path.dentry,
-					     old_path.mnt, new_dentry,
-					     nd.path.mnt);
+	error = ccs_check_link_permission(old_path.dentry,
+					  nd.path.dentry->d_inode, new_dentry,
+					  nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_path.dentry, nd.path.dentry->d_inode, new_dentry);
@@ -2873,10 +2819,6 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	char *from;
 	char *to;
 	int error;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(olddfd, oldname, &oldnd, &from);
 	if (error)
@@ -2929,17 +2871,6 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	error = -ENOTEMPTY;
 	if (new_dentry == trap)
 		goto exit5;
-	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-				     oldnd.path.mnt, new_dentry,
-				     newnd.path.mnt);
-	if (error)
-		goto exit5;
-	/***** TOMOYO Linux end. *****/
 
 	error = gr_acl_handle_rename(new_dentry, new_dir, newnd.path.mnt,
 				     old_dentry, old_dir->d_inode, oldnd.path.mnt,
@@ -2950,6 +2881,12 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	error = mnt_want_write(oldnd.path.mnt);
 	if (error)
 		goto exit5;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.path.mnt);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
 	if (!error)
diff -upr before/distro/gentoo/linux-2.6.27-hardened-r8/fs/open.c after/distro/gentoo/linux-2.6.27-hardened-r8/fs/open.c
--- before/distro/gentoo/linux-2.6.27-hardened-r8/fs/open.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/gentoo/linux-2.6.27-hardened-r8/fs/open.c	2009-03-19 23:23:42.000000000 +0900
@@ -280,7 +280,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, path.dentry, path.mnt);
+	error = ccs_check_truncate_permission(path.dentry, path.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -341,7 +341,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/gentoo/linux-2.6.27-hardened-r8/net/unix/af_unix.c after/distro/gentoo/linux-2.6.27-hardened-r8/net/unix/af_unix.c
--- before/distro/gentoo/linux-2.6.27-hardened-r8/net/unix/af_unix.c	2009-03-19 11:24:49.000000000 +0900
+++ after/distro/gentoo/linux-2.6.27-hardened-r8/net/unix/af_unix.c	2009-03-19 22:52:19.000000000 +0900
@@ -798,11 +798,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -857,10 +852,8 @@ static int unix_bind(struct socket *sock
 		}
 
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.path.mnt);
+		err = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						 dentry, nd.path.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.path.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/gentoo/linux-2.6.28-hardened-r3/fs/namei.c after/distro/gentoo/linux-2.6.28-hardened-r3/fs/namei.c
--- before/distro/gentoo/linux-2.6.28-hardened-r3/fs/namei.c	2009-03-19 11:24:50.000000000 +0900
+++ after/distro/gentoo/linux-2.6.28-hardened-r3/fs/namei.c	2009-03-20 02:12:35.000000000 +0900
@@ -1502,14 +1502,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1622,6 +1614,11 @@ static int __open_namei_create(struct na
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	if (!error)
 		gr_handle_create(path->dentry, nd->path.mnt);
@@ -2030,16 +2027,6 @@ int vfs_mknod(struct inode *dir, struct 
 
 static int may_mknod(mode_t mode)
 {
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 	case S_IFREG:
 	case S_IFCHR:
@@ -2094,39 +2081,21 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const
 	error = mnt_want_write(nd.path.mnt);
 	if (error)
 		goto out_dput;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode,
+					   new_decode_dev(dev));
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);
 			break;
 	}
@@ -2198,10 +2167,8 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);
@@ -2334,10 +2301,8 @@ static long do_rmdir(int dfd, const char
 	if (error)
 		goto exit3;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
@@ -2405,10 +2370,6 @@ static long do_unlinkat(int dfd, const c
 	struct inode *inode = NULL;
 	ino_t saved_ino = 0;
 	dev_t saved_dev = 0;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(dfd, pathname, &nd, &name);
 	if (error)
@@ -2445,10 +2406,8 @@ static long do_unlinkat(int dfd, const c
 		if (error)
 			goto exit2;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-						     nd.path.mnt);
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
@@ -2517,10 +2476,6 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	char *to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if (IS_ERR(from))
@@ -2544,10 +2499,8 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_symlink_permission(nd.path.dentry->d_inode, dentry,
+					     nd.path.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.path.dentry->d_inode, dentry, from);
@@ -2628,10 +2581,6 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_at(olddfd, oldname,
 			     flags & AT_SYMLINK_FOLLOW ? LOOKUP_FOLLOW : 0,
@@ -2667,12 +2616,9 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_path.dentry, nd.path.dentry->d_inode,
-			     new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_path.dentry,
-					     old_path.mnt, new_dentry,
-					     nd.path.mnt);
+	error = ccs_check_link_permission(old_path.dentry,
+					  nd.path.dentry->d_inode, new_dentry,
+					  nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_path.dentry, nd.path.dentry->d_inode, new_dentry);
@@ -2853,10 +2799,6 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	char *from;
 	char *to;
 	int error;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(olddfd, oldname, &oldnd, &from);
 	if (error)
@@ -2913,17 +2855,6 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	error = -ENOTEMPTY;
 	if (new_dentry == trap)
 		goto exit5;
-	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-				     oldnd.path.mnt, new_dentry,
-				     newnd.path.mnt);
-	if (error)
-		goto exit5;
-	/***** TOMOYO Linux end. *****/
 
 	error = gr_acl_handle_rename(new_dentry, new_dir, newnd.path.mnt,
 				     old_dentry, old_dir->d_inode, oldnd.path.mnt,
@@ -2934,6 +2865,12 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	error = mnt_want_write(oldnd.path.mnt);
 	if (error)
 		goto exit5;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.path.mnt);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
 	if (!error)
diff -upr before/distro/gentoo/linux-2.6.28-hardened-r3/fs/open.c after/distro/gentoo/linux-2.6.28-hardened-r3/fs/open.c
--- before/distro/gentoo/linux-2.6.28-hardened-r3/fs/open.c	2009-03-19 11:24:50.000000000 +0900
+++ after/distro/gentoo/linux-2.6.28-hardened-r3/fs/open.c	2009-03-19 23:23:37.000000000 +0900
@@ -279,7 +279,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, path.dentry, path.mnt);
+	error = ccs_check_truncate_permission(path.dentry, path.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -340,7 +340,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/gentoo/linux-2.6.28-hardened-r3/net/unix/af_unix.c after/distro/gentoo/linux-2.6.28-hardened-r3/net/unix/af_unix.c
--- before/distro/gentoo/linux-2.6.28-hardened-r3/net/unix/af_unix.c	2009-03-19 11:24:50.000000000 +0900
+++ after/distro/gentoo/linux-2.6.28-hardened-r3/net/unix/af_unix.c	2009-03-19 22:51:50.000000000 +0900
@@ -799,11 +799,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -858,10 +853,8 @@ static int unix_bind(struct socket *sock
 		}
 
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.path.mnt);
+		err = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						 dentry, nd.path.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.path.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/natures-linux-1.6/linux-2.6.18.8p9/fs/namei.c after/distro/natures-linux-1.6/linux-2.6.18.8p9/fs/namei.c
--- before/distro/natures-linux-1.6/linux-2.6.18.8p9/fs/namei.c	2009-03-19 11:25:03.000000000 +0900
+++ after/distro/natures-linux-1.6/linux-2.6.18.8p9/fs/namei.c	2009-03-20 01:42:12.000000000 +0900
@@ -1501,13 +1501,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1698,6 +1691,11 @@ do_last:
 		}
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1888,16 +1886,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1917,37 +1905,21 @@ asmlinkage long sys_mknodat(int dfd, con
 			dput(dentry);
 			goto out_dput;
 		}
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2014,10 +1986,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2129,10 +2100,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2194,10 +2163,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2220,12 +2185,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2289,10 +2251,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2310,10 +2268,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2388,10 +2345,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2415,12 +2368,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2650,14 +2600,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2682,10 +2628,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/natures-linux-1.6/linux-2.6.18.8p9/fs/open.c after/distro/natures-linux-1.6/linux-2.6.18.8p9/fs/open.c
--- before/distro/natures-linux-1.6/linux-2.6.18.8p9/fs/open.c	2009-03-19 11:25:03.000000000 +0900
+++ after/distro/natures-linux-1.6/linux-2.6.18.8p9/fs/open.c	2009-03-19 23:23:32.000000000 +0900
@@ -275,7 +275,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -332,7 +332,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/natures-linux-1.6/linux-2.6.18.8p9/net/unix/af_unix.c after/distro/natures-linux-1.6/linux-2.6.18.8p9/net/unix/af_unix.c
--- before/distro/natures-linux-1.6/linux-2.6.18.8p9/net/unix/af_unix.c	2009-03-19 11:25:03.000000000 +0900
+++ after/distro/natures-linux-1.6/linux-2.6.18.8p9/net/unix/af_unix.c	2009-03-19 22:44:37.000000000 +0900
@@ -768,11 +768,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -817,10 +812,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/fs/namei.c after/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/fs/namei.c
--- before/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/fs/namei.c	2009-03-19 11:25:03.000000000 +0900
+++ after/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/fs/namei.c	2009-03-20 02:11:19.000000000 +0900
@@ -1069,10 +1069,10 @@ do_last:
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt,
+						   mode & ~current->fs->umask,
+						   0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry,
@@ -1304,16 +1304,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1327,35 +1317,16 @@ asmlinkage long sys_mknod(const char * f
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1418,10 +1389,10 @@ asmlinkage long sys_mkdir(const char * p
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode &
+							   ~current->fs->umask);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1534,10 +1505,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1584,10 +1553,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1607,12 +1572,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1662,10 +1624,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1683,10 +1641,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1754,10 +1711,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1778,14 +1731,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2019,18 +1967,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2038,6 +1979,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2056,10 +2000,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/fs/open.c after/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/fs/open.c
--- before/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/fs/open.c	2009-03-19 11:25:03.000000000 +0900
+++ after/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/fs/open.c	2009-03-19 23:23:27.000000000 +0900
@@ -168,7 +168,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -226,7 +226,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/net/unix/af_unix.c after/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/net/unix/af_unix.c
--- before/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/net/unix/af_unix.c	2009-03-19 11:25:03.000000000 +0900
+++ after/distro/redhat-linux-9/linux-2.4.20-46.9.legacy/net/unix/af_unix.c	2009-03-19 22:44:24.000000000 +0900
@@ -664,11 +664,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -734,10 +729,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/suse-10.1/linux-2.6.16.54-0.2.5/fs/namei.c after/distro/suse-10.1/linux-2.6.16.54-0.2.5/fs/namei.c
--- before/distro/suse-10.1/linux-2.6.16.54-0.2.5/fs/namei.c	2009-03-19 11:25:04.000000000 +0900
+++ after/distro/suse-10.1/linux-2.6.16.54-0.2.5/fs/namei.c	2009-03-20 01:42:25.000000000 +0900
@@ -1475,13 +1475,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1661,6 +1654,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1844,16 +1842,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1867,37 +1855,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1963,10 +1935,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2078,10 +2049,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2143,10 +2112,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2169,12 +2134,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2238,10 +2200,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2259,10 +2217,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2337,10 +2294,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if (flags != 0)
 		return -EINVAL;
@@ -2362,12 +2315,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2597,14 +2547,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2629,10 +2575,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/suse-10.1/linux-2.6.16.54-0.2.5/fs/open.c after/distro/suse-10.1/linux-2.6.16.54-0.2.5/fs/open.c
--- before/distro/suse-10.1/linux-2.6.16.54-0.2.5/fs/open.c	2009-03-19 11:25:04.000000000 +0900
+++ after/distro/suse-10.1/linux-2.6.16.54-0.2.5/fs/open.c	2009-03-19 23:23:21.000000000 +0900
@@ -275,7 +275,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -331,7 +331,8 @@ static long do_sys_ftruncate(unsigned in
 	if (IS_APPEND(inode))
 		goto out_putf;
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/suse-10.1/linux-2.6.16.54-0.2.5/net/unix/af_unix.c after/distro/suse-10.1/linux-2.6.16.54-0.2.5/net/unix/af_unix.c
--- before/distro/suse-10.1/linux-2.6.16.54-0.2.5/net/unix/af_unix.c	2009-03-19 11:25:04.000000000 +0900
+++ after/distro/suse-10.1/linux-2.6.16.54-0.2.5/net/unix/af_unix.c	2009-03-19 22:44:14.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/suse-10.2/linux-2.6.18.8-0.13/fs/namei.c after/distro/suse-10.2/linux-2.6.18.8-0.13/fs/namei.c
--- before/distro/suse-10.2/linux-2.6.18.8-0.13/fs/namei.c	2009-03-19 11:25:04.000000000 +0900
+++ after/distro/suse-10.2/linux-2.6.18.8-0.13/fs/namei.c	2009-03-20 01:42:36.000000000 +0900
@@ -1485,13 +1485,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1671,6 +1664,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1856,16 +1854,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1879,37 +1867,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1975,10 +1947,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2090,10 +2061,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2155,10 +2124,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2181,12 +2146,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2250,10 +2212,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2271,10 +2229,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2349,10 +2306,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2376,12 +2329,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2611,14 +2561,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2643,10 +2589,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/suse-10.2/linux-2.6.18.8-0.13/fs/open.c after/distro/suse-10.2/linux-2.6.18.8-0.13/fs/open.c
--- before/distro/suse-10.2/linux-2.6.18.8-0.13/fs/open.c	2009-03-19 11:25:04.000000000 +0900
+++ after/distro/suse-10.2/linux-2.6.18.8-0.13/fs/open.c	2009-03-19 23:23:13.000000000 +0900
@@ -277,7 +277,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -334,7 +334,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/suse-10.2/linux-2.6.18.8-0.13/net/unix/af_unix.c after/distro/suse-10.2/linux-2.6.18.8-0.13/net/unix/af_unix.c
--- before/distro/suse-10.2/linux-2.6.18.8-0.13/net/unix/af_unix.c	2009-03-19 11:25:04.000000000 +0900
+++ after/distro/suse-10.2/linux-2.6.18.8-0.13/net/unix/af_unix.c	2009-03-19 22:44:04.000000000 +0900
@@ -767,11 +767,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -816,10 +811,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/suse-10.3/linux-2.6.22.19-0.2/fs/namei.c after/distro/suse-10.3/linux-2.6.22.19-0.2/fs/namei.c
--- before/distro/suse-10.3/linux-2.6.22.19-0.2/fs/namei.c	2009-03-19 11:25:04.000000000 +0900
+++ after/distro/suse-10.3/linux-2.6.22.19-0.2/fs/namei.c	2009-03-20 01:21:46.000000000 +0900
@@ -1554,13 +1554,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, nd ? nd->mnt : NULL, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1663,6 +1656,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1937,16 +1935,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1960,37 +1948,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
 					  mode, new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
 					  mode, 0);
 			break;
@@ -2061,9 +2033,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, nd.mnt, mode);
@@ -2175,9 +2146,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry, nd.mnt);
@@ -2239,10 +2208,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2265,12 +2230,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry, nd.mnt);
 	exit2:
@@ -2337,10 +2299,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2359,9 +2317,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, nd.mnt, from,
@@ -2438,10 +2395,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2466,10 +2419,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, old_nd.mnt, nd.dentry->d_inode,
@@ -2706,14 +2657,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry, oldnd.mnt,
@@ -2738,10 +2685,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/suse-10.3/linux-2.6.22.19-0.2/fs/open.c after/distro/suse-10.3/linux-2.6.22.19-0.2/fs/open.c
--- before/distro/suse-10.3/linux-2.6.22.19-0.2/fs/open.c	2009-03-19 11:25:04.000000000 +0900
+++ after/distro/suse-10.3/linux-2.6.22.19-0.2/fs/open.c	2009-03-19 23:23:06.000000000 +0900
@@ -273,7 +273,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -330,7 +330,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/suse-10.3/linux-2.6.22.19-0.2/net/unix/af_unix.c after/distro/suse-10.3/linux-2.6.22.19-0.2/net/unix/af_unix.c
--- before/distro/suse-10.3/linux-2.6.22.19-0.2/net/unix/af_unix.c	2009-03-19 11:25:04.000000000 +0900
+++ after/distro/suse-10.3/linux-2.6.22.19-0.2/net/unix/af_unix.c	2009-03-19 22:43:53.000000000 +0900
@@ -767,11 +767,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -816,10 +811,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt, mode, 0);
diff -upr before/distro/suse-11.0/linux-2.6.25.20-0.1/fs/namei.c after/distro/suse-11.0/linux-2.6.25.20-0.1/fs/namei.c
--- before/distro/suse-11.0/linux-2.6.25.20-0.1/fs/namei.c	2009-03-19 11:25:05.000000000 +0900
+++ after/distro/suse-11.0/linux-2.6.25.20-0.1/fs/namei.c	2009-03-20 01:03:10.000000000 +0900
@@ -1639,14 +1639,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, nd ? nd->path.mnt : NULL, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1750,6 +1742,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->path.dentry);
@@ -2028,16 +2025,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -2051,39 +2038,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.path.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode, dentry,
 					  nd.path.mnt, mode, new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode, dentry,
 					  nd.path.mnt, mode, 0);
 			break;
@@ -2154,10 +2123,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.path.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, nd.path.mnt, mode);
@@ -2269,10 +2236,8 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry, nd.path.mnt);
@@ -2335,10 +2300,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2361,13 +2322,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-					     nd.path.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry, nd.path.mnt);
 	exit2:
@@ -2434,10 +2391,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2456,10 +2409,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_symlink_permission(nd.path.dentry->d_inode, dentry,
+					     nd.path.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.path.dentry->d_inode, dentry, nd.path.mnt, from,
@@ -2536,10 +2487,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2564,12 +2511,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.path.dentry, nd.path.dentry->d_inode,
-			     new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.path.dentry,
-					     old_nd.path.mnt, new_dentry,
-					     nd.path.mnt);
+	error = ccs_check_link_permission(old_nd.path.dentry,
+					  nd.path.dentry->d_inode, new_dentry,
+					  nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.path.dentry, old_nd.path.mnt, nd.path.dentry->d_inode,
@@ -2806,15 +2750,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-				     oldnd.path.mnt, new_dentry,
-				     newnd.path.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.path.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry, oldnd.path.mnt,
@@ -2839,10 +2778,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/suse-11.0/linux-2.6.25.20-0.1/fs/open.c after/distro/suse-11.0/linux-2.6.25.20-0.1/fs/open.c
--- before/distro/suse-11.0/linux-2.6.25.20-0.1/fs/open.c	2009-03-19 11:25:05.000000000 +0900
+++ after/distro/suse-11.0/linux-2.6.25.20-0.1/fs/open.c	2009-03-19 23:22:59.000000000 +0900
@@ -274,8 +274,8 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.path.dentry,
-				     nd.path.mnt);
+	error = ccs_check_truncate_permission(nd.path.dentry, nd.path.mnt,
+					      length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -334,7 +334,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/suse-11.0/linux-2.6.25.20-0.1/net/unix/af_unix.c after/distro/suse-11.0/linux-2.6.25.20-0.1/net/unix/af_unix.c
--- before/distro/suse-11.0/linux-2.6.25.20-0.1/net/unix/af_unix.c	2009-03-19 11:25:05.000000000 +0900
+++ after/distro/suse-11.0/linux-2.6.25.20-0.1/net/unix/af_unix.c	2009-03-19 22:51:17.000000000 +0900
@@ -779,11 +779,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -828,10 +823,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.path.mnt);
+		err = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						 dentry, nd.path.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.path.dentry->d_inode, dentry, nd.path.mnt,
diff -upr before/distro/suse-11.1/linux-2.6.27.19-3.2.1/fs/namei.c after/distro/suse-11.1/linux-2.6.27.19-3.2.1/fs/namei.c
--- before/distro/suse-11.1/linux-2.6.27.19-3.2.1/fs/namei.c	2009-03-19 11:25:05.000000000 +0900
+++ after/distro/suse-11.1/linux-2.6.27.19-3.2.1/fs/namei.c	2009-03-20 01:55:07.000000000 +0900
@@ -1562,14 +1562,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, nd ? nd->path.mnt : NULL, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1677,6 +1669,11 @@ static int __open_namei_create(struct na
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->path.dentry);
@@ -2041,16 +2038,6 @@ int vfs_mknod(struct inode *dir, struct 
 
 static int may_mknod(mode_t mode)
 {
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 	case S_IFREG:
 	case S_IFCHR:
@@ -2094,39 +2081,21 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const
 	error = mnt_want_write(nd.path.mnt);
 	if (error)
 		goto out_dput;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode,
+					   new_decode_dev(dev));
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode, dentry,
 					  nd.path.mnt, mode, new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode, dentry,
 					  nd.path.mnt, mode, 0);
 			break;
@@ -2192,10 +2161,8 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, nd.path.mnt, mode);
@@ -2307,10 +2274,8 @@ static long do_rmdir(int dfd, const char
 	if (error)
 		goto exit3;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry, nd.path.mnt);
@@ -2374,10 +2339,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(dfd, pathname, &nd, &name);
 	if (error)
@@ -2400,10 +2361,8 @@ static long do_unlinkat(int dfd, const c
 		if (error)
 			goto exit2;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-						     nd.path.mnt);
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry, nd.path.mnt);
@@ -2471,10 +2430,6 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	char *to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if (IS_ERR(from))
@@ -2493,10 +2448,8 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_symlink_permission(nd.path.dentry->d_inode, dentry,
+					     nd.path.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.path.dentry->d_inode, dentry, nd.path.mnt, from);
@@ -2576,10 +2529,6 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_at(olddfd, oldname,
 			     flags & AT_SYMLINK_FOLLOW ? LOOKUP_FOLLOW : 0,
@@ -2601,12 +2550,9 @@ SYSCALL_DEFINE5(linkat, int, olddfd, con
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_path.dentry, nd.path.dentry->d_inode,
-			     new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_path.dentry,
-					     old_path.mnt, new_dentry,
-					     nd.path.mnt);
+	error = ccs_check_link_permission(old_path.dentry,
+					  nd.path.dentry->d_inode, new_dentry,
+					  nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_path.dentry, old_path.mnt,
@@ -2794,10 +2740,6 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	char *from;
 	char *to;
 	int error;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(olddfd, oldname, &oldnd, &from);
 	if (error)
@@ -2850,21 +2792,16 @@ SYSCALL_DEFINE4(renameat, int, olddfd, c
 	error = -ENOTEMPTY;
 	if (new_dentry == trap)
 		goto exit5;
-	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-				     oldnd.path.mnt, new_dentry,
-				     newnd.path.mnt);
-	if (error)
-		goto exit5;
-	/***** TOMOYO Linux end. *****/
 
 	error = mnt_want_write(oldnd.path.mnt);
 	if (error)
 		goto exit5;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.path.mnt);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_rename(old_dir->d_inode, old_dentry, oldnd.path.mnt,
 			   new_dir->d_inode, new_dentry, newnd.path.mnt);
 	mnt_drop_write(oldnd.path.mnt);
diff -upr before/distro/suse-11.1/linux-2.6.27.19-3.2.1/fs/open.c after/distro/suse-11.1/linux-2.6.27.19-3.2.1/fs/open.c
--- before/distro/suse-11.1/linux-2.6.27.19-3.2.1/fs/open.c	2009-03-19 11:25:05.000000000 +0900
+++ after/distro/suse-11.1/linux-2.6.27.19-3.2.1/fs/open.c	2009-03-19 23:22:53.000000000 +0900
@@ -276,7 +276,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, path.dentry, path.mnt);
+	error = ccs_check_truncate_permission(path.dentry, path.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -337,7 +337,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/suse-11.1/linux-2.6.27.19-3.2.1/net/unix/af_unix.c after/distro/suse-11.1/linux-2.6.27.19-3.2.1/net/unix/af_unix.c
--- before/distro/suse-11.1/linux-2.6.27.19-3.2.1/net/unix/af_unix.c	2009-03-19 11:25:05.000000000 +0900
+++ after/distro/suse-11.1/linux-2.6.27.19-3.2.1/net/unix/af_unix.c	2009-03-19 22:51:05.000000000 +0900
@@ -784,11 +784,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -836,10 +831,8 @@ static int unix_bind(struct socket *sock
 		if (err)
 			goto out_mknod_dput;
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.path.mnt);
+		err = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						 dentry, nd.path.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.path.dentry->d_inode, dentry, nd.path.mnt,
diff -upr before/distro/turbolinux-11/linux-2.6.23-7/fs/namei.c after/distro/turbolinux-11/linux-2.6.23-7/fs/namei.c
--- before/distro/turbolinux-11/linux-2.6.23-7/fs/namei.c	2009-03-19 11:25:06.000000000 +0900
+++ after/distro/turbolinux-11/linux-2.6.23-7/fs/namei.c	2009-03-20 01:19:44.000000000 +0900
@@ -1562,13 +1562,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1670,6 +1663,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1943,16 +1941,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1966,37 +1954,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2065,9 +2037,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2178,9 +2149,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2242,10 +2211,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2268,12 +2233,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2339,10 +2301,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2361,9 +2319,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2438,10 +2395,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2466,10 +2419,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2698,14 +2649,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2730,10 +2677,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/turbolinux-11/linux-2.6.23-7/fs/open.c after/distro/turbolinux-11/linux-2.6.23-7/fs/open.c
--- before/distro/turbolinux-11/linux-2.6.23-7/fs/open.c	2009-03-19 11:25:06.000000000 +0900
+++ after/distro/turbolinux-11/linux-2.6.23-7/fs/open.c	2009-03-19 23:22:38.000000000 +0900
@@ -275,7 +275,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -334,7 +334,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/turbolinux-11/linux-2.6.23-7/net/unix/af_unix.c after/distro/turbolinux-11/linux-2.6.23-7/net/unix/af_unix.c
--- before/distro/turbolinux-11/linux-2.6.23-7/net/unix/af_unix.c	2009-03-19 11:25:06.000000000 +0900
+++ after/distro/turbolinux-11/linux-2.6.23-7/net/unix/af_unix.c	2009-03-19 22:43:05.000000000 +0900
@@ -794,11 +794,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -843,10 +838,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/ubuntu-6.06/linux-2.6.15-53.75/fs/namei.c after/distro/ubuntu-6.06/linux-2.6.15-53.75/fs/namei.c
--- before/distro/ubuntu-6.06/linux-2.6.15-53.75/fs/namei.c	2009-03-19 11:25:06.000000000 +0900
+++ after/distro/ubuntu-6.06/linux-2.6.15-53.75/fs/namei.c	2009-03-20 01:42:45.000000000 +0900
@@ -1437,13 +1437,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1615,6 +1608,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
@@ -1789,16 +1787,6 @@ asmlinkage long sys_mknod(const char __u
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1812,37 +1800,21 @@ asmlinkage long sys_mknod(const char __u
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1903,10 +1875,9 @@ asmlinkage long sys_mkdir(const char __u
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2013,10 +1984,8 @@ asmlinkage long sys_rmdir(const char __u
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2073,10 +2042,6 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2099,12 +2064,9 @@ asmlinkage long sys_unlink(const char __
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2151,10 +2113,6 @@ asmlinkage long sys_symlink(const char _
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2172,10 +2130,9 @@ asmlinkage long sys_symlink(const char _
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2243,10 +2200,6 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -2265,12 +2218,9 @@ asmlinkage long sys_link(const char __us
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2494,14 +2444,10 @@ static inline int do_rename(const char *
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2525,10 +2471,6 @@ asmlinkage long sys_rename(const char __
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/ubuntu-6.06/linux-2.6.15-53.75/fs/open.c after/distro/ubuntu-6.06/linux-2.6.15-53.75/fs/open.c
--- before/distro/ubuntu-6.06/linux-2.6.15-53.75/fs/open.c	2009-03-19 11:25:06.000000000 +0900
+++ after/distro/ubuntu-6.06/linux-2.6.15-53.75/fs/open.c	2009-03-19 23:22:29.000000000 +0900
@@ -293,7 +293,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -349,7 +349,8 @@ static inline long do_sys_ftruncate(unsi
 	if (IS_APPEND(inode))
 		goto out_putf;
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/ubuntu-6.06/linux-2.6.15-53.75/net/unix/af_unix.c after/distro/ubuntu-6.06/linux-2.6.15-53.75/net/unix/af_unix.c
--- before/distro/ubuntu-6.06/linux-2.6.15-53.75/net/unix/af_unix.c	2009-03-19 11:25:06.000000000 +0900
+++ after/distro/ubuntu-6.06/linux-2.6.15-53.75/net/unix/af_unix.c	2009-03-19 22:42:51.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/ubuntu-6.10/linux-2.6.17.1-12.44/fs/namei.c after/distro/ubuntu-6.10/linux-2.6.17.1-12.44/fs/namei.c
--- before/distro/ubuntu-6.10/linux-2.6.17.1-12.44/fs/namei.c	2009-03-19 11:25:06.000000000 +0900
+++ after/distro/ubuntu-6.10/linux-2.6.17.1-12.44/fs/namei.c	2009-03-20 01:42:54.000000000 +0900
@@ -1478,13 +1478,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1664,6 +1657,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1845,16 +1843,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1868,37 +1856,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1964,10 +1936,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2079,10 +2050,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2144,10 +2113,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2170,12 +2135,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2239,10 +2201,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2260,10 +2218,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2338,10 +2295,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if (flags != 0)
 		return -EINVAL;
@@ -2363,12 +2316,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2598,14 +2548,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2630,10 +2576,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/ubuntu-6.10/linux-2.6.17.1-12.44/fs/open.c after/distro/ubuntu-6.10/linux-2.6.17.1-12.44/fs/open.c
--- before/distro/ubuntu-6.10/linux-2.6.17.1-12.44/fs/open.c	2009-03-19 11:25:06.000000000 +0900
+++ after/distro/ubuntu-6.10/linux-2.6.17.1-12.44/fs/open.c	2009-03-19 23:22:22.000000000 +0900
@@ -275,7 +275,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -331,7 +331,8 @@ static long do_sys_ftruncate(unsigned in
 	if (IS_APPEND(inode))
 		goto out_putf;
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/ubuntu-6.10/linux-2.6.17.1-12.44/net/unix/af_unix.c after/distro/ubuntu-6.10/linux-2.6.17.1-12.44/net/unix/af_unix.c
--- before/distro/ubuntu-6.10/linux-2.6.17.1-12.44/net/unix/af_unix.c	2009-03-19 11:25:06.000000000 +0900
+++ after/distro/ubuntu-6.10/linux-2.6.17.1-12.44/net/unix/af_unix.c	2009-03-19 22:42:39.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/ubuntu-7.04/linux-2.6.20-17.39/fs/namei.c after/distro/ubuntu-7.04/linux-2.6.20-17.39/fs/namei.c
--- before/distro/ubuntu-7.04/linux-2.6.20-17.39/fs/namei.c	2009-03-19 11:25:23.000000000 +0900
+++ after/distro/ubuntu-7.04/linux-2.6.20-17.39/fs/namei.c	2009-03-20 01:19:32.000000000 +0900
@@ -1525,13 +1525,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1633,6 +1626,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1906,16 +1904,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1929,37 +1917,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2028,9 +2000,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2141,9 +2112,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2205,10 +2174,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2231,12 +2196,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2302,10 +2264,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2324,9 +2282,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2401,10 +2358,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2429,10 +2382,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2661,14 +2612,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2693,10 +2640,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/ubuntu-7.04/linux-2.6.20-17.39/fs/open.c after/distro/ubuntu-7.04/linux-2.6.20-17.39/fs/open.c
--- before/distro/ubuntu-7.04/linux-2.6.20-17.39/fs/open.c	2009-03-19 11:25:23.000000000 +0900
+++ after/distro/ubuntu-7.04/linux-2.6.20-17.39/fs/open.c	2009-03-19 23:22:15.000000000 +0900
@@ -271,7 +271,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -328,7 +328,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/ubuntu-7.04/linux-2.6.20-17.39/net/unix/af_unix.c after/distro/ubuntu-7.04/linux-2.6.20-17.39/net/unix/af_unix.c
--- before/distro/ubuntu-7.04/linux-2.6.20-17.39/net/unix/af_unix.c	2009-03-19 11:25:23.000000000 +0900
+++ after/distro/ubuntu-7.04/linux-2.6.20-17.39/net/unix/af_unix.c	2009-03-19 22:42:28.000000000 +0900
@@ -768,11 +768,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -817,10 +812,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/distro/ubuntu-7.10/linux-2.6.22-16.61/fs/namei.c after/distro/ubuntu-7.10/linux-2.6.22-16.61/fs/namei.c
--- before/distro/ubuntu-7.10/linux-2.6.22-16.61/fs/namei.c	2009-03-19 11:25:24.000000000 +0900
+++ after/distro/ubuntu-7.10/linux-2.6.22-16.61/fs/namei.c	2009-03-20 01:19:11.000000000 +0900
@@ -1559,13 +1559,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, nd ? nd->mnt : NULL, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1668,6 +1661,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1942,16 +1940,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1965,37 +1953,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
 					  mode, new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
 					  mode, 0);
 			break;
@@ -2066,9 +2038,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, nd.mnt, mode);
@@ -2180,9 +2151,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry, nd.mnt);
@@ -2244,10 +2213,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2270,12 +2235,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry, nd.mnt);
 	exit2:
@@ -2342,10 +2304,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2364,9 +2322,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, nd.mnt, from,
@@ -2443,10 +2400,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2471,10 +2424,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, old_nd.mnt, nd.dentry->d_inode,
@@ -2711,14 +2662,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry, oldnd.mnt,
@@ -2743,10 +2690,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/ubuntu-7.10/linux-2.6.22-16.61/fs/open.c after/distro/ubuntu-7.10/linux-2.6.22-16.61/fs/open.c
--- before/distro/ubuntu-7.10/linux-2.6.22-16.61/fs/open.c	2009-03-19 11:25:24.000000000 +0900
+++ after/distro/ubuntu-7.10/linux-2.6.22-16.61/fs/open.c	2009-03-19 23:22:04.000000000 +0900
@@ -273,7 +273,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -330,7 +330,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/ubuntu-7.10/linux-2.6.22-16.61/net/unix/af_unix.c after/distro/ubuntu-7.10/linux-2.6.22-16.61/net/unix/af_unix.c
--- before/distro/ubuntu-7.10/linux-2.6.22-16.61/net/unix/af_unix.c	2009-03-19 11:25:24.000000000 +0900
+++ after/distro/ubuntu-7.10/linux-2.6.22-16.61/net/unix/af_unix.c	2009-03-19 22:42:16.000000000 +0900
@@ -767,11 +767,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -816,10 +811,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt, mode, 0);
diff -upr before/distro/ubuntu-8.04/linux-2.6.24-23.48/fs/namei.c after/distro/ubuntu-8.04/linux-2.6.24-23.48/fs/namei.c
--- before/distro/ubuntu-8.04/linux-2.6.24-23.48/fs/namei.c	2009-03-19 11:25:24.000000000 +0900
+++ after/distro/ubuntu-8.04/linux-2.6.24-23.48/fs/namei.c	2009-03-20 01:14:18.000000000 +0900
@@ -1611,13 +1611,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, nd ? nd->mnt : NULL, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1721,6 +1714,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1995,16 +1993,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -2018,37 +2006,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
 					  mode, new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt,
 					  mode, 0);
 			break;
@@ -2119,9 +2091,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, nd.mnt, mode);
@@ -2233,9 +2204,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry, nd.mnt);
@@ -2297,10 +2266,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2323,12 +2288,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry, nd.mnt);
 	exit2:
@@ -2395,10 +2357,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2417,9 +2375,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, nd.mnt, from,
@@ -2496,10 +2453,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2524,10 +2477,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, old_nd.mnt, nd.dentry->d_inode,
@@ -2764,14 +2715,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry, oldnd.mnt,
@@ -2796,10 +2743,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/ubuntu-8.04/linux-2.6.24-23.48/fs/open.c after/distro/ubuntu-8.04/linux-2.6.24-23.48/fs/open.c
--- before/distro/ubuntu-8.04/linux-2.6.24-23.48/fs/open.c	2009-03-19 11:25:24.000000000 +0900
+++ after/distro/ubuntu-8.04/linux-2.6.24-23.48/fs/open.c	2009-03-19 23:21:48.000000000 +0900
@@ -274,7 +274,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -333,7 +333,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/ubuntu-8.04/linux-2.6.24-23.48/net/unix/af_unix.c after/distro/ubuntu-8.04/linux-2.6.24-23.48/net/unix/af_unix.c
--- before/distro/ubuntu-8.04/linux-2.6.24-23.48/net/unix/af_unix.c	2009-03-19 11:25:24.000000000 +0900
+++ after/distro/ubuntu-8.04/linux-2.6.24-23.48/net/unix/af_unix.c	2009-03-19 22:42:05.000000000 +0900
@@ -799,11 +799,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -848,10 +843,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, nd.mnt, mode, 0);
diff -upr before/distro/ubuntu-8.10/linux-2.6.27-11.27/fs/namei.c after/distro/ubuntu-8.10/linux-2.6.27-11.27/fs/namei.c
--- before/distro/ubuntu-8.10/linux-2.6.27-11.27/fs/namei.c	2009-03-19 11:25:24.000000000 +0900
+++ after/distro/ubuntu-8.10/linux-2.6.27-11.27/fs/namei.c	2009-03-20 01:53:07.000000000 +0900
@@ -1531,14 +1531,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, nd ? nd->path.mnt : NULL, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1646,6 +1638,11 @@ static int __open_namei_create(struct na
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->path.dentry);
@@ -2010,16 +2007,6 @@ int vfs_mknod(struct inode *dir, struct 
 
 static int may_mknod(mode_t mode)
 {
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 	case S_IFREG:
 	case S_IFCHR:
@@ -2063,39 +2050,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	error = mnt_want_write(nd.path.mnt);
 	if (error)
 		goto out_dput;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode,
+					   new_decode_dev(dev));
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode, dentry,
 					  nd.path.mnt, mode, new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode, dentry,
 					  nd.path.mnt, mode, 0);
 			break;
@@ -2161,10 +2130,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, nd.path.mnt, mode);
@@ -2276,10 +2243,8 @@ static long do_rmdir(int dfd, const char
 	if (error)
 		goto exit3;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry, nd.path.mnt);
@@ -2343,10 +2308,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(dfd, pathname, &nd, &name);
 	if (error)
@@ -2369,10 +2330,8 @@ static long do_unlinkat(int dfd, const c
 		if (error)
 			goto exit2;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-						     nd.path.mnt);
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry, nd.path.mnt);
@@ -2440,10 +2399,6 @@ asmlinkage long sys_symlinkat(const char
 	char *to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if (IS_ERR(from))
@@ -2462,10 +2417,8 @@ asmlinkage long sys_symlinkat(const char
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_symlink_permission(nd.path.dentry->d_inode, dentry,
+					     nd.path.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.path.dentry->d_inode, dentry, nd.path.mnt, from);
@@ -2546,10 +2499,6 @@ asmlinkage long sys_linkat(int olddfd, c
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_at(olddfd, oldname,
 			     flags & AT_SYMLINK_FOLLOW ? LOOKUP_FOLLOW : 0,
@@ -2571,12 +2520,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_path.dentry, nd.path.dentry->d_inode,
-			     new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_path.dentry,
-					     old_path.mnt, new_dentry,
-					     nd.path.mnt);
+	error = ccs_check_link_permission(old_path.dentry,
+					  nd.path.dentry->d_inode, new_dentry,
+					  nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_path.dentry, old_path.mnt,
@@ -2764,10 +2710,6 @@ asmlinkage long sys_renameat(int olddfd,
 	char *from;
 	char *to;
 	int error;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(olddfd, oldname, &oldnd, &from);
 	if (error)
@@ -2820,21 +2762,16 @@ asmlinkage long sys_renameat(int olddfd,
 	error = -ENOTEMPTY;
 	if (new_dentry == trap)
 		goto exit5;
-	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-				     oldnd.path.mnt, new_dentry,
-				     newnd.path.mnt);
-	if (error)
-		goto exit5;
-	/***** TOMOYO Linux end. *****/
 
 	error = mnt_want_write(oldnd.path.mnt);
 	if (error)
 		goto exit5;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.path.mnt);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_rename(old_dir->d_inode, old_dentry, oldnd.path.mnt,
 			   new_dir->d_inode, new_dentry, newnd.path.mnt);
 	mnt_drop_write(oldnd.path.mnt);
diff -upr before/distro/ubuntu-8.10/linux-2.6.27-11.27/fs/open.c after/distro/ubuntu-8.10/linux-2.6.27-11.27/fs/open.c
--- before/distro/ubuntu-8.10/linux-2.6.27-11.27/fs/open.c	2009-03-19 11:25:24.000000000 +0900
+++ after/distro/ubuntu-8.10/linux-2.6.27-11.27/fs/open.c	2009-03-19 23:21:36.000000000 +0900
@@ -277,7 +277,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, path.dentry, path.mnt);
+	error = ccs_check_truncate_permission(path.dentry, path.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -338,7 +338,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/ubuntu-8.10/linux-2.6.27-11.27/net/unix/af_unix.c after/distro/ubuntu-8.10/linux-2.6.27-11.27/net/unix/af_unix.c
--- before/distro/ubuntu-8.10/linux-2.6.27-11.27/net/unix/af_unix.c	2009-03-19 11:25:24.000000000 +0900
+++ after/distro/ubuntu-8.10/linux-2.6.27-11.27/net/unix/af_unix.c	2009-03-19 22:50:40.000000000 +0900
@@ -784,11 +784,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -836,10 +831,8 @@ static int unix_bind(struct socket *sock
 		if (err)
 			goto out_mknod_dput;
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.path.mnt);
+		err = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						 dentry, nd.path.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.path.dentry->d_inode, dentry, nd.path.mnt,
diff -upr before/distro/ubuntu-9.04/linux-2.6.28-9.30/fs/namei.c after/distro/ubuntu-9.04/linux-2.6.28-9.30/fs/namei.c
--- before/distro/ubuntu-9.04/linux-2.6.28-9.30/fs/namei.c	2009-03-19 11:25:24.000000000 +0900
+++ after/distro/ubuntu-9.04/linux-2.6.28-9.30/fs/namei.c	2009-03-20 01:51:54.000000000 +0900
@@ -1500,14 +1500,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, nd ? nd->path.mnt : NULL, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1615,6 +1607,11 @@ static int __open_namei_create(struct na
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->path.dentry);
@@ -1989,16 +1986,6 @@ int vfs_mknod(struct inode *dir, struct 
 
 static int may_mknod(mode_t mode)
 {
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 	case S_IFREG:
 	case S_IFCHR:
@@ -2042,39 +2029,21 @@ SYSCALL_DEFINE4(mknodat, int, dfd, const
 	error = mnt_want_write(nd.path.mnt);
 	if (error)
 		goto out_dput;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode,
+					   new_decode_dev(dev));
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode, dentry,
 					  nd.path.mnt, mode, new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode, dentry,
 					  nd.path.mnt, mode, 0);
 			break;
@@ -2140,10 +2109,8 @@ SYSCALL_DEFINE3(mkdirat, int, dfd, const
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, nd.path.mnt, mode);
@@ -2258,10 +2225,8 @@ static long do_rmdir(int dfd, const char
 	if (error)
 		goto exit3;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry, nd.path.mnt);
@@ -2325,10 +2290,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	error = user_path_parent(dfd, pathname, &nd, &name);
 	if (error)
@@ -2354,10 +2315,8 @@ static long do_unlinkat(int dfd, const c
 		if (error)
 			goto exit2;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-						     nd.path.mnt);
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry, nd.path.mnt);
@@ -2425,10 +2384,6 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	char *to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if (IS_ERR(from))
@@ -2447,10 +2402,8 @@ SYSCALL_DEFINE3(symlinkat, const char __
 	if (error)
diff -upr before/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/fs/namei.c after/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/fs/namei.c
--- before/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/fs/namei.c	2009-03-19 11:25:25.000000000 +0900
+++ after/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/fs/namei.c	2009-03-20 01:43:02.000000000 +0900
@@ -1488,13 +1488,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1674,6 +1667,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1855,16 +1853,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1878,37 +1866,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1974,10 +1946,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2089,10 +2060,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2154,10 +2123,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2180,12 +2145,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2249,10 +2211,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2270,10 +2228,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2348,10 +2305,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if (flags != 0)
 		return -EINVAL;
@@ -2373,12 +2326,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2608,14 +2558,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2640,10 +2586,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/fs/open.c after/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/fs/open.c
--- before/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/fs/open.c	2009-03-19 11:25:25.000000000 +0900
+++ after/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/fs/open.c	2009-03-19 23:21:19.000000000 +0900
@@ -277,7 +277,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -333,7 +333,8 @@ static long do_sys_ftruncate(unsigned in
 	if (IS_APPEND(inode))
 		goto out_putf;
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/net/unix/af_unix.c after/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/net/unix/af_unix.c
--- before/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/net/unix/af_unix.c	2009-03-19 11:25:25.000000000 +0900
+++ after/distro/vine-linux-4.2/linux-2.6.16-76.40vl4/net/unix/af_unix.c	2009-03-19 22:40:43.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.4.30/fs/namei.c after/vanilla/linux-2.4.30/fs/namei.c
--- before/vanilla/linux-2.4.30/fs/namei.c	2009-03-19 11:24:19.000000000 +0900
+++ after/vanilla/linux-2.4.30/fs/namei.c	2009-03-20 02:30:04.000000000 +0900
@@ -1062,10 +1062,10 @@ do_last:
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt,
+						   mode & ~current->fs->umask,
+						   0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry,
@@ -1299,16 +1299,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1322,35 +1312,16 @@ asmlinkage long sys_mknod(const char * f
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1413,10 +1384,9 @@ asmlinkage long sys_mkdir(const char * p
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1529,10 +1499,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1579,10 +1547,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1602,12 +1566,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1657,10 +1618,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1678,10 +1635,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1749,10 +1705,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1773,14 +1725,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2014,18 +1961,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2033,6 +1973,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2051,10 +1994,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.4.30/fs/open.c after/vanilla/linux-2.4.30/fs/open.c
--- before/vanilla/linux-2.4.30/fs/open.c	2009-03-19 11:24:19.000000000 +0900
+++ after/vanilla/linux-2.4.30/fs/open.c	2009-03-19 23:27:39.000000000 +0900
@@ -170,7 +170,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -228,7 +228,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.4.30/net/unix/af_unix.c after/vanilla/linux-2.4.30/net/unix/af_unix.c
--- before/vanilla/linux-2.4.30/net/unix/af_unix.c	2009-03-19 11:24:19.000000000 +0900
+++ after/vanilla/linux-2.4.30/net/unix/af_unix.c	2009-03-19 22:40:20.000000000 +0900
@@ -648,11 +648,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -718,10 +713,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.4.31/fs/namei.c after/vanilla/linux-2.4.31/fs/namei.c
--- before/vanilla/linux-2.4.31/fs/namei.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.31/fs/namei.c	2009-03-20 02:29:30.000000000 +0900
@@ -1062,10 +1062,10 @@ do_last:
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt,
+						   mode & ~current->fs->umask,
+						   0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry,
@@ -1299,16 +1299,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1322,35 +1312,16 @@ asmlinkage long sys_mknod(const char * f
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1413,10 +1384,9 @@ asmlinkage long sys_mkdir(const char * p
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1529,10 +1499,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1579,10 +1547,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1602,12 +1566,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1657,10 +1618,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1678,10 +1635,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1749,10 +1705,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1773,14 +1725,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2014,18 +1961,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2033,6 +1973,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2051,10 +1994,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.4.31/fs/open.c after/vanilla/linux-2.4.31/fs/open.c
--- before/vanilla/linux-2.4.31/fs/open.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.31/fs/open.c	2009-03-19 23:27:33.000000000 +0900
@@ -170,7 +170,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -228,7 +228,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.4.31/net/unix/af_unix.c after/vanilla/linux-2.4.31/net/unix/af_unix.c
--- before/vanilla/linux-2.4.31/net/unix/af_unix.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.31/net/unix/af_unix.c	2009-03-19 22:40:10.000000000 +0900
@@ -648,11 +648,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -718,10 +713,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.4.32/fs/namei.c after/vanilla/linux-2.4.32/fs/namei.c
--- before/vanilla/linux-2.4.32/fs/namei.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.32/fs/namei.c	2009-03-20 02:29:04.000000000 +0900
@@ -1062,10 +1062,10 @@ do_last:
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt,
+						   mode & ~current->fs->umask,
+						   0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry,
@@ -1299,16 +1299,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1322,35 +1312,16 @@ asmlinkage long sys_mknod(const char * f
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1413,10 +1384,9 @@ asmlinkage long sys_mkdir(const char * p
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1529,10 +1499,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1579,10 +1547,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1602,12 +1566,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1657,10 +1618,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1678,10 +1635,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1749,10 +1705,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1773,14 +1725,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2014,18 +1961,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2033,6 +1973,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2051,10 +1994,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.4.32/fs/open.c after/vanilla/linux-2.4.32/fs/open.c
--- before/vanilla/linux-2.4.32/fs/open.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.32/fs/open.c	2009-03-19 23:27:29.000000000 +0900
@@ -170,7 +170,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -228,7 +228,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.4.32/net/unix/af_unix.c after/vanilla/linux-2.4.32/net/unix/af_unix.c
--- before/vanilla/linux-2.4.32/net/unix/af_unix.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.32/net/unix/af_unix.c	2009-03-19 22:39:48.000000000 +0900
@@ -648,11 +648,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -718,10 +713,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.4.33.7/fs/namei.c after/vanilla/linux-2.4.33.7/fs/namei.c
--- before/vanilla/linux-2.4.33.7/fs/namei.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.33.7/fs/namei.c	2009-03-20 02:28:39.000000000 +0900
@@ -1062,10 +1062,10 @@ do_last:
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt,
+						   mode & ~current->fs->umask,
+						   0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry,
@@ -1299,16 +1299,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1322,35 +1312,16 @@ asmlinkage long sys_mknod(const char * f
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1413,10 +1384,9 @@ asmlinkage long sys_mkdir(const char * p
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1529,10 +1499,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1586,10 +1554,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1609,12 +1573,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1664,10 +1625,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1685,10 +1642,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1758,10 +1714,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1782,14 +1734,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2023,18 +1970,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2042,6 +1982,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2060,10 +2003,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.4.33.7/fs/open.c after/vanilla/linux-2.4.33.7/fs/open.c
--- before/vanilla/linux-2.4.33.7/fs/open.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.33.7/fs/open.c	2009-03-19 23:27:25.000000000 +0900
@@ -170,7 +170,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -228,7 +228,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.4.33.7/net/unix/af_unix.c after/vanilla/linux-2.4.33.7/net/unix/af_unix.c
--- before/vanilla/linux-2.4.33.7/net/unix/af_unix.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.33.7/net/unix/af_unix.c	2009-03-19 22:39:26.000000000 +0900
@@ -648,11 +648,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -718,10 +713,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.4.34.6/fs/namei.c after/vanilla/linux-2.4.34.6/fs/namei.c
--- before/vanilla/linux-2.4.34.6/fs/namei.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.34.6/fs/namei.c	2009-03-20 02:28:07.000000000 +0900
@@ -1062,10 +1062,10 @@ do_last:
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt,
+						   mode & ~current->fs->umask,
+						   0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry,
@@ -1299,16 +1299,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1322,35 +1312,16 @@ asmlinkage long sys_mknod(const char * f
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1413,10 +1384,9 @@ asmlinkage long sys_mkdir(const char * p
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1529,10 +1499,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1586,10 +1554,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1609,12 +1573,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1664,10 +1625,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1685,10 +1642,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1758,10 +1714,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1782,14 +1734,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2023,18 +1970,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2042,6 +1982,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2060,10 +2003,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.4.34.6/fs/open.c after/vanilla/linux-2.4.34.6/fs/open.c
--- before/vanilla/linux-2.4.34.6/fs/open.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.34.6/fs/open.c	2009-03-19 23:27:21.000000000 +0900
@@ -170,7 +170,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -228,7 +228,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.4.34.6/net/unix/af_unix.c after/vanilla/linux-2.4.34.6/net/unix/af_unix.c
--- before/vanilla/linux-2.4.34.6/net/unix/af_unix.c	2009-03-19 11:24:20.000000000 +0900
+++ after/vanilla/linux-2.4.34.6/net/unix/af_unix.c	2009-03-19 22:39:02.000000000 +0900
@@ -648,11 +648,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -718,10 +713,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.4.35.5/fs/namei.c after/vanilla/linux-2.4.35.5/fs/namei.c
--- before/vanilla/linux-2.4.35.5/fs/namei.c	2009-03-19 11:24:21.000000000 +0900
+++ after/vanilla/linux-2.4.35.5/fs/namei.c	2009-03-20 02:27:42.000000000 +0900
@@ -1062,10 +1062,10 @@ do_last:
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt,
+						   mode & ~current->fs->umask,
+						   0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry,
@@ -1299,16 +1299,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1322,35 +1312,16 @@ asmlinkage long sys_mknod(const char * f
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1413,10 +1384,9 @@ asmlinkage long sys_mkdir(const char * p
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1529,10 +1499,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1586,10 +1554,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1609,12 +1573,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1664,10 +1625,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1685,10 +1642,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1758,10 +1714,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1782,14 +1734,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2023,18 +1970,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2042,6 +1982,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2060,10 +2003,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.4.35.5/fs/open.c after/vanilla/linux-2.4.35.5/fs/open.c
--- before/vanilla/linux-2.4.35.5/fs/open.c	2009-03-19 11:24:21.000000000 +0900
+++ after/vanilla/linux-2.4.35.5/fs/open.c	2009-03-19 23:27:17.000000000 +0900
@@ -170,7 +170,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -228,7 +228,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.4.35.5/net/unix/af_unix.c after/vanilla/linux-2.4.35.5/net/unix/af_unix.c
--- before/vanilla/linux-2.4.35.5/net/unix/af_unix.c	2009-03-19 11:24:21.000000000 +0900
+++ after/vanilla/linux-2.4.35.5/net/unix/af_unix.c	2009-03-19 22:38:53.000000000 +0900
@@ -648,11 +648,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -718,10 +713,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.4.36.9/fs/namei.c after/vanilla/linux-2.4.36.9/fs/namei.c
--- before/vanilla/linux-2.4.36.9/fs/namei.c	2009-03-19 11:24:21.000000000 +0900
+++ after/vanilla/linux-2.4.36.9/fs/namei.c	2009-03-20 02:27:07.000000000 +0900
@@ -1077,10 +1077,10 @@ do_last:
 	/* Negative dentry, just create the file */
 	if (!dentry->d_inode) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_create(dir->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd->mnt);
+		error = ccs_check_mknod_permission(dir->d_inode, dentry,
+						   nd->mnt,
+						   mode & ~current->fs->umask,
+						   0);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry,
@@ -1314,16 +1314,6 @@ asmlinkage long sys_mknod(const char * f
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
@@ -1337,35 +1327,16 @@ asmlinkage long sys_mknod(const char * f
 
 	mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt, mode, dev);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_create(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-						     nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_create(nd.dentry->d_inode,dentry,mode);
 			break;
 		case S_IFCHR: case S_IFBLK: case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     S_ISBLK(mode) ?
-						     TYPE_MKBLOCK_ACL :
-						     S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,dev);
 			break;
 		case S_IFDIR:
@@ -1428,10 +1399,9 @@ asmlinkage long sys_mkdir(const char * p
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry,
@@ -1544,10 +1514,8 @@ asmlinkage long sys_rmdir(const char * p
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1601,10 +1569,6 @@ asmlinkage long sys_unlink(const char * 
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1624,12 +1588,9 @@ asmlinkage long sys_unlink(const char * 
 		if (nd.last.name[nd.last.len])
 			goto slashes;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1679,10 +1640,6 @@ asmlinkage long sys_symlink(const char *
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1700,10 +1657,9 @@ asmlinkage long sys_symlink(const char *
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from);
@@ -1773,10 +1729,6 @@ asmlinkage long sys_link(const char * ol
 {
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	error = PTR_ERR(to);
@@ -1797,14 +1749,9 @@ asmlinkage long sys_link(const char * ol
 		error = PTR_ERR(new_dentry);
 		if (!IS_ERR(new_dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-					     new_dentry);
-			if (!error)
-				error = ccs_check_2path_perm(TYPE_LINK_ACL,
-							     old_nd.dentry,
-							     old_nd.mnt,
-							     new_dentry,
-							     nd.mnt);
+			error = ccs_check_link_permission(old_nd.dentry,
+							  nd.dentry->d_inode,
+							  new_dentry, nd.mnt);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2038,18 +1985,11 @@ static inline int do_rename(const char *
 	if (IS_ERR(new_dentry))
 		goto exit4;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error) {
-		dput(new_dentry);
-		goto exit4;
-	}
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (error)
+		goto exit5;
 	/***** TOMOYO Linux end. *****/
 
 	lock_kernel();
@@ -2057,6 +1997,9 @@ static inline int do_rename(const char *
 				   new_dir->d_inode, new_dentry);
 	unlock_kernel();
 
+	/***** TOMOYO Linux start. *****/
+exit5:
+	/***** TOMOYO Linux end. *****/
 	dput(new_dentry);
 exit4:
 	dput(old_dentry);
@@ -2075,10 +2018,6 @@ asmlinkage long sys_rename(const char * 
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.4.36.9/fs/open.c after/vanilla/linux-2.4.36.9/fs/open.c
--- before/vanilla/linux-2.4.36.9/fs/open.c	2009-03-19 11:24:21.000000000 +0900
+++ after/vanilla/linux-2.4.36.9/fs/open.c	2009-03-19 23:27:13.000000000 +0900
@@ -172,7 +172,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 
@@ -230,7 +230,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.4.36.9/net/unix/af_unix.c after/vanilla/linux-2.4.36.9/net/unix/af_unix.c
--- before/vanilla/linux-2.4.36.9/net/unix/af_unix.c	2009-03-19 11:24:21.000000000 +0900
+++ after/vanilla/linux-2.4.36.9/net/unix/af_unix.c	2009-03-19 22:38:43.000000000 +0900
@@ -648,11 +648,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -718,10 +713,8 @@ static int unix_bind(struct socket *sock
 		 */
 		mode = S_IFSOCK | (sock->inode->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.11.12/fs/namei.c after/vanilla/linux-2.6.11.12/fs/namei.c
--- before/vanilla/linux-2.6.11.12/fs/namei.c	2009-03-19 11:24:24.000000000 +0900
+++ after/vanilla/linux-2.6.11.12/fs/namei.c	2009-03-20 01:35:36.000000000 +0900
@@ -1253,13 +1253,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error) {
@@ -1432,6 +1425,11 @@ do_last:
 	if (!dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, dentry, mode, nd);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
@@ -1593,16 +1591,6 @@ asmlinkage long sys_mknod(const char __u
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1616,37 +1604,21 @@ asmlinkage long sys_mknod(const char __u
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1709,10 +1681,9 @@ asmlinkage long sys_mkdir(const char __u
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -1824,10 +1795,8 @@ asmlinkage long sys_rmdir(const char __u
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1884,10 +1853,6 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1910,12 +1875,9 @@ asmlinkage long sys_unlink(const char __
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -1964,10 +1926,6 @@ asmlinkage long sys_symlink(const char _
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -1985,10 +1943,9 @@ asmlinkage long sys_symlink(const char _
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2058,10 +2015,6 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -2080,12 +2033,9 @@ asmlinkage long sys_link(const char __us
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2311,14 +2261,10 @@ static inline int do_rename(const char *
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2342,10 +2288,6 @@ asmlinkage long sys_rename(const char __
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.11.12/fs/open.c after/vanilla/linux-2.6.11.12/fs/open.c
--- before/vanilla/linux-2.6.11.12/fs/open.c	2009-03-19 11:24:24.000000000 +0900
+++ after/vanilla/linux-2.6.11.12/fs/open.c	2009-03-19 23:27:02.000000000 +0900
@@ -265,7 +265,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -322,7 +322,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.11.12/net/unix/af_unix.c after/vanilla/linux-2.6.11.12/net/unix/af_unix.c
--- before/vanilla/linux-2.6.11.12/net/unix/af_unix.c	2009-03-19 11:24:24.000000000 +0900
+++ after/vanilla/linux-2.6.11.12/net/unix/af_unix.c	2009-03-19 22:38:18.000000000 +0900
@@ -733,11 +733,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -803,10 +798,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.12.6/fs/namei.c after/vanilla/linux-2.6.12.6/fs/namei.c
--- before/vanilla/linux-2.6.12.6/fs/namei.c	2009-03-19 11:24:24.000000000 +0900
+++ after/vanilla/linux-2.6.12.6/fs/namei.c	2009-03-20 01:34:42.000000000 +0900
@@ -1313,13 +1313,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error) {
@@ -1493,6 +1486,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
@@ -1657,16 +1655,6 @@ asmlinkage long sys_mknod(const char __u
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1680,37 +1668,21 @@ asmlinkage long sys_mknod(const char __u
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1773,10 +1745,9 @@ asmlinkage long sys_mkdir(const char __u
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -1884,10 +1855,8 @@ asmlinkage long sys_rmdir(const char __u
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1944,10 +1913,6 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1970,12 +1935,9 @@ asmlinkage long sys_unlink(const char __
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2024,10 +1986,6 @@ asmlinkage long sys_symlink(const char _
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2045,10 +2003,9 @@ asmlinkage long sys_symlink(const char _
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2118,10 +2075,6 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -2140,12 +2093,9 @@ asmlinkage long sys_link(const char __us
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2371,14 +2321,10 @@ static inline int do_rename(const char *
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2402,10 +2348,6 @@ asmlinkage long sys_rename(const char __
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.12.6/fs/open.c after/vanilla/linux-2.6.12.6/fs/open.c
--- before/vanilla/linux-2.6.12.6/fs/open.c	2009-03-19 11:24:24.000000000 +0900
+++ after/vanilla/linux-2.6.12.6/fs/open.c	2009-03-19 23:26:58.000000000 +0900
@@ -265,7 +265,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -322,7 +322,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.12.6/net/unix/af_unix.c after/vanilla/linux-2.6.12.6/net/unix/af_unix.c
--- before/vanilla/linux-2.6.12.6/net/unix/af_unix.c	2009-03-19 11:24:24.000000000 +0900
+++ after/vanilla/linux-2.6.12.6/net/unix/af_unix.c	2009-03-19 22:38:08.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.13.5/fs/namei.c after/vanilla/linux-2.6.13.5/fs/namei.c
--- before/vanilla/linux-2.6.13.5/fs/namei.c	2009-03-19 11:24:24.000000000 +0900
+++ after/vanilla/linux-2.6.13.5/fs/namei.c	2009-03-20 01:34:31.000000000 +0900
@@ -1316,13 +1316,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error) {
@@ -1496,6 +1489,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
@@ -1676,16 +1674,6 @@ asmlinkage long sys_mknod(const char __u
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1699,37 +1687,21 @@ asmlinkage long sys_mknod(const char __u
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1792,10 +1764,9 @@ asmlinkage long sys_mkdir(const char __u
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -1902,10 +1873,8 @@ asmlinkage long sys_rmdir(const char __u
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1962,10 +1931,6 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1988,12 +1953,9 @@ asmlinkage long sys_unlink(const char __
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2042,10 +2004,6 @@ asmlinkage long sys_symlink(const char _
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2063,10 +2021,9 @@ asmlinkage long sys_symlink(const char _
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2136,10 +2093,6 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -2158,12 +2111,9 @@ asmlinkage long sys_link(const char __us
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2391,14 +2341,10 @@ static inline int do_rename(const char *
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2422,10 +2368,6 @@ asmlinkage long sys_rename(const char __
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.13.5/fs/open.c after/vanilla/linux-2.6.13.5/fs/open.c
--- before/vanilla/linux-2.6.13.5/fs/open.c	2009-03-19 11:24:24.000000000 +0900
+++ after/vanilla/linux-2.6.13.5/fs/open.c	2009-03-19 23:26:54.000000000 +0900
@@ -266,7 +266,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -323,7 +323,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.13.5/net/unix/af_unix.c after/vanilla/linux-2.6.13.5/net/unix/af_unix.c
--- before/vanilla/linux-2.6.13.5/net/unix/af_unix.c	2009-03-19 11:24:25.000000000 +0900
+++ after/vanilla/linux-2.6.13.5/net/unix/af_unix.c	2009-03-19 22:37:55.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.14.7/fs/namei.c after/vanilla/linux-2.6.14.7/fs/namei.c
--- before/vanilla/linux-2.6.14.7/fs/namei.c	2009-03-19 11:24:25.000000000 +0900
+++ after/vanilla/linux-2.6.14.7/fs/namei.c	2009-03-20 01:34:19.000000000 +0900
@@ -1318,13 +1318,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1496,6 +1489,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
@@ -1668,16 +1666,6 @@ asmlinkage long sys_mknod(const char __u
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1691,37 +1679,21 @@ asmlinkage long sys_mknod(const char __u
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1782,10 +1754,9 @@ asmlinkage long sys_mkdir(const char __u
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -1892,10 +1863,8 @@ asmlinkage long sys_rmdir(const char __u
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -1952,10 +1921,6 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -1978,12 +1943,9 @@ asmlinkage long sys_unlink(const char __
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2030,10 +1992,6 @@ asmlinkage long sys_symlink(const char _
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2051,10 +2009,9 @@ asmlinkage long sys_symlink(const char _
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2122,10 +2079,6 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -2144,12 +2097,9 @@ asmlinkage long sys_link(const char __us
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2373,14 +2323,10 @@ static inline int do_rename(const char *
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2404,10 +2350,6 @@ asmlinkage long sys_rename(const char __
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.14.7/fs/open.c after/vanilla/linux-2.6.14.7/fs/open.c
--- before/vanilla/linux-2.6.14.7/fs/open.c	2009-03-19 11:24:25.000000000 +0900
+++ after/vanilla/linux-2.6.14.7/fs/open.c	2009-03-19 23:26:50.000000000 +0900
@@ -267,7 +267,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -324,7 +324,8 @@ static inline long do_sys_ftruncate(unsi
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.14.7/net/unix/af_unix.c after/vanilla/linux-2.6.14.7/net/unix/af_unix.c
--- before/vanilla/linux-2.6.14.7/net/unix/af_unix.c	2009-03-19 11:24:25.000000000 +0900
+++ after/vanilla/linux-2.6.14.7/net/unix/af_unix.c	2009-03-19 22:37:45.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.15.7/fs/namei.c after/vanilla/linux-2.6.15.7/fs/namei.c
--- before/vanilla/linux-2.6.15.7/fs/namei.c	2009-03-19 11:24:25.000000000 +0900
+++ after/vanilla/linux-2.6.15.7/fs/namei.c	2009-03-20 01:33:25.000000000 +0900
@@ -1421,13 +1421,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1599,6 +1592,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		up(&dir->d_inode->i_sem);
 		dput(nd->dentry);
@@ -1773,16 +1771,6 @@ asmlinkage long sys_mknod(const char __u
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1796,37 +1784,21 @@ asmlinkage long sys_mknod(const char __u
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1887,10 +1859,9 @@ asmlinkage long sys_mkdir(const char __u
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -1997,10 +1968,8 @@ asmlinkage long sys_rmdir(const char __u
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2057,10 +2026,6 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2083,12 +2048,9 @@ asmlinkage long sys_unlink(const char __
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2135,10 +2097,6 @@ asmlinkage long sys_symlink(const char _
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2156,10 +2114,9 @@ asmlinkage long sys_symlink(const char _
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2227,10 +2184,6 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	to = getname(newname);
 	if (IS_ERR(to))
@@ -2249,12 +2202,9 @@ asmlinkage long sys_link(const char __us
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2478,14 +2428,10 @@ static inline int do_rename(const char *
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2509,10 +2455,6 @@ asmlinkage long sys_rename(const char __
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.15.7/fs/open.c after/vanilla/linux-2.6.15.7/fs/open.c
--- before/vanilla/linux-2.6.15.7/fs/open.c	2009-03-19 11:24:25.000000000 +0900
+++ after/vanilla/linux-2.6.15.7/fs/open.c	2009-03-19 23:26:45.000000000 +0900
@@ -271,7 +271,7 @@ static inline long do_sys_truncate(const
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -327,7 +327,8 @@ static inline long do_sys_ftruncate(unsi
 	if (IS_APPEND(inode))
 		goto out_putf;
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.15.7/net/unix/af_unix.c after/vanilla/linux-2.6.15.7/net/unix/af_unix.c
--- before/vanilla/linux-2.6.15.7/net/unix/af_unix.c	2009-03-19 11:24:25.000000000 +0900
+++ after/vanilla/linux-2.6.15.7/net/unix/af_unix.c	2009-03-19 22:37:35.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.16.62/fs/namei.c after/vanilla/linux-2.6.16.62/fs/namei.c
--- before/vanilla/linux-2.6.16.62/fs/namei.c	2009-03-19 11:24:25.000000000 +0900
+++ after/vanilla/linux-2.6.16.62/fs/namei.c	2009-03-20 01:33:14.000000000 +0900
@@ -1474,13 +1474,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1660,6 +1653,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1841,16 +1839,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1864,37 +1852,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1960,10 +1932,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2075,10 +2046,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2140,10 +2109,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2166,12 +2131,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2235,10 +2197,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2256,10 +2214,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2334,10 +2291,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if (flags != 0)
 		return -EINVAL;
@@ -2359,12 +2312,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2594,14 +2544,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2626,10 +2572,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.16.62/fs/open.c after/vanilla/linux-2.6.16.62/fs/open.c
--- before/vanilla/linux-2.6.16.62/fs/open.c	2009-03-19 11:24:25.000000000 +0900
+++ after/vanilla/linux-2.6.16.62/fs/open.c	2009-03-19 23:26:41.000000000 +0900
@@ -274,7 +274,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -330,7 +330,8 @@ static long do_sys_ftruncate(unsigned in
 	if (IS_APPEND(inode))
 		goto out_putf;
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.16.62/net/unix/af_unix.c after/vanilla/linux-2.6.16.62/net/unix/af_unix.c
--- before/vanilla/linux-2.6.16.62/net/unix/af_unix.c	2009-03-19 11:24:25.000000000 +0900
+++ after/vanilla/linux-2.6.16.62/net/unix/af_unix.c	2009-03-19 22:37:23.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.17.14/fs/namei.c after/vanilla/linux-2.6.17.14/fs/namei.c
--- before/vanilla/linux-2.6.17.14/fs/namei.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.17.14/fs/namei.c	2009-03-20 01:32:13.000000000 +0900
@@ -1478,13 +1478,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1664,6 +1657,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1845,16 +1843,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1868,37 +1856,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1964,10 +1936,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2079,10 +2050,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2144,10 +2113,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2170,12 +2135,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2239,10 +2201,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2260,10 +2218,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2338,10 +2295,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if (flags != 0)
 		return -EINVAL;
@@ -2363,12 +2316,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2598,14 +2548,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2630,10 +2576,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.17.14/fs/open.c after/vanilla/linux-2.6.17.14/fs/open.c
--- before/vanilla/linux-2.6.17.14/fs/open.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.17.14/fs/open.c	2009-03-19 23:26:36.000000000 +0900
@@ -275,7 +275,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -331,7 +331,8 @@ static long do_sys_ftruncate(unsigned in
 	if (IS_APPEND(inode))
 		goto out_putf;
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.17.14/net/unix/af_unix.c after/vanilla/linux-2.6.17.14/net/unix/af_unix.c
--- before/vanilla/linux-2.6.17.14/net/unix/af_unix.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.17.14/net/unix/af_unix.c	2009-03-19 22:37:11.000000000 +0900
@@ -741,11 +741,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -790,10 +785,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.18.8/fs/namei.c after/vanilla/linux-2.6.18.8/fs/namei.c
--- before/vanilla/linux-2.6.18.8/fs/namei.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.18.8/fs/namei.c	2009-03-20 01:30:36.000000000 +0900
@@ -1485,13 +1485,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1671,6 +1664,11 @@ do_last:
 	if (!path.dentry->d_inode) {
 		if (!IS_POSIXACL(dir->d_inode))
 			mode &= ~current->fs->umask;
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(dir->d_inode, path.dentry,
+						   nd->path.mnt, mode, 0);
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		error = vfs_create(dir->d_inode, path.dentry, mode, nd);
 		mutex_unlock(&dir->d_inode->i_mutex);
 		dput(nd->dentry);
@@ -1856,16 +1854,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1879,37 +1867,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -1975,10 +1947,9 @@ asmlinkage long sys_mkdirat(int dfd, con
 			if (!IS_POSIXACL(nd.dentry->d_inode))
 				mode &= ~current->fs->umask;
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_MKDIR_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_mkdir_permission(nd.dentry->d_inode,
+							   dentry, nd.mnt,
+							   mode);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2090,10 +2061,8 @@ static long do_rmdir(int dfd, const char
 	error = PTR_ERR(dentry);
 	if (!IS_ERR(dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-						     nd.mnt);
+		error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry,
+						   nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2155,10 +2124,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2181,12 +2146,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2250,10 +2212,6 @@ asmlinkage long sys_symlinkat(const char
 	int error = 0;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2271,10 +2229,9 @@ asmlinkage long sys_symlinkat(const char
 		error = PTR_ERR(dentry);
 		if (!IS_ERR(dentry)) {
 			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-			if (!error)
-				error = ccs_check_1path_perm(TYPE_SYMLINK_ACL,
-							     dentry, nd.mnt);
+			error = ccs_check_symlink_permission(nd.dentry->d_inode,
+							     dentry, nd.mnt,
+							     from);
 			if (!error)
 			/***** TOMOYO Linux end. *****/
 			error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2349,10 +2306,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2376,12 +2329,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	error = PTR_ERR(new_dentry);
 	if (!IS_ERR(new_dentry)) {
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode,
-				     new_dentry);
-		if (!error)
-			error = ccs_check_2path_perm(TYPE_LINK_ACL,
-						     old_nd.dentry, old_nd.mnt,
-						     new_dentry, nd.mnt);
+		error = ccs_check_link_permission(old_nd.dentry,
+						  nd.dentry->d_inode,
+						  new_dentry, nd.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2611,14 +2561,10 @@ static int do_rename(int olddfd, const c
 		goto exit5;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2643,10 +2589,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.18.8/fs/open.c after/vanilla/linux-2.6.18.8/fs/open.c
--- before/vanilla/linux-2.6.18.8/fs/open.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.18.8/fs/open.c	2009-03-19 23:26:32.000000000 +0900
@@ -274,7 +274,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -331,7 +331,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.18.8/net/unix/af_unix.c after/vanilla/linux-2.6.18.8/net/unix/af_unix.c
--- before/vanilla/linux-2.6.18.8/net/unix/af_unix.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.18.8/net/unix/af_unix.c	2009-03-19 22:37:01.000000000 +0900
@@ -767,11 +767,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -816,10 +811,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.19.7/fs/namei.c after/vanilla/linux-2.6.19.7/fs/namei.c
--- before/vanilla/linux-2.6.19.7/fs/namei.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.19.7/fs/namei.c	2009-03-20 01:15:56.000000000 +0900
@@ -1513,13 +1513,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1621,6 +1614,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1894,16 +1892,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1917,37 +1905,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2016,9 +1988,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2130,9 +2101,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2194,10 +2163,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2220,12 +2185,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2291,10 +2253,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2313,9 +2271,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2390,10 +2347,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2418,10 +2371,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2650,14 +2601,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2682,10 +2629,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.19.7/fs/open.c after/vanilla/linux-2.6.19.7/fs/open.c
--- before/vanilla/linux-2.6.19.7/fs/open.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.19.7/fs/open.c	2009-03-19 23:26:28.000000000 +0900
@@ -271,7 +271,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -328,7 +328,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.19.7/net/unix/af_unix.c after/vanilla/linux-2.6.19.7/net/unix/af_unix.c
--- before/vanilla/linux-2.6.19.7/net/unix/af_unix.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.19.7/net/unix/af_unix.c	2009-03-19 22:36:50.000000000 +0900
@@ -767,11 +767,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -816,10 +811,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.20.21/fs/namei.c after/vanilla/linux-2.6.20.21/fs/namei.c
--- before/vanilla/linux-2.6.20.21/fs/namei.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.20.21/fs/namei.c	2009-03-20 01:15:46.000000000 +0900
@@ -1510,13 +1510,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1618,6 +1611,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1891,16 +1889,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1914,37 +1902,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2013,9 +1985,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2126,9 +2097,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2190,10 +2159,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2216,12 +2181,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2287,10 +2249,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2309,9 +2267,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2386,10 +2343,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2414,10 +2367,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2646,14 +2597,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2678,10 +2625,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.20.21/fs/open.c after/vanilla/linux-2.6.20.21/fs/open.c
--- before/vanilla/linux-2.6.20.21/fs/open.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.20.21/fs/open.c	2009-03-19 23:26:23.000000000 +0900
@@ -271,7 +271,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -328,7 +328,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.20.21/net/unix/af_unix.c after/vanilla/linux-2.6.20.21/net/unix/af_unix.c
--- before/vanilla/linux-2.6.20.21/net/unix/af_unix.c	2009-03-19 11:24:26.000000000 +0900
+++ after/vanilla/linux-2.6.20.21/net/unix/af_unix.c	2009-03-19 22:36:40.000000000 +0900
@@ -768,11 +768,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -817,10 +812,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.21.7/fs/namei.c after/vanilla/linux-2.6.21.7/fs/namei.c
--- before/vanilla/linux-2.6.21.7/fs/namei.c	2009-03-19 11:24:27.000000000 +0900
+++ after/vanilla/linux-2.6.21.7/fs/namei.c	2009-03-20 01:15:38.000000000 +0900
@@ -1510,13 +1510,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1618,6 +1611,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1891,16 +1889,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1914,37 +1902,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2013,9 +1985,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2126,9 +2097,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2190,10 +2159,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2216,12 +2181,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2287,10 +2249,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2309,9 +2267,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2386,10 +2343,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2414,10 +2367,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2646,14 +2597,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2678,10 +2625,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.21.7/fs/open.c after/vanilla/linux-2.6.21.7/fs/open.c
--- before/vanilla/linux-2.6.21.7/fs/open.c	2009-03-19 11:24:27.000000000 +0900
+++ after/vanilla/linux-2.6.21.7/fs/open.c	2009-03-19 23:26:19.000000000 +0900
@@ -271,7 +271,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -328,7 +328,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.21.7/net/unix/af_unix.c after/vanilla/linux-2.6.21.7/net/unix/af_unix.c
--- before/vanilla/linux-2.6.21.7/net/unix/af_unix.c	2009-03-19 11:24:27.000000000 +0900
+++ after/vanilla/linux-2.6.21.7/net/unix/af_unix.c	2009-03-19 22:36:29.000000000 +0900
@@ -768,11 +768,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -817,10 +812,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.22.19/fs/namei.c after/vanilla/linux-2.6.22.19/fs/namei.c
--- before/vanilla/linux-2.6.22.19/fs/namei.c	2009-03-19 11:24:27.000000000 +0900
+++ after/vanilla/linux-2.6.22.19/fs/namei.c	2009-03-20 01:15:29.000000000 +0900
@@ -1528,13 +1528,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1636,6 +1629,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1909,16 +1907,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1932,37 +1920,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2031,9 +2003,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2144,9 +2115,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2208,10 +2177,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2234,12 +2199,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2305,10 +2267,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2327,9 +2285,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2404,10 +2361,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2432,10 +2385,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2664,14 +2615,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2696,10 +2643,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.22.19/fs/open.c after/vanilla/linux-2.6.22.19/fs/open.c
--- before/vanilla/linux-2.6.22.19/fs/open.c	2009-03-19 11:24:27.000000000 +0900
+++ after/vanilla/linux-2.6.22.19/fs/open.c	2009-03-19 23:26:14.000000000 +0900
@@ -273,7 +273,7 @@ static long do_sys_truncate(const char _
 		goto dput_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = locks_verify_truncate(inode, NULL, length);
@@ -330,7 +330,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.22.19/net/unix/af_unix.c after/vanilla/linux-2.6.22.19/net/unix/af_unix.c
--- before/vanilla/linux-2.6.22.19/net/unix/af_unix.c	2009-03-19 11:24:27.000000000 +0900
+++ after/vanilla/linux-2.6.22.19/net/unix/af_unix.c	2009-03-19 22:36:20.000000000 +0900
@@ -767,11 +767,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -816,10 +811,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.23.17/fs/namei.c after/vanilla/linux-2.6.23.17/fs/namei.c
--- before/vanilla/linux-2.6.23.17/fs/namei.c	2009-03-19 11:24:27.000000000 +0900
+++ after/vanilla/linux-2.6.23.17/fs/namei.c	2009-03-20 01:15:20.000000000 +0900
@@ -1561,13 +1561,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1669,6 +1662,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1942,16 +1940,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1965,37 +1953,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2064,9 +2036,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2177,9 +2148,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2241,10 +2210,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2267,12 +2232,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2338,10 +2300,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2360,9 +2318,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2437,10 +2394,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2465,10 +2418,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2697,14 +2648,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2729,10 +2676,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.23.17/fs/open.c after/vanilla/linux-2.6.23.17/fs/open.c
--- before/vanilla/linux-2.6.23.17/fs/open.c	2009-03-19 11:24:27.000000000 +0900
+++ after/vanilla/linux-2.6.23.17/fs/open.c	2009-03-19 23:26:09.000000000 +0900
@@ -275,7 +275,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -334,7 +334,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.23.17/net/unix/af_unix.c after/vanilla/linux-2.6.23.17/net/unix/af_unix.c
--- before/vanilla/linux-2.6.23.17/net/unix/af_unix.c	2009-03-19 11:24:27.000000000 +0900
+++ after/vanilla/linux-2.6.23.17/net/unix/af_unix.c	2009-03-19 22:36:10.000000000 +0900
@@ -794,11 +794,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -843,10 +838,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.24.7/fs/namei.c after/vanilla/linux-2.6.24.7/fs/namei.c
--- before/vanilla/linux-2.6.24.7/fs/namei.c	2009-03-19 11:24:28.000000000 +0900
+++ after/vanilla/linux-2.6.24.7/fs/namei.c	2009-03-20 01:11:05.000000000 +0900
@@ -1590,13 +1590,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry, nd->mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1700,6 +1693,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->dentry);
@@ -1973,16 +1971,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -1996,37 +1984,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2095,9 +2067,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_mkdir_permission(nd.dentry->d_inode, dentry, nd.mnt,
+					   mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.dentry->d_inode, dentry, mode);
@@ -2208,9 +2179,7 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry, nd.mnt);
+	error = ccs_check_rmdir_permission(nd.dentry->d_inode, dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.dentry->d_inode, dentry);
@@ -2272,10 +2241,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2298,12 +2263,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry, nd.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.dentry->d_inode, dentry,
+						    nd.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.dentry->d_inode, dentry);
 	exit2:
@@ -2369,10 +2331,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2391,9 +2349,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry, nd.mnt);
+	error = ccs_check_symlink_permission(nd.dentry->d_inode, dentry,
+					     nd.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2468,10 +2425,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2496,10 +2449,8 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.dentry,
-					     old_nd.mnt, new_dentry, nd.mnt);
+	error = ccs_check_link_permission(old_nd.dentry, nd.dentry->d_inode,
+					  new_dentry, nd.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.dentry, nd.dentry->d_inode, new_dentry);
@@ -2728,14 +2679,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry, oldnd.mnt,
-				     new_dentry, newnd.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2760,10 +2707,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.24.7/fs/open.c after/vanilla/linux-2.6.24.7/fs/open.c
--- before/vanilla/linux-2.6.24.7/fs/open.c	2009-03-19 11:24:28.000000000 +0900
+++ after/vanilla/linux-2.6.24.7/fs/open.c	2009-03-19 23:26:03.000000000 +0900
@@ -275,7 +275,7 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.dentry, nd.mnt);
+	error = ccs_check_truncate_permission(nd.dentry, nd.mnt, length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -334,7 +334,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.24.7/net/unix/af_unix.c after/vanilla/linux-2.6.24.7/net/unix/af_unix.c
--- before/vanilla/linux-2.6.24.7/net/unix/af_unix.c	2009-03-19 11:24:28.000000000 +0900
+++ after/vanilla/linux-2.6.24.7/net/unix/af_unix.c	2009-03-19 22:35:57.000000000 +0900
@@ -799,11 +799,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -848,10 +843,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.mnt);
+		err = ccs_check_mknod_permission(nd.dentry->d_inode, dentry,
+						 nd.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.25.20/fs/namei.c after/vanilla/linux-2.6.25.20/fs/namei.c
--- before/vanilla/linux-2.6.25.20/fs/namei.c	2009-03-19 11:24:28.000000000 +0900
+++ after/vanilla/linux-2.6.25.20/fs/namei.c	2009-03-20 00:58:03.000000000 +0900
@@ -1608,14 +1608,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1719,6 +1711,11 @@ static int open_namei_create(struct name
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->path.dentry);
@@ -1996,16 +1993,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -2019,39 +2006,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	if (!IS_POSIXACL(nd.path.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	if (!IS_ERR(dentry)) {
+		/***** TOMOYO Linux start. *****/
+		error = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						   dentry, nd.path.mnt, mode,
+						   new_decode_dev(dev));
+		if (!error)
+		/***** TOMOYO Linux end. *****/
 		switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);
 			break;
 		case S_IFDIR:
@@ -2120,10 +2089,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (!IS_POSIXACL(nd.path.dentry->d_inode))
 		mode &= ~current->fs->umask;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);
@@ -2234,10 +2201,8 @@ static long do_rmdir(int dfd, const char
 	if (IS_ERR(dentry))
 		goto exit2;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
@@ -2300,10 +2265,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2326,13 +2287,9 @@ static long do_unlinkat(int dfd, const c
 		if (inode)
 			atomic_inc(&inode->i_count);
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (error)
-			goto exit2;
-		error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-					     nd.path.mnt);
-		if (error)
-			goto exit2;
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
+		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
 	exit2:
@@ -2398,10 +2355,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2420,10 +2373,8 @@ asmlinkage long sys_symlinkat(const char
 		goto out_unlock;
 
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_symlink_permission(nd.path.dentry->d_inode, dentry,
+					     nd.path.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.path.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2498,10 +2449,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2526,12 +2473,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (IS_ERR(new_dentry))
 		goto out_unlock;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.path.dentry, nd.path.dentry->d_inode,
-			     new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.path.dentry,
-					     old_nd.path.mnt, new_dentry,
-					     nd.path.mnt);
+	error = ccs_check_link_permission(old_nd.path.dentry,
+					  nd.path.dentry->d_inode, new_dentry,
+					  nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.path.dentry, nd.path.dentry->d_inode, new_dentry);
@@ -2760,15 +2704,10 @@ static int do_rename(int olddfd, const c
 	if (new_dentry == trap)
 		goto exit5;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-				     oldnd.path.mnt, new_dentry,
-				     newnd.path.mnt);
-	if (error)
-		goto exit5;
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.path.mnt);
+	if (!error)
 	/***** TOMOYO Linux end. *****/
 
 	error = vfs_rename(old_dir->d_inode, old_dentry,
@@ -2793,10 +2732,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.25.20/fs/open.c after/vanilla/linux-2.6.25.20/fs/open.c
--- before/vanilla/linux-2.6.25.20/fs/open.c	2009-03-19 11:24:28.000000000 +0900
+++ after/vanilla/linux-2.6.25.20/fs/open.c	2009-03-19 23:25:57.000000000 +0900
@@ -275,8 +275,8 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.path.dentry,
-				     nd.path.mnt);
+	error = ccs_check_truncate_permission(nd.path.dentry, nd.path.mnt,
+					      length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -335,7 +335,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.25.20/net/unix/af_unix.c after/vanilla/linux-2.6.25.20/net/unix/af_unix.c
--- before/vanilla/linux-2.6.25.20/net/unix/af_unix.c	2009-03-19 11:24:28.000000000 +0900
+++ after/vanilla/linux-2.6.25.20/net/unix/af_unix.c	2009-03-19 22:35:19.000000000 +0900
@@ -779,11 +779,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -828,10 +823,8 @@ static int unix_bind(struct socket *sock
 		mode = S_IFSOCK |
 		       (SOCK_INODE(sock)->i_mode & ~current->fs->umask);
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.path.mnt);
+		err = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						 dentry, nd.path.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.path.dentry->d_inode, dentry, mode, 0);
diff -upr before/vanilla/linux-2.6.26.8/fs/namei.c after/vanilla/linux-2.6.26.8/fs/namei.c
--- before/vanilla/linux-2.6.26.8/fs/namei.c	2009-03-19 11:24:28.000000000 +0900
+++ after/vanilla/linux-2.6.26.8/fs/namei.c	2009-03-20 02:22:59.000000000 +0900
@@ -1612,14 +1612,6 @@ int vfs_create(struct inode *dir, struct
 	error = security_inode_create(dir, dentry, mode);
 	if (error)
 		return error;
-	/***** TOMOYO Linux start. *****/
-	if (nd) {
-		error = ccs_check_1path_perm(TYPE_CREATE_ACL, dentry,
-					     nd->path.mnt);
-		if (error)
-			return error;
-	}
-	/***** TOMOYO Linux end. *****/
 	DQUOT_INIT(dir);
 	error = dir->i_op->create(dir, dentry, mode, nd);
 	if (!error)
@@ -1727,6 +1719,11 @@ static int __open_namei_create(struct na
 
 	if (!IS_POSIXACL(dir->d_inode))
 		mode &= ~current->fs->umask;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(dir->d_inode, path->dentry,
+					   nd->path.mnt, mode, 0);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_create(dir->d_inode, path->dentry, mode, nd);
 	mutex_unlock(&dir->d_inode->i_mutex);
 	dput(nd->path.dentry);
@@ -2115,16 +2112,6 @@ asmlinkage long sys_mknodat(int dfd, con
 
 	if (S_ISDIR(mode))
 		return -EPERM;
-	/***** TOMOYO Linux start. *****/
-	if (S_ISCHR(mode) && !ccs_capable(CCS_CREATE_CHAR_DEV))
-		return -EPERM;
-	if (S_ISBLK(mode) && !ccs_capable(CCS_CREATE_BLOCK_DEV))
-		return -EPERM;
-	if (S_ISFIFO(mode) && !ccs_capable(CCS_CREATE_FIFO))
-		return -EPERM;
-	if (S_ISSOCK(mode) && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 	tmp = getname(filename);
 	if (IS_ERR(tmp))
 		return PTR_ERR(tmp);
@@ -2145,39 +2132,21 @@ asmlinkage long sys_mknodat(int dfd, con
 	error = mnt_want_write(nd.path.mnt);
 	if (error)
 		goto out_dput;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_mknod_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode,
+					   new_decode_dev(dev));
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	switch (mode & S_IFMT) {
 		case 0: case S_IFREG:
 			error = vfs_create(nd.path.dentry->d_inode,dentry,mode,&nd);
 			break;
 		case S_IFCHR: case S_IFBLK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISCHR(mode) ?
-						     TYPE_MKCHAR_ACL :
-						     TYPE_MKBLOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,
 					new_decode_dev(dev));
 			break;
 		case S_IFIFO: case S_IFSOCK:
-			/***** TOMOYO Linux start. *****/
-			error = pre_vfs_mknod(nd.path.dentry->d_inode, dentry,
-					      mode);
-			if (error)
-				break;
-			error = ccs_check_1path_perm(S_ISFIFO(mode) ?
-						     TYPE_MKFIFO_ACL :
-						     TYPE_MKSOCK_ACL,
-						     dentry, nd.path.mnt);
-			if (error)
-				break;
-			/***** TOMOYO Linux end. *****/
 			error = vfs_mknod(nd.path.dentry->d_inode,dentry,mode,0);
 			break;
 	}
@@ -2246,10 +2215,8 @@ asmlinkage long sys_mkdirat(int dfd, con
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_mkdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_MKDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_mkdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt, mode);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_mkdir(nd.path.dentry->d_inode, dentry, mode);
@@ -2365,10 +2332,8 @@ static long do_rmdir(int dfd, const char
 	if (error)
 		goto exit3;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rmdir(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_RMDIR_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_rmdir_permission(nd.path.dentry->d_inode, dentry,
+					   nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_rmdir(nd.path.dentry->d_inode, dentry);
@@ -2433,10 +2398,6 @@ static long do_unlinkat(int dfd, const c
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_UNLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	name = getname(pathname);
 	if(IS_ERR(name))
@@ -2462,10 +2423,8 @@ static long do_unlinkat(int dfd, const c
 		if (error)
 			goto exit2;
 		/***** TOMOYO Linux start. *****/
-		error = pre_vfs_unlink(nd.path.dentry->d_inode, dentry);
-		if (!error)
-			error = ccs_check_1path_perm(TYPE_UNLINK_ACL, dentry,
-						     nd.path.mnt);
+		error = ccs_check_unlink_permission(nd.path.dentry->d_inode,
+						    dentry, nd.path.mnt);
 		if (!error)
 		/***** TOMOYO Linux end. *****/
 		error = vfs_unlink(nd.path.dentry->d_inode, dentry);
@@ -2533,10 +2492,6 @@ asmlinkage long sys_symlinkat(const char
 	char * to;
 	struct dentry *dentry;
 	struct nameidata nd;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_SYMLINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
@@ -2558,10 +2513,8 @@ asmlinkage long sys_symlinkat(const char
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_symlink(nd.path.dentry->d_inode, dentry);
-	if (!error)
-		error = ccs_check_1path_perm(TYPE_SYMLINK_ACL, dentry,
-					     nd.path.mnt);
+	error = ccs_check_symlink_permission(nd.path.dentry->d_inode, dentry,
+					     nd.path.mnt, from);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_symlink(nd.path.dentry->d_inode, dentry, from, S_IALLUGO);
@@ -2638,10 +2591,6 @@ asmlinkage long sys_linkat(int olddfd, c
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_LINK))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	if ((flags & ~AT_SYMLINK_FOLLOW) != 0)
 		return -EINVAL;
@@ -2669,12 +2618,9 @@ asmlinkage long sys_linkat(int olddfd, c
 	if (error)
 		goto out_dput;
 	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_link(old_nd.path.dentry, nd.path.dentry->d_inode,
-			     new_dentry);
-	if (!error)
-		error = ccs_check_2path_perm(TYPE_LINK_ACL, old_nd.path.dentry,
-					     old_nd.path.mnt, new_dentry,
-					     nd.path.mnt);
+	error = ccs_check_link_permission(old_nd.path.dentry,
+					  nd.path.dentry->d_inode, new_dentry,
+					  nd.path.mnt);
 	if (!error)
 	/***** TOMOYO Linux end. *****/
 	error = vfs_link(old_nd.path.dentry, nd.path.dentry->d_inode, new_dentry);
@@ -2904,21 +2850,16 @@ static int do_rename(int olddfd, const c
 	error = -ENOTEMPTY;
 	if (new_dentry == trap)
 		goto exit5;
-	/***** TOMOYO Linux start. *****/
-	error = pre_vfs_rename(old_dir->d_inode, old_dentry,
-			       new_dir->d_inode, new_dentry);
-	if (error)
-		goto exit5;
-	error = ccs_check_2path_perm(TYPE_RENAME_ACL, old_dentry,
-				     oldnd.path.mnt, new_dentry,
-				     newnd.path.mnt);
-	if (error)
-		goto exit5;
-	/***** TOMOYO Linux end. *****/
 
 	error = mnt_want_write(oldnd.path.mnt);
 	if (error)
 		goto exit5;
+	/***** TOMOYO Linux start. *****/
+	error = ccs_check_rename_permission(old_dir->d_inode, old_dentry,
+					    new_dir->d_inode, new_dentry,
+					    newnd.path.mnt);
+	if (!error)
+	/***** TOMOYO Linux end. *****/
 	error = vfs_rename(old_dir->d_inode, old_dentry,
 				   new_dir->d_inode, new_dentry);
 	mnt_drop_write(oldnd.path.mnt);
@@ -2942,10 +2883,6 @@ asmlinkage long sys_renameat(int olddfd,
 	int error;
 	char * from;
 	char * to;
-	/***** TOMOYO Linux start. *****/
-	if (!ccs_capable(CCS_SYS_RENAME))
-		return -EPERM;
-	/***** TOMOYO Linux end. *****/
 
 	from = getname(oldname);
 	if(IS_ERR(from))
diff -upr before/vanilla/linux-2.6.26.8/fs/open.c after/vanilla/linux-2.6.26.8/fs/open.c
--- before/vanilla/linux-2.6.26.8/fs/open.c	2009-03-19 11:24:28.000000000 +0900
+++ after/vanilla/linux-2.6.26.8/fs/open.c	2009-03-19 23:25:52.000000000 +0900
@@ -277,8 +277,8 @@ static long do_sys_truncate(const char _
 		goto put_write_and_out;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, nd.path.dentry,
-				     nd.path.mnt);
+	error = ccs_check_truncate_permission(nd.path.dentry, nd.path.mnt,
+					      length, 0);
 	if (error)
 		goto put_write_and_out;
 	/***** TOMOYO Linux end. *****/
@@ -339,7 +339,8 @@ static long do_sys_ftruncate(unsigned in
 		goto out_putf;
 
 	/***** TOMOYO Linux start. *****/
-	error = ccs_check_1path_perm(TYPE_TRUNCATE_ACL, dentry, file->f_vfsmnt);
+	error = ccs_check_truncate_permission(dentry, file->f_vfsmnt, length,
+					      0);
 	if (error)
 		goto out_putf;
 	/***** TOMOYO Linux end. *****/
diff -upr before/vanilla/linux-2.6.26.8/net/unix/af_unix.c after/vanilla/linux-2.6.26.8/net/unix/af_unix.c
--- before/vanilla/linux-2.6.26.8/net/unix/af_unix.c	2009-03-19 11:24:28.000000000 +0900
+++ after/vanilla/linux-2.6.26.8/net/unix/af_unix.c	2009-03-19 22:35:02.000000000 +0900
@@ -786,11 +786,6 @@ static int unix_bind(struct socket *sock
 		err = unix_autobind(sock);
 		goto out;
 	}
-	/***** TOMOYO Linux start. *****/
-	err = -EPERM;
-	if (sunaddr->sun_path[0] && !ccs_capable(CCS_CREATE_UNIX_SOCKET))
-		goto out;
-	/***** TOMOYO Linux end. *****/
 
 	err = unix_mkname(sunaddr, addr_len, &hash);
 	if (err < 0)
@@ -838,10 +833,8 @@ static int unix_bind(struct socket *sock
 		if (err)
 			goto out_mknod_dput;
 		/***** TOMOYO Linux start. *****/
-		err = pre_vfs_mknod(nd.path.dentry->d_inode, dentry, mode);
-		if (!err)
-			err = ccs_check_1path_perm(TYPE_MKSOCK_ACL, dentry,
-						   nd.path.mnt);
+		err = ccs_check_mknod_permission(nd.path.dentry->d_inode,
+						 dentry, nd.path.mnt, mode, 0);
 		if (!err)
 		/***** TOMOYO Linux end. *****/
 		err = vfs_mknod(nd.path.dentry->d_inode, dentry, mode, 0);
