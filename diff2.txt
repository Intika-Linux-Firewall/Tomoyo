Index: trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/autobind.c	(working copy)
@@ -37,45 +37,51 @@
 {
 	const struct ccs_reserved *p1 = container_of(a, typeof(*p1), head);
 	const struct ccs_reserved *p2 = container_of(b, typeof(*p2), head);
-	return p1->min_port == p2->min_port && p1->max_port == p2->max_port;
+	return ccs_same_number_union(&p1->port, &p2->port);
 }
 
 /**
- * ccs_update_reserved_entry - Update "struct ccs_reserved" list.
+ * ccs_write_reserved_port - Write "struct ccs_reserved" list.
  *
- * @min_port:  Start of port number range.
- * @max_port:  End of port number range.
- * @is_delete: True if it is a delete request.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_update_reserved_entry(const u16 min_port, const u16 max_port,
-				     const bool is_delete)
+int ccs_write_reserved_port(struct ccs_element_param *param, char *data)
 {
-	struct ccs_reserved *ptr;
-	struct ccs_reserved e = {
-		.min_port = min_port,
-		.max_port = max_port
-	};
-	const int error =
-		ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_RESERVEDPORT],
-				  ccs_same_reserved);
+	struct ccs_reserved e = { };
+	struct ccs_policy_namespace *ns = param->ns;
+	int error;
 	u8 *tmp;
+	if (*data == '@' || strchr(data, ' ') ||
+	    !ccs_parse_number_union(ns, data, &e.port) ||
+	    e.port.values[0] > e.port.values[1] || e.port.values[1] > 65535)
+		return -EINVAL;
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+	param->check_duplicate = ccs_same_reserved;
+	error = ccs_update_policy(param);
 	if (error)
 		return error;
 	tmp = kzalloc(sizeof(ccs_reserved_port_map), CCS_GFP_FLAGS);
 	if (!tmp)
 		return -ENOMEM;
-	list_for_each_entry_srcu(ptr, &ccs_policy_list[CCS_ID_RESERVEDPORT],
-				 head.list, &ccs_ss) {
-		unsigned int port;
-		if (ptr->head.is_deleted)
-			continue;
-		for (port = ptr->min_port; port <= ptr->max_port; port++)
-			tmp[port >> 3] |= 1 << (port & 7);
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		struct ccs_reserved *ptr;
+		struct list_head *list = &ns->policy_list[CCS_ID_RESERVEDPORT];
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
+			unsigned int port;
+			if (ptr->head.is_deleted)
+				continue;
+			for (port = ptr->port.values[0];
+			     port <= ptr->port.values[1]; port++)
+				tmp[port >> 3] |= 1 << (port & 7);
+		}
 	}
 	memmove(ccs_reserved_port_map, tmp, sizeof(ccs_reserved_port_map));
 	kfree(tmp);
@@ -86,33 +92,3 @@
 	ccsecurity_ops.lport_reserved = __ccs_lport_reserved;
 	return 0;
 }
-
-/**
- * ccs_write_reserved_port - Write "struct ccs_reserved" list.
- *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- *
- * Returns 0 on success, negative value otherwise.
- *
- * Caller holds ccs_read_lock().
- */
-int ccs_write_reserved_port(char *data, const bool is_delete)
-{
-	unsigned int from;
-	unsigned int to;
-	if (strchr(data, ' '))
-		goto out;
-	switch (sscanf(data, "%u-%u", &from, &to)) {
-	case 1:
-		to = from;
-		/* fall through */
-	case 2:
-		if (from <= to && to < 65536)
-			return ccs_update_reserved_entry(from, to,
-							 is_delete);
-		break;
-	}
-out:
-	return -EINVAL;
-}
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/audit.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/audit.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/audit.c	(working copy)
@@ -336,6 +336,7 @@
 {
 	const struct ccs_domain_info *domain;
 	char *buf;
+	const char *cp;
 	const struct ccs_acl_info *acl = r->matched_acl;
 	r->matched_acl = NULL;
 	if (!acl || !acl->cond || !acl->cond->transit)
@@ -349,8 +350,12 @@
 			return;
 	}
 	domain = ccs_current_domain();
-	snprintf(buf, CCS_EXEC_TMPSIZE - 1, "%s %s", domain->domainname->name,
-		 acl->cond->transit->name);
+	cp = acl->cond->transit->name;
+	if (*cp == '/')
+		snprintf(buf, CCS_EXEC_TMPSIZE - 1, "%s %s",
+			 domain->domainname->name, cp);
+	else
+		strncpy(buf, cp, CCS_EXEC_TMPSIZE - 1);
 	if (!ccs_assign_domain(buf, r->profile, domain->group, true))
 		ccs_transition_failed(buf);
 	kfree(buf);
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/domain.c	(working copy)
@@ -8,59 +8,40 @@
 
 #include "internal.h"
 
-/*
- * The global domains referred by "use_group" keyword.
- *
- * Although "use_group" needs only "struct list_head acl_info_list[2]",
- * we define structure for "use_group" as "struct ccs_domain_info" in order to
- * use common code.
- */
-struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
-
 /* The initial domain. */
 struct ccs_domain_info ccs_kernel_domain;
 
 /* The list for "struct ccs_domain_info". */
 LIST_HEAD(ccs_domain_list);
 
-/* List of policy. */
-struct list_head ccs_policy_list[CCS_MAX_POLICY];
-/* List of "struct ccs_group". */
-struct list_head ccs_group_list[CCS_MAX_GROUP];
 /* List of "struct ccs_condition" and "struct ccs_ipv6addr". */
 struct list_head ccs_shared_list[CCS_MAX_LIST];
 
 /**
  * ccs_update_policy - Update an entry for exception policy.
  *
- * @new_entry:       Pointer to "struct ccs_acl_info".
- * @size:            Size of @new_entry in bytes.
- * @is_delete:       True if it is a delete request.
- * @list:            Pointer to "struct list_head".
- * @check_duplicate: Callback function to find duplicated entry.
+ * @param: Pointer to "struct ccs_element_param".
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      bool is_delete, struct list_head *list,
-		      bool (*check_duplicate) (const struct ccs_acl_head *,
-					       const struct ccs_acl_head *))
+int ccs_update_policy(struct ccs_element_param *param)
 {
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	struct ccs_acl_head *entry;
+	struct list_head *list = param->list;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return -ENOMEM;
 	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
-		if (!check_duplicate(entry, new_entry))
+		if (!param->check_duplicate(entry, param->new_entry))
 			continue;
-		entry->is_deleted = is_delete;
+		entry->is_deleted = param->is_delete;
 		error = 0;
 		break;
 	}
-	if (error && !is_delete) {
-		entry = ccs_commit_ok(new_entry, size);
+	if (error && !param->is_delete) {
+		entry = ccs_commit_ok(param->new_entry, param->size);
 		if (entry) {
 			list_add_tail_rcu(&entry->list, list);
 			error = 0;
@@ -105,23 +86,22 @@
 					       struct ccs_acl_info *,
 					       const bool))
 {
-	struct ccs_domain_info * const domain = param->domain;
 	const bool is_delete = param->is_delete;
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	struct ccs_acl_info *entry;
 	const u8 type = new_entry->type;
-	const u8 i = type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
-		type == CCS_TYPE_DENIED_EXECUTE_HANDLER ||
-		type == CCS_TYPE_AUTO_TASK_ACL;
+	struct list_head * const list = &param->list
+		[type == CCS_TYPE_AUTO_EXECUTE_HANDLER ||
+		 type == CCS_TYPE_DENIED_EXECUTE_HANDLER ||
+		 type == CCS_TYPE_AUTO_TASK_ACL];
 	if (param->data[0]) {
-		new_entry->cond = ccs_get_condition(param->data);
+		new_entry->cond = ccs_get_condition(param->ns, param->data);
 		if (!new_entry->cond)
 			return -EINVAL;
 	}
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list_for_each_entry_srcu(entry, &domain->acl_info_list[i], list,
-				 &ccs_ss) {
+	list_for_each_entry_srcu(entry, list, list, &ccs_ss) {
 		if (!ccs_same_acl_head(entry, new_entry) ||
 		    !check_duplicate(entry, new_entry))
 			continue;
@@ -136,8 +116,7 @@
 	if (error && !is_delete) {
 		entry = ccs_commit_ok(new_entry, size);
 		if (entry) {
-			list_add_tail_rcu(&entry->list,
-					  &domain->acl_info_list[i]);
+			list_add_tail_rcu(&entry->list, list);
 			error = 0;
 		}
 	}
@@ -166,9 +145,9 @@
 	struct ccs_acl_info *ptr;
 	bool retried = false;
 	const u8 i = !check_entry;
+	const struct list_head *list = &domain->acl_info_list[i];
 retry:
-	list_for_each_entry_srcu(ptr, &domain->acl_info_list[i], list,
-				 &ccs_ss) {
+	list_for_each_entry_srcu(ptr, list, list, &ccs_ss) {
 		if (ptr->is_deleted)
 			continue;
 		if (ptr->type != r->param_type)
@@ -183,7 +162,7 @@
 	}
 	if (!retried) {
 		retried = true;
-		domain = &ccs_acl_group[domain->group];
+		list = &r->ns->acl_group[domain->group][i];
 		goto retry;
 	}
 	r->granted = false;
@@ -212,20 +191,20 @@
 /**
  * ccs_update_transition_control_entry - Update "struct ccs_transition_control" list.
  *
+ * @param:      Pointer to "struct ccs_element_param".
  * @domainname: The name of domain. Maybe NULL.
  * @program:    The name of program. Maybe NULL.
  * @type:       Type of transition.
- * @is_delete:  True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_transition_control_entry(const char *domainname,
+static int ccs_update_transition_control_entry(struct ccs_element_param *param,
+					       const char *domainname,
 					       const char *program,
-					       const u8 type,
-					       const bool is_delete)
+					       const u8 type)
 {
 	struct ccs_transition_control e = { .type = type };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	if (program && strcmp(program, "any")) {
 		if (!ccs_correct_path(program))
 			return -EINVAL;
@@ -243,9 +222,11 @@
 		if (!e.domainname)
 			goto out;
 	}
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_TRANSITION_CONTROL],
-				  ccs_same_transition_control);
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &param->ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+	param->check_duplicate = ccs_same_transition_control;
+	error = ccs_update_policy(param);
 out:
 	ccs_put_name(e.domainname);
 	ccs_put_name(e.program);
@@ -255,13 +236,13 @@
 /**
  * ccs_write_transition_control - Write "struct ccs_transition_control" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- * @type:      Type of this entry.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
+ * @type:  Type of this entry.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_transition_control(char *data, const bool is_delete,
+int ccs_write_transition_control(struct ccs_element_param *param, char *data,
 				 const u8 type)
 {
 	char *domainname = strstr(data, " from ");
@@ -273,8 +254,8 @@
 		domainname = data;
 		data = NULL;
 	}
-	return ccs_update_transition_control_entry(domainname, data, type,
-						   is_delete);
+	return ccs_update_transition_control_entry(param, domainname, data,
+						   type);
 }
 
 /**
@@ -295,6 +276,7 @@
 /**
  * ccs_transition_type - Get domain transition type.
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @domainname: The name of domain.
  * @program:    The name of program.
  *
@@ -304,17 +286,18 @@
  *
  * Caller holds ccs_read_lock().
  */
-static u8 ccs_transition_type(const struct ccs_path_info *domainname,
+static u8 ccs_transition_type(const struct ccs_policy_namespace *ns,
+			      const struct ccs_path_info *domainname,
 			      const struct ccs_path_info *program)
 {
 	const struct ccs_transition_control *ptr;
 	const char *last_name = ccs_last_word(domainname->name);
 	u8 type;
 	for (type = 0; type < CCS_MAX_TRANSITION_TYPE; type++) {
+		const struct list_head *list;
 next:
-		list_for_each_entry_srcu(ptr, &ccs_policy_list
-					 [CCS_ID_TRANSITION_CONTROL],
-					 head.list, &ccs_ss) {
+		list = &ns->policy_list[CCS_ID_TRANSITION_CONTROL];
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 			if (ptr->head.is_deleted || ptr->type != type)
 				continue;
 			if (ptr->domainname) {
@@ -333,6 +316,14 @@
 			}
 			if (ptr->program && ccs_pathcmp(ptr->program, program))
 				continue;
+			if (type == CCS_TRANSITION_CONTROL_NO_NAMESPACE) {
+				/*
+				 * Do not check for move_namespace if
+				 * no_move_namespace matched.
+				 */
+				type = CCS_TRANSITION_CONTROL_NO_INITIALIZE;
+				goto next;
+			}
 			if (type == CCS_TRANSITION_CONTROL_NO_INITIALIZE) {
 				/*
 				 * Do not check for initialize_domain if
@@ -368,18 +359,18 @@
 /**
  * ccs_update_aggregator_entry - Update "struct ccs_aggregator" list.
  *
+ * @param:           Pointer to "struct ccs_element_param".
  * @original_name:   The original program's name.
  * @aggregated_name: The aggregated program's name.
- * @is_delete:       True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_aggregator_entry(const char *original_name,
-				       const char *aggregated_name,
-				       const bool is_delete)
+static int ccs_update_aggregator_entry(struct ccs_element_param *param,
+				       const char *original_name,
+				       const char *aggregated_name)
 {
 	struct ccs_aggregator e = { };
-	int error = is_delete ? -ENOENT : -ENOMEM;
+	int error = param->is_delete ? -ENOENT : -ENOMEM;
 	if (!ccs_correct_word(original_name) ||
 	    !ccs_correct_path(aggregated_name))
 		return -EINVAL;
@@ -388,9 +379,11 @@
 	if (!e.original_name || !e.aggregated_name ||
 	    e.aggregated_name->is_patterned) /* No patterns allowed. */
 		goto out;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_AGGREGATOR],
-				  ccs_same_aggregator);
+	param->new_entry = &e.head;
+	param->size = sizeof(e);
+	param->list = &param->ns->policy_list[CCS_ID_AGGREGATOR];
+	param->check_duplicate = ccs_same_aggregator;
+	error = ccs_update_policy(param);
 out:
 	ccs_put_name(e.original_name);
 	ccs_put_name(e.aggregated_name);
@@ -400,24 +393,107 @@
 /**
  * ccs_write_aggregator - Write "struct ccs_aggregator" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_aggregator(char *data, const bool is_delete)
+int ccs_write_aggregator(struct ccs_element_param *param, char *data)
 {
 	char *w[2];
 	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
 		return -EINVAL;
-	return ccs_update_aggregator_entry(w[0], w[1], is_delete);
+	return ccs_update_aggregator_entry(param, w[0], w[1]);
 }
 
 /* Domain create handler. */
 
 /**
- * ccs_assign_domain - Create a domain.
+ * ccs_find_namespace - Find specified namespace.
  *
+ * @name: Name of namespace to find.
+ * @len:  Length of @name.
+ *
+ * Returns pointer to "struct ccs_policy_namespace" if found, NULL otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+static struct ccs_policy_namespace *ccs_find_namespace(const char *name,
+						       const unsigned int len)
+{
+	struct ccs_policy_namespace *ns;
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		if (strncmp(name, ns->name, len) ||
+		    (name[len] && name[len] != ' '))
+			continue;
+		return ns;
+	}
+	return NULL;
+}
+
+
+/**
+ * ccs_assign_namespace - Create a new namespace.
+ *
+ * @domainname: Name of namespace to create.
+ *
+ * Returns pointer to "struct ccs_policy_namespace" on success, NULL otherwise.
+ *
+ * Caller holds ccs_read_lock().
+ */
+struct ccs_policy_namespace *ccs_assign_namespace(const char *domainname)
+{
+	struct ccs_policy_namespace *ptr;
+	struct ccs_policy_namespace *entry;
+	const char *cp = domainname;
+	unsigned int len = 0;
+	while (*cp && *cp++ != ' ')
+		len++;
+	ptr = ccs_find_namespace(domainname, len);
+	if (ptr)
+		return ptr;
+	if (len >= CCS_EXEC_TMPSIZE - 10 || !ccs_domain_def(domainname))
+		return NULL;
+	entry = kzalloc(sizeof(*entry) + len + 1, CCS_GFP_FLAGS);
+	if (!entry)
+		return NULL;
+	if (mutex_lock_interruptible(&ccs_policy_lock))
+		goto out;
+	ptr = ccs_find_namespace(domainname, len);
+	if (!ptr && ccs_memory_ok(entry, sizeof(*entry) + len + 1)) {
+		char *name = (char *) (entry + 1);
+		ptr = entry;
+		memmove(name, domainname, len);
+		name[len] = '\0';
+		entry->name = name;
+		ccs_init_policy_namespace(entry);
+		entry = NULL;
+	}
+	mutex_unlock(&ccs_policy_lock);
+out:
+	kfree(entry);
+	return entry;
+}
+
+/**
+ * ccs_namespace_jump - Check for namespace jump.
+ *
+ * @domainname: Name of domain.
+ *
+ * Returns true if namespace differs, false otherwise.
+ */
+static bool ccs_namespace_jump(const char *domainname)
+{
+	const char *namespace = ccs_current_namespace()->name;
+	const int len = strlen(namespace);
+	return strncmp(domainname, namespace, len) ||
+		(domainname[len] && domainname[len] != ' ');
+}
+
+/**
+ * ccs_assign_domain - Create a domain or a namespace.
+ *
  * @domainname: The name of domain.
  * @profile:    Profile number to assign if the domain was newly created.
  * @group:      Group number to assign if the domain was newly created.
@@ -432,13 +508,26 @@
 					  const bool transit)
 {
 	struct ccs_domain_info e = { };
-	struct ccs_domain_info *entry = ccs_find_domain(domainname);
+	struct ccs_domain_info *entry;
 	bool created = false;
-	if (entry)
-		goto out;
 	if (strlen(domainname) >= CCS_EXEC_TMPSIZE - 10 ||
 	    !ccs_correct_domain(domainname))
 		return NULL;
+	entry = ccs_find_domain(domainname);
+	if (entry)
+		goto out;
+	if (transit && ccs_namespace_jump(domainname))
+		/*
+		 * Namespace jump is requested but target domain was not found.
+		 * Don't create target domains upon namespace jump in order to
+		 * avoid inheriting "use_profile" and "use_group" information,
+		 * for definition of profiles and acl_groups may differ across
+		 * namespaces.
+		 */
+		return NULL;
+	e.ns = ccs_assign_namespace(domainname);
+	if (!e.ns)
+		return NULL;
 	e.profile = profile;
 	e.group = group;
 	e.domainname = ccs_get_name(domainname);
@@ -519,10 +608,10 @@
 		}
 	} else {
 		struct ccs_aggregator *ptr;
+		struct list_head *list =
+			&r->ns->policy_list[CCS_ID_AGGREGATOR];
 		/* Check 'aggregator' directive. */
-		list_for_each_entry_srcu(ptr,
-					 &ccs_policy_list[CCS_ID_AGGREGATOR],
-					 head.list, &ccs_ss) {
+		list_for_each_entry_srcu(ptr, list, head.list, &ccs_ss) {
 			if (ptr->head.is_deleted ||
 			    !ccs_path_matches_pattern(&rn, ptr->original_name))
 				continue;
@@ -555,10 +644,14 @@
 	}
 
 	/* Calculate domain to transit to. */
-	switch (ccs_transition_type(old_domain->domainname, &rn)) {
+	switch (ccs_transition_type(r->ns, old_domain->domainname, &rn)) {
+	case CCS_TRANSITION_CONTROL_NAMESPACE:
+		/* Transit to the root of specified namespace. */
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "<%s>", rn.name);
+		break;
 	case CCS_TRANSITION_CONTROL_INITIALIZE:
-		/* Transit to the child of ccs_kernel_domain domain. */
-		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, CCS_ROOT_NAME " " "%s",
+		/* Transit to the child of current namespace's root. */
+		snprintf(ee->tmp, CCS_EXEC_TMPSIZE - 1, "%s %s", r->ns->name,
 			 rn.name);
 		break;
 	case CCS_TRANSITION_CONTROL_KEEP:
@@ -566,7 +659,7 @@
 		domain = old_domain;
 		break;
 	default:
-		if (old_domain == &ccs_kernel_domain && !ccs_policy_loaded) {
+		if (!ccs_policy_loaded && old_domain == &ccs_kernel_domain) {
 			/*
 			 * Needn't to transit from kernel domain before
 			 * starting /sbin/init. But transit from kernel domain
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/memory.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/memory.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/memory.c	(working copy)
@@ -109,15 +109,18 @@
 /**
  * ccs_get_group - Allocate memory for "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group".
  *
+ * @ns:         Pointer to "struct ccs_policy_namespace".
  * @group_name: The name of address group.
  * @idx:        Index number.
  *
  * Returns pointer to "struct ccs_group" on success, NULL otherwise.
  */
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx)
+struct ccs_group *ccs_get_group(struct ccs_policy_namespace *ns,
+				const char *group_name, const u8 idx)
 {
 	struct ccs_group e = { };
 	struct ccs_group *group = NULL;
+	struct list_head *list;
 	bool found = false;
 	if (!ccs_correct_word(group_name) || idx >= CCS_MAX_GROUP)
 		return NULL;
@@ -126,7 +129,8 @@
 		return NULL;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	list_for_each_entry(group, &ccs_group_list[idx], head.list) {
+	list = &ns->group_list[idx];
+	list_for_each_entry(group, list, head.list) {
 		if (e.group_name != group->group_name)
 			continue;
 		atomic_inc(&group->head.users);
@@ -138,8 +142,7 @@
 		if (entry) {
 			INIT_LIST_HEAD(&entry->member_list);
 			atomic_set(&entry->head.users, 1);
-			list_add_tail_rcu(&entry->head.list,
-					  &ccs_group_list[idx]);
+			list_add_tail_rcu(&entry->head.list, list);
 			group = entry;
 			found = true;
 		}
@@ -400,6 +403,9 @@
 
 #endif
 
+/* Initial namespace.*/
+struct ccs_policy_namespace ccs_kernel_namespace;
+
 /**
  * ccs_mm_init - Initialize mm related code.
  *
@@ -410,10 +416,9 @@
 	int idx;
 	for (idx = 0; idx < CCS_MAX_HASH; idx++)
 		INIT_LIST_HEAD(&ccs_name_list[idx]);
-	for (idx = 0; idx < CCS_MAX_ACL_GROUPS; idx++) {
-		INIT_LIST_HEAD(&ccs_acl_group[idx].acl_info_list[0]);
-		INIT_LIST_HEAD(&ccs_acl_group[idx].acl_info_list[1]);
-	}
+	ccs_kernel_namespace.name = "<kernel>";
+	ccs_init_policy_namespace(&ccs_kernel_namespace);
+	ccs_kernel_domain.ns = &ccs_kernel_namespace;
 	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list[0]);
 	INIT_LIST_HEAD(&ccs_kernel_domain.acl_info_list[1]);
 #ifdef CONFIG_CCSECURITY_USE_EXTERNAL_TASK_SECURITY
@@ -425,27 +430,27 @@
 	ccsecurity_ops.alloc_task_security = __ccs_alloc_task_security;
 	ccsecurity_ops.free_task_security = __ccs_free_task_security;
 #endif
-	ccs_kernel_domain.domainname = ccs_get_name(CCS_ROOT_NAME);
+	ccs_kernel_domain.domainname = ccs_get_name("<kernel>");
 	list_add_tail_rcu(&ccs_kernel_domain.list, &ccs_domain_list);
+#ifdef CONFIG_CCSECURITY_BUILTIN_INITIALIZERS
 	idx = ccs_read_lock();
-	if (ccs_find_domain(CCS_ROOT_NAME) != &ccs_kernel_domain)
-		panic("Can't register ccs_kernel_domain");
-#ifdef CONFIG_CCSECURITY_BUILTIN_INITIALIZERS
 	{
 		/* Load built-in policy. */
+		struct ccs_element_param param = { };
 		static char ccs_builtin_initializers[] __initdata
 			= CONFIG_CCSECURITY_BUILTIN_INITIALIZERS;
 		char *cp = ccs_builtin_initializers;
 		ccs_normalize_line(cp);
+		param.ns = &ccs_kernel_namespace;
 		while (cp && *cp) {
 			char *cp2 = strchr(cp, ' ');
 			if (cp2)
 				*cp2++ = '\0';
-			ccs_write_transition_control(cp, false,
+			ccs_write_transition_control(&param, cp,
 				     CCS_TRANSITION_CONTROL_INITIALIZE);
 			cp = cp2;
 		}
 	}
+	ccs_read_unlock(idx);
 #endif
-	ccs_read_unlock(idx);
 }
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/util.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/util.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/util.c	(working copy)
@@ -247,17 +247,19 @@
 /**
  * ccs_parse_name_union - Parse a ccs_name_union.
  *
+ * @ns:       Pointer to "struct ccs_policy_namespace".
  * @filename: Name or name group.
  * @ptr:      Pointer to "struct ccs_name_union".
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr)
+bool ccs_parse_name_union(struct ccs_policy_namespace *ns,
+			  const char *filename, struct ccs_name_union *ptr)
 {
 	if (!ccs_correct_word(filename))
 		return false;
 	if (filename[0] == '@') {
-		ptr->group = ccs_get_group(filename + 1, CCS_PATH_GROUP);
+		ptr->group = ccs_get_group(ns, filename + 1, CCS_PATH_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
@@ -269,12 +271,14 @@
 /**
  * ccs_parse_number_union - Parse a ccs_number_union.
  *
+ * @ns:   Pointer to "struct ccs_policy_namespace".
  * @data: Number or number range or number group.
  * @ptr:  Pointer to "struct ccs_number_union".
  *
  * Returns true on success, false otherwise.
  */
-bool ccs_parse_number_union(char *data, struct ccs_number_union *ptr)
+bool ccs_parse_number_union(struct ccs_policy_namespace *ns, char *data,
+			    struct ccs_number_union *ptr)
 {
 	u8 type;
 	unsigned long v;
@@ -284,7 +288,7 @@
 	if (data[0] == '@') {
 		if (!ccs_correct_word(data))
 			return false;
-		ptr->group = ccs_get_group(data + 1, CCS_NUMBER_GROUP);
+		ptr->group = ccs_get_group(ns, data + 1, CCS_NUMBER_GROUP);
 		ptr->is_group = true;
 		return ptr->group != NULL;
 	}
@@ -562,26 +566,21 @@
  */
 bool ccs_correct_domain(const unsigned char *domainname)
 {
-	if (!domainname || strncmp(domainname, CCS_ROOT_NAME,
-				   CCS_ROOT_NAME_LEN))
-		goto out;
-	domainname += CCS_ROOT_NAME_LEN;
-	if (!*domainname)
+	if (!domainname || !ccs_domain_def(domainname))
+		return false;
+	domainname = strchr(domainname, ' ');
+	if (!domainname++)
 		return true;
-	if (*domainname++ != ' ')
-		goto out;
 	while (1) {
 		const unsigned char *cp = strchr(domainname, ' ');
 		if (!cp)
 			break;
 		if (*domainname != '/' ||
 		    !ccs_correct_word2(domainname, cp - domainname))
-			goto out;
+			return false;
 		domainname = cp + 1;
 	}
 	return ccs_correct_path(domainname);
-out:
-	return false;
 }
 
 /**
@@ -593,7 +592,18 @@
  */
 bool ccs_domain_def(const unsigned char *buffer)
 {
-	return !strncmp(buffer, CCS_ROOT_NAME, CCS_ROOT_NAME_LEN);
+	const unsigned char *cp;
+	int len;
+	if (*buffer != '<')
+		return false;
+	cp = strchr(buffer, ' ');
+	if (!cp)
+		len = strlen(buffer);
+	else
+		len = cp - buffer;
+	if (buffer[len - 1] != '>' || !ccs_correct_word2(buffer + 1, len - 2))
+		return false;
+	return true;
 }
 
 /**
@@ -1028,6 +1038,7 @@
 		struct ccs_domain_info *domain = ccs_current_domain();
 		const u8 profile = domain->profile;
 		memset(r, 0, sizeof(*r));
+		r->ns = ccs_current_namespace();
 		r->profile = profile;
 		r->type = index;
 		r->mode = ccs_get_mode(profile, index);
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/file.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/file.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/file.c	(working copy)
@@ -393,7 +393,7 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name))
+	if (!ccs_parse_name_union(param->ns, ccs_read_token(param), &e.name))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -462,10 +462,11 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.mode) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.major) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.minor))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.name) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.mode) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.major) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.minor))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -535,8 +536,9 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name1) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.name2))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.name1) ||
+	    !ccs_parse_name_union(ns, ccs_read_token(param), &e.name2))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -579,10 +581,11 @@
 {
 	struct ccs_mount_acl e = { .head.type = CCS_TYPE_MOUNT_ACL };
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.dev_name) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.dir_name) ||
-	    !ccs_parse_name_union(ccs_read_token(param), &e.fs_type) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.flags))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.dev_name) ||
+	    !ccs_parse_name_union(ns, ccs_read_token(param), &e.dir_name) ||
+	    !ccs_parse_name_union(ns, ccs_read_token(param), &e.fs_type) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.flags))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
@@ -1001,8 +1004,9 @@
 		.perm = perm
 	};
 	int error;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name) ||
-	    !ccs_parse_number_union(ccs_read_token(param), &e.number))
+	struct ccs_policy_namespace *ns = param->ns;
+	if (!ccs_parse_name_union(ns, ccs_read_token(param), &e.name) ||
+	    !ccs_parse_number_union(ns, ccs_read_token(param), &e.number))
 		error = -EINVAL;
 	else
 		error = ccs_update_domain(&e.head, sizeof(e), param,
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/internal.h	(working copy)
@@ -697,6 +697,8 @@
 /* Index numbers for domain transition control keywords. */
 enum ccs_transition_type {
 	/* Do not change this order, */
+	CCS_TRANSITION_CONTROL_NO_NAMESPACE,
+	CCS_TRANSITION_CONTROL_NAMESPACE,
 	CCS_TRANSITION_CONTROL_NO_INITIALIZE,
 	CCS_TRANSITION_CONTROL_INITIALIZE,
 	CCS_TRANSITION_CONTROL_NO_KEEP,
@@ -728,10 +730,6 @@
  */
 #define CCS_SOCK_MAX 6
 
-/* A domain definition starts with <kernel>. */
-#define CCS_ROOT_NAME                         "<kernel>"
-#define CCS_ROOT_NAME_LEN                     (sizeof(CCS_ROOT_NAME) - 1)
-
 /* Size of temporary buffer for execve() operation. */
 #define CCS_EXEC_TMPSIZE     4096
 
@@ -934,6 +932,7 @@
 };
 
 struct ccs_execve;
+struct ccs_policy_namespace;
 
 /* Structure for request info. */
 struct ccs_request_info {
@@ -1027,6 +1026,7 @@
 			const struct ccs_path_info *domainname;
 		} task;
 	} param;
+	struct ccs_policy_namespace *ns;
 	u8 param_type; /* One of values in "enum ccs_acl_entry_type_index". */
 	bool granted; /* True if granted, false otherwise. */
 	/* True if current thread should not be carried sleep penalty. */
@@ -1095,6 +1095,8 @@
 	struct list_head acl_info_list[2];
 	/* Name of this domain. Never NULL.          */
 	const struct ccs_path_info *domainname;
+	/* Namespace for this domain. Never NULL. */
+	struct ccs_policy_namespace *ns;
 	u8 profile;        /* Profile number to use. */
 	u8 group;          /* Group number to use.   */
 	bool is_deleted;   /* Delete flag.           */
@@ -1102,7 +1104,8 @@
 };
 
 /*
- * Structure for "initialize_domain"/"no_initialize_domain" and
+ * Structure for "move_namespace"/"no_move_namespace" and
+ * "initialize_domain"/"no_initialize_domain" and
  * "keep_domain"/"no_keep_domain" keyword.
  */
 struct ccs_transition_control {
@@ -1123,8 +1126,7 @@
 /* Structure for "deny_autobind" keyword. */
 struct ccs_reserved {
 	struct ccs_acl_head head;
-	u16 min_port;                /* Start of port number range.          */
-	u16 max_port;                /* End of port number range.            */
+	struct ccs_number_union port;
 };
 
 /* Structure for policy manager. */
@@ -1311,10 +1313,28 @@
 /* Structure for holding a line from /proc/ccs/ interface. */
 struct ccs_acl_param {
 	char *data;
-	struct ccs_domain_info *domain;
+	struct list_head *list; /* = &"struct list_head[2]" */
+	struct ccs_policy_namespace *ns;
 	bool is_delete;
 };
 
+/* Structure for holding a line from /proc/ccs/ interface. */
+struct ccs_element_param {
+	/* Namespace to use. */
+	struct ccs_policy_namespace *ns;
+	/* Pointer to "struct ccs_acl_info". */
+	struct ccs_acl_head *new_entry;
+	/* Size of @new_entry in bytes. */
+	u8 size;
+	/* True if it is a delete request. */
+	bool is_delete;
+	/* Pointer to "struct list_head". */
+	struct list_head *list;
+	/* Callback function to find duplicated entry. */
+	bool (*check_duplicate) (const struct ccs_acl_head *,
+				 const struct ccs_acl_head *);
+};
+
 /* Structure for reading/writing policy via /proc/ccs/ interfaces. */
 struct ccs_io_buffer {
 	void (*read) (struct ccs_io_buffer *);
@@ -1325,6 +1345,7 @@
 	char __user *read_user_buf;
 	size_t read_user_buf_avail;
 	struct {
+		struct list_head *ns;
 		struct list_head *domain;
 		struct list_head *group;
 		struct list_head *acl;
@@ -1344,8 +1365,10 @@
 		const char *w[CCS_MAX_IO_READ_QUEUE];
 	} r;
 	struct {
+		struct ccs_policy_namespace *ns;
 		struct ccs_domain_info *domain;
 		size_t avail;
+		bool is_delete;
 	} w;
 	/* Buffer for reading.                  */
 	char *read_buf;
@@ -1355,6 +1378,8 @@
 	char *write_buf;
 	/* Size of write buffer.                */
 	size_t writebuf_size;
+	/* Namespace as of open(). */
+	struct ccs_policy_namespace *original_ns;
 	/* Type of interface. */
 	enum ccs_proc_interface_index type;
 	/* Users counter protected by ccs_io_buffer_list_lock. */
@@ -1381,6 +1406,22 @@
 	u8 sec;
 };
 
+/* Structure for policy namespace. */
+struct ccs_policy_namespace {
+	/* Profile table. Memory is allocated as needed. */
+	struct ccs_profile *profile_ptr[CCS_MAX_PROFILES];
+	/* List of "struct ccs_group". */
+	struct list_head group_list[CCS_MAX_GROUP];
+	/* List of policy. */
+	struct list_head policy_list[CCS_MAX_POLICY];
+	/* The global ACL referred by "use_group" keyword. */
+	struct list_head acl_group[CCS_MAX_ACL_GROUPS][2];
+	/* List for connecting to ccs_namespace_list list. */
+	struct list_head namespace_list;
+	/* Name of this namespace (e.g. "<kernel>", "</usr/sbin/httpd>" ). */
+	const char *name;
+};
+
 /* Prototype definition for "struct ccsecurity_operations". */
 
 void __init ccs_capability_init(void);
@@ -1410,8 +1451,10 @@
 bool ccs_memory_ok(const void *ptr, const unsigned int size);
 bool ccs_number_matches_group(const unsigned long min, const unsigned long max,
 			      const struct ccs_group *group);
-bool ccs_parse_name_union(const char *filename, struct ccs_name_union *ptr);
-bool ccs_parse_number_union(char *data, struct ccs_number_union *num);
+bool ccs_parse_name_union(struct ccs_policy_namespace *ns,
+			  const char *filename, struct ccs_name_union *ptr);
+bool ccs_parse_number_union(struct ccs_policy_namespace *ns, char *data,
+			    struct ccs_number_union *num);
 bool ccs_path_matches_pattern(const struct ccs_path_info *filename,
 			      const struct ccs_path_info *pattern);
 bool ccs_permstr(const char *string, const char *keyword);
@@ -1452,31 +1495,32 @@
 		      bool (*merge_duplicate) (struct ccs_acl_info *,
 					       struct ccs_acl_info *,
 					       const bool));
-int ccs_update_policy(struct ccs_acl_head *new_entry, const int size,
-		      bool is_delete, struct list_head *list,
-		      bool (*check_duplicate) (const struct ccs_acl_head *,
-					       const struct ccs_acl_head *));
-int ccs_write_aggregator(char *data, const bool is_delete);
+int ccs_update_policy(struct ccs_element_param *param);
+int ccs_write_aggregator(struct ccs_element_param *param, char *data);
 int ccs_write_capability(struct ccs_acl_param *param);
 int ccs_write_file(struct ccs_acl_param *param);
-int ccs_write_group(char *data, const bool is_delete, const u8 type);
+int ccs_write_group(struct ccs_element_param *param, char *data,
+		    const u8 type);
 int ccs_write_inet_network(struct ccs_acl_param *param);
 int ccs_write_ipc(struct ccs_acl_param *param);
 int ccs_write_misc(struct ccs_acl_param *param);
-int ccs_write_reserved_port(char *data, const bool is_delete);
-int ccs_write_transition_control(char *data, const bool is_delete,
+int ccs_write_reserved_port(struct ccs_element_param *param, char *data);
+int ccs_write_transition_control(struct ccs_element_param *param, char *data,
 				 const u8 type);
 int ccs_write_unix_network(struct ccs_acl_param *param);
 ssize_t ccs_read_control(struct file *file, char __user *buffer,
 			 const size_t buffer_len);
 ssize_t ccs_write_control(struct file *file, const char __user *buffer,
 			  const size_t buffer_len);
-struct ccs_condition *ccs_get_condition(char *condition);
+struct ccs_condition *ccs_get_condition(struct ccs_policy_namespace *ns,
+					char *condition);
 struct ccs_domain_info *ccs_assign_domain(const char *domainname,
 					  const u8 profile, const u8 group,
 					  const bool transit);
 struct ccs_domain_info *ccs_find_domain(const char *domainname);
-struct ccs_group *ccs_get_group(const char *group_name, const u8 idx);
+struct ccs_group *ccs_get_group(struct ccs_policy_namespace *ns,
+				const char *group_name, const u8 idx);
+struct ccs_policy_namespace *ccs_assign_namespace(const char *domainname);
 struct ccs_profile *ccs_profile(const u8 profile);
 u8 ccs_get_config(const u8 profile, const u8 index);
 u8 ccs_parse_ulong(unsigned long *result, char **str);
@@ -1488,6 +1532,7 @@
 void ccs_del_condition(struct list_head *element);
 void ccs_fill_path_info(struct ccs_path_info *ptr);
 void ccs_get_attributes(struct ccs_obj_info *obj);
+void ccs_init_policy_namespace(struct ccs_policy_namespace *ns);
 void ccs_memory_free(const void *ptr, size_t size);
 void ccs_normalize_line(unsigned char *buffer);
 void ccs_notify_gc(struct ccs_io_buffer *head, const bool is_register);
@@ -1528,12 +1573,12 @@
 extern const u8 ccs_pn2mac[CCS_MAX_PATH_NUMBER_OPERATION];
 extern const u8 ccs_pnnn2mac[CCS_MAX_MKDEV_OPERATION];
 extern const u8 ccs_pp2mac[CCS_MAX_PATH2_OPERATION];
-extern struct ccs_domain_info ccs_acl_group[CCS_MAX_ACL_GROUPS];
+extern struct ccs_policy_namespace ccs_kernel_namespace;
 extern struct ccs_domain_info ccs_kernel_domain;
 extern struct list_head ccs_domain_list;
-extern struct list_head ccs_group_list[CCS_MAX_GROUP];
+extern struct list_head ccs_manager_list;
 extern struct list_head ccs_name_list[CCS_MAX_HASH];
-extern struct list_head ccs_policy_list[CCS_MAX_POLICY];
+extern struct list_head ccs_namespace_list;
 extern struct list_head ccs_shared_list[CCS_MAX_LIST];
 extern struct mutex ccs_policy_lock;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 19)
@@ -2045,8 +2090,8 @@
  * Returns pointer to "struct ccs_domain_info" for current thread.
  *
  * If current thread does not belong to a domain (which is true for initial
- * init_task in order to hide ccs_kernel_domain from this module), current
- * thread enters into ccs_kernel_domain.
+ * init_task in order to hide ccs_kernel_domain from this module),
+ * current thread enters into ccs_kernel_domain.
  */
 static inline struct ccs_domain_info *ccs_current_domain(void)
 {
@@ -2080,4 +2125,9 @@
 
 #endif
 
+static inline struct ccs_policy_namespace *ccs_current_namespace(void)
+{
+	return ccs_current_domain()->ns;
+}
+
 #endif
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/proc_if.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/proc_if.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/proc_if.c	(working copy)
@@ -338,10 +338,6 @@
 static int __init ccs_init_module(void)
 {
 	int i;
-	for (i = 0; i < CCS_MAX_POLICY; i++)
-		INIT_LIST_HEAD(&ccs_policy_list[i]);
-	for (i = 0; i < CCS_MAX_GROUP; i++)
-		INIT_LIST_HEAD(&ccs_group_list[i]);
 	for (i = 0; i < CCS_MAX_LIST; i++)
 		INIT_LIST_HEAD(&ccs_shared_list[i]);
 	if (ccsecurity_ops.disabled)
@@ -353,7 +349,6 @@
 	if (init_srcu_struct(&ccs_ss))
 		panic("Out of memory.");
 #endif
-	ccs_proc_init();
 	ccs_mm_init();
 	ccs_capability_init();
 	ccs_file_init();
@@ -362,6 +357,7 @@
 	ccs_mount_init();
 	ccs_policy_io_init();
 	ccs_domain_init();
+	ccs_proc_init();
 #ifdef CONFIG_CCSECURITY_USE_BUILTIN_POLICY
 	ccs_load_builtin_policy();
 #endif
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/condition.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/condition.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/condition.c	(working copy)
@@ -277,16 +277,18 @@
 /**
  * ccs_parse_name_union_quoted - Parse a quoted word.
  *
+ * @ns:       Pointer to "struct ccs_policy_namespace".
  * @filename: A line containing a quoted word.
  * @ptr:      Pointer to "struct ccs_name_union".
  *
  * Returns true on success, false otherwise.
  */
-static bool ccs_parse_name_union_quoted(char *filename,
+static bool ccs_parse_name_union_quoted(struct ccs_policy_namespace *ns,
+					char *filename,
 					struct ccs_name_union *ptr)
 {
 	if (*filename == '@')
-		return ccs_parse_name_union(filename, ptr);
+		return ccs_parse_name_union(ns, filename, ptr);
 	ptr->is_group = false;
 	ptr->filename = ccs_get_dqword(filename);
 	return ptr->filename != NULL;
@@ -482,11 +484,13 @@
 /**
  * ccs_get_condition - Parse condition part.
  *
+ * @ns:        Pointer to "struct ccs_policy_namespace".
  * @condition: Pointer to string to parse.
  *
  * Returns pointer to "struct ccs_condition" on success, NULL otherwise.
  */
-struct ccs_condition *ccs_get_condition(char *condition)
+struct ccs_condition *ccs_get_condition(struct ccs_policy_namespace *ns,
+					char *condition)
 {
 	char *start;
 	struct ccs_condition *entry = NULL;
@@ -541,6 +545,17 @@
 					goto out;
 			}
 			continue;
+		} else if (!strncmp(word, "auto_namespace_transition=", 26)) {
+			if (!dry_run) {
+				word += 26;
+				if (entry->transit)
+					goto out;
+				entry->transit = ccs_get_dqword(word);
+				if (!entry->transit ||
+				    !ccs_domain_def(entry->transit->name))
+					goto out;
+			}
+			continue;
 		}
 		if (!strncmp(word, "exec.argv[", 10)) {
 			if (dry_run) {
@@ -584,7 +599,8 @@
 			} else {
 				e.numbers_count--;
 				left = CCS_NUMBER_UNION;
-				if (!ccs_parse_number_union(word, numbers_p))
+				if (!ccs_parse_number_union(ns, word,
+							    numbers_p))
 					goto out;
 				if (numbers_p->is_group)
 					goto out;
@@ -605,7 +621,7 @@
 			} else {
 				e.names_count--;
 				right = CCS_NAME_UNION;
-				if (!ccs_parse_name_union_quoted(word,
+				if (!ccs_parse_name_union_quoted(ns, word,
 								 names_p++))
 					goto out;
 			}
@@ -618,7 +634,8 @@
 			} else {
 				e.numbers_count--;
 				right = CCS_NUMBER_UNION;
-				if (!ccs_parse_number_union(word, numbers_p++))
+				if (!ccs_parse_number_union(ns, word,
+							    numbers_p++))
 					goto out;
 			}
 		}
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -83,9 +83,6 @@
 /* Profile version. Currently only 20100903 is defined. */
 static unsigned int ccs_profile_version;
 
-/* Profile table. Memory is allocated as needed. */
-static struct ccs_profile *ccs_profile_ptr[CCS_MAX_PROFILES];
-
 /* String table for operation mode. */
 const char * const ccs_mode[CCS_CONFIG_MAX_MODE] = {
 	[CCS_CONFIG_DISABLED]   = "disabled",
@@ -430,26 +427,72 @@
 	ccs_set_string(head, "/");
 }
 
+/* List of namespaces. */
+LIST_HEAD(ccs_namespace_list);
+/* True if namespace other than ccs_kernel_namespace is defined. */
+static bool ccs_namespace_enabled;
+
 /**
+ * ccs_init_policy_namespace - Initialize namespace.
+ *
+ * @ns: Pointer to "struct ccs_policy_namespace".
+ *
+ * Returns nothing.
+ */
+void ccs_init_policy_namespace(struct ccs_policy_namespace *ns)
+{
+	unsigned int idx;
+	for (idx = 0; idx < CCS_MAX_ACL_GROUPS; idx++) {
+		INIT_LIST_HEAD(&ns->acl_group[idx][0]);
+		INIT_LIST_HEAD(&ns->acl_group[idx][1]);
+	}
+	for (idx = 0; idx < CCS_MAX_GROUP; idx++)
+		INIT_LIST_HEAD(&ns->group_list[idx]);
+	for (idx = 0; idx < CCS_MAX_POLICY; idx++)
+		INIT_LIST_HEAD(&ns->policy_list[idx]);
+	ccs_namespace_enabled = !list_empty(&ccs_namespace_list);
+	list_add_tail_rcu(&ns->namespace_list, &ccs_namespace_list);
+}
+
+/**
+ * ccs_print_namespace - Print namespace header.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ */
+static void ccs_print_namespace(struct ccs_io_buffer *head)
+{
+	if (!ccs_namespace_enabled)
+		return;
+	ccs_set_string(head,
+		       container_of(head->r.ns, struct ccs_policy_namespace,
+				    namespace_list)->name);
+	ccs_set_space(head);
+}
+
+/**
  * ccs_assign_profile - Create a new profile.
  *
+ * @ns:      Pointer to "struct ccs_policy_namespace".
  * @profile: Profile number to create.
  *
  * Returns pointer to "struct ccs_profile" on success, NULL otherwise.
  */
-static struct ccs_profile *ccs_assign_profile(const unsigned int profile)
+static struct ccs_profile *ccs_assign_profile(struct ccs_policy_namespace *ns,
+					      const unsigned int profile)
 {
 	struct ccs_profile *ptr;
 	struct ccs_profile *entry;
 	if (profile >= CCS_MAX_PROFILES)
 		return NULL;
-	ptr = ccs_profile_ptr[profile];
+	ptr = ns->profile_ptr[profile];
 	if (ptr)
 		return ptr;
 	entry = kzalloc(sizeof(*entry), CCS_GFP_FLAGS);
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		goto out;
-	ptr = ccs_profile_ptr[profile];
+	ptr = ns->profile_ptr[profile];
 	if (!ptr && ccs_memory_ok(entry, sizeof(*entry))) {
 		ptr = entry;
 		ptr->default_config = CCS_CONFIG_DISABLED |
@@ -461,7 +504,7 @@
 		ptr->pref[CCS_PREF_MAX_LEARNING_ENTRY] =
 			CONFIG_CCSECURITY_MAX_ACCEPT_ENTRY;
 		mb(); /* Avoid out-of-order execution. */
-		ccs_profile_ptr[profile] = ptr;
+		ns->profile_ptr[profile] = ptr;
 		entry = NULL;
 	}
 	mutex_unlock(&ccs_policy_lock);
@@ -482,16 +525,15 @@
 	ccs_policy_loaded = true;
 	list_for_each_entry_srcu(domain, &ccs_domain_list, list, &ccs_ss) {
 		const u8 profile = domain->profile;
-		if (ccs_profile_ptr[profile])
+		if (domain->ns->profile_ptr[profile])
 			continue;
-		printk(KERN_ERR "Profile %u must be defined before using it.\n",
-		       profile);
+		printk(KERN_ERR "Profile %u must be defined before "
+		       "using it.\n", profile);
 		printk(KERN_ERR "Please see http://tomoyo.sourceforge.jp/1.8/ "
 		       "for more information.\n");
 		panic("Profile %u (used by '%s') not defined.\n",
 		      profile, domain->domainname->name);
 	}
-	ccs_read_unlock(idx);
 	if (ccs_profile_version != 20100903) {
 		printk(KERN_ERR "Userland tools must be installed for "
 		       "TOMOYO 1.8, and policy must be initialized.\n");
@@ -500,6 +542,7 @@
 		panic("Profile version %u is not supported.\n",
 		      ccs_profile_version);
 	}
+	ccs_read_unlock(idx);
 	printk(KERN_INFO "CCSecurity: 1.8.1+   2011/05/11\n");
 	printk(KERN_INFO "Mandatory Access Control activated.\n");
 }
@@ -514,7 +557,8 @@
 struct ccs_profile *ccs_profile(const u8 profile)
 {
 	static struct ccs_profile ccs_null_profile;
-	struct ccs_profile *ptr = ccs_profile_ptr[profile];
+	struct ccs_profile *ptr = ccs_current_namespace()->
+		profile_ptr[profile];
 	if (!ptr)
 		ptr = &ccs_null_profile;
 	return ptr;
@@ -654,7 +698,7 @@
 	if (*cp != '-')
 		return -EINVAL;
 	data = cp + 1;
-	profile = ccs_assign_profile(i);
+	profile = ccs_assign_profile(head->w.ns, i);
 	if (!profile)
 		return -EINVAL;
 	cp = strchr(data, '=');
@@ -711,31 +755,39 @@
 static void ccs_read_profile(struct ccs_io_buffer *head)
 {
 	u8 index;
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
 	const struct ccs_profile *profile;
+	if (head->r.eof)
+		return;
 next:
 	index = head->r.index;
-	profile = ccs_profile_ptr[index];
+	profile = ns->profile_ptr[index];
 	switch (head->r.step) {
 	case 0:
+		ccs_print_namespace(head);
 		ccs_io_printf(head, "PROFILE_VERSION=%u\n", 20100903);
 		head->r.step++;
 		break;
 	case 1:
-		for ( ; head->r.index < CCS_MAX_PROFILES;
-		      head->r.index++)
-			if (ccs_profile_ptr[head->r.index])
+		for ( ; head->r.index < CCS_MAX_PROFILES; head->r.index++)
+			if (ns->profile_ptr[head->r.index])
 				break;
-		if (head->r.index == CCS_MAX_PROFILES)
+		if (head->r.index == CCS_MAX_PROFILES) {
+			head->r.eof = true;
 			return;
+		}
 		head->r.step++;
 		break;
 	case 2:
 		{
 			u8 i;
 			const struct ccs_path_info *comment = profile->comment;
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-COMMENT=", index);
 			ccs_set_string(head, comment ? comment->name : "");
 			ccs_set_lf(head);
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-PREFERENCE={ ", index);
 			for (i = 0; i < CCS_MAX_PREF; i++)
 				ccs_io_printf(head, "%s=%u ",
@@ -747,6 +799,7 @@
 		break;
 	case 3:
 		{
+			ccs_print_namespace(head);
 			ccs_io_printf(head, "%u-%s", index, "CONFIG");
 			ccs_print_config(head, profile->default_config);
 			head->r.bit = 0;
@@ -760,6 +813,7 @@
 			const u8 config = profile->config[i];
 			if (config == CCS_CONFIG_USE_DEFAULT)
 				continue;
+			ccs_print_namespace(head);
 			if (i < CCS_MAX_MAC_INDEX)
 				ccs_io_printf(head, "%u-CONFIG::%s::%s", index,
 					      ccs_category_keywords
@@ -806,9 +860,18 @@
  *
  * Returns 0 on success, negative value otherwise.
  */
-static int ccs_update_manager_entry(const char *manager, const bool is_delete)
+static inline int ccs_update_manager_entry(const char *manager,
+					   const bool is_delete)
 {
 	struct ccs_manager e = { };
+	struct ccs_element_param param = {
+		/* .ns = &ccs_kernel_namespace, */
+		.is_delete = is_delete,
+		.new_entry = &e.head,
+		.size = sizeof(e),
+		.list = &ccs_kernel_namespace.policy_list[CCS_ID_MANAGER],
+		.check_duplicate = ccs_same_manager,
+	};
 	int error = is_delete ? -ENOENT : -ENOMEM;
 	if (ccs_domain_def(manager)) {
 		if (!ccs_correct_domain(manager))
@@ -819,12 +882,10 @@
 			return -EINVAL;
 	}
 	e.manager = ccs_get_name(manager);
-	if (!e.manager)
-		return error;
-	error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-				  &ccs_policy_list[CCS_ID_MANAGER],
-				  ccs_same_manager);
-	ccs_put_name(e.manager);
+	if (e.manager) {
+		error = ccs_update_policy(&param);
+		ccs_put_name(e.manager);
+	}
 	return error;
 }
 
@@ -837,13 +898,12 @@
  */
 static int ccs_write_manager(struct ccs_io_buffer *head)
 {
-	char *data = head->write_buf;
-	bool is_delete = ccs_str_starts(&data, "delete ");
+	const char *data = head->write_buf;
 	if (!strcmp(data, "manage_by_non_root")) {
-		ccs_manage_by_non_root = !is_delete;
+		ccs_manage_by_non_root = !head->w.is_delete;
 		return 0;
 	}
-	return ccs_update_manager_entry(data, is_delete);
+	return ccs_update_manager_entry(data, head->w.is_delete);
 }
 
 /**
@@ -859,7 +919,8 @@
 {
 	if (head->r.eof)
 		return;
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[CCS_ID_MANAGER]) {
+	list_for_each_cookie(head->r.acl, &ccs_kernel_namespace.
+			     policy_list[CCS_ID_MANAGER]) {
 		struct ccs_manager *ptr =
 			list_entry(head->r.acl, typeof(*ptr), head.list);
 		if (ptr->head.is_deleted)
@@ -895,8 +956,9 @@
 	if (!ccs_manage_by_non_root && (current_uid() || current_euid()))
 		return false;
 	exe = ccs_get_exe();
-	list_for_each_entry_srcu(ptr, &ccs_policy_list[CCS_ID_MANAGER],
-				 head.list, &ccs_ss) {
+	list_for_each_entry_srcu(ptr, &ccs_kernel_namespace.
+				 policy_list[CCS_ID_MANAGER], head.list,
+				 &ccs_ss) {
 		if (ptr->head.is_deleted)
 			continue;
 		if (ptr->is_domain) {
@@ -925,7 +987,7 @@
 }
 
 /**
- * ccs_select_one - Parse select command.
+ * ccs_select_domain - Parse select command.
  *
  * @head: Pointer to "struct ccs_io_buffer".
  * @data: String to parse.
@@ -934,15 +996,14 @@
  *
  * Caller holds ccs_read_lock().
  */
-static bool ccs_select_one(struct ccs_io_buffer *head, const char *data)
+static bool ccs_select_domain(struct ccs_io_buffer *head, const char *data)
 {
 	unsigned int pid;
 	struct ccs_domain_info *domain = NULL;
 	bool global_pid = false;
-	if (!strcmp(data, "transition_only")) {
-		head->r.print_transition_related_only = true;
-		return true;
-	}
+	if (strncmp(data, "select ", 7))
+		return false;
+	data += 7;
 	if (sscanf(data, "pid=%u", &pid) == 1 ||
 	    (global_pid = true, sscanf(data, "global-pid=%u", &pid) == 1)) {
 		struct task_struct *p;
@@ -960,7 +1021,7 @@
 			domain = ccs_task_domain(p);
 		ccs_tasklist_unlock();
 	} else if (!strncmp(data, "domain=", 7)) {
-		if (ccs_domain_def(data + 7))
+		if (*(data + 7) == '<')
 			domain = ccs_find_domain(data + 7);
 	} else
 		return false;
@@ -1068,20 +1129,23 @@
 /**
  * ccs_write_domain2 - Write domain policy.
  *
+ * @ns:        Pointer to "struct ccs_policy_namespace".
+ * @list:      Pointer to "struct list_head [2]".
  * @data:      Policy to be interpreted.
- * @domain:    Pointer to "struct ccs_domain_info".
  * @is_delete: True if it is a delete request.
  *
  * Returns 0 on success, negative value otherwise.
  *
  * Caller holds ccs_read_lock().
  */
-static int ccs_write_domain2(char *data, struct ccs_domain_info *domain,
+static int ccs_write_domain2(struct ccs_policy_namespace *ns,
+			     struct list_head list[2], char *data,
 			     const bool is_delete)
 {
 	struct ccs_acl_param param = {
+		.ns = ns,
+		.list = list,
 		.data = data,
-		.domain = domain,
 		.is_delete = is_delete,
 	};
 	static const struct {
@@ -1153,20 +1217,12 @@
 static int ccs_write_domain(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
+	struct ccs_policy_namespace *ns;
 	struct ccs_domain_info *domain = head->w.domain;
-	bool is_delete = false;
-	bool is_select = false;
+	const bool is_delete = head->w.is_delete;
+	const bool is_select = !is_delete && ccs_str_starts(&data, "select ");
 	unsigned int profile;
-	if (ccs_str_starts(&data, "delete "))
-		is_delete = true;
-	else if (ccs_str_starts(&data, "select "))
-		is_select = true;
-	if (is_select && ccs_select_one(head, data))
-		return -EAGAIN;
-	/* Don't allow updating policies by non manager programs. */
-	if (!ccs_manager())
-		return -EPERM;
-	if (ccs_domain_def(data)) {
+	if (*data == '<') {
 		domain = NULL;
 		if (is_delete)
 			ccs_delete_domain(data);
@@ -1179,10 +1235,10 @@
 	}
 	if (!domain)
 		return -EINVAL;
-
+	ns = domain->ns;
 	if (sscanf(data, "use_profile %u\n", &profile) == 1
 	    && profile < CCS_MAX_PROFILES) {
-		if (!ccs_policy_loaded || ccs_profile_ptr[(u8) profile])
+		if (!ccs_policy_loaded || ns->profile_ptr[(u8) profile])
 			if (!is_delete)
 				domain->profile = (u8) profile;
 		return 0;
@@ -1200,7 +1256,7 @@
 		domain->flags[profile] = !is_delete;
 		return 0;
 	}
-	return ccs_write_domain2(data, domain, is_delete);
+	return ccs_write_domain2(ns, domain->acl_info_list, data, is_delete);
 }
 
 /**
@@ -1214,34 +1270,47 @@
 static void ccs_print_name_union(struct ccs_io_buffer *head,
 				 const struct ccs_name_union *ptr)
 {
-	const bool cond = head->r.print_cond_part;
-	if (!cond)
-		ccs_set_space(head);
+	ccs_set_space(head);
 	if (ptr->is_group) {
 		ccs_set_string(head, "@");
 		ccs_set_string(head, ptr->group->group_name->name);
 	} else {
-		if (cond)
-			ccs_set_string(head, "\"");
 		ccs_set_string(head, ptr->filename->name);
-		if (cond)
-			ccs_set_string(head, "\"");
 	}
 }
 
 /**
- * ccs_print_number_union - Print a ccs_number_union.
+ * ccs_print_name_union_quoted - Print a ccs_name_union with a quote.
  *
  * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ccs_name_union".
+ *
+ * Returns nothing.
+ */
+static void ccs_print_name_union_quoted(struct ccs_io_buffer *head,
+					const struct ccs_name_union *ptr)
+{
+	if (ptr->is_group) {
+		ccs_set_string(head, "@");
+		ccs_set_string(head, ptr->group->group_name->name);
+	} else {
+		ccs_set_string(head, "\"");
+		ccs_set_string(head, ptr->filename->name);
+		ccs_set_string(head, "\"");
+	}
+}
+
+/**
+ * ccs_print_number_union_nospace - Print a ccs_number_union without a space.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
  * @ptr:  Pointer to "struct ccs_number_union".
  *
  * Returns nothing.
  */
-static void ccs_print_number_union(struct ccs_io_buffer *head,
-				   const struct ccs_number_union *ptr)
+static void ccs_print_number_union_nospace(struct ccs_io_buffer *head,
+					   const struct ccs_number_union *ptr)
 {
-	if (!head->r.print_cond_part)
-		ccs_set_space(head);
 	if (ptr->is_group) {
 		ccs_set_string(head, "@");
 		ccs_set_string(head, ptr->group->group_name->name);
@@ -1279,6 +1348,21 @@
 }
 
 /**
+ * ccs_print_number_union - Print a ccs_number_union.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @ptr:  Pointer to "struct ccs_number_union".
+ *
+ * Returns nothing.
+ */
+static void ccs_print_number_union(struct ccs_io_buffer *head,
+				   const struct ccs_number_union *ptr)
+{
+	ccs_set_space(head);
+	ccs_print_number_union_nospace(head, ptr);
+}
+
+/**
  * ccs_print_condition - Print condition part.
  *
  * @head: Pointer to "struct ccs_io_buffer".
@@ -1369,8 +1453,8 @@
 					envp++;
 					continue;
 				case CCS_NUMBER_UNION:
-					ccs_print_number_union(head,
-							       numbers_p++);
+					ccs_print_number_union_nospace
+						(head, numbers_p++);
 					break;
 				default:
 					ccs_set_string(head,
@@ -1380,11 +1464,12 @@
 				ccs_set_string(head, match ? "=" : "!=");
 				switch (right) {
 				case CCS_NAME_UNION:
-					ccs_print_name_union(head, names_p++);
+					ccs_print_name_union_quoted
+						(head, names_p++);
 					break;
 				case CCS_NUMBER_UNION:
-					ccs_print_number_union(head,
-							       numbers_p++);
+					ccs_print_number_union_nospace
+						(head, numbers_p++);
 					break;
 				default:
 					ccs_set_string(head,
@@ -1406,8 +1491,11 @@
 				      ccs_yesno(cond->grant_log ==
 						CCS_GRANTLOG_YES));
 		if (cond->transit) {
-			ccs_set_string(head, " auto_domain_transition=\"");
-			ccs_set_string(head, cond->transit->name);
+			const char *name = cond->transit->name;
+			ccs_set_string(head, *name == '<' ?
+				       " auto_namespace_transition=\"" :
+				       " auto_domain_transition=\"");
+			ccs_set_string(head, name);
 			ccs_set_string(head, "\"");
 		}
 		ccs_set_lf(head);
@@ -1426,8 +1514,10 @@
  */
 static void ccs_set_group(struct ccs_io_buffer *head, const char *category)
 {
-	if (head->type == CCS_EXCEPTIONPOLICY)
+	if (head->type == CCS_EXCEPTIONPOLICY) {
+		ccs_print_namespace(head);
 		ccs_io_printf(head, "acl_group %u ", head->r.acl_group_index);
+	}
 	ccs_set_string(head, category);
 }
 
@@ -1661,19 +1751,17 @@
 /**
  * ccs_read_domain2 - Read domain policy.
  *
- * @head:   Pointer to "struct ccs_io_buffer".
- * @domain: Pointer to "struct ccs_domain_info".
- * @index:  Index number.
+ * @head: Pointer to "struct ccs_io_buffer".
+ * @list: Pointer to "struct list_head".
  *
  * Returns true on success, false otherwise.
  *
  * Caller holds ccs_read_lock().
  */
 static bool ccs_read_domain2(struct ccs_io_buffer *head,
-			     struct ccs_domain_info *domain,
-			     const u8 index)
+			     struct list_head *list)
 {
-	list_for_each_cookie(head->r.acl, &domain->acl_info_list[index]) {
+	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_acl_info *ptr =
 			list_entry(head->r.acl, typeof(*ptr), list);
 		if (!ccs_print_entry(head, ptr))
@@ -1718,12 +1806,12 @@
 			ccs_set_lf(head);
 			/* fall through */
 		case 1:
-			if (!ccs_read_domain2(head, domain, 0))
+			if (!ccs_read_domain2(head, &domain->acl_info_list[0]))
 				return;
 			head->r.step++;
 			/* fall through */
 		case 2:
-			if (!ccs_read_domain2(head, domain, 1))
+			if (!ccs_read_domain2(head, &domain->acl_info_list[1]))
 				return;
 			head->r.step++;
 			if (!ccs_set_lf(head))
@@ -1766,7 +1854,8 @@
 	if (profile >= CCS_MAX_PROFILES)
 		return -EINVAL;
 	domain = ccs_find_domain(cp + 1);
-	if (domain && (!ccs_policy_loaded || ccs_profile_ptr[(u8) profile]))
+	if (domain && (!ccs_policy_loaded ||
+		       head->w.ns->profile_ptr[(u8) profile]))
 		domain->profile = (u8) profile;
 	return 0;
 }
@@ -1881,6 +1970,9 @@
 
 /* String table for domain transition control keywords. */
 static const char * const ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
+	[CCS_TRANSITION_CONTROL_NAMESPACE]     = "move_namespace ",
+	[CCS_TRANSITION_CONTROL_NO_NAMESPACE]  = "no_move_namespace ",
+	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
 	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
 	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
 	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
@@ -1904,42 +1996,32 @@
 static int ccs_write_exception(struct ccs_io_buffer *head)
 {
 	char *data = head->write_buf;
-	const bool is_delete = ccs_str_starts(&data, "delete ");
+	const bool is_delete = head->w.is_delete;
+	struct ccs_element_param param = {
+		.ns = head->w.ns,
+		.is_delete = is_delete,
+	};
 	u8 i;
-	static const struct {
-		const char *keyword;
-		int (*write) (char *, const bool);
-	} ccs_callback[2] = {
-		{ "aggregator ",    ccs_write_aggregator },
-		{ "deny_autobind ", ccs_write_reserved_port },
-	};
-	if (!is_delete && ccs_str_starts(&data, "select ") &&
-	    !strcmp(data, "transition_only")) {
-		head->r.print_transition_related_only = true;
-		return -EAGAIN;
-	}
-	/* Don't allow updating policies by non manager programs. */
-	if (!ccs_manager())
-		return -EPERM;
-	for (i = 0; i < 2; i++)
-		if (ccs_str_starts(&data, ccs_callback[i].keyword))
-			return ccs_callback[i].write(data, is_delete);
+	if (ccs_str_starts(&data, "aggregator "))
+		return ccs_write_aggregator(&param, data);
+	if (ccs_str_starts(&data, "deny_autobind "))
+		return ccs_write_reserved_port(&param, data);
 	for (i = 0; i < CCS_MAX_TRANSITION_TYPE; i++)
 		if (ccs_str_starts(&data, ccs_transition_type[i]))
-			return ccs_write_transition_control(data, is_delete,
-							    i);
+			return ccs_write_transition_control(&param, data, i);
 	for (i = 0; i < CCS_MAX_GROUP; i++)
 		if (ccs_str_starts(&data, ccs_group_name[i]))
-			return ccs_write_group(data, is_delete, i);
+			return ccs_write_group(&param, data, i);
 	if (ccs_str_starts(&data, "acl_group ")) {
 		unsigned int group;
 		if (sscanf(data, "%u", &group) == 1 &&
 		    group < CCS_MAX_ACL_GROUPS) {
 			data = strchr(data, ' ');
-			if (data)
-				return ccs_write_domain2(data + 1,
-							 &ccs_acl_group[group],
-							 is_delete);
+			if (data++)
+				return ccs_write_domain2(head->w.ns,
+							 head->w.ns->
+							 acl_group[group],
+							 data, is_delete);
 		}
 	}
 	return -EINVAL;
@@ -1957,7 +2039,10 @@
  */
 static bool ccs_read_group(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.group, &ccs_group_list[idx]) {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
+	struct list_head *list = &ns->group_list[idx];
+	list_for_each_cookie(head->r.group, list) {
 		struct ccs_group *group =
 			list_entry(head->r.group, typeof(*group), head.list);
 		list_for_each_cookie(head->r.acl, &group->member_list) {
@@ -1967,6 +2052,7 @@
 				continue;
 			if (!ccs_flush(head))
 				return false;
+			ccs_print_namespace(head);
 			ccs_set_string(head, ccs_group_name[idx]);
 			ccs_set_string(head, group->group_name->name);
 			if (idx == CCS_PATH_GROUP) {
@@ -2013,7 +2099,10 @@
  */
 static bool ccs_read_policy(struct ccs_io_buffer *head, const int idx)
 {
-	list_for_each_cookie(head->r.acl, &ccs_policy_list[idx]) {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
+	struct list_head *list = &ns->policy_list[idx];
+	list_for_each_cookie(head->r.acl, list) {
 		struct ccs_acl_head *acl =
 			container_of(head->r.acl, typeof(*acl), list);
 		if (acl->is_deleted)
@@ -2028,6 +2117,7 @@
 			{
 				struct ccs_transition_control *ptr =
 					container_of(acl, typeof(*ptr), head);
+				ccs_print_namespace(head);
 				ccs_set_string(head,
 					       ccs_transition_type[ptr->type]);
 				ccs_set_string(head, ptr->program ?
@@ -2041,6 +2131,7 @@
 			{
 				struct ccs_aggregator *ptr =
 					container_of(acl, typeof(*ptr), head);
+				ccs_print_namespace(head);
 				ccs_set_string(head, "aggregator ");
 				ccs_set_string(head, ptr->original_name->name);
 				ccs_set_space(head);
@@ -2052,12 +2143,10 @@
 			{
 				struct ccs_reserved *ptr =
 					container_of(acl, typeof(*ptr), head);
-				const u16 min_port = ptr->min_port;
-				const u16 max_port = ptr->max_port;
+				ccs_print_namespace(head);
 				ccs_set_string(head, "deny_autobind ");
-				ccs_io_printf(head, "%u", min_port);
-				if (min_port != max_port)
-					ccs_io_printf(head, "-%u", max_port);
+				ccs_print_number_union_nospace(head,
+							       &ptr->port);
 			}
 			break;
 		default:
@@ -2080,6 +2169,8 @@
  */
 static void ccs_read_exception(struct ccs_io_buffer *head)
 {
+	struct ccs_policy_namespace *ns = container_of(head->r.ns, typeof(*ns),
+						       namespace_list);
 	if (head->r.eof)
 		return;
 	while (head->r.step < CCS_MAX_POLICY &&
@@ -2096,9 +2187,9 @@
 	       + CCS_MAX_ACL_GROUPS * 2) {
 		head->r.acl_group_index = (head->r.step - CCS_MAX_POLICY
 					   - CCS_MAX_GROUP) / 2;
-		if (!ccs_read_domain2(head,
-				      &ccs_acl_group[head->r.acl_group_index],
-				      head->r.step & 1))
+		if (!ccs_read_domain2(head, &ns->acl_group
+				      [head->r.acl_group_index]
+				      [head->r.step & 1]))
 			return;
 		head->r.step++;
 	}
@@ -2201,7 +2292,8 @@
 	if (symlink)
 		ccs_addprintf(buffer, len, "%s", symlink);
 	ccs_normalize_line(buffer);
-	if (!ccs_write_domain2(buffer, ccs_current_domain(), false))
+	if (!ccs_write_domain2(ccs_current_namespace(), ccs_current_domain()->
+			       acl_info_list, buffer, false))
 		ccs_update_stat(CCS_STAT_POLICY_UPDATES);
 	kfree(buffer);
 }
@@ -2477,9 +2569,9 @@
 
 /* String table for /proc/ccs/stat interface. */
 static const char * const ccs_memory_headers[CCS_MAX_MEMORY_STAT] = {
-	[CCS_MEMORY_POLICY] = "policy:",
-	[CCS_MEMORY_AUDIT]  = "audit log:",
-	[CCS_MEMORY_QUERY]  = "query message:",
+	[CCS_MEMORY_POLICY]     = "policy:",
+	[CCS_MEMORY_AUDIT]      = "audit log:",
+	[CCS_MEMORY_QUERY]      = "query message:",
 };
 
 /* Timestamp counter for last updated. */
@@ -2577,6 +2669,7 @@
 	struct ccs_io_buffer *head = kzalloc(sizeof(*head), CCS_GFP_FLAGS);
 	if (!head)
 		return -ENOMEM;
+	head->original_ns = ccs_current_namespace();
 	mutex_init(&head->io_sem);
 	head->type = type;
 	switch (type) {
@@ -2695,6 +2788,44 @@
 }
 
 /**
+ * ccs_move_namespace_cursor - Print namespace delimiter if needed.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns nothing.
+ */
+static inline void ccs_move_namespace_cursor(struct ccs_io_buffer *head)
+{
+	struct list_head *ns;
+	if (head->type != CCS_EXCEPTIONPOLICY && head->type != CCS_PROFILE)
+		return;
+	/*
+	 * If this is the first read, or reading previous namespace finished
+	 * and has more namespaces to read, update the namespace cursor.
+	 */
+	ns = head->r.ns;
+	if (!ns || (head->r.eof && ns->next != &ccs_namespace_list)) {
+		/* Clearing is OK because ccs_flush() returned true. */
+		memset(&head->r, 0, sizeof(head->r));
+		head->r.ns = ns ? ns->next : ccs_namespace_list.next;
+	}
+}
+
+/**
+ * ccs_has_more_namespace - Check for unread namespaces.
+ *
+ * @head: Pointer to "struct ccs_io_buffer".
+ *
+ * Returns true if we have more entries to print, false otherwise.
+ */
+static inline bool ccs_has_more_namespace(struct ccs_io_buffer *head)
+{
+	return (head->type == CCS_EXCEPTIONPOLICY ||
+		head->type == CCS_PROFILE) && head->r.eof &&
+		head->r.ns->next != &ccs_namespace_list;
+}
+
+/**
  * ccs_read_control - read() for /proc/ccs/ interface.
  *
  * @file:       Pointer to "struct file".
@@ -2720,8 +2851,10 @@
 	idx = ccs_read_lock();
 	if (ccs_flush(head))
 		/* Call the policy handler. */
-		head->read(head);
-	ccs_flush(head);
+		do {
+			ccs_move_namespace_cursor(head);
+			head->read(head);
+		} while (ccs_flush(head) && ccs_has_more_namespace(head));
 	ccs_read_unlock(idx);
 	len = head->read_user_buf - buffer;
 	mutex_unlock(&head->io_sem);
@@ -2752,13 +2885,6 @@
 	if (mutex_lock_interruptible(&head->io_sem))
 		return -EINTR;
 	idx = ccs_read_lock();
-	/* Don't allow updating policies by non manager programs. */
-	if (head->write != ccs_write_pid && head->write != ccs_write_domain &&
-	    head->write != ccs_write_exception && !ccs_manager()) {
-		ccs_read_unlock(idx);
-		mutex_unlock(&head->io_sem);
-		return -EPERM;
-	}
 	/* Read a line and dispatch it to the policy handler. */
 	while (avail_len > 0) {
 		char c;
@@ -2787,15 +2913,68 @@
 		cp0[head->w.avail - 1] = '\0';
 		head->w.avail = 0;
 		ccs_normalize_line(cp0);
+		if (!strcmp(cp0, "reset")) {
+			head->w.ns = head->original_ns;
+			head->w.domain = NULL;
+			memset(&head->r, 0, sizeof(head->r));
+			continue;
+		}
+		/* Don't allow updating policies by non manager programs. */
+		switch (head->type) {
+		case CCS_PROCESS_STATUS:
+			/* This does not write anything. */
+			break;
+		case CCS_DOMAINPOLICY:
+			if (ccs_select_domain(head, cp0))
+				continue;
+			/* fall through */
+		case CCS_EXCEPTIONPOLICY:
+			if (!strcmp(cp0, "select transition_only")) {
+				head->r.print_transition_related_only = true;
+				continue;
+			}
+			/* fall through */
+		default:
+			if (!ccs_manager()) {
+				error = -EPERM;
+				goto out;
+			}
+		}
+		/* Delete request? */
+		head->w.is_delete = !strncmp(cp0, "delete ", 7);
+		if (head->w.is_delete)
+			memmove(cp0, cp0 + 7, strlen(cp0 + 7) + 1);
+		/* Selecting namespace to update. */
+		if (head->type == CCS_EXCEPTIONPOLICY ||
+		    head->type == CCS_PROFILE) {
+			if (*cp0 == '<') {
+				char *cp = strchr(cp0, ' ');
+				if (cp) {
+					*cp++ = '\0';
+					head->w.ns = ccs_assign_namespace(cp0);
+					memmove(cp0, cp, strlen(cp) + 1);
+				} else
+					head->w.ns = NULL;
+			} else
+				head->w.ns = head->original_ns;
+			/* Don't allow updating if namespace is invalid. */
+			if (!head->w.ns) {
+				error = -ENOENT;
+				goto out;
+			}
+		}
 		{
+			/* Do the update. */
 			const int ret = head->write(head);
 			if (ret == -EPERM) {
 				error = -EPERM;
 				break;
 			}
+			/* Do not update statistics if not updated. */
 			if (ret)
 				continue;
 		}
+		/* Update statistics. */
 		switch (head->type) {
 		case CCS_DOMAINPOLICY:
 		case CCS_EXCEPTIONPOLICY:
@@ -2809,6 +2988,7 @@
 			break;
 		}
 	}
+out:
 	ccs_read_unlock(idx);
 	mutex_unlock(&head->io_sem);
 	return error;
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/gc.c	(working copy)
@@ -749,12 +749,12 @@
  *
  * Returns true if some elements are deleted, false otherwise.
  */
-static bool ccs_collect_acl(struct ccs_domain_info *domain)
+static bool ccs_collect_acl(struct list_head *list)
 {
 	struct ccs_acl_info *acl;
 	u8 i;
 	for (i = 0; i < 2; i++) {
-		list_for_each_entry(acl, &domain->acl_info_list[i], list) {
+		list_for_each_entry(acl, &list[i], list) {
 			if (!acl->is_deleted)
 				continue;
 			if (!ccs_add_to_gc(CCS_ID_ACL, &acl->list))
@@ -773,20 +773,15 @@
 {
 	int i;
 	enum ccs_policy_id id;
+	struct ccs_policy_namespace *ns;
 	int idx;
 	if (mutex_lock_interruptible(&ccs_policy_lock))
 		return;
 	idx = ccs_read_lock();
-	for (id = 0; id < CCS_MAX_POLICY; id++)
-		if (!ccs_collect_member(id, &ccs_policy_list[id]))
-			goto unlock;
-	for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
-		if (!ccs_collect_acl(&ccs_acl_group[i]))
-			goto unlock;
 	{
 		struct ccs_domain_info *domain;
 		list_for_each_entry(domain, &ccs_domain_list, list) {
-			if (!ccs_collect_acl(domain))
+			if (!ccs_collect_acl(domain->acl_info_list))
 				goto unlock;
 			if (!domain->is_deleted ||
 			    ccs_domain_used_by_task(domain))
@@ -795,28 +790,39 @@
 				goto unlock;
 		}
 	}
-	for (i = 0; i < CCS_MAX_GROUP; i++) {
-		struct list_head *list = &ccs_group_list[i];
-		struct ccs_group *group;
-		switch (i) {
-		case 0:
-			id = CCS_ID_PATH_GROUP;
-			break;
-		case 1:
-			id = CCS_ID_NUMBER_GROUP;
-			break;
-		default:
-			id = CCS_ID_ADDRESS_GROUP;
-			break;
-		}
-		list_for_each_entry(group, list, head.list) {
-			if (!ccs_collect_member(id, &group->member_list))
+	list_for_each_entry_srcu(ns, &ccs_namespace_list, namespace_list,
+				 &ccs_ss) {
+		for (id = 0; id < CCS_MAX_POLICY; id++)
+			if (!ccs_collect_member(id, &ns->policy_list[id]))
 				goto unlock;
-			if (!list_empty(&group->member_list) ||
-			    atomic_read(&group->head.users))
-				continue;
-			if (!ccs_add_to_gc(CCS_ID_GROUP, &group->head.list))
+		for (i = 0; i < CCS_MAX_ACL_GROUPS; i++)
+			if (!ccs_collect_acl(ns->acl_group[i]))
 				goto unlock;
+		for (i = 0; i < CCS_MAX_GROUP; i++) {
+			struct list_head *list = &ns->group_list[i];
+			struct ccs_group *group;
+			switch (i) {
+			case 0:
+				id = CCS_ID_PATH_GROUP;
+				break;
+			case 1:
+				id = CCS_ID_NUMBER_GROUP;
+				break;
+			default:
+				id = CCS_ID_ADDRESS_GROUP;
+				break;
+			}
+			list_for_each_entry(group, list, head.list) {
+				if (!ccs_collect_member(id,
+							&group->member_list))
+					goto unlock;
+				if (!list_empty(&group->member_list) ||
+				    atomic_read(&group->head.users))
+					continue;
+				if (!ccs_add_to_gc(CCS_ID_GROUP,
+						   &group->head.list))
+					goto unlock;
+			}
 		}
 	}
 	for (i = 0; i < CCS_MAX_LIST + CCS_MAX_HASH; i++) {
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/network.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/network.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/network.c	(working copy)
@@ -343,13 +343,13 @@
 		if (address[0] != '@')
 			return -EINVAL;
 		e.address_type = CCS_IP_ADDRESS_TYPE_ADDRESS_GROUP;
-		e.address.group = ccs_get_group(address + 1,
+		e.address.group = ccs_get_group(param->ns, address + 1,
 						CCS_ADDRESS_GROUP);
 		if (!e.address.group)
 			return -ENOMEM;
 		break;
 	}
-	if (!ccs_parse_number_union(ccs_read_token(param), &e.port))
+	if (!ccs_parse_number_union(param->ns, ccs_read_token(param), &e.port))
 		goto out;
 	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_inet_acl,
 				  ccs_merge_inet_acl);
@@ -386,7 +386,7 @@
 			e.perm |= 1 << type;
 	if (e.protocol == CCS_SOCK_MAX || !e.perm)
 		return -EINVAL;
-	if (!ccs_parse_name_union(ccs_read_token(param), &e.name))
+	if (!ccs_parse_name_union(param->ns, ccs_read_token(param), &e.name))
 		return -EINVAL;
 	error = ccs_update_domain(&e.head, sizeof(e), param, ccs_same_unix_acl,
 				  ccs_merge_unix_acl);
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/group.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/group.c	(revision 5039)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/group.c	(working copy)
@@ -63,13 +63,13 @@
 /**
  * ccs_write_group - Write "struct ccs_path_group"/"struct ccs_number_group"/"struct ccs_address_group" list.
  *
- * @data:      String to parse.
- * @is_delete: True if it is a delete request.
- * @type:      Type of this group.
+ * @param: Pointer to "struct ccs_element_param".
+ * @data:  String to parse.
+ * @type:  Type of this group.
  *
  * Returns 0 on success, negative value otherwise.
  */
-int ccs_write_group(char *data, const bool is_delete, const u8 type)
+int ccs_write_group(struct ccs_element_param *param, char *data, const u8 type)
 {
 	struct ccs_group *group;
 	struct list_head *member;
@@ -77,10 +77,11 @@
 	int error = -EINVAL;
 	if (!ccs_tokenize(data, w, sizeof(w)) || !w[1][0])
 		return -EINVAL;
-	group = ccs_get_group(w[0], type);
+	group = ccs_get_group(param->ns, w[0], type);
 	if (!group)
 		return -ENOMEM;
 	member = &group->member_list;
+	param->list = member;
 	if (type == CCS_PATH_GROUP) {
 		struct ccs_path_group e = { };
 		e.member_name = ccs_get_name(w[1]);
@@ -88,16 +89,21 @@
 			error = -ENOMEM;
 			goto out;
 		}
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_path_group);
+		param->new_entry = &e.head;
+		param->size = sizeof(e);
+		param->check_duplicate = ccs_same_path_group;
+		error = ccs_update_policy(param);
 		ccs_put_name(e.member_name);
 	} else if (type == CCS_NUMBER_GROUP) {
 		struct ccs_number_group e = { };
-		if (w[1][0] == '@' || !ccs_parse_number_union(w[1], &e.number)
+		if (w[1][0] == '@' || !ccs_parse_number_union(param->ns, w[1],
+							      &e.number)
 		    || e.number.values[0] > e.number.values[1])
 			goto out;
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_number_group);
+		param->new_entry = &e.head;
+		param->size = sizeof(e);
+		param->check_duplicate = ccs_same_number_group;
+		error = ccs_update_policy(param);
 		/*
 		 * ccs_put_number_union() is not needed because w[1][0] != '@'.
 		 */
@@ -122,8 +128,10 @@
 		default:
 			goto out_address;
 		}
-		error = ccs_update_policy(&e.head, sizeof(e), is_delete,
-					  member, ccs_same_address_group);
+		param->new_entry = &e.head;
+		param->size = sizeof(e);
+		param->check_duplicate = ccs_same_address_group;
+		error = ccs_update_policy(param);
 out_address:
 		if (e.is_ipv6) {
 			ccs_put_ipv6_address(e.min.ipv6);
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.h
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.h	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.h	(working copy)
@@ -51,9 +51,6 @@
 
 /***** CONSTANTS DEFINITION START *****/
 
-#define CCS_ROOT_NAME                    "<kernel>"
-#define CCS_ROOT_NAME_LEN                (sizeof(CCS_ROOT_NAME) - 1)
-
 #define CCS_PROC_POLICY_DIR              "/proc/ccs/"
 #define CCS_PROC_POLICY_DOMAIN_POLICY    "/proc/ccs/domain_policy"
 #define CCS_PROC_POLICY_DOMAIN_STATUS    "/proc/ccs/.domain_status"
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-checkpolicy.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-checkpolicy.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-checkpolicy.c	(working copy)
@@ -238,17 +238,27 @@
 			pos = eq + 1;
 			if (!strcmp(pos, "NULL"))
 				goto next;
-			if (r_len < 2)
+			if (r_len < 2 || pos[0] != '"' ||
+			    pos[r_len - 1] != '"')
 				goto out;
-			if (pos[0] == '"' && pos[r_len - 1] == '"')
-				goto next;
-			goto out;
+			goto next;
 		} else if (!strcmp(pos, "auto_domain_transition")) {
 			pos = eq + 1;
-			if (r_len < 2)
+			if (r_len < 2 || pos[0] != '"' ||
+			    pos[r_len - 1] != '"')
 				goto out;
-			if (pos[0] == '"' && pos[r_len - 1] == '"')
-				goto next;
+			if (pos[1] != '/')
+				goto out;
+			goto next;
+		} else if (!strcmp(pos, "auto_namespace_transition")) {
+			pos = eq + 1;
+			if (r_len < 2 || pos[0] != '"' ||
+			    pos[r_len - 1] != '"')
+				goto out;
+			pos[r_len - 1] = '\0';
+			if (!ccs_domain_def(pos + 1))
+				goto out;
+			goto next;
 		} else if (!strcmp(pos, "grant_log")) {
 			pos = eq + 1;
 			if (!strcmp(pos, "yes") || !strcmp(pos, "no"))
@@ -662,7 +672,7 @@
 
 static void ccs_check_domain_policy(char *policy)
 {
-	if (!strncmp(policy, "<kernel>", 8)) {
+	if (ccs_domain_def(policy)) {
 		if (!ccs_correct_domain(policy) ||
 		    strlen(policy) >= CCS_MAX_DOMAINNAME_LEN) {
 			printf("%u: ERROR: '%s' is a bad domainname.\n",
@@ -700,8 +710,10 @@
 		{ "address_group ", ccs_check_path, ccs_check_ip_address },
 		{ "aggregator ", ccs_check_path, ccs_check_path },
 		{ "deny_autobind ", ccs_check_port },
+		{ "move_namespace ", ccs_check_path_domain },
 		{ "initialize_domain ", ccs_check_path_domain },
 		{ "keep_domain ", ccs_check_path_domain },
+		{ "no_move_namespace ", ccs_check_path_domain },
 		{ "no_initialize_domain ", ccs_check_path_domain },
 		{ "no_keep_domain ", ccs_check_path_domain },
 		{ "number_group ", ccs_check_path, ccs_check_number },
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.c	(working copy)
@@ -40,7 +40,7 @@
 /* Array of string ACL entries. */
 struct ccs_generic_acl *ccs_gacl_list = NULL;
 /* Length of ccs_generic_list array. */
-int ccs_gacl_list_count = 0;
+static int ccs_gacl_list_count = 0;
 
 /* Policy directory. */
 static const char *ccs_policy_dir = NULL;
@@ -62,6 +62,8 @@
 static unsigned int ccs_current_pid = 0;
 /* Currently active screen's index. */
 enum ccs_screen_type ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
+/* Previously active screen's index. */
+static enum ccs_screen_type ccs_previous_screen = CCS_SCREEN_DOMAIN_LIST;
 /*
  * Array of "initialize_domain"/"no_initialize_domain"/"keep_domain"/
  * "no_keep_domain" entries.
@@ -96,12 +98,18 @@
 /* Start from the first line when showing ACL screen? */
 static _Bool ccs_no_restore_cursor = false;
 
+/* Namespace to use. */
+static char *ccs_current_namespace = NULL;
+static int ccs_current_namespace_len = 0;
+
 /* Domain transition coltrol keywords. */
 static const char *ccs_transition_type[CCS_MAX_TRANSITION_TYPE] = {
-	[CCS_TRANSITION_CONTROL_INITIALIZE] = "initialize_domain ",
+	[CCS_TRANSITION_CONTROL_NAMESPACE]     = "move_namespace ",
+	[CCS_TRANSITION_CONTROL_NO_NAMESPACE]  = "no_move_namespace ",
+	[CCS_TRANSITION_CONTROL_INITIALIZE]    = "initialize_domain ",
 	[CCS_TRANSITION_CONTROL_NO_INITIALIZE] = "no_initialize_domain ",
-	[CCS_TRANSITION_CONTROL_KEEP] = "keep_domain ",
-	[CCS_TRANSITION_CONTROL_NO_KEEP] = "no_keep_domain ",
+	[CCS_TRANSITION_CONTROL_KEEP]          = "keep_domain ",
+	[CCS_TRANSITION_CONTROL_NO_KEEP]       = "no_keep_domain ",
 };
 
 static FILE *ccs_editpolicy_open_write(const char *filename);
@@ -152,6 +160,7 @@
 static void ccs_page_down_key(void);
 static void ccs_page_up_key(void);
 static void ccs_read_domain_and_exception_policy(void);
+static void ccs_read_namespace_list(void);
 static void ccs_read_generic_policy(void);
 static void ccs_resize_window(void);
 static void ccs_set_cursor_pos(const int index);
@@ -375,7 +384,7 @@
 }
 
 /**
- * ccs_add_transition_control_policy - Add "initialize_domain"/"no_initialize_domain"/"keep_domain"/ "no_keep_domain" entries.
+ * ccs_add_transition_control_policy - Add "move_namespace"/"no_move_namespace"/"initialize_domain"/"no_initialize_domain"/"keep_domain"/ "no_keep_domain" entries.
  *
  * @data: Line to parse.
  * @type: One of values in "enum ccs_transition_type".
@@ -425,16 +434,26 @@
 {
 	const struct ccs_transition_control_entry *d_t =
 		ccs_transition_control(domainname, program);
-	if (d_t && d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE) {
+	if (d_t && (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE ||
+		    d_t->type == CCS_TRANSITION_CONTROL_NAMESPACE)) {
 		char *line;
 		int source;
 		ccs_get();
-		line = ccs_shprintf("%s %s", domainname->name, program);
+		if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE)
+			line = ccs_shprintf("%s %s", domainname->name,
+					    program);
+		else
+			line = ccs_shprintf("%s <%s>", domainname->name,
+					    program);
 		ccs_normalize_line(line);
 		source = ccs_assign_domain(&ccs_dp, line, true, false);
 		if (source == EOF)
 			ccs_out_of_memory();
-		line = ccs_shprintf(CCS_ROOT_NAME " %s", program);
+		if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE)
+			line = ccs_shprintf("%s %s", ccs_current_namespace,
+					    program);
+		else
+			line = ccs_shprintf("<%s>", program);
 		ccs_dp.list[source].target_domainname = strdup(line);
 		if (!ccs_dp.list[source].target_domainname)
 			ccs_out_of_memory();
@@ -465,12 +484,16 @@
  *
  * @index: Index in the domain policy.
  *
- * Returns index in the domain policy if found, EOF otherwise.
+ * Returns index in the domain policy if found, -2 if namespace jump,
+ * EOF otherwise.
  */
 static int ccs_find_target_domain(const int index)
 {
-	return ccs_find_domain(&ccs_dp, ccs_dp.list[index].target_domainname,
-			       false, false);
+	const char *cp = ccs_dp.list[index].target_domainname;
+	const char *sp = ccs_get_last_word(cp);
+	if (*sp == '<' && strcmp(ccs_current_namespace, sp))
+		return -2;
+	return ccs_find_domain(&ccs_dp, cp, false, false);
 }
 
 /**
@@ -544,8 +567,10 @@
 	if (redirect_index >= 0)
 		line = ccs_shprintf(" ( -> %d )",
 				    ccs_dp.list[redirect_index].number);
+	else if (redirect_index == EOF)
+                line = ccs_shprintf(" ( -> Not Found )");
 	else
-		line = ccs_shprintf(" ( -> Not Found )");
+		line = ccs_shprintf(" ( -> Namespace jump )");
 	printw("%s", ccs_eat(line));
 	tmp_col += strlen(line);
 	ccs_put();
@@ -972,6 +997,14 @@
 			if (ptr->program &&
 			    strcmp(ptr->program->name, program))
 				continue;
+			if (type == CCS_TRANSITION_CONTROL_NO_NAMESPACE) {
+				/*
+				 * Do not check for move_namespace if
+				 * no_move_namespace matched.
+				 */
+				type = CCS_TRANSITION_CONTROL_NO_INITIALIZE;
+				goto next;
+			}
 			if (type == CCS_TRANSITION_CONTROL_NO_INITIALIZE) {
 				/*
 				 * Do not check for initialize_domain if
@@ -980,7 +1013,8 @@
 				type = CCS_TRANSITION_CONTROL_NO_KEEP;
 				goto next;
 			}
-			if (type == CCS_TRANSITION_CONTROL_INITIALIZE ||
+			if (type == CCS_TRANSITION_CONTROL_NAMESPACE ||
+			    type == CCS_TRANSITION_CONTROL_INITIALIZE ||
 			    type == CCS_TRANSITION_CONTROL_KEEP)
 				return ptr;
 			else
@@ -1031,6 +1065,81 @@
 }
 
 /**
+ * ccs_is_current_namespace - Check namespace.
+ *
+ * @line: Line to check namespace.
+ *
+ * Returns true if this line deals current namespace, false otherwise.
+ */
+static _Bool ccs_is_current_namespace(const char *line)
+{
+	return !strncmp(line, ccs_current_namespace, ccs_current_namespace_len)
+		&& (line[ccs_current_namespace_len] == ' ' ||
+		    !line[ccs_current_namespace_len]);
+}
+
+static void ccs_add_generic_entry(const char *line, const enum
+				  ccs_editpolicy_directives directive)
+{
+	int i;
+	char *cp;
+	for (i = 0; i < ccs_gacl_list_count; i++)
+		if (!strcmp(line, ccs_gacl_list[i].operand))
+			return;
+	ccs_gacl_list = realloc(ccs_gacl_list,
+				(ccs_gacl_list_count + 1) *
+				sizeof(struct ccs_generic_acl));
+	if (!ccs_gacl_list)
+		ccs_out_of_memory();
+	cp = strdup(line);
+	if (!cp)
+		ccs_out_of_memory();
+	ccs_gacl_list[ccs_gacl_list_count].directive = directive;
+	ccs_gacl_list[ccs_gacl_list_count].selected = 0;
+	ccs_gacl_list[ccs_gacl_list_count++].operand = cp;
+}
+
+/**
+ * ccs_read_namespace_list - Read namespace list.
+ *
+ * Returns nothing.
+ */
+static void ccs_read_namespace_list(void)
+{
+	u8 i;
+	static const char *files[3] = { CCS_PROC_POLICY_PROFILE,
+					CCS_PROC_POLICY_EXCEPTION_POLICY,
+					CCS_PROC_POLICY_DOMAIN_POLICY };
+	while (ccs_gacl_list_count)
+		free((void *) ccs_gacl_list[--ccs_gacl_list_count].operand);
+	ccs_add_generic_entry("<kernel>", CCS_DIRECTIVE_NONE);
+	for (i = 0; i < 3; i++) {
+		FILE *fp = ccs_editpolicy_open_read(files[i]);
+		if (!fp)
+			continue;
+		ccs_get();
+		while (true) {
+			char *line = ccs_freadline_unpack(fp);
+			char *cp;
+			if (!line)
+				break;
+			cp = strchr(line, ' ');
+			if (cp)
+				*cp = '\0';
+			else if (i != 2)
+				continue;
+			if (!ccs_domain_def(line))
+				continue;
+			ccs_add_generic_entry(line, CCS_DIRECTIVE_NONE);
+		}
+		ccs_put();
+		fclose(fp);
+	}
+	qsort(ccs_gacl_list, ccs_gacl_list_count,
+	      sizeof(struct ccs_generic_acl), ccs_string_acl_compare);
+}
+
+/**
  * ccs_read_generic_policy - Read policy data other than domain policy.
  *
  * Returns nothing.
@@ -1040,9 +1149,7 @@
 	FILE *fp = NULL;
 	_Bool flag = false;
 	while (ccs_gacl_list_count)
-		free((void *)
-		     ccs_gacl_list[--ccs_gacl_list_count].
-		     operand);
+		free((void *) ccs_gacl_list[--ccs_gacl_list_count].operand);
 	if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
 		if (ccs_network_mode)
 			/* We can read after write. */
@@ -1088,6 +1195,14 @@
 			if (!line[0])
 				continue;
 		}
+		if ((ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST ||
+		    ccs_current_screen == CCS_SCREEN_PROFILE_LIST) &&
+		    *line == '<') {
+			char *cp = strchr(line, ' ');
+			if (!cp++ || !ccs_is_current_namespace(line))
+				continue;
+			memmove(line, cp, strlen(cp) + 1);
+		}
 		switch (ccs_current_screen) {
 		case CCS_SCREEN_EXCEPTION_LIST:
 		case CCS_SCREEN_ACL_LIST:
@@ -1108,20 +1223,7 @@
 			directive = CCS_DIRECTIVE_NONE;
 			break;
 		}
-		ccs_gacl_list =
-			realloc(ccs_gacl_list,
-				(ccs_gacl_list_count + 1) *
-				sizeof(struct ccs_generic_acl));
-		if (!ccs_gacl_list)
-			ccs_out_of_memory();
-		cp = strdup(line);
-		if (!cp)
-			ccs_out_of_memory();
-		ccs_gacl_list[ccs_gacl_list_count].directive =
-			directive;
-		ccs_gacl_list[ccs_gacl_list_count].selected = 0;
-		ccs_gacl_list[ccs_gacl_list_count++].operand =
-			cp;
+		ccs_add_generic_entry(line, directive);
 	}
 	ccs_put();
 	ccs_freadline_raw = false;
@@ -1281,10 +1383,16 @@
 	static char domainname[4096];
 	int source;
 	char *cp = strrchr(line, ' ');
-	if (!cp || strncmp(cp, " auto_domain_transition=\"", 25))
+	if (!cp)
 		return;
-	*cp = '\0';
-	cp += 25;
+	if (!strncmp(cp, " auto_domain_transition=\"", 25)) {
+		*cp = '\0';
+		cp += 25;
+	} else if (!strncmp(cp, " auto_namespace_transition=\"", 28)) {
+		*cp = '\0';
+		cp += 28;
+	} else
+		return;
 	source = strlen(cp);
 	if (!source)
 		return;
@@ -1395,19 +1503,13 @@
 static void ccs_parse_exception_line(char *line, const int max_index)
 {
 	unsigned int group;
-	if (ccs_str_starts(line, "initialize_domain "))
-		ccs_add_transition_control_policy
-			(line, CCS_TRANSITION_CONTROL_INITIALIZE);
-	else if (ccs_str_starts(line, "no_initialize_domain "))
-		ccs_add_transition_control_policy
-			(line, CCS_TRANSITION_CONTROL_NO_INITIALIZE);
-	else if (ccs_str_starts(line, "keep_domain "))
-		ccs_add_transition_control_policy
-			(line, CCS_TRANSITION_CONTROL_KEEP);
-	else if (ccs_str_starts(line, "no_keep_domain "))
-		ccs_add_transition_control_policy
-			(line, CCS_TRANSITION_CONTROL_NO_KEEP);
-	else if (ccs_str_starts(line, "path_group "))
+	for (group = 0; group < CCS_MAX_TRANSITION_TYPE; group++) {
+		if (!ccs_str_starts(line, ccs_transition_type[group]))
+			continue;
+		ccs_add_transition_control_policy(line, group);
+		return;
+	}
+	if (ccs_str_starts(line, "path_group "))
 		ccs_add_path_group_policy(line, false);
 	else if (ccs_str_starts(line, "address_group "))
 		ccs_add_address_group_policy(line, false);
@@ -1451,7 +1553,6 @@
 	ccs_clear_domain_policy(&ccs_dp);
 	ccs_transition_control_list_len = 0;
 	ccs_editpolicy_clear_groups();
-	ccs_assign_domain(&ccs_dp, CCS_ROOT_NAME, false, false);
 
 	/* Load all domain transition related entries. */
 	fp = NULL;
@@ -1476,7 +1577,11 @@
 			char *line = ccs_freadline_unpack(fp);
 			if (!line)
 				break;
-			if (ccs_domain_def(line)) {
+			if (*line == '<') {
+				if (!ccs_is_current_namespace(line)) {
+					index = EOF;
+					continue;
+				}
 				index = ccs_assign_domain(&ccs_dp, line, false,
 							  false);
 				continue;
@@ -1517,6 +1622,12 @@
 			char *line = ccs_freadline_unpack(fp);
 			if (!line)
 				break;
+			if (*line == '<') {
+				char *cp = strchr(line, ' ');
+				if (!cp++ || !ccs_is_current_namespace(line))
+					continue;
+				memmove(line, cp, strlen(cp) + 1);
+			}
 			ccs_parse_exception_line(line, max_index);
 		}
 		ccs_put();
@@ -1550,9 +1661,9 @@
 			d_t = ccs_transition_control(&parent, cp);
 			if (!d_t)
 				continue;
-			/* Initializer under <kernel> is reachable. */
+			/* Initializer under root of namespace is reachable. */
 			if (d_t->type == CCS_TRANSITION_CONTROL_INITIALIZE &&
-			    parent.total_len == CCS_ROOT_NAME_LEN)
+			    !strchr(parent.name, ' '))
 				break;
 			ccs_dp.list[index].d_t = d_t;
 			continue;
@@ -1611,10 +1722,10 @@
 			= ccs_dp.list[index].string_ptr;
 		const int max_count = ccs_dp.list[index].string_count;
 		/*
-		 * Don't create source domain under <kernel> because
-		 * they will become target domains.
+		 * Don't create source domains under root of namespace
+		 * because they will become target domains.
 		 */
-		if (domainname->total_len == CCS_ROOT_NAME_LEN)
+		if (!strchr(domainname->name, ' '))
 			continue;
 		for (i = 0; i < max_count; i++) {
 			const struct ccs_path_info *cp = string_ptr[i];
@@ -1986,8 +2097,12 @@
 		const int index = ccs_editpolicy_get_current();
 		ccs_get();
 		ccs_eat_col = ptr->x;
-		line = ccs_shprintf("%s",
-				    ccs_eat(ccs_domain_name(&ccs_dp, index)));
+		if (index >= 0)
+			line = ccs_shprintf("%s",
+					    ccs_eat(ccs_domain_name(&ccs_dp,
+								    index)));
+		else
+			line = ccs_shprintf("%s", ccs_current_namespace);
 		if (ccs_window_width < strlen(line))
 			line[ccs_window_width] = '\0';
 		move(2, 0);
@@ -1997,6 +2112,21 @@
 		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
 		ccs_put();
 	}
+	if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST ||
+	    ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
+		char *line;
+		ccs_get();
+		ccs_eat_col = ptr->x;
+		line = ccs_shprintf("%s", ccs_current_namespace);
+		if (ccs_window_width < strlen(line))
+			line[ccs_window_width] = '\0';
+		move(2, 0);
+		clrtoeol();
+		ccs_editpolicy_attr_change(A_REVERSE, true);  /* add color */
+		printw("%s", line);
+		ccs_editpolicy_attr_change(A_REVERSE, false); /* add color */
+		ccs_put();
+	}
 	move(CCS_HEADER_LINES + ptr->y, 0);
 	ccs_editpolicy_line_draw();     /* add color */
 	refresh();
@@ -2203,7 +2333,9 @@
 			if (!ccs_gacl_list[i].selected)
 				continue;
 			directive = ccs_gacl_list[i].directive;
-			fprintf(fp, "delete %s %s\n",
+			fprintf(fp, "delete %s %s %s\n",
+				ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST
+				? ccs_current_namespace : "",
 				ccs_directives[directive].original,
 				ccs_gacl_list[i].operand);
 		}
@@ -2252,14 +2384,17 @@
 			fprintf(fp, "select domain=%s\n", ccs_current_domain);
 		/* Fall through. */
 	case CCS_SCREEN_EXCEPTION_LIST:
+		if (ccs_current_screen == CCS_SCREEN_EXCEPTION_LIST)
+			fprintf(fp, "%s ", ccs_current_namespace);
 		directive = ccs_find_directive(false, line);
 		if (directive != CCS_DIRECTIVE_NONE)
-			fprintf(fp, "%s ",
-				ccs_directives[directive].original);
+			fprintf(fp, "%s ", ccs_directives[directive].original);
 		break;
 	case CCS_SCREEN_PROFILE_LIST:
 		if (!strchr(line, '='))
-			fprintf(fp, "%s-COMMENT=\n", line);
+			fprintf(fp, "%s %s-COMMENT=\n", ccs_current_namespace,
+				line);
+		fprintf(fp, "%s ", ccs_current_namespace);
 		break;
 	default:
 		break;
@@ -2445,6 +2580,7 @@
 		if (cp)
 			*cp = '\0';
 		directive = ccs_gacl_list[index].directive;
+		fprintf(fp, "%s ", ccs_current_namespace);
 		if (directive < 256)
 			fprintf(fp, "%u-", directive);
 		fprintf(fp, "%s=%s\n", buf, line);
@@ -2501,27 +2637,50 @@
  *
  * @current: Index in the domain policy.
  *
- * Returns true if next window is ACL list, false otherwise.
+ * Returns true if next window is ACL list or namespace list, false otherwise.
  */
 static _Bool ccs_select_acl_window(const int current)
 {
 	char *old_domain;
-	if (ccs_current_screen != CCS_SCREEN_DOMAIN_LIST || current == EOF)
+	if (current == EOF)
 		return false;
+	if (ccs_current_screen == CCS_SCREEN_NAMESPACE_LIST) {
+		free(ccs_current_namespace);
+		ccs_current_namespace = strdup(ccs_gacl_list[current].operand);
+		if (!ccs_current_namespace)
+			ccs_out_of_memory();
+		ccs_current_namespace_len = strlen(ccs_current_namespace);
+		ccs_current_screen = ccs_previous_screen;
+		return true;
+	}
+	if (ccs_current_screen != CCS_SCREEN_DOMAIN_LIST)
+		return false;
 	ccs_current_pid = 0;
 	if (ccs_domain_sort_type) {
 		ccs_current_pid = ccs_task_list[current].pid;
 	} else if (ccs_initializer_source(current)) {
 		struct ccs_screen *ptr = &ccs_screen[ccs_current_screen];
 		const int redirect_index = ccs_find_target_domain(current);
-		if (redirect_index == EOF)
-			return false;
-		ptr->current = redirect_index - ptr->y;
-		while (ptr->current < 0) {
-			ptr->current++;
-			ptr->y--;
+		if (redirect_index >= 0) {
+			ptr->current = redirect_index - ptr->y;
+			while (ptr->current < 0) {
+				ptr->current++;
+				ptr->y--;
+			}
+			ccs_show_list();
 		}
-		ccs_show_list();
+		if (redirect_index == -2) {
+			free(ccs_current_namespace);
+			ccs_current_namespace =
+				strdup(ccs_get_last_word(ccs_dp.list[current].
+							 target_domainname));
+			if (!ccs_current_namespace)
+				ccs_out_of_memory();
+			ccs_current_namespace_len =
+				strlen(ccs_current_namespace);
+			ccs_current_screen = CCS_SCREEN_DOMAIN_LIST;
+			return true;
+		}
 		return false;
 	} else if (ccs_deleted_domain(current)) {
 		return false;
@@ -2536,6 +2695,7 @@
 	ccs_no_restore_cursor = old_domain &&
 		strcmp(old_domain, ccs_current_domain);
 	free(old_domain);
+	ccs_current_screen = CCS_SCREEN_ACL_LIST;
 	return true;
 }
 
@@ -2557,6 +2717,7 @@
 		printw("a     <<< Domain Policy Editor >>>\n");
 	printw("p     <<< Profile Editor >>>\n");
 	printw("m     <<< Manager Policy Editor >>>\n");
+	printw("n     <<< Namespace Selector >>>\n");
 	if (!ccs_offline_mode) {
 		/* printw("i     <<< Interactive Enforcing Mode >>>\n"); */
 		printw("s     <<< Statistics >>>\n");
@@ -2572,11 +2733,15 @@
 			return CCS_SCREEN_DOMAIN_LIST;
 		if (c == 'A' || c == 'a')
 			if (ccs_select_acl_window(current))
-				return CCS_SCREEN_ACL_LIST;
+				return ccs_current_screen;
 		if (c == 'P' || c == 'p')
 			return CCS_SCREEN_PROFILE_LIST;
 		if (c == 'M' || c == 'm')
 			return CCS_SCREEN_MANAGER_LIST;
+		if (c == 'N' || c == 'n') {
+			ccs_previous_screen = ccs_current_screen;
+			return CCS_SCREEN_NAMESPACE_LIST;
+		}
 		if (!ccs_offline_mode) {
 			/*
 			if (c == 'I' || c == 'i')
@@ -2684,9 +2849,14 @@
 	} else if (ccs_current_screen == CCS_SCREEN_ACL_LIST) {
 		ccs_policy_file = CCS_PROC_POLICY_DOMAIN_POLICY;
 		ccs_list_caption = "Domain Policy Editor";
+		/*
 	} else if (ccs_current_screen == CCS_SCREEN_QUERY_LIST) {
 		ccs_policy_file = CCS_PROC_POLICY_QUERY;
 		ccs_list_caption = "Interactive Enforcing Mode";
+		*/
+	} else if (ccs_current_screen == CCS_SCREEN_NAMESPACE_LIST) {
+		ccs_policy_file = CCS_PROC_POLICY_DOMAIN_STATUS;
+		ccs_list_caption = "Namespace Selector";
 	} else if (ccs_current_screen == CCS_SCREEN_PROFILE_LIST) {
 		ccs_policy_file = CCS_PROC_POLICY_PROFILE;
 		ccs_list_caption = "Profile Editor";
@@ -2718,6 +2888,9 @@
 			ccs_read_process_list(true);
 			ccs_adjust_cursor_pos(ccs_task_list_len);
 		}
+	} else if (ccs_current_screen == CCS_SCREEN_NAMESPACE_LIST) {
+		ccs_read_namespace_list();
+		ccs_adjust_cursor_pos(ccs_gacl_list_count);
 	} else {
 		ccs_read_generic_policy();
 		ccs_adjust_cursor_pos(ccs_gacl_list_count);
@@ -2833,6 +3006,7 @@
 			case CCS_SCREEN_ACL_LIST:
 			case CCS_SCREEN_PROFILE_LIST:
 			case CCS_SCREEN_MANAGER_LIST:
+			case CCS_SCREEN_NAMESPACE_LIST:
 				ccs_add_entry();
 				goto start;
 			default:
@@ -2842,7 +3016,7 @@
 		case '\r':
 		case '\n':
 			if (ccs_select_acl_window(current))
-				return CCS_SCREEN_ACL_LIST;
+				return ccs_current_screen;
 			break;
 		case 's':
 		case 'S':
@@ -2965,6 +3139,11 @@
 				goto usage;
 			ccs_policy_dir = ptr;
 			ccs_offline_mode = true;
+		} else if (*ptr == '<') {
+			if (ccs_current_namespace || strchr(ptr, ' ') ||
+			    !ccs_domain_def(ptr))
+				goto usage;
+			ccs_current_namespace = strdup(ptr);
 		} else if (cp) {
 			*cp++ = '\0';
 			if (ccs_network_mode || ccs_offline_mode)
@@ -2990,12 +3169,17 @@
 			 != 1) {
 usage:
 			printf("Usage: %s [e|d|p|m|s] [readonly] "
-			       "[refresh=interval] "
+			       "[refresh=interval] [<namespace>]"
 			       "[{policy_dir|remote_ip:remote_port}]\n",
 			       argv[0]);
 			exit(1);
 		}
 	}
+	if (!ccs_current_namespace)
+		ccs_current_namespace = strdup("<kernel>");
+	if (!ccs_current_namespace)
+		goto usage;
+	ccs_current_namespace_len = strlen(ccs_current_namespace);
 }
 
 /**
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_optimizer.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_optimizer.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_optimizer.c	(working copy)
@@ -237,8 +237,10 @@
 		if (!cp)
 			return;
 		if (index == CCS_DIRECTIVE_IPC_SIGNAL && i == 1 &&
-		    !strncmp(buffer, "<kernel>", 8)) {
-			cp = buffer + 8;
+		    ccs_domain_def(buffer)) {
+			cp = strchr(buffer, ' ');
+			if (!cp)
+				return;
 			while (*cp) {
 				if (*cp++ != ' ' || *cp++ == '/')
 					continue;
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_offline.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_offline.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_offline.c	(working copy)
@@ -94,7 +94,7 @@
 	memset(&ccs_dp, 0, sizeof(ccs_dp));
 	memset(&mp, 0, sizeof(mp));
 	ccs_get();
-	ccs_assign_domain(&ccs_dp, CCS_ROOT_NAME, false, false);
+	ccs_assign_domain(&ccs_dp, "<kernel>", false, false);
 	while (true) {
 		FILE *fp;
 		struct msghdr msg;
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_keyword.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_keyword.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy_keyword.c	(working copy)
@@ -314,11 +314,14 @@
 	[CCS_DIRECTIVE_IPC_SIGNAL]    = { "ipc signal", NULL, 0, 0 },
 	[CCS_DIRECTIVE_KEEP_DOMAIN]   = { "keep_domain", NULL, 0, 0 },
 	[CCS_DIRECTIVE_MISC_ENV]      = { "misc env", NULL, 0, 0 },
+	[CCS_DIRECTIVE_MOVE_NAMESPACE] = { "move_namespace", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NETWORK_INET]  = { "network inet", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NETWORK_UNIX]  = { "network unix", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NONE]          = { "", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN]
 	= { "no_initialize_domain", NULL, 0, 0 },
+	[CCS_DIRECTIVE_NO_MOVE_NAMESPACE]
+	= { "no_move_namespace", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NO_KEEP_DOMAIN] = { "no_keep_domain", NULL, 0, 0 },
 	[CCS_DIRECTIVE_NUMBER_GROUP]  = { "number_group", NULL, 0, 0 },
 	[CCS_DIRECTIVE_PATH_GROUP]    = { "path_group", NULL, 0, 0 },
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.h
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.h	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/editpolicy.h	(working copy)
@@ -29,13 +29,16 @@
 	CCS_SCREEN_ACL_LIST,
 	CCS_SCREEN_PROFILE_LIST,
 	CCS_SCREEN_MANAGER_LIST,
-	CCS_SCREEN_QUERY_LIST,
+	/* CCS_SCREEN_QUERY_LIST, */
+	CCS_SCREEN_NAMESPACE_LIST,
 	CCS_SCREEN_STAT_LIST,
 	CCS_MAXSCREEN
 };
 
 enum ccs_transition_type {
 	/* Do not change this order, */
+	CCS_TRANSITION_CONTROL_NO_NAMESPACE,
+	CCS_TRANSITION_CONTROL_NAMESPACE,
 	CCS_TRANSITION_CONTROL_NO_INITIALIZE,
 	CCS_TRANSITION_CONTROL_INITIALIZE,
 	CCS_TRANSITION_CONTROL_NO_KEEP,
@@ -334,9 +337,11 @@
 	CCS_DIRECTIVE_IPC_SIGNAL,
 	CCS_DIRECTIVE_KEEP_DOMAIN,
 	CCS_DIRECTIVE_MISC_ENV,
+	CCS_DIRECTIVE_MOVE_NAMESPACE,
 	CCS_DIRECTIVE_NETWORK_INET,
 	CCS_DIRECTIVE_NETWORK_UNIX,
 	CCS_DIRECTIVE_NO_INITIALIZE_DOMAIN,
+	CCS_DIRECTIVE_NO_MOVE_NAMESPACE,
 	CCS_DIRECTIVE_NO_KEEP_DOMAIN,
 	CCS_DIRECTIVE_NUMBER_GROUP,
 	CCS_DIRECTIVE_PATH_GROUP,
@@ -441,7 +446,6 @@
 void ccs_editpolicy_sttr_save(void);
 
 extern enum ccs_screen_type ccs_current_screen;
-extern int ccs_gacl_list_count;
 extern int ccs_list_item_count;
 extern int ccs_path_group_list_len;
 extern int ccs_persistent_fd;
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-findtemp.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-findtemp.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-findtemp.c	(working copy)
@@ -38,8 +38,7 @@
 				char *cp = strchr(buffer, '\n');
 				if (cp)
 					*cp = '\0';
-				if (!strncmp(buffer, "<kernel>", 8) &&
-				    (buffer[8] == ' ' || !buffer[8])) {
+				if (ccs_domain_def(buffer)) {
 					free(domain);
 					domain = strdup(buffer);
 					if (!domain)
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccstools.c	(working copy)
@@ -286,22 +286,6 @@
 }
 
 /**
- * ccs_domain_def - Check whether the given token can be a domainname.
- *
- * @domainname: The token to check.
- *
- * Returns true if @domainname possibly be a domainname, false otherwise.
- *
- * Note that this function in kernel source checks only !strncmp() part.
- */
-_Bool ccs_domain_def(const char *domainname)
-{
-	return !strncmp(domainname, CCS_ROOT_NAME, CCS_ROOT_NAME_LEN) &&
-		(domainname[CCS_ROOT_NAME_LEN] == '\0'
-		 || domainname[CCS_ROOT_NAME_LEN] == ' ');
-}
-
-/**
  * ccs_fprintf_encoded - fprintf() using TOMOYO's escape rules.
  *
  * @fp:       Pointer to "FILE".
@@ -481,6 +465,30 @@
 }
 
 /**
+ * ccs_domain_def - Check whether the given token can be a domainname.
+ *
+ * @buffer: The token to check.
+ *
+ * Returns true if @buffer possibly be a domainname, false otherwise.
+ */
+_Bool ccs_domain_def(const char *buffer)
+{
+	const char *cp;
+	int len;
+	       if (*buffer != '<')
+		       return false;
+	       cp = strchr(buffer, ' ');
+	       if (!cp)
+		       len = strlen(buffer);
+	       else
+		       len = cp - buffer;
+	       if (buffer[len - 1] != '>' ||
+		   !ccs_correct_word2(buffer + 1, len - 2))
+		       return false;
+	       return true;
+}
+
+/**
  * ccs_correct_domain - Check whether the given domainname follows the naming rules.
  *
  * @domainname: The domainname to check.
@@ -489,14 +497,11 @@
  */
 _Bool ccs_correct_domain(const char *domainname)
 {
-	if (!domainname || strncmp(domainname, CCS_ROOT_NAME,
-				   CCS_ROOT_NAME_LEN))
-		goto out;
-	domainname += CCS_ROOT_NAME_LEN;
-	if (!*domainname)
+	if (!domainname || !ccs_domain_def(domainname))
+		return false;
+	domainname = strchr(domainname, ' ');
+	if (!domainname++)
 		return true;
-	if (*domainname++ != ' ')
-		goto out;
 	while (1) {
 		const char *cp = strchr(domainname, ' ');
 		if (!cp)
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-domainmatch.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-domainmatch.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-domainmatch.c	(working copy)
@@ -43,8 +43,7 @@
 		char *cp = strchr(buffer, '\n');
 		if (cp)
 			*cp = '\0';
-		if (!strncmp(buffer, "<kernel>", 8) &&
-		    (buffer[8] == ' ' || !buffer[8])) {
+		if (ccs_domain_def(buffer)) {
 			free(domain);
 			domain = strdup(buffer);
 			if (!domain)
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-patternize.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-patternize.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-patternize.c	(working copy)
@@ -514,7 +514,7 @@
 		char *sp = ccs_freadline_unpack(stdin);
 		if (!sp)
 			break;
-		if (!strncmp(sp, "<kernel>", 8) && (!sp[8] || sp[8] == ' ')) {
+		if (ccs_domain_def(sp)) {
 			free(ccs_current_domainname);
 			ccs_current_domainname = strdup(sp);
 			printf("%s\n", sp);
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/Makefile
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/Makefile	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/Makefile	(working copy)
@@ -15,8 +15,8 @@
 	sleep 10
 
 libccstools.so: ccstools.c ccstools.h
-	$(CC) $(CFLAGS) -fPIC ccstools.c -shared -Wl,-soname,libccstools.so.1 -o libccstools.so.1.0.4
-	ln -sf libccstools.so.1.0.4 libccstools.so
+	$(CC) $(CFLAGS) -fPIC ccstools.c -shared -Wl,-soname,libccstools.so.1 -o libccstools.so.1.0.5
+	ln -sf libccstools.so.1.0.5 libccstools.so
 
 .c:
 	$(CC) $(CFLAGS) -o $@ -lccstools -L. $<
@@ -29,8 +29,8 @@
 
 install: all
 	mkdir -p -m 0755 $(INSTALLDIR)$(USRLIBDIR)
-	$(INSTALL) -m 0755 libccstools.so.1.0.4 $(INSTALLDIR)$(USRLIBDIR)
-	ln -sf libccstools.so.1.0.4 $(INSTALLDIR)$(USRLIBDIR)/libccstools.so.1
+	$(INSTALL) -m 0755 libccstools.so.1.0.5 $(INSTALLDIR)$(USRLIBDIR)
+	ln -sf libccstools.so.1.0.5 $(INSTALLDIR)$(USRLIBDIR)/libccstools.so.1
 ifeq ($(INSTALLDIR),)
 	ldconfig || true
 endif
Index: trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/init_policy.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/init_policy.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/init_policy.c	(working copy)
@@ -1277,9 +1277,11 @@
 "keyword_alias ipc signal                    = ipc signal\n"
 "keyword_alias keep_domain                   = keep_domain\n"
 "keyword_alias misc env                      = misc env\n"
+"keyword_alias move_namespace                = move_namespace\n"
 "keyword_alias network inet                  = network inet\n"
 "keyword_alias network unix                  = network unix\n"
 "keyword_alias no_initialize_domain          = no_initialize_domain\n"
+"keyword_alias no_move_namespace             = no_move_namespace\n"
 "keyword_alias no_keep_domain                = no_keep_domain\n"
 "keyword_alias number_group                  = number_group\n"
 "keyword_alias path_group                    = path_group\n"
@@ -1417,7 +1419,7 @@
 "# This file contains rewriting rules used by ccs-patternize command.\n"
 "\n"
 "# Domain policy consists with domain declaration lines (which start with\n"
-"# <kernel> ) and acl declaration lines (which do not start with <kernel> ).\n"
+"# '<' ,) and acl declaration lines (which do not start with '<' ).\n"
 "# You can refer the former using 'domain' keyword and the latter using 'acl'"
 "\n"
 "# keyword.\n"
Index: trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/convert-audit-log.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/convert-audit-log.c	(revision 5039)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_lib_ccs/convert-audit-log.c	(working copy)
@@ -100,6 +100,7 @@
 
 int main(int argc, char *argv[])
 {
+	char *namespace = NULL;
 	char *domainname = NULL;
 	memset(buffer, 0, sizeof(buffer));
 	if (argc > 1) {
@@ -125,8 +126,12 @@
 		else if (!strncmp(buffer, "symlink.target=", 15)) {
 			realloc_buffer(strlen(buffer) + 2);
 			cond_len += sprintf(cond + cond_len, " %s", buffer);
-		} else if (!strcmp(buffer, "<kernel>")) {
+		} else if (buffer[0] == '<' /* ccs_domain_def(buffer) */) {
 			char *cp;
+			free(namespace);
+			namespace = strdup(buffer);
+			if (!namespace)
+				break;
 			if (!fgets(buffer, sizeof(buffer) - 1, stdin) ||
 			    !strchr(buffer, '\n'))
 				break;
@@ -145,7 +150,7 @@
 				cond_len = 0;
 				continue;
 			}
-			printf("<kernel>%s", domainname);
+			printf("%s%s", namespace, domainname);
 			printf("%s", buffer);
 			if (cond_len) {
 				printf("%s", cond);
@@ -155,6 +160,7 @@
 		}
 	}
 	free(domainname);
+	free(namespace);
 	free(cond);
 	return 0;
 }
