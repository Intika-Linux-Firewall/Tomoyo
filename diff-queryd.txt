Index: trunk/2.5.x/tomoyo-tools/usr_sbin/tomoyo-queryd.c
===================================================================
--- trunk/2.5.x/tomoyo-tools/usr_sbin/tomoyo-queryd.c	(revision 5548)
+++ trunk/2.5.x/tomoyo-tools/usr_sbin/tomoyo-queryd.c	(working copy)
@@ -107,7 +107,7 @@
 	if (strstr(ccs_buffer, "\n#"))
 		goto not_domain_query;
 	memset(pidbuf, 0, sizeof(pidbuf));
-	snprintf(pidbuf, sizeof(pidbuf) - 1, "select global-pid=%u\n", pid);
+	snprintf(pidbuf, sizeof(pidbuf) - 1, "select Q=%u\n", serial);
 	ccs_printw("Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy "
 		   "and retry):");
 	while (true) {
Index: trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c
===================================================================
--- trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(revision 5548)
+++ trunk/1.8.x/ccs-patch/security/ccsecurity/policy_io.c	(working copy)
@@ -992,6 +992,8 @@
 	return found;
 }
 
+static struct ccs_domain_info *ccs_find_domain_by_qid(unsigned int serial);
+
 /**
  * ccs_select_domain - Parse select command.
  *
@@ -1029,6 +1031,8 @@
 	} else if (!strncmp(data, "domain=", 7)) {
 		if (*(data + 7) == '<')
 			domain = ccs_find_domain(data + 7);
+	} else if (sscanf(data, "Q=%u", &pid) == 1) {
+		domain = ccs_find_domain_by_qid(pid);
 	} else
 		return false;
 	head->w.domain = domain;
@@ -2121,6 +2125,7 @@
 /* Structure for query. */
 struct ccs_query {
 	struct list_head list;
+	struct ccs_domain_info *domain;
 	char *query;
 	size_t query_len;
 	unsigned int serial;
@@ -2286,6 +2291,7 @@
 		goto out;
 	}
 	len = ccs_round2(entry.query_len);
+	entry.domain = ccs_current_domain();
 	spin_lock(&ccs_query_list_lock);
 	if (ccs_memory_quota[CCS_MEMORY_QUERY] &&
 	    ccs_memory_used[CCS_MEMORY_QUERY] + len
@@ -2333,6 +2339,28 @@
 }
 
 /**
+ * ccs_find_domain_by_qid - Get domain by query id.
+ *
+ * @serial: Query ID assigned by ccs_supervisor().
+ *
+ * Returns pointer to "struct ccs_domain_info" if found, NULL otherwise.
+ */
+static struct ccs_domain_info *ccs_find_domain_by_qid(unsigned int serial)
+{
+	struct ccs_query *ptr;
+	struct ccs_domain_info *domain = NULL;
+	spin_lock(&ccs_query_list_lock);
+	list_for_each_entry(ptr, &ccs_query_list, list) {
+		if (ptr->serial != serial || ptr->answer)
+			continue;
+		domain = ptr->domain;
+		break;
+	}
+	spin_unlock(&ccs_query_list_lock);
+	return domain;
+}
+
+/**
  * ccs_poll_query - poll() for /proc/ccs/query.
  *
  * @file: Pointer to "struct file".
Index: trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-queryd.c
===================================================================
--- trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-queryd.c	(revision 5548)
+++ trunk/1.8.x/ccs-tools/ccstools/usr_sbin/ccs-queryd.c	(working copy)
@@ -107,7 +107,7 @@
 	if (strstr(ccs_buffer, "\n#"))
 		goto not_domain_query;
 	memset(pidbuf, 0, sizeof(pidbuf));
-	snprintf(pidbuf, sizeof(pidbuf) - 1, "select global-pid=%u\n", pid);
+	snprintf(pidbuf, sizeof(pidbuf) - 1, "select Q=%u\n", serial);
 	ccs_printw("Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy "
 		   "and retry):");
 	while (true) {
