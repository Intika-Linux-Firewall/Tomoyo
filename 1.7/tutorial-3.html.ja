<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linux の世界　第３回：「ポリシーをチューニングしてみよう」</title>
<link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<!--
<p style="text-align:right;"><a href="tutorial-3.html.en">English Page</a></p>
-->
<p style="text-align:right;">Last modified: $Date$</p>

<h1>TOMOYO Linux の世界<br>第３回：「ポリシーをチューニングしてみよう」</h1>

<p>「 TOMOYO Linux 」の魅力をお届けする連載の第３回．今回は， TOMOYO Linux を使いこなすうえで必須のポリシーチューニング手法について解説していきます．どうぞお楽しみに．</p>

<h2>今回の内容</h2>

<p>第２回は， TOMOYO Linux における制御モードとプロファイルについて紹介し，それらを組み合わせて実際に強制アクセス制御を行う手順について紹介しました．やや駆け足でしたが，実はこれまでの部分で TOMOYO Linux の基本部分の説明は終わっています．今回からは必要に応じて説明を補足しながら，詳細，応用的な使い方について紹介していくことにします．どうぞおつきあいください．今回のテーマは，ポリシーのチューニングと，それを支援する機能についてです．</p>

<h2>ポリシーのチューニング</h2>

<h3>TOMOYO Linux におけるドメイン遷移</h3>

<p>第２回で説明したように， TOMOYO Linux では原則としてプログラムを実行するたびにドメイン遷移が発生します（図１）．</p>

<table border="1" summary="fig">
<tr><td>
■図１　TOMOYO Linux におけるドメイン遷移<br>（プログラムの実行により新たなドメインに遷移する．）<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-3&amp;src=sd200703-fig01.png" alt="sd200703-fig01.png">
</td></tr>
</table>

<p>つまりすべてのプログラムはそれぞれが独立なドメインになります．ドメインの名称は，基点である &lt;kernel&gt; から現在に至るまでに実行された全てのプログラムのパス名を結合したものになります．これに対して， SELinux におけるドメインは，階層的な構造を持っておらずフラットに並んでいます．プログラムとドメインの対応はポリシー策定者が定めますが，通常はドメインには複数のプログラムが含まれます．各ドメインであらかじめ定義されたプログラムを実行することにより定められたドメインに遷移します（図２．その結果アクセス制御の内容が変わります）．</p>

<table border="1" summary="fig">
<tr><td>
■図２　SELinuxにおけるドメイン遷移<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-3&amp;src=sd200703-fig02.png" alt="sd200703-fig02.png">
</td></tr>
</table>

<h3>ドメイン遷移の例外</h3>

<p>TOMOYO Linux におけるドメインの遷移には，例外が５つあります．</p>

<p>１つ目は， initialize_domain という構文により指定されたプログラムが実行された場合で，そのときには， &lt;kernel&gt; 直下のドメイン（たとえば initialize_domain /etc/rc.d/init.d/sshd という指定が行われていた場合は &lt;kernel&gt; /etc/rc.d/init.d/sshd ドメイン）へ強制的に遷移します（図３）．</p>

<p>２つ目は， keep_domain という構文により指定されたドメインについては，そこに属しているプロセスは， initialize_domain に指定されたプログラムが実行されない限り，同一のドメインに留まります（図４）．複数のプログラムが同一ドメインに所属するという意味では SELinux のドメインに近い部分があります．</p>

<table border="1" summary="fig">
<tr><td>
■図３　initialize_domain によるドメイン遷移<br>（ /some/where/baz が initialize_domain として登録されているので，それが実行された時点で強制的に &lt;kernel&gt; 直下の /some/where/baz ドメインに遷移する．）<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-3&amp;src=sd200703-fig03.png" alt="sd200703-fig03.png">
</td><td>
■図４　keep_domain の効果<br>（ &lt;kernel&gt; /sbin/init ・・・ foo bar ドメインは keep_domain 指定されているため，プログラムを実行してもドメイン遷移は起こらない． initialize_domain 指定されているプログラムが実行されることにより &lt;kernel&gt; /some/where/baz に遷移している．）<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-3&amp;src=sd200703-fig04.png" alt="sd200703-fig04.png">
</td></tr>
</table>

<p>残りの３つの例外については次回以降紹介します．</p>

<h3>一連の操作をグループ化する</h3>

<p>initialize_domain と keep_domain という２つの例外を組み合わせることにより，柔軟なアクセス制御の指定が可能になります．以下，例を挙げて説明します．ログインして ccs-editpolicy を実行してください．そして， /etc/rc.d/init.d/network の実行されるドメイン（ &lt;kernel&gt; /etc/rc.d/init.d/network ）を探してください． /etc/rc.d/init.d/network から /sbin/ifup や /bin/touch など，たくさんのプログラムが実行されているのがおわかりだと思います（図５）．</p>

<table border="1" summary="fig">
<tr><td>
■図５　keep_domain 指定前のドメイン遷移（この図では /etc/init.d/networking ）<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-3&amp;src=sd200703-fig05.jpg" alt="sd200703-fig05.jpg">
</td></tr>
</table>

<p>ここで，「 TAB 」を押してください．「 &lt;&lt;&lt; Domain Transition Editor &gt;&gt;&gt; 」から「 &lt;&lt;&lt; Exception Policy Editor &gt;&gt;&gt; 」という画面に切り替わったと思います．この画面をスクロールしていくと， initialize_domain で始まる行が現れます．一番下までスクロールしてください．この位置で，「 A 」を押してから keep_domain &lt;kernel&gt; /etc/rc.d/init.d/network と入力して「 ENTER 」を押してください．すると，入力した内容が現れるはずです（図６）．</p>

<table border="1" summary="fig">
<tr><td>
■図６　keep_domain を指定（この図では keep_domain &lt;kernel&gt; /etc/init.d/networking ）<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-3&amp;src=sd200703-fig06.jpg" alt="sd200703-fig06.jpg">
</td></tr>
</table>

<p>再度，「 TAB 」を押してください．「 &lt;&lt;&lt; Exception Policy Editor &gt;&gt;&gt; 」から「 &lt;&lt;&lt; Domain Transition Editor &gt;&gt;&gt; 」という画面に切り替わったと思います．そこから，「 &lt;kernel&gt; /etc/rc.d/init.d/network 」ドメインを探してください（図７）．</p>

<table border="1" summary="fig">
<tr><td>
■図７　keep_domain 指定直後のドメイン遷移（この図では &lt;kernel&gt; /etc/init.d/networking ）<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-3&amp;src=sd200703-fig07.jpg" alt="sd200703-fig07.jpg">
</td></tr>
</table>

<p>「 * 」という表示が「 #* 」に変化しました．「 # 」は「このドメインは keep_domain に指定されているので複数のプログラムがこのドメインで動作する可能性がある」ことを，「 * 」は「このドメインは initialize_domain に指定されているので複数のドメインからこのドメインへ遷移する可能性がある」ことを意味します．ここで， /etc/rc.d/init.d/network の実行されるドメインを keep_domain に指定したことで，そのドメインのアクセス許可を学習し直す必要が生じます．「 &lt;kernel&gt; /etc/rc.d/init.d/network 」ドメインの子孫ドメイン（図７の６７～７３行）にカーソルを合わせて「スペース」キーを押すと，行頭に &amp; マークが表示されます．最後に「 D 」を押すと図８のように聞かれるので「 Y 」を押します．</p>

<table border="1" summary="fig">
<tr><td>
■図８　ドメインを削除するかどうかの確認メッセージ
<pre>
Delete selected domains? ('Y'es/'N'o)
</pre>
</td></tr>
</table>

<p>すると，行頭に &amp; マークが表示されているドメインが削除されます．「 Q 」を押して ccs-editpolicy を終了し， /etc/rc.d /init.d/network restart を実行します．再度 ccs-editpolicy を実行して &lt;kernel&gt; /etc/rc.d/init.d/network ドメインを探してみてください．今度は /sbin/ifup や /bin/touch などは現れなくなります（図１０）．</p>

<table border="1" summary="fig">
<tr><td>
■図１０　再学習後のドメイン遷移（この図では &lt;kernel&gt; /etc/init.d/networking ）<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-3&amp;src=sd200703-fig09.jpg" alt="sd200703-fig09.jpg">
</td></tr>
</table>

<p>TOMOYO Linux の自動ドメイン定義機能は強力です．しかし，実行するプログラムの限定とそのアクセス制御は行いたいけれども，プログラムの実行順序が特定できないような場合（典型的なものとしてはログイン後の作業）はポリシーの策定が大変です．グループ化を行うことで，ログイン後のドメインをグループ化してから，そのドメインに強制モード用のプロファイルを割り当てれば，コマンドの実行順序は制限せずにアクセス可能な資源だけを制限することができます．また，強制モード用以外のプロファイルを割り当てれば，従来の Linux と同様に自由に振る舞うことができるようになります．</p>

<h3>条件付きアクセス許可について</h3>

<p>TOMOYO Linux には RBAC （ Role Based Access Control ）機能はありませんが，ポリシーの中でユーザＩＤに基づく条件を付けることができます．これにより，システムアカウントのユーザＩＤに基づくアクセス制御が可能です．条件はアクセス許可の後ろに「 if 条件式」という形で指定します．利用できる条件について図１０に，使い方の例を図１１に示します．</p>

<table border="1" summary="fig">
<tr><td>
■図１０　条件指定に使えるパラメータ<br>
<table border="1" summary="fig">
<tr><td>変数</td><td>意味</td></tr>
<tr><td>task.uid</td><td>呼び出したプロセスのユーザＩＤ</td></tr>
<tr><td>task.euid</td><td>呼び出したプロセスの実効ユーザＩＤ</td></tr>
<tr><td>task.suid</td><td>呼び出したプロセスの保存ユーザＩＤ</td></tr>
<tr><td>task.fsuid</td><td>呼び出したプロセスのファイルシステムユーザＩＤ</td></tr>
<tr><td>task.gid</td><td>呼び出したプロセスのグループＩＤ</td></tr>
<tr><td>task.egid</td><td>呼び出したプロセスの実効グループＩＤ</td></tr>
<tr><td>task.sgid</td><td>呼び出したプロセスの保存グループＩＤ</td></tr>
<tr><td>task.fsgid</td><td>呼び出したプロセスのファイルシステムグループＩＤ</td></tr>
<tr><td>task.pid</td><td>呼び出したプロセスのプロセスＩＤ</td></tr>
<tr><td>task.ppid</td><td>呼び出したプロセスの親プロセスのプロセスＩＤ</td></tr>
<tr><td>task.type</td><td>呼び出したプロセスの種類（ execute_handler か否か）</td></tr>
<tr><td>task.state[0]</td><td>呼び出したプロセスの状態変数0</td></tr>
<tr><td>task.state[1]</td><td>呼び出したプロセスの状態変数1</td></tr>
<tr><td>task.state[2]</td><td>呼び出したプロセスの状態変数2</td></tr>
<tr><td>path1.uid</td><td>１つめのパス名の所有者ＩＤ</td></tr>
<tr><td>path1.gid</td><td>１つめのパス名のグループＩＤ</td></tr>
<tr><td>path1.ino</td><td>１つめのパス名のiノード番号</td></tr>
<tr><td>path1.type</td><td>１つめのパス名の種類（ファイル，ディレクトリ，ソケット等）</td></tr>
<tr><td>path1.perm</td><td>１つめのパス名のパーミッション</td></tr>
<tr><td>path1.major</td><td>１つめのパス名の存在しているデバイスファイルのメジャー番号</td></tr>
<tr><td>path1.minor</td><td>１つめのパス名の存在しているデバイスファイルのマイナー番号</td></tr>
<tr><td>path1.dev_major</td><td>１つめのパス名のパス名（デバイスファイル）のメジャー番号</td></tr>
<tr><td>path1.dev_minor</td><td>１つめのパス名のパス名（デバイスファイル）のマイナー番号</td></tr>
<tr><td>path1.parent.uid</td><td>１つめのパス名の親ディレクトリの所有者ＩＤ</td></tr>
<tr><td>path1.parent.gid</td><td>１つめのパス名の親ディレクトリのグループＩＤ</td></tr>
<tr><td>path1.parent.ino</td><td>１つめのパス名の親ディレクトリのiノード番号</td></tr>
<tr><td>path1.parent.perm</td><td>１つめのパス名の親ディレクトリのパーミッション</td></tr>
<tr><td>path2.uid</td><td>２つめのパス名の所有者ＩＤ</td></tr>
<tr><td>path2.gid</td><td>２つめのパス名のグループＩＤ</td></tr>
<tr><td>path2.ino</td><td>２つめのパス名のiノード番号</td></tr>
<tr><td>path2.type</td><td>２つめのパス名の種類（ファイル，ディレクトリ，ソケット等）</td></tr>
<tr><td>path2.perm</td><td>２つめのパス名のパーミッション</td></tr>
<tr><td>path2.major</td><td>２つめのパス名の存在しているデバイスファイルのメジャー番号</td></tr>
<tr><td>path2.minor</td><td>２つめのパス名の存在しているデバイスファイルのマイナー番号</td></tr>
<tr><td>path2.dev_major</td><td>２つめのパス名のパス名（デバイスファイル）のメジャー番号</td></tr>
<tr><td>path2.dev_minor</td><td>２つめのパス名のパス名（デバイスファイル）のマイナー番号</td></tr>
<tr><td>path2.parent.uid</td><td>２つめのパス名の親ディレクトリの所有者ＩＤ</td></tr>
<tr><td>path2.parent.gid</td><td>２つめのパス名の親ディレクトリのグループＩＤ</td></tr>
<tr><td>path2.parent.ino</td><td>２つめのパス名の親ディレクトリのiノード番号</td></tr>
<tr><td>path2.parent.perm</td><td>２つめのパス名の親ディレクトリのパーミッション</td></tr>
<tr><td>exec.argc</td><td>プログラム実行時の引数の数</td></tr>
<tr><td>exec.envc</td><td>プログラム実行時の環境変数の数</td></tr>
<tr><td>exec.argv[index]</td><td>プログラム実行時のindex番目の引数</td></tr>
<tr><td>exec.envp["name"]</td><td>プログラム実行時の環境変数name</td></tr>
<tr><td>exec.realpath</td><td>プログラム実行時のシンボリックリンクを解決したパス</td></tr>
<tr><td>symlink.target</td><td>シンボリックリンク作成時のリンク先</td></tr>
</table>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図１１　条件指定の例<br>
<table border="1" summary="fig">
<tr><td>条件</td><td>意味</td></tr>
<tr><td>if task.uid=0</td><td>プロセスのユーザＩＤが 0 （ root ）である場合</td></tr>
<tr><td>if task.uid!=0</td><td>プロセスのユーザＩＤが 0 （ root ）ではない場合</td></tr>
<tr><td>if task.uid=100-500</td><td>プロセスのユーザＩＤが 100 以上 500 以下である場合</td></tr>
<tr><td>if task.uid=0 task.gid=0</td><td>プロセスのユーザＩＤとグループＩＤの両方が 0 （ root ）である場合</td></tr>
<tr><td>if task.uid!=0 task.gid!=0</td><td>プロセスのユーザＩＤとグループＩＤの両方が 0 （ root ）ではない場合</td></tr>
<tr><td>if task.uid=100-500 task.gid!=0</td><td>プロセスのユーザＩＤが 100 以上 500 以下であり，かつ，グループＩＤが 0 ではない場合</td></tr>
<tr><td>if exec.argv[index]="value"</td><td>index （ 0&lt;=index&lt;exec.argc ）番目の引数の値が value である場合</td></tr>
<tr><td>if exec.argv[index]!="value"</td><td>index （ 0&lt;=index&lt;exec.argc ）番目の引数の値が value ではない場合</td></tr>
<tr><td>if exec.envp["name"]="value"</td><td>環境変数 name が定義されており，値が value である場合</td></tr>
<tr><td>if exec.envp["name"]!="value"</td><td>環境変数 name が定義されていないか，あるいは値が value ではない場合</td></tr>
<tr><td>if exec.envp["name"]!=NULL</td><td>環境変数 name が定義されている場合</td></tr>
<tr><td>if exec.envp["name"]=NULL</td><td>環境変数 name が定義されていない場合</td></tr>
</table>
</td></tr>
</table>

<h4>●条件を付与してみよう</h4>

<p>例として，コンソールからログインしたユーザが， cat コマンドで自分の所有するファイルのみを閲覧できるようにする手順について説明します．説明用に， user1 と user2 というアカウント使用します．コンソールからログインして，以降の操作を行ってください．まず，アカウントを２つ作成します（図１２）．</p>

<table border="1" summary="fig">
<tr><td>
■図１２　アカウントを２つ作成
<pre>
# useradd -s /bin/bash user1
# useradd -s /bin/bash user2
</pre>
</td></tr>
</table>

<p>パスワードを適当に設定してください（図１３）．</p>

<table border="1" summary="fig">
<tr><td>
■図１３　作成したアカウントのパスワードを設定
<pre>
# passwd user1
# passwd user2
</pre>
</td></tr>
</table>

<p>cat コマンド用のドメインを作成するために， cat コマンドを実行してください．ついでに，このコマンドが動作するドメインも表示してみます（図１４）．</p>

<table border="1" summary="fig">
<tr><td>
■図１４　cat コマンドが動作するドメインを表示
<pre>
# cat /proc/ccs/self_domain
&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
</pre>
</td></tr>
</table>

<p>このドメインに学習用プロファイルを割り当ててください．この連載では学習用プロファイルの番号は１ですので，図１５のようになります．</p>

<table border="1" summary="fig">
<tr><td>
■図１５　cat コマンド用ドメインに学習用プロファイルを割り当て
<pre>
# /usr/sbin/ccs-setprofile 1 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat'
</pre>
</td></tr>
</table>

<p>ログアウトして， user1 としてログインし直します．そして，図１６の操作を行ってください．</p>

<table border="1" summary="fig">
<tr><td>
■図１６　user1 でログインし， /tmp/testfile1 を作成
<pre>
$ echo "This file was created by user1" &gt; /tmp/testfile1
$ cat /tmp/testfile1
This file was created by user1
</pre>
</td></tr>
</table>

<p>ログアウトして， user2 としてログインし直します． user1 と同様に操作を行ってください（図１７）．</p>

<table border="1" summary="fig">
<tr><td>
■図１７　user2 でログインし， /tmp/testfile2 を作成
<pre>
$ echo "This file was created by user2" &gt; /tmp/testfile2
$ cat /tmp/testfile2
This file was created by user2
</pre>
</td></tr>
</table>

<p>ログアウトして， root としてログインし直します． ccs-editpolicy を起動して，「 &lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat 」ドメインのアクセス許可を確認してください．図１８のようなエントリが含まれているはずです．</p>

<table border="1" summary="fig">
<tr><td>
■図１８　&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat ドメインのアクセス許可
<pre>
allow_read /tmp/testfile1
allow_read /tmp/testfile2
</pre>
</td></tr>
</table>

<p>このままではどちらのファイルもＤＡＣ（任意アクセス制御）のパーミッションにより許可されれば誰でも読むことができてしまいます．ここで，キーボードの「 A 」を押して，図１９のように入力してください．</p>

<table border="1" summary="fig">
<tr><td>
■図１９　アクセス許可を追加<br>（※これらをまとめて， allow_read /tmp/testfile\+ if task.uid=path1.uid のように入力してもかまいません．）
<pre>
allow_read /tmp/testfile1 if task.uid=path1.uid
allow_read /tmp/testfile2 if task.uid=path1.uid
</pre>
</td></tr>
</table>

<p>それから，図２０の内容をキーボードの「 D 」を押して削除します．</p>

<table border="1" summary="fig">
<tr><td>
■図２０　削除する内容
<pre>
allow_read /tmp/testfile1
allow_read /tmp/testfile2
</pre>
</td></tr>
</table>

<p>キーボードの「 Q 」を押して， ccs-editpolicy を終了します．そして， cat コマンド用のドメインに強制用プロファイルを割り当ててください．この連載では強制用プロファイルの番号は３ですので図２１のようになります．</p>

<table border="1" summary="fig">
<tr><td>
■図２１　cat コマンド用ドメインに強制用プロファイルを割り当て
<pre>
# /usr/sbin/ccs-setprofile 3 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat'
</pre>
</td></tr>
</table>

<p>ログアウトして， user1 としてログインし直します．そして， /tmp/testfile1 と /tmp/testfile2 を cat してみてください． /tmp/testfile2 へのアクセスが禁止されていることを確認できます（図２２）．</p>

<table border="1" summary="fig">
<tr><td>
■図２２ /tmp/testfile2 へのアクセスが禁止されている
<pre>
$ cat /tmp/testfile1
This file was created by user1
$ cat /tmp/testfile2
cat: /tmp/testfile2: Operation not permitted
</pre>
</td></tr>
</table>

<p>ログアウトして， user2 としてログインし直します． user1 と同様に操作を行ってください． /tmp/testfile1 へのアクセスが禁止されていることを確認できます．変数の代わりにユーザＩＤを直接指定することもできます．たとえば，ユーザ認証を行ってログインシェルを起動するための「 &lt;kernel&gt; /sbin/mingetty /bin/login 」ドメインに対して，図２３のように変更してやると， root ユーザのログインを禁止することができます．</p>

<table border="1" summary="fig">
<tr><td>
■図２３　root ユーザのログインを禁止する設定
<pre>
[修正前]
allow_execute /bin/bash
[修正後]
allow_execute /bin/bash if task.uid!=0
</pre>
</td></tr>
</table>

<p>また，図２４のように変更してやると，ユーザＩＤが 500 以上 1000 以下のユーザだけがログインできるようにすることができます． SSH 経由でのログインを制限したい場合に使うことができます．</p>

<table border="1" summary="fig">
<tr><td>
■図２４　ユーザＩＤ 500 以上 1000 以下のユーザのみログインできる設定
<pre>
[修正前]
allow_execute /bin/bash
[修正後]
allow_execute /bin/bash if task.uid=500-1000
</pre>
</td></tr>
</table>

<h2>アクセスログの保存について</h2>

<p>TOMOYO Linux では，「ポリシーに違反しなかったアクセス要求のログ」（アクセス許可ログ）と「ポリシーに違反したアクセス要求のログ」（アクセス拒否ログ）を取得することができます．アクセス許可ログとアクセス拒否ログをカーネルから読み出してファイルに保存するために， ccs-auditd というデーモンプログラムを利用できます．</p>

<h4>●アクセスログを保存してみよう</h4>

<p>まず，アクセスログを保存するディレクトリを作成します（図２５）．</p>

<table border="1" summary="fig">
<tr><td>
■図２５　アクセスログ保存用のディレクトリを作成
<pre>
# mkdir -p /var/log/tomoyo
</pre>
</td></tr>
</table>

<p>次に， /etc/rc.d/rc.local に図２６の行を追加します．１番目の引数が「アクセス許可ログ」の保存場所で，２番目の引数が「アクセス拒否ログ」の保存場所です．</p>

<table border="1" summary="fig">
<tr><td>
■図２６　/etc/rc.d/rc.local を修正
<pre>
/usr/sbin/ccs-auditd /dev/null /var/log/tomoyo/reject_log.txt
</pre>
</td></tr>
</table>

<p>次に， logrotate によるローテーションを行わせるために，図２７のような内容のファイルを /etc/logrotate.d/tomoyo として作成してください．なお， nocreate オプションを必ず指定してください． nocreate オプションを忘れると，最初のローテーションが実行されて以降のログが保存されなくなってしまいます．</p>

<table border="1" summary="fig">
<tr><td>
■図２７　logrotate によるローテーションの設定（ /etc/logrotate.d/tomoyo ）
<pre>
/var/log/tomoyo/reject_log.txt {
    weekly
    rotate 9
    missingok
    notifempty
    nocreate
}
</pre>
</td></tr>
</table>

<p>アクセス許可ログを保存する必要がない場合は，プロファイルで「 PREFERENCE::audit={ max_grant_log=0 } 」という指定をして，アクセス許可ログの保存場所として /dev/null を指定することができます． ccs-auditd にはフィルタリング機能がありませんので，アクセス許可ログを保存する場合はディスク容量に注意してください．アクセス拒否ログを保存する必要がない場合は，プロファイルで「 PREFERENCE::audit={ max_reject_log=0 } 」という指定をして，アクセス拒否ログの保存場所として /dev/null を指定することができます．アクセス拒否ログは保存しておくことを推奨します．アクセス許可ログ／アクセス拒否ログのどちらも保存しない場合には ccs-auditd を実行する必要はありません．また，プロファイルで「 PREFERENCE::audit={ max_grant_log=0 max_reject_log=0 } 」を指定しておくことで，消費メモリの節約と応答速度の向上が期待できます．</p>

<h4>●アクセスログを閲覧してみよう</h4>

<p>アクセスログは，そのまま /etc/ccs/domain_policy.conf に追記可能な形式になっています（図２８）．</p>

<table border="1" summary="fig">
<tr><td>
■図２８　アクセスログの内容例（ /var/log/tomoyo/reject_log.txt ）
<pre>
# cat /var/log/tomoyo/reject_log.txt
#2010-05-13 15:36:22# profile=3 mode=enforcing (global-pid=4350) task={ pid=4350 ppid=4312 uid=500 gid=500 euid=500 egid=500 suid=500 sgid=500 fsuid=500 fsgid=500 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=501 gid=501 ino=393251 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
allow_read /tmp/testfile2

#2010-05-13 15:36:36# profile=3 mode=enforcing (global-pid=4518) task={ pid=4518 ppid=4480 uid=501 gid=501 euid=501 egid=501 suid=501 sgid=501 fsuid=501 fsgid=501 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=500 gid=500 ino=393250 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
allow_read /tmp/testfile1
</pre>
</td></tr>
</table>

<p>また，プロセスのユーザＩＤなどの情報も記録されているため，個々のアクセス許可に条件を付与する際のヒントにもなります．</p>

<h2>対話的なアクセス許可の追加について</h2>

<p>TOMOYO Linux では，強制モードで運用中にポリシー違反が発生しても，そのアクセス要求を直ちに拒否する（図２９）のではなく，管理者による対話的な操作によりそのアクセス要求の諾否を指示する（図３０）ことができます．この機能は，強制モードでの動作確認中にポリシー違反が発生した場合や，ソフトウェアのアップデートなどによりポリシーの微調整が必要になった場合に役に立ちます．</p>

<table border="1" summary="fig">
<tr><td>
■図２９　ポリシーに違反する要求はすぐに拒否<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-3&amp;src=sd200703-fig31.png" alt="sd200703-fig31.png">
</td><td>
■図３０　ポリシーに違反する要求は対話的に処理<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-3&amp;src=sd200703-fig20.png" alt="sd200703-fig20.png">
</td></tr>
</table>

<h4>●対話的にアクセス許可を追加してみよう</h4>

<p>ポリシー違反の発生を監視して管理者に問い合わせを行う ccs-queryd コマンドを起動してください（図３１）．</p>

<table border="1" summary="fig">
<tr><td>
■図３１　ccs-queryd を起動
<pre>
# /usr/sbin/ccs-queryd
Monitoring /proc/ccs/query and /etc/ld.so.cache . Press Ctrl-C to terminate.
</pre>
</td></tr>
</table>

<p>この状態でポリシー違反が発生すると， ccs-queryd を実行中の画面にアクセス要求の内容が表示されます．このメッセージは， /etc/ccs/domain_policy.conf と同じ構文になっていますので，許可すべきかどうかを判断してください．先ほど，コンソールからログインしたユーザが cat コマンドで自分の所有するファイルのみを閲覧できるようにするポリシーを作成しましたので，ここではそれを用いてポリシー違反を発生させることにします． ccs-queryd を動作させている画面を残したまま，別の画面を開いて user1 としてログインします．その後，図３２のコマンドを実行してください．</p>

<table border="1" summary="fig">
<tr><td>
■図３２　user1 で操作を行う
<pre>
$ cat /tmp/testfile1
This file was created by user1
$ cat /tmp/testfile2
</pre>
</td></tr>
</table>

<p>この操作によりポリシー違反が発生しました． ccs-queryd を動作させている画面をチェックしてみてください．図３３のようなメッセージが表示されているはずです．</p>

<table border="1" summary="fig">
<tr><td>
■図３３　ポリシー違反が発生した場合の ccs-queryd の画面
<pre>
#2010-05-13 15:39:20# profile=3 mode=enforcing (global-pid=4619) task={ pid=4619 ppid=4581 uid=500 gid=500 euid=500 egid=500 suid=500 sgid=500 fsuid=500 fsgid=500 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=501 gid=501 ino=393251 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
allow_read /tmp/testfile2
Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):
</pre>
</td></tr>
</table>

<p>許可したい場合は「 Y 」を，拒否したい場合は「 N 」を，ポリシーに追加したうえで再試行したい場合は「 A 」を押します．ここで「 N 」を押してから， user1 の画面を見てください．図３４のようなメッセージが表示されました．</p>

<table border="1" summary="fig">
<tr><td>
■図３４　操作が許可されていないことを知らせるメッセージ
<pre>
cat: /tmp/testfile2: Operation not permitted
</pre>
</td></tr>
</table>

<p>再度図３５を実行して， ccs-queryd の画面をチェックしてください．</p>

<table border="1" summary="fig">
<tr><td>
■図３５　再度 user1 で操作を行う
<pre>
$ cat /tmp/testfile2
</pre>
</td></tr>
</table>

<p>図３６のようなメッセージが表示されているはずです．</p>

<table border="1" summary="fig">
<tr><td>
■図３６　ポリシー違反が発生した場合の ccs-queryd の画面
<pre>
#2010-05-13 15:41:36# profile=3 mode=enforcing (global-pid=4620) task={ pid=4620 ppid=4581 uid=500 gid=500 euid=500 egid=500 suid=500 sgid=500 fsuid=500 fsgid=500 state[0]=0 state[1]=0 state[2]=0 type!=execute_handler } path1={ uid=501 gid=501 ino=393251 major=253 minor=0 perm=0555 type=file } path1.parent={ uid=0 gid=0 ino=393217 perm=0755 }
&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
allow_read /tmp/testfile2
Allow? ('Y'es/'N'o/'R'etry/'S'how policy/'A'dd to policy and retry):
</pre>
</td></tr>
</table>

<p>ここで「 Y 」を押してから， user1 の画面を見てください．図３７のように， /tmp/testfile2 の内容が表示されました．</p>

<table border="1" summary="fig">
<tr><td>
■図３７　/tmp/testfile2 の内容が表示される
<pre>
This file was created by user2
</pre>
</td></tr>
</table>

<p>再度図３５を実行して， ccs-queryd の画面をチェックしてください．</p>

<p>今度は「 A 」を押してください．図３８という内容が表示されます．</p>

<table border="1" summary="fig">
<tr><td>
■図３８　編集を行うプロンプト
<pre>
Enter new entry&gt; allow_read /tmp/testfile2
</pre>
</td></tr>
</table>

<p>このまま「 ENTER 」を押すと，編集中の内容がポリシーに追加され（図３９），再試行されます．</p>

<table border="1" summary="fig">
<tr><td>
■図３９　ポリシーに追加される
<pre>
Added 'allow_read /tmp/testfile2'.
</pre>
</td></tr>
</table>

<p>ポリシーに追加されたことでポリシー違反は発生しなくなるため，図３７のように /tmp/testfile2 の内容が表示されます．</p>

<p>また， ccs-editpolicy を起動して「 &lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat 」ドメインに対するアクセス許可の一覧を表示してみると，図４０のようになっているはずです．</p>

<table border="1" summary="fig">
<tr><td>
■図４０　アクセス許可の一覧を表示する
<pre>
allow_read /tmp/testfile1 if task.uid=path1.uid
allow_read /tmp/testfile2
allow_read /tmp/testfile2 if task.uid=path1.uid
</pre>
</td></tr>
</table>

<p>これは， ccs-queryd によって「 allow_read /tmp/testfile2 」というアクセス許可が追加されたためです．チューニングが終わったら， ccs-queryd を「 CTRL＋C 」により終了させてください．</p>

<h3>ccs-queryd 利用時の注意点</h3>

<p>ccs-queryd を利用するうえで注意すべき点が２つあります．１つは，無条件にアクセス要求を許可してはいけない点です．ポリシー違反の原因が悪意あるユーザによる攻撃である可能性があるからです．もし，悪意あるユーザによる攻撃によって発生したアクセス要求に対してアクセスを許可してしまった場合，強制アクセス制御による保護が無意味になってしまいます．もう１つは， ccs-queryd が動作している間は，ポリシー違反が発生しても管理者が応答するまでそのアクセス要求は保留状態となる点です．そのため， ccs-queryd を動作させたまま席を外したりログアウトしたりしないでください．</p>

<h2>次回予告</h2>

<p>今回はドメイン遷移の制御とポリシーのチューニング方法について紹介しました．次回は，ファイル以外に関する強制アクセス制御機能について紹介していきます．どうぞお楽しみに．</p>

<hr>

<p><a href="index.html.ja">目次へ戻る</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</body>
</html>
