<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linux の世界　第５回：「アクセス許可に条件を付けてみよう」</title>
<link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<p>Info: Version <a href="../1.8/">1.8.x</a> is available.</p>
<p style="text-align:right;"><a href="tutorial-5.html.en">English Page</a></p>
<p style="text-align:right;">Last modified: $Date$</p>

<h1>TOMOYO Linux の世界<br>第５回：「アクセス許可に条件を付けてみよう」</h1>

<h2>今回の内容</h2>

<p>今回は TOMOYO Linux の強力なパラメータチェック機能を活用するための「条件付きアクセス許可」について紹介します．</p>

<h2>アクセス許可に条件を付ける</h2>

<h3>条件付きアクセス許可について</h3>

<p>TOMOYO Linux には RBAC （ Role Based Access Control ）機能はありませんが，ポリシーの中でユーザＩＤに基づく条件を付けることができます．これにより，システムアカウントのユーザＩＤに基づくアクセス制御が可能です．条件はアクセス許可の後ろに「 if 条件式」という形で指定します．利用できる条件について図１に，使い方の例を図２に示します．</p>

<table border="1" summary="fig">
<tr><td>
■図１　条件指定に使えるパラメータ<br>
<table border="1" summary="fig">
<tr><td>変数</td><td>意味</td></tr>
<tr><td>task.uid</td><td>呼び出したプロセスのユーザＩＤ</td></tr>
<tr><td>task.euid</td><td>呼び出したプロセスの実効ユーザＩＤ</td></tr>
<tr><td>task.suid</td><td>呼び出したプロセスの保存ユーザＩＤ</td></tr>
<tr><td>task.fsuid</td><td>呼び出したプロセスのファイルシステムユーザＩＤ</td></tr>
<tr><td>task.gid</td><td>呼び出したプロセスのグループＩＤ</td></tr>
<tr><td>task.egid</td><td>呼び出したプロセスの実効グループＩＤ</td></tr>
<tr><td>task.sgid</td><td>呼び出したプロセスの保存グループＩＤ</td></tr>
<tr><td>task.fsgid</td><td>呼び出したプロセスのファイルシステムグループＩＤ</td></tr>
<tr><td>task.pid</td><td>呼び出したプロセスのプロセスＩＤ</td></tr>
<tr><td>task.ppid</td><td>呼び出したプロセスの親プロセスのプロセスＩＤ</td></tr>
<tr><td>task.type</td><td>呼び出したプロセスの種類（ execute_handler か否か）</td></tr>
<tr><td>task.state[0]</td><td>呼び出したプロセスの状態変数0</td></tr>
<tr><td>task.state[1]</td><td>呼び出したプロセスの状態変数1</td></tr>
<tr><td>task.state[2]</td><td>呼び出したプロセスの状態変数2</td></tr>
<tr><td>path1.uid</td><td>１つめのパス名の所有者ＩＤ</td></tr>
<tr><td>path1.gid</td><td>１つめのパス名のグループＩＤ</td></tr>
<tr><td>path1.ino</td><td>１つめのパス名のiノード番号</td></tr>
<tr><td>path1.type</td><td>１つめのパス名の種類（ファイル，ディレクトリ，ソケット等）</td></tr>
<tr><td>path1.perm</td><td>１つめのパス名のパーミッション</td></tr>
<tr><td>path1.major</td><td>１つめのパス名の存在しているデバイスファイルのメジャー番号</td></tr>
<tr><td>path1.minor</td><td>１つめのパス名の存在しているデバイスファイルのマイナー番号</td></tr>
<tr><td>path1.dev_major</td><td>１つめのパス名のパス名（デバイスファイル）のメジャー番号</td></tr>
<tr><td>path1.dev_minor</td><td>１つめのパス名のパス名（デバイスファイル）のマイナー番号</td></tr>
<tr><td>path1.parent.uid</td><td>１つめのパス名の親ディレクトリの所有者ＩＤ</td></tr>
<tr><td>path1.parent.gid</td><td>１つめのパス名の親ディレクトリのグループＩＤ</td></tr>
<tr><td>path1.parent.ino</td><td>１つめのパス名の親ディレクトリのiノード番号</td></tr>
<tr><td>path1.parent.perm</td><td>１つめのパス名の親ディレクトリのパーミッション</td></tr>
<tr><td>path2.uid</td><td>２つめのパス名の所有者ＩＤ</td></tr>
<tr><td>path2.gid</td><td>２つめのパス名のグループＩＤ</td></tr>
<tr><td>path2.ino</td><td>２つめのパス名のiノード番号</td></tr>
<tr><td>path2.type</td><td>２つめのパス名の種類（ファイル，ディレクトリ，ソケット等）</td></tr>
<tr><td>path2.perm</td><td>２つめのパス名のパーミッション</td></tr>
<tr><td>path2.major</td><td>２つめのパス名の存在しているデバイスファイルのメジャー番号</td></tr>
<tr><td>path2.minor</td><td>２つめのパス名の存在しているデバイスファイルのマイナー番号</td></tr>
<tr><td>path2.dev_major</td><td>２つめのパス名のパス名（デバイスファイル）のメジャー番号</td></tr>
<tr><td>path2.dev_minor</td><td>２つめのパス名のパス名（デバイスファイル）のマイナー番号</td></tr>
<tr><td>path2.parent.uid</td><td>２つめのパス名の親ディレクトリの所有者ＩＤ</td></tr>
<tr><td>path2.parent.gid</td><td>２つめのパス名の親ディレクトリのグループＩＤ</td></tr>
<tr><td>path2.parent.ino</td><td>２つめのパス名の親ディレクトリのiノード番号</td></tr>
<tr><td>path2.parent.perm</td><td>２つめのパス名の親ディレクトリのパーミッション</td></tr>
<tr><td>exec.argc</td><td>プログラム実行時の引数の数</td></tr>
<tr><td>exec.envc</td><td>プログラム実行時の環境変数の数</td></tr>
<tr><td>exec.argv[index]</td><td>プログラム実行時のindex番目の引数</td></tr>
<tr><td>exec.envp["name"]</td><td>プログラム実行時の環境変数name</td></tr>
<tr><td>exec.realpath</td><td>プログラム実行時のシンボリックリンクを解決したパス</td></tr>
<tr><td>symlink.target</td><td>シンボリックリンク作成時のリンク先</td></tr>
</table>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図２　条件指定の例<br>
<table border="1" summary="fig">
<tr><td>条件</td><td>意味</td></tr>
<tr><td>if task.uid=0</td><td>プロセスのユーザＩＤが 0 （ root ）である場合</td></tr>
<tr><td>if task.uid!=0</td><td>プロセスのユーザＩＤが 0 （ root ）ではない場合</td></tr>
<tr><td>if task.uid=100-500</td><td>プロセスのユーザＩＤが 100 以上 500 以下である場合</td></tr>
<tr><td>if task.uid=0 task.gid=0</td><td>プロセスのユーザＩＤとグループＩＤの両方が 0 （ root ）である場合</td></tr>
<tr><td>if task.uid!=0 task.gid!=0</td><td>プロセスのユーザＩＤとグループＩＤの両方が 0 （ root ）ではない場合</td></tr>
<tr><td>if task.uid=100-500 task.gid!=0</td><td>プロセスのユーザＩＤが 100 以上 500 以下であり，かつ，グループＩＤが 0 ではない場合</td></tr>
<tr><td>if exec.argv[index]="value"</td><td>index （ 0&lt;=index&lt;exec.argc ）番目の引数の値が value である場合</td></tr>
<tr><td>if exec.argv[index]!="value"</td><td>index （ 0&lt;=index&lt;exec.argc ）番目の引数の値が value ではない場合</td></tr>
<tr><td>if exec.envp["name"]="value"</td><td>環境変数 name が定義されており，値が value である場合</td></tr>
<tr><td>if exec.envp["name"]!="value"</td><td>環境変数 name が定義されていないか，あるいは値が value ではない場合</td></tr>
<tr><td>if exec.envp["name"]!=NULL</td><td>環境変数 name が定義されている場合</td></tr>
<tr><td>if exec.envp["name"]=NULL</td><td>環境変数 name が定義されていない場合</td></tr>
</table>
</td></tr>
</table>

<h3>条件を付与してみよう</h3>

<p>例として，コンソールからログインしたユーザが， /bin/cat コマンドで自分の所有するファイルのみを閲覧できるようにする手順について説明します．説明用に， user1 と user2 というアカウントを使用します．コンソールからログインして，以降の操作を行ってください．まず，アカウントを２つ作成します（図３）．</p>

<table border="1" summary="fig">
<tr><td>
■図３　アカウントを２つ作成
<pre>
# useradd -s /bin/bash user1
# useradd -s /bin/bash user2
</pre>
</td></tr>
</table>

<p>パスワードを適当に設定してください（図４）．</p>

<table border="1" summary="fig">
<tr><td>
■図４　作成したアカウントのパスワードを設定
<pre>
# passwd user1
# passwd user2
</pre>
</td></tr>
</table>

<p>cat コマンド用のドメインを作成するために， /bin/cat コマンドを実行してください．ついでに，このコマンドが動作するドメインも表示してみます（図５）．</p>

<table border="1" summary="fig">
<tr><td>
■図５　cat コマンドが動作するドメインを表示
<pre>
# cat /proc/ccs/self_domain
&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat
</pre>
</td></tr>
</table>

<p>このドメインに学習用プロファイルを割り当ててください．この連載では学習用プロファイルの番号は１ですので，図６のようになります．</p>

<table border="1" summary="fig">
<tr><td>
■図６　cat コマンド用ドメインに学習用プロファイルを割り当て
<pre>
# /usr/sbin/ccs-setprofile 1 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat'
</pre>
</td></tr>
</table>

<p>ログアウトして， user1 としてログインし直します．そして，図７の操作を行ってください．</p>

<table border="1" summary="fig">
<tr><td>
■図７　user1 でログインし， /tmp/testfile1 を作成
<pre>
$ echo "This file was created by user1" &gt; /tmp/testfile1
$ cat /tmp/testfile1
This file was created by user1
</pre>
</td></tr>
</table>

<p>ログアウトして， user2 としてログインし直します． user1 と同様に操作を行ってください（図８）．</p>

<table border="1" summary="fig">
<tr><td>
■図８　user2 でログインし， /tmp/testfile2 を作成
<pre>
$ echo "This file was created by user2" &gt; /tmp/testfile2
$ cat /tmp/testfile2
This file was created by user2
</pre>
</td></tr>
</table>

<p>ログアウトして， root としてログインし直します． ccs-editpolicy を起動して，「 &lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat 」ドメインのアクセス許可を確認してください．図９のようなエントリが含まれているはずです．</p>

<table border="1" summary="fig">
<tr><td>
■図９　&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat ドメインのアクセス許可
<pre>
allow_read /tmp/testfile1
allow_read /tmp/testfile2
</pre>
</td></tr>
</table>

<p>このままではどちらのファイルもＤＡＣ（任意アクセス制御）のパーミッションにより許可されれば誰でも読むことができてしまいます．ここで，キーボードの「 A 」を押して，図１０のように入力してください．</p>

<table border="1" summary="fig">
<tr><td>
■図１０　アクセス許可を追加<br>（※これらをまとめて， allow_read /tmp/testfile\+ if task.uid=path1.uid のように入力してもかまいません．）
<pre>
allow_read /tmp/testfile1 if task.uid=path1.uid
allow_read /tmp/testfile2 if task.uid=path1.uid
</pre>
</td></tr>
</table>

<p>それから，図１１の内容をキーボードの「 D 」を押して削除します．</p>

<table border="1" summary="fig">
<tr><td>
■図１１　削除する内容
<pre>
allow_read /tmp/testfile1
allow_read /tmp/testfile2
</pre>
</td></tr>
</table>

<p>キーボードの「 Q 」を押して， ccs-editpolicy を終了します．そして， /bin/cat コマンド用のドメインに強制用プロファイルを割り当ててください．この連載では強制用プロファイルの番号は３ですので図１２のようになります．</p>

<table border="1" summary="fig">
<tr><td>
■図１２　cat コマンド用ドメインに強制用プロファイルを割り当て
<pre>
# /usr/sbin/ccs-setprofile 3 '&lt;kernel&gt; /sbin/mingetty /bin/login /bin/bash /bin/cat'
</pre>
</td></tr>
</table>

<p>ログアウトして， user1 としてログインし直します．そして， /tmp/testfile1 と /tmp/testfile2 を /bin/cat コマンドで表示してみてください． /tmp/testfile2 へのアクセスが禁止されていることを確認できます（図１３）．</p>

<table border="1" summary="fig">
<tr><td>
■図１３ /tmp/testfile2 へのアクセスが禁止されている
<pre>
$ cat /tmp/testfile1
This file was created by user1
$ cat /tmp/testfile2
cat: /tmp/testfile2: Operation not permitted
</pre>
</td></tr>
</table>

<p>ログアウトして， user2 としてログインし直します． user1 と同様に操作を行ってください． /tmp/testfile1 へのアクセスが禁止されていることを確認できます．変数の代わりにユーザＩＤを直接指定することもできます．たとえば，ユーザ認証を行ってログインシェルを起動するための「 &lt;kernel&gt; /sbin/mingetty /bin/login 」ドメインに対して，図１４のように変更してやると， root ユーザのログインを禁止することができます．</p>

<table border="1" summary="fig">
<tr><td>
■図１４　root ユーザのログインを禁止する設定
<pre>
[修正前]
allow_execute /bin/bash
[修正後]
allow_execute /bin/bash if task.uid!=0
</pre>
</td></tr>
</table>

<p>また，図１５のように変更してやると，ユーザＩＤが 500 以上 1000 以下のユーザだけがログインできるようにすることができます．ＳＳＨ経由でのログインを制限したい場合に使うことができます．</p>

<table border="1" summary="fig">
<tr><td>
■図１５　ユーザＩＤ 500 以上 1000 以下のユーザのみログインできる設定
<pre>
[修正前]
allow_execute /bin/bash
[修正後]
allow_execute /bin/bash if task.uid=500-1000
</pre>
</td></tr>
</table>

<p>以上で条件付きアクセス許可の説明は終わりです．この説明のために作成したアカウントを削除します（図１６）．</p>

<table border="1" summary="fig">
<tr><td>
■図１６　図３で作成したアカウントを削除
<pre>
# userdel user1
# userdel user2
</pre>
</td></tr>
</table>

<h3>プログラムの起動方法による振る舞いの変化について</h3>

<p>ちょっと横道に逸れますが，ここでアクセス制御を行う場合に注意すべき点として，プログラムの起動方法による振る舞いの変化について触れておきたいと思います．システム（ TOMOYO Linux カーネルで動作しているシステムである必要はありません）にログインして，図１７のプログラムを /tmp/argv0.c という名前で保存してください．</p>

<table border="1" summary="fig">
<tr><td>
■図１７　起動方法を表示するＣプログラム
<pre>
#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
        printf("I am running as %s\n", argv[0]);
        return 0;
}
</pre>
</td></tr>
</table>

<p>その後，図１８のようにコンパイルしておよびシンボリックリンク（またはハードリンク）を作成してください．</p>

<table border="1" summary="fig">
<tr><td>
■図１８　コンパイルしてシンボリックリンクを作成する
<pre>
# gcc -o /tmp/argv0 /tmp/argv0.c
# ln -s /tmp/argv0 /tmp/cat
# ln -s /tmp/argv0 /tmp/passwd
</pre>
</td></tr>
</table>

<p>そして，そのシンボリックリンク（またはハードリンク）を実行してください．すると，シンボリックリンクの名前が表示されます（図１９）．</p>

<table border="1" summary="fig">
<tr><td>
■図１９　シンボリックリンク経由で起動する
<pre>
# /tmp/cat
I am running as /tmp/cat
# /tmp/passwd
I am running as /tmp/passwd
</pre>
</td></tr>
</table>

<p>一部のコマンドは，そのコマンドが起動されたときの「名前（ argv[0] と呼ばれているものです） 」によって振る舞いを変えるように作られています．たとえば， CentOS 5.9 において， /sbin/pidof は /sbin/killall5 へのシンボリックリンクであり， pidof という名前で起動された場合には指定されたプログラムのプロセスＩＤを表示し， killall5 という名前で起動された場合には自分のセッション以外のすべてのプロセスにシグナルを送信します．</p>

<p>TOMOYO Linux では /tmp/cat を実行すれば /tmp/cat のドメインで動作し， /tmp/passwd を実行すれば /tmp/passwd のドメインで動作します．では，図２０のように /tmp/cat という名前で /tmp/passwd を実行した場合には，どのようになるでしょうか？（結果を予想してみてください）</p>

<table border="1" summary="fig">
<tr><td>
■図２０　passwd コマンドを cat という名前で実行する
<pre>
# sh -c 'exec -a /tmp/cat /tmp/passwd'
</pre>
</td></tr>
</table>

<p>図２０の実行結果は図２１となります．このことから，図２０を認めることは図２２を認めることと同じです．ただし，図２２は /tmp/cat ドメインで /tmp/cat として動作するのを認めているのに対して，図２０は /tmp/passwd ドメインで /tmp/cat として動作することを認めているという点に注意してください．</p>

<table border="1" summary="fig">
<tr><td>
■図２１　cat コマンドとして動作する
<pre>
I am running as /tmp/cat
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図２２　図２０がもたらす結果
<pre>
# sh -c 'exec /tmp/cat'
</pre>
</td></tr>
</table>

<p>/usr/bin/passwd コマンドと /bin/cat コマンドが /sbin/busybox のハードリンクまたはシンボリックリンクとして提供されていると仮定します．この場合， TOMOYO Linux では /bin/cat を実行すれば /bin/cat のドメインで動作し， /usr/bin/passwd を実行すれば /usr/bin/passwd のドメインで動作します．パスワードを変更するための /usr/bin/passwd ドメインには /etc/shadow へのアクセスを認める必要がありますが，ファイルの内容を表示するための /bin/cat ドメインには /etc/shadow へのアクセスを認めたくありません．では，図２３のように /bin/cat という名前で /usr/bin/passwd を実行した場合には，どのようになるでしょうか？</p>

<table border="1" summary="fig">
<tr><td>
■図２３　passwd コマンドを cat という名前で実行する
<pre>
# sh -c 'exec -a /bin/cat /usr/bin/passwd /etc/shadow'
</pre>
</td></tr>
</table>

<p>図２３を実行すると， /usr/bin/passwd は /usr/bin/passwd ドメインで動作します．しかし，起動時の名前が /bin/cat であったため，その振る舞いは /bin/cat となります．結果として図２４のような振る舞いを許可してしまったことになります．</p>

<table border="1" summary="fig">
<tr><td>
■図２４　パスワードファイルを閲覧できる
<pre>
# sh -c 'exec /bin/cat /etc/shadow'
</pre>
</td></tr>
</table>

<p>このような脅威を防ぐために， TOMOYO Linux ではプログラムのパス名と argv[0] の組み合わせをチェックする機能を備えており，プログラムの実行許可に対しては自動的に exec.realpath および exec.argv[0] という形でシンボリックリンクを解決したパス名と argv[0] も一緒にチェックするようになっています．図２３のような脅威も /usr/bin/passwd コマンドを /bin/cat という名前で起動することを禁止することで防ぐことができるようになります．</p>

<h2>アクセスログからポリシーを生成する（上級者向け）</h2>

<p>学習モードで生成されるポリシーに含まれているアクセス許可には exec.realpath と exec.argv[0] と symlink.target だけしか含まれていませんが，アクセスログには図１で示した全ての変数が含まれています．そのため，アクセスログからポリシーを生成してやれば，最も厳格な条件付きアクセス許可を定義することができます．</p>

<h3>自動的にアクセス許可を追加しないように設定する</h3>

<p>学習モードでは，一度ポリシー違反が発生すると，そのポリシー違反を起こさないようにするために必要なアクセス許可が自動的に追加されてしまいます．しかし，自動的に追加されるアクセス許可には図１で示した全ての情報が含まれているわけではありません．そのため，プロファイルを図２５のように編集して自動的に追加されないようにします．</p>

<table border="1" summary="fig">
<tr><td>
■図２５　/etc/ccs/profile.conf の変更箇所
<pre>
[修正前]
PREFERENCE::learning={ verbose=no }
[修正後]
PREFERENCE::learning={ verbose=no max_entry=0 }
</pre>
</td></tr>
</table>

<p>保存したら，図２６のコマンドを実行して変更を反映してください．</p>

<table border="1" summary="fig">
<tr><td>
■図２６　変更を反映する
<pre>
# /usr/sbin/ccs-loadpolicy p
</pre>
</td></tr>
</table>

<h3>プログラムを動作させる</h3>

<p>この状態でプログラムを動作させます．ポリシー違反は全てアクセスログとして保存されていきます．</p>

<p>図２５で max_entry=0 という指定をしたため，図２７のようなメッセージが大量に表示されますが無視してください．</p>

<table border="1" summary="fig">
<tr><td>
■図２７　学習する件数の上限に達したことを示すメッセージ
<pre>
WARNING: Domain 'ドメイン名' has so many ACLs to hold. Stopped learning mode.
</pre>
</td></tr>
</table>

<h3>アクセスログから必要な部分を抽出する</h3>

<p>grep を用いて mode=learning を含むログを抽出します（図２８）．前後に空白を含めていることに注意してください．空白を入れ忘れると，ファイル名などと一致してしまう可能性があります．</p>

<table border="1" summary="fig">
<tr><td>
■図２８　学習モードのアクセスログだけを抽出する
<pre>
# grep -F -A 2 " mode=learning " /var/log/tomoyo/reject_log.conf &gt; /var/log/tomoyo/learning_log.txt
</pre>
</td></tr>
</table>

<p>抽出したら，条件付きのアクセス許可に変換します（図２９）．</p>

<table border="1" summary="fig">
<tr><td>
■図２９　条件付きのアクセス許可に変換する
<pre>
# /usr/lib/ccs/convert-audit-log &lt; /var/log/tomoyo/learning_log.txt &gt; /var/log/tomoyo/policy.tmp
</pre>
</td></tr>
</table>

<p>変換したら，ドメイン単位でソートすることにより圧縮します（図３０）．</p>

<table border="1" summary="fig">
<tr><td>
■図３０　ドメイン単位でソートする
<pre>
# /usr/sbin/ccs-sortpolicy &lt; /var/log/tomoyo/policy.tmp &gt; /var/log/tomoyo/policy.txt
</pre>
</td></tr>
</table>

<h3>加工してからポリシーとして追加する</h3>

<p>/var/log/tomoyo/policy.txt はそのままドメインポリシーとして /etc/ccs/domain_policy.conf に追加することが可能ですが，図３１のように条件が厳密すぎて使い物にならない（例えばプロセスＩＤやｉノード番号などは毎回変わるため、指定しない方が良い）ので，テキストエディタを用いて条件を緩めて（不要と思われる条件部分を除去して）から追加してください．</p>

<table border="1" summary="fig">
<tr><td>
■図３１　厳密すぎるアクセス許可
<pre>
allow_execute /usr/bin/id if task.pid=4641 task.ppid=4637 task.uid=48 task.gid=48 task.euid=48 task.egid=48 task.suid=48 task.sgid=48 task.fsuid=48 task.fsgid=48 task.state[0]=0 task.state[1]=0 task.state[2]=0 task.type!=execute_handler path1.uid=0 path1.gid=0 path1.ino=603159 path1.major=8 path1.minor=1 path1.perm=0755 path1.type=file path1.parent.uid=0 path1.parent.gid=0 path1.parent.ino=589834 path1.parent.perm=0755 exec.realpath="/usr/bin/id" exec.argc=1 exec.envc=7 exec.argv[0]="id" exec.envp["TERM"]="linux" exec.envp["PATH"]="/sbin:/usr/sbin:/bin:/usr/bin" exec.envp["PWD"]="/usr/share/horde/admin" exec.envp["LANG"]="en_US.UTF-8" exec.envp["SHLVL"]="3" exec.envp["LANGUAGE"]="en_US.UTF-8" exec.envp["_"]="/usr/bin/id"
</pre>
</td></tr>
</table>

<h2>次回予告</h2>

<p>今回は条件付きアクセス許可について紹介しました．次回は， TOMOYO Linux の特徴である階層化されたドメイン遷移を利用して，近年急増しているＳＳＨブルートフォース攻撃への対策と管理者権限の分割方法について紹介します．どうぞお楽しみに．</p>

<p><a href="tutorial-4.html.ja">第４回へ戻る</a>　<a href="tutorial-6.html.ja">第６回へ進む</a></p>

<hr>

<p><a href="index.html.ja#tutorial">目次へ戻る</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="sflogo.php" title="SourceForge.jp"></a></p>
</body>
</html>
