<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="ja-JP">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>TOMOYO Linuxの世界　第４回：「いろんな機能を試してみよう（前編）」</title>
<link rel="stylesheet" href="http://tomoyo.sourceforge.jp/tomoyo.css" media="all" type="text/css">
</head>
<body>
<!--
<p style="text-align:right;"><a href="tutorial-4.html.en">English Page</a></p>
<p style="text-align:right;">Last modified: $Date$</p>
-->
<h1>TOMOYO Linuxの世界<br>第４回：「いろんな機能を試してみよう（前編）」</h1>

<p>TOMOYO Linuxでは，ファイルに対して以外にもさまざまなアクセス制御を行うことができます．今回は，ネットワーク，ケイパビリティ，シグナルに対するアクセス制御について解説します．</p>

<h2>今回の内容</h2>

<p>これまでの連載では，ファイルに対するアクセス制御機能について紹介してきました．ファイルに対するアクセス制御機能は，プログラムやデータへの不要なアクセスを排除する，セキュアOSを用いたセキュリティ強化の基本となります．しかし，この機能だけでは十分とは言えません．今回は，TOMOYO Linuxが備える他のアクセス制御機能の中からネットワークに対するアクセス制御機能をはじめ主要なものを紹介します．</p>

<h2>ネットワークに対するアクセス制御機能について</h2>

<p>Linuxではデフォルトでiptablesというパケットフィルタリングを行うための機能が利用できます．TOMOYO Linuxでも同様の機能を提供しますが，TOMOYO Linuxのネットワークに対するアクセス制御機能はドメイン単位やユーザID単位でパケットフィルタリングを行うことができ，設定も容易です．iptablesの設定は構文が難しくてわからないという人でも使えます（ただし，iptablesと連携しているわけではないので，iptablesでしか利用できない機能もあります．）．</p>

<h2>制御可能な範囲</h2>

<p>TOMOYO Linuxにおけるネットワーク制御の対象について図1に示します．</p>

<table border="1" summary="fig">
<tr><td>
■図1 ネットワーク制御の対象
<pre>
TCPプロトコル／UDPプロトコル／IPプロトコル
IPv4ネットワークアドレス／IPv6ネットワークアドレス
ポート番号
</pre>
</td></tr>
</table>

<p>TOMOYO Linuxのネットワークアクセス制御機能を用いると，たとえば「sshdからログインしたuidが500のユーザが実行したsvnプロセスのみが，ホスト202.221.179.21のポート80に対してTCPプロトコルを用いた通信を行うことができる」といった制御が可能となります．次節以降，実際に設定してみることにしましょう．</p>

<h2>準備</h2>

<p>ネットワークに対するアクセス制御はファイルに対するアクセス制御と同様にドメイン毎に指定ができます．ここでは，「ネットワークアクセス制御のみの学習」「ネットワークアクセス制御のみの確認」「ネットワークアクセス制御のみの強制」の3種類のプロファイルを作ります．</p>

<h3>(1)プロファイルの定義</h3>

<p>準備としてプロファイル5～7を作成することにします．/etc/ccs/profile.confの末尾に図2の内容を追加してください．</p>

<table border="1" summary="fig">
<tr><td>
■図2 /etc/ccs/profile.confの末尾に追加する内容
<pre>
5-COMMENT=Learning Mode (Network Only)
5-CONFIG::network={ mode=learning }
6-COMMENT=Permissive Mode (Network Only)
6-CONFIG::network={ mode=permissive }
7-COMMENT=Enforcing Mode (Network Only)
7-CONFIG::network={ mode=enforcing }
</pre>
</td></tr>
</table>

<p>保存したら，図3のコマンドを実行して変更を反映してください．</p>

<table border="1" summary="fig">
<tr><td>
■図3 変更を反映する
<pre>
# /usr/sbin/ccs-loadpolicy p
</pre>
</td></tr>
</table>

<h3>(2)学習させるドメインの決定</h3>

<p>学習させるドメインの範囲は任意ですが，今回は操作中のシェルが属しているドメイン以下を対象としましょう．現在のプロセスが属しているドメイン名は，/proc/ccs/self_domainの内容をcatするとわかります．もし，現在実行中のシェルがkeep_domainによりドメイン遷移を行わないように指定されていた場合は，ポリシーエディタを用いて一時的にkeep_domainの指定を削除してください（ポリシーエディタで表示する際に見やすくするためであり，実環境で利用する場合にはkeep_domainの指定を削除する必要はありません．）．なお，学習されるIPアドレスやポート番号は環境により異なりますのでご了承ください．</p>

<h2>学習させてみよう</h2>

<h3>(1)クライアント側の学習</h3>

<p>図4の内容を実行し，現在のプロセスの属しているドメイン以下を学習モードにします（リダイレクトの部分は，実際のドメイン名を文字列として引用しても結構です）．</p>
<table border="1" summary="fig">
<tr><td>
■図4 現在のプロセスが属しているドメイン以下を学習モードにする
<pre>
# xargs -0 /usr/sbin/ccs-setprofile -r 5 &lt; /proc/ccs/self_domain
</pre>
</td></tr>
</table>

<p>学習させるためのコマンドとして，ここではcurlコマンドを用いてhttp://www.sourceforge.jp/にアクセスしてみます（図5）．</p>

<table border="1" summary="fig">
<tr><td>
■図5 curlコマンドを学習させる
<pre>
# curl http://www.sourceforge.jp/ &gt; /dev/null
</pre>
</td></tr>
</table>

<p>なお，curlコマンドが使えない場合は，wgetやtelnetなどでもかまいません．ポリシーエディタを起動して，curlコマンドを実行したドメインのアクセス許可を表示してみましょう（図6）．</p>

<table border="1" summary="fig">
<tr><td>
■図6 curlコマンドを実行したドメインのアクセス許可<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig04.jpg" alt="sd200704-fig04.jpg">
</td></tr>
</table>

<p>allow_networkで始まる行が，ネットワークに対するアクセス制御のためのアクセス許可です．「allow_network UDP connect 192.168.10.1 53」という部分は，UDPプロトコルを用いてDNSサーバ192.168.10.1のポート53にアクセスすることを許可するという意味です．また，「allow_network TCPconnect 202.221.179.21 80」という部分は，TCPプロトコルを用いてHTTPサーバ202.221.179.21（本稿執筆時点のwww.sourceforge.jpのIP アドレスです）のポート80にアクセスすることを許可するという意味です．</p>

<h3>(2)サーバ側の学習</h3>

<p>今度は，sshコマンドを用いてSSHサービスにログインしてみます（SSHサービスを稼動させていない場合には，HTTPなどの他のサービスでもかまいません）．例外ポリシーで「initialize_domain /usr/sbin/sshd」という指定がされている場合（連載第1回で実行したinit_policy.shによりそのように指定されているはずです），/usr/sbin/sshdは「&lt;kernel&gt; /usr/sbin/sshd」というドメインで動作することになるので，そのドメインに学習用のプロファイルを割り当ててみます（図7）．</p>

<table border="1" summary="fig">
<tr><td>
■図7 &lt;kernel&gt; /usr/sbin/sshdドメインに学習用プロファイルを割り当てる
<pre>
# /usr/sbin/ccs-setprofile 5 '&lt;kernel&gt; /usr/sbin/sshd'
</pre>
</td></tr>
</table>

<p>その後，sshでlocalhostにログインし（図8），ポリシーエディタを実行して&lt;kernel&gt; /usr/sbin/sshdドメインに対するアクセス許可を確認してください（図9）．</p>

<table border="1" summary="fig">
<tr><td>
■図8 sshでlocalhostにログイン
<pre>
# ssh localhost
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図9 &lt;kernel&gt; /usr/sbin/sshdドメインに対するアクセス許可<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig07.jpg" alt="sd200704-fig07.jpg">
</td></tr>
</table>

<p>図9では「allow_network TCP accept 127.0.0.1 51051」としてアクセス許可が与えられていますが，もしIPv6が有効になっている場合はv6のアドレスになりますので注意してください．ファイルに対するアクセス許可と同様に，ネットワークに対するアクセス許可にも条件を付与することができます．たとえば，図10のようにプロセスのユーザIDと組み合わせることで，ユーザごとに接続可能なサーバを制限したりすることもできます．</p>
<table border="1" summary="fig">
<tr><td>
■図10 ユーザごとに接続可能なサーバを制限
<pre>
allow_network TCP connect 202.221.179.21 80 if task.uid=500
allow_network TCP connect 66.35.250.203 80 if task.uid=501
</pre>
</td></tr>
</table>

<p>IPソケットの場合には，ポート番号の代わりにプロトコル番号を指定します．pingコマンドを例に説明します．図11の内容を実行してから，ポリシーエディタでpingコマンドの動作するドメインに対するアクセス許可を確認してください（図12）．</p>

<table border="1" summary="fig">
<tr><td>
■図11 pingコマンドを実行
<pre>
# ping -c 4 www.sourceforge.jp
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図12 pingコマンドの動作するドメインに対するアクセス許可<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig09.jpg" alt="sd200704-fig09.jpg">
</td></tr>
</table>

<p>「allow_network RAW connect 202.221.179.21 1」というアクセス許可が与えられていることを確認できます．これは，pingコマンドが動作しているドメインではIPソケット上でプロトコル番号1のプロトコル（ICMP）を用いて202.221.179.21と通信を行うことを許可するという意味です．</p>

<h2>チューニングしてみよう</h2>

<p>ひととおり学習してみたら，確認モードに切り替えて確認してみましょう．確認モードにするにはプロファイル6を割り当てます（図13）．</p>

<table border="1" summary="fig">
<tr><td>
■図13 プロファイル6を割り当て，確認モードに切り替え
<pre>
# xargs -0 /usr/sbin/ccs-setprofile -r 6 &lt; /proc/ccs/self_domain
</pre>
</td></tr>
</table>

<h3>(1)アドレスのパターン化</h3>

<p>ファイルに対するアクセス制御を行う際にワイルドカードを用いてパターン化したように，ネットワークに対するアクセス制御を行う際にもパターン化が必要になります．パターン化を行う場合は，開始アドレスと終了アドレスを-を用いて図14のように指定してください．-の前後に空白を入れてはいけません．</p>

<table border="1" summary="fig">
<tr><td>
■図14 IPv4アドレスを範囲で指定する
<pre>
xxx.xxx.xxx.xxx-yyy.yyy.yyy.yyy
</pre>
</td></tr>
</table>

<p>IPv6アドレスによる指定もIPv4アドレスの場合と同様ですが，"::"という省略表記や"."混じりの表記はサポートしていません．つねに図15のような形式で指定する必要があります．その他，負荷分散のため複数のIPアドレスを持つサーバに対するアクセス許可を与える場合は，使う可能性のあるすべてのIPアドレスを指定することを忘れないでください．</p>

<table border="1" summary="fig">
<tr><td>
■図15 IPv6アドレスを指定する
<pre>
xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx
</pre>
</td></tr>
</table>

<h3>(2)ポート番号のパターン化</h3>

<p>サーバがクライアントからのリクエストを受け付けるためのポート番号は一般に固定されているのに対し，クライアントがリクエストを送り出すときに使用するポート番号は固定されていません．そのため，サーバ側でクライアントが使用する可能性のあるポート番号を範囲としてパターン化してやる必要があります．パターン化を行う場合は，開始ポートと終了ポートを-を用いて図16のように指定してください．-の前後に空白を入れてはいけません．よくあるパターンは図17の3つです．</p>

<table border="1" summary="fig">
<tr><td>
■図16 ポート番号を範囲で指定する
<pre>
xxxxx-yyyyy
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図17 ポート番号パターン化の例
<pre>
1024-65535
32768-61000
600-1023
</pre>
</td></tr>
</table>

<p>最初のパターンは通常のクライアントがサーバに接続する際に選択する可能性がある範囲で，おもにサーバ側のプログラムで必要になります．2番目のパターンは「/proc/sys/net/ipv4/ip_local_port_range」に指定されているポート番号の範囲です．通常のクライアントはこの範囲から未使用のローカルポート番号を選択してサーバに接続するため，おもにクライアント側のプログラムで必要になります．実際の/proc /sys/net/ipv4/ip_local_port_rangeの内容に合わせてパターンを定義してください．</p>

<p>最後のパターンは，portmapコマンドのように未使用の特権ポート（ポート番号が1024未満のポート）を選択して接続するプログラムで必要になります．実際に必要な範囲は異なる場合があります．パターン化が必要か否かを判断する簡単な方法は，プログラムを何度か実行してみることです．たとえば，学習モードで何度か実行すると，図18のように，ポート番号が連続するアクセス許可が増えていきますので，その傾向から必要な範囲を推測してください．</p>

<table border="1" summary="fig">
<tr><td>
■図18 ポート番号が連続するアクセス許可の例①
<pre>
allow_network TCP bind 127.0.0.1 610
allow_network TCP bind 127.0.0.1 611
allow_network TCP bind 127.0.0.1 612
allow_network TCP bind 127.0.0.1 613
</pre>
</td></tr>
</table>

<p>図18の例の場合，図19のような許可が必要である可能性が高いと言えます．</p>

<table border="1" summary="fig">
<tr><td>
■図19 図19を元にパターン化したアクセス許可
<pre>
allow_network TCP bind 127.0.0.1 600-1023
</pre>
</td></tr>
</table>

<p>また，図20であれば，図21または図22という許可が必要である可能性が高いでしょう．</p>

<table border="1" summary="fig">
<tr><td>
■図20 ポート番号が連続するアクセス許可の例②
<pre>
allow_network TCP accept 127.0.0.1 32780
allow_network TCP accept 127.0.0.1 32781
allow_network TCP accept 127.0.0.1 32782
allow_network TCP accept 127.0.0.1 32783
allow_network TCP accept 127.0.0.1 32784
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図21 図20を元にパターン化したアクセス許可
<pre>
allow_network TCP accept 127.0.0.1 1024-65535
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図22 図20を元にパターン化したアクセス許可
<pre>
allow_network TCP accept 127.0.0.1 32768-61000
</pre>
</td></tr>
</table>

<h2>強制してみよう</h2>

<p>確認が終わったら，実際にネットワークのアクセス制御を適用しましょう．強制モードにするにはプロファイル7を割り当てます（図23）．</p>

<table border="1" summary="fig">
<tr><td>
■図23 プロファイル7を割り当て，強制モードを適用
<pre>
xargs -0 /usr/sbin/ccs-setprofile -r 7 &lt; /proc/ccs/self_domain
</pre>
</td></tr>
</table>

<p>なお，プロファイル5～7はファイルに関するアクセス制御を行っていないことに注意してください．前回の本連載で紹介した，対話的にアクセス許可を追加するccs-querydを用いることで，その場で不足しているアクセス許可を追加することもできます．TOMOYO Linuxを使うと，iptables単体で行えるネットワークアクセス制御の内容を細分，詳細化できることがご理解いただけると思います．</p>

<h2>ケイパビリティに対するアクセス制御機能について</h2>

<p>Linuxカーネル2.2以降ではPOSIXケイパビリティに対応しています．ケイパビリティは，セキュアOSの基本概念である最少権限を形にしたもので，プロセス単位で各種特権の利用について制限を加えるために用いられます．Linuxで対応済みのケイパビリティについては，/usr /include/linux/capability.hの中で参照することができます．しかし，CAP_SYS_ADMIN権限がさまざまな目的に用いられているので，そのままでは本来の効果が期待できません．そこでTOMOYOLinuxでは独自にケイパビリティを定義，制御しています（以下「ケイパビリティ」はTOMOYO Linuxにおけるケイパビリティを指します）．</p>

<p>TOMOYO LinuxではPOSIXとは異なる独自のケイパビリティを使用していますが，プログラムからはその存在は見えないので，プログラムに変更を加える必要はありません．バージョン1.7.2では図24の操作の可否を制限することができます．</p>

<table border="1" summary="fig">
<tr><td>
■図24 TOMOYO Linux 1.7.2のケイパビリティ<br>
<table border="1" summary="fig">
<tr><td>値</td><td>内容</td></tr>
<tr><td>inet_tcp_create</td><td>TCPソケットの使用を許可</td></tr>
<tr><td>inet_tcp_listen</td><td>TCPソケットのlistenを許可</td></tr>
<tr><td>inet_tcp_connect</td><td>TCPソケットのconnectを許可</td></tr>
<tr><td>use_inet_udp</td><td>UDPソケットの使用を許可</td></tr>
<tr><td>use_inet_ip</td><td>RAWソケットの使用を許可</td></tr>
<tr><td>use_route</td><td>ROUTEソケットの使用を許可</td></tr>
<tr><td>use_packet</td><td>PACKETソケットの使用を許可</td></tr>
<tr><td>use_kernel_module</td><td>create_module(2),init_module(2),delete_module(2)の使用を許可</td></tr>
<tr><td>create_fifo</td><td>mknod(2)でFIFOの作成を許可</td></tr>
<tr><td>create_block_dev</td><td>mknod(2)でブロック型デバイスの作成を許可</td></tr>
<tr><td>create_char_dev</td><td>mknod(2)でキャラクタ型デバイスの作成を許可</td></tr>
<tr><td>create_unix_socket</td><td>mknod(2)でUNIXドメインソケットの作成を許可</td></tr>
<tr><td>SYS_MOUNT</td><td>mount(2)の使用を許可</td></tr>
<tr><td>SYS_UMOUNT</td><td>umount(2)の使用を許可</td></tr>
<tr><td>SYS_REBOOT</td><td>reboot(2)の使用を許可</td></tr>
<tr><td>SYS_CHROOT</td><td>chroot(2)の使用を許可</td></tr>
<tr><td>SYS_KILL</td><td>0以外のシグナルでkill(2),tkill(2),tgkill(2)の使用を許可</td></tr>
<tr><td>SYS_VHANGUP</td><td>vhangup(2)の使用を許可</td></tr>
<tr><td>SYS_TIME</td><td>stime(2),settimeofday(2),adjtimex(2)の使用を許可</td></tr>
<tr><td>SYS_NICE</td><td>nice(2),setpriority(2)の使用を許可</td></tr>
<tr><td>SYS_SETHOSTNAME</td><td>sethostname(2),setdomainname(2)の使用を許可</td></tr>
<tr><td>SYS_LINK</td><td>link(2)の使用を許可</td></tr>
<tr><td>SYS_SYMLINK</td><td>symlink(2)の使用を許可</td></tr>
<tr><td>SYS_RENAME</td><td>rename(2)の使用を許可</td></tr>
<tr><td>SYS_UNLINK</td><td>unlink(2)の使用を許可</td></tr>
<tr><td>SYS_CHMOD</td><td>chmod(2),fchmod(2)の使用を許可</td></tr>
<tr><td>SYS_CHOWN</td><td>chown(2),fchown(2),lchown(2)の使用を許可</td></tr>
<tr><td>SYS_IOCTL</td><td>ioctl(2),compat_sys_ioctl(2)の使用を許可</td></tr>
<tr><td>SYS_KEXEC_LOAD</td><td>kexec_load(2)の使用を許可</td></tr>
<tr><td>SYS_PIVOT_ROOT</td><td>pivot_root(2)の使用を許可</td></tr>
<tr><td>SYS_PTRACE</td><td>ptrace(2)の使用を許可</td></tr>
<tr><td>conceal_mount</td><td>既存のマウントを隠ぺいするようなマウントを許可</td></tr>
</table>
</td></tr>
</table>

<p>ここではマウント操作を行う権限（SYS_MOUNT）を例に説明します．TOMOYO Linuxはパス名を用いてアクセス制御を行うため，管理者が期待したとおりにファイルシステムがマウントされていることは絶対の前提となります．root権限で動作しているすべてのプロセスが好き勝手にマウントをしてしまうようでは困ります．そのため，ケイパビリティを用いることでマウント操作を許可するドメインを制限します．ケイパビリティのアクセス制御の手順はネットワークに関するアクセス制御のときと同様です．まず，制限したいケイパビリティをプロファイルで指定します．/etc/ccs/profile.confの末尾に図25の内容を追加してください．</p>

<table border="1" summary="fig">
<tr><td>
■図25 /etc/ccs/profile.confの末尾に追加する内容（ケイパビリティに対するアクセス制御）
<pre>
9-CONFIG::capability::SYS_MOUNT={ mode=learning }
10-CONFIG::capability::SYS_MOUNT={ mode=enforcing }
</pre>
</td></tr>
</table>

<p>ファイルやネットワークとは異なり，ケイパビリティの場合は操作対象を指定する必要がありません．学習モードで学習させるだけで強制モードで必要なすべてのケイパビリティが与えられるので，図25のプロファイルでは確認モードを省略しています．保存したら，図3のコマンドを実行して変更を反映してください．</p>

<p>説明のために，先に強制モード用のプロファイル（10）を使用します（図26）．</p>

<table border="1" summary="fig">
<tr><td>
■図26 強制モード用プロファイルを使用
<pre>
# xargs -0 /usr/sbin/ccs-setprofile -r 10 &lt; /proc/ccs/self_domain
</pre>
</td></tr>
</table>

<p>その後，適当なディレクトリにtmpfsをマウントします（図27）．</p>

<table border="1" summary="fig">
<tr><td>
■図27 tmpfsをマウントする
<pre>
# mount -t tmpfs none /tmp/
mount: permission denied
</pre>
</td></tr>
</table>

<p>拒否されました．これは，mountコマンドを実行したドメインに対して，マウント操作を行う権限が与えられていないためです．次に，学習モード用のプロファイル（9）を割り当てます（図28）．</p>

<table border="1" summary="fig">
<tr><td>
■図28 学習モード用プロファイルを使用
<pre>
# xargs -0 /usr/sbin/ccs-setprofile -r 9 &lt; /proc/ccs/self_domain
</pre>
</td></tr>
</table>

<p>再度，適当なディレクトリにtmpfsをマウントします（図29）．</p>

<table border="1" summary="fig">
<tr><td>
■図29 tmpfsをマウントする
<pre>
# mount -t tmpfs none /tmp/
</pre>
</td></tr>
</table>

<p>今度は正常に動作しました．ポリシーエディタを起動してmountコマンドを実行したドメインを探し，アクセス許可を確認してください（図30）．</p>

<table border="1" summary="fig">
<tr><td>
■図30 allow_capability SYS_MOUNTというアクセス許可が学習されている<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig18.jpg" alt="sd200704-fig18.jpg">
</td></tr>
</table>

<p>allow_capability SYS_MOUNTというアクセス許可が学習されていることを確認できます．この状態で強制モード用のプロファイル（10）を割り当てれば，許可されていないドメインからマウント操作を行うことを禁止できるようになります．</p>

<p>マウント操作の可否だけを制限しても，マウント操作が許可されていれば任意のディレクトリにマウントできてしまうので，不十分だと思われる方がいるかもしれません．実際そのとおりであり，TOMOYO Linuxではマウントを許可するパーティションとマウントポイントの組み合わせを制限する機能も備えています．それについては次回紹介する予定です．</p>

<h2>シグナルに対するアクセス制御機能について</h2>

<p>TOMOYO Linuxでは，シグナルの種類と送信先を制限することができます．手順はネットワークに関するアクセス制御のときと同様です．/etc/ccs /profile.conf末尾に図31の内容を追加してください．</p>

<table border="1" summary="fig">
<tr><td>
■図31 /etc/ccs/profile.confの末尾に追加する内容（シグナルに対するアクセス制御）
<pre>
11-CONFIG::ipc::signal={ mode=learning }
12-CONFIG::ipc::signal={ mode=enforcing }
</pre>
</td></tr>
</table>

<p>保存したら，図3のコマンドを実行して変更を反映してください．</p>

<p>以降の操作は，「&lt;kernel&gt; /usr/sbin/sshd /bin/bash」ドメインに属しているシェル（つまりsshdからログインしたときのログインシェル）から行うものとします．事前に「keep_domain &lt;kernel&gt; /usr/sbin/sshd /bin/bash」という指定がされていないことを確認しておいてください．最初に，sleepコマンドを実行してください（図32）．</p>

<table border="1" summary="fig">
<tr><td>
■図32 sleepコマンドを実行
<pre>
# sleep 100
</pre>
</td></tr>
</table>

<p>この状態で，別の画面を開いてログインしてください．説明のために，先に強制モード用のプロファイル（14）を割り当てます（図33）．</p>

<table border="1" summary="fig">
<tr><td>
■図33 強制モード用プロファイルを使用
<pre>
# xargs -0 /usr/sbin/ccs-setprofile -r 14 &lt; /proc/ccs/self_domain
</pre>
</td></tr>
</table>

<p>次に，動作中のsleepコマンドのプロセスIDを取得し，そのプロセスIDに対してシグナルを送信します（図34）（シェルのビルトインではなく，/bin/killが実行されるよう明示的に指定しています．）．</p>

<table border="1" summary="fig">
<tr><td>
■図34 sleepコマンドのプロセスIDに対してシグナル送信
<pre>
# pidof sleep
4649
# /bin/kill -15 4649
kill 4649: Operation not permitted
</pre>
</td></tr>
</table>

<p>拒否されました．これは，killコマンドが動作するドメインに対して，sleepコマンドが動作するドメインへシグナルを送信する権限が与えられていないためです．次に，学習モード用のプロファイル（13）を割り当て（図35），再度シグナルを送信します（図36）．</p>

<table border="1" summary="fig">
<tr><td>
■図35 学習モード用プロファイルを使用
<pre>
# xargs -0 /usr/sbin/ccs-setprofile -r 13 &lt; /proc/ccs/self_domain
</pre>
</td></tr>
</table>

<table border="1" summary="fig">
<tr><td>
■図36 再度sleepコマンドのプロセスIDに対してシグナル送信
<pre>
# /bin/kill -15 4649
</pre>
</td></tr>
</table>

<p>今度は正常に動作しました．ポリシーエディタを起動してkillコマンドを実行したドメインを探し，アクセス許可を確認してください（図37）．</p>

<table border="1" summary="fig">
<tr><td>
■図37 killコマンドを実行したドメインのアクセス許可<br>
<img src="http://tomoyo.sourceforge.jp/wiki/?plugin=ref&amp;page=WorldOfTomoyoLinux-4&amp;src=sd200704-fig25.jpg" alt="sd200704-fig25.jpg">
</td></tr>
</table>

<p>「allow_signal 15 &lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/sleep」というアクセス許可が学習されていることを確認できます．これは，「&lt;kernel&gt; /usr/sbin/sshd /bin/bash /bin/sleep」という名前で始まるドメインに属しているプロセスに対して15番のシグナル（SIGTERM）を送信することを許可するという意味です．TOMOYO Linuxにおけるドメイン名は&lt;kernel&gt;で始まる階層構造であるため，allow_signal 15 &lt;kernel&gt;のように指定した場合，すべてのプロセスに対して15番のシグナルを送信することが許可されることに注意してください．例外として，シグナルの送信元が送信先と同じドメインの場合はつねに許可されます．また，0番のシグナルもつねに許可されます．</p>

<h2>次回予告</h2>

<p>今回はTOMOYO Linuxのネットワークのアクセス制御機能を中心に紹介しました．通信を行うドメインを限定したうえで，強力かつ柔軟なアクセス制御を行えることがご理解いただけたと思います．次回は，パス名に基づくアクセス制御を行う際の注意点についての紹介を行います．どうぞお楽しみに．</p>

<hr>

<p><a href="index.html.ja">目次へ戻る</a></p>
<p><a href="http://sourceforge.jp/"><img src="http://sourceforge.jp/sflogo.php?group_id=1973" width="96" height="31" alt="SourceForge.jp"></a></p>
</body>
</html>
